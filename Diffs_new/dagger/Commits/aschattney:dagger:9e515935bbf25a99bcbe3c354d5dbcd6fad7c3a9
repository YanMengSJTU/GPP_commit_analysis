diff --git a/android-support/pom.xml b/android-support/pom.xml
index d6d6badf8..78b2bb0bb 100644
--- a/android-support/pom.xml
+++ b/android-support/pom.xml
@@ -10,9 +10,7 @@
     <modelVersion>4.0.0</modelVersion>
 
     <artifactId>dagger-android-support</artifactId>
-
     <name>Dagger for Android Support</name>
-
     <packaging>aar</packaging>
 
     <repositories>
@@ -43,7 +41,7 @@
             <groupId>com.google.dagger</groupId>
             <artifactId>dagger-android</artifactId>
             <version>3.0</version>
-            <type>aar</type>
+            <scope>provided</scope>
         </dependency>
     </dependencies>
 
diff --git a/android-testcase/pom.xml b/android-testcase/pom.xml
new file mode 100644
index 000000000..05f9937d3
--- /dev/null
+++ b/android-testcase/pom.xml
@@ -0,0 +1,88 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <artifactId>dagger-parent</artifactId>
+        <groupId>com.google.dagger</groupId>
+        <version>3.0</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <repositories>
+        <repository>
+            <id>android-support</id>
+            <url>file://${env.ANDROID_HOME}/extras/android/m2repository</url>
+        </repository>
+    </repositories>
+
+    <artifactId>dagger-android-testcase</artifactId>
+
+    <packaging>aar</packaging>
+
+    <properties>
+        <java.version>1.6</java.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.google.android</groupId>
+            <artifactId>android</artifactId>
+            <version>4.2.2_r3</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.android.support.test</groupId>
+            <artifactId>runner</artifactId>
+            <version>0.5</version>
+            <type>aar</type>
+            <scope>compile</scope>
+            <exclusions>
+                <exclusion>
+                    <groupId>com.android.support</groupId>
+                    <artifactId>support-annotations</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
+        <dependency>
+            <groupId>com.android.support.test</groupId>
+            <artifactId>rules</artifactId>
+            <version>0.5</version>
+            <type>aar</type>
+            <scope>compile</scope>
+            <exclusions>
+                <exclusion>
+                    <groupId>com.android.support</groupId>
+                    <artifactId>support-annotations</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.android.support</groupId>
+            <artifactId>support-annotations</artifactId>
+            <version>24.2.0</version>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>com.simpligility.maven.plugins</groupId>
+                <artifactId>android-maven-plugin</artifactId>
+                <extensions>true</extensions>
+                <configuration>
+                    <sdk>
+                        <platform>${android.latest.version}</platform>
+                        <path>${env.ANDROID_HOME}</path>
+                    </sdk>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>
\ No newline at end of file
diff --git a/android-testcase/src/main/AndroidManifest.xml b/android-testcase/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..e4a1542c7
--- /dev/null
+++ b/android-testcase/src/main/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<!--
+  ~ Copyright (C) 2017 The Dagger Authors.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="dagger.android.testcase">
+  <uses-sdk android:minSdkVersion="14" />
+</manifest>
diff --git a/android-testcase/src/main/java/dagger/android/testcase/DaggerActivityTestRule.java b/android-testcase/src/main/java/dagger/android/testcase/DaggerActivityTestRule.java
new file mode 100644
index 000000000..a2407350e
--- /dev/null
+++ b/android-testcase/src/main/java/dagger/android/testcase/DaggerActivityTestRule.java
@@ -0,0 +1,288 @@
+package dagger.android.testcase;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Instrumentation;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.rule.UiThreadTestRule;
+import android.util.Log;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import java.lang.reflect.Field;
+
+public class DaggerActivityTestRule<T extends Activity> extends UiThreadTestRule
+{
+
+    private static final String TAG = "ActivityTestRule";
+
+    private final Class<T> mActivityClass;
+    private Instrumentation mInstrumentation;
+    private boolean mInitialTouchMode = false;
+    private boolean mLaunchActivity = false;
+    private T mActivity;
+
+    /**
+     * Similar to {@link DaggerActivityTestRule  (Class, boolean, boolean)} but with "touch mode" disabled.
+     *
+     * @param activityClass The activity under test. This must be a class in the instrumentation
+     *                      targetPackage specified in the AndroidManifest.xml
+     * @see android.support.test.rule.ActivityTestRule#ActivityTestRule(Class, boolean, boolean)
+     */
+    public DaggerActivityTestRule(Class<T> activityClass)
+    {
+        mActivityClass = activityClass;
+        mInitialTouchMode = true;
+        mLaunchActivity = false;
+        mInstrumentation = InstrumentationRegistry.getInstrumentation();
+    }
+
+    /**
+     * Override this method to set up Intent as if supplied to
+     * {@link android.content.Context#startActivity}.
+     * <p>
+     * The default Intent (if this method returns null or is not overwritten) is:
+     * action = {@link Intent#ACTION_MAIN}
+     * flags = {@link Intent#FLAG_ACTIVITY_NEW_TASK}
+     * All other intent fields are null or empty.
+     *
+     * @return The Intent as if supplied to {@link android.content.Context#startActivity}.
+     */
+    protected Intent getActivityIntent()
+    {
+        return new Intent(Intent.ACTION_MAIN);
+    }
+
+    /**
+     * Override this method to execute any code that should run before your {@link Activity} is
+     * created and launched.
+     * This method is called before each test method, including any method annotated with
+     * <a href="http://junit.sourceforge.net/javadoc/org/junit/Before.html"><code>Before</code></a>.
+     */
+    protected void beforeActivityLaunched()
+    {
+        // empty by default
+        try
+        {
+            apply(new Statement()
+            {
+                @Override
+                public void evaluate() throws Throwable
+                {
+                    Application application = getApplication();
+                    application.onCreate();
+                }
+            }, Description.EMPTY).evaluate();
+        } catch (Throwable throwable)
+        {
+            throwable.printStackTrace();
+        }
+    }
+
+    private Application getApplication()
+    {
+        DaggerRunner abstractRunner = (DaggerRunner) InstrumentationRegistry.getInstrumentation();
+        return abstractRunner.getApplication();
+    }
+
+    /**
+     * Override this method to execute any code that should run after your {@link Activity} is
+     * launched, but before any test code is run including any method annotated with
+     * <a href="http://junit.sourceforge.net/javadoc/org/junit/Before.html"><code>Before</code></a>.
+     * <p>
+     * Prefer
+     * <a href="http://junit.sourceforge.net/javadoc/org/junit/Before.html"><code>Before</code></a>
+     * over this method. This method should usually not be overwritten directly in tests and only be
+     * used by subclasses of com.mvp.CustomActivityTestRule  to get notified when the activity is created and
+     * visible but test runs.
+     */
+    protected void afterActivityLaunched()
+    {
+        // empty by default
+    }
+
+    /**
+     * Override this method to execute any code that should run after your {@link Activity} is
+     * finished.
+     * This method is called after each test method, including any method annotated with
+     * <a href="http://junit.sourceforge.net/javadoc/org/junit/After.html"><code>After</code></a>.
+     */
+    protected void afterActivityFinished()
+    {
+        // empty by default
+        try
+        {
+            Application app = getApplication();
+            resetFields(app, app.getClass());
+        } catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+    }
+
+    public void resetDecorations() {
+        try
+        {
+            resetFields(getApplication(), getApplication().getClass());
+        } catch (Exception e)
+        {
+            e.printStackTrace();
+        }
+    }
+
+    private void resetFields(Application app, Class<?> clazz) throws Exception{
+        Field[] declaredFields = clazz.getDeclaredFields();
+        for (Field f : declaredFields){
+            try {
+                String name = f.getName().toLowerCase();
+                if (!name.contains("decorator") && !f.getType().isPrimitive())
+                {
+                    f.setAccessible(true);
+                    f.set(app, null);
+                }else if (name.contains("decorator")) {
+                    Object newDecoratorInstance = f.getType().getConstructors()[0].newInstance(app);
+                    f.setAccessible(true);
+                    f.set(app, newDecoratorInstance);
+                }
+            }catch(Exception e) {
+                e.printStackTrace();
+            }
+        }
+        Class<?> superclass = clazz.getSuperclass();
+        if (superclass != null && !superclass.equals(Application.class)){
+            resetFields(app, superclass);
+        }
+    }
+
+    /**
+     * @return The activity under test.
+     */
+    public T getActivity()
+    {
+        if (mActivity == null)
+        {
+            Log.w(TAG, "Activity wasn't created yet");
+        }
+        return mActivity;
+    }
+
+    @Override
+    public Statement apply(final Statement base, Description description)
+    {
+        return new ActivityStatement(super.apply(base, description));
+    }
+
+    /**
+     * Launches the Activity under test.
+     * <p>
+     * Don't call this method directly, unless you explicitly requested not to lazily launch the
+     * Activity manually using the launchActivity flag in
+     * {@link android.support.test.rule.ActivityTestRule#ActivityTestRule(Class, boolean, boolean)}.
+     * <p>
+     * Usage:
+     * <pre>
+     *    &#064;Test
+     *    public void customIntentToStartActivity() {
+     *        Intent intent = new Intent(Intent.ACTION_PICK);
+     *        mActivity = mActivityRule.launchActivity(intent);
+     *    }
+     * </pre>
+     *
+     * @param startIntent The Intent that will be used to start the Activity under test. If
+     *                    {@code startIntent} is null, the Intent returned by
+     *                    {@link android.support.test.rule.ActivityTestRule#getActivityIntent()} is used.
+     * @return the Activity launched by this rule.
+     * @see android.support.test.rule.ActivityTestRule#getActivityIntent()
+     */
+    public T launchActivity(@Nullable Intent startIntent)
+    {
+
+        // set initial touch mode
+        mInstrumentation.setInTouchMode(mInitialTouchMode);
+
+        final String targetPackage = mInstrumentation.getTargetContext().getPackageName();
+        // inject custom intent, if provided
+        if (null == startIntent)
+        {
+            startIntent = getActivityIntent();
+            if (null == startIntent)
+            {
+                Log.w(TAG, "getActivityIntent() returned null using default: " +
+                        "Intent(Intent.ACTION_MAIN)");
+                startIntent = new Intent(Intent.ACTION_MAIN);
+            }
+        }
+        startIntent.setClassName(targetPackage, mActivityClass.getName());
+        startIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        Log.d(TAG, String.format("Launching activity %s",
+                mActivityClass.getName()));
+
+        beforeActivityLaunched();
+        // The following cast is correct because the activity we're creating is of the same type as
+        // the one passed in
+        mActivity = mActivityClass.cast(mInstrumentation.startActivitySync(startIntent));
+
+        mInstrumentation.waitForIdleSync();
+
+        if (mActivity != null)
+        {
+            // Notify that Activity was successfully launched
+            afterActivityLaunched();
+        } else
+        {
+            // Log an error message to logcat/instrumentation, that the Activity failed to launch
+            String errorMessage = String.format("Activity %s, failed to launch",
+                    mActivityClass.getName());
+            Bundle bundle = new Bundle();
+            bundle.putString(Instrumentation.REPORT_KEY_STREAMRESULT, TAG + " " + errorMessage);
+            mInstrumentation.sendStatus(0, bundle);
+            Log.e(TAG, errorMessage);
+        }
+
+        return mActivity;
+    }
+
+    void finishActivity()
+    {
+        if (mActivity != null)
+        {
+            mActivity.finish();
+            afterActivityFinished();
+            mActivity = null;
+        }
+    }
+
+    /**
+     * <a href="http://junit.org/apidocs/org/junit/runners/model/Statement.html">
+     * <code>Statement</code></a> that finishes the activity after the test was executed
+     */
+    private class ActivityStatement extends Statement
+    {
+
+        private final Statement mBase;
+
+        public ActivityStatement(Statement base)
+        {
+            mBase = base;
+        }
+
+        @Override
+        public void evaluate() throws Throwable
+        {
+            try
+            {
+                if (mLaunchActivity)
+                {
+                    mActivity = launchActivity(getActivityIntent());
+                }
+                mBase.evaluate();
+            } finally
+            {
+                finishActivity();
+            }
+        }
+    }
+
+}
diff --git a/android-testcase/src/main/java/dagger/android/testcase/DaggerRunner.java b/android-testcase/src/main/java/dagger/android/testcase/DaggerRunner.java
new file mode 100644
index 000000000..8ab165bf8
--- /dev/null
+++ b/android-testcase/src/main/java/dagger/android/testcase/DaggerRunner.java
@@ -0,0 +1,37 @@
+package dagger.android.testcase;
+
+import android.app.Activity;
+import android.app.Application;
+import android.content.Context;
+import android.os.Bundle;
+import android.support.test.runner.AndroidJUnitRunner;
+
+import java.lang.reflect.ParameterizedType;
+import java.util.ArrayList;
+import java.util.List;
+
+public abstract class DaggerRunner<T extends Application> extends AndroidJUnitRunner
+{
+
+    private T application;
+
+    @Override
+    public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException
+    {
+        application = (T) super.newApplication(cl, parseApplicationClassName(), context);
+        return application;
+    }
+
+    private String parseApplicationClassName()
+    {
+        Class<?> applicationClass = ((Class<?>)
+                ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0]);
+        return applicationClass.getName();
+    }
+
+    public T getApplication()
+    {
+        return application;
+    }
+
+}
diff --git a/android-testcase/src/main/java/dagger/android/testcase/EspressoTestCase.java b/android-testcase/src/main/java/dagger/android/testcase/EspressoTestCase.java
new file mode 100644
index 000000000..56935c9c7
--- /dev/null
+++ b/android-testcase/src/main/java/dagger/android/testcase/EspressoTestCase.java
@@ -0,0 +1,30 @@
+package dagger.android.testcase;
+
+import android.app.Application;
+import android.support.test.InstrumentationRegistry;
+import org.junit.After;
+import org.junit.Before;
+
+public abstract class EspressoTestCase<T extends Application>
+{
+
+    private T app;
+
+    public T app()
+    {
+        return app;
+    }
+
+    @Before
+    public void setUp() throws Exception {
+        final DaggerRunner abstractRunner = (DaggerRunner) InstrumentationRegistry.getInstrumentation();
+        T app = (T) abstractRunner.getApplication();
+        this.app = app;
+    }
+
+    @After
+    public void tearDown() throws Exception {
+
+    }
+
+}
diff --git a/android/pom.xml b/android/pom.xml
index 6fe096965..aea93b781 100644
--- a/android/pom.xml
+++ b/android/pom.xml
@@ -17,7 +17,7 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
-  <parent>
+    <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
     <version>3.0</version>
@@ -26,7 +26,11 @@
   <artifactId>dagger-android</artifactId>
   <name>Dagger for Android</name>
 
-  <packaging>aar</packaging>
+  <packaging>pom</packaging>
+
+  <properties>
+    <java.version>1.6</java.version>
+  </properties>
 
   <repositories>
     <repository>
@@ -35,10 +39,6 @@
     </repository>
   </repositories>
 
-  <properties>
-    <java.version>1.6</java.version>
-  </properties>
-
   <dependencies>
     <dependency>
       <groupId>com.google.dagger</groupId>
@@ -49,12 +49,12 @@
       <groupId>com.android.support</groupId>
       <artifactId>support-annotations</artifactId>
     </dependency>
-      <dependency>
-          <groupId>com.google.android</groupId>
-          <artifactId>android</artifactId>
-          <version>4.2.2_r3</version>
-          <scope>provided</scope>
-      </dependency>
+    <dependency>
+        <groupId>com.google.android</groupId>
+        <artifactId>android</artifactId>
+        <version>4.2.2_r3</version>
+        <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>com.google.code.findbugs</groupId>
       <artifactId>jsr305</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index ff548f4d0..5a25f1b73 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -1251,7 +1251,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
             /* 2 */ bindingKeyTypeName,
             /* 3 */ subcomponentName,
             /* 4 */ expression,
-            /* 5 */ Util.lowerCaseFirstLetter(subcomponentName));
+            /* 5 */ "decorate" + subcomponentName);
 
       case BUILDER_BINDING:
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
index 1f4444ec0..a170f7a79 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
@@ -49,7 +49,7 @@ ClassName nameGeneratedType(DI input) {
         builder.addSuperinterface(TYPENAME_INJECTOR_SPEC);
         final Set<TypeElement> components = di.getComponents();
 
-        builder.addField(TYPENAME_INJECTOR, FIELDNAME_INJECTOR, Modifier.PRIVATE);
+        //builder.addField(TYPENAME_INJECTOR, FIELDNAME_INJECTOR, Modifier.PRIVATE);
 
         for (TypeElement component : components) {
             final List<SpecComponentInfo> infos = ComponentInfo.forSpec(component, componentDescriptorFactory, bindingGraphFactory, di.getAppClass().asType());
@@ -79,16 +79,16 @@ ClassName nameGeneratedType(DI input) {
         final Optional<ExecutableElement> onCreateMethod = findOnCreateMethod(di.getAppClass());
         if (onCreateMethod.isPresent()) {
             final MethodSpec.Builder overriding = MethodSpec.overriding(onCreateMethod.get());
-            overriding.addStatement("this.$L = new $T(this)", FIELDNAME_INJECTOR, TYPENAME_INJECTOR);
+            //overriding.addStatement("this.$L = new $T(this)", FIELDNAME_INJECTOR, TYPENAME_INJECTOR);
             overriding.addStatement(SUPER_ON_CREATE_CALL);
             builder.addMethod(overriding.build());
         }
 
-        builder.addMethod(MethodSpec.methodBuilder(METHOD_NAME_GET_INJECTOR)
+        /*builder.addMethod(MethodSpec.methodBuilder(METHOD_NAME_GET_INJECTOR)
                 .addModifiers(Modifier.PUBLIC)
                 .returns(TYPENAME_INJECTOR)
                 .addStatement(String.format("return this.%s", FIELDNAME_INJECTOR))
-                .build());
+                .build());*/
 
         return Optional.ofNullable(builder);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 5aa1277a0..608b8e0af 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -243,12 +243,13 @@ public SourceVersion getSupportedSourceVersion() {
                 types,
                 messager,
                 new AppConfig.Factory(elements),
-                new InjectorGenerator(filer, elements, componentDescriptorFactory,
+                new InjectorGenerator(filer, elements, messager, componentDescriptorFactory,
                         bindingGraphFactory, new TestClassGenerator.Factory(filer, elements),
                         testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory, testRegistry)),
                 ComponentDescriptor.Kind.COMPONENT,
                 bindingGraphFactory,
                 componentDescriptorFactory,
+                new DecoratorGenerator(filer, elements, componentDescriptorFactory, bindingGraphFactory, testRegistry),
                 new DependencySpecGenerator(filer, elements, componentDescriptorFactory, bindingGraphFactory),
                 new DependencyInjectorGenerator(filer, elements, bindingGraphFactory, componentDescriptorFactory),
                 provisionBindingFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index cae48a5d7..09afc5021 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -214,7 +214,7 @@ public void postAddBuildMethod() {
                                     graph.componentDescriptor().builderSpec().get().builderDefinitionType())
                                     : builderName.get())
                     .addStatement("return application.$L(new $T())",
-                            Util.lowerCaseFirstLetter(graph.componentType().getSimpleName().toString()),
+                            "decorate" + graph.componentType().getSimpleName().toString(),
                             builderName.get())
                     .build();
     component.addMethod(builderFactoryMethod);
diff --git a/compiler/src/main/java/dagger/internal/codegen/DI.java b/compiler/src/main/java/dagger/internal/codegen/DI.java
index e1bf55f6e..19738931b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DI.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DI.java
@@ -14,11 +14,13 @@
     private Set<TypeElement> components;
     private List<InjectorType> injectorTypes;
     private AppConfig config;
+    private ClassName decoratorType;
 
-    public DI(AppConfig config, Set<TypeElement> components, List<InjectorType> injectorTypes) {
+    public DI(AppConfig config, Set<TypeElement> components, List<InjectorType> injectorTypes, ClassName decoratorType) {
         this.config = config;
         this.components = components;
         this.injectorTypes = injectorTypes;
+        this.decoratorType = decoratorType;
     }
 
     public ClassName getClassName() {
@@ -39,4 +41,6 @@ public TypeElement getAppClass() {
     }
 
     public TypeElement getBaseAppClass() { return config.getBaseAppClass(); }
+
+    public ClassName getDecoratorType() { return this.decoratorType; }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Decorator.java b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
index 2ebbbc925..7a4a056b3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Decorator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
@@ -3,6 +3,7 @@
 import java.util.Optional;
 
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.UnmodifiableIterator;
 import com.squareup.javapoet.*;
 
 import javax.annotation.processing.Filer;
@@ -16,7 +17,7 @@
 import java.util.HashMap;
 import java.util.List;
 
-public class Decorator  extends SourceFileGenerator<BindingGraph>{
+public class Decorator  extends SourceFileGenerator<ImmutableSet<BindingGraph>>{
 
     private BindingGraph.Factory factory;
     private TypeMirror appClass;
@@ -32,81 +33,104 @@ private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory,
     }
 
     @Override
-    ClassName nameGeneratedType(BindingGraph input) {
-        return getClassName(input);
+    ClassName nameGeneratedType(ImmutableSet<BindingGraph> input) {
+        return getClassName(input.stream().findFirst().get());
     }
 
     private ClassName getClassName(BindingGraph input) {
-        final TypeElement component = input.componentDescriptor().componentDefinitionType();
-        return ClassName.get(component).topLevelClassName().peerClass(component.getSimpleName().toString() + "Decorator");
+        return className(input);
+    }
+
+    static ClassName className(BindingGraph input) {
+        final ComponentDescriptor topDescriptor = getTopDescriptor(input.componentDescriptor());
+        final TypeElement topComponent = topDescriptor.componentDefinitionType();
+        final String componentName = input.componentDescriptor().componentDefinitionType().getSimpleName().toString();
+        return ClassName.get(topComponent).topLevelClassName().peerClass(componentName + "Decorator");
     }
 
     @Override
-    Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
-        return Optional.of(input.componentDescriptor().componentDefinitionType());
+    Optional<? extends Element> getElementForErrorReporting(ImmutableSet<BindingGraph> input) {
+        return Optional.of(input.stream().findFirst().get().componentDescriptor().componentDefinitionType());
     }
 
     @Override
-    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, BindingGraph input) {
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ImmutableSet<BindingGraph> input) {
         final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName)
                 .addModifiers(Modifier.PUBLIC);
 
-        ComponentDescriptor topDescriptor = getTopDescriptor(input.componentDescriptor());
+        builder.addModifiers(Modifier.PUBLIC);
+        builder.addMethod(MethodSpec.constructorBuilder()
+                .addModifiers(Modifier.PUBLIC)
+                .addParameter(testAppClassName, "app")
+                .addStatement("this.app = app")
+                .build());
+
+        final BindingGraph bindingGraph = input.stream().findFirst().get();
+
+        ComponentDescriptor topDescriptor = getTopDescriptor(bindingGraph.componentDescriptor());
         final BindingGraph parentGraph = factory.create(topDescriptor, appClass);
-        final String daggerBuilderClassName = TriggerComponentInfo.resolveBuilderName(input, parentGraph);
+        final String daggerBuilderClassName = TriggerComponentInfo.resolveBuilderName(bindingGraph, parentGraph);
 
         builder.addField(testAppClassName, "app", Modifier.PRIVATE);
-        TypeName builderClassName = ClassName.get(input.componentDescriptor().builderSpec().get().builderDefinitionType());
-        final ImmutableSet<ContributionBinding> delegateRequirements = input.delegateRequirements();
+        TypeName builderClassName = ClassName.get(bindingGraph.componentDescriptor().builderSpec().get().builderDefinitionType());
+        final ImmutableSet<ContributionBinding> delegateRequirements = bindingGraph.delegateRequirements();
 
         if (delegateRequirements.isEmpty()) {
             return Optional.empty();
         }else {
-            final String componentName = input.componentDescriptor().componentDefinitionType().getSimpleName().toString();
-            addDecoratorType(builder, daggerBuilderClassName, builderClassName, delegateRequirements, componentName);
+            final String componentName = bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString();
+            TypeName interfaceName = getAccessorTypeName(ClassName.bestGuess(testAppClassName.toString()), componentName);
+            builder.addSuperinterface(interfaceName);
+            addDecoratorType(builder, daggerBuilderClassName, builderClassName, input, delegateRequirements, componentName);
             return Optional.of(builder);
         }
     }
 
     public TypeSpec.Builder getAccessorType(ClassName appClassName, BindingGraph bindingGraph) {
         final String componentName = bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString();
-        ClassName name = this.getAccessorTypeName(appClassName, componentName);
-        final TypeSpec.Builder interfaceBuilder = TypeSpec.interfaceBuilder(name)
-                .addModifiers(Modifier.PUBLIC);
+        ClassName name = getAccessorTypeName(appClassName, componentName);
+        final TypeSpec.Builder interfaceBuilder = TypeSpec.interfaceBuilder(name).addModifiers(Modifier.PUBLIC);
         for (ContributionBinding contributionBinding : bindingGraph.delegateRequirements()) {
             Util.createDelegateMethod(name, interfaceBuilder, contributionBinding);
         }
         interfaceBuilder.addMethod(MethodSpec.methodBuilder("and")
                 .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
-                .returns(testAppClassName)
+                .returns(testAppClassName.topLevelClassName().peerClass("Decorator"))
                 .build());
         return interfaceBuilder;
     }
 
-    private void addDecoratorType(TypeSpec.Builder builder, String className, TypeName builderClassName, ImmutableSet<ContributionBinding> delegateRequirements, String componentName) {
-
-        builder.addModifiers(Modifier.PUBLIC);
-        builder.addMethod(MethodSpec.constructorBuilder()
-                .addModifiers(Modifier.PUBLIC)
-                .addParameter(testAppClassName, "app")
-                .addStatement("this.app = app")
-                .build());
+    private void addDecoratorType(TypeSpec.Builder builder, String className, TypeName builderClassName, ImmutableSet<BindingGraph> input, ImmutableSet<ContributionBinding> delegateRequirements, String componentName) {
 
         List<CodeBlock> statements = new ArrayList<>();
-        final ClassName name = ClassName.bestGuess(className);
-        statements.add(CodeBlock.of("$T impl = ($T) builder;", name, name));
-
-        TypeName interfaceName = this.getAccessorTypeName(ClassName.bestGuess(testAppClassName.toString()), componentName);
-        builder.addSuperinterface(interfaceName);
-
-        for (ContributionBinding contributionBinding : delegateRequirements) {
-            Util.createDelegateFieldAndMethod(interfaceName, builder, contributionBinding, new HashMap<>(1), true);
-            final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
-            final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
-            statements.add(CodeBlock.of("impl.$L(this.$L);", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
+        final UnmodifiableIterator<BindingGraph> it = input.iterator();
+        int counter = 0;
+        while(it.hasNext()) {
+            final BindingGraph bindingGraph = it.next();
+            final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+            ComponentDescriptor topDescriptor = getTopDescriptor(bindingGraph.componentDescriptor());
+            final BindingGraph parentGraph = factory.create(topDescriptor, appClass);
+            final ClassName name = ClassName.bestGuess(TriggerComponentInfo.resolveBuilderName(bindingGraph, parentGraph));
+            codeBuilder.beginControlFlow("if (builder instanceof $T)", name);
+            codeBuilder.add(CodeBlock.of("$T impl = ($T) builder;\n", name, name));
+            TypeName interfaceName = getAccessorTypeName(ClassName.bestGuess(testAppClassName.toString()),
+                    bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString());
+            for (ContributionBinding contributionBinding : delegateRequirements) {
+                if (counter == 0) {
+                    Util.createDelegateField(builder, contributionBinding);
+                    Util.createDelegateMethodImplementation(interfaceName, builder, contributionBinding);
+                }
+                final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
+                final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
+                codeBuilder.add(CodeBlock.of("impl.$L(this.$L);\n", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
+            }
+            codeBuilder.add(CodeBlock.of("return impl;\n"));
+            codeBuilder.endControlFlow();
+            statements.add(codeBuilder.build());
+            counter++;
         }
 
-        statements.add(CodeBlock.of("return impl;"));
+        statements.add(CodeBlock.of("throw new $T($S);", IllegalStateException.class, "could not resolve builder type"));
 
         builder.addMethod(MethodSpec.methodBuilder("and")
                 .addModifiers(Modifier.PUBLIC)
@@ -124,8 +148,8 @@ private void addDecoratorType(TypeSpec.Builder builder, String className, TypeNa
     }
 
     @Override
-    void generate(BindingGraph input) throws SourceFileGenerationException {
-        final ClassName generatedTypeName = getClassName(input);
+    void generate(ImmutableSet<BindingGraph> input) throws SourceFileGenerationException {
+        final ClassName generatedTypeName = this.nameGeneratedType(input);
         final Optional<TypeSpec.Builder> builder = write(generatedTypeName, input);
         if (builder.isPresent()) {
             try {
@@ -136,7 +160,7 @@ void generate(BindingGraph input) throws SourceFileGenerationException {
         }
     }
 
-    public ClassName getAccessorTypeName(ClassName app, String componentName) {
+    public static ClassName getAccessorTypeName(ClassName app, String componentName) {
         return app.nestedClass(componentName + "Accessor");
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DecoratorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DecoratorGenerator.java
new file mode 100644
index 000000000..1f1bd2358
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DecoratorGenerator.java
@@ -0,0 +1,112 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSetMultimap;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import java.io.IOException;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.Util.distinctByKey;
+import static java.util.stream.Collectors.mapping;
+import static java.util.stream.Collectors.toList;
+
+class DecoratorGenerator extends SourceFileGenerator<DI>{
+
+    private final ComponentDescriptor.Factory componentDescriptorFactory;
+    private final BindingGraph.Factory bindingGraphFactory;
+    private TestRegistry testRegistry;
+
+    DecoratorGenerator(Filer filer, Elements elements,
+                       ComponentDescriptor.Factory componentDescriptorFactory,
+                       BindingGraph.Factory bindingGraphFactory,
+                       TestRegistry testRegistry) {
+        super(filer, elements);
+        this.componentDescriptorFactory = componentDescriptorFactory;
+        this.bindingGraphFactory = bindingGraphFactory;
+        this.testRegistry = testRegistry;
+    }
+
+    @Override
+    ClassName nameGeneratedType(DI input) {
+        return input.getDecoratorType();
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(DI input) {
+        return Optional.empty();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI input) {
+        final TypeSpec.Builder builder = TypeSpec.interfaceBuilder(input.getDecoratorType())
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
+
+        final Set<TypeElement> components = input.getComponents();
+
+       components.stream()
+                .map(componentDescriptorFactory::forComponent)
+                .map(descriptor -> bindingGraphFactory.create(descriptor, input.getAppClass().asType()))
+                .flatMap(this::flatMapAllSubgraphs)
+                .filter(bindingGraph -> bindingGraph.componentDescriptor() != null && !bindingGraph.delegateRequirements().isEmpty())
+                .filter(distinctByKey(graph -> simpleVariableName(graph.componentDescriptor().componentDefinitionType())))
+                .forEach(graph -> builder.addMethod(createMethod(graph, input.getClassName())));
+
+        /*final ImmutableSetMultimap.Builder<String, BindingGraph> graphBuilder = ImmutableSetMultimap.builder();
+        graphs.forEach(graph -> graphBuilder.put(simpleVariableName(graph.componentType()), graph));
+        ImmutableSetMultimap<String, BindingGraph> groupedGraphs = graphBuilder.build();*/
+
+        /*groupedGraphs.keys().stream()
+                .map(groupedGraphs::get)
+                .forEach(bindingGraphs -> builder.addMethod(createMethod(bindingGraphs, input.getClassName())));*/
+
+        //groupedGraphs.entries().forEach(entry -> builder.addMethod(createMethod(entry.getValue(), input.getClassName())));
+
+        //graphs.forEach(graph -> builder.addMethod(createMethod(graph, input.getClassName())));
+
+        return Optional.of(builder);
+    }
+
+    private MethodSpec createMethod(BindingGraph graph, ClassName testAppClassName) {
+        final String componentName = graph.componentDescriptor().componentDefinitionType().getSimpleName().toString();
+        final ClassName className = Decorator.className(graph);
+        final String methodName = Util.lowerCaseFirstLetter(className.simpleName().replaceAll("Decorator$", ""));
+        final TypeName accessorName = Decorator.getAccessorTypeName(testAppClassName, componentName);
+        return MethodSpec.methodBuilder(methodName)
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
+                .returns(accessorName)
+                .build();
+    }
+
+    private Stream<BindingGraph> flatMapAllSubgraphs(BindingGraph graph) {
+        return Stream.concat(
+                Stream.of(graph),
+                graph.subgraphs().stream().flatMap(this::flatMapAllSubgraphs));
+    }
+
+    @Override
+    void generate(DI input) throws SourceFileGenerationException {
+        final ClassName generatedTypeName = this.nameGeneratedType(input);
+        final Optional<TypeSpec.Builder> builder = write(generatedTypeName, input);
+        if (builder.isPresent()) {
+            try {
+                testRegistry.addEncodedClass(generatedTypeName, buildJavaFile(generatedTypeName, builder.get()));
+            } catch (IOException e) {
+                throw new IllegalStateException(e);
+            }
+        }
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
index f63c9d1c6..b807ecc8a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
@@ -45,10 +45,10 @@ ClassName nameGeneratedType(DI input) {
                 .collect(Collectors.toList())
                 .forEach(info -> info.process(builder));
 
-        builder.addMethod(MethodSpec.methodBuilder(METHOD_NAME_GET_INJECTOR)
+        /*builder.addMethod(MethodSpec.methodBuilder(METHOD_NAME_GET_INJECTOR)
                 .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                 .returns(TYPENAME_INJECTOR)
-                .build());
+                .build());*/
 
         return Optional.of(builder);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
index 0f22a3644..6659d33a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
@@ -19,7 +19,7 @@ protected GeneratorComponentInfo(TypeElement component, ComponentDescriptor desc
 
     @Override
     protected String getId() {
-        return simpleVariableName(component);
+        return "decorate" + component.getSimpleName().toString();
     }
 
     @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index c86ec8c76..5c5c40396 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -2,30 +2,38 @@
 
 import java.util.Optional;
 
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.squareup.javapoet.*;
 
 import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
 import javax.lang.model.element.*;
 import javax.lang.model.util.Elements;
+import javax.tools.Diagnostic;
 import java.io.IOException;
 import java.util.*;
+import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.Util.distinctByKey;
+import static dagger.internal.codegen.Util.toImmutableList;
 
 class InjectorGenerator extends SourceFileGenerator<DI> {
 
-    private static final String METHOD_NAME_PREFIX = "decorate";
+    static final String METHOD_NAME_PREFIX = "";
 
+    private Messager messager;
     private final ComponentDescriptor.Factory componentDescriptorFactory;
     private final BindingGraph.Factory bindingGraphFactory;
     private TestClassGenerator.Factory testClassGeneratorFactory;
     private final TestRegistry registry;
     private Decorator.Factory decoratorFactory;
 
-    InjectorGenerator(Filer filer, Elements elements, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory, TestClassGenerator.Factory testClassGeneratorFactoty, TestRegistry registry, Decorator.Factory decoratorFactory) {
+    InjectorGenerator(Filer filer, Elements elements, Messager messager, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory, TestClassGenerator.Factory testClassGeneratorFactoty, TestRegistry registry, Decorator.Factory decoratorFactory) {
         super(filer, elements);
+        this.messager = messager;
         this.componentDescriptorFactory = componentDescriptorFactory;
         this.bindingGraphFactory = bindingGraphFactory;
         this.testClassGeneratorFactory = testClassGeneratorFactoty;
@@ -49,6 +57,7 @@ ClassName nameGeneratedType(DI input) {
         final Set<TypeElement> components = input.getComponents();
         final TypeElement appClass = input.getAppClass();
         builder.superclass(ClassName.get(appClass));
+        builder.addSuperinterface(input.getDecoratorType());
         createDecoratorClasses(builder, components, appClass);
         for (TypeElement component : components) {
             final List<TriggerComponentInfo> infos =
@@ -64,13 +73,20 @@ private void createDecoratorClasses(TypeSpec.Builder builder, Set<TypeElement> c
         ClassName testAppClassName = appClassName.topLevelClassName().peerClass("Test" + appClassName.simpleName());
         final Decorator decorator = decoratorFactory.create(testAppClassName, appClass.asType());
 
-        components.stream()
+        final List<BindingGraph> graphs = components.stream()
                 .map(componentDescriptorFactory::forComponent)
                 .map(descriptor -> bindingGraphFactory.create(descriptor, appClass.asType()))
                 .flatMap(this::flatMapAllSubgraphs)
                 .filter(bindingGraph -> bindingGraph.componentDescriptor() != null && !bindingGraph.delegateRequirements().isEmpty())
-                .filter(distinctByKey(graph -> simpleVariableName(graph.componentDescriptor().componentDefinitionType())))
-                .forEach(graph -> createDecoratorClass(builder, graph, decorator, testAppClassName));
+                .collect(Collectors.toList());
+
+        final ImmutableSetMultimap.Builder<String, BindingGraph> graphBuilder = ImmutableSetMultimap.builder();
+        graphs.forEach(graph -> graphBuilder.put(Util.lowerCaseFirstLetter(graph.componentType().getSimpleName().toString()), graph));
+        ImmutableSetMultimap<String, BindingGraph> groupedGraphs = graphBuilder.build();
+
+        groupedGraphs.keySet().stream()
+                .map(groupedGraphs::get)
+                .forEach(e -> createDecoratorClass(builder, e, decorator, testAppClassName));
 
     }
 
@@ -80,23 +96,34 @@ private void createDecoratorClasses(TypeSpec.Builder builder, Set<TypeElement> c
                 graph.subgraphs().stream().flatMap(this::flatMapAllSubgraphs));
     }
 
-    private void createDecoratorClass(TypeSpec.Builder builder, BindingGraph bindingGraph, Decorator decorator, ClassName testAppClassName) {
+    private void createDecoratorClass(TypeSpec.Builder builder, ImmutableSet<BindingGraph> graphs,
+                                      Decorator decorator, ClassName testAppClassName) {
         try {
-            decorator.generate(bindingGraph);
-            final ClassName decoratorName = decorator.nameGeneratedType(bindingGraph);
-            final String componentName = bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString();
-            final TypeName accessorName = decorator.getAccessorTypeName(testAppClassName, componentName);
+            messager.printMessage(Diagnostic.Kind.NOTE, "-----");
+            for (BindingGraph graph : graphs) {
+                messager.printMessage(Diagnostic.Kind.NOTE, String.valueOf(graph.componentType().getSimpleName().toString()));
+            }
+            messager.printMessage(Diagnostic.Kind.NOTE, "-----");
+            decorator.generate(graphs);
+            final Optional<BindingGraph> e = graphs.stream().findFirst();
+            if (!e.isPresent()) {
+                return;
+            }
+            final ClassName decoratorName = decorator.nameGeneratedType(graphs);
+            final String componentName = e.get().componentDescriptor().componentDefinitionType().getSimpleName().toString();
+            final TypeName accessorName = Decorator.getAccessorTypeName(testAppClassName, componentName);
             final String fieldName = Util.lowerCaseFirstLetter(decoratorName.simpleName());
-            final String methodName = METHOD_NAME_PREFIX + Util.capitalize(fieldName.replaceAll("Decorator$", ""));
+            final String methodName = Util.lowerCaseFirstLetter(fieldName.replaceAll("Decorator$", ""));
             final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, fieldName, Modifier.PRIVATE);
             final FieldSpec field = fieldBuilder.initializer("new $T(this)", decoratorName).build();
             builder.addField(field);
             builder.addMethod(MethodSpec.methodBuilder(methodName)
+                    .addAnnotation(Override.class)
                     .addModifiers(Modifier.PUBLIC)
                     .returns(accessorName)
                     .addStatement("return this.$L", fieldName)
                     .build());
-            builder.addType(decorator.getAccessorType(testAppClassName, bindingGraph).build());
+            builder.addType(decorator.getAccessorType(testAppClassName, e.get()).build());
         } catch (SourceFileGenerationException e) {
             throw new IllegalStateException("Exception while generating decorator: " + e);
         }
@@ -114,7 +141,6 @@ void generate(DI input) throws SourceFileGenerationException {
         } catch (IOException e) {
             throw new IllegalStateException(e);
         }
-
     }
 
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index 73b7f3055..9e41cc702 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -6,6 +6,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.TypeName;
 import dagger.*;
 
@@ -38,16 +39,19 @@
     private ApplicationGenerator applicationGenerator;
     private StubGenerator stubGenerator;
     private HashSet<TypeElement> components = new HashSet<>();
+    private DecoratorGenerator decoratorGenerator;
 
     public InjectorProcessingStep(Types types, Messager messager,
                                   AppConfig.Factory appConfigFactory,
                                   InjectorGenerator injectorGenerator,
                                   ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory,
                                   ComponentDescriptor.Factory componentDescriptorFactory,
+                                  DecoratorGenerator decoratorGenerator,
                                   DependencySpecGenerator dependencySpecGenerator,
                                   DependencyInjectorGenerator dependencyInjectorGenerator,
                                   ProvisionBinding.Factory provisionBindingFactory,
-                                  ApplicationGenerator applicationGenerator, StubGenerator stubGenerator) {
+                                  ApplicationGenerator applicationGenerator,
+                                  StubGenerator stubGenerator) {
         this.types = types;
         this.messager = messager;
         this.appConfigFactory = appConfigFactory;
@@ -60,6 +64,7 @@ public InjectorProcessingStep(Types types, Messager messager,
         this.provisionBindingFactory = provisionBindingFactory;
         this.applicationGenerator = applicationGenerator;
         this.stubGenerator = stubGenerator;
+        this.decoratorGenerator = decoratorGenerator;
     }
 
     @Override
@@ -114,10 +119,12 @@ public InjectorProcessingStep(Types types, Messager messager,
                         });
 
             }
-            final DI di = new DI(appConfig, components, injectorTypeList);
+            final ClassName decoratorClassName = ClassName.get(appConfig.getAppClass()).topLevelClassName().peerClass("Decorator");
+            final DI di = new DI(appConfig, components, injectorTypeList, decoratorClassName);
+            this.decoratorGenerator.generate(di, messager);
             this.applicationGenerator.generate(di, messager);
             this.dependencySpecGenerator.generate(di, messager);
-            this.dependencyInjectorGenerator.generate(di, messager);
+            //this.dependencyInjectorGenerator.generate(di, messager);
             this.injectorGenerator.generate(di, messager);
         } else {
             throw new IllegalStateException(rejectedElements.toString());
diff --git a/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
index e4c70b75d..49cb65693 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
@@ -20,7 +20,7 @@ protected SpecComponentInfo(TypeElement component, ComponentDescriptor descripto
 
     @Override
     protected String getId() {
-        return simpleVariableName(component);
+        return "decorate" + component.getSimpleName().toString();
     }
 
     @Override
@@ -43,10 +43,9 @@ protected String getId() {
 
         ClassName builderClassName = getBuilderClassName(component);
         methodBuilder.returns(builderClassName);
-        List<ParameterSpec> parameterSpecs = new ArrayList<>();
 
+        List<ParameterSpec> parameterSpecs = new ArrayList<>();
         ParameterSpec builderParameter = ParameterSpec.builder(builderClassName, "builder").build();
-
         parameterSpecs.add(builderParameter);
 
         methodBuilder.addParameters(parameterSpecs);
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
index bc6fbb485..f566347f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
@@ -58,7 +58,7 @@ protected boolean noActionRequired(List<String> ids) {
 
     @Override
     protected String getId() {
-        return simpleVariableName(descriptor.componentDefinitionType());
+        return "decorate" + descriptor.componentDefinitionType().getSimpleName().toString();
     }
 
     protected ParameterSpec getBuilderParameterSpec(ClassName builderClassName) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 2aabb02e0..6d3e047c2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -571,6 +571,39 @@ public static void createDelegateMethod(TypeName generatedTypeName, TypeSpec.Bui
         }
     }
 
+    public static void createDelegateMethodImplementation(TypeName generatedTypeName, TypeSpec.Builder classBuilder, ContributionBinding binding) {
+        try {
+            if (bindingSupportsTestDelegate(binding)) {
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final String methodName = getDelegateMethodName(delegateType);
+                final MethodSpec.Builder delegateMethodBuilder = MethodSpec.methodBuilder(methodName);
+                delegateMethodBuilder.addModifiers(Modifier.PUBLIC);
+                classBuilder.addMethod(delegateMethodBuilder
+                        .returns(generatedTypeName)
+                        .addParameter(delegateType, delegateFieldName)
+                        .addStatement("this.$L = $L", delegateFieldName, CodeBlock.of(delegateFieldName))
+                        .addStatement("return this")
+                        .build());
+            }
+        } catch (Exception e) {
+        }
+    }
+
+    public static void createDelegateField(TypeSpec.Builder classBuilder, ContributionBinding binding) {
+        try {
+            if (bindingSupportsTestDelegate(binding)) {
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
+                builder.addModifiers(Modifier.PRIVATE);
+                final FieldSpec fieldSpec = builder.build();
+                classBuilder.addField(fieldSpec);
+            }
+        } catch (Exception e) {
+        }
+    }
+
     public static void createDelegateFieldAndMethod(TypeName generatedTypeName, TypeSpec.Builder classBuilder, ContributionBinding binding, Map<Key, String> delegateFieldNames, boolean publicMethod) {
         try {
             if (bindingSupportsTestDelegate(binding)) {
diff --git a/core/pom.xml b/core/pom.xml
index 1a53f76a2..7daaf0b0e 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -127,14 +127,14 @@
           </execution>
         </executions>
       </plugin>-->
-      <plugin>
+      <!--<plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
         <configuration>
           <source>1.8</source>
           <target>1.8</target>
         </configuration>
-      </plugin>
+      </plugin>-->
     </plugins>
   </build>
 </project>
diff --git a/core/src/main/java/dagger/ActivityComponent.java b/core/src/main/java/dagger/ActivityComponent.java
deleted file mode 100644
index fabba2310..000000000
--- a/core/src/main/java/dagger/ActivityComponent.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package dagger;
-
-public interface ActivityComponent<A> extends BaseComponent<A> {}
diff --git a/core/src/main/java/dagger/ActivityComponentBuilder.java b/core/src/main/java/dagger/ActivityComponentBuilder.java
deleted file mode 100644
index c7db4f597..000000000
--- a/core/src/main/java/dagger/ActivityComponentBuilder.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package dagger;
-
-public interface ActivityComponentBuilder<C extends ActivityComponent> extends BaseComponentBuilder<C> {}
diff --git a/core/src/main/java/dagger/BaseComponent.java b/core/src/main/java/dagger/BaseComponent.java
deleted file mode 100644
index 17fd34e7e..000000000
--- a/core/src/main/java/dagger/BaseComponent.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package dagger;
-
-import dagger.MembersInjector;
-
-public interface BaseComponent<A> extends MembersInjector<A> {}
diff --git a/core/src/main/java/dagger/BaseComponentBuilder.java b/core/src/main/java/dagger/BaseComponentBuilder.java
deleted file mode 100644
index 6a64cf1bf..000000000
--- a/core/src/main/java/dagger/BaseComponentBuilder.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package dagger;
-
-public interface BaseComponentBuilder<C extends BaseComponent> {
-    C build();
-}
diff --git a/core/src/main/java/dagger/ComponentBuilder.java b/core/src/main/java/dagger/ComponentBuilder.java
deleted file mode 100644
index dbdb8f5de..000000000
--- a/core/src/main/java/dagger/ComponentBuilder.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package dagger;
-
-import java.util.Map;
-
-import javax.inject.Provider;
-
-public class ComponentBuilder<P> {
-
-    private final Map<Class<?>, Provider<P>> builders;
-
-    public ComponentBuilder(Map<Class<?>, Provider<P>> builders) {
-        this.builders = builders;
-    }
-
-    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(Class<T> clazz,
-                                                                                             A injectable,
-                                                                                             Config<A, C, T> config) {
-        T builder = (T) builders.get(injectable.getClass()).get();
-        C component = config.configure(builder).build();
-        component.injectMembers(injectable);
-        return component;
-    }
-
-    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(Class<T> clazz,
-                                                                                             A injectable) {
-        T builder = (T) builders.get(injectable.getClass()).get();
-        C component = builder.build();
-        component.injectMembers(injectable);
-        return component;
-    }
-
-    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(A injectable) {
-        T builder = (T) builders.get(injectable.getClass()).get();
-        C component = builder.build();
-        component.injectMembers(injectable);
-        return component;
-    }
-
-    public interface Config<A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> {
-        T configure(T builder);
-    }
-
-}
diff --git a/core/src/main/java/dagger/FragmentComponent.java b/core/src/main/java/dagger/FragmentComponent.java
deleted file mode 100644
index b10c8773d..000000000
--- a/core/src/main/java/dagger/FragmentComponent.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package dagger;
-
-public interface FragmentComponent<F> extends BaseComponent<F> {}
diff --git a/core/src/main/java/dagger/FragmentComponentBuilder.java b/core/src/main/java/dagger/FragmentComponentBuilder.java
deleted file mode 100644
index b08570dca..000000000
--- a/core/src/main/java/dagger/FragmentComponentBuilder.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package dagger;
-
-public interface FragmentComponentBuilder<C extends FragmentComponent> extends BaseComponentBuilder<C>{}
diff --git a/decoder/pom.xml b/decoder/pom.xml
new file mode 100644
index 000000000..e97be6d17
--- /dev/null
+++ b/decoder/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <groupId>com.google.dagger</groupId>
+        <artifactId>dagger-parent</artifactId>
+        <version>3.0</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dagger-decoder</artifactId>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.google.auto.service</groupId>
+            <artifactId>auto-service</artifactId>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup</groupId>
+            <artifactId>javapoet</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.google.auto</groupId>
+            <artifactId>auto-common</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>dagger</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+
+</project>
\ No newline at end of file
diff --git a/decoder/src/main/java/dagger/decoder/DecodingProcessingStep.java b/decoder/src/main/java/dagger/decoder/DecodingProcessingStep.java
new file mode 100644
index 000000000..4f4a0fc15
--- /dev/null
+++ b/decoder/src/main/java/dagger/decoder/DecodingProcessingStep.java
@@ -0,0 +1,63 @@
+package dagger.decoder;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.List;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.tools.JavaFileObject;
+import javax.xml.bind.DatatypeConverter;
+
+import dagger.Trigger;
+
+class DecodingProcessingStep {
+
+    private Filer filer;
+
+    DecodingProcessingStep(Filer filer) {
+        this.filer = filer;
+    }
+
+    private static byte[] decodeClass(String value) {
+        return DatatypeConverter.parseBase64Binary(value);
+    }
+
+    public void process(TypeElement typeElement) {
+        List<? extends Element> enclosedElements = typeElement.getEnclosedElements();
+        enclosedElements.stream()
+                        .filter(this::isMethod)
+                        .filter(this::hasTriggerAnnotation)
+                        .map(element -> (ExecutableElement) element)
+                        .map(method -> method.getAnnotation(Trigger.class))
+                        .forEach(trigger ->
+                        {
+                            try {
+                                process(trigger);
+                            } catch (IOException e) {
+                                e.printStackTrace();
+                            }
+                        });
+    }
+
+    private boolean hasTriggerAnnotation(Element method) {
+        return method.getAnnotation(Trigger.class) != null;
+    }
+
+    private boolean isMethod(Element element) {
+        return element.getKind() == ElementKind.METHOD;
+    }
+
+    private void process(Trigger annotation) throws IOException {
+        final String value = annotation.value();
+        final String qualifiedName = annotation.qualifiedName();
+        final JavaFileObject sourceFile = filer.createSourceFile(qualifiedName);
+        final OutputStream os = sourceFile.openOutputStream();
+        os.write(decodeClass(value));
+        os.flush();
+        os.close();
+    }
+}
diff --git a/decoder/src/main/java/dagger/decoder/DecodingProcessor.java b/decoder/src/main/java/dagger/decoder/DecodingProcessor.java
new file mode 100644
index 000000000..ac822e127
--- /dev/null
+++ b/decoder/src/main/java/dagger/decoder/DecodingProcessor.java
@@ -0,0 +1,66 @@
+package dagger.decoder;
+
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableSet;
+
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+@AutoService(javax.annotation.processing.Processor.class)
+public class DecodingProcessor extends AbstractProcessor
+{
+
+    public static final String DAGGER_TEST_TRIGGER = "dagger.TestTrigger";
+    private Elements elements;
+    private Filer filer;
+    private boolean alreadyProcessed = false;
+
+    @Override
+    public SourceVersion getSupportedSourceVersion() {
+        return SourceVersion.latestSupported();
+    }
+
+    @Override
+    public synchronized void init(ProcessingEnvironment processingEnvironment)
+    {
+        super.init(processingEnvironment);
+        elements = processingEnv.getElementUtils();
+        filer = processingEnv.getFiler();
+    }
+
+    @Override
+    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment)
+    {
+        return !alreadyProcessed && (Utils.isUnitTest(elements) || Utils.isAndroidTest(elements)) && processElement();
+    }
+
+    private boolean processElement()
+    {
+        TypeElement triggerElement = getTriggerElement();
+        if (triggerElement == null) {
+            return false;
+        }
+        alreadyProcessed = true;
+        DecodingProcessingStep step = new DecodingProcessingStep(filer);
+        step.process(triggerElement);
+        return false;
+    }
+
+    private TypeElement getTriggerElement() {
+        return elements.getTypeElement(DAGGER_TEST_TRIGGER);
+    }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes()
+    {
+        return ImmutableSet.of("*");
+    }
+
+}
diff --git a/decoder/src/main/java/dagger/decoder/Utils.java b/decoder/src/main/java/dagger/decoder/Utils.java
new file mode 100644
index 000000000..c7e6b950d
--- /dev/null
+++ b/decoder/src/main/java/dagger/decoder/Utils.java
@@ -0,0 +1,17 @@
+package dagger.decoder;
+
+import javax.lang.model.util.Elements;
+
+class Utils {
+
+    static boolean isAndroidTest(Elements elements)
+    {
+        return elements.getPackageElement("android.test") != null;
+    }
+
+    static boolean isUnitTest(Elements elements)
+    {
+        return elements.getPackageElement("org.junit") != null;
+    }
+
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
deleted file mode 100644
index 3d84a4707..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.activitygraphs;
-
-import android.app.Activity;
-import com.example.dagger.activitygraphs.ui.PerActivity;
-import dagger.Component;
-
-/**
- * A base component upon which fragment's components may depend.  Activity-level components
- * should extend this component.
- */
-@PerActivity // Subtypes of AbstractActivityComponent should be decorated with @PerActivity.
-@Component(dependencies = ApplicationComponent.class, modules = ActivityModule.class)
-public interface AbstractActivityComponent {
-  Activity activity(); // Expose the activity to sub-graphs.
-  @Component.Builder
-  interface Builder {
-    //Builder moduleActivity(ActivityModule module);
-    Builder component(ApplicationComponent component);
-    AbstractActivityComponent build();
-  }
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
deleted file mode 100644
index a155296c9..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package com.example.dagger.activitygraphs;
-
-import dagger.Module;
-
-@Module
-public class ActivityModule {
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AppConfig.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AppConfig.java
deleted file mode 100644
index 1b721ae1a..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AppConfig.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package com.example.dagger.activitygraphs;
-
-import dagger.Config;
-
-@Config(applicationClass = DemoApplication.class)
-public class AppConfig {
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
deleted file mode 100644
index 6bd3bef59..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.activitygraphs;
-
-import android.app.Application;
-import android.location.LocationManager;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import dagger.Component;
-import javax.inject.Singleton;
-
-/**
- * A component whose lifetime is the life of the application.
- */
-@Singleton // Constraints this component to one-per-application or unscoped bindings.
-@Component(modules = DemoApplicationModule.class)
-public interface ApplicationComponent {
-
-  // Exported for child-components.
-  Application application();
-  LocationManager locationManager();
-  @Component.Builder
-  interface Builder {
-    Builder module(DemoApplicationModule module);
-    ApplicationComponent build();
-  }
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
deleted file mode 100644
index b508e96e4..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.activitygraphs;
-
-import android.location.LocationManager;
-import dagger.Injector;
-import dagger.Provides;
-import dagger.ProvidesComponent;
-import dagger.ProvidesModule;
-
-import javax.inject.Inject;
-
-public class DemoApplication extends DaggerApplication {
-  private ApplicationComponent applicationComponent;
-
-  // TODO(cgruber): Figure out a better example of something one might inject into the app.
-  @Inject LocationManager locationManager; // to illustrate injecting something into the app.
-
-  @Override public void onCreate() {
-    super.onCreate();
-    applicationComponent = DaggerApplicationComponent.builder()
-        .module(new DemoApplicationModule(this))
-        .build();
-  }
-
-  public ApplicationComponent component() {
-    return applicationComponent;
-  }
-
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
deleted file mode 100644
index 8395cf4f6..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.activitygraphs;
-
-import static android.content.Context.LOCATION_SERVICE;
-
-import android.app.Application;
-import android.location.LocationManager;
-import dagger.AllowStubGeneration;
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.StringKey;
-
-import javax.inject.Singleton;
-
-/**
- * A module for Android-specific dependencies which require a {@link Context} or
- * {@link android.app.Application} to create.
- */
-@Module
-public class DemoApplicationModule {
-  private final Application application;
-
-  public DemoApplicationModule(Application application) {
-    this.application = application;
-  }
-
-  /**
-   * Expose the application to the graph.
-   */
-  @Provides @Singleton Application application() {
-    return application;
-  }
-
-  @Provides @Singleton LocationManager provideLocationManager() {
-    return (LocationManager) application.getSystemService(LOCATION_SERVICE);
-  }
-
-  @Provides
-  @StringKey("BLA")
-  @AllowStubGeneration
-  @IntoMap
-  public String prov() {
-    return "";
-  }
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/FragmentComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/FragmentComponent.java
deleted file mode 100644
index 948451a46..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/FragmentComponent.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package com.example.dagger.activitygraphs;
-
-import dagger.Component;
-
-@PerFragment
-@Component(dependencies = AbstractActivityComponent.class)
-public interface FragmentComponent {
-    @Component.Builder
-    interface Builder {
-        Builder component(AbstractActivityComponent component);
-        FragmentComponent build();
-    }
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerFragment.java
deleted file mode 100644
index a19da6203..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerFragment.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.activitygraphs;
-
-import javax.inject.Scope;
-import java.lang.annotation.Retention;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-/**
- * A scoping annotation to permit objects whose lifetime should
- * conform to the life of the activity to be memoized in the
- * correct component.
- */
-@Scope
-@Retention(RUNTIME)
-public @interface PerFragment {
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/SomeClass.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/SomeClass.java
deleted file mode 100644
index 3fdcea951..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/SomeClass.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.example.dagger.activitygraphs;
-
-import dagger.Lazy;
-
-import javax.inject.Inject;
-import javax.inject.Named;
-import java.util.Set;
-
-/**
- * Created by Andy on 07.05.2017.
- */
-public class SomeClass {
-
-    @Inject
-    public SomeClass(Lazy<String> lazy) {
-
-    }
-
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
deleted file mode 100644
index 65e65dd87..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.activitygraphs.ui;
-
-import android.location.LocationManager;
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-//import com.example.dagger.activitygraphs.ActivityModule;
-import com.example.dagger.activitygraphs.DemoApplication;
-import com.example.dagger.activitygraphs.SomeClass;
-import dagger.Lazy;
-
-import javax.inject.Inject;
-import javax.inject.Named;
-import javax.inject.Provider;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-public class HomeActivity extends FragmentActivity {
-
-  @Inject LocationManager locationManager;
-  private HomeComponent component;
-
-  @Inject
-  Lazy<SomeClass> someClass;
-
-  @Inject
-  Lazy<List<String>> list;
-
-  @Inject
-  Lazy<Map<String, String>> map;
-
-  HomeComponent component() {
-    if (component == null) {
-      /*component = DaggerHomeComponent.builder()
-          .componentApplication(((DemoApplication) getApplication()).component())
-          .moduleActivity(new ActivityModule(this))
-          .build();*/
-    }
-    return component;
-  }
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    component().inject(this);
-
-    if (savedInstanceState == null) {
-      getSupportFragmentManager().beginTransaction()
-          //.add(android.R.id.content, new HomeFragment())
-          .commit();
-    }
-
-    // TODO do something with the injected dependencies here!
-  }
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
deleted file mode 100644
index d390f9787..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.activitygraphs.ui;
-
-import com.example.dagger.activitygraphs.AbstractActivityComponent;
-import com.example.dagger.activitygraphs.ActivityModule;
-import com.example.dagger.activitygraphs.ApplicationComponent;
-import dagger.Component;
-
-@PerActivity
-@Component(dependencies = ApplicationComponent.class, modules = ActivityModule.class)
-public interface HomeComponent extends AbstractActivityComponent {
-  void inject(HomeActivity homeActivity);
-  //void inject(HomeFragment homeFragment);
-  @Component.Builder
-  interface Builder {
-    Builder moduleActivity(ActivityModule activityModule);
-    Builder componentApplication(ApplicationComponent component);
-    HomeComponent build();
-  }
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/PerActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/PerActivity.java
deleted file mode 100644
index fe3e2b5d8..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/PerActivity.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.example.dagger.activitygraphs.ui;
-
-import javax.inject.Scope;
-
-/**
- * Created by Andy on 06.06.2017.
- */
-@Scope
-public @interface PerActivity {
-}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
index 6cf8c3c79..b15d366ab 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
@@ -29,22 +29,17 @@
  * {@link android.app.Application} to create.
  */
 @Module
-public class AndroidModule {
-  private final DemoApplication1 application;
-
-  public AndroidModule(DemoApplication1 application) {
-    this.application = application;
-  }
+public abstract class AndroidModule {
 
   /**
    * Allow the application context to be injected but require that it be annotated with
    * {@link ForApplication @Annotation} to explicitly differentiate it from an activity context.
    */
-  @Provides @Singleton @ForApplication Context provideApplicationContext() {
-    return application;
+  @Provides @Singleton @ForApplication static Context provideApplicationContext(DemoApplication1 app) {
+    return app;
   }
 
-  @Provides @Singleton LocationManager provideLocationManager() {
-    return (LocationManager) application.getSystemService(LOCATION_SERVICE);
+  @Provides @Singleton static LocationManager provideLocationManager(DemoApplication1 app) {
+    return (LocationManager) app.getSystemService(LOCATION_SERVICE);
   }
 }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java b/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java
index 130595894..abeb5ab36 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java
@@ -1,5 +1,6 @@
 package com.example.dagger.simple;
 
+import dagger.BindsInstance;
 import dagger.Component;
 import javax.inject.Singleton;
 
@@ -9,15 +10,11 @@
     @Singleton
     @Component(modules = {AndroidModule.class, SingletonModule.class})
     public interface ApplicationComponent {
-        //void inject(DemoApplication1 application);
-        //void inject(HomeActivity homeActivity);
-        //void inject(DemoActivity demoActivity);
         void inject(DemoApplication1 app);
 
         @Component.Builder
         interface Builder {
-            Builder androidModule(AndroidModule module);
-            Builder singletonModule(SingletonModule module);
+            @BindsInstance Builder app(DemoApplication1 app);
             ApplicationComponent build();
         }
     }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
index fec7c8c32..7318dcfc2 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
@@ -20,7 +20,7 @@
 import javax.inject.Inject;
 import javax.inject.Named;
 
-public class DemoApplication1 extends DaggerApplication{
+public class DemoApplication1 extends DaggerHookApplication {
 
   @Inject LocationManager locationManager; // for some reason.
   @Inject @Named("apiKey") String someString;
@@ -29,7 +29,7 @@
 
   @Override public void onCreate() {
     super.onCreate();
-    component = getInjector().applicationComponent(new AndroidModule(this));
+    component = DaggerComponents_ApplicationComponent.builder(this).build();
     component.inject(this);
   }
 
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java
index 38db0e8d6..9a03e132a 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java
@@ -9,17 +9,17 @@
  * Created by Andy on 04.05.2017.
  */
 @Module
-public class SingletonModule {
+public abstract class SingletonModule {
 
     @Provides
     @Named("apiKey")
-    public String someString() {
+    public static String someString() {
        return "";
     }
 
     @Provides
     @Named("apiKey1")
-    public String secondString() {
+    public static String secondString() {
         return "";
     }
 }
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index 24b1ce699..6731955da 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -43,7 +43,8 @@
   }
 
   public static void main(String[] args) {
-    Coffee coffee = DaggerCoffeeApp_Coffee.builder().build();
+    App app = new App();
+    Coffee coffee = DaggerCoffeeApp_Coffee.builder(app).build();
     coffee.maker().brew();
   }
 }
diff --git a/pom.xml b/pom.xml
index 840b69644..83f39afb3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -36,10 +36,12 @@
     <module>compiler</module>
     <module>core</module>
     <module>gwt</module>
+    <module>decoder</module>
     <!-- examples are handled in a default profile (see below) -->
     <module>producers</module>
     <module>android-support</module>
     <module>android-compiler</module>
+    <module>android-testcase</module>
   </modules>
 
   <properties>
diff --git a/settings.gradle b/settings.gradle
deleted file mode 100644
index cf0d917a3..000000000
--- a/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-include ':dagger-android-support'
