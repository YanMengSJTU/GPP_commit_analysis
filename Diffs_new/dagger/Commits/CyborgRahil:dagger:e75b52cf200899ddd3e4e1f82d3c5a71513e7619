diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index e213b4bc9..a02cee2dc 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -18,6 +18,8 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.DaggerStreams.presentValues;
+import static dagger.internal.codegen.DaggerStreams.stream;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
@@ -35,15 +37,11 @@
 import java.util.Collection;
 import java.util.Map;
 import java.util.Optional;
-import java.util.stream.Stream;
-import java.util.stream.StreamSupport;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 
-/**
- * The canonical representation of a full-resolved graph.
- */
+/** The canonical representation of a full-resolved graph. */
 @AutoValue
 abstract class BindingGraph {
   abstract ComponentDescriptor componentDescriptor();
@@ -156,67 +154,31 @@ TypeElement componentTypeElement() {
    */
   @Memoized
   ImmutableSet<ComponentRequirement> componentRequirements() {
-    return componentRequirements(
-        StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
-            .flatMap(graph -> graph.contributionBindings().values().stream())
-            .flatMap(bindings -> bindings.contributionBindings().stream()));
-  }
-
-  /**
-   * The types for which the component may need instances, depending on how it is resolved in a
-   * parent component.
-   *
-   * <ul>
-   *   <li>{@linkplain #ownedModules() Owned modules} with concrete instance bindings. If the module
-   *       is never used in the fully resolved binding graph, the instance will not be required
-   *       unless a component builder requests it.
-   *   <li>Bound instances (always required)
-   * </ul>
-   */
-  @Memoized
-  ImmutableSet<ComponentRequirement> possiblyNecessaryRequirements() {
-    checkState(componentDescriptor().isSubcomponent());
-    return componentRequirements(
-        StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
-            .flatMap(graph -> graph.ownedModules().stream())
-            .flatMap(module -> module.bindings().stream()));
-  }
-
-  /**
-   * The types for which the component needs instances.
-   *
-   * <ul>
-   *   <li>component dependencies
-   *   <li>The modules of {@code bindings} that require a module instance
-   *   <li>bound instances
-   * </ul>
-   */
-  private ImmutableSet<ComponentRequirement> componentRequirements(
-      // accept Stream instead of ImmutableSet so the binding instances don't need to be
-      // materialized in a large set + hashed. Even though this is in support of implementing
-      // methods that are themselves memoized, they still have a measurable impact on performance
-      Stream<ContributionBinding> bindings) {
+    ImmutableSet<TypeElement> requiredModules = requiredModuleElements();
     ImmutableSet.Builder<ComponentRequirement> requirements = ImmutableSet.builder();
-    bindings
-        .filter(ContributionBinding::requiresModuleInstance)
-        .map(ContributionBinding::contributingModule)
-        .distinct()
-        .flatMap(presentValues())
-        .filter(ownedModuleTypes()::contains)
-        .map(module -> ComponentRequirement.forModule(module.asType()))
+    componentDescriptor().requirements().stream()
+        .filter(
+            requirement ->
+                !requirement.kind().isModule()
+                    || requiredModules.contains(requirement.typeElement()))
         .forEach(requirements::add);
     if (factoryMethod().isPresent()) {
       requirements.addAll(factoryMethodParameters().keySet());
     }
-    requirements.addAll(componentDescriptor().dependencies());
-    componentDescriptor()
-        .creatorDescriptor()
-        .ifPresent(
-            creatorDescriptor ->
-                requirements.addAll(creatorDescriptor.boundInstanceRequirements()));
     return requirements.build();
   }
 
+  private ImmutableSet<TypeElement> requiredModuleElements() {
+    return stream(SUBGRAPH_TRAVERSER.depthFirstPostOrder(this))
+        .flatMap(graph -> graph.contributionBindings().values().stream())
+        .flatMap(bindings -> bindings.contributionBindings().stream())
+        .map(ContributionBinding::contributingModule)
+        .distinct()
+        .flatMap(presentValues())
+        .filter(ownedModuleTypes()::contains)
+        .collect(toImmutableSet());
+  }
+
   /** Returns the {@link ComponentDescriptor}s for this component and its subcomponents. */
   ImmutableSet<ComponentDescriptor> componentDescriptors() {
     return FluentIterable.from(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this))
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 06aa17bcb..6cdd19bbf 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -132,6 +132,34 @@ final boolean isRealComponent() {
     return modules().stream().map(ModuleDescriptor::moduleElement).collect(toImmutableSet());
   }
 
+  /**
+   * The types for which the component will need instances if all of its bindings are used. For the
+   * types the component will need in a given binding graph, use {@link
+   * BindingGraph#componentRequirements()}.
+   *
+   * <ul>
+   *   <li>{@linkplain #modules()} modules} with concrete instance bindings
+   *   <li>Bound instances
+   *   <li>{@linkplain #dependencies() dependencies}
+   * </ul>
+   */
+  @Memoized
+  ImmutableSet<ComponentRequirement> requirements() {
+    ImmutableSet.Builder<ComponentRequirement> requirements = ImmutableSet.builder();
+    modules().stream()
+        .filter(
+            module ->
+                module.bindings().stream().anyMatch(ContributionBinding::requiresModuleInstance))
+        .map(module -> ComponentRequirement.forModule(module.moduleElement().asType()))
+        .forEach(requirements::add);
+    requirements.addAll(dependencies());
+    requirements.addAll(
+        creatorDescriptor()
+            .map(ComponentCreatorDescriptor::boundInstanceRequirements)
+            .orElse(ImmutableSet.of()));
+    return requirements.build();
+  }
+
   /**
    * This component's {@linkplain #dependencies() dependencies} keyed by each provision or
    * production method defined by that dependency. Note that the dependencies' types are not simply
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index afe8b02f9..626e51213 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -307,17 +307,20 @@ boolean isAbstract() {
   }
 
   /**
-   * The possible requirements for creating an instance of this component implementation type.
+   * The requirements for creating an instance of this component implementation type.
    *
    * <p>If this component implementation is concrete, these requirements will be in the order that
    * the implementation's constructor takes them as parameters.
    */
   ImmutableSet<ComponentRequirement> requirements() {
     // If the base implementation's creator is being generated in ahead-of-time-subcomponents
-    // mode, this uses possiblyNecessaryRequirements() since Dagger doesn't know what modules may
-    // end up being unused. Otherwise, we use the necessary component requirements.
+    // mode, this uses the ComponentDescriptor's requirements() since Dagger doesn't know what
+    // modules may end being unused or owned by an ancestor component. Otherwise, we use the
+    // necessary component requirements.
+    // TODO(ronshapiro): can we remove the second condition here? Or, is it never going to be
+    // called, so we should enforce that invariant?
     return isAbstract() && !superclassImplementation().isPresent()
-        ? graph().possiblyNecessaryRequirements()
+        ? componentDescriptor().requirements()
         : graph().componentRequirements();
   }
 
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index d652aff77..4b51fe2c2 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -4812,11 +4812,11 @@ public void modifiableCycles() {
 
   /**
    * This tests a regression case where the component builder in the base implementation used one
-   * set of disambiguated names from all of the {@link
-   * BindingGraph#possiblyNecessaryRequirements()}, and the final implementation used a different
-   * set of disambiguated names from the resolved {@link BindingGraph#componentRequirements()}. This
-   * resulted in generated output that didn't compile, as the builder implementation attempted to
-   * use the new names in validation, which didn't line up with the old names.
+   * set of disambiguated names from all of the {@link ComponentDescriptor#requirements()}, and the
+   * final implementation used a different set of disambiguated names from the resolved {@link
+   * BindingGraph#componentRequirements()}. This resulted in generated output that didn't compile,
+   * as the builder implementation attempted to use the new names in validation, which didn't line
+   * up with the old names.
    */
   @Test
   public void componentBuilderFields_consistencyAcrossImplementations() {
