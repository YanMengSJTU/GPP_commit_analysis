diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index e3d07523d..5aa996d67 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -200,6 +200,7 @@ java_library(
     name = "internal_validation",
     srcs = [
         "BindingGraphValidationModule.java",
+        "MembersInjectionValidation.java",
         "NonNullableRequestForNullableBindingValidation.java",
         "ProviderDependsOnProducerValidation.java",
         "Validation.java",
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index c2049da92..c47b830f3 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -25,6 +25,11 @@
 @Module
 interface BindingGraphValidationModule {
 
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin membersInjection(MembersInjectionValidation validation);
+
   @Binds
   @IntoSet
   @Validation
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 3aa26610c..d960a196e 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -41,8 +41,6 @@
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
-import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE;
-import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.abstractModuleHasInstanceBindingMethods;
 import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
@@ -62,7 +60,6 @@
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static dagger.model.BindingKind.INJECTION;
-import static dagger.model.BindingKind.MEMBERS_INJECTOR;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static java.util.function.Predicate.isEqual;
 import static java.util.stream.Collectors.groupingBy;
@@ -120,15 +117,11 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor8;
 
 /** Reports errors in the shape of the binding graph. */
 final class BindingGraphValidator {
@@ -645,19 +638,10 @@ protected void visitContributionBinding(
         }
         if (binding.kind().equals(MULTIBOUND_MAP)) {
           validateMapKeys(binding, owningComponent);
-        } else if (binding.kind().equals(MEMBERS_INJECTOR)) {
-          validateMembersInjectionType(binding);
         }
         super.visitContributionBinding(binding, owningComponent);
       }
 
-      @Override
-      protected void visitMembersInjectionBinding(
-          MembersInjectionBinding binding, ComponentDescriptor owningComponent) {
-        validateMembersInjectionType(binding);
-        super.visitMembersInjectionBinding(binding, owningComponent);
-      }
-
       /**
        * Returns the binding declarations that can be reported for {@code resolvedBindings}, indexed
        * by the component that owns each declaration.
@@ -751,94 +735,6 @@ private void validateMapKeyAnnotationTypes(Set<ContributionBinding> mapBindingCo
         }
       }
 
-      /** Reports errors if a members injection binding is invalid. */
-      // TODO(dpb): Can this be done while validating @Inject?
-      private void validateMembersInjectionType(Binding binding) {
-        TypeMirror type =
-            binding.bindingType().equals(BindingType.MEMBERS_INJECTION)
-                ? binding.key().type()
-                : types.unwrapType(binding.key().type());
-        type.accept(membersInjectionBindingValidator, binding);
-      }
-
-      private final TypeVisitor<Void, Binding> membersInjectionBindingValidator =
-          new SimpleTypeVisitor8<Void, Binding>() {
-            @Override
-            protected Void defaultAction(TypeMirror e, Binding binding) {
-              report(currentGraph())
-                  .addError(
-                      "Invalid members injection request.", binding.bindingTypeElement().get());
-              return null;
-            }
-
-            @Override
-            public Void visitDeclared(DeclaredType type, Binding binding) {
-              // If the key has type arguments, validate that each type argument is declared.
-              // Otherwise the type argument may be a wildcard (or other type), and we can't
-              // resolve that to actual types.  If the arg was an array, validate the type
-              // of the array.
-              for (TypeMirror arg : type.getTypeArguments()) {
-                boolean declared =
-                    arg.accept(
-                        new SimpleTypeVisitor8<Boolean, Void>(false) {
-                          @Override
-                          public Boolean visitArray(ArrayType t, Void p) {
-                            return t.getComponentType()
-                                .accept(
-                                    new SimpleTypeVisitor8<Boolean, Void>(false) {
-                                      @Override
-                                      public Boolean visitDeclared(DeclaredType t, Void p) {
-                                        for (TypeMirror arg : t.getTypeArguments()) {
-                                          if (!arg.accept(this, null)) {
-                                            return false;
-                                          }
-                                        }
-                                        return true;
-                                      }
-
-                                      @Override
-                                      public Boolean visitArray(ArrayType t, Void p) {
-                                        return t.getComponentType().accept(this, null);
-                                      }
-
-                                      @Override
-                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {
-                                        return true;
-                                      }
-                                    },
-                                    null);
-                          }
-
-                          @Override
-                          public Boolean visitDeclared(DeclaredType t, Void p) {
-                            return true;
-                          }
-                        },
-                        null);
-                if (!declared) {
-                  reportErrorAtEntryPoint(
-                      MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
-                      arg.toString(),
-                      type.toString(),
-                      formatDependencyTrace());
-                  return null;
-                }
-              }
-
-              TypeElement element = MoreElements.asType(type.asElement());
-              // Also validate that the key is not the erasure of a generic type.
-              // If it is, that means the user referred to Foo<T> as just 'Foo',
-              // which we don't allow.  (This is a judgement call -- we *could*
-              // allow it and instantiate the type bounds... but we don't.)
-              if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
-                  && types.isSameType(types.erasure(element.asType()), type)) {
-                reportErrorAtEntryPoint(
-                    MEMBERS_INJECTION_WITH_RAW_TYPE, type.toString(), formatDependencyTrace());
-              }
-              return null;
-            }
-          };
-
       /**
        * Descriptive portion of the error message for when the given request has no binding.
        * Currently, the only other portions of the message are the dependency path, line number and
diff --git a/java/dagger/internal/codegen/MembersInjectionValidation.java b/java/dagger/internal/codegen/MembersInjectionValidation.java
new file mode 100644
index 000000000..531420a6a
--- /dev/null
+++ b/java/dagger/internal/codegen/MembersInjectionValidation.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.common.MoreElements;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.Optional;
+import javax.inject.Inject;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.util.SimpleTypeVisitor8;
+
+/**
+ * Validates types for which members injection is requested, either via a members-injecting entry
+ * point method or a request for a {@link dagger.MembersInjector}.
+ */
+final class MembersInjectionValidation implements BindingGraphPlugin {
+
+  private final DaggerTypes types;
+
+  @Inject
+  MembersInjectionValidation(DaggerTypes types) {
+    this.types = types;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/MembersInjection";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    for (BindingNode bindingNode : bindingGraph.bindingNodes()) {
+      membersInjectedType(bindingNode)
+          .ifPresent(type -> validateMembersInjectionType(type, bindingNode, diagnosticReporter));
+    }
+  }
+
+  /**
+   * Returns the type whose members will be injected if the binding is a {@link
+   * dagger.model.BindingKind#MEMBERS_INJECTION} or {@link
+   * dagger.model.BindingKind#MEMBERS_INJECTOR} binding.
+   */
+  private Optional<TypeMirror> membersInjectedType(BindingNode bindingNode) {
+    switch (bindingNode.binding().kind()) {
+      case MEMBERS_INJECTION:
+        return Optional.of(bindingNode.binding().key().type());
+
+      case MEMBERS_INJECTOR:
+        return Optional.of(types.unwrapType(bindingNode.binding().key().type()));
+
+      default:
+        return Optional.empty();
+    }
+  }
+
+  /** Reports errors if a members injection binding is invalid. */
+  private void validateMembersInjectionType(
+      TypeMirror membersInjectedType,
+      BindingNode bindingNode,
+      DiagnosticReporter diagnosticReporter) {
+    membersInjectedType.accept(
+        new SimpleTypeVisitor8<Void, Void>() {
+          @Override
+          protected Void defaultAction(TypeMirror e, Void v) {
+            // Only declared types can be members-injected.
+            diagnosticReporter.reportBinding(
+                ERROR, bindingNode, "Cannot inject members into %s", e);
+            return null;
+          }
+
+          @Override
+          public Void visitDeclared(DeclaredType type, Void v) {
+            if (type.getTypeArguments().isEmpty()) {
+              // If the type is the erasure of a generic type, that means the user referred to
+              // Foo<T> as just 'Foo', which we don't allow.  (This is a judgement call; we
+              // *could* allow it and instantiate the type bounds, but we don't.)
+              if (!MoreElements.asType(type.asElement()).getTypeParameters().isEmpty()) {
+                diagnosticReporter.reportBinding(
+                    ERROR, bindingNode, "Cannot inject members into raw type %s", type);
+              }
+            } else {
+              // If the type has arguments, validate that each type argument is declared.
+              // Otherwise the type argument may be a wildcard (or other type), and we can't
+              // resolve that to actual types.  For array type arguments, validate the type of
+              // the array.
+              for (TypeMirror arg : type.getTypeArguments()) {
+                if (!arg.accept(DECLARED_OR_ARRAY, null)) {
+                  diagnosticReporter.reportBinding(
+                      ERROR,
+                      bindingNode,
+                      "Cannot inject members into types with unbounded type arguments: %s",
+                      type);
+                }
+              }
+            }
+            return null;
+          }
+        },
+        null);
+  }
+
+  // TODO(dpb): Can this be inverted so it explicitly rejects wildcards or type variables?
+  // This logic is hard to describe.
+  private static final TypeVisitor<Boolean, Void> DECLARED_OR_ARRAY =
+      new SimpleTypeVisitor8<Boolean, Void>(false) {
+        @Override
+        public Boolean visitArray(ArrayType arrayType, Void p) {
+          return arrayType
+              .getComponentType()
+              .accept(
+                  new SimpleTypeVisitor8<Boolean, Void>(false) {
+                    @Override
+                    public Boolean visitDeclared(DeclaredType declaredType, Void p) {
+                      for (TypeMirror arg : declaredType.getTypeArguments()) {
+                        if (!arg.accept(this, null)) {
+                          return false;
+                        }
+                      }
+                      return true;
+                    }
+
+                    @Override
+                    public Boolean visitArray(ArrayType arrayType, Void p) {
+                      return arrayType.getComponentType().accept(this, null);
+                    }
+
+                    @Override
+                    public Boolean visitPrimitive(PrimitiveType primitiveType, Void p) {
+                      return true;
+                    }
+                  },
+                  null);
+        }
+
+        @Override
+        public Boolean visitDeclared(DeclaredType t, Void p) {
+          return true;
+        }
+      };
+}
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 3e55833a5..01da55889 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -30,6 +30,7 @@
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Arrays;
 import javax.tools.JavaFileObject;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -202,8 +203,8 @@ public void membersInjectDependsOnUnboundedType() {
         .withErrorContaining(
             Joiner.on('\n')
                 .join(
-                    "Type parameters must be bounded for members injection."
-                        + " ? required by java.util.ArrayList<?>, via:",
+                    "Cannot inject members into types with unbounded type arguments: "
+                        + "java.util.ArrayList<?>",
                     "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
                     "          test.InjectsUnboundedType.listInjector",
                     "      test.InjectsUnboundedType is injected at",
@@ -212,8 +213,94 @@ public void membersInjectDependsOnUnboundedType() {
         .onLine(7);
   }
 
+  @Ignore // TODO(b/77220343)
   @Test
-  public void invalidMembersInjection() {
+  public void membersInjectPrimitive() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(int primitive);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into int")
+        .inFile(component)
+        .onLineContaining("void inject(int primitive);");
+  }
+
+  @Ignore // TODO(b/77220343)
+  @Test
+  public void membersInjectArray() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Object[] array);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into java.lang.Object[]")
+        .inFile(component)
+        .onLineContaining("void inject(Object[] array);");
+  }
+
+  @Ignore // TODO(b/77220343)
+  @Test
+  public void membersInjectorOfArray() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  MembersInjector<Object[]> objectArrayInjector();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into java.lang.Object[]")
+        .inFile(component)
+        .onLineContaining("objectArrayInjector();");
+  }
+
+  @Test
+  public void membersInjectRawType() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Set;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Set rawSet);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("Cannot inject members into raw type java.util.Set");
+  }
+
+  @Test
+  public void staticFieldInjection() {
     JavaFileObject injected =
         JavaFileObjects.forSourceLines(
             "test.Injected",
