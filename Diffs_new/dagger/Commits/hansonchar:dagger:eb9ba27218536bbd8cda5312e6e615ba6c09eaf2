diff --git a/WORKSPACE b/WORKSPACE
index daec64fdd..ac4dfc3da 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -61,14 +61,14 @@ maven_jar(
 
 maven_jar(
     name = "com_google_errorprone_javac",
-    artifact = "com.google.errorprone:javac:9-dev-r3297-1-shaded",
-    sha1 = "0f6d4998965282068a3feecddc21578d23f17275",
+    artifact = "com.google.errorprone:javac-shaded:9-dev-r4023-3",
+    sha1 = "72b688efd290280a0afde5f9892b0fde6f362d1d",
 )
 
 maven_jar(
     name = "com_google_googlejavaformat_google_java_format",
-    artifact = "com.google.googlejavaformat:google-java-format:1.3",
-    sha1 = "949e85e75b3160ce1446aa99d806d5b509631b02",
+    artifact = "com.google.googlejavaformat:google-java-format:1.4",
+    sha1 = "c2f8925850e17caa6da0ed1891a9e9de9414c062",
 )
 
 maven_jar(
diff --git a/java/dagger/internal/MapBuilder.java b/java/dagger/internal/MapBuilder.java
new file mode 100644
index 000000000..1560491b1
--- /dev/null
+++ b/java/dagger/internal/MapBuilder.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+
+import java.util.Collections;
+import java.util.Map;
+
+/**
+ * A fluent builder class that returns a {@link Map}. Used in component implementations where a map
+ * must be created in one fluent statement for inlined request fulfillments.
+ */
+public final class MapBuilder<K, V> {
+  private final Map<K, V> contributions;
+
+  private MapBuilder(int size) {
+    contributions = newLinkedHashMapWithExpectedSize(size);
+  }
+
+  /**
+   * Creates a new {@link MapBuilder} with {@code size} elements.
+   */
+  public static <K, V> MapBuilder<K, V> newMapBuilder(int size) {
+    return new MapBuilder<>(size);
+  }
+
+  public MapBuilder<K, V> put(K key, V value) {
+    contributions.put(key, value);
+    return this;
+  }
+
+  public Map<K, V> build() {
+    switch (contributions.size()) {
+      case 0:
+        return Collections.emptyMap();
+      default:
+        return Collections.unmodifiableMap(contributions);
+    }
+  }
+}
diff --git a/java/dagger/internal/MapFactory.java b/java/dagger/internal/MapFactory.java
index d4b918924..b6f925a98 100644
--- a/java/dagger/internal/MapFactory.java
+++ b/java/dagger/internal/MapFactory.java
@@ -17,8 +17,11 @@
 package dagger.internal;
 
 import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.Preconditions.checkNotNull;
 import static java.util.Collections.unmodifiableMap;
 
+import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.inject.Provider;
@@ -32,18 +35,28 @@
  *
  */
 public final class MapFactory<K, V> implements Factory<Map<K, V>> {
+  private static final Provider<Map<Object, Object>> EMPTY =
+      InstanceFactory.create(Collections.emptyMap());
+
   private final Map<K, Provider<V>> contributingMap;
 
-  private MapFactory(Map<K, Provider<V>> map) {
-    this.contributingMap = unmodifiableMap(map);
+  /**
+   * Returns a new {@link Builder}
+   */
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<>(size);
   }
 
   /**
-   * Returns a new MapFactory.
+   * Returns a factory of an empty map.
    */
-  public static <K, V> MapFactory<K, V> create(Provider<Map<K, Provider<V>>> mapProviderFactory) {
-    Map<K, Provider<V>> map = mapProviderFactory.get();
-    return new MapFactory<K, V>(map);
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> Provider<Map<K, V>> emptyMapProvider() {
+    return (Provider<Map<K, V>>) (Provider) EMPTY;
+  }
+
+  private MapFactory(Map<K, Provider<V>> map) {
+    this.contributingMap = unmodifiableMap(map);
   }
 
   /**
@@ -58,4 +71,25 @@ private MapFactory(Map<K, Provider<V>> map) {
     }
     return unmodifiableMap(result);
   }
+
+  // TODO(ronshapiro): can we merge the builders? Or maybe just use a (Immutable)MapBuilder?
+  /** A builder for {@link MapFactory}. */
+  public static final class Builder<K, V> {
+    private final LinkedHashMap<K, Provider<V>> map;
+
+    private Builder(int size) {
+      this.map = newLinkedHashMapWithExpectedSize(size);
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
+      return this;
+    }
+
+    /** Returns a new {@link MapProviderFactory}. */
+    public MapFactory<K, V> build() {
+      return new MapFactory<>(map);
+    }
+  }
 }
diff --git a/java/dagger/internal/MapProviderFactory.java b/java/dagger/internal/MapProviderFactory.java
index c27beb222..2458a3c05 100644
--- a/java/dagger/internal/MapProviderFactory.java
+++ b/java/dagger/internal/MapProviderFactory.java
@@ -17,10 +17,10 @@
 package dagger.internal;
 
 import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.Preconditions.checkNotNull;
 import static java.util.Collections.unmodifiableMap;
 
 import dagger.Lazy;
-import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import javax.inject.Provider;
@@ -34,24 +34,13 @@
  */
 public final class MapProviderFactory<K, V>
     implements Factory<Map<K, Provider<V>>>, Lazy<Map<K, Provider<V>>> {
-  private static final MapProviderFactory<Object, Object> EMPTY =
-      new MapProviderFactory<Object, Object>(Collections.<Object, Provider<Object>>emptyMap());
-
   private final Map<K, Provider<V>> contributingMap;
 
   /**
    * Returns a new {@link Builder}
    */
   public static <K, V> Builder<K, V> builder(int size) {
-    return new Builder<K, V>(size);
-  }
-
-  /**
-   * Returns a factory of an empty map.
-   */
-  @SuppressWarnings("unchecked") // safe contravariant cast
-  public static <K, V> MapProviderFactory<K, V> empty() {
-    return (MapProviderFactory<K, V>) EMPTY;
+    return new Builder<>(size);
   }
 
   private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
@@ -68,37 +57,23 @@ private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
     return this.contributingMap;
   }
 
-  /**
-   * A builder to help build the {@link MapProviderFactory}
-   */
+  /** A builder for {@link MapProviderFactory}. */
   public static final class Builder<K, V> {
-    private final LinkedHashMap<K, Provider<V>> mapBuilder;
+    private final LinkedHashMap<K, Provider<V>> map;
 
     private Builder(int size) {
-      // TODO(user): consider which way to initialize mapBuilder is better
-      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
+      this.map = newLinkedHashMapWithExpectedSize(size);
     }
 
-    /**
-     * Returns a new {@link MapProviderFactory}
-     */
-    public MapProviderFactory<K, V> build() {
-      return new MapProviderFactory<K, V>(this.mapBuilder);
-    }
-
-    /**
-     * Associate k with providerOfValue in {@code Builder}
-     */
+    /** Associates {@code key} with {@code providerOfValue}. */
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
-      if (key == null) {
-        throw new NullPointerException("The key is null");
-      }
-      if (providerOfValue == null) {
-        throw new NullPointerException("The provider of the value is null");
-      }
-
-      this.mapBuilder.put(key, providerOfValue);
+      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
       return this;
     }
+
+    /** Returns a new {@link MapProviderFactory}. */
+    public MapProviderFactory<K, V> build() {
+      return new MapProviderFactory<>(map);
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index f760fec5d..f56b83f07 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -19,44 +19,24 @@
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.BindingType.PRODUCTION;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MemberSelect.localField;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scope.reusableScope;
-import static dagger.internal.codegen.SourceFiles.frameworkMapFactoryClassName;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
-import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
-import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
-import static dagger.internal.codegen.TypeNames.listenableFutureOf;
-import static dagger.internal.codegen.TypeNames.producerOf;
-import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.internal.codegen.Util.toImmutableList;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.auto.common.MoreElements;
@@ -74,28 +54,19 @@
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
-import dagger.internal.InstanceFactory;
-import dagger.internal.TypedReleasableReferenceManagerDecorator;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.InjectionMethods.InjectionSiteMethod;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.EnumSet;
-import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
@@ -186,7 +157,8 @@
             this,
             childComponentNames(keyFactory, subcomponentNames),
             graph,
-            elements);
+            elements,
+            optionalFactories);
     this.componentRequirementFieldFactory =
         new ComponentRequirementField.Factory(this, componentFieldNames, name, builderFields);
   }
@@ -243,11 +215,18 @@ public void addField(FieldSpec fieldSpec) {
     component.addField(fieldSpec);
   }
 
-  /**
-   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
-   * object for a scope.
-   */
-  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+  @Override
+  public void addType(TypeSpec typeSpec) {
+    component.addType(typeSpec);
+  }
+
+  @Override
+  public String getSubcomponentName(ComponentDescriptor subcomponentDescriptor) {
+    return checkNotNull(subcomponentNames.get(subcomponentDescriptor));
+  }
+
+  @Override
+  public CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
     return referenceReleasingProviderManagerFields.get(scope).getExpressionFor(name);
   }
 
@@ -386,14 +365,6 @@ private void createComponentRequirementFields() {
         .forEach(componentRequirementFields::add);
   }
 
-  private boolean useRawType(Binding binding) {
-    return useRawType(binding.bindingPackage());
-  }
-
-  private boolean useRawType(Optional<String> bindingPackage) {
-    return bindingPackage.isPresent() && !bindingPackage.get().equals(name.packageName());
-  }
-
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethodSignatures = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -519,47 +490,6 @@ private void writeInitializeAndInterfaceMethods() {
     component.addMethods(interfaceMethods);
   }
 
-  @Override
-  public CodeBlock getFieldInitialization(FrameworkInstanceBindingExpression bindingExpression) {
-    if (bindingExpression.isProducerFromProvider()) {
-      return bindingExpressions.getDependencyExpression(
-          FrameworkDependency.create(bindingExpression.bindingKey(), PRODUCTION), name);
-    }
-
-    switch (bindingExpression.bindingKey().kind()) {
-      case CONTRIBUTION:
-        return contributionBindingInitialization(bindingExpression);
-      case MEMBERS_INJECTION:
-        return membersInjectionBindingInitialization(bindingExpression);
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private CodeBlock contributionBindingInitialization(
-      FrameworkInstanceBindingExpression bindingExpression) {
-    ContributionBinding binding =
-        graph.resolvedBindings().get(bindingExpression.bindingKey()).contributionBinding();
-    switch (binding.factoryCreationStrategy()) {
-      case DELEGATE:
-        CodeBlock delegatingCodeBlock =
-            CodeBlock.of(
-                "($T) $L",
-                binding.bindingType().frameworkClass(),
-                bindingExpressions.getDependencyExpression(
-                    getOnlyElement(binding.frameworkDependencies()), name));
-        return decorateForScope(delegatingCodeBlock, binding.scope());
-      case SINGLETON_INSTANCE:
-        checkState(binding.scope().isPresent());
-        // fall through
-      case CLASS_CONSTRUCTOR:
-        return factoryForContributionBindingInitialization(binding);
-
-      default:
-        throw new AssertionError();
-    }
-  }
-
   private void writeMembersInjectionMethods() {
     component.addMethods(membersInjectionMethods.values());
   }
@@ -619,233 +549,9 @@ private MethodSpec membersInjectionMethod(Key key) {
     throw new IllegalArgumentException(binding.key().toString());
   }
 
-  private CodeBlock membersInjectionBindingInitialization(
-      FrameworkInstanceBindingExpression bindingExpression) {
-    BindingKey bindingKey = bindingExpression.bindingKey();
-    MembersInjectionBinding binding =
-        graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
-    checkState(!binding.injectionSites().isEmpty());
-    return membersInjectorForBindingInitialization(binding);
-  }
-
-  private FrameworkInstanceBindingExpression getProducerFromProviderBindingExpression(
-      FrameworkDependency frameworkDependency) {
-    checkState(isProducerFromProvider(frameworkDependency));
-    return producerFromProviderBindingExpressions.computeIfAbsent(
-        frameworkDependency.bindingKey(),
-        dependencyKey ->
-            bindingExpressionFactory.forProducerFromProviderField(
-                graph.resolvedBindings().get(dependencyKey)));
-  }
-
-  private boolean isProducerFromProvider(FrameworkDependency frameworkDependency) {
-    ResolvedBindings resolvedBindings =
-        graph.resolvedBindings().get(frameworkDependency.bindingKey());
-    return resolvedBindings.frameworkClass().equals(Provider.class)
-        && frameworkDependency.frameworkClass().equals(Producer.class);
-  }
-
-  private CodeBlock factoryForContributionBindingInitialization(ContributionBinding binding) {
-    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
-    switch (binding.bindingKind()) {
-      case COMPONENT:
-        // This bindingKeyTypeName type parameter can be removed when we drop java 7 source support
-        return CodeBlock.of("$T.<$T>create(this)", INSTANCE_FACTORY, bindingKeyTypeName);
-
-      case COMPONENT_DEPENDENCY:
-        return CodeBlock.of(
-            "$T.create($L)",
-            INSTANCE_FACTORY,
-            componentRequirementFields.getExpressionDuringInitialization(
-                ComponentRequirement.forDependency(binding.key().type()), name));
-
-      case COMPONENT_PROVISION:
-        {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          String dependencyVariable = simpleVariableName(dependencyType);
-          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
-          // TODO(sameb): The Provider.get() throws a very vague NPE.  The stack trace doesn't
-          // help to figure out what the method or return type is.  If we include a string
-          // of the return type or method name in the error message, that can defeat obfuscation.
-          // We can easily include the raw type (no generics) + annotation type (no values),
-          // using .class & String.format -- but that wouldn't be the whole story.
-          // What should we do?
-          CodeBlock invocation =
-              ComponentProvisionBindingExpression.maybeCheckForNull(
-                  (ProvisionBinding) binding,
-                  compilerOptions,
-                  CodeBlock.of("$L.$L()", dependencyVariable, componentMethod));
-          ClassName dependencyClassName = ClassName.get(dependencyType);
-          String factoryName =
-              dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
-          MethodSpec.Builder getMethod =
-              methodBuilder("get")
-                  .addAnnotation(Override.class)
-                  .addModifiers(PUBLIC)
-                  .returns(bindingKeyTypeName)
-                  .addStatement("return $L", invocation);
-          if (binding.nullableType().isPresent()) {
-            getMethod.addAnnotation(
-                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
-          }
-          component.addType(
-              TypeSpec.classBuilder(factoryName)
-                  .addSuperinterface(providerOf(bindingKeyTypeName))
-                  .addModifiers(PRIVATE, STATIC)
-                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
-                  .addMethod(
-                      constructorBuilder()
-                          .addParameter(dependencyClassName, dependencyVariable)
-                          .addStatement("this.$1L = $1L", dependencyVariable)
-                          .build())
-                  .addMethod(getMethod.build())
-                  .build());
-          return CodeBlock.of(
-              "new $L($L)",
-              factoryName,
-              componentRequirementFields.getExpressionDuringInitialization(
-                  ComponentRequirement.forDependency(dependencyType.asType()), name));
-        }
-
-      case SUBCOMPONENT_BUILDER:
-        String subcomponentName =
-            subcomponentNames.get(
-                graph
-                    .componentDescriptor()
-                    .subcomponentsByBuilderType()
-                    .get(MoreTypes.asTypeElement(binding.key().type())));
-        return CodeBlock.of(
-            "$L",
-            anonymousClassBuilder("")
-                .superclass(providerOf(bindingKeyTypeName))
-                .addMethod(
-                    methodBuilder("get")
-                        .addAnnotation(Override.class)
-                        .addModifiers(PUBLIC)
-                        .returns(bindingKeyTypeName)
-                        .addStatement("return new $LBuilder()", subcomponentName)
-                        .build())
-                .build());
-
-      case BUILDER_BINDING:
-        return CodeBlock.of(
-            "$T.$L($L)",
-            InstanceFactory.class,
-            binding.nullableType().isPresent() ? "createNullable" : "create",
-            componentRequirementFields.getExpressionDuringInitialization(
-                ComponentRequirement.forBinding(binding), name));
-
-      case INJECTION:
-      case PROVISION:
-        {
-          List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(
-                componentRequirementFields.getExpressionDuringInitialization(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
-                    name));
-          }
-          arguments.addAll(getDependencyArguments(binding));
-
-          CodeBlock factoryCreate =
-              CodeBlock.of(
-                  "$T.create($L)",
-                  generatedClassNameForBinding(binding),
-                  makeParametersCodeBlock(arguments));
-
-          // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
-          // type properly, so cast to a raw framework type before scoping.
-          if (binding.bindingKind().equals(INJECTION)
-              && binding.unresolved().isPresent()
-              && binding.scope().isPresent()) {
-            factoryCreate =
-                CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
-          }
-          return decorateForScope(factoryCreate, binding.scope());
-        }
-
-      case COMPONENT_PRODUCTION:
-        {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          FieldSpec dependencyField =
-              FieldSpec.builder(
-                      ClassName.get(dependencyType),
-                      simpleVariableName(dependencyType),
-                      PRIVATE,
-                      FINAL)
-                  .initializer(
-                      componentRequirementFields.getExpressionDuringInitialization(
-                          ComponentRequirement.forDependency(dependencyType.asType()), name))
-                  .build();
-          return CodeBlock.of(
-              "$L",
-              anonymousClassBuilder("")
-                  .superclass(producerOf(bindingKeyTypeName))
-                  .addField(dependencyField)
-                  .addMethod(
-                      methodBuilder("get")
-                          .addAnnotation(Override.class)
-                          .addModifiers(PUBLIC)
-                          .returns(listenableFutureOf(bindingKeyTypeName))
-                          .addStatement(
-                              "return $N.$L()",
-                              dependencyField,
-                              binding.bindingElement().get().getSimpleName())
-                          .build())
-                  .build());
-        }
-
-      case PRODUCTION:
-        {
-          List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(
-                componentRequirementFields.getExpressionDuringInitialization(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
-                    name));
-          }
-          arguments.addAll(getDependencyArguments(binding));
-
-          return CodeBlock.of(
-              "new $T($L)",
-              generatedClassNameForBinding(binding),
-              makeParametersCodeBlock(arguments));
-        }
-
-      case SYNTHETIC_MAP:
-        FrameworkDependency frameworkDependency = getOnlyElement(binding.frameworkDependencies());
-        return CodeBlock.of(
-            "$T.create($L)",
-            mapFactoryClassName(binding),
-            bindingExpressions.getDependencyExpression(frameworkDependency, name));
-
-      case SYNTHETIC_MULTIBOUND_SET:
-        return factoryForSetMultibindingInitialization(binding);
-
-      case SYNTHETIC_MULTIBOUND_MAP:
-        return factoryForMapMultibindingInitialization(binding);
-
-      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
-        return factoryForSyntheticReleasableReferenceManagerBindingInitialization(binding);
-
-      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
-        return factoryForSyntheticSetOfReleasableReferenceManagersInitialization(binding);
-
-      case SYNTHETIC_OPTIONAL_BINDING:
-        return factoryForSyntheticOptionalBindingInitialization(binding);
-
-      default:
-        throw new AssertionError(binding);
-    }
-  }
-
-  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
-    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
-  }
-
-  private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
+  // TODO(user): Pull this out into a separate Scoper object or move to field initializer?
+  @Override
+  public CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
     if (!maybeScope.isPresent()) {
       return factoryCreate;
     }
@@ -864,247 +570,34 @@ private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> mayb
     }
   }
 
-  private CodeBlock membersInjectorForBindingInitialization(MembersInjectionBinding binding) {
-    return binding.injectionSites().isEmpty()
-        ? CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS)
-        : CodeBlock.of(
-            "$T.create($L)",
-            membersInjectorNameForType(binding.membersInjectedType()),
-            makeParametersCodeBlock(getDependencyArguments(binding)));
-  }
-
-  /**
-   * The expressions that represent factory arguments for the dependencies of a binding.
-   */
-  private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
+  @Override
+  public ImmutableList<CodeBlock> getBindingDependencyExpressions(Binding binding) {
     ImmutableList<FrameworkDependency> dependencies = binding.frameworkDependencies();
-    return dependencies.stream().map(this::getDependencyArgument).collect(toImmutableList());
+    return dependencies.stream().map(this::getDependencyExpression).collect(toImmutableList());
   }
 
-  /** Returns the expression to use as an argument for a dependency. */
-  private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
+  @Override
+  public CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency) {
     return isProducerFromProvider(frameworkDependency)
         ? getProducerFromProviderBindingExpression(frameworkDependency)
             .getDependencyExpression(frameworkDependency.dependencyRequestKind(), name)
         : bindingExpressions.getDependencyExpression(frameworkDependency, name);
   }
 
-  private CodeBlock factoryForSetMultibindingInitialization(ContributionBinding binding) {
-    CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
-    boolean useRawTypes = useRawType(binding);
-    if (!useRawTypes) {
-      SetType setType = SetType.from(binding.key());
-      builder.add(
-          "<$T>",
-          setType.elementsAreTypeOf(Produced.class)
-              ? setType.unwrappedElementType(Produced.class)
-              : setType.elementType());
-    }
-    int individualProviders = 0;
-    int setProviders = 0;
-    CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
-      ContributionType contributionType =
-          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
-      String methodName;
-      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
-      switch (contributionType) {
-        case SET:
-          individualProviders++;
-          methodName = "add" + methodNameSuffix;
-          break;
-        case SET_VALUES:
-          setProviders++;
-          methodName = "addCollection" + methodNameSuffix;
-          break;
-        default:
-          throw new AssertionError(frameworkDependency + " is not a set multibinding");
-      }
-
-      builderMethodCalls.add(
-          ".$L($L)",
-          methodName,
-          potentiallyCast(
-              useRawTypes,
-              frameworkDependency.frameworkClass(),
-              getDependencyArgument(frameworkDependency)));
-    }
-    builder.add("builder($L, $L)", individualProviders, setProviders);
-    builder.add(builderMethodCalls.build());
-    return builder.add(".build()").build();
-  }
-
-  private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding binding) {
-    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
-
-    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    MapType mapType = MapType.from(binding.key().type());
-    CodeBlock.Builder builderCall =
-        CodeBlock.builder().add("$T.", frameworkMapFactoryClassName(binding.bindingType()));
-    boolean useRawTypes = useRawType(binding);
-    if (!useRawTypes) {
-      builderCall.add(
-          "<$T, $T>",
-          mapType.keyType(),
-          mapType.unwrappedValueType(binding.bindingType().frameworkClass()));
-    }
-    builderCall.add("builder($L)", frameworkDependencies.size());
-    codeBlocks.add(builderCall.build());
-
-    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
-      BindingKey bindingKey = frameworkDependency.bindingKey();
-      ContributionBinding contributionBinding =
-          graph.resolvedBindings().get(bindingKey).contributionBinding();
-      CodeBlock value =
-          potentiallyCast(
-              useRawTypes,
-              frameworkDependency.frameworkClass(),
-              getDependencyArgument(frameworkDependency));
-      codeBlocks.add(
-          CodeBlock.of(
-              ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
-    }
-    codeBlocks.add(CodeBlock.of(".build()"));
-
-    return CodeBlocks.concat(codeBlocks.build());
-  }
-
-  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
-    if (!shouldCast) {
-      return notCasted;
-    }
-    return CodeBlock.of("($T) $L", classToCast, notCasted);
-  }
-
-  /**
-   * Initializes the factory for a {@link
-   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
-   *
-   * <p>The {@code get()} method just returns the component field with the {@link
-   * dagger.internal.ReferenceReleasingProviderManager} object.
-   */
-  private CodeBlock factoryForSyntheticReleasableReferenceManagerBindingInitialization(
-      ContributionBinding binding) {
-    // The scope is the value of the @ForReleasableReferences annotation.
-    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
-
-    CodeBlock managerExpression;
-    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
-      /* The key's type is TypedReleasableReferenceManager<M>, so return
-       * new TypedReleasableReferenceManager(field, metadata). */
-      TypeMirror metadataType =
-          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
-      managerExpression =
-          typedReleasableReferenceManagerDecoratorExpression(
-              getReferenceReleasingProviderManagerExpression(scope),
-              scope.releasableReferencesMetadata(metadataType).get());
-    } else {
-      // The key's type is ReleasableReferenceManager, so return the field as is.
-      managerExpression = getReferenceReleasingProviderManagerExpression(scope);
-    }
-
-    TypeName keyType = TypeName.get(binding.key().type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyType))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyType)
-                    .addCode("return $L;", managerExpression)
-                    .build())
-            .build());
-  }
-
-  /**
-   * Initializes the factory for a {@link
-   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
-   *
-   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
-   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
-   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
-   */
-  private CodeBlock factoryForSyntheticSetOfReleasableReferenceManagersInitialization(
-      ContributionBinding binding) {
-    Key key = binding.key();
-    SetType keyType = SetType.from(key);
-    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
-    for (Map.Entry<Scope, MemberSelect> entry :
-        referenceReleasingProviderManagerFields.entrySet()) {
-      Scope scope = entry.getKey();
-      CodeBlock releasableReferenceManagerExpression = entry.getValue().getExpressionFor(name);
-
-      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
-        managerExpressions.add(releasableReferenceManagerExpression);
-      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
-        TypeMirror metadataType =
-            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
-        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
-        if (metadata.isPresent()) {
-          managerExpressions.add(
-              typedReleasableReferenceManagerDecoratorExpression(
-                  releasableReferenceManagerExpression, metadata.get()));
-        }
-      } else {
-        throw new IllegalArgumentException("inappropriate key: " + binding);
-      }
-    }
-    TypeName keyTypeName = TypeName.get(key.type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyTypeName))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyTypeName)
-                    .addCode(
-                        "return new $T($T.asList($L));",
-                        HashSet.class,
-                        Arrays.class,
-                        makeParametersCodeBlock(managerExpressions.build()))
-                    .build())
-            .build());
-  }
-
-  /**
-   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
-   * decorates the {@code managerExpression} to supply {@code metadata}.
-   */
-  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
-      CodeBlock managerExpression, AnnotationMirror metadata) {
-    return CodeBlock.of(
-        "new $T<$T>($L, $L)",
-        TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
-        metadata.getAnnotationType(),
-        managerExpression,
-        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
-  }
-
-  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
-    checkArgument(
-        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
-    return Scope.scope(
-        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
+  private FrameworkInstanceBindingExpression getProducerFromProviderBindingExpression(
+      FrameworkDependency frameworkDependency) {
+    checkState(isProducerFromProvider(frameworkDependency));
+    return producerFromProviderBindingExpressions.computeIfAbsent(
+        frameworkDependency.bindingKey(),
+        dependencyKey ->
+            bindingExpressionFactory.forProducerFromProviderField(
+                graph.resolvedBindings().get(dependencyKey)));
   }
 
-  /**
-   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
-   * binding.
-   */
-  private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionBinding binding) {
-    if (binding.explicitDependencies().isEmpty()) {
-      verify(
-          binding.bindingType().equals(BindingType.PROVISION),
-          "Absent optional bindings should be provisions: %s",
-          binding);
-      return optionalFactories.absentOptionalProvider(binding);
-    } else {
-      return optionalFactories.presentOptionalFactory(
-          binding, getOnlyElement(getDependencyArguments(binding)));
-    }
+  private boolean isProducerFromProvider(FrameworkDependency frameworkDependency) {
+    ResolvedBindings resolvedBindings =
+        graph.resolvedBindings().get(frameworkDependency.bindingKey());
+    return resolvedBindings.frameworkClass().equals(Provider.class)
+        && frameworkDependency.frameworkClass().equals(Producer.class);
   }
 }
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 97b5b358e..06c8e6483 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -32,16 +32,22 @@
 
 /** A factory of code expressions used to access a single binding in a component. */
 abstract class BindingExpression {
-  // TODO(dpb): Put the Binding or ResolvedBindings itself here.
-  private final BindingKey bindingKey;
+  private final ResolvedBindings resolvedBindings;
+  private final ClassName componentName;
 
-  BindingExpression(BindingKey bindingKey) {
-    this.bindingKey = checkNotNull(bindingKey);
+  BindingExpression(ResolvedBindings resolvedBindings, ClassName componentName) {
+    this.resolvedBindings = checkNotNull(resolvedBindings);
+    this.componentName = checkNotNull(componentName);
   }
 
-  /** The key for which this instance can fulfill requests. */
-  final BindingKey bindingKey() {
-    return bindingKey;
+  /** The binding this instance uses to fulfill requests. */
+  final ResolvedBindings resolvedBindings() {
+    return resolvedBindings;
+  }
+
+  /** The name of the component owning this binding expression. */
+  final ClassName componentName() {
+    return componentName;
   }
 
   /**
@@ -64,6 +70,7 @@ abstract CodeBlock getDependencyExpression(
     private final ImmutableMap<BindingKey, String> subcomponentNames;
     private final BindingGraph graph;
     private final Elements elements;
+    private final OptionalFactories optionalFactories;
 
     Factory(
         CompilerOptions compilerOptions,
@@ -74,7 +81,8 @@ abstract CodeBlock getDependencyExpression(
         GeneratedComponentModel generatedComponentModel,
         ImmutableMap<BindingKey, String> subcomponentNames,
         BindingGraph graph,
-        Elements elements) {
+        Elements elements,
+        OptionalFactories optionalFactories) {
       this.compilerOptions = checkNotNull(compilerOptions);
       this.componentName = checkNotNull(componentName);
       this.componentFieldNames = checkNotNull(componentFieldNames);
@@ -84,6 +92,7 @@ abstract CodeBlock getDependencyExpression(
       this.subcomponentNames = checkNotNull(subcomponentNames);
       this.graph = checkNotNull(graph);
       this.elements = checkNotNull(elements);
+      this.optionalFactories = checkNotNull(optionalFactories);
     }
 
     /** Creates a binding expression for a field. */
@@ -98,10 +107,16 @@ FrameworkInstanceBindingExpression forProducerFromProviderField(
       FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.of(PRODUCER));
       MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
       return producerFromProviderBindingExpression(
-          resolvedBindings.bindingKey(),
+          resolvedBindings,
+          componentName,
           Optional.of(fieldSpec),
           generatedComponentModel,
-          memberSelect);
+          memberSelect,
+          componentBindingExpressions,
+          componentRequirementFields,
+          compilerOptions,
+          graph,
+          optionalFactories);
     }
 
     /** Creates a binding expression for a static method call. */
@@ -146,7 +161,16 @@ private BindingExpression create(
         MemberSelect memberSelect) {
       FrameworkInstanceBindingExpression bindingExpression =
           FrameworkInstanceBindingExpression.create(
-              resolvedBindings, fieldSpec, generatedComponentModel, memberSelect);
+              resolvedBindings,
+              componentName,
+              fieldSpec,
+              generatedComponentModel,
+              memberSelect,
+              componentBindingExpressions,
+              componentRequirementFields,
+              compilerOptions,
+              graph,
+              optionalFactories);
 
       if (!resolvedBindings.bindingType().equals(BindingType.PROVISION)) {
         return bindingExpression;
@@ -174,6 +198,9 @@ private BindingExpression create(
         case SYNTHETIC_MULTIBOUND_SET:
           return new SetBindingExpression(
               provisionBinding, graph, componentBindingExpressions, bindingExpression, elements);
+        case SYNTHETIC_MULTIBOUND_MAP:
+          return new MapBindingExpression(
+              provisionBinding, graph, componentBindingExpressions, bindingExpression, elements);
         case SYNTHETIC_OPTIONAL_BINDING:
           return new OptionalBindingExpression(
               provisionBinding, bindingExpression, componentBindingExpressions);
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 110d08ea0..14b9c7d07 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -35,7 +35,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
-import com.google.common.base.VerifyException;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -519,7 +518,6 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
 
             ImmutableSet.Builder<Optional<ContributionBinding>> maybeContributionBindings =
                 ImmutableSet.builder();
-            maybeContributionBindings.add(syntheticMapOfValuesBinding(requestKey));
             maybeContributionBindings.add(
                 syntheticMultibinding(
                     requestKey, multibindingContributions, multibindingDeclarations));
@@ -585,70 +583,16 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
             owningResolver.componentDescriptor.subcomponentsByBuilderType().get(builderType));
       }
 
-      private Iterable<Key> keysMatchingRequest(Key requestKey) {
+      private ImmutableSet<Key> keysMatchingRequest(Key requestKey) {
         ImmutableSet.Builder<Key> keys = ImmutableSet.builder();
         keys.add(requestKey);
         keyFactory.unwrapSetKey(requestKey, Produced.class).ifPresent(keys::add);
         keyFactory.rewrapMapKey(requestKey, Producer.class, Provider.class).ifPresent(keys::add);
         keyFactory.rewrapMapKey(requestKey, Provider.class, Producer.class).ifPresent(keys::add);
+        keys.addAll(keyFactory.implicitFrameworkMapKeys(requestKey));
         return keys.build();
       }
 
-      /**
-       * If {@code key} is a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, and there are any
-       * multibinding contributions or declarations that apply to that map, returns a synthetic
-       * binding for the {@code key} that depends on an {@linkplain #syntheticMultibinding(Key,
-       * Iterable, Iterable) underlying synthetic multibinding}.
-       *
-       * <p>The returned binding has the same {@link BindingType} as the underlying synthetic
-       * multibinding.
-       */
-      private Optional<ContributionBinding> syntheticMapOfValuesBinding(final Key key) {
-        return syntheticMultibinding(
-                key,
-                multibindingContributionsForValueMap(key),
-                multibindingDeclarationsForValueMap(key))
-            .map(
-                syntheticMultibinding -> {
-                  switch (syntheticMultibinding.bindingType()) {
-                    case PROVISION:
-                      return provisionBindingFactory.syntheticMapOfValuesBinding(key);
-
-                    case PRODUCTION:
-                      return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(key);
-
-                    default:
-                      throw new VerifyException(syntheticMultibinding.toString());
-                  }
-                });
-      }
-
-      /**
-       * If {@code key} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
-       * multibinding contributions whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
-       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
-       */
-      private ImmutableSet<ContributionBinding> multibindingContributionsForValueMap(Key key) {
-        return keyFactory
-            .implicitFrameworkMapKeys(key)
-            .stream()
-            .flatMap(mapKey -> getExplicitMultibindings(mapKey).stream())
-            .collect(toImmutableSet());
-      }
-
-      /**
-       * If {@code key} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
-       * multibinding declarations whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
-       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
-       */
-      private ImmutableSet<MultibindingDeclaration> multibindingDeclarationsForValueMap(Key key) {
-        return keyFactory
-            .implicitFrameworkMapKeys(key)
-            .stream()
-            .flatMap(mapKey -> getMultibindingDeclarations(mapKey).stream())
-            .collect(toImmutableSet());
-      }
-
       /**
        * Returns a synthetic binding that depends on individual multibinding contributions.
        *
@@ -1165,7 +1109,9 @@ private boolean hasLocalMultibindingContributions(ResolvedBindings resolvedBindi
                   .stream()
                   .map(ContributionBinding::bindingKind)
                   .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)
-              && !getLocalExplicitMultibindings(resolvedBindings.key()).isEmpty();
+              && keysMatchingRequest(resolvedBindings.key())
+                  .stream()
+                  .anyMatch(key -> !getLocalExplicitMultibindings(key).isEmpty());
         }
 
         /**
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 1bbcbdc55..32143d089 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -30,7 +30,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
@@ -994,8 +993,7 @@ private void reportDuplicateBindings() {
             .stream()
             .map(ContributionBinding::bindingKind)
             // TODO(dpb): Kill with fire.
-            .anyMatch(
-                kind -> SYNTHETIC_MULTIBOUND_KINDS.contains(kind) || SYNTHETIC_MAP.equals(kind))) {
+            .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)) {
           reportMultipleContributionTypes();
           return;
         }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 8e45306ac..b49076575 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -115,7 +115,9 @@ private BindingExpression getBindingExpression(BindingKey bindingKey) {
 
   /** Adds a binding expression for a single binding owned by this component. */
   void addBindingExpression(BindingExpression bindingExpression) {
-    bindingExpressionsMaps.get(0).put(bindingExpression.bindingKey(), bindingExpression);
+    bindingExpressionsMaps
+        .get(0)
+        .put(bindingExpression.resolvedBindings().bindingKey(), bindingExpression);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 529d17537..0797433f8 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -216,7 +216,7 @@ protected void addFactoryMethods() {
               : "build";
       component.addMethod(
           methodBuilder("create")
-              .returns(componentDefinitionTypeName())
+              .returns(ClassName.get(graph.componentType()))
               .addModifiers(PUBLIC, STATIC)
               .addStatement("return new Builder().$L()", buildMethodName)
               .build());
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 8891e67d1..670675768 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -72,12 +72,6 @@
    * of contribution.
    */
   enum Kind {
-    /**
-     * The synthetic binding for {@code Map<K, V>} that depends on either
-     * {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}.
-     */
-    SYNTHETIC_MAP,
-
     /**
      * A synthetic binding for a multibound set that depends on the individual multibinding
      * {@link Provides @Provides} or {@link Produces @Produces} methods.
diff --git a/java/dagger/internal/codegen/DependencyRequest.java b/java/dagger/internal/codegen/DependencyRequest.java
index bbd899acd..06ab062ae 100644
--- a/java/dagger/internal/codegen/DependencyRequest.java
+++ b/java/dagger/internal/codegen/DependencyRequest.java
@@ -340,27 +340,49 @@ DependencyRequest producerForImplicitMapBinding(Key mapOfFactoryKey) {
       return DependencyRequest.builder().kind(Kind.PRODUCER).key(mapOfFactoryKey).build();
     }
 
+    /**
+     * Creates synthetic dependency requests for each individual multibinding contribution in {@code
+     * multibindingContributions}.
+     */
+    ImmutableSet<DependencyRequest> forMultibindingContributions(
+        Key multibindingKey, Iterable<ContributionBinding> multibindingContributions) {
+      ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
+      for (ContributionBinding multibindingContribution : multibindingContributions) {
+        requests.add(forMultibindingContribution(multibindingKey, multibindingContribution));
+      }
+      return requests.build();
+    }
+
     /**
      * Creates a synthetic dependency request for one individual {@code multibindingContribution}.
      */
     private DependencyRequest forMultibindingContribution(
-        ContributionBinding multibindingContribution) {
+        Key multibindingKey, ContributionBinding multibindingContribution) {
       checkArgument(
           multibindingContribution.key().multibindingContributionIdentifier().isPresent(),
           "multibindingContribution's key must have a multibinding contribution identifier: %s",
           multibindingContribution);
       return DependencyRequest.builder()
-          .kind(multibindingContributionRequestKind(multibindingContribution))
+          .kind(multibindingContributionRequestKind(multibindingKey, multibindingContribution))
           .key(multibindingContribution.key())
           .build();
     }
 
-    private Kind multibindingContributionRequestKind(ContributionBinding multibindingContribution) {
+    // TODO(b/28555349): support PROVIDER_OF_LAZY here too
+    private static final ImmutableSet<Kind> WRAPPING_MAP_VALUE_FRAMEWORK_TYPES =
+        ImmutableSet.of(Kind.PROVIDER, Kind.PRODUCER);
+
+    private Kind multibindingContributionRequestKind(
+        Key multibindingKey, ContributionBinding multibindingContribution) {
       switch (multibindingContribution.contributionType()) {
         case MAP:
-          return multibindingContribution.bindingType().equals(BindingType.PRODUCTION)
-              ? Kind.PRODUCER
-              : Kind.PROVIDER;
+          MapType mapType = MapType.from(multibindingKey);
+          for (Kind kind : WRAPPING_MAP_VALUE_FRAMEWORK_TYPES) {
+            if (mapType.valuesAreTypeOf(kind.frameworkClass.get())) {
+              return kind;
+            }
+          }
+          // fall through
         case SET:
         case SET_VALUES:
           return Kind.INSTANCE;
@@ -372,19 +394,6 @@ private Kind multibindingContributionRequestKind(ContributionBinding multibindin
       }
     }
 
-    /**
-     * Creates synthetic dependency requests for each individual multibinding contribution in {@code
-     * multibindingContributions}.
-     */
-    ImmutableSet<DependencyRequest> forMultibindingContributions(
-        Iterable<ContributionBinding> multibindingContributions) {
-      ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
-      for (ContributionBinding multibindingContribution : multibindingContributions) {
-        requests.add(forMultibindingContribution(multibindingContribution));
-      }
-      return requests.build();
-    }
-
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
       return forRequiredVariable(variableElement, Optional.empty());
     }
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
new file mode 100644
index 000000000..0b22230d0
--- /dev/null
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -0,0 +1,590 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static dagger.internal.codegen.BindingType.PRODUCTION;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
+import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.producerOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.InstanceFactory;
+import dagger.internal.TypedReleasableReferenceManagerDecorator;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Optional;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * An object that can initialize a framework-type component field for a binding. An instance should
+ * be created for every field.
+ */
+final class FrameworkFieldInitializer {
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final ComponentRequirementFields componentRequirementFields;
+  // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
+  private final ResolvedBindings resolvedBindings;
+  private final CompilerOptions compilerOptions;
+  private final boolean isProducerFromProvider;
+  private final BindingGraph graph;
+  private final OptionalFactories optionalFactories;
+  private final ClassName componentName;
+
+  FrameworkFieldInitializer(
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      ResolvedBindings resolvedBindings,
+      CompilerOptions compilerOptions,
+      boolean isProducerFromProvider,
+      BindingGraph graph,
+      OptionalFactories optionalFactories,
+      ClassName componentName) {
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.resolvedBindings = checkNotNull(resolvedBindings);
+    this.compilerOptions = checkNotNull(compilerOptions);
+    this.isProducerFromProvider = isProducerFromProvider;
+    this.graph = checkNotNull(graph);
+    this.optionalFactories = checkNotNull(optionalFactories);
+    this.componentName = checkNotNull(componentName);
+  }
+
+  /** Returns the expression to use to initialize the field. */
+  CodeBlock getFieldInitialization() {
+    if (isProducerFromProvider) {
+      return componentBindingExpressions.getDependencyExpression(
+          FrameworkDependency.create(resolvedBindings.bindingKey(), PRODUCTION), componentName);
+    }
+
+    switch (resolvedBindings.bindingKey().kind()) {
+      case CONTRIBUTION:
+        return contributionBindingInitialization();
+      case MEMBERS_INJECTION:
+        return membersInjectionBindingInitialization();
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private CodeBlock contributionBindingInitialization() {
+    ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+    switch (contributionBinding.factoryCreationStrategy()) {
+      case DELEGATE:
+        CodeBlock delegatingCodeBlock =
+            CodeBlock.of(
+                "($T) $L",
+                contributionBinding.bindingType().frameworkClass(),
+                componentBindingExpressions.getDependencyExpression(
+                    getOnlyElement(contributionBinding.frameworkDependencies()), componentName));
+        return generatedComponentModel.decorateForScope(
+            delegatingCodeBlock, contributionBinding.scope());
+      case SINGLETON_INSTANCE:
+        checkState(contributionBinding.scope().isPresent());
+        // fall through
+      case CLASS_CONSTRUCTOR:
+        return factoryForContributionBindingInitialization(contributionBinding);
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private CodeBlock membersInjectionBindingInitialization() {
+    MembersInjectionBinding membersInjectionBinding =
+        resolvedBindings.membersInjectionBinding().get();
+    return CodeBlock.of(
+        "$T.create($L)",
+        membersInjectorNameForType(membersInjectionBinding.membersInjectedType()),
+        makeParametersCodeBlock(
+            generatedComponentModel.getBindingDependencyExpressions(membersInjectionBinding)));
+  }
+
+  private CodeBlock factoryForContributionBindingInitialization(ContributionBinding binding) {
+    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
+    switch (binding.bindingKind()) {
+      case COMPONENT:
+        // This bindingKeyTypeName type parameter can be removed when we drop java 7 source support
+        return CodeBlock.of("$T.<$T>create(this)", INSTANCE_FACTORY, bindingKeyTypeName);
+
+      case COMPONENT_DEPENDENCY:
+        return CodeBlock.of(
+            "$T.create($L)",
+            INSTANCE_FACTORY,
+            componentRequirementFields.getExpressionDuringInitialization(
+                ComponentRequirement.forDependency(binding.key().type()), componentName));
+
+      case COMPONENT_PROVISION:
+        {
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          String dependencyVariable = simpleVariableName(dependencyType);
+          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
+          // TODO(sameb): The Provider.get() throws a very vague NPE.  The stack trace doesn't
+          // help to figure out what the method or return type is.  If we include a string
+          // of the return type or method name in the error message, that can defeat obfuscation.
+          // We can easily include the raw type (no generics) + annotation type (no values),
+          // using .class & String.format -- but that wouldn't be the whole story.
+          // What should we do?
+          CodeBlock invocation =
+              ComponentProvisionBindingExpression.maybeCheckForNull(
+                  (ProvisionBinding) binding,
+                  compilerOptions,
+                  CodeBlock.of("$L.$L()", dependencyVariable, componentMethod));
+          ClassName dependencyClassName = ClassName.get(dependencyType);
+          String factoryName =
+              dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
+          MethodSpec.Builder getMethod =
+              methodBuilder("get")
+                  .addAnnotation(Override.class)
+                  .addModifiers(PUBLIC)
+                  .returns(bindingKeyTypeName)
+                  .addStatement("return $L", invocation);
+          if (binding.nullableType().isPresent()) {
+            getMethod.addAnnotation(
+                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
+          }
+          generatedComponentModel.addType(
+              TypeSpec.classBuilder(factoryName)
+                  .addSuperinterface(providerOf(bindingKeyTypeName))
+                  .addModifiers(PRIVATE, STATIC)
+                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
+                  .addMethod(
+                      constructorBuilder()
+                          .addParameter(dependencyClassName, dependencyVariable)
+                          .addStatement("this.$1L = $1L", dependencyVariable)
+                          .build())
+                  .addMethod(getMethod.build())
+                  .build());
+          return CodeBlock.of(
+              "new $L($L)",
+              factoryName,
+              componentRequirementFields.getExpressionDuringInitialization(
+                  ComponentRequirement.forDependency(dependencyType.asType()), componentName));
+        }
+
+      case SUBCOMPONENT_BUILDER:
+        String subcomponentName =
+            generatedComponentModel.getSubcomponentName(
+                graph
+                    .componentDescriptor()
+                    .subcomponentsByBuilderType()
+                    .get(MoreTypes.asTypeElement(binding.key().type())));
+        return CodeBlock.of(
+            "$L",
+            anonymousClassBuilder("")
+                .superclass(providerOf(bindingKeyTypeName))
+                .addMethod(
+                    methodBuilder("get")
+                        .addAnnotation(Override.class)
+                        .addModifiers(PUBLIC)
+                        .returns(bindingKeyTypeName)
+                        .addStatement("return new $LBuilder()", subcomponentName)
+                        .build())
+                .build());
+
+      case BUILDER_BINDING:
+        return CodeBlock.of(
+            "$T.$L($L)",
+            InstanceFactory.class,
+            binding.nullableType().isPresent() ? "createNullable" : "create",
+            componentRequirementFields.getExpressionDuringInitialization(
+                ComponentRequirement.forBinding(binding), componentName));
+
+      case INJECTION:
+      case PROVISION:
+        {
+          List<CodeBlock> arguments =
+              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
+          if (binding.requiresModuleInstance()) {
+            arguments.add(
+                componentRequirementFields.getExpressionDuringInitialization(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
+                    componentName));
+          }
+          arguments.addAll(generatedComponentModel.getBindingDependencyExpressions(binding));
+
+          CodeBlock factoryCreate =
+              CodeBlock.of(
+                  "$T.create($L)",
+                  generatedClassNameForBinding(binding),
+                  makeParametersCodeBlock(arguments));
+
+          // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
+          // type properly, so cast to a raw framework type before scoping.
+          if (binding.bindingKind().equals(INJECTION)
+              && binding.unresolved().isPresent()
+              && binding.scope().isPresent()) {
+            factoryCreate =
+                CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
+          }
+          return generatedComponentModel.decorateForScope(factoryCreate, binding.scope());
+        }
+
+      case COMPONENT_PRODUCTION:
+        {
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          FieldSpec dependencyField =
+              FieldSpec.builder(
+                      ClassName.get(dependencyType),
+                      simpleVariableName(dependencyType),
+                      PRIVATE,
+                      FINAL)
+                  .initializer(
+                      componentRequirementFields.getExpressionDuringInitialization(
+                          ComponentRequirement.forDependency(dependencyType.asType()),
+                          componentName))
+                  .build();
+          return CodeBlock.of(
+              "$L",
+              anonymousClassBuilder("")
+                  .superclass(producerOf(bindingKeyTypeName))
+                  .addField(dependencyField)
+                  .addMethod(
+                      methodBuilder("get")
+                          .addAnnotation(Override.class)
+                          .addModifiers(PUBLIC)
+                          .returns(listenableFutureOf(bindingKeyTypeName))
+                          .addStatement(
+                              "return $N.$L()",
+                              dependencyField,
+                              binding.bindingElement().get().getSimpleName())
+                          .build())
+                  .build());
+        }
+
+      case PRODUCTION:
+        {
+          List<CodeBlock> arguments =
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
+          if (binding.requiresModuleInstance()) {
+            arguments.add(
+                componentRequirementFields.getExpressionDuringInitialization(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
+                    componentName));
+          }
+          arguments.addAll(generatedComponentModel.getBindingDependencyExpressions(binding));
+
+          return CodeBlock.of(
+              "new $T($L)",
+              generatedClassNameForBinding(binding),
+              makeParametersCodeBlock(arguments));
+        }
+
+      case SYNTHETIC_MULTIBOUND_SET:
+        return factoryForSetMultibindingInitialization(binding);
+
+      case SYNTHETIC_MULTIBOUND_MAP:
+        return factoryForMapMultibindingInitialization(binding);
+
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
+        return factoryForSyntheticReleasableReferenceManagerBindingInitialization(binding);
+
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
+        return factoryForSyntheticSetOfReleasableReferenceManagersInitialization(binding);
+
+      case SYNTHETIC_OPTIONAL_BINDING:
+        return factoryForSyntheticOptionalBindingInitialization(binding);
+
+      default:
+        throw new AssertionError(binding);
+    }
+  }
+
+  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
+    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
+  }
+
+  private CodeBlock factoryForSetMultibindingInitialization(ContributionBinding binding) {
+    CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
+    boolean useRawTypes = useRawType();
+    if (!useRawTypes) {
+      SetType setType = SetType.from(binding.key());
+      builder.add(
+          "<$T>",
+          setType.elementsAreTypeOf(Produced.class)
+              ? setType.unwrappedElementType(Produced.class)
+              : setType.elementType());
+    }
+    int individualProviders = 0;
+    int setProviders = 0;
+    CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
+      ContributionType contributionType =
+          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
+      String methodName;
+      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
+      switch (contributionType) {
+        case SET:
+          individualProviders++;
+          methodName = "add" + methodNameSuffix;
+          break;
+        case SET_VALUES:
+          setProviders++;
+          methodName = "addCollection" + methodNameSuffix;
+          break;
+        default:
+          throw new AssertionError(frameworkDependency + " is not a set multibinding");
+      }
+
+      builderMethodCalls.add(
+          ".$L($L)",
+          methodName,
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              generatedComponentModel.getDependencyExpression(frameworkDependency)));
+    }
+    builder.add("builder($L, $L)", individualProviders, setProviders);
+    builder.add(builderMethodCalls.build());
+    return builder.add(".build()").build();
+  }
+
+  private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding binding) {
+    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
+
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+    MapType mapType = MapType.from(binding.key().type());
+    CodeBlock.Builder builderCall = CodeBlock.builder().add("$T.", mapFactoryClassName(binding));
+    boolean useRawTypes = useRawType();
+    if (!useRawTypes) {
+      // TODO(ronshapiro): either inline this into mapFactoryClassName, or add a
+      // mapType.unwrappedValueType() method that doesn't require a framework type
+      TypeMirror valueType = mapType.valueType();
+      for (Class<?> frameworkClass :
+          ImmutableSet.of(Provider.class, Producer.class, Produced.class)) {
+        if (mapType.valuesAreTypeOf(frameworkClass)) {
+          valueType = mapType.unwrappedValueType(frameworkClass);
+          break;
+        }
+      }
+      builderCall.add("<$T, $T>", mapType.keyType(), valueType);
+    }
+
+    if (binding.bindingType().equals(BindingType.PROVISION)) {
+      builderCall.add("builder($L)", frameworkDependencies.size());
+    } else {
+      builderCall.add("builder()");
+    }
+    codeBlocks.add(builderCall.build());
+
+    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
+      BindingKey bindingKey = frameworkDependency.bindingKey();
+      ContributionBinding contributionBinding =
+          graph.resolvedBindings().get(bindingKey).contributionBinding();
+      CodeBlock value =
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              generatedComponentModel.getDependencyExpression(frameworkDependency));
+      codeBlocks.add(
+          CodeBlock.of(
+              ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
+    }
+    codeBlocks.add(CodeBlock.of(".build()"));
+
+    return CodeBlocks.concat(codeBlocks.build());
+  }
+
+  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
+    if (!shouldCast) {
+      return notCasted;
+    }
+    return CodeBlock.of("($T) $L", classToCast, notCasted);
+  }
+
+  private boolean useRawType() {
+    Optional<String> bindingPackage = resolvedBindings.binding().bindingPackage();
+    return bindingPackage.isPresent() && !bindingPackage.get().equals(componentName.packageName());
+  }
+
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
+   *
+   * <p>The {@code get()} method just returns the component field with the {@link
+   * dagger.internal.ReferenceReleasingProviderManager} object.
+   */
+  private CodeBlock factoryForSyntheticReleasableReferenceManagerBindingInitialization(
+      ContributionBinding binding) {
+    // The scope is the value of the @ForReleasableReferences annotation.
+    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
+
+    CodeBlock managerExpression;
+    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
+      /* The key's type is TypedReleasableReferenceManager<M>, so return
+       * new TypedReleasableReferenceManager(field, metadata). */
+      TypeMirror metadataType =
+          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
+      managerExpression =
+          typedReleasableReferenceManagerDecoratorExpression(
+              generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope),
+              scope.releasableReferencesMetadata(metadataType).get());
+    } else {
+      // The key's type is ReleasableReferenceManager, so return the field as is.
+      managerExpression =
+          generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope);
+    }
+
+    TypeName keyType = TypeName.get(binding.key().type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyType))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyType)
+                    .addCode("return $L;", managerExpression)
+                    .build())
+            .build());
+  }
+
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
+   *
+   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
+   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
+   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
+   */
+  private CodeBlock factoryForSyntheticSetOfReleasableReferenceManagersInitialization(
+      ContributionBinding binding) {
+    Key key = binding.key();
+    SetType keyType = SetType.from(key);
+    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
+    for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
+      CodeBlock releasableReferenceManagerExpression =
+          generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope);
+
+      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
+        managerExpressions.add(releasableReferenceManagerExpression);
+      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
+        TypeMirror metadataType =
+            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
+        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
+        if (metadata.isPresent()) {
+          managerExpressions.add(
+              typedReleasableReferenceManagerDecoratorExpression(
+                  releasableReferenceManagerExpression, metadata.get()));
+        }
+      } else {
+        throw new IllegalArgumentException("inappropriate key: " + binding);
+      }
+    }
+    TypeName keyTypeName = TypeName.get(key.type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyTypeName))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyTypeName)
+                    .addCode(
+                        "return new $T($T.asList($L));",
+                        HashSet.class,
+                        Arrays.class,
+                        makeParametersCodeBlock(managerExpressions.build()))
+                    .build())
+            .build());
+  }
+
+  /**
+   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
+   * decorates the {@code managerExpression} to supply {@code metadata}.
+   */
+  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
+      CodeBlock managerExpression, AnnotationMirror metadata) {
+    return CodeBlock.of(
+        "new $T<$T>($L, $L)",
+        TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
+        metadata.getAnnotationType(),
+        managerExpression,
+        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
+  }
+
+  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
+    checkArgument(
+        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
+    return Scope.scope(
+        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
+  }
+
+  /**
+   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
+   * binding.
+   */
+  private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionBinding binding) {
+    if (binding.explicitDependencies().isEmpty()) {
+      verify(
+          binding.bindingType().equals(BindingType.PROVISION),
+          "Absent optional bindings should be provisions: %s",
+          binding);
+      return optionalFactories.absentOptionalProvider(binding);
+    } else {
+      return optionalFactories.presentOptionalFactory(
+          binding,
+          getOnlyElement(generatedComponentModel.getBindingDependencyExpressions(binding)));
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 4bf779eeb..00b8d0b7d 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -17,7 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 
 import com.squareup.javapoet.ClassName;
@@ -32,22 +32,40 @@
   private final GeneratedComponentModel generatedComponentModel;
   private final MemberSelect memberSelect;
   private final FrameworkType frameworkType;
-  private final boolean isProducerFromProvider;
+  private final FrameworkFieldInitializer fieldInitializer;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   /** Returns a binding expression for a binding. */
   static FrameworkInstanceBindingExpression create(
       ResolvedBindings resolvedBindings,
+      ClassName componentName,
       Optional<FieldSpec> fieldSpec,
       GeneratedComponentModel generatedComponentModel,
-      MemberSelect memberSelect) {
+      MemberSelect memberSelect,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      CompilerOptions compilerOptions,
+      BindingGraph graph,
+      OptionalFactories optionalFactories) {
     return new FrameworkInstanceBindingExpression(
-        resolvedBindings.bindingKey(),
+        resolvedBindings,
+        componentName,
         fieldSpec,
         generatedComponentModel,
         memberSelect,
         resolvedBindings.bindingType().frameworkType(),
-        false);
+        // TODO(user): When producerFromProvider is moved, this initialization can be moved
+        // to BindingExpression.Factory
+        new FrameworkFieldInitializer(
+            generatedComponentModel,
+            componentBindingExpressions,
+            componentRequirementFields,
+            resolvedBindings,
+            compilerOptions,
+            false,
+            graph,
+            optionalFactories,
+            componentName));
   }
 
   /**
@@ -55,27 +73,51 @@ static FrameworkInstanceBindingExpression create(
    * from a {@link javax.inject.Provider}.
    */
   static FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
-      BindingKey bindingKey,
+      ResolvedBindings resolvedBindings,
+      ClassName componentName,
       Optional<FieldSpec> fieldSpec,
       GeneratedComponentModel generatedComponentModel,
-      MemberSelect memberSelect) {
+      MemberSelect memberSelect,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      CompilerOptions compilerOptions,
+      BindingGraph graph,
+      OptionalFactories optionalFactories) {
     return new FrameworkInstanceBindingExpression(
-        bindingKey, fieldSpec, generatedComponentModel, memberSelect, FrameworkType.PRODUCER, true);
+        resolvedBindings,
+        componentName,
+        fieldSpec,
+        generatedComponentModel,
+        memberSelect,
+        FrameworkType.PRODUCER,
+        // TODO(user): When producerFromProvider is moved, this initialization can be moved
+        // to BindingExpression.Factory
+        new FrameworkFieldInitializer(
+            generatedComponentModel,
+            componentBindingExpressions,
+            componentRequirementFields,
+            resolvedBindings,
+            compilerOptions,
+            true,
+            graph,
+            optionalFactories,
+            componentName));
   }
 
   private FrameworkInstanceBindingExpression(
-      BindingKey bindingKey,
+      ResolvedBindings resolvedBindings,
+      ClassName componentName,
       Optional<FieldSpec> fieldSpec,
       GeneratedComponentModel generatedComponentModel,
       MemberSelect memberSelect,
       FrameworkType frameworkType,
-      boolean isProducerFromProvider) {
-    super(bindingKey);
+      FrameworkFieldInitializer fieldInitializer) {
+    super(resolvedBindings, componentName);
     this.generatedComponentModel = generatedComponentModel;
     this.memberSelect = memberSelect;
     this.fieldSpec = fieldSpec;
     this.frameworkType = frameworkType;
-    this.isProducerFromProvider = isProducerFromProvider;
+    this.fieldInitializer = fieldInitializer;
   }
 
   @Override
@@ -105,11 +147,6 @@ private String fieldName() {
     return fieldSpec.get().name;
   }
 
-  /** Returns true if this binding expression represents a producer from provider. */
-  boolean isProducerFromProvider() {
-    return isProducerFromProvider;
-  }
-
   /**
    * Sets the initialization state for the binding's underlying field. Only valid for field types.
    *
@@ -128,6 +165,7 @@ private void checkHasField() {
   }
 
   // Adds our field and initialization of our field to the component.
+  // TODO(user): Move this to the field initializer class
   private void maybeInitializeField() {
     if (!fieldSpec.isPresent()) {
       return;
@@ -141,7 +179,7 @@ private void maybeInitializeField() {
             CodeBlock.of(
                 "this.$L = $L;",
                 fieldName(),
-                checkNotNull(generatedComponentModel.getFieldInitialization(this)));
+                checkNotNull(fieldInitializer.getFieldInitialization()));
 
         if (fieldInitializationState == InitializationState.DELEGATED) {
           // If we were recursively invoked, set the delegate factory as part of our initialization
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index e21533230..f3b2a7de8 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -16,25 +16,51 @@
 
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Optional;
 
 /** The model of the component being generated. */
 interface GeneratedComponentModel {
 
-  /** Returns the expression used to initialize a binding expression field. */
-  // TODO(user): Move this method onto FrameworkInstanceBindingExpression and subtypes.
-  CodeBlock getFieldInitialization(FrameworkInstanceBindingExpression bindingExpression);
-
   /** Adds the given field to the component. */
   void addField(FieldSpec fieldSpec);
 
   /** Adds the given code block to the initialize methods of the component. */
   void addInitialization(CodeBlock codeBlock);
 
+  /** Adds the given type to the component. */
+  void addType(TypeSpec typeSpec);
+
+  /** Returns the corresponding subcomponent name for the given subcomponent descriptor. */
+  String getSubcomponentName(ComponentDescriptor subcomponentDescriptor);
+
   /**
    * Returns the {@code private} members injection method that injects objects with the {@code key}.
    */
   MethodSpec getMembersInjectionMethod(Key key);
+
+  /**
+   * Maybe wraps the given creation code block in single/double check or reference releasing
+   * providers.
+   */
+  CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope);
+
+  /**
+   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
+   * object for a scope.
+   */
+  CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope);
+
+  // TODO(user): this and getDependencyArguments should go on ComponentBindingExpressions
+  // once producerFromProvider fields are pushed into their corresponding binding expressions.
+  // This cannot be done currently due to these expressions being created lazily.
+  /** Returns a code block referencing the given dependency. */
+  CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency);
+
+  /** Returns a list of code blocks for referencing all of the given binding's dependencies. */
+  ImmutableList<CodeBlock> getBindingDependencyExpressions(Binding binding);
 }
diff --git a/java/dagger/internal/codegen/Key.java b/java/dagger/internal/codegen/Key.java
index 3c4cecc06..4871e4b30 100644
--- a/java/dagger/internal/codegen/Key.java
+++ b/java/dagger/internal/codegen/Key.java
@@ -546,12 +546,15 @@ Key forProductionComponentMonitor() {
     }
 
     /**
-     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
-     * valid key can be inferred from the given key.  Specifically, if the key represents a
-     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
+     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a valid key
+     * can be inferred from the given key. Specifically, if the key represents a {@link Map}{@code
+     * <K, V>} or {@code Map<K, Producer<V>>}, a key of {@code Map<K, Provider<V>>} will be
+     * returned.
      */
     Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
-      return wrapMapKey(possibleMapKey, Provider.class);
+      return firstPresent(
+          rewrapMapKey(possibleMapKey, Produced.class, Provider.class),
+          wrapMapKey(possibleMapKey, Provider.class));
     }
 
     /**
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
new file mode 100644
index 000000000..8e5746c19
--- /dev/null
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.MapBuilder;
+import java.util.Collections;
+import java.util.Map;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/** A {@link BindingExpression} for multibound maps. */
+final class MapBindingExpression extends SimpleInvocationBindingExpression {
+  /** Maximum number of key-value pairs that can be passed to ImmutableMap.of(K, V, K, V, ...). */
+  private static final int MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS = 5;
+
+  private final ProvisionBinding binding;
+  private final ImmutableMap<DependencyRequest, ContributionBinding> dependencies;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final Elements elements;
+
+  MapBindingExpression(
+      ProvisionBinding binding,
+      BindingGraph graph,
+      ComponentBindingExpressions componentBindingExpressions,
+      BindingExpression delegate,
+      Elements elements) {
+    super(delegate);
+    ContributionBinding.Kind bindingKind = binding.bindingKind();
+    checkArgument(bindingKind.equals(SYNTHETIC_MULTIBOUND_MAP), bindingKind);
+    this.binding = binding;
+    this.componentBindingExpressions = componentBindingExpressions;
+    this.elements = elements;
+    this.dependencies =
+        Maps.toMap(
+            binding.dependencies(),
+            dep -> graph.resolvedBindings().get(dep.bindingKey()).contributionBinding());
+  }
+
+  @Override
+  CodeBlock getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    // TODO(ronshapiro): We should also make an ImmutableMap version of MapFactory
+    boolean isImmutableMapAvailable = isImmutableMapAvailable();
+    // TODO(ronshapiro, gak): Use Maps.immutableEnumMap() if it's available?
+    if (isImmutableMapAvailable && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS) {
+      return CodeBlock.builder()
+          .add("$T.", ImmutableMap.class)
+          .add(maybeTypeParameters(requestingClass))
+          .add(
+              "of($L)",
+              dependencies
+                  .keySet()
+                  .stream()
+                  .map(dependency -> keyAndValueExpression(dependency, requestingClass))
+                  .collect(toParametersCodeBlock()))
+          .build();
+    }
+    switch (dependencies.size()) {
+      case 0:
+        return collectionsStaticFactoryInvocation(requestingClass, CodeBlock.of("emptyMap()"));
+      case 1:
+        return collectionsStaticFactoryInvocation(
+            requestingClass,
+            CodeBlock.of(
+                "singletonMap($L)",
+                keyAndValueExpression(getOnlyElement(dependencies.keySet()), requestingClass)));
+      default:
+        CodeBlock.Builder instantiation = CodeBlock.builder();
+        instantiation
+            .add("$T.", isImmutableMapAvailable ? ImmutableMap.class : MapBuilder.class)
+            .add(maybeTypeParameters(requestingClass));
+        if (isImmutableMapAvailable) {
+          // TODO(ronshapiro): builderWithExpectedSize
+          instantiation.add("builder()");
+        } else {
+          instantiation.add("newMapBuilder($L)", dependencies.size());
+        }
+        for (DependencyRequest dependency : dependencies.keySet()) {
+          instantiation.add(".put($L)", keyAndValueExpression(dependency, requestingClass));
+        }
+        return instantiation.add(".build()").build();
+    }
+  }
+
+  private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName requestingClass) {
+    return CodeBlock.of(
+        "$L, $L",
+        getMapKeyExpression(dependencies.get(dependency).mapKey().get()),
+        componentBindingExpressions.getDependencyExpression(dependency, requestingClass));
+  }
+
+  private CodeBlock collectionsStaticFactoryInvocation(
+      ClassName requestingClass, CodeBlock methodInvocation) {
+    return CodeBlock.builder()
+        .add("$T.", Collections.class)
+        .add(maybeTypeParameters(requestingClass))
+        .add(methodInvocation)
+        .build();
+  }
+
+  private CodeBlock maybeTypeParameters(ClassName requestingClass) {
+    TypeMirror bindingKeyType = binding.key().type();
+    MapType mapType = MapType.from(binding.key());
+    return isTypeAccessibleFrom(bindingKeyType, requestingClass.packageName())
+        ? CodeBlock.of("<$T, $T>", mapType.keyType(), mapType.valueType())
+        : CodeBlock.of("");
+  }
+
+  private boolean isImmutableMapAvailable() {
+    return elements.getTypeElement(ImmutableMap.class.getCanonicalName()) != null;
+  }
+
+  @Override
+  protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
+    if (isImmutableMapAvailable()) {
+      TypeMirror keyType = binding.key().type();
+      return CodeBlock.of(
+          "<$T>",
+          isTypeAccessibleFrom(keyType, requestingClass.packageName()) ? keyType : Map.class);
+    }
+    return CodeBlock.of("");
+  }
+}
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index 54662921f..fc0217a39 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -20,17 +20,19 @@
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.toTypeNamesCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.frameworkMapFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 import static dagger.internal.codegen.TypeNames.FACTORY;
+import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
+import static dagger.internal.codegen.TypeNames.PRODUCER;
+import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.PROVIDER;
 import static javax.lang.model.type.TypeKind.DECLARED;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -88,7 +90,7 @@ CodeBlock getExpressionFor(ClassName usingClass) {
             && !contributionBinding.scope().isPresent()) {
           switch (contributionBinding.bindingKind()) {
             case SYNTHETIC_MULTIBOUND_MAP:
-              return Optional.of(emptyFrameworkMapFactory(contributionBinding));
+              return Optional.of(emptyMapFactory(contributionBinding));
 
             case SYNTHETIC_MULTIBOUND_SET:
               return Optional.of(emptySetFactory(contributionBinding));
@@ -166,20 +168,19 @@ private static MemberSelect noOpMembersInjector(TypeMirror type) {
         MEMBERS_INJECTOR);
   }
 
-  /**
-   * A {@link MemberSelect} for a factory of an empty map of factory types, where a factory can be
-   * either a {@link javax.inject.Provider} or {@link dagger.producers.Producer}.
-   */
-  private static MemberSelect emptyFrameworkMapFactory(ContributionBinding contributionBinding) {
+  /** A {@link MemberSelect} for a factory of an empty map. */
+  private static MemberSelect emptyMapFactory(ContributionBinding contributionBinding) {
     BindingType bindingType = contributionBinding.bindingType();
-    MapType mapType = MapType.from(contributionBinding.key());
-
-    return new ParameterizedStaticMethod(
-        frameworkMapFactoryClassName(bindingType),
-        ImmutableList.of(
-            mapType.keyType(), mapType.unwrappedValueType(bindingType.frameworkClass())),
-        CodeBlock.of("empty()"),
-        ClassName.get(bindingType.frameworkClass()));
+    ImmutableList<TypeMirror> typeParameters =
+        ImmutableList.copyOf(
+            MoreTypes.asDeclared(contributionBinding.key().type()).getTypeArguments());
+    if (bindingType.equals(BindingType.PRODUCTION)) {
+      return new ParameterizedStaticMethod(
+          PRODUCERS, typeParameters, CodeBlock.of("emptyMapProducer()"), PRODUCER);
+    } else {
+      return new ParameterizedStaticMethod(
+          MAP_FACTORY, typeParameters, CodeBlock.of("emptyMapProvider()"), PROVIDER);
+    }
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index 4a71dea84..441fb5c1e 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -178,28 +178,6 @@ ProductionBinding forProducesMethod(
           .build();
     }
 
-    /**
-     * A synthetic binding of {@code Map<K, V>} or {@code Map<K, Produced<V>>} that depends on
-     * {@code Map<K, Producer<V>>}.
-     */
-    ProductionBinding syntheticMapOfValuesOrProducedBinding(Key mapOfValuesOrProducedKey) {
-      checkNotNull(mapOfValuesOrProducedKey);
-      Optional<Key> mapOfProducersKey =
-          keyFactory.implicitMapProducerKeyFrom(mapOfValuesOrProducedKey);
-      checkArgument(
-          mapOfProducersKey.isPresent(),
-          "%s is not a key for of Map<K, V> or Map<K, Produced<V>>",
-          mapOfValuesOrProducedKey);
-      DependencyRequest requestForMapOfProducers =
-          dependencyRequestFactory.producerForImplicitMapBinding(mapOfProducersKey.get());
-      return ProductionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(mapOfValuesOrProducedKey)
-          .explicitDependencies(requestForMapOfProducers)
-          .bindingKind(Kind.SYNTHETIC_MAP)
-          .build();
-    }
-
     /**
      * A synthetic binding that depends explicitly on a set of individual provision or production
      * multibinding contribution methods.
@@ -212,7 +190,7 @@ ProductionBinding syntheticMultibinding(
           .contributionType(ContributionType.UNIQUE)
           .key(key)
           .explicitDependencies(
-              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
+              dependencyRequestFactory.forMultibindingContributions(key, multibindingContributions))
           .bindingKind(Kind.forMultibindingKey(key))
           .build();
     }
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index 6d40e97ec..67168ce5a 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -235,21 +235,6 @@ ProvisionBinding forProvidesMethod(
           .build();
     }
 
-    /** A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}. */
-    ProvisionBinding syntheticMapOfValuesBinding(Key mapOfValuesKey) {
-      checkNotNull(mapOfValuesKey);
-      Optional<Key> mapOfProvidersKey = keyFactory.implicitMapProviderKeyFrom(mapOfValuesKey);
-      checkArgument(mapOfProvidersKey.isPresent(), "%s is not a key for Map<K, V>", mapOfValuesKey);
-      DependencyRequest requestForMapOfProviders =
-          dependencyRequestFactory.providerForImplicitMapBinding(mapOfProvidersKey.get());
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(mapOfValuesKey)
-          .provisionDependencies(requestForMapOfProviders)
-          .bindingKind(Kind.SYNTHETIC_MAP)
-          .build();
-    }
-
     /**
      * A synthetic binding that depends explicitly on a set of individual provision multibinding
      * contribution methods.
@@ -262,7 +247,7 @@ ProvisionBinding syntheticMultibinding(
           .contributionType(ContributionType.UNIQUE)
           .key(key)
           .provisionDependencies(
-              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
+              dependencyRequestFactory.forMultibindingContributions(key, multibindingContributions))
           .bindingKind(Kind.forMultibindingKey(key))
           .build();
     }
diff --git a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
index a56bf2590..84c8b14da 100644
--- a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
@@ -28,7 +28,7 @@
   private final BindingExpression delegate;
 
   SimpleInvocationBindingExpression(BindingExpression delegate) {
-    super(delegate.bindingKey());
+    super(delegate.resolvedBindings(), delegate.componentName());
     this.delegate = delegate;
   }
 
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/SourceFiles.java
index ded5f6f67..858f18445 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/SourceFiles.java
@@ -19,8 +19,10 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_SET;
 import static dagger.internal.codegen.Optionals.optionalComparator;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
@@ -51,17 +53,15 @@
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
-import dagger.internal.MapFactory;
-import dagger.internal.MapProviderFactory;
 import dagger.internal.SetFactory;
 import dagger.producers.Produced;
-import dagger.producers.internal.MapOfProducerProducer;
-import dagger.producers.internal.MapProducer;
+import dagger.producers.Producer;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
+import javax.inject.Provider;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -264,41 +264,24 @@ static ClassName setFactoryClassName(ContributionBinding binding) {
     }
   }
 
-  /**
-   * The {@link java.util.Map}-of-value factory class name appropriate for map bindings.
-   *
-   * <ul>
-   * <li>{@link MapFactory} for provision bindings.
-   * <li>{@link MapProducer} for production bindings.
-   * </ul>
-   */
+  /** The {@link java.util.Map} factory class name appropriate for map bindings. */
   static ClassName mapFactoryClassName(ContributionBinding binding) {
+    checkState(binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP), binding.bindingKind());
+    MapType mapType = MapType.from(binding.key());
     switch (binding.bindingType()) {
-      case PRODUCTION:
-        return MapType.from(binding.key()).valuesAreTypeOf(Produced.class)
-            ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
-
       case PROVISION:
-        return MAP_FACTORY;
-
+        return mapType.valuesAreTypeOf(Provider.class) ? MAP_PROVIDER_FACTORY : MAP_FACTORY;
+      case PRODUCTION:
+        return mapType.valuesAreFrameworkType()
+            ? mapType.valuesAreTypeOf(Producer.class)
+                ? MAP_OF_PRODUCER_PRODUCER
+                : MAP_OF_PRODUCED_PRODUCER
+            : MAP_PRODUCER;
       default:
-        throw new AssertionError(binding.toString());
+        throw new IllegalArgumentException(binding.bindingType().toString());
     }
   }
 
-  /**
-   * The {@link java.util.Map}-of-framework factory class name appropriate for map bindings.
-   *
-   * <ul>
-   * <li>{@link MapProviderFactory} for provision bindings.
-   * <li>{@link MapOfProducerProducer} for production bindings.
-   * </ul>
-   */
-  static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
-    return bindingType.equals(BindingType.PRODUCTION)
-        ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
-  }
-
   private static String factoryPrefix(ContributionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
diff --git a/java/dagger/internal/codegen/SubcomponentWriter.java b/java/dagger/internal/codegen/SubcomponentWriter.java
index c53030770..65a0bbcc7 100644
--- a/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -74,7 +74,7 @@ private static ClassName subcomponentName(AbstractComponentWriter parent, Bindin
   }
 
   @Override
-  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+  public CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
     return parent.getReferenceReleasingProviderManagerExpression(scope);
   }
 
diff --git a/java/dagger/producers/internal/MapOfProducedProducer.java b/java/dagger/producers/internal/MapOfProducedProducer.java
index 7fe2ce488..6a50b22a9 100644
--- a/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -16,20 +16,22 @@
 
 package dagger.producers.internal;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Futures.transform;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.List;
 import java.util.Map;
+import javax.inject.Provider;
 
 /**
  * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
@@ -39,48 +41,22 @@
  * @author Jesse Beder
  */
 public final class MapOfProducedProducer<K, V> extends AbstractProducer<Map<K, Produced<V>>> {
-  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+  private final Map<K, Producer<V>> mapOfProducers;
 
-  private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    this.mapProducerProducer = mapProducerProducer;
-  }
-
-  /**
-   * Returns a producer of {@code Map<K, Produced<V>>}, where the map is derived from the given map
-   * of producers by waiting for those producers' resulting futures. The iteration order mirrors the
-   * order of the input map.
-   *
-   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
-   * future will succeed and the corresponding {@code Produced<V>} will fail with a
-   * {@link NullPointerException}.
-   *
-   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
-   * component futures fails or is canceled, this one is, too.
-   */
-  public static <K, V> MapOfProducedProducer<K, V> create(
-      Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    return new MapOfProducedProducer<K, V>(mapProducerProducer);
+  private MapOfProducedProducer(Map<K, Producer<V>> mapOfProducers) {
+    this.mapOfProducers = mapOfProducers;
   }
 
   @Override
   public ListenableFuture<Map<K, Produced<V>>> compute() {
-    return Futures.transformAsync(
-        mapProducerProducer.get(),
-        new AsyncFunction<Map<K, Producer<V>>, Map<K, Produced<V>>>() {
+    return Futures.transform(
+        Futures.allAsList(
+            Iterables.transform(
+                mapOfProducers.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
+        new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
           @Override
-          public ListenableFuture<Map<K, Produced<V>>> apply(final Map<K, Producer<V>> map) {
-            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return transform(
-                Futures.allAsList(
-                    Iterables.transform(
-                        map.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
-                new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
-                  @Override
-                  public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
-                    return ImmutableMap.copyOf(entries);
-                  }
-                },
-                directExecutor());
+          public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
+            return ImmutableMap.copyOf(entries);
           }
         },
         directExecutor());
@@ -114,4 +90,35 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
           entryUnwrapper() {
     return (Function) ENTRY_UNWRAPPER;
   }
+
+  /** Returns a new {@link Builder}. */
+  public static <K, V> Builder<K, V> builder() {
+    return new Builder<>();
+  }
+
+  /** A builder for {@link MapOfProducedProducer}. */
+  public static final class Builder<K, V> {
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
+
+    /** Returns a new {@link MapOfProducedProducer}. */
+    public MapOfProducedProducer<K, V> build() {
+      return new MapOfProducedProducer<>(mapBuilder.build());
+    }
+
+    /** Associates {@code key} with {@code producerOfValue}. */
+    public Builder<K, V> put(K key, Producer<V> producerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(producerOfValue, "producer of value");
+      mapBuilder.put(key, producerOfValue);
+      return this;
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(providerOfValue, "provider of value");
+      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      return this;
+    }
+  }
 }
diff --git a/java/dagger/producers/internal/MapOfProducerProducer.java b/java/dagger/producers/internal/MapOfProducerProducer.java
index 5eef863c3..282cf86a1 100644
--- a/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -17,7 +17,6 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
 import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.collect.ImmutableMap;
@@ -34,20 +33,11 @@
  * @author Jesse Beder
  */
 public final class MapOfProducerProducer<K, V> extends AbstractProducer<Map<K, Producer<V>>> {
-  private static final MapOfProducerProducer<Object, Object> EMPTY =
-      new MapOfProducerProducer<Object, Object>(ImmutableMap.<Object, Producer<Object>>of());
-
   private final ImmutableMap<K, Producer<V>> contributingMap;
 
   /** Returns a new {@link Builder}. */
-  public static <K, V> Builder<K, V> builder(int size) {
-    return new Builder<K, V>(size);
-  }
-
-  /** Returns a producer of an empty map. */
-  @SuppressWarnings("unchecked") // safe contravariant cast
-  public static <K, V> MapOfProducerProducer<K, V> empty() {
-    return (MapOfProducerProducer<K, V>) EMPTY;
+  public static <K, V> Builder<K, V> builder() {
+    return new Builder<>();
   }
 
   private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
@@ -59,22 +49,11 @@ private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
     return Futures.<Map<K, Producer<V>>>immediateFuture(contributingMap);
   }
 
-  /**
-   * A builder to help build the {@link MapOfProducerProducer}
-   */
+  /** A builder for {@link MapOfProducerProducer} */
   public static final class Builder<K, V> {
-    private final Map<K, Producer<V>> mapBuilder;
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
 
-    private Builder(int size) {
-      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
-    }
-
-    /** Returns a new {@link MapOfProducerProducer}. */
-    public MapOfProducerProducer<K, V> build() {
-      return new MapOfProducerProducer<K, V>(ImmutableMap.copyOf(mapBuilder));
-    }
-
-    /** Associates key with producerOfValue in {@code Builder}. */
+    /** Associates {@code key} with {@code producerOfValue}. */
     public Builder<K, V> put(K key, Producer<V> producerOfValue) {
       checkNotNull(key, "key");
       checkNotNull(producerOfValue, "producer of value");
@@ -82,12 +61,17 @@ private Builder(int size) {
       return this;
     }
 
-    /** Associates key with providerOfValue in {@code Builder}. */
+    /** Associates {@code key} with {@code providerOfValue}. */
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
       checkNotNull(key, "key");
       checkNotNull(providerOfValue, "provider of value");
       mapBuilder.put(key, producerFromProvider(providerOfValue));
       return this;
     }
+
+    /** Returns a new {@link MapOfProducerProducer}. */
+    public MapOfProducerProducer<K, V> build() {
+      return new MapOfProducerProducer<>(mapBuilder.build());
+    }
   }
 }
diff --git a/java/dagger/producers/internal/MapProducer.java b/java/dagger/producers/internal/MapProducer.java
index 1a13b9d53..ca1650e08 100644
--- a/java/dagger/producers/internal/MapProducer.java
+++ b/java/dagger/producers/internal/MapProducer.java
@@ -16,19 +16,21 @@
 
 package dagger.producers.internal;
 
-import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
+import javax.inject.Provider;
 
 /**
  * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
@@ -37,73 +39,64 @@
  * @author Jesse Beder
  */
 public final class MapProducer<K, V> extends AbstractProducer<Map<K, V>> {
-  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+  private final ImmutableMap<K, Producer<V>> mapOfProducers;
 
-  private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    this.mapProducerProducer = mapProducerProducer;
+  private MapProducer(ImmutableMap<K, Producer<V>> mapOfProducers) {
+    this.mapOfProducers = mapOfProducers;
   }
 
-  /**
-   * Returns a producer of {@code Map<K, V>}, where the map is derived from the given map of
-   * producers by waiting for those producers' resulting futures. The iteration order mirrors the
-   * order of the input map.
-   *
-   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
-   * future will fail with a {@link NullPointerException}.
-   *
-   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
-   * component futures fails or is canceled, this one is, too.
-   */
-  public static <K, V> MapProducer<K, V> create(Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    return new MapProducer<K, V>(mapProducerProducer);
+  /** Returns a new {@link Builder}. */
+  public static <K, V> Builder<K, V> builder() {
+    return new Builder<>();
   }
 
-  @Override
-  public ListenableFuture<Map<K, V>> compute() {
-    return Futures.transformAsync(
-        mapProducerProducer.get(),
-        new AsyncFunction<Map<K, Producer<V>>, Map<K, V>>() {
-          @Override
-          public ListenableFuture<Map<K, V>> apply(final Map<K, Producer<V>> map) {
-            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return transform(
-                Futures.allAsList(
-                    Iterables.transform(map.entrySet(), MapProducer.<K, V>entryUnwrapper())),
-                new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
-                  @Override
-                  public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
-                    return ImmutableMap.copyOf(entries);
-                  }
-                },
-                directExecutor());
-          }
-        },
-        directExecutor());
+  /** A builder for {@link MapProducer} */
+  public static final class Builder<K, V> {
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
+
+    /** Associates {@code key} with {@code producerOfValue}. */
+    public Builder<K, V> put(K key, Producer<V> producerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(producerOfValue, "producer of value");
+      mapBuilder.put(key, producerOfValue);
+      return this;
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(providerOfValue, "provider of value");
+      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      return this;
+    }
+
+    /** Returns a new {@link MapProducer}. */
+    public MapProducer<K, V> build() {
+      return new MapProducer<>(mapBuilder.build());
+    }
   }
 
-  private static final Function<
-          Map.Entry<Object, Producer<Object>>, ListenableFuture<Map.Entry<Object, Object>>>
-      ENTRY_UNWRAPPER =
-          new Function<
-              Map.Entry<Object, Producer<Object>>, ListenableFuture<Map.Entry<Object, Object>>>() {
+  @Override
+  protected ListenableFuture<Map<K, V>> compute() {
+    final List<ListenableFuture<Map.Entry<K, V>>> listOfEntries = new ArrayList<>();
+    for (final Entry<K, Producer<V>> entry : mapOfProducers.entrySet()) {
+      listOfEntries.add(
+          Futures.transform(entry.getValue().get(), new Function<V, Entry<K, V>>() {
             @Override
-            public ListenableFuture<Map.Entry<Object, Object>> apply(
-                final Map.Entry<Object, Producer<Object>> entry) {
-              return transform(
-                  entry.getValue().get(),
-                  new Function<Object, Map.Entry<Object, Object>>() {
-                    @Override
-                    public Map.Entry<Object, Object> apply(Object value) {
-                      return Maps.immutableEntry(entry.getKey(), value);
-                    }
-                  },
-                  directExecutor());
+            public Entry<K, V> apply(V computedValue) {
+              return Maps.immutableEntry(entry.getKey(), computedValue);
             }
-          };
+          }, directExecutor()));
+    }
 
-  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariate implementation
-  private static <K, V>
-      Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, V>>> entryUnwrapper() {
-    return (Function) ENTRY_UNWRAPPER;
+    return Futures.transform(
+        Futures.allAsList(listOfEntries),
+        new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
+          @Override
+          public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
+            return ImmutableMap.copyOf(entries);
+          }
+        },
+        directExecutor());
   }
 }
diff --git a/java/dagger/producers/internal/Producers.java b/java/dagger/producers/internal/Producers.java
index 029bcb51a..3a603bebe 100644
--- a/java/dagger/producers/internal/Producers.java
+++ b/java/dagger/producers/internal/Producers.java
@@ -22,6 +22,7 @@
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
 import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
@@ -29,6 +30,7 @@
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
 
@@ -123,9 +125,9 @@
    */
   public static <T> Producer<T> producerFromProvider(final Provider<T> provider) {
     checkNotNull(provider);
-    return new AbstractProducer<T>() {
+    return new Producer<T>() {
       @Override
-      protected ListenableFuture<T> compute() {
+      public ListenableFuture<T> get() {
         return Futures.immediateFuture(provider.get());
       }
     };
@@ -151,5 +153,13 @@
     };
   }
 
+  private static final Producer<Map<Object, Object>> EMPTY_MAP_PRODUCER =
+      Producers.<Map<Object, Object>>immediateProducer(ImmutableMap.of());
+
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> Producer<Map<K, V>> emptyMapProducer() {
+    return (Producer<Map<K, V>>) (Producer) EMPTY_MAP_PRODUCER;
+  }
+
   private Producers() {}
 }
diff --git a/javatests/dagger/functional/LazyMaps.java b/javatests/dagger/functional/LazyMaps.java
new file mode 100644
index 000000000..eeb136849
--- /dev/null
+++ b/javatests/dagger/functional/LazyMaps.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.StringKey;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+
+/**
+ * Bindings that use {@code Lazy<T>} as the value in a multibound map. A regression was uncovered
+ * when using {@code MapType.valuesAreFrameworkType()}, which treats {@link Lazy} as a framework
+ * type and incorrectly suggested {@link dagger.internal.MapProviderFactory} for a {@code Map<K,
+ * Lazy<V>>} instead of a plain {@link dagger.internal.MapFactory}. See b/65084589.
+ */
+class LazyMaps {
+  @Module
+  abstract static class TestModule {
+    @Provides
+    @Singleton
+    static AtomicInteger provideAtomicInteger() {
+      return new AtomicInteger();
+    }
+
+    @Provides
+    static String provideString(AtomicInteger atomicInteger) {
+      return "value-" + atomicInteger.incrementAndGet();
+    }
+
+    @Provides
+    @IntoMap
+    @StringKey("key")
+    static Lazy<String> mapContribution(Lazy<String> lazy) {
+      return lazy;
+    }
+
+    /* TODO(b/65118638) Replace once @Binds @IntoMap Lazy<T> methods work properly.
+    @Binds
+    @IntoMap
+    @StringKey("binds-key")
+    abstract Lazy<String> mapContributionAsBinds(Lazy<String> lazy);
+    */
+  }
+
+  @Singleton
+  @Component(modules = TestModule.class)
+  interface TestComponent {
+    Map<String, Lazy<String>> mapOfLazy();
+
+    Map<String, Provider<Lazy<String>>> mapOfProviderOfLazy();
+
+    Provider<Map<String, Lazy<String>>> providerForMapOfLazy();
+
+    Provider<Map<String, Provider<Lazy<String>>>> providerForMapOfProviderOfLazy();
+  }
+}
diff --git a/javatests/dagger/functional/LazyMapsTest.java b/javatests/dagger/functional/LazyMapsTest.java
new file mode 100644
index 000000000..a3e289a4c
--- /dev/null
+++ b/javatests/dagger/functional/LazyMapsTest.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Lazy;
+import dagger.functional.LazyMaps.TestComponent;
+import java.util.Map;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link LazyMaps}. */
+@RunWith(JUnit4.class)
+public class LazyMapsTest {
+  @Test
+  public void mapOfLazies() {
+    TestComponent component = DaggerLazyMaps_TestComponent.create();
+    Map<String, Lazy<String>> laziesMap = component.mapOfLazy();
+
+    String firstGet = laziesMap.get("key").get();
+    assertThat(firstGet).isEqualTo("value-1");
+    assertThat(firstGet).isSameAs(laziesMap.get("key").get());
+
+    assertThat(component.mapOfLazy().get("key").get()).isEqualTo("value-2");
+  }
+
+  @Test
+  public void mapOfProviderOfLaziesReturnsDifferentLazy() {
+    TestComponent component = DaggerLazyMaps_TestComponent.create();
+    Map<String, Provider<Lazy<String>>> providersOfLaziesMap = component.mapOfProviderOfLazy();
+
+    assertThat(providersOfLaziesMap.get("key").get().get())
+        .isNotEqualTo(providersOfLaziesMap.get("key").get().get());
+  }
+}
diff --git a/javatests/dagger/internal/codegen/Compilers.java b/javatests/dagger/internal/codegen/Compilers.java
index a42d1a2ff..3eee251f3 100644
--- a/javatests/dagger/internal/codegen/Compilers.java
+++ b/javatests/dagger/internal/codegen/Compilers.java
@@ -16,8 +16,12 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
+import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
 import static com.google.testing.compile.Compiler.javac;
+import static java.util.stream.Collectors.joining;
 
+import com.google.common.base.Splitter;
 import com.google.testing.compile.Compiler;
 
 /** {@link Compiler} instances for testing Dagger. */
@@ -27,4 +31,18 @@
   static Compiler daggerCompiler() {
     return javac().withProcessors(new ComponentProcessor());
   }
+
+  static Compiler daggerCompilerWithoutGuava() {
+    return daggerCompiler().withOptions("-classpath", classpathWithoutGuava());
+  }
+
+  private static final String GUAVA = "guava";
+
+  private static String classpathWithoutGuava() {
+    return Splitter.on(PATH_SEPARATOR.value())
+        .splitToList(JAVA_CLASS_PATH.value())
+        .stream()
+        .filter(jar -> !jar.contains(GUAVA))
+        .collect(joining(PATH_SEPARATOR.value()));
+  }
 }
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 6aba380dc..cc22bae84 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -107,7 +107,7 @@ public void mapBindingsWithEnumKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<PathEnum, Provider<Handler>> dispatcher();",
+        "  Provider<Map<PathEnum, Provider<Handler>>> dispatcher();",
         "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
@@ -153,8 +153,8 @@ public void mapBindingsWithEnumKey() {
             "  }",
             "",
             "  @Override",
-            "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
+            "  public Provider<Map<PathEnum, Provider<Handler>>> dispatcher() {",
+            "    return mapOfPathEnumAndProviderOfHandlerProvider;",
             "  }",
             "",
             "  public static final class Builder {",
@@ -259,7 +259,7 @@ public void mapBindingsWithStringKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<String, Provider<Handler>> dispatcher();",
+        "  Provider<Map<String, Provider<Handler>>> dispatcher();",
         "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
@@ -305,8 +305,8 @@ public void mapBindingsWithStringKey() {
             "  }",
             "",
             "  @Override",
-            "  public Map<String, Provider<Handler>> dispatcher() {",
-            "    return mapOfStringAndProviderOfHandlerProvider.get();",
+            "  public Provider<Map<String, Provider<Handler>>> dispatcher() {",
+            "    return mapOfStringAndProviderOfHandlerProvider;",
             "  }",
             "",
             "  public static final class Builder {",
@@ -420,7 +420,7 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<WrappedClassKey, Provider<Handler>> dispatcher();",
+        "  Provider<Map<WrappedClassKey, Provider<Handler>>> dispatcher();",
         "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
@@ -468,8 +468,8 @@ public void mapBindingsWithWrappedKey() {
             "  }",
             "",
             "  @Override",
-            "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
+            "  public Provider<Map<WrappedClassKey, Provider<Handler>>> dispatcher() {",
+            "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
             "  }",
             "",
             "  public static final class Builder {",
@@ -585,7 +585,7 @@ public void mapBindingsWithNonProviderValue() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<PathEnum, Handler> dispatcher();",
+        "  Provider<Map<PathEnum, Handler>> dispatcher();",
         "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
@@ -593,7 +593,6 @@ public void mapBindingsWithNonProviderValue() {
             "package test;",
             "",
             "import dagger.internal.MapFactory;",
-            "import dagger.internal.MapProviderFactory;",
             "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
@@ -603,8 +602,6 @@ public void mapBindingsWithNonProviderValue() {
             "public final class DaggerTestComponent implements TestComponent {",
             "  private Provider<Handler> provideAdminHandlerProvider;",
             "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathEnum, Provider<Handler>>>",
-            "      mapOfPathEnumAndProviderOfHandlerProvider;",
             "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
@@ -625,18 +622,16 @@ public void mapBindingsWithNonProviderValue() {
             "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
             "    this.provideLoginHandlerProvider =",
             "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+            "    this.mapOfPathEnumAndHandlerProvider =",
+            "        MapFactory.<PathEnum, Handler>builder(2)",
             "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
             "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
             "            .build();",
-            "    this.mapOfPathEnumAndHandlerProvider =",
-            "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
             "  }",
             "",
             "  @Override",
-            "  public Map<PathEnum, Handler> dispatcher() {",
-            "    return mapOfPathEnumAndHandlerProvider.get();",
+            "  public Provider<Map<PathEnum, Handler>> dispatcher() {",
+            "    return mapOfPathEnumAndHandlerProvider;",
             "  }",
             "",
             "  public static final class Builder {",
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
new file mode 100644
index 000000000..77594192e
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompilerWithoutGuava;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MapBindingExpressionTest {
+  public static final CodeBlock NPE_FROM_PROVIDES =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
+  @Test
+  public void mapBindings() {
+    JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntKey;",
+        "import dagger.multibindings.IntoMap;",
+        "import dagger.multibindings.LongKey;",
+        "import dagger.multibindings.Multibinds;",
+        "import java.util.Map;",
+        "",
+        "@Module",
+        "interface MapModule {",
+        "  @Multibinds Map<String, String> stringMap();",
+        "  @Provides @IntoMap @IntKey(0) static int provideInt() { return 0; }",
+        "  @Provides @IntoMap @LongKey(0) static long provideLong0() { return 0; }",
+        "  @Provides @IntoMap @LongKey(1) static long provideLong1() { return 1; }",
+        "  @Provides @IntoMap @LongKey(2) static long provideLong2() { return 2; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = MapModule.class)",
+        "interface TestComponent {",
+        "  Map<String, String> strings();",
+        "  Map<String, Provider<String>> providerStrings();",
+        "",
+        "  Map<Integer, Integer> ints();",
+        "  Map<Integer, Provider<Integer>> providerInts();",
+        "  Map<Long, Long> longs();",
+        "  Map<Long, Provider<Long>> providerLongs();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapBuilder;",
+            "import java.util.Collections;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, String> strings() {",
+            "    return Collections.<String, String>emptyMap();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, Provider<String>> providerStrings() {",
+            "    return Collections.<String, Provider<String>>emptyMap();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Integer, Integer> ints() {",
+            "    return Collections.<Integer, Integer>singletonMap(0, MapModule.provideInt());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Integer, Provider<Integer>> providerInts() {",
+            "    return Collections.<Integer, Provider<Integer>>singletonMap(",
+            "        0, MapModule_ProvideIntFactory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Long, Long> longs() {",
+            "    return MapBuilder.<Long, Long>newMapBuilder(3)",
+            "      .put(0L, MapModule.provideLong0())",
+            "      .put(1L, MapModule.provideLong1())",
+            "      .put(2L, MapModule.provideLong2())",
+            "      .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Long, Provider<Long>> providerLongs() {",
+            "    return MapBuilder.<Long, Provider<Long>>newMapBuilder(3)",
+            "      .put(0L, MapModule_ProvideLong0Factory.create())",
+            "      .put(1L, MapModule_ProvideLong1Factory.create())",
+            "      .put(2L, MapModule_ProvideLong2Factory.create())",
+            "      .build();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompilerWithoutGuava().compile(mapModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void inaccessible() {
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible",
+            "package other;",
+            "",
+            "class Inaccessible {}");
+    JavaFileObject usesInaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessible",
+            "package other;",
+            "",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessible {",
+            "  @Inject UsesInaccessible(Map<Integer, Inaccessible> map) {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.TestModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "public abstract class TestModule {",
+            "  @Multibinds abstract Map<Integer, Inaccessible> ints();",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "import other.TestModule;",
+            "import other.UsesInaccessible;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  UsesInaccessible usesInaccessible();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import java.util.Collections;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import other.UsesInaccessible;",
+            "import other.UsesInaccessible_Factory;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public UsesInaccessible usesInaccessible() {",
+            "    return UsesInaccessible_Factory.newUsesInaccessible(",
+            "        (Map) Collections.emptyMap());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompilerWithoutGuava().compile(module, inaccessible, usesInaccessible, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Collections;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private ParentModule parentModule;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.parentModule = builder.parentModule;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private ParentModule parentModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      if (parentModule == null) {",
+            "        this.parentModule = new ParentModule();",
+            "      }",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private ChildImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<String, Object> objectMap() {",
+            "      return Collections.<String, Object>singletonMap(",
+            "          \"parent key\",",
+            "          Preconditions.checkNotNull(",
+            "              DaggerParent.this.parentModule.parentKeyObject(),",
+            "              " + NPE_FROM_PROVIDES_METHOD + ");",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompilerWithoutGuava().compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(expected);
+  }
+
+}
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
new file mode 100644
index 000000000..0b10fa4b8
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -0,0 +1,502 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MapBindingExpressionWithGuavaTest {
+  @Test
+  public void mapBindings() {
+    JavaFileObject mapModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.LongKey;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface MapModule {",
+            "  @Multibinds Map<String, String> stringMap();",
+            "  @Provides @IntoMap @IntKey(0) static int provideInt() { return 0; }",
+            "  @Provides @IntoMap @LongKey(0) static long provideLong0() { return 0; }",
+            "  @Provides @IntoMap @LongKey(1) static long provideLong1() { return 1; }",
+            "  @Provides @IntoMap @LongKey(2) static long provideLong2() { return 2; }",
+            "}");
+    JavaFileObject subcomponentModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.SubcomponentMapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.LongKey;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface SubcomponentMapModule {",
+            "  @Provides @IntoMap @LongKey(3) static long provideLong3() { return 3; }",
+            "  @Provides @IntoMap @LongKey(4) static long provideLong4() { return 4; }",
+            "  @Provides @IntoMap @LongKey(5) static long provideLong5() { return 5; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = MapModule.class)",
+            "interface TestComponent {",
+            "  Map<String, String> strings();",
+            "  Map<String, Provider<String>> providerStrings();",
+            "",
+            "  Map<Integer, Integer> ints();",
+            "  Map<Integer, Provider<Integer>> providerInts();",
+            "  Map<Long, Long> longs();",
+            "  Map<Long, Provider<Long>> providerLongs();",
+            "",
+            "  Sub sub();",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = SubcomponentMapModule.class)",
+            "interface Sub {",
+            "  Map<Long, Long> longs();",
+            "  Map<Long, Provider<Long>> providerLongs();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, String> strings() {",
+            "    return ImmutableMap.<String, String>of();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, Provider<String>> providerStrings() {",
+            "    return ImmutableMap.<String, Provider<String>>of();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Integer, Integer> ints() {",
+            "    return ImmutableMap.<Integer, Integer>of(0, MapModule.provideInt());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Integer, Provider<Integer>> providerInts() {",
+            "    return ImmutableMap.<Integer, Provider<Integer>>of(",
+            "        0, MapModule_ProvideIntFactory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Long, Long> longs() {",
+            "    return ImmutableMap.<Long, Long>of(",
+            "      0L, MapModule.provideLong0(),",
+            "      1L, MapModule.provideLong1(),",
+            "      2L, MapModule.provideLong2());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Long, Provider<Long>> providerLongs() {",
+            "    return ImmutableMap.<Long, Provider<Long>>of(",
+            "      0L, MapModule_ProvideLong0Factory.create(),",
+            "      1L, MapModule_ProvideLong1Factory.create(),",
+            "      2L, MapModule_ProvideLong2Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Sub sub() {",
+            "    return new SubImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "  private final class SubImpl implements Sub {",
+            "    private SubImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<Long, Long> longs() {",
+            "      return ImmutableMap.<Long, Long>builder()",
+            "          .put(0L, MapModule.provideLong0())",
+            "          .put(1L, MapModule.provideLong1())",
+            "          .put(2L, MapModule.provideLong2())",
+            "          .put(3L, SubcomponentMapModule.provideLong3())",
+            "          .put(4L, SubcomponentMapModule.provideLong4())",
+            "          .put(5L, SubcomponentMapModule.provideLong5())",
+            "          .build();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<Long, Provider<Long>> providerLongs() {",
+            "      return ImmutableMap.<Long, Provider<Long>>builder()",
+            "          .put(0L, MapModule_ProvideLong0Factory.create())",
+            "          .put(1L, MapModule_ProvideLong1Factory.create())",
+            "          .put(2L, MapModule_ProvideLong2Factory.create())",
+            "          .put(3L, SubcomponentMapModule_ProvideLong3Factory.create())",
+            "          .put(4L, SubcomponentMapModule_ProvideLong4Factory.create())",
+            "          .put(5L, SubcomponentMapModule_ProvideLong5Factory.create())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(mapModuleFile, componentFile, subcomponentModuleFile, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void inaccessible() {
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible", "package other;", "", "class Inaccessible {}");
+    JavaFileObject usesInaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessible",
+            "package other;",
+            "",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessible {",
+            "  @Inject UsesInaccessible(Map<Integer, Inaccessible> map) {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.TestModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "public abstract class TestModule {",
+            "  @Multibinds abstract Map<Integer, Inaccessible> ints();",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "import other.TestModule;",
+            "import other.UsesInaccessible;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  UsesInaccessible usesInaccessible();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import other.UsesInaccessible;",
+            "import other.UsesInaccessible_Factory;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public UsesInaccessible usesInaccessible() {",
+            "    return UsesInaccessible_Factory.newUsesInaccessible((Map) ImmutableMap.of());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(module, inaccessible, usesInaccessible, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private ParentModule parentModule;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.parentModule = builder.parentModule;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private ParentModule parentModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      if (parentModule == null) {",
+            "        this.parentModule = new ParentModule();",
+            "      }",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private ChildImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<String, Object> objectMap() {",
+            "      return ImmutableMap.<String, Object>of(",
+            "          \"parent key\",",
+            "          Preconditions.checkNotNull(",
+            "              DaggerParent.this.parentModule.parentKeyObject(),",
+            "              " + NPE_FROM_PROVIDES_METHOD + ");",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(expected);
+  }
+
+  @Test
+  public void productionComponents() {
+    JavaFileObject mapModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface MapModule {",
+            "  @Multibinds Map<String, String> stringMap();",
+            "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProductionComponent;",
+        "import java.util.Map;",
+        "",
+        "@ProductionComponent(modules = MapModule.class)",
+        "interface TestComponent {",
+        "  ListenableFuture<Map<String, String>> stringMap();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<Map<String, String>> stringMap() {",
+            "    return Futures.<Map<String, String>>immediateFuture(",
+            "        ImmutableMap.<String, String>of());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder testComponent_ProductionExecutorModule(",
+            "        TestComponent_ProductionExecutorModule",
+            "            testComponent_ProductionExecutorModule) {",
+            "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(mapModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
index 4a72a5f01..11d9db41c 100644
--- a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -212,7 +212,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "test.DaggerTestComponent",
             "package test;",
             "",
-            "import dagger.internal.MapProviderFactory;",
+            "import com.google.common.collect.ImmutableMap;",
             "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
@@ -222,8 +222,6 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "public final class DaggerTestComponent implements TestComponent {",
             "  private Provider<Handler> provideAdminHandlerProvider;",
             "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathKey, Provider<Handler>>>",
-            "      mapOfPathKeyAndProviderOfHandlerProvider;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
             "    initialize(builder);",
@@ -243,18 +241,15 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
             "    this.provideLoginHandlerProvider =",
             "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathKey, Handler>builder(2)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
-            "                provideAdminHandlerProvider)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-            "                provideLoginHandlerProvider)",
-            "            .build();",
             "  }",
             "",
             "  @Override",
             "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+            "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
+            "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
+            "        provideAdminHandlerProvider,",
+            "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+            "        provideLoginHandlerProvider);",
             "  }",
             "",
             "  public static final class Builder {",
@@ -386,7 +381,7 @@ public void mapKeyComponentFileWithDefaultField() {
             "test.DaggerTestComponent",
             "package test;",
             "",
-            "import dagger.internal.MapProviderFactory;",
+            "import com.google.common.collect.ImmutableMap;",
             "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
@@ -396,8 +391,6 @@ public void mapKeyComponentFileWithDefaultField() {
             "public final class DaggerTestComponent implements TestComponent {",
             "  private Provider<Handler> provideAdminHandlerProvider;",
             "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathKey, Provider<Handler>>>",
-            "      mapOfPathKeyAndProviderOfHandlerProvider;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
             "    initialize(builder);",
@@ -417,18 +410,15 @@ public void mapKeyComponentFileWithDefaultField() {
             "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
             "    this.provideLoginHandlerProvider =",
             "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathKey, Handler>builder(2)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
-            "                provideAdminHandlerProvider)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-            "                provideLoginHandlerProvider)",
-            "            .build();",
             "  }",
             "",
             "  @Override",
             "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+            "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
+            "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
+            "        provideAdminHandlerProvider,",
+            "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+            "        provideLoginHandlerProvider);",
             "  }",
             "",
             "  public static final class Builder {",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
index 1cadddbd7..226972c21 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
@@ -16,16 +16,11 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
-import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.Compilers.daggerCompilerWithoutGuava;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static java.util.stream.Collectors.joining;
 
-import com.google.common.base.Splitter;
 import com.google.testing.compile.Compilation;
-import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
@@ -136,7 +131,8 @@ public void setBindings() {
             "    }",
             "  }",
             "}");
-    Compilation compilation = compiler().compile(emptySetModuleFile, setModuleFile, componentFile);
+    Compilation compilation =
+        daggerCompilerWithoutGuava().compile(emptySetModuleFile, setModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -251,7 +247,8 @@ public void inaccessible() {
             "  }",
             "}");
     Compilation compilation =
-        compiler().compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
+        daggerCompilerWithoutGuava()
+            .compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -279,7 +276,6 @@ public void subcomponentOmitsInheritedBindings() {
             "import dagger.Module;",
             "import dagger.Provides;",
             "import dagger.multibindings.IntoSet;",
-            "import dagger.multibindings.IntoMap;",
             "import dagger.multibindings.StringKey;",
             "",
             "@Module",
@@ -287,10 +283,6 @@ public void subcomponentOmitsInheritedBindings() {
             "  @Provides @IntoSet static Object parentObject() {",
             "    return \"parent object\";",
             "  }",
-            "",
-            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
-            "    return \"parent value\";",
-            "  }",
             "}");
     JavaFileObject child =
         JavaFileObjects.forSourceLines(
@@ -298,35 +290,25 @@ public void subcomponentOmitsInheritedBindings() {
             "package test;",
             "",
             "import dagger.Subcomponent;",
-            "import java.util.Map;",
             "import java.util.Set;",
             "",
             "@Subcomponent",
             "interface Child {",
             "  Set<Object> objectSet();",
-            "  Map<String, Object> objectMap();",
             "}");
     JavaFileObject expected =
         JavaFileObjects.forSourceLines(
             "test.DaggerParent",
             "package test;",
             "",
-            "import dagger.internal.MapFactory;",
-            "import dagger.internal.MapProviderFactory;",
             "import dagger.internal.Preconditions;",
             "import java.util.Collections;",
-            "import java.util.Map;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
-            "  private Provider<Object> parentKeyObjectProvider;",
-            "",
-            "  private DaggerParent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerParent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -336,84 +318,40 @@ public void subcomponentOmitsInheritedBindings() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.parentKeyObjectProvider =",
-            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
-            "  }",
-            "",
             "  @Override",
             "  public Child child() {",
             "    return new ChildImpl();",
             "  }",
             "",
             "  public static final class Builder {",
-            "    private ParentModule parentModule;",
-            "",
             "    private Builder() {}",
             "",
             "    public Parent build() {",
-            "      if (parentModule == null) {",
-            "        this.parentModule = new ParentModule();",
-            "      }",
             "      return new DaggerParent(this);",
             "    }",
             "",
+            "    @Deprecated",
             "    public Builder parentModule(ParentModule parentModule) {",
-            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+            "      Preconditions.checkNotNull(parentModule);",
             "      return this;",
             "    }",
             "  }",
             "",
             "  private final class ChildImpl implements Child {",
-            "    private Provider<Map<String, Provider<Object>>>",
-            "        mapOfStringAndProviderOfObjectProvider;",
-            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
-            "",
-            "    private ChildImpl() {",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      this.mapOfStringAndProviderOfObjectProvider =",
-            "          MapProviderFactory.<String, Object>builder(1)",
-            "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
-            "              .build();",
-            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
-            "          mapOfStringAndProviderOfObjectProvider);",
-            "    }",
+            "    private ChildImpl() {}",
             "",
             "    @Override",
             "    public Set<Object> objectSet() {",
             "      return Collections.<Object>singleton(Preconditions.checkNotNull(",
             "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
             "    }",
-            "",
-            "    @Override",
-            "    public Map<String, Object> objectMap() {",
-            "      return mapOfStringAndObjectProvider.get();",
-            "    }",
             "  }",
             "}");
-    Compilation compilation = compiler().compile(parent, parentModule, child);
+    Compilation compilation = daggerCompilerWithoutGuava().compile(parent, parentModule, child);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerParent")
         .hasSourceEquivalentTo(expected);
   }
 
-  private Compiler compiler() {
-    return daggerCompiler().withOptions("-classpath", classpathWithoutGuava());
-  }
-
-  private static final String GUAVA = "guava";
-
-  private String classpathWithoutGuava() {
-    return Splitter.on(PATH_SEPARATOR.value())
-        .splitToList(JAVA_CLASS_PATH.value())
-        .stream()
-        .filter(jar -> !jar.contains(GUAVA))
-        .collect(joining(":"));
-  }
 }
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index 1312e096e..8de07ec85 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -286,7 +286,6 @@ public void subcomponentOmitsInheritedBindings() {
             "import dagger.Module;",
             "import dagger.Provides;",
             "import dagger.multibindings.IntoSet;",
-            "import dagger.multibindings.IntoMap;",
             "import dagger.multibindings.StringKey;",
             "",
             "@Module",
@@ -294,10 +293,6 @@ public void subcomponentOmitsInheritedBindings() {
             "  @Provides @IntoSet static Object parentObject() {",
             "    return \"parent object\";",
             "  }",
-            "",
-            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
-            "    return \"parent value\";",
-            "  }",
             "}");
     JavaFileObject child =
         JavaFileObjects.forSourceLines(
@@ -305,13 +300,11 @@ public void subcomponentOmitsInheritedBindings() {
             "package test;",
             "",
             "import dagger.Subcomponent;",
-            "import java.util.Map;",
             "import java.util.Set;",
             "",
             "@Subcomponent",
             "interface Child {",
             "  Set<Object> objectSet();",
-            "  Map<String, Object> objectMap();",
             "}");
     JavaFileObject expected =
         JavaFileObjects.forSourceLines(
@@ -319,21 +312,13 @@ public void subcomponentOmitsInheritedBindings() {
             "package test;",
             "",
             "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.MapFactory;",
-            "import dagger.internal.MapProviderFactory;",
             "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
-            "  private Provider<Object> parentKeyObjectProvider;",
-            "",
-            "  private DaggerParent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerParent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -343,64 +328,33 @@ public void subcomponentOmitsInheritedBindings() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.parentKeyObjectProvider =",
-            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
-            "  }",
-            "",
             "  @Override",
             "  public Child child() {",
             "    return new ChildImpl();",
             "  }",
             "",
             "  public static final class Builder {",
-            "    private ParentModule parentModule;",
-            "",
             "    private Builder() {}",
             "",
             "    public Parent build() {",
-            "      if (parentModule == null) {",
-            "        this.parentModule = new ParentModule();",
-            "      }",
             "      return new DaggerParent(this);",
             "    }",
             "",
+            "    @Deprecated",
             "    public Builder parentModule(ParentModule parentModule) {",
-            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+            "      Preconditions.checkNotNull(parentModule);",
             "      return this;",
             "    }",
             "  }",
             "",
             "  private final class ChildImpl implements Child {",
-            "    private Provider<Map<String, Provider<Object>>>",
-            "        mapOfStringAndProviderOfObjectProvider;",
-            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
-            "",
-            "    private ChildImpl() {",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      this.mapOfStringAndProviderOfObjectProvider =",
-            "          MapProviderFactory.<String, Object>builder(1)",
-            "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
-            "              .build();",
-            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
-            "          mapOfStringAndProviderOfObjectProvider);",
-            "    }",
+            "    private ChildImpl() {}",
             "",
             "    @Override",
             "    public Set<Object> objectSet() {",
             "      return ImmutableSet.<Object>of(Preconditions.checkNotNull(",
             "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
             "    }",
-            "",
-            "    @Override",
-            "    public Map<String, Object> objectMap() {",
-            "      return mapOfStringAndObjectProvider.get();",
-            "    }",
             "  }",
             "}");
     Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
diff --git a/javatests/dagger/producers/internal/MapOfProducerProducerTest.java b/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
index fe285ed5c..645a016b5 100644
--- a/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
+++ b/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
@@ -31,7 +31,7 @@
   @Test
   public void success() throws Exception {
     MapOfProducerProducer<Integer, String> mapOfProducerProducer =
-        MapOfProducerProducer.<Integer, String>builder(2)
+        MapOfProducerProducer.<Integer, String>builder()
             .put(15, Producers.<String>immediateProducer("fifteen"))
             .put(42, Producers.<String>immediateProducer("forty two"))
             .build();
@@ -47,7 +47,7 @@ public void success() throws Exception {
   public void failingContributionDoesNotFailMap() throws Exception {
     RuntimeException cause = new RuntimeException("monkey");
     MapOfProducerProducer<Integer, String> mapOfProducerProducer =
-        MapOfProducerProducer.<Integer, String>builder(2)
+        MapOfProducerProducer.<Integer, String>builder()
             .put(15, Producers.<String>immediateProducer("fifteen"))
             .put(42, Producers.<String>immediateFailedProducer(cause))
             .build();
diff --git a/javatests/dagger/producers/internal/MapProducerTest.java b/javatests/dagger/producers/internal/MapProducerTest.java
index 3a8f19ddc..ee7978b7b 100644
--- a/javatests/dagger/producers/internal/MapProducerTest.java
+++ b/javatests/dagger/producers/internal/MapProducerTest.java
@@ -19,7 +19,6 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
-import com.google.common.collect.ImmutableMap;
 import dagger.producers.Producer;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
@@ -32,13 +31,10 @@
   @Test
   public void success() throws Exception {
     Producer<Map<Integer, String>> mapProducer =
-        MapProducer.create(
-            Producers.<Map<Integer, Producer<String>>>immediateProducer(
-                ImmutableMap.<Integer, Producer<String>>of(
-                    15,
-                    Producers.<String>immediateProducer("fifteen"),
-                    42,
-                    Producers.<String>immediateProducer("forty two"))));
+        MapProducer.<Integer, String>builder()
+            .put(15, Producers.immediateProducer("fifteen"))
+            .put(42, Producers.immediateProducer("forty two"))
+            .build();
     Map<Integer, String> map = mapProducer.get().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsEntry(15, "fifteen");
@@ -49,27 +45,11 @@ public void success() throws Exception {
   public void failingContribution() throws Exception {
     RuntimeException cause = new RuntimeException("monkey");
     Producer<Map<Integer, String>> mapProducer =
-        MapProducer.create(
-            Producers.<Map<Integer, Producer<String>>>immediateProducer(
-                ImmutableMap.<Integer, Producer<String>>of(
-                    15,
-                    Producers.<String>immediateProducer("fifteen"),
-                    42,
-                    Producers.<String>immediateFailedProducer(cause))));
-    try {
-      mapProducer.get().get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isSameAs(cause);
-    }
-  }
-
-  @Test
-  public void failingInput() throws Exception {
-    RuntimeException cause = new RuntimeException("monkey");
-    Producer<Map<Integer, String>> mapProducer =
-        MapProducer.create(
-            Producers.<Map<Integer, Producer<String>>>immediateFailedProducer(cause));
+        MapProducer.<Integer, String>builder()
+            .put(15, Producers.immediateProducer("fifteen"))
+            // TODO(ronshapiro): remove the type parameter when we drop java7 support
+            .put(42, Producers.<String>immediateFailedProducer(cause))
+            .build();
     try {
       mapProducer.get().get();
       fail();
diff --git a/javatests/dagger/producers/internal/ProducersTest.java b/javatests/dagger/producers/internal/ProducersTest.java
index 910b73ca0..8c4a256b2 100644
--- a/javatests/dagger/producers/internal/ProducersTest.java
+++ b/javatests/dagger/producers/internal/ProducersTest.java
@@ -124,7 +124,7 @@ public void allAsSet_failure() throws Exception {
     }
   }
 
-  @Test public void producerFromProvider() throws Exception {
+  @Test public void producerFromProvider_doesntCache() throws Exception {
     Producer<Integer> producer = Producers.producerFromProvider(new Provider<Integer>() {
       int i = 0;
 
@@ -133,7 +133,7 @@ public void allAsSet_failure() throws Exception {
       }
     });
     assertThat(producer.get().get()).isEqualTo(0);
-    assertThat(producer.get().get()).isEqualTo(0);
-    assertThat(producer.get().get()).isEqualTo(0);
+    assertThat(producer.get().get()).isEqualTo(1);
+    assertThat(producer.get().get()).isEqualTo(2);
   }
 }
