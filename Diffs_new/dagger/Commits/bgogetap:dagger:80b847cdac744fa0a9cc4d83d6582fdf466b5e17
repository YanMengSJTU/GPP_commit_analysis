diff --git a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
index 0f5b57d11..b67e1d06b 100644
--- a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
@@ -17,12 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.Key;
 import dagger.model.RequestKind;
+import javax.lang.model.type.TypeMirror;
 
 /** A binding expression that depends on a framework instance. */
 final class DerivedFromFrameworkInstanceBindingExpression extends BindingExpression {
@@ -57,9 +59,22 @@ Expression getDependencyExpression(ClassName requestingClass) {
   @Override
   Expression getDependencyExpressionForComponentMethod(
       ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
-    Expression expression =
+    Expression frameworkInstance =
         componentBindingExpressions.getDependencyExpressionForComponentMethod(
             frameworkRequest, componentMethod, component);
-    return frameworkType.to(requestKind, expression, types);
+    Expression forRequestKind = frameworkType.to(requestKind, frameworkInstance, types);
+    TypeMirror rawReturnType = types.erasure(componentMethod.resolvedReturnType(types));
+    if (!types.isAssignable(forRequestKind.type(), rawReturnType)) {
+      checkState(
+          component.isAbstract(),
+          "FrameworkType.to() should always return an accessible type unless we're in "
+              + "ahead-of-time mode, where the framework instance type is erased since it's not "
+              + "publicly accessible, but the return type is accessible to the package. "
+              + "\n  Component: %s, method: %s",
+          component.name(),
+          componentMethod);
+      return forRequestKind.castTo(rawReturnType);
+    }
+    return forRequestKind;
   }
 }
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index d9bcdebc0..3e120df62 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -5172,6 +5172,58 @@ public void boundInstanceUsedOnlyInInitialize() {
         .containsElementsIn(generated);
   }
 
+  @Test
+  public void packagePrivate_derivedFromFrameworkInstance_ComponentMethod() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.PackagePrivate",
+            "package test;",
+            "",
+            "import dagger.Reusable;",
+            "import javax.inject.Inject;",
+            "",
+            "@Reusable", // Use @Reusable to force a framework field
+            "class PackagePrivate {",
+            "  @Inject PackagePrivate() {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  PackagePrivate packagePrivate();",
+            "}"));
+
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            GENERATION_OPTIONS_ANNOTATION,
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private Provider<PackagePrivate> packagePrivateProvider;",
+            "",
+            "  @Override",
+            "  public PackagePrivate packagePrivate() {",
+            "    return (PackagePrivate) getPackagePrivateProvider().get();",
+            "  }",
+            "",
+            "  protected Provider getPackagePrivateProvider() {",
+            "    return packagePrivateProvider;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .containsElementsIn(generatedLeaf);
+  }
+
   // TODO(ronshapiro): remove copies from AheadOfTimeSubcomponents*Test classes
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
