diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index a804cff1d..26c26d8a5 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -227,6 +227,7 @@ java_library(
         "GeneratedComponentModel.java",
         "GwtCompatibility.java",
         "ImmediateFutureBindingExpression.java",
+        "InaccessibleMapKeyProxyGenerator.java",
         "InjectionMethods.java",
         "InjectionOrProvisionProviderCreationExpression.java",
         "InstanceFactoryCreationExpression.java",
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 808bd9627..58ef85858 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -408,7 +408,7 @@ ContributionBinding delegateBinding(
    * Returns a {@link dagger.model.BindingKind#DELEGATE} binding used when there is no binding that
    * satisfies the {@code @Binds} declaration.
    */
-  ContributionBinding missingDelegateBinding(DelegateDeclaration delegateDeclaration) {
+  ContributionBinding unresolvedDelegateBinding(DelegateDeclaration delegateDeclaration) {
     return buildDelegateBinding(
         ProvisionBinding.builder().scope(uniqueScopeOf(delegateDeclaration.bindingElement().get())),
         delegateDeclaration,
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 8cdc35f03..6647eb6c2 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -509,7 +509,7 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
     private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDeclaration) {
       Key delegateKey = delegateDeclaration.delegateRequest().key();
       if (cycleStack.contains(delegateKey)) {
-        return bindingFactory.missingDelegateBinding(delegateDeclaration);
+        return bindingFactory.unresolvedDelegateBinding(delegateDeclaration);
       }
 
       ResolvedBindings resolvedDelegate;
@@ -529,7 +529,7 @@ private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDe
         // is needed.
         // TODO(gak): revisit how we model missing delegates if/when we clean up how we model
         // binding declarations
-        return bindingFactory.missingDelegateBinding(delegateDeclaration);
+        return bindingFactory.unresolvedDelegateBinding(delegateDeclaration);
       }
       // It doesn't matter which of these is selected, since they will later on produce a
       // duplicate binding error.
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index d08e2fad5..de5a8a7c0 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -28,7 +28,6 @@
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
-import static dagger.internal.codegen.MapKeys.mapKeyFactoryMethod;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkFieldUsages;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
@@ -119,7 +118,6 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     ProvisionMethod.create(binding, compilerOptions).ifPresent(factoryBuilder::addMethod);
     gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
-    mapKeyFactoryMethod(binding, types).ifPresent(factoryBuilder::addMethod);
 
     return factoryBuilder;
   }
diff --git a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
new file mode 100644
index 000000000..b486eb7e6
--- /dev/null
+++ b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Optional;
+import javax.annotation.processing.Filer;
+import javax.inject.Inject;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+
+/**
+ * Generates a class that exposes a non-{@code public} {@link ContributionBinding#mapKey()} @MapKey}
+ * annotation.
+ */
+final class InaccessibleMapKeyProxyGenerator extends SourceFileGenerator<ContributionBinding> {
+  private final DaggerTypes types;
+
+  @Inject
+  InaccessibleMapKeyProxyGenerator(
+      Filer filer, DaggerTypes types, DaggerElements elements, SourceVersion sourceVersion) {
+    super(filer, elements, sourceVersion);
+    this.types = types;
+  }
+
+  @Override
+  ClassName nameGeneratedType(ContributionBinding binding) {
+    return MapKeys.mapKeyProxyClassName(binding);
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(ContributionBinding binding) {
+    return binding.bindingElement();
+  }
+
+  @Override
+  Optional<TypeSpec.Builder> write(ClassName generatedName, ContributionBinding binding) {
+    return MapKeys.mapKeyFactoryMethod(binding, types)
+        .map(method -> classBuilder(generatedName).addModifiers(PUBLIC, FINAL).addMethod(method));
+  }
+}
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/MapKeys.java
index ad7e5e62a..d0a80e05c 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/MapKeys.java
@@ -22,11 +22,12 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.MapKeyAccessibility.isMapKeyPubliclyAccessible;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.elementBasedClassName;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
@@ -149,7 +150,7 @@ static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requ
     return MapKeyAccessibility.isMapKeyAccessibleFrom(
             mapKeyAnnotation, requestingClass.packageName())
         ? directMapKeyExpression(mapKeyAnnotation)
-        : CodeBlock.of("$T.mapKey()", generatedClassNameForBinding(binding));
+        : CodeBlock.of("$T.create()", mapKeyProxyClassName(binding));
   }
 
   /**
@@ -177,8 +178,18 @@ private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
   }
 
   /**
-   * A {@code static mapKey()} method to be added to generated factories when the {@code @MapKey}
-   * annotation is not publicly accessible.
+   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types)}
+   * is generated.
+   */
+  static ClassName mapKeyProxyClassName(ContributionBinding binding) {
+    return elementBasedClassName(
+        MoreElements.asExecutable(binding.bindingElement().get()), "MapKey");
+  }
+
+  /**
+   * A {@code static create()} method to be added to {@link
+   * #mapKeyProxyClassName(ContributionBinding)} when the {@code @MapKey} annotation is not publicly
+   * accessible.
    */
   static Optional<MethodSpec> mapKeyFactoryMethod(ContributionBinding binding, Types types) {
     return binding
@@ -186,7 +197,7 @@ private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
         .filter(mapKey -> !isMapKeyPubliclyAccessible(mapKey))
         .map(
             mapKey ->
-                methodBuilder("mapKey")
+                methodBuilder("create")
                     .addModifiers(PUBLIC, STATIC)
                     .returns(TypeName.get(mapKeyType(mapKey, types)))
                     .addStatement("return $L", directMapKeyExpression(mapKey))
diff --git a/java/dagger/internal/codegen/ModuleProcessingStep.java b/java/dagger/internal/codegen/ModuleProcessingStep.java
index b67a399b2..5e6609bfe 100644
--- a/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -24,8 +24,10 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.DelegateDeclaration.Factory;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
@@ -47,6 +49,8 @@
   private final BindingFactory bindingFactory;
   private final FactoryGenerator factoryGenerator;
   private final ProducerFactoryGenerator producerFactoryGenerator;
+  private final InaccessibleMapKeyProxyGenerator inaccessibleMapKeyProxyGenerator;
+  private final DelegateDeclaration.Factory delegateDeclarationFactory;
   private final Set<TypeElement> processedModuleElements = Sets.newLinkedHashSet();
 
   @Inject
@@ -55,12 +59,16 @@
       ModuleValidator moduleValidator,
       BindingFactory bindingFactory,
       FactoryGenerator factoryGenerator,
-      ProducerFactoryGenerator producerFactoryGenerator) {
+      ProducerFactoryGenerator producerFactoryGenerator,
+      InaccessibleMapKeyProxyGenerator inaccessibleMapKeyProxyGenerator,
+      Factory delegateDeclarationFactory) {
     this.messager = messager;
     this.moduleValidator = moduleValidator;
     this.bindingFactory = bindingFactory;
     this.factoryGenerator = factoryGenerator;
     this.producerFactoryGenerator = producerFactoryGenerator;
+    this.inaccessibleMapKeyProxyGenerator = inaccessibleMapKeyProxyGenerator;
+    this.delegateDeclarationFactory = delegateDeclarationFactory;
   }
 
   @Override
@@ -87,12 +95,24 @@ private void processModule(TypeElement module) {
     if (report.isClean()) {
       for (ExecutableElement method : methodsIn(module.getEnclosedElements())) {
         if (isAnnotationPresent(method, Provides.class)) {
-          factoryGenerator.generate(bindingFactory.providesMethodBinding(method, module), messager);
+          generate(factoryGenerator, bindingFactory.providesMethodBinding(method, module));
         } else if (isAnnotationPresent(method, Produces.class)) {
-          producerFactoryGenerator.generate(
-              bindingFactory.producesMethodBinding(method, module), messager);
+          generate(producerFactoryGenerator, bindingFactory.producesMethodBinding(method, module));
+        } else if (isAnnotationPresent(method, Binds.class)) {
+          inaccessibleMapKeyProxyGenerator.generate(bindsMethodBinding(module, method), messager);
         }
       }
     }
   }
+
+  private <B extends ContributionBinding> void generate(
+      SourceFileGenerator<B> generator, B binding) {
+    generator.generate(binding, messager);
+    inaccessibleMapKeyProxyGenerator.generate(binding, messager);
+  }
+
+  private ContributionBinding bindsMethodBinding(TypeElement module, ExecutableElement method) {
+    return bindingFactory.unresolvedDelegateBinding(
+        delegateDeclarationFactory.create(method, module));
+  }
 }
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 33c77bd71..6d292cfc5 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -24,7 +24,6 @@
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
-import static dagger.internal.codegen.MapKeys.mapKeyFactoryMethod;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
@@ -71,13 +70,11 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
  */
 final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
-  private final Types types;
   private final CompilerOptions compilerOptions;
 
   @Inject
@@ -85,10 +82,8 @@
       Filer filer,
       Elements elements,
       SourceVersion sourceVersion,
-      Types types,
       CompilerOptions compilerOptions) {
     super(filer, elements, sourceVersion);
-    this.types = types;
     this.compilerOptions = compilerOptions;
   }
 
@@ -231,7 +226,6 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     factoryBuilder.addMethod(executeMethodBuilder.build());
 
     gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
-    mapKeyFactoryMethod(binding, types).ifPresent(factoryBuilder::addMethod);
 
     // TODO(gak): write a sensible toString
     return Optional.of(factoryBuilder);
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/SourceFiles.java
index b36493f9d..b97fc764b 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/SourceFiles.java
@@ -40,6 +40,7 @@
 import static java.util.Comparator.comparing;
 import static javax.lang.model.SourceVersion.isName;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
@@ -67,6 +68,8 @@
 import javax.inject.Provider;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 
@@ -184,19 +187,12 @@ static ClassName generatedClassNameForBinding(Binding binding) {
       case PROVISION:
       case PRODUCTION:
         ContributionBinding contribution = (ContributionBinding) binding;
-        checkArgument(contribution.bindingTypeElement().isPresent());
-        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement().get());
         switch (contribution.kind()) {
           case INJECTION:
           case PROVISION:
           case PRODUCTION:
-            return enclosingClassName
-                .topLevelClassName()
-                .peerClass(
-                    classFileName(enclosingClassName)
-                        + "_"
-                        + factoryPrefix(contribution)
-                        + "Factory");
+            return elementBasedClassName(
+                MoreElements.asExecutable(binding.bindingElement().get()), "Factory");
 
           default:
             throw new AssertionError();
@@ -211,6 +207,25 @@ static ClassName generatedClassNameForBinding(Binding binding) {
     }
   }
 
+  /**
+   * Calculates an appropriate {@link ClassName} for a generated class that is based on {@code
+   * element}, appending {@code suffix} at the end.
+   *
+   * <p>This will always return a {@linkplain ClassName#topLevelClassName() top level class name},
+   * even if {@code element}'s enclosing class is a nested type.
+   */
+  static ClassName elementBasedClassName(ExecutableElement element, String suffix) {
+    ClassName enclosingClassName =
+        ClassName.get(MoreElements.asType(element.getEnclosingElement()));
+    String methodName =
+        element.getKind().equals(ElementKind.CONSTRUCTOR)
+            ? ""
+            : LOWER_CAMEL.to(UPPER_CAMEL, element.getSimpleName().toString());
+    return ClassName.get(
+        enclosingClassName.packageName(),
+        classFileName(enclosingClassName) + "_" + methodName + suffix);
+  }
+
   static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     ClassName className = generatedClassNameForBinding(binding);
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
@@ -280,21 +295,6 @@ static ClassName mapFactoryClassName(ContributionBinding binding) {
     }
   }
 
-  private static String factoryPrefix(ContributionBinding binding) {
-    switch (binding.kind()) {
-      case INJECTION:
-        return "";
-
-      case PROVISION:
-      case PRODUCTION:
-        return CaseFormat.LOWER_CAMEL.to(
-            UPPER_CAMEL, binding.bindingElement().get().getSimpleName().toString());
-
-      default:
-        throw new IllegalArgumentException();
-    }
-  }
-
   static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(Binding binding) {
     if (binding instanceof ContributionBinding) {
       ContributionBinding contributionBinding = (ContributionBinding) binding;
diff --git a/javatests/dagger/functional/multibindings/BindsInaccessibleMapKey.java b/javatests/dagger/functional/multibindings/BindsInaccessibleMapKey.java
new file mode 100644
index 000000000..6256812ea
--- /dev/null
+++ b/javatests/dagger/functional/multibindings/BindsInaccessibleMapKey.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multibindings;
+
+import dagger.Component;
+import dagger.functional.multibindings.subpackage.BindsInaccessibleMapKeyModule;
+import java.util.Map;
+
+// b/73820357
+@Component(modules = BindsInaccessibleMapKeyModule.class)
+interface BindsInaccessibleMapKey {
+  Map<Class<?>, Object> mapWithAnInaccessibleMapKey();
+}
diff --git a/javatests/dagger/functional/multibindings/subpackage/BindsInaccessibleMapKeyModule.java b/javatests/dagger/functional/multibindings/subpackage/BindsInaccessibleMapKeyModule.java
new file mode 100644
index 000000000..62df4ae4a
--- /dev/null
+++ b/javatests/dagger/functional/multibindings/subpackage/BindsInaccessibleMapKeyModule.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multibindings.subpackage;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.IntoMap;
+import javax.inject.Inject;
+
+@Module
+public abstract class BindsInaccessibleMapKeyModule {
+  @Binds
+  @IntoMap
+  @ClassKey(Inaccessible.class)
+  abstract Object bindInaccessibleMapKey(Inaccessible inaccessible);
+
+  static class Inaccessible {
+    @Inject Inaccessible() {}
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index a66e594f5..d6968b427 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -330,13 +330,6 @@ public void mapBindingsWithInaccessibleKeys() {
                 "test.DaggerTestComponent",
                 "package test;",
                 "",
-                "import mapkeys.MapKeys;",
-                "import mapkeys.MapModule_ClassKeyFactory;",
-                "import mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory;",
-                "import mapkeys.MapModule_ComplexKeyWithInaccessibleArrayValueFactory;",
-                "import mapkeys.MapModule_ComplexKeyWithInaccessibleValueFactory;",
-                "import mapkeys.MapModule_EnumKeyFactory;",
-                "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private Provider<Map<Class<?>, Integer>> mapOfClassOfAndIntegerProvider;",
@@ -349,31 +342,31 @@ public void mapBindingsWithInaccessibleKeys() {
                 "",
                 "  private Map getMapOfPackagePrivateEnumAndInteger() {",
                 "    return ImmutableMap.of(",
-                "        MapModule_EnumKeyFactory.mapKey(), MapModule.enumKey());",
+                "        MapModule_EnumKeyMapKey.create(), MapModule.enumKey());",
                 "  }",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
                 "  private void initialize(final Builder builder) {",
                 "    this.mapOfClassOfAndIntegerProvider =",
                 "        MapFactory.<Class<?>, Integer>builder(1)",
-                "            .put(MapModule_ClassKeyFactory.mapKey(),",
+                "            .put(MapModule_ClassKeyMapKey.create(),",
                 "                 MapModule_ClassKeyFactory.create())",
                 "            .build();",
                 "    this.mapOfPackagePrivateEnumAndIntegerProvider =",
                 "        MapFactory.builder(1)",
-                "            .put(MapModule_EnumKeyFactory.mapKey(), ",
+                "            .put(MapModule_EnumKeyMapKey.create(), ",
                 "                 (Provider) MapModule_EnumKeyFactory.create())",
                 "            .build();",
                 "    this.mapOfComplexKeyAndIntegerProvider =",
                 "       MapFactory.<MapKeys.ComplexKey, Integer>builder(3)",
                 "          .put(",
-                "             MapModule_ComplexKeyWithInaccessibleValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleValueMapKey.create(),",
                 "             MapModule_ComplexKeyWithInaccessibleValueFactory.create())",
                 "          .put(",
-                "             MapModule_ComplexKeyWithInaccessibleArrayValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleArrayValueMapKey.create(),",
                 "             MapModule_ComplexKeyWithInaccessibleArrayValueFactory.create())",
                 "          .put(",
-                "             MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleAnnotationValueMapKey.create(),",
                 "             MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.create())",
                 "          .build();",
                 "  }",
@@ -381,7 +374,7 @@ public void mapBindingsWithInaccessibleKeys() {
                 "  @Override",
                 "  public Map<Class<?>, Integer> classKey() {",
                 "    return ImmutableMap.<Class<?>, Integer>of(",
-                "        MapModule_ClassKeyFactory.mapKey(), MapModule.classKey());",
+                "        MapModule_ClassKeyMapKey.create(), MapModule.classKey());",
                 "  }",
                 "",
                 "  @Override",
@@ -402,11 +395,11 @@ public void mapBindingsWithInaccessibleKeys() {
                 "  @Override",
                 "  public Map<MapKeys.ComplexKey, Integer> complexKey() {",
                 "    return ImmutableMap.<MapKeys.ComplexKey, Integer>of(",
-                "        MapModule_ComplexKeyWithInaccessibleValueFactory.mapKey(),",
+                "        MapModule_ComplexKeyWithInaccessibleValueMapKey.create(),",
                 "        MapModule.complexKeyWithInaccessibleValue(),",
-                "        MapModule_ComplexKeyWithInaccessibleArrayValueFactory.mapKey(),",
+                "        MapModule_ComplexKeyWithInaccessibleArrayValueMapKey.create(),",
                 "        MapModule.complexKeyWithInaccessibleArrayValue(),",
-                "        MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.mapKey(),",
+                "        MapModule_ComplexKeyWithInaccessibleAnnotationValueMapKey.create(),",
                 "        MapModule.complexKeyWithInaccessibleAnnotationValue());",
                 "  }",
                 "",
@@ -417,23 +410,15 @@ public void mapBindingsWithInaccessibleKeys() {
                 "}"));
     assertThat(compilation)
         .generatedSourceFile(
-            "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory")
+            "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueMapKey")
         .containsElementsIn(
             JavaFileObjects.forSourceLines(
-                "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory",
+                "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueMapKey",
                 "package mapkeys;",
                 "",
                 GENERATED_ANNOTATION,
-                "public final class",
-                "    MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory",
-                "        implements Factory<Integer> {",
-                "",
-                "  @Override",
-                "  public Integer get() {",
-                "    return MapModule.complexKeyWithInaccessibleAnnotationValue();",
-                "  }",
-                "",
-                "  public static MapKeys.ComplexKey mapKey() {",
+                "public final class MapModule_ComplexKeyWithInaccessibleAnnotationValueMapKey {",
+                "  public static MapKeys.ComplexKey create() {",
                 "    return MapKeys_ComplexKeyCreator.createComplexKey(",
                 "        new Class[] {String.class},",
                 "        String.class,",
@@ -441,20 +426,15 @@ public void mapBindingsWithInaccessibleKeys() {
                 "  }",
                 "}"));
     assertThat(compilation)
-        .generatedSourceFile("mapkeys.MapModule_ClassKeyFactory")
+        .generatedSourceFile("mapkeys.MapModule_ClassKeyMapKey")
         .containsElementsIn(
             JavaFileObjects.forSourceLines(
-                "mapkeys.MapModule_ClassKeyFactory",
+                "mapkeys.MapModule_ClassKeyMapKey",
                 "package mapkeys;",
                 "",
                 GENERATED_ANNOTATION,
-                "public final class MapModule_ClassKeyFactory implements Factory<Integer> {",
-                "  @Override",
-                "  public Integer get() {",
-                "    return MapModule.classKey();",
-                "  }",
-                "",
-                "  public static Class<?> mapKey() {",
+                "public final class MapModule_ClassKeyMapKey {",
+                "  public static Class<?> create() {",
                 "    return MapKeys.Inaccessible.class;",
                 "  }",
                 "}"));
