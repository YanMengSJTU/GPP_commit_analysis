diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 0b5996384..ef1c4c841 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -204,7 +204,7 @@ BindingExpression getBindingExpression(BindingRequest request) {
     ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
     if (resolvedBindings != null
         && !resolvedBindings.bindingsOwnedBy(graph.componentDescriptor()).isEmpty()) {
-      BindingExpression expression = createBindingExpression(resolvedBindings, request);
+      BindingExpression expression = createBindingExpression(resolvedBindings.binding(), request);
       expressions.put(request, expression);
       return expression;
     }
@@ -214,30 +214,28 @@ BindingExpression getBindingExpression(BindingRequest request) {
   }
 
   /** Creates a binding expression. */
-  BindingExpression createBindingExpression(
-      ResolvedBindings resolvedBindings, BindingRequest request) {
-    switch (resolvedBindings.bindingType()) {
+  private BindingExpression createBindingExpression(Binding binding, BindingRequest request) {
+    switch (binding.bindingType()) {
       case MEMBERS_INJECTION:
         checkArgument(request.isRequestKind(RequestKind.MEMBERS_INJECTION));
         return new MembersInjectionBindingExpression(
-            resolvedBindings.membersInjectionBinding().get(), membersInjectionMethods);
+            (MembersInjectionBinding) binding, membersInjectionMethods);
 
       case PROVISION:
-        return provisionBindingExpression(resolvedBindings, request);
+        return provisionBindingExpression((ContributionBinding) binding, request);
 
       case PRODUCTION:
-        return productionBindingExpression(resolvedBindings, request);
+        return productionBindingExpression((ContributionBinding) binding, request);
     }
-    throw new AssertionError(resolvedBindings);
+    throw new AssertionError(binding);
   }
 
   /**
    * Returns a binding expression that uses a {@link javax.inject.Provider} for provision bindings
    * or a {@link dagger.producers.Producer} for production bindings.
    */
-  private BindingExpression frameworkInstanceBindingExpression(ResolvedBindings resolvedBindings) {
+  private BindingExpression frameworkInstanceBindingExpression(ContributionBinding binding) {
     // TODO(user): Consider merging the static factory creation logic into CreationExpressions?
-    ContributionBinding binding = resolvedBindings.contributionBinding();
     Optional<MemberSelect> staticMethod =
         useStaticFactoryCreation(binding) ? staticFactoryCreation(binding) : Optional.empty();
     FrameworkInstanceCreationExpression frameworkInstanceCreationExpression =
@@ -248,7 +246,7 @@ private BindingExpression frameworkInstanceBindingExpression(ResolvedBindings re
         staticMethod.isPresent()
             ? staticMethod::get
             : new FrameworkFieldInitializer(
-                componentImplementation, resolvedBindings, frameworkInstanceCreationExpression);
+                componentImplementation, binding, frameworkInstanceCreationExpression);
 
     switch (binding.bindingType()) {
       case PROVISION:
@@ -348,22 +346,22 @@ private InstanceFactoryCreationExpression instanceFactoryCreationExpression(
 
   /** Returns a binding expression for a provision binding. */
   private BindingExpression provisionBindingExpression(
-      ResolvedBindings resolvedBindings, BindingRequest request) {
+      ContributionBinding binding, BindingRequest request) {
     if (!request.requestKind().isPresent()) {
       verify(
           request.frameworkType().get().equals(FrameworkType.PRODUCER_NODE),
           "expected a PRODUCER_NODE: %s",
           request);
-      return producerFromProviderBindingExpression(resolvedBindings);
+      return producerFromProviderBindingExpression(binding);
     }
     RequestKind requestKind = request.requestKind().get();
     Key key = request.key();
     switch (requestKind) {
       case INSTANCE:
-        return instanceBindingExpression(resolvedBindings);
+        return instanceBindingExpression(binding);
 
       case PROVIDER:
-        return providerBindingExpression(resolvedBindings);
+        return providerBindingExpression(binding);
 
       case LAZY:
       case PRODUCED:
@@ -372,7 +370,7 @@ private BindingExpression provisionBindingExpression(
             key, FrameworkType.PROVIDER, requestKind, this, types);
 
       case PRODUCER:
-        return producerFromProviderBindingExpression(resolvedBindings);
+        return producerFromProviderBindingExpression(binding);
 
       case FUTURE:
         return new ImmediateFutureBindingExpression(key, this, types, sourceVersion);
@@ -386,9 +384,9 @@ private BindingExpression provisionBindingExpression(
 
   /** Returns a binding expression for a production binding. */
   private BindingExpression productionBindingExpression(
-      ResolvedBindings resolvedBindings, BindingRequest request) {
+      ContributionBinding binding, BindingRequest request) {
     if (request.frameworkType().isPresent()) {
-      return frameworkInstanceBindingExpression(resolvedBindings);
+      return frameworkInstanceBindingExpression(binding);
     } else {
       // If no FrameworkType is present, a RequestKind is guaranteed to be present.
       RequestKind requestKind = request.requestKind().get();
@@ -409,21 +407,20 @@ private BindingExpression productionBindingExpression(
    *
    * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
    */
-  private BindingExpression providerBindingExpression(ResolvedBindings resolvedBindings) {
-    ContributionBinding binding = resolvedBindings.contributionBinding();
+  private BindingExpression providerBindingExpression(ContributionBinding binding) {
     if (binding.kind().equals(DELEGATE) && !needsCaching(binding)) {
       return new DelegateBindingExpression(
           binding, RequestKind.PROVIDER, this, types, elements);
     } else if (compilerOptions.fastInit()
         && frameworkInstanceCreationExpression(binding).useInnerSwitchingProvider()
-        && !(instanceBindingExpression(resolvedBindings)
+        && !(instanceBindingExpression(binding)
             instanceof DerivedFromFrameworkInstanceBindingExpression)) {
       return wrapInMethod(
-          resolvedBindings,
+          binding,
           bindingRequest(binding.key(), RequestKind.PROVIDER),
           innerSwitchingProviders.newBindingExpression(binding));
     }
-    return frameworkInstanceBindingExpression(resolvedBindings);
+    return frameworkInstanceBindingExpression(binding);
   }
 
   /**
@@ -431,14 +428,13 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
    * provision binding.
    */
   private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
-      ResolvedBindings resolvedBindings) {
-    ContributionBinding binding = resolvedBindings.contributionBinding();
+      ContributionBinding binding) {
     checkArgument(binding.bindingType().equals(BindingType.PROVISION));
     return new ProducerNodeInstanceBindingExpression(
         binding,
         new FrameworkFieldInitializer(
             componentImplementation,
-            resolvedBindings,
+            binding,
             new ProducerFromProviderCreationExpression(binding, componentImplementation, this)),
         types,
         elements,
@@ -454,15 +450,14 @@ private FrameworkInstanceBindingExpression producerFromProviderBindingExpression
    *
    * <p>In fastInit mode, we can use direct expressions unless the binding needs to be cached.
    */
-  private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBindings) {
-    ContributionBinding binding = resolvedBindings.contributionBinding();
+  private BindingExpression instanceBindingExpression(ContributionBinding binding) {
     Optional<BindingExpression> maybeDirectInstanceExpression =
         unscopedDirectInstanceExpression(binding);
     if (canUseDirectInstanceExpression(binding) && maybeDirectInstanceExpression.isPresent()) {
       BindingExpression directInstanceExpression = maybeDirectInstanceExpression.get();
       return directInstanceExpression.requiresMethodEncapsulation() || needsCaching(binding)
           ? wrapInMethod(
-              resolvedBindings,
+              binding,
               bindingRequest(binding.key(), RequestKind.INSTANCE),
               directInstanceExpression)
           : directInstanceExpression;
@@ -583,7 +578,7 @@ private boolean canUseDirectInstanceExpression(ContributionBinding binding) {
    * modifiable, then a new private method will be written.
    */
   BindingExpression wrapInMethod(
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       BindingRequest request,
       BindingExpression bindingExpression) {
     // If we've already wrapped the expression, then use the delegate.
@@ -592,7 +587,7 @@ BindingExpression wrapInMethod(
     }
 
     MethodImplementationStrategy methodImplementationStrategy =
-        methodImplementationStrategy(resolvedBindings.contributionBinding(), request);
+        methodImplementationStrategy(binding, request);
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
         graph.componentDescriptor().firstMatchingComponentMethod(request);
 
@@ -600,7 +595,7 @@ BindingExpression wrapInMethod(
       ComponentMethodDescriptor componentMethod = matchingComponentMethod.get();
       return new ComponentMethodBindingExpression(
           request,
-          resolvedBindings,
+          binding,
           methodImplementationStrategy,
           bindingExpression,
           componentImplementation,
@@ -609,7 +604,7 @@ BindingExpression wrapInMethod(
     } else {
       return new PrivateMethodBindingExpression(
           request,
-          resolvedBindings,
+          binding,
           methodImplementationStrategy,
           bindingExpression,
           componentImplementation,
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index 7e7bbd839..3f9f1373f 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -36,7 +36,7 @@
 
   ComponentMethodBindingExpression(
       BindingRequest request,
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       MethodImplementationStrategy methodImplementationStrategy,
       BindingExpression wrappedBindingExpression,
       ComponentImplementation componentImplementation,
@@ -44,7 +44,7 @@
       DaggerTypes types) {
     super(
         request,
-        resolvedBindings,
+        binding,
         methodImplementationStrategy,
         wrappedBindingExpression,
         componentImplementation,
diff --git a/java/dagger/internal/codegen/FrameworkField.java b/java/dagger/internal/codegen/FrameworkField.java
index de2ada047..038c8e69b 100644
--- a/java/dagger/internal/codegen/FrameworkField.java
+++ b/java/dagger/internal/codegen/FrameworkField.java
@@ -62,38 +62,33 @@ static FrameworkField create(
   }
 
   /**
-   * A framework field for a {@link ResolvedBindings}.
+   * A framework field for a {@link ContributionBinding}.
    * 
    * @param frameworkClass if present, the field will use this framework class instead of the normal
-   *     one for the bindings
+   *     one for the binding's type.
    */
-  static FrameworkField forResolvedBindings(
-      ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
+  static FrameworkField forBinding(
+      ContributionBinding binding, Optional<ClassName> frameworkClass) {
     return create(
         frameworkClass.orElse(
             ClassName.get(
-                FrameworkType.forBindingType(resolvedBindings.bindingType()).frameworkClass())),
-        TypeName.get(fieldValueType(resolvedBindings)),
-        frameworkFieldName(resolvedBindings));
+                FrameworkType.forBindingType(binding.bindingType()).frameworkClass())),
+        TypeName.get(fieldValueType(binding)),
+        frameworkFieldName(binding));
   }
 
-  private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
-    return resolvedBindings.isMultibindingContribution()
-        ? resolvedBindings.contributionBinding().contributedType()
-        : resolvedBindings.key().type();
+  private static TypeMirror fieldValueType(ContributionBinding binding) {
+    return binding.contributionType().isMultibinding()
+        ? binding.contributedType()
+        : binding.key().type();
   }
 
-  private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
-    if (!resolvedBindings.contributionBindings().isEmpty()) {
-      ContributionBinding binding = resolvedBindings.contributionBinding();
-      if (binding.bindingElement().isPresent()) {
-        String name = BINDING_ELEMENT_NAME.visit(binding.bindingElement().get(), binding);
-        return binding.kind().equals(MEMBERS_INJECTOR)
-            ? name + "MembersInjector"
-            : name;
-      }
+  private static String frameworkFieldName(ContributionBinding binding) {
+    if (binding.bindingElement().isPresent()) {
+      String name = BINDING_ELEMENT_NAME.visit(binding.bindingElement().get(), binding);
+      return binding.kind().equals(MEMBERS_INJECTOR) ? name + "MembersInjector" : name;
     }
-    return KeyVariableNamer.name(resolvedBindings.key());
+    return KeyVariableNamer.name(binding.key());
   }
 
   private static final ElementVisitor<String, Binding> BINDING_ELEMENT_NAME =
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index c0a555281..7aa2ae953 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -67,17 +67,17 @@ default boolean useInnerSwitchingProvider() {
   }
 
   private final ComponentImplementation componentImplementation;
-  private final ResolvedBindings resolvedBindings;
+  private final ContributionBinding binding;
   private final FrameworkInstanceCreationExpression frameworkInstanceCreationExpression;
   private FieldSpec fieldSpec;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   FrameworkFieldInitializer(
       ComponentImplementation componentImplementation,
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       FrameworkInstanceCreationExpression frameworkInstanceCreationExpression) {
     this.componentImplementation = checkNotNull(componentImplementation);
-    this.resolvedBindings = checkNotNull(resolvedBindings);
+    this.binding = checkNotNull(binding);
     this.frameworkInstanceCreationExpression = checkNotNull(frameworkInstanceCreationExpression);
   }
 
@@ -133,10 +133,10 @@ private FieldSpec getOrCreateField() {
     if (fieldSpec != null) {
       return fieldSpec;
     }
-    boolean useRawType = !componentImplementation.isTypeAccessible(resolvedBindings.key().type());
+    boolean useRawType = !componentImplementation.isTypeAccessible(binding.key().type());
     FrameworkField contributionBindingField =
-        FrameworkField.forResolvedBindings(
-            resolvedBindings, frameworkInstanceCreationExpression.alternativeFrameworkClass());
+        FrameworkField.forBinding(
+            binding, frameworkInstanceCreationExpression.alternativeFrameworkClass());
 
     TypeName fieldType =
         useRawType ? contributionBindingField.type().rawType : contributionBindingField.type();
@@ -160,7 +160,7 @@ private FieldSpec getOrCreateField() {
   }
 
   private boolean isProvider() {
-    return resolvedBindings.bindingType().equals(BindingType.PROVISION)
+    return binding.bindingType().equals(BindingType.PROVISION)
         && frameworkInstanceCreationExpression
             .alternativeFrameworkClass()
             .map(TypeNames.PROVIDER::equals)
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index 952eae687..915d9a58b 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -39,7 +39,6 @@
 /** A binding expression that wraps another in a nullary method on the component. */
 abstract class MethodBindingExpression extends BindingExpression {
   private final BindingRequest request;
-  private final ResolvedBindings resolvedBindings;
   private final ContributionBinding binding;
   private final BindingMethodImplementation bindingMethodImplementation;
   private final ComponentImplementation componentImplementation;
@@ -49,14 +48,13 @@
 
   protected MethodBindingExpression(
       BindingRequest request,
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       MethodImplementationStrategy methodImplementationStrategy,
       BindingExpression wrappedBindingExpression,
       ComponentImplementation componentImplementation,
       DaggerTypes types) {
     this.request = checkNotNull(request);
-    this.resolvedBindings = resolvedBindings;
-    this.binding = resolvedBindings.contributionBinding();
+    this.binding = checkNotNull(binding);
     this.bindingMethodImplementation = bindingMethodImplementation(methodImplementationStrategy);
     this.wrappedBindingExpression = checkNotNull(wrappedBindingExpression);
     this.componentImplementation = checkNotNull(componentImplementation);
@@ -215,10 +213,7 @@ FieldSpec createField() {
           componentImplementation.getUniqueFieldName(
               request.isRequestKind(RequestKind.INSTANCE)
                   ? KeyVariableNamer.name(binding.key())
-                  // TODO(ronshapiro): Use KeyVariableNamer directly so we don't need to use a
-                  // ResolvedBindings instance and construct a whole framework field just to get the
-                  // name
-                  : FrameworkField.forResolvedBindings(resolvedBindings, Optional.empty()).name());
+                  : FrameworkField.forBinding(binding, Optional.empty()).name());
 
       FieldSpec.Builder builder = FieldSpec.builder(fieldType(), name, PRIVATE, VOLATILE);
       if (isNullable()) {
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 482c12320..3152e306b 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -37,14 +37,14 @@
 
   PrivateMethodBindingExpression(
       BindingRequest request,
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       MethodImplementationStrategy methodImplementationStrategy,
       BindingExpression wrappedBindingExpression,
       ComponentImplementation componentImplementation,
       DaggerTypes types) {
     super(
         request,
-        resolvedBindings,
+        binding,
         methodImplementationStrategy,
         wrappedBindingExpression,
         componentImplementation,
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index 814995a42..406b3b1a0 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -200,14 +200,6 @@ static ResolvedBindings noBindings(Key key) {
         ImmutableSet.of());
   }
 
-  /**
-   * {@code true} if this is a multibinding contribution.
-   */
-  boolean isMultibindingContribution() {
-    return contributionBindings().size() == 1
-        && contributionBinding().contributionType().isMultibinding();
-  }
-
   /**
    * Returns the single contribution binding.
    *
