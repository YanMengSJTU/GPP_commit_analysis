diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index f58382cff..7028151df 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -39,7 +39,6 @@
 import com.squareup.javapoet.MethodSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.model.DependencyRequest;
 import dagger.model.RequestKind;
 import java.util.HashMap;
@@ -639,44 +638,30 @@ BindingExpression wrapInMethod(
       return bindingExpression;
     }
 
+    ContributionBinding binding = resolvedBindings.contributionBinding();
     BindingMethodImplementation methodImplementation =
         methodImplementation(resolvedBindings, request, bindingExpression);
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
         graph.componentDescriptor().firstMatchingComponentMethod(request);
-    Optional<ModifiableBindingMethod> matchingModifiableBindingMethod =
-        componentImplementation.getModifiableBindingMethod(request);
 
-    Optional<BindingExpression> modifiableBindingExpression =
-        modifiableBindingExpressions.maybeWrapInModifiableMethodBindingExpression(
-            resolvedBindings,
-            request,
-            methodImplementation,
-            matchingComponentMethod,
-            matchingModifiableBindingMethod);
-    if (modifiableBindingExpression.isPresent()) {
-      return modifiableBindingExpression.get();
+    if (modifiableBindingExpressions.getModifiableBindingType(request).isModifiable()
+        && (componentImplementation.superclassImplementation().isPresent()
+            || !matchingComponentMethod.isPresent())) {
+      return modifiableBindingExpressions.wrapInModifiableMethodBindingExpression(
+          binding, request, methodImplementation);
+    } else if (matchingComponentMethod.isPresent()) {
+      ComponentMethodDescriptor componentMethod = matchingComponentMethod.get();
+      return new ComponentMethodBindingExpression(
+          request, methodImplementation, componentImplementation, componentMethod, types);
+    } else {
+      return new PrivateMethodBindingExpression(
+          binding, request, methodImplementation, componentImplementation, types);
     }
-
-    return matchingComponentMethod
-        .<BindingExpression>map(
-            componentMethod ->
-                new ComponentMethodBindingExpression(
-                    methodImplementation,
-                    componentImplementation,
-                    componentMethod,
-                    matchingModifiableBindingMethod,
-                    types))
-        .orElseGet(
-            () ->
-                new PrivateMethodBindingExpression(
-                    resolvedBindings,
-                    request,
-                    methodImplementation,
-                    componentImplementation,
-                    matchingModifiableBindingMethod,
-                    types));
   }
 
+  // TODO(ronshapiro): pass ContributionBinding directly instead of ResolvedBindings. The
+  // ResolvedBindings type is only needed in one case, and it seems like it could be removed. The
+  // rest seem could all use a ContributionBinding directly
   private BindingMethodImplementation methodImplementation(
       ResolvedBindings resolvedBindings,
       BindingRequest request,
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index 2067aa730..21a24418e 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -21,8 +21,6 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import java.util.Optional;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -36,12 +34,12 @@
   private final ComponentMethodDescriptor componentMethod;
 
   ComponentMethodBindingExpression(
+      BindingRequest request,
       BindingMethodImplementation methodImplementation,
       ComponentImplementation componentImplementation,
       ComponentMethodDescriptor componentMethod,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
       DaggerTypes types) {
-    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod, types);
+    super(request, methodImplementation, componentImplementation, types);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.componentImplementation = checkNotNull(componentImplementation);
     this.componentMethod = checkNotNull(componentMethod);
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index 461da98ec..fce9fb5a5 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -27,20 +27,19 @@
 
 /** A binding expression that wraps another in a nullary method on the component. */
 abstract class MethodBindingExpression extends BindingExpression {
-
+  private final BindingRequest request;
   private final BindingMethodImplementation methodImplementation;
   private final ComponentImplementation componentImplementation;
-  private final Optional<ModifiableBindingMethod> matchingModifiableBindingMethod;
   private final ProducerEntryPointView producerEntryPointView;
 
   protected MethodBindingExpression(
+      BindingRequest request,
       BindingMethodImplementation methodImplementation,
       ComponentImplementation componentImplementation,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
       DaggerTypes types) {
+    this.request = checkNotNull(request);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.componentImplementation = checkNotNull(componentImplementation);
-    this.matchingModifiableBindingMethod = checkNotNull(matchingModifiableBindingMethod);
     this.producerEntryPointView = new ProducerEntryPointView(types);
   }
 
@@ -61,14 +60,24 @@ final CodeBlock getModifiableBindingMethodImplementation(
     // and we are now implementing it. If there is no matching method we need to first create the
     // method. We create the method by deferring to getDependencyExpression (defined above) via a
     // call to super.getModifiableBindingMethodImplementation().
-    if (matchingModifiableBindingMethod.isPresent()) {
+    if (supertypeModifiableBindingMethod().isPresent()) {
       checkState(
-          matchingModifiableBindingMethod.get().fulfillsSameRequestAs(modifiableBindingMethod));
+          supertypeModifiableBindingMethod().get().fulfillsSameRequestAs(modifiableBindingMethod));
       return methodImplementation.body();
     }
     return super.getModifiableBindingMethodImplementation(modifiableBindingMethod, component);
   }
 
+  /**
+   * Returns the {@link ModifiableBindingMethod} of a supertype for this method's {@link #request},
+   * if one exists.
+   */
+  protected final Optional<ModifiableBindingMethod> supertypeModifiableBindingMethod() {
+    return componentImplementation
+        .superclassImplementation()
+        .flatMap(superImplementation -> superImplementation.getModifiableBindingMethod(request));
+  }
+
   @Override
   Expression getDependencyExpressionForComponentMethod(ComponentMethodDescriptor componentMethod,
       ComponentImplementation component) {
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index cad0b8b19..e8b840968 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -239,7 +239,7 @@ private BindingExpression createModifiableBindingExpression(
    * The reason why a binding may need to be modified across implementations of a subcomponent, if
    * at all.
    */
-  private ModifiableBindingType getModifiableBindingType(BindingRequest request) {
+  ModifiableBindingType getModifiableBindingType(BindingRequest request) {
     if (!compilerOptions.aheadOfTimeSubcomponents()) {
       return ModifiableBindingType.NONE;
     }
@@ -417,48 +417,22 @@ private boolean resolvedInThisComponent(BindingRequest request) {
   }
 
   /**
-   * Returns a binding expression that invokes a method whose implementation is the given binding
-   * expression. It will only return such an expression if the binding represents a modifiable
-   * binding that should be wrapped in a method. We wrap expressions in this way so we can modify
-   * the binding when generating a subcomponent subclass by overriding the method.
+   * Wraps a modifiable binding expression in a method that can be overridden in a subclass
+   * implementation.
    */
-  Optional<BindingExpression> maybeWrapInModifiableMethodBindingExpression(
-      ResolvedBindings resolvedBindings,
+  BindingExpression wrapInModifiableMethodBindingExpression(
+      ContributionBinding binding,
       BindingRequest request,
-      BindingMethodImplementation methodImplementation,
-      Optional<ComponentMethodDescriptor> matchingComponentMethod,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
+      BindingMethodImplementation methodImplementation) {
     ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
-    if (shouldUseAModifiableConcreteMethodBindingExpression(
-        modifiableBindingType, matchingComponentMethod)) {
-      return Optional.of(
-          new ModifiableConcreteMethodBindingExpression(
-              resolvedBindings,
-              request,
-              modifiableBindingType,
-              methodImplementation,
-              componentImplementation,
-              matchingModifiableBindingMethod,
-              newModifiableBindingWillBeFinalized(modifiableBindingType, request),
-              types));
-    }
-    return Optional.empty();
-  }
-
-  /**
-   * Returns true if we should wrap a binding expression using a {@link
-   * ModifiableConcreteMethodBindingExpression}. If we're generating the abstract base class of a
-   * subcomponent and the binding matches a component method, even if it is modifiable, then it
-   * should be "wrapped" by a {@link ComponentMethodBindingExpression}. If it isn't a base class
-   * then modifiable methods should be handled by a {@link
-   * ModifiableConcreteMethodBindingExpression}. When generating an inner subcomponent it doesn't
-   * matter whether the binding matches a component method: All modifiable bindings should be
-   * handled by a {@link ModifiableConcreteMethodBindingExpression}.
-   */
-  private boolean shouldUseAModifiableConcreteMethodBindingExpression(
-      ModifiableBindingType type, Optional<ComponentMethodDescriptor> matchingComponentMethod) {
-    return type.isModifiable()
-        && (componentImplementation.superclassImplementation().isPresent()
-            || !matchingComponentMethod.isPresent());
+    checkState(modifiableBindingType.isModifiable());
+    return new ModifiableConcreteMethodBindingExpression(
+        binding,
+        request,
+        modifiableBindingType,
+        methodImplementation,
+        componentImplementation,
+        newModifiableBindingWillBeFinalized(modifiableBindingType, request),
+        types);
   }
 }
diff --git a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
index efecb4a5d..429cd5ec0 100644
--- a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
@@ -23,7 +23,6 @@
 import static javax.lang.model.element.Modifier.PROTECTED;
 
 import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import java.util.Optional;
 
 /**
@@ -38,43 +37,47 @@
   private final BindingMethodImplementation methodImplementation;
   private final ComponentImplementation componentImplementation;
   private final boolean bindingCannotBeModified;
-  private Optional<String> methodName;
+  private Optional<String> methodName = Optional.empty();
 
   ModifiableConcreteMethodBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       BindingRequest request,
       ModifiableBindingType modifiableBindingType,
       BindingMethodImplementation methodImplementation,
       ComponentImplementation componentImplementation,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
       boolean bindingCannotBeModified,
       DaggerTypes types) {
-    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod, types);
-    this.binding = resolvedBindings.contributionBinding();
+    super(request, methodImplementation, componentImplementation, types);
+    this.binding = checkNotNull(binding);
     this.request = checkNotNull(request);
     this.modifiableBindingType = checkNotNull(modifiableBindingType);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.componentImplementation = checkNotNull(componentImplementation);
     this.bindingCannotBeModified = bindingCannotBeModified;
-    this.methodName =
-        matchingModifiableBindingMethod.map(modifiableMethod -> modifiableMethod.methodSpec().name);
   }
 
   @Override
   protected void addMethod() {
-    // Add the modifiable binding method to the component if we haven't already.
-    if (!methodName.isPresent()) {
-      methodName = Optional.of(componentImplementation.getUniqueMethodName(request, binding));
-      componentImplementation.addModifiableBindingMethod(
-          modifiableBindingType,
-          request,
-          methodBuilder(methodName.get())
-              .addModifiers(bindingCannotBeModified ? PRIVATE : PROTECTED)
-              .returns(TypeName.get(methodImplementation.returnType()))
-              .addCode(methodImplementation.body())
-              .build(),
-          bindingCannotBeModified);
+    if (methodName.isPresent()) {
+      return;
+    }
+
+    if (supertypeModifiableBindingMethod().isPresent()) {
+      methodName = supertypeModifiableBindingMethod().map(method -> method.methodSpec().name);
+      return;
     }
+
+    // Add the modifiable binding method to the component if we haven't already.
+    methodName = Optional.of(componentImplementation.getUniqueMethodName(request, binding));
+    componentImplementation.addModifiableBindingMethod(
+        modifiableBindingType,
+        request,
+        methodBuilder(methodName.get())
+            .addModifiers(bindingCannotBeModified ? PRIVATE : PROTECTED)
+            .returns(TypeName.get(methodImplementation.returnType()))
+            .addCode(methodImplementation.body())
+            .build(),
+        bindingCannotBeModified);
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 4fb43ec8f..0d6fc666d 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -23,8 +23,6 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import java.util.Optional;
 
 /**
  * A binding expression that wraps the dependency expressions in a private, no-arg method.
@@ -39,14 +37,13 @@
   private String methodName;
 
   PrivateMethodBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       BindingRequest request,
       BindingMethodImplementation methodImplementation,
       ComponentImplementation componentImplementation,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
       DaggerTypes types) {
-    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod, types);
-    this.binding = resolvedBindings.contributionBinding();
+    super(request, methodImplementation, componentImplementation, types);
+    this.binding = checkNotNull(binding);
     this.request = checkNotNull(request);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.componentImplementation = checkNotNull(componentImplementation);
