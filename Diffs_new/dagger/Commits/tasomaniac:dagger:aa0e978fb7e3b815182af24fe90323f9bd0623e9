diff --git a/android.md b/android.md
index 6c66a1585..9b9f15d16 100644
--- a/android.md
+++ b/android.md
@@ -231,15 +231,20 @@ public interface YourActivityOrYourApplicationComponent { ... }
 
 Because `DispatchingAndroidInjector` looks up the appropriate
 `AndroidInjector.Factory` by the class at runtime, a base class can implement
-`HasDispatchingActivityInjector` and `HasDispatchingFragmentInjector` as well as
+`HasDispatchingActivityInjector`/`HasDispatchingFragmentInjector`/etc as well as
 call `AndroidInjection.inject()`. All each subclass needs to do is bind a
 corresponding `@Subcomponent`. Dagger provides a few base types that do this,
-[`DaggerActivity`] and [`DaggerFragment`], if you don't have a complicated
-activity/fragment class hierarchy. Dagger also provides a [`DaggerApplication`]
-for the same purpose — all you need to do is to extend it and override the
+such as [`DaggerActivity`] and [`DaggerFragment`], if you don't have a
+complicated class hierarchy. Dagger also provides a [`DaggerApplication`] for
+the same purpose — all you need to do is to extend it and override the
 `applicationInjector()` method to return the component that should inject the
 `Application`.
 
+*Note:* [`DaggerBroadcastReceiver`] should only be used when the
+`BroadcastReceiver` is registered in the `AndroidManifest.xml`. When the
+`BroadcastReceiver` is created in your own code, prefer constructor injection
+instead.
+
 ### Support libraries
 
 For users of the Android support library, parallel types exist in the
@@ -256,9 +261,9 @@ Constructor injection is preferred whenever possible because `javac` will ensure
 that no field is referenced before it has been set, which helps avoid
 `NullPointerException`s. When members injection is required (as discussed
 above), prefer to inject as early as possible. For this reason, `DaggerActivity`
-calls `AndroidInjection.inject()` immediately in `onCreate()`, before calling `super.onCreate()`, and
-`DaggerFragment` does the same in `onAttach()`, which also prevents
-inconsistencies if the `Fragment` is reattached.
+calls `AndroidInjection.inject()` immediately in `onCreate()`, before calling
+`super.onCreate()`, and `DaggerFragment` does the same in `onAttach()`, which
+also prevents inconsistencies if the `Fragment` is reattached.
 
 It is crucial to call `AndroidInjection.inject()` before `super.onCreate()` in
 an `Activity`, since the call to `super` attaches `Fragment`s from the previous
@@ -292,6 +297,7 @@ method.
 [`dagger.android`]: https://google.github.io/dagger/api/latest/dagger/android/package-summary.html
 [DaggerActivity]: https://google.github.io/dagger/api/latest/dagger/android/DaggerActivity.html
 [DaggerApplication]: https://google.github.io/dagger/api/latest/dagger/android/DaggerApplication.html
+[DaggerBroadcastReceiver]: https://google.github.io/dagger/api/latest/dagger/android/DaggerBroadcastReceiver.html
 [DaggerFragment]: https://google.github.io/dagger/api/latest/dagger/android/DaggerFragment.html
 [DispatchingAndroidInjector]: https://google.github.io/dagger/api/latest/dagger/android/DispatchingAndroidInjector.html
 [effective-java]: https://books.google.com/books?id=ka2VUBqHiWkC
