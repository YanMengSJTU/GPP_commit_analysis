diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 7df8a4d80..dbeea6565 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -64,7 +64,7 @@
       BindingGraph graph) {
     GeneratedComponentModel generatedComponentModel = GeneratedComponentModel.forComponent(name);
     SubcomponentNames subcomponentNames = new SubcomponentNames(graph, keyFactory);
-    OptionalFactories optionalFactories = new OptionalFactories();
+    OptionalFactories optionalFactories = new OptionalFactories(generatedComponentModel);
     Optional<ComponentBuilder> builder =
         ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
     ComponentRequirementFields componentRequirementFields =
@@ -170,9 +170,6 @@ private ComponentWriter(
     addSubcomponents();
     addConstructor();
 
-    if (graph.componentDescriptor().kind().isTopLevel()) {
-      optionalFactories.addMembers(generatedComponentModel);
-    }
     done = true;
     return generatedComponentModel.generate();
   }
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index 498ec3594..3297823d0 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -67,6 +67,11 @@
 /** The nested class and static methods required by the component to implement optional bindings. */
 // TODO(dpb): Name members simply if a component uses only one of Guava or JDK Optional.
 final class OptionalFactories {
+  private final GeneratedComponentModel generatedComponentModel;
+
+  OptionalFactories(GeneratedComponentModel generatedComponentModel) {
+    this.generatedComponentModel = generatedComponentModel;
+  }
 
   /**
    * The factory classes that implement {@code Provider<Optional<T>>} or {@code
@@ -105,7 +110,12 @@ CodeBlock absentOptionalProvider(ContributionBinding binding) {
     return CodeBlock.of(
         "$N()",
         absentOptionalProviderMethods.computeIfAbsent(
-            optionalKind, this::absentOptionalProviderMethod));
+            optionalKind,
+            kind -> {
+              MethodSpec method = absentOptionalProviderMethod(kind);
+              generatedComponentModel.addMethod(ABSENT_OPTIONAL_METHOD, method);
+              return method;
+            }));
   }
 
   /**
@@ -129,7 +139,12 @@ private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
             "$1T provider = ($1T) $2N;",
             providerOf(optionalKind.of(typeVariable)),
             absentOptionalProviderFields.computeIfAbsent(
-                optionalKind, this::absentOptionalProviderField))
+                optionalKind,
+                kind -> {
+                  FieldSpec field = absentOptionalProviderField(kind);
+                  generatedComponentModel.addField(ABSENT_OPTIONAL_FIELD, field);
+                  return field;
+                }))
         .addCode("return provider;")
         .build();
   }
@@ -235,7 +250,12 @@ CodeBlock presentOptionalFactory(ContributionBinding binding, CodeBlock delegate
     return CodeBlock.of(
         "$N.of($L)",
         presentFactoryClasses.computeIfAbsent(
-            PresentFactorySpec.of(binding), this::presentOptionalFactoryClass),
+            PresentFactorySpec.of(binding),
+            spec -> {
+              TypeSpec type = presentOptionalFactoryClass(spec);
+              generatedComponentModel.addType(PRESENT_FACTORY, type);
+              return type;
+            }),
         delegateFactory);
   }
 
@@ -243,20 +263,55 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
     FieldSpec delegateField =
         FieldSpec.builder(spec.delegateType(), "delegate", PRIVATE, FINAL).build();
     ParameterSpec delegateParameter = ParameterSpec.builder(delegateField.type, "delegate").build();
+    return classBuilder(spec.factoryClassName())
+        .addTypeVariable(spec.typeVariable())
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .addSuperinterface(spec.factoryType())
+        .addJavadoc(
+            "A {@code $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
+        .addField(delegateField)
+        .addMethod(
+            constructorBuilder()
+                .addModifiers(PRIVATE)
+                .addParameter(delegateParameter)
+                .addCode(
+                    "this.$N = $T.checkNotNull($N);",
+                    delegateField,
+                    Preconditions.class,
+                    delegateParameter)
+                .build())
+        .addMethod(presentOptionalFactoryGetMethod(spec, delegateField))
+        .addMethod(
+            methodBuilder("of")
+                .addModifiers(PRIVATE, STATIC)
+                .addTypeVariable(spec.typeVariable())
+                .returns(spec.factoryType())
+                .addParameter(delegateParameter)
+                .addCode(
+                    "return new $L<$T>($N);",
+                    spec.factoryClassName(),
+                    spec.typeVariable(),
+                    delegateParameter)
+                .build())
+        .build();
+  }
 
+  private MethodSpec presentOptionalFactoryGetMethod(
+      PresentFactorySpec spec, FieldSpec delegateField) {
     MethodSpec.Builder getMethodBuilder =
         methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
+
     switch (spec.bindingType()) {
       case PROVISION:
-        getMethodBuilder
+        return getMethodBuilder
             .returns(spec.optionalType())
             .addCode(
                 "return $L;",
                 spec.optionalKind()
                     .presentExpression(
                         FrameworkType.PROVIDER.to(
-                            spec.valueKind(), CodeBlock.of("$N", delegateField))));
-        break;
+                            spec.valueKind(), CodeBlock.of("$N", delegateField))))
+            .build();
 
       case PRODUCTION:
         getMethodBuilder.returns(listenableFutureOf(spec.optionalType()));
@@ -264,75 +319,45 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
         switch (spec.valueKind()) {
           case FUTURE: // return a ListenableFuture<Optional<ListenableFuture<T>>>
           case PRODUCER: // return a ListenableFuture<Optional<Producer<T>>>
-            getMethodBuilder.addCode(
-                "return $T.immediateFuture($L);",
-                Futures.class,
-                spec.optionalKind()
-                    .presentExpression(
-                        FrameworkType.PRODUCER.to(
-                            spec.valueKind(), CodeBlock.of("$N", delegateField))));
-            break;
+            return getMethodBuilder
+                .addCode(
+                    "return $T.immediateFuture($L);",
+                    Futures.class,
+                    spec.optionalKind()
+                        .presentExpression(
+                            FrameworkType.PRODUCER.to(
+                                spec.valueKind(), CodeBlock.of("$N", delegateField))))
+                .build();
 
           case INSTANCE: // return a ListenableFuture<Optional<T>>
-            getMethodBuilder.addCode(
-                "return $L;",
-                transformFutureToOptional(
-                    spec.optionalKind(),
-                    spec.typeVariable(),
-                    CodeBlock.of("$N.get()", delegateField)));
-            break;
+            return getMethodBuilder
+                .addCode(
+                    "return $L;",
+                    transformFutureToOptional(
+                        spec.optionalKind(),
+                        spec.typeVariable(),
+                        CodeBlock.of("$N.get()", delegateField)))
+                .build();
 
           case PRODUCED: // return a ListenableFuture<Optional<Produced<T>>>
-            getMethodBuilder.addCode(
-                "return $L;",
-                transformFutureToOptional(
-                    spec.optionalKind(),
-                    spec.valueType(),
-                    CodeBlock.of(
-                        "$T.createFutureProduced($N.get())", Producers.class, delegateField)));
-            break;
+            return getMethodBuilder
+                .addCode(
+                    "return $L;",
+                    transformFutureToOptional(
+                        spec.optionalKind(),
+                        spec.valueType(),
+                        CodeBlock.of(
+                            "$T.createFutureProduced($N.get())", Producers.class, delegateField)))
+                .build();
 
           default:
             throw new UnsupportedOperationException(
                 spec.factoryType() + " objects are not supported");
         }
-        break;
 
       default:
         throw new AssertionError(spec.bindingType());
     }
-
-    return classBuilder(spec.factoryClassName())
-        .addTypeVariable(spec.typeVariable())
-        .addModifiers(PRIVATE, STATIC, FINAL)
-        .addSuperinterface(spec.factoryType())
-        .addJavadoc(
-            "A {@code $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
-        .addField(delegateField)
-        .addMethod(
-            constructorBuilder()
-                .addModifiers(PRIVATE)
-                .addParameter(delegateParameter)
-                .addCode(
-                    "this.$N = $T.checkNotNull($N);",
-                    delegateField,
-                    Preconditions.class,
-                    delegateParameter)
-                .build())
-        .addMethod(getMethodBuilder.build())
-        .addMethod(
-            methodBuilder("of")
-                .addModifiers(PRIVATE, STATIC)
-                .addTypeVariable(spec.typeVariable())
-                .returns(spec.factoryType())
-                .addParameter(delegateParameter)
-                .addCode(
-                    "return new $L<$T>($N);",
-                    spec.factoryClassName(),
-                    spec.typeVariable(),
-                    delegateParameter)
-                .build())
-        .build();
   }
 
   /**
@@ -363,16 +388,4 @@ private static CodeBlock transformFutureToOptional(
             .build(),
         MoreExecutors.class);
   }
-
-  /**
-   * Adds classes and methods required by previous calls to {@link
-   * #absentOptionalProvider(ContributionBinding)} and {@link
-   * #presentOptionalFactory(ContributionBinding, CodeBlock)} to the top-level {@code component}.
-   */
-  void addMembers(GeneratedComponentModel generatedComponentModel) {
-    generatedComponentModel.addTypes(PRESENT_FACTORY, presentFactoryClasses.values());
-    generatedComponentModel.addMethods(
-        ABSENT_OPTIONAL_METHOD, absentOptionalProviderMethods.values());
-    generatedComponentModel.addFields(ABSENT_OPTIONAL_FIELD, absentOptionalProviderFields.values());
-  }
 }
