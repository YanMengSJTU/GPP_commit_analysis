diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 235a226c8..f71041607 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -127,8 +127,8 @@
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final ComponentBindingExpressions bindingExpressions;
   // TODO(user): Merge into ComponentBindingExpressions after we refactor BindingKey.
-  private final Map<BindingKey, ProducerBindingExpression> producerFromProviderBindingExpressions =
-      new LinkedHashMap<>();
+  private final Map<BindingKey, FrameworkInstanceBindingExpression>
+      producerFromProviderBindingExpressions = new LinkedHashMap<>();
   private final List<CodeBlock> initializations = new ArrayList<>();
   protected final List<MethodSpec> interfaceMethods = new ArrayList<>();
   private final BindingExpression.Factory bindingExpressionFactory;
@@ -700,7 +700,7 @@ private CodeBlock membersInjectionBindingInitialization(
     return membersInjectorForBindingInitialization(binding);
   }
 
-  private ProducerBindingExpression getProducerFromProviderBindingExpression(
+  private FrameworkInstanceBindingExpression getProducerFromProviderBindingExpression(
       FrameworkDependency frameworkDependency) {
     checkState(isProducerFromProvider(frameworkDependency));
     return producerFromProviderBindingExpressions.computeIfAbsent(
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index e8df4f6c5..4d06d38ca 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.FrameworkInstanceBindingExpression.producerFromProviderBindingExpression;
 import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
 import static dagger.internal.codegen.TypeNames.PRODUCER;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -31,6 +32,7 @@
 
 /** A factory of code expressions used to access a single binding in a component. */
 abstract class BindingExpression {
+  // TODO(dpb): Put the Binding or ResolvedBindings itself here.
   private final BindingKey bindingKey;
 
   BindingExpression(BindingKey bindingKey) {
@@ -88,15 +90,15 @@ BindingExpression forField(ResolvedBindings resolvedBindings) {
       return create(resolvedBindings, Optional.of(fieldSpec), memberSelect);
     }
 
-    ProducerBindingExpression forProducerFromProviderField(ResolvedBindings resolvedBindings) {
+    FrameworkInstanceBindingExpression forProducerFromProviderField(
+        ResolvedBindings resolvedBindings) {
       FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.of(PRODUCER));
       MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
-      return new ProducerBindingExpression(
+      return producerFromProviderBindingExpression(
           resolvedBindings.bindingKey(),
           Optional.of(fieldSpec),
           generatedComponentModel,
-          memberSelect,
-          true);
+          memberSelect);
     }
 
     /** Creates a binding expression for a static method call. */
@@ -139,54 +141,40 @@ private BindingExpression create(
         ResolvedBindings resolvedBindings,
         Optional<FieldSpec> fieldSpec,
         MemberSelect memberSelect) {
-      BindingKey bindingKey = resolvedBindings.bindingKey();
-      switch (resolvedBindings.bindingType()) {
-        case MEMBERS_INJECTION:
-          return new MembersInjectorBindingExpression(
-              bindingKey, fieldSpec, generatedComponentModel, memberSelect);
-        case PRODUCTION:
-          return new ProducerBindingExpression(
-              bindingKey, fieldSpec, generatedComponentModel, memberSelect, false);
-        case PROVISION:
-          ProvisionBinding provisionBinding =
-              (ProvisionBinding) resolvedBindings.contributionBinding();
-
-          ProviderBindingExpression providerBindingExpression =
-              new ProviderBindingExpression(
-                  bindingKey, fieldSpec, generatedComponentModel, memberSelect);
-
-          switch (provisionBinding.bindingKind()) {
-            case SUBCOMPONENT_BUILDER:
-              return new SubcomponentBuilderBindingExpression(
-                  providerBindingExpression, subcomponentNames.get(bindingKey));
-            case SYNTHETIC_MULTIBOUND_SET:
-              return new SetBindingExpression(
-                  provisionBinding,
-                  graph,
-                  componentBindingExpressions,
-                  providerBindingExpression,
-                  elements);
-            case SYNTHETIC_OPTIONAL_BINDING:
-              return new OptionalBindingExpression(
-                  provisionBinding, providerBindingExpression, componentBindingExpressions);
+      FrameworkInstanceBindingExpression bindingExpression =
+          FrameworkInstanceBindingExpression.create(
+              resolvedBindings, fieldSpec, generatedComponentModel, memberSelect);
+
+      if (!resolvedBindings.bindingType().equals(BindingType.PROVISION)) {
+        return bindingExpression;
+      }
+
+      ProvisionBinding provisionBinding = (ProvisionBinding) resolvedBindings.contributionBinding();
+      switch (provisionBinding.bindingKind()) {
+        case SUBCOMPONENT_BUILDER:
+          return new SubcomponentBuilderBindingExpression(
+              bindingExpression, subcomponentNames.get(resolvedBindings.bindingKey()));
+        case SYNTHETIC_MULTIBOUND_SET:
+          return new SetBindingExpression(
+              provisionBinding, graph, componentBindingExpressions, bindingExpression, elements);
+        case SYNTHETIC_OPTIONAL_BINDING:
+          return new OptionalBindingExpression(
+              provisionBinding, bindingExpression, componentBindingExpressions);
             case INJECTION:
-            case PROVISION:
-              if (!provisionBinding.scope().isPresent()
-                  && !provisionBinding.requiresModuleInstance()
-                  && provisionBinding.bindingElement().isPresent()) {
-                return new SimpleMethodBindingExpression(
-                    compilerOptions,
-                    provisionBinding,
-                    providerBindingExpression,
-                    componentBindingExpressions,
-                    generatedComponentModel);
-              }
-              // fall through
-            default:
-              return providerBindingExpression;
+        case PROVISION:
+          if (!provisionBinding.scope().isPresent()
+              && !provisionBinding.requiresModuleInstance()
+              && provisionBinding.bindingElement().isPresent()) {
+            return new SimpleMethodBindingExpression(
+                compilerOptions,
+                provisionBinding,
+                bindingExpression,
+                componentBindingExpressions,
+                generatedComponentModel);
           }
+          // fall through
         default:
-          throw new AssertionError();
+          return bindingExpression;
       }
     }
   }
diff --git a/java/dagger/internal/codegen/BindingType.java b/java/dagger/internal/codegen/BindingType.java
index e654b04a4..60e4ad0ec 100644
--- a/java/dagger/internal/codegen/BindingType.java
+++ b/java/dagger/internal/codegen/BindingType.java
@@ -25,18 +25,17 @@
 import dagger.producers.Producer;
 import javax.inject.Provider;
 
-/**
- * Whether a binding or declaration is for provision, production, or a {@link MembersInjector}.
- */
+/** Whether a binding or declaration is for provision, production, or a {@link MembersInjector}. */
+// TODO(dpb): Merge with FrameworkType?
 enum BindingType {
   /** A binding with this type is a {@link ProvisionBinding}. */
-  PROVISION(Provider.class),
+  PROVISION(Provider.class, FrameworkType.PROVIDER),
 
   /** A binding with this type is a {@link MembersInjectionBinding}. */
-  MEMBERS_INJECTION(MembersInjector.class),
+  MEMBERS_INJECTION(MembersInjector.class, FrameworkType.MEMBERS_INJECTOR),
 
   /** A binding with this type is a {@link ProductionBinding}. */
-  PRODUCTION(Producer.class),
+  PRODUCTION(Producer.class, FrameworkType.PRODUCER),
   ;
 
   boolean isOfType(HasBindingType hasBindingType) {
@@ -48,14 +47,16 @@ boolean isOfType(HasBindingType hasBindingType) {
 
   /** An object that is associated with a {@link BindingType}. */
   interface HasBindingType {
+
     /** The binding type of this object. */
     BindingType bindingType();
   }
-
   private final Class<?> frameworkClass;
+  private final FrameworkType frameworkType;
 
-  BindingType(Class<?> frameworkClass) {
+  private BindingType(Class<?> frameworkClass, FrameworkType frameworkType) {
     this.frameworkClass = frameworkClass;
+    this.frameworkType = frameworkType;
   }
 
   /** The framework class associated with bindings of this type. */
@@ -63,6 +64,11 @@ boolean isOfType(HasBindingType hasBindingType) {
     return frameworkClass;
   }
 
+  /** The framework type used to represent bindings of this type. */
+  FrameworkType frameworkType() {
+    return frameworkType;
+  }
+
   /** Returns the {@link #frameworkClass()} parameterized with a type. */
   ParameterizedTypeName frameworkClassOf(TypeName valueType) {
     return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 88bd24891..4bf779eeb 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -27,23 +27,60 @@
 import java.util.Optional;
 
 /** A binding expression that uses an instance of a {@link FrameworkType}. */
-// TODO(user): consider removing this class and making it a strategy that is created by
-// {Provider,Producer,MembersInjector}BindingExpression
-abstract class FrameworkInstanceBindingExpression extends BindingExpression {
+final class FrameworkInstanceBindingExpression extends BindingExpression {
   private final Optional<FieldSpec> fieldSpec;
   private final GeneratedComponentModel generatedComponentModel;
   private final MemberSelect memberSelect;
+  private final FrameworkType frameworkType;
+  private final boolean isProducerFromProvider;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
-  protected FrameworkInstanceBindingExpression(
+  /** Returns a binding expression for a binding. */
+  static FrameworkInstanceBindingExpression create(
+      ResolvedBindings resolvedBindings,
+      Optional<FieldSpec> fieldSpec,
+      GeneratedComponentModel generatedComponentModel,
+      MemberSelect memberSelect) {
+    return new FrameworkInstanceBindingExpression(
+        resolvedBindings.bindingKey(),
+        fieldSpec,
+        generatedComponentModel,
+        memberSelect,
+        resolvedBindings.bindingType().frameworkType(),
+        false);
+  }
+
+  /**
+   * Returns a binding expression that uses a {@link dagger.producers.Producer} instance derived
+   * from a {@link javax.inject.Provider}.
+   */
+  static FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
       BindingKey bindingKey,
       Optional<FieldSpec> fieldSpec,
       GeneratedComponentModel generatedComponentModel,
       MemberSelect memberSelect) {
+    return new FrameworkInstanceBindingExpression(
+        bindingKey, fieldSpec, generatedComponentModel, memberSelect, FrameworkType.PRODUCER, true);
+  }
+
+  private FrameworkInstanceBindingExpression(
+      BindingKey bindingKey,
+      Optional<FieldSpec> fieldSpec,
+      GeneratedComponentModel generatedComponentModel,
+      MemberSelect memberSelect,
+      FrameworkType frameworkType,
+      boolean isProducerFromProvider) {
     super(bindingKey);
     this.generatedComponentModel = generatedComponentModel;
     this.memberSelect = memberSelect;
     this.fieldSpec = fieldSpec;
+    this.frameworkType = frameworkType;
+    this.isProducerFromProvider = isProducerFromProvider;
+  }
+
+  @Override
+  CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return frameworkType.to(requestKind, getFrameworkTypeInstance(requestingClass));
   }
 
   /**
@@ -69,8 +106,9 @@ private String fieldName() {
   }
 
   /** Returns true if this binding expression represents a producer from provider. */
-  // TODO(user): remove this and represent this via a subtype of BindingExpression
-  abstract boolean isProducerFromProvider();
+  boolean isProducerFromProvider() {
+    return isProducerFromProvider;
+  }
 
   /**
    * Sets the initialization state for the binding's underlying field. Only valid for field types.
diff --git a/java/dagger/internal/codegen/MembersInjectorBindingExpression.java b/java/dagger/internal/codegen/MembersInjectorBindingExpression.java
deleted file mode 100644
index 9134ed0fa..000000000
--- a/java/dagger/internal/codegen/MembersInjectorBindingExpression.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkArgument;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import dagger.internal.codegen.DependencyRequest.Kind;
-import java.util.Optional;
-
-/** A binding expression that uses a {@link dagger.MembersInjector} instance. */
-final class MembersInjectorBindingExpression extends FrameworkInstanceBindingExpression {
-  MembersInjectorBindingExpression(
-      BindingKey bindingKey,
-      Optional<FieldSpec> fieldSpec,
-      GeneratedComponentModel generatedComponentModel,
-      MemberSelect memberSelect) {
-    super(bindingKey, fieldSpec, generatedComponentModel, memberSelect);
-  }
-
-  @Override
-  CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName requestingClass) {
-    checkArgument(requestKind.equals(Kind.MEMBERS_INJECTOR));
-    return getFrameworkTypeInstance(requestingClass);
-  }
-
-  @Override
-  boolean isProducerFromProvider() {
-    return false;
-  }
-}
diff --git a/java/dagger/internal/codegen/ProducerBindingExpression.java b/java/dagger/internal/codegen/ProducerBindingExpression.java
deleted file mode 100644
index 7fdef7162..000000000
--- a/java/dagger/internal/codegen/ProducerBindingExpression.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import java.util.Optional;
-
-/** A binding expression that uses a {@link dagger.producers.Producer} instance. */
-final class ProducerBindingExpression extends FrameworkInstanceBindingExpression {
-  private final boolean isProducerFromProvider;
-
-  ProducerBindingExpression(
-      BindingKey bindingKey,
-      Optional<FieldSpec> fieldSpec,
-      GeneratedComponentModel generatedComponentModel,
-      MemberSelect memberSelect,
-      boolean isProducerFromProvider) {
-    super(bindingKey, fieldSpec, generatedComponentModel, memberSelect);
-    this.isProducerFromProvider = isProducerFromProvider;
-  }
-
-  @Override
-  CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName requestingClass) {
-    return FrameworkType.PRODUCER.to(requestKind, getFrameworkTypeInstance(requestingClass));
-  }
-
-  @Override
-  boolean isProducerFromProvider() {
-    return isProducerFromProvider;
-  }
-}
diff --git a/java/dagger/internal/codegen/ProviderBindingExpression.java b/java/dagger/internal/codegen/ProviderBindingExpression.java
deleted file mode 100644
index 0d6e70c94..000000000
--- a/java/dagger/internal/codegen/ProviderBindingExpression.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import java.util.Optional;
-
-/** A binding expression that uses a {@link javax.inject.Provider} instance. */
-final class ProviderBindingExpression extends FrameworkInstanceBindingExpression {
-  ProviderBindingExpression(
-      BindingKey bindingKey,
-      Optional<FieldSpec> fieldSpec,
-      GeneratedComponentModel generatedComponentModel,
-      MemberSelect memberSelect) {
-    super(bindingKey, fieldSpec, generatedComponentModel, memberSelect);
-  }
-
-  @Override
-  CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName requestingClass) {
-    return FrameworkType.PROVIDER.to(requestKind, getFrameworkTypeInstance(requestingClass));
-  }
-
-  @Override
-  boolean isProducerFromProvider() {
-    return false;
-  }
-}
