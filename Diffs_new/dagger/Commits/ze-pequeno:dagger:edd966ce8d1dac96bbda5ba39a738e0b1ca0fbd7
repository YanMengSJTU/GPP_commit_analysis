diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 365cb8157..4146964ec 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -186,10 +186,10 @@ private BindingGraph create(
               }
             });
 
-    if (componentDescriptor.kind().isForModuleValidation()) {
+    if (requestResolver.rootComponent().kind().isForModuleValidation()) {
       // For module-binding validation, resolve the keys for all bindings in all modules, stripping
       // any multibinding contribution identifier so that the multibinding itself is resolved.
-      componentDescriptor.modules().stream()
+      modules(componentDescriptor, parentResolver).stream()
           .flatMap(module -> module.allBindingKeys().stream())
           .map(key -> key.toBuilder().multibindingContributionIdentifier(Optional.empty()).build())
           .forEach(requestResolver::resolve);
diff --git a/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java b/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java
index dee9a8ff7..0121072d5 100644
--- a/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java
@@ -20,8 +20,10 @@
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.TestUtils.message;
 
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.regex.Pattern;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,6 +31,16 @@
 
 @RunWith(JUnit4.class)
 public final class ModuleBindingValidationTest {
+  private static final JavaFileObject INCLUDING_MODULE =
+      JavaFileObjects.forSourceLines(
+          "test.IncludingModule",
+          "package test;",
+          "",
+          "import dagger.Module;",
+          "",
+          "@Module(includes = TestModule.class)",
+          "interface IncludingModule {}");
+
   private static final JavaFileObject MODULE =
       JavaFileObjects.forSourceLines(
           "test.TestModule",
@@ -37,37 +49,75 @@
           "import dagger.Binds;",
           "import dagger.Module;",
           "",
-          "@Module",
+          "@Module(subcomponents = Child.class)",
           "interface TestModule {",
           "  @Binds Object toString(String string);",
           "  @Binds Object toLong(Long l);",
           "}");
 
-  private static final JavaFileObject INCLUDING_MODULE =
+  private static final JavaFileObject CHILD =
       JavaFileObjects.forSourceLines(
-          "test.IncludingModule",
+          "test.Child",
+          "package test;",
+          "",
+          "import dagger.BindsInstance;",
+          "import dagger.Subcomponent;",
+          "",
+          "@Subcomponent(modules = ChildModule.class)",
+          "interface Child {",
+          "  @Subcomponent.Builder",
+          "  interface Builder {",
+          "    @BindsInstance Builder object(Object object);",
+          "    Child build();",
+          "  }",
+          "}");
+
+  private static final JavaFileObject CHILD_MODULE =
+      JavaFileObjects.forSourceLines(
+          "test.ChildModule",
           "package test;",
           "",
           "import dagger.Module;",
+          "import dagger.Binds;",
           "",
-          "@Module(includes = TestModule.class)",
-          "interface IncludingModule {}");
+          "@Module",
+          "interface ChildModule {",
+          "  @Binds Object toNumber(Number number);",
+          "}");
+
+  // Make sure the module-level errors don't show a dependency trace afterwards (note the $).
+  private static final String MODULE_MESSAGE =
+      Pattern.quote(
+              message(
+                  "[Dagger/DuplicateBindings] java.lang.Object is bound multiple times:",
+                  "    @Binds Object test.TestModule.toLong(Long)",
+                  "    @Binds Object test.TestModule.toString(String)"))
+          + "$";
+
+  // Make sure the module-level errors don't show a dependency trace afterwards (note the $).
+  private static final String CHILD_MESSAGE =
+      Pattern.quote(
+              message(
+                  "[Dagger/DuplicateBindings] java.lang.Object is bound multiple times:",
+                  "    @BindsInstance test.Child.Builder test.Child.Builder.object(Object)",
+                  "    @Binds Object test.ChildModule.toNumber(Number)",
+                  "    @Binds Object test.TestModule.toLong(Long)",
+                  "    @Binds Object test.TestModule.toString(String)"))
+          + "$";
+
+  private static final ImmutableList<JavaFileObject> SOURCES =
+      ImmutableList.of(MODULE, INCLUDING_MODULE, CHILD, CHILD_MODULE);
 
   @Test
-  public void moduleBindingValidationErrors() {
+  public void error() {
     Compilation compilation =
-        daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
-            .compile(MODULE, INCLUDING_MODULE);
+        daggerCompiler().withOptions("-Adagger.moduleBindingValidation=ERROR").compile(SOURCES);
     assertThat(compilation).failed();
 
-    // Make sure the module-level error doesn't show a dependency trace afterwards (note the $).
+    // Some javacs report only one error for each source line.
+    // Assert that one of the expected errors is reported.
     assertThat(compilation)
-        .hadErrorContainingMatch(
-            message(
-                "^\\Q[Dagger/DuplicateBindings] java.lang.Object is bound multiple times:",
-                "    @Binds Object test.TestModule.toLong(Long)",
-                "    @Binds Object test.TestModule.toString(String)\\E$"))
+        .hadErrorContainingMatch(CHILD_MESSAGE + "|" + MODULE_MESSAGE)
         .inFile(MODULE)
         .onLineContaining("interface TestModule");
 
@@ -76,49 +126,44 @@ public void moduleBindingValidationErrors() {
         .inFile(INCLUDING_MODULE)
         .onLineContaining("TestModule.class");
 
-    // The duplicate bindings error is reported only once, for TestModule, and not again for
-    // IncludingModule.
-    assertThat(compilation).hadErrorCount(2);
   }
 
   @Test
-  public void moduleBindingValidationWarning() {
+  public void warning() {
     Compilation compilation =
-        daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=WARNING")
-            .compile(MODULE, INCLUDING_MODULE);
+        daggerCompiler().withOptions("-Adagger.moduleBindingValidation=WARNING").compile(SOURCES);
     assertThat(compilation).succeeded();
 
     assertThat(compilation)
-        .hadWarningContainingMatch(
-            message(
-                "^\\Q[Dagger/DuplicateBindings] java.lang.Object is bound multiple times:",
-                "    @Binds Object test.TestModule.toLong(Long)",
-                "    @Binds Object test.TestModule.toString(String)\\E$"))
+        .hadWarningContainingMatch(MODULE_MESSAGE)
         .inFile(MODULE)
         .onLineContaining("interface TestModule");
 
-    // Make sure the module-level error doesn't show a dependency trace.
     assertThat(compilation)
-        .hadWarningContainingMatch(
-            message(
-                "^\\Q[Dagger/DuplicateBindings] java.lang.Object is bound multiple times:",
-                "    @Binds Object test.TestModule.toLong(Long)",
-                "    @Binds Object test.TestModule.toString(String)\\E$"))
+        .hadWarningContainingMatch(CHILD_MESSAGE)
+        .inFile(MODULE)
+        .onLineContaining("interface TestModule");
+
+    // TODO(dpb): When warning, don't repeat in including modules.
+    assertThat(compilation)
+        .hadWarningContainingMatch(MODULE_MESSAGE)
+        .inFile(INCLUDING_MODULE)
+        .onLineContaining("interface IncludingModule");
+
+    assertThat(compilation)
+        .hadWarningContainingMatch(CHILD_MESSAGE)
         .inFile(INCLUDING_MODULE)
         .onLineContaining("interface IncludingModule");
 
-    // If module binding validation reports warnings, the duplicate bindings warning occurs twice:
+    // If module binding validation reports warnings, the warnings occur twice:
     // once for TestModule and once for IncludingModule, which includes it.
-    assertThat(compilation).hadWarningCount(2);
+    assertThat(compilation).hadWarningCount(4);
   }
 
   @Test
-  public void moduleBindingValidationNone() {
+  public void none() {
     Compilation compilation =
-        daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=NONE")
-            .compile(MODULE, INCLUDING_MODULE);
+        daggerCompiler().withOptions("-Adagger.moduleBindingValidation=NONE").compile(SOURCES);
     assertThat(compilation).succeededWithoutWarnings();
   }
 }
