diff --git a/tools/bazel.rc b/.bazelrc
similarity index 62%
rename from tools/bazel.rc
rename to .bazelrc
index c930d8e25..ecd54a58a 100644
--- a/tools/bazel.rc
+++ b/.bazelrc
@@ -1,6 +1,8 @@
 # Include debug info in the compiled jars
 build --javacopt=-g
+build --host_javacopt=-g
 
 # Disable The Guava Beta Checker.
 # TODO(ronshapiro): explore how much work it would be to reenable this
-build  --javacopt="-Xep:BetaApi:OFF"
+build --javacopt="-Xep:BetaApi:OFF"
+build --host_javacopt="-Xep:BetaApi:OFF"
diff --git a/.travis.yml b/.travis.yml
index c135891c9..41ef29f8f 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -46,7 +46,7 @@ env:
     - secure: LTzrlqcSNeZTOV52D3ibY9RBdxY4Yu8dUOYhAonrWLE+eDTzuoyCzcPw8pEcYVNUi1rG6Q7v3QBDTnBztsPoCbcN5tEGjw5cQEbfEzSTkWaNCFjncWn36cLwx9lgbF+5Db/L0mYJ36unDKUpKVC8AgOtxQibfv/ffugfxxj8ohY=
     - secure: PEdRiHTy+xVFPnlBwOhr7RVW/QIFSgd4hO0LESRBeF7KGIjxTZWtKPjnYrysZFm6tozMk6WBVJO6avOss0v7L64nemwpCnSspNYBa6pRGPgQ3rv/wgdPSzqDDmABmpPC18EHbUtF94KVdRX3Cr4kmwKQyD+YUKNRCY11Txt+xfo=
     - JDK_FOR_PUBLISHING: *jdk_for_publishing
-    - BAZEL_VERSION="0.16.1"
+    - BAZEL_VERSION="0.19.2"
 
 after_success:
   - util/generate-latest-docs.sh
diff --git a/BUILD b/BUILD
index cd0e40c54..651372aef 100644
--- a/BUILD
+++ b/BUILD
@@ -59,11 +59,12 @@ jarjar_library(
         "//java/dagger/internal/codegen:base",
         "//java/dagger/internal/codegen:binding",
         "//java/dagger/internal/codegen:binding_graph_validation",
+        "//java/dagger/internal/codegen:jdk-and-guava-extras",
         "//java/dagger/internal/codegen:processor",
-        "//java/dagger/internal/codegen:shared-with-spi",
         "//java/dagger/internal/codegen:validation",
         "//java/dagger/internal/codegen:writing",
         "//java/dagger/model:internal-proxies",
+        "//java/dagger/errorprone",
         "@com_google_auto_auto_common//jar",
     ],
     rules = SHADE_RULES,
@@ -75,17 +76,18 @@ jarjar_library(
         "//java/dagger/internal/codegen:libbase-src.jar",
         "//java/dagger/internal/codegen:libbinding-src.jar",
         "//java/dagger/internal/codegen:libbinding_graph_validation-src.jar",
+        "//java/dagger/internal/codegen:libjdk-and-guava-extras-src.jar",
         "//java/dagger/internal/codegen:libprocessor-src.jar",
-        "//java/dagger/internal/codegen:libshared-with-spi-src.jar",
         "//java/dagger/internal/codegen:libvalidation-src.jar",
         "//java/dagger/internal/codegen:libwriting-src.jar",
+        "//java/dagger/errorprone:liberrorprone-src.jar",
     ],
 )
 
 jarjar_library(
     name = "shaded_spi",
     jars = [
-        "//java/dagger/internal/codegen:shared-with-spi",
+        "//java/dagger/internal/codegen:jdk-and-guava-extras",
         "//java/dagger/model",
         "//java/dagger/spi",
         "@com_google_auto_auto_common//jar",
@@ -96,7 +98,7 @@ jarjar_library(
 jarjar_library(
     name = "shaded_spi_src",
     jars = [
-        "//java/dagger/internal/codegen:libshared-with-spi-src.jar",
+        "//java/dagger/internal/codegen:libjdk-and-guava-extras-src.jar",
         "//java/dagger/model:libmodel-src.jar",
         "//java/dagger/spi:libspi-src.jar",
     ],
diff --git a/WORKSPACE b/WORKSPACE
index f27e36f2f..e279be227 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -14,8 +14,8 @@
 
 http_archive(
     name = "google_bazel_common",
-    strip_prefix = "bazel-common-aafb9b64f25f66b5ab6b9b991331160ef4130626",
-    urls = ["https://github.com/google/bazel-common/archive/aafb9b64f25f66b5ab6b9b991331160ef4130626.zip"],
+    strip_prefix = "bazel-common-1c225e62390566a9e88916471948ddd56e5f111c",
+    urls = ["https://github.com/google/bazel-common/archive/1c225e62390566a9e88916471948ddd56e5f111c.zip"],
 )
 
 load("@google_bazel_common//:workspace_defs.bzl", "google_common_workspace_rules")
diff --git a/java/dagger/android/AndroidInjectionModule.java b/java/dagger/android/AndroidInjectionModule.java
index 05f1adae3..4e496f86b 100644
--- a/java/dagger/android/AndroidInjectionModule.java
+++ b/java/dagger/android/AndroidInjectionModule.java
@@ -16,11 +16,6 @@
 
 package dagger.android;
 
-import android.app.Activity;
-import android.app.Fragment;
-import android.app.Service;
-import android.content.BroadcastReceiver;
-import android.content.ContentProvider;
 import dagger.Module;
 import dagger.internal.Beta;
 import dagger.multibindings.Multibinds;
@@ -35,45 +30,10 @@
 @Module
 public abstract class AndroidInjectionModule {
   @Multibinds
-  abstract Map<Class<? extends Activity>, AndroidInjector.Factory<? extends Activity>>
-      activityInjectorFactories();
+  abstract Map<Class<?>, AndroidInjector.Factory<?>> classKeyedInjectorFactories();
 
   @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends Activity>>
-      activityInjectorFactoriesWithStringKeys();
-
-  @Multibinds
-  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
-      fragmentInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
-      fragmentInjectorFactoriesWithStringKeys();
-
-  @Multibinds
-  abstract Map<Class<? extends Service>, AndroidInjector.Factory<? extends Service>>
-      serviceInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends Service>>
-      serviceInjectorFactoriesWithStringKeys();
-
-  @Multibinds
-  abstract Map<
-          Class<? extends BroadcastReceiver>, AndroidInjector.Factory<? extends BroadcastReceiver>>
-      broadcastReceiverInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends BroadcastReceiver>>
-      broadcastReceiverInjectorFactoriesWithStringKeys();
-
-  @Multibinds
-  abstract Map<Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
-      contentProviderInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends ContentProvider>>
-      contentProviderInjectorFactoriesWithStringKeys();
+  abstract Map<String, AndroidInjector.Factory<?>> stringKeyedInjectorFactories();
 
   private AndroidInjectionModule() {}
 }
diff --git a/java/dagger/android/AndroidMemorySensitiveReferenceManager.java b/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
deleted file mode 100644
index 80de62760..000000000
--- a/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.util.Set;
-import javax.inject.Inject;
-
-/**
- * Releases references in {@link ReleaseReferencesAt} {@linkplain javax.inject.Scope scopes} in
- * low-memory conditions.
- *
- * <p>In order to release references in low-memory conditions, inject an {@code
- * AndroidMemorySensitiveReferenceManager} into your {@link android.app.Application} and delegate
- * {@link android.app.Application#onTrimMemory(int)} to it.
- *
- * <p>For example:
- *
- * <pre>
- *   class MyApplication extends Application {
- *     {@literal @Inject} AndroidMemorySensitiveReferenceManager manager;
- *
- *     public void onTrimMemory(int level) {
- *       manager.onTrimMemory(level);
- *     }
- *   }</pre>
- *
- * @since 2.8
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@GwtIncompatible
-@Deprecated
-public final class AndroidMemorySensitiveReferenceManager {
-
-  private final Set<TypedReleasableReferenceManager<ReleaseReferencesAt>> managers;
-
-  @Inject
-  AndroidMemorySensitiveReferenceManager(
-      Set<TypedReleasableReferenceManager<ReleaseReferencesAt>> managers) {
-    this.managers = managers;
-  }
-
-  /**
-   * Releases references for {@link ReleaseReferencesAt} scopes whose {@link
-   * ReleaseReferencesAt#value()} is less than or equal to {@code level}. Restores references for
-   * scopes whose {@link ReleaseReferencesAt#value()} is greater than {@code level}.
-   *
-   * @see android.app.Application#onTrimMemory(int)
-   */
-  public void onTrimMemory(int level) {
-    for (TypedReleasableReferenceManager<ReleaseReferencesAt> manager : managers) {
-      if (level >= manager.metadata().value()) {
-        manager.releaseStrongReferences();
-      } else {
-        manager.restoreStrongReferences();
-      }
-    }
-  }
-}
diff --git a/java/dagger/android/BUILD b/java/dagger/android/BUILD
index 6dfa1c5e3..a88d16e3e 100644
--- a/java/dagger/android/BUILD
+++ b/java/dagger/android/BUILD
@@ -23,7 +23,7 @@ load(
     "DOCLINT_REFERENCES",
     "SOURCE_7_TARGET_7",
 )
-load("//tools:maven.bzl", "pom_file", "POM_VERSION")
+load("//tools:maven.bzl", "POM_VERSION", "pom_file")
 
 # Work around b/70476182 which prevents Kythe from connecting :producers to the .java files it
 # contains.
diff --git a/java/dagger/android/BroadcastReceiverKey.java b/java/dagger/android/BroadcastReceiverKey.java
deleted file mode 100644
index 653de8f35..000000000
--- a/java/dagger/android/BroadcastReceiverKey.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import android.content.BroadcastReceiver;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/** {@link MapKey} annotation to key bindings by a type of a {@link BroadcastReceiver}. */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-public @interface BroadcastReceiverKey {
-  Class<? extends BroadcastReceiver> value();
-}
diff --git a/java/dagger/android/ContentProviderKey.java b/java/dagger/android/ContentProviderKey.java
deleted file mode 100644
index 9f12e44d8..000000000
--- a/java/dagger/android/ContentProviderKey.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import android.content.ContentProvider;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/** {@link MapKey} annotation to key bindings by a type of a {@link ContentProvider}. */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-public @interface ContentProviderKey {
-  Class<? extends ContentProvider> value();
-}
diff --git a/java/dagger/android/DaggerDialogFragment.java b/java/dagger/android/DaggerDialogFragment.java
index 3aec6545f..00e65f256 100644
--- a/java/dagger/android/DaggerDialogFragment.java
+++ b/java/dagger/android/DaggerDialogFragment.java
@@ -26,7 +26,12 @@
  * A {@link DialogFragment} that injects its members in {@link #onAttach(Context)} and can be used
  * to inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached,
  * its members will be injected again.
+ *
+ * @deprecated Framework fragments are deprecated in Android P; prefer {@code
+ *     dagger.android.support.DaggerDialogFragment} to use a support-library-friendly {@code
+ *     dagger.android} dialog fragment implementation.
  */
+@Deprecated
 @Beta
 public abstract class DaggerDialogFragment extends DialogFragment implements HasFragmentInjector {
 
diff --git a/java/dagger/android/DispatchingAndroidInjector.java b/java/dagger/android/DispatchingAndroidInjector.java
index 9b011dd13..9b6518066 100644
--- a/java/dagger/android/DispatchingAndroidInjector.java
+++ b/java/dagger/android/DispatchingAndroidInjector.java
@@ -49,12 +49,12 @@
       "No injector factory bound for Class<%1$s>. Injector factories were bound for supertypes "
           + "of %1$s: %2$s. Did you mean to bind an injector factory for the subtype?";
 
-  private final Map<String, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories;
+  private final Map<String, Provider<AndroidInjector.Factory<?>>> injectorFactories;
 
   @Inject
   DispatchingAndroidInjector(
-      Map<Class<? extends T>, Provider<Factory<? extends T>>> injectorFactoriesWithClassKeys,
-      Map<String, Provider<Factory<? extends T>>> injectorFactoriesWithStringKeys) {
+      Map<Class<?>, Provider<AndroidInjector.Factory<?>>> injectorFactoriesWithClassKeys,
+      Map<String, Provider<AndroidInjector.Factory<?>>> injectorFactoriesWithStringKeys) {
     this.injectorFactories = merge(injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys);
   }
 
@@ -68,10 +68,12 @@
    * <p>Ideally we could achieve this with a generic {@code @Provides} method, but we'd need to have
    * <i>N</i> modules that each extend one base module.
    */
-  private static <C, V> Map<String, V> merge(
+  private static <C, V> Map<String, Provider<AndroidInjector.Factory<?>>> merge(
       Map<Class<? extends C>, V> classKeyedMap, Map<String, V> stringKeyedMap) {
     if (classKeyedMap.isEmpty()) {
-      return stringKeyedMap;
+      @SuppressWarnings({"unchecked", "rawtypes"})
+      Map<String, Provider<AndroidInjector.Factory<?>>> safeCast = (Map) stringKeyedMap;
+      return safeCast;
     }
 
     Map<String, V> merged =
@@ -81,7 +83,9 @@
       merged.put(entry.getKey().getName(), entry.getValue());
     }
 
-    return Collections.unmodifiableMap(merged);
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    Map<String, Provider<AndroidInjector.Factory<?>>> safeCast = (Map) merged;
+    return Collections.unmodifiableMap(safeCast);
   }
 
   /**
@@ -93,7 +97,7 @@
    */
   @CanIgnoreReturnValue
   public boolean maybeInject(T instance) {
-    Provider<AndroidInjector.Factory<? extends T>> factoryProvider =
+    Provider<AndroidInjector.Factory<?>> factoryProvider =
         injectorFactories.get(instance.getClass().getName());
     if (factoryProvider == null) {
       return false;
diff --git a/java/dagger/android/ReleaseReferencesAt.java b/java/dagger/android/ReleaseReferencesAt.java
deleted file mode 100644
index 78ae99c4d..000000000
--- a/java/dagger/android/ReleaseReferencesAt.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import dagger.releasablereferences.CanReleaseReferences;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * Annotates {@linkplain javax.inject.Scope scopes} to associate them with a low-memory threshold
- * level, as described in {@link android.app.Application#onTrimMemory(int)}.
- *
- * <p>For example:
- *
- * <pre>
- *   {@literal @Documented}
- *   {@literal @Retention}(RUNTIME)
- *   {@literal @Target}({TYPE, METHOD})
- *   {@literal @ReleaseReferencesAt}(TRIM_MEMORY_BACKGROUND)
- *   {@literal @Scope}
- *   public {@literal @interface} MyScope {}</pre>
- *
- * <p>Any scope annotated with {@code @ReleaseReferencesAt} can {@linkplain CanReleaseReferences
- * release its references}.
- *
- * <p>In order to release references in low-memory conditions, inject an {@link
- * AndroidMemorySensitiveReferenceManager} into your {@link android.app.Application} and delegate
- * {@link android.app.Application#onTrimMemory(int)} to it.
- *
- * @since 2.8
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@Documented
-@GwtIncompatible
-@Target(ANNOTATION_TYPE)
-@CanReleaseReferences
-@Deprecated
-public @interface ReleaseReferencesAt {
-  /**
-   * If {@link AndroidMemorySensitiveReferenceManager#onTrimMemory(int)} is called with a value
-   * greater than or equal to this, the scope's references will be released. If it is called with a
-   * value less than this, the scope's references will be restored.
-   *
-   * <p>Use one of the constants defined in {@link android.content.ComponentCallbacks2}.
-   */
-  @OnTrimMemoryValue
-  int value();
-}
diff --git a/java/dagger/android/package-info.java b/java/dagger/android/package-info.java
index 3739a50c2..f59ef488c 100644
--- a/java/dagger/android/package-info.java
+++ b/java/dagger/android/package-info.java
@@ -14,12 +14,8 @@
  * limitations under the License.
  */
 
+/** APIs to assist with performing injection on Android. */
 @CheckReturnValue
 package dagger.android;
 
-/**
- * APIs to assist with using Dagger on Android devices. It includes common code to perform injection
- * as well as Android-specific extensions to {@link dagger.releasablereferences}.
- */
-
 import com.google.errorprone.annotations.CheckReturnValue;
diff --git a/java/dagger/android/processor/AndroidInjectorDescriptor.java b/java/dagger/android/processor/AndroidInjectorDescriptor.java
index 1e0d93f6a..7c5ae073f 100644
--- a/java/dagger/android/processor/AndroidInjectorDescriptor.java
+++ b/java/dagger/android/processor/AndroidInjectorDescriptor.java
@@ -20,7 +20,6 @@
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
@@ -33,9 +32,7 @@
 import com.squareup.javapoet.TypeName;
 import dagger.Module;
 import dagger.android.ContributesAndroidInjector;
-import java.lang.annotation.Annotation;
 import java.util.List;
-import java.util.Map;
 import java.util.Optional;
 import javax.annotation.processing.Messager;
 import javax.inject.Qualifier;
@@ -60,15 +57,6 @@
   /** The type to be injected; the return type of the {@link ContributesAndroidInjector} method. */
   abstract ClassName injectedType();
 
-  /**
-   * The base framework type of {@link #injectedType()}, e.g. {@code Activity}, {@code Fragment},
-   * etc.
-   */
-  abstract ClassName frameworkType();
-
-  /** The {@link dagger.MapKey} type for the associated {@link #frameworkType()}. */
-  abstract ClassName mapKeyType();
-
   /** Scopes to apply to the generated {@link dagger.Subcomponent}. */
   abstract ImmutableSet<AnnotationSpec> scopes();
 
@@ -89,10 +77,6 @@
 
     abstract ImmutableSet.Builder<ClassName> modulesBuilder();
 
-    abstract Builder frameworkType(ClassName frameworkType);
-
-    abstract Builder mapKeyType(ClassName mapKeyType);
-
     abstract Builder enclosingModule(ClassName enclosingModule);
 
     abstract Builder method(ExecutableElement method);
@@ -135,27 +119,11 @@
       builder.enclosingModule(ClassName.get(enclosingElement));
 
       TypeMirror injectedType = method.getReturnType();
-      Optional<? extends Class<? extends Annotation>> maybeMapKeyAnnotation =
-          annotationsAndFrameworkTypes(elements)
-              .entrySet()
-              .stream()
-              .filter(entry -> types.isAssignable(injectedType, entry.getValue()))
-              .map(Map.Entry::getKey)
-              .findFirst();
-      if (maybeMapKeyAnnotation.isPresent()) {
-        Class<? extends Annotation> mapKeyAnnotation = maybeMapKeyAnnotation.get();
-        TypeMirror frameworkType = annotationsAndFrameworkTypes(elements).get(mapKeyAnnotation);
-        builder
-            .mapKeyType(ClassName.get(mapKeyAnnotation))
-            .frameworkType((ClassName) TypeName.get(frameworkType));
-        if (MoreTypes.asDeclared(injectedType).getTypeArguments().isEmpty()) {
-          builder.injectedType(ClassName.get(MoreTypes.asTypeElement(injectedType)));
-        } else {
-          reporter.reportError(
-              "@ContributesAndroidInjector methods cannot return parameterized types");
-        }
+      if (MoreTypes.asDeclared(injectedType).getTypeArguments().isEmpty()) {
+        builder.injectedType(ClassName.get(MoreTypes.asTypeElement(injectedType)));
       } else {
-        reporter.reportError(String.format("%s is not a framework type", injectedType));
+        reporter.reportError(
+            "@ContributesAndroidInjector methods cannot return parameterized types");
       }
 
       AnnotationMirror annotation =
diff --git a/java/dagger/android/processor/AndroidMapKeyValidator.java b/java/dagger/android/processor/AndroidMapKeyValidator.java
index 4084ff4e2..4cdcd2a5c 100644
--- a/java/dagger/android/processor/AndroidMapKeyValidator.java
+++ b/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -20,17 +20,17 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
 import static dagger.android.processor.AndroidMapKeys.injectedTypeFromMapKey;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.Binds;
+import dagger.MapKey;
 import dagger.android.AndroidInjectionKey;
 import dagger.android.AndroidInjector;
+import dagger.multibindings.ClassKey;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
@@ -46,10 +46,7 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
-/**
- * Validates the correctness of {@link dagger.MapKey}s in {@code dagger.android} and {@code
- * dagger.android.support} methods.
- */
+/** Validates the correctness of {@link MapKey}s used with {@code dagger.android}. */
 final class AndroidMapKeyValidator implements ProcessingStep {
   private final Elements elements;
   private final Types types;
@@ -64,17 +61,26 @@
   @Override
   public Set<? extends Class<? extends Annotation>> annotations() {
     return ImmutableSet.<Class<? extends Annotation>>builder()
-        .addAll(annotationsAndFrameworkTypes(elements).keySet())
         .add(AndroidInjectionKey.class)
+        .add(ClassKey.class)
         .build();
   }
 
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    elementsByAnnotation.forEach(
-        (annotation, element) -> validateMethod(annotation, MoreElements.asExecutable(element)));
-    return ImmutableSet.of();
+    ImmutableSet.Builder<Element> deferredElements = ImmutableSet.builder();
+    elementsByAnnotation
+        .entries()
+        .forEach(
+            entry -> {
+              try {
+                validateMethod(entry.getKey(), MoreElements.asExecutable(entry.getValue()));
+              } catch (TypeNotPresentException e) {
+                deferredElements.add(entry.getValue());
+              }
+            });
+    return deferredElements.build();
   }
 
   private void validateMethod(Class<? extends Annotation> annotation, ExecutableElement method) {
@@ -88,42 +94,47 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
       return;
     }
 
-    TypeMirror frameworkType = frameworkTypeForMapKey(method, annotation);
-
     if (!getAnnotatedAnnotations(method, Scope.class).isEmpty()) {
       SuppressWarnings suppressedWarnings = method.getAnnotation(SuppressWarnings.class);
       if (suppressedWarnings == null
           || !ImmutableSet.copyOf(suppressedWarnings.value())
               .contains("dagger.android.ScopedInjectorFactory")) {
+        AnnotationMirror mapKeyAnnotation =
+            getOnlyElement(getAnnotatedAnnotations(method, MapKey.class));
+        TypeElement mapKeyValueElement =
+            elements.getTypeElement(injectedTypeFromMapKey(mapKeyAnnotation).get());
         messager.printMessage(
             Kind.ERROR,
             String.format(
-                "%s bindings should not be scoped. Scoping this method may leak instances of %s. ",
-                AndroidInjector.Factory.class.getCanonicalName(), frameworkType),
+                "%s bindings should not be scoped. Scoping this method may leak instances of %s.",
+                AndroidInjector.Factory.class.getCanonicalName(),
+                mapKeyValueElement.getQualifiedName()),
             method);
       }
     }
 
-    DeclaredType intendedReturnType = injectorFactoryOf(types.getWildcardType(frameworkType, null));
-    if (!MoreTypes.equivalence().equivalent(returnType, intendedReturnType)) {
-      String subject =
-          annotation.equals(AndroidInjectionKey.class)
-              ? method.toString()
-              : String.format("@%s methods", annotation.getCanonicalName());
+    validateReturnType(method);
+
+    // @Binds methods should only have one parameter, but we can't guarantee the order of Processors
+    // in javac, so do a basic check for valid form
+    if (isAnnotationPresent(method, Binds.class) && method.getParameters().size() == 1) {
+      validateMapKeyMatchesBindsParameter(annotation, method);
+    }
+  }
+
+  /** Report an error if the method's return type is not {@code AndroidInjector.Factory<?>}. */
+  private void validateReturnType(ExecutableElement method) {
+    TypeMirror returnType = method.getReturnType();
+    DeclaredType requiredReturnType = injectorFactoryOf(types.getWildcardType(null, null));
 
+    if (!types.isSameType(returnType, requiredReturnType)) {
       messager.printMessage(
           Kind.ERROR,
           String.format(
               "%s should bind %s, not %s. See https://google.github.io/dagger/android",
-              subject, intendedReturnType, returnType),
+              method, requiredReturnType, returnType),
           method);
     }
-
-    // @Binds methods should only have one parameter, but we can't guarantee the order of Processors
-    // in javac, so do a basic check for valid form
-    if (isAnnotationPresent(method, Binds.class) && method.getParameters().size() == 1) {
-      validateMapKeyMatchesBindsParameter(annotation, method);
-    }
   }
 
   /**
@@ -135,8 +146,8 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
    * <pre>{@code
    * {@literal @Binds}
    * {@literal @IntoMap}
-   * {@literal @ActivityKey(GreenActivity.class)}
-   * abstract AndroidInjector.Factory<? extends Activity> bindBlueActivity(
+   * {@literal @ClassKey(GreenActivity.class)}
+   * abstract AndroidInjector.Factory<?> bindBlueActivity(
    *     BlueActivityComponent.Builder builder);
    * }</pre>
    */
@@ -155,19 +166,6 @@ private void validateMapKeyMatchesBindsParameter(
     }
   }
 
-  private TypeMirror frameworkTypeForMapKey(
-      ExecutableElement method, Class<? extends Annotation> annotation) {
-    AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
-    TypeMirror mapKeyType =
-        elements.getTypeElement(injectedTypeFromMapKey(annotationMirror).get()).asType();
-    return annotationsAndFrameworkTypes(elements)
-        .values()
-        .stream()
-        .filter(frameworkType -> types.isAssignable(mapKeyType, frameworkType))
-        .findFirst()
-        .get();
-  }
-
   /** Returns a {@link DeclaredType} for {@code AndroidInjector.Factory<implementationType>}. */
   private DeclaredType injectorFactoryOf(TypeMirror implementationType) {
     return types.getDeclaredType(factoryElement(), implementationType);
diff --git a/java/dagger/android/processor/AndroidMapKeys.java b/java/dagger/android/processor/AndroidMapKeys.java
index 64682070a..fb1fc3853 100644
--- a/java/dagger/android/processor/AndroidMapKeys.java
+++ b/java/dagger/android/processor/AndroidMapKeys.java
@@ -17,78 +17,19 @@
 package dagger.android.processor;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static java.util.stream.Collectors.toMap;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableMap;
-import dagger.MapKey;
 import dagger.android.AndroidInjectionKey;
-import java.lang.annotation.Annotation;
-import java.util.List;
 import java.util.Optional;
-import java.util.stream.Stream;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.Elements;
 
 final class AndroidMapKeys {
-
-  /**
-   * Returns the Android framework types available to the compiler, keyed by their associated {@code
-   * dagger.android} {@link MapKey}s. This will always contain the types that are defined by the
-   * framework, and only contain the support library types if they are on the classpath of the
-   * current compilation.
-   */
-  static ImmutableMap<Class<? extends Annotation>, TypeMirror> annotationsAndFrameworkTypes(
-      Elements elements) {
-    return ImmutableMap.copyOf(
-        Stream.of(
-                elements.getPackageElement("dagger.android"),
-                elements.getPackageElement("dagger.android.support"))
-            .filter(packageElement -> packageElement != null)
-            .flatMap(packageElement -> typesIn(packageElement.getEnclosedElements()).stream())
-            .filter(AndroidMapKeys::isNotAndroidInjectionKey)
-            .filter(type -> isAnnotationPresent(type, MapKey.class))
-            .filter(mapKey -> mapKey.getAnnotation(MapKey.class).unwrapValue())
-            .flatMap(AndroidMapKeys::classForAnnotationElement)
-            .collect(toMap(key -> key, key -> mapKeyValue(key, elements))));
-  }
-
-  private static boolean isNotAndroidInjectionKey(TypeElement type) {
-    return !type.getQualifiedName().contentEquals(AndroidInjectionKey.class.getCanonicalName());
-  }
-
-  private static Stream<Class<? extends Annotation>> classForAnnotationElement(TypeElement type) {
-    try {
-      @SuppressWarnings("unchecked")
-      Class<? extends Annotation> clazz =
-          (Class<? extends Annotation>) Class.forName(type.getQualifiedName().toString());
-      return Stream.of(clazz);
-    } catch (ClassNotFoundException e) {
-      return Stream.of();
-    }
-  }
-
-  private static TypeMirror mapKeyValue(Class<? extends Annotation> annotation, Elements elements) {
-    List<ExecutableElement> mapKeyMethods =
-        methodsIn(elements.getTypeElement(annotation.getCanonicalName()).getEnclosedElements());
-    TypeMirror returnType = getOnlyElement(mapKeyMethods).getReturnType();
-    // TODO(ronshapiro): replace with MoreTypes.asWildcard() when auto-common 0.9 is released
-    return ((WildcardType) getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments()))
-        .getExtendsBound();
-  }
-
   /**
    * If {@code mapKey} is {@link AndroidInjectionKey}, returns the string value for the map key. If
-   * it's {@link dagger.android.ActivityKey} or one of the other class-based keys, returns the
-   * fully-qualified class name of the annotation value. Otherwise returns {@link Optional#empty()}.
+   * it's {@link dagger.multibindings.ClassKey}, returns the fully-qualified class name of the
+   * annotation value. Otherwise returns {@link Optional#empty()}.
    */
   static Optional<String> injectedTypeFromMapKey(AnnotationMirror mapKey) {
     Object mapKeyClass = getAnnotationValue(mapKey, "value").getValue();
diff --git a/java/dagger/android/processor/BUILD b/java/dagger/android/processor/BUILD
index 7b2948fc7..00c10211c 100644
--- a/java/dagger/android/processor/BUILD
+++ b/java/dagger/android/processor/BUILD
@@ -47,7 +47,7 @@ java_library(
         "//java/dagger/model",
         "//java/dagger/spi",
         # https://github.com/bazelbuild/bazel/issues/2517
-        ":dagger-android-jars",
+        ":dagger-android-jar",
     ],
 )
 
@@ -55,19 +55,13 @@ java_library(
 # This target serves two (related) purposes:
 # 1. Bazel does not allow a java_library to depend on an android_library, even if that java_library
 # will be used in a java_plugin.
-# 2. It stores the metadata for the "jarimpl" targets that we use to work-around Gradle not loading
+# 2. It stores the metadata for the "jarimpl" target that we use to work-around Gradle not loading
 # aar artifacts that are declared as deps of an annotation processor. Our pom.xml generator reads
 # the tags and includes them apppropriately.
 java_import(
-    name = "dagger-android-jars",
-    jars = [
-        "//java/dagger/android:libandroid.jar",
-        "//java/dagger/android/support:libsupport.jar",
-    ],
-    tags = [
-        "maven_coordinates=com.google.dagger:dagger-android-jarimpl:" + POM_VERSION,
-        "maven_coordinates=com.google.dagger:dagger-android-support-jarimpl:" + POM_VERSION,
-    ],
+    name = "dagger-android-jar",
+    jars = ["//java/dagger/android:libandroid.jar"],
+    tags = ["maven_coordinates=com.google.dagger:dagger-android-jarimpl:" + POM_VERSION],
     visibility = ["//visibility:private"],
 )
 
diff --git a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
index 4f022c229..d25e7b444 100644
--- a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
+++ b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
@@ -50,6 +50,7 @@
 import dagger.android.AndroidInjector;
 import dagger.android.ContributesAndroidInjector;
 import dagger.android.processor.AndroidInjectorDescriptor.Validator;
+import dagger.multibindings.ClassKey;
 import dagger.multibindings.IntoMap;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
@@ -90,10 +91,15 @@
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> deferredElements = ImmutableSet.builder();
     for (ExecutableElement method : methodsIn(elementsByAnnotation.values())) {
-      validator.createIfValid(method).ifPresent(this::generate);
+      try {
+        validator.createIfValid(method).ifPresent(this::generate);
+      } catch (TypeNotPresentException e) {
+        deferredElements.add(method);
+      }
     }
-    return ImmutableSet.of();
+    return deferredElements.build();
   }
 
   private void generate(AndroidInjectorDescriptor descriptor) {
@@ -144,7 +150,7 @@ private MethodSpec bindAndroidInjectorFactory(
         .returns(
             parameterizedTypeName(
                 AndroidInjector.Factory.class,
-                WildcardTypeName.subtypeOf(descriptor.frameworkType())))
+                WildcardTypeName.subtypeOf(TypeName.OBJECT)))
         .addParameter(subcomponentBuilderName, "builder")
         .build();
   }
@@ -155,7 +161,7 @@ private AnnotationSpec androidInjectorMapKey(AndroidInjectorDescriptor descripto
           .addMember("value", "$S", descriptor.injectedType().toString())
           .build();
     }
-    return AnnotationSpec.builder(descriptor.mapKeyType())
+    return AnnotationSpec.builder(ClassKey.class)
         .addMember("value", "$T.class", descriptor.injectedType())
         .build();
   }
diff --git a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
index a5c664b56..a19c5efaa 100644
--- a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
+++ b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
@@ -32,8 +32,8 @@
 import dagger.MapKey;
 import dagger.android.AndroidInjector;
 import dagger.android.DispatchingAndroidInjector;
+import dagger.model.Binding;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingKind;
 import dagger.model.Key;
 import dagger.spi.BindingGraphPlugin;
@@ -58,31 +58,30 @@
 public final class DuplicateAndroidInjectorsChecker implements BindingGraphPlugin {
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    for (BindingNode node : graph.bindingNodes()) {
-      if (isDispatchingAndroidInjector(node)) {
-        validateMapKeyUniqueness(node, graph, diagnosticReporter);
+    for (Binding binding : graph.bindings()) {
+      if (isDispatchingAndroidInjector(binding)) {
+        validateMapKeyUniqueness(binding, graph, diagnosticReporter);
       }
     }
   }
 
-  private boolean isDispatchingAndroidInjector(BindingNode node) {
-    Key key = node.key();
+  private boolean isDispatchingAndroidInjector(Binding binding) {
+    Key key = binding.key();
     return MoreTypes.isTypeOf(DispatchingAndroidInjector.class, key.type())
         && !key.qualifier().isPresent();
   }
 
   private void validateMapKeyUniqueness(
-      BindingNode dispatchingAndroidInjectorNode,
+      Binding dispatchingAndroidInjector,
       BindingGraph graph,
       DiagnosticReporter diagnosticReporter) {
-    ImmutableSet<BindingNode> injectorFactories =
-        injectorMapDependencies(dispatchingAndroidInjectorNode, graph)
-            .flatMap(injectorFactoryMap -> dependencies(injectorFactoryMap, graph))
+    ImmutableSet<Binding> injectorFactories =
+        injectorMapDependencies(dispatchingAndroidInjector, graph)
+            .flatMap(injectorFactoryMap -> graph.requestedBindings(injectorFactoryMap).stream())
             .collect(collectingAndThen(toList(), ImmutableSet::copyOf));
 
-    ImmutableListMultimap.Builder<String, BindingNode> mapKeyIndex =
-        ImmutableListMultimap.builder();
-    for (BindingNode injectorFactory : injectorFactories) {
+    ImmutableListMultimap.Builder<String, Binding> mapKeyIndex = ImmutableListMultimap.builder();
+    for (Binding injectorFactory : injectorFactories) {
       AnnotationMirror mapKey = mapKey(injectorFactory).get();
       Optional<String> injectedType = injectedTypeFromMapKey(mapKey);
       if (injectedType.isPresent()) {
@@ -93,9 +92,8 @@ private void validateMapKeyUniqueness(
       }
     }
 
-    Map<String, List<BindingNode>> duplicates =
-        Maps.filterValues(
-            Multimaps.asMap(mapKeyIndex.build()), bindingNodes -> bindingNodes.size() > 1);
+    Map<String, List<Binding>> duplicates =
+        Maps.filterValues(Multimaps.asMap(mapKeyIndex.build()), bindings -> bindings.size() > 1);
     if (!duplicates.isEmpty()) {
       StringBuilder errorMessage =
           new StringBuilder("Multiple injector factories bound for the same type:\n");
@@ -105,31 +103,21 @@ private void validateMapKeyUniqueness(
             formatter.format("  %s:\n", injectedType);
             duplicateFactories.forEach(duplicate -> formatter.format("    %s\n", duplicate));
           });
-      diagnosticReporter.reportBinding(
-          ERROR, dispatchingAndroidInjectorNode, errorMessage.toString());
+      diagnosticReporter.reportBinding(ERROR, dispatchingAndroidInjector, errorMessage.toString());
     }
   }
 
-  private Stream<BindingNode> dependencies(BindingNode bindingNode, BindingGraph graph) {
-    return graph
-        .successors(bindingNode)
-        .stream()
-        // TODO(ronshapiro): reuse DaggerStreams.instancesOf()?
-        .filter(BindingNode.class::isInstance)
-        .map(BindingNode.class::cast);
-  }
-
   /**
-   * Returns a stream of the dependencies of {@code bindingNode} that have a key type of {@code
-   * Map<K, Provider<AndroidInjector.Factory<?>>}.
+   * Returns a stream of the dependencies of {@code binding} that have a key type of {@code Map<K,
+   * Provider<AndroidInjector.Factory<?>>}.
    */
-  private Stream<BindingNode> injectorMapDependencies(BindingNode bindingNode, BindingGraph graph) {
-    return dependencies(bindingNode, graph)
-        .filter(node -> node.binding().kind().equals(BindingKind.MULTIBOUND_MAP))
+  private Stream<Binding> injectorMapDependencies(Binding binding, BindingGraph graph) {
+    return graph.requestedBindings(binding).stream()
+        .filter(requestedBinding -> requestedBinding.kind().equals(BindingKind.MULTIBOUND_MAP))
         .filter(
-            node -> {
+            requestedBinding -> {
               TypeMirror valueType =
-                  MoreTypes.asDeclared(node.key().type()).getTypeArguments().get(1);
+                  MoreTypes.asDeclared(requestedBinding.key().type()).getTypeArguments().get(1);
               if (!MoreTypes.isTypeOf(Provider.class, valueType)
                   || !valueType.getKind().equals(TypeKind.DECLARED)) {
                 return false;
@@ -139,9 +127,8 @@ private void validateMapKeyUniqueness(
             });
   }
 
-  private Optional<AnnotationMirror> mapKey(BindingNode bindingNode) {
-    return bindingNode
-        .binding()
+  private Optional<AnnotationMirror> mapKey(Binding binding) {
+    return binding
         .bindingElement()
         .map(bindingElement -> getAnnotatedAnnotations(bindingElement, MapKey.class))
         .flatMap(
diff --git a/java/dagger/android/support/AndroidSupportInjectionModule.java b/java/dagger/android/support/AndroidSupportInjectionModule.java
index 85b277a97..d78b0cb39 100644
--- a/java/dagger/android/support/AndroidSupportInjectionModule.java
+++ b/java/dagger/android/support/AndroidSupportInjectionModule.java
@@ -16,29 +16,16 @@
 
 package dagger.android.support;
 
-import android.support.v4.app.Fragment;
 import dagger.Module;
 import dagger.android.AndroidInjectionModule;
-import dagger.android.AndroidInjector;
 import dagger.internal.Beta;
-import dagger.multibindings.Multibinds;
-import java.util.Map;
 
 /**
- * Configures bindings to ensure the usability of {@code dagger.android} and {@code
- * dagger.android.support} framework classes. This module should be installed in the root-most
- * component which will use these types.
+ * This module no longer provides any value beyond what is provided in {@link
+ * AndroidInjectionModule} and is just an alias. It will be removed in a future release.
  */
 @Beta
 @Module(includes = AndroidInjectionModule.class)
 public abstract class AndroidSupportInjectionModule {
-  @Multibinds
-  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
-      supportFragmentInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
-      supportFragmentInjectorFactoriesWithStringKeys();
-
   private AndroidSupportInjectionModule() {}
 }
diff --git a/java/dagger/android/support/BUILD b/java/dagger/android/support/BUILD
index e4b06560f..749d541fe 100644
--- a/java/dagger/android/support/BUILD
+++ b/java/dagger/android/support/BUILD
@@ -64,14 +64,6 @@ pom_file(
     targets = [":support"],
 )
 
-# b/37741866 and https://github.com/google/dagger/issues/715
-pom_file(
-    name = "jarimpl-pom",
-    artifact_id = "dagger-android-support-jarimpl",
-    artifact_name = "Dagger Android Support",
-    targets = [":support"],
-)
-
 load("@google_bazel_common//tools/javadoc:javadoc.bzl", "javadoc_library")
 
 javadoc_library(
diff --git a/java/dagger/android/support/DaggerDialogFragment.java b/java/dagger/android/support/DaggerDialogFragment.java
new file mode 100644
index 000000000..18feb6e39
--- /dev/null
+++ b/java/dagger/android/support/DaggerDialogFragment.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.content.Context;
+import android.support.v4.app.DialogFragment;
+import android.support.v4.app.Fragment;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * A {@link DialogFragment} that injects its members in {@link #onAttach(Context)} and can be used
+ * to inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached,
+ * its members will be injected again.
+ */
+@Beta
+public abstract class DaggerDialogFragment extends DialogFragment
+    implements HasSupportFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  @Override
+  public void onAttach(Context context) {
+    AndroidSupportInjection.inject(this);
+    super.onAttach(context);
+  }
+
+  @Override
+  public AndroidInjector<Fragment> supportFragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/java/dagger/android/support/FragmentKey.java b/java/dagger/android/support/FragmentKey.java
deleted file mode 100644
index 902574be2..000000000
--- a/java/dagger/android/support/FragmentKey.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.support;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import android.support.v4.app.Fragment;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-public @interface FragmentKey {
-  Class<? extends Fragment> value();
-}
diff --git a/java/dagger/errorprone/AndroidSupportInjectionModuleMigrator.java b/java/dagger/errorprone/AndroidSupportInjectionModuleMigrator.java
new file mode 100644
index 000000000..c2d90249e
--- /dev/null
+++ b/java/dagger/errorprone/AndroidSupportInjectionModuleMigrator.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.errorprone;
+
+import static com.google.errorprone.BugPattern.SeverityLevel.SUGGESTION;
+
+import com.google.errorprone.BugPattern;
+import com.google.errorprone.BugPattern.ProvidesFix;
+import com.google.errorprone.VisitorState;
+import com.google.errorprone.bugpatterns.BugChecker;
+import com.google.errorprone.bugpatterns.BugChecker.MemberSelectTreeMatcher;
+import com.google.errorprone.fixes.SuggestedFix;
+import com.google.errorprone.matchers.Description;
+import com.google.errorprone.matchers.Matcher;
+import com.google.errorprone.matchers.Matchers;
+import com.google.errorprone.util.ASTHelpers;
+import com.sun.source.tree.ExpressionTree;
+import com.sun.source.tree.MemberSelectTree;
+import com.sun.tools.javac.code.Symbol;
+
+/** A refactoring to update AndroidInjector bindings to their new form. */
+@BugPattern(
+    name = "AndroidSupportInjectionModuleMigrator",
+    providesFix = ProvidesFix.REQUIRES_HUMAN_ATTENTION,
+    summary = "Inlines usages of AndroidSupportInjectionModule to AndroidInjectionModule",
+    explanation =
+        "AndroidSupportInjectionModule is now an empty module and acts as an alias for "
+            + "AndroidInjectionModule. This migration rewrites usages of the former to the latter.",
+    severity = SUGGESTION)
+public final class AndroidSupportInjectionModuleMigrator extends BugChecker
+    implements MemberSelectTreeMatcher {
+  private static final Matcher<ExpressionTree> MODULE_CLASS_LITERAL =
+      Matchers.classLiteral(
+          (ExpressionTree expressionTree, VisitorState state) -> {
+            Symbol symbol = ASTHelpers.getSymbol(expressionTree);
+            if (symbol == null) {
+              return false;
+            }
+            return symbol
+                .getQualifiedName()
+                .contentEquals("dagger.android.support.AndroidSupportInjectionModule");
+          });
+
+  @Override
+  public Description matchMemberSelect(MemberSelectTree tree, VisitorState state) {
+    if (MODULE_CLASS_LITERAL.matches(tree, state)) {
+      return buildDescription(tree)
+          .addFix(
+              SuggestedFix.builder()
+                  .replace(tree, "AndroidInjectionModule.class")
+                  .addImport("dagger.android.AndroidInjectionModule")
+                  .build())
+          .build();
+    }
+    return Description.NO_MATCH;
+  }
+}
diff --git a/java/dagger/errorprone/BUILD b/java/dagger/errorprone/BUILD
new file mode 100644
index 000000000..408925aa2
--- /dev/null
+++ b/java/dagger/errorprone/BUILD
@@ -0,0 +1,15 @@
+# Description:
+#   ErrorProne refactorings and static analysis for Dagger
+
+package(default_visibility = ["//:src"])
+
+java_library(
+    name = "errorprone",
+    srcs = glob(["*.java"]),
+    deps = [
+        "//java/dagger:core",
+        "@bazel_tools//tools/jdk:langtools-neverlink",
+        "@google_bazel_common//third_party/java/error_prone:check_api",
+        "@google_bazel_common//third_party/java/guava",
+    ],
+)
diff --git a/java/dagger/example/android/simple/BUILD b/java/dagger/example/android/simple/BUILD
index 1c9d9f522..7396744f9 100644
--- a/java/dagger/example/android/simple/BUILD
+++ b/java/dagger/example/android/simple/BUILD
@@ -34,6 +34,7 @@ android_library(
 
 android_binary(
     name = "simple",
+    aapt_version = "aapt",
     manifest = "AndroidManifest.xml",
     deps = [
         ":simple_lib",
diff --git a/java/dagger/example/android/simple/MainActivity.java b/java/dagger/example/android/simple/MainActivity.java
index 8a51ae07f..f2aab2dfa 100644
--- a/java/dagger/example/android/simple/MainActivity.java
+++ b/java/dagger/example/android/simple/MainActivity.java
@@ -16,14 +16,13 @@
 
 package dagger.example.android.simple;
 
-import android.app.Activity;
 import android.os.Bundle;
 import android.util.Log;
 import android.widget.TextView;
 import dagger.Binds;
-import dagger.android.ActivityKey;
 import dagger.android.AndroidInjector;
 import dagger.android.support.DaggerAppCompatActivity;
+import dagger.multibindings.ClassKey;
 import dagger.multibindings.IntoMap;
 import javax.inject.Inject;
 
@@ -44,8 +43,8 @@
 
     @Binds
     @IntoMap
-    @ActivityKey(MainActivity.class)
-    abstract AndroidInjector.Factory<? extends Activity> bind(Component.Builder builder);
+    @ClassKey(MainActivity.class)
+    abstract AndroidInjector.Factory<?> bind(Component.Builder builder);
   }
 
   private static final String TAG = MainActivity.class.getSimpleName();
diff --git a/java/dagger/example/android/simple/SimpleApplication.java b/java/dagger/example/android/simple/SimpleApplication.java
index c64417408..ae3d42db8 100644
--- a/java/dagger/example/android/simple/SimpleApplication.java
+++ b/java/dagger/example/android/simple/SimpleApplication.java
@@ -17,9 +17,9 @@
 package dagger.example.android.simple;
 
 import android.util.Log;
+import dagger.android.AndroidInjectionModule;
 import dagger.android.AndroidInjector;
 import dagger.android.DaggerApplication;
-import dagger.android.support.AndroidSupportInjectionModule;
 import javax.inject.Inject;
 
 /**
@@ -30,8 +30,7 @@
   private static final String TAG = SimpleApplication.class.getSimpleName();
 
   @dagger.Component(
-    modules = {AndroidSupportInjectionModule.class, MainActivity.Module.class, BuildModule.class}
-  )
+      modules = {AndroidInjectionModule.class, MainActivity.Module.class, BuildModule.class})
   /* @ApplicationScoped and/or @Singleton */
   interface Component extends AndroidInjector<SimpleApplication> {
     @dagger.Component.Builder
diff --git a/java/dagger/example/spi/BindingGraphVisualizer.java b/java/dagger/example/spi/BindingGraphVisualizer.java
index 01b5c42d4..8865c8de8 100644
--- a/java/dagger/example/spi/BindingGraphVisualizer.java
+++ b/java/dagger/example/spi/BindingGraphVisualizer.java
@@ -28,13 +28,13 @@
 import com.google.common.graph.EndpointPair;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
+import dagger.model.Binding;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.MaybeBindingNode;
-import dagger.model.BindingGraph.MissingBindingNode;
+import dagger.model.BindingGraph.MaybeBinding;
+import dagger.model.BindingGraph.MissingBinding;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingGraph.SubcomponentBuilderBindingEdge;
 import dagger.model.BindingKind;
@@ -58,7 +58,7 @@
 import javax.tools.StandardLocation;
 
 /**
- * Experimental network visualizer used as a proof-of-concept for {@link BindingGraphPlugin}.
+ * Experimental visualizer used as a proof-of-concept for {@link BindingGraphPlugin}.
  *
  * <p>For each component, writes a <a href=http://www.graphviz.org/content/dot-language>DOT file</a>
  * in the same package. The file name is the name of the component type (with enclosing type names,
@@ -224,9 +224,7 @@ private static String quote(String string) {
     DotGraph graph() {
       if (nodeIds.isEmpty()) {
         Iterator<String> colors = Iterators.cycle(COMPONENT_COLORS);
-        bindingGraph
-            .nodes()
-            .stream()
+        bindingGraph.network().nodes().stream()
             .collect(groupingBy(Node::componentPath))
             .forEach(
                 (component, networkNodes) -> {
@@ -241,7 +239,7 @@ DotGraph graph() {
                     subgraph.add(dotNode(node));
                   }
                 });
-        for (Edge edge : bindingGraph.edges()) {
+        for (Edge edge : bindingGraph.network().edges()) {
           dotEdge(edge).ifPresent(graph::add);
         }
       }
@@ -259,7 +257,7 @@ UUID nodeId(Node node) {
     }
 
     Optional<DotEdge> dotEdge(Edge edge) {
-      EndpointPair<Node> incidentNodes = bindingGraph.incidentNodes(edge);
+      EndpointPair<Node> incidentNodes = bindingGraph.network().incidentNodes(edge);
       DotEdge dotEdge = new DotEdge(nodeId(incidentNodes.source()), nodeId(incidentNodes.target()));
       if (edge instanceof DependencyEdge) {
         if (((DependencyEdge) edge).isEntryPoint()) {
@@ -280,17 +278,17 @@ UUID nodeId(Node node) {
 
     DotNode dotNode(Node node) {
       DotNode dotNode = new DotNode(nodeId(node));
-      if (node instanceof MaybeBindingNode) {
+      if (node instanceof MaybeBinding) {
         dotNode.addAttribute("tooltip", "");
-        if (bindingGraph.entryPointBindingNodes().contains(node)) {
+        if (bindingGraph.entryPointBindings().contains(node)) {
           dotNode.addAttribute("penwidth", 3);
         }
-        if (node instanceof BindingNode) {
-          dotNode.addAttribute("label", label((BindingNode) node));
+        if (node instanceof Binding) {
+          dotNode.addAttribute("label", label((Binding) node));
         }
-        if (node instanceof MissingBindingNode) {
+        if (node instanceof MissingBinding) {
           dotNode.addAttributeFormat(
-              "label", "missing binding for %s", ((MissingBindingNode) node).key());
+              "label", "missing binding for %s", ((MissingBinding) node).key());
         }
       } else {
         dotNode.addAttribute("style", "invis").addAttribute("shape", "point");
@@ -298,13 +296,13 @@ DotNode dotNode(Node node) {
       return dotNode;
     }
 
-    private String label(BindingNode bindingNode) {
-      if (bindingNode.binding().kind().equals(BindingKind.MEMBERS_INJECTION)) {
-        return String.format("inject(%s)", bindingNode.key());
-      } else if (bindingNode.binding().isProduction()) {
-        return String.format("@Produces %s", bindingNode.key());
+    private String label(Binding binding) {
+      if (binding.kind().equals(BindingKind.MEMBERS_INJECTION)) {
+        return String.format("inject(%s)", binding.key());
+      } else if (binding.isProduction()) {
+        return String.format("@Produces %s", binding.key());
       } else {
-        return bindingNode.key().toString();
+        return binding.key().toString();
       }
     }
 
diff --git a/java/dagger/grpc/server/processor/GrpcServiceProcessor.java b/java/dagger/grpc/server/processor/GrpcServiceProcessor.java
index 122718d5d..58495e2f1 100644
--- a/java/dagger/grpc/server/processor/GrpcServiceProcessor.java
+++ b/java/dagger/grpc/server/processor/GrpcServiceProcessor.java
@@ -63,16 +63,21 @@ public SourceVersion getSupportedSourceVersion() {
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> deferredElements = ImmutableSet.builder();
     for (TypeElement element : typesIn(elementsByAnnotation.get(GrpcService.class))) {
-      GrpcServiceModel grpcServiceModel = new GrpcServiceModel(processingEnv, element);
-      if (grpcServiceModel.validate()) {
-        write(new ServiceDefinitionTypeGenerator(grpcServiceModel), element);
-        write(new ProxyModuleGenerator(grpcServiceModel), element);
-        write(new GrpcServiceModuleGenerator(grpcServiceModel), element);
-        write(new UnscopedGrpcServiceModuleGenerator(grpcServiceModel), element);
+      try {
+        GrpcServiceModel grpcServiceModel = new GrpcServiceModel(processingEnv, element);
+        if (grpcServiceModel.validate()) {
+          write(new ServiceDefinitionTypeGenerator(grpcServiceModel), element);
+          write(new ProxyModuleGenerator(grpcServiceModel), element);
+          write(new GrpcServiceModuleGenerator(grpcServiceModel), element);
+          write(new UnscopedGrpcServiceModuleGenerator(grpcServiceModel), element);
+        }
+      } catch (TypeNotPresentException e) {
+        deferredElements.add(element);
       }
     }
-    return ImmutableSet.of();
+    return deferredElements.build();
   }
 
   private void write(SourceGenerator grpcServiceTypeWriter, final TypeElement element) {
diff --git a/java/dagger/internal/DelegateFactory.java b/java/dagger/internal/DelegateFactory.java
index 4ec047ca8..416c2a172 100644
--- a/java/dagger/internal/DelegateFactory.java
+++ b/java/dagger/internal/DelegateFactory.java
@@ -16,6 +16,8 @@
 
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 import javax.inject.Provider;
 
 /**
@@ -34,14 +36,26 @@ public T get() {
     return delegate.get();
   }
 
+  // TODO(ronshapiro): remove this once we can reasonably expect generated code is no longer using
+  // this method
+  @Deprecated
   public void setDelegatedProvider(Provider<T> delegate) {
-    if (delegate == null) {
-      throw new IllegalArgumentException();
-    }
-    if (this.delegate != null) {
+    setDelegate(this, delegate);
+  }
+
+  /**
+   * Sets {@code delegateFactory}'s delegate provider to {@code delegate}.
+   *
+   * <p>{@code delegateFactory} must be an instance of {@link DelegateFactory}, otherwise this
+   * method will throw a {@link ClassCastException}.
+   */
+  public static <T> void setDelegate(Provider<T> delegateFactory, Provider<T> delegate) {
+    checkNotNull(delegate);
+    DelegateFactory<T> asDelegateFactory = (DelegateFactory<T>) delegateFactory;
+    if (asDelegateFactory.delegate != null) {
       throw new IllegalStateException();
     }
-    this.delegate = delegate;
+    asDelegateFactory.delegate = delegate;
   }
 }
 
diff --git a/java/dagger/internal/MapBuilder.java b/java/dagger/internal/MapBuilder.java
index 1560491b1..25e2b5b86 100644
--- a/java/dagger/internal/MapBuilder.java
+++ b/java/dagger/internal/MapBuilder.java
@@ -44,6 +44,11 @@ private MapBuilder(int size) {
     return this;
   }
 
+  public MapBuilder<K, V> putAll(Map<K, V> map) {
+    contributions.putAll(map);
+    return this;
+  }
+
   public Map<K, V> build() {
     switch (contributions.size()) {
       case 0:
diff --git a/java/dagger/internal/MapFactory.java b/java/dagger/internal/MapFactory.java
index a580a1388..ea2135494 100644
--- a/java/dagger/internal/MapFactory.java
+++ b/java/dagger/internal/MapFactory.java
@@ -83,6 +83,13 @@ private Builder(int size) {
       return this;
     }
 
+    // TODO(b/118630627): make this accept MapFactory<K, V>, and change all framework fields to be
+    // of that type so we don't need an unsafe cast
+    public Builder<K, V> putAll(Provider<Map<K, V>> mapFactory) {
+      map.putAll(((MapFactory<K, V>) mapFactory).contributingMap);
+      return this;
+    }
+
     /** Returns a new {@link MapProviderFactory}. */
     public MapFactory<K, V> build() {
       return new MapFactory<>(map);
diff --git a/java/dagger/internal/MapProviderFactory.java b/java/dagger/internal/MapProviderFactory.java
index 0a5c115e6..950ad6417 100644
--- a/java/dagger/internal/MapProviderFactory.java
+++ b/java/dagger/internal/MapProviderFactory.java
@@ -68,6 +68,13 @@ private Builder(int size) {
       return this;
     }
 
+    // TODO(b/118630627): make this accept MapProviderFactory<K, V>, and change all framework fields
+    // to be of that type so we don't need an unsafe cast
+    public Builder<K, V> putAll(Provider<Map<K, Provider<V>>> mapProviderFactory) {
+      map.putAll(((MapProviderFactory<K, V>) mapProviderFactory).contributingMap);
+      return this;
+    }
+
     /** Returns a new {@link MapProviderFactory}. */
     public MapProviderFactory<K, V> build() {
       return new MapProviderFactory<>(map);
diff --git a/java/dagger/internal/MissingBindingFactory.java b/java/dagger/internal/MissingBindingFactory.java
new file mode 100644
index 000000000..993d15047
--- /dev/null
+++ b/java/dagger/internal/MissingBindingFactory.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+/**
+ * A {@link Factory} that always throws on calls to {@link Factory#get()}. This is necessary in
+ * ahead-of-time subcomponents mode, where modifiable binding methods need to return a {@code
+ * Provider<T>} to a framework instance initialization that is pruned and no longer in the binding
+ * graph, but was present in a superclass implementation. This class fulfills that requirement but
+ * is still practically unusable.
+ */
+public final class MissingBindingFactory<T> implements Factory<T> {
+  private static final MissingBindingFactory<Object> INSTANCE = new MissingBindingFactory<>();
+
+  private MissingBindingFactory() {}
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
+  public static <T> Factory<T> create() {
+    return (Factory) INSTANCE;
+  }
+
+  @Override
+  public T get() {
+    throw new AssertionError(
+        "This binding is not part of the final binding graph. The key was requested by a binding "
+            + "that was believed to possibly be part of the graph, but is no longer requested. "
+            + "If this exception is thrown, it is the result of a Dagger bug.");
+  }
+}
diff --git a/java/dagger/internal/Preconditions.java b/java/dagger/internal/Preconditions.java
index 7b64da1a5..714a3535e 100644
--- a/java/dagger/internal/Preconditions.java
+++ b/java/dagger/internal/Preconditions.java
@@ -85,5 +85,16 @@
     return reference;
   }
 
+  /**
+   * Checks that the component builder field {@code requirement} has been initialized.
+   *
+   * @throws IllegalStateException if {@code requirement is null}
+   */
+  public static <T> void checkBuilderRequirement(T requirement, Class<T> clazz) {
+    if (requirement == null) {
+      throw new IllegalStateException(clazz.getCanonicalName() + " must be set");
+    }
+  }
+
   private Preconditions() {}
 }
diff --git a/java/dagger/internal/ReferenceReleasingProvider.java b/java/dagger/internal/ReferenceReleasingProvider.java
deleted file mode 100644
index 30a9cb4b5..000000000
--- a/java/dagger/internal/ReferenceReleasingProvider.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import static dagger.internal.Preconditions.checkNotNull;
-
-import java.lang.ref.WeakReference;
-import javax.inject.Provider;
-
-/**
- * A {@link Provider} implementation that can exchange its strong reference to the stored object for
- * a {@link WeakReference}.
- *
- * <p>The provider can be in any one of four states at a time:
- *
- * <ul>
- *   <li>In <b>uninitialized</b> state, the provider's strong reference and its weak reference are
- *       both {@code null}.
- *   <li>In <b>cleared</b> state, the strong reference is {@code null}, and the weak reference's
- *       value is {@code null}.
- *   <li>In <b>strong-reference</b> state, the strong reference refers to the stored object, and the
- *       weak reference is {@code null}.
- *   <li>In <b>weak-reference</b> state, the strong reference is {@code null}, and the weak
- *       reference's value is not {@code null}.
- * </ul>
- *
- * <p>The provider starts in <b>uninitialized</b> state.
- *
- * <p>{@link #get()} transitions to <b>strong-reference</b> state when in <b>uninitialized</b> or
- * <b>cleared</b> state.
- *
- * <p>{@link #releaseStrongReference()} transitions to <b>weak-reference</b> state when in
- * <b>strong-reference</b> state, unless the stored value is {@code null}.
- *
- * <p>{@link #restoreStrongReference()} transitions to <b>strong-reference</b> state when in
- * <b>weak-reference</b> state.
- *
- * <p>If garbage collection clears the weak reference while in <b>weak-reference</b> state, the
- * provider transitions to <b>cleared</b> state.
- *
- * <p><img src="doc-files/ReferenceReleasingProvider-statemachine.png">
- *
- * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
- */
-@GwtIncompatible
-public final class ReferenceReleasingProvider<T> implements Provider<T> {
-  private static final Object NULL = new Object(); // sentinel used when provider.get() returns null
-
-  private final Provider<T> provider;
-  private volatile Object strongReference;
-  private volatile WeakReference<T> weakReference;
-
-  private ReferenceReleasingProvider(Provider<T> provider) {
-    assert provider != null;
-    this.provider = provider;
-  }
-
-  /**
-   * Releases the strong reference to the object previously returned by {@link #get()}, and creates
-   * a {@link WeakReference} to that object, unless the stored value is {@code null}.
-   */
-  public void releaseStrongReference() {
-    Object value = strongReference;
-    if (value != null && value != NULL) {
-      synchronized (this) {
-        @SuppressWarnings("unchecked") // values other than NULL come from the provider
-        T storedValue = (T) value;
-        weakReference = new WeakReference<T>(storedValue);
-        strongReference = null;
-      }
-    }
-  }
-
-  /**
-   * Restores the strong reference that was previously {@linkplain #releaseStrongReference()
-   * released} if the {@link WeakReference} has not yet been cleared during garbage collection.
-   */
-  public void restoreStrongReference() {
-    Object value = strongReference;
-    if (weakReference != null && value == null) {
-      synchronized (this) {
-        value = strongReference;
-        if (weakReference != null && value == null) {
-          value = weakReference.get();
-          if (value != null) {
-            strongReference = value;
-            weakReference = null;
-          }
-        }
-      }
-    }
-  }
-
-  /**
-   * Returns the result of calling {@link Provider#get()} on the underlying {@link Provider}.
-   *
-   * <p>Calling {@code get()} in <b>uninitialized</b> or <b>cleared</b> state calls {@code get()}
-   * on the underlying provider, sets the strong reference to the returned value, and returns it,
-   * leaving the provider in <b>strong-reference</b> state.
-   *
-   * <p>Calling {@code get()} in <b>strong-reference</b> state simply returns the strong reference,
-   * leaving the provider in <b>strong-reference</b> state.
-   *
-   * <p>Calling {@code get()} in <b>weak-reference</b> state returns the {@link WeakReference}'s
-   * value, leaving the provider in <b>weak-reference</b> state.
-   */
-  @SuppressWarnings("unchecked") // cast only happens when result comes from the provider
-  @Override
-  public T get() {
-    Object value = currentValue();
-    if (value == null) {
-      synchronized (this) {
-        value = currentValue();
-        if (value == null) {
-          value = provider.get();
-          if (value == null) {
-            value = NULL;
-          }
-          strongReference = value;
-        }
-      }
-    }
-    return value == NULL ? null : (T) value;
-  }
-
-  private Object currentValue() {
-    Object value = strongReference;
-    if (value != null) {
-      return value;
-    }
-    if (weakReference != null) {
-      return weakReference.get();
-    }
-    return null;
-  }
-
-  /**
-   * Returns a {@link Provider} that stores the value from the given delegate provider and is
-   * managed by {@code references}.
-   */
-  public static <T> ReferenceReleasingProvider<T> create(
-      Provider<T> delegate, ReferenceReleasingProviderManager references) {
-    ReferenceReleasingProvider<T> provider =
-        new ReferenceReleasingProvider<T>(checkNotNull(delegate));
-    references.addProvider(provider);
-    return provider;
-  }
-}
diff --git a/java/dagger/internal/ReferenceReleasingProviderManager.java b/java/dagger/internal/ReferenceReleasingProviderManager.java
deleted file mode 100644
index 9be7c342a..000000000
--- a/java/dagger/internal/ReferenceReleasingProviderManager.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import static dagger.internal.Preconditions.checkNotNull;
-
-import dagger.releasablereferences.ReleasableReferenceManager;
-import java.lang.annotation.Annotation;
-import java.lang.ref.WeakReference;
-import java.util.Iterator;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-/**
- * A {@link ReleasableReferenceManager} that forwards calls to a dynamic set of weakly-referenced
- * {@link ReferenceReleasingProvider}s.
- *
- * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
- */
-@GwtIncompatible
-public final class ReferenceReleasingProviderManager implements ReleasableReferenceManager {
-
-  private final Class<? extends Annotation> scope;
-  private final Queue<WeakReference<ReferenceReleasingProvider<?>>> providers =
-      new ConcurrentLinkedQueue<WeakReference<ReferenceReleasingProvider<?>>>();
-
-  public ReferenceReleasingProviderManager(Class<? extends Annotation> scope) {
-    this.scope = checkNotNull(scope);
-  }
-
-  /**
-   * Adds a weak reference to {@code provider}.
-   */
-  public void addProvider(ReferenceReleasingProvider<?> provider) {
-    providers.add(new WeakReference<ReferenceReleasingProvider<?>>(provider));
-  }
-
-  @Override
-  public Class<? extends Annotation> scope() {
-    return scope;
-  }
-
-  /**
-   * {@inheritDoc} Calls {@link ReferenceReleasingProvider#releaseStrongReference()} on all
-   * providers that have been {@linkplain #addProvider(ReferenceReleasingProvider) added} and that
-   * are still weakly referenced.
-   */
-  @Override
-  public void releaseStrongReferences() {
-    execute(Operation.RELEASE);
-  }
-
-  /**
-   * {@inheritDoc} Calls {@link ReferenceReleasingProvider#restoreStrongReference()} on all
-   * providers that have been {@linkplain #addProvider(ReferenceReleasingProvider) added} and that
-   * are still weakly referenced.
-   */
-  @Override
-  public void restoreStrongReferences() {
-    execute(Operation.RESTORE);
-  }
-
-  private void execute(Operation operation) {
-    Iterator<WeakReference<ReferenceReleasingProvider<?>>> iterator = providers.iterator();
-    while (iterator.hasNext()) {
-      ReferenceReleasingProvider<?> provider = iterator.next().get();
-      if (provider == null) {
-        iterator.remove();
-      } else {
-        operation.execute(provider);
-      }
-    }
-  }
-
-  private enum Operation {
-    RELEASE {
-      @Override
-      void execute(ReferenceReleasingProvider<?> provider) {
-        provider.releaseStrongReference();
-      }
-    },
-    RESTORE {
-      @Override
-      void execute(ReferenceReleasingProvider<?> provider) {
-        provider.restoreStrongReference();
-      }
-    },
-    ;
-
-    abstract void execute(ReferenceReleasingProvider<?> provider);
-  }
-}
diff --git a/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java b/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java
deleted file mode 100644
index a1167ef8e..000000000
--- a/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import static dagger.internal.Preconditions.checkNotNull;
-
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.lang.annotation.Annotation;
-
-/**
- * A {@link TypedReleasableReferenceManager} that decorates another {@link
- * ReleasableReferenceManager} with a metadata annotation.
- *
- * <p>For each scope that requires a {@link ReleasableReferenceManager}, the generated component
- * implementation has a field that implements that manager. For every {@link
- * TypedReleasableReferenceManager} that is required for that scope, the component uses this class
- * to decorate the field with the metadata annotation.
- *
- * @param <M> the type of the metadata annotation
- */
-@GwtIncompatible
-public final class TypedReleasableReferenceManagerDecorator<M extends Annotation>
-    implements TypedReleasableReferenceManager<M> {
-
-  private final ReleasableReferenceManager delegate;
-  private final M metadata;
-
-  /**
-   * Constructs a manager that delegates {@link #releaseStrongReferences()} and {@link
-   * #releaseStrongReferences()} to {@code delegate}.
-   */
-  public TypedReleasableReferenceManagerDecorator(ReleasableReferenceManager delegate, M metadata) {
-    this.delegate = checkNotNull(delegate);
-    this.metadata = checkNotNull(metadata);
-  }
-
-  @Override
-  public Class<? extends Annotation> scope() {
-    return delegate.scope();
-  }
-
-  @Override
-  public M metadata() {
-    return metadata;
-  }
-
-  @Override
-  public void releaseStrongReferences() {
-    delegate.releaseStrongReferences();
-  }
-
-  @Override
-  public void restoreStrongReferences() {
-    delegate.restoreStrongReferences();
-  }
-}
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 2365772ed..f41ba7980 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -18,14 +18,14 @@
 package(default_visibility = ["//:src"])
 
 load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
-load("//tools:maven.bzl", "pom_file", "POM_VERSION")
+load("//tools:maven.bzl", "POM_VERSION", "pom_file")
 load("//tools:simple_jar.bzl", "simple_jar")
 
 EXPERIMENTAL_VISUALIZER_SRCS = ["BindingNetworkVisualizer.java"]
 
 KYTHE_SRCS = [
-    "KytheBindingGraphFactory.java",
     "DaggerKythePlugin.java",
+    "JavacPluginModule.java",
 ]
 
 CODEGEN_SRCS = glob(
@@ -43,6 +43,7 @@ CODEGEN_SHARED_DEPS = [
     "@google_bazel_common//third_party/java/error_prone:annotations",
     "@google_bazel_common//third_party/java/google_java_format",
     "@google_bazel_common//third_party/java/javapoet",
+    "@bazel_tools//tools/jdk:langtools-neverlink",
     "@google_bazel_common//third_party/java/jsr250_annotations",
     "@google_bazel_common//third_party/java/jsr330_inject",
     "//java/dagger:core",
@@ -53,15 +54,19 @@ CODEGEN_SHARED_DEPS = [
 ]
 
 CODEGEN_DEPS = CODEGEN_SHARED_DEPS + [
+    ":jdk-and-guava-extras",
     "@google_bazel_common//third_party/java/guava",
-    ":shared-with-spi",
 ]
 
-# Code that is shared with the dagger.model and dagger.spi packages. This code is merged into both
+# Extra features for the JDK and Guava. This code is merged into both
 # the dagger-compiler and dagger-spi artifacts that are sent to Maven
 java_library(
-    name = "shared-with-spi",
-    srcs = ["DaggerStreams.java"],
+    name = "jdk-and-guava-extras",
+    srcs = [
+        "DaggerGraphs.java",
+        "DaggerStreams.java",
+        "Optionals.java",
+    ],
     plugins = CODEGEN_PLUGINS,
     tags = ["maven:merged"],
     deps = [
@@ -79,7 +84,7 @@ java_library(
         "CompilerOptions.java",
         "ContributionType.java",
         "DaggerElements.java",
-        "DaggerGraphs.java",
+        "DaggerStatistics.java",
         "DaggerTypes.java",
         "DiagnosticFormatting.java",
         "Expression.java",
@@ -94,7 +99,6 @@ java_library(
         "MoreAnnotationValues.java",
         "MultibindingAnnotations.java",
         "OptionalType.java",
-        "Optionals.java",
         "RequestKinds.java",
         "Scopes.java",
         "SetType.java",
@@ -102,6 +106,7 @@ java_library(
         "SimpleTypeAnnotationValue.java",
         "SourceFileGenerationException.java",  # Used in :writing and :processor
         "SourceFileGenerator.java",  # Needed by InjectBindingRegistry in :binding and also :writing
+        "TypeCheckingProcessingStep.java",
         "TypeNames.java",
         "TypeSpecs.java",
         "UniqueNameSet.java",
@@ -121,21 +126,29 @@ java_library(
         "AnnotationExpression.java",
         "Binding.java",
         "BindingDeclaration.java",
+        "BindingDeclarationFormatter.java",
         "BindingFactory.java",
         "BindingGraph.java",
-        "BindingNodeImpl.java",
+        "BindingGraphConverter.java",
+        "BindingGraphFactory.java",
+        "BindingNode.java",
         "BindingRequest.java",
         "BindingType.java",
-        "BindingVariableNamer.java",  # needed by FrameworkField
+        "BindingVariableNamer.java",  # needs KeyVariableNamer
         "BindsTypeChecker.java",
+        "ChildFactoryMethodEdgeImpl.java",
+        "ComponentCreatorDescriptor.java",
         "ComponentDescriptor.java",
+        "ComponentKind.java",
         "ComponentNodeImpl.java",
         "ComponentRequirement.java",
         "ComponentTreeTraverser.java",
         "ConfigurationAnnotations.java",  # Uses ModuleDescriptors
         "ContributionBinding.java",
         "DelegateDeclaration.java",
+        "DependencyEdgeImpl.java",
         "DependencyRequestFactory.java",
+        "DependencyRequestFormatter.java",
         "DependencyVariableNamer.java",  # Used by SourceFiles
         "ErrorMessages.java",  # Consider splitting this up as it pulls in too much
         "FrameworkDependency.java",
@@ -144,16 +157,20 @@ java_library(
         "FrameworkTypeMapper.java",
         "InjectBindingRegistry.java",
         "KeyFactory.java",
+        "KeyVariableNamer.java",  # needs ConfigurationAnnotations, SourceFiles
         "MapKeys.java",
         "MembersInjectionBinding.java",
         "MethodSignature.java",
+        "MethodSignatureFormatter.java",
         "ModuleDescriptor.java",
+        "ModuleKind.java",
         "MultibindingDeclaration.java",
         "OptionalBindingDeclaration.java",
         "ProductionBinding.java",
         "ProvisionBinding.java",
         "ResolvedBindings.java",
         "SourceFiles.java",  # Consider splitting this up?
+        "SubcomponentBuilderBindingEdgeImpl.java",
         "SubcomponentDeclaration.java",
     ],
     plugins = CODEGEN_PLUGINS,
@@ -166,24 +183,22 @@ java_library(
     name = "validation",
     srcs = [
         "AnyBindingMethodValidator.java",
-        "BindingDeclarationFormatter.java",
+        "BindingGraphPlugins.java",
         "BindingMethodProcessingStep.java",
         "BindingMethodValidator.java",
         "BindsInstanceProcessingStep.java",
         "BindsMethodValidator.java",
         "BindsOptionalOfMethodValidator.java",
-        "BuilderValidator.java",
-        "CanReleaseReferencesValidator.java",
+        "ComponentCreatorValidator.java",
         "ComponentDescriptorValidator.java",
         "ComponentHierarchyValidator.java",
         "ComponentValidator.java",
-        "DependencyRequestFormatter.java",
         "DependencyRequestValidator.java",
-        "ForReleasableReferencesValidator.java",
+        "DiagnosticReporterFactory.java",
         "InjectValidator.java",
         "MapKeyValidator.java",
         "MembersInjectionValidator.java",
-        "MethodSignatureFormatter.java",
+        "ModuleValidation.java",
         "ModuleValidator.java",
         "MultibindingAnnotationsProcessingStep.java",
         "MultibindsMethodValidator.java",
@@ -202,19 +217,16 @@ java_library(
 java_library(
     name = "binding_graph_validation",
     srcs = [
-        "BindingGraphValidationModule.java",
         "DependencyCycleValidator.java",
         "DependsOnProductionExecutorValidator.java",
         "DuplicateBindingsValidator.java",
         "IncompatiblyScopedBindingsValidator.java",
-        "IncorrectlyInstalledBindsMethodsValidator.java",
         "InjectBindingValidator.java",
         "MapMultibindingValidator.java",
         "MissingBindingValidator.java",
         "NullableBindingValidator.java",
         "ProvisionDependencyOnProducerBindingValidator.java",
         "SubcomponentFactoryMethodValidator.java",
-        "Validation.java",
     ],
     plugins = CODEGEN_PLUGINS,
     tags = ["maven:merged"],
@@ -233,13 +245,15 @@ java_library(
         "BindingExpression.java",
         "BindingMethodImplementation.java",
         "ComponentBindingExpressions.java",
-        "ComponentBuilder.java",
+        "ComponentCreatorImplementation.java",
+        "ComponentImplementation.java",
         "ComponentInstanceBindingExpression.java",
         "ComponentMethodBindingExpression.java",
         "ComponentProvisionBindingExpression.java",
         "ComponentRequirementBindingExpression.java",
-        "ComponentRequirementField.java",
-        "ComponentRequirementFields.java",
+        "ComponentRequirementExpression.java",
+        "ComponentRequirementExpressions.java",
+        "DeferredModifiableBindingExpression.java",
         "DelegateBindingExpression.java",
         "DelegatingFrameworkInstanceCreationExpression.java",
         "DependencyMethodProducerCreationExpression.java",
@@ -250,9 +264,8 @@ java_library(
         "FrameworkFieldInitializer.java",
         "FrameworkInstanceBindingExpression.java",
         "FrameworkInstanceSupplier.java",
-        "GeneratedComponentModel.java",
-        "GeneratedInstanceBindingExpression.java",
         "GwtCompatibility.java",
+        "HjarSourceFileGenerator.java",
         "ImmediateFutureBindingExpression.java",
         "InaccessibleMapKeyProxyGenerator.java",
         "InjectionMethods.java",
@@ -269,25 +282,25 @@ java_library(
         "MethodBindingExpression.java",
         "MissingBindingExpression.java",
         "ModifiableAbstractMethodBindingExpression.java",
+        "ModifiableBindingExpressions.java",
         "ModifiableBindingMethods.java",
         "ModifiableBindingType.java",
         "ModifiableConcreteMethodBindingExpression.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
         "MultibindingExpression.java",
+        "MultibindingFactoryCreationExpression.java",
         "OptionalBindingExpression.java",
         "OptionalFactories.java",
         "OptionalFactoryInstanceCreationExpression.java",
         "PrivateMethodBindingExpression.java",
         "ProducerCreationExpression.java",
+        "ProducerEntryPointView.java",
         "ProducerFactoryGenerator.java",
         "ProducerFromProviderCreationExpression.java",
-        "ProducerInstanceBindingExpression.java",
-        "ProductionExecutorModuleGenerator.java",
+        "ProducerNodeInstanceBindingExpression.java",
         "ProviderInstanceBindingExpression.java",
-        "ReferenceReleasingManagerFields.java",
-        "ReleasableReferenceManagerProviderCreationExpression.java",
-        "ReleasableReferenceManagerSetProviderCreationExpression.java",
+        "PrunedConcreteMethodBindingExpression.java",
         "SetBindingExpression.java",
         "SetFactoryCreationExpression.java",
         "SimpleInvocationBindingExpression.java",
@@ -317,25 +330,24 @@ simple_jar(
 java_library(
     name = "processor",
     srcs = [
-        "BindingGraphConverter.java",
-        "BindingGraphFactory.java",
-        "BindingGraphPlugins.java",
-        "BindingGraphPluginsModule.java",
+        "BindingGraphValidationModule.java",
         "BindingMethodValidatorsModule.java",
-        "CanReleaseReferencesProcessingStep.java",
         "ComponentGenerator.java",
         "ComponentHjarProcessingStep.java",
-        "ComponentModelBuilder.java",
+        "ComponentImplementationFactory.java",
         "ComponentProcessingStep.java",
         "ComponentProcessor.java",
-        "DiagnosticReporterFactory.java",
         "InjectBindingRegistryImpl.java",
+        "InjectBindingRegistryModule.java",
         "InjectProcessingStep.java",
         "MapKeyProcessingStep.java",
         "ModuleProcessingStep.java",
         "ProcessingEnvironmentModule.java",
         "ProcessingOptions.java",
-        "ProductionExecutorModuleProcessingStep.java",
+        "SourceFileGeneratorsModule.java",
+        "SpiModule.java",
+        "SystemComponentsModule.java",
+        "Validation.java",
     ],
     plugins = CODEGEN_PLUGINS,
     resource_jars = [":processor_manifest_files.jar"],
@@ -370,10 +382,8 @@ java_library(
     deps = [
         ":base",
         ":binding",
-        ":binding_graph_validation",
         ":kythe_plugin",
         ":processor",
-        ":validation",
         "//java/dagger:core",
         "//java/dagger/model",
         "//java/dagger/producers",
diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/Binding.java
index f3fd84a4a..386e29a78 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/Binding.java
@@ -20,6 +20,8 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static java.util.stream.Collectors.toSet;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Supplier;
@@ -30,6 +32,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
+import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.Scope;
@@ -39,6 +42,7 @@
 import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.DeclaredType;
@@ -47,12 +51,34 @@
 import javax.lang.model.util.Types;
 
 /**
- * An abstract type for classes representing a Dagger binding.  Particularly, contains the
- * {@link Element} that generated the binding and the {@link DependencyRequest} instances that are
- * required to satisfy the binding, but leaves the specifics of the <i>mechanism</i> of the binding
- * to the subtypes.
+ * An abstract type for classes representing a Dagger binding. Particularly, contains the {@link
+ * Element} that generated the binding and the {@link DependencyRequest} instances that are required
+ * to satisfy the binding, but leaves the specifics of the <i>mechanism</i> of the binding to the
+ * subtypes.
  */
-abstract class Binding extends BindingDeclaration implements dagger.model.Binding {
+abstract class Binding extends BindingDeclaration {
+
+  /**
+   * Returns {@code true} if using this binding requires an instance of the {@link
+   * #contributingModule()}.
+   */
+  boolean requiresModuleInstance() {
+    if (!bindingElement().isPresent() || !contributingModule().isPresent()) {
+      return false;
+    }
+    Set<Modifier> modifiers = bindingElement().get().getModifiers();
+    return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
+  }
+
+  /**
+   * Returns {@code true} if this binding may provide {@code null} instead of an instance of {@link
+   * #key()}. Nullable bindings cannot be requested from {@linkplain DependencyRequest#isNullable()
+   * non-nullable dependency requests}.
+   */
+  abstract boolean isNullable();
+
+  /** The kind of binding this instance represents. */
+  abstract BindingKind kind();
 
   /** The {@link BindingType} of this binding. */
   abstract BindingType bindingType();
@@ -87,8 +113,7 @@
    * union of {@link #explicitDependencies()} and {@link #implicitDependencies()}. This returns an
    * unmodifiable set.
    */
-  @Override
-  public ImmutableSet<DependencyRequest> dependencies() {
+  ImmutableSet<DependencyRequest> dependencies() {
     return dependencies.get();
   }
 
@@ -236,8 +261,7 @@ static DependencyAssociation create(
    */
   abstract Optional<? extends Binding> unresolved();
 
-  @Override
-  public Optional<Scope> scope() {
+  Optional<Scope> scope() {
     return Optional.empty();
   }
 
diff --git a/java/dagger/internal/codegen/BindingDeclaration.java b/java/dagger/internal/codegen/BindingDeclaration.java
index ef19c6090..d7aa1fb13 100644
--- a/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/java/dagger/internal/codegen/BindingDeclaration.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import dagger.model.BindingKind;
 import dagger.model.Key;
 import java.util.Optional;
 import javax.lang.model.element.Element;
@@ -28,10 +29,20 @@
   abstract Key key();
 
   /**
-   * The {@link Element} that declares the binding. Absent for bindings without identifying
-   * declarations.
+   * The {@link Element} that declares this binding. Absent for {@linkplain BindingKind binding
+   * kinds} that are not always declared by exactly one element.
+   *
+   * <p>For example, consider {@link BindingKind#MULTIBOUND_SET}. A component with many
+   * {@code @IntoSet} bindings for the same key will have a synthetic binding that depends on all
+   * contributions, but with no identifiying binding element. A {@code @Multibinds} method will also
+   * contribute a synthetic binding, but since multiple {@code @Multibinds} methods can coexist in
+   * the same component (and contribute to one single binding), it has no binding element.
    */
-  abstract Optional<? extends Element> bindingElement();
+  // TODO(ronshapiro): examine whether this wildcard+bound have any benefit.
+  // We never actually refer to the overridden bindingElement methods directly in a way which needs
+  // anything more than an Element. Removing the wildcard would allow for simpler user-written code
+  // when the binding element is passed to a method.
+  abstract Optional<Element> bindingElement();
 
   /**
    * The type enclosing the {@link #bindingElement()}, or {@link Optional#empty()} if {@link
diff --git a/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index 13a960c4e..72ece3ca1 100644
--- a/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -20,8 +20,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
-import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGER;
-import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGERS;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.EXECUTABLE;
 
@@ -30,7 +28,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import dagger.model.BindingKind;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeKind;
@@ -43,11 +40,6 @@
   private static final ImmutableSet<TypeKind> FORMATTABLE_ELEMENT_TYPE_KINDS =
       immutableEnumSet(EXECUTABLE, DECLARED);
 
-  private static final ImmutableSet<BindingKind>
-      FORMATTABLE_ELEMENTLESS_BINDING_KINDS =
-          immutableEnumSet(
-              RELEASABLE_REFERENCE_MANAGER, RELEASABLE_REFERENCE_MANAGERS);
-
   private final MethodSignatureFormatter methodSignatureFormatter;
 
   @Inject
@@ -56,14 +48,9 @@
   }
 
   /**
-   * Returns {@code true} for declarations that this formatter can format. Specifically:
-   *
-   * <ul>
-   * <li>Those with {@linkplain BindingDeclaration#bindingElement() binding elements} that are
-   *     methods, constructors, or types.
-   * <li>{@link BindingKind#RELEASABLE_REFERENCE_MANAGER} bindings.
-   * <li>{@link BindingKind#RELEASABLE_REFERENCE_MANAGERS} bindings.
-   * </ul>
+   * Returns {@code true} for declarations that this formatter can format. Specifically bindings
+   * from subcomponent declarations or those with {@linkplain BindingDeclaration#bindingElement()
+   * binding elements} that are methods, constructors, or types.
    */
   boolean canFormat(BindingDeclaration bindingDeclaration) {
     if (bindingDeclaration instanceof SubcomponentDeclaration) {
@@ -73,10 +60,6 @@ boolean canFormat(BindingDeclaration bindingDeclaration) {
       return FORMATTABLE_ELEMENT_TYPE_KINDS.contains(
           bindingDeclaration.bindingElement().get().asType().getKind());
     }
-    if (bindingDeclaration instanceof ContributionBinding) {
-      ContributionBinding contributionBinding = (ContributionBinding) bindingDeclaration;
-      return FORMATTABLE_ELEMENTLESS_BINDING_KINDS.contains(contributionBinding.kind());
-    }
     return false;
   }
 
@@ -105,12 +88,6 @@ public String format(BindingDeclaration bindingDeclaration) {
       }
     }
 
-    if (isReleasableReferenceManagerBinding(bindingDeclaration)) {
-      return String.format(
-          "binding for %s from the scope declaration",
-          stripCommonTypePrefixes(bindingDeclaration.key().toString()));
-    }
-
     return String.format(
         "Dagger-generated binding for %s",
         stripCommonTypePrefixes(bindingDeclaration.key().toString()));
@@ -143,9 +120,4 @@ private String formatSubcomponentDeclaration(SubcomponentDeclaration subcomponen
         annotationValue,
         subcomponentDeclaration.contributingModule().get());
   }
-
-  private boolean isReleasableReferenceManagerBinding(BindingDeclaration bindingDeclaration) {
-    return bindingDeclaration instanceof ContributionBinding
-        && ((ContributionBinding) bindingDeclaration).kind().equals(RELEASABLE_REFERENCE_MANAGER);
-  }
 }
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 1f190f6dc..9ac6edc7f 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -16,10 +16,13 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import javax.lang.model.type.TypeMirror;
 
 /** A factory of code expressions used to access a single request for a binding in a component. */
 // TODO(user): Rename this to RequestExpression?
@@ -33,6 +36,16 @@
    */
   abstract Expression getDependencyExpression(ClassName requestingClass);
 
+  /**
+   * Equivalent to {@link #getDependencyExpression} that is used only when the request is for an
+   * implementation of a component method. By default, just delegates to {@link
+   * #getDependencyExpression}.
+   */
+  Expression getDependencyExpressionForComponentMethod(
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
+    return getDependencyExpression(component.name());
+  }
+
   /** Returns {@code true} if this binding expression should be encapsulated in a method. */
   boolean requiresMethodEncapsulation() {
     return false;
@@ -44,17 +57,53 @@ boolean requiresMethodEncapsulation() {
    * @param component the component that will contain the implemented method
    */
   CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
     // By default, just delegate to #getDependencyExpression().
-    return CodeBlock.of("return $L;", getDependencyExpression(component.name()).codeBlock());
+    return CodeBlock.of(
+        "return $L;",
+        getDependencyExpressionForComponentMethod(componentMethod, component).codeBlock());
   }
 
   /**
    * Returns an expression for the implementation of a modifiable binding method for the given
-   * component model.
+   * component.
    */
   CodeBlock getModifiableBindingMethodImplementation(
-      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
-    return CodeBlock.of("return $L;", getDependencyExpression(component.name()).codeBlock());
+      ModifiableBindingMethod modifiableBindingMethod,
+      ComponentImplementation component,
+      DaggerTypes types) {
+    Expression dependencyExpression = getDependencyExpression(component.name());
+
+    // It's possible to have a case where a modifiable component method delegates to another
+    // binding method from an enclosing class that is not itself a component method. In that case,
+    // the enclosing class's method may return a publicly accessible type, but the nested class will
+    // have a return type that is defined by the component method. In that case, a downcast is
+    // necessary so that the return statement is valid.
+    //
+    // E.g.:
+    //
+    // public class DaggerAncestor implements Ancestor {
+    //   protected Object packagePrivateModifiable() { ... }
+    //
+    //   protected class LeafImpl extends DaggerLeaf {
+    //     @Override
+    //     public final PackagePrivateModifiable componentMethod() {
+    //       return (PackagePrivateModifiable) DaggerAncestor.this.packagePrivateModifiable();
+    //     }
+    //   }
+    // }
+    //
+    // DaggerAncestor.packagePrivateModifiable returns Object even though the actual instance's type
+    // is PackagePrivateModifiable. So a cast is necessary.
+    //
+    // This isn't necessary for getComponentMethodImplementation() because that's only used for
+    // non-modifiable bindings
+    TypeMirror returnType = modifiableBindingMethod.returnType();
+    if (!types.isAssignable(dependencyExpression.type(), returnType)
+       && isTypeAccessibleFrom(returnType, component.name().packageName())) {
+      dependencyExpression = dependencyExpression.castTo(returnType);
+    }
+
+    return CodeBlock.of("return $L;", dependencyExpression.codeBlock());
   }
 }
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 9406467c2..65bcfb9dc 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -23,7 +23,6 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Binding.hasNonDefaultTypeParameters;
-import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
 import static dagger.internal.codegen.ContributionBinding.bindingKindForMultibindingKey;
@@ -44,8 +43,6 @@
 import static dagger.model.BindingKind.OPTIONAL;
 import static dagger.model.BindingKind.PRODUCTION;
 import static dagger.model.BindingKind.PROVISION;
-import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGER;
-import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGERS;
 import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -60,13 +57,11 @@
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.SetMultimap;
 import dagger.Module;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import dagger.internal.codegen.ProductionBinding.ProductionKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
-import dagger.model.Scope;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.ArrayList;
@@ -303,7 +298,7 @@ ContributionBinding componentDependencyMethodBinding(
     checkArgument(dependencyMethod.getKind().equals(METHOD));
     checkArgument(dependencyMethod.getParameters().isEmpty());
     ContributionBinding.Builder<?, ?> builder;
-    if (componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
+    if (componentDescriptor.kind().isProducer()
         && isComponentProductionMethod(elements, dependencyMethod)) {
       builder =
           ProductionBinding.builder()
@@ -328,14 +323,15 @@ ContributionBinding componentDependencyMethodBinding(
    * Returns a {@link dagger.model.BindingKind#BOUND_INSTANCE} binding for a
    * {@code @BindsInstance}-annotated builder method.
    */
-  ProvisionBinding boundInstanceBinding(BuilderRequirementMethod bindsInstanceMethod) {
-    checkArgument(bindsInstanceMethod.method().getKind().equals(METHOD));
-    checkArgument(bindsInstanceMethod.method().getParameters().size() == 1);
+  ProvisionBinding boundInstanceBinding(
+      ComponentRequirement requirement, ExecutableElement method) {
+    checkArgument(method.getKind().equals(METHOD));
+    checkArgument(method.getParameters().size() == 1);
     return ProvisionBinding.builder()
         .contributionType(ContributionType.UNIQUE)
-        .bindingElement(bindsInstanceMethod.method())
-        .key(bindsInstanceMethod.requirement().key().get())
-        .nullableType(getNullableType(getOnlyElement(bindsInstanceMethod.method().getParameters())))
+        .bindingElement(method)
+        .key(requirement.key().get())
+        .nullableType(getNullableType(getOnlyElement(method.getParameters())))
         .kind(BOUND_INSTANCE)
         .build();
   }
@@ -343,21 +339,21 @@ ProvisionBinding boundInstanceBinding(BuilderRequirementMethod bindsInstanceMeth
   /**
    * Returns a {@link dagger.model.BindingKind#SUBCOMPONENT_BUILDER} binding declared by a component
    * method that returns a subcomponent builder. Use {{@link
-   * #subcomponentBuilderBinding(ImmutableSet)}} for bindings declared using {@link
+   * #subcomponentCreatorBinding(ImmutableSet)}} for bindings declared using {@link
    * Module#subcomponents()}.
    *
    * @param component the component that declares or inherits the method
    */
-  ProvisionBinding subcomponentBuilderBinding(
-      ExecutableElement subcomponentBuilderMethod, TypeElement component) {
-    checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
-    checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
+  ProvisionBinding subcomponentCreatorBinding(
+      ExecutableElement subcomponentCreatorMethod, TypeElement component) {
+    checkArgument(subcomponentCreatorMethod.getKind().equals(METHOD));
+    checkArgument(subcomponentCreatorMethod.getParameters().isEmpty());
     Key key =
-        keyFactory.forSubcomponentBuilderMethod(
-            subcomponentBuilderMethod, asDeclared(component.asType()));
+        keyFactory.forSubcomponentCreatorMethod(
+            subcomponentCreatorMethod, asDeclared(component.asType()));
     return ProvisionBinding.builder()
         .contributionType(ContributionType.UNIQUE)
-        .bindingElement(subcomponentBuilderMethod)
+        .bindingElement(subcomponentCreatorMethod)
         .key(key)
         .kind(SUBCOMPONENT_BUILDER)
         .build();
@@ -367,7 +363,7 @@ ProvisionBinding subcomponentBuilderBinding(
    * Returns a {@link dagger.model.BindingKind#SUBCOMPONENT_BUILDER} binding declared using {@link
    * Module#subcomponents()}.
    */
-  ProvisionBinding subcomponentBuilderBinding(
+  ProvisionBinding subcomponentCreatorBinding(
       ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
     SubcomponentDeclaration subcomponentDeclaration = subcomponentDeclarations.iterator().next();
     return ProvisionBinding.builder()
@@ -431,52 +427,6 @@ private ContributionBinding buildDelegateBinding(
         .build();
   }
 
-  /**
-   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGER} binding for a {@code
-   * ReleasableReferenceManager}.
-   */
-  ProvisionBinding releasableReferenceManagerBinding(Scope scope) {
-    return ProvisionBinding.builder()
-        .contributionType(ContributionType.UNIQUE)
-        .key(keyFactory.forReleasableReferenceManager(scope))
-        .kind(RELEASABLE_REFERENCE_MANAGER)
-        .build();
-  }
-
-  /**
-   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGER} binding for a {@code
-   * TypedReleasableReferenceManager<M>}.
-   */
-  ProvisionBinding typedReleasableReferenceManagerBinding(Scope scope, DeclaredType metadataType) {
-    return releasableReferenceManagerBinding(scope)
-        .toBuilder()
-        .key(keyFactory.forTypedReleasableReferenceManager(scope, metadataType))
-        .build();
-  }
-
-  /**
-   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGERS} binding for a set of
-   * {@code ReleasableReferenceManager}s.
-   */
-  ProvisionBinding setOfReleasableReferenceManagersBinding() {
-    return ProvisionBinding.builder()
-        .contributionType(ContributionType.UNIQUE)
-        .key(keyFactory.forSetOfReleasableReferenceManagers())
-        .kind(RELEASABLE_REFERENCE_MANAGERS)
-        .build();
-  }
-
-  /**
-   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGERS} binding for a set of
-   * {@code TypedReleasableReferenceManager<M>}s.
-   */
-  ProvisionBinding setOfTypedReleasableReferenceManagersBinding(DeclaredType metadataType) {
-    return setOfReleasableReferenceManagersBinding()
-        .toBuilder()
-        .key(keyFactory.forSetOfTypedReleasableReferenceManagers(metadataType))
-        .build();
-  }
-
   /**
    * Returns an {@link dagger.model.BindingKind#OPTIONAL} binding for {@code key}.
    *
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 9ec4d2aea..174979596 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -17,24 +17,23 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.DaggerStreams.presentValues;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
 import com.google.common.graph.Traverser;
 import dagger.Subcomponent;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
-import dagger.model.Scope;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
+import java.util.Collection;
+import java.util.Map;
 import java.util.Optional;
 import java.util.stream.StreamSupport;
 import javax.lang.model.element.ExecutableElement;
@@ -82,53 +81,24 @@ final ResolvedBindings resolvedBindings(BindingRequest request) {
         .build();
   }
 
-  abstract ImmutableSet<BindingGraph> subgraphs();
+  abstract ImmutableList<BindingGraph> subgraphs();
 
-  /**
-   * The scopes in the graph that {@linkplain CanReleaseReferences can release their references} for
-   * which there is a dependency request for any of the following:
-   *
-   * <ul>
-   *   <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
-   *   <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
-   *       {@code M} is the releasable-references metadata type for {@code scope}
-   *   <li>{@code Set<ReleasableReferenceManager>}
-   *   <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
-   *       the scope
-   * </ul>
-   *
-   * <p>This set is always empty for subcomponent graphs.
-   */
-  abstract ImmutableSet<Scope> scopesRequiringReleasableReferenceManagers();
-
-  /** Returns the resolved bindings for the dependencies of {@code binding}. */
-  ImmutableSet<ResolvedBindings> resolvedDependencies(ContributionBinding binding) {
-    return binding
-        .dependencies()
-        .stream()
-        .map(DependencyRequest::key)
-        .map(
-            key ->
-                contributionBindings()
-                    .getOrDefault(key, ResolvedBindings.noBindings(key, componentDescriptor())))
-        .collect(toImmutableSet());
-  }
   /**
    * The type that defines the component for this graph.
    *
-   * @see ComponentDescriptor#componentDefinitionType()
+   * @see ComponentDescriptor#typeElement()
    */
-  TypeElement componentType() {
-    return componentDescriptor().componentDefinitionType();
+  TypeElement componentTypeElement() {
+    return componentDescriptor().typeElement();
   }
 
   /**
    * Returns the set of modules that are owned by this graph regardless of whether or not any of
    * their bindings are used in this graph. For graphs representing top-level {@link
-   * dagger.Component components}, this set will be the same as
-   * {@linkplain ComponentDescriptor#transitiveModules the component's transitive modules}. For
-   * {@linkplain Subcomponent subcomponents}, this set will be the transitive modules that are not
-   * owned by any of their ancestors.
+   * dagger.Component components}, this set will be the same as {@linkplain
+   * ComponentDescriptor#modules() the component's transitive modules}. For {@linkplain Subcomponent
+   * subcomponents}, this set will be the transitive modules that are not owned by any of their
+   * ancestors.
    */
   abstract ImmutableSet<ModuleDescriptor> ownedModules();
 
@@ -184,10 +154,47 @@ TypeElement componentType() {
    */
   @Memoized
   ImmutableSet<ComponentRequirement> componentRequirements() {
+    return componentRequirements(
+        StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
+            .flatMap(graph -> graph.contributionBindings().values().stream())
+            .flatMap(bindings -> bindings.contributionBindings().stream())
+        .collect(toImmutableSet()));
+  }
+
+  /**
+   * The types for which the component may need instances, depending on how it is resolved in a
+   * parent component.
+   *
+   * <ul>
+   *   <li>{@linkplain #ownedModules() Owned modules} with concrete instance bindings. If the module
+   *       is never used in the fully resolved binding graph, the instance will not be required
+   *       unless a component builder requests it.
+   *   <li>Bound instances (always required)
+   * </ul>
+   */
+  @Memoized
+  ImmutableSet<ComponentRequirement> possiblyNecessaryRequirements() {
+    checkState(!componentDescriptor().kind().isTopLevel());
+    return componentRequirements(
+        StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
+            .flatMap(graph -> graph.ownedModules().stream())
+            .flatMap(module -> module.bindings().stream())
+            .collect(toImmutableSet()));
+  }
+
+  /**
+   * The types for which the component needs instances.
+   *
+   * <ul>
+   *   <li>component dependencies
+   *   <li>The modules of {@code bindings} that require a module instance
+   *   <li>bound instances
+   * </ul>
+   */
+  private ImmutableSet<ComponentRequirement> componentRequirements(
+      ImmutableSet<ContributionBinding> bindings) {
     ImmutableSet.Builder<ComponentRequirement> requirements = ImmutableSet.builder();
-    StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
-        .flatMap(graph -> graph.contributionBindings().values().stream())
-        .flatMap(bindings -> bindings.contributionBindings().stream())
+    bindings.stream()
         .filter(ContributionBinding::requiresModuleInstance)
         .map(ContributionBinding::contributingModule)
         .flatMap(presentValues())
@@ -198,16 +205,11 @@ TypeElement componentType() {
       factoryMethodParameters().keySet().forEach(requirements::add);
     }
     requirements.addAll(componentDescriptor().dependencies());
-    if (componentDescriptor().builderSpec().isPresent()) {
-      componentDescriptor()
-          .builderSpec()
-          .get()
-          .requirementMethods()
-          .stream()
-          .map(BuilderRequirementMethod::requirement)
-          .filter(req -> req.kind().equals(BOUND_INSTANCE))
-          .forEach(requirements::add);
-    }
+    componentDescriptor()
+        .creatorDescriptor()
+        .ifPresent(
+            creatorDescriptor ->
+                creatorDescriptor.boundInstanceRequirements().forEach(requirements::add));
     return requirements.build();
   }
 
@@ -229,17 +231,26 @@ static BindingGraph create(
       ComponentDescriptor componentDescriptor,
       ImmutableMap<Key, ResolvedBindings> resolvedContributionBindingsMap,
       ImmutableMap<Key, ResolvedBindings> resolvedMembersInjectionBindings,
-      ImmutableSet<BindingGraph> subgraphs,
-      ImmutableSet<Scope> scopesRequiringReleasableReferenceManagers,
+      ImmutableList<BindingGraph> subgraphs,
       ImmutableSet<ModuleDescriptor> ownedModules,
       Optional<ExecutableElement> factoryMethod) {
+    checkForDuplicates(subgraphs);
     return new AutoValue_BindingGraph(
         componentDescriptor,
         resolvedContributionBindingsMap,
         resolvedMembersInjectionBindings,
         subgraphs,
-        scopesRequiringReleasableReferenceManagers,
         ownedModules,
         factoryMethod);
   }
+
+  private static final void checkForDuplicates(Iterable<BindingGraph> graphs) {
+    Map<TypeElement, Collection<BindingGraph>> duplicateGraphs =
+        Maps.filterValues(
+            Multimaps.index(graphs, graph -> graph.componentDescriptor().typeElement()).asMap(),
+            overlapping -> overlapping.size() > 1);
+    if (!duplicateGraphs.isEmpty()) {
+      throw new IllegalArgumentException("Expected no duplicates: " + duplicateGraphs);
+    }
+  }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index b1e942bec..aec497e82 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -17,13 +17,11 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreTypes.asTypeElement;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.DaggerGraphs.unreachableNodes;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.presentValues;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.model.BindingGraphProxies.childFactoryMethodEdge;
-import static dagger.model.BindingGraphProxies.dependencyEdge;
-import static dagger.model.BindingGraphProxies.subcomponentBuilderBindingEdge;
 import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 
 import com.google.common.collect.ImmutableSet;
@@ -31,12 +29,10 @@
 import com.google.common.graph.MutableNetwork;
 import com.google.common.graph.Network;
 import com.google.common.graph.NetworkBuilder;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.MissingBindingNode;
+import dagger.model.BindingGraph.MissingBinding;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingGraphProxies;
 import dagger.model.DependencyRequest;
@@ -74,7 +70,11 @@
     unreachableNodes(traverser.network.asGraph(), rootComponentNode(traverser.network))
         .forEach(traverser.network::removeNode);
 
-    return BindingGraphProxies.bindingGraph(traverser.network);
+    ComponentKind rootComponentKind = rootGraph.componentDescriptor().kind();
+    return BindingGraphProxies.bindingGraph(
+        traverser.network,
+        rootComponentKind.isForModuleValidation(),
+        !rootComponentKind.isTopLevel());
   }
 
   // TODO(dpb): Example of BindingGraph logic applied to derived networks.
@@ -107,19 +107,16 @@ protected void visitComponent(BindingGraph graph) {
 
       network.addNode(currentComponent);
 
-      for (ComponentMethodDescriptor method : graph.componentDescriptor().entryPointMethods()) {
-        addDependencyEdges(currentComponent, method.dependencyRequest().get());
-      }
-
       for (ResolvedBindings resolvedBindings : graph.resolvedBindings()) {
-        for (BindingNode node : bindingNodes(resolvedBindings)) {
-          addBindingNode(node);
-          if (node.binding().kind().equals(SUBCOMPONENT_BUILDER)
-              && node.componentPath().equals(currentComponent.componentPath())) {
+        ImmutableSet<TypeElement> declaringModules = subcomponentDeclaringModules(resolvedBindings);
+        for (BindingNode binding : bindingNodes(resolvedBindings)) {
+          addBinding(binding);
+          if (binding.kind().equals(SUBCOMPONENT_BUILDER)
+              && binding.componentPath().equals(currentComponent.componentPath())) {
             network.addEdge(
-                node,
-                subcomponentNode(node.key().type(), graph),
-                subcomponentBuilderBindingEdge(subcomponentDeclaringModules(resolvedBindings)));
+                binding,
+                subcomponentNode(binding.key().type(), graph),
+                new SubcomponentBuilderBindingEdgeImpl(declaringModules));
           }
         }
       }
@@ -130,10 +127,17 @@ protected void visitComponent(BindingGraph graph) {
       parentComponent = grandparentComponent;
     }
 
+    @Override
+    protected void visitEntryPoint(DependencyRequest entryPoint, BindingGraph graph) {
+      addDependencyEdges(currentComponent, entryPoint);
+      super.visitEntryPoint(entryPoint, graph);
+    }
+
     @Override
     protected void visitSubcomponentFactoryMethod(
         BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {
-      network.addEdge(parentComponent, currentComponent, childFactoryMethodEdge(factoryMethod));
+      network.addEdge(
+          parentComponent, currentComponent, new ChildFactoryMethodEdgeImpl(factoryMethod));
       super.visitSubcomponentFactoryMethod(graph, parent, factoryMethod);
     }
 
@@ -157,7 +161,9 @@ private void addDependencyEdge(
       network.addNode(dependency);
       if (!hasDependencyEdge(source, dependency, dependencyRequest)) {
         network.addEdge(
-            source, dependency, dependencyEdge(dependencyRequest, source instanceof ComponentNode));
+            source,
+            dependency,
+            new DependencyEdgeImpl(dependencyRequest, source instanceof ComponentNode));
       }
     }
 
@@ -175,14 +181,14 @@ private ResolvedBindings resolvedDependencies(
       return componentTreePath()
           .pathFromRootToAncestor(source.componentPath().currentComponent())
           .currentGraph()
-          .resolvedBindings(BindingRequest.forDependencyRequest(dependencyRequest));
+          .resolvedBindings(bindingRequest(dependencyRequest));
     }
 
-    /** Adds a binding node and edges for all its dependencies. */
-    private void addBindingNode(BindingNode node) {
-      network.addNode(node);
-      for (DependencyRequest dependencyRequest : node.binding().dependencies()) {
-        addDependencyEdges(node, dependencyRequest);
+    /** Adds a binding and all its dependencies. */
+    private void addBinding(BindingNode binding) {
+      network.addNode(binding);
+      for (DependencyRequest dependencyRequest : binding.dependencies()) {
+        addDependencyEdges(binding, dependencyRequest);
       }
     }
 
@@ -202,9 +208,9 @@ private void addBindingNode(BindingNode node) {
 
     private BindingNode bindingNode(
         ResolvedBindings resolvedBindings, Binding binding, ComponentDescriptor owningComponent) {
-      return BindingNodeImpl.create(
+      return BindingNode.create(
           componentTreePath()
-              .pathFromRootToAncestor(owningComponent.componentDefinitionType())
+              .pathFromRootToAncestor(owningComponent.typeElement())
               .toComponentPath(),
           binding,
           associatedDeclaringElements(resolvedBindings),
@@ -219,10 +225,10 @@ private BindingNode bindingNode(
           resolvedBindings.subcomponentDeclarations());
     }
 
-    private MissingBindingNode missingBindingNode(ResolvedBindings dependencies) {
+    private MissingBinding missingBindingNode(ResolvedBindings dependencies) {
       return BindingGraphProxies.missingBindingNode(
           componentTreePath()
-              .pathFromRootToAncestor(dependencies.owningComponent().componentDefinitionType())
+              .pathFromRootToAncestor(dependencies.owningComponent().typeElement())
               .toComponentPath(),
           dependencies.key());
     }
@@ -230,9 +236,9 @@ private MissingBindingNode missingBindingNode(ResolvedBindings dependencies) {
     private ComponentNode subcomponentNode(TypeMirror subcomponentBuilderType, BindingGraph graph) {
       TypeElement subcomponentBuilderElement = asTypeElement(subcomponentBuilderType);
       ComponentDescriptor subcomponent =
-          graph.componentDescriptor().subcomponentsByBuilderType().get(subcomponentBuilderElement);
+          graph.componentDescriptor().getChildComponentWithBuilderType(subcomponentBuilderElement);
       return ComponentNodeImpl.create(
-          componentTreePath().childPath(subcomponent.componentDefinitionType()).toComponentPath(),
+          componentTreePath().childPath(subcomponent.typeElement()).toComponentPath(),
           subcomponent);
     }
 
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 318f334bc..748fd1bbb 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -23,11 +23,12 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.isEmpty;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
-import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
+import static dagger.internal.codegen.SourceFiles.generatedMonitoringModuleName;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static dagger.model.BindingKind.DELEGATE;
+import static dagger.model.BindingKind.INJECTION;
 import static dagger.model.BindingKind.OPTIONAL;
 import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 import static java.util.function.Predicate.isEqual;
@@ -39,23 +40,18 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.MembersInjector;
 import dagger.Reusable;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind;
-import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
+import dagger.model.RequestKind;
 import dagger.model.Scope;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.producers.internal.ProductionExecutorModule;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
@@ -71,7 +67,6 @@
 import java.util.function.Function;
 import javax.inject.Inject;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
@@ -81,8 +76,8 @@
   private final InjectBindingRegistry injectBindingRegistry;
   private final KeyFactory keyFactory;
   private final BindingFactory bindingFactory;
-  private final IncorrectlyInstalledBindsMethodsValidator incorrectlyInstalledBindsMethodsValidator;
   private final CompilerOptions compilerOptions;
+  private final ModuleDescriptor.Factory moduleDescriptorFactory;
 
   @Inject
   BindingGraphFactory(
@@ -90,13 +85,13 @@
       InjectBindingRegistry injectBindingRegistry,
       KeyFactory keyFactory,
       BindingFactory bindingFactory,
-      IncorrectlyInstalledBindsMethodsValidator incorrectlyInstalledBindsMethodsValidator,
+      ModuleDescriptor.Factory moduleDescriptorFactory,
       CompilerOptions compilerOptions) {
     this.elements = elements;
     this.injectBindingRegistry = injectBindingRegistry;
     this.keyFactory = keyFactory;
     this.bindingFactory = bindingFactory;
-    this.incorrectlyInstalledBindsMethodsValidator = incorrectlyInstalledBindsMethodsValidator;
+    this.moduleDescriptorFactory = moduleDescriptorFactory;
     this.compilerOptions = compilerOptions;
   }
 
@@ -113,9 +108,11 @@ private BindingGraph create(
     ImmutableSet.Builder<DelegateDeclaration> delegatesBuilder = ImmutableSet.builder();
     ImmutableSet.Builder<OptionalBindingDeclaration> optionalsBuilder = ImmutableSet.builder();
 
-    // binding for the component itself
-    explicitBindingsBuilder.add(
-        bindingFactory.componentBinding(componentDescriptor.componentDefinitionType()));
+    if (!componentDescriptor.kind().isForModuleValidation()) {
+      // binding for the component itself
+      explicitBindingsBuilder.add(
+          bindingFactory.componentBinding(componentDescriptor.typeElement()));
+    }
 
     // Collect Component dependencies.
     for (ComponentRequirement dependency : componentDescriptor.dependencies()) {
@@ -131,32 +128,36 @@ private BindingGraph create(
       }
     }
 
-    // Collect bindings on the builder.
-    if (componentDescriptor.builderSpec().isPresent()) {
-      for (BuilderRequirementMethod method :
-          componentDescriptor.builderSpec().get().requirementMethods()) {
-        if (method.requirement().kind().equals(BOUND_INSTANCE)) {
-          explicitBindingsBuilder.add(bindingFactory.boundInstanceBinding(method));
-        }
-      }
-    }
-
-    for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> componentMethodAndSubcomponent :
-        componentDescriptor.subcomponentsByBuilderMethod().entrySet()) {
-      ComponentMethodDescriptor componentMethod = componentMethodAndSubcomponent.getKey();
-      ComponentDescriptor subcomponentDescriptor = componentMethodAndSubcomponent.getValue();
-      if (!componentDescriptor.subcomponentsFromModules().contains(subcomponentDescriptor)) {
-        explicitBindingsBuilder.add(
-            bindingFactory.subcomponentBuilderBinding(
-                componentMethod.methodElement(), componentDescriptor.componentDefinitionType()));
-      }
-    }
+    // Collect bindings on the creator.
+    componentDescriptor
+        .creatorDescriptor()
+        .ifPresent(
+            creatorDescriptor ->
+                creatorDescriptor.boundInstanceRequirements().stream()
+                    .map(
+                        requirement ->
+                            bindingFactory.boundInstanceBinding(
+                                requirement, creatorDescriptor.elementForRequirement(requirement)))
+                    .forEach(explicitBindingsBuilder::add));
+
+    componentDescriptor
+        .childComponentsDeclaredByBuilderEntryPoints()
+        .forEach(
+            (builderEntryPoint, childComponent) -> {
+              if (!componentDescriptor
+                  .childComponentsDeclaredByModules()
+                  .contains(childComponent)) {
+                explicitBindingsBuilder.add(
+                    bindingFactory.subcomponentCreatorBinding(
+                        builderEntryPoint.methodElement(), componentDescriptor.typeElement()));
+              }
+            });
 
     ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations = ImmutableSet.builder();
     ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarations = ImmutableSet.builder();
 
     // Collect transitive module bindings and multibinding declarations.
-    for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
+    for (ModuleDescriptor moduleDescriptor : modules(componentDescriptor, parentResolver)) {
       explicitBindingsBuilder.addAll(moduleDescriptor.bindings());
       multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());
       subcomponentDeclarations.addAll(moduleDescriptor.subcomponentDeclarations());
@@ -164,10 +165,6 @@ private BindingGraph create(
       optionalsBuilder.addAll(moduleDescriptor.optionalDeclarations());
     }
 
-    ImmutableSetMultimap<Scope, ProvisionBinding> releasableReferenceManagerBindings =
-        getReleasableReferenceManagerBindings(componentDescriptor);
-    explicitBindingsBuilder.addAll(releasableReferenceManagerBindings.values());
-
     final Resolver requestResolver =
         new Resolver(
             parentResolver,
@@ -177,14 +174,11 @@ private BindingGraph create(
             indexBindingDeclarationsByKey(subcomponentDeclarations.build()),
             indexBindingDeclarationsByKey(delegatesBuilder.build()),
             indexBindingDeclarationsByKey(optionalsBuilder.build()));
-    for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
-      if (componentMethod.kind().equals(ComponentMethodKind.MEMBERS_INJECTION)) {
-        requestResolver.resolveMembersInjectionMethod(componentMethod);
+    for (DependencyRequest entryPoint : componentDescriptor.entryPoints()) {
+      if (entryPoint.kind().equals(RequestKind.MEMBERS_INJECTION)) {
+        requestResolver.resolveMembersInjection(entryPoint.key());
       } else {
-        Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
-        if (componentMethodRequest.isPresent()) {
-          requestResolver.resolve(componentMethodRequest.get().key());
-        }
+        requestResolver.resolve(entryPoint.key());
       }
     }
 
@@ -194,7 +188,7 @@ private BindingGraph create(
     // done in a queue since resolving one subcomponent might resolve a key for a subcomponent
     // from a parent graph. This is done until no more new subcomponents are resolved.
     Set<ComponentDescriptor> resolvedSubcomponents = new HashSet<>();
-    ImmutableSet.Builder<BindingGraph> subgraphs = ImmutableSet.builder();
+    ImmutableList.Builder<BindingGraph> subgraphs = ImmutableList.builder();
     for (ComponentDescriptor subcomponent :
         Iterables.consumingIterable(requestResolver.subcomponentsToResolve)) {
       if (resolvedSubcomponents.add(subcomponent)) {
@@ -217,73 +211,52 @@ private BindingGraph create(
         resolvedContributionBindingsMap,
         requestResolver.getResolvedMembersInjectionBindings(),
         subgraphs.build(),
-        getScopesRequiringReleasableReferenceManagers(
-            releasableReferenceManagerBindings, resolvedContributionBindingsMap.keySet()),
         requestResolver.getOwnedModules(),
         requestResolver.getFactoryMethod());
   }
 
   /**
-   * Returns the bindings for {@link ReleasableReferenceManager}s for all {@link
-   * CanReleaseReferences @CanReleaseReferences} scopes.
+   * Returns all the modules that should be installed in the component. For production components
+   * and production subcomponents that have a parent that is not a production component or
+   * subcomponent, also includes the production monitoring module for the component and the
+   * production executor module.
    */
-  private ImmutableSetMultimap<Scope, ProvisionBinding> getReleasableReferenceManagerBindings(
-      ComponentDescriptor componentDescriptor) {
-    ImmutableSetMultimap.Builder<Scope, ProvisionBinding> bindings = ImmutableSetMultimap.builder();
-    // TODO(dpb,gak): Do we need to bind an empty Set<ReleasableReferenceManager> if there are
-    // none?
-    for (Scope scope : componentDescriptor.releasableReferencesScopes()) {
-      // Add a binding for @ForReleasableReferences(scope) ReleasableReferenceManager.
-      bindings.put(scope, bindingFactory.releasableReferenceManagerBinding(scope));
-
-      /* Add a binding for Set<ReleasableReferenceManager>. Even if these are added more than
-       * once, each instance will be equal to the rest. Since they're being added to a set, there
-       * will be only one instance. */
-      bindings.put(scope, bindingFactory.setOfReleasableReferenceManagersBinding());
-
-      for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
-        // Add a binding for @ForReleasableReferences(scope) TypedReleasableReferenceManager<M>.
-        bindings.put(
-            scope,
-            bindingFactory.typedReleasableReferenceManagerBinding(
-                scope, metadata.getAnnotationType()));
-
-        /* Add a binding for Set<TypedReleasableReferenceManager<M>>. Even if these are added more
-         * than once, each instance will be equal to the rest. Since they're being added to a set,
-         * there will be only one instance. */
-        bindings.put(
-            scope,
-            bindingFactory.setOfTypedReleasableReferenceManagersBinding(
-                metadata.getAnnotationType()));
-      }
-    }
-    return bindings.build();
+  private ImmutableSet<ModuleDescriptor> modules(
+      ComponentDescriptor componentDescriptor, Optional<Resolver> parentResolver) {
+    return shouldIncludeImplicitProductionModules(componentDescriptor, parentResolver)
+        ? new ImmutableSet.Builder<ModuleDescriptor>()
+            .addAll(componentDescriptor.modules())
+            .add(descriptorForMonitoringModule(componentDescriptor.typeElement()))
+            .add(descriptorForProductionExecutorModule())
+            .build()
+        : componentDescriptor.modules();
+  }
+
+  private boolean shouldIncludeImplicitProductionModules(
+      ComponentDescriptor componentDescriptor, Optional<Resolver> parentResolver) {
+    ComponentKind kind = componentDescriptor.kind();
+    return kind.isProducer()
+        && ((kind.isTopLevel() && !kind.isForModuleValidation())
+            || (parentResolver.isPresent()
+                && !parentResolver.get().componentDescriptor.kind().isProducer()));
   }
 
   /**
-   * Returns the set of scopes that will be returned by {@link
-   * BindingGraph#scopesRequiringReleasableReferenceManagers()}.
+   * Returns a descriptor for a generated module that handles monitoring for production components.
+   * This module is generated in the {@link MonitoringModuleProcessingStep}.
    *
-   * @param releasableReferenceManagerBindings the {@link ReleasableReferenceManager} bindings for
-   *     each scope
-   * @param resolvedContributionKeys the keys of the resolved bindings for the component
+   * @throws TypeNotPresentException if the module has not been generated yet. This will cause the
+   *     processor to retry in a later processing round.
    */
-  private ImmutableSet<Scope> getScopesRequiringReleasableReferenceManagers(
-      ImmutableSetMultimap<Scope, ProvisionBinding> releasableReferenceManagerBindings,
-      ImmutableSet<Key> resolvedContributionKeys) {
-    ImmutableSet.Builder<Scope> scopes = ImmutableSet.builder();
-    releasableReferenceManagerBindings
-        .asMap()
-        .forEach(
-            (scope, bindings) -> {
-              for (Binding binding : bindings) {
-                if (resolvedContributionKeys.contains(binding.key())) {
-                  scopes.add(scope);
-                  return;
-                }
-              }
-            });
-    return scopes.build();
+  private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
+    return moduleDescriptorFactory.create(
+        elements.checkTypePresent(
+            generatedMonitoringModuleName(componentDefinitionType).toString()));
+  }
+
+  /** Returns a descriptor {@link ProductionExecutorModule}. */
+  private ModuleDescriptor descriptorForProductionExecutorModule() {
+    return moduleDescriptorFactory.create(elements.getTypeElement(ProductionExecutorModule.class));
   }
 
   /** Indexes {@code bindingDeclarations} by {@link BindingDeclaration#key()}. */
@@ -318,7 +291,7 @@ private BindingGraph create(
         ImmutableSetMultimap<Key, SubcomponentDeclaration> subcomponentDeclarations,
         ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations,
         ImmutableSetMultimap<Key, OptionalBindingDeclaration> optionalBindingDeclarations) {
-      this.parentResolver = checkNotNull(parentResolver);
+      this.parentResolver = parentResolver;
       this.componentDescriptor = checkNotNull(componentDescriptor);
       this.explicitBindings = checkNotNull(explicitBindings);
       this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
@@ -329,20 +302,18 @@ private BindingGraph create(
       this.explicitMultibindings = multibindingContributionsByMultibindingKey(explicitBindingsSet);
       this.delegateMultibindingDeclarations =
           multibindingContributionsByMultibindingKey(delegateDeclarations.values());
-      subcomponentsToResolve.addAll(componentDescriptor.subcomponentsFromEntryPoints());
+      subcomponentsToResolve.addAll(
+          componentDescriptor.childComponentsDeclaredByFactoryMethods().values());
+      subcomponentsToResolve.addAll(
+          componentDescriptor.childComponentsDeclaredByBuilderEntryPoints().values());
     }
 
     /** Returns the optional factory method for this component. */
     Optional<ExecutableElement> getFactoryMethod() {
       return parentResolver
-          .map(
-              parent -> {
-                return parent
-                    .componentDescriptor
-                    .subcomponentsByFactoryMethod()
-                    .inverse()
-                    .get(componentDescriptor);
-              })
+          .flatMap(
+              parent ->
+                  parent.componentDescriptor.getFactoryMethodForChildComponent(componentDescriptor))
           .map(method -> method.methodElement());
     }
 
@@ -400,7 +371,9 @@ ResolvedBindings lookUpBindings(Key requestKey) {
 
       // If there are no bindings, add the implicit @Inject-constructed binding if there is one.
       if (bindings.isEmpty()) {
-        injectBindingRegistry.getOrFindProvisionBinding(requestKey).ifPresent(bindings::add);
+        injectBindingRegistry.getOrFindProvisionBinding(requestKey)
+            .filter(binding -> !isIncorrectlyScopedInPartialGraph(binding))
+            .ifPresent(bindings::add);
       }
 
       return ResolvedBindings.forContributionBindings(
@@ -412,6 +385,26 @@ ResolvedBindings lookUpBindings(Key requestKey) {
           optionalBindingDeclarations);
     }
 
+    /**
+     * Returns true if this binding graph resolution is for a partial graph and the {@code @Inject}
+     * binding's scope doesn't match any of the components in the current component ancestry. If so,
+     * the binding is not owned by any of the currently known components, and will be owned by a
+     * future ancestor (or, if never owned, will result in an incompatibly scoped binding error at
+     * the root component).
+     */
+    private boolean isIncorrectlyScopedInPartialGraph(ProvisionBinding binding) {
+      checkArgument(binding.kind().equals(INJECTION));
+      Resolver owningResolver = getOwningResolver(binding).orElse(this);
+      ComponentDescriptor owningComponent = owningResolver.componentDescriptor;
+      return !rootComponent().kind().isTopLevel()
+          && binding.scope().isPresent()
+          && !owningComponent.scopes().contains(binding.scope().get());
+    }
+
+    private ComponentDescriptor rootComponent() {
+      return parentResolver.map(Resolver::rootComponent).orElse(componentDescriptor);
+    }
+
     /** Returns the resolved members injection bindings for the given {@link Key}. */
     ResolvedBindings lookUpMembersInjectionBinding(Key requestKey) {
       // no explicit deps for members injection, so just look it up
@@ -428,13 +421,13 @@ ResolvedBindings lookUpMembersInjectionBinding(Key requestKey) {
      * ComponentDescriptor subcomponent} to a queue in the owning component's resolver. The queue
      * will be used to detect which subcomponents need to be resolved.
      */
-    private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilderBinding) {
-      checkArgument(subcomponentBuilderBinding.kind().equals(SUBCOMPONENT_BUILDER));
-      Resolver owningResolver = getOwningResolver(subcomponentBuilderBinding).get();
+    private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentCreatorBinding) {
+      checkArgument(subcomponentCreatorBinding.kind().equals(SUBCOMPONENT_BUILDER));
+      Resolver owningResolver = getOwningResolver(subcomponentCreatorBinding).get();
 
-      TypeElement builderType = MoreTypes.asTypeElement(subcomponentBuilderBinding.key().type());
+      TypeElement builderType = MoreTypes.asTypeElement(subcomponentCreatorBinding.key().type());
       owningResolver.subcomponentsToResolve.add(
-          owningResolver.componentDescriptor.subcomponentsByBuilderType().get(builderType));
+          owningResolver.componentDescriptor.getChildComponentWithBuilderType(builderType));
     }
 
     private ImmutableSet<Key> keysMatchingRequest(Key requestKey) {
@@ -477,7 +470,7 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
         ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
       return subcomponentDeclarations.isEmpty()
           ? Optional.empty()
-          : Optional.of(bindingFactory.subcomponentBuilderBinding(subcomponentDeclarations));
+          : Optional.of(bindingFactory.subcomponentCreatorBinding(subcomponentDeclarations));
     }
 
     /**
@@ -599,6 +592,24 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
     }
 
     private Optional<Resolver> getOwningResolver(ContributionBinding binding) {
+      // TODO(ronshapiro): extract the different pieces of this method into their own methods
+      if ((binding.scope().isPresent() && binding.scope().get().isProductionScope())
+          || binding.bindingType().equals(BindingType.PRODUCTION)) {
+        for (Resolver requestResolver : getResolverLineage()) {
+          // Resolve @Inject @ProductionScope bindings at the highest production component.
+          if (binding.kind().equals(INJECTION)
+              && requestResolver.componentDescriptor.kind().isProducer()) {
+            return Optional.of(requestResolver);
+          }
+
+          // Resolve explicit @Produces and @ProductionScope bindings at the highest component that
+          // installs the binding.
+          if (requestResolver.containsExplicitBinding(binding)) {
+            return Optional.of(requestResolver);
+          }
+        }
+      }
+
       if (binding.scope().isPresent() && binding.scope().get().isReusable()) {
         for (Resolver requestResolver : getResolverLineage().reverse()) {
           // If a @Reusable binding was resolved in an ancestor, use that component.
@@ -613,9 +624,7 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
       }
 
       for (Resolver requestResolver : getResolverLineage().reverse()) {
-        if (requestResolver.explicitBindingsSet.contains(binding)
-            || resolverContainsDelegateDeclarationForBinding(requestResolver, binding)
-            || requestResolver.subcomponentDeclarations.containsKey(binding.key())) {
+        if (requestResolver.containsExplicitBinding(binding)) {
           return Optional.of(requestResolver);
         }
       }
@@ -633,80 +642,31 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
       return Optional.empty();
     }
 
-    /**
-     * Returns true if {@code binding} was installed in a module in this resolver's component. If
-     * {@link CompilerOptions#floatingBindsMethods()} is enabled, calls {@link
-     * #recordFloatingBindsMethod(Resolver, ContributionBinding)} and returns false.
-     */
-    private boolean resolverContainsDelegateDeclarationForBinding(
-        Resolver resolver, ContributionBinding binding) {
-      // TODO(ronshapiro): remove the flag once we feel enough time has passed, and return this
-      // value directly. At that point, this can be remove the resolver parameter and become a
-      // method invoked on a particular resolver
-      boolean resolverContainsDeclaration =
-          binding.kind().equals(DELEGATE)
-              && resolver
-                  .delegateDeclarations
-                  .get(binding.key())
-                  .stream()
-                  .anyMatch(
-                      declaration ->
-                          declaration.contributingModule().equals(binding.contributingModule())
-                              && declaration.bindingElement().equals(binding.bindingElement()));
-      if (resolverContainsDeclaration && compilerOptions.floatingBindsMethods()) {
-        recordFloatingBindsMethod(resolver, binding);
-        return false;
-      }
-      return resolverContainsDeclaration;
+    private boolean containsExplicitBinding(ContributionBinding binding) {
+      return explicitBindingsSet.contains(binding)
+          || resolverContainsDelegateDeclarationForBinding(binding)
+          || subcomponentDeclarations.containsKey(binding.key());
     }
 
-    /**
-     * Records binds methods that are resolved in the wrong component due to b/79859714. These will
-     * be reported later on in {@link IncorrectlyInstalledBindsMethodsValidator}.
-     */
-    private void recordFloatingBindsMethod(Resolver idealResolver, ContributionBinding binding) {
-      Resolver actualResolver = this;
-      if (binding.scope().isPresent()) {
-        for (Resolver requestResolver : getResolverLineage().reverse()) {
-          if (requestResolver.componentDescriptor.scopes().contains(binding.scope().get())) {
-            actualResolver = requestResolver;
-            break;
-          }
-        }
-      }
-      if (actualResolver != idealResolver) {
-        incorrectlyInstalledBindsMethodsValidator.recordBinding(
-            componentPath(idealResolver), binding);
-      }
-    }
-
-    /**
-     * Constructs a {@link ComponentPath} from the root component of this resolver to a {@code
-     * destination}.
-     */
-    private ComponentPath componentPath(Resolver destination) {
-      ImmutableList.Builder<TypeElement> path = ImmutableList.builder();
-      for (Resolver resolver : getResolverLineage()) {
-        path.add(resolver.componentDescriptor.componentDefinitionType());
-        if (resolver == destination) {
-          return ComponentPath.create(path.build());
-        }
-      }
-      throw new AssertionError(
-          String.format(
-              "%s not found in %s",
-              destination.componentDescriptor.componentDefinitionType(), path.build()));
+    /** Returns true if {@code binding} was installed in a module in this resolver's component. */
+    private boolean resolverContainsDelegateDeclarationForBinding(ContributionBinding binding) {
+      return binding.kind().equals(DELEGATE)
+          && delegateDeclarations.get(binding.key()).stream()
+              .anyMatch(
+                  declaration ->
+                      declaration.contributingModule().equals(binding.contributingModule())
+                          && declaration.bindingElement().equals(binding.bindingElement()));
     }
 
     /** Returns the resolver lineage from parent to child. */
     private ImmutableList<Resolver> getResolverLineage() {
-      List<Resolver> resolverList = Lists.newArrayList();
+      ImmutableList.Builder<Resolver> resolverList = ImmutableList.builder();
       for (Optional<Resolver> currentResolver = Optional.of(this);
           currentResolver.isPresent();
           currentResolver = currentResolver.get().parentResolver) {
         resolverList.add(currentResolver.get());
       }
-      return ImmutableList.copyOf(Lists.reverse(resolverList));
+      return resolverList.build().reverse();
     }
 
     /**
@@ -740,9 +700,13 @@ private ComponentPath componentPath(Resolver destination) {
     private ImmutableSet<ContributionBinding> getLocalExplicitBindings(Key key) {
       return new ImmutableSet.Builder<ContributionBinding>()
           .addAll(explicitBindings.get(key))
+          // @Binds @IntoMap declarations have key Map<K, V>, unlike @Provides @IntoMap or @Produces
+          // @IntoMap, which have Map<K, Provider/Producer<V>> keys. So unwrap the key's type's
+          // value type if it's a Map<K, Provider/Producer<V>> before looking in
+          // delegateDeclarations. createDelegateBindings() will create bindings with the properly
+          // wrapped key type.
           .addAll(
-              createDelegateBindings(
-                  delegateDeclarations.get(keyFactory.convertToDelegateKey(key))))
+              createDelegateBindings(delegateDeclarations.get(keyFactory.unwrapMapValueType(key))))
           .build();
     }
 
@@ -768,11 +732,14 @@ private ComponentPath componentPath(Resolver destination) {
       if (!MapType.isMap(key)
           || MapType.from(key).isRawType()
           || MapType.from(key).valuesAreFrameworkType()) {
-        // There are no @Binds @IntoMap delegate declarations for Map<K, V> requests. All
-        // @IntoMap requests must be for Map<K, Framework<V>>.
+        // @Binds @IntoMap declarations have key Map<K, V>, unlike @Provides @IntoMap or @Produces
+        // @IntoMap, which have Map<K, Provider/Producer<V>> keys. So unwrap the key's type's
+        // value type if it's a Map<K, Provider/Producer<V>> before looking in
+        // delegateMultibindingDeclarations. createDelegateBindings() will create bindings with the
+        // properly wrapped key type.
         multibindings.addAll(
             createDelegateBindings(
-                delegateMultibindingDeclarations.get(keyFactory.convertToDelegateKey(key))));
+                delegateMultibindingDeclarations.get(keyFactory.unwrapMapValueType(key))));
       }
       return multibindings.build();
     }
@@ -835,9 +802,7 @@ private ComponentPath componentPath(Resolver destination) {
       }
     }
 
-    private void resolveMembersInjectionMethod(ComponentMethodDescriptor componentMethod) {
-      checkArgument(componentMethod.kind().equals(ComponentMethodKind.MEMBERS_INJECTION));
-      Key key = componentMethod.dependencyRequest().get().key();
+    private void resolveMembersInjection(Key key) {
       ResolvedBindings bindings = lookUpMembersInjectionBinding(key);
       resolveDependencies(bindings);
       resolvedMembersInjectionBindings.put(key, bindings);
@@ -855,15 +820,16 @@ void resolve(Key key) {
         return;
       }
 
-      /* If the binding was previously resolved in a supercomponent, then we may be able to avoid
-       * resolving it here and just depend on the supercomponent resolution.
+      /*
+       * If the binding was previously resolved in an ancestor component, then we may be able to
+       * avoid resolving it here and just depend on the ancestor component resolution.
        *
        * 1. If it depends transitively on multibinding contributions or optional bindings with
        *    bindings from this subcomponent, then we have to resolve it in this subcomponent so
        *    that it sees the local bindings.
        *
        * 2. If there are any explicit bindings in this component, they may conflict with those in
-       *    the supercomponent, so resolve them here so that conflicts can be caught.
+       *    the ancestor component, so resolve them here so that conflicts can be caught.
        */
       if (getPreviouslyResolvedBindings(key).isPresent()) {
         /* Resolve in the parent in case there are multibinding contributions or conflicts in some
@@ -935,14 +901,13 @@ private void resolveDependencies(ResolvedBindings resolvedBindings) {
       return parentResolver.isPresent()
           ? Sets.union(
                   parentResolver.get().getInheritedModules(),
-                  parentResolver.get().componentDescriptor.transitiveModules())
+                  parentResolver.get().componentDescriptor.modules())
               .immutableCopy()
           : ImmutableSet.<ModuleDescriptor>of();
     }
 
     ImmutableSet<ModuleDescriptor> getOwnedModules() {
-      return Sets.difference(componentDescriptor.transitiveModules(), getInheritedModules())
-          .immutableCopy();
+      return Sets.difference(componentDescriptor.modules(), getInheritedModules()).immutableCopy();
     }
 
     private final class LocalDependencyChecker {
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index 63e1fa255..48c28b79e 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -18,8 +18,15 @@
 
 import dagger.Binds;
 import dagger.Module;
+import dagger.Provides;
 import dagger.multibindings.IntoSet;
 import dagger.spi.BindingGraphPlugin;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.Filer;
+import javax.inject.Singleton;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /** Binds the set of {@link BindingGraphPlugin}s used to implement Dagger validation. */
 @Module
@@ -75,4 +82,40 @@ BindingGraphPlugin provisionDependencyOnProducerBinding(
   @IntoSet
   @Validation
   BindingGraphPlugin subcomponentFactoryMethod(SubcomponentFactoryMethodValidator validation);
+
+  @Provides
+  @Singleton
+  @Validation
+  static BindingGraphPlugins validationPlugins(
+      @Validation Set<BindingGraphPlugin> validationPlugins,
+      Filer filer,
+      Types types,
+      Elements elements,
+      @ProcessingOptions Map<String, String> processingOptions,
+      DiagnosticReporterFactory diagnosticReporterFactory) {
+    return new BindingGraphPlugins(
+        validationPlugins, filer, types, elements, processingOptions, diagnosticReporterFactory);
+  }
+
+  @Provides
+  @Singleton
+  @ModuleValidation
+  static BindingGraphPlugins moduleValidationPlugins(
+      @Validation Set<BindingGraphPlugin> validationPlugins,
+      Filer filer,
+      Types types,
+      Elements elements,
+      @ProcessingOptions Map<String, String> processingOptions,
+      DiagnosticReporterFactory diagnosticReporterFactory,
+      CompilerOptions compilerOptions) {
+    return new BindingGraphPlugins(
+        validationPlugins,
+        filer,
+        types,
+        elements,
+        processingOptions,
+        diagnosticReporterFactory
+            .treatingErrorsAs(compilerOptions.moduleBindingValidationType())
+            .withoutPrintingEntryPoints());
+  }
 }
diff --git a/java/dagger/internal/codegen/BindingMethodImplementation.java b/java/dagger/internal/codegen/BindingMethodImplementation.java
index a3d9b3220..9fc28d031 100644
--- a/java/dagger/internal/codegen/BindingMethodImplementation.java
+++ b/java/dagger/internal/codegen/BindingMethodImplementation.java
@@ -17,32 +17,45 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.RequestKinds.requestType;
 
-import com.squareup.javapoet.ClassName;
+import com.google.common.base.Supplier;
 import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.RequestKind;
+import java.util.Optional;
 import javax.lang.model.type.TypeMirror;
 
 /** Defines a method body and return type for a given {@link BindingExpression}. */
 class BindingMethodImplementation {
+  private final ComponentImplementation component;
   private final ContributionBinding binding;
   private final BindingRequest request;
   private final BindingExpression bindingExpression;
-  private final ClassName componentName;
   private final DaggerTypes types;
 
   BindingMethodImplementation(
-      ResolvedBindings resolvedBindings,
+      ComponentImplementation component,
+      ContributionBinding binding,
       BindingRequest request,
       BindingExpression bindingExpression,
-      ClassName componentName,
       DaggerTypes types) {
-    this.binding = resolvedBindings.contributionBinding();
-    this.request = checkNotNull(request);
+    this.component = component;
+    this.binding = binding;
+    this.request = request;
     this.bindingExpression = checkNotNull(bindingExpression);
-    this.componentName = checkNotNull(componentName);
-    this.types = checkNotNull(types);
+    this.types = types;
+  }
+
+  /** The method's body. */
+  final CodeBlock body() {
+    return implementation(bindingExpression.getDependencyExpression(component.name())::codeBlock);
+  }
+
+  /** The method's body if this method is a component method. */
+  final CodeBlock bodyForComponentMethod(ComponentMethodDescriptor componentMethod) {
+    return implementation(
+        bindingExpression.getDependencyExpressionForComponentMethod(componentMethod, component)
+            ::codeBlock);
   }
 
   /**
@@ -50,14 +63,12 @@
    *
    * <p>If the implementation has a non-void return type, the body will also include the {@code
    * return} statement.
+   *
+   * @param simpleBindingExpression the expression to retrieve an instance of this binding without
+   *     the wrapping method.
    */
-  CodeBlock body() {
-    return CodeBlock.of("return $L;", simpleBindingExpression());
-  }
-
-  /** Returns the code for the binding expression. */
-  protected final CodeBlock simpleBindingExpression() {
-    return bindingExpression.getDependencyExpression(componentName).codeBlock();
+  CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
+    return CodeBlock.of("return $L;", simpleBindingExpression.get());
   }
 
   /** Returns the return type for the dependency request. */
@@ -66,14 +77,25 @@ final TypeMirror returnType() {
         && binding.contributedPrimitiveType().isPresent()) {
       return binding.contributedPrimitiveType().get();
     }
-    return types.accessibleType(requestedType(), componentName);
-  }
 
-  private TypeMirror requestedType() {
-    if (request.requestKind().isPresent()) {
-      return requestType(request.requestKind().get(), binding.contributedType(), types);
+    if (matchingComponentMethod().isPresent()) {
+      // Component methods are part of the user-defined API, and thus we must use the user-defined
+      // type.
+      return matchingComponentMethod().get().resolvedReturnType(types);
     }
-    return types.wrapType(
-        binding.contributedType(), request.frameworkType().get().frameworkClass());
+
+    // If the component is abstract, this method may be overridden by another implementation in a
+    // different package for which requestedType is inaccessible. In order to make that method
+    // overridable, we use the publicly accessible type. If the type is final, we don't need to 
+    // worry about this, and instead just need to check accessibility of the file we're about to
+    // write
+    TypeMirror requestedType = request.requestedType(binding.contributedType(), types);
+    return component.isAbstract()
+        ? types.publiclyAccessibleType(requestedType)
+        : types.accessibleType(requestedType, component.name());
+  }
+
+  private Optional<ComponentMethodDescriptor> matchingComponentMethod() {
+    return component.componentDescriptor().firstMatchingComponentMethod(request);
   }
 }
diff --git a/java/dagger/internal/codegen/BindingMethodProcessingStep.java b/java/dagger/internal/codegen/BindingMethodProcessingStep.java
index 50c2081a4..e6c4f8ed3 100644
--- a/java/dagger/internal/codegen/BindingMethodProcessingStep.java
+++ b/java/dagger/internal/codegen/BindingMethodProcessingStep.java
@@ -17,20 +17,17 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static javax.lang.model.util.ElementFilter.methodsIn;
 
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 
 /** A step that validates all binding methods that were not validated while processing modules. */
-final class BindingMethodProcessingStep implements ProcessingStep {
+final class BindingMethodProcessingStep extends TypeCheckingProcessingStep<ExecutableElement> {
 
   private final Messager messager;
   private final AnyBindingMethodValidator anyBindingMethodValidator;
@@ -38,6 +35,7 @@
   @Inject
   BindingMethodProcessingStep(
       Messager messager, AnyBindingMethodValidator anyBindingMethodValidator) {
+    super(MoreElements::asExecutable);
     this.messager = messager;
     this.anyBindingMethodValidator = anyBindingMethodValidator;
   }
@@ -48,18 +46,15 @@
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (ExecutableElement method : methodsIn(elementsByAnnotation.values())) {
-      checkArgument(
-          anyBindingMethodValidator.isBindingMethod(method),
-          "%s is not annotated with any of %s",
-          method,
-          annotations());
-      if (!anyBindingMethodValidator.wasAlreadyValidated(method)) {
-        anyBindingMethodValidator.validate(method).printMessagesTo(messager);
-      }
+  protected void process(
+      ExecutableElement method, ImmutableSet<Class<? extends Annotation>> annotations) {
+    checkArgument(
+        anyBindingMethodValidator.isBindingMethod(method),
+        "%s is not annotated with any of %s",
+        method,
+        annotations());
+    if (!anyBindingMethodValidator.wasAlreadyValidated(method)) {
+      anyBindingMethodValidator.validate(method).printMessagesTo(messager);
     }
-    return ImmutableSet.of();
   }
 }
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 32bc9f0fc..779a5800c 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -342,23 +342,35 @@ protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder)
   }
 
   /**
-   * Adds errors if the method has more than one {@linkplain MultibindingAnnotations multibinding
-   * annotation} or if it has a multibinding annotation and its {@link Provides} or {@link Produces}
-   * annotation has a {@code type} parameter.
+   * Adds errors if the method doesn't allow {@linkplain MultibindingAnnotations multibinding
+   * annotations} and has any, or if it does allow them but has more than one, or if it has a
+   * multibinding annotation and its {@link Provides} or {@link Produces} annotation has a {@code
+   * type} parameter.
    */
   protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!allowsMultibindings.allowsMultibindings()) {
-      return;
-    }
     ImmutableSet<AnnotationMirror> multibindingAnnotations =
         MultibindingAnnotations.forMethod(builder.getSubject());
-    if (multibindingAnnotations.size() > 1) {
-      for (AnnotationMirror annotation : multibindingAnnotations) {
-        builder.addError(
-            bindingMethods("cannot have more than one multibinding annotation"),
-            builder.getSubject(),
-            annotation);
-      }
+
+    switch (allowsMultibindings) {
+      case NO_MULTIBINDINGS:
+        for (AnnotationMirror annotation : multibindingAnnotations) {
+          builder.addError(
+              bindingMethods("cannot have multibinding annotations"),
+              builder.getSubject(),
+              annotation);
+        }
+        break;
+
+      case ALLOWS_MULTIBINDINGS:
+        if (multibindingAnnotations.size() > 1) {
+          for (AnnotationMirror annotation : multibindingAnnotations) {
+            builder.addError(
+                bindingMethods("cannot have more than one multibinding annotation"),
+                builder.getSubject(),
+                annotation);
+          }
+        }
+        break;
     }
 
     AnnotationMirror bindingAnnotationMirror =
diff --git a/java/dagger/internal/codegen/BindingNode.java b/java/dagger/internal/codegen/BindingNode.java
new file mode 100644
index 000000000..fb9b5e3a3
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingNode.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingType.PRODUCTION;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.model.BindingKind;
+import dagger.model.ComponentPath;
+import dagger.model.DependencyRequest;
+import dagger.model.Key;
+import dagger.model.Scope;
+import dagger.multibindings.Multibinds;
+import java.util.Optional;
+import java.util.function.Supplier;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * An implementation of {@link dagger.model.Binding} that also exposes {@link BindingDeclaration}s
+ * associated with the binding.
+ */
+// TODO(dpb): Consider a supertype of dagger.model.Binding that dagger.internal.codegen.Binding
+// could also implement.
+@AutoValue
+abstract class BindingNode implements dagger.model.Binding {
+  static BindingNode create(
+      ComponentPath component,
+      Binding delegate,
+      Iterable<BindingDeclaration> associatedDeclarations,
+      Supplier<String> toStringFunction) {
+    BindingNode node =
+        new AutoValue_BindingNode(component, delegate, ImmutableSet.copyOf(associatedDeclarations));
+    node.toStringFunction = checkNotNull(toStringFunction);
+    return node;
+  }
+
+  private Supplier<String> toStringFunction;
+
+  abstract Binding delegate();
+
+  /**
+   * The {@link Element}s (other than the binding's {@link #bindingElement()}) that are associated
+   * with the binding.
+   *
+   * <ul>
+   *   <li>{@linkplain BindsOptionalOf optional binding} declarations
+   *   <li>{@linkplain Module#subcomponents() module subcomponent} declarations
+   *   <li>{@linkplain Multibinds multibinding} declarations
+   * </ul>
+   */
+  abstract ImmutableSet<BindingDeclaration> associatedDeclarations();
+
+  @Override
+  public Key key() {
+    return delegate().key();
+  }
+
+  @Override
+  public ImmutableSet<DependencyRequest> dependencies() {
+    return delegate().dependencies();
+  }
+
+  @Override
+  public Optional<Element> bindingElement() {
+    return delegate().bindingElement();
+  }
+
+  @Override
+  public Optional<TypeElement> contributingModule() {
+    return delegate().contributingModule();
+  }
+
+  @Override
+  public boolean requiresModuleInstance() {
+    return delegate().requiresModuleInstance();
+  }
+
+  @Override
+  public Optional<Scope> scope() {
+    return delegate().scope();
+  }
+
+  @Override
+  public boolean isNullable() {
+    return delegate().isNullable();
+  }
+
+  @Override
+  public boolean isProduction() {
+    return delegate().bindingType().equals(PRODUCTION);
+  }
+
+  @Override
+  public BindingKind kind() {
+    return delegate().kind();
+  }
+
+  @Override
+  public final String toString() {
+    return toStringFunction.get();
+  }
+}
diff --git a/java/dagger/internal/codegen/BindingNodeImpl.java b/java/dagger/internal/codegen/BindingNodeImpl.java
deleted file mode 100644
index 3c2b32859..000000000
--- a/java/dagger/internal/codegen/BindingNodeImpl.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.collect.ImmutableSet;
-import dagger.BindsOptionalOf;
-import dagger.Module;
-import dagger.model.BindingGraph.BindingNode;
-import dagger.model.ComponentPath;
-import dagger.multibindings.Multibinds;
-import java.util.function.Supplier;
-import javax.lang.model.element.Element;
-
-/**
- * An implementation of {@link BindingNode} that also exposes {@link BindingDeclaration}s associated
- * with the binding.
- */
-@AutoValue
-abstract class BindingNodeImpl implements BindingNode {
-  static BindingNode create(
-      ComponentPath component,
-      dagger.model.Binding binding,
-      Iterable<BindingDeclaration> associatedDeclarations,
-      Supplier<String> toStringFunction) {
-    BindingNodeImpl node =
-        new AutoValue_BindingNodeImpl(
-            component, binding, ImmutableSet.copyOf(associatedDeclarations));
-    node.toStringFunction = checkNotNull(toStringFunction);
-    return node;
-  }
-
-  private Supplier<String> toStringFunction;
-
-  /**
-   * The {@link Element}s (other than the binding's {@link dagger.model.Binding#bindingElement()})
-   * that are associated with the binding.
-   *
-   * <ul>
-   *   <li>{@linkplain BindsOptionalOf optional binding} declarations
-   *   <li>{@linkplain Module#subcomponents() module subcomponent} declarations
-   *   <li>{@linkplain Multibinds multibinding} declarations
-   * </ul>
-   */
-  abstract ImmutableSet<BindingDeclaration> associatedDeclarations();
-
-  @Override
-  public final String toString() {
-    return toStringFunction.get();
-  }
-}
diff --git a/java/dagger/internal/codegen/BindingRequest.java b/java/dagger/internal/codegen/BindingRequest.java
index d15683e79..85f231ec3 100644
--- a/java/dagger/internal/codegen/BindingRequest.java
+++ b/java/dagger/internal/codegen/BindingRequest.java
@@ -16,14 +16,14 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.RequestKinds.requestTypeName;
+import static dagger.internal.codegen.RequestKinds.requestType;
 
 import com.google.auto.value.AutoValue;
-import com.squareup.javapoet.TypeName;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
 import java.util.Optional;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * A request for a binding, which may be in the form of a request for a dependency to pass to a
@@ -32,17 +32,16 @@
  */
 @AutoValue
 abstract class BindingRequest {
-
   /** Creates a {@link BindingRequest} for the given {@link DependencyRequest}. */
-  static BindingRequest forDependencyRequest(DependencyRequest dependencyRequest) {
-    return forDependencyRequest(dependencyRequest.key(), dependencyRequest.kind());
+  static BindingRequest bindingRequest(DependencyRequest dependencyRequest) {
+    return bindingRequest(dependencyRequest.key(), dependencyRequest.kind());
   }
 
   /**
    * Creates a {@link BindingRequest} for a normal dependency request for the given {@link Key} and
    * {@link RequestKind}.
    */
-  static BindingRequest forDependencyRequest(Key key, RequestKind requestKind) {
+  static BindingRequest bindingRequest(Key key, RequestKind requestKind) {
     // When there's a request that has a 1:1 mapping to a FrameworkType, the request should be
     // associated with that FrameworkType as well, because we want to ensure that if a request
     // comes in for that as a dependency first and as a framework instance later, they resolve to
@@ -59,14 +58,14 @@ static BindingRequest forDependencyRequest(Key key, RequestKind requestKind) {
    * Creates a {@link BindingRequest} for a request for a framework instance for the given {@link
    * Key} with the given {@link FrameworkType}.
    */
-  static BindingRequest forFrameworkDependency(Key key, FrameworkType frameworkType) {
+  static BindingRequest bindingRequest(Key key, FrameworkType frameworkType) {
     return new AutoValue_BindingRequest(
-        key, Optional.of(frameworkType.requestKind()), Optional.of(frameworkType));
+        key, frameworkType.requestKind(), Optional.of(frameworkType));
   }
 
   /** Creates a {@link BindingRequest} for the given {@link FrameworkDependency}. */
-  static BindingRequest forFrameworkDependency(FrameworkDependency frameworkDependency) {
-    return forFrameworkDependency(frameworkDependency.key(), frameworkDependency.frameworkType());
+  static BindingRequest bindingRequest(FrameworkDependency frameworkDependency) {
+    return bindingRequest(frameworkDependency.key(), frameworkDependency.frameworkType());
   }
 
   /** Returns the {@link Key} for the requested binding. */
@@ -83,19 +82,19 @@ final boolean isRequestKind(RequestKind requestKind) {
     return requestKind.equals(requestKind().orElse(null));
   }
 
-  /** Returns the type name for the requested type. */
-  final TypeName typeName() {
-    TypeName keyTypeName = TypeName.get(key().type());
+  final TypeMirror requestedType(TypeMirror contributedType, DaggerTypes types) {
     if (requestKind().isPresent()) {
-      return requestTypeName(requestKind().get(), keyTypeName);
+      return requestType(requestKind().get(), contributedType, types);
     }
-    return frameworkType().get().frameworkClassOf(keyTypeName);
+    return types.wrapType(contributedType, frameworkType().get().frameworkClass());
   }
 
   /** Returns a name that can be used for the kind of request this is. */
   final String kindName() {
     Object requestKindObject =
-        requestKind().isPresent() ? requestKind().get() : frameworkType().get();
+        requestKind().isPresent()
+            ? requestKind().get()
+            : frameworkType().get().frameworkClass().getSimpleName();
     return requestKindObject.toString();
   }
 }
diff --git a/java/dagger/internal/codegen/BindingVariableNamer.java b/java/dagger/internal/codegen/BindingVariableNamer.java
index 526e2db4c..8e7600cec 100644
--- a/java/dagger/internal/codegen/BindingVariableNamer.java
+++ b/java/dagger/internal/codegen/BindingVariableNamer.java
@@ -16,88 +16,22 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
-import static dagger.internal.codegen.SourceFiles.protectAgainstKeywords;
-
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
-import java.util.Iterator;
-import javax.lang.model.element.Element;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.PrimitiveType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVisitor;
-import javax.lang.model.util.SimpleTypeVisitor6;
 
 /**
  * Suggests a variable name for a type based on a {@link Binding}. Prefer
  * {@link DependencyVariableNamer} for cases where a specific {@link DependencyRequest} is present.
  */
 final class BindingVariableNamer {
-  private static final TypeVisitor<Void, StringBuilder> TYPE_NAMER =
-      new SimpleTypeVisitor6<Void, StringBuilder>() {
-        @Override
-        public Void visitDeclared(DeclaredType declaredType, StringBuilder builder) {
-          Element element = declaredType.asElement();
-          if (isSubcomponentBuilder(element)) {
-            // Most Subcomponent builders are named "Builder", so add their associated
-            // Subcomponent type so that they're not all "builderProvider{N}"
-            builder.append(element.getEnclosingElement().getSimpleName());
-          }
-          builder.append(element.getSimpleName());
-          Iterator<? extends TypeMirror> argumentIterator =
-              declaredType.getTypeArguments().iterator();
-          if (argumentIterator.hasNext()) {
-            builder.append("Of");
-            TypeMirror first = argumentIterator.next();
-            first.accept(this, builder);
-            while (argumentIterator.hasNext()) {
-              builder.append("And");
-              argumentIterator.next().accept(this, builder);
-            }
-          }
-          return null;
-        }
-
-        @Override
-        public Void visitPrimitive(PrimitiveType type, StringBuilder builder) {
-          builder.append(LOWER_CAMEL.to(UPPER_CAMEL, type.toString()));
-          return null;
-        }
-
-        @Override
-        public Void visitArray(ArrayType type, StringBuilder builder) {
-          type.getComponentType().accept(this, builder);
-          builder.append("Array");
-          return null;
-        }
-      };
-
   private BindingVariableNamer() {}
 
   static String name(Binding binding) {
-    StringBuilder builder = new StringBuilder();
-
     Key key = binding.key();
-    if (key.qualifier().isPresent()) {
-      // TODO(gak): Use a better name for fields with qualifiers with members.
-      builder.append(key.qualifier().get().getAnnotationType().asElement().getSimpleName());
-    }
-
-    TypeMirror type = typeToName(binding);
-    type.accept(TYPE_NAMER, builder);
-
-    return protectAgainstKeywords(UPPER_CAMEL.to(LOWER_CAMEL, builder.toString()));
-  }
-
-  private static TypeMirror typeToName(Binding binding) {
     if (binding instanceof ContributionBinding
         && ((ContributionBinding) binding).contributionType().equals(ContributionType.SET)) {
-      return SetType.from(binding.key().type()).elementType();
+      key = key.toBuilder().type(SetType.from(key.type()).elementType()).build();
     }
-    return binding.key().type();
+    return KeyVariableNamer.name(key);
   }
 }
diff --git a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index 87ddbf772..c9d3cca50 100644
--- a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -22,20 +22,17 @@
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
+import static java.util.Arrays.stream;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import dagger.BindsInstance;
 import java.lang.annotation.Annotation;
 import java.util.Set;
-import java.util.stream.Stream;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -44,21 +41,22 @@
  * Processing step that validates that the {@code BindsInstance} annotation is applied to the
  * correct elements.
  */
-final class BindsInstanceProcessingStep implements ProcessingStep {
+final class BindsInstanceProcessingStep extends TypeCheckingProcessingStep<ExecutableElement> {
 
   private static final ImmutableSet<Class<? extends Annotation>> COMPONENT_ANNOTATIONS =
-      Stream.of(ComponentDescriptor.Kind.values())
-          .map(ComponentDescriptor.Kind::annotationType)
+      stream(ComponentKind.values())
+          .filter(kind -> !kind.isForModuleValidation())
+          .map(ComponentKind::annotation)
           .collect(toImmutableSet());
+
   private static final ImmutableSet<Class<? extends Annotation>> MODULE_ANNOTATIONS =
-      Stream.of(ModuleDescriptor.Kind.values())
-          .map(ModuleDescriptor.Kind::moduleAnnotation)
-          .collect(toImmutableSet());
+      stream(ModuleKind.values()).map(ModuleKind::annotation).collect(toImmutableSet());
 
   private final Messager messager;
 
   @Inject
   BindsInstanceProcessingStep(Messager messager) {
+    super(MoreElements::asExecutable);
     this.messager = messager;
   }
 
@@ -68,10 +66,8 @@
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (Element element : elementsByAnnotation.get(BindsInstance.class)) {
-      ExecutableElement method = MoreElements.asExecutable(element);
+  protected void process(
+      ExecutableElement method, ImmutableSet<Class<? extends Annotation>> annotations) {
       ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
       if (!method.getModifiers().contains(ABSTRACT)) {
         report.addError("@BindsInstance methods must be abstract");
@@ -102,7 +98,5 @@
                 simpleName(componentAnnotation)));
       }
       report.build().printMessagesTo(messager);
-    }
-    return ImmutableSet.of();
   }
 }
diff --git a/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java b/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
deleted file mode 100644
index f3333dab3..000000000
--- a/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static javax.lang.model.util.ElementFilter.typesIn;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import dagger.releasablereferences.CanReleaseReferences;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.inject.Inject;
-import javax.inject.Scope;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/**
- * Processes annotations annotated with {@link CanReleaseReferences}. For each one that is not also
- * a {@link Scope}, generates a class that can create instances at runtime.
- */
-final class CanReleaseReferencesProcessingStep implements ProcessingStep {
-
-  private final Messager messager;
-  private final CanReleaseReferencesValidator canReleaseReferencesValidator;
-  private final AnnotationCreatorGenerator annotationCreatorGenerator;
-
-  @Inject
-  CanReleaseReferencesProcessingStep(
-      Messager messager,
-      CanReleaseReferencesValidator canReleaseReferencesValidator,
-      AnnotationCreatorGenerator annotationCreatorGenerator) {
-    this.messager = messager;
-    this.canReleaseReferencesValidator = canReleaseReferencesValidator;
-    this.annotationCreatorGenerator = annotationCreatorGenerator;
-  }
-
-  @Override
-  public Set<? extends Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(CanReleaseReferences.class);
-  }
-
-  @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (TypeElement annotatedElement :
-        typesIn(elementsByAnnotation.get(CanReleaseReferences.class))) {
-      ValidationReport<TypeElement> report =
-          canReleaseReferencesValidator.validate(annotatedElement);
-      report.printMessagesTo(messager);
-      if (report.isClean() && !isAnnotationPresent(annotatedElement, Scope.class)) {
-        annotationCreatorGenerator.generate(annotatedElement, messager);
-      }
-    }
-    return ImmutableSet.of();
-  }
-}
diff --git a/java/dagger/internal/codegen/CanReleaseReferencesValidator.java b/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
deleted file mode 100644
index 5c79dab0a..000000000
--- a/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
-import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static java.lang.annotation.RetentionPolicy.SOURCE;
-
-import dagger.releasablereferences.CanReleaseReferences;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.SimpleAnnotationValueVisitor7;
-
-/**
- * Validates that {@link CanReleaseReferences} are applied only to valid annotations.
- *
- * <p>They must not annotate annotations that have {@link RetentionPolicy#SOURCE}-level retention.
- */
-final class CanReleaseReferencesValidator {
-
-  @Inject CanReleaseReferencesValidator() {}
-
-  ValidationReport<TypeElement> validate(TypeElement annotatedElement) {
-    ValidationReport.Builder<TypeElement> report = ValidationReport.about(annotatedElement);
-    checkNoSourceRetention(annotatedElement, report);
-    return report.build();
-  }
-
-  private void checkNoSourceRetention(
-      TypeElement annotatedElement, ValidationReport.Builder<TypeElement> report) {
-    getAnnotationMirror(annotatedElement, Retention.class)
-        .ifPresent(
-            retention -> {
-              if (getRetentionPolicy(retention).equals(SOURCE)) {
-                report.addError(
-                    "@CanReleaseReferences annotations must not have SOURCE retention",
-                    report.getSubject(),
-                    retention);
-              }
-            });
-  }
-
-  // TODO(dpb): Move the ability to get an annotation type's retention policy somewhere common.
-  private RetentionPolicy getRetentionPolicy(AnnotationMirror retention) {
-    return getAnnotationValue(retention, "value")
-        .accept(
-            new SimpleAnnotationValueVisitor7<RetentionPolicy, Void>() {
-              @Override
-              public RetentionPolicy visitEnumConstant(VariableElement element, Void p) {
-                return RetentionPolicy.valueOf(element.getSimpleName().toString());
-              }
-            },
-            null);
-  }
-}
diff --git a/java/dagger/internal/codegen/ChildFactoryMethodEdgeImpl.java b/java/dagger/internal/codegen/ChildFactoryMethodEdgeImpl.java
new file mode 100644
index 000000000..8a81017f5
--- /dev/null
+++ b/java/dagger/internal/codegen/ChildFactoryMethodEdgeImpl.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.DaggerElements.elementToString;
+
+import dagger.model.BindingGraph.ChildFactoryMethodEdge;
+import javax.lang.model.element.ExecutableElement;
+
+/** An implementation of {@link ChildFactoryMethodEdge}. */
+final class ChildFactoryMethodEdgeImpl implements ChildFactoryMethodEdge {
+
+  private final ExecutableElement factoryMethod;
+
+  ChildFactoryMethodEdgeImpl(ExecutableElement factoryMethod) {
+    this.factoryMethod = factoryMethod;
+  }
+
+  @Override
+  public ExecutableElement factoryMethod() {
+    return factoryMethod;
+  }
+
+  @Override
+  public String toString() {
+    return elementToString(factoryMethod);
+  }
+}
diff --git a/java/dagger/internal/codegen/CodeBlocks.java b/java/dagger/internal/codegen/CodeBlocks.java
index ab4d90ffa..c1ca32d3c 100644
--- a/java/dagger/internal/codegen/CodeBlocks.java
+++ b/java/dagger/internal/codegen/CodeBlocks.java
@@ -25,57 +25,30 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.CodeBlock.Builder;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import java.util.stream.Collector;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 
 final class CodeBlocks {
-  /**
-   * A {@link Collector} implementation that joins {@link CodeBlock} instances together into one
-   * separated by {@code delimiter}. For example, joining {@code String s}, {@code Object o} and
-   * {@code int i} using {@code ", "} would produce {@code String s, Object o, int i}.
-   */
-  static Collector<CodeBlock, ?, CodeBlock> joiningCodeBlocks(String delimiter) {
-    return Collector.of(
-        () -> new CodeBlockJoiner(delimiter, CodeBlock.builder()),
-        CodeBlockJoiner::add,
-        CodeBlockJoiner::merge,
-        CodeBlockJoiner::join);
-  }
-
   /**
    * Joins {@link CodeBlock} instances in a manner suitable for use as method parameters (or
-   * arguments). This is equivalent to {@code joiningCodeBlocks(", ")}.
+   * arguments).
    */
   static Collector<CodeBlock, ?, CodeBlock> toParametersCodeBlock() {
-    return joiningCodeBlocks(", ");
+    // TODO(ronshapiro,jakew): consider adding zero-width spaces to help line breaking when the
+    // formatter is off. If not, inline this
+    return CodeBlock.joining(", ");
   }
 
-  /**
-   * Joins {@link TypeName} instances into a {@link CodeBlock} that is a comma-separated list for
-   * use as type parameters or javadoc method arguments.
-   */
-  static Collector<TypeName, ?, CodeBlock> toTypeNamesCodeBlock() {
-    return Collector.of(
-        () -> new CodeBlockJoiner(", ", CodeBlock.builder()),
-        CodeBlockJoiner::addTypeName,
-        CodeBlockJoiner::merge,
-        CodeBlockJoiner::join);
-  }
-
-  /**
-   * Concatenates {@link CodeBlock} instances separated by newlines for readability. This is
-   * equivalent to {@code joiningCodeBlocks("\n")}.
-   */
+  /** Concatenates {@link CodeBlock} instances separated by newlines for readability. */
   static Collector<CodeBlock, ?, CodeBlock> toConcatenatedCodeBlock() {
-    return joiningCodeBlocks("\n");
+    return CodeBlock.joining("\n", "", "\n");
   }
 
   /** Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}. */
@@ -83,6 +56,25 @@ static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
     return stream(codeBlocks.spliterator(), false).collect(toParametersCodeBlock());
   }
 
+  /**
+   * Returns a comma-separated {@link CodeBlock} using the name of every parameter in {@code
+   * parameters}.
+   */
+  static CodeBlock parameterNames(Iterable<ParameterSpec> parameters) {
+    // TODO(ronshapiro): Add DaggerStreams.stream(Iterable)
+    return stream(parameters.spliterator(), false)
+        .map(p -> CodeBlock.of("$N", p))
+        .collect(toParametersCodeBlock());
+  }
+
+  /**
+   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a
+   * newline.
+   */
+  static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
+    return stream(codeBlocks.spliterator(), false).collect(toConcatenatedCodeBlock());
+  }
+
   /** Adds an annotation to a method. */
   static void addAnnotation(MethodSpec.Builder method, DeclaredType nullableType) {
     method.addAnnotation(ClassName.get(MoreTypes.asTypeElement(nullableType)));
@@ -111,57 +103,8 @@ static CodeBlock cast(CodeBlock expression, Class<?> castTo) {
     return CodeBlock.of("($T) $L", castTo, expression);
   }
 
-  private static final class CodeBlockJoiner {
-    private final String delimiter;
-    private final CodeBlock.Builder builder;
-    private boolean first = true;
-
-    CodeBlockJoiner(String delimiter, Builder builder) {
-      this.delimiter = delimiter;
-      this.builder = builder;
-    }
-
-    @CanIgnoreReturnValue
-    CodeBlockJoiner add(CodeBlock codeBlock) {
-      maybeAddDelimiter();
-      builder.add(codeBlock);
-      return this;
-    }
-
-    @CanIgnoreReturnValue
-    CodeBlockJoiner addTypeName(TypeName typeName) {
-      maybeAddDelimiter();
-      builder.add("$T", typeName);
-      return this;
-    }
-
-    private void maybeAddDelimiter() {
-      if (!first) {
-        builder.add(delimiter);
-      }
-      first = false;
-    }
-
-    @CanIgnoreReturnValue
-    CodeBlockJoiner merge(CodeBlockJoiner other) {
-      CodeBlock otherBlock = other.builder.build();
-      if (!otherBlock.isEmpty()) {
-        add(otherBlock);
-      }
-      return this;
-    }
-
-    CodeBlock join() {
-      return builder.build();
-    }
-  }
-
-  /**
-   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a
-   * newline.
-   */
-  static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
-    return stream(codeBlocks.spliterator(), false).collect(toConcatenatedCodeBlock());
+  static CodeBlock type(TypeMirror type) {
+    return CodeBlock.of("$T", type);
   }
 
   static CodeBlock stringLiteral(String toWrap) {
@@ -195,10 +138,8 @@ static CodeBlock javadocLinkTo(ExecutableElement executableElement) {
         executableElement
             .getParameters()
             .stream()
-            .map(VariableElement::asType)
-            .map(TypeName::get)
-            .map(TypeNames::rawTypeName)
-            .collect(toTypeNamesCodeBlock()));
+            .map(parameter -> CodeBlock.of("$T", rawTypeName(TypeName.get(parameter.asType()))))
+            .collect(toParametersCodeBlock()));
     return builder.add(")}").build();
   }
 
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index 6e6b24acc..5c2647571 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -16,18 +16,33 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.concat;
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.FeatureStatus.DISABLED;
+import static dagger.internal.codegen.FeatureStatus.ENABLED;
+import static dagger.internal.codegen.ValidationType.ERROR;
+import static dagger.internal.codegen.ValidationType.NONE;
+import static dagger.internal.codegen.ValidationType.WARNING;
+import static java.util.EnumSet.allOf;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.CheckReturnValue;
 import dagger.producers.Produces;
-import java.util.EnumSet;
+import java.util.Arrays;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.stream.Stream;
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
 import javax.tools.Diagnostic;
-import javax.tools.Diagnostic.Kind;
 
 /** A collection of options that dictate how the compiler will run. */
 @AutoValue
@@ -64,13 +79,20 @@
   abstract Diagnostic.Kind nullableValidationKind();
 
   boolean doCheckForNulls() {
-    return nullableValidationKind().equals(Kind.ERROR);
+    return nullableValidationKind().equals(Diagnostic.Kind.ERROR);
   }
 
   abstract Diagnostic.Kind privateMemberValidationKind();
 
   abstract Diagnostic.Kind staticMemberValidationKind();
 
+  /**
+   * If {@code true}, Dagger will generate factories and components even if some members-injected
+   * types have {@code private} or {@code static} {@code @Inject}-annotated members.
+   *
+   * <p>This should only ever be enabled by the TCK tests. Disabling this validation could lead to
+   * generating code that does not compile.
+   */
   abstract boolean ignorePrivateAndStaticInjectionForComponent();
 
   abstract ValidationType scopeCycleValidationType();
@@ -81,49 +103,35 @@ boolean doCheckForNulls() {
 
   abstract boolean aheadOfTimeSubcomponents();
 
-  /** See b/79859714 */
-  abstract boolean floatingBindsMethods();
+  abstract boolean useGradleIncrementalProcessing();
+
+  abstract ValidationType moduleBindingValidationType();
+
+  abstract Diagnostic.Kind moduleHasDifferentScopesDiagnosticKind();
 
   static Builder builder() {
-    return new AutoValue_CompilerOptions.Builder().headerCompilation(false);
+    return new AutoValue_CompilerOptions.Builder()
+        .headerCompilation(false)
+        .useGradleIncrementalProcessing(false);
+  }
+
+  static CompilerOptions create(ProcessingEnvironment processingEnv) {
+    Builder builder = new AutoValue_CompilerOptions.Builder();
+    for (Option option : concat(allOf(Feature.class), allOf(Validation.class))) {
+      option.set(builder, processingEnv);
+    }
+    return builder.build().validate();
   }
 
-  static CompilerOptions create(ProcessingEnvironment processingEnv, DaggerElements elements) {
+  CompilerOptions validate() {
     checkState(
-        !(fastInitEnabled(processingEnv)
-            && experimentalAndroidMode2FeatureStatus(processingEnv).equals(FeatureStatus.ENABLED)),
+        !(fastInit() && experimentalAndroidMode2()),
         "fastInit/experimentalAndroidMode and experimentalAndroidMode2 cannot be used together.");
-
-    return builder()
-        .usesProducers(elements.getTypeElement(Produces.class) != null)
-        .headerCompilation(processingEnv.getOptions().containsKey(HEADER_COMPILATION))
-        .fastInit(fastInitEnabled(processingEnv))
-        .experimentalAndroidMode2(
-            experimentalAndroidMode2FeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
-        .formatGeneratedSource(
-            formatGeneratedSourceFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
-        .writeProducerNameInToken(
-            writeProducerNameInTokenFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
-        .nullableValidationKind(nullableValidationType(processingEnv).diagnosticKind().get())
-        .privateMemberValidationKind(
-            privateMemberValidationType(processingEnv).diagnosticKind().get())
-        .staticMemberValidationKind(
-            staticMemberValidationType(processingEnv).diagnosticKind().get())
-        .ignorePrivateAndStaticInjectionForComponent(
-            ignorePrivateAndStaticInjectionForComponentFeatureStatus(processingEnv)
-                .equals(FeatureStatus.DISABLED))
-        .scopeCycleValidationType(scopeValidationType(processingEnv))
-        .warnIfInjectionFactoryNotGeneratedUpstream(
-            warnIfInjectionFactoryNotGeneratedUpstreamFeatureStatus(processingEnv)
-                .equals(FeatureStatus.ENABLED))
-        .aheadOfTimeSubcomponents(
-            aheadOfTimeSubcomponentsFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
-        .floatingBindsMethods(
-            floatingBindsMethodsFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
-        .build();
+    return this;
   }
 
   @AutoValue.Builder
+  @CanIgnoreReturnValue
   interface Builder {
     Builder usesProducers(boolean usesProduces);
 
@@ -153,177 +161,208 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
 
     Builder aheadOfTimeSubcomponents(boolean aheadOfTimeSubcomponents);
 
-    Builder floatingBindsMethods(boolean enabled);
+    Builder useGradleIncrementalProcessing(boolean enabled);
+
+    Builder moduleBindingValidationType(ValidationType validationType);
 
+    Builder moduleHasDifferentScopesDiagnosticKind(Diagnostic.Kind kind);
+
+    @CheckReturnValue
     CompilerOptions build();
   }
 
-  private static final String HEADER_COMPILATION = "experimental_turbine_hjar";
+  /** An option that can be set into {@link CompilerOptions}. */
+  private interface Option {
 
-  static final String FAST_INIT = "dagger.fastInit";
+    /** Sets the appropriate property on a {@link CompilerOptions.Builder}. */
+    void set(Builder builder, ProcessingEnvironment processingEnvironment);
 
-  // TODO(user): Remove once all usages are migrated to FAST_INIT.
-  static final String EXPERIMENTAL_ANDROID_MODE = "dagger.experimentalAndroidMode";
+    /**
+     * {@code true} if {@link #toString()} represents a {@linkplain Processor#getSupportedOptions()
+     * supported command line option}.
+     */
+    default boolean useCommandLineOption() {
+      return true;
+    }
+  }
 
-  static final String EXPERIMENTAL_ANDROID_MODE2 = "dagger.experimentalAndroidMode2";
+  /** A feature that can be enabled or disabled. */
+  private enum Feature implements Option {
+    HEADER_COMPILATION(Builder::headerCompilation) {
+      @Override
+      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+        return processingEnvironment.getOptions().containsKey(toString());
+      }
 
-  static final String FORMAT_GENERATED_SOURCE = "dagger.formatGeneratedSource";
+      @Override
+      public String toString() {
+        return "experimental_turbine_hjar";
+      }
+    },
 
-  static final String WRITE_PRODUCER_NAME_IN_TOKEN_KEY = "dagger.writeProducerNameInToken";
+    FAST_INIT(Builder::fastInit) {
+      @Override
+      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+        return super.isEnabled(processingEnvironment)
+            || EXPERIMENTAL_ANDROID_MODE.isEnabled(processingEnvironment);
+      }
+    },
 
-  static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
-      "dagger.disableInterComponentScopeValidation";
+    // TODO(user): Remove once all usages are migrated to FAST_INIT.
+    EXPERIMENTAL_ANDROID_MODE((builder, enabled) -> {}),
 
-  static final String NULLABLE_VALIDATION_KEY = "dagger.nullableValidation";
+    EXPERIMENTAL_ANDROID_MODE2(Builder::experimentalAndroidMode2),
 
-  static final String PRIVATE_MEMBER_VALIDATION_TYPE_KEY = "dagger.privateMemberValidation";
+    FORMAT_GENERATED_SOURCE(Builder::formatGeneratedSource, ENABLED),
 
-  static final String STATIC_MEMBER_VALIDATION_TYPE_KEY = "dagger.staticMemberValidation";
+    WRITE_PRODUCER_NAME_IN_TOKEN(Builder::writeProducerNameInToken),
 
-  static final String WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY =
-      "dagger.warnIfInjectionFactoryNotGeneratedUpstream";
+    WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM(
+        Builder::warnIfInjectionFactoryNotGeneratedUpstream),
 
-  /**
-   * If true, Dagger will generate factories and components even if some members-injected types have
-   * private or static {@code @Inject}-annotated members.
-   *
-   * <p>This defaults to false, and should only ever be enabled by the TCK tests. Disabling this
-   * validation could lead to generating code that does not compile.
-   */
-  static final String IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT =
-      "dagger.ignorePrivateAndStaticInjectionForComponent";
+    IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT(
+        Builder::ignorePrivateAndStaticInjectionForComponent),
 
-  static final String AHEAD_OF_TIME_COMPONENTS_KEY = "dagger.experimentalAheadOfTimeSubcomponents";
+    EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS(Builder::aheadOfTimeSubcomponents),
 
-  static final String FLOATING_BINDS_METHODS_KEY = "dagger.floatingBindsMethods";
+    FLOATING_BINDS_METHODS((builder, ignoredValue) -> {}) {
+     @Override
+      public void set(Builder builder, ProcessingEnvironment processingEnvironment) {
+        if (processingEnvironment.getOptions().containsKey(toString())) {
+          processingEnvironment
+            .getMessager()
+            .printMessage(
+                Diagnostic.Kind.WARNING,
+                toString() + " is no longer a recognized option by Dagger");
+        }
+      }
+    },
 
-  static final String GRADLE_INCREMENTAL = "dagger.gradle.incremental";
+    USE_GRADLE_INCREMENTAL_PROCESSING(Builder::useGradleIncrementalProcessing) {
+      @Override
+      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+        return processingEnvironment.getOptions().containsKey(toString());
+      }
 
-  static final ImmutableSet<String> SUPPORTED_OPTIONS =
-      ImmutableSet.of(
-          FAST_INIT,
-          EXPERIMENTAL_ANDROID_MODE,
-          HEADER_COMPILATION,
-          FORMAT_GENERATED_SOURCE,
-          WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
-          DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-          NULLABLE_VALIDATION_KEY,
-          PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-          STATIC_MEMBER_VALIDATION_TYPE_KEY,
-          WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
-          IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,
-          AHEAD_OF_TIME_COMPONENTS_KEY,
-          FLOATING_BINDS_METHODS_KEY,
-          GRADLE_INCREMENTAL);
-
-  private static boolean fastInitEnabled(ProcessingEnvironment processingEnv) {
-    return valueOf(
-            processingEnv,
-            FAST_INIT,
-            FeatureStatus.DISABLED,
-            EnumSet.allOf(FeatureStatus.class))
-        .equals(FeatureStatus.ENABLED)
-      || valueOf(
-            processingEnv,
-            EXPERIMENTAL_ANDROID_MODE,
-            FeatureStatus.DISABLED,
-            EnumSet.allOf(FeatureStatus.class))
-        .equals(FeatureStatus.ENABLED);
-  }
+      @Override
+      public String toString() {
+        return "dagger.gradle.incremental";
+      }
+    },
+
+    USES_PRODUCERS(Builder::usesProducers) {
+      @Override
+      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+        return processingEnvironment
+                .getElementUtils()
+                .getTypeElement(Produces.class.getCanonicalName())
+            != null;
+      }
 
-  private static FeatureStatus experimentalAndroidMode2FeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        EXPERIMENTAL_ANDROID_MODE2,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
-  }
+      @Override
+      public boolean useCommandLineOption() {
+        return false;
+      }
+    },
+    ;
 
-  private static FeatureStatus formatGeneratedSourceFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        FORMAT_GENERATED_SOURCE,
-        FeatureStatus.ENABLED,
-        EnumSet.allOf(FeatureStatus.class));
-  }
+    final FeatureStatus defaultValue;
+    final BiConsumer<Builder, Boolean> setter;
 
-  private static FeatureStatus writeProducerNameInTokenFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
-  }
+    Feature(BiConsumer<Builder, Boolean> setter) {
+      this(setter, DISABLED);
+    }
 
-  private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        ValidationType.ERROR,
-        EnumSet.allOf(ValidationType.class));
-  }
+    Feature(BiConsumer<Builder, Boolean> setter, FeatureStatus defaultValue) {
+      this.setter = setter;
+      this.defaultValue = defaultValue;
+    }
 
-  private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        NULLABLE_VALIDATION_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
+    @Override
+    public void set(Builder builder, ProcessingEnvironment processingEnvironment) {
+      setter.accept(builder, isEnabled(processingEnvironment));
+    }
 
-  private static ValidationType privateMemberValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
+    boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+      return CompilerOptions.valueOf(
+              processingEnvironment, toString(), defaultValue, allOf(FeatureStatus.class))
+          .equals(ENABLED);
+    }
 
-  private static ValidationType staticMemberValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        STATIC_MEMBER_VALIDATION_TYPE_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+    @Override
+    public String toString() {
+      return optionName(name());
+    }
   }
 
-  private static FeatureStatus ignorePrivateAndStaticInjectionForComponentFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
-  }
+  /** The diagnostic kind or validation type for a kind of validation. */
+  private enum Validation implements Option {
+    DISABLE_INTER_COMPONENT_SCOPE_VALIDATION(Builder::scopeCycleValidationType),
 
-  private static FeatureStatus warnIfInjectionFactoryNotGeneratedUpstreamFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
-  }
+    NULLABLE_VALIDATION(kindSetter(Builder::nullableValidationKind), ERROR, WARNING) {
+    },
+
+    PRIVATE_MEMBER_VALIDATION(kindSetter(Builder::privateMemberValidationKind), ERROR, WARNING),
+
+    STATIC_MEMBER_VALIDATION(kindSetter(Builder::staticMemberValidationKind), ERROR, WARNING),
+
+    /** Whether to validate partial binding graphs associated with modules. */
+    MODULE_BINDING_VALIDATION(Builder::moduleBindingValidationType, NONE, ERROR, WARNING),
+
+    /**
+     * How to report conflicting scoped bindings when validating partial binding graphs associated
+     * with modules.
+     */
+    MODULE_HAS_DIFFERENT_SCOPES_VALIDATION(
+        kindSetter(Builder::moduleHasDifferentScopesDiagnosticKind), ERROR, WARNING),
+    ;
 
-  private static FeatureStatus aheadOfTimeSubcomponentsFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        AHEAD_OF_TIME_COMPONENTS_KEY,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
+    static BiConsumer<Builder, ValidationType> kindSetter(
+        BiConsumer<Builder, Diagnostic.Kind> setter) {
+      return (builder, validationType) ->
+          setter.accept(builder, validationType.diagnosticKind().get());
+    }
+
+    final ValidationType defaultType;
+    final ImmutableSet<ValidationType> validTypes;
+    final BiConsumer<Builder, ValidationType> setter;
+
+    Validation(BiConsumer<Builder, ValidationType> setter) {
+      this(setter, ERROR, WARNING, NONE);
+    }
+
+    Validation(
+        BiConsumer<Builder, ValidationType> setter,
+        ValidationType defaultType,
+        ValidationType... moreValidTypes) {
+      this.setter = setter;
+      this.defaultType = defaultType;
+      this.validTypes = immutableEnumSet(defaultType, moreValidTypes);
+    }
+
+    @Override
+    public void set(Builder builder, ProcessingEnvironment processingEnvironment) {
+      setter.accept(builder, validationType(processingEnvironment));
+    }
+
+    ValidationType validationType(ProcessingEnvironment processingEnvironment) {
+      return CompilerOptions.valueOf(processingEnvironment, toString(), defaultType, validTypes);
+    }
+
+    @Override
+    public String toString() {
+      return optionName(name());
+    }
   }
 
-  private static FeatureStatus floatingBindsMethodsFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        FLOATING_BINDS_METHODS_KEY,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
+  static final ImmutableSet<String> SUPPORTED_OPTIONS =
+      Stream.<Option>concat(Arrays.stream(Feature.values()), Arrays.stream(Validation.values()))
+          .filter(Option::useCommandLineOption)
+          .map(Object::toString)
+          .collect(toImmutableSet());
+
+  private static String optionName(String enumName) {
+    return "dagger." + UPPER_UNDERSCORE.to(LOWER_CAMEL, enumName);
   }
 
   private static <T extends Enum<T>> T valueOf(
@@ -347,12 +386,10 @@ private static FeatureStatus floatingBindsMethodsFeatureStatus(
               .getMessager()
               .printMessage(
                   Diagnostic.Kind.ERROR,
-                  "Processor option -A"
-                      + key
-                      + " may only have the values "
-                      + validValues
-                      + " (case insensitive), found: "
-                      + options.get(key));
+                  String.format(
+                      "Processor option -A%s may only have the values %s "
+                          + "(case insensitive), found: %s",
+                      key, validValues, options.get(key)));
         }
       }
     }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index add74973e..f715ca47f 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -18,20 +18,20 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
 import static dagger.internal.codegen.MemberSelect.staticFactoryCreation;
+import static dagger.internal.codegen.RequestKinds.isDerivedFromProvider;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.model.BindingKind.DELEGATE;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static dagger.model.BindingKind.MULTIBOUND_SET;
-import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
@@ -40,10 +40,7 @@
 import com.squareup.javapoet.MethodSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
-import dagger.model.Key;
 import dagger.model.RequestKind;
 import java.util.HashMap;
 import java.util.Map;
@@ -53,17 +50,14 @@
 
 /** A central repository of code expressions used to access any binding available to a component. */
 final class ComponentBindingExpressions {
-
-  // TODO(dpb,ronshapiro): refactor this and ComponentRequirementFields into a
+  // TODO(dpb,ronshapiro): refactor this and ComponentRequirementExpressions into a
   // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
   // parents? If so, maybe make BindingExpression.Factory create it.
 
   private final Optional<ComponentBindingExpressions> parent;
   private final BindingGraph graph;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final SubcomponentNames subcomponentNames;
-  private final ComponentRequirementFields componentRequirementFields;
-  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
+  private final ComponentImplementation componentImplementation;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
   private final OptionalFactories optionalFactories;
   private final DaggerTypes types;
   private final DaggerElements elements;
@@ -71,13 +65,13 @@
   private final MembersInjectionMethods membersInjectionMethods;
   private final InnerSwitchingProviders innerSwitchingProviders;
   private final StaticSwitchingProviders staticSwitchingProviders;
+  private final ModifiableBindingExpressions modifiableBindingExpressions;
   private final Map<BindingRequest, BindingExpression> expressions = new HashMap<>();
 
   ComponentBindingExpressions(
       BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
-      SubcomponentNames subcomponentNames,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentImplementation componentImplementation,
+      ComponentRequirementExpressions componentRequirementExpressions,
       OptionalFactories optionalFactories,
       DaggerTypes types,
       DaggerElements elements,
@@ -85,11 +79,9 @@
     this(
         Optional.empty(),
         graph,
-        generatedComponentModel,
-        subcomponentNames,
-        componentRequirementFields,
-        new ReferenceReleasingManagerFields(graph, generatedComponentModel, compilerOptions),
-        new StaticSwitchingProviders(generatedComponentModel, types),
+        componentImplementation,
+        componentRequirementExpressions,
+        new StaticSwitchingProviders(componentImplementation, types),
         optionalFactories,
         types,
         elements,
@@ -99,10 +91,8 @@
   private ComponentBindingExpressions(
       Optional<ComponentBindingExpressions> parent,
       BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
-      SubcomponentNames subcomponentNames,
-      ComponentRequirementFields componentRequirementFields,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields,
+      ComponentImplementation componentImplementation,
+      ComponentRequirementExpressions componentRequirementExpressions,
       StaticSwitchingProviders staticSwitchingProviders,
       OptionalFactories optionalFactories,
       DaggerTypes types,
@@ -110,19 +100,25 @@ private ComponentBindingExpressions(
       CompilerOptions compilerOptions) {
     this.parent = parent;
     this.graph = graph;
-    this.generatedComponentModel = generatedComponentModel;
-    this.subcomponentNames = checkNotNull(subcomponentNames);
-    this.componentRequirementFields = checkNotNull(componentRequirementFields);
-    this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
+    this.componentImplementation = componentImplementation;
+    this.componentRequirementExpressions = checkNotNull(componentRequirementExpressions);
     this.optionalFactories = checkNotNull(optionalFactories);
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
     this.compilerOptions = checkNotNull(compilerOptions);
     this.membersInjectionMethods =
-        new MembersInjectionMethods(generatedComponentModel, this, graph, elements, types);
+        new MembersInjectionMethods(componentImplementation, this, graph, elements, types);
     this.innerSwitchingProviders =
-        new InnerSwitchingProviders(generatedComponentModel, this, types);
+        new InnerSwitchingProviders(componentImplementation, this, types);
     this.staticSwitchingProviders = staticSwitchingProviders;
+    this.modifiableBindingExpressions =
+        new ModifiableBindingExpressions(
+            parent.map(cbe -> cbe.modifiableBindingExpressions),
+            this,
+            graph,
+            componentImplementation,
+            compilerOptions,
+            types);
   }
 
   /**
@@ -130,15 +126,13 @@ private ComponentBindingExpressions(
    */
   ComponentBindingExpressions forChildComponent(
       BindingGraph childGraph,
-      GeneratedComponentModel childComponentModel,
-      ComponentRequirementFields childComponentRequirementFields) {
+      ComponentImplementation childComponentImplementation,
+      ComponentRequirementExpressions childComponentRequirementExpressions) {
     return new ComponentBindingExpressions(
         Optional.of(this),
         childGraph,
-        childComponentModel,
-        subcomponentNames,
-        childComponentRequirementFields,
-        referenceReleasingManagerFields,
+        childComponentImplementation,
+        childComponentRequirementExpressions,
         staticSwitchingProviders,
         optionalFactories,
         types,
@@ -146,65 +140,38 @@ ComponentBindingExpressions forChildComponent(
         compilerOptions);
   }
 
-  /**
-   * Returns an expression that evaluates to the value of a dependency request for a binding owned
-   * by this component or an ancestor.
-   *
-   * @param requestingClass the class that will contain the expression
-   * @throws IllegalStateException if there is no binding expression that satisfies the dependency
-   *     request
-   */
-  Expression getDependencyExpression(Key key, RequestKind requestKind, ClassName requestingClass) {
-    return getDependencyExpression(
-        BindingRequest.forDependencyRequest(key, requestKind), requestingClass);
+  /* Returns the {@link ModifiableBindingExpressions} for this component. */
+  ModifiableBindingExpressions modifiableBindingExpressions() {
+    return modifiableBindingExpressions;
   }
 
   /**
-   * Returns an expression that evaluates to the value of a dependency request for a binding owned
-   * by this component or an ancestor.
-   *
-   * @param requestingClass the class that will contain the expression
-   * @throws IllegalStateException if there is no binding expression that satisfies the dependency
-   *     request
-   */
-  Expression getDependencyExpression(DependencyRequest request, ClassName requestingClass) {
-    return getDependencyExpression(BindingRequest.forDependencyRequest(request), requestingClass);
-  }
-
-  /**
-   * Returns an expression that evaluates to the value of a framework dependency for a binding owned
-   * in this component or an ancestor.
+   * Returns an expression that evaluates to the value of a binding request for a binding owned by
+   * this component or an ancestor.
    *
    * @param requestingClass the class that will contain the expression
-   * @throws IllegalStateException if there is no binding expression that satisfies the dependency
-   *     request
+   * @throws IllegalStateException if there is no binding expression that satisfies the request
    */
-  Expression getDependencyExpression(
-      FrameworkDependency frameworkDependency, ClassName requestingClass) {
-    return getDependencyExpression(
-        BindingRequest.forFrameworkDependency(frameworkDependency), requestingClass);
+  Expression getDependencyExpression(BindingRequest request, ClassName requestingClass) {
+    return getBindingExpression(request).getDependencyExpression(requestingClass);
   }
 
   /**
-   * Returns an expression that evaluates to the value of a framework request for a binding owned by
-   * this component or an ancestor.
+   * Equivalent to {@link #getDependencyExpression(BindingRequest, ClassName)} that is used only
+   * when the request is for implementation of a component method.
    *
-   * @param requestingClass the class that will contain the expression
-   * @throws IllegalStateException if there is no binding expression that satisfies the framework
-   *     request
+   * @throws IllegalStateException if there is no binding expression that satisfies the request
    */
-  Expression getDependencyExpression(
-      Key key, FrameworkType frameworkType, ClassName requestingClass) {
-    return getDependencyExpression(
-        BindingRequest.forFrameworkDependency(key, frameworkType), requestingClass);
-  }
-
-  private Expression getDependencyExpression(BindingRequest request, ClassName requestingClass) {
-    return getBindingExpression(request).getDependencyExpression(requestingClass);
+  Expression getDependencyExpressionForComponentMethod(
+      BindingRequest request,
+      ComponentMethodDescriptor componentMethod,
+      ComponentImplementation componentImplementation) {
+    return getBindingExpression(request)
+        .getDependencyExpressionForComponentMethod(componentMethod, componentImplementation);
   }
 
   /**
-   * Returns the {@link CodeBlock} for the method argmuments used with the factory {@code create()}
+   * Returns the {@link CodeBlock} for the method arguments used with the factory {@code create()}
    * method for the given {@link ContributionBinding binding}.
    */
   CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
@@ -216,15 +183,14 @@ CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
 
     if (binding.requiresModuleInstance()) {
       arguments.add(
-          componentRequirementFields.getExpressionDuringInitialization(
+          componentRequirementExpressions.getExpressionDuringInitialization(
               ComponentRequirement.forModule(binding.contributingModule().get().asType()),
-              generatedComponentModel.name()));
+              componentImplementation.name()));
     }
 
-    binding
-        .frameworkDependencies()
-        .stream()
-        .map(dependency -> getDependencyExpression(dependency, generatedComponentModel.name()))
+    binding.frameworkDependencies().stream()
+        .map(BindingRequest::bindingRequest)
+        .map(request -> getDependencyExpression(request, componentImplementation.name()))
         .map(Expression::codeBlock)
         .forEach(arguments::add);
 
@@ -241,12 +207,12 @@ CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
    *
    * @param requestingClass the class that will contain the expression
    */
-  // TODO(b/64024402) Merge with getDependencyExpression(DependencyRequest, ClassName) if possible.
   Expression getDependencyArgumentExpression(
       DependencyRequest dependencyRequest, ClassName requestingClass) {
 
     TypeMirror dependencyType = dependencyRequest.key().type();
-    Expression dependencyExpression = getDependencyExpression(dependencyRequest, requestingClass);
+    Expression dependencyExpression =
+        getDependencyExpression(bindingRequest(dependencyRequest), requestingClass);
 
     if (dependencyRequest.kind().equals(RequestKind.INSTANCE)
         && !isTypeAccessibleFrom(dependencyType, requestingClass.packageName())
@@ -257,143 +223,44 @@ Expression getDependencyArgumentExpression(
     return dependencyExpression;
   }
 
-  /**
-   * Returns the implementation of a component method. Returns {@link Optional#empty} if the
-   * component method implementation should not be emitted.
-   */
-  Optional<MethodSpec> getComponentMethod(ComponentMethodDescriptor componentMethod) {
+  /** Returns the implementation of a component method. */
+  MethodSpec getComponentMethod(ComponentMethodDescriptor componentMethod) {
     checkArgument(componentMethod.dependencyRequest().isPresent());
-    BindingRequest request =
-        BindingRequest.forDependencyRequest(componentMethod.dependencyRequest().get());
-    MethodSpec method =
-        MethodSpec.overriding(
-                componentMethod.methodElement(),
-                MoreTypes.asDeclared(graph.componentType().asType()),
-                types)
-            .addCode(
-                getBindingExpression(request)
-                    .getComponentMethodImplementation(componentMethod, generatedComponentModel))
-            .build();
-
-    ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
-    if (modifiableBindingType.isModifiable()) {
-      generatedComponentModel.registerModifiableBindingMethod(
-          modifiableBindingType,
-          request,
-          method,
-          newModifiableBindingWillBeFinalized(modifiableBindingType, request));
-      if (!modifiableBindingType.hasBaseClassImplementation()) {
-        // A component method should not be emitted if it encapsulates a modifiable binding that
-        // cannot be satisfied by the abstract base class implementation of a subcomponent.
-        checkState(
-            !generatedComponentModel.supermodel().isPresent(),
-            "Attempting to generate a component method in a subtype of the abstract subcomponent "
-                + "base class.");
-        return Optional.empty();
-      }
-    }
-
-    return Optional.of(method);
-  }
-
-  /**
-   * Returns the implementation of a modifiable binding method originally defined in a supertype
-   * implementation of this subcomponent. Returns {@link Optional#empty()} when the binding cannot
-   * or should not be modified by the current binding graph. This is only relevant for ahead-of-time
-   * subcomponents.
-   */
-  Optional<ModifiableBindingMethod> getModifiableBindingMethod(
-      ModifiableBindingMethod modifiableBindingMethod) {
-    if (shouldModifyKnownBinding(modifiableBindingMethod)) {
-      MethodSpec baseMethod = modifiableBindingMethod.methodSpec();
-      return Optional.of(
-          ModifiableBindingMethod.implement(
-              modifiableBindingMethod,
-              MethodSpec.methodBuilder(baseMethod.name)
-                  .addModifiers(PUBLIC)
-                  // TODO(b/72748365): Mark method as final if binding should not be further
-                  // modified.
-                  .returns(baseMethod.returnType)
-                  .addAnnotation(Override.class)
-                  .addCode(
-                      getBindingExpression(modifiableBindingMethod.request())
-                          .getModifiableBindingMethodImplementation(
-                              modifiableBindingMethod, generatedComponentModel))
-                  .build(),
-              knownModifiableBindingWillBeFinalized(modifiableBindingMethod)));
-    }
-    return Optional.empty();
-  }
-
-  /**
-   * Returns true if a modifiable binding method that was registered in a superclass implementation
-   * of this subcomponent should be marked as "finalized" if it is being overridden by this
-   * subcomponent implementation. "Finalized" means we should not attempt to modify the binding in
-   * any subcomponent subclass. This is only relevant for ahead-of-time subcomponents.
-   */
-  // TODO(user): extract a ModifiableBindingExpressions class? This may need some dependencies
-  // (like the GCM) but could remove some concerns from this class
-  private boolean knownModifiableBindingWillBeFinalized(
-      ModifiableBindingMethod modifiableBindingMethod) {
-    ModifiableBindingType newModifiableBindingType =
-        getModifiableBindingType(modifiableBindingMethod.request());
-    if (!newModifiableBindingType.isModifiable()) {
-      // If a modifiable binding has become non-modifiable it is final by definition.
-      return true;
-    }
-    // All currently supported modifiable types are finalized upon modification.
-    return modifiableBindingWillBeFinalized(
-        newModifiableBindingType,
-        shouldModifyBinding(newModifiableBindingType, modifiableBindingMethod.request()));
-  }
-
-  /**
-   * Returns true if a newly discovered modifiable binding method, once it is defined in this
-   * subcomponent implementation, should be marked as "finalized", meaning we should not attempt to
-   * modify the binding in any subcomponent subclass. This is only relevant for ahead-of-time
-   * subcomponents.
-   */
-  private boolean newModifiableBindingWillBeFinalized(
-      ModifiableBindingType modifiableBindingType, BindingRequest request) {
-    return modifiableBindingWillBeFinalized(
-        modifiableBindingType, shouldModifyBinding(modifiableBindingType, request));
-  }
-
-  /**
-   * Returns true if we shouldn't attempt to further modify a modifiable binding once we complete
-   * the implementation for the current subcomponent.
-   */
-  private boolean modifiableBindingWillBeFinalized(
-      ModifiableBindingType modifiableBindingType, boolean modifyingBinding) {
-    switch (modifiableBindingType) {
-      case MISSING:
-      case GENERATED_INSTANCE:
-      case OPTIONAL:
-      case INJECTION:
-        // Once we modify any of the above a single time, then they are finalized.
-        return modifyingBinding;
-      case MULTIBINDING:
-        return false;
-      default:
-        throw new IllegalStateException(
-            String.format(
-                "Building binding expression for unsupported ModifiableBindingType [%s].",
-                modifiableBindingType));
-    }
-  }
-
-  private BindingExpression getBindingExpression(BindingRequest request) {
+    BindingRequest request = bindingRequest(componentMethod.dependencyRequest().get());
+    return MethodSpec.overriding(
+            componentMethod.methodElement(),
+            MoreTypes.asDeclared(graph.componentTypeElement().asType()),
+            types)
+        .addCode(
+            getBindingExpression(request)
+                .getComponentMethodImplementation(componentMethod, componentImplementation))
+        .build();
+  }
+
+  /** Returns the {@link BindingExpression} for the given {@link BindingRequest}. */
+  BindingExpression getBindingExpression(BindingRequest request) {
     if (expressions.containsKey(request)) {
       return expressions.get(request);
     }
-    Optional<BindingExpression> expression = Optional.empty();
-    ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
-    if (modifiableBindingType.isModifiable()) {
-      expression = Optional.of(createModifiableBindingExpression(modifiableBindingType, request));
-    } else if (resolvedInThisComponent(request)) {
+    Optional<BindingExpression> expression =
+        modifiableBindingExpressions.maybeCreateModifiableBindingExpression(request);
+    if (!expression.isPresent()) {
       ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-      expression = Optional.of(createBindingExpression(resolvedBindings, request));
+      if (resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty()) {
+        expression = Optional.of(createBindingExpression(resolvedBindings, request));
+      }
+    }
+    if (!expression.isPresent()
+        && compilerOptions.aheadOfTimeSubcomponents()
+        && request.requestKind().isPresent()
+        && isDerivedFromProvider(request.requestKind().get())) {
+      RequestKind requestKind = request.requestKind().get();
+      expression =
+          Optional.of(
+              new DerivedFromFrameworkInstanceBindingExpression(
+                  request.key(), FrameworkType.PROVIDER, requestKind, this, types));
     }
+
     if (expression.isPresent()) {
       expressions.put(request, expression.get());
       return expression.get();
@@ -403,7 +270,7 @@ private BindingExpression getBindingExpression(BindingRequest request) {
   }
 
   /** Creates a binding expression. */
-  private BindingExpression createBindingExpression(
+  BindingExpression createBindingExpression(
       ResolvedBindings resolvedBindings, BindingRequest request) {
     switch (resolvedBindings.bindingType()) {
       case MEMBERS_INJECTION:
@@ -421,166 +288,11 @@ private BindingExpression createBindingExpression(
     }
   }
 
-  /**
-   * Creates a binding expression for a binding that may be modified across implementations of a
-   * subcomponent. This is only relevant for ahead-of-time subcomponents.
-   */
-  private BindingExpression createModifiableBindingExpression(
-      ModifiableBindingType type, BindingRequest request) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-    Optional<ModifiableBindingMethod> matchingModifiableBindingMethod =
-        generatedComponentModel.getModifiableBindingMethod(request);
-    Optional<ComponentMethodDescriptor> matchingComponentMethod =
-        findMatchingComponentMethod(request);
-    switch (type) {
-      case GENERATED_INSTANCE:
-        return new GeneratedInstanceBindingExpression(
-            generatedComponentModel,
-            resolvedBindings,
-            request,
-            matchingModifiableBindingMethod,
-            matchingComponentMethod);
-      case MISSING:
-        return new MissingBindingExpression(
-            generatedComponentModel,
-            request,
-            matchingModifiableBindingMethod,
-            matchingComponentMethod);
-      case OPTIONAL:
-      case MULTIBINDING:
-      case INJECTION:
-        return wrapInMethod(
-            resolvedBindings, request, createBindingExpression(resolvedBindings, request));
-      default:
-        throw new IllegalStateException(
-            String.format(
-                "Building binding expression for unsupported ModifiableBindingType [%s].", type));
-    }
-  }
-
-  /**
-   * The reason why a binding may need to be modified across implementations of a subcomponent, if
-   * at all. This is only relevant for ahead-of-time subcomponents.
-   */
-  private ModifiableBindingType getModifiableBindingType(BindingRequest request) {
-    if (!compilerOptions.aheadOfTimeSubcomponents()) {
-      return ModifiableBindingType.NONE;
-    }
-
-    // When generating a final (concrete) implementation of a (sub)component the binding is no
-    // longer considered modifiable. It cannot be further modified by a subclass implementation.
-    if (!generatedComponentModel.isAbstract()) {
-      return ModifiableBindingType.NONE;
-    }
-
-    if (resolvedInThisComponent(request)) {
-      ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-      if (resolvedBindings.contributionBindings().isEmpty()) {
-        // TODO(ronshapiro): Confirm whether a resolved binding must have a single contribution
-        // binding.
-        return ModifiableBindingType.NONE;
-      }
-
-      ContributionBinding binding = resolvedBindings.contributionBinding();
-      if (binding.requiresGeneratedInstance()) {
-        return ModifiableBindingType.GENERATED_INSTANCE;
-      }
-
-      if (binding.kind().equals(BindingKind.OPTIONAL)) {
-        return ModifiableBindingType.OPTIONAL;
-      }
-
-      if (resolvedBindings.bindingType().equals(BindingType.PROVISION)
-          && binding.isSyntheticMultibinding()) {
-        return ModifiableBindingType.MULTIBINDING;
-      }
-
-      if (binding.kind().equals(BindingKind.INJECTION)) {
-        return ModifiableBindingType.INJECTION;
-      }
-    } else if (!resolvableBinding(request)) {
-      return ModifiableBindingType.MISSING;
-    }
-
-    return ModifiableBindingType.NONE;
-  }
-
-  /**
-   * Returns true if the current binding graph can, and should, modify a binding by overriding a
-   * modifiable binding method. This is only relevant for ahead-of-time subcomponents.
-   */
-  private boolean shouldModifyKnownBinding(ModifiableBindingMethod modifiableBindingMethod) {
-    ModifiableBindingType newModifiableBindingType =
-        getModifiableBindingType(modifiableBindingMethod.request());
-    if (!newModifiableBindingType.equals(modifiableBindingMethod.type())) {
-      // It is possible that a binding can change types, in which case we should always modify the
-      // binding.
-      return true;
-    }
-    return shouldModifyBinding(modifiableBindingMethod.type(), modifiableBindingMethod.request());
-  }
-
-  /**
-   * Returns true if the current binding graph can, and should, modify a binding by overriding a
-   * modifiable binding method. This is only relevant for ahead-of-time subcomponents.
-   */
-  private boolean shouldModifyBinding(
-      ModifiableBindingType modifiableBindingType, BindingRequest request) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-    switch (modifiableBindingType) {
-      case GENERATED_INSTANCE:
-        return !generatedComponentModel.isAbstract();
-      case MISSING:
-        // TODO(b/72748365): investigate beder@'s comment about having intermediate component
-        // ancestors satisfy missing bindings of their children with their own missing binding
-        // methods so that we can minimize the cases where we need to reach into doubly-nested
-        // descendant component implementations
-        return resolvableBinding(request);
-      case OPTIONAL:
-        // Only override optional binding methods if we have a non-empty binding.
-        return !resolvedBindings.contributionBinding().dependencies().isEmpty();
-      case MULTIBINDING:
-        // Only modify a multibinding if there are new contributions.
-        return !generatedComponentModel
-            .superclassContributionsMade(request.key())
-            .containsAll(resolvedBindings.contributionBinding().dependencies());
-      case INJECTION:
-        return !resolvedBindings.contributionBinding().kind().equals(BindingKind.INJECTION);
-      default:
-        throw new IllegalStateException(
-            String.format(
-                "Overriding modifiable binding method with unsupported ModifiableBindingType [%s].",
-                modifiableBindingType));
-    }
-  }
-
-  /**
-   * Returns true if the binding can be resolved by the graph for this component or any parent
-   * component.
-   */
-  private boolean resolvableBinding(BindingRequest request) {
-    for (ComponentBindingExpressions expressions = this;
-        expressions != null;
-        expressions = expressions.parent.orElse(null)) {
-      if (expressions.resolvedInThisComponent(request)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /** Returns true if the binding can be resolved by the graph for this component. */
-  private boolean resolvedInThisComponent(BindingRequest request) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-    return resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty();
-  }
-
   /**
    * Returns a binding expression that uses a {@link javax.inject.Provider} for provision bindings
    * or a {@link dagger.producers.Producer} for production bindings.
    */
-  private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
-      ResolvedBindings resolvedBindings) {
+  private BindingExpression frameworkInstanceBindingExpression(ResolvedBindings resolvedBindings) {
     // TODO(user): Consider merging the static factory creation logic into CreationExpressions?
     Optional<MemberSelect> staticMethod =
         useStaticFactoryCreation(resolvedBindings.contributionBinding())
@@ -594,15 +306,15 @@ private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
         staticMethod.isPresent()
             ? staticMethod::get
             : new FrameworkFieldInitializer(
-                generatedComponentModel, resolvedBindings, frameworkInstanceCreationExpression);
+                componentImplementation, resolvedBindings, frameworkInstanceCreationExpression);
 
     switch (resolvedBindings.bindingType()) {
       case PROVISION:
         return new ProviderInstanceBindingExpression(
             resolvedBindings, frameworkInstanceSupplier, types, elements);
       case PRODUCTION:
-        return new ProducerInstanceBindingExpression(
-            resolvedBindings, frameworkInstanceSupplier, types, elements);
+        return new ProducerNodeInstanceBindingExpression(
+            resolvedBindings, frameworkInstanceSupplier, types, elements, componentImplementation);
       default:
         throw new AssertionError("invalid binding type: " + resolvedBindings.bindingType());
     }
@@ -610,21 +322,11 @@ private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
 
   private FrameworkInstanceCreationExpression scope(
       ResolvedBindings resolvedBindings, FrameworkInstanceCreationExpression unscoped) {
-    if (requiresReleasableReferences(resolvedBindings)) {
-      return () ->
-          CodeBlock.of(
-              "$T.create($L, $L)",
-              REFERENCE_RELEASING_PROVIDER,
-              unscoped.creationExpression(),
-              referenceReleasingManagerFields.getExpression(
-                  resolvedBindings.scope().get(), generatedComponentModel.name()));
-    } else {
-      return () ->
-          CodeBlock.of(
-              "$T.provider($L)",
-              resolvedBindings.scope().get().isReusable() ? SINGLE_CHECK : DOUBLE_CHECK,
-              unscoped.creationExpression());
-    }
+    return () ->
+        CodeBlock.of(
+            "$T.provider($L)",
+            resolvedBindings.scope().get().isReusable() ? SINGLE_CHECK : DOUBLE_CHECK,
+            unscoped.creationExpression());
   }
 
   /**
@@ -651,11 +353,15 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
 
       case COMPONENT_PROVISION:
         return new DependencyMethodProviderCreationExpression(
-            binding, generatedComponentModel, componentRequirementFields, compilerOptions, graph);
+            binding,
+            componentImplementation,
+            componentRequirementExpressions,
+            compilerOptions,
+            graph);
 
       case SUBCOMPONENT_BUILDER:
         return new SubcomponentBuilderProviderCreationExpression(
-            binding.key().type(), subcomponentNames.get(binding.key()));
+            binding.key().type(), componentImplementation.getSubcomponentName(binding.key()));
 
       case INJECTION:
       case PROVISION:
@@ -665,33 +371,25 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
 
       case COMPONENT_PRODUCTION:
         return new DependencyMethodProducerCreationExpression(
-            binding, generatedComponentModel, componentRequirementFields, graph);
+            binding, componentImplementation, componentRequirementExpressions, graph);
 
       case PRODUCTION:
         return new ProducerCreationExpression(binding, this);
 
       case MULTIBOUND_SET:
-        return new SetFactoryCreationExpression(binding, generatedComponentModel, this, graph);
+        return new SetFactoryCreationExpression(binding, componentImplementation, this, graph);
 
       case MULTIBOUND_MAP:
         return new MapFactoryCreationExpression(
-            binding, generatedComponentModel, this, graph, elements);
-
-      case RELEASABLE_REFERENCE_MANAGER:
-        return new ReleasableReferenceManagerProviderCreationExpression(
-            binding, generatedComponentModel, referenceReleasingManagerFields);
-
-      case RELEASABLE_REFERENCE_MANAGERS:
-        return new ReleasableReferenceManagerSetProviderCreationExpression(
-            binding, generatedComponentModel, referenceReleasingManagerFields, graph);
+            binding, componentImplementation, this, graph, elements);
 
       case DELEGATE:
         return new DelegatingFrameworkInstanceCreationExpression(
-            binding, generatedComponentModel, this);
+            binding, componentImplementation, this);
 
       case OPTIONAL:
         return new OptionalFactoryInstanceCreationExpression(
-            optionalFactories, binding, generatedComponentModel, this);
+            optionalFactories, binding, componentImplementation, this);
 
       case MEMBERS_INJECTOR:
         return new MembersInjectorProviderCreationExpression((ProvisionBinding) binding, this);
@@ -706,16 +404,20 @@ private InstanceFactoryCreationExpression instanceFactoryCreationExpression(
     return new InstanceFactoryCreationExpression(
         binding.nullableType().isPresent(),
         () ->
-            componentRequirementFields.getExpressionDuringInitialization(
-                componentRequirement, generatedComponentModel.name()));
+            componentRequirementExpressions.getExpressionDuringInitialization(
+                componentRequirement, componentImplementation.name()));
   }
 
   /** Returns a binding expression for a provision binding. */
   private BindingExpression provisionBindingExpression(
       ResolvedBindings resolvedBindings, BindingRequest request) {
-    // All provision requests should have an associated RequestKind, even if they're a framework
-    // request.
-    checkArgument(request.requestKind().isPresent());
+    if (!request.requestKind().isPresent()) {
+      verify(
+          request.frameworkType().get().equals(FrameworkType.PRODUCER_NODE),
+          "expected a PRODUCER_NODE: %s",
+          request);
+      return producerFromProviderBindingExpression(resolvedBindings);
+    }
     RequestKind requestKind = request.requestKind().get();
     switch (requestKind) {
       case INSTANCE:
@@ -728,7 +430,7 @@ private BindingExpression provisionBindingExpression(
       case PRODUCED:
       case PROVIDER_OF_LAZY:
         return new DerivedFromFrameworkInstanceBindingExpression(
-            resolvedBindings, FrameworkType.PROVIDER, requestKind, this, types);
+            resolvedBindings.key(), FrameworkType.PROVIDER, requestKind, this, types);
 
       case PRODUCER:
         return producerFromProviderBindingExpression(resolvedBindings);
@@ -750,8 +452,9 @@ private BindingExpression productionBindingExpression(
       return frameworkInstanceBindingExpression(resolvedBindings);
     } else {
       // If no FrameworkType is present, a RequestKind is guaranteed to be present.
+      RequestKind requestKind = request.requestKind().get();
       return new DerivedFromFrameworkInstanceBindingExpression(
-          resolvedBindings, FrameworkType.PRODUCER, request.requestKind().get(), this, types);
+          resolvedBindings.key(), FrameworkType.PRODUCER_NODE, requestKind, this, types);
     }
   }
 
@@ -778,7 +481,7 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
             instanceof DerivedFromFrameworkInstanceBindingExpression)) {
       return wrapInMethod(
           resolvedBindings,
-          BindingRequest.forDependencyRequest(resolvedBindings.key(), RequestKind.PROVIDER),
+          bindingRequest(resolvedBindings.key(), RequestKind.PROVIDER),
           innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
     }
     return frameworkInstanceBindingExpression(resolvedBindings);
@@ -791,15 +494,16 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
   private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
       ResolvedBindings resolvedBindings) {
     checkArgument(resolvedBindings.bindingType().equals(BindingType.PROVISION));
-    return new ProducerInstanceBindingExpression(
+    return new ProducerNodeInstanceBindingExpression(
         resolvedBindings,
         new FrameworkFieldInitializer(
-            generatedComponentModel,
+            componentImplementation,
             resolvedBindings,
             new ProducerFromProviderCreationExpression(
-                resolvedBindings.contributionBinding(), generatedComponentModel, this)),
+                resolvedBindings.contributionBinding(), componentImplementation, this)),
         types,
-        elements);
+        elements,
+        componentImplementation);
   }
 
   /**
@@ -809,9 +513,6 @@ private FrameworkInstanceBindingExpression producerFromProviderBindingExpression
    * instance of this binding, return it, wrapped in a method if the binding {@linkplain
    * #needsCaching(ResolvedBindings) needs to be cached} or the expression has dependencies.
    *
-   * <p>In default mode, we can use direct expressions for bindings that don't need to be cached in
-   * a reference-releasing scope.
-   *
    * <p>In fastInit mode, we can use direct expressions unless the binding needs to be cached.
    */
   private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBindings) {
@@ -824,12 +525,12 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
               || needsCaching(resolvedBindings)
           ? wrapInMethod(
               resolvedBindings,
-              BindingRequest.forDependencyRequest(resolvedBindings.key(), RequestKind.INSTANCE),
+              bindingRequest(resolvedBindings.key(), RequestKind.INSTANCE),
               directInstanceExpression)
           : directInstanceExpression;
     }
     return new DerivedFromFrameworkInstanceBindingExpression(
-        resolvedBindings, FrameworkType.PROVIDER, RequestKind.INSTANCE, this, types);
+        resolvedBindings.key(), FrameworkType.PROVIDER, RequestKind.INSTANCE, this, types);
   }
 
   /**
@@ -847,34 +548,35 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
       case COMPONENT:
         return Optional.of(
             new ComponentInstanceBindingExpression(
-                resolvedBindings, generatedComponentModel.name()));
+                resolvedBindings, componentImplementation.name()));
 
       case COMPONENT_DEPENDENCY:
         return Optional.of(
             new ComponentRequirementBindingExpression(
                 resolvedBindings,
                 ComponentRequirement.forDependency(resolvedBindings.key().type()),
-                componentRequirementFields));
+                componentRequirementExpressions));
 
       case COMPONENT_PROVISION:
         return Optional.of(
             new ComponentProvisionBindingExpression(
-                resolvedBindings, graph, componentRequirementFields, compilerOptions));
+                resolvedBindings, graph, componentRequirementExpressions, compilerOptions));
 
       case SUBCOMPONENT_BUILDER:
         return Optional.of(
             new SubcomponentBuilderBindingExpression(
-                resolvedBindings, subcomponentNames.get(resolvedBindings.key())));
+                resolvedBindings,
+                componentImplementation.getSubcomponentName(resolvedBindings.key())));
 
       case MULTIBOUND_SET:
         return Optional.of(
             new SetBindingExpression(
-                resolvedBindings, generatedComponentModel, graph, this, types, elements));
+                resolvedBindings, componentImplementation, graph, this, types, elements));
 
       case MULTIBOUND_MAP:
         return Optional.of(
             new MapBindingExpression(
-                resolvedBindings, generatedComponentModel, graph, this, types, elements));
+                resolvedBindings, componentImplementation, graph, this, types, elements));
 
       case OPTIONAL:
         return Optional.of(new OptionalBindingExpression(resolvedBindings, this, types));
@@ -884,7 +586,7 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
             new ComponentRequirementBindingExpression(
                 resolvedBindings,
                 ComponentRequirement.forBoundInstance(resolvedBindings.contributionBinding()),
-                componentRequirementFields));
+                componentRequirementExpressions));
 
       case INJECTION:
       case PROVISION:
@@ -894,13 +596,11 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
                 compilerOptions,
                 this,
                 membersInjectionMethods,
-                componentRequirementFields,
+                componentRequirementExpressions,
+                types,
                 elements));
 
       case MEMBERS_INJECTOR:
-      case RELEASABLE_REFERENCE_MANAGER:
-      case RELEASABLE_REFERENCE_MANAGERS:
-        // TODO(dpb): Implement direct expressions for these.
         return Optional.empty();
 
       case MEMBERS_INJECTION:
@@ -932,22 +632,20 @@ private boolean useStaticFactoryCreation(ContributionBinding binding) {
    * we can.
    *
    * <p>In fastInit mode, we can use a direct expression even if the binding {@linkplain
-   * #needsCaching(ResolvedBindings) needs to be cached} as long as it's not in a
-   * reference-releasing scope.
+   * #needsCaching(ResolvedBindings) needs to be cached}.
    */
   private boolean canUseDirectInstanceExpression(ResolvedBindings resolvedBindings) {
-    return !needsCaching(resolvedBindings)
-        || (compilerOptions.fastInit() && !requiresReleasableReferences(resolvedBindings));
+    return !needsCaching(resolvedBindings) || compilerOptions.fastInit();
   }
 
   /**
    * Returns a binding expression that uses a given one as the body of a method that users call. If
    * a component provision method matches it, it will be the method implemented. If it does not
-   * match a component provision method and the binding is modifiable the a new public modifiable
-   * binding method will be written. If the binding doesn't match a component method nor is it
+   * match a component provision method and the binding is modifiable, then a new public modifiable
+   * binding method will be written. If the binding doesn't match a component method and is not
    * modifiable, then a new private method will be written.
    */
-  private BindingExpression wrapInMethod(
+  BindingExpression wrapInMethod(
       ResolvedBindings resolvedBindings,
       BindingRequest request,
       BindingExpression bindingExpression) {
@@ -956,88 +654,49 @@ private BindingExpression wrapInMethod(
       return bindingExpression;
     }
 
+    ContributionBinding binding = resolvedBindings.contributionBinding();
     BindingMethodImplementation methodImplementation =
         methodImplementation(resolvedBindings, request, bindingExpression);
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
-        findMatchingComponentMethod(request);
-
-    ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
-    if (shouldUseAModifiableConcreteMethodBindingExpression(
-        modifiableBindingType, matchingComponentMethod)) {
-      return new ModifiableConcreteMethodBindingExpression(
-          resolvedBindings,
-          request,
-          modifiableBindingType,
-          methodImplementation,
-          generatedComponentModel,
-          generatedComponentModel.getModifiableBindingMethod(request),
-          newModifiableBindingWillBeFinalized(modifiableBindingType, request));
+        graph.componentDescriptor().firstMatchingComponentMethod(request);
+
+    if (modifiableBindingExpressions.getModifiableBindingType(request).isModifiable()
+        && (componentImplementation.superclassImplementation().isPresent()
+            || !matchingComponentMethod.isPresent())) {
+      return modifiableBindingExpressions.wrapInModifiableMethodBindingExpression(
+          binding, request, methodImplementation);
+    } else if (matchingComponentMethod.isPresent()) {
+      ComponentMethodDescriptor componentMethod = matchingComponentMethod.get();
+      return new ComponentMethodBindingExpression(
+          request, methodImplementation, componentImplementation, componentMethod, types);
+    } else {
+      return new PrivateMethodBindingExpression(
+          binding, request, methodImplementation, componentImplementation, types);
     }
-
-    return matchingComponentMethod
-        .<BindingExpression>map(
-            componentMethod ->
-                new ComponentMethodBindingExpression(
-                    methodImplementation, generatedComponentModel, componentMethod))
-        .orElseGet(
-            () ->
-                new PrivateMethodBindingExpression(
-                    resolvedBindings, request, methodImplementation, generatedComponentModel));
-  }
-
-  /**
-   * Returns true if we should wrap a binding expression using a {@link
-   * ModifiableConcreteMethodBindingExpression}. If we're generating the abstract base class of a
-   * subcomponent and the binding matches a component method, even if it is modifiable, then it
-   * should be "wrapped" by a {@link ComponentMethodBindingExpression}. If it isn't a base class
-   * then modifiable methods should be handled by a {@link
-   * ModifiableConcreteMethodBindingExpression}. When generating an inner subcomponent it doesn't
-   * matter whether the binding matches a component method: All modifiable bindings should be
-   * handled by a {@link ModifiableConcreteMethodBindingExpression}.
-   */
-  private boolean shouldUseAModifiableConcreteMethodBindingExpression(
-      ModifiableBindingType type, Optional<ComponentMethodDescriptor> matchingComponentMethod) {
-    return type.isModifiable()
-        && (generatedComponentModel.supermodel().isPresent()
-            || !matchingComponentMethod.isPresent());
-  }
-
-  /** Returns the first component method associated with this request kind, if one exists. */
-  private Optional<ComponentMethodDescriptor> findMatchingComponentMethod(BindingRequest request) {
-    return graph.componentDescriptor().componentMethods().stream()
-        .filter(method -> doesComponentMethodMatch(method, request))
-        .findFirst();
-  }
-
-  /** Returns true if the component method matches the binding request. */
-  private boolean doesComponentMethodMatch(
-      ComponentMethodDescriptor componentMethod, BindingRequest request) {
-    return componentMethod
-        .dependencyRequest()
-        .map(BindingRequest::forDependencyRequest)
-        .filter(request::equals)
-        .isPresent();
   }
 
+  // TODO(ronshapiro): pass ContributionBinding directly instead of ResolvedBindings. The
+  // ResolvedBindings type is only needed in one case, and it seems like it could be removed.
   private BindingMethodImplementation methodImplementation(
       ResolvedBindings resolvedBindings,
       BindingRequest request,
       BindingExpression bindingExpression) {
+    ContributionBinding binding = resolvedBindings.contributionBinding();
     if (compilerOptions.fastInit()) {
       if (request.isRequestKind(RequestKind.PROVIDER)) {
         return new SingleCheckedMethodImplementation(
-            resolvedBindings, request, bindingExpression, types, generatedComponentModel);
+            componentImplementation, resolvedBindings, request, bindingExpression, types);
       } else if (request.isRequestKind(RequestKind.INSTANCE) && needsCaching(resolvedBindings)) {
         return resolvedBindings.scope().get().isReusable()
             ? new SingleCheckedMethodImplementation(
-                resolvedBindings, request, bindingExpression, types, generatedComponentModel)
+                componentImplementation, resolvedBindings, request, bindingExpression, types)
             : new DoubleCheckedMethodImplementation(
-                resolvedBindings, request, bindingExpression, types, generatedComponentModel);
+                componentImplementation, binding, request, bindingExpression, types);
       }
     }
 
     return new BindingMethodImplementation(
-        resolvedBindings, request, bindingExpression, generatedComponentModel.name(), types);
+        componentImplementation, binding, request, bindingExpression, types);
   }
 
   /**
@@ -1055,11 +714,4 @@ private boolean needsCaching(ResolvedBindings resolvedBindings) {
     }
     return true;
   }
-
-  // TODO(user): Enable releasable references in fastInit
-  private boolean requiresReleasableReferences(ResolvedBindings resolvedBindings) {
-    return resolvedBindings.scope().isPresent()
-        && referenceReleasingManagerFields.requiresReleasableReferences(
-            resolvedBindings.scope().get());
-  }
 }
diff --git a/java/dagger/internal/codegen/ComponentBuilder.java b/java/dagger/internal/codegen/ComponentBuilder.java
deleted file mode 100644
index d4ad5fd5f..000000000
--- a/java/dagger/internal/codegen/ComponentBuilder.java
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
-import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.type.TypeKind.VOID;
-
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Sets;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.TypeName;
-import com.squareup.javapoet.TypeSpec;
-import dagger.internal.Preconditions;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import java.util.Optional;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-/** Models the generated code for a component builder. */
-final class ComponentBuilder {
-  private final TypeSpec typeSpec;
-  private final ClassName name;
-  private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
-
-  private ComponentBuilder(
-      TypeSpec typeSpec,
-      ClassName name,
-      ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
-    this.typeSpec = typeSpec;
-    this.name = name;
-    this.builderFields = builderFields;
-  }
-
-  TypeSpec typeSpec() {
-    return typeSpec;
-  }
-
-  ClassName name() {
-    return name;
-  }
-
-  ImmutableMap<ComponentRequirement, FieldSpec> builderFields() {
-    return builderFields;
-  }
-
-  static Optional<ComponentBuilder> create(
-      GeneratedComponentModel generatedComponentModel,
-      BindingGraph graph,
-      SubcomponentNames subcomponentNames,
-      Elements elements,
-      Types types) {
-    return hasBuilder(graph.componentDescriptor())
-        ? Optional.of(
-            new Creator(generatedComponentModel, graph, subcomponentNames, elements, types)
-                .create())
-        : Optional.empty();
-  }
-
-  private static boolean hasBuilder(ComponentDescriptor component) {
-    return component.kind().isTopLevel() || component.builderSpec().isPresent();
-  }
-
-  private static final class Creator {
-    private static final String NOOP_BUILDER_METHOD_JAVADOC =
-        "This module is declared, but an instance is not used in the component. This method is a "
-            + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
-    private final BindingGraph graph;
-    private final TypeSpec.Builder builder;
-    private final GeneratedComponentModel generatedComponentModel;
-    private final ClassName builderName;
-    private final SubcomponentNames subcomponentNames;
-    private final Elements elements;
-    private final Types types;
-
-    Creator(
-        GeneratedComponentModel generatedComponentModel,
-        BindingGraph graph,
-        SubcomponentNames subcomponentNames,
-        Elements elements,
-        Types types) {
-      this.generatedComponentModel = generatedComponentModel;
-      ClassName componentName = generatedComponentModel.name();
-      if (!generatedComponentModel.isNested()) {
-        builderName = componentName.nestedClass("Builder");
-        builder = classBuilder(builderName).addModifiers(STATIC);
-      } else {
-        builderName =
-            componentName.peerClass(subcomponentNames.get(graph.componentDescriptor()) + "Builder");
-        builder = classBuilder(builderName);
-      }
-      this.graph = graph;
-      this.subcomponentNames = subcomponentNames;
-      this.elements = elements;
-      this.types = types;
-    }
-
-    ComponentBuilder create() {
-      if (builderSpec().isPresent()) {
-        if (generatedComponentModel.isAbstract()) {
-          builder.addModifiers(PROTECTED);
-        } else {
-          builder.addModifiers(PRIVATE);
-        }
-        setSupertype();
-      } else {
-        builder.addModifiers(PUBLIC).addMethod(constructorBuilder().addModifiers(PRIVATE).build());
-      }
-
-      ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields(graph);
-
-      if (generatedComponentModel.isAbstract()) {
-        builder.addModifiers(ABSTRACT);
-      } else {
-        builder.addModifiers(FINAL);
-        builder.addMethod(buildMethod(builderFields)); // Can only instantiate concrete classes.
-      }
-
-      builder
-          .addFields(builderFields.values())
-          // TODO(ronshapiro): this should be switched with buildMethod(), but that currently breaks
-          // compile-testing tests that rely on the order of the methods
-          .addMethods(builderMethods(builderFields));
-
-      return new ComponentBuilder(builder.build(), builderName, builderFields);
-    }
-
-    /** Set the superclass being extended or interface being implemented for this builder. */
-    private void setSupertype() {
-      if (generatedComponentModel.supermodel().isPresent()) {
-        // If there's a superclass, extend the Builder defined there.
-        GeneratedComponentModel subcomponentSupermodel = generatedComponentModel.supermodel().get();
-        if (subcomponentSupermodel.isNested()) {
-          // If the subcomponent superclass is nested we're overriding the builder that was
-          // defined as a peer of the superclass.
-          builder.superclass(
-              subcomponentSupermodel
-                  .name()
-                  .peerClass(subcomponentNames.get(graph.componentDescriptor()) + "Builder"));
-        } else {
-          // Otherwise we're extending the builder defined inside the subcomponent definition.
-          builder.superclass(subcomponentSupermodel.name().nestedClass("Builder"));
-        }
-      } else {
-        addSupertype(builder, builderSpec().get().builderDefinitionType());
-      }
-    }
-
-    /**
-     * Computes fields for each of the {@linkplain BindingGraph#componentRequirements component
-     * requirements}. Regardless of builder spec, there is always one field per requirement.
-     */
-    private static ImmutableMap<ComponentRequirement, FieldSpec> builderFields(BindingGraph graph) {
-      UniqueNameSet fieldNames = new UniqueNameSet();
-      ImmutableMap.Builder<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.builder();
-      for (ComponentRequirement componentRequirement : graph.componentRequirements()) {
-        String name = fieldNames.getUniqueName(componentRequirement.variableName());
-        builderFields.put(
-            componentRequirement,
-            FieldSpec.builder(TypeName.get(componentRequirement.type()), name, PRIVATE).build());
-      }
-      return builderFields.build();
-    }
-
-    private MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
-      MethodSpec.Builder buildMethod;
-      if (builderSpec().isPresent()) {
-        ExecutableElement specBuildMethod = builderSpec().get().buildMethod();
-        // Note: we don't use the specBuildMethod.getReturnType() as the return type
-        // because it might be a type variable.  We make use of covariant returns to allow
-        // us to return the component type, which will always be valid.
-        buildMethod =
-            methodBuilder(specBuildMethod.getSimpleName().toString()).addAnnotation(Override.class);
-      } else {
-        buildMethod = methodBuilder("build");
-      }
-      buildMethod.returns(ClassName.get(graph.componentType())).addModifiers(PUBLIC);
-
-      builderFields.forEach(
-          (requirement, builderField) -> {
-            switch (requirement.nullPolicy(elements, types)) {
-              case NEW:
-                buildMethod.addCode(
-                    "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
-                break;
-              case THROW:
-                buildMethod.addCode(
-                    "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
-                    builderField,
-                    IllegalStateException.class,
-                    TypeNames.rawTypeName(builderField.type),
-                    " must be set");
-                break;
-              case ALLOW:
-                break;
-              default:
-                throw new AssertionError(requirement);
-            }
-          });
-      buildMethod.addStatement("return new $T(this)", generatedComponentModel.name());
-      return buildMethod.build();
-    }
-
-    /**
-     * Computes the methods that set each of parameters on the builder. If the {@link BuilderSpec}
-     * is present, it will tailor the methods to match the spec.
-     */
-    private ImmutableSet<MethodSpec> builderMethods(
-        ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
-      ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
-      ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
-      if (builderSpec().isPresent()) {
-        UniqueNameSet parameterNames = new UniqueNameSet();
-        for (BuilderRequirementMethod requirementMethod :
-            builderSpec().get().requirementMethods()) {
-          ComponentRequirement builderRequirement = requirementMethod.requirement();
-          ExecutableElement specMethod = requirementMethod.method();
-          MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(specMethod);
-          VariableElement parameterElement = Iterables.getOnlyElement(specMethod.getParameters());
-          String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
-
-          TypeName argType =
-              parameterElement.asType().getKind().isPrimitive()
-                  // Primitives need to use the original (unresolved) type to avoid boxing.
-                  ? TypeName.get(parameterElement.asType())
-                  // Otherwise we use the full resolved type.
-                  : TypeName.get(builderRequirement.type());
-
-          builderMethod.addParameter(argType, parameterName);
-          if (componentRequirements.contains(builderRequirement)) {
-            // required type
-            builderMethod.addStatement(
-                "this.$N = $L",
-                builderFields.get(builderRequirement),
-                builderRequirement
-                        .nullPolicy(elements, types)
-                        .equals(ComponentRequirement.NullPolicy.ALLOW)
-                    ? parameterName
-                    : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
-            addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
-          } else if (graph.ownedModuleTypes().contains(builderRequirement.typeElement())) {
-            // owned, but not required
-            builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
-            addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
-          } else {
-            // neither owned nor required, so it must be an inherited module
-            builderMethod.addStatement(
-                "throw new $T($T.format($S, $T.class.getCanonicalName()))",
-                UnsupportedOperationException.class,
-                String.class,
-                "%s cannot be set because it is inherited from the enclosing component",
-                TypeNames.rawTypeName(TypeName.get(builderRequirement.type())));
-          }
-          methods.add(builderMethod.build());
-        }
-      } else {
-        for (ComponentRequirement componentRequirement :
-            graph.componentDescriptor().availableDependencies()) {
-          String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
-          MethodSpec.Builder builderMethod =
-              methodBuilder(componentRequirementName)
-                  .returns(builderName)
-                  .addModifiers(PUBLIC)
-                  .addParameter(
-                      TypeName.get(componentRequirement.type()), componentRequirementName);
-          if (componentRequirements.contains(componentRequirement)) {
-            builderMethod.addStatement(
-                "this.$N = $T.checkNotNull($L)",
-                builderFields.get(componentRequirement),
-                Preconditions.class,
-                componentRequirementName);
-          } else {
-            builderMethod.addStatement(
-                "$T.checkNotNull($L)", Preconditions.class, componentRequirementName);
-            builderMethod.addJavadoc("@deprecated " + NOOP_BUILDER_METHOD_JAVADOC);
-            builderMethod.addAnnotation(Deprecated.class);
-          }
-          builderMethod.addStatement("return this");
-          methods.add(builderMethod.build());
-        }
-      }
-      return methods.build();
-    }
-
-    private MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {
-      TypeMirror returnType = method.getReturnType();
-      MethodSpec.Builder builderMethod =
-          methodBuilder(method.getSimpleName().toString())
-              .addAnnotation(Override.class)
-              .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
-      // If the return type is void, we add a method with the void return type.
-      // Otherwise we use the generated builder name and take advantage of covariant returns
-      // (so that we don't have to worry about setter methods that return type variables).
-      if (!returnType.getKind().equals(VOID)) {
-        builderMethod.returns(builderName);
-      }
-      return builderMethod;
-    }
-
-    private static void addBuilderMethodReturnStatementForSpec(
-        ExecutableElement specMethod, MethodSpec.Builder builderMethod) {
-      if (!specMethod.getReturnType().getKind().equals(VOID)) {
-        builderMethod.addStatement("return this");
-      }
-    }
-
-    private Optional<BuilderSpec> builderSpec() {
-      return graph.componentDescriptor().builderSpec();
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
new file mode 100644
index 000000000..cd7c7780e
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asTypeElement;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import dagger.BindsInstance;
+import dagger.model.DependencyRequest;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A descriptor for a component <i>creator</i> type: that is, a type annotated with
+ * {@code @Component.Builder} (or one of the corresponding production or subcomponent versions).
+ */
+@AutoValue
+abstract class ComponentCreatorDescriptor {
+
+  /** The annotated creator type. */
+  abstract TypeElement typeElement();
+
+  /** The method that creates and returns a component instance. */
+  abstract ExecutableElement factoryMethod();
+
+  /**
+   * Multimap of component requirements to the element that sets that requirements.
+   *
+   * <p>Validation must ensure that no more than one element exists that sets a given requirement.
+   */
+  abstract ImmutableSetMultimap<ComponentRequirement, ExecutableElement> requirementElements();
+
+  /** Returns the set of component requirements for this creator. */
+  final ImmutableSet<ComponentRequirement> requirements() {
+    return requirementElements().keySet();
+  }
+
+  /** Returns the set of requirements for modules and component dependencies for this creator. */
+  final ImmutableSet<ComponentRequirement> moduleAndDependencyRequirements() {
+    return requirements().stream()
+        .filter(requirement -> !requirement.isBoundInstance())
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the set of bound instance requirements for this creator. */
+  final ImmutableSet<ComponentRequirement> boundInstanceRequirements() {
+    return requirements().stream()
+        .filter(requirement -> requirement.isBoundInstance())
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the element in this creator that sets the given {@code requirement}. */
+  final ExecutableElement elementForRequirement(ComponentRequirement requirement) {
+    return getOnlyElement(requirementElements().get(requirement));
+  }
+
+  /** Creates a new {@link ComponentCreatorDescriptor} for the given creator {@code type}. */
+  static ComponentCreatorDescriptor create(
+      DeclaredType type,
+      DaggerElements elements,
+      DaggerTypes types,
+      DependencyRequestFactory dependencyRequestFactory) {
+    TypeElement typeElement = asTypeElement(type);
+    TypeMirror componentType = typeElement.getEnclosingElement().asType();
+
+    ImmutableSetMultimap.Builder<ComponentRequirement, ExecutableElement> requirementElements =
+        ImmutableSetMultimap.builder();
+
+    ExecutableElement factoryMethod = null;
+    for (ExecutableElement method : elements.getUnimplementedMethods(typeElement)) {
+      ExecutableType resolvedMethodType = MoreTypes.asExecutable(types.asMemberOf(type, method));
+
+      if (types.isSubtype(componentType, resolvedMethodType.getReturnType())) {
+        factoryMethod = method;
+      } else {
+        VariableElement parameter = getOnlyElement(method.getParameters());
+        TypeMirror parameterType = getOnlyElement(resolvedMethodType.getParameterTypes());
+        requirementElements.put(
+            requirement(method, parameter, parameterType, dependencyRequestFactory), method);
+      }
+    }
+    verify(factoryMethod != null); // validation should have ensured this.
+
+    return new AutoValue_ComponentCreatorDescriptor(
+        typeElement, factoryMethod, requirementElements.build());
+  }
+
+  private static ComponentRequirement requirement(
+      ExecutableElement method,
+      VariableElement parameter,
+      TypeMirror type,
+      DependencyRequestFactory dependencyRequestFactory) {
+    if (isAnnotationPresent(method, BindsInstance.class)) {
+      DependencyRequest request =
+          dependencyRequestFactory.forRequiredResolvedVariable(parameter, type);
+      return ComponentRequirement.forBoundInstance(
+          request.key(), request.isNullable(), method.getSimpleName().toString());
+    }
+
+    return ConfigurationAnnotations.getModuleAnnotation(asTypeElement(type)).isPresent()
+        ? ComponentRequirement.forModule(type)
+        : ComponentRequirement.forDependency(type);
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementation.java b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
new file mode 100644
index 000000000..74badf8fb
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
@@ -0,0 +1,377 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.VOID;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.Preconditions;
+import java.util.Optional;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/** The implementation of a component creator type. */
+final class ComponentCreatorImplementation {
+  private final TypeSpec componentCreatorClass;
+  private final ClassName name;
+  private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
+
+  private ComponentCreatorImplementation(
+      TypeSpec componentCreatorClass,
+      ClassName name,
+      ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
+    this.componentCreatorClass = componentCreatorClass;
+    this.name = name;
+    this.builderFields = builderFields;
+  }
+
+  TypeSpec componentCreatorClass() {
+    return componentCreatorClass;
+  }
+
+  ClassName name() {
+    return name;
+  }
+
+  ImmutableMap<ComponentRequirement, FieldSpec> builderFields() {
+    return builderFields;
+  }
+
+  static Optional<ComponentCreatorImplementation> create(
+      ComponentImplementation componentImplementation,
+      BindingGraph graph,
+      Elements elements,
+      Types types) {
+    if (componentImplementation.superclassImplementation().isPresent()
+        && componentImplementation.isAbstract()) {
+      // The component builder in ahead-of-time mode is generated with the base subcomponent
+      // implementation, with the exception of the build method since that requires invoking the
+      // constructor of a subclass component implementation. Intermediate component implementations,
+      // because they still can't invoke the eventual constructor and have no additional extensions
+      // to the builder, can ignore generating a builder implementation.
+      return Optional.empty();
+    }
+    return graph.componentDescriptor().hasCreator()
+        ? Optional.of(
+            new CreatorImplementationFactory(componentImplementation, graph, elements, types)
+                .create())
+        : Optional.empty();
+  }
+
+  /** Factory for creating a {@link ComponentCreatorImplementation} instance. */
+  private static final class CreatorImplementationFactory {
+    // TODO(cgdecker): Possibly extract this to another top-level type,
+    // ComponentCreatorImplementationFactory, to match the separation between
+    // ComponentImplementation and ComponentImplementationFactory
+
+    static final String NOOP_BUILDER_METHOD_JAVADOC =
+        "This module is declared, but an instance is not used in the component. This method is a "
+            + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
+
+    final BindingGraph graph;
+    final TypeSpec.Builder componentCreatorClass;
+    final ComponentImplementation componentImplementation;
+    final Elements elements;
+    final Types types;
+
+    CreatorImplementationFactory(
+        ComponentImplementation componentImplementation,
+        BindingGraph graph,
+        Elements elements,
+        Types types) {
+      this.componentImplementation = componentImplementation;
+      this.componentCreatorClass = classBuilder(componentImplementation.getCreatorName());
+      this.graph = graph;
+      this.elements = elements;
+      this.types = types;
+    }
+
+    ComponentCreatorImplementation create() {
+      if (!componentImplementation.isNested()) {
+        componentCreatorClass.addModifiers(STATIC);
+      }
+      if (creatorDescriptor().isPresent()) {
+        if (componentImplementation.isAbstract()) {
+          // The component creator class of a top-level component implementation in ahead-of-time
+          // subcomponents mode must be public, not protected, because the creator's subclass will
+          // be a sibling of the component subclass implementation, not nested.
+          componentCreatorClass.addModifiers(
+              componentImplementation.isNested() ? PROTECTED : PUBLIC);
+        } else {
+          componentCreatorClass.addModifiers(PRIVATE);
+        }
+        setSupertype();
+      } else {
+        componentCreatorClass
+            .addModifiers(PUBLIC)
+            .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
+      }
+
+      ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields();
+
+      if (componentImplementation.isAbstract()) {
+        componentCreatorClass.addModifiers(ABSTRACT);
+      } else {
+        componentCreatorClass.addModifiers(FINAL);
+        componentCreatorClass.addMethod(factoryMethod(builderFields));
+      }
+
+      if (!componentImplementation.baseImplementation().isPresent()) {
+        componentCreatorClass.addFields(builderFields.values());
+      }
+
+      // TODO(ronshapiro): this should be switched with factoryMethod(), but that currently breaks
+      // compile-testing tests that rely on the order of the methods
+      componentCreatorClass.addMethods(builderMethods(builderFields));
+
+      return new ComponentCreatorImplementation(
+          componentCreatorClass.build(), componentImplementation.getCreatorName(), builderFields);
+    }
+
+    /** Set the superclass being extended or interface being implemented for this creator. */
+    void setSupertype() {
+      if (componentImplementation.baseImplementation().isPresent()) {
+        // If there's a superclass, extend the creator defined there.
+        componentCreatorClass.superclass(
+            componentImplementation.baseImplementation().get().getCreatorName());
+      } else {
+        addSupertype(componentCreatorClass, creatorDescriptor().get().typeElement());
+      }
+    }
+
+    /**
+     * Computes fields for each of the {@link ComponentRequirement}s}. Regardless of creator spec,
+     * there is always one field per requirement.
+     *
+     * <p>If the base implementation's creator is being generated in ahead-of-time-subcomponents
+     * mode, this uses {@link BindingGraph#possiblyNecessaryRequirements()} since Dagger doesn't
+     * know what modules may end up being unused. Otherwise, we use the {@link
+     * BindingGraph#componentRequirements() necessary component requirements}.
+     */
+    ImmutableMap<ComponentRequirement, FieldSpec> builderFields() {
+      UniqueNameSet fieldNames = new UniqueNameSet();
+      ImmutableMap.Builder<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.builder();
+      Modifier modifier = componentImplementation.isAbstract() ? PUBLIC : PRIVATE;
+      for (ComponentRequirement componentRequirement : componentRequirements()) {
+        String name = fieldNames.getUniqueName(componentRequirement.variableName());
+        builderFields.put(
+            componentRequirement,
+            FieldSpec.builder(TypeName.get(componentRequirement.type()), name, modifier).build());
+      }
+      return builderFields.build();
+    }
+
+    MethodSpec factoryMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
+      MethodSpec.Builder factoryMethod;
+      if (creatorDescriptor().isPresent()) {
+        ExecutableElement factoryMethodElement = creatorDescriptor().get().factoryMethod();
+        // Note: we don't use the factoryMethodElement.getReturnType() as the return type
+        // because it might be a type variable.  We make use of covariant returns to allow
+        // us to return the component type, which will always be valid.
+        factoryMethod =
+            methodBuilder(factoryMethodElement.getSimpleName().toString())
+                .addAnnotation(Override.class);
+      } else {
+        factoryMethod = methodBuilder("build");
+      }
+      factoryMethod.returns(ClassName.get(graph.componentTypeElement())).addModifiers(PUBLIC);
+
+      builderFields.forEach(
+          (requirement, field) -> {
+            switch (requirement.nullPolicy(elements, types)) {
+              case NEW:
+                factoryMethod
+                    .beginControlFlow("if ($N == null)", field)
+                    .addStatement("this.$N = new $T()", field, field.type)
+                    .endControlFlow();
+                break;
+              case THROW:
+                // TODO(cgdecker,ronshapiro): ideally this should use the key instead of a class for
+                // @BindsInstance requirements, but that's not easily proguardable.
+                factoryMethod.addStatement(
+                    "$T.checkBuilderRequirement($N, $T.class)",
+                    Preconditions.class,
+                    field,
+                    TypeNames.rawTypeName(field.type));
+                break;
+              case ALLOW:
+                break;
+              default:
+                throw new AssertionError(requirement);
+            }
+          });
+      factoryMethod.addStatement("return new $T(this)", componentImplementation.name());
+      return factoryMethod.build();
+    }
+
+    /**
+     * Computes the methods that set each of parameters on the builder. If the {@link
+     * ComponentCreatorDescriptor} is present, it will tailor the methods to match the descriptor.
+     */
+    ImmutableSet<MethodSpec> builderMethods(
+        ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
+      ImmutableSet<ComponentRequirement> componentRequirements = componentRequirements();
+      ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
+      // TODO(ronshapiro): extract two separate methods: builderMethodsForBuilderSpec and
+      // builderMethodsForGeneratedTopLevelComponentBuilder()
+      if (creatorDescriptor().isPresent()) {
+        // In ahead-of-time subcomponents mode, all builder methods are defined at the base
+        // implementation. The only case where a method needs to be overridden is for a repeated
+        // module, which is unknown at the point when a base implementation is generated. We do this
+        // at the root for simplicity (and as an aside, repeated modules are never used in google
+        // as of 11/28/18, and thus the additional cost of including these methods at the root is
+        // negligible).
+        boolean hasBaseCreatorImplementation =
+            !componentImplementation.isAbstract()
+                && componentImplementation.baseImplementation().isPresent();
+
+        UniqueNameSet parameterNames = new UniqueNameSet();
+        ComponentCreatorDescriptor creatorDescriptor = creatorDescriptor().get();
+        for (ComponentRequirement requirement : creatorDescriptor.requirements()) {
+          ExecutableElement method = creatorDescriptor.elementForRequirement(requirement);
+          MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(method);
+          VariableElement parameterElement = getOnlyElement(method.getParameters());
+          String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
+
+          TypeName argType =
+              parameterElement.asType().getKind().isPrimitive()
+                  // Primitives need to use the original (unresolved) type to avoid boxing.
+                  ? TypeName.get(parameterElement.asType())
+                  // Otherwise we use the full resolved type.
+                  : TypeName.get(requirement.type());
+
+          builderMethod.addParameter(argType, parameterName);
+
+          if (componentRequirements.contains(requirement)) {
+            if (hasBaseCreatorImplementation) {
+              continue;
+            }
+            // required type
+            builderMethod.addStatement(
+                "this.$N = $L",
+                builderFields.get(requirement),
+                requirement
+                        .nullPolicy(elements, types)
+                        .equals(ComponentRequirement.NullPolicy.ALLOW)
+                    ? parameterName
+                    : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
+            addBuilderMethodReturnStatementForSpec(method, builderMethod);
+          } else if (graph.ownedModuleTypes().contains(requirement.typeElement())) {
+            if (hasBaseCreatorImplementation) {
+              continue;
+            }
+            // owned, but not required
+            builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
+            addBuilderMethodReturnStatementForSpec(method, builderMethod);
+          } else {
+            // neither owned nor required, so it must be an inherited module
+            builderMethod.addStatement(
+                "throw new $T($T.format($S, $T.class.getCanonicalName()))",
+                UnsupportedOperationException.class,
+                String.class,
+                "%s cannot be set because it is inherited from the enclosing component",
+                TypeNames.rawTypeName(TypeName.get(requirement.type())));
+          }
+
+          methods.add(builderMethod.build());
+        }
+      } else {
+        for (ComponentRequirement requirement :
+            graph.componentDescriptor().dependenciesAndConcreteModules()) {
+          String componentRequirementName = simpleVariableName(requirement.typeElement());
+          MethodSpec.Builder builderMethod =
+              methodBuilder(componentRequirementName)
+                  .returns(componentImplementation.getCreatorName())
+                  .addModifiers(PUBLIC)
+                  .addParameter(TypeName.get(requirement.type()), componentRequirementName);
+          if (componentRequirements.contains(requirement)) {
+            builderMethod.addStatement(
+                "this.$N = $T.checkNotNull($L)",
+                builderFields.get(requirement),
+                Preconditions.class,
+                componentRequirementName);
+          } else {
+            builderMethod.addStatement(
+                "$T.checkNotNull($L)", Preconditions.class, componentRequirementName);
+            builderMethod.addJavadoc("@deprecated " + NOOP_BUILDER_METHOD_JAVADOC);
+            builderMethod.addAnnotation(Deprecated.class);
+          }
+          builderMethod.addStatement("return this");
+          methods.add(builderMethod.build());
+        }
+      }
+      return methods.build();
+    }
+
+    private ImmutableSet<ComponentRequirement> componentRequirements() {
+      return !componentImplementation.superclassImplementation().isPresent()
+              && componentImplementation.isAbstract()
+          ? graph.possiblyNecessaryRequirements()
+          : graph.componentRequirements();
+    }
+
+    MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {
+      TypeMirror returnType = method.getReturnType();
+      MethodSpec.Builder builderMethod =
+          methodBuilder(method.getSimpleName().toString())
+              .addAnnotation(Override.class)
+              .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
+      // If the return type is void, we add a method with the void return type.
+      // Otherwise we use the generated builder name and take advantage of covariant returns
+      // (so that we don't have to worry about setter methods that return type variables).
+      if (!returnType.getKind().equals(VOID)) {
+        builderMethod.returns(componentImplementation.getCreatorName());
+      }
+      return builderMethod;
+    }
+
+    static void addBuilderMethodReturnStatementForSpec(
+        ExecutableElement specMethod, MethodSpec.Builder builderMethod) {
+      if (!specMethod.getReturnType().getKind().equals(VOID)) {
+        builderMethod.addStatement("return this");
+      }
+    }
+
+    Optional<ComponentCreatorDescriptor> creatorDescriptor() {
+      return graph.componentDescriptor().creatorDescriptor();
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/BuilderValidator.java b/java/dagger/internal/codegen/ComponentCreatorValidator.java
similarity index 88%
rename from java/dagger/internal/codegen/BuilderValidator.java
rename to java/dagger/internal/codegen/ComponentCreatorValidator.java
index 543cd5691..d939c9fd7 100644
--- a/java/dagger/internal/codegen/BuilderValidator.java
+++ b/java/dagger/internal/codegen/ComponentCreatorValidator.java
@@ -29,8 +29,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import dagger.BindsInstance;
-import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
-import java.lang.annotation.Annotation;
+import dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
@@ -45,16 +44,14 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Types;
 
-/**
- * Validates {@link dagger.Component.Builder} annotations.
- */
-class BuilderValidator {
+/** Validates {@link dagger.Component.Builder} annotations. */
+class ComponentCreatorValidator {
 
   private final DaggerElements elements;
   private final Types types;
 
   @Inject
-  BuilderValidator(DaggerElements elements, Types types) {
+  ComponentCreatorValidator(DaggerElements elements, Types types) {
     this.elements = elements;
     this.types = types;
   }
@@ -62,16 +59,13 @@
   public ValidationReport<TypeElement> validate(TypeElement subject) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
-    ComponentDescriptor.Kind componentKind =
-        ComponentDescriptor.Kind.forAnnotatedBuilderElement(subject).get();
+    ComponentKind componentKind = ComponentKind.forAnnotatedBuilderElement(subject).get();
 
     Element componentElement = subject.getEnclosingElement();
-    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentKind);
-    Class<? extends Annotation> componentAnnotation = componentKind.annotationType();
-    Class<? extends Annotation> builderAnnotation = componentKind.builderAnnotationType();
-    checkArgument(subject.getAnnotation(builderAnnotation) != null);
+    ErrorMessages.ComponentCreatorMessages msgs = ErrorMessages.creatorMessagesFor(componentKind);
+    checkArgument(isAnnotationPresent(subject, componentKind.builderAnnotation().get()));
 
-    if (!isAnnotationPresent(componentElement, componentAnnotation)) {
+    if (!isAnnotationPresent(componentElement, componentKind.annotation())) {
       builder.addError(msgs.mustBeInComponent(), subject);
     }
 
@@ -107,7 +101,7 @@
       builder.addError(msgs.mustBeAbstract(), subject);
     }
 
-    ExecutableElement buildMethod = null;
+    ExecutableElement factoryMethod = null;
     for (ExecutableElement method : elements.getUnimplementedMethods(subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
@@ -115,21 +109,21 @@
       switch (method.getParameters().size()) {
         case 0: // If this is potentially a build() method, validate it returns the correct type.
           if (types.isSubtype(componentElement.asType(), returnType)) {
-            validateBuildMethodReturnType(
+            validateFactoryMethodReturnType(
                 builder,
                 // since types.isSubtype() passed, componentElement cannot be a PackageElement
                 MoreElements.asType(componentElement),
                 msgs,
                 method,
                 returnType);
-            if (buildMethod != null) {
+            if (factoryMethod != null) {
               // If we found more than one build-like method, fail.
               error(
                   builder,
                   method,
                   msgs.twoBuildMethods(),
                   msgs.inheritedTwoBuildMethods(),
-                  buildMethod);
+                  factoryMethod);
             }
           } else {
             error(
@@ -138,8 +132,8 @@
                 msgs.buildMustReturnComponentType(),
                 msgs.inheritedBuildMustReturnComponentType());
           }
-          // We set the buildMethod regardless of the return type to reduce error spam.
-          buildMethod = method;
+          // We set the factoryMethod regardless of the return type to reduce error spam.
+          factoryMethod = method;
           break;
 
         case 1: // If this correctly had one parameter, make sure the return types are valid.
@@ -175,7 +169,7 @@
       }
     }
 
-    if (buildMethod == null) {
+    if (factoryMethod == null) {
       builder.addError(msgs.missingBuildMethod(), subject);
     }
 
@@ -186,10 +180,10 @@
     return builder.build();
   }
 
-  private void validateBuildMethodReturnType(
+  private void validateFactoryMethodReturnType(
       ValidationReport.Builder<TypeElement> builder,
       TypeElement componentElement,
-      ComponentBuilderMessages msgs,
+      ComponentCreatorMessages msgs,
       ExecutableElement method,
       TypeMirror returnType) {
     if (types.isSameType(componentElement.asType(), returnType)) {
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index b2fea631a..9d405e377 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -18,14 +18,16 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Verify.verify;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
-import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
+import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentCreator;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerStreams.toImmutableMap;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DaggerTypes.isFutureType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
@@ -39,31 +41,23 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.auto.value.extension.memoized.Memoized;
-import com.google.common.collect.FluentIterable;
+import com.google.common.base.Supplier;
+import com.google.common.base.Suppliers;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
-import com.google.common.graph.Traverser;
-import com.squareup.javapoet.ClassName;
-import dagger.BindsInstance;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.model.DependencyRequest;
+import dagger.model.RequestKind;
 import dagger.model.Scope;
+import dagger.producers.CancellationPolicy;
 import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import dagger.releasablereferences.CanReleaseReferences;
-import java.lang.annotation.Annotation;
-import java.util.EnumSet;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Optional;
-import java.util.Set;
 import java.util.stream.Stream;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -74,133 +68,30 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /**
- * The logical representation of a {@link Component} or {@link ProductionComponent} definition.
+ * A component declaration.
+ *
+ * <p>Represents one type annotated with {@code @Component}, {@code Subcomponent},
+ * {@code @ProductionComponent}, or {@code @ProductionSubcomponent}.
+ *
+ * <p>When validating bindings installed in modules, a {@link ComponentDescriptor} can also
+ * represent a synthetic component for the module, where there is an entry point for each binding in
+ * the module.
  */
 @AutoValue
 abstract class ComponentDescriptor {
-  enum Kind {
-    COMPONENT(Component.class, Component.Builder.class, true),
-    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class, false),
-    PRODUCTION_COMPONENT(ProductionComponent.class, ProductionComponent.Builder.class, true),
-    PRODUCTION_SUBCOMPONENT(
-        ProductionSubcomponent.class, ProductionSubcomponent.Builder.class, false);
-
-    private final Class<? extends Annotation> annotationType;
-    private final Class<? extends Annotation> builderType;
-    private final boolean isTopLevel;
-
-    /**
-     * Returns the kind of an annotated element if it is annotated with one of the
-     * {@linkplain #annotationType() annotation types}.
-     *
-     * @throws IllegalArgumentException if the element is annotated with more than one of the
-     *     annotation types
-     */
-    static Optional<Kind> forAnnotatedElement(TypeElement element) {
-      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
-      for (Kind kind : values()) {
-        if (isAnnotationPresent(element, kind.annotationType())) {
-          kinds.add(kind);
-        }
-      }
-      checkArgument(
-          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.ofNullable(getOnlyElement(kinds, null));
-    }
-
-    /**
-     * Returns the kind of an annotated element if it is annotated with one of the
-     * {@linkplain #builderAnnotationType() annotation types}.
-     *
-     * @throws IllegalArgumentException if the element is annotated with more than one of the
-     *     annotation types
-     */
-    static Optional<Kind> forAnnotatedBuilderElement(TypeElement element) {
-      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
-      for (Kind kind : values()) {
-        if (isAnnotationPresent(element, kind.builderAnnotationType())) {
-          kinds.add(kind);
-        }
-      }
-      checkArgument(
-          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.ofNullable(getOnlyElement(kinds, null));
-    }
-
-    Kind(
-        Class<? extends Annotation> annotationType,
-        Class<? extends Annotation> builderType,
-        boolean isTopLevel) {
-      this.annotationType = annotationType;
-      this.builderType = builderType;
-      this.isTopLevel = isTopLevel;
-    }
-
-    Class<? extends Annotation> annotationType() {
-      return annotationType;
-    }
-
-    Class<? extends Annotation> builderAnnotationType() {
-      return builderType;
-    }
-
-    ImmutableSet<ModuleDescriptor.Kind> moduleKinds() {
-      switch (this) {
-        case COMPONENT:
-        case SUBCOMPONENT:
-          return Sets.immutableEnumSet(ModuleDescriptor.Kind.MODULE);
-        case PRODUCTION_COMPONENT:
-        case PRODUCTION_SUBCOMPONENT:
-          return Sets.immutableEnumSet(
-              ModuleDescriptor.Kind.MODULE, ModuleDescriptor.Kind.PRODUCER_MODULE);
-        default:
-          throw new AssertionError(this);
-      }
-    }
-
-    ImmutableSet<Kind> subcomponentKinds() {
-      switch (this) {
-        case COMPONENT:
-        case SUBCOMPONENT:
-          return ImmutableSet.of(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT);
-        case PRODUCTION_COMPONENT:
-        case PRODUCTION_SUBCOMPONENT:
-          return ImmutableSet.of(PRODUCTION_SUBCOMPONENT);
-        default:
-          throw new AssertionError();
-      }
-    }
-
-    boolean isTopLevel() {
-      return isTopLevel;
-    }
-
-    boolean isProducer() {
-      switch (this) {
-        case COMPONENT:
-        case SUBCOMPONENT:
-          return false;
-        case PRODUCTION_COMPONENT:
-        case PRODUCTION_SUBCOMPONENT:
-          return true;
-        default:
-          throw new AssertionError();
-      }
-    }
-  }
-
-  abstract Kind kind();
+  /** The kind of the component. */
+  abstract ComponentKind kind();
 
-  abstract AnnotationMirror componentAnnotation();
+  /** The annotation that specifies that {@link #typeElement()} is a component. */
+  abstract AnnotationMirror annotation();
 
   /**
-   * The type (interface or abstract class) that defines the component. This is the element to which
-   * the {@link Component} annotation was applied.
+   * The element that defines the component. This is the element to which the {@link #annotation()}
+   * was applied.
    */
-  abstract TypeElement componentDefinitionType();
+  abstract TypeElement typeElement();
 
   /**
    * The set of component dependencies listed in {@link Component#dependencies} or {@link
@@ -208,11 +99,10 @@ boolean isProducer() {
    */
   abstract ImmutableSet<ComponentRequirement> dependencies();
 
-  /** The non-abstract {@link #transitiveModules()} and the {@link #dependencies()}. */
-  ImmutableSet<ComponentRequirement> availableDependencies() {
+  /** The non-abstract {@link #modules()} and the {@link #dependencies()}. */
+  final ImmutableSet<ComponentRequirement> dependenciesAndConcreteModules() {
     return Stream.concat(
-            transitiveModuleTypes()
-                .stream()
+            moduleTypes().stream()
                 .filter(dep -> !dep.getModifiers().contains(ABSTRACT))
                 .map(module -> ComponentRequirement.forModule(module.asType())),
             dependencies().stream())
@@ -220,35 +110,32 @@ boolean isProducer() {
   }
 
   /**
-   * The set of {@link ModuleDescriptor modules} declared directly in {@link Component#modules}.
-   * Use {@link #transitiveModules} to get the full set of modules available upon traversing
-   * {@link Module#includes}.
+   * The {@link ModuleDescriptor modules} declared in {@link Component#modules()} and reachable by
+   * traversing {@link Module#includes()}.
    */
   abstract ImmutableSet<ModuleDescriptor> modules();
 
-  /**
-   * Returns the set of {@link ModuleDescriptor modules} declared in {@link Component#modules} and
-   * those reachable by traversing {@link Module#includes}.
-   *
-   * <p>Note that for subcomponents this <em>will not</em> include descriptors for any modules that
-   * are declared in parent components.
-   */
-  abstract ImmutableSet<ModuleDescriptor> transitiveModules();
-
-  ImmutableSet<TypeElement> transitiveModuleTypes() {
-    return FluentIterable.from(transitiveModules())
-        .transform(ModuleDescriptor::moduleElement)
-        .toSet();
+  /** The types of the {@link #modules()}. */
+  final ImmutableSet<TypeElement> moduleTypes() {
+    return modules().stream().map(ModuleDescriptor::moduleElement).collect(toImmutableSet());
   }
 
   /**
    * This component's {@linkplain #dependencies() dependencies} keyed by each provision or
-   * production method implemented by that dependency. Note that the dependencies' types are not
-   * simply the enclosing type of the method; a method may be declared by a supertype of the actual
+   * production method defined by that dependency. Note that the dependencies' types are not simply
+   * the enclosing type of the method; a method may be declared by a supertype of the actual
    * dependency.
    */
   abstract ImmutableMap<ExecutableElement, ComponentRequirement> dependenciesByDependencyMethod();
 
+  /** The {@linkplain #dependencies() component dependency} that defines a method. */
+  final ComponentRequirement getDependencyThatDefinesMethod(Element method) {
+    checkArgument(
+        method instanceof ExecutableElement, "method must be an executable element: %s", method);
+    return checkNotNull(
+        dependenciesByDependencyMethod().get(method), "no dependency implements %s", method);
+  }
+
   /**
    * The scopes of the component.
    */
@@ -257,14 +144,14 @@ boolean isProducer() {
   /**
    * All {@link Subcomponent}s which are direct children of this component. This includes
    * subcomponents installed from {@link Module#subcomponents()} as well as subcomponent {@linkplain
-   * #subcomponentsByFactoryMethod() factory methods} and {@linkplain
-   * #subcomponentsByBuilderMethod() builder methods}.
+   * #childComponentsDeclaredByFactoryMethods() factory methods} and {@linkplain
+   * #childComponentsDeclaredByBuilderEntryPoints() builder methods}.
    */
-  ImmutableSet<ComponentDescriptor> subcomponents() {
+  final ImmutableSet<ComponentDescriptor> childComponents() {
     return ImmutableSet.<ComponentDescriptor>builder()
-        .addAll(subcomponentsByFactoryMethod().values())
-        .addAll(subcomponentsByBuilderMethod().values())
-        .addAll(subcomponentsFromModules())
+        .addAll(childComponentsDeclaredByFactoryMethods().values())
+        .addAll(childComponentsDeclaredByBuilderEntryPoints().values())
+        .addAll(childComponentsDeclaredByModules())
         .build();
   }
 
@@ -272,85 +159,133 @@ boolean isProducer() {
    * All {@linkplain Subcomponent direct child} components that are declared by a {@linkplain
    * Module#subcomponents() module's subcomponents}.
    */
-  abstract ImmutableSet<ComponentDescriptor> subcomponentsFromModules();
+  abstract ImmutableSet<ComponentDescriptor> childComponentsDeclaredByModules();
 
   /**
    * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
    * factory method.
    */
   abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
-      subcomponentsByFactoryMethod();
+      childComponentsDeclaredByFactoryMethods();
+
+  /** Returns the factory method that declares a child component. */
+  final Optional<ComponentMethodDescriptor> getFactoryMethodForChildComponent(
+      ComponentDescriptor childComponent) {
+    return Optional.ofNullable(
+        childComponentsDeclaredByFactoryMethods().inverse().get(childComponent));
+  }
 
   /**
    * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
    * builder method.
    */
   abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
-      subcomponentsByBuilderMethod();
-
-  /**
-   * All {@linkplain Subcomponent direct child} components that are declared by an entry point
-   * method. This is equivalent to the set of values from {@link #subcomponentsByFactoryMethod()}
-   * and {@link #subcomponentsByBuilderMethod()}.
-   */
-  ImmutableSet<ComponentDescriptor> subcomponentsFromEntryPoints() {
-    return ImmutableSet.<ComponentDescriptor>builder()
-        .addAll(subcomponentsByFactoryMethod().values())
-        .addAll(subcomponentsByBuilderMethod().values())
-        .build();
+      childComponentsDeclaredByBuilderEntryPoints();
+
+  private final Supplier<ImmutableMap<TypeElement, ComponentDescriptor>>
+      childComponentsByBuilderType =
+          Suppliers.memoize(
+              () ->
+                  childComponents().stream()
+                      .filter(child -> child.creatorDescriptor().isPresent())
+                      .collect(
+                          toImmutableMap(
+                              child -> child.creatorDescriptor().get().typeElement(),
+                              child -> child)));
+
+  /** Returns the child component with the given builder type. */
+  final ComponentDescriptor getChildComponentWithBuilderType(TypeElement builderType) {
+    return checkNotNull(
+        childComponentsByBuilderType.get().get(builderType),
+        "no child component found for builder type %s",
+        builderType.getQualifiedName());
   }
 
-  @Memoized
-  ImmutableBiMap<TypeElement, ComponentDescriptor> subcomponentsByBuilderType() {
-    ImmutableBiMap.Builder<TypeElement, ComponentDescriptor> subcomponentsByBuilderType =
-        ImmutableBiMap.builder();
-    for (ComponentDescriptor subcomponent : subcomponents()) {
-      if (subcomponent.builderSpec().isPresent()) {
-        subcomponentsByBuilderType.put(
-            subcomponent.builderSpec().get().builderDefinitionType(), subcomponent);
-      }
-    }
-    return subcomponentsByBuilderType.build();
+  abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
+
+  /** Returns the first component method associated with this binding request, if one exists. */
+  Optional<ComponentMethodDescriptor> firstMatchingComponentMethod(BindingRequest request) {
+    return componentMethods().stream()
+        .filter(method -> doesComponentMethodMatch(method, request))
+        .findFirst();
   }
 
-  abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
+  /** Returns true if the component method matches the binding request. */
+  private static boolean doesComponentMethodMatch(
+      ComponentMethodDescriptor componentMethod, BindingRequest request) {
+    return componentMethod
+        .dependencyRequest()
+        .map(BindingRequest::bindingRequest)
+        .filter(request::equals)
+        .isPresent();
+  }
 
   /** The entry point methods on the component type. */
-  ImmutableSet<ComponentMethodDescriptor> entryPointMethods() {
+  final ImmutableSet<ComponentMethodDescriptor> entryPointMethods() {
     return componentMethods()
         .stream()
         .filter(method -> method.dependencyRequest().isPresent())
         .collect(toImmutableSet());
   }
 
-  /** The entry point dependency requests on the component type. */
-  ImmutableSet<DependencyRequest> entryPoints() {
-    return entryPointMethods()
-        .stream()
-        .map(method -> method.dependencyRequest().get())
-        .collect(toImmutableSet());
+  /**
+   * The entry points.
+   *
+   * <p>For descriptors that are generated from a module in order to validate the module's bindings,
+   * these will be requests for every key for every binding declared in the module (erasing
+   * multibinding contribution identifiers so that we get the multibinding key).
+   *
+   * <p>In order not to trigger a validation error if the requested binding is nullable, each
+   * request will be nullable.
+   *
+   * <p>In order not to trigger a validation error if the requested binding is a production binding,
+   * each request will be for a {@link com.google.common.util.concurrent.ListenableFuture} of the
+   * key type.
+   */
+  final ImmutableSet<DependencyRequest> entryPoints() {
+    if (kind().isForModuleValidation()) {
+      return modules().stream()
+          .flatMap(module -> module.allBindingKeys().stream())
+          .map(key -> key.toBuilder().multibindingContributionIdentifier(Optional.empty()).build())
+          .map(
+              key ->
+                  DependencyRequest.builder()
+                      .key(key)
+                      // TODO(dpb): Futures only in ProducerModules, instances elsewhere?
+                      .kind(RequestKind.FUTURE)
+                      .isNullable(true)
+                      .build())
+          .collect(toImmutableSet());
+    } else {
+      return entryPointMethods().stream()
+          .map(method -> method.dependencyRequest().get())
+          .collect(toImmutableSet());
+    }
   }
 
   // TODO(gak): Consider making this non-optional and revising the
   // interaction between the spec & generation
-  abstract Optional<BuilderSpec> builderSpec();
+  /** Returns a descriptor for the creator type for this component type, if the user defined one. */
+  abstract Optional<ComponentCreatorDescriptor> creatorDescriptor();
 
   /**
-   * For {@link Component @Component}s, all {@link CanReleaseReferences @CanReleaseReferences}
-   * scopes associated with this component or any subcomponent. Otherwise empty.
+   * Returns {@code true} for components that have a creator, either because the user {@linkplain
+   * #creatorDescriptor() specified one} or because it's a top-level component with an implicit
+   * builder.
    */
-  ImmutableSet<Scope> releasableReferencesScopes() {
-    return kind().equals(Kind.COMPONENT)
-        ? FluentIterable.from(SUBCOMPONENT_TRAVERSER.breadthFirst(this))
-            .transformAndConcat(ComponentDescriptor::scopes)
-            .filter(Scope::canReleaseReferences)
-            .toSet()
-        : ImmutableSet.<Scope>of();
+  final boolean hasCreator() {
+    return kind().isTopLevel() || creatorDescriptor().isPresent();
   }
 
-  /** {@link Traverser} for the subcomponent tree. */
-  private static final Traverser<ComponentDescriptor> SUBCOMPONENT_TRAVERSER =
-      Traverser.forTree(ComponentDescriptor::subcomponents);
+  /**
+   * Returns the {@link CancellationPolicy} for this component, or an empty optional if either the
+   * component is not a production component or no {@code CancellationPolicy} annotation is present.
+   */
+  final Optional<CancellationPolicy> cancellationPolicy() {
+    return kind().isProducer()
+        ? Optional.ofNullable(typeElement().getAnnotation(CancellationPolicy.class))
+        : Optional.empty();
+  }
 
   /** A function that returns all {@link #scopes()} of its input. */
   @AutoValue
@@ -383,12 +318,28 @@ static ComponentMethodDescriptor forSubcomponent(
       return create(kind, Optional.empty(), methodElement);
     }
 
-    static ComponentMethodDescriptor forSubcomponentBuilder(
+    static ComponentMethodDescriptor forSubcomponentCreator(
         ComponentMethodKind kind,
         DependencyRequest dependencyRequestForBuilder,
         ExecutableElement methodElement) {
       return create(kind, Optional.of(dependencyRequestForBuilder), methodElement);
     }
+
+    /**
+     * Returns the return type of {@link #methodElement()} as resolved in the {@link
+     * ComponentDescriptor#typeElement() component type}. If there are no type variables in the
+     * return type, this is the equivalent of {@code methodElement().getReturnType()}.
+     */
+    TypeMirror resolvedReturnType(DaggerTypes types) {
+      checkState(dependencyRequest().isPresent());
+
+      TypeMirror returnType = methodElement().getReturnType();
+      if (returnType.getKind().isPrimitive() || returnType.getKind().equals(VOID)) {
+        return returnType;
+      }
+      return BindingRequest.bindingRequest(dependencyRequest().get())
+          .requestedType(dependencyRequest().get().key().type(), types);
+    }
   }
 
   enum ComponentMethodKind {
@@ -400,46 +351,27 @@ static ComponentMethodDescriptor forSubcomponentBuilder(
     PRODUCTION_SUBCOMPONENT,
     PRODUCTION_SUBCOMPONENT_BUILDER;
 
-    boolean isSubcomponentKind() {
-      return this == SUBCOMPONENT || this == PRODUCTION_SUBCOMPONENT;
-    }
-
     /**
      * Returns the component kind associated with this component method, if it exists. Otherwise,
      * throws.
      */
-    Kind componentKind() {
+    ComponentKind componentKind() {
       switch (this) {
         case SUBCOMPONENT:
         case SUBCOMPONENT_BUILDER:
-          return Kind.SUBCOMPONENT;
+          return ComponentKind.SUBCOMPONENT;
         case PRODUCTION_SUBCOMPONENT:
         case PRODUCTION_SUBCOMPONENT_BUILDER:
-          return Kind.PRODUCTION_SUBCOMPONENT;
+          return ComponentKind.PRODUCTION_SUBCOMPONENT;
         default:
           throw new IllegalStateException("no component associated with method " + this);
       }
     }
   }
 
-  @AutoValue
-  abstract static class BuilderRequirementMethod {
-    abstract ExecutableElement method();
-
-    abstract ComponentRequirement requirement();
-  }
-
-  @AutoValue
-  abstract static class BuilderSpec {
-    abstract TypeElement builderDefinitionType();
-    abstract ImmutableSet<BuilderRequirementMethod> requirementMethods();
-    abstract ExecutableElement buildMethod();
-    abstract TypeMirror componentType();
-  }
-
   static final class Factory {
     private final DaggerElements elements;
-    private final Types types;
+    private final DaggerTypes types;
     private final DependencyRequestFactory dependencyRequestFactory;
     private final ModuleDescriptor.Factory moduleDescriptorFactory;
     private final CompilerOptions compilerOptions;
@@ -447,7 +379,7 @@ Kind componentKind() {
     @Inject
     Factory(
         DaggerElements elements,
-        Types types,
+        DaggerTypes types,
         DependencyRequestFactory dependencyRequestFactory,
         ModuleDescriptor.Factory moduleDescriptorFactory,
         CompilerOptions compilerOptions) {
@@ -459,32 +391,31 @@ Kind componentKind() {
     }
 
     /**
-     * Returns a component descriptor for a type annotated with either {@link Component @Component}
-     * or {@link ProductionComponent @ProductionComponent}. This is also compatible with {@link
-     * Subcomponent @Subcomponent} or {@link ProductionSubcomponent @ProductionSubcomponent} when
-     * generating ahead-of-time subcomponents.
+     * Returns a component descriptor for a type.
+     *
+     * <p>The type must be annotated with a top-level component annotation unless ahead-of-time
+     * subcomponents are being generated or we are creating a descriptor for a module in order to
+     * validate its bindings.
      */
-    ComponentDescriptor forComponent(TypeElement componentType) {
-      Optional<Kind> kind = Kind.forAnnotatedElement(componentType);
+    ComponentDescriptor forTypeElement(TypeElement typeElement) {
+      Optional<ComponentKind> kind = ComponentKind.forAnnotatedElement(typeElement);
       checkArgument(
-          kind.isPresent(), "%s must have a component or subcomponent annotation", componentType);
+          kind.isPresent(),
+          "%s must have a component or subcomponent or module annotation",
+          typeElement);
       if (!compilerOptions.aheadOfTimeSubcomponents()) {
-        checkArgument(kind.get().isTopLevel(),
-            "%s must be annotated with @Component or @ProductionComponent.",
-            componentType);
+        checkArgument(kind.get().isTopLevel(), "%s must be a top-level component.", typeElement);
       }
-      return create(componentType, kind.get(), Optional.empty());
+      return create(typeElement, kind.get());
     }
 
-    private ComponentDescriptor create(
-        TypeElement componentDefinitionType, Kind kind, Optional<Kind> parentKind) {
-      DeclaredType declaredComponentType = MoreTypes.asDeclared(componentDefinitionType.asType());
-      AnnotationMirror componentMirror =
-          getAnnotationMirror(componentDefinitionType, kind.annotationType()).get();
+    private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind) {
+      AnnotationMirror componentAnnotation =
+          getAnnotationMirror(typeElement, kind.annotation()).get();
+      DeclaredType declaredComponentType = MoreTypes.asDeclared(typeElement.asType());
       ImmutableSet<ComponentRequirement> componentDependencies =
-          kind.isTopLevel()
-              ? getComponentDependencies(componentMirror)
-                  .stream()
+          kind.isTopLevel() && !kind.isForModuleValidation()
+              ? getComponentDependencies(componentAnnotation).stream()
                   .map(ComponentRequirement::forDependency)
                   .collect(toImmutableSet())
               : ImmutableSet.of();
@@ -501,78 +432,78 @@ private ComponentDescriptor create(
         }
       }
 
-      ImmutableSet.Builder<ModuleDescriptor> modulesBuilder = ImmutableSet.builder();
-      for (TypeMirror componentModulesType : getComponentModules(componentMirror)) {
-        modulesBuilder.add(
-            moduleDescriptorFactory.create(MoreTypes.asTypeElement(componentModulesType)));
-      }
-      if (kind.equals(Kind.PRODUCTION_COMPONENT)
-          || (kind.equals(Kind.PRODUCTION_SUBCOMPONENT)
-              && parentKind.isPresent()
-              && (parentKind.get().equals(Kind.COMPONENT)
-                  || parentKind.get().equals(Kind.SUBCOMPONENT)))) {
-        modulesBuilder.add(descriptorForMonitoringModule(componentDefinitionType));
-        modulesBuilder.add(descriptorForProductionExecutorModule(componentDefinitionType));
-      }
-      ImmutableSet<ModuleDescriptor> modules = modulesBuilder.build();
-      ImmutableSet<ModuleDescriptor> transitiveModules = transitiveModules(modules);
+      ImmutableSet<TypeElement> modules =
+          kind.isForModuleValidation()
+              ? ImmutableSet.of(typeElement)
+              : getComponentModules(componentAnnotation).stream()
+                  .map(MoreTypes::asTypeElement)
+                  .collect(toImmutableSet());
+
+      ImmutableSet<ModuleDescriptor> transitiveModules =
+          moduleDescriptorFactory.transitiveModules(modules);
+
       ImmutableSet.Builder<ComponentDescriptor> subcomponentsFromModules = ImmutableSet.builder();
       for (ModuleDescriptor module : transitiveModules) {
         for (SubcomponentDeclaration subcomponentDeclaration : module.subcomponentDeclarations()) {
           TypeElement subcomponent = subcomponentDeclaration.subcomponentType();
           subcomponentsFromModules.add(
-              create(
-                  subcomponent, Kind.forAnnotatedElement(subcomponent).get(), Optional.of(kind)));
+              create(subcomponent, ComponentKind.forAnnotatedElement(subcomponent).get()));
         }
       }
-      ImmutableSet<ExecutableElement> unimplementedMethods =
-          elements.getUnimplementedMethods(componentDefinitionType);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
-
       ImmutableBiMap.Builder<ComponentMethodDescriptor, ComponentDescriptor>
           subcomponentsByFactoryMethod = ImmutableBiMap.builder();
       ImmutableBiMap.Builder<ComponentMethodDescriptor, ComponentDescriptor>
           subcomponentsByBuilderMethod = ImmutableBiMap.builder();
-      for (ExecutableElement componentMethod : unimplementedMethods) {
-        ExecutableType resolvedMethod =
-            MoreTypes.asExecutable(types.asMemberOf(declaredComponentType, componentMethod));
-        ComponentMethodDescriptor componentMethodDescriptor =
-            getDescriptorForComponentMethod(componentDefinitionType, kind, componentMethod);
-        componentMethodsBuilder.add(componentMethodDescriptor);
-        switch (componentMethodDescriptor.kind()) {
-          case SUBCOMPONENT:
-          case PRODUCTION_SUBCOMPONENT:
-            subcomponentsByFactoryMethod.put(
-                componentMethodDescriptor,
-                create(
-                    MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
-                    componentMethodDescriptor.kind().componentKind(),
-                    Optional.of(kind)));
-            break;
-          case SUBCOMPONENT_BUILDER:
-          case PRODUCTION_SUBCOMPONENT_BUILDER:
-            subcomponentsByBuilderMethod.put(
-                componentMethodDescriptor,
-                create(
-                    MoreElements.asType(
-                        MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
-                    componentMethodDescriptor.kind().componentKind(),
-                    Optional.of(kind)));
-            break;
-          default: // nothing special to do for other methods.
+      if (!kind.isForModuleValidation()) {
+        ImmutableSet<ExecutableElement> unimplementedMethods =
+            elements.getUnimplementedMethods(typeElement);
+        for (ExecutableElement componentMethod : unimplementedMethods) {
+          ExecutableType resolvedMethod =
+              MoreTypes.asExecutable(types.asMemberOf(declaredComponentType, componentMethod));
+          ComponentMethodDescriptor componentMethodDescriptor =
+              getDescriptorForComponentMethod(typeElement, kind, componentMethod);
+          componentMethodsBuilder.add(componentMethodDescriptor);
+          switch (componentMethodDescriptor.kind()) {
+            case SUBCOMPONENT:
+            case PRODUCTION_SUBCOMPONENT:
+              subcomponentsByFactoryMethod.put(
+                  componentMethodDescriptor,
+                  create(
+                      MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
+                      componentMethodDescriptor.kind().componentKind()));
+              break;
+
+            case SUBCOMPONENT_BUILDER:
+            case PRODUCTION_SUBCOMPONENT_BUILDER:
+              subcomponentsByBuilderMethod.put(
+                  componentMethodDescriptor,
+                  create(
+                      MoreElements.asType(
+                          MoreTypes.asElement(resolvedMethod.getReturnType())
+                              .getEnclosingElement()),
+                      componentMethodDescriptor.kind().componentKind()));
+              break;
+
+            default: // nothing special to do for other methods.
+          }
         }
       }
 
-      ImmutableList<DeclaredType> enclosedBuilders = kind.builderAnnotationType() == null
-          ? ImmutableList.<DeclaredType>of()
-          : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());
-      Optional<DeclaredType> builderType =
-          Optional.ofNullable(getOnlyElement(enclosedBuilders, null));
-      Optional<BuilderSpec> builderSpec = createBuilderSpec(builderType);
-
-      ImmutableSet<Scope> scopes = scopesOf(componentDefinitionType);
+      ImmutableList<DeclaredType> enclosedCreators =
+          kind.builderAnnotation()
+              .map(builderAnnotation -> enclosedAnnotatedTypes(typeElement, builderAnnotation))
+              .orElse(ImmutableList.of());
+      Optional<ComponentCreatorDescriptor> creatorDescriptor =
+          enclosedCreators.isEmpty()
+              ? Optional.empty()
+              : Optional.of(
+                  ComponentCreatorDescriptor.create(
+                      getOnlyElement(enclosedCreators), elements, types, dependencyRequestFactory));
+
+      ImmutableSet<Scope> scopes = scopesOf(typeElement);
       if (kind.isProducer()) {
         scopes =
             ImmutableSet.<Scope>builder().addAll(scopes).add(productionScope(elements)).build();
@@ -580,10 +511,9 @@ private ComponentDescriptor create(
 
       return new AutoValue_ComponentDescriptor(
           kind,
-          componentMirror,
-          componentDefinitionType,
+          componentAnnotation,
+          typeElement,
           componentDependencies,
-          modules,
           transitiveModules,
           dependenciesByDependencyMethod.build(),
           scopes,
@@ -591,11 +521,13 @@ private ComponentDescriptor create(
           subcomponentsByFactoryMethod.build(),
           subcomponentsByBuilderMethod.build(),
           componentMethodsBuilder.build(),
-          builderSpec);
+          creatorDescriptor);
     }
 
     private ComponentMethodDescriptor getDescriptorForComponentMethod(
-        TypeElement componentElement, Kind componentKind, ExecutableElement componentMethod) {
+        TypeElement componentElement,
+        ComponentKind componentKind,
+        ExecutableElement componentMethod) {
       ExecutableType resolvedComponentMethod =
           MoreTypes.asExecutable(
               types.asMemberOf(MoreTypes.asDeclared(componentElement.asType()), componentMethod));
@@ -615,11 +547,11 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
                     ? ComponentMethodKind.SUBCOMPONENT
                     : ComponentMethodKind.PRODUCTION_SUBCOMPONENT,
                 componentMethod);
-          } else if (isSubcomponentBuilder(returnTypeElement)) {
+          } else if (isSubcomponentCreator(returnTypeElement)) {
             DependencyRequest dependencyRequest =
                 dependencyRequestFactory.forComponentProvisionMethod(
                     componentMethod, resolvedComponentMethod);
-            return ComponentMethodDescriptor.forSubcomponentBuilder(
+            return ComponentMethodDescriptor.forSubcomponentCreator(
                 isAnnotationPresent(returnTypeElement, Subcomponent.Builder.class)
                     ? ComponentMethodKind.SUBCOMPONENT_BUILDER
                     : ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER,
@@ -662,101 +594,6 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
 
       throw new IllegalArgumentException("not a valid component method: " + componentMethod);
     }
-
-    private Optional<BuilderSpec> createBuilderSpec(Optional<DeclaredType> builderType) {
-      if (!builderType.isPresent()) {
-        return Optional.empty();
-      }
-      TypeElement element = MoreTypes.asTypeElement(builderType.get());
-      ImmutableSet<ExecutableElement> methods = elements.getUnimplementedMethods(element);
-      ImmutableSet.Builder<BuilderRequirementMethod> requirementMethods = ImmutableSet.builder();
-      ExecutableElement buildMethod = null;
-      for (ExecutableElement method : methods) {
-        if (method.getParameters().isEmpty()) {
-          buildMethod = method;
-        } else {
-          ExecutableType resolved =
-              MoreTypes.asExecutable(types.asMemberOf(builderType.get(), method));
-          requirementMethods.add(
-              new AutoValue_ComponentDescriptor_BuilderRequirementMethod(
-                  method, requirementForBuilderMethod(method, resolved)));
-        }
-      }
-      verify(buildMethod != null); // validation should have ensured this.
-      return Optional.of(
-          new AutoValue_ComponentDescriptor_BuilderSpec(
-              element,
-              requirementMethods.build(),
-              buildMethod,
-              element.getEnclosingElement().asType()));
-    }
-
-    private ComponentRequirement requirementForBuilderMethod(
-        ExecutableElement method, ExecutableType resolvedType) {
-      checkArgument(method.getParameters().size() == 1);
-      if (isAnnotationPresent(method, BindsInstance.class)) {
-        DependencyRequest request =
-            dependencyRequestFactory.forRequiredResolvedVariable(
-                getOnlyElement(method.getParameters()),
-                getOnlyElement(resolvedType.getParameterTypes()));
-        return ComponentRequirement.forBoundInstance(
-            request.key(), request.isNullable(), method.getSimpleName().toString());
-      }
-
-      TypeMirror type = getOnlyElement(resolvedType.getParameterTypes());
-      return ConfigurationAnnotations.getModuleAnnotation(MoreTypes.asTypeElement(type)).isPresent()
-          ? ComponentRequirement.forModule(type)
-          : ComponentRequirement.forDependency(type);
-    }
-
-    /**
-     * Returns a descriptor for a generated module that handles monitoring for production
-     * components. This module is generated in the {@link MonitoringModuleProcessingStep}.
-     *
-     * @throws TypeNotPresentException if the module has not been generated yet. This will cause the
-     *     processor to retry in a later processing round.
-     */
-    private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
-      ClassName monitoringModuleName =
-          SourceFiles.generatedMonitoringModuleName(componentDefinitionType);
-      TypeElement monitoringModule = elements.checkTypePresent(monitoringModuleName.toString());
-      return moduleDescriptorFactory.create(monitoringModule);
-    }
-
-    /**
-     * Returns a descriptor for a generated module that handles the producer executor for production
-     * components. This module is generated in the {@link ProductionExecutorModuleProcessingStep}.
-     *
-     * @throws TypeNotPresentException if the module has not been generated yet. This will cause the
-     *     processor to retry in a later processing round.
-     */
-    // TODO(beder): Replace this with a single class when the producers client library exists.
-    private ModuleDescriptor descriptorForProductionExecutorModule(
-        TypeElement componentDefinitionType) {
-      ClassName productionExecutorModuleName =
-          SourceFiles.generatedProductionExecutorModuleName(componentDefinitionType);
-      TypeElement productionExecutorModule =
-          elements.checkTypePresent(productionExecutorModuleName.toString());
-      return moduleDescriptorFactory.create(productionExecutorModule);
-    }
-
-    private ImmutableSet<ModuleDescriptor> transitiveModules(
-        Iterable<ModuleDescriptor> topLevelModules) {
-      Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
-      for (ModuleDescriptor module : topLevelModules) {
-        addTransitiveModules(transitiveModules, module);
-      }
-      return ImmutableSet.copyOf(transitiveModules);
-    }
-
-    private void addTransitiveModules(
-        Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
-      if (transitiveModules.add(module)) {
-        for (TypeElement includedModule : module.includedModules()) {
-          addTransitiveModules(transitiveModules, moduleDescriptorFactory.create(includedModule));
-        }
-      }
-    }
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentDescriptorValidator.java b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
index 8cc8b7c64..780c21d2f 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorValidator.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
@@ -16,39 +16,40 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Predicates.in;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.Scopes.getReadableSource;
 import static dagger.internal.codegen.Scopes.scopesOf;
 import static dagger.internal.codegen.Scopes.singletonScope;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
-import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
-import static java.util.stream.Collectors.mapping;
 import static java.util.stream.Collectors.toList;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentRequirement.NullPolicy;
-import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
+import dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages;
 import dagger.model.Scope;
 import java.util.ArrayDeque;
+import java.util.Collection;
 import java.util.Deque;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
@@ -112,7 +113,7 @@
     /** Returns a report that contains all validation messages found during traversal. */
     ValidationReport<TypeElement> buildReport() {
       ValidationReport.Builder<TypeElement> report =
-          ValidationReport.about(rootComponent.componentDefinitionType());
+          ValidationReport.about(rootComponent.typeElement());
       reports.values().forEach(subreport -> report.addSubreport(subreport.build()));
       return report.build();
     }
@@ -120,23 +121,20 @@
     /** Returns the report builder for a (sub)component. */
     private ValidationReport.Builder<TypeElement> report(ComponentDescriptor component) {
       return reentrantComputeIfAbsent(
-          reports,
-          component,
-          descriptor -> ValidationReport.about(descriptor.componentDefinitionType()));
+          reports, component, descriptor -> ValidationReport.about(descriptor.typeElement()));
     }
 
     void visitComponent(ComponentDescriptor component) {
       validateDependencyScopes(component);
       validateComponentDependencyHierarchy(component);
       validateModules(component);
-      validateBuilders(component);
-      component.subcomponents().forEach(this::visitComponent);
+      validateCreators(component);
+      component.childComponents().forEach(this::visitComponent);
     }
 
     /** Validates that component dependencies do not form a cycle. */
     private void validateComponentDependencyHierarchy(ComponentDescriptor component) {
-      validateComponentDependencyHierarchy(
-          component, component.componentDefinitionType(), new ArrayDeque<>());
+      validateComponentDependencyHierarchy(component, component.typeElement(), new ArrayDeque<>());
     }
 
     /** Recursive method to validate that component dependencies do not form a cycle. */
@@ -145,7 +143,7 @@ private void validateComponentDependencyHierarchy(
       if (dependencyStack.contains(dependency)) {
         // Current component has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(component.componentDefinitionType().getQualifiedName());
+        message.append(component.typeElement().getQualifiedName());
         message.append(" contains a cycle in its component dependencies:\n");
         dependencyStack.push(dependency);
         appendIndentedComponentsList(message, dependencyStack);
@@ -154,8 +152,8 @@ private void validateComponentDependencyHierarchy(
             .addItem(
                 message.toString(),
                 compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                component.componentDefinitionType(),
-                getComponentAnnotation(component.componentDefinitionType()).get());
+                component.typeElement(),
+                getComponentAnnotation(component.typeElement()).get());
       } else {
         Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(dependency);
         if (componentAnnotation.isPresent()) {
@@ -201,8 +199,8 @@ private void validateDependencyScopes(ComponentDescriptor component) {
                 .addItem(
                     message.toString(),
                     compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                    component.componentDefinitionType(),
-                    component.componentAnnotation());
+                    component.typeElement(),
+                    component.annotation());
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
@@ -211,42 +209,33 @@ private void validateDependencyScopes(ComponentDescriptor component) {
             message.append(getReadableSource(scope)).append(' ');
           }
           message
-              .append(component.componentDefinitionType().getQualifiedName())
+              .append(component.typeElement().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
           report(component)
-              .addError(
-                  message.toString(),
-                  component.componentDefinitionType(),
-                  component.componentAnnotation());
+              .addError(message.toString(), component.typeElement(), component.annotation());
         } else {
           // Dagger 1.x scope compatibility requires this be suppress-able.
           if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
             validateDependencyScopeHierarchy(
-                component,
-                component.componentDefinitionType(),
-                new ArrayDeque<ImmutableSet<Scope>>(),
-                new ArrayDeque<TypeElement>());
+                component, component.typeElement(), new ArrayDeque<>(), new ArrayDeque<>());
           }
         }
       } else {
         // Scopeless components may not depend on scoped components.
         if (!scopedDependencies.isEmpty()) {
           StringBuilder message =
-              new StringBuilder(component.componentDefinitionType().getQualifiedName())
+              new StringBuilder(component.typeElement().getQualifiedName())
                   .append(" (unscoped) cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
           report(component)
-              .addError(
-                  message.toString(),
-                  component.componentDefinitionType(),
-                  component.componentAnnotation());
+              .addError(message.toString(), component.typeElement(), component.annotation());
         }
       }
     }
 
     private void validateModules(ComponentDescriptor component) {
-      for (ModuleDescriptor module : component.transitiveModules()) {
+      for (ModuleDescriptor module : component.modules()) {
         if (module.moduleElement().getModifiers().contains(Modifier.ABSTRACT)) {
           for (ContributionBinding binding : module.bindings()) {
             if (binding.requiresModuleInstance()) {
@@ -276,81 +265,84 @@ private String abstractModuleHasInstanceBindingMethodsError(ModuleDescriptor mod
           module.moduleElement(), methodAnnotations);
     }
 
-    private void validateBuilders(ComponentDescriptor component) {
-      ComponentDescriptor componentDesc = component;
-      if (!componentDesc.builderSpec().isPresent()) {
+    private void validateCreators(ComponentDescriptor component) {
+      if (!component.creatorDescriptor().isPresent()) {
         // If no builder, nothing to validate.
         return;
       }
 
-      Set<ComponentRequirement> availableDependencies = component.availableDependencies();
-      Set<ComponentRequirement> requiredDependencies =
-          Sets.filter(
-              availableDependencies,
-              input -> input.nullPolicy(elements, types).equals(NullPolicy.THROW));
-      final BuilderSpec spec = componentDesc.builderSpec().get();
-      ImmutableSet<BuilderRequirementMethod> declaredSetters =
-          spec.requirementMethods()
-              .stream()
-              .filter(method -> !method.requirement().kind().equals(BOUND_INSTANCE))
-              .collect(toImmutableSet());
-      ImmutableSet<ComponentRequirement> declaredRequirements =
-          declaredSetters
-              .stream()
-              .map(BuilderRequirementMethod::requirement)
-              .collect(toImmutableSet());
-
-      ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(component.kind());
-      Set<ComponentRequirement> extraSetters =
-          Sets.difference(declaredRequirements, availableDependencies);
-      if (!extraSetters.isEmpty()) {
-        List<ExecutableElement> excessMethods =
-            declaredSetters
-                .stream()
-                .filter(method -> extraSetters.contains(method.requirement()))
-                .map(BuilderRequirementMethod::method)
-                .collect(toList());
-        Optional<DeclaredType> container =
-            Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType()));
+      ComponentCreatorDescriptor creator = component.creatorDescriptor().get();
+      ComponentCreatorMessages msgs = ErrorMessages.creatorMessagesFor(component.kind());
+
+      // Requirements for modules and dependencies that the creator can set
+      Set<ComponentRequirement> creatorModuleAndDependencyRequirements =
+          creator.moduleAndDependencyRequirements();
+      // Modules and dependencies the component requires
+      Set<ComponentRequirement> componentModuleAndDependencyRequirements =
+          component.dependenciesAndConcreteModules();
+
+      // Requirements that the creator can set that don't match any requirements that the component
+      // actually has.
+      Set<ComponentRequirement> inapplicableRequirementsOnCreator =
+          Sets.difference(
+              creatorModuleAndDependencyRequirements, componentModuleAndDependencyRequirements);
+
+      if (!inapplicableRequirementsOnCreator.isEmpty()) {
+        Collection<ExecutableElement> excessElements =
+            Multimaps.filterKeys(
+                    creator.requirementElements(), in(inapplicableRequirementsOnCreator))
+                .values();
+        Optional<DeclaredType> container = Optional.of(asDeclared(creator.typeElement().asType()));
         String formatted =
-            excessMethods
-                .stream()
+            excessElements.stream()
                 .map(method -> methodSignatureFormatter.format(method, container))
                 .collect(joining(", ", "[", "]"));
         report(component)
-            .addError(String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
+            .addError(String.format(msgs.extraSetters(), formatted), creator.typeElement());
       }
 
-      Set<ComponentRequirement> missingSetters =
-          Sets.difference(requiredDependencies, declaredRequirements);
-      if (!missingSetters.isEmpty()) {
+      // Component requirements that the creator must be able to set
+      Set<ComponentRequirement> mustBePassed =
+          Sets.filter(
+              componentModuleAndDependencyRequirements,
+              input -> input.nullPolicy(elements, types).equals(NullPolicy.THROW));
+      // Component requirements that the creator must be able to set, but can't
+      Set<ComponentRequirement> missingRequirements =
+          Sets.difference(mustBePassed, creatorModuleAndDependencyRequirements);
+
+      if (!missingRequirements.isEmpty()) {
         report(component)
             .addError(
                 String.format(
                     msgs.missingSetters(),
-                    missingSetters.stream().map(ComponentRequirement::type).collect(toList())),
-                spec.builderDefinitionType());
+                    missingRequirements.stream().map(ComponentRequirement::type).collect(toList())),
+                creator.typeElement());
       }
 
       // Validate that declared builder requirements (modules, dependencies) have unique types.
-      Map<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> declaredRequirementsByType =
-          spec.requirementMethods()
+      ImmutableSetMultimap<Wrapper<TypeMirror>, ExecutableElement> declaredRequirementsByType =
+          Multimaps.filterKeys(
+                  creator.requirementElements(), in(creatorModuleAndDependencyRequirements))
+              .entries()
               .stream()
-              .filter(method -> !method.requirement().kind().equals(BOUND_INSTANCE))
               .collect(
-                  groupingBy(
-                      method -> method.requirement().wrappedType(),
-                      mapping(method -> method.method(), toList())));
-      for (Map.Entry<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> entry :
-          declaredRequirementsByType.entrySet()) {
-        if (entry.getValue().size() > 1) {
-          TypeMirror type = entry.getKey().get();
-          report(component)
-              .addError(
-                  String.format(msgs.manyMethodsForType(), type, entry.getValue()),
-                  spec.builderDefinitionType());
-        }
-      }
+                  toImmutableSetMultimap(entry -> entry.getKey().wrappedType(), Entry::getValue));
+      declaredRequirementsByType
+          .asMap()
+          .forEach(
+              (typeWrapper, elementsForType) -> {
+                if (elementsForType.size() > 1) {
+                  TypeMirror type = typeWrapper.get();
+                  report(component)
+                      .addError(
+                          String.format(msgs.manyMethodsForType(), type, elementsForType),
+                          creator.typeElement());
+                }
+              });
+
+      // TODO(cgdecker): Duplicate binding validation should handle the case of multiple elements
+      // that set the same bound-instance Key, but validating that here would make it fail faster
+      // for subcomponents.
     }
 
     /**
@@ -372,7 +364,7 @@ private void validateDependencyScopeHierarchy(
         scopedDependencyStack.push(dependency);
         // Current scope has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(component.componentDefinitionType().getQualifiedName());
+        message.append(component.typeElement().getQualifiedName());
         message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
         appendIndentedComponentsList(message, scopedDependencyStack);
         if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
@@ -380,8 +372,8 @@ private void validateDependencyScopeHierarchy(
               .addItem(
                   message.toString(),
                   compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                  component.componentDefinitionType(),
-                  getComponentAnnotation(component.componentDefinitionType()).get());
+                  component.typeElement(),
+                  getComponentAnnotation(component.typeElement()).get());
         }
         scopedDependencyStack.pop();
       } else {
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index d15341cf3..dad54b7f7 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.SourceFiles.classFileName;
 
 import com.squareup.javapoet.ClassName;
@@ -32,32 +33,21 @@
  * Generates the implementation of the abstract types annotated with {@link Component}.
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
-  private final DaggerTypes types;
-  private final DaggerElements elements;
-  private final KeyFactory keyFactory;
-  private final CompilerOptions compilerOptions;
-  private final BindingGraphFactory bindingGraphFactory;
+  private final ComponentImplementationFactory componentImplementationFactory;
 
   @Inject
   ComponentGenerator(
       Filer filer,
       DaggerElements elements,
       SourceVersion sourceVersion,
-      DaggerTypes types,
-      KeyFactory keyFactory,
-      CompilerOptions compilerOptions,
-      BindingGraphFactory bindingGraphFactory) {
+      ComponentImplementationFactory componentImplementationFactory) {
     super(filer, elements, sourceVersion);
-    this.types = types;
-    this.elements = elements;
-    this.keyFactory = keyFactory;
-    this.compilerOptions = compilerOptions;
-    this.bindingGraphFactory = bindingGraphFactory;
+    this.componentImplementationFactory = componentImplementationFactory;
   }
 
   @Override
   ClassName nameGeneratedType(BindingGraph input) {
-    return componentName(input.componentType());
+    return componentName(input.componentTypeElement());
   }
 
   static ClassName componentName(TypeElement componentDefinitionType) {
@@ -67,20 +57,14 @@ static ClassName componentName(TypeElement componentDefinitionType) {
 
   @Override
   Element originatingElement(BindingGraph input) {
-    return input.componentType();
+    return input.componentTypeElement();
   }
 
   @Override
-  Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
-    return Optional.of(
-        ComponentModelBuilder.buildComponentModel(
-                types,
-                elements,
-                keyFactory,
-                compilerOptions,
-                componentName,
-                input,
-                bindingGraphFactory)
-            .generate());
+  Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph bindingGraph) {
+    ComponentImplementation componentImplementation =
+        componentImplementationFactory.createComponentImplementation(bindingGraph);
+    verify(componentImplementation.name().equals(componentName));
+    return Optional.of(componentImplementation.generate());
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index a921825d7..22c657e91 100644
--- a/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -48,13 +48,11 @@
 
   ValidationReport<TypeElement> validate(ComponentDescriptor componentDescriptor) {
     ValidationReport.Builder<TypeElement> report =
-        ValidationReport.about(componentDescriptor.componentDefinitionType());
+        ValidationReport.about(componentDescriptor.typeElement());
     validateSubcomponentMethods(
         report,
         componentDescriptor,
-        Maps.toMap(
-            componentDescriptor.transitiveModuleTypes(),
-            constant(componentDescriptor.componentDefinitionType())));
+        Maps.toMap(componentDescriptor.moduleTypes(), constant(componentDescriptor.typeElement())));
 
     if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
       validateScopeHierarchy(
@@ -67,38 +65,51 @@ private void validateSubcomponentMethods(
       ValidationReport.Builder<?> report,
       ComponentDescriptor componentDescriptor,
       ImmutableMap<TypeElement, TypeElement> existingModuleToOwners) {
-    for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
-        componentDescriptor.subcomponentsByFactoryMethod().entrySet()) {
-      ComponentMethodDescriptor subcomponentMethodDescriptor = subcomponentEntry.getKey();
-      ComponentDescriptor subcomponentDescriptor = subcomponentEntry.getValue();
-      // validate the way that we create subcomponents
-      for (VariableElement factoryMethodParameter :
-          subcomponentMethodDescriptor.methodElement().getParameters()) {
-        TypeElement moduleType = MoreTypes.asTypeElement(factoryMethodParameter.asType());
-        TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
-        if (originatingComponent != null) {
-          /* Factory method tries to pass a module that is already present in the parent.
-           * This is an error. */
-          report.addError(
-              String.format(
-                  "%s is present in %s. A subcomponent cannot use an instance of a "
-                      + "module that differs from its parent.",
-                  moduleType.getSimpleName(), originatingComponent.getQualifiedName()),
-              factoryMethodParameter);
-        }
+    componentDescriptor
+        .childComponentsDeclaredByFactoryMethods()
+        .forEach(
+            (method, childComponent) -> {
+              if (childComponent.hasCreator()) {
+                report.addError(
+                    "Components may not have factory methods for subcomponents that define a "
+                        + "builder.",
+                    method.methodElement());
+              } else {
+                validateFactoryMethodParameters(report, method, existingModuleToOwners);
+              }
+
+              validateSubcomponentMethods(
+                  report,
+                  childComponent,
+                  new ImmutableMap.Builder<TypeElement, TypeElement>()
+                      .putAll(existingModuleToOwners)
+                      .putAll(
+                          Maps.toMap(
+                              Sets.difference(
+                                  childComponent.moduleTypes(), existingModuleToOwners.keySet()),
+                              constant(childComponent.typeElement())))
+                      .build());
+            });
+  }
+
+  private void validateFactoryMethodParameters(
+      ValidationReport.Builder<?> report,
+      ComponentMethodDescriptor subcomponentMethodDescriptor,
+      ImmutableMap<TypeElement, TypeElement> existingModuleToOwners) {
+    for (VariableElement factoryMethodParameter :
+        subcomponentMethodDescriptor.methodElement().getParameters()) {
+      TypeElement moduleType = MoreTypes.asTypeElement(factoryMethodParameter.asType());
+      TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
+      if (originatingComponent != null) {
+        /* Factory method tries to pass a module that is already present in the parent.
+         * This is an error. */
+        report.addError(
+            String.format(
+                "%s is present in %s. A subcomponent cannot use an instance of a "
+                    + "module that differs from its parent.",
+                moduleType.getSimpleName(), originatingComponent.getQualifiedName()),
+            factoryMethodParameter);
       }
-      validateSubcomponentMethods(
-          report,
-          subcomponentDescriptor,
-          new ImmutableMap.Builder<TypeElement, TypeElement>()
-              .putAll(existingModuleToOwners)
-              .putAll(
-                  Maps.toMap(
-                      Sets.difference(
-                          subcomponentDescriptor.transitiveModuleTypes(),
-                          existingModuleToOwners.keySet()),
-                      constant(subcomponentDescriptor.componentDefinitionType())))
-              .build());
     }
   }
 
@@ -111,8 +122,8 @@ private void validateScopeHierarchy(
       SetMultimap<ComponentDescriptor, Scope> scopesByComponent) {
     scopesByComponent.putAll(subject, subject.scopes());
 
-    for (ComponentDescriptor child : subject.subcomponents()) {
-      validateScopeHierarchy(report, child, scopesByComponent);
+    for (ComponentDescriptor childComponent : subject.childComponents()) {
+      validateScopeHierarchy(report, childComponent, scopesByComponent);
     }
 
     scopesByComponent.removeAll(subject);
@@ -127,19 +138,20 @@ private void validateScopeHierarchy(
     if (!overlappingScopes.isEmpty()) {
       StringBuilder error =
           new StringBuilder()
-              .append(subject.componentDefinitionType().getQualifiedName())
+              .append(subject.typeElement().getQualifiedName())
               .append(" has conflicting scopes:");
       for (Map.Entry<ComponentDescriptor, Scope> entry : overlappingScopes.entries()) {
         Scope scope = entry.getValue();
-        error.append("\n  ")
-            .append(entry.getKey().componentDefinitionType().getQualifiedName())
+        error
+            .append("\n  ")
+            .append(entry.getKey().typeElement().getQualifiedName())
             .append(" also has ")
             .append(getReadableSource(scope));
       }
       report.addItem(
           error.toString(),
           compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-          subject.componentDefinitionType());
+          subject.typeElement());
     }
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index cedc3896c..6fdcc77a4 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -22,7 +22,8 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static dagger.internal.codegen.ComponentGenerator.componentName;
-import static dagger.internal.codegen.ComponentProcessingStep.getElementsFromAnnotations;
+import static dagger.internal.codegen.ComponentKind.annotationsFor;
+import static dagger.internal.codegen.ComponentKind.topLevelComponentKinds;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -31,21 +32,18 @@
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.BindsInstance;
-import dagger.Component;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
-import dagger.producers.ProductionComponent;
+import dagger.producers.internal.CancellationListener;
 import java.lang.annotation.Annotation;
 import java.util.Optional;
 import java.util.Set;
@@ -74,7 +72,7 @@
  * <p>The components emitted by this processing step include all of the API elements exposed by the
  * normal step. Method bodies are omitted as Turbine ignores them entirely.
  */
-final class ComponentHjarProcessingStep implements ProcessingStep {
+final class ComponentHjarProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Elements elements;
   private final SourceVersion sourceVersion;
   private final Types types;
@@ -92,6 +90,7 @@
       Messager messager,
       ComponentValidator componentValidator,
       Factory componentDescriptorFactory) {
+    super(MoreElements::asType);
     this.elements = elements;
     this.sourceVersion = sourceVersion;
     this.types = types;
@@ -103,37 +102,23 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(Component.class, ProductionComponent.class);
+    return annotationsFor(topLevelComponentKinds());
   }
 
   @Override
-  public ImmutableSet<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-
-    ImmutableSet<Element> componentElements =
-        getElementsFromAnnotations(
-            elementsByAnnotation, Component.class, ProductionComponent.class);
-
-    for (Element element : componentElements) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      try {
-        // TODO(ronshapiro): component validation might not be necessary. We should measure it and
-        // figure out if it's worth seeing if removing it will still work. We could potentially
-        // add a new catch clause for any exception that's not TypeNotPresentException and ignore
-        // the component entirely in that case.
-        ComponentValidationReport validationReport =
-            componentValidator.validate(componentTypeElement, ImmutableSet.of(), ImmutableSet.of());
-        validationReport.report().printMessagesTo(messager);
-        if (validationReport.report().isClean()) {
-          new EmptyComponentGenerator(filer, elements, sourceVersion)
-              .generate(componentDescriptorFactory.forComponent(componentTypeElement), messager);
-        }
-      } catch (TypeNotPresentException e) {
-        rejectedElements.add(componentTypeElement);
-      }
+  protected void process(
+      TypeElement componentTypeElement, ImmutableSet<Class<? extends Annotation>> annotations) {
+    // TODO(ronshapiro): component validation might not be necessary. We should measure it and
+    // figure out if it's worth seeing if removing it will still work. We could potentially add a
+    // new catch clause for any exception that's not TypeNotPresentException and ignore the
+    // component entirely in that case.
+    ComponentValidationReport validationReport =
+        componentValidator.validate(componentTypeElement, ImmutableSet.of(), ImmutableSet.of());
+    validationReport.report().printMessagesTo(messager);
+    if (validationReport.report().isClean()) {
+      new EmptyComponentGenerator(filer, elements, sourceVersion)
+          .generate(componentDescriptorFactory.forTypeElement(componentTypeElement), messager);
     }
-    return rejectedElements.build();
   }
 
   private final class EmptyComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
@@ -143,12 +128,12 @@
 
     @Override
     ClassName nameGeneratedType(ComponentDescriptor input) {
-      return componentName(input.componentDefinitionType());
+      return componentName(input.typeElement());
     }
 
     @Override
     Element originatingElement(ComponentDescriptor input) {
-      return input.componentDefinitionType();
+      return input.typeElement();
     }
 
     @Override
@@ -158,13 +143,13 @@ Element originatingElement(ComponentDescriptor input) {
           TypeSpec.classBuilder(generatedTypeName)
               .addModifiers(PUBLIC, FINAL)
               .addMethod(privateConstructor());
-      TypeElement componentElement = componentDescriptor.componentDefinitionType();
+      TypeElement componentElement = componentDescriptor.typeElement();
       addSupertype(generatedComponent, componentElement);
 
       TypeName builderMethodReturnType;
-      if (componentDescriptor.builderSpec().isPresent()) {
+      if (componentDescriptor.creatorDescriptor().isPresent()) {
         builderMethodReturnType =
-            ClassName.get(componentDescriptor.builderSpec().get().builderDefinitionType());
+            ClassName.get(componentDescriptor.creatorDescriptor().get().typeElement());
       } else {
         TypeSpec.Builder builder =
             TypeSpec.classBuilder("Builder")
@@ -188,7 +173,7 @@ Element originatingElement(ComponentDescriptor input) {
       }
 
       DeclaredType componentType = MoreTypes.asDeclared(componentElement.asType());
-      // TODO(ronshapiro): unify with ComponentModelBuilder
+      // TODO(ronshapiro): unify with ComponentImplementationBuilder
       Set<MethodSignature> methodSignatures =
           Sets.newHashSetWithExpectedSize(componentDescriptor.componentMethods().size());
       componentDescriptor
@@ -204,6 +189,12 @@ Element originatingElement(ComponentDescriptor input) {
                   generatedComponent.addMethod(
                       emptyComponentMethod(componentElement, method.methodElement())));
 
+      if (componentDescriptor.kind().isProducer()) {
+        generatedComponent
+            .addSuperinterface(ClassName.get(CancellationListener.class))
+            .addMethod(onProducerFutureCancelledMethod());
+      }
+
       return Optional.of(generatedComponent);
     }
   }
@@ -219,24 +210,21 @@ private MethodSpec privateConstructor() {
 
   /**
    * Returns the {@link ComponentRequirement}s for a component that does not have a {@link
-   * ComponentDescriptor#builderSpec()}.
+   * ComponentDescriptor#creatorDescriptor()}.
    */
   private Stream<ComponentRequirement> componentRequirements(ComponentDescriptor component) {
     checkArgument(component.kind().isTopLevel());
     return Stream.concat(
         component.dependencies().stream(),
-        component
-            .transitiveModules()
-            .stream()
+        component.modules().stream()
             .filter(module -> !module.moduleElement().getModifiers().contains(ABSTRACT))
             .map(module -> ComponentRequirement.forModule(module.moduleElement().asType())));
   }
 
   private boolean hasBindsInstanceMethods(ComponentDescriptor componentDescriptor) {
-    return componentDescriptor.builderSpec().isPresent()
+    return componentDescriptor.creatorDescriptor().isPresent()
         && methodsIn(
-                elements.getAllMembers(
-                    componentDescriptor.builderSpec().get().builderDefinitionType()))
+                elements.getAllMembers(componentDescriptor.creatorDescriptor().get().typeElement()))
             .stream()
             .anyMatch(method -> isAnnotationPresent(method, BindsInstance.class));
   }
@@ -255,7 +243,7 @@ private MethodSpec builderInstanceMethod(
   private MethodSpec builderBuildMethod(ComponentDescriptor component) {
     return MethodSpec.methodBuilder("build")
         .addModifiers(PUBLIC)
-        .returns(ClassName.get(component.componentDefinitionType()))
+        .returns(ClassName.get(component.typeElement()))
         .build();
   }
 
@@ -269,7 +257,14 @@ private MethodSpec staticBuilderMethod(TypeName builderMethodReturnType) {
   private MethodSpec createMethod(ComponentDescriptor componentDescriptor) {
     return MethodSpec.methodBuilder("create")
         .addModifiers(PUBLIC, STATIC)
-        .returns(ClassName.get(componentDescriptor.componentDefinitionType()))
+        .returns(ClassName.get(componentDescriptor.typeElement()))
+        .build();
+  }
+
+  private MethodSpec onProducerFutureCancelledMethod() {
+    return MethodSpec.methodBuilder("onProducerFutureCancelled")
+        .addModifiers(PUBLIC)
+        .addParameter(TypeName.BOOLEAN, "mayInterruptIfRunning")
         .build();
   }
 }
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/ComponentImplementation.java
similarity index 50%
rename from java/dagger/internal/codegen/GeneratedComponentModel.java
rename to java/dagger/internal/codegen/ComponentImplementation.java
index 6fe15d0b0..06d345c34 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -20,29 +20,26 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Supplier;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.MultimapBuilder;
 import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
-import dagger.internal.ReferenceReleasingProviderManager;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
@@ -50,17 +47,21 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
+import java.util.Set;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.NestingKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
-/** The model of the component being generated. */
-final class GeneratedComponentModel {
-  /** A type of field that this component model can generate. */
+/** The implementation of a component type. */
+final class ComponentImplementation {
+  /** A type of field that this component can contain. */
   // TODO(user, dpb): Move component requirements and reference managers to top? The order should
   // be component requirements, reference managers, framework fields, private method fields, ... etc
   enum FieldSpecKind {
@@ -74,23 +75,27 @@
     /** A field required by the component, e.g. module instances. */
     COMPONENT_REQUIREMENT_FIELD,
 
-    /** A framework field for type T, e.g. Provider<T>. */
+    /** A framework field for type T, e.g. {@code Provider<T>}. */
     FRAMEWORK_FIELD,
 
-    /** A field for a {@link ReferenceReleasingProviderManager}. */
-    REFERENCE_RELEASING_MANAGER_FIELD,
-
     /** A static field that always returns an absent {@code Optional} value for the binding. */
     ABSENT_OPTIONAL_FIELD
   }
 
-  /** A type of method that this component model can generate. */
+  /** A type of method that this component can contain. */
   // TODO(user, dpb): Change the oder to constructor, initialize, component, then private
   // (including MIM and AOM—why treat those separately?).
   enum MethodSpecKind {
     /** The component constructor. */
     CONSTRUCTOR,
 
+    /**
+     * In ahead-of-time subcomponents, this method coordinates the invocation of {@link
+     * #INITIALIZE_METHOD initialization methods} instead of constructors.
+     */
+    // TODO(b/117833324): try to merge this with other initialize() methods so it looks more natural
+    CONFIGURE_INITIALIZATION_METHOD,
+
     /** A builder method for the component. (Only used by the root component.) */
     BUILDER_METHOD,
 
@@ -115,16 +120,22 @@
      * subcomponents.
      */
     MODIFIABLE_BINDING_METHOD,
+
+    /**
+     * The {@link dagger.producers.internal.CancellationListener#onProducerFutureCancelled(boolean)}
+     * method for a production component.
+     */
+    CANCELLATION_LISTENER_METHOD,
     ;
   }
 
-  /** A type of nested class that this component model can generate. */
+  /** A type of nested class that this component can contain. */
   enum TypeSpecKind {
     /** A factory class for a present optional binding. */
     PRESENT_FACTORY,
 
-    /** A class for the component builder (Only used by the root component.) */
-    COMPONENT_BUILDER,
+    /** A class for the component creator (only used by the root component.) */
+    COMPONENT_CREATOR,
 
     /** A provider class for a component provision. */
     COMPONENT_PROVISION_FACTORY,
@@ -133,15 +144,20 @@
     SUBCOMPONENT
   }
 
+  private final ComponentDescriptor componentDescriptor;
   private final ClassName name;
   private final NestingKind nestingKind;
   private final boolean isAbstract;
-  private final Optional<GeneratedComponentModel> supermodel;
-  private final Map<TypeElement, GeneratedComponentModel> subcomponentModels = new HashMap<>();
+  private final Optional<ComponentImplementation> superclassImplementation;
+  private Optional<ComponentCreatorImplementation> creatorImplementation;
+  private final Map<TypeElement, ComponentImplementation> childImplementations = new HashMap<>();
   private final TypeSpec.Builder component;
+  private final SubcomponentNames subcomponentNames;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final List<CodeBlock> initializations = new ArrayList<>();
+  private final List<CodeBlock> componentRequirementInitializations = new ArrayList<>();
+  private final Set<Key> cancellableProducerKeys = new LinkedHashSet<>();
   private final ListMultimap<FieldSpecKind, FieldSpec> fieldSpecsMap =
       MultimapBuilder.enumKeys(FieldSpecKind.class).arrayListValues().build();
   private final ListMultimap<MethodSpecKind, MethodSpec> methodSpecsMap =
@@ -150,78 +166,172 @@
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
   private final List<Supplier<TypeSpec>> switchingProviderSupplier = new ArrayList<>();
   private final ModifiableBindingMethods modifiableBindingMethods = new ModifiableBindingMethods();
-  private final SetMultimap<Key, DependencyRequest> contributionsByMultibinding =
+  // TODO(b/117833324): can this just be a Set instead of a SetMultimap? The values should be
+  // implicit
+  private final SetMultimap<BindingRequest, DependencyRequest> multibindingContributionsMade =
       HashMultimap.create();
+  private Optional<MethodSpec> configureInitializationMethod = Optional.empty();
+  private final Map<ComponentRequirement, String> modifiableModuleMethods = new LinkedHashMap<>();
 
-  private GeneratedComponentModel(
+  ComponentImplementation(
+      ComponentDescriptor componentDescriptor,
       ClassName name,
       NestingKind nestingKind,
-      Optional<GeneratedComponentModel> supermodel,
+      Optional<ComponentImplementation> superclassImplementation,
+      SubcomponentNames subcomponentNames,
       Modifier... modifiers) {
+    checkName(name, nestingKind);
+    this.componentDescriptor = componentDescriptor;
     this.name = name;
     this.nestingKind = nestingKind;
     this.isAbstract = Arrays.asList(modifiers).contains(ABSTRACT);
-    this.supermodel = supermodel;
+    this.superclassImplementation = superclassImplementation;
     this.component = classBuilder(name).addModifiers(modifiers);
+    this.subcomponentNames = subcomponentNames;
+  }
+
+  ComponentImplementation(
+      ComponentImplementation parent,
+      ComponentDescriptor componentDescriptor,
+      Optional<ComponentImplementation> superclassImplementation,
+      Modifier... modifiers) {
+    this(
+        componentDescriptor,
+        parent.getSubcomponentName(componentDescriptor),
+        NestingKind.MEMBER,
+        superclassImplementation,
+        parent.subcomponentNames,
+        modifiers);
+  }
+
+  // TODO(dpb): Just determine the nesting kind from the name.
+  private static void checkName(ClassName name, NestingKind nestingKind) {
+    switch (nestingKind) {
+      case TOP_LEVEL:
+        checkArgument(
+            name.enclosingClassName() == null, "must be a top-level class name: %s", name);
+        break;
+
+      case MEMBER:
+        checkNotNull(name.enclosingClassName(), "must not be a top-level class name: %s", name);
+        break;
+
+      default:
+        throw new IllegalArgumentException(
+            "nestingKind must be TOP_LEVEL or MEMBER: " + nestingKind);
+    }
+  }
+
+  /** Returns the descriptor for the component being generated. */
+  ComponentDescriptor componentDescriptor() {
+    return componentDescriptor;
+  }
+
+  /** Returns the name of the component. */
+  ClassName name() {
+    return name;
+  }
+
+  /** Returns whether or not the implementation is nested within another class. */
+  boolean isNested() {
+    return nestingKind.isNested();
+  }
+
+  /** Returns whether or not the implementation is abstract. */
+  boolean isAbstract() {
+    return isAbstract;
   }
 
-  /** Create a model for a root component. */
-  static GeneratedComponentModel forComponent(ClassName name) {
-    return new GeneratedComponentModel(
-        name, NestingKind.TOP_LEVEL, Optional.empty(), /* supermodel */ PUBLIC, FINAL);
+  /** Returns the superclass implementation. */
+  Optional<ComponentImplementation> superclassImplementation() {
+    return superclassImplementation;
   }
 
   /**
-   * Create a model for a subcomponent. This is for concrete subcomponents implementations when not
-   * generating ahead-of-time subcomponents.
+   * Returns the base implementation of this component in ahead-of-time subcomponents mode. If this
+   * is the base implementation, this returns {@link Optional#empty()}.
    */
-  static GeneratedComponentModel forSubcomponent(ClassName name) {
-    return new GeneratedComponentModel(
-        name, NestingKind.MEMBER, Optional.empty(), /* supermodel */ PRIVATE, FINAL);
+  Optional<ComponentImplementation> baseImplementation() {
+    return superclassImplementation.isPresent()
+        ? Optional.of(Optionals.rootmostValue(this, c -> c.superclassImplementation))
+        : Optional.empty();
   }
 
   /**
-   * Create a model for the top-level abstract subcomponent implementation when generating
-   * ahead-of-time subcomponents.
+   * Returns the {@link #configureInitializationMethod()} of the nearest supertype that defines one,
+   * if any.
+   *
+   * <p>Only returns a present value in {@link CompilerOptions#aheadOfTimeSubcomponents()}.
    */
-  static GeneratedComponentModel forBaseSubcomponent(ClassName name) {
-    return new GeneratedComponentModel(
-        name, NestingKind.TOP_LEVEL, Optional.empty(), /* supermodel */ PUBLIC, ABSTRACT);
+  Optional<MethodSpec> superConfigureInitializationMethod() {
+    for (Optional<ComponentImplementation> currentSuper = superclassImplementation;
+        currentSuper.isPresent();
+        currentSuper = currentSuper.get().superclassImplementation) {
+      if (currentSuper.get().configureInitializationMethod.isPresent()) {
+        return currentSuper.get().configureInitializationMethod;
+      }
+    }
+    return Optional.empty();
   }
 
   /**
-   * Create a model for an inner abstract implementation of a subcomponent. This is applicable when
-   * generating ahead-of-time subcomponents.
+   * Returns the {@link MethodSpecKind#CONFIGURE_INITIALIZATION_METHOD} of this implementation if
+   * there is one.
+   *
+   * <p>Only returns a present value in {@link CompilerOptions#aheadOfTimeSubcomponents()}.
    */
-  static GeneratedComponentModel forAbstractSubcomponent(
-      ClassName name, GeneratedComponentModel supermodel) {
-    return new GeneratedComponentModel(
-        name, NestingKind.MEMBER, Optional.of(supermodel), PUBLIC, ABSTRACT);
+  Optional<MethodSpec> configureInitializationMethod() {
+    return configureInitializationMethod;
   }
 
-  /** Returns the name of the component. */
-  ClassName name() {
-    return name;
+  /**
+   * Set's this component implementation's {@code configureInitialization()} method and {@linkplain
+   * #addMethod(MethodSpecKind, MethodSpec) adds the method}.
+   */
+  void setConfigureInitializationMethod(MethodSpec method) {
+    configureInitializationMethod = Optional.of(method);
+    addMethod(MethodSpecKind.CONFIGURE_INITIALIZATION_METHOD, method);
   }
 
-  /** Returns whether or not the implementation is nested within another class. */
-  boolean isNested() {
-    return nestingKind.isNested();
+  void setCreatorImplementation(Optional<ComponentCreatorImplementation> creatorImplementation) {
+    checkState(
+        this.creatorImplementation == null, "setCreatorImplementation has already been called");
+    this.creatorImplementation = creatorImplementation;
   }
 
-  /** Returns whether or not the implementation is abstract. */
-  boolean isAbstract() {
-    return isAbstract;
+  Optional<ComponentCreatorImplementation> creatorImplementation() {
+    checkState(creatorImplementation != null, "setCreatorImplementation has not been called yet");
+    return creatorImplementation;
   }
 
-  /** Returns the model of this model's superclass. */
-  Optional<GeneratedComponentModel> supermodel() {
-    return supermodel;
+  /**
+   * Returns the name of the creator class for this component. It will be a sibling of this
+   * generated class unless this is a top-level component, in which case it will be nested.
+   */
+  ClassName getCreatorName() {
+    return isNested()
+        ? name.peerClass(subcomponentNames.get(componentDescriptor) + "Builder")
+        : name.nestedClass("Builder");
   }
 
-  /** Returns the model of the child subcomponent. */
-  Optional<GeneratedComponentModel> subcomponentModel(ComponentDescriptor subcomponent) {
-    return Optional.ofNullable(subcomponentModels.get(subcomponent.componentDefinitionType()));
+  /** Returns the name of the nested implementation class for a child component. */
+  ClassName getSubcomponentName(ComponentDescriptor childDescriptor) {
+    checkArgument(
+        componentDescriptor.childComponents().contains(childDescriptor),
+        "%s is not a child component of %s",
+        childDescriptor.typeElement(),
+        componentDescriptor.typeElement());
+    return name.nestedClass(subcomponentNames.get(childDescriptor) + "Impl");
+  }
+
+  /** Returns the simple subcomponent name for the given subcomponent builder {@link Key}. */
+  String getSubcomponentName(Key key) {
+    return subcomponentNames.get(key);
+  }
+
+  /** Returns the child implementation. */
+  Optional<ComponentImplementation> childImplementation(ComponentDescriptor child) {
+    return Optional.ofNullable(childImplementations.get(child.typeElement()));
   }
 
   /** Returns {@code true} if {@code type} is accessible from the generated component. */
@@ -237,8 +347,8 @@ void addSupertype(TypeElement supertype) {
   /** Adds the given super class to the subcomponent. */
   void addSuperclass(ClassName className) {
     checkState(
-        supermodel.isPresent(),
-        "Setting the supertype for model [%s] as a class when model has no supermodel.",
+        superclassImplementation.isPresent(),
+        "Setting the superclass for component [%s] when there is no superclass implementation.",
         name);
     component.superclass(className);
   }
@@ -273,9 +383,10 @@ void addMethods(MethodSpecKind methodKind, Iterable<MethodSpec> methodSpecs) {
   void addModifiableBindingMethod(
       ModifiableBindingType type,
       BindingRequest request,
+      TypeMirror returnType,
       MethodSpec methodSpec,
       boolean finalized) {
-    modifiableBindingMethods.addMethod(type, request, methodSpec, finalized);
+    modifiableBindingMethods.addMethod(type, request, returnType, methodSpec, finalized);
     methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, methodSpec);
   }
 
@@ -287,9 +398,10 @@ void addModifiableBindingMethod(
   void registerModifiableBindingMethod(
       ModifiableBindingType type,
       BindingRequest request,
+      TypeMirror returnType,
       MethodSpec methodSpec,
       boolean finalized) {
-    modifiableBindingMethods.addMethod(type, request, methodSpec, finalized);
+    modifiableBindingMethods.addMethod(type, request, returnType, methodSpec, finalized);
   }
 
   /** Adds the implementation for the given {@link ModifiableBindingMethod} to the component. */
@@ -298,6 +410,13 @@ void addImplementedModifiableBindingMethod(ModifiableBindingMethod method) {
     methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, method.methodSpec());
   }
 
+  /** Add's a modifiable module method to this implementation. */
+  void addModifiableModuleMethod(ComponentRequirement module, MethodSpec method) {
+    checkArgument(module.kind().isModule());
+    checkState(modifiableModuleMethods.put(module, method.name) == null);
+    methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, method);
+  }
+
   /** Adds the given type to the component. */
   void addType(TypeSpecKind typeKind, TypeSpec typeSpec) {
     typeSpecsMap.put(typeKind, typeSpec);
@@ -308,11 +427,10 @@ void addTypes(TypeSpecKind typeKind, Iterable<TypeSpec> typeSpecs) {
     typeSpecsMap.putAll(typeKind, typeSpecs);
   }
 
-  /** Adds the type generated from the given subcomponent model. */
-  void addSubcomponent(
-      ComponentDescriptor subcomponent, GeneratedComponentModel subcomponentModel) {
-    subcomponentModels.put(subcomponent.componentDefinitionType(), subcomponentModel);
-    addType(TypeSpecKind.SUBCOMPONENT, subcomponentModel.generate().build());
+  /** Adds the type generated from the given child implementation. */
+  void addChild(ComponentDescriptor child, ComponentImplementation childImplementation) {
+    childImplementations.put(child.typeElement(), childImplementation);
+    addType(TypeSpecKind.SUBCOMPONENT, childImplementation.generate().build());
   }
 
   /** Adds a {@link Supplier} for the SwitchingProvider for the component. */
@@ -325,6 +443,22 @@ void addInitialization(CodeBlock codeBlock) {
     initializations.add(codeBlock);
   }
 
+  /**
+   * Adds the given code block that initializes a {@link ComponentRequirement} to the component
+   * implementation.
+   */
+  void addComponentRequirementInitialization(CodeBlock codeBlock) {
+    componentRequirementInitializations.add(codeBlock);
+  }
+
+  /**
+   * Marks the given key of a producer as one that should have a cancellation statement in the
+   * cancellation listener method of the component.
+   */
+  void addCancellableProducerKey(Key key) {
+    cancellableProducerKeys.add(key);
+  }
+
   /** Returns a new, unique field name for the component based on the given name. */
   String getUniqueFieldName(String name) {
     return componentFieldNames.getUniqueName(name);
@@ -337,8 +471,7 @@ String getUniqueMethodName(String name) {
 
   /** Returns a new, unique method name for a getter method for the given request. */
   String getUniqueMethodName(BindingRequest request) {
-    return uniqueMethodName(
-        request, simpleVariableName(MoreTypes.asTypeElement(request.key().type())));
+    return uniqueMethodName(request, KeyVariableNamer.name(request.key()));
   }
 
   /**
@@ -371,6 +504,36 @@ void claimMethodName(CharSequence name) {
     return ImmutableList.copyOf(initializations);
   }
 
+  /**
+   * Returns the list of {@link CodeBlock}s that initialize {@link ComponentRequirement}s. These
+   * initializations are kept separate from {@link #getInitializations()} because they must be
+   * executed before the initializations of any framework instance initializations in a superclass
+   * implementation that may depend on the instances. We cannot use the same strategy that we use
+   * for framework instances (i.e. wrap in a {@link dagger.internal.DelegateFactory} or {@link
+   * dagger.producers.internal.DelegateProducer} since the types of these initialized fields have no
+   * interface type that we can write a proxy for.
+   */
+  ImmutableList<CodeBlock> getComponentRequirementInitializations() {
+    return ImmutableList.copyOf(componentRequirementInitializations);
+  }
+
+  /**
+   * Returns the list of producer {@link Key}s that need cancellation statements in the cancellation
+   * listener method.
+   */
+  ImmutableList<Key> getCancellableProducerKeys() {
+    Optional<ComponentImplementation> currentSuperImplementation = superclassImplementation;
+    Set<Key> cancelledKeysFromSuperclass = new HashSet<>();
+    while (currentSuperImplementation.isPresent()) {
+      cancelledKeysFromSuperclass.addAll(
+          currentSuperImplementation.get().cancellableProducerKeys);
+      currentSuperImplementation = currentSuperImplementation.get().superclassImplementation;
+    }
+    return Sets.difference(cancellableProducerKeys, cancelledKeysFromSuperclass)
+        .immutableCopy()
+        .asList();
+  }
+
   /**
    * Returns the {@link ModifiableBindingMethod}s for this subcomponent implementation and its
    * superclasses.
@@ -378,9 +541,9 @@ void claimMethodName(CharSequence name) {
   ImmutableList<ModifiableBindingMethod> getModifiableBindingMethods() {
     ImmutableList.Builder<ModifiableBindingMethod> modifiableBindingMethodsBuilder =
         ImmutableList.builder();
-    if (supermodel.isPresent()) {
+    if (superclassImplementation.isPresent()) {
       ImmutableList<ModifiableBindingMethod> superclassModifiableBindingMethods =
-          supermodel.get().getModifiableBindingMethods();
+          superclassImplementation.get().getModifiableBindingMethods();
       superclassModifiableBindingMethods.stream()
           .filter(method -> !modifiableBindingMethods.finalized(method))
           .forEach(modifiableBindingMethodsBuilder::add);
@@ -389,18 +552,68 @@ void claimMethodName(CharSequence name) {
     return modifiableBindingMethodsBuilder.build();
   }
 
+  /**
+   * Returns the names of every modifiable method of this implementation and any superclass
+   * implementations.
+   */
+  ImmutableSet<String> getAllModifiableMethodNames() {
+    ImmutableSet.Builder<String> names = ImmutableSet.builder();
+    modifiableBindingMethods.allMethods().forEach(method -> names.add(method.methodSpec().name));
+    names.addAll(modifiableModuleMethods.values());
+    superclassImplementation.ifPresent(
+        superclass -> names.addAll(superclass.getAllModifiableMethodNames()));
+    return names.build();
+  }
+
   /**
    * Returns the {@link ModifiableBindingMethod} for this subcomponent for the given binding, if it
    * exists.
    */
   Optional<ModifiableBindingMethod> getModifiableBindingMethod(BindingRequest request) {
     Optional<ModifiableBindingMethod> method = modifiableBindingMethods.getMethod(request);
-    if (!method.isPresent() && supermodel.isPresent()) {
-      return supermodel.get().getModifiableBindingMethod(request);
+    if (!method.isPresent() && superclassImplementation.isPresent()) {
+      return superclassImplementation.get().getModifiableBindingMethod(request);
     }
     return method;
   }
 
+  /**
+   * Returns the {@link ModifiableBindingMethod} of a supertype for this method's {@code request},
+   * if one exists.
+   */
+  Optional<ModifiableBindingMethod> supertypeModifiableBindingMethod(BindingRequest request) {
+    return superclassImplementation()
+        .flatMap(superImplementation -> superImplementation.getModifiableBindingMethod(request));
+  }
+
+  /**
+   * Returns the names of modifiable module methods for this implementation and all inherited
+   * implementations, keyed by the corresponding module's {@link ComponentRequirement}.
+   */
+  ImmutableMap<ComponentRequirement, String> getAllModifiableModuleMethods() {
+    ImmutableMap.Builder<ComponentRequirement, String> methods = ImmutableMap.builder();
+    methods.putAll(modifiableModuleMethods);
+    superclassImplementation.ifPresent(
+        superclass -> methods.putAll(superclass.getAllModifiableModuleMethods()));
+    return methods.build();
+  }
+
+  /**
+   * Returns the name of the modifiable module method for {@code module} that is inherited in this
+   * implementation, or empty if none has been defined.
+   */
+  Optional<String> supertypeModifiableModuleMethodName(ComponentRequirement module) {
+    checkArgument(module.kind().isModule());
+    if (!superclassImplementation.isPresent()) {
+      return Optional.empty();
+    }
+    String methodName = superclassImplementation.get().modifiableModuleMethods.get(module);
+    if (methodName == null) {
+      return superclassImplementation.get().supertypeModifiableModuleMethodName(module);
+    }
+    return Optional.of(methodName);
+  }
+
   /** Generates the component and returns the resulting {@link TypeSpec.Builder}. */
   TypeSpec.Builder generate() {
     fieldSpecsMap.asMap().values().forEach(component::addFields);
@@ -416,12 +629,13 @@ void claimMethodName(CharSequence name) {
    * to know whether a contribution has been made by a superclass implementation. This is only
    * relevant for ahead-of-time subcomponents.
    */
-  void registerImplementedMultibinding(ContributionBinding multibinding) {
+  void registerImplementedMultibinding(
+      ContributionBinding multibinding, BindingRequest bindingRequest) {
     checkArgument(multibinding.isSyntheticMultibinding());
     // We register a multibinding as implemented each time we request the multibinding expression,
     // so only modify the set of contributions once.
-    if (!contributionsByMultibinding.containsKey(multibinding.key())) {
-      contributionsByMultibinding.putAll(multibinding.key(), multibinding.dependencies());
+    if (!multibindingContributionsMade.containsKey(bindingRequest)) {
+      multibindingContributionsMade.putAll(bindingRequest, multibinding.dependencies());
     }
   }
 
@@ -429,23 +643,21 @@ void registerImplementedMultibinding(ContributionBinding multibinding) {
    * Returns the set of multibinding contributions associated with all superclass implementations of
    * a multibinding.
    */
-  ImmutableSet<DependencyRequest> superclassContributionsMade(Key key) {
-    ImmutableSet.Builder<DependencyRequest> contributionsBuilder = ImmutableSet.builder();
-    if (supermodel.isPresent()) {
-      contributionsBuilder.addAll(supermodel.get().getAllMultibindingContributions(key));
-    }
-    return contributionsBuilder.build();
+  ImmutableSet<DependencyRequest> superclassContributionsMade(BindingRequest bindingRequest) {
+    return superclassImplementation
+        .map(s -> s.getAllMultibindingContributions(bindingRequest))
+        .orElse(ImmutableSet.of());
   }
 
   /**
    * Returns the set of multibinding contributions associated with all implementations of a
    * multibinding.
    */
-  private ImmutableSet<DependencyRequest> getAllMultibindingContributions(Key key) {
-    ImmutableSet.Builder<DependencyRequest> contributionsBuilder = ImmutableSet.builder();
-    if (contributionsByMultibinding.containsKey(key)) {
-      contributionsBuilder.addAll(contributionsByMultibinding.get(key));
-    }
-    return contributionsBuilder.addAll(superclassContributionsMade(key)).build();
+  private ImmutableSet<DependencyRequest> getAllMultibindingContributions(
+      BindingRequest bindingRequest) {
+    return ImmutableSet.copyOf(
+        Sets.union(
+            multibindingContributionsMade.get(bindingRequest),
+            superclassContributionsMade(bindingRequest)));
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
new file mode 100644
index 000000000..9f8623021
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -0,0 +1,791 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.base.Preconditions.checkState;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.CodeBlocks.parameterNames;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.ComponentGenerator.componentName;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.BUILDER_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.CANCELLATION_LISTENER_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.COMPONENT_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.CONSTRUCTOR;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.INITIALIZE_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.MODIFIABLE_BINDING_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.COMPONENT_CREATOR;
+import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.SUBCOMPONENT;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.producers.CancellationPolicy.Propagation.PROPAGATE;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Multimaps;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.Key;
+import dagger.producers.internal.CancellationListener;
+import dagger.producers.internal.Producers;
+import java.util.List;
+import java.util.Optional;
+import javax.inject.Inject;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.NestingKind;
+import javax.lang.model.type.DeclaredType;
+
+/** Factory for {@link ComponentImplementation}s. */
+final class ComponentImplementationFactory {
+  private static final String MAY_INTERRUPT_IF_RUNNING = "mayInterruptIfRunning";
+
+  /**
+   * How many statements per {@code initialize()} or {@code onProducerFutureCancelled()} method
+   * before they get partitioned.
+   */
+  private static final int STATEMENTS_PER_METHOD = 100;
+
+  private static final String CANCELLATION_LISTENER_METHOD_NAME = "onProducerFutureCancelled";
+
+  private final DaggerTypes types;
+  private final DaggerElements elements;
+  private final KeyFactory keyFactory;
+  private final CompilerOptions compilerOptions;
+  private final BindingGraphFactory bindingGraphFactory;
+
+  @Inject
+  ComponentImplementationFactory(
+      DaggerTypes types,
+      DaggerElements elements,
+      KeyFactory keyFactory,
+      CompilerOptions compilerOptions,
+      BindingGraphFactory bindingGraphFactory) {
+    this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
+    this.compilerOptions = compilerOptions;
+    this.bindingGraphFactory = bindingGraphFactory;
+  }
+
+  /**
+   * Returns a top-level (non-nested) component implementation for a binding graph.
+   *
+   * @throws IllegalStateException if the binding graph is for a subcomponent and
+   *     ahead-of-time-subcomponents mode is not enabled
+   */
+  ComponentImplementation createComponentImplementation(BindingGraph bindingGraph) {
+    ComponentImplementation componentImplementation =
+        topLevelImplementation(componentName(bindingGraph.componentTypeElement()), bindingGraph);
+    OptionalFactories optionalFactories = new OptionalFactories(componentImplementation);
+    Optional<ComponentCreatorImplementation> componentCreatorImplementation =
+        ComponentCreatorImplementation.create(
+            componentImplementation, bindingGraph, elements, types);
+    componentImplementation.setCreatorImplementation(componentCreatorImplementation);
+    ComponentRequirementExpressions componentRequirementExpressions =
+        new ComponentRequirementExpressions(bindingGraph, componentImplementation, types, elements);
+    ComponentBindingExpressions bindingExpressions =
+        new ComponentBindingExpressions(
+            bindingGraph,
+            componentImplementation,
+            componentRequirementExpressions,
+            optionalFactories,
+            types,
+            elements,
+            compilerOptions);
+    if (componentImplementation.isAbstract()) {
+      checkState(
+          compilerOptions.aheadOfTimeSubcomponents(),
+          "Calling 'componentImplementation()' on %s when not generating ahead-of-time "
+              + "subcomponents.",
+          bindingGraph.componentTypeElement());
+      return new SubcomponentImplementationBuilder(
+              Optional.empty(), /* parent */
+              bindingGraph,
+              componentImplementation,
+              optionalFactories,
+              bindingExpressions,
+              componentRequirementExpressions)
+          .build();
+    } else {
+      return new RootComponentImplementationBuilder(
+              bindingGraph,
+              componentImplementation,
+              optionalFactories,
+              bindingExpressions,
+              componentRequirementExpressions)
+          .build();
+    }
+  }
+
+  /** Creates a root component or top-level abstract subcomponent implementation. */
+  ComponentImplementation topLevelImplementation(ClassName name, BindingGraph graph) {
+    return new ComponentImplementation(
+        graph.componentDescriptor(),
+        name,
+        NestingKind.TOP_LEVEL,
+        Optional.empty(), // superclassImplementation
+        new SubcomponentNames(graph, keyFactory),
+        PUBLIC,
+        graph.componentDescriptor().kind().isTopLevel() ? FINAL : ABSTRACT);
+  }
+
+  private abstract class ComponentImplementationBuilder {
+    final BindingGraph graph;
+    final ComponentBindingExpressions bindingExpressions;
+    final ComponentRequirementExpressions componentRequirementExpressions;
+    final ComponentImplementation componentImplementation;
+    final OptionalFactories optionalFactories;
+    boolean done;
+
+    ComponentImplementationBuilder(
+        BindingGraph graph,
+        ComponentImplementation componentImplementation,
+        OptionalFactories optionalFactories,
+        ComponentBindingExpressions bindingExpressions,
+        ComponentRequirementExpressions componentRequirementExpressions) {
+      this.graph = graph;
+      this.componentImplementation = componentImplementation;
+      this.optionalFactories = optionalFactories;
+      this.bindingExpressions = bindingExpressions;
+      this.componentRequirementExpressions = componentRequirementExpressions;
+    }
+
+    /**
+     * Returns a {@link ComponentImplementation} for this component. This is only intended to be
+     * called once (and will throw on successive invocations). If the component must be regenerated,
+     * use a new instance.
+     */
+    final ComponentImplementation build() {
+      checkState(
+          !done,
+          "ComponentImplementationBuilder has already built the ComponentImplementation for [%s].",
+          componentImplementation.name());
+      setSupertype();
+      componentImplementation
+          .creatorImplementation()
+          .map(ComponentCreatorImplementation::componentCreatorClass)
+          .ifPresent(this::addCreatorClass);
+
+      getLocalAndInheritedMethods(graph.componentTypeElement(), types, elements)
+          .forEach(method -> componentImplementation.claimMethodName(method.getSimpleName()));
+      componentImplementation
+          .superclassImplementation()
+          .ifPresent(
+              superclassImplementation -> {
+                superclassImplementation
+                    .getAllModifiableMethodNames()
+                    .forEach(componentImplementation::claimMethodName);
+              });
+
+      addFactoryMethods();
+      addInterfaceMethods();
+      addChildComponents();
+      implementModifiableModuleMethods();
+
+      addConstructor();
+
+      if (graph.componentDescriptor().kind().isProducer()) {
+        addCancellationListenerImplementation();
+      }
+
+      done = true;
+      return componentImplementation;
+    }
+
+    /** Set the supertype for this generated class. */
+    final void setSupertype() {
+      if (componentImplementation.superclassImplementation().isPresent()) {
+        componentImplementation.addSuperclass(
+            componentImplementation.superclassImplementation().get().name());
+      } else {
+        componentImplementation.addSupertype(graph.componentTypeElement());
+      }
+    }
+
+    /**
+     * Adds {@code creator} as a nested creator class. Root components and subcomponents will nest
+     * this in different classes.
+     */
+    abstract void addCreatorClass(TypeSpec creator);
+
+    /** Adds component factory methods. */
+    abstract void addFactoryMethods();
+
+    void addInterfaceMethods() {
+      // Each component method may have been declared by several supertypes. We want to implement
+      // only one method for each distinct signature.
+      ImmutableListMultimap<MethodSignature, ComponentMethodDescriptor>
+          componentMethodsBySignature =
+              Multimaps.index(
+                  graph.componentDescriptor().entryPointMethods(), this::getMethodSignature);
+      for (List<ComponentMethodDescriptor> methodsWithSameSignature :
+          Multimaps.asMap(componentMethodsBySignature).values()) {
+        ComponentMethodDescriptor anyOneMethod = methodsWithSameSignature.stream().findAny().get();
+        MethodSpec methodSpec = bindingExpressions.getComponentMethod(anyOneMethod);
+
+        // If the binding for the component method is modifiable, register it as such.
+        ModifiableBindingType modifiableBindingType =
+            bindingExpressions
+                .modifiableBindingExpressions()
+                .registerComponentMethodIfModifiable(anyOneMethod, methodSpec);
+
+        // If the method should be implemented in this component, implement it.
+        if (modifiableBindingType.hasBaseClassImplementation()) {
+          componentImplementation.addMethod(COMPONENT_METHOD, methodSpec);
+        }
+      }
+    }
+
+    final void addCancellationListenerImplementation() {
+      componentImplementation.addSupertype(elements.getTypeElement(CancellationListener.class));
+      componentImplementation.claimMethodName(CANCELLATION_LISTENER_METHOD_NAME);
+
+      MethodSpec.Builder methodBuilder =
+          methodBuilder(CANCELLATION_LISTENER_METHOD_NAME)
+              .addModifiers(PUBLIC)
+              .addAnnotation(Override.class)
+              .addParameter(boolean.class, MAY_INTERRUPT_IF_RUNNING);
+      if (componentImplementation.superclassImplementation().isPresent()) {
+        methodBuilder.addStatement(
+            "super.$L($L)", CANCELLATION_LISTENER_METHOD_NAME, MAY_INTERRUPT_IF_RUNNING);
+      }
+
+      ImmutableList<CodeBlock> cancellationStatements = cancellationStatements();
+
+      if (cancellationStatements.size() < STATEMENTS_PER_METHOD) {
+        methodBuilder.addCode(CodeBlocks.concat(cancellationStatements)).build();
+      } else {
+        List<List<CodeBlock>> partitions =
+            Lists.partition(cancellationStatements, STATEMENTS_PER_METHOD);
+        for (List<CodeBlock> partition : partitions) {
+          String methodName = componentImplementation.getUniqueMethodName("cancelProducers");
+          MethodSpec method =
+              methodBuilder(methodName)
+                  .addModifiers(PRIVATE)
+                  .addParameter(boolean.class, MAY_INTERRUPT_IF_RUNNING)
+                  .addCode(CodeBlocks.concat(partition))
+                  .build();
+          methodBuilder.addStatement("$N($L)", method, MAY_INTERRUPT_IF_RUNNING);
+          componentImplementation.addMethod(CANCELLATION_LISTENER_METHOD, method);
+        }
+      }
+
+      Optional<CodeBlock> cancelParentStatement = cancelParentStatement();
+      cancelParentStatement.ifPresent(methodBuilder::addCode);
+
+      if (cancellationStatements.isEmpty()
+          && !cancelParentStatement.isPresent()
+          && componentImplementation.superclassImplementation().isPresent()) {
+        // Partial child implementations that have no new cancellations don't need to override
+        // the method just to call super().
+        return;
+      }
+
+      componentImplementation.addMethod(CANCELLATION_LISTENER_METHOD, methodBuilder.build());
+    }
+
+    private ImmutableList<CodeBlock> cancellationStatements() {
+      // Reversing should order cancellations starting from entry points and going down to leaves
+      // rather than the other way around. This shouldn't really matter but seems *slightly*
+      // preferable because:
+      // When a future that another future depends on is cancelled, that cancellation will propagate
+      // up the future graph toward the entry point. Cancelling in reverse order should ensure that
+      // everything that depends on a particular node has already been cancelled when that node is
+      // cancelled, so there's no need to propagate. Otherwise, when we cancel a leaf node, it might
+      // propagate through most of the graph, making most of the cancel calls that follow in the
+      // onProducerFutureCancelled method do nothing.
+      ImmutableList<Key> cancellationKeys =
+          componentImplementation.getCancellableProducerKeys().reverse();
+
+      ImmutableList.Builder<CodeBlock> cancellationStatements = ImmutableList.builder();
+      for (Key cancellationKey : cancellationKeys) {
+        cancellationStatements.add(
+            CodeBlock.of(
+                "$T.cancel($L, $N);",
+                Producers.class,
+                bindingExpressions
+                    .getDependencyExpression(
+                        bindingRequest(cancellationKey, FrameworkType.PRODUCER_NODE),
+                        componentImplementation.name())
+                    .codeBlock(),
+                MAY_INTERRUPT_IF_RUNNING));
+      }
+      return cancellationStatements.build();
+    }
+
+    Optional<CodeBlock> cancelParentStatement() {
+      // Returns empty by default. Overridden in subclass(es) to add a statement if and only if the
+      // component being generated is a concrete subcomponent implementation with a parent that
+      // allows cancellation to propagate to it from subcomponents.
+      return Optional.empty();
+    }
+
+    /**
+     * For final components, reimplements all modifiable module methods that may have been modified.
+     */
+    private void implementModifiableModuleMethods() {
+      if (componentImplementation.isAbstract()) {
+        return;
+      }
+      componentImplementation
+          .getAllModifiableModuleMethods()
+          .forEach(this::implementModifiableModuleMethod);
+    }
+
+    private void implementModifiableModuleMethod(ComponentRequirement module, String methodName) {
+      // TODO(b/117833324): only reimplement methods for modules that were abstract or were repeated
+      // by an ancestor component.
+      componentImplementation.addMethod(
+          MODIFIABLE_BINDING_METHOD,
+          methodBuilder(methodName)
+              .addAnnotation(Override.class)
+              .addModifiers(PROTECTED)
+              .returns(TypeName.get(module.type()))
+              .addStatement(
+                  "return $L",
+                  componentRequirementExpressions.getExpression(
+                      module, componentImplementation.name()))
+              .build());
+    }
+
+    final MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
+      return MethodSignature.forComponentMethod(
+          method, MoreTypes.asDeclared(graph.componentTypeElement().asType()), types);
+    }
+
+    final void addChildComponents() {
+      for (BindingGraph subgraph : graph.subgraphs()) {
+        // TODO(b/117833324): Can an abstract inner subcomponent implementation be elided if it's
+        // totally empty?
+        componentImplementation.addChild(
+            subgraph.componentDescriptor(), buildChildImplementation(subgraph));
+      }
+    }
+
+    final ComponentImplementation getChildSuperclassImplementation(ComponentDescriptor child) {
+      // If the current component has superclass implementations, a superclass may contain a
+      // reference to the child. Traverse this component's superimplementation hierarchy looking for
+      // the child's implementation. The child superclass implementation may not be present in the
+      // direct superclass implementations if the subcomponent builder was previously a pruned
+      // binding.
+      Optional<ComponentImplementation> currentSuperclassImplementation =
+          componentImplementation.superclassImplementation();
+      while (currentSuperclassImplementation.isPresent()) {
+        Optional<ComponentImplementation> childSuperclassImplementation =
+            currentSuperclassImplementation.get().childImplementation(child);
+        if (childSuperclassImplementation.isPresent()) {
+          return childSuperclassImplementation.get();
+        }
+        currentSuperclassImplementation =
+            currentSuperclassImplementation.get().superclassImplementation();
+      }
+
+      // Otherwise, the superclass implementation is top-level, so we must recreate the
+      // implementation object for the base implementation of the child by truncating the binding
+      // graph at the child.
+      BindingGraph truncatedBindingGraph = bindingGraphFactory.create(child);
+      return createComponentImplementation(truncatedBindingGraph);
+    }
+
+    final ComponentImplementation buildChildImplementation(BindingGraph childGraph) {
+      ComponentImplementation childImplementation =
+          compilerOptions.aheadOfTimeSubcomponents()
+              ? abstractInnerSubcomponent(childGraph.componentDescriptor())
+              : concreteSubcomponent(childGraph.componentDescriptor());
+      Optional<ComponentCreatorImplementation> childCreatorImplementation =
+          ComponentCreatorImplementation.create(childImplementation, childGraph, elements, types);
+      childImplementation.setCreatorImplementation(childCreatorImplementation);
+      ComponentRequirementExpressions childComponentRequirementExpressions =
+          componentRequirementExpressions.forChildComponent(childGraph, childImplementation);
+      ComponentBindingExpressions childBindingExpressions =
+          bindingExpressions.forChildComponent(
+              childGraph, childImplementation, childComponentRequirementExpressions);
+      return new SubcomponentImplementationBuilder(
+              Optional.of(this),
+              childGraph,
+              childImplementation,
+              optionalFactories,
+              childBindingExpressions,
+              childComponentRequirementExpressions)
+          .build();
+    }
+
+    /** Creates an inner abstract subcomponent implementation. */
+    final ComponentImplementation abstractInnerSubcomponent(ComponentDescriptor child) {
+      return new ComponentImplementation(
+          componentImplementation,
+          child,
+          Optional.of(getChildSuperclassImplementation(child)),
+          PROTECTED,
+          componentImplementation.isAbstract() ? ABSTRACT : FINAL);
+    }
+
+    /** Creates a concrete inner subcomponent implementation. */
+    final ComponentImplementation concreteSubcomponent(ComponentDescriptor child) {
+      return new ComponentImplementation(
+          componentImplementation,
+          child,
+          Optional.empty(), // superclassImplementation
+          PRIVATE,
+          FINAL);
+    }
+
+    final void addConstructor() {
+      List<List<CodeBlock>> partitions =
+          Lists.partition(componentImplementation.getInitializations(), STATEMENTS_PER_METHOD);
+      ImmutableList<CodeBlock> componentRequirementInitializations =
+          componentImplementation.getComponentRequirementInitializations();
+
+      ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
+      MethodSpec.Builder constructor =
+          constructorBuilder()
+              .addModifiers(componentImplementation.isAbstract() ? PROTECTED : PRIVATE);
+
+      if (!componentImplementation.isAbstract()) {
+        constructor.addParameters(constructorParameters);
+      }
+
+      Optional<MethodSpec.Builder> configureInitialization =
+          (partitions.isEmpty() && componentRequirementInitializations.isEmpty())
+                  || !componentImplementation.isAbstract()
+              ? Optional.empty()
+              : Optional.of(configureInitializationMethodBuilder(constructorParameters));
+
+      configureInitialization
+          .orElse(constructor)
+          .addCode(CodeBlocks.concat(componentRequirementInitializations));
+
+      if (componentImplementation.superConfigureInitializationMethod().isPresent()) {
+        MethodSpec superConfigureInitializationMethod =
+            componentImplementation.superConfigureInitializationMethod().get();
+        CodeBlock superInvocation =
+            CodeBlock.of(
+                "$N($L)",
+                superConfigureInitializationMethod,
+                parameterNames(superConfigureInitializationMethod.parameters));
+        if (configureInitialization.isPresent()) {
+          configureInitialization.get().addStatement("super.$L", superInvocation);
+        } else if (!componentImplementation.isAbstract()) {
+          constructor.addStatement(superInvocation);
+        }
+      }
+
+      ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
+      CodeBlock initializeParametersCodeBlock = parameterNames(constructorParameters);
+
+      for (List<CodeBlock> partition : partitions) {
+        String methodName = componentImplementation.getUniqueMethodName("initialize");
+        MethodSpec.Builder initializeMethod =
+            methodBuilder(methodName)
+                .addModifiers(PRIVATE)
+                /* TODO(gak): Strictly speaking, we only need the suppression here if we are also
+                 * initializing a raw field in this method, but the structure of this code makes it
+                 * awkward to pass that bit through.  This will be cleaned up when we no longer
+                 * separate fields and initialization as we do now. */
+                .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
+                .addCode(CodeBlocks.concat(partition));
+        initializeMethod.addParameters(initializeParameters);
+        configureInitialization
+            .orElse(constructor)
+            .addStatement("$L($L)", methodName, initializeParametersCodeBlock);
+        componentImplementation.addMethod(INITIALIZE_METHOD, initializeMethod.build());
+      }
+      componentImplementation.addMethod(CONSTRUCTOR, constructor.build());
+      configureInitialization.ifPresent(
+          method -> componentImplementation.setConfigureInitializationMethod(method.build()));
+    }
+
+    /**
+     * Returns a {@link MethodSpec.Builder} for the {@link
+     * ComponentImplementation#configureInitializationMethod()}.
+     */
+    private MethodSpec.Builder configureInitializationMethodBuilder(
+        ImmutableList<ParameterSpec> initializationMethodParameters) {
+      String methodName = componentImplementation.getUniqueMethodName("configureInitialization");
+      MethodSpec.Builder configureInitialization =
+          methodBuilder(methodName)
+              .addModifiers(PROTECTED)
+              .addParameters(initializationMethodParameters);
+
+      // Checks all super configureInitialization() methods to see if they have the same signature
+      // as this one, and if so, adds as an @Override annotation
+      for (Optional<ComponentImplementation> currentSuperImplementation =
+              componentImplementation.superclassImplementation();
+          currentSuperImplementation.isPresent();
+          currentSuperImplementation =
+              currentSuperImplementation.get().superclassImplementation()) {
+        Optional<MethodSpec> superConfigureInitializationMethod =
+            currentSuperImplementation.get().configureInitializationMethod();
+        if (superConfigureInitializationMethod
+            .filter(superMethod -> superMethod.name.equals(methodName))
+            .filter(superMethod -> superMethod.parameters.equals(initializationMethodParameters))
+            .isPresent()) {
+          configureInitialization.addAnnotation(Override.class);
+          break;
+        }
+      }
+
+      return configureInitialization;
+    }
+
+    /** Returns the list of {@link ParameterSpec}s for the initialize methods. */
+    final ImmutableList<ParameterSpec> initializeParameters() {
+      return constructorParameters().stream()
+          .map(param -> param.toBuilder().addModifiers(FINAL).build())
+          .collect(toImmutableList());
+    }
+
+    /** Returns the list of {@link ParameterSpec}s for the constructor. */
+    final ImmutableList<ParameterSpec> constructorParameters() {
+      Optional<ClassName> componentCreatorName;
+      if (componentImplementation.creatorImplementation().isPresent()) {
+        componentCreatorName =
+            componentImplementation.creatorImplementation().map(creator -> creator.name());
+      } else {
+        componentCreatorName =
+            componentImplementation
+                .baseImplementation()
+                .filter(component -> component.componentDescriptor().hasCreator())
+                .map(ComponentImplementation::getCreatorName);
+      }
+
+      if (componentCreatorName.isPresent()) {
+        return ImmutableList.of(
+            ParameterSpec.builder(componentCreatorName.get(), "builder").build());
+      } else if (componentImplementation.isAbstract() && componentImplementation.isNested()) {
+        // If we're generating an abstract inner subcomponent, then we are not implementing module
+        // instance bindings and have no need for factory method parameters.
+        return ImmutableList.of();
+      } else if (graph.factoryMethod().isPresent()) {
+        return getFactoryMethodParameterSpecs(graph);
+      } else if (componentImplementation.isAbstract()) {
+        // If we're generating an abstract base implementation of a subcomponent it's acceptable to
+        // have neither a creator nor factory method.
+        return ImmutableList.of();
+      } else {
+        throw new AssertionError(
+            "Expected either a component creator or factory method but found neither.");
+      }
+    }
+  }
+
+  /** Builds a root component implementation. */
+  private final class RootComponentImplementationBuilder extends ComponentImplementationBuilder {
+    private final ClassName componentCreatorName;
+
+    RootComponentImplementationBuilder(
+        BindingGraph graph,
+        ComponentImplementation componentImplementation,
+        OptionalFactories optionalFactories,
+        ComponentBindingExpressions bindingExpressions,
+        ComponentRequirementExpressions componentRequirementExpressions) {
+      super(
+          graph,
+          componentImplementation,
+          optionalFactories,
+          bindingExpressions,
+          componentRequirementExpressions);
+      this.componentCreatorName = componentImplementation.creatorImplementation().get().name();
+    }
+
+    @Override
+    void addCreatorClass(TypeSpec creator) {
+      componentImplementation.addType(COMPONENT_CREATOR, creator);
+    }
+
+    @Override
+    void addFactoryMethods() {
+      // Only top-level components have the factory builder() method.
+      // Mirror the user's creator API type if they had one.
+      MethodSpec creatorFactoryMethod =
+          methodBuilder("builder")
+              .addModifiers(PUBLIC, STATIC)
+              .returns(
+                  creatorDescriptor()
+                      .map(creatorDescriptor -> ClassName.get(creatorDescriptor.typeElement()))
+                      .orElse(componentCreatorName))
+              .addStatement("return new $T()", componentCreatorName)
+              .build();
+      componentImplementation.addMethod(BUILDER_METHOD, creatorFactoryMethod);
+      if (canInstantiateAllRequirements()) {
+        CharSequence buildMethodName =
+            creatorDescriptor().isPresent()
+                ? creatorDescriptor().get().factoryMethod().getSimpleName()
+                : "build";
+        componentImplementation.addMethod(
+            BUILDER_METHOD,
+            methodBuilder("create")
+                .returns(ClassName.get(super.graph.componentTypeElement()))
+                .addModifiers(PUBLIC, STATIC)
+                .addStatement("return new Builder().$L()", buildMethodName)
+                .build());
+      }
+    }
+
+    private Optional<ComponentCreatorDescriptor> creatorDescriptor() {
+      return graph.componentDescriptor().creatorDescriptor();
+    }
+
+    /** {@code true} if all of the graph's required dependencies can be automatically constructed */
+    boolean canInstantiateAllRequirements() {
+      return !Iterables.any(
+          graph.componentRequirements(),
+          dependency -> dependency.requiresAPassedInstance(elements, types));
+    }
+  }
+
+  /**
+   * Builds a subcomponent implementation. If generating ahead-of-time subcomponents, this may be an
+   * abstract base class implementation, an abstract inner implementation, or a concrete
+   * implementation that extends an abstract base implementation. Otherwise it represents a private,
+   * inner, concrete, final implementation of a subcomponent which extends a user defined type.
+   */
+  private final class SubcomponentImplementationBuilder extends ComponentImplementationBuilder {
+    final Optional<ComponentImplementationBuilder> parent;
+
+    SubcomponentImplementationBuilder(
+        Optional<ComponentImplementationBuilder> parent,
+        BindingGraph graph,
+        ComponentImplementation componentImplementation,
+        OptionalFactories optionalFactories,
+        ComponentBindingExpressions bindingExpressions,
+        ComponentRequirementExpressions componentRequirementExpressions) {
+      super(
+          graph,
+          componentImplementation,
+          optionalFactories,
+          bindingExpressions,
+          componentRequirementExpressions);
+      this.parent = parent;
+    }
+
+    @Override
+    void addCreatorClass(TypeSpec creator) {
+      if (parent.isPresent()) {
+        // In an inner implementation of a subcomponent the creator is a peer class.
+        parent.get().componentImplementation.addType(SUBCOMPONENT, creator);
+      } else {
+        componentImplementation.addType(SUBCOMPONENT, creator);
+      }
+    }
+
+    @Override
+    void addFactoryMethods() {
+      // Only construct instances of subcomponents that have concrete implementations.
+      if (!componentImplementation.isAbstract()) {
+        // Use the parent's factory method to create this subcomponent if the
+        // subcomponent was not added via {@link dagger.Module#subcomponents()}.
+        graph.factoryMethod().ifPresent(this::createSubcomponentFactoryMethod);
+      }
+    }
+
+    void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
+      checkState(parent.isPresent());
+      parent
+          .get()
+          .componentImplementation
+          .addMethod(
+              COMPONENT_METHOD,
+              MethodSpec.overriding(factoryMethod, parentType(), types)
+                  .addStatement(
+                      "return new $T($L)",
+                      componentImplementation.name(),
+                      getFactoryMethodParameterSpecs(graph).stream()
+                          .map(param -> CodeBlock.of("$N", param))
+                          .collect(toParametersCodeBlock()))
+                  .build());
+    }
+
+    DeclaredType parentType() {
+      return asDeclared(parent.get().graph.componentTypeElement().asType());
+    }
+
+    @Override
+    void addInterfaceMethods() {
+      if (componentImplementation.superclassImplementation().isPresent()) {
+        // Since we're overriding a subcomponent implementation we add to its implementation given
+        // an expanded binding graph.
+
+        ComponentImplementation superclassImplementation =
+            componentImplementation.superclassImplementation().get();
+        for (ModifiableBindingMethod superclassModifiableBindingMethod :
+            superclassImplementation.getModifiableBindingMethods()) {
+          bindingExpressions
+              .modifiableBindingExpressions()
+              .reimplementedModifiableBindingMethod(superclassModifiableBindingMethod)
+              .ifPresent(componentImplementation::addImplementedModifiableBindingMethod);
+        }
+      } else {
+        super.addInterfaceMethods();
+      }
+    }
+
+    @Override
+    Optional<CodeBlock> cancelParentStatement() {
+      if (!shouldPropagateCancellationToParent()){
+        return Optional.empty();
+      }
+      return Optional.of(
+          CodeBlock.builder()
+              .addStatement(
+                  "$T.this.$N($N)",
+                  parent.get().componentImplementation.name(),
+                  CANCELLATION_LISTENER_METHOD_NAME,
+                  MAY_INTERRUPT_IF_RUNNING)
+              .build());
+    }
+
+    boolean shouldPropagateCancellationToParent() {
+      return parent.isPresent()
+          && parent
+              .get()
+              .componentImplementation
+              .componentDescriptor()
+              .cancellationPolicy()
+              .map(policy -> policy.fromSubcomponents().equals(PROPAGATE))
+              .orElse(false);
+    }
+  }
+
+  /** Returns the list of {@link ParameterSpec}s for the corresponding graph's factory method. */
+  private static ImmutableList<ParameterSpec> getFactoryMethodParameterSpecs(BindingGraph graph) {
+    return graph
+        .factoryMethodParameters()
+        .values()
+        .stream()
+        .map(ParameterSpec::get)
+        .collect(toImmutableList());
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentKind.java b/java/dagger/internal/codegen/ComponentKind.java
new file mode 100644
index 000000000..74d94f731
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentKind.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.DaggerStreams.presentValues;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static java.util.Arrays.stream;
+import static java.util.EnumSet.allOf;
+
+import com.google.common.collect.ImmutableSet;
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Annotation;
+import java.util.EnumSet;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Stream;
+import javax.lang.model.element.TypeElement;
+
+/** Enumeration of the different kinds of components. */
+enum ComponentKind {
+  /** {@code @Component} */
+  COMPONENT(Component.class, Optional.of(Component.Builder.class), true, false),
+
+  /** {@code @Subcomponent} */
+  SUBCOMPONENT(Subcomponent.class, Optional.of(Subcomponent.Builder.class), false, false),
+
+  /** {@code @ProductionComponent} */
+  PRODUCTION_COMPONENT(
+      ProductionComponent.class, Optional.of(ProductionComponent.Builder.class), true, true),
+
+  /** {@code @ProductionSubcomponent} */
+  PRODUCTION_SUBCOMPONENT(
+      ProductionSubcomponent.class, Optional.of(ProductionSubcomponent.Builder.class), false, true),
+
+  /**
+   * Kind for a descriptor that was generated from a {@link Module} instead of a component type in
+   * order to validate the module's bindings.
+   */
+  MODULE(Module.class, Optional.empty(), true, false),
+
+  /**
+   * Kind for a descriptor was generated from a {@link ProducerModule} instead of a component type
+   * in order to validate the module's bindings.
+   */
+  PRODUCER_MODULE(ProducerModule.class, Optional.empty(), true, true),
+  ;
+
+  private static final ImmutableSet<ComponentKind> TOP_LEVEL_COMPONENT_KINDS =
+      stream(values())
+          .filter(kind -> !kind.isForModuleValidation())
+          .filter(kind -> kind.isTopLevel())
+          .collect(toImmutableSet());
+
+  private static final ImmutableSet<ComponentKind> SUBCOMPONENT_KINDS =
+      stream(values())
+          .filter(kind -> !kind.isForModuleValidation())
+          .filter(kind -> !kind.isTopLevel())
+          .collect(toImmutableSet());
+
+  /** Returns the set of kinds for top-level components. */
+  static ImmutableSet<ComponentKind> topLevelComponentKinds() {
+    return TOP_LEVEL_COMPONENT_KINDS;
+  }
+
+  /** Returns the set of kinds for subcomponents. */
+  static ImmutableSet<ComponentKind> subcomponentKinds() {
+    return SUBCOMPONENT_KINDS;
+  }
+
+  /** Returns the set of all annotations that mark components and their builders. */
+  static ImmutableSet<Class<? extends Annotation>> allComponentAndBuilderAnnotations() {
+    return stream(values())
+        .filter(kind -> !kind.isForModuleValidation())
+        .flatMap(kind -> Stream.of(kind.annotation(), kind.builderAnnotation().get()))
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the annotations for components of the given kinds. */
+  static ImmutableSet<Class<? extends Annotation>> annotationsFor(Set<ComponentKind> kinds) {
+    return annotationsFor(kinds, kind -> Optional.of(kind.annotation()));
+  }
+
+  private static ImmutableSet<Class<? extends Annotation>> annotationsFor(
+      Set<ComponentKind> kinds,
+      Function<ComponentKind, Optional<Class<? extends Annotation>>> annotationFunction) {
+    return kinds.stream()
+        .map(annotationFunction)
+        .flatMap(presentValues())
+        .collect(toImmutableSet());
+  }
+  
+  /** Returns the annotations for builders for components of the given kinds. */
+  static ImmutableSet<Class<? extends Annotation>> builderAnnotationsFor(Set<ComponentKind> kinds) {
+    return annotationsFor(kinds, ComponentKind::builderAnnotation);
+  }
+
+  /**
+   * Returns the kind of an annotated element if it is annotated with one of the {@linkplain
+   * #annotation() annotations}.
+   *
+   * @throws IllegalArgumentException if the element is annotated with more than one of the
+   *     annotations
+   */
+  static Optional<ComponentKind> forAnnotatedElement(TypeElement element) {
+    return forAnnotatedElement(element, kind -> Optional.of(kind.annotation()));
+  }
+
+  private static Optional<ComponentKind> forAnnotatedElement(
+      TypeElement element,
+      Function<ComponentKind, Optional<Class<? extends Annotation>>> annotationFunction) {
+    Set<ComponentKind> kinds = EnumSet.noneOf(ComponentKind.class);
+    for (ComponentKind kind : values()) {
+      if (annotationFunction
+          .apply(kind)
+          .filter(annotation -> isAnnotationPresent(element, annotation))
+          .isPresent()) {
+        kinds.add(kind);
+      }
+    }
+
+    if (kinds.size() > 1) {
+      throw new IllegalArgumentException(
+          element
+              + " cannot be annotated with more than one of "
+              + annotationsFor(kinds, annotationFunction));
+    }
+    return kinds.stream().findAny();
+  }
+  
+  /**
+   * Returns the kind of an annotated element if it is annotated with one of the {@linkplain
+   * #builderAnnotation() builder annotations}.
+   *
+   * @throws IllegalArgumentException if the element is annotated with more than one of the builder
+   *     annotations
+   */
+  static Optional<ComponentKind> forAnnotatedBuilderElement(TypeElement element) {
+    return forAnnotatedElement(element, ComponentKind::builderAnnotation);
+  }
+
+  private final Class<? extends Annotation> annotation;
+  private final Optional<Class<? extends Annotation>> builderAnnotation;
+  private final boolean topLevel;
+  private final boolean production;
+
+  ComponentKind(
+      Class<? extends Annotation> annotation,
+      Optional<Class<? extends Annotation>> builderAnnotation,
+      boolean topLevel,
+      boolean production) {
+    this.annotation = annotation;
+    this.builderAnnotation = builderAnnotation;
+    this.topLevel = topLevel;
+    this.production = production;
+  }
+
+  /** Returns the annotation that marks a component of this kind. */
+  Class<? extends Annotation> annotation() {
+    return annotation;
+  }
+
+  /**
+   * Returns the {@code @Builder} annotation type for this kind of component, or empty if the
+   * descriptor is {@linkplain #isForModuleValidation() for a module} in order to validate its
+   * bindings.
+   */
+  Optional<Class<? extends Annotation>> builderAnnotation() {
+    return builderAnnotation;
+  }
+
+  /** Returns the kinds of modules that can be used with a component of this kind. */
+  ImmutableSet<ModuleKind> legalModuleKinds() {
+    return isProducer()
+        ? immutableEnumSet(allOf(ModuleKind.class))
+        : immutableEnumSet(ModuleKind.MODULE);
+  }
+
+  /** Returns the kinds of subcomponents a component of this kind can have. */
+  ImmutableSet<ComponentKind> legalSubcomponentKinds() {
+    return isProducer()
+        ? immutableEnumSet(PRODUCTION_SUBCOMPONENT)
+        : immutableEnumSet(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT);
+  }
+
+  /**
+   * Returns {@code true} if the descriptor is for a top-level (not a child) component or is for
+   * {@linkplain #isForModuleValidation() module-validation}.
+   */
+  boolean isTopLevel() {
+    return topLevel;
+  }
+
+  /** Returns true if this is a production component. */
+  boolean isProducer() {
+    return production;
+  }
+
+  /** Returns {@code true} if the descriptor is for a module in order to validate its bindings. */
+  boolean isForModuleValidation() {
+    switch (this) {
+      case MODULE:
+      case PRODUCER_MODULE:
+        return true;
+      default:
+        // fall through
+    }
+    return false;
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index 760c73523..e5e5c271f 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -30,22 +30,24 @@
  */
 final class ComponentMethodBindingExpression extends MethodBindingExpression {
   private final BindingMethodImplementation methodImplementation;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentMethodDescriptor componentMethod;
 
   ComponentMethodBindingExpression(
+      BindingRequest request,
       BindingMethodImplementation methodImplementation,
-      GeneratedComponentModel generatedComponentModel,
-      ComponentMethodDescriptor componentMethod) {
-    super(methodImplementation, generatedComponentModel);
+      ComponentImplementation componentImplementation,
+      ComponentMethodDescriptor componentMethod,
+      DaggerTypes types) {
+    super(request, methodImplementation, componentImplementation, types);
     this.methodImplementation = checkNotNull(methodImplementation);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.componentMethod = checkNotNull(componentMethod);
   }
 
   @Override
   protected CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
     // There could be several methods on the component for the same request key and kind.
     // Only one should use the BindingMethodImplementation; the others can delegate that one. So
     // use methodImplementation.body() only if componentMethod equals the method for this instance.
@@ -55,8 +57,8 @@ protected CodeBlock getComponentMethodImplementation(
     // for the parent and the child. Only the parent's should use the BindingMethodImplementation;
     // the child's can delegate to the parent. So use methodImplementation.body() only if
     // componentName equals the component for this instance.
-    return componentMethod.equals(this.componentMethod) && component.equals(generatedComponentModel)
-        ? methodImplementation.body()
+    return componentMethod.equals(this.componentMethod) && component.equals(componentImplementation)
+        ? methodImplementation.bodyForComponentMethod(componentMethod)
         : super.getComponentMethodImplementation(componentMethod, component);
   }
 
diff --git a/java/dagger/internal/codegen/ComponentModelBuilder.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
deleted file mode 100644
index 0b19d9010..000000000
--- a/java/dagger/internal/codegen/ComponentModelBuilder.java
+++ /dev/null
@@ -1,618 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.Preconditions.checkState;
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
-import static dagger.internal.codegen.DaggerStreams.toImmutableList;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.BUILDER_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.COMPONENT_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.CONSTRUCTOR;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.INITIALIZE_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_BUILDER;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Multimaps;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.ParameterSpec;
-import com.squareup.javapoet.TypeSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import java.util.List;
-import java.util.Optional;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.type.DeclaredType;
-
-/** Builds the model for an implementation of a component or subcomponent. */
-abstract class ComponentModelBuilder {
-  static GeneratedComponentModel buildComponentModel(
-      DaggerTypes types,
-      DaggerElements elements,
-      KeyFactory keyFactory,
-      CompilerOptions compilerOptions,
-      ClassName name,
-      BindingGraph graph,
-      BindingGraphFactory bindingGraphFactory) {
-    GeneratedComponentModel generatedComponentModel;
-    if (graph.componentDescriptor().kind().isTopLevel()) {
-      generatedComponentModel = GeneratedComponentModel.forComponent(name);
-    } else {
-      generatedComponentModel = GeneratedComponentModel.forBaseSubcomponent(name);
-    }
-    SubcomponentNames subcomponentNames = new SubcomponentNames(graph, keyFactory);
-    OptionalFactories optionalFactories = new OptionalFactories(generatedComponentModel);
-    Optional<ComponentBuilder> builder =
-        ComponentBuilder.create(generatedComponentModel, graph, subcomponentNames, elements, types);
-    ComponentRequirementFields componentRequirementFields =
-        new ComponentRequirementFields(graph, generatedComponentModel, builder);
-    ComponentBindingExpressions bindingExpressions =
-        new ComponentBindingExpressions(
-            graph,
-            generatedComponentModel,
-            subcomponentNames,
-            componentRequirementFields,
-            optionalFactories,
-            types,
-            elements,
-            compilerOptions);
-    if (generatedComponentModel.isAbstract()) {
-      checkState(
-          compilerOptions.aheadOfTimeSubcomponents(),
-          "Calling 'buildComponentModel()' on %s when not generating ahead-of-time subcomponents.",
-          graph.componentDescriptor().componentDefinitionType());
-      return new AbstractSubcomponentModelBuilder(
-              Optional.empty(), /* parent */
-              types,
-              elements,
-              keyFactory,
-              graph,
-              generatedComponentModel,
-              subcomponentNames,
-              optionalFactories,
-              bindingExpressions,
-              componentRequirementFields,
-              builder,
-              bindingGraphFactory,
-              compilerOptions)
-          .build();
-    } else {
-      return new RootComponentModelBuilder(
-              types,
-              elements,
-              keyFactory,
-              graph,
-              generatedComponentModel,
-              subcomponentNames,
-              optionalFactories,
-              bindingExpressions,
-              componentRequirementFields,
-              builder,
-              bindingGraphFactory,
-              compilerOptions)
-          .build();
-    }
-  }
-
-  private final DaggerElements elements;
-  private final DaggerTypes types;
-  private final KeyFactory keyFactory;
-  private final BindingGraph graph;
-  private final SubcomponentNames subcomponentNames;
-  private final ComponentBindingExpressions bindingExpressions;
-  private final ComponentRequirementFields componentRequirementFields;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final OptionalFactories optionalFactories;
-  private final Optional<ComponentBuilder> builder;
-  private final BindingGraphFactory bindingGraphFactory;
-  private final CompilerOptions compilerOptions;
-  private boolean done;
-
-  private ComponentModelBuilder(
-      DaggerTypes types,
-      DaggerElements elements,
-      KeyFactory keyFactory,
-      BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
-      SubcomponentNames subcomponentNames,
-      OptionalFactories optionalFactories,
-      ComponentBindingExpressions bindingExpressions,
-      ComponentRequirementFields componentRequirementFields,
-      Optional<ComponentBuilder> builder,
-      BindingGraphFactory bindingGraphFactory,
-      CompilerOptions compilerOptions) {
-    this.types = types;
-    this.elements = elements;
-    this.keyFactory = keyFactory;
-    this.graph = graph;
-    this.subcomponentNames = subcomponentNames;
-    this.generatedComponentModel = generatedComponentModel;
-    this.optionalFactories = optionalFactories;
-    this.bindingExpressions = bindingExpressions;
-    this.componentRequirementFields = componentRequirementFields;
-    this.builder = builder;
-    this.bindingGraphFactory = bindingGraphFactory;
-    this.compilerOptions = compilerOptions;
-  }
-
-  /**
-   * Returns a {@link GeneratedComponentModel} for this component. This is only intended to be
-   * called once (and will throw on successive invocations). If the component must be regenerated,
-   * use a new instance.
-   */
-  protected final GeneratedComponentModel build() {
-    checkState(
-        !done,
-        "ComponentModelBuilder has already built the GeneratedComponentModel for [%s].",
-        generatedComponentModel.name());
-    setSupertype();
-    builder.map(ComponentBuilder::typeSpec).ifPresent(this::addBuilderClass);
-
-    getLocalAndInheritedMethods(
-            graph.componentDescriptor().componentDefinitionType(), types, elements)
-        .forEach(method -> generatedComponentModel.claimMethodName(method.getSimpleName()));
-
-    addFactoryMethods();
-    addInterfaceMethods();
-    addSubcomponents();
-    addConstructor();
-
-    done = true;
-    return generatedComponentModel;
-  }
-
-  /** Set the supertype for this generated class. */
-  private void setSupertype() {
-    if (generatedComponentModel.supermodel().isPresent()) {
-      generatedComponentModel.addSuperclass(generatedComponentModel.supermodel().get().name());
-    } else {
-      generatedComponentModel.addSupertype(graph.componentType());
-    }
-  }
-
-  /**
-   * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest
-   * this in different classes.
-   */
-  protected abstract void addBuilderClass(TypeSpec builder);
-
-  /** Adds component factory methods. */
-  protected abstract void addFactoryMethods();
-
-  protected void addInterfaceMethods() {
-    /* Each component method may have been declared by several supertypes. We want to implement only
-     * one method for each distinct signature.*/
-    ImmutableListMultimap<MethodSignature, ComponentMethodDescriptor> componentMethodsBySignature =
-        Multimaps.index(graph.componentDescriptor().entryPointMethods(), this::getMethodSignature);
-    for (List<ComponentMethodDescriptor> methodsWithSameSignature :
-        Multimaps.asMap(componentMethodsBySignature).values()) {
-      ComponentMethodDescriptor anyOneMethod = methodsWithSameSignature.stream().findAny().get();
-      bindingExpressions
-          .getComponentMethod(anyOneMethod)
-          .ifPresent(method -> generatedComponentModel.addMethod(COMPONENT_METHOD, method));
-    }
-  }
-
-  private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
-    return MethodSignature.forComponentMethod(
-        method, MoreTypes.asDeclared(graph.componentType().asType()), types);
-  }
-
-  private void addSubcomponents() {
-    for (BindingGraph subgraph : graph.subgraphs()) {
-      // TODO(b/72748365): Can an abstract inner subcomponent implementation be elided if it's
-      // totally empty?
-      generatedComponentModel.addSubcomponent(
-          subgraph.componentDescriptor(),
-          generatedComponentModel.isAbstract()
-              ? buildAbstractInnerSubcomponentModel(subgraph)
-              : buildSubcomponentModel(subgraph));
-    }
-  }
-
-  private GeneratedComponentModel buildAbstractInnerSubcomponentModel(BindingGraph childGraph) {
-    ClassName childName =
-        generatedComponentModel
-            .name()
-            .nestedClass(subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
-    GeneratedComponentModel supermodel =
-        getSubcomponentSupermodel(childGraph.componentDescriptor());
-    GeneratedComponentModel childModel =
-        GeneratedComponentModel.forAbstractSubcomponent(childName, supermodel);
-    Optional<ComponentBuilder> childBuilder =
-        ComponentBuilder.create(childModel, childGraph, subcomponentNames, elements, types);
-    ComponentRequirementFields childComponentRequirementFields =
-        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilder);
-    ComponentBindingExpressions childBindingExpressions =
-        bindingExpressions.forChildComponent(
-            childGraph, childModel, childComponentRequirementFields);
-    return new AbstractSubcomponentModelBuilder(
-            Optional.of(this),
-            types,
-            elements,
-            keyFactory,
-            childGraph,
-            childModel,
-            subcomponentNames,
-            optionalFactories,
-            childBindingExpressions,
-            childComponentRequirementFields,
-            childBuilder,
-            bindingGraphFactory,
-            compilerOptions)
-        .build();
-  }
-
-  private GeneratedComponentModel getSubcomponentSupermodel(ComponentDescriptor subcomponent) {
-    // If the current model is for a subcomponent that has a defined supermodel, that supermodel
-    // should contain a reference to a model for `subcomponent`
-    if (generatedComponentModel.supermodel().isPresent()) {
-      Optional<GeneratedComponentModel> supermodel =
-          generatedComponentModel.supermodel().get().subcomponentModel(subcomponent);
-      checkState(
-          supermodel.isPresent(),
-          "Attempting to generate an implementation of a subcomponent [%s] whose parent is a "
-              + "subcomponent [%s], but whose supermodel is not present on the parent's "
-              + "supermodel.",
-          subcomponent.componentDefinitionType(),
-          graph.componentType());
-      return supermodel.get();
-    }
-
-    // Otherwise, the enclosing component is top-level, so we must generate the supermodel for the
-    // subcomponent. We do so by building the model for the abstract base class for the
-    // subcomponent. This is done by truncating the binding graph at the subcomponent.
-    BindingGraph truncatedBindingGraph = bindingGraphFactory.create(subcomponent);
-    return buildComponentModel(
-        // TODO(ronshapiro): extract a factory class here so that we don't need to pass around
-        // types, elements, keyFactory, etc...
-        types,
-        elements,
-        keyFactory,
-        compilerOptions,
-        ComponentGenerator.componentName(truncatedBindingGraph.componentType()),
-        truncatedBindingGraph,
-        bindingGraphFactory);
-  }
-
-  private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph) {
-    ClassName parentName = generatedComponentModel.name();
-    ClassName childName =
-        parentName.nestedClass(subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
-    GeneratedComponentModel childModel = GeneratedComponentModel.forSubcomponent(childName);
-    Optional<ComponentBuilder> childBuilder =
-        ComponentBuilder.create(childModel, childGraph, subcomponentNames, elements, types);
-    ComponentRequirementFields childComponentRequirementFields =
-        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilder);
-    ComponentBindingExpressions childBindingExpressions =
-        bindingExpressions.forChildComponent(
-            childGraph, childModel, childComponentRequirementFields);
-    return new SubComponentModelBuilder(
-            this,
-            childGraph,
-            childModel,
-            childBindingExpressions,
-            childComponentRequirementFields,
-            childBuilder)
-        .build();
-  }
-
-  private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
-
-  private void addConstructor() {
-    List<List<CodeBlock>> partitions =
-        Lists.partition(
-            generatedComponentModel.getInitializations(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
-
-    ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
-    MethodSpec.Builder constructor =
-        constructorBuilder()
-            .addModifiers(generatedComponentModel.isAbstract() ? PROTECTED : PRIVATE)
-            .addParameters(constructorParameters);
-
-    if (generatedComponentModel.supermodel().isPresent()) {
-      constructor.addStatement(
-          CodeBlock.of(
-              "super($L)",
-              constructorParameters
-                  .stream()
-                  .map(param -> CodeBlock.of("$N", param))
-                  .collect(toParametersCodeBlock())));
-    }
-
-    ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
-    CodeBlock initializeParametersCodeBlock =
-        constructorParameters
-            .stream()
-            .map(param -> CodeBlock.of("$N", param))
-            .collect(toParametersCodeBlock());
-
-    UniqueNameSet methodNames = new UniqueNameSet();
-    for (List<CodeBlock> partition : partitions) {
-      String methodName = methodNames.getUniqueName("initialize");
-      MethodSpec.Builder initializeMethod =
-          methodBuilder(methodName)
-              .addModifiers(PRIVATE)
-              /* TODO(gak): Strictly speaking, we only need the suppression here if we are also
-               * initializing a raw field in this method, but the structure of this code makes it
-               * awkward to pass that bit through.  This will be cleaned up when we no longer
-               * separate fields and initilization as we do now. */
-              .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
-              .addCode(CodeBlocks.concat(partition));
-      initializeMethod.addParameters(initializeParameters);
-      constructor.addStatement("$L($L)", methodName, initializeParametersCodeBlock);
-      generatedComponentModel.addMethod(INITIALIZE_METHOD, initializeMethod.build());
-    }
-    generatedComponentModel.addMethod(CONSTRUCTOR, constructor.build());
-  }
-
-  /** Returns the list of {@link ParameterSpec}s for the initialze methods. */
-  private ImmutableList<ParameterSpec> initializeParameters() {
-    return constructorParameters()
-        .stream()
-        .map(param -> param.toBuilder().addModifiers(FINAL).build())
-        .collect(toImmutableList());
-  }
-
-  /** Returns the list of {@link ParameterSpec}s for the constructor. */
-  private ImmutableList<ParameterSpec> constructorParameters() {
-    if (builder.isPresent()) {
-      return ImmutableList.of(ParameterSpec.builder(builder.get().name(), "builder").build());
-    } else if (graph.factoryMethod().isPresent()) {
-      return getFactoryMethodParameterSpecs(graph);
-    } else if (generatedComponentModel.isAbstract() && !generatedComponentModel.isNested()) {
-      return ImmutableList.of();
-    } else {
-      throw new AssertionError(
-          "Expected either a component builder or factory method but found neither.");
-    }
-  }
-
-  /** Builds the model for the root component. */
-  private static final class RootComponentModelBuilder extends ComponentModelBuilder {
-    RootComponentModelBuilder(
-        DaggerTypes types,
-        DaggerElements elements,
-        KeyFactory keyFactory,
-        BindingGraph graph,
-        GeneratedComponentModel generatedComponentModel,
-        SubcomponentNames subcomponentNames,
-        OptionalFactories optionalFactories,
-        ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields,
-        Optional<ComponentBuilder> builder,
-        BindingGraphFactory bindingGraphFactory,
-        CompilerOptions compilerOptions) {
-      super(
-          types,
-          elements,
-          keyFactory,
-          graph,
-          generatedComponentModel,
-          subcomponentNames,
-          optionalFactories,
-          bindingExpressions,
-          componentRequirementFields,
-          builder,
-          bindingGraphFactory,
-          compilerOptions);
-    }
-
-    @Override
-    protected void addBuilderClass(TypeSpec builder) {
-      super.generatedComponentModel.addType(COMPONENT_BUILDER, builder);
-    }
-
-    @Override
-    protected void addFactoryMethods() {
-      // Only top-level components have the factory builder() method.
-      // Mirror the user's builder API type if they had one.
-      MethodSpec builderFactoryMethod =
-          methodBuilder("builder")
-              .addModifiers(PUBLIC, STATIC)
-              .returns(
-                  builderSpec().isPresent()
-                      ? ClassName.get(builderSpec().get().builderDefinitionType())
-                      : super.builder.get().name())
-              .addStatement("return new $T()", super.builder.get().name())
-              .build();
-      super.generatedComponentModel.addMethod(BUILDER_METHOD, builderFactoryMethod);
-      if (canInstantiateAllRequirements()) {
-        CharSequence buildMethodName =
-            builderSpec().isPresent() ? builderSpec().get().buildMethod().getSimpleName() : "build";
-        super.generatedComponentModel.addMethod(
-            BUILDER_METHOD,
-            methodBuilder("create")
-                .returns(ClassName.get(super.graph.componentType()))
-                .addModifiers(PUBLIC, STATIC)
-                .addStatement("return new Builder().$L()", buildMethodName)
-                .build());
-      }
-    }
-
-    private Optional<ComponentDescriptor.BuilderSpec> builderSpec() {
-      return super.graph.componentDescriptor().builderSpec();
-    }
-
-    /** {@code true} if all of the graph's required dependencies can be automatically constructed */
-    private boolean canInstantiateAllRequirements() {
-      return !Iterables.any(
-          super.graph.componentRequirements(),
-          dependency -> dependency.requiresAPassedInstance(super.elements, super.types));
-    }
-  }
-
-  /**
-   * Builds the model for a nested subcomponent. This is used when ahead-of-time components are not
-   * enabled (current default mode).
-   */
-  private static final class SubComponentModelBuilder extends ComponentModelBuilder {
-    private final ComponentModelBuilder parent;
-
-    SubComponentModelBuilder(
-        ComponentModelBuilder parent,
-        BindingGraph graph,
-        GeneratedComponentModel generatedComponentModel,
-        ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields,
-        Optional<ComponentBuilder> builder) {
-      super(
-          parent.types,
-          parent.elements,
-          parent.keyFactory,
-          graph,
-          generatedComponentModel,
-          parent.subcomponentNames,
-          parent.optionalFactories,
-          bindingExpressions,
-          componentRequirementFields,
-          builder,
-          parent.bindingGraphFactory,
-          parent.compilerOptions);
-      this.parent = parent;
-    }
-
-    @Override
-    protected void addBuilderClass(TypeSpec builder) {
-      parent.generatedComponentModel.addType(SUBCOMPONENT, builder);
-    }
-
-    @Override
-    protected void addFactoryMethods() {
-      // The parent's factory method to create this subcomponent if the
-      // subcomponent was not added via {@link dagger.Module#subcomponents()}.
-      super.graph.factoryMethod().ifPresent(this::createSubcomponentFactoryMethod);
-    }
-
-    private void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
-      parent.generatedComponentModel.addMethod(
-          COMPONENT_METHOD,
-          MethodSpec.overriding(factoryMethod, parentType(), super.types)
-              .addStatement(
-                  "return new $T($L)",
-                  super.generatedComponentModel.name(),
-                  getFactoryMethodParameterSpecs(super.graph)
-                      .stream()
-                      .map(param -> CodeBlock.of("$N", param))
-                      .collect(toParametersCodeBlock()))
-              .build());
-    }
-
-    private DeclaredType parentType() {
-      return asDeclared(parent.graph.componentType().asType());
-    }
-  }
-
-  /** Builds the model for abstract implementations of a subcomponent. */
-  private static final class AbstractSubcomponentModelBuilder extends ComponentModelBuilder {
-    private final Optional<ComponentModelBuilder> parent;
-    private final GeneratedComponentModel generatedComponentModel;
-    private final ComponentBindingExpressions bindingExpressions;
-
-    AbstractSubcomponentModelBuilder(
-        Optional<ComponentModelBuilder> parent,
-        DaggerTypes types,
-        DaggerElements elements,
-        KeyFactory keyFactory,
-        BindingGraph graph,
-        GeneratedComponentModel generatedComponentModel,
-        SubcomponentNames subcomponentNames,
-        OptionalFactories optionalFactories,
-        ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields,
-        Optional<ComponentBuilder> builder,
-        BindingGraphFactory bindingGraphFactory,
-        CompilerOptions compilerOptions) {
-      super(
-          types,
-          elements,
-          keyFactory,
-          graph,
-          generatedComponentModel,
-          subcomponentNames,
-          optionalFactories,
-          bindingExpressions,
-          componentRequirementFields,
-          builder,
-          bindingGraphFactory,
-          compilerOptions);
-      this.parent = parent;
-      this.generatedComponentModel = generatedComponentModel;
-      this.bindingExpressions = bindingExpressions;
-    }
-
-    @Override
-    protected void addBuilderClass(TypeSpec builder) {
-      if (parent.isPresent()) {
-        // If an inner implementation of a subcomponent the builder is a peer class.
-        parent.get().generatedComponentModel.addType(SUBCOMPONENT, builder);
-      } else {
-        generatedComponentModel.addType(SUBCOMPONENT, builder);
-      }
-    }
-
-    @Override
-    protected void addFactoryMethods() {
-      // Only construct instances of subcomponents that have concrete implementations.
-    }
-
-    @Override
-    protected void addInterfaceMethods() {
-      if (generatedComponentModel.supermodel().isPresent()) {
-        // Since we're overriding a subcomponent implementation we add to its implementation given
-        // an expanded binding graph.
-
-        // Override modifiable binding methods.
-        for (ModifiableBindingMethod modifiableBindingMethod :
-            generatedComponentModel.getModifiableBindingMethods()) {
-          bindingExpressions
-              .getModifiableBindingMethod(modifiableBindingMethod)
-              .ifPresent(
-                  method -> generatedComponentModel.addImplementedModifiableBindingMethod(method));
-        }
-      } else {
-        super.addInterfaceMethods();
-      }
-    }
-  }
-
-  /** Returns the list of {@link ParameterSpec}s for the corresponding graph's factory method. */
-  private static ImmutableList<ParameterSpec> getFactoryMethodParameterSpecs(BindingGraph graph) {
-    return graph
-        .factoryMethodParameters()
-        .values()
-        .stream()
-        .map(ParameterSpec::get)
-        .collect(toImmutableList());
-  }
-}
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 62881c3d3..2a6397241 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -16,21 +16,23 @@
 
 package dagger.internal.codegen;
 
-import static javax.lang.model.util.ElementFilter.typesIn;
+import static dagger.internal.codegen.ComponentKind.allComponentAndBuilderAnnotations;
+import static dagger.internal.codegen.ComponentKind.annotationsFor;
+import static dagger.internal.codegen.ComponentKind.builderAnnotationsFor;
+import static dagger.internal.codegen.ComponentKind.subcomponentKinds;
+import static dagger.internal.codegen.ComponentKind.topLevelComponentKinds;
+import static java.util.Collections.disjoint;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
-import dagger.Component;
-import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
@@ -42,35 +44,41 @@
  * A {@link ProcessingStep} that is responsible for dealing with a component or production component
  * as part of the {@link ComponentProcessor}.
  */
-final class ComponentProcessingStep implements ProcessingStep {
+final class ComponentProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Messager messager;
   private final ComponentValidator componentValidator;
-  private final BuilderValidator builderValidator;
+  private final ComponentCreatorValidator creatorValidator;
   private final ComponentDescriptorValidator componentDescriptorValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraphFactory bindingGraphFactory;
-  private final ComponentGenerator componentGenerator;
+  private final SourceFileGenerator<BindingGraph> componentGenerator;
   private final BindingGraphConverter bindingGraphConverter;
   private final BindingGraphPlugins validationPlugins;
   private final BindingGraphPlugins spiPlugins;
   private final CompilerOptions compilerOptions;
+  private ImmutableSet<Element> subcomponentElements;
+  private ImmutableSet<Element> subcomponentBuilderElements;
+  private ImmutableMap<Element, ValidationReport<TypeElement>> builderReportsByComponent;
+  private ImmutableMap<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent;
+  private ImmutableMap<Element, ValidationReport<TypeElement>> reportsBySubcomponent;
 
   @Inject
   ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
-      BuilderValidator builderValidator,
+      ComponentCreatorValidator creatorValidator,
       ComponentDescriptorValidator componentDescriptorValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraphFactory bindingGraphFactory,
-      ComponentGenerator componentGenerator,
+      SourceFileGenerator<BindingGraph> componentGenerator,
       BindingGraphConverter bindingGraphConverter,
       @Validation BindingGraphPlugins validationPlugins,
       BindingGraphPlugins spiPlugins,
       CompilerOptions compilerOptions) {
+    super(MoreElements::asType);
     this.messager = messager;
     this.componentValidator = componentValidator;
-    this.builderValidator = builderValidator;
+    this.creatorValidator = creatorValidator;
     this.componentDescriptorValidator = componentDescriptorValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
@@ -83,92 +91,65 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(
-        Component.class,
-        Component.Builder.class,
-        ProductionComponent.class,
-        ProductionComponent.Builder.class,
-        Subcomponent.class,
-        Subcomponent.Builder.class,
-        ProductionSubcomponent.class,
-        ProductionSubcomponent.Builder.class);
+    return allComponentAndBuilderAnnotations();
   }
 
   @Override
   public ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-
-    ImmutableSet<Element> componentElements =
-        getElementsFromAnnotations(
-            elementsByAnnotation, Component.class, ProductionComponent.class);
-    ImmutableSet<Element> componentBuilderElements =
+    subcomponentElements =
+        getElementsFromAnnotations(elementsByAnnotation, annotationsFor(subcomponentKinds()));
+    subcomponentBuilderElements =
         getElementsFromAnnotations(
-            elementsByAnnotation, Component.Builder.class, ProductionComponent.Builder.class);
+            elementsByAnnotation, builderAnnotationsFor(subcomponentKinds()));
 
-    ImmutableSet<Element> subcomponentElements =
-        getElementsFromAnnotations(
-            elementsByAnnotation, Subcomponent.class, ProductionSubcomponent.class);
-    ImmutableSet<Element> subcomponentBuilderElements =
-        getElementsFromAnnotations(
-            elementsByAnnotation, Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
+    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
 
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
-        processBuilders(componentBuilderElements);
-    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
-        processBuilders(subcomponentBuilderElements);
-    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
-        processSubcomponents(subcomponentElements, subcomponentBuilderElements);
+    builderReportsByComponent =
+        processBuilders(
+            getElementsFromAnnotations(
+                elementsByAnnotation, builderAnnotationsFor(topLevelComponentKinds())),
+            rejectedElements);
+    builderReportsBySubcomponent = processBuilders(subcomponentBuilderElements, rejectedElements);
+    reportsBySubcomponent =
+        processSubcomponents(subcomponentElements, subcomponentBuilderElements, rejectedElements);
 
-    for (TypeElement componentTypeElement : typesIn(componentElements)) {
-      try {
-        ComponentValidationReport validationReport =
-            componentValidator.validate(
-                componentTypeElement, subcomponentElements, subcomponentBuilderElements);
-        validationReport.report().printMessagesTo(messager);
-        if (!isClean(
-            validationReport,
-            builderReportsByComponent,
-            reportsBySubcomponent,
-            builderReportsBySubcomponent)) {
-          continue;
-        }
-        ComponentDescriptor componentDescriptor =
-            componentDescriptorFactory.forComponent(componentTypeElement);
-        ValidationReport<TypeElement> componentDescriptorReport =
-            componentDescriptorValidator.validate(componentDescriptor);
-        componentDescriptorReport.printMessagesTo(messager);
-        if (!componentDescriptorReport.isClean()) {
-          continue;
-        }
-        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-        if (isValid(bindingGraph)) {
-          generateComponent(bindingGraph);
-        }
-      } catch (TypeNotPresentException e) {
-        rejectedElements.add(componentTypeElement);
+    return rejectedElements.addAll(super.process(elementsByAnnotation)).build();
+  }
+
+  @Override
+  protected void process(
+      TypeElement element, ImmutableSet<Class<? extends Annotation>> annotations) {
+    if (!disjoint(annotations, annotationsFor(topLevelComponentKinds()))) {
+      ComponentValidationReport validationReport =
+          componentValidator.validate(element, subcomponentElements, subcomponentBuilderElements);
+      validationReport.report().printMessagesTo(messager);
+      if (!isClean(validationReport)) {
+        return;
+      }
+      ComponentDescriptor componentDescriptor = componentDescriptorFactory.forTypeElement(element);
+      ValidationReport<TypeElement> componentDescriptorReport =
+          componentDescriptorValidator.validate(componentDescriptor);
+      componentDescriptorReport.printMessagesTo(messager);
+      if (!componentDescriptorReport.isClean()) {
+        return;
+      }
+      BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+      if (isValid(bindingGraph)) {
+        generateComponent(bindingGraph);
       }
     }
-
-    if (compilerOptions.aheadOfTimeSubcomponents()) {
-      for (TypeElement subcomponentTypeElement : typesIn(subcomponentElements)) {
-        if (!subcomponentIsClean(
-            subcomponentTypeElement, reportsBySubcomponent, builderReportsBySubcomponent)) {
-          continue;
-        }
-        try {
-          ComponentDescriptor componentDescriptor =
-              componentDescriptorFactory.forComponent(subcomponentTypeElement);
-          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-          // TODO(b/72748365): Do subgraph validation.
-          generateComponent(bindingGraph);
-        } catch (TypeNotPresentException e) {
-          rejectedElements.add(subcomponentTypeElement);
-        }
+    if (compilerOptions.aheadOfTimeSubcomponents()
+        && !disjoint(annotations, annotationsFor(subcomponentKinds()))) {
+      if (!subcomponentIsClean(element)) {
+        return;
+      }
+      ComponentDescriptor componentDescriptor = componentDescriptorFactory.forTypeElement(element);
+      BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+      if (isValid(bindingGraph)) {
+        generateComponent(bindingGraph);
       }
     }
-
-    return rejectedElements.build();
   }
 
   private boolean isValid(BindingGraph bindingGraph) {
@@ -183,47 +164,53 @@ private void generateComponent(BindingGraph bindingGraph) {
 
   static ImmutableSet<Element> getElementsFromAnnotations(
       final SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation,
-      Class<? extends Annotation>... annotations) {
+      Set<Class<? extends Annotation>> annotations) {
     return ImmutableSet.copyOf(
-        Multimaps.filterKeys(elementsByAnnotation, Predicates.in(ImmutableSet.copyOf(annotations)))
-            .values());
+        Multimaps.filterKeys(elementsByAnnotation, Predicates.in(annotations)).values());
   }
 
-  private Map<Element, ValidationReport<TypeElement>> processBuilders(
-      Set<? extends Element> builderElements) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+  private ImmutableMap<Element, ValidationReport<TypeElement>> processBuilders(
+      Set<? extends Element> builderElements, ImmutableSet.Builder<Element> rejectedElements) {
+    // Can't use an ImmutableMap.Builder here because a component may have (invalidly) more than one
+    // builder type, and that would make ImmutableMap.Builder throw.
+    Map<Element, ValidationReport<TypeElement>> reports = new HashMap<>();
     for (Element element : builderElements) {
-      ValidationReport<TypeElement> report =
-          builderValidator.validate(MoreElements.asType(element));
-      report.printMessagesTo(messager);
-      builderReportsByComponent.put(element.getEnclosingElement(), report);
+      try {
+        ValidationReport<TypeElement> report =
+            creatorValidator.validate(MoreElements.asType(element));
+        report.printMessagesTo(messager);
+        reports.put(element.getEnclosingElement(), report);
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(element);
+      }
     }
-    return builderReportsByComponent;
+    return ImmutableMap.copyOf(reports);
   }
 
-  private Map<Element, ValidationReport<TypeElement>> processSubcomponents(
+  private ImmutableMap<Element, ValidationReport<TypeElement>> processSubcomponents(
       Set<? extends Element> subcomponentElements,
-      Set<? extends Element> subcomponentBuilderElements) {
-    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent = Maps.newHashMap();
+      Set<? extends Element> subcomponentBuilderElements,
+      ImmutableSet.Builder<Element> rejectedElements) {
+    ImmutableMap.Builder<Element, ValidationReport<TypeElement>> reports = ImmutableMap.builder();
     for (Element element : subcomponentElements) {
-      ComponentValidationReport report =
-          componentValidator.validate(
-              MoreElements.asType(element), subcomponentElements, subcomponentBuilderElements);
-      report.report().printMessagesTo(messager);
-      reportsBySubcomponent.put(element, report.report());
+      try {
+        ComponentValidationReport report =
+            componentValidator.validate(
+                MoreElements.asType(element), subcomponentElements, subcomponentBuilderElements);
+        report.report().printMessagesTo(messager);
+        reports.put(element, report.report());
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(element);
+      }
     }
-    return reportsBySubcomponent;
+    return reports.build();
   }
 
   /**
    * Returns true if the component's report is clean, its builder report is clean, and all
    * referenced subcomponent reports and subcomponent builder reports are clean.
    */
-  private boolean isClean(
-      ComponentValidationReport report,
-      Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
-      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
-      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+  private boolean isClean(ComponentValidationReport report) {
     Element component = report.report().subject();
     ValidationReport<?> componentReport = report.report();
     if (!componentReport.isClean()) {
@@ -234,7 +221,7 @@ private boolean isClean(
       return false;
     }
     for (Element element : report.referencedSubcomponents()) {
-      if (!subcomponentIsClean(element, reportsBySubcomponent, builderReportsBySubcomponent)) {
+      if (!subcomponentIsClean(element)) {
         return false;
       }
     }
@@ -242,10 +229,7 @@ private boolean isClean(
   }
 
   /** Returns true if the reports associated with the subcomponent are clean. */
-  private boolean subcomponentIsClean(
-      Element subcomponentElement,
-      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
-      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+  private boolean subcomponentIsClean(Element subcomponentElement) {
     ValidationReport<?> subcomponentBuilderReport =
         builderReportsBySubcomponent.get(subcomponentElement);
     if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index 4af57560a..28e5af748 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
-import dagger.Binds;
 import dagger.BindsInstance;
 import dagger.Component;
 import dagger.Module;
@@ -50,11 +49,13 @@
   private final Optional<ImmutableSet<BindingGraphPlugin>> testingPlugins;
 
   @Inject InjectBindingRegistry injectBindingRegistry;
-  @Inject FactoryGenerator factoryGenerator;
-  @Inject MembersInjectorGenerator membersInjectorGenerator;
+  @Inject SourceFileGenerator<ProvisionBinding> factoryGenerator;
+  @Inject SourceFileGenerator<MembersInjectionBinding> membersInjectorGenerator;
   @Inject ImmutableList<ProcessingStep> processingSteps;
   @Inject BindingGraphPlugins spiPlugins;
+  @Inject CompilerOptions compilerOptions;
   @Inject @Validation BindingGraphPlugins validationPlugins;
+  @Inject DaggerStatistics daggerStatistics;
 
   public ComponentProcessor() {
     this.testingPlugins = Optional.empty();
@@ -93,7 +94,7 @@ public SourceVersion getSupportedSourceVersion() {
     options.addAll(CompilerOptions.SUPPORTED_OPTIONS);
     options.addAll(spiPlugins.allSupportedOptions());
     options.addAll(validationPlugins.allSupportedOptions());
-    if (processingEnv.getOptions().containsKey(CompilerOptions.GRADLE_INCREMENTAL)) {
+    if (compilerOptions.useGradleIncrementalProcessing()) {
       options.add("org.gradle.annotation.processing.isolating");
     }
     return options.build();
@@ -107,6 +108,7 @@ public SourceVersion getSupportedSourceVersion() {
         .build()
         .inject(this);
 
+    daggerStatistics.processingStarted();
     spiPlugins.initializePlugins();
     validationPlugins.initializePlugins();
     return processingSteps;
@@ -115,12 +117,14 @@ public SourceVersion getSupportedSourceVersion() {
   @Singleton
   @Component(
       modules = {
-        ProcessingEnvironmentModule.class,
-        BindingGraphPluginsModule.class,
         BindingGraphValidationModule.class,
         BindingMethodValidatorsModule.class,
-        IncorrectlyInstalledBindsMethodsValidator.Module.class,
+        InjectBindingRegistryModule.class,
+        ProcessingEnvironmentModule.class,
         ProcessingStepsModule.class,
+        SourceFileGeneratorsModule.class,
+        SpiModule.class,
+        SystemComponentsModule.class
       })
   interface ProcessorComponent {
     void inject(ComponentProcessor processor);
@@ -147,11 +151,8 @@ Builder testingPlugins(
     @Provides
     static ImmutableList<ProcessingStep> processingSteps(
         MapKeyProcessingStep mapKeyProcessingStep,
-        ForReleasableReferencesValidator forReleasableReferencesValidator,
-        CanReleaseReferencesProcessingStep canReleaseReferencesProcessingStep,
         InjectProcessingStep injectProcessingStep,
         MonitoringModuleProcessingStep monitoringModuleProcessingStep,
-        ProductionExecutorModuleProcessingStep productionExecutorModuleProcessingStep,
         MultibindingAnnotationsProcessingStep multibindingAnnotationsProcessingStep,
         BindsInstanceProcessingStep bindsInstanceProcessingStep,
         ModuleProcessingStep moduleProcessingStep,
@@ -161,27 +162,27 @@ Builder testingPlugins(
         CompilerOptions compilerOptions) {
       return ImmutableList.of(
           mapKeyProcessingStep,
-          forReleasableReferencesValidator,
-          canReleaseReferencesProcessingStep,
           injectProcessingStep,
           monitoringModuleProcessingStep,
-          productionExecutorModuleProcessingStep,
           multibindingAnnotationsProcessingStep,
           bindsInstanceProcessingStep,
           moduleProcessingStep,
           compilerOptions.headerCompilation()
+                  // Ahead Of Time subcomponents use the regular hjar filtering in
+                  // HjarSourceFileGenerator since they must retain protected implementation methods
+                  // between subcomponents
+                  && !compilerOptions.aheadOfTimeSubcomponents()
               ? componentHjarProcessingStep
               : componentProcessingStep,
           bindingMethodProcessingStep);
     }
-
-    @Binds
-    InjectBindingRegistry injectBindingRegistry(InjectBindingRegistryImpl impl);
   }
 
   @Override
   protected void postRound(RoundEnvironment roundEnv) {
-    if (!roundEnv.processingOver()) {
+    if (roundEnv.processingOver()) {
+      daggerStatistics.processingStopped();
+    } else {
       try {
         injectBindingRegistry.generateSourcesForRequiredBindings(
             factoryGenerator, membersInjectorGenerator);
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index f781a8986..723673ba6 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -26,18 +26,18 @@
 final class ComponentProvisionBindingExpression extends SimpleInvocationBindingExpression {
   private final ProvisionBinding binding;
   private final BindingGraph bindingGraph;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
   private final CompilerOptions compilerOptions;
 
   ComponentProvisionBindingExpression(
       ResolvedBindings resolvedBindings,
       BindingGraph bindingGraph,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentRequirementExpressions componentRequirementExpressions,
       CompilerOptions compilerOptions) {
     super(resolvedBindings);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     this.bindingGraph = checkNotNull(bindingGraph);
-    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.componentRequirementExpressions = checkNotNull(componentRequirementExpressions);
     this.compilerOptions = checkNotNull(compilerOptions);
   }
 
@@ -46,7 +46,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
     CodeBlock invocation =
         CodeBlock.of(
             "$L.$L()",
-            componentRequirementFields.getExpression(componentRequirement(), requestingClass),
+            componentRequirementExpressions.getExpression(componentRequirement(), requestingClass),
             binding.bindingElement().get().getSimpleName());
     return Expression.create(
         binding.contributedPrimitiveType().orElse(binding.key().type()),
@@ -56,8 +56,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   private ComponentRequirement componentRequirement() {
     return bindingGraph
         .componentDescriptor()
-        .dependenciesByDependencyMethod()
-        .get(binding.bindingElement().get());
+        .getDependencyThatDefinesMethod(binding.bindingElement().get());
   }
 
   static CodeBlock maybeCheckForNull(
diff --git a/java/dagger/internal/codegen/ComponentRequirement.java b/java/dagger/internal/codegen/ComponentRequirement.java
index 38104faa6..7047d9bbd 100644
--- a/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/java/dagger/internal/codegen/ComponentRequirement.java
@@ -57,11 +57,26 @@
      * An object that is passed to a builder's {@link dagger.BindsInstance @BindsInstance} method.
      */
     BOUND_INSTANCE,
+    ;
+
+    boolean isBoundInstance() {
+      return equals(BOUND_INSTANCE);
+    }
+
+    boolean isModule() {
+      return equals(MODULE);
+    }
   }
 
   /** The kind of requirement. */
   abstract Kind kind();
 
+  /** Returns true if this is a {@link Kind#BOUND_INSTANCE} requirement. */
+  // TODO(ronshapiro): consider removing this and inlining the usages
+  final boolean isBoundInstance() {
+    return kind().isBoundInstance();
+  }
+
   /**
    * The type of the instance the component must have, wrapped so that requirements can be used as
    * value types.
@@ -120,7 +135,7 @@ NullPolicy nullPolicy(Elements elements, Types types) {
    * to be used within a component.
    */
   boolean requiresAPassedInstance(Elements elements, Types types) {
-    if (kind().equals(Kind.BOUND_INSTANCE)) {
+    if (isBoundInstance()) {
       // A user has explicitly defined in their component builder they will provide an instance.
       return true;
     }
diff --git a/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java b/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
index f00502bdc..e0cdd5a46 100644
--- a/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
@@ -25,21 +25,21 @@
  */
 final class ComponentRequirementBindingExpression extends SimpleInvocationBindingExpression {
   private final ComponentRequirement componentRequirement;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
 
   ComponentRequirementBindingExpression(
       ResolvedBindings resolvedBindings,
       ComponentRequirement componentRequirement,
-      ComponentRequirementFields componentRequirementFields) {
+      ComponentRequirementExpressions componentRequirementExpressions) {
     super(resolvedBindings);
     this.componentRequirement = componentRequirement;
-    this.componentRequirementFields = componentRequirementFields;
+    this.componentRequirementExpressions = componentRequirementExpressions;
   }
 
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
     return Expression.create(
         componentRequirement.type(),
-        componentRequirementFields.getExpression(componentRequirement, requestingClass));
+        componentRequirementExpressions.getExpression(componentRequirement, requestingClass));
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentRequirementField.java b/java/dagger/internal/codegen/ComponentRequirementExpression.java
similarity index 72%
rename from java/dagger/internal/codegen/ComponentRequirementField.java
rename to java/dagger/internal/codegen/ComponentRequirementExpression.java
index b9c478539..540d00cff 100644
--- a/java/dagger/internal/codegen/ComponentRequirementField.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpression.java
@@ -25,11 +25,11 @@
  * {@link dagger.model.Key}. See {@link ComponentRequirementBindingExpression} for binding
  * expressions that are themselves a component requirement.
  */
-interface ComponentRequirementField {
+interface ComponentRequirementExpression {
   /**
    * Returns an expression for the {@link ComponentRequirement} to be used when implementing a
-   * component method. This may add a field to the component in order to reference the component
-   * requirement outside of the {@code initialize()} methods.
+   * component method. This may add a field or method to the component in order to reference the
+   * component requirement outside of the {@code initialize()} methods.
    */
   CodeBlock getExpression(ClassName requestingClass);
 
@@ -37,8 +37,10 @@
    * Returns an expression for the {@link ComponentRequirement} to be used only within {@code
    * initialize()} methods, where the component builder is available.
    *
-   * <p>When accessing this field from a subcomponent, this may cause a field to be initialized in
-   * the component that owns this {@link ComponentRequirement}.
+   * <p>When accessing this expression from a subcomponent, this may cause a field to be initialized
+   * or a method to be added in the component that owns this {@link ComponentRequirement}.
    */
-  CodeBlock getExpressionDuringInitialization(ClassName requestingClass);
+  default CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
+    return getExpression(requestingClass);
+  }
 }
diff --git a/java/dagger/internal/codegen/ComponentRequirementExpressions.java b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
new file mode 100644
index 000000000..0638167f3
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Suppliers.memoize;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+
+import com.google.common.base.Supplier;
+import com.google.common.base.Suppliers;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.Preconditions;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+
+/**
+ * A central repository of expressions used to access any {@link ComponentRequirement} available to
+ * a component.
+ */
+final class ComponentRequirementExpressions {
+
+  // TODO(dpb,ronshapiro): refactor this and ComponentBindingExpressions into a
+  // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
+  // parents? If so, maybe make ComponentRequirementExpression.Factory create it.
+
+  private final Optional<ComponentRequirementExpressions> parent;
+  private final Map<ComponentRequirement, ComponentRequirementExpression>
+      componentRequirementExpressions = new HashMap<>();
+  private final BindingGraph graph;
+  private final ComponentImplementation componentImplementation;
+  private final DaggerTypes types;
+  private final DaggerElements elements;
+
+  private ComponentRequirementExpressions(
+      Optional<ComponentRequirementExpressions> parent,
+      BindingGraph graph,
+      ComponentImplementation componentImplementation,
+      DaggerTypes types,
+      DaggerElements elements) {
+    this.parent = parent;
+    this.graph = graph;
+    this.componentImplementation = componentImplementation;
+    this.types = types;
+    this.elements = elements;
+  }
+
+  // TODO(ronshapiro): give ComponentImplementation a graph() method
+  ComponentRequirementExpressions(
+      BindingGraph graph,
+      ComponentImplementation componentImplementation,
+      DaggerTypes types,
+      DaggerElements elements) {
+    this(Optional.empty(), graph, componentImplementation, types, elements);
+  }
+
+  /**
+   * Returns a new object representing the expressions available from a child component of this one.
+   */
+  ComponentRequirementExpressions forChildComponent(
+      BindingGraph graph, ComponentImplementation componentImplementation) {
+    return new ComponentRequirementExpressions(
+        Optional.of(this), graph, componentImplementation, types, elements);
+  }
+
+  /**
+   * Returns an expression for the {@code componentRequirement} to be used when implementing a
+   * component method. This may add a field or method to the component in order to reference the
+   * component requirement outside of the {@code initialize()} methods.
+   */
+  CodeBlock getExpression(ComponentRequirement componentRequirement, ClassName requestingClass) {
+    return getExpression(componentRequirement).getExpression(requestingClass);
+  }
+
+  /**
+   * Returns an expression for the {@code componentRequirement} to be used only within {@code
+   * initialize()} methods, where the component builder is available.
+   *
+   * <p>When accessing this expression from a subcomponent, this may cause a field to be initialized
+   * or a method to be added in the component that owns this {@link ComponentRequirement}.
+   */
+  CodeBlock getExpressionDuringInitialization(
+      ComponentRequirement componentRequirement, ClassName requestingClass) {
+    return getExpression(componentRequirement).getExpressionDuringInitialization(requestingClass);
+  }
+
+  ComponentRequirementExpression getExpression(ComponentRequirement componentRequirement) {
+    if (graph.componentRequirements().contains(componentRequirement)) {
+      return componentRequirementExpressions.computeIfAbsent(
+          componentRequirement, this::createMethodOrField);
+    }
+    if (parent.isPresent()) {
+      return parent.get().getExpression(componentRequirement);
+    }
+    throw new IllegalStateException(
+        "no component requirement expression found for " + componentRequirement);
+  }
+
+  /**
+   * If {@code requirement} is a module that may be owned by a future ancestor component, returns a
+   * modifiable module method. Otherwise, returns a field for {@code requirement}.
+   */
+  private ComponentRequirementExpression createMethodOrField(ComponentRequirement requirement) {
+    if (componentImplementation.isAbstract() && requirement.kind().isModule()) {
+      return new ModifiableModule(requirement);
+    }
+    return createField(requirement);
+  }
+
+  /** Returns a field for a {@link ComponentRequirement}. */
+  private ComponentRequirementExpression createField(ComponentRequirement requirement) {
+    Optional<ComponentCreatorImplementation> creatorImplementation =
+        Optionals.firstPresent(
+            componentImplementation.baseImplementation().flatMap(c -> c.creatorImplementation()),
+            componentImplementation.creatorImplementation());
+    if (creatorImplementation.isPresent()) {
+      FieldSpec builderField = creatorImplementation.get().builderFields().get(requirement);
+      return new BuilderField(requirement, componentImplementation, builderField);
+    } else if (graph.factoryMethod().isPresent()
+        && graph.factoryMethodParameters().containsKey(requirement)) {
+      ParameterSpec factoryParameter =
+          ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
+      return new ComponentParameterField(requirement, componentImplementation, factoryParameter);
+    } else if (requirement.kind().isModule()) {
+      return new ComponentInstantiableField(requirement, componentImplementation);
+    } else {
+      throw new AssertionError(
+          String.format("Can't create %s in %s", requirement, componentImplementation.name()));
+    }
+  }
+
+  private abstract static class AbstractField implements ComponentRequirementExpression {
+    private final ComponentRequirement componentRequirement;
+    private final ComponentImplementation componentImplementation;
+    private final Supplier<MemberSelect> field = memoize(this::createField);
+
+    private AbstractField(
+        ComponentRequirement componentRequirement,
+        ComponentImplementation componentImplementation) {
+      this.componentRequirement = checkNotNull(componentRequirement);
+      this.componentImplementation = checkNotNull(componentImplementation);
+    }
+
+    @Override
+    public CodeBlock getExpression(ClassName requestingClass) {
+      return field.get().getExpressionFor(requestingClass);
+    }
+
+    private MemberSelect createField() {
+      // TODO(dpb,ronshapiro): think about whether ComponentImplementation.addField
+      // should make a unique name for the field.
+      String fieldName =
+          componentImplementation.getUniqueFieldName(componentRequirement.variableName());
+      FieldSpec field =
+          FieldSpec.builder(TypeName.get(componentRequirement.type()), fieldName, PRIVATE).build();
+      componentImplementation.addField(COMPONENT_REQUIREMENT_FIELD, field);
+      componentImplementation.addComponentRequirementInitialization(fieldInitialization(field));
+      return MemberSelect.localField(componentImplementation.name(), fieldName);
+    }
+
+    /** Returns the {@link CodeBlock} that initializes the component field during construction. */
+    abstract CodeBlock fieldInitialization(FieldSpec componentField);
+  }
+
+  /**
+   * A {@link ComponentRequirementExpression} for {@link ComponentRequirement}s that have a
+   * corresponding field on the component builder.
+   */
+  private static final class BuilderField extends AbstractField {
+    private final FieldSpec builderField;
+
+    private BuilderField(
+        ComponentRequirement componentRequirement,
+        ComponentImplementation componentImplementation,
+        FieldSpec builderField) {
+      super(componentRequirement, componentImplementation);
+      this.builderField = checkNotNull(builderField);
+    }
+
+    @Override
+    public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
+      if (super.componentImplementation.name().equals(requestingClass)) {
+        return CodeBlock.of("builder.$N", builderField);
+      } else {
+        // requesting this component requirement during initialization of a child component requires
+        // the it to be access from a field and not the builder (since it is no longer available)
+        return getExpression(requestingClass);
+      }
+    }
+
+    @Override
+    CodeBlock fieldInitialization(FieldSpec componentField) {
+      return CodeBlock.of("this.$N = builder.$N;", componentField, builderField);
+    }
+  }
+
+  /**
+   * A {@link ComponentRequirementExpression} for {@link ComponentRequirement}s that can be
+   * instantiated by the component (i.e. a static class with a no-arg constructor).
+   */
+  private static final class ComponentInstantiableField extends AbstractField {
+    private ComponentInstantiableField(
+        ComponentRequirement componentRequirement,
+        ComponentImplementation componentImplementation) {
+      super(componentRequirement, componentImplementation);
+    }
+
+    @Override
+    CodeBlock fieldInitialization(FieldSpec componentField) {
+      return CodeBlock.of("this.$N = new $T();", componentField, componentField.type);
+    }
+  }
+
+  /**
+   * A {@link ComponentRequirementExpression} for {@link ComponentRequirement}s that are passed in
+   * as parameters to a component factory method.
+   */
+  private static final class ComponentParameterField extends AbstractField {
+    private final ParameterSpec factoryParameter;
+
+    private ComponentParameterField(
+        ComponentRequirement componentRequirement,
+        ComponentImplementation componentImplementation,
+        ParameterSpec factoryParameter) {
+      super(componentRequirement, componentImplementation);
+      this.factoryParameter = checkNotNull(factoryParameter);
+    }
+
+    @Override
+    CodeBlock fieldInitialization(FieldSpec componentField) {
+      return CodeBlock.of(
+          "this.$N = $T.checkNotNull($N);", componentField, Preconditions.class, factoryParameter);
+    }
+  }
+
+  private final class ModifiableModule implements ComponentRequirementExpression {
+    private final ComponentRequirement module;
+    private final Supplier<MemberSelect> method = Suppliers.memoize(this::methodSelect);
+
+    private ModifiableModule(ComponentRequirement module) {
+      checkArgument(module.kind().isModule());
+      this.module = module;
+    }
+
+    @Override
+    public CodeBlock getExpression(ClassName requestingClass) {
+      return method.get().getExpressionFor(requestingClass);
+    }
+
+    private MemberSelect methodSelect() {
+      String methodName =
+          componentImplementation
+              .supertypeModifiableModuleMethodName(module)
+              .orElseGet(this::createMethod);
+      return MemberSelect.localMethod(componentImplementation.name(), methodName);
+    }
+
+    private String createMethod() {
+      String methodName =
+          UPPER_CAMEL.to(
+              LOWER_CAMEL,
+              componentImplementation.getUniqueMethodName(
+                  module.typeElement().getSimpleName().toString()));
+      MethodSpec.Builder methodBuilder =
+          methodBuilder(methodName)
+              .addModifiers(PROTECTED)
+              .returns(TypeName.get(module.type()));
+      // TODO(b/117833324): if the module is instantiable, we could provide an implementation here
+      // too. Then, if no ancestor ever repeats the module, there's nothing to do in subclasses.
+      if (graph.componentDescriptor().creatorDescriptor().isPresent()) {
+        methodBuilder.addStatement(
+            "return $L",
+            createField(module).getExpression(componentImplementation.name()));
+      } else {
+        methodBuilder.addModifiers(ABSTRACT);
+      }
+      componentImplementation.addModifiableModuleMethod(module, methodBuilder.build());
+      return methodName;
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
deleted file mode 100644
index 62d6aa6fc..000000000
--- a/java/dagger/internal/codegen/ComponentRequirementFields.java
+++ /dev/null
@@ -1,236 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Suppliers.memoize;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
-import static javax.lang.model.element.Modifier.PRIVATE;
-
-import com.google.common.base.Supplier;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.ParameterSpec;
-import com.squareup.javapoet.TypeName;
-import dagger.internal.Preconditions;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Optional;
-
-/**
- * A central repository of fields used to access any {@link ComponentRequirement} available to a
- * component.
- */
-final class ComponentRequirementFields {
-
-  // TODO(dpb,ronshapiro): refactor this and ComponentBindingExpressions into a
-  // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
-  // parents? If so, maybe make ComponentRequirementField.Factory create it.
-
-  private final Optional<ComponentRequirementFields> parent;
-  private final Map<ComponentRequirement, ComponentRequirementField> componentRequirementFields =
-      new HashMap<>();
-  private final BindingGraph graph;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final Optional<ComponentBuilder> componentBuilder;
-
-  private ComponentRequirementFields(
-      Optional<ComponentRequirementFields> parent,
-      BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
-      Optional<ComponentBuilder> componentBuilder) {
-    this.parent = parent;
-    this.graph = graph;
-    this.generatedComponentModel = generatedComponentModel;
-    this.componentBuilder = componentBuilder;
-  }
-
-  ComponentRequirementFields(
-      BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
-      Optional<ComponentBuilder> componentBuilder) {
-    this(Optional.empty(), graph, generatedComponentModel, componentBuilder);
-  }
-
-  /** Returns a new object representing the fields available from a child component of this one. */
-  ComponentRequirementFields forChildComponent(
-      BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
-      Optional<ComponentBuilder> componentBuilder) {
-    return new ComponentRequirementFields(
-        Optional.of(this), graph, generatedComponentModel, componentBuilder);
-  }
-
-  /**
-   * Returns an expression for the {@code componentRequirement} to be used when implementing a
-   * component method. This may add a field to the component in order to reference the component
-   * requirement outside of the {@code initialize()} methods.
-   */
-  CodeBlock getExpression(ComponentRequirement componentRequirement, ClassName requestingClass) {
-    return getField(componentRequirement).getExpression(requestingClass);
-  }
-
-  /**
-   * Returns an expression for the {@code componentRequirement} to be used only within {@code
-   * initialize()} methods, where the component builder is available.
-   *
-   * <p>When accessing this field from a subcomponent, this may cause a field to be initialized in
-   * the component that owns this {@link ComponentRequirement}.
-   */
-  CodeBlock getExpressionDuringInitialization(
-      ComponentRequirement componentRequirement, ClassName requestingClass) {
-    return getField(componentRequirement).getExpressionDuringInitialization(requestingClass);
-  }
-
-  ComponentRequirementField getField(ComponentRequirement componentRequirement) {
-    if (graph.componentRequirements().contains(componentRequirement)) {
-      return componentRequirementFields.computeIfAbsent(componentRequirement, this::create);
-    }
-    if (parent.isPresent()) {
-      return parent.get().getField(componentRequirement);
-    }
-    throw new IllegalStateException(
-        "no component requirement field found for " + componentRequirement);
-  }
-
-  /** Returns a {@link ComponentRequirementField} for a {@link ComponentRequirement}. */
-  private ComponentRequirementField create(ComponentRequirement requirement) {
-    if (componentBuilder.isPresent()) {
-      FieldSpec builderField = componentBuilder.get().builderFields().get(requirement);
-      return new BuilderField(requirement, generatedComponentModel, builderField);
-    } else if (graph.factoryMethod().isPresent()
-        && graph.factoryMethodParameters().containsKey(requirement)) {
-      ParameterSpec factoryParameter =
-          ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
-      return new ComponentParameterField(requirement, generatedComponentModel, factoryParameter);
-    } else if (graph.componentRequirements().contains(requirement)) {
-      return new ComponentInstantiableField(requirement, generatedComponentModel);
-    } else {
-      throw new AssertionError();
-    }
-  }
-
-  private abstract static class AbstractField implements ComponentRequirementField {
-    private final ComponentRequirement componentRequirement;
-    private final GeneratedComponentModel generatedComponentModel;
-    private final Supplier<MemberSelect> field = memoize(this::createField);
-
-    private AbstractField(
-        ComponentRequirement componentRequirement,
-        GeneratedComponentModel generatedComponentModel) {
-      this.componentRequirement = checkNotNull(componentRequirement);
-      this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    }
-
-    @Override
-    public CodeBlock getExpression(ClassName requestingClass) {
-      return field.get().getExpressionFor(requestingClass);
-    }
-
-    @Override
-    public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
-      return getExpression(requestingClass);
-    }
-
-    private MemberSelect createField() {
-      // TODO(dpb,ronshapiro): think about whether GeneratedComponentModel.addField
-      // should make a unique name for the field.
-      String fieldName =
-          generatedComponentModel.getUniqueFieldName(componentRequirement.variableName());
-      FieldSpec field =
-          FieldSpec.builder(TypeName.get(componentRequirement.type()), fieldName, PRIVATE).build();
-      generatedComponentModel.addField(COMPONENT_REQUIREMENT_FIELD, field);
-      generatedComponentModel.addInitialization(fieldInitialization(field));
-      return MemberSelect.localField(generatedComponentModel.name(), fieldName);
-    }
-
-    /** Returns the {@link CodeBlock} that initializes the component field during construction. */
-    abstract CodeBlock fieldInitialization(FieldSpec componentField);
-  }
-
-  /**
-   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a corresponding
-   * field on the component builder.
-   */
-  private static final class BuilderField extends AbstractField {
-    private final FieldSpec builderField;
-
-    private BuilderField(
-        ComponentRequirement componentRequirement,
-        GeneratedComponentModel generatedComponentModel,
-        FieldSpec builderField) {
-      super(componentRequirement, generatedComponentModel);
-      this.builderField = checkNotNull(builderField);
-    }
-
-    @Override
-    public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
-      if (super.generatedComponentModel.name().equals(requestingClass)) {
-        return CodeBlock.of("builder.$N", builderField);
-      } else {
-        // requesting this component requirement during initialization of a child component requires
-        // the it to be access from a field and not the builder (since it is no longer available)
-        return getExpression(requestingClass);
-      }
-    }
-
-    @Override
-    CodeBlock fieldInitialization(FieldSpec componentField) {
-      return CodeBlock.of("this.$N = builder.$N;", componentField, builderField);
-    }
-  }
-
-  /**
-   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that can be instantiated
-   * by the component (i.e. a static class with a no-arg constructor).
-   */
-  private static final class ComponentInstantiableField extends AbstractField {
-    private ComponentInstantiableField(
-        ComponentRequirement componentRequirement,
-        GeneratedComponentModel generatedComponentModel) {
-      super(componentRequirement, generatedComponentModel);
-    }
-
-    @Override
-    CodeBlock fieldInitialization(FieldSpec componentField) {
-      return CodeBlock.of("this.$N = new $T();", componentField, componentField.type);
-    }
-  }
-
-  /**
-   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that are passed in
-   * as parameters to a component factory method.
-   */
-  private static final class ComponentParameterField extends AbstractField {
-    private final ParameterSpec factoryParameter;
-
-    private ComponentParameterField(
-        ComponentRequirement componentRequirement,
-        GeneratedComponentModel generatedComponentModel,
-        ParameterSpec factoryParameter) {
-      super(componentRequirement, generatedComponentModel);
-      this.factoryParameter = checkNotNull(factoryParameter);
-    }
-
-    @Override
-    CodeBlock fieldInitialization(FieldSpec componentField) {
-      return CodeBlock.of(
-          "this.$N = $T.checkNotNull($N);", componentField, Preconditions.class, factoryParameter);
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 0c12a68c4..72135f401 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -25,6 +25,7 @@
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Iterables.skip;
 import static com.google.common.collect.Multimaps.asMap;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static java.util.Spliterator.ORDERED;
 import static java.util.Spliterator.SIZED;
@@ -37,11 +38,10 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.LinkedHashMultiset;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind;
 import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
+import dagger.model.RequestKind;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.HashSet;
@@ -65,8 +65,8 @@
  * component in the tree, and {@link #visitSubcomponentFactoryMethod(BindingGraph, BindingGraph,
  * ExecutableElement)} to perform custom logic at each subcomponent factory method.
  *
- * <p>Subclasses can override {@link #bindingGraphTraverser(ComponentTreePath,
- * ComponentMethodDescriptor)} to traverse each entry point within each component in the tree.
+ * <p>Subclasses can override {@link #bindingGraphTraverser(ComponentTreePath, DependencyRequest)}
+ * to traverse each entry point within each component in the tree.
  */
 public class ComponentTreeTraverser {
 
@@ -79,7 +79,7 @@ public ComponentTreeTraverser(BindingGraph rootGraph, CompilerOptions compilerOp
         rootGraph.componentDescriptor().kind().isTopLevel()
             || compilerOptions.aheadOfTimeSubcomponents(),
         "only top-level graphs can be traversed, not %s",
-        rootGraph.componentDescriptor().componentDefinitionType().getQualifiedName());
+        rootGraph.componentTypeElement().getQualifiedName());
     bindingGraphPath.add(rootGraph);
   }
 
@@ -105,8 +105,8 @@ public final void traverseComponents() {
    * <ol>
    *   <li>If this component is installed in its parent by a subcomponent factory method, calls
    *       {@link #visitSubcomponentFactoryMethod(BindingGraph, BindingGraph, ExecutableElement)}.
-   *   <li>For each entry point in the component, calls {@link
-   *       #visitEntryPoint(ComponentMethodDescriptor, BindingGraph)}.
+   *   <li>For each entry point in the component, calls {@link #visitEntryPoint(DependencyRequest,
+   *       BindingGraph)}.
    *   <li>For each child component, calls {@link #visitComponent(BindingGraph)}, updating the
    *       traversal state.
    * </ol>
@@ -116,20 +116,17 @@ public final void traverseComponents() {
   protected void visitComponent(BindingGraph graph) {
     if (bindingGraphPath.size() > 1) {
       BindingGraph parent = Iterators.get(bindingGraphPath.descendingIterator(), 1);
-      ComponentMethodDescriptor childFactoryMethod =
-          parent
-              .componentDescriptor()
-              .subcomponentsByFactoryMethod()
-              .inverse()
-              .get(graph.componentDescriptor());
-      if (childFactoryMethod != null) {
-        visitSubcomponentFactoryMethod(graph, parent, childFactoryMethod.methodElement());
-      }
+      parent
+          .componentDescriptor()
+          .getFactoryMethodForChildComponent(graph.componentDescriptor())
+          .ifPresent(
+              childFactoryMethod ->
+                  visitSubcomponentFactoryMethod(
+                      graph, parent, childFactoryMethod.methodElement()));
     }
 
-    for (ComponentMethodDescriptor entryPointMethod :
-        graph.componentDescriptor().entryPointMethods()) {
-      visitEntryPoint(entryPointMethod, graph);
+    for (DependencyRequest entryPoint : graph.componentDescriptor().entryPoints()) {
+      visitEntryPoint(entryPoint, graph);
     }
 
     for (BindingGraph child : graph.subgraphs()) {
@@ -163,13 +160,13 @@ protected void visitSubcomponentFactoryMethod(
    * standard order.
    *
    * <p>This implementation passes the entry point and the current component tree path to {@link
-   * #bindingGraphTraverser(ComponentTreePath, ComponentMethodDescriptor)}, and calls {@link
+   * #bindingGraphTraverser(ComponentTreePath, DependencyRequest)}, and calls {@link
    * BindingGraphTraverser#traverseDependencies()} on the returned object.
    *
    * @param graph the graph for the component that contains the entry point
    */
-  protected void visitEntryPoint(ComponentMethodDescriptor entryPointMethod, BindingGraph graph) {
-    bindingGraphTraverser(componentTreePath(), entryPointMethod).traverseDependencies();
+  protected void visitEntryPoint(DependencyRequest entryPoint, BindingGraph graph) {
+    bindingGraphTraverser(componentTreePath(), entryPoint).traverseDependencies();
   }
 
   /**
@@ -180,11 +177,10 @@ protected void visitEntryPoint(ComponentMethodDescriptor entryPointMethod, Bindi
    *
    * @param componentPath the path from the root component to the component that includes the entry
    *     point
-   * @param entryPointMethod the entry point method
    */
   protected BindingGraphTraverser bindingGraphTraverser(
-      ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
-    return new NoOpBindingGraphTraverser(componentPath, entryPointMethod);
+      ComponentTreePath componentPath, DependencyRequest entryPoint) {
+    return new NoOpBindingGraphTraverser(componentPath, entryPoint);
   }
 
   /**
@@ -204,7 +200,7 @@ protected final ComponentTreePath componentTreePath() {
   public static class BindingGraphTraverser {
 
     private final ComponentTreePath componentTreePath;
-    private final ComponentMethodDescriptor entryPointMethod;
+    private final DependencyRequest entryPoint;
     private final Deque<DependencyRequest> dependencyRequestPath = new ArrayDeque<>();
     private final Deque<ResolvedBindings> resolvedBindingsPath = new ArrayDeque<>();
     private final LinkedHashMultiset<Key> keysInPath = LinkedHashMultiset.create();
@@ -215,12 +211,11 @@ protected final ComponentTreePath componentTreePath() {
      *
      * @param componentPath the path from the root component to the component that includes the
      *     entry point to be traversed
-     * @param entryPointMethod the entry point method to be traversed
+     * @param entryPoint the entry point to be traversed
      */
-    public BindingGraphTraverser(
-        ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
+    public BindingGraphTraverser(ComponentTreePath componentPath, DependencyRequest entryPoint) {
       this.componentTreePath = componentPath;
-      this.entryPointMethod = entryPointMethod;
+      this.entryPoint = entryPoint;
     }
 
     /**
@@ -234,7 +229,7 @@ public void traverseDependencies() {
       checkState(resolvedBindingsPath.isEmpty());
       checkState(keysInPath.isEmpty());
       checkState(visitedDependencyRequests.isEmpty());
-      nextDependencyRequest(entryPointMethod.dependencyRequest().get(), currentGraph());
+      nextDependencyRequest(entryPoint, currentGraph());
     }
 
     /**
@@ -393,7 +388,7 @@ protected void visitBinding(Binding binding, ComponentDescriptor owningComponent
     private void nextDependencyRequest(
         DependencyRequest dependencyRequest, BindingGraph bindingGraph) {
       ResolvedBindings resolvedBindings =
-          bindingGraph.resolvedBindings(BindingRequest.forDependencyRequest(dependencyRequest));
+          bindingGraph.resolvedBindings(bindingRequest(dependencyRequest));
       dependencyRequestPath.addLast(dependencyRequest);
       resolvedBindingsPath.addLast(resolvedBindings);
       // Don't add the key of a members injection request, as it doesn't participate in cycles
@@ -412,12 +407,12 @@ private void nextDependencyRequest(
     }
 
     /**
-     * Returns {@code true} if {@code dependencyRequest} is the {@link #entryPointMethod}'s request
-     * and the entry point is a members injection method.
+     * Returns {@code true} if {@code dependencyRequest} is the {@link #entryPoint} and it's a
+     * members injection method.
      */
     private boolean isComponentMembersInjectionRequest(DependencyRequest dependencyRequest) {
-      return entryPointMethod.kind().equals(ComponentMethodKind.MEMBERS_INJECTION)
-          && entryPointMethod.dependencyRequest().get().equals(dependencyRequest);
+      return dependencyRequest.kind().equals(RequestKind.MEMBERS_INJECTION)
+          && dependencyRequest.equals(entryPoint);
     }
 
     /**
@@ -498,7 +493,7 @@ protected final ResolvedBindings resolvedBindings() {
      * @throws IllegalStateException if this object is not currently traversing dependencies
      */
     protected final Element entryPointElement() {
-      return entryPointMethod.dependencyRequest().get().requestElement().get();
+      return entryPoint.requestElement().get();
     }
 
     /**
@@ -542,8 +537,8 @@ protected final DependencyTrace cycleDependencyTrace() {
   /** A traverser that does nothing. */
   private static final class NoOpBindingGraphTraverser extends BindingGraphTraverser {
     private NoOpBindingGraphTraverser(
-        ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
-      super(componentPath, entryPointMethod);
+        ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      super(componentPath, entryPoint);
     }
 
     @Override
@@ -574,7 +569,7 @@ public BindingGraph currentGraph() {
 
     /** Returns the type of the component at the end of the path. */
     public TypeElement currentComponent() {
-      return currentGraph().componentDescriptor().componentDefinitionType();
+      return currentGraph().componentTypeElement();
     }
 
     /**
@@ -621,7 +616,7 @@ ComponentTreePath pathFromRootToAncestor(TypeElement ancestor) {
       ImmutableList.Builder<BindingGraph> path = ImmutableList.builder();
       for (BindingGraph graph : graphsInPath()) {
         path.add(graph);
-        if (graph.componentDescriptor().componentDefinitionType().equals(ancestor)) {
+        if (graph.componentTypeElement().equals(ancestor)) {
           return create(path.build());
         }
       }
@@ -638,7 +633,7 @@ ComponentTreePath pathFromRootToAncestor(TypeElement ancestor) {
      */
     ComponentTreePath childPath(TypeElement subcomponent) {
       for (BindingGraph child : currentGraph().subgraphs()) {
-        if (child.componentType().equals(subcomponent)) {
+        if (child.componentTypeElement().equals(subcomponent)) {
           return create(
               ImmutableList.<BindingGraph>builder().addAll(graphsInPath()).add(child).build());
         }
@@ -646,7 +641,8 @@ ComponentTreePath childPath(TypeElement subcomponent) {
       throw new IllegalArgumentException(
           String.format(
               "%s is not a child of %s",
-              subcomponent.getQualifiedName(), currentGraph().componentType().getQualifiedName()));
+              subcomponent.getQualifiedName(),
+              currentGraph().componentTypeElement().getQualifiedName()));
     }
 
     private BindingGraph rootmostGraph(Predicate<? super BindingGraph> predicate) {
@@ -656,14 +652,13 @@ private BindingGraph rootmostGraph(Predicate<? super BindingGraph> predicate) {
     /** Converts this {@link ComponentTreePath} into a {@link ComponentPath}. */
     ComponentPath toComponentPath() {
       return ComponentPath.create(
-          graphsInPath().stream().map(BindingGraph::componentType).collect(toList()));
+          graphsInPath().stream().map(BindingGraph::componentTypeElement).collect(toList()));
     }
 
     @Override
     public final String toString() {
-      return graphsInPath()
-          .stream()
-          .map(BindingGraph::componentType)
+      return graphsInPath().stream()
+          .map(BindingGraph::componentTypeElement)
           .map(TypeElement::getQualifiedName)
           .collect(joining(" → "));
     }
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 51adcbe53..88799dfea 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -18,17 +18,19 @@
 
 import static com.google.auto.common.MoreElements.asType;
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Multimaps.asMap;
-import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
+import static dagger.internal.codegen.DaggerStreams.presentValues;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static java.util.Comparator.comparing;
 import static javax.lang.model.element.ElementKind.CLASS;
@@ -37,10 +39,8 @@
 import static javax.lang.model.type.TypeKind.VOID;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -51,9 +51,10 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Reusable;
-import dagger.internal.codegen.ComponentDescriptor.Kind;
+import dagger.internal.codegen.ErrorMessages.SubcomponentCreatorMessages;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
+import dagger.producers.CancellationPolicy;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -81,7 +82,7 @@
   private final DaggerElements elements;
   private final Types types;
   private final ModuleValidator moduleValidator;
-  private final BuilderValidator builderValidator;
+  private final ComponentCreatorValidator creatorValidator;
   private final DependencyRequestValidator dependencyRequestValidator;
   private final MembersInjectionValidator membersInjectionValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
@@ -92,7 +93,7 @@
       DaggerElements elements,
       Types types,
       ModuleValidator moduleValidator,
-      BuilderValidator builderValidator,
+      ComponentCreatorValidator creatorValidator,
       DependencyRequestValidator dependencyRequestValidator,
       MembersInjectionValidator membersInjectionValidator,
       MethodSignatureFormatter methodSignatureFormatter,
@@ -100,7 +101,7 @@
     this.elements = elements;
     this.types = types;
     this.moduleValidator = moduleValidator;
-    this.builderValidator = builderValidator;
+    this.creatorValidator = creatorValidator;
     this.dependencyRequestValidator = dependencyRequestValidator;
     this.membersInjectionValidator = membersInjectionValidator;
     this.methodSignatureFormatter = methodSignatureFormatter;
@@ -121,26 +122,34 @@
   public ComponentValidationReport validate(
       final TypeElement subject,
       Set<? extends Element> validatedSubcomponents,
-      Set<? extends Element> validatedSubcomponentBuilders) {
+      Set<? extends Element> validatedSubcomponentCreators) {
     ValidationReport.Builder<TypeElement> report = ValidationReport.about(subject);
 
-    ComponentDescriptor.Kind componentKind =
-        ComponentDescriptor.Kind.forAnnotatedElement(subject).get();
+    ComponentKind componentKind = ComponentKind.forAnnotatedElement(subject).get();
+
+    if (isAnnotationPresent(subject, CancellationPolicy.class) && !componentKind.isProducer()) {
+      report.addError(
+          "@CancellationPolicy may only be applied to production components and subcomponents",
+          subject);
+    }
 
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
       report.addError(
           String.format(
               "@%s may only be applied to an interface or abstract class",
-              componentKind.annotationType().getSimpleName()),
+              componentKind.annotation().getSimpleName()),
           subject);
     }
 
     ImmutableList<DeclaredType> builders =
-        enclosedBuilders(subject, componentKind.builderAnnotationType());
+        componentKind
+            .builderAnnotation()
+            .map(builderAnnotation -> enclosedAnnotatedTypes(subject, builderAnnotation))
+            .orElse(ImmutableList.of());
     if (builders.size() > 1) {
       report.addError(
-          String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
+          String.format(ErrorMessages.creatorMessagesFor(componentKind).moreThanOne(), builders),
           subject);
     }
 
@@ -173,22 +182,21 @@ public ComponentValidationReport validate(
               Optional<AnnotationMirror> subcomponentAnnotation =
                   checkForAnnotations(
                       returnType,
-                      FluentIterable.from(componentKind.subcomponentKinds())
-                          .transform(Kind::annotationType)
-                          .toSet());
+                      componentKind.legalSubcomponentKinds().stream()
+                          .map(ComponentKind::annotation)
+                          .collect(toImmutableSet()));
               Optional<AnnotationMirror> subcomponentBuilderAnnotation =
                   checkForAnnotations(
                       returnType,
-                      FluentIterable.from(componentKind.subcomponentKinds())
-                          .transform(Kind::builderAnnotationType)
-                          .toSet());
+                      componentKind.legalSubcomponentKinds().stream()
+                          .map(ComponentKind::builderAnnotation)
+                          .flatMap(presentValues())
+                          .collect(toImmutableSet()));
               if (subcomponentAnnotation.isPresent()) {
                 referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
                 validateSubcomponentMethod(
                     report,
-                    ComponentDescriptor.Kind.forAnnotatedElement(
-                            MoreTypes.asTypeElement(returnType))
-                        .get(),
+                    ComponentKind.forAnnotatedElement(MoreTypes.asTypeElement(returnType)).get(),
                     method,
                     parameters,
                     parameterTypes,
@@ -197,8 +205,8 @@ public ComponentValidationReport validate(
               } else if (subcomponentBuilderAnnotation.isPresent()) {
                 referencedSubcomponents.put(
                     MoreTypes.asElement(returnType).getEnclosingElement(), method);
-                validateSubcomponentBuilderMethod(
-                    report, method, parameters, returnType, validatedSubcomponentBuilders);
+                validateSubcomponentCreatorMethod(
+                    report, method, parameters, returnType, validatedSubcomponentCreators);
               } else {
                 // if it's not a subcomponent...
                 switch (parameters.size()) {
@@ -238,20 +246,19 @@ public ComponentValidationReport validate(
             (subcomponent, methods) ->
                 report.addError(
                     String.format(
-                        ErrorMessages.SubcomponentBuilderMessages.INSTANCE
-                            .moreThanOneRefToSubcomponent(),
+                        SubcomponentCreatorMessages.INSTANCE.moreThanOneRefToSubcomponent(),
                         subcomponent,
                         methods),
                     subject));
 
     AnnotationMirror componentMirror =
-        getAnnotationMirror(subject, componentKind.annotationType()).get();
+        getAnnotationMirror(subject, componentKind.annotation()).get();
     if (componentKind.isTopLevel()) {
       validateComponentDependencies(report, getComponentDependencies(componentMirror));
     }
     report.addSubreport(
         moduleValidator.validateReferencedModules(
-            subject, componentMirror, componentKind.moduleKinds(), new HashSet<>()));
+            subject, componentMirror, componentKind.legalModuleKinds(), new HashSet<>()));
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
@@ -263,7 +270,7 @@ public ComponentValidationReport validate(
     for (Element subcomponent :
         Sets.difference(referencedSubcomponents.keySet(), validatedSubcomponents)) {
       ComponentValidationReport subreport =
-          validate(asType(subcomponent), validatedSubcomponents, validatedSubcomponentBuilders);
+          validate(asType(subcomponent), validatedSubcomponents, validatedSubcomponentCreators);
       report.addItems(subreport.report().items());
       allSubcomponents.addAll(subreport.referencedSubcomponents());
     }
@@ -313,7 +320,7 @@ private boolean isEntryPoint(ExecutableElement method, ExecutableType methodType
   private DependencyRequest dependencyRequest(ExecutableElement method, TypeElement component) {
     ExecutableType methodType =
         asExecutable(types.asMemberOf(asDeclared(component.asType()), method));
-    return ComponentDescriptor.Kind.forAnnotatedElement(component).get().isProducer()
+    return ComponentKind.forAnnotatedElement(component).get().isProducer()
         ? dependencyRequestFactory.forComponentProductionMethod(method, methodType)
         : dependencyRequestFactory.forComponentProvisionMethod(method, methodType);
   }
@@ -356,7 +363,7 @@ private void reportConflictingEntryPoints(
 
   private void validateSubcomponentMethod(
       final ValidationReport.Builder<TypeElement> report,
-      final ComponentDescriptor.Kind subcomponentKind,
+      final ComponentKind subcomponentKind,
       ExecutableElement method,
       List<? extends VariableElement> parameters,
       List<? extends TypeMirror> parameterTypes,
@@ -387,9 +394,8 @@ private void validateSubcomponentMethod(
 
                 @Override
                 public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
-                  for (ModuleDescriptor.Kind moduleKind : subcomponentKind.moduleKinds()) {
-                    if (MoreElements.isAnnotationPresent(
-                        t.asElement(), moduleKind.moduleAnnotation())) {
+                  for (ModuleKind moduleKind : subcomponentKind.legalModuleKinds()) {
+                    if (isAnnotationPresent(t.asElement(), moduleKind.annotation())) {
                       return Optional.of(MoreTypes.asTypeElement(t));
                     }
                   }
@@ -426,25 +432,24 @@ private void validateSubcomponentMethod(
     }
   }
 
-  private void validateSubcomponentBuilderMethod(
+  private void validateSubcomponentCreatorMethod(
       ValidationReport.Builder<TypeElement> report,
       ExecutableElement method,
       List<? extends VariableElement> parameters,
       TypeMirror returnType,
-      Set<? extends Element> validatedSubcomponentBuilders) {
+      Set<? extends Element> validatedSubcomponentCreators) {
 
     if (!parameters.isEmpty()) {
-      report.addError(
-          ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
+      report.addError(SubcomponentCreatorMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
     }
 
-    // If we haven't already validated the subcomponent builder itself, validate it now.
-    TypeElement builderElement = MoreTypes.asTypeElement(returnType);
-    if (!validatedSubcomponentBuilders.contains(builderElement)) {
-      // TODO(sameb): The builder validator right now assumes the element is being compiled
+    // If we haven't already validated the subcomponent creator itself, validate it now.
+    TypeElement creatorElement = MoreTypes.asTypeElement(returnType);
+    if (!validatedSubcomponentCreators.contains(creatorElement)) {
+      // TODO(sameb): The creator validator right now assumes the element is being compiled
       // in this pass, which isn't true here.  We should change error messages to spit out
       // this method as the subject and add the original subject to the message output.
-      report.addItems(builderValidator.validate(builderElement).items());
+      report.addItems(creatorValidator.validate(creatorElement).items());
     }
   }
 
diff --git a/java/dagger/internal/codegen/ConfigurationAnnotations.java b/java/dagger/internal/codegen/ConfigurationAnnotations.java
index d939bc595..275f52e9f 100644
--- a/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -19,6 +19,9 @@
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ComponentKind.annotationsFor;
+import static dagger.internal.codegen.ComponentKind.builderAnnotationsFor;
+import static dagger.internal.codegen.ComponentKind.subcomponentKinds;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeListValue;
@@ -75,22 +78,21 @@
   }
 
   static boolean isSubcomponent(Element element) {
-    return isAnyAnnotationPresent(element, Subcomponent.class, ProductionSubcomponent.class);
+    return isAnyAnnotationPresent(element, annotationsFor(subcomponentKinds()));
   }
 
-  static Optional<TypeElement> getSubcomponentBuilder(TypeElement subcomponent) {
+  static Optional<TypeElement> getSubcomponentCreator(TypeElement subcomponent) {
     checkArgument(isSubcomponent(subcomponent));
     for (TypeElement nestedType : typesIn(subcomponent.getEnclosedElements())) {
-      if (isSubcomponentBuilder(nestedType)) {
+      if (isSubcomponentCreator(nestedType)) {
         return Optional.of(nestedType);
       }
     }
     return Optional.empty();
   }
 
-  static boolean isSubcomponentBuilder(Element element) {
-    return isAnyAnnotationPresent(
-        element, Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
+  static boolean isSubcomponentCreator(Element element) {
+    return isAnyAnnotationPresent(element, builderAnnotationsFor(subcomponentKinds()));
   }
 
   /**
@@ -102,10 +104,12 @@ static boolean isSubcomponentBuilder(Element element) {
    */
   static ImmutableList<AnnotationValue> getModules(
       TypeElement annotatedType, AnnotationMirror annotation) {
-    if (ComponentDescriptor.Kind.forAnnotatedElement(annotatedType).isPresent()) {
+    if (ComponentKind.forAnnotatedElement(annotatedType)
+        .filter(kind -> !kind.isForModuleValidation())
+        .isPresent()) {
       return asAnnotationValues(getAnnotationValue(annotation, MODULES_ATTRIBUTE));
     }
-    if (ModuleDescriptor.Kind.forAnnotatedElement(annotatedType).isPresent()) {
+    if (ModuleKind.forAnnotatedElement(annotatedType).isPresent()) {
       return asAnnotationValues(getAnnotationValue(annotation, INCLUDES_ATTRIBUTE));
     }
     throw new IllegalArgumentException(String.format("unsupported annotation: %s", annotation));
@@ -166,7 +170,7 @@ static boolean isSubcomponentBuilder(Element element) {
    * given seed modules. If a module is malformed and a type listed in {@link Module#includes} is
    * not annotated with {@link Module}, it is ignored.
    *
-   * @deprecated Use {@link ComponentDescriptor#transitiveModules}.
+   * @deprecated Use {@link ComponentDescriptor#modules()}.
    */
   @Deprecated
   static ImmutableSet<TypeElement> getTransitiveModules(
@@ -199,9 +203,9 @@ static boolean isSubcomponentBuilder(Element element) {
     return ImmutableSet.copyOf(moduleElements);
   }
 
-  /** Returns the enclosed elements annotated with the given annotation type. */
-  static ImmutableList<DeclaredType> enclosedBuilders(TypeElement typeElement,
-      final Class<? extends Annotation> annotation) {
+  /** Returns the enclosed types annotated with the given annotation. */
+  static ImmutableList<DeclaredType> enclosedAnnotatedTypes(
+      TypeElement typeElement, Class<? extends Annotation> annotation) {
     final ImmutableList.Builder<DeclaredType> builders = ImmutableList.builder();
     for (TypeElement element : typesIn(typeElement.getEnclosedElements())) {
       if (MoreElements.isAnnotationPresent(element, annotation)) {
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 9d206eff5..7de7372f1 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -23,8 +23,6 @@
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static java.util.Arrays.asList;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Equivalence;
@@ -35,12 +33,10 @@
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import java.util.Optional;
-import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -71,18 +67,6 @@ final Object mapKey() {
     return unwrapValue(mapKeyAnnotation).map(AnnotationValue::getValue).orElse(mapKeyAnnotation);
   }
 
-  /**
-   * {@code true} if {@link #contributingModule()} is present and this is a nonabstract instance
-   * method.
-   */
-  boolean requiresModuleInstance() {
-    if (!bindingElement().isPresent() || !contributingModule().isPresent()) {
-      return false;
-    }
-    Set<Modifier> modifiers = bindingElement().get().getModifiers();
-    return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
-  }
-
   /** If {@link #bindingElement()} is a method that returns a primitive type, returns that type. */
   Optional<TypeMirror> contributedPrimitiveType() {
     return bindingElement()
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index e9e505213..9313a7247 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -122,9 +122,7 @@ static String elementToString(Element element) {
         public String visitExecutable(ExecutableElement executableElement, Void aVoid) {
           return enclosingTypeAndMemberName(executableElement)
               .append(
-                  executableElement
-                      .getParameters()
-                      .stream()
+                  executableElement.getParameters().stream()
                       .map(parameter -> parameter.asType().toString())
                       .collect(joining(", ", "(", ")")))
               .toString();
@@ -161,10 +159,11 @@ protected String defaultAction(Element element, Void aVoid) {
         }
 
         private StringBuilder enclosingTypeAndMemberName(Element element) {
-          return new StringBuilder()
-              .append(element.getEnclosingElement().accept(this, null))
-              .append('.')
-              .append(element.getSimpleName());
+          StringBuilder name = new StringBuilder(element.getEnclosingElement().accept(this, null));
+          if (!element.getSimpleName().contentEquals("<init>")) {
+            name.append('.').append(element.getSimpleName());
+          }
+          return name;
         }
       };
 
diff --git a/java/dagger/internal/codegen/DaggerGraphs.java b/java/dagger/internal/codegen/DaggerGraphs.java
index e9f384247..dda6c118c 100644
--- a/java/dagger/internal/codegen/DaggerGraphs.java
+++ b/java/dagger/internal/codegen/DaggerGraphs.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.graph.Graph;
 import com.google.common.graph.SuccessorsFunction;
-import dagger.model.BindingGraph.Node;
 import java.util.ArrayDeque;
 import java.util.HashMap;
 import java.util.Map;
@@ -31,7 +30,7 @@
 import java.util.Set;
 
 /** Utility methods for {@link com.google.common.graph} types. */
-final class DaggerGraphs {
+public final class DaggerGraphs {
   /**
    * Returns a shortest path from {@code nodeU} to {@code nodeV} in {@code graph} as a list of the
    * nodes visited in sequence, including both {@code nodeU} and {@code nodeV}. (Note that there may
@@ -44,7 +43,7 @@
    * @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not present in {@code
    *     graph}
    */
-  static <N> ImmutableList<N> shortestPath(SuccessorsFunction<N> graph, N nodeU, N nodeV) {
+  public static <N> ImmutableList<N> shortestPath(SuccessorsFunction<N> graph, N nodeU, N nodeV) {
     if (nodeU.equals(nodeV)) {
       return ImmutableList.of(nodeU);
     }
@@ -91,7 +90,7 @@
   }
 
   /** Returns the nodes in a graph that are not reachable from a node. */
-  static ImmutableSet<Node> unreachableNodes(Graph<Node> graph, Node node) {
+  public static <N> ImmutableSet<N> unreachableNodes(Graph<N> graph, N node) {
     return ImmutableSet.copyOf(difference(graph.nodes(), reachableNodes(graph, node)));
   }
 
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index ab5341ae6..2e9b3f61e 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -19,6 +19,9 @@
 // the regular kythe/java tree.
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
+
 import com.google.auto.service.AutoService;
 import com.google.common.collect.Iterables;
 import com.google.devtools.kythe.analyzers.base.EntrySet;
@@ -27,8 +30,6 @@
 import com.google.devtools.kythe.analyzers.java.Plugin;
 import com.google.devtools.kythe.proto.Storage.VName;
 import com.sun.tools.javac.code.Symbol;
-import com.sun.tools.javac.model.JavacElements;
-import com.sun.tools.javac.model.JavacTypes;
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 import com.sun.tools.javac.util.Context;
@@ -36,15 +37,12 @@
 import dagger.Component;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
-import java.util.ArrayList;
-import java.util.List;
+import dagger.producers.ProductionComponent;
 import java.util.Optional;
 import java.util.logging.Logger;
 import javax.inject.Inject;
 import javax.inject.Singleton;
 import javax.lang.model.element.Element;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * A plugin which emits nodes and edges for <a href="https://github.com/google/dagger">Dagger</a>
@@ -52,20 +50,31 @@
  */
 @AutoService(Plugin.class)
 public class DaggerKythePlugin extends Plugin.Scanner<Void, Void> {
+  // TODO(ronshapiro): use flogger
   private static final Logger logger = Logger.getLogger(DaggerKythePlugin.class.getCanonicalName());
   private FactEmitter emitter;
-  @Inject KytheBindingGraphFactory bindingGraphFactory;
+  @Inject ComponentDescriptor.Factory componentDescriptorFactory;
+  @Inject BindingGraphFactory bindingGraphFactory;
 
   @Override
   public Void visitClassDef(JCClassDecl tree, Void p) {
-    Optional.ofNullable(tree.sym)
-        .flatMap(bindingGraphFactory::create)
-        .ifPresent(this::addNodesForGraph);
-
+    if (tree.sym != null
+        && isAnyAnnotationPresent(tree.sym, Component.class, ProductionComponent.class)) {
+      addNodesForGraph(
+          bindingGraphFactory.create(componentDescriptorFactory.forTypeElement(tree.sym)));
+    }
     return super.visitClassDef(tree, p);
   }
 
   private void addNodesForGraph(BindingGraph graph) {
+    addDependencyEdges(graph);
+    addModuleEdges(graph);
+    addChildComponentEdges(graph);
+
+    graph.subgraphs().forEach(this::addNodesForGraph);
+  }
+
+  private void addDependencyEdges(BindingGraph graph) {
     for (ResolvedBindings resolvedBinding : graph.resolvedBindings()) {
       for (Binding binding : resolvedBinding.bindings()) {
         for (DependencyRequest dependency : binding.explicitDependencies()) {
@@ -80,8 +89,6 @@ private void addNodesForGraph(BindingGraph graph) {
           .dependencyRequest()
           .ifPresent(request -> addEdgesForDependencyRequest(request, request.key(), graph));
     }
-
-    graph.subgraphs().forEach(this::addNodesForGraph);
   }
 
   /**
@@ -98,7 +105,7 @@ private void addEdgesForDependencyRequest(
     if (!dependency.requestElement().isPresent()) {
       return;
     }
-    BindingRequest request = BindingRequest.forDependencyRequest(targetKey, dependency.kind());
+    BindingRequest request = bindingRequest(targetKey, dependency.kind());
     ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
     for (Binding binding : resolvedBindings.bindings()) {
       if (binding.bindingElement().isPresent()) {
@@ -121,42 +128,49 @@ private void addDependencyEdge(
       DependencyRequest dependency, BindingDeclaration bindingDeclaration) {
     Element requestElement = dependency.requestElement().get();
     Element bindingElement = bindingDeclaration.bindingElement().get();
-    Optional<VName> requestElementNode = jvmNode(requestElement);
-    Optional<VName> bindingElementNode = jvmNode(bindingElement);
-    if (requestElementNode.isPresent() && bindingElementNode.isPresent()) {
-      new EntrySet.Builder(
-              requestElementNode.get(), "/inject/satisfiedby", bindingElementNode.get())
-          .build()
-          .emit(emitter);
-      // TODO(ronshapiro): emit facts about the component that satisfies the edge
-    } else {
-      List<String> missingNodes = new ArrayList<>();
-      if (!requestElementNode.isPresent()) {
-        missingNodes.add("requestElement: " + requestElement);
-      }
-      if (!bindingElementNode.isPresent()) {
-        missingNodes.add("bindingElement: " + bindingElement);
-      }
+    Optional<VName> requestElementNode = jvmNode(requestElement, "request element");
+    Optional<VName> bindingElementNode = jvmNode(bindingElement, "binding element");
+    emitEdge(requestElementNode, "/inject/satisfiedby", bindingElementNode);
+    // TODO(ronshapiro): emit facts about the component that satisfies the edge
+  }
+
+  private void addModuleEdges(BindingGraph graph) {
+    Optional<VName> componentNode = jvmNode(graph.componentTypeElement(), "component");
+    for (ModuleDescriptor module : graph.componentDescriptor().modules()) {
+      Optional<VName> moduleNode = jvmNode(module.moduleElement(), "module");
+      emitEdge(componentNode, "/inject/installsmodule", moduleNode);
+    }
+  }
 
-      // TODO(ronshapiro): use Flogger
-      logger.warning(String.format("Missing JVM nodes: %s ", missingNodes));
+  private void addChildComponentEdges(BindingGraph graph) {
+    Optional<VName> componentNode = jvmNode(graph.componentTypeElement(), "component");
+    for (BindingGraph subgraph : graph.subgraphs()) {
+      Optional<VName> subcomponentNode =
+          jvmNode(subgraph.componentTypeElement(), "child component");
+      emitEdge(componentNode, "/inject/childcomponent", subcomponentNode);
     }
   }
 
-  private Optional<VName> jvmNode(Element element) {
-    return kytheGraph.getJvmNode((Symbol) element).map(KytheNode::getVName);
+  private Optional<VName> jvmNode(Element element, String name) {
+    Optional<VName> jvmNode = kytheGraph.getJvmNode((Symbol) element).map(KytheNode::getVName);
+    if (!jvmNode.isPresent()) {
+      logger.warning(String.format("Missing JVM node for %s: %s", name, element));
+    }
+    return jvmNode;
+  }
+
+  private void emitEdge(Optional<VName> source, String edgeName, Optional<VName> target) {
+    source.ifPresent(
+        s -> target.ifPresent(t -> new EntrySet.Builder(s, edgeName, t).build().emit(emitter)));
   }
 
   @Override
   public void run(
       JCCompilationUnit compilationUnit, KytheEntrySets entrySets, KytheGraph kytheGraph) {
     if (bindingGraphFactory == null) {
-      Context javaContext = kytheGraph.getJavaContext();
       emitter = entrySets.getEmitter();
       DaggerDaggerKythePlugin_PluginComponent.builder()
-          .types(JavacTypes.instance(javaContext))
-          .elements(JavacElements.instance(javaContext))
-          .compilerOptions(KytheBindingGraphFactory.createCompilerOptions())
+          .context(kytheGraph.getJavaContext())
           .build()
           .inject(this);
     }
@@ -164,20 +178,14 @@ public void run(
   }
 
   @Singleton
-  @Component
+  @Component(modules = JavacPluginModule.class)
   interface PluginComponent {
     void inject(DaggerKythePlugin plugin);
 
     @Component.Builder
     interface Builder {
       @BindsInstance
-      Builder types(Types types);
-
-      @BindsInstance
-      Builder elements(Elements elements);
-
-      @BindsInstance
-      Builder compilerOptions(CompilerOptions compilerOptions);
+      Builder context(Context context);
 
       PluginComponent build();
     }
diff --git a/java/dagger/internal/codegen/DaggerStatistics.java b/java/dagger/internal/codegen/DaggerStatistics.java
new file mode 100644
index 000000000..a103f0287
--- /dev/null
+++ b/java/dagger/internal/codegen/DaggerStatistics.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.base.Preconditions;
+import com.google.common.base.Stopwatch;
+import com.google.common.base.Ticker;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton // for state sharing
+final class DaggerStatistics {
+
+  private final Stopwatch totalRuntimeStopwatch;
+
+  @Inject
+  DaggerStatistics(
+      Ticker ticker) {
+    totalRuntimeStopwatch = Stopwatch.createUnstarted(ticker);
+  }
+
+  void processingStarted() {
+    Preconditions.checkState(!totalRuntimeStopwatch.isRunning());
+    totalRuntimeStopwatch.start();
+  }
+
+  void processingStopped() {
+    Preconditions.checkState(totalRuntimeStopwatch.isRunning());
+    totalRuntimeStopwatch.stop();
+
+  }
+}
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index a0f352ff2..e0947c14e 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -29,6 +29,7 @@
 import com.squareup.javapoet.ClassName;
 import java.util.List;
 import java.util.Optional;
+import java.util.function.Predicate;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -144,12 +145,44 @@ DeclaredType rewrapType(TypeMirror type, Class<?> wrappingClass) {
     }
   }
 
-  /** Returns a {@link TypeMirror} for the binding that is accessible to the component. */
-  protected final TypeMirror accessibleType(TypeMirror type, ClassName requestingClass) {
-    if (Accessibility.isTypeAccessibleFrom(type, requestingClass.packageName())) {
+  /**
+   * Returns a publicly accessible type based on {@code type}:
+   *
+   * <ul>
+   *   <li>If {@code type} is publicly accessible, returns it.
+   *   <li>If not, but {@code type}'s raw type is publicly accessible, returns the raw type.
+   *   <li>Otherwise returns {@link Object}.
+   * </ul>
+   */
+  protected TypeMirror publiclyAccessibleType(TypeMirror type) {
+    return accessibleType(
+        type, Accessibility::isTypePubliclyAccessible, Accessibility::isRawTypePubliclyAccessible);
+  }
+
+  /**
+   * Returns an accessible type in {@code requestingClass}'s package based on {@code type}:
+   *
+   * <ul>
+   *   <li>If {@code type} is accessible from the package, returns it.
+   *   <li>If not, but {@code type}'s raw type is accessible from the package, returns the raw type.
+   *   <li>Otherwise returns {@link Object}.
+   * </ul>
+   */
+  protected TypeMirror accessibleType(TypeMirror type, ClassName requestingClass) {
+    return accessibleType(
+        type,
+        t -> Accessibility.isTypeAccessibleFrom(t, requestingClass.packageName()),
+        t -> Accessibility.isRawTypeAccessible(t, requestingClass.packageName()));
+  }
+
+  private TypeMirror accessibleType(
+      TypeMirror type,
+      Predicate<TypeMirror> accessibilityPredicate,
+      Predicate<TypeMirror> rawTypeAccessibilityPredicate) {
+    if (accessibilityPredicate.test(type)) {
       return type;
     } else if (type.getKind().equals(TypeKind.DECLARED)
-        && Accessibility.isRawTypeAccessible(type, requestingClass.packageName())) {
+        && rawTypeAccessibilityPredicate.test(type)) {
       return getDeclaredType(MoreTypes.asTypeElement(type));
     } else {
       return elements.getTypeElement(Object.class).asType();
diff --git a/java/dagger/internal/codegen/DeferredModifiableBindingExpression.java b/java/dagger/internal/codegen/DeferredModifiableBindingExpression.java
new file mode 100644
index 000000000..ac529f620
--- /dev/null
+++ b/java/dagger/internal/codegen/DeferredModifiableBindingExpression.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import java.util.Optional;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A {@link ModifiableAbstractMethodBindingExpression} for a binding that exists but is not ready to
+ * be expressed in this compilation unit and should be deferred until a future compilation.
+ * Generates a method that will be implemented in the future compilation.
+ *
+ * <p>A deferred modifiable binding expression is used when:
+ *
+ * <ul>
+ *   <li>The generated code for a binding requires an instance of a type that is generated in the
+ *       root component compilation unit.
+ *   <li>A {@linkplain ModifiableBindingType#BINDS_METHOD_WITH_MISSING_DEPENDENCY {@code @Binds}
+ *       method's dependency is missing} in a subcomponent.
+ * </ul>
+ */
+final class DeferredModifiableBindingExpression extends ModifiableAbstractMethodBindingExpression {
+  private final ComponentImplementation componentImplementation;
+  private final ContributionBinding binding;
+  private final BindingRequest request;
+
+  DeferredModifiableBindingExpression(
+      ComponentImplementation componentImplementation,
+      ModifiableBindingType modifiableBindingType,
+      ContributionBinding binding,
+      BindingRequest request,
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
+      Optional<ComponentMethodDescriptor> matchingComponentMethod,
+      DaggerTypes types) {
+    super(
+        componentImplementation,
+        modifiableBindingType,
+        request,
+        matchingModifiableBindingMethod,
+        matchingComponentMethod,
+        types);
+    this.componentImplementation = checkNotNull(componentImplementation);
+    this.binding = checkNotNull(binding);
+    this.request = checkNotNull(request);
+  }
+
+  @Override
+  String chooseMethodName() {
+    return componentImplementation.getUniqueMethodName(request, binding);
+  }
+
+  @Override
+  protected TypeMirror contributedType() {
+    return binding.contributedType();
+  }
+}
diff --git a/java/dagger/internal/codegen/DelegateBindingExpression.java b/java/dagger/internal/codegen/DelegateBindingExpression.java
index 702b3342f..8f1ed0c55 100644
--- a/java/dagger/internal/codegen/DelegateBindingExpression.java
+++ b/java/dagger/internal/codegen/DelegateBindingExpression.java
@@ -20,12 +20,12 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.RequestKinds.requestType;
 import static dagger.model.BindingKind.DELEGATE;
 
 import com.squareup.javapoet.ClassName;
 import dagger.model.RequestKind;
-import dagger.model.Scope;
 import javax.lang.model.type.TypeMirror;
 
 /** A {@link BindingExpression} for {@code @Binds} methods. */
@@ -71,7 +71,8 @@ static boolean isBindsScopeStrongerThanDependencyScope(
   Expression getDependencyExpression(ClassName requestingClass) {
     Expression delegateExpression =
         componentBindingExpressions.getDependencyExpression(
-            getOnlyElement(binding.dependencies()).key(), requestKind, requestingClass);
+            bindingRequest(getOnlyElement(binding.dependencies()).key(), requestKind),
+            requestingClass);
 
     TypeMirror contributedType = binding.contributedType();
     switch (requestKind) {
@@ -111,21 +112,15 @@ private Expression castToRawTypeIfNecessary(
 
   private enum ScopeKind {
     UNSCOPED,
-    RELEASABLE,
     SINGLE_CHECK,
     DOUBLE_CHECK,
     ;
 
     static ScopeKind get(Binding binding, BindingGraph graph) {
-      if (!binding.scope().isPresent()) {
-        return UNSCOPED;
-      }
-
-      Scope scope = binding.scope().get();
-      if (graph.scopesRequiringReleasableReferenceManagers().contains(scope)) {
-        return RELEASABLE;
-      }
-      return scope.isReusable() ? SINGLE_CHECK : DOUBLE_CHECK;
+      return binding
+          .scope()
+          .map(scope -> scope.isReusable() ? SINGLE_CHECK : DOUBLE_CHECK)
+          .orElse(UNSCOPED);
     }
 
     boolean isStrongerScopeThan(ScopeKind other) {
diff --git a/java/dagger/internal/codegen/DelegateDeclaration.java b/java/dagger/internal/codegen/DelegateDeclaration.java
index 3a99feba9..d0ae32b67 100644
--- a/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -31,6 +31,7 @@
 import java.util.Optional;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
@@ -41,9 +42,6 @@
  */
 @AutoValue
 abstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {
-  @Override
-  abstract Optional<ExecutableElement> bindingElement();
-
   abstract DependencyRequest delegateRequest();
 
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
@@ -73,8 +71,8 @@ DelegateDeclaration create(
       return new AutoValue_DelegateDeclaration(
           ContributionType.fromBindingMethod(bindsMethod),
           keyFactory.forBindsMethod(bindsMethod, contributingModule),
+          Optional.<Element>of(bindsMethod),
           Optional.of(contributingModule),
-          Optional.of(bindsMethod),
           delegateRequest,
           wrapOptionalInEquivalence(getMapKey(bindsMethod)));
     }
diff --git a/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java b/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
index 63521c07f..5d5f4635f 100644
--- a/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
+++ b/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
@@ -27,15 +28,15 @@
     implements FrameworkInstanceCreationExpression {
 
   private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentBindingExpressions componentBindingExpressions;
 
   DelegatingFrameworkInstanceCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions) {
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
   }
 
@@ -44,7 +45,8 @@ public CodeBlock creationExpression() {
     FrameworkDependency frameworkDependency = getOnlyElement(binding.frameworkDependencies());
     return CodeBlocks.cast(
         componentBindingExpressions
-            .getDependencyExpression(frameworkDependency, generatedComponentModel.name())
+            .getDependencyExpression(
+                bindingRequest(frameworkDependency), componentImplementation.name())
             .codeBlock(),
         frameworkDependency.frameworkClass());
   }
diff --git a/java/dagger/internal/codegen/DependencyCycleValidator.java b/java/dagger/internal/codegen/DependencyCycleValidator.java
index 87564cdd7..2007ce8cd 100644
--- a/java/dagger/internal/codegen/DependencyCycleValidator.java
+++ b/java/dagger/internal/codegen/DependencyCycleValidator.java
@@ -38,7 +38,6 @@
 import com.google.common.graph.MutableNetwork;
 import com.google.common.graph.NetworkBuilder;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Node;
@@ -133,7 +132,7 @@ private void reportCycle(
     ComponentNode componentContainingCycle =
         bindingGraph.componentNode(someCycleNode.componentPath()).get();
     ImmutableList<Node> pathToCycle =
-        shortestPath(bindingGraph, componentContainingCycle, someCycleNode);
+        shortestPath(bindingGraph.network(), componentContainingCycle, someCycleNode);
     return subpathToCycle(pathToCycle, cycle);
   }
 
@@ -171,7 +170,7 @@ private String errorMessage(Cycle<Node> cycle, BindingGraph graph) {
    * #breaksCycle(DependencyEdge, BindingGraph) break} a cycle.
    */
   private DependencyEdge nonCycleBreakingEdge(EndpointPair<Node> endpointPair, BindingGraph graph) {
-    return graph.edgesConnecting(endpointPair.source(), endpointPair.target()).stream()
+    return graph.network().edgesConnecting(endpointPair.source(), endpointPair.target()).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .filter(edge -> !breaksCycle(edge, graph))
         .findFirst()
@@ -185,9 +184,9 @@ private boolean breaksCycle(DependencyEdge edge, BindingGraph graph) {
     if (breaksCycle(edge.dependencyRequest().key().type(), edge.dependencyRequest().kind())) {
       return true;
     }
-    Node target = graph.incidentNodes(edge).target();
-    if (target instanceof BindingNode
-        && ((BindingNode) target).binding().kind().equals(BindingKind.OPTIONAL)) {
+    Node target = graph.network().incidentNodes(edge).target();
+    if (target instanceof dagger.model.Binding
+        && ((dagger.model.Binding) target).kind().equals(BindingKind.OPTIONAL)) {
       /* For @BindsOptionalOf bindings, unwrap the type inside the Optional. If the unwrapped type
        * breaks the cycle, so does the optional binding. */
       TypeMirror optionalValueType = OptionalType.from(edge.dependencyRequest().key()).valueType();
@@ -218,7 +217,7 @@ private boolean breaksCycle(TypeMirror requestedType, RequestKind requestKind) {
 
   private DependencyEdge chooseDependencyEdgeConnecting(
       Node source, Node target, BindingGraph bindingGraph) {
-    return bindingGraph.edgesConnecting(source, target).stream()
+    return bindingGraph.network().edgesConnecting(source, target).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .findFirst()
         .get();
@@ -228,15 +227,15 @@ private DependencyEdge chooseDependencyEdgeConnecting(
   private ImmutableNetwork<Node, DependencyEdge> nonCycleBreakingDependencyGraph(
       BindingGraph bindingGraph) {
     MutableNetwork<Node, DependencyEdge> dependencyNetwork =
-        NetworkBuilder.from(bindingGraph)
-            .expectedNodeCount(bindingGraph.nodes().size())
+        NetworkBuilder.from(bindingGraph.network())
+            .expectedNodeCount(bindingGraph.network().nodes().size())
             .expectedEdgeCount(bindingGraph.dependencyEdges().size())
             .build();
     bindingGraph.dependencyEdges().stream()
         .filter(edge -> !breaksCycle(edge, bindingGraph))
         .forEach(
             edge -> {
-              EndpointPair<Node> endpoints = bindingGraph.incidentNodes(edge);
+              EndpointPair<Node> endpoints = bindingGraph.network().incidentNodes(edge);
               dependencyNetwork.addEdge(endpoints.source(), endpoints.target(), edge);
             });
     return ImmutableNetwork.copyOf(dependencyNetwork);
diff --git a/java/dagger/internal/codegen/DependencyEdgeImpl.java b/java/dagger/internal/codegen/DependencyEdgeImpl.java
new file mode 100644
index 000000000..b777251af
--- /dev/null
+++ b/java/dagger/internal/codegen/DependencyEdgeImpl.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.DependencyRequest;
+
+/** An implementation of {@link DependencyEdge}. */
+final class DependencyEdgeImpl implements DependencyEdge {
+
+  private final DependencyRequest dependencyRequest;
+  private final boolean entryPoint;
+
+  DependencyEdgeImpl(DependencyRequest dependencyRequest, boolean entryPoint) {
+    this.dependencyRequest = dependencyRequest;
+    this.entryPoint = entryPoint;
+  }
+
+  @Override
+  public DependencyRequest dependencyRequest() {
+    return dependencyRequest;
+  }
+
+  @Override
+  public boolean isEntryPoint() {
+    return entryPoint;
+  }
+
+  @Override
+  public String toString() {
+    String string =
+        dependencyRequest
+            .requestElement()
+            .map(DaggerElements::elementToString)
+            .orElseGet(
+                () ->
+                    "synthetic request for "
+                        + dependencyRequest.kind().format(dependencyRequest.key()));
+    return entryPoint ? string + " (entry point)" : string;
+  }
+}
diff --git a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
index 6efe4c750..909d9921c 100644
--- a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
@@ -19,8 +19,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static dagger.internal.codegen.TypeNames.dependencyMethodProducerOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
-import static dagger.internal.codegen.TypeNames.producerOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -40,44 +40,41 @@
 final class DependencyMethodProducerCreationExpression
     implements FrameworkInstanceCreationExpression {
   private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentImplementation componentImplementation;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
   private final BindingGraph graph;
 
   DependencyMethodProducerCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentImplementation componentImplementation,
+      ComponentRequirementExpressions componentRequirementExpressions,
       BindingGraph graph) {
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.componentImplementation = checkNotNull(componentImplementation);
+    this.componentRequirementExpressions = checkNotNull(componentRequirementExpressions);
     this.graph = checkNotNull(graph);
   }
 
   @Override
   public CodeBlock creationExpression() {
     ComponentRequirement dependency =
-        graph
-            .componentDescriptor()
-            .dependenciesByDependencyMethod()
-            .get(binding.bindingElement().get());
+        graph.componentDescriptor().getDependencyThatDefinesMethod(binding.bindingElement().get());
     FieldSpec dependencyField =
         FieldSpec.builder(
                 ClassName.get(dependency.typeElement()), dependency.variableName(), PRIVATE, FINAL)
             .initializer(
-                componentRequirementFields.getExpressionDuringInitialization(
-                    dependency, generatedComponentModel.name()))
+                componentRequirementExpressions.getExpressionDuringInitialization(
+                    dependency, componentImplementation.name()))
             .build();
     // TODO(b/70395982): Explore using a private static type instead of an anonymous class.
     TypeName keyType = TypeName.get(binding.key().type());
     return CodeBlock.of(
         "$L",
         anonymousClassBuilder("")
-            .superclass(producerOf(keyType))
+            .superclass(dependencyMethodProducerOf(keyType))
             .addField(dependencyField)
             .addMethod(
-                methodBuilder("get")
+                methodBuilder("callDependencyMethod")
                     .addAnnotation(Override.class)
                     .addModifiers(PUBLIC)
                     .returns(listenableFutureOf(keyType))
diff --git a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
index e76400ae9..485f389ab 100644
--- a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
@@ -20,7 +20,7 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_PROVISION_FACTORY;
+import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.COMPONENT_PROVISION_FACTORY;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -44,21 +44,21 @@
 final class DependencyMethodProviderCreationExpression
     implements FrameworkInstanceCreationExpression {
 
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentImplementation componentImplementation;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
   private final CompilerOptions compilerOptions;
   private final BindingGraph graph;
   private final ContributionBinding binding;
 
   DependencyMethodProviderCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentImplementation componentImplementation,
+      ComponentRequirementExpressions componentRequirementExpressions,
       CompilerOptions compilerOptions,
       BindingGraph graph) {
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.componentImplementation = checkNotNull(componentImplementation);
+    this.componentRequirementExpressions = checkNotNull(componentRequirementExpressions);
     this.compilerOptions = checkNotNull(compilerOptions);
     this.graph = checkNotNull(graph);
   }
@@ -88,7 +88,7 @@ public CodeBlock creationExpression() {
     if (binding.nullableType().isPresent()) {
       getMethod.addAnnotation(ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
     }
-    generatedComponentModel.addType(
+    componentImplementation.addType(
         COMPONENT_PROVISION_FACTORY,
         classBuilder(factoryClassName())
             .addSuperinterface(providerOf(keyType))
@@ -104,8 +104,8 @@ public CodeBlock creationExpression() {
     return CodeBlock.of(
         "new $T($L)",
         factoryClassName(),
-        componentRequirementFields.getExpressionDuringInitialization(
-            dependency(), generatedComponentModel.name()));
+        componentRequirementExpressions.getExpressionDuringInitialization(
+            dependency(), componentImplementation.name()));
   }
 
   private ClassName factoryClassName() {
@@ -113,11 +113,11 @@ private ClassName factoryClassName() {
         ClassName.get(dependency().typeElement()).toString().replace('.', '_')
             + "_"
             + binding.bindingElement().get().getSimpleName();
-    return generatedComponentModel.name().nestedClass(factoryName);
+    return componentImplementation.name().nestedClass(factoryName);
   }
 
   private ComponentRequirement dependency() {
-    return graph.componentDescriptor().dependenciesByDependencyMethod().get(provisionMethod());
+    return graph.componentDescriptor().getDependencyThatDefinesMethod(provisionMethod());
   }
 
   private Element provisionMethod() {
diff --git a/java/dagger/internal/codegen/DependencyRequestFormatter.java b/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 4ccf8aa18..7ad57c181 100644
--- a/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -40,25 +40,21 @@
 import javax.lang.model.util.ElementKindVisitor8;
 
 /**
- * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing
- * a chain of dependencies.
- * 
+ * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing a
+ * chain of dependencies.
+ *
  * <dl>
- * <dt>For component provision methods
- * <dd>{@code @Qualifier SomeType is provided at\n    ComponentType.method()}
- * 
- * <dt>For component injection methods
- * <dd>{@code SomeType is injected at\n    ComponentType.method(foo)}
- * 
- * <dt>For parameters to {@link Provides @Provides}, {@link Produces @Produces}, or
- * {@link Inject @Inject} methods:
- * <dd>{@code @Qualified ResolvedType is injected at\n    EnclosingType.method([…, ]param[, …])}
- * 
- * <dt>For parameters to {@link Inject @Inject} constructors:
- * <dd>{@code @Qualified ResolvedType is injected at\n    EnclosingType.<init>([…, ]param[, …])}
- * 
- * <dt>For {@link Inject @Inject} fields:
- * <dd>{@code @Qualified ResolvedType is injected at\n    EnclosingType.field}
+ *   <dt>For component provision methods
+ *   <dd>{@code @Qualifier SomeType is provided at\n ComponentType.method()}
+ *   <dt>For component injection methods
+ *   <dd>{@code SomeType is injected at\n ComponentType.method(foo)}
+ *   <dt>For parameters to {@link Provides @Provides}, {@link Produces @Produces}, or {@link
+ *       Inject @Inject} methods:
+ *   <dd>{@code @Qualified ResolvedType is injected at\n EnclosingType.method([…, ]param[, …])}
+ *   <dt>For parameters to {@link Inject @Inject} constructors:
+ *   <dd>{@code @Qualified ResolvedType is injected at\n EnclosingType([…, ]param[, …])}
+ *   <dt>For {@link Inject @Inject} fields:
+ *   <dd>{@code @Qualified ResolvedType is injected at\n EnclosingType.field}
  * </dl>
  */
 final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
diff --git a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
index 73da6c9fc..e611d22fb 100644
--- a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
+++ b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
@@ -20,7 +20,7 @@
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.MaybeBinding;
 import dagger.model.Key;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
@@ -54,17 +54,16 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
     Key productionImplementationExecutorKey = keyFactory.forProductionImplementationExecutor();
     Key productionExecutorKey = keyFactory.forProductionExecutor();
 
-    bindingGraph.bindingNodes(productionExecutorKey).stream()
-        .flatMap(
-            productionExecutorBinding ->
-                bindingGraph.predecessors(productionExecutorBinding).stream())
-        .flatMap(instancesOf(BindingNode.class))
+    bindingGraph.network().nodes().stream()
+        .flatMap(instancesOf(MaybeBinding.class))
+        .filter(node -> node.key().equals(productionExecutorKey))
+        .flatMap(productionExecutor -> bindingGraph.requestingBindings(productionExecutor).stream())
         .filter(binding -> !binding.key().equals(productionImplementationExecutorKey))
         .forEach(binding -> reportError(diagnosticReporter, binding));
   }
 
-  private void reportError(DiagnosticReporter diagnosticReporter, BindingNode bindingNode) {
+  private void reportError(DiagnosticReporter diagnosticReporter, dagger.model.Binding binding) {
     diagnosticReporter.reportBinding(
-        ERROR, bindingNode, "%s may not depend on the production executor", bindingNode.key());
+        ERROR, binding, "%s may not depend on the production executor", binding.key());
   }
 }
diff --git a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
index adcd17acf..0f5b57d11 100644
--- a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
@@ -17,27 +17,29 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.Key;
 import dagger.model.RequestKind;
 
 /** A binding expression that depends on a framework instance. */
 final class DerivedFromFrameworkInstanceBindingExpression extends BindingExpression {
 
-  private final Key key;
+  private final BindingRequest frameworkRequest;
   private final RequestKind requestKind;
   private final FrameworkType frameworkType;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final DaggerTypes types;
 
   DerivedFromFrameworkInstanceBindingExpression(
-      ResolvedBindings resolvedBindings,
+      Key key,
       FrameworkType frameworkType,
       RequestKind requestKind,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types) {
-    this.key = resolvedBindings.key();
+    this.frameworkRequest = bindingRequest(key, frameworkType);
     this.requestKind = checkNotNull(requestKind);
     this.frameworkType = checkNotNull(frameworkType);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
@@ -48,7 +50,16 @@
   Expression getDependencyExpression(ClassName requestingClass) {
     return frameworkType.to(
         requestKind,
-        componentBindingExpressions.getDependencyExpression(key, frameworkType, requestingClass),
+        componentBindingExpressions.getDependencyExpression(frameworkRequest, requestingClass),
         types);
   }
+
+  @Override
+  Expression getDependencyExpressionForComponentMethod(
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
+    Expression expression =
+        componentBindingExpressions.getDependencyExpressionForComponentMethod(
+            frameworkRequest, componentMethod, component);
+    return frameworkType.to(requestKind, expression, types);
+  }
 }
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index a35414e2f..4625a9f83 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -19,11 +19,11 @@
 import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.filter;
 import static com.google.common.collect.Iterables.getLast;
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Iterables.transform;
 import static com.google.common.collect.Lists.asList;
-import static com.google.common.collect.Sets.filter;
 import static dagger.internal.codegen.DaggerElements.DECLARATION_ORDER;
 import static dagger.internal.codegen.DaggerElements.closestEnclosingTypeElement;
 import static dagger.internal.codegen.DaggerElements.elementEncloses;
@@ -34,6 +34,7 @@
 import static java.util.Collections.min;
 import static java.util.Comparator.comparing;
 import static java.util.Comparator.comparingInt;
+import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.common.MoreElements;
 import com.google.common.cache.CacheBuilder;
@@ -46,12 +47,11 @@
 import com.google.common.collect.Table;
 import com.google.errorprone.annotations.FormatMethod;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.MaybeBindingNode;
+import dagger.model.BindingGraph.MaybeBinding;
 import dagger.model.BindingGraph.Node;
 import dagger.model.ComponentPath;
 import dagger.spi.BindingGraphPlugin;
@@ -73,14 +73,41 @@
   private final DaggerTypes types;
   private final Messager messager;
   private final DependencyRequestFormatter dependencyRequestFormatter;
+  private final ValidationType validationType;
+  private final boolean printingEntryPoints;
 
   @Inject
   DiagnosticReporterFactory(
       DaggerTypes types, Messager messager, DependencyRequestFormatter dependencyRequestFormatter) {
+    this(types, messager, dependencyRequestFormatter, ValidationType.ERROR, true);
+  }
+
+  private DiagnosticReporterFactory(
+      DaggerTypes types,
+      Messager messager,
+      DependencyRequestFormatter dependencyRequestFormatter,
+      ValidationType validationType,
+      boolean printingEntryPoints) {
     this.types = types;
     this.messager = messager;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
+    this.validationType = validationType;
+    this.printingEntryPoints = printingEntryPoints;
+  }
+
+  /** Returns a factory that treats all reported errors as some other kind instead. */
+  DiagnosticReporterFactory treatingErrorsAs(ValidationType validationType) {
+    if (validationType.equals(this.validationType)) {
+      return this;
+    }
+    return new DiagnosticReporterFactory(
+        types, messager, dependencyRequestFormatter, validationType, printingEntryPoints);
+  }
 
+  /** Returns a factory that does not print dependency traces from entry points to the error. */
+  DiagnosticReporterFactory withoutPrintingEntryPoints() {
+    return new DiagnosticReporterFactory(
+        types, messager, dependencyRequestFormatter, validationType, false);
   }
 
   /** Creates a reporter for a binding graph and a plugin. */
@@ -119,7 +146,7 @@ DiagnosticReporterImpl reporter(BindingGraph graph, BindingGraphPlugin plugin) {
                 transform(types.supertypes(component.asType()), type -> asTypeElement(type)));
 
     /** The shortest path (value) from an entry point (column) to a binding (row). */
-    private final Table<MaybeBindingNode, DependencyEdge, ImmutableList<Node>> shortestPaths =
+    private final Table<MaybeBinding, DependencyEdge, ImmutableList<Node>> shortestPaths =
         HashBasedTable.create();
 
     private final BindingGraph graph;
@@ -144,6 +171,7 @@ public void reportComponent(
         Diagnostic.Kind diagnosticKind, ComponentNode componentNode, String messageFormat) {
       StringBuilder message = new StringBuilder(messageFormat);
       appendComponentPathUnlessAtRoot(message, componentNode);
+      // TODO(dpb): Report at the component node component.
       printMessage(diagnosticKind, message, rootComponent);
     }
 
@@ -162,18 +190,18 @@ public void reportComponent(
     // TODO(ronshapiro): should this also include the binding element?
     @Override
     public void reportBinding(
-        Diagnostic.Kind diagnosticKind, MaybeBindingNode bindingNode, String message) {
-      printMessage(diagnosticKind, message + new DiagnosticInfo(bindingNode), rootComponent);
+        Diagnostic.Kind diagnosticKind, MaybeBinding binding, String message) {
+      printMessage(diagnosticKind, message + new DiagnosticInfo(binding), rootComponent);
     }
 
     @Override
     public void reportBinding(
         Diagnostic.Kind diagnosticKind,
-        MaybeBindingNode bindingNode,
+        MaybeBinding binding,
         String messageFormat,
         Object firstArg,
         Object... moreArgs) {
-      reportBinding(diagnosticKind, bindingNode, formatMessage(messageFormat, firstArg, moreArgs));
+      reportBinding(diagnosticKind, binding, formatMessage(messageFormat, firstArg, moreArgs));
     }
 
     @Override
@@ -217,20 +245,28 @@ private String formatMessage(String messageFormat, Object firstArg, Object[] mor
     }
 
     private Node source(Edge edge) {
-      return graph.incidentNodes(edge).source();
+      return graph.network().incidentNodes(edge).source();
     }
 
     void printMessage(
         Diagnostic.Kind diagnosticKind, CharSequence message, Element elementToReport) {
+      if (diagnosticKind.equals(ERROR)) {
+        if (!validationType.diagnosticKind().isPresent()) {
+          return;
+        }
+        diagnosticKind = validationType.diagnosticKind().get();
+      }
       reportedDiagnosticKinds.add(diagnosticKind);
       StringBuilder fullMessage = new StringBuilder();
       appendBracketPrefix(fullMessage, plugin);
+
       // TODO(ronshapiro): should we create a HashSet out of elementEncloses() so we don't
       // need to do an O(n) contains() each time?
       if (!elementEncloses(rootComponent, elementToReport)) {
         appendBracketPrefix(fullMessage, elementToString(elementToReport));
         elementToReport = rootComponent;
       }
+
       messager.printMessage(diagnosticKind, fullMessage.append(message), elementToReport);
     }
 
@@ -250,10 +286,10 @@ private void appendBracketPrefix(StringBuilder message, String prefix) {
       final ImmutableSet<DependencyEdge> requests;
       final ImmutableSet<DependencyEdge> entryPoints;
 
-      DiagnosticInfo(MaybeBindingNode bindingNode) {
-        entryPoints = graph.entryPointEdgesDependingOnBindingNode(bindingNode);
-        requests = requests(bindingNode);
-        dependencyTrace = dependencyTrace(bindingNode, entryPoints);
+      DiagnosticInfo(MaybeBinding binding) {
+        entryPoints = graph.entryPointEdgesDependingOnBinding(binding);
+        requests = requests(binding);
+        dependencyTrace = dependencyTrace(binding, entryPoints);
       }
 
       DiagnosticInfo(DependencyEdge dependencyEdge) {
@@ -265,9 +301,9 @@ private void appendBracketPrefix(StringBuilder message, String prefix) {
           entryPoints = ImmutableSet.of(dependencyEdge);
         } else {
           // It's not an entry point, so it's part of a binding
-          BindingNode bindingNode = (BindingNode) source(dependencyEdge);
-          entryPoints = graph.entryPointEdgesDependingOnBindingNode(bindingNode);
-          dependencyTraceBuilder.addAll(dependencyTrace(bindingNode, entryPoints));
+          dagger.model.Binding binding = (dagger.model.Binding) source(dependencyEdge);
+          entryPoints = graph.entryPointEdgesDependingOnBinding(binding);
+          dependencyTraceBuilder.addAll(dependencyTrace(binding, entryPoints));
         }
         dependencyTrace = dependencyTraceBuilder.build();
       }
@@ -275,30 +311,44 @@ private void appendBracketPrefix(StringBuilder message, String prefix) {
       @Override
       public String toString() {
         StringBuilder message =
-            new StringBuilder(dependencyTrace.size() * 100 /* a guess heuristic */);
-
-        // Print the dependency trace.
-        dependencyTrace.forEach(
-            edge -> dependencyRequestFormatter.appendFormatLine(message, edge.dependencyRequest()));
-        appendComponentPathUnlessAtRoot(message, source(getLast(dependencyTrace)));
+            printingEntryPoints
+                ? new StringBuilder(dependencyTrace.size() * 100 /* a guess heuristic */)
+                : new StringBuilder();
+
+        // Print the dependency trace if we're printing entry points
+        if (printingEntryPoints) {
+          dependencyTrace.forEach(
+              edge ->
+                  dependencyRequestFormatter.appendFormatLine(message, edge.dependencyRequest()));
+          appendComponentPathUnlessAtRoot(message, source(getLast(dependencyTrace)));
+        }
 
-        // List any other dependency requests.
-        ImmutableSet<Element> otherRequests =
+        // Print any dependency requests that aren't shown as part of the dependency trace.
+        ImmutableSet<Element> requestsToPrint =
             requests.stream()
-                .filter(request -> !request.isEntryPoint()) // skip entry points, listed below
-                // skip the request from the dependency trace above
-                .filter(request -> !request.equals(dependencyTrace.get(0)))
+                .filter(
+                    // if printing entry points, skip them and the request at the head of the
+                    // dependency trace here.
+                    printingEntryPoints
+                        ? request ->
+                            !request.isEntryPoint() && !request.equals(dependencyTrace.get(0))
+                        : request -> true)
+                .filter(request -> request.dependencyRequest().requestElement().isPresent())
                 .map(request -> request.dependencyRequest().requestElement().get())
                 .collect(toImmutableSet());
-        if (!otherRequests.isEmpty()) {
-          message.append("\nIt is also requested at:");
-          for (Element otherRequest : otherRequests) {
-            message.append("\n    ").append(elementToString(otherRequest));
+        if (!requestsToPrint.isEmpty()) {
+          message
+              .append("\nIt is")
+              .append(printingEntryPoints ? " also " : " ")
+              .append("requested at:");
+          for (Element request : requestsToPrint) {
+            message.append("\n    ").append(elementToString(request));
           }
         }
 
-        // List the remaining entry points, showing which component they're in.
-        if (entryPoints.size() > 1) {
+        // Print the remaining entry points, showing which component they're in, if we're printing
+        // entry points.
+        if (printingEntryPoints && entryPoints.size() > 1) {
           message.append("\nThe following other entry points also depend on it:");
           entryPoints.stream()
               .filter(entryPoint -> !entryPoint.equals(getLast(dependencyTrace)))
@@ -330,13 +380,13 @@ public String toString() {
       }
 
       /**
-       * Returns the dependency trace from one of the {@code entryPoints} to {@code bindingNode} to
+       * Returns the dependency trace from one of the {@code entryPoints} to {@code binding} to
        * {@code message} as a list <i>ending with</i> the entry point.
        */
       // TODO(ronshapiro): Adding a DependencyPath type to dagger.model could be useful, i.e.
       // bindingGraph.shortestPathFromEntryPoint(DependencyEdge, MaybeBindingNode)
       ImmutableList<DependencyEdge> dependencyTrace(
-          MaybeBindingNode bindingNode, ImmutableSet<DependencyEdge> entryPoints) {
+          MaybeBinding binding, ImmutableSet<DependencyEdge> entryPoints) {
         // Show the full dependency trace for one entry point.
         DependencyEdge entryPointForTrace =
             min(
@@ -344,7 +394,7 @@ public String toString() {
                 // prefer entry points in components closest to the root
                 rootComponentFirst()
                     // then prefer entry points with a short dependency path to the error
-                    .thenComparing(shortestDependencyPathFirst(bindingNode))
+                    .thenComparing(shortestDependencyPathFirst(binding))
                     // then prefer entry points declared in the component to those declared in a
                     // supertype
                     .thenComparing(nearestComponentSupertypeFirst())
@@ -352,19 +402,21 @@ public String toString() {
                     .thenComparing(requestElementDeclarationOrder()));
 
         ImmutableList<Node> shortestBindingPath =
-            shortestPathFromEntryPoint(entryPointForTrace, bindingNode);
+            shortestPathFromEntryPoint(entryPointForTrace, binding);
         verify(
             !shortestBindingPath.isEmpty(),
             "no dependency path from %s to %s in %s",
             entryPointForTrace,
-            bindingNode,
+            binding,
             graph);
 
         ImmutableList.Builder<DependencyEdge> dependencyTrace = ImmutableList.builder();
         dependencyTrace.add(entryPointForTrace);
         for (int i = 0; i < shortestBindingPath.size() - 1; i++) {
           Set<Edge> dependenciesBetween =
-              graph.edgesConnecting(shortestBindingPath.get(i), shortestBindingPath.get(i + 1));
+              graph
+                  .network()
+                  .edgesConnecting(shortestBindingPath.get(i), shortestBindingPath.get(i + 1));
           // If a binding requests a key more than once, any of them should be fine to get to the
           // shortest path
           dependencyTrace.add((DependencyEdge) Iterables.get(dependenciesBetween, 0));
@@ -372,9 +424,9 @@ public String toString() {
         return dependencyTrace.build().reverse();
       }
 
-      /** Returns all the nonsynthetic dependency requests for a binding node. */
-      ImmutableSet<DependencyEdge> requests(MaybeBindingNode bindingNode) {
-        return graph.inEdges(bindingNode).stream()
+      /** Returns all the nonsynthetic dependency requests for a binding. */
+      ImmutableSet<DependencyEdge> requests(MaybeBinding binding) {
+        return graph.network().inEdges(binding).stream()
             .flatMap(instancesOf(DependencyEdge.class))
             .filter(edge -> edge.dependencyRequest().requestElement().isPresent())
             .sorted(requestEnclosingTypeName().thenComparing(requestElementDeclarationOrder()))
@@ -391,23 +443,25 @@ public String toString() {
 
       /**
        * Returns a comparator that puts entry points whose shortest dependency path to {@code
-       * bindingNode} is shortest first.
+       * binding} is shortest first.
        */
-      Comparator<DependencyEdge> shortestDependencyPathFirst(MaybeBindingNode bindingNode) {
-        return comparing(entryPoint -> shortestPathFromEntryPoint(entryPoint, bindingNode).size());
+      Comparator<DependencyEdge> shortestDependencyPathFirst(MaybeBinding binding) {
+        return comparing(entryPoint -> shortestPathFromEntryPoint(entryPoint, binding).size());
       }
 
       ImmutableList<Node> shortestPathFromEntryPoint(
-          DependencyEdge entryPoint, MaybeBindingNode bindingNode) {
+          DependencyEdge entryPoint, MaybeBinding binding) {
         return shortestPaths
-            .row(bindingNode)
+            .row(binding)
             .computeIfAbsent(
                 entryPoint,
                 ep ->
                     shortestPath(
-                        node -> filter(graph.successors(node), MaybeBindingNode.class::isInstance),
-                        graph.incidentNodes(ep).target(),
-                        bindingNode));
+                        node ->
+                            filter(
+                                graph.network().successors(node), MaybeBinding.class::isInstance),
+                        graph.network().incidentNodes(ep).target(),
+                        binding));
       }
 
       /**
diff --git a/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
index 7c059d9c1..e14d44969 100644
--- a/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
+++ b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
@@ -16,7 +16,8 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.VOLATILE;
 
@@ -34,23 +35,23 @@
  */
 final class DoubleCheckedMethodImplementation extends BindingMethodImplementation {
 
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ContributionBinding binding;
   private final Supplier<String> fieldName = Suppliers.memoize(this::createField);
 
   DoubleCheckedMethodImplementation(
-      ResolvedBindings resolvedBindings,
+      ComponentImplementation component,
+      ContributionBinding binding,
       BindingRequest request,
       BindingExpression bindingExpression,
-      DaggerTypes types,
-      GeneratedComponentModel generatedComponentModel) {
-    super(resolvedBindings, request, bindingExpression, generatedComponentModel.name(), types);
-    this.generatedComponentModel = generatedComponentModel;
-    this.binding = resolvedBindings.contributionBinding();
+      DaggerTypes types) {
+    super(component, binding, request, bindingExpression, types);
+    this.componentImplementation = checkNotNull(component);
+    this.binding = checkNotNull(binding);
   }
 
   @Override
-  CodeBlock body() {
+  CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
     String fieldExpression = fieldName.get().equals("local") ? "this.local" : fieldName.get();
     return CodeBlock.builder()
         .addStatement("$T local = $L", TypeName.OBJECT, fieldExpression)
@@ -58,7 +59,7 @@ CodeBlock body() {
         .beginControlFlow("synchronized (local)")
         .addStatement("local = $L", fieldExpression)
         .beginControlFlow("if (local instanceof $T)", MemoizedSentinel.class)
-        .addStatement("local = $L", simpleBindingExpression())
+        .addStatement("local = $L", simpleBindingExpression.get())
         .addStatement("$1L = $2T.reentrantCheck($1L, local)", fieldExpression, DoubleCheck.class)
         .endControlFlow()
         .endControlFlow()
@@ -68,8 +69,8 @@ CodeBlock body() {
   }
 
   private String createField() {
-    String name = generatedComponentModel.getUniqueFieldName(BindingVariableNamer.name(binding));
-    generatedComponentModel.addField(
+    String name = componentImplementation.getUniqueFieldName(BindingVariableNamer.name(binding));
+    componentImplementation.addField(
         PRIVATE_METHOD_SCOPED_FIELD,
         FieldSpec.builder(TypeName.OBJECT, name, PRIVATE, VOLATILE)
             .initializer("new $T()", MemoizedSentinel.class)
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidator.java b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
index 2e54f84ae..926ea6086 100644
--- a/java/dagger/internal/codegen/DuplicateBindingsValidator.java
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
@@ -18,30 +18,33 @@
 
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static com.google.common.collect.Maps.filterValues;
+import static com.google.common.collect.Maps.transformValues;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
-import static dagger.internal.codegen.DuplicateBindingsValidator.SourceAndRequest.indexEdgesBySourceAndRequest;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.Optionals.emptiesLast;
 import static java.util.Comparator.comparing;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
+import dagger.model.Binding;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
-import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Node;
 import dagger.model.DependencyRequest;
+import dagger.model.Key;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
 import java.util.Comparator;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
@@ -66,6 +69,27 @@
                   comparing((Element element) -> element.getSimpleName().toString())
                       .thenComparing((Element element) -> element.asType().toString())));
 
+  /**
+   * An {@link Equivalence} between {@link Binding}s that ignores the {@link
+   * Binding#componentPath()}. (All other properties are essentially derived from the {@link
+   * Binding#bindingElement()} and {@link Binding#contributingModule()}, so only those two are
+   * compared.)
+   */
+  // TODO(dpb): Move to dagger.model?
+  private static final Equivalence<Binding> IGNORING_COMPONENT_PATH =
+      new Equivalence<Binding>() {
+        @Override
+        protected boolean doEquivalent(Binding a, Binding b) {
+          return a.bindingElement().equals(b.bindingElement())
+              && a.contributingModule().equals(b.contributingModule());
+        }
+
+        @Override
+        protected int doHash(Binding binding) {
+          return Objects.hash(binding.bindingElement(), binding.contributingModule());
+        }
+      };
+
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
 
   @Inject
@@ -80,67 +104,80 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    Multimaps.asMap(indexEdgesBySourceAndRequest(bindingGraph))
+    // If two unrelated subcomponents have the same duplicate bindings only because they install the
+    // same two modules, then fixing the error in one subcomponent will uncover the second
+    // subcomponent to fix.
+    // TODO(ronshapiro): Explore ways to address such underreporting without overreporting.
+    Set<ImmutableSet<Equivalence.Wrapper<Binding>>> reportedDuplicateBindingSets = new HashSet<>();
+    duplicateBindings(bindingGraph)
         .forEach(
-            (sourceAndRequest, dependencyEdges) -> {
-              if (dependencyEdges.size() > 1) {
-                reportDuplicateBindings(
-                    sourceAndRequest.request(), dependencyEdges, bindingGraph, diagnosticReporter);
+            (sourceAndRequest, resolvedBindings) -> {
+              // Only report each set of duplicate bindings once, ignoring the installed component.
+              if (reportedDuplicateBindingSets.add(
+                  equivalentSetIgnoringComponentPath(resolvedBindings))) {
+                reportDuplicateBindings(resolvedBindings, bindingGraph, diagnosticReporter);
               }
             });
   }
 
+  /**
+   * Returns duplicate bindings for each dependency request, counting the same dependency request
+   * separately when coming from separate source nodes.
+   */
+  private Map<SourceAndRequest, ImmutableSet<Binding>> duplicateBindings(
+      BindingGraph bindingGraph) {
+    ImmutableSetMultimap<SourceAndRequest, Binding> bindingsByDependencyRequest =
+        bindingGraph.dependencyEdges().stream()
+            .filter(edge -> bindingGraph.network().incidentNodes(edge).target() instanceof Binding)
+            .collect(
+                toImmutableSetMultimap(
+                    edge ->
+                        SourceAndRequest.create(
+                            bindingGraph.network().incidentNodes(edge).source(),
+                            edge.dependencyRequest()),
+                    edge -> ((Binding) bindingGraph.network().incidentNodes(edge).target())));
+    return transformValues(
+        filterValues(bindingsByDependencyRequest.asMap(), bindings -> bindings.size() > 1),
+        ImmutableSet::copyOf);
+  }
+
   private void reportDuplicateBindings(
-      DependencyRequest dependencyRequest,
-      Set<DependencyEdge> duplicateDependencies,
+      ImmutableSet<Binding> duplicateBindings,
       BindingGraph bindingGraph,
       DiagnosticReporter diagnosticReporter) {
-    ImmutableSet<BindingNode> duplicateBindings =
-        duplicateDependencies.stream()
-            .map(edge -> bindingGraph.incidentNodes(edge).target())
-            .flatMap(instancesOf(BindingNode.class))
-            .collect(toImmutableSet());
-    diagnosticReporter.reportDependency(
+    Binding oneBinding = duplicateBindings.asList().get(0);
+    diagnosticReporter.reportBinding(
         ERROR,
-        Iterables.get(duplicateDependencies, 0),
-        Iterables.any(duplicateBindings, node -> node.binding().kind().isMultibinding())
-            ? incompatibleBindingsMessage(dependencyRequest, duplicateBindings, bindingGraph)
-            : duplicateBindingMessage(dependencyRequest, duplicateBindings, bindingGraph));
+        oneBinding,
+        Iterables.any(duplicateBindings, binding -> binding.kind().isMultibinding())
+            ? incompatibleBindingsMessage(oneBinding.key(), duplicateBindings, bindingGraph)
+            : duplicateBindingMessage(oneBinding.key(), duplicateBindings, bindingGraph));
   }
 
   private String duplicateBindingMessage(
-      DependencyRequest dependencyRequest,
-      ImmutableSet<BindingNode> duplicateBindings,
-      BindingGraph graph) {
-    StringBuilder message =
-        new StringBuilder().append(dependencyRequest.key()).append(" is bound multiple times:");
+      Key key, ImmutableSet<Binding> duplicateBindings, BindingGraph graph) {
+    StringBuilder message = new StringBuilder().append(key).append(" is bound multiple times:");
     formatDeclarations(message, 1, declarations(graph, duplicateBindings));
     return message.toString();
   }
 
   private String incompatibleBindingsMessage(
-      DependencyRequest dependencyRequest,
-      ImmutableSet<BindingNode> duplicateBindings,
-      BindingGraph graph) {
-    ImmutableSet<BindingNode> multibindings =
+      Key key, ImmutableSet<Binding> duplicateBindings, BindingGraph graph) {
+    ImmutableSet<dagger.model.Binding> multibindings =
         duplicateBindings.stream()
-            .filter(node -> node.binding().kind().isMultibinding())
+            .filter(binding -> binding.kind().isMultibinding())
             .collect(toImmutableSet());
     verify(
-        multibindings.size() == 1,
-        "expected only one multibinding for %s: %s",
-        dependencyRequest,
-        multibindings);
+        multibindings.size() == 1, "expected only one multibinding for %s: %s", key, multibindings);
     StringBuilder message = new StringBuilder();
     java.util.Formatter messageFormatter = new java.util.Formatter(message);
-    messageFormatter.format(
-        "%s has incompatible bindings or declarations:\n", dependencyRequest.key());
+    messageFormatter.format("%s has incompatible bindings or declarations:\n", key);
     message.append(INDENT);
-    BindingNode multibinding = getOnlyElement(multibindings);
+    dagger.model.Binding multibinding = getOnlyElement(multibindings);
     messageFormatter.format("%s bindings and declarations:", multibindingTypeString(multibinding));
     formatDeclarations(message, 2, declarations(graph, multibindings));
 
-    Set<BindingNode> uniqueBindings =
+    Set<dagger.model.Binding> uniqueBindings =
         Sets.filter(duplicateBindings, binding -> !binding.equals(multibinding));
     message.append('\n').append(INDENT).append("Unique bindings and declarations:");
     formatDeclarations(
@@ -161,33 +198,31 @@ private void formatDeclarations(
   }
 
   private ImmutableSet<BindingDeclaration> declarations(
-      BindingGraph graph, Set<BindingNode> bindings) {
+      BindingGraph graph, Set<dagger.model.Binding> bindings) {
     return bindings.stream()
-        .flatMap(node -> declarations(graph, node).stream())
+        .flatMap(binding -> declarations(graph, binding).stream())
         .distinct()
         .sorted(BINDING_DECLARATION_COMPARATOR)
         .collect(toImmutableSet());
   }
 
-  private ImmutableSet<BindingDeclaration> declarations(BindingGraph graph, BindingNode node) {
+  private ImmutableSet<BindingDeclaration> declarations(
+      BindingGraph graph, dagger.model.Binding binding) {
     ImmutableSet.Builder<BindingDeclaration> declarations = ImmutableSet.builder();
-    ((BindingNodeImpl) node).associatedDeclarations().forEach(declarations::add);
-    if (node.binding() instanceof BindingDeclaration) {
-      BindingDeclaration declaration = ((BindingDeclaration) node.binding());
-      if (bindingDeclarationFormatter.canFormat(declaration)) {
-        declarations.add(declaration);
-      } else {
-        graph.successors(node).stream()
-            .flatMap(instancesOf(BindingNode.class))
-            .flatMap(dependency -> declarations(graph, dependency).stream())
-            .forEach(declarations::add);
-      }
+    BindingNode bindingNode = (BindingNode) binding;
+    bindingNode.associatedDeclarations().forEach(declarations::add);
+    if (bindingDeclarationFormatter.canFormat(bindingNode.delegate())) {
+      declarations.add(bindingNode.delegate());
+    } else {
+      graph.requestedBindings(binding).stream()
+          .flatMap(requestedBinding -> declarations(graph, requestedBinding).stream())
+          .forEach(declarations::add);
     }
     return declarations.build();
   }
 
-  private String multibindingTypeString(BindingNode multibinding) {
-    switch (multibinding.binding().kind()) {
+  private String multibindingTypeString(dagger.model.Binding multibinding) {
+    switch (multibinding.kind()) {
       case MULTIBOUND_MAP:
         return "Map";
       case MULTIBOUND_SET:
@@ -197,6 +232,11 @@ private String multibindingTypeString(BindingNode multibinding) {
     }
   }
 
+  private static ImmutableSet<Equivalence.Wrapper<Binding>> equivalentSetIgnoringComponentPath(
+      ImmutableSet<Binding> resolvedBindings) {
+    return resolvedBindings.stream().map(IGNORING_COMPONENT_PATH::wrap).collect(toImmutableSet());
+  }
+
   @AutoValue
   abstract static class SourceAndRequest {
 
@@ -204,16 +244,6 @@ private String multibindingTypeString(BindingNode multibinding) {
 
     abstract DependencyRequest request();
 
-    static ImmutableSetMultimap<SourceAndRequest, DependencyEdge> indexEdgesBySourceAndRequest(
-        BindingGraph bindingGraph) {
-      return bindingGraph.dependencyEdges().stream()
-          .collect(
-              toImmutableSetMultimap(
-                  edge ->
-                      create(bindingGraph.incidentNodes(edge).source(), edge.dependencyRequest()),
-                  edge -> edge));
-    }
-
     static SourceAndRequest create(Node source, DependencyRequest request) {
       return new AutoValue_DuplicateBindingsValidator_SourceAndRequest(source, request);
     }
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index f7b143eb5..76c9e58bb 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -27,23 +27,23 @@
  */
 final class ErrorMessages {
 
-  static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
+  static ComponentCreatorMessages creatorMessagesFor(ComponentKind kind) {
     switch(kind) {
       case COMPONENT:
-        return ComponentBuilderMessages.INSTANCE;
+        return ComponentCreatorMessages.INSTANCE;
       case SUBCOMPONENT:
-        return SubcomponentBuilderMessages.INSTANCE;
+        return SubcomponentCreatorMessages.INSTANCE;
       case PRODUCTION_COMPONENT:
-        return ProductionComponentBuilderMessages.INSTANCE;
+        return ProductionComponentCreatorMessages.INSTANCE;
       case PRODUCTION_SUBCOMPONENT:
-        return ProductionSubcomponentBuilderMessages.INSTANCE;
+        return ProductionSubcomponentCreatorMessages.INSTANCE;
       default:
         throw new IllegalStateException(kind.toString());
     }
   }
 
-  static class ComponentBuilderMessages {
-    static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
+  static class ComponentCreatorMessages {
+    static final ComponentCreatorMessages INSTANCE = new ComponentCreatorMessages();
 
     protected String process(String s) { return s; }
 
@@ -161,7 +161,7 @@ final String inheritedNonBindsInstanceMethodsMayNotTakePrimitives() {
 
     final String buildMethodReturnsSupertypeWithMissingMethods(
         TypeElement component,
-        TypeElement componentBuilder,
+        TypeElement componentCreator,
         TypeMirror returnType,
         ExecutableElement buildMethod,
         Set<ExecutableElement> additionalMethods) {
@@ -169,7 +169,7 @@ final String buildMethodReturnsSupertypeWithMissingMethods(
           "%1$s.%2$s() returns %3$s, but %4$s declares additional component method(s): %5$s. In "
               + "order to provide type-safe access to these methods, override %2$s() to return "
               + "%4$s",
-          componentBuilder.getQualifiedName(),
+          componentCreator.getQualifiedName(),
           buildMethod.getSimpleName(),
           returnType,
           component.getQualifiedName(),
@@ -177,9 +177,9 @@ final String buildMethodReturnsSupertypeWithMissingMethods(
     }
   }
 
-  static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
+  static final class SubcomponentCreatorMessages extends ComponentCreatorMessages {
     @SuppressWarnings("hiding")
-    static final SubcomponentBuilderMessages INSTANCE = new SubcomponentBuilderMessages();
+    static final SubcomponentCreatorMessages INSTANCE = new SubcomponentCreatorMessages();
 
     @Override protected String process(String s) {
       return s.replaceAll("component", "subcomponent").replaceAll("Component", "Subcomponent");
@@ -194,10 +194,10 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
-  private static final class ProductionComponentBuilderMessages extends ComponentBuilderMessages {
+  private static final class ProductionComponentCreatorMessages extends ComponentCreatorMessages {
     @SuppressWarnings("hiding")
-    static final ProductionComponentBuilderMessages INSTANCE =
-        new ProductionComponentBuilderMessages();
+    static final ProductionComponentCreatorMessages INSTANCE =
+        new ProductionComponentCreatorMessages();
 
     @Override protected String process(String s) {
       return s.replaceAll("component", "production component")
@@ -205,11 +205,11 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
-  private static final class ProductionSubcomponentBuilderMessages
-      extends ComponentBuilderMessages {
+  private static final class ProductionSubcomponentCreatorMessages
+      extends ComponentCreatorMessages {
     @SuppressWarnings("hiding")
-    static final ProductionSubcomponentBuilderMessages INSTANCE =
-        new ProductionSubcomponentBuilderMessages();
+    static final ProductionSubcomponentCreatorMessages INSTANCE =
+        new ProductionSubcomponentCreatorMessages();
 
     @Override
     protected String process(String s) {
diff --git a/java/dagger/internal/codegen/ForReleasableReferencesValidator.java b/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
deleted file mode 100644
index df8d3b969..000000000
--- a/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
-import static dagger.internal.codegen.Scopes.scope;
-import static dagger.model.Scope.isScope;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/** Validates uses of {@link ForReleasableReferences @ForReleasableReferences}. */
-final class ForReleasableReferencesValidator implements ProcessingStep {
-
-  private final Messager messager;
-
-  @Inject
-  ForReleasableReferencesValidator(Messager messager) {
-    this.messager = messager;
-  }
-
-  ValidationReport<Element> validateAnnotatedElement(Element annotatedElement) {
-    checkArgument(isAnnotationPresent(annotatedElement, ForReleasableReferences.class));
-    ValidationReport.Builder<Element> report = ValidationReport.about(annotatedElement);
-    AnnotationMirror annotation =
-        getAnnotationMirror(annotatedElement, ForReleasableReferences.class).get();
-    TypeElement scopeType = MoreTypes.asTypeElement(getTypeValue(annotation, "value"));
-    if (!isScope(scopeType)) {
-      report.addError(
-          forReleasableReferencesValueNotAScope(scopeType), annotatedElement, annotation);
-    } else if (!scope(scopeType).canReleaseReferences()) {
-      report.addError(
-          forReleasableReferencesValueCannotReleaseReferences(scopeType),
-          annotatedElement,
-          annotation);
-    }
-    return report.build();
-  }
-
-  @Override
-  public Set<? extends Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(ForReleasableReferences.class);
-  }
-
-  @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    elementsByAnnotation
-        .get(ForReleasableReferences.class)
-        .stream()
-        .map(this::validateAnnotatedElement)
-        .forEach(report -> report.printMessagesTo(messager));
-    return ImmutableSet.of();
-  }
-
-  private static String forReleasableReferencesValueNotAScope(TypeElement scopeType) {
-    return forReleasableReferencesValueNeedsAnnotation(
-        scopeType,
-        String.format(
-            "@%s and @%s",
-            javax.inject.Scope.class.getCanonicalName(),
-            CanReleaseReferences.class.getCanonicalName()));
-  }
-
-  private static String forReleasableReferencesValueCannotReleaseReferences(TypeElement scopeType) {
-    return forReleasableReferencesValueNeedsAnnotation(
-        scopeType, "@" + CanReleaseReferences.class.getCanonicalName());
-  }
-
-  private static String forReleasableReferencesValueNeedsAnnotation(
-      TypeElement scopeType, String annotations) {
-    return String.format(
-        "The value of @%s must be a reference-releasing scope. "
-            + "Did you mean to annotate %s with %s? Or did you mean to use a different class here?",
-        ForReleasableReferences.class.getSimpleName(), scopeType.getQualifiedName(), annotations);
-  }
-}
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 9bc1d176a..da349b8a8 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -18,7 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.FRAMEWORK_FIELD;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.FRAMEWORK_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.squareup.javapoet.ClassName;
@@ -26,6 +26,7 @@
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.DelegateFactory;
+import dagger.producers.internal.DelegateProducer;
 import java.util.Optional;
 
 /**
@@ -71,17 +72,17 @@ default boolean useInnerSwitchingProvider() {
     }
   }
 
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ResolvedBindings resolvedBindings;
   private final FrameworkInstanceCreationExpression frameworkInstanceCreationExpression;
   private FieldSpec fieldSpec;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   FrameworkFieldInitializer(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ResolvedBindings resolvedBindings,
       FrameworkInstanceCreationExpression frameworkInstanceCreationExpression) {
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.resolvedBindings = checkNotNull(resolvedBindings);
     this.frameworkInstanceCreationExpression = checkNotNull(frameworkInstanceCreationExpression);
   }
@@ -93,7 +94,7 @@ default boolean useInnerSwitchingProvider() {
   @Override
   public final MemberSelect memberSelect() {
     initializeField();
-    return MemberSelect.localField(generatedComponentModel.name(), checkNotNull(fieldSpec).name);
+    return MemberSelect.localField(componentImplementation.name(), checkNotNull(fieldSpec).name);
   }
 
   /** Adds the field and its initialization code to the component. */
@@ -106,18 +107,14 @@ private void initializeField() {
         CodeBlock fieldInitialization = frameworkInstanceCreationExpression.creationExpression();
         CodeBlock initCode = CodeBlock.of("this.$N = $L;", getOrCreateField(), fieldInitialization);
 
-        if (fieldInitializationState == InitializationState.DELEGATED) {
-          // If we were recursively invoked, set the delegate factory as part of our initialization
-          CodeBlock delegateFactoryVariable = CodeBlock.of("$NDelegate", fieldSpec);
-          codeBuilder
-              .add(
-                  "$1T $2L = ($1T) $3N;", DelegateFactory.class, delegateFactoryVariable, fieldSpec)
-              .add(initCode)
-              .add("$L.setDelegatedProvider($N);", delegateFactoryVariable, fieldSpec);
+        if (isReplacingSuperclassFrameworkInstance()
+            || fieldInitializationState == InitializationState.DELEGATED) {
+          codeBuilder.add(
+              "$T.setDelegate($N, $L);", delegateType(), fieldSpec, fieldInitialization);
         } else {
           codeBuilder.add(initCode);
         }
-        generatedComponentModel.addInitialization(codeBuilder.build());
+        componentImplementation.addInitialization(codeBuilder.build());
 
         fieldInitializationState = InitializationState.INITIALIZED;
         break;
@@ -125,8 +122,8 @@ private void initializeField() {
       case INITIALIZING:
         // We were recursively invoked, so create a delegate factory instead
         fieldInitializationState = InitializationState.DELEGATED;
-        generatedComponentModel.addInitialization(
-            CodeBlock.of("this.$N = new $T<>();", getOrCreateField(), DelegateFactory.class));
+        componentImplementation.addInitialization(
+            CodeBlock.of("this.$N = new $T<>();", getOrCreateField(), delegateType()));
         break;
 
       case DELEGATED:
@@ -146,37 +143,78 @@ private FieldSpec getOrCreateField() {
     if (fieldSpec != null) {
       return fieldSpec;
     }
-    boolean useRawType = !generatedComponentModel.isTypeAccessible(resolvedBindings.key().type());
+    boolean useRawType = !componentImplementation.isTypeAccessible(resolvedBindings.key().type());
     FrameworkField contributionBindingField =
         FrameworkField.forResolvedBindings(
             resolvedBindings, frameworkInstanceCreationExpression.alternativeFrameworkClass());
 
     TypeName fieldType;
-    if (!fieldInitializationState.equals(InitializationState.DELEGATED)
+    boolean rawTypeUsed = false;
+    if (!isReplacingSuperclassFrameworkInstance()
+        && !fieldInitializationState.equals(InitializationState.DELEGATED)
         && specificType().isPresent()) {
       // For some larger components, this causes javac to compile much faster by getting the
       // field type to exactly match the type of the expression being assigned to it.
       fieldType = specificType().get();
     } else if (useRawType) {
       fieldType = contributionBindingField.type().rawType;
+      rawTypeUsed = true;
     } else {
       fieldType = contributionBindingField.type();
     }
 
     FieldSpec.Builder contributionField =
         FieldSpec.builder(
-            fieldType,
-            generatedComponentModel.getUniqueFieldName(contributionBindingField.name()));
+            fieldType, componentImplementation.getUniqueFieldName(contributionBindingField.name()));
     contributionField.addModifiers(PRIVATE);
-    if (useRawType && !specificType().isPresent()) {
+    if (rawTypeUsed) {
       contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
+
+    if (isReplacingSuperclassFrameworkInstance()) {
+      // If a binding is modified in a subclass, the framework instance will be replaced in the
+      // subclass implementation. The superclass framework instance initialization will run first,
+      // however, and may refer to the modifiable binding method returning this type's modified
+      // framework instance before it is initialized, so we use a delegate factory as a placeholder
+      // until it has properly been initialized.
+      contributionField.initializer("new $T<>()", delegateType());
+    }
+
     fieldSpec = contributionField.build();
-    generatedComponentModel.addField(FRAMEWORK_FIELD, fieldSpec);
+    componentImplementation.addField(FRAMEWORK_FIELD, fieldSpec);
 
     return fieldSpec;
   }
 
+  /**
+   * Returns true if this framework field is replacing a superclass's implementation of the
+   * framework field.
+   */
+  private boolean isReplacingSuperclassFrameworkInstance() {
+    return componentImplementation
+        .superclassImplementation()
+        .flatMap(
+            superclassImplementation ->
+                // TODO(b/117833324): can we constrain this further?
+                superclassImplementation.getModifiableBindingMethod(
+                    BindingRequest.bindingRequest(
+                        resolvedBindings.key(),
+                        isProvider() ? FrameworkType.PROVIDER : FrameworkType.PRODUCER_NODE)))
+        .isPresent();
+  }
+
+  private Class<?> delegateType() {
+    return isProvider() ? DelegateFactory.class : DelegateProducer.class;
+  }
+
+  private boolean isProvider() {
+    return resolvedBindings.bindingType().equals(BindingType.PROVISION)
+        && frameworkInstanceCreationExpression
+            .alternativeFrameworkClass()
+            .map(TypeNames.PROVIDER::equals)
+            .orElse(true);
+  }
+
   /** Returns the type of the instance when it is a specific factory type. */
   @Override
   public Optional<TypeName> specificType() {
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 54284a738..d832ca432 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -45,8 +45,8 @@
 
   /**
    * The expression for the framework instance for this binding. The field will be {@link
-   * GeneratedComponentModel#addInitialization(CodeBlock) initialized} and {@link
-   * GeneratedComponentModel#addField(GeneratedComponentModel.FieldSpecKind, FieldSpec) added} to
+   * ComponentImplementation#addInitialization(CodeBlock) initialized} and {@link
+   * ComponentImplementation#addField(ComponentImplementation.FieldSpecKind, FieldSpec) added} to
    * the component the first time this method is invoked.
    */
   @Override
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/FrameworkType.java
index 05fcbcc69..0e279fce7 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/FrameworkType.java
@@ -48,8 +48,8 @@
     }
 
     @Override
-    RequestKind requestKind() {
-      return RequestKind.PROVIDER;
+    Optional<RequestKind> requestKind() {
+      return Optional.of(RequestKind.PROVIDER);
     }
 
     @Override
@@ -108,15 +108,18 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
   },
 
   /** A {@link Producer}. */
-  PRODUCER {
+  PRODUCER_NODE {
     @Override
     Class<?> frameworkClass() {
+      // TODO(cgdecker): Replace this with new class for representing internal producer nodes.
+      // Currently the new class is CancellableProducer, but it may be changed to ProducerNode and
+      // made to not implement Producer.
       return Producer.class;
     }
 
     @Override
-    RequestKind requestKind() {
-      return RequestKind.PRODUCER;
+    Optional<RequestKind> requestKind() {
+      return Optional.empty();
     }
 
     @Override
@@ -143,7 +146,7 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
               to(requestKind, from.codeBlock()));
 
         case PRODUCER:
-          return from;
+          return Expression.create(from.type(), to(requestKind, from.codeBlock()));
 
         default:
           throw new IllegalArgumentException(
@@ -159,7 +162,7 @@ static FrameworkType forBindingType(BindingType bindingType) {
       case PROVISION:
         return PROVIDER;
       case PRODUCTION:
-        return PRODUCER;
+        return PRODUCER_NODE;
       case MEMBERS_INJECTION:
     }
     throw new AssertionError(bindingType);
@@ -170,8 +173,6 @@ static FrameworkType forBindingType(BindingType bindingType) {
     switch (requestKind) {
       case PROVIDER:
         return Optional.of(FrameworkType.PROVIDER);
-      case PRODUCER:
-        return Optional.of(FrameworkType.PRODUCER);
       default:
         return Optional.empty();
     }
@@ -185,8 +186,8 @@ ParameterizedTypeName frameworkClassOf(TypeName valueType) {
     return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
   }
 
-  /** Returns the {@link RequestKind} matching this framework type. */
-  abstract RequestKind requestKind();
+  /** The request kind that an instance of this framework type can satisfy directly, if any. */
+  abstract Optional<RequestKind> requestKind();
 
   /**
    * Returns a {@link CodeBlock} that evaluates to a requested object given an expression that
diff --git a/java/dagger/internal/codegen/FrameworkTypeMapper.java b/java/dagger/internal/codegen/FrameworkTypeMapper.java
index d768ca79f..774669253 100644
--- a/java/dagger/internal/codegen/FrameworkTypeMapper.java
+++ b/java/dagger/internal/codegen/FrameworkTypeMapper.java
@@ -20,8 +20,6 @@
 import static dagger.internal.codegen.BindingType.PRODUCTION;
 import static java.util.stream.Collectors.toSet;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
@@ -58,7 +56,7 @@ public FrameworkType getFrameworkType(RequestKind requestKind) {
         case INSTANCE:
         case PRODUCED:
         case PRODUCER:
-          return FrameworkType.PRODUCER;
+          return FrameworkType.PRODUCER_NODE;
         case PROVIDER:
         case PROVIDER_OF_LAZY:
         case LAZY:
@@ -82,15 +80,6 @@ static FrameworkTypeMapper forBindingType(BindingType bindingType) {
   FrameworkType getFrameworkType(Set<DependencyRequest> requests) {
     Set<FrameworkType> frameworkTypes =
         requests.stream().map(request -> getFrameworkType(request.kind())).collect(toSet());
-    if (frameworkTypes.size() == 1) {
-      return getOnlyElement(frameworkTypes);
-    } else if (frameworkTypes.equals(CONTRIBUTION_TYPES)) {
-      return FrameworkType.PROVIDER;
-    } else {
-      throw new IllegalArgumentException("Bad set of framework classes: " + frameworkTypes);
-    }
+    return frameworkTypes.size() == 1 ? getOnlyElement(frameworkTypes) : FrameworkType.PROVIDER;
   }
-
-  private static final ImmutableSet<FrameworkType> CONTRIBUTION_TYPES =
-      Sets.immutableEnumSet(FrameworkType.PROVIDER, FrameworkType.PRODUCER);
 }
diff --git a/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
deleted file mode 100644
index a5a99f8a2..000000000
--- a/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import java.util.Optional;
-
-/**
- * An {@link ModifiableAbstractMethodBindingExpression} for a binding that requires an instance of a
- * generated type. This expression is used in abstract implementations of a subcomponent when there
- * are no concrete definitions of generated types available. The (unimplemented) method is added to
- * the {@code GeneratedComponentModel} when this dependency expression is requested. The method is
- * overridden when generating the concrete implementation of an ancestor component.
- */
-final class GeneratedInstanceBindingExpression extends ModifiableAbstractMethodBindingExpression {
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ContributionBinding binding;
-  private final BindingRequest request;
-
-  GeneratedInstanceBindingExpression(
-      GeneratedComponentModel generatedComponentModel,
-      ResolvedBindings resolvedBindings,
-      BindingRequest request,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
-      Optional<ComponentMethodDescriptor> matchingComponentMethod) {
-    super(
-        generatedComponentModel,
-        ModifiableBindingType.GENERATED_INSTANCE,
-        request,
-        matchingModifiableBindingMethod,
-        matchingComponentMethod);
-    this.generatedComponentModel = generatedComponentModel;
-    this.binding = resolvedBindings.contributionBinding();
-    this.request = request;
-  }
-
-  @Override
-  String chooseMethodName() {
-    return generatedComponentModel.getUniqueMethodName(request, binding);
-  }
-}
diff --git a/java/dagger/internal/codegen/HjarSourceFileGenerator.java b/java/dagger/internal/codegen/HjarSourceFileGenerator.java
new file mode 100644
index 000000000..9e3a14c60
--- /dev/null
+++ b/java/dagger/internal/codegen/HjarSourceFileGenerator.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Optional;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+
+/**
+ * A source file generator that only writes the relevant code necessary for Bazel to create a
+ * correct header (ABI) jar.
+ */
+final class HjarSourceFileGenerator<T> extends SourceFileGenerator<T> {
+  private final SourceFileGenerator<T> delegate;
+
+  private HjarSourceFileGenerator(SourceFileGenerator<T> delegate) {
+    super(delegate);
+    this.delegate = delegate;
+  }
+
+  static <T> SourceFileGenerator<T> wrap(SourceFileGenerator<T> delegate) {
+    return new HjarSourceFileGenerator<>(delegate);
+  }
+
+  @Override
+  ClassName nameGeneratedType(T input) {
+    return delegate.nameGeneratedType(input);
+  }
+
+  @Override
+  Element originatingElement(T input) {
+    return delegate.originatingElement(input);
+  }
+
+  @Override
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, T input) {
+    return delegate
+        .write(generatedTypeName, input)
+        .map(completeType -> skeletonType(completeType.build()));
+  }
+
+  private TypeSpec.Builder skeletonType(TypeSpec completeType) {
+    TypeSpec.Builder skeleton =
+        classBuilder(completeType.name)
+            .addSuperinterfaces(completeType.superinterfaces)
+            .addTypeVariables(completeType.typeVariables);
+
+    if (!completeType.superclass.equals(ClassName.OBJECT)) {
+      skeleton.superclass(completeType.superclass);
+    }
+
+    completeType.modifiers.forEach(skeleton::addModifiers);
+
+    completeType.methodSpecs.stream()
+        .filter(method -> !method.modifiers.contains(PRIVATE) || method.isConstructor())
+        .map(this::skeletonMethod)
+        .forEach(skeleton::addMethod);
+
+    completeType.fieldSpecs.stream()
+        .filter(field -> !field.modifiers.contains(PRIVATE))
+        .map(this::skeletonField)
+        .forEach(skeleton::addField);
+
+    completeType.typeSpecs.stream()
+        .map(type -> skeletonType(type).build())
+        .forEach(skeleton::addType);
+
+    return skeleton;
+  }
+
+  private MethodSpec skeletonMethod(MethodSpec completeMethod) {
+    MethodSpec.Builder skeleton =
+        completeMethod.isConstructor()
+            ? constructorBuilder()
+            : methodBuilder(completeMethod.name).returns(completeMethod.returnType);
+
+    if (completeMethod.isConstructor()) {
+      // Code in Turbine must (for technical reasons in javac) have a valid super() call for
+      // constructors, otherwise javac will bark, and Turbine has no way to avoid this. So we retain
+      // constructor method bodies if they do exist
+      skeleton.addCode(completeMethod.code);
+    }
+
+    return skeleton
+        .addModifiers(completeMethod.modifiers)
+        .addTypeVariables(completeMethod.typeVariables)
+        .addParameters(completeMethod.parameters)
+        .addExceptions(completeMethod.exceptions)
+        .varargs(completeMethod.varargs)
+        .build();
+  }
+
+  private FieldSpec skeletonField(FieldSpec completeField) {
+    return FieldSpec.builder(
+            completeField.type,
+            completeField.name,
+            completeField.modifiers.toArray(new Modifier[0]))
+        .build();
+  }
+}
diff --git a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
index 661063425..d4e082021 100644
--- a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
+++ b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -50,7 +51,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   private CodeBlock instanceExpression(ClassName requestingClass) {
     Expression expression =
         componentBindingExpressions.getDependencyExpression(
-            key, RequestKind.INSTANCE, requestingClass);
+            bindingRequest(key, RequestKind.INSTANCE), requestingClass);
     // Java 7 type inference is not as strong as in Java 8, and therefore some generated code must
     // cast.
     //
diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
index 17b8c7eb2..984b686e1 100644
--- a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
@@ -19,6 +19,7 @@
 import static dagger.internal.codegen.DaggerElements.closestEnclosingTypeElement;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.Scopes.getReadableSource;
+import static dagger.model.BindingKind.INJECTION;
 import static java.util.stream.Collectors.joining;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
@@ -27,12 +28,13 @@
 import com.google.common.collect.Multimaps;
 import dagger.model.Binding;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
+import javax.tools.Diagnostic;
 
 /**
  * Reports an error for any component that uses bindings with scopes that are not assigned to the
@@ -41,10 +43,13 @@
 final class IncompatiblyScopedBindingsValidator implements BindingGraphPlugin {
 
   private final MethodSignatureFormatter methodSignatureFormatter;
+  private final CompilerOptions compilerOptions;
 
   @Inject
-  IncompatiblyScopedBindingsValidator(MethodSignatureFormatter methodSignatureFormatter) {
+  IncompatiblyScopedBindingsValidator(
+      MethodSignatureFormatter methodSignatureFormatter, CompilerOptions compilerOptions) {
     this.methodSignatureFormatter = methodSignatureFormatter;
+    this.compilerOptions = compilerOptions;
   }
 
   @Override
@@ -54,51 +59,65 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    ImmutableSetMultimap.Builder<ComponentNode, BindingNode> incompatibleBindingNodes =
+    ImmutableSetMultimap.Builder<ComponentNode, dagger.model.Binding> incompatibleBindings =
         ImmutableSetMultimap.builder();
-    for (BindingNode bindingNode : bindingGraph.bindingNodes()) {
-      bindingNode
-          .binding()
+    for (dagger.model.Binding binding : bindingGraph.bindings()) {
+      binding
           .scope()
+          .filter(scope -> !scope.isReusable())
           .ifPresent(
               scope -> {
-                if (scope.isReusable()) {
-                  return;
-                }
                 ComponentNode componentNode =
-                    bindingGraph.componentNode(bindingNode.componentPath()).get();
+                    bindingGraph.componentNode(binding.componentPath()).get();
                 if (!componentNode.scopes().contains(scope)) {
-                  incompatibleBindingNodes.put(componentNode, bindingNode);
+                  // @Inject bindings in module binding graphs will appear at the properly scoped
+                  // ancestor component, so ignore them here.
+                  if (binding.kind().equals(INJECTION) && bindingGraph.isModuleBindingGraph()) {
+                    return;
+                  }
+                  incompatibleBindings.put(componentNode, binding);
                 }
               });
     }
-    Multimaps.asMap(incompatibleBindingNodes.build())
+    Multimaps.asMap(incompatibleBindings.build())
         .forEach(
-            (componentNode, bindingNodes) ->
-                diagnosticReporter.reportComponent(
-                    ERROR,
-                    componentNode,
-                    incompatibleBindingScopesError(componentNode, bindingNodes)));
+            (componentNode, bindings) ->
+                report(componentNode, bindings, bindingGraph, diagnosticReporter));
   }
 
-  private String incompatibleBindingScopesError(
-      ComponentNode componentNode, Set<BindingNode> bindingNodes) {
+  private void report(
+      ComponentNode componentNode,
+      Set<Binding> bindings,
+      BindingGraph bindingGraph,
+      DiagnosticReporter diagnosticReporter) {
+    Diagnostic.Kind diagnosticKind = ERROR;
     StringBuilder message =
         new StringBuilder(componentNode.componentPath().currentComponent().getQualifiedName());
-    if (!componentNode.scopes().isEmpty()) {
+
+    if (bindingGraph.isModuleBindingGraph() && componentNode.componentPath().atRoot()) {
+      // The root "component" of a module binding graph is a module, which will have no scopes
+      // attached. We want to report if there is more than one scope in that component.
+      if (bindings.stream().map(Binding::scope).map(Optional::get).distinct().count() <= 1) {
+        return;
+      }
+      message.append(" contains bindings with different scopes:");
+      diagnosticKind = compilerOptions.moduleHasDifferentScopesDiagnosticKind();
+    } else if (componentNode.scopes().isEmpty()) {
+      message.append(" (unscoped) may not reference scoped bindings:");
+    } else {
       message
           .append(" scoped with ")
           .append(
               componentNode.scopes().stream().map(Scopes::getReadableSource).collect(joining(" ")))
-          .append(" may not reference bindings with different scopes:\n");
-    } else {
-      message.append(" (unscoped) may not reference scoped bindings:\n");
+          .append(" may not reference bindings with different scopes:");
     }
+
     // TODO(ronshapiro): Should we group by scope?
-    for (BindingNode bindingNode : bindingNodes) {
-      message.append(INDENT);
+    for (Binding binding : bindings) {
+      message.append('\n').append(INDENT);
 
-      Binding binding = bindingNode.binding();
+      // TODO(dpb): Use BindingDeclarationFormatter.
+      // But that doesn't print scopes for @Inject-constructed types.
       switch (binding.kind()) {
         case DELEGATE:
         case PROVISION:
@@ -116,11 +135,9 @@ private String incompatibleBindingScopesError(
           break;
 
         default:
-          throw new AssertionError(bindingNode);
+          throw new AssertionError(binding);
       }
-
-      message.append("\n");
     }
-    return message.toString();
+    diagnosticReporter.reportComponent(diagnosticKind, componentNode, message.toString());
   }
 }
diff --git a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
deleted file mode 100644
index 5df3b9a2f..000000000
--- a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkState;
-import static java.util.stream.Collectors.toCollection;
-import static javax.tools.Diagnostic.Kind.WARNING;
-
-import com.google.common.collect.Iterables;
-import com.google.common.collect.MultimapBuilder;
-import com.google.common.collect.SetMultimap;
-import com.google.common.graph.EndpointPair;
-import com.google.common.graph.Graphs;
-import com.google.common.graph.ImmutableGraph;
-import com.google.common.graph.ImmutableNetwork;
-import com.google.common.graph.MutableNetwork;
-import com.google.common.graph.NetworkBuilder;
-import dagger.Binds;
-import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
-import dagger.model.BindingGraph.DependencyEdge;
-import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.Node;
-import dagger.model.ComponentPath;
-import dagger.multibindings.IntoSet;
-import dagger.spi.BindingGraphPlugin;
-import dagger.spi.DiagnosticReporter;
-import java.util.LinkedHashSet;
-import java.util.Map.Entry;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-/**
- * Prints warnings to help users debug <a
- * href="https://github.com/google/dagger/wiki/Dagger-2.17-@Binds-bugs">the floating {@code @Binds}
- * bug</a>.
- */
-@Singleton
-final class IncorrectlyInstalledBindsMethodsValidator implements BindingGraphPlugin {
-  private final SetMultimap<ComponentPath, ContributionBinding> incorrectlyInstalledBindingsCache =
-      MultimapBuilder.hashKeys().linkedHashSetValues().build();
-  private final CompilerOptions compilerOptions;
-
-  @Inject
-  IncorrectlyInstalledBindsMethodsValidator(CompilerOptions compilerOptions) {
-    this.compilerOptions = compilerOptions;
-  }
-
-  @Override
-  public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    checkState(
-        compilerOptions.floatingBindsMethods() || incorrectlyInstalledBindingsCache.isEmpty());
-    for (Entry<ComponentPath, ContributionBinding> entry :
-        incorrectlyInstalledBindingsCache.entries()) {
-      ComponentPath idealComponentPath = entry.getKey();
-      ContributionBinding incorrectlyInstalledBinding = entry.getValue();
-      graph
-          .bindingNodes(incorrectlyInstalledBinding.key())
-          .stream()
-          .filter(bindingNode -> bindingNode.binding().equals(incorrectlyInstalledBinding))
-          .forEach(
-              bindingNode -> report(bindingNode, idealComponentPath, graph, diagnosticReporter));
-    }
-  }
-
-  private void report(
-      BindingNode incompatiblyInstalledBinding,
-      ComponentPath idealComponentPath,
-      BindingGraph graph,
-      DiagnosticReporter diagnosticReporter) {
-    // TODO(dpb): consider creating this once per visitGraph()
-    ImmutableGraph<Node> dependencyGraph = dependencyGraph(graph).asGraph();
-    Set<Node> culpableDependencies =
-        Graphs.reachableNodes(dependencyGraph, incompatiblyInstalledBinding)
-            .stream()
-            .filter(node -> isChild(idealComponentPath, node.componentPath()))
-            .filter(node -> !node.equals(incompatiblyInstalledBinding))
-            .collect(toCollection(LinkedHashSet::new));
-    if (culpableDependencies.isEmpty()) {
-      return;
-    }
-    StringBuilder warning =
-        new StringBuilder()
-            .append("Floating @Binds method detected:\n  ")
-            .append(incompatiblyInstalledBinding)
-            .append("\n  It is installed in:       ")
-            .append(idealComponentPath)
-            .append("\n  But is being resolved in: ")
-            .append(incompatiblyInstalledBinding.componentPath())
-            .append("\n  This is because it depends transitively on:");
-
-    while (!culpableDependencies.isEmpty()) {
-      BindingNode culpableDependency = (BindingNode) Iterables.get(culpableDependencies, 0);
-      warning
-          .append("\n      ")
-          .append(culpableDependency)
-          .append(", resolved in: ")
-          .append(culpableDependency.componentPath());
-      culpableDependencies.removeAll(Graphs.reachableNodes(dependencyGraph, culpableDependency));
-    }
-
-    diagnosticReporter.reportComponent(WARNING, graph.rootComponentNode(), warning.toString());
-  }
-
-  private boolean isChild(ComponentPath possibleParent, ComponentPath possibleChild) {
-    return !possibleParent.equals(possibleChild)
-        && possibleChild.components().containsAll(possibleParent.components());
-  }
-
-  private ImmutableNetwork<Node, Edge> dependencyGraph(BindingGraph graph) {
-    MutableNetwork<Node, Edge> dependencyGraph = NetworkBuilder.from(graph).build();
-    for (DependencyEdge dependencyEdge : graph.dependencyEdges()) {
-      EndpointPair<Node> endpoint = graph.incidentNodes(dependencyEdge);
-      dependencyGraph.addEdge(endpoint.source(), endpoint.target(), dependencyEdge);
-    }
-    return ImmutableNetwork.copyOf(dependencyGraph);
-  }
-
-  void recordBinding(ComponentPath componentPath, ContributionBinding binding) {
-    incorrectlyInstalledBindingsCache.put(componentPath, binding);
-  }
-
-  @dagger.Module
-  interface Module {
-    @Binds
-    @IntoSet
-    @Validation
-    BindingGraphPlugin validator(IncorrectlyInstalledBindsMethodsValidator validator);
-  }
-}
diff --git a/java/dagger/android/ServiceKey.java b/java/dagger/internal/codegen/InjectBindingRegistryModule.java
similarity index 54%
rename from java/dagger/android/ServiceKey.java
rename to java/dagger/internal/codegen/InjectBindingRegistryModule.java
index 834868c53..45633620d 100644
--- a/java/dagger/android/ServiceKey.java
+++ b/java/dagger/internal/codegen/InjectBindingRegistryModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Dagger Authors.
+ * Copyright (C) 2018 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,21 +14,13 @@
  * limitations under the License.
  */
 
-package dagger.android;
+package dagger.internal.codegen;
 
-import static java.lang.annotation.ElementType.METHOD;
+import dagger.Binds;
+import dagger.Module;
 
-import android.app.Service;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/** {@link MapKey} annotation to key bindings by a type of a {@link Service}. */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-public @interface ServiceKey {
-  Class<? extends Service> value();
+@Module
+interface InjectBindingRegistryModule {
+  @Binds
+  InjectBindingRegistry injectBindingRegistry(InjectBindingRegistryImpl impl);
 }
diff --git a/java/dagger/internal/codegen/InjectBindingValidator.java b/java/dagger/internal/codegen/InjectBindingValidator.java
index a275bcbe4..183d16200 100644
--- a/java/dagger/internal/codegen/InjectBindingValidator.java
+++ b/java/dagger/internal/codegen/InjectBindingValidator.java
@@ -21,7 +21,6 @@
 import com.google.auto.common.MoreTypes;
 import dagger.internal.codegen.ValidationReport.Item;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
 import javax.inject.Inject;
@@ -44,12 +43,13 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    bindingGraph.bindingNodes().stream()
-        .filter(node -> node.binding().kind().equals(INJECTION)) // TODO(dpb): Move to BindingGraph
-        .forEach(node -> validateInjectionBinding(node, diagnosticReporter));
+    bindingGraph.bindings().stream()
+        .filter(binding -> binding.kind().equals(INJECTION)) // TODO(dpb): Move to BindingGraph
+        .forEach(binding -> validateInjectionBinding(binding, diagnosticReporter));
   }
 
-  private void validateInjectionBinding(BindingNode node, DiagnosticReporter diagnosticReporter) {
+  private void validateInjectionBinding(
+      dagger.model.Binding node, DiagnosticReporter diagnosticReporter) {
     ValidationReport<TypeElement> typeReport =
         injectValidator.validateType(MoreTypes.asTypeElement(node.key().type()));
     for (Item item : typeReport.allItems()) {
diff --git a/java/dagger/internal/codegen/InjectProcessingStep.java b/java/dagger/internal/codegen/InjectProcessingStep.java
index 5ea414ef3..be8c975a1 100644
--- a/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -16,72 +16,61 @@
 
 package dagger.internal.codegen;
 
-import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.ElementKindVisitor6;
+import javax.lang.model.util.ElementKindVisitor8;
 
 /**
  * An annotation processor for generating Dagger implementation code based on the {@link Inject}
  * annotation.
  */
-final class InjectProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
-  private final InjectBindingRegistry injectBindingRegistry;
+// TODO(gak): add some error handling for bad source files
+final class InjectProcessingStep extends TypeCheckingProcessingStep<Element> {
+  private final ElementVisitor<Void, Void> visitor;
 
   @Inject
   InjectProcessingStep(InjectBindingRegistry injectBindingRegistry) {
-    this.injectBindingRegistry = injectBindingRegistry;
+    super(e -> e);
+    this.visitor =
+        new ElementKindVisitor8<Void, Void>() {
+          @Override
+          public Void visitExecutableAsConstructor(
+              ExecutableElement constructorElement, Void aVoid) {
+            injectBindingRegistry.tryRegisterConstructor(constructorElement);
+            return null;
+          }
+
+          @Override
+          public Void visitVariableAsField(VariableElement fieldElement, Void aVoid) {
+            injectBindingRegistry.tryRegisterMembersInjectedType(
+                MoreElements.asType(fieldElement.getEnclosingElement()));
+            return null;
+          }
+
+          @Override
+          public Void visitExecutableAsMethod(ExecutableElement methodElement, Void aVoid) {
+            injectBindingRegistry.tryRegisterMembersInjectedType(
+                MoreElements.asType(methodElement.getEnclosingElement()));
+            return null;
+          }
+        };
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(Inject.class);
+    return ImmutableSet.of(Inject.class);
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-    // TODO(gak): add some error handling for bad source files
-
-    for (Element injectElement : elementsByAnnotation.get(Inject.class)) {
-      try {
-        injectElement.accept(
-            new ElementKindVisitor6<Void, Void>() {
-              @Override
-              public Void visitExecutableAsConstructor(
-                  ExecutableElement constructorElement, Void v) {
-                injectBindingRegistry.tryRegisterConstructor(constructorElement);
-                return null;
-              }
-
-              @Override
-              public Void visitVariableAsField(VariableElement fieldElement, Void p) {
-                injectBindingRegistry.tryRegisterMembersInjectedType(
-                    MoreElements.asType(fieldElement.getEnclosingElement()));
-                return null;
-              }
-
-              @Override
-              public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-                injectBindingRegistry.tryRegisterMembersInjectedType(
-                    MoreElements.asType(methodElement.getEnclosingElement()));
-                return null;
-              }
-            },
-            null);
-      } catch (TypeNotPresentException e) {
-        rejectedElements.add(injectElement);
-      }
-    }
-
-    return rejectedElements.build();
+  protected void process(
+      Element injectElement, ImmutableSet<Class<? extends Annotation>> annotations) {
+    injectElement.accept(visitor, null);
   }
 }
diff --git a/java/dagger/internal/codegen/InjectValidator.java b/java/dagger/internal/codegen/InjectValidator.java
index b912fcbcd..2c83f3730 100644
--- a/java/dagger/internal/codegen/InjectValidator.java
+++ b/java/dagger/internal/codegen/InjectValidator.java
@@ -82,17 +82,18 @@ private InjectValidator(
 
   /**
    * Returns a new validator that performs the same validation as this one, but is strict about
-   * rejecting optionally-specified JSR 330 behavior that Dagger doesn't support.
+   * rejecting optionally-specified JSR 330 behavior that Dagger doesn't support (unless {@code
+   * -Adagger.ignorePrivateAndStaticInjectionForComponent=enabled} was set in the javac options).
    */
   InjectValidator whenGeneratingCode() {
     return compilerOptions.ignorePrivateAndStaticInjectionForComponent()
-        ? new InjectValidator(
+        ? this
+        : new InjectValidator(
             types,
             elements,
             compilerOptions,
             dependencyRequestValidator,
-            Optional.of(Diagnostic.Kind.ERROR))
-        : this;
+            Optional.of(Diagnostic.Kind.ERROR));
   }
 
   ValidationReport<TypeElement> validateConstructor(ExecutableElement constructorElement) {
@@ -124,8 +125,7 @@ InjectValidator whenGeneratingCode() {
     if (throwsCheckedExceptions(constructorElement)) {
       builder.addItem(
           "Dagger does not support checked exceptions on @Inject constructors",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
+          privateMemberDiagnosticKind(),
           constructorElement);
     }
 
@@ -178,16 +178,14 @@ InjectValidator whenGeneratingCode() {
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
           "Dagger does not support injection into private fields",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
+          privateMemberDiagnosticKind(),
           fieldElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
           "Dagger does not support injection into static fields",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.staticMemberValidationKind()),
+          staticMemberDiagnosticKind(),
           fieldElement);
     }
 
@@ -206,16 +204,14 @@ InjectValidator whenGeneratingCode() {
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
           "Dagger does not support injection into private methods",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
+          privateMemberDiagnosticKind(),
           methodElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
           "Dagger does not support injection into static methods",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.staticMemberValidationKind()),
+          staticMemberDiagnosticKind(),
           methodElement);
     }
 
@@ -317,9 +313,18 @@ private void checkInjectIntoPrivateClass(Element element, Builder<TypeElement> b
         DaggerElements.closestEnclosingTypeElement(element))) {
       builder.addItem(
           "Dagger does not support injection into private classes",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
+          privateMemberDiagnosticKind(),
           element);
     }
   }
+
+  private Diagnostic.Kind privateMemberDiagnosticKind() {
+    return privateAndStaticInjectionDiagnosticKind.orElse(
+        compilerOptions.privateMemberValidationKind());
+  }
+
+  private Diagnostic.Kind staticMemberDiagnosticKind() {
+    return privateAndStaticInjectionDiagnosticKind.orElse(
+        compilerOptions.staticMemberValidationKind());
+  }
 }
diff --git a/java/dagger/internal/codegen/InjectionMethods.java b/java/dagger/internal/codegen/InjectionMethods.java
index 5d6e0c0ac..a4190247d 100644
--- a/java/dagger/internal/codegen/InjectionMethods.java
+++ b/java/dagger/internal/codegen/InjectionMethods.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
@@ -174,16 +175,32 @@ private static MethodSpec constructorProxy(ExecutableElement constructor) {
      * requires the use of an injection method.
      */
     static boolean requiresInjectionMethod(
-        ProvisionBinding binding, CompilerOptions compilerOptions, String callingPackage) {
+        ProvisionBinding binding,
+        ImmutableList<Expression> arguments,
+        CompilerOptions compilerOptions,
+        String callingPackage,
+        DaggerTypes types) {
       ExecutableElement method = MoreElements.asExecutable(binding.bindingElement().get());
       return !binding.injectionSites().isEmpty()
           || binding.shouldCheckForNull(compilerOptions)
           || !isElementAccessibleFrom(method, callingPackage)
-          || method
-          .getParameters()
-          .stream()
-          .map(VariableElement::asType)
-          .anyMatch(type -> !isRawTypeAccessible(type, callingPackage));
+          || !areParametersAssignable(method, arguments, types)
+          // This check should be removable once we drop support for -source 7
+          || method.getParameters().stream()
+              .map(VariableElement::asType)
+              .anyMatch(type -> !isRawTypeAccessible(type, callingPackage));
+    }
+
+    private static boolean areParametersAssignable(
+        ExecutableElement element, ImmutableList<Expression> arguments, DaggerTypes types) {
+      List<? extends VariableElement> parameters = element.getParameters();
+      checkArgument(parameters.size() == arguments.size());
+      for (int i = 0; i < parameters.size(); i++) {
+        if (!types.isAssignable(arguments.get(i).type(), parameters.get(i).asType())) {
+          return false;
+        }
+      }
+      return true;
     }
 
     /**
diff --git a/java/dagger/internal/codegen/InnerSwitchingProviders.java b/java/dagger/internal/codegen/InnerSwitchingProviders.java
index c3c590e3f..91c131773 100644
--- a/java/dagger/internal/codegen/InnerSwitchingProviders.java
+++ b/java/dagger/internal/codegen/InnerSwitchingProviders.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.model.RequestKind.INSTANCE;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -38,10 +39,10 @@
   private final DaggerTypes types;
 
   InnerSwitchingProviders(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types) {
-    super(generatedComponentModel, types);
+    super(componentImplementation, types);
     this.componentBindingExpressions = componentBindingExpressions;
     this.types = types;
   }
@@ -87,17 +88,17 @@ public Key key() {
     }
 
     @Override
-    public Expression getProviderExpression(ClassName switchType, int switchId) {
+    public Expression getProviderExpression(ClassName switchingProviderClass, int switchId) {
       TypeMirror instanceType = types.accessibleType(binding.contributedType(), requestingClass);
       return Expression.create(
           types.wrapType(instanceType, Provider.class),
-          CodeBlock.of("new $T<>($L)", switchType, switchId));
+          CodeBlock.of("new $T<>($L)", switchingProviderClass, switchId));
     }
 
     @Override
-    public Expression getReturnExpression() {
+    public Expression getReturnExpression(ClassName switchingProviderClass) {
       return componentBindingExpressions.getDependencyExpression(
-          binding.key(), INSTANCE, requestingClass);
+          bindingRequest(binding.key(), INSTANCE), switchingProviderClass);
     }
   }
 }
diff --git a/java/dagger/internal/codegen/JavacPluginModule.java b/java/dagger/internal/codegen/JavacPluginModule.java
new file mode 100644
index 000000000..1bc1e36ba
--- /dev/null
+++ b/java/dagger/internal/codegen/JavacPluginModule.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.sun.tools.javac.model.JavacElements;
+import com.sun.tools.javac.model.JavacTypes;
+import com.sun.tools.javac.util.Context;
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.codegen.ProcessingEnvironmentModule.ElementsModule;
+import javax.annotation.processing.Messager;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
+/**
+ * A module that provides a {@link BindingGraphFactory} and {@link ComponentDescriptor.Factory} for
+ * use in {@code javac} plugins. Requires a binding for the {@code javac} {@link Context}.
+ */
+@Module(includes = {InjectBindingRegistryModule.class, ElementsModule.class})
+abstract class JavacPluginModule {
+  @Provides
+  static CompilerOptions compilerOptions() {
+    return CompilerOptions.builder()
+        .usesProducers(true)
+        .writeProducerNameInToken(true)
+        .nullableValidationKind(Diagnostic.Kind.NOTE)
+        .privateMemberValidationKind(Diagnostic.Kind.NOTE)
+        .staticMemberValidationKind(Diagnostic.Kind.NOTE)
+        .ignorePrivateAndStaticInjectionForComponent(false)
+        .scopeCycleValidationType(ValidationType.NONE)
+        .warnIfInjectionFactoryNotGeneratedUpstream(false)
+        .fastInit(false)
+        .experimentalAndroidMode2(false)
+        .aheadOfTimeSubcomponents(false)
+        .moduleBindingValidationType(ValidationType.NONE)
+        .moduleHasDifferentScopesDiagnosticKind(Diagnostic.Kind.NOTE)
+        .build()
+        .validate();
+  }
+
+  @Binds
+  abstract Messager messager(NullMessager nullMessager);
+
+  static final class NullMessager implements Messager {
+
+    @Inject
+    NullMessager() {}
+
+    @Override
+    public void printMessage(Diagnostic.Kind kind, CharSequence charSequence) {}
+
+    @Override
+    public void printMessage(Diagnostic.Kind kind, CharSequence charSequence, Element element) {}
+
+    @Override
+    public void printMessage(
+        Diagnostic.Kind kind,
+        CharSequence charSequence,
+        Element element,
+        AnnotationMirror annotationMirror) {}
+
+    @Override
+    public void printMessage(
+        Diagnostic.Kind kind,
+        CharSequence charSequence,
+        Element element,
+        AnnotationMirror annotationMirror,
+        AnnotationValue annotationValue) {}
+  }
+
+  @Provides
+  static DaggerElements daggerElements(Context javaContext) {
+    return new DaggerElements(
+        JavacElements.instance(javaContext), JavacTypes.instance(javaContext));
+  }
+
+  @Provides
+  static DaggerTypes daggerTypes(Context javaContext, DaggerElements elements) {
+    return new DaggerTypes(JavacTypes.instance(javaContext), elements);
+  }
+
+  @Binds abstract Types types(DaggerTypes daggerTypes);
+
+  private JavacPluginModule() {}
+}
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index 645c2193e..2ff8957e2 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -30,26 +30,22 @@
 import static dagger.internal.codegen.Optionals.firstPresent;
 import static dagger.internal.codegen.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
+import static java.util.Arrays.asList;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.model.Key;
 import dagger.model.Key.MultibindingContributionIdentifier;
 import dagger.model.RequestKind;
-import dagger.model.Scope;
 import dagger.multibindings.Multibinds;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Production;
 import dagger.producers.internal.ProductionImplementation;
 import dagger.producers.monitoring.ProductionComponentMonitor;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
@@ -99,11 +95,6 @@ private TypeMirror mapOfFrameworkType(
     return mapOf(keyType, types.getDeclaredType(frameworkType, boxPrimitives(valueType)));
   }
 
-  private DeclaredType typedReleasableReferenceManagerOf(DeclaredType metadataType) {
-    return types.getDeclaredType(
-        getClassElement(TypedReleasableReferenceManager.class), metadataType);
-  }
-
   Key forComponentMethod(ExecutableElement componentMethod) {
     checkArgument(componentMethod.getKind().equals(METHOD));
     return forMethod(componentMethod, componentMethod.getReturnType());
@@ -119,16 +110,16 @@ Key forProductionComponentMethod(ExecutableElement componentMethod) {
     return forMethod(componentMethod, keyType);
   }
 
-  Key forSubcomponentBuilderMethod(
-      ExecutableElement subcomponentBuilderMethod, DeclaredType declaredContainer) {
-    checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+  Key forSubcomponentCreatorMethod(
+      ExecutableElement subcomponentCreatorMethod, DeclaredType declaredContainer) {
+    checkArgument(subcomponentCreatorMethod.getKind().equals(METHOD));
     ExecutableType resolvedMethod =
-        asExecutable(types.asMemberOf(declaredContainer, subcomponentBuilderMethod));
+        asExecutable(types.asMemberOf(declaredContainer, subcomponentCreatorMethod));
     return Key.builder(resolvedMethod.getReturnType()).build();
   }
 
-  Key forSubcomponentBuilder(TypeMirror builderType) {
-    return Key.builder(builderType).build();
+  Key forSubcomponentCreator(TypeMirror creatorType) {
+    return Key.builder(creatorType).build();
   }
 
   Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
@@ -318,29 +309,26 @@ Key forProductionComponentMonitor() {
   }
 
   /**
-   * Keys for map contributions from {@link dagger.Provides} and {@link dagger.producers.Produces}
-   * are in the form {@code Map<K, Framework<V>>}, but keys for {@link Binds} methods are just
-   * {@code Map<K, V>} since the framework type is not known until graph resolution. This
-   * translates from the {@code @Provides}/{@code @Produces} format into the {@code @Binds}
-   * format. If {@link Key#type() possibleMapKey.type()} is not a {@code Map<K, Framework<V>>},
-   * returns {@code possibleMapKey}.
+   * If {@code key}'s type is {@code Map<K, Provider<V>>}, {@code Map<K, Producer<V>>}, or {@code
+   * Map<K, Produced<V>>}, returns a key with the same qualifier and {@link
+   * Key#multibindingContributionIdentifier()} whose type is simply {@code Map<K, V>}.
+   *
+   * <p>Otherwise, returns {@code key}.
    */
-  Key convertToDelegateKey(Key possibleMapKey) {
-    if (!MapType.isMap(possibleMapKey)) {
-      return possibleMapKey;
-    }
-    MapType mapType = MapType.from(possibleMapKey);
-    TypeMirror wrappedValueType;
-    if (mapType.isRawType()) {
-      return possibleMapKey;
-    } else if (mapType.valuesAreTypeOf(Provider.class)) {
-      wrappedValueType = mapType.unwrappedValueType(Provider.class);
-    } else if (mapType.valuesAreTypeOf(Producer.class)) {
-      wrappedValueType = mapType.unwrappedValueType(Producer.class);
-    } else {
-      return possibleMapKey;
+  Key unwrapMapValueType(Key key) {
+    if (MapType.isMap(key)) {
+      MapType mapType = MapType.from(key);
+      if (!mapType.isRawType()) {
+        for (Class<?> frameworkClass : asList(Provider.class, Producer.class, Produced.class)) {
+          if (mapType.valuesAreTypeOf(frameworkClass)) {
+            return key.toBuilder()
+                .type(mapOf(mapType.keyType(), mapType.unwrappedValueType(frameworkClass)))
+                .build();
+          }
+        }
+      }
     }
-    return possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build();
+    return key;
   }
 
   /**
@@ -441,39 +429,4 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
             .type(extractKeyType(getRequestKind(optionalValueType), optionalValueType))
             .build());
   }
-
-  /** Returns a key for a {@code @ForReleasableReferences(scope) ReleasableReferenceManager}. */
-  Key forReleasableReferenceManager(Scope scope) {
-    return forQualifiedType(
-        Optional.of(forReleasableReferencesAnnotationMirror(scope)),
-        getClassElement(ReleasableReferenceManager.class).asType());
-  }
-
-  /**
-   * Returns a key for a {@code @ForReleasableReferences(scope)
-   * TypedReleasableReferenceManager<metadataType>}
-   */
-  Key forTypedReleasableReferenceManager(Scope scope, DeclaredType metadataType) {
-    return Key.builder(typedReleasableReferenceManagerOf(metadataType))
-        .qualifier(forReleasableReferencesAnnotationMirror(scope))
-        .build();
-  }
-
-  /** Returns a key for a {@code Set<ReleasableReferenceManager>}. */
-  Key forSetOfReleasableReferenceManagers() {
-    return Key.builder(setOf(getClassElement(ReleasableReferenceManager.class).asType())).build();
-  }
-
-  /** Returns a key for a {@code Set<TypedReleasableReferenceManager<metadataType>}. */
-  Key forSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
-    return forQualifiedType(
-        Optional.empty(), setOf(typedReleasableReferenceManagerOf(metadataType)));
-  }
-
-  private AnnotationMirror forReleasableReferencesAnnotationMirror(Scope scope) {
-    return SimpleAnnotationMirror.of(
-        getClassElement(ForReleasableReferences.class),
-        ImmutableMap.of(
-            "value", new SimpleTypeAnnotationValue(scope.scopeAnnotationElement().asType())));
-  }
 }
diff --git a/java/dagger/internal/codegen/KeyVariableNamer.java b/java/dagger/internal/codegen/KeyVariableNamer.java
new file mode 100644
index 000000000..675498424
--- /dev/null
+++ b/java/dagger/internal/codegen/KeyVariableNamer.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentCreator;
+import static dagger.internal.codegen.SourceFiles.protectAgainstKeywords;
+
+import dagger.model.DependencyRequest;
+import dagger.model.Key;
+import java.util.Iterator;
+import javax.lang.model.element.Element;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.util.SimpleTypeVisitor8;
+
+/**
+ * Suggests a variable name for a type based on a {@link Key}. Prefer {@link BindingVariableNamer}
+ * for cases where a specific {@link Binding} is present, or {@link DependencyVariableNamer} for
+ * cases where a specific {@link DependencyRequest} is present.
+ */
+final class KeyVariableNamer {
+  private static final TypeVisitor<Void, StringBuilder> TYPE_NAMER =
+      new SimpleTypeVisitor8<Void, StringBuilder>() {
+        @Override
+        public Void visitDeclared(DeclaredType declaredType, StringBuilder builder) {
+          Element element = declaredType.asElement();
+          if (isSubcomponentCreator(element)) {
+            // Most Subcomponent builders are named "Builder", so add their associated
+            // Subcomponent type so that they're not all "builderProvider{N}"
+            builder.append(element.getEnclosingElement().getSimpleName());
+          }
+          builder.append(element.getSimpleName());
+          Iterator<? extends TypeMirror> argumentIterator =
+              declaredType.getTypeArguments().iterator();
+          if (argumentIterator.hasNext()) {
+            builder.append("Of");
+            TypeMirror first = argumentIterator.next();
+            first.accept(this, builder);
+            while (argumentIterator.hasNext()) {
+              builder.append("And");
+              argumentIterator.next().accept(this, builder);
+            }
+          }
+          return null;
+        }
+
+        @Override
+        public Void visitPrimitive(PrimitiveType type, StringBuilder builder) {
+          builder.append(LOWER_CAMEL.to(UPPER_CAMEL, type.toString()));
+          return null;
+        }
+
+        @Override
+        public Void visitArray(ArrayType type, StringBuilder builder) {
+          type.getComponentType().accept(this, builder);
+          builder.append("Array");
+          return null;
+        }
+      };
+
+  private KeyVariableNamer() {}
+
+  static String name(Key key) {
+    StringBuilder builder = new StringBuilder();
+
+    if (key.qualifier().isPresent()) {
+      // TODO(gak): Use a better name for fields with qualifiers with members.
+      builder.append(key.qualifier().get().getAnnotationType().asElement().getSimpleName());
+    }
+
+    key.type().accept(TYPE_NAMER, builder);
+
+    return protectAgainstKeywords(UPPER_CAMEL.to(LOWER_CAMEL, builder.toString()));
+  }
+}
diff --git a/java/dagger/internal/codegen/KytheBindingGraphFactory.java b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
deleted file mode 100644
index 10e67ec03..000000000
--- a/java/dagger/internal/codegen/KytheBindingGraphFactory.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import dagger.Component;
-import dagger.producers.ProductionComponent;
-import java.util.Optional;
-import javax.annotation.processing.Messager;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-
-/**
- * A factory of {@link BindingGraph}s for use by <a href="https://kythe.io">Kythe</a>.
- *
- * <p>This is <b>not</b> intended to be used by any other APIs/processors and is not part of any
- * supported API except for Kythe.
- */
-final class KytheBindingGraphFactory {
-  private final ComponentDescriptor.Factory componentDescriptorFactory;
-  private final BindingGraphFactory bindingGraphFactory;
-
-  @Inject
-  KytheBindingGraphFactory(Types types, Elements elements, CompilerOptions compilerOptions) {
-    DaggerElements daggerElements = new DaggerElements(elements, types);
-    DaggerTypes daggerTypes = new DaggerTypes(types, daggerElements);
-    this.componentDescriptorFactory =
-        createComponentDescriptorFactory(daggerElements, daggerTypes, compilerOptions);
-    this.bindingGraphFactory =
-        createBindingGraphFactory(daggerTypes, daggerElements, compilerOptions);
-  }
-
-  /**
-   * Creates a {@link BindingGraph} for {@code type} if it is annotated with a component annotation,
-   * otherwise returns {@link Optional#empty()}.
-   */
-  Optional<BindingGraph> create(TypeElement type) {
-    if (MoreElements.isAnnotationPresent(type, Component.class)
-        || MoreElements.isAnnotationPresent(type, ProductionComponent.class)) {
-      return Optional.of(bindingGraphFactory.create(componentDescriptorFactory.forComponent(type)));
-    }
-    return Optional.empty();
-  }
-
-  /** Creates the {@link CompilerOptions} for use during {@link BindingGraph} construction. */
-  static CompilerOptions createCompilerOptions() {
-    return CompilerOptions.builder()
-        .usesProducers(true)
-        .writeProducerNameInToken(true)
-        .nullableValidationKind(Diagnostic.Kind.NOTE)
-        .privateMemberValidationKind(Diagnostic.Kind.NOTE)
-        .staticMemberValidationKind(Diagnostic.Kind.NOTE)
-        .ignorePrivateAndStaticInjectionForComponent(false)
-        .scopeCycleValidationType(ValidationType.NONE)
-        .warnIfInjectionFactoryNotGeneratedUpstream(false)
-        .fastInit(false)
-        .experimentalAndroidMode2(false)
-        .aheadOfTimeSubcomponents(false)
-        .floatingBindsMethods(false)
-        .build();
-  }
-
-  private static ComponentDescriptor.Factory createComponentDescriptorFactory(
-      DaggerElements elements, DaggerTypes types, CompilerOptions compilerOptions) {
-    KeyFactory keyFactory = new KeyFactory(types, elements);
-    DependencyRequestFactory dependencyRequestFactory =
-        new DependencyRequestFactory(keyFactory, types);
-    BindingFactory provisionBindingFactory =
-        new BindingFactory(types, elements, keyFactory, dependencyRequestFactory);
-    MultibindingDeclaration.Factory multibindingDeclarationFactory =
-        new MultibindingDeclaration.Factory(types, keyFactory);
-    DelegateDeclaration.Factory bindingDelegateDeclarationFactory =
-        new DelegateDeclaration.Factory(types, keyFactory, dependencyRequestFactory);
-    SubcomponentDeclaration.Factory subcomponentDeclarationFactory =
-        new SubcomponentDeclaration.Factory(keyFactory);
-    OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory =
-        new OptionalBindingDeclaration.Factory(keyFactory);
-
-    ModuleDescriptor.Factory moduleDescriptorFactory =
-        new ModuleDescriptor.Factory(
-            elements,
-            provisionBindingFactory,
-            multibindingDeclarationFactory,
-            bindingDelegateDeclarationFactory,
-            subcomponentDeclarationFactory,
-            optionalBindingDeclarationFactory);
-    return new ComponentDescriptor.Factory(
-        elements, types, dependencyRequestFactory, moduleDescriptorFactory, compilerOptions);
-  }
-
-  private static BindingGraphFactory createBindingGraphFactory(
-      DaggerTypes types, DaggerElements elements, CompilerOptions compilerOptions) {
-    KeyFactory keyFactory = new KeyFactory(types, elements);
-
-    BindingFactory bindingFactory =
-        new BindingFactory(
-            types, elements, keyFactory, new DependencyRequestFactory(keyFactory, types));
-
-    InjectBindingRegistry injectBindingRegistry =
-        new InjectBindingRegistryImpl(
-            elements,
-            types,
-            new NullMessager(),
-            new InjectValidator(
-                types,
-                elements,
-                new DependencyRequestValidator(new MembersInjectionValidator()),
-                compilerOptions),
-            keyFactory,
-            bindingFactory,
-            compilerOptions);
-    return new BindingGraphFactory(
-        elements,
-        injectBindingRegistry,
-        keyFactory,
-        bindingFactory,
-        new IncorrectlyInstalledBindsMethodsValidator(compilerOptions),
-        compilerOptions);
-  }
-
-  private static class NullMessager implements Messager {
-    @Override
-    public void printMessage(Diagnostic.Kind kind, CharSequence charSequence) {}
-
-    @Override
-    public void printMessage(Diagnostic.Kind kind, CharSequence charSequence, Element element) {}
-
-    @Override
-    public void printMessage(
-        Diagnostic.Kind kind,
-        CharSequence charSequence,
-        Element element,
-        AnnotationMirror annotationMirror) {}
-
-    @Override
-    public void printMessage(
-        Diagnostic.Kind kind,
-        CharSequence charSequence,
-        Element element,
-        AnnotationMirror annotationMirror,
-        AnnotationValue annotationValue) {}
-  }
-}
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 4884d2b49..9d4fdf0f0 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -19,6 +19,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
@@ -49,12 +50,12 @@
 
   MapBindingExpression(
       ResolvedBindings resolvedBindings,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(resolvedBindings, generatedComponentModel);
+    super(resolvedBindings, componentImplementation);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     BindingKind bindingKind = this.binding.kind();
     checkArgument(bindingKind.equals(MULTIBOUND_MAP), bindingKind);
@@ -134,7 +135,7 @@ private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName
         "$L, $L",
         getMapKeyExpression(dependencies.get(dependency), requestingClass, elements),
         componentBindingExpressions
-            .getDependencyExpression(dependency, requestingClass)
+            .getDependencyExpression(bindingRequest(dependency), requestingClass)
             .codeBlock());
   }
 
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index 3e61293b7..0fff44b87 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -23,31 +23,28 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.CodeBlock;
-import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
 /** A factory creation expression for a multibound map. */
-// TODO(dpb): Resolve with SetFactoryCreationExpression.
-final class MapFactoryCreationExpression implements FrameworkInstanceCreationExpression {
+final class MapFactoryCreationExpression extends MultibindingFactoryCreationExpression {
 
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ComponentBindingExpressions componentBindingExpressions;
+  private final ComponentImplementation componentImplementation;
   private final BindingGraph graph;
   private final ContributionBinding binding;
   private final DaggerElements elements;
 
   MapFactoryCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions,
       BindingGraph graph,
       DaggerElements elements) {
+    super(binding, componentImplementation, componentBindingExpressions);
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.graph = checkNotNull(graph);
     this.elements = checkNotNull(elements);
   }
@@ -55,8 +52,7 @@
   @Override
   public CodeBlock creationExpression() {
     CodeBlock.Builder builder = CodeBlock.builder().add("$T.", mapFactoryClassName(binding));
-    boolean useRawType = !generatedComponentModel.isTypeAccessible(binding.key().type());
-    if (!useRawType) {
+    if (!useRawType()) {
       MapType mapType = MapType.from(binding.key().type());
       // TODO(ronshapiro): either inline this into mapFactoryClassName, or add a
       // mapType.unwrappedValueType() method that doesn't require a framework type
@@ -72,31 +68,23 @@ public CodeBlock creationExpression() {
     }
 
     ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
-    if (binding.bindingType().equals(BindingType.PROVISION)) {
-      builder.add("builder($L)", frameworkDependencies.size());
-    } else {
-      builder.add("builder()");
-    }
+    builder.add("builder($L)", frameworkDependencies.size());
+
+    superContributions()
+        .ifPresent(superContributions -> builder.add(".putAll($L)", superContributions));
 
-    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesToImplement()) {
       ContributionBinding contributionBinding =
           graph.contributionBindings().get(frameworkDependency.key()).contributionBinding();
-      CodeBlock value =
-          componentBindingExpressions
-              .getDependencyExpression(frameworkDependency, generatedComponentModel.name())
-              .codeBlock();
       builder.add(
           ".put($L, $L)",
-          getMapKeyExpression(contributionBinding, generatedComponentModel.name(), elements),
-          useRawType ? CodeBlocks.cast(value, frameworkDependency.frameworkClass()) : value);
+          getMapKeyExpression(contributionBinding, componentImplementation.name(), elements),
+          multibindingDependencyExpression(frameworkDependency));
     }
     builder.add(".build()");
 
-    return builder.build();
-  }
+    componentImplementation.registerImplementedMultibinding(binding, bindingRequest());
 
-  @Override
-  public boolean useInnerSwitchingProvider() {
-    return !binding.dependencies().isEmpty();
+    return builder.build();
   }
 }
diff --git a/java/dagger/internal/codegen/MapKeyProcessingStep.java b/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 7bf3ab5df..ff541c2e9 100644
--- a/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -18,12 +18,10 @@
 
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
 import static javax.lang.model.element.ElementKind.ANNOTATION_TYPE;
-import static javax.lang.model.util.ElementFilter.typesIn;
 
-import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import dagger.MapKey;
 import java.lang.annotation.Annotation;
 import java.util.Set;
@@ -39,7 +37,7 @@
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
  * implementation of annotations marked with {@link MapKey @MapKey} where necessary.
  */
-public class MapKeyProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+public class MapKeyProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Messager messager;
   private final Types types;
   private final MapKeyValidator mapKeyValidator;
@@ -53,6 +51,7 @@
       MapKeyValidator mapKeyValidator,
       AnnotationCreatorGenerator annotationCreatorGenerator,
       UnwrappedMapKeyGenerator unwrappedMapKeyGenerator) {
+    super(MoreElements::asType);
     this.messager = messager;
     this.types = types;
     this.mapKeyValidator = mapKeyValidator;
@@ -66,22 +65,19 @@
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (TypeElement mapKeyAnnotationType : typesIn(elementsByAnnotation.get(MapKey.class))) {
-      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(mapKeyAnnotationType);
-      mapKeyReport.printMessagesTo(messager);
+  protected void process(
+      TypeElement mapKeyAnnotationType, ImmutableSet<Class<? extends Annotation>> annotations) {
+    ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(mapKeyAnnotationType);
+    mapKeyReport.printMessagesTo(messager);
 
-      if (mapKeyReport.isClean()) {
-        MapKey mapkey = mapKeyAnnotationType.getAnnotation(MapKey.class);
-        if (!mapkey.unwrapValue()) {
-          annotationCreatorGenerator.generate(mapKeyAnnotationType, messager);
-        } else if (unwrappedValueKind(mapKeyAnnotationType).equals(ANNOTATION_TYPE)) {
-          unwrappedMapKeyGenerator.generate(mapKeyAnnotationType, messager);
-        }
+    if (mapKeyReport.isClean()) {
+      MapKey mapkey = mapKeyAnnotationType.getAnnotation(MapKey.class);
+      if (!mapkey.unwrapValue()) {
+        annotationCreatorGenerator.generate(mapKeyAnnotationType, messager);
+      } else if (unwrappedValueKind(mapKeyAnnotationType).equals(ANNOTATION_TYPE)) {
+        unwrappedMapKeyGenerator.generate(mapKeyAnnotationType, messager);
       }
     }
-    return ImmutableSet.of();
   }
 
   private ElementKind unwrappedValueKind(TypeElement mapKeyAnnotationType) {
diff --git a/java/dagger/internal/codegen/MapMultibindingValidator.java b/java/dagger/internal/codegen/MapMultibindingValidator.java
index d7ccf2be0..346d27145 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidator.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidator.java
@@ -17,8 +17,9 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static com.google.common.collect.Multimaps.filterKeys;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static javax.tools.Diagnostic.Kind.ERROR;
@@ -28,13 +29,15 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
+import com.google.common.collect.SetMultimap;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.Key;
+import dagger.producers.Producer;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
 import java.util.Set;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.type.DeclaredType;
 
 /**
@@ -44,10 +47,13 @@
 final class MapMultibindingValidator implements BindingGraphPlugin {
 
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
+  private final KeyFactory keyFactory;
 
   @Inject
-  MapMultibindingValidator(BindingDeclarationFormatter bindingDeclarationFormatter) {
+  MapMultibindingValidator(
+      BindingDeclarationFormatter bindingDeclarationFormatter, KeyFactory keyFactory) {
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
+    this.keyFactory = keyFactory;
   }
 
   @Override
@@ -57,27 +63,74 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    for (BindingNode node : bindingGraph.bindingNodes()) {
-      if (node.binding().kind().equals(MULTIBOUND_MAP)) {
-        ImmutableSet<ContributionBinding> contributions =
-            mapBindingContributions(node, bindingGraph);
-        checkForDuplicateMapKeys(node, contributions, diagnosticReporter);
-        checkForInconsistentMapKeyAnnotationTypes(node, contributions, diagnosticReporter);
-      }
-    }
+    mapMultibindings(bindingGraph)
+        .forEach(
+            binding -> {
+              ImmutableSet<ContributionBinding> contributions =
+                  mapBindingContributions(binding, bindingGraph);
+              checkForDuplicateMapKeys(binding, contributions, diagnosticReporter);
+              checkForInconsistentMapKeyAnnotationTypes(binding, contributions, diagnosticReporter);
+            });
+  }
+
+  /**
+   * Returns the map multibindings in the binding graph. If a graph contains bindings for more than
+   * one of the following for the same {@code K} and {@code V}, then only the first one found will
+   * be returned so we don't report the same map contribution problem more than once.
+   *
+   * <ol>
+   *   <li>{@code Map<K, V>}
+   *   <li>{@code Map<K, Provider<V>>}
+   *   <li>{@code Map<K, Producer<V>>}
+   * </ol>
+   */
+  private ImmutableSet<dagger.model.Binding> mapMultibindings(BindingGraph bindingGraph) {
+    ImmutableSetMultimap<Key, dagger.model.Binding> mapMultibindings =
+        bindingGraph.bindings().stream()
+            .filter(node -> node.kind().equals(MULTIBOUND_MAP))
+            .collect(toImmutableSetMultimap(dagger.model.Binding::key, node -> node));
+
+    // Mutlbindings for Map<K, V>
+    SetMultimap<Key, dagger.model.Binding> plainValueMapMultibindings =
+        filterKeys(mapMultibindings, key -> !MapType.from(key).valuesAreFrameworkType());
+
+    // Multibindings for Map<K, Provider<V>> where Map<K, V> isn't in plainValueMapMultibindings
+    SetMultimap<Key, dagger.model.Binding> providerValueMapMultibindings =
+        filterKeys(
+            mapMultibindings,
+            key ->
+                MapType.from(key).valuesAreTypeOf(Provider.class)
+                    && !plainValueMapMultibindings.containsKey(keyFactory.unwrapMapValueType(key)));
+
+    // Multibindings for Map<K, Producer<V>> where Map<K, V> isn't in plainValueMapMultibindings and
+    // Map<K, Provider<V>> isn't in providerValueMapMultibindings
+    SetMultimap<Key, dagger.model.Binding> producerValueMapMultibindings =
+        filterKeys(
+            mapMultibindings,
+            key ->
+                MapType.from(key).valuesAreTypeOf(Producer.class)
+                    && !plainValueMapMultibindings.containsKey(keyFactory.unwrapMapValueType(key))
+                    && !providerValueMapMultibindings.containsKey(
+                        keyFactory.rewrapMapKey(key, Producer.class, Provider.class).get()));
+
+    return new ImmutableSet.Builder<dagger.model.Binding>()
+        .addAll(plainValueMapMultibindings.values())
+        .addAll(providerValueMapMultibindings.values())
+        .addAll(producerValueMapMultibindings.values())
+        .build();
   }
 
   private ImmutableSet<ContributionBinding> mapBindingContributions(
-      BindingNode bindingNode, BindingGraph bindingGraph) {
-    checkArgument(bindingNode.binding().kind().equals(MULTIBOUND_MAP));
-    return bindingGraph.successors(bindingNode).stream()
-        .flatMap(instancesOf(BindingNode.class))
-        .map(node -> (ContributionBinding) node.binding())
+      dagger.model.Binding binding, BindingGraph bindingGraph) {
+    checkArgument(binding.kind().equals(MULTIBOUND_MAP));
+    return bindingGraph.requestedBindings(binding).stream()
+        .map(b -> (BindingNode) b)
+        .map(b -> (ContributionBinding) b.delegate())
         .collect(toImmutableSet());
   }
 
   private void checkForDuplicateMapKeys(
-      BindingNode multiboundMapBindingNode,
+      dagger.model.Binding multiboundMapBinding,
       ImmutableSet<ContributionBinding> contributions,
       DiagnosticReporter diagnosticReporter) {
     ImmutableSetMultimap<Object, ContributionBinding> contributionsByMapKey =
@@ -88,14 +141,14 @@ private void checkForDuplicateMapKeys(
       if (contributionsForOneMapKey.size() > 1) {
         diagnosticReporter.reportBinding(
             ERROR,
-            multiboundMapBindingNode,
-            duplicateMapKeyErrorMessage(contributionsForOneMapKey, multiboundMapBindingNode.key()));
+            multiboundMapBinding,
+            duplicateMapKeyErrorMessage(contributionsForOneMapKey, multiboundMapBinding.key()));
       }
     }
   }
 
   private void checkForInconsistentMapKeyAnnotationTypes(
-      BindingNode multiboundMapBindingNode,
+      dagger.model.Binding multiboundMapBinding,
       ImmutableSet<ContributionBinding> contributions,
       DiagnosticReporter diagnosticReporter) {
     ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
@@ -104,9 +157,9 @@ private void checkForInconsistentMapKeyAnnotationTypes(
     if (contributionsByMapKeyAnnotationType.keySet().size() > 1) {
       diagnosticReporter.reportBinding(
           ERROR,
-          multiboundMapBindingNode,
+          multiboundMapBinding,
           inconsistentMapKeyAnnotationTypesErrorMessage(
-              contributionsByMapKeyAnnotationType, multiboundMapBindingNode.key()));
+              contributionsByMapKeyAnnotationType, multiboundMapBinding.key()));
     }
   }
 
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index 0dd9170e9..2806207ff 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -18,7 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.CodeBlocks.toTypeNamesCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -34,7 +34,6 @@
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
 import java.util.List;
 import java.util.Optional;
@@ -68,8 +67,35 @@ static MemberSelect localField(ClassName owningClass, String fieldName) {
     @Override
     CodeBlock getExpressionFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
-          ? CodeBlock.of("$L", fieldName)
-          : CodeBlock.of("$T.this.$L", owningClass(), fieldName);
+          ? CodeBlock.of("$N", fieldName)
+          : CodeBlock.of("$T.this.$N", owningClass(), fieldName);
+    }
+  }
+
+  /**
+   * Returns a {@link MemberSelect} that accesses the method given by {@code methodName} owned by
+   * {@code owningClass}. In this context "local" refers to the fact that the method is owned by the
+   * type (or an enclosing type) from which the code block will be used. The returned {@link
+   * MemberSelect} will not be valid for accessing the method from a different class (regardless of
+   * accessibility).
+   */
+  static MemberSelect localMethod(ClassName owningClass, String methodName) {
+    return new LocalMethod(owningClass, methodName);
+  }
+
+  private static final class LocalMethod extends MemberSelect {
+    final String methodName;
+
+    LocalMethod(ClassName owningClass, String methodName) {
+      super(owningClass, false);
+      this.methodName = checkNotNull(methodName);
+    }
+
+    @Override
+    CodeBlock getExpressionFor(ClassName usingClass) {
+      return owningClass().equals(usingClass)
+          ? CodeBlock.of("$N()", methodName)
+          : CodeBlock.of("$T.this.$N()", owningClass(), methodName);
     }
   }
 
@@ -210,7 +236,7 @@ CodeBlock getExpressionFor(ClassName usingClass) {
         return CodeBlock.of(
             "$T.<$L>$L",
             owningClass(),
-            typeParameters.stream().map(TypeName::get).collect(toTypeNamesCodeBlock()),
+            typeParameters.stream().map(CodeBlocks::type).collect(toParametersCodeBlock()),
             methodCodeBlock);
       } else {
         return CodeBlock.of("(($T) $T.$L)", rawReturnType, owningClass(), methodCodeBlock);
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index 2b6c94040..ac9f6811d 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -37,7 +37,7 @@
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
   @Override
-  public Optional<TypeElement> bindingElement() {
+  public final Optional<Element> bindingElement() {
     return Optional.of(membersInjectedType());
   }
 
@@ -80,11 +80,6 @@ boolean hasLocalInjectionSites() {
                 injectionSite.element().getEnclosingElement().equals(membersInjectedType()));
   }
 
-  @Override
-  public final boolean isProduction() {
-    return false;
-  }
-
   @AutoValue
   abstract static class InjectionSite {
     enum Kind {
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
index a22b1dd5a..12e8070bc 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
@@ -49,7 +49,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   // better suited as a method on MembersInjectionMethods
   @Override
   protected CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
     ExecutableElement methodElement = componentMethod.methodElement();
     ParameterSpec parameter = ParameterSpec.get(getOnlyElement(methodElement.getParameters()));
 
diff --git a/java/dagger/internal/codegen/MembersInjectionMethods.java b/java/dagger/internal/codegen/MembersInjectionMethods.java
index 36108cfa2..34c617938 100644
--- a/java/dagger/internal/codegen/MembersInjectionMethods.java
+++ b/java/dagger/internal/codegen/MembersInjectionMethods.java
@@ -19,7 +19,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.MEMBERS_INJECTION_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.MEMBERS_INJECTION_METHOD;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
@@ -41,19 +41,19 @@
 /** Manages the member injection methods for a component. */
 final class MembersInjectionMethods {
   private final Map<Key, MethodSpec> membersInjectionMethods = new LinkedHashMap<>();
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentBindingExpressions bindingExpressions;
   private final BindingGraph graph;
   private final DaggerElements elements;
   private final DaggerTypes types;
 
   MembersInjectionMethods(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions bindingExpressions,
       BindingGraph graph,
       DaggerElements elements,
       DaggerTypes types) {
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.bindingExpressions = checkNotNull(bindingExpressions);
     this.graph = checkNotNull(graph);
     this.elements = checkNotNull(elements);
@@ -74,14 +74,14 @@ private MethodSpec membersInjectionMethod(Key key) {
     Binding binding = resolvedBindings.binding();
     TypeMirror keyType = binding.key().type();
     TypeMirror membersInjectedType =
-        isTypeAccessibleFrom(keyType, generatedComponentModel.name().packageName())
+        isTypeAccessibleFrom(keyType, componentImplementation.name().packageName())
             ? keyType
             : elements.getTypeElement(Object.class).asType();
     TypeName membersInjectedTypeName = TypeName.get(membersInjectedType);
     Name bindingTypeName = binding.bindingTypeElement().get().getSimpleName();
     // TODO(ronshapiro): include type parameters in this name e.g. injectFooOfT, and outer class
     // simple names Foo.Builder -> injectFooBuilder
-    String methodName = generatedComponentModel.getUniqueMethodName("inject" + bindingTypeName);
+    String methodName = componentImplementation.getUniqueMethodName("inject" + bindingTypeName);
     ParameterSpec parameter = ParameterSpec.builder(membersInjectedTypeName, "instance").build();
     MethodSpec.Builder methodBuilder =
         methodBuilder(methodName)
@@ -97,18 +97,18 @@ private MethodSpec membersInjectionMethod(Key key) {
     methodBuilder.addCode(
         InjectionSiteMethod.invokeAll(
             injectionSites(binding),
-            generatedComponentModel.name(),
+            componentImplementation.name(),
             instance,
             membersInjectedType,
             types,
             request ->
                 bindingExpressions
-                    .getDependencyArgumentExpression(request, generatedComponentModel.name())
+                    .getDependencyArgumentExpression(request, componentImplementation.name())
                     .codeBlock()));
     methodBuilder.addStatement("return $L", instance);
 
     MethodSpec method = methodBuilder.build();
-    generatedComponentModel.addMethod(MEMBERS_INJECTION_METHOD, method);
+    componentImplementation.addMethod(MEMBERS_INJECTION_METHOD, method);
     return method;
   }
 
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index 3d8520a3e..86b8787ae 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -17,21 +17,30 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import java.util.Optional;
 
 /** A binding expression that wraps another in a nullary method on the component. */
 abstract class MethodBindingExpression extends BindingExpression {
-
+  private final BindingRequest request;
   private final BindingMethodImplementation methodImplementation;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
+  private final ProducerEntryPointView producerEntryPointView;
 
   protected MethodBindingExpression(
+      BindingRequest request,
       BindingMethodImplementation methodImplementation,
-      GeneratedComponentModel generatedComponentModel) {
+      ComponentImplementation componentImplementation,
+      DaggerTypes types) {
+    this.request = checkNotNull(request);
     this.methodImplementation = checkNotNull(methodImplementation);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
+    this.producerEntryPointView = new ProducerEntryPointView(types);
   }
 
   @Override
@@ -39,9 +48,40 @@ Expression getDependencyExpression(ClassName requestingClass) {
     addMethod();
     return Expression.create(
         methodImplementation.returnType(),
-        requestingClass.equals(generatedComponentModel.name())
+        requestingClass.equals(componentImplementation.name())
             ? CodeBlock.of("$N()", methodName())
-            : CodeBlock.of("$T.this.$N()", generatedComponentModel.name(), methodName()));
+            : CodeBlock.of("$T.this.$N()", componentImplementation.name(), methodName()));
+  }
+
+  @Override
+  final CodeBlock getModifiableBindingMethodImplementation(
+      ModifiableBindingMethod modifiableBindingMethod,
+      ComponentImplementation component,
+      DaggerTypes types) {
+    // A matching modifiable binding method means that we have previously created the binding method
+    // and we are now implementing it. If there is no matching method we need to first create the
+    // method. We create the method by deferring to getDependencyExpression (defined above) via a
+    // call to super.getModifiableBindingMethodImplementation().
+    if (supertypeModifiableBindingMethod().isPresent()) {
+      checkState(
+          supertypeModifiableBindingMethod().get().fulfillsSameRequestAs(modifiableBindingMethod));
+      return methodImplementation.body();
+    }
+    return super.getModifiableBindingMethodImplementation(
+        modifiableBindingMethod, component, types);
+  }
+
+  protected final Optional<ModifiableBindingMethod> supertypeModifiableBindingMethod() {
+    return componentImplementation.supertypeModifiableBindingMethod(request);
+  }
+
+  @Override
+  Expression getDependencyExpressionForComponentMethod(ComponentMethodDescriptor componentMethod,
+      ComponentImplementation component) {
+    return producerEntryPointView
+        .getProducerEntryPointField(this, componentMethod, component)
+        .orElseGet(
+            () -> super.getDependencyExpressionForComponentMethod(componentMethod, component));
   }
 
   /** Adds the method to the component (if necessary) the first time it's called. */
diff --git a/java/dagger/internal/codegen/MethodSignatureFormatter.java b/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 67535572c..ad79fa5af 100644
--- a/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -95,11 +95,16 @@ private String format(
       }
       builder.append(' ');
     }
-    builder.append(nameOfType(methodType.getReturnType()));
-    builder.append(' ');
-    builder.append(declaringType.getQualifiedName());
-    builder.append('.');
-    builder.append(method.getSimpleName());
+    if (method.getSimpleName().contentEquals("<init>")) {
+      builder.append(declaringType.getQualifiedName());
+    } else {
+      builder
+          .append(nameOfType(methodType.getReturnType()))
+          .append(' ')
+          .append(declaringType.getQualifiedName())
+          .append('.')
+          .append(method.getSimpleName());
+    }
     builder.append('(');
     checkState(method.getParameters().size() == methodType.getParameterTypes().size());
     Iterator<? extends VariableElement> parameters = method.getParameters().iterator();
diff --git a/java/dagger/internal/codegen/MissingBindingExpression.java b/java/dagger/internal/codegen/MissingBindingExpression.java
index 2c1b7df46..c7fa17c13 100644
--- a/java/dagger/internal/codegen/MissingBindingExpression.java
+++ b/java/dagger/internal/codegen/MissingBindingExpression.java
@@ -19,34 +19,42 @@
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import java.util.Optional;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * A {@link ModifiableAbstractMethodBindingExpression} for a binding that is missing when generating
  * the abstract base class implementation of a subcomponent. The (unimplemented) method is added to
- * the {@link GeneratedComponentModel} when the dependency expression is requested. The method is
+ * the {@link ComponentImplementation} when the dependency expression is requested. The method is
  * overridden when generating the implementation of an ancestor component.
  */
 final class MissingBindingExpression extends ModifiableAbstractMethodBindingExpression {
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final BindingRequest request;
 
   MissingBindingExpression(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       BindingRequest request,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
-      Optional<ComponentMethodDescriptor> matchingComponentMethod) {
+      Optional<ComponentMethodDescriptor> matchingComponentMethod,
+      DaggerTypes types) {
     super(
-        generatedComponentModel,
+        componentImplementation,
         ModifiableBindingType.MISSING,
         request,
         matchingModifiableBindingMethod,
-        matchingComponentMethod);
-    this.generatedComponentModel = generatedComponentModel;
+        matchingComponentMethod,
+        types);
+    this.componentImplementation = componentImplementation;
     this.request = request;
   }
 
   @Override
   String chooseMethodName() {
-    return generatedComponentModel.getUniqueMethodName(request);
+    return componentImplementation.getUniqueMethodName(request);
+  }
+
+  @Override
+  protected TypeMirror contributedType() {
+    return request.key().type();
   }
 }
diff --git a/java/dagger/internal/codegen/MissingBindingValidator.java b/java/dagger/internal/codegen/MissingBindingValidator.java
index ab8e754ce..dd2f6e3b1 100644
--- a/java/dagger/internal/codegen/MissingBindingValidator.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -16,59 +16,35 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.asTypeElement;
-import static com.google.auto.common.MoreTypes.isType;
-import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Verify.verify;
-import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
 import static dagger.internal.codegen.Keys.isValidMembersInjectionKey;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.RequestKinds.entryPointCanUseProduction;
-import static dagger.internal.codegen.Scopes.getReadableSource;
-import static java.util.function.Predicate.isEqual;
-import static java.util.stream.Collectors.toList;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
-import com.google.auto.common.MoreTypes;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
-import dagger.model.BindingGraph.MissingBindingNode;
+import dagger.model.BindingGraph.MissingBinding;
 import dagger.model.BindingGraph.Node;
 import dagger.model.Key;
-import dagger.model.Scope;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
-import java.util.List;
-import java.util.Optional;
-import java.util.stream.Stream;
 import javax.inject.Inject;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
 
 /** Reports errors for missing bindings. */
 final class MissingBindingValidator implements BindingGraphPlugin {
 
   private final DaggerTypes types;
-  private final DaggerElements elements;
   private final InjectBindingRegistry injectBindingRegistry;
 
   @Inject
   MissingBindingValidator(
-      DaggerTypes types, DaggerElements elements, InjectBindingRegistry injectBindingRegistry) {
+      DaggerTypes types, InjectBindingRegistry injectBindingRegistry) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
-    this.elements = elements;
   }
 
   @Override
@@ -78,25 +54,22 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
+    if (graph.isModuleBindingGraph() || graph.isPartialBindingGraph()) {
+      return; // Don't report missing bindings when validating a module or a partial binding graph
+    }
     graph
-        .missingBindingNodes()
-        .forEach(node -> reportMissingBinding(node, graph, diagnosticReporter));
+        .missingBindings()
+        .forEach(missingBinding -> reportMissingBinding(missingBinding, graph, diagnosticReporter));
   }
 
   private void reportMissingBinding(
-      MissingBindingNode missingBindingNode,
-      BindingGraph graph,
-      DiagnosticReporter diagnosticReporter) {
+      MissingBinding missingBinding, BindingGraph graph, DiagnosticReporter diagnosticReporter) {
     diagnosticReporter.reportBinding(
-        ERROR,
-        missingBindingNode,
-        missingReleasableReferenceManagerBindingErrorMessage(missingBindingNode, graph)
-            .orElseGet(() -> missingBindingErrorMessage(missingBindingNode, graph)));
+        ERROR, missingBinding, missingBindingErrorMessage(missingBinding, graph));
   }
 
-  private String missingBindingErrorMessage(
-      MissingBindingNode missingBindingNode, BindingGraph graph) {
-    Key key = missingBindingNode.key();
+  private String missingBindingErrorMessage(MissingBinding missingBinding, BindingGraph graph) {
+    Key key = missingBinding.key();
     StringBuilder errorMessage = new StringBuilder();
     // Wildcards should have already been checked by DependencyRequestValidator.
     verify(!key.type().getKind().equals(TypeKind.WILDCARD), "unexpected wildcard request: %s", key);
@@ -106,7 +79,7 @@ private String missingBindingErrorMessage(
       errorMessage.append("an @Inject constructor or ");
     }
     errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
-    if (allIncomingDependenciesCanUseProduction(missingBindingNode, graph)) {
+    if (allIncomingDependenciesCanUseProduction(missingBinding, graph)) {
       errorMessage.append(" or @Produces-");
     }
     errorMessage.append("annotated method.");
@@ -114,8 +87,8 @@ private String missingBindingErrorMessage(
       errorMessage.append(
           " This type supports members injection but cannot be implicitly provided.");
     }
-    graph.bindingNodes(key).stream()
-        .map(bindingNode -> bindingNode.componentPath().currentComponent())
+    graph.bindings(key).stream()
+        .map(binding -> binding.componentPath().currentComponent())
         .distinct()
         .forEach(
             component ->
@@ -126,21 +99,22 @@ private String missingBindingErrorMessage(
   }
 
   private boolean allIncomingDependenciesCanUseProduction(
-      MissingBindingNode missingBindingNode, BindingGraph graph) {
-    return graph.inEdges(missingBindingNode).stream()
+      MissingBinding missingBinding, BindingGraph graph) {
+    return graph.network().inEdges(missingBinding).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .allMatch(edge -> dependencyCanBeProduction(edge, graph));
   }
 
   private boolean dependencyCanBeProduction(DependencyEdge edge, BindingGraph graph) {
-    Node source = graph.incidentNodes(edge).source();
+    Node source = graph.network().incidentNodes(edge).source();
     if (source instanceof ComponentNode) {
       return entryPointCanUseProduction(edge.dependencyRequest().kind());
     }
-    if (source instanceof BindingNode) {
-      return ((BindingNode) source).binding().isProduction();
+    if (source instanceof dagger.model.Binding) {
+      return ((dagger.model.Binding) source).isProduction();
     }
-    throw new IllegalArgumentException("expected a BindingNode or ComponentNode: " + source);
+    throw new IllegalArgumentException(
+        "expected a dagger.model.Binding or ComponentNode: " + source);
   }
 
   private boolean typeHasInjectionSites(Key key) {
@@ -149,77 +123,4 @@ private boolean typeHasInjectionSites(Key key) {
         .map(binding -> !binding.injectionSites().isEmpty())
         .orElse(false);
   }
-
-  /**
-   * If {@code missingBindingNode}'s key is for an invalid {@code @ForReleasableReferences}, returns
-   * a more specific error message.
-   *
-   * <p>An invalid key is one whose type is either {@link ReleasableReferenceManager} or {@link
-   * TypedReleasableReferenceManager}, and whose scope:
-   *
-   * <ul>
-   *   <li>does not annotate any component in the hierarchy, or
-   *   <li>is not annotated with the metadata annotation type that is the {@link
-   *       TypedReleasableReferenceManager}'s type argument
-   * </ul>
-   */
-  private Optional<String> missingReleasableReferenceManagerBindingErrorMessage(
-      MissingBindingNode missingBindingNode, BindingGraph graph) {
-    Key key = missingBindingNode.key();
-    if (!key.qualifier().isPresent()
-        || !isTypeOf(ForReleasableReferences.class, key.qualifier().get().getAnnotationType())
-        || !isType(key.type())) {
-      return Optional.empty();
-    }
-
-    Optional<DeclaredType> metadataType;
-    if (isTypeOf(ReleasableReferenceManager.class, key.type())) {
-      metadataType = Optional.empty();
-    } else if (isTypeOf(TypedReleasableReferenceManager.class, key.type())) {
-      List<? extends TypeMirror> typeArguments =
-          MoreTypes.asDeclared(key.type()).getTypeArguments();
-      if (typeArguments.size() != 1 || !typeArguments.get(0).getKind().equals(TypeKind.DECLARED)) {
-        return Optional.empty();
-      }
-      metadataType = Optional.of(MoreTypes.asDeclared(typeArguments.get(0)));
-    } else {
-      return Optional.empty();
-    }
-
-    Scope scope = Scopes.scope(asTypeElement(getTypeValue(key.qualifier().get(), "value")));
-    if (releasableReferencesScopes(graph).noneMatch(isEqual(scope))) {
-      return Optional.of(
-          String.format(
-              "There is no binding for %s because no component in %s's component hierarchy is "
-                  + "annotated with %s. The available reference-releasing scopes are %s.",
-              key,
-              graph.rootComponentNode().componentPath().currentComponent().getQualifiedName(),
-              getReadableSource(scope),
-              releasableReferencesScopes(graph).map(Scopes::getReadableSource).collect(toList())));
-    }
-    if (metadataType.isPresent()) {
-      TypeElement metadataTypeElement = asTypeElement(metadataType.get());
-      if (!isAnnotationPresent(scope.scopeAnnotationElement(), metadataType.get())) {
-        return Optional.of(notAnnotated(key, scope.scopeAnnotationElement(), metadataTypeElement));
-      }
-      if (!isAnnotationPresent(metadataTypeElement, CanReleaseReferences.class)) {
-        return Optional.of(
-            notAnnotated(
-                key, metadataTypeElement, elements.getTypeElement(CanReleaseReferences.class)));
-      }
-    }
-    return Optional.empty();
-  }
-
-  private static String notAnnotated(Key key, TypeElement type, TypeElement annotation) {
-    return String.format(
-        "There is no binding for %s because %s is not annotated with @%s.",
-        key, type.getQualifiedName(), annotation);
-  }
-
-  private Stream<Scope> releasableReferencesScopes(BindingGraph graph) {
-    return graph.componentNodes().stream()
-        .flatMap(node -> node.scopes().stream())
-        .filter(Scope::canReleaseReferences);
-  }
 }
diff --git a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
index 0da08797d..102094413 100644
--- a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
@@ -17,42 +17,44 @@
 package dagger.internal.codegen;
 
 import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.PROTECTED;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import java.util.Optional;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * A {@link BindingExpression} that invokes a method that encapsulates a binding that cannot be
  * satisfied when generating the abstract base class implementation of a subcomponent. The
- * (unimplemented) method is added to the {@link GeneratedComponentModel} when the dependency
+ * (unimplemented) method is added to the {@link ComponentImplementation} when the dependency
  * expression is requested. The method is overridden when generating the implementation of an
  * ancestor component.
  */
-// TODO(b/72748365): There may be unimplemented abstract binding methods even after considering a
-// complete binding graph: If there are @Provides-over-@Inject bindings then there could be branches
-// of dependencies (of the @Inject binding) that have induced abstract modifiable binding methods
-// that are missing in the full binding graph (given the @Provides binding). Such abstract
-// modifiable methods should be overridden and an exception thrown.
 abstract class ModifiableAbstractMethodBindingExpression extends BindingExpression {
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ModifiableBindingType modifiableBindingType;
   private final BindingRequest request;
+  private final Optional<ComponentMethodDescriptor> matchingComponentMethod;
+  private final DaggerTypes types;
   private Optional<String> methodName;
 
   ModifiableAbstractMethodBindingExpression(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ModifiableBindingType modifiableBindingType,
       BindingRequest request,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
-      Optional<ComponentMethodDescriptor> matchingComponentMethod) {
-    this.generatedComponentModel = generatedComponentModel;
+      Optional<ComponentMethodDescriptor> matchingComponentMethod,
+      DaggerTypes types) {
+    this.componentImplementation = componentImplementation;
     this.modifiableBindingType = modifiableBindingType;
     this.request = request;
+    this.matchingComponentMethod = matchingComponentMethod;
+    this.types = types;
     this.methodName =
         initializeMethodName(matchingComponentMethod, matchingModifiableBindingMethod);
   }
@@ -77,24 +79,57 @@
   @Override
   final Expression getDependencyExpression(ClassName requestingClass) {
     addUnimplementedMethod();
-    return Expression.create(request.key().type(), CodeBlock.of("$L()", methodName.get()));
+    return Expression.create(
+        returnType(),
+        componentImplementation.name().equals(requestingClass)
+            ? CodeBlock.of("$N()", methodName.get())
+            : CodeBlock.of("$T.this.$N()", componentImplementation.name(), methodName.get()));
   }
 
   private void addUnimplementedMethod() {
     if (!methodName.isPresent()) {
       // Only add the method once in case of repeated references to the missing binding.
       methodName = Optional.of(chooseMethodName());
-      generatedComponentModel.addModifiableBindingMethod(
+      TypeMirror returnType = returnType();
+      componentImplementation.addModifiableBindingMethod(
           modifiableBindingType,
           request,
+          returnType,
           MethodSpec.methodBuilder(methodName.get())
-              .addModifiers(PUBLIC, ABSTRACT)
-              .returns(request.typeName())
+              .addModifiers(PROTECTED, ABSTRACT)
+              .returns(TypeName.get(returnType))
               .build(),
           false /* finalized */);
     }
   }
 
+  /**
+   * The return type of this abstract method expression:
+   *
+   * <ul>
+   *   <li>If there's a {@code matchingComponentMethod}, use its return type.
+   *   <li>Otherwise, use the {@linkplain DaggerTypes#publiclyAccessibleType(TypeMirror) publicly
+   *       accessible type} of the request. We can't use the {@linkplain
+   *       Accessibility#isTypeAccessibleFrom(TypeMirror, String) type accessible from the current
+   *       implementation's package} because a subclass implementation may be in a different package
+   *       from which the request type is not accessible.
+   * </ul>
+   */
+  private TypeMirror returnType() {
+    if (matchingComponentMethod.isPresent()) {
+      return matchingComponentMethod.get().resolvedReturnType(types);
+    }
+
+    TypeMirror requestedType = request.requestedType(contributedType(), types);
+    return types.publiclyAccessibleType(requestedType);
+  }
+
+  /**
+   * The {@link ContributionBinding#contributedType() type contributed} by the binding of this
+   * expression. For missing bindings, this will be the key type.
+   */
+  protected abstract TypeMirror contributedType();
+
   /** Returns a unique 'getter' method name for the current component. */
   abstract String chooseMethodName();
 }
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
new file mode 100644
index 000000000..c6a699431
--- /dev/null
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -0,0 +1,471 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.MethodSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.BindingKind;
+import dagger.model.DependencyRequest;
+import dagger.model.Scope;
+import java.util.Optional;
+
+/**
+ * A central repository of code expressions used to access modifiable bindings available to a
+ * component. A binding is modifiable if it can be modified across implementations of a
+ * subcomponent. This is only relevant for ahead-of-time subcomponents.
+ */
+final class ModifiableBindingExpressions {
+  private final Optional<ModifiableBindingExpressions> parent;
+  private final ComponentBindingExpressions bindingExpressions;
+  private final BindingGraph graph;
+  private final ComponentImplementation componentImplementation;
+  private final CompilerOptions compilerOptions;
+  private final DaggerTypes types;
+
+  ModifiableBindingExpressions(
+      Optional<ModifiableBindingExpressions> parent,
+      ComponentBindingExpressions bindingExpressions,
+      BindingGraph graph,
+      ComponentImplementation componentImplementation,
+      CompilerOptions compilerOptions,
+      DaggerTypes types) {
+    this.parent = parent;
+    this.bindingExpressions = bindingExpressions;
+    this.graph = graph;
+    this.componentImplementation = componentImplementation;
+    this.compilerOptions = compilerOptions;
+    this.types = types;
+  }
+
+  /**
+   * Records the binding exposed by the given component method as modifiable, if it is, and returns
+   * the {@link ModifiableBindingType} associated with the binding.
+   */
+  ModifiableBindingType registerComponentMethodIfModifiable(
+      ComponentMethodDescriptor componentMethod, MethodSpec method) {
+    BindingRequest request = bindingRequest(componentMethod.dependencyRequest().get());
+    ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
+    if (modifiableBindingType.isModifiable()) {
+      componentImplementation.registerModifiableBindingMethod(
+          modifiableBindingType,
+          request,
+          componentMethod.resolvedReturnType(types),
+          method,
+          newModifiableBindingWillBeFinalized(modifiableBindingType, request));
+    }
+    return modifiableBindingType;
+  }
+
+  /**
+   * Returns the implementation of a modifiable binding method originally defined in a supertype
+   * implementation of this subcomponent. Returns {@link Optional#empty()} when the binding cannot
+   * or should not be modified by the current binding graph.
+   */
+  Optional<ModifiableBindingMethod> reimplementedModifiableBindingMethod(
+      ModifiableBindingMethod modifiableBindingMethod) {
+    checkState(componentImplementation.superclassImplementation().isPresent());
+    ModifiableBindingType newModifiableBindingType =
+        getModifiableBindingType(modifiableBindingMethod.request());
+    ModifiableBindingType oldModifiableBindingType = modifiableBindingMethod.type();
+    boolean modifiableBindingTypeChanged =
+        !newModifiableBindingType.equals(oldModifiableBindingType);
+    if (modifiableBindingTypeChanged
+        && !newModifiableBindingType.hasBaseClassImplementation()
+        && (oldModifiableBindingType.hasBaseClassImplementation()
+            || componentImplementation.isAbstract())) {
+      // We don't want to override one abstract method with another one. However, If the component
+      // is not abstract (such as a transition from GENERATED_INSTANCE -> MISSING), we must provide
+      // an implementation like normal.
+      return Optional.empty();
+    }
+
+    if (modifiableBindingTypeChanged
+        || shouldModifyImplementation(
+            newModifiableBindingType, modifiableBindingMethod.request())) {
+      MethodSpec baseMethod = modifiableBindingMethod.methodSpec();
+      boolean markMethodFinal =
+          knownModifiableBindingWillBeFinalized(modifiableBindingMethod)
+              // no need to mark the method final if the component implementation will be final
+              && componentImplementation.isAbstract();
+      return Optional.of(
+          ModifiableBindingMethod.implement(
+              modifiableBindingMethod,
+              MethodSpec.methodBuilder(baseMethod.name)
+                  .addModifiers(baseMethod.modifiers.contains(PUBLIC) ? PUBLIC : PROTECTED)
+                  .addModifiers(markMethodFinal ? ImmutableSet.of(FINAL) : ImmutableSet.of())
+                  .returns(baseMethod.returnType)
+                  .addAnnotation(Override.class)
+                  .addCode(
+                      bindingExpressions
+                          .getBindingExpression(modifiableBindingMethod.request())
+                          .getModifiableBindingMethodImplementation(
+                              modifiableBindingMethod, componentImplementation, types))
+                  .build(),
+              markMethodFinal));
+    }
+    return Optional.empty();
+  }
+
+  /**
+   * Returns true if a modifiable binding method that was registered in a superclass implementation
+   * of this subcomponent should be marked as "finalized" if it is being overridden by this
+   * subcomponent implementation. "Finalized" means we should not attempt to modify the binding in
+   * any subcomponent subclass.
+   */
+  private boolean knownModifiableBindingWillBeFinalized(
+      ModifiableBindingMethod modifiableBindingMethod) {
+    ModifiableBindingType newModifiableBindingType =
+        getModifiableBindingType(modifiableBindingMethod.request());
+    if (!newModifiableBindingType.isModifiable()) {
+      // If a modifiable binding has become non-modifiable it is final by definition.
+      return true;
+    }
+    return modifiableBindingWillBeFinalized(
+        newModifiableBindingType,
+        shouldModifyImplementation(newModifiableBindingType, modifiableBindingMethod.request()));
+  }
+
+  /**
+   * Returns true if a newly discovered modifiable binding method, once it is defined in this
+   * subcomponent implementation, should be marked as "finalized", meaning we should not attempt to
+   * modify the binding in any subcomponent subclass.
+   */
+  private boolean newModifiableBindingWillBeFinalized(
+      ModifiableBindingType modifiableBindingType, BindingRequest request) {
+    return modifiableBindingWillBeFinalized(
+        modifiableBindingType, shouldModifyImplementation(modifiableBindingType, request));
+  }
+
+  /**
+   * Returns true if we shouldn't attempt to further modify a modifiable binding once we complete
+   * the implementation for the current subcomponent.
+   */
+  private boolean modifiableBindingWillBeFinalized(
+      ModifiableBindingType modifiableBindingType, boolean modifyingBinding) {
+    switch (modifiableBindingType) {
+      case MISSING:
+      case BINDS_METHOD_WITH_MISSING_DEPENDENCY:
+      case GENERATED_INSTANCE:
+      case OPTIONAL:
+      case INJECTION:
+        // Once we modify any of the above a single time, then they are finalized.
+        return modifyingBinding;
+      case PRODUCTION:
+        // For production bindings, we know that the binding will be finalized if the parent is a
+        // non-production component, but for @ProductionScope bindings we don't ever know because an
+        // ancestor non-production component can apply @ProductionScope. We therefore return false
+        // always. If we wanted, we could create a separate ModifiableBindingType for production
+        // scope to allow us to make this distinction.
+        return false;
+      case MULTIBINDING:
+        return false;
+      default:
+        throw new IllegalStateException(
+            String.format(
+                "Building binding expression for unsupported ModifiableBindingType [%s].",
+                modifiableBindingType));
+    }
+  }
+
+  /**
+   * Creates a binding expression for a binding if it may be modified across implementations of a
+   * subcomponent.
+   */
+  Optional<BindingExpression> maybeCreateModifiableBindingExpression(BindingRequest request) {
+    ModifiableBindingType type = getModifiableBindingType(request);
+    if (!type.isModifiable()) {
+      return Optional.empty();
+    }
+    return Optional.of(createModifiableBindingExpression(type, request));
+  }
+
+  /** Creates a binding expression for a modifiable binding. */
+  private BindingExpression createModifiableBindingExpression(
+      ModifiableBindingType type, BindingRequest request) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+    Optional<ModifiableBindingMethod> matchingModifiableBindingMethod =
+        componentImplementation.getModifiableBindingMethod(request);
+    Optional<ComponentMethodDescriptor> matchingComponentMethod =
+        graph.componentDescriptor().firstMatchingComponentMethod(request);
+    switch (type) {
+      case GENERATED_INSTANCE:
+        // If the subcomponent is abstract then we need to define an (un-implemented)
+        // DeferredModifiableBindingExpression.
+        if (componentImplementation.isAbstract()) {
+          return new DeferredModifiableBindingExpression(
+              componentImplementation,
+              type,
+              resolvedBindings.contributionBinding(),
+              request,
+              matchingModifiableBindingMethod,
+              matchingComponentMethod,
+              types);
+        }
+        // Otherwise return a concrete implementation.
+        return bindingExpressions.createBindingExpression(resolvedBindings, request);
+
+      case MISSING:
+        // If we need an expression for a missing binding and the current implementation is
+        // abstract, then we need an (un-implemented) MissingBindingExpression.
+        if (componentImplementation.isAbstract()) {
+          return new MissingBindingExpression(
+              componentImplementation,
+              request,
+              matchingModifiableBindingMethod,
+              matchingComponentMethod,
+              types);
+        }
+        // Otherwise we assume that it is valid to have a missing binding as it is part of a
+        // dependency chain that has been passively pruned.
+        // TODO(b/117833324): Identify pruned bindings when generating the subcomponent
+        // implementation in which the bindings are pruned. If we hold a reference to the binding
+        // graph used to generate a given implementation then we can compare a implementation's
+        // graph with its superclass implementation's graph to detect pruned dependency branches.
+        return new PrunedConcreteMethodBindingExpression();
+
+      case BINDS_METHOD_WITH_MISSING_DEPENDENCY:
+        checkState(componentImplementation.isAbstract());
+        return new DeferredModifiableBindingExpression(
+            componentImplementation,
+            type,
+            resolvedBindings.contributionBinding(),
+            request,
+            matchingModifiableBindingMethod,
+            matchingComponentMethod,
+            types);
+
+      case OPTIONAL:
+      case MULTIBINDING:
+      case INJECTION:
+      case PRODUCTION:
+        return bindingExpressions.wrapInMethod(
+            resolvedBindings,
+            request,
+            bindingExpressions.createBindingExpression(resolvedBindings, request));
+      default:
+        throw new IllegalStateException(
+            String.format(
+                "Building binding expression for unsupported ModifiableBindingType [%s].", type));
+    }
+  }
+
+  /**
+   * The reason why a binding may need to be modified across implementations of a subcomponent, if
+   * at all.
+   */
+  ModifiableBindingType getModifiableBindingType(BindingRequest request) {
+    if (!compilerOptions.aheadOfTimeSubcomponents()) {
+      return ModifiableBindingType.NONE;
+    }
+
+    // When generating a component the binding is not considered modifiable. Bindings are modifiable
+    // only across subcomponent implementations.
+    if (componentImplementation.componentDescriptor().kind().isTopLevel()) {
+      return ModifiableBindingType.NONE;
+    }
+
+    if (request.requestKind().filter(RequestKinds::isDerivedFromProvider).isPresent()) {
+      return ModifiableBindingType.NONE;
+    }
+
+    if (resolvedInThisComponent(request)) {
+      ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+      if (resolvedBindings.contributionBindings().isEmpty()) {
+        // TODO(ronshapiro): Confirm whether a resolved binding must have a single contribution
+        // binding.
+        return ModifiableBindingType.NONE;
+      }
+
+      ContributionBinding binding = resolvedBindings.contributionBinding();
+      if (binding.requiresGeneratedInstance()) {
+        return ModifiableBindingType.GENERATED_INSTANCE;
+      }
+
+      if (binding.kind().equals(BindingKind.DELEGATE)
+          && graph
+              .contributionBindings()
+              .get(getOnlyElement(binding.dependencies()).key())
+              .isEmpty()) {
+        return ModifiableBindingType.BINDS_METHOD_WITH_MISSING_DEPENDENCY;
+      }
+
+      if (binding.kind().equals(BindingKind.OPTIONAL) && binding.dependencies().isEmpty()) {
+        // only empty optional bindings can be modified
+        return ModifiableBindingType.OPTIONAL;
+      }
+
+      if (binding.isSyntheticMultibinding()) {
+        return ModifiableBindingType.MULTIBINDING;
+      }
+
+      if (binding.kind().equals(BindingKind.INJECTION)) {
+        return ModifiableBindingType.INJECTION;
+      }
+
+      if ((binding.scope().map(Scope::isProductionScope).orElse(false)
+              && componentImplementation.isAbstract())
+          || binding.bindingType().equals(BindingType.PRODUCTION)) {
+        return ModifiableBindingType.PRODUCTION;
+      }
+    } else if (!resolvableBinding(request)) {
+      return ModifiableBindingType.MISSING;
+    }
+
+    return ModifiableBindingType.NONE;
+  }
+
+  /**
+   * Returns true if the current binding graph can, and should, modify a binding by overriding a
+   * modifiable binding method.
+   */
+  private boolean shouldModifyImplementation(
+      ModifiableBindingType modifiableBindingType, BindingRequest request) {
+    if (request.requestKind().isPresent()) {
+      switch (request.requestKind().get()) {
+        case FUTURE:
+          // Futures are always requested by a Producer.get() call, so if the binding is modifiable,
+          // the producer will be wrapped in a modifiable method and the future can refer to that
+          // method; even if the producer binding is modified, getModifiableProducer().get() will
+          // never need to be modified. Furthermore, because cancellation is treated by wrapped
+          // producers, and those producers point to the modifiable producer wrapper methods, we
+          // never need or want to change the access of these wrapped producers for entry
+          // methods
+          return false;
+
+        case LAZY:
+        case PROVIDER_OF_LAZY:
+          // Lazy and ProviderOfLazy are always created from a Provider, and therefore this request
+          // never needs to be modifiable. It will refer (via DoubleCheck.lazy() or
+          // ProviderOfLazy.create()) to the modifiable method and not the framework instance.
+          return false;
+
+        case MEMBERS_INJECTION:
+        case PRODUCED:
+          // MEMBERS_INJECTION has a completely different code path for binding expressions, and
+          // PRODUCED requests are only requestable in @Produces methods, which are hidden from
+          // generated components inside Producer factories
+          throw new AssertionError(request);
+
+        case INSTANCE:
+        case PROVIDER:
+        case PRODUCER:
+          // These may be modifiable, so run through the regular logic. They're spelled out
+          // explicitly so that ErrorProne will detect if a new enum value is created and missing
+          // from this list.
+          break;
+      }
+    }
+
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+    switch (modifiableBindingType) {
+      case GENERATED_INSTANCE:
+        return !componentImplementation.isAbstract();
+
+      case MISSING:
+        // TODO(b/117833324): investigate beder@'s comment about having intermediate component
+        // ancestors satisfy missing bindings of their children with their own missing binding
+        // methods so that we can minimize the cases where we need to reach into doubly-nested
+        // descendant component implementations.
+
+        // Implement a missing binding if it is resolvable, or if we're generating a concrete
+        // subcomponent implementation. If a binding is still missing when the subcomponent
+        // implementation is concrete then it is assumed to be part of a dependency that would have
+        // been passively pruned when implementing the full component hierarchy.
+        return resolvableBinding(request) || !componentImplementation.isAbstract();
+
+      case BINDS_METHOD_WITH_MISSING_DEPENDENCY:
+        DependencyRequest dependency =
+            getOnlyElement(resolvedBindings.contributionBinding().dependencies());
+        return !graph.contributionBindings().get(dependency.key()).isEmpty();
+
+      case OPTIONAL:
+        // Only override optional binding methods if we have a non-empty binding.
+        return !resolvedBindings.contributionBinding().dependencies().isEmpty();
+
+      case MULTIBINDING:
+        // Only modify a multibinding if there are new contributions.
+        return !componentImplementation
+            .superclassContributionsMade(request)
+            .containsAll(resolvedBindings.contributionBinding().dependencies());
+
+      case INJECTION:
+        return !resolvedBindings.contributionBinding().kind().equals(BindingKind.INJECTION);
+
+      case PRODUCTION:
+        // TODO(b/117833324): Profile this to see if this check is slow
+        return !resolvedBindings
+            .owningComponent()
+            .equals(componentImplementation.componentDescriptor());
+
+      default:
+        throw new IllegalStateException(
+            String.format(
+                "Overriding modifiable binding method with unsupported ModifiableBindingType [%s].",
+                modifiableBindingType));
+    }
+  }
+
+  /**
+   * Returns true if the binding can be resolved by the graph for this component or any parent
+   * component.
+   */
+  private boolean resolvableBinding(BindingRequest request) {
+    for (ModifiableBindingExpressions expressions = this;
+        expressions != null;
+        expressions = expressions.parent.orElse(null)) {
+      if (expressions.resolvedInThisComponent(request)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Returns true if the binding can be resolved by the graph for this component. */
+  private boolean resolvedInThisComponent(BindingRequest request) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+    return resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty();
+  }
+
+  /**
+   * Wraps a modifiable binding expression in a method that can be overridden in a subclass
+   * implementation.
+   */
+  BindingExpression wrapInModifiableMethodBindingExpression(
+      ContributionBinding binding,
+      BindingRequest request,
+      BindingMethodImplementation methodImplementation) {
+    ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
+    checkState(modifiableBindingType.isModifiable());
+    return new ModifiableConcreteMethodBindingExpression(
+        binding,
+        request,
+        modifiableBindingType,
+        methodImplementation,
+        componentImplementation,
+        newModifiableBindingWillBeFinalized(modifiableBindingType, request),
+        types);
+  }
+}
diff --git a/java/dagger/internal/codegen/ModifiableBindingMethods.java b/java/dagger/internal/codegen/ModifiableBindingMethods.java
index d83a5fc9b..e19abb9d6 100644
--- a/java/dagger/internal/codegen/ModifiableBindingMethods.java
+++ b/java/dagger/internal/codegen/ModifiableBindingMethods.java
@@ -20,7 +20,9 @@
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -28,6 +30,7 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * A registry for those methods which each wrap a binding whose definition may be modified across
@@ -44,12 +47,17 @@
 
   /** Register a method encapsulating a modifiable binding. */
   void addMethod(
-      ModifiableBindingType type, BindingRequest request, MethodSpec method, boolean finalized) {
+      ModifiableBindingType type,
+      BindingRequest request,
+      TypeMirror returnType,
+      MethodSpec method,
+      boolean finalized) {
     checkArgument(type.isModifiable());
     if (finalized) {
       finalizedMethods.add(request);
     }
-    methods.put(request, ModifiableBindingMethod.create(type, request, method, finalized));
+    methods.put(
+        request, ModifiableBindingMethod.create(type, request, returnType, method, finalized));
   }
 
   /** Returns all {@link ModifiableBindingMethod}s that have not been marked as finalized. */
@@ -62,6 +70,11 @@ void addMethod(
     return Optional.ofNullable(methods.get(request));
   }
 
+  /** Returns all of the {@link ModifiableBindingMethod}s. */
+  ImmutableList<ModifiableBindingMethod> allMethods() {
+    return ImmutableList.copyOf(methods.values());
+  }
+
   /**
    * Mark the {@link ModifiableBindingMethod} as having been implemented, thus modifying the
    * binding.
@@ -88,23 +101,34 @@ boolean finalized(ModifiableBindingMethod method) {
     private static ModifiableBindingMethod create(
         ModifiableBindingType type,
         BindingRequest request,
+        TypeMirror returnType,
         MethodSpec methodSpec,
         boolean finalized) {
       return new AutoValue_ModifiableBindingMethods_ModifiableBindingMethod(
-          type, request, methodSpec, finalized);
+          type, request, MoreTypes.equivalence().wrap(returnType), methodSpec, finalized);
     }
 
     /** Create a {@ModifiableBindingMethod} representing an implementation of an existing method. */
     static ModifiableBindingMethod implement(
         ModifiableBindingMethod unimplementedMethod, MethodSpec methodSpec, boolean finalized) {
       return new AutoValue_ModifiableBindingMethods_ModifiableBindingMethod(
-          unimplementedMethod.type(), unimplementedMethod.request(), methodSpec, finalized);
+          unimplementedMethod.type(),
+          unimplementedMethod.request(),
+          unimplementedMethod.returnTypeWrapper(),
+          methodSpec,
+          finalized);
     }
 
     abstract ModifiableBindingType type();
 
     abstract BindingRequest request();
 
+    final TypeMirror returnType() {
+      return returnTypeWrapper().get();
+    }
+
+    abstract Equivalence.Wrapper<TypeMirror> returnTypeWrapper();
+
     abstract MethodSpec methodSpec();
 
     abstract boolean finalized();
diff --git a/java/dagger/internal/codegen/ModifiableBindingType.java b/java/dagger/internal/codegen/ModifiableBindingType.java
index d5e2e7c53..92a66f341 100644
--- a/java/dagger/internal/codegen/ModifiableBindingType.java
+++ b/java/dagger/internal/codegen/ModifiableBindingType.java
@@ -70,10 +70,42 @@
    * such bindings are modifiable across subcomponent implementations.
    */
   INJECTION,
+
+  /**
+   * {@link dagger.producers.ProductionScope} is a unique scope that is allowed on multiple
+   * components. In Ahead-of-Time mode, we don't actually know what component will end up owning the
+   * binding because a parent could install the same module or also be an @ProductionScoped @Inject
+   * constructor.
+   *
+   * <p>We don't apply the same logic to @Reusable, even though it can also be on multiple
+   * components, because it is by definition ok to be reimplemented across multiple components.
+   * Allowing @Reusable bindings to be redefined could only result in more code for subclass
+   * implementations.
+   *
+   * <p>All production bindings are also treated as modifiable since they are implicitly {@link
+   * dagger.producers.ProductionScope} in {@link dagger.producers.internal.AbstractProducer}. If an
+   * ancestor component includes the same module as a descendant component, the descendant's
+   * subclass implementation will need to be replaced with the ancestor's {@link
+   * dagger.producers.Producer} instance. beder@ believes this to be a bug and that, because
+   * {@code @Produces} methods are implicitly scoped, descendant components should not be allowed to
+   * redefine the same module as an ancestor. If we disallow that, we can stop treating all
+   * {@code @Produces} methods as modifiable.
+   */
+  PRODUCTION,
+
+  /**
+   * A {@link dagger.Binds} method whose dependency is {@link #MISSING}.
+   *
+   * <p>There's not much to do for @Binds bindings if the dependency is missing - at best, if the
+   * dependency is a weaker scope/unscoped, we save only a few lines that implement the scoping. But
+   * it's also possible, if the dependency is the same or stronger scope, that no extra code is
+   * necessary, in which case we'd be overriding a method that just returns another.
+   */
+  BINDS_METHOD_WITH_MISSING_DEPENDENCY,
   ;
 
   private static final ImmutableSet<ModifiableBindingType> TYPES_WITH_BASE_CLASS_IMPLEMENTATIONS =
-      ImmutableSet.of(MULTIBINDING, OPTIONAL, INJECTION);
+      ImmutableSet.of(NONE, INJECTION, MULTIBINDING, OPTIONAL, PRODUCTION);
 
   boolean isModifiable() {
     return !equals(NONE);
diff --git a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
index fb2c1fdc2..e3583430b 100644
--- a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
@@ -20,11 +20,9 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.PROTECTED;
 
-import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import java.util.Optional;
 
 /**
@@ -37,60 +35,50 @@
   private final BindingRequest request;
   private final ModifiableBindingType modifiableBindingType;
   private final BindingMethodImplementation methodImplementation;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final boolean bindingFinalized;
-  private final Optional<ModifiableBindingMethod> matchingModifiableBindingMethod;
-  private Optional<String> methodName;
+  private final ComponentImplementation componentImplementation;
+  private final boolean bindingCannotBeModified;
+  private Optional<String> methodName = Optional.empty();
 
   ModifiableConcreteMethodBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       BindingRequest request,
       ModifiableBindingType modifiableBindingType,
       BindingMethodImplementation methodImplementation,
-      GeneratedComponentModel generatedComponentModel,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
-      boolean bindingFinalized) {
-    super(methodImplementation, generatedComponentModel);
-    this.binding = resolvedBindings.contributionBinding();
+      ComponentImplementation componentImplementation,
+      boolean bindingCannotBeModified,
+      DaggerTypes types) {
+    super(request, methodImplementation, componentImplementation, types);
+    this.binding = checkNotNull(binding);
     this.request = checkNotNull(request);
     this.modifiableBindingType = checkNotNull(modifiableBindingType);
     this.methodImplementation = checkNotNull(methodImplementation);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.bindingFinalized = bindingFinalized;
-    this.matchingModifiableBindingMethod = matchingModifiableBindingMethod;
-    this.methodName =
-        matchingModifiableBindingMethod.map(modifiableMethod -> modifiableMethod.methodSpec().name);
+    this.componentImplementation = checkNotNull(componentImplementation);
+    this.bindingCannotBeModified = bindingCannotBeModified;
   }
 
   @Override
-  CodeBlock getModifiableBindingMethodImplementation(
-      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
-    // Only emit the method implementation if the binding was known when the expression was created
-    // (and not registered when calling 'getDependencyExpression'), and we're generating a
-    // modifiable binding method for the original component (and not an ancestor component).
-    if (matchingModifiableBindingMethod.isPresent() && generatedComponentModel.equals(component)) {
-      checkState(
-          matchingModifiableBindingMethod.get().fulfillsSameRequestAs(modifiableBindingMethod));
-      return methodImplementation.body();
+  protected void addMethod() {
+    if (methodName.isPresent()) {
+      return;
     }
-    return super.getModifiableBindingMethodImplementation(modifiableBindingMethod, component);
-  }
 
-  @Override
-  protected void addMethod() {
-    // Add the modifiable binding method to the component model if we haven't already.
-    if (!methodName.isPresent()) {
-      methodName = Optional.of(generatedComponentModel.getUniqueMethodName(request, binding));
-      generatedComponentModel.addModifiableBindingMethod(
-          modifiableBindingType,
-          request,
-          methodBuilder(methodName.get())
-              .addModifiers(bindingFinalized ? PRIVATE : PUBLIC)
-              .returns(TypeName.get(methodImplementation.returnType()))
-              .addCode(methodImplementation.body())
-              .build(),
-          bindingFinalized);
+    if (supertypeModifiableBindingMethod().isPresent()) {
+      methodName = supertypeModifiableBindingMethod().map(method -> method.methodSpec().name);
+      return;
     }
+
+    // Add the modifiable binding method to the component if we haven't already.
+    methodName = Optional.of(componentImplementation.getUniqueMethodName(request, binding));
+    componentImplementation.addModifiableBindingMethod(
+        modifiableBindingType,
+        request,
+        methodImplementation.returnType(),
+        methodBuilder(methodName.get())
+            .addModifiers(bindingCannotBeModified ? PRIVATE : PROTECTED)
+            .returns(TypeName.get(methodImplementation.returnType()))
+            .addCode(methodImplementation.body())
+            .build(),
+        bindingCannotBeModified);
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ModuleDescriptor.java b/java/dagger/internal/codegen/ModuleDescriptor.java
index 1210e22ea..c34c0ef1c 100644
--- a/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -20,11 +20,10 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.transform;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
-import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.SourceFiles.classFileName;
@@ -36,21 +35,21 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
+import com.google.common.graph.Traverser;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.Module;
 import dagger.Provides;
+import dagger.model.Key;
 import dagger.multibindings.Multibinds;
-import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
-import java.lang.annotation.Annotation;
-import java.util.EnumSet;
+import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.Optional;
 import java.util.Set;
+import java.util.stream.Stream;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -78,63 +77,20 @@
   /** The {@link BindsOptionalOf} method declarations that define optional bindings. */
   abstract ImmutableSet<OptionalBindingDeclaration> optionalDeclarations();
 
-  abstract Kind kind();
-
-  enum Kind {
-    MODULE(Module.class, Provides.class),
-    PRODUCER_MODULE(ProducerModule.class, Produces.class);
-
-    private final Class<? extends Annotation> moduleAnnotation;
-    private final Class<? extends Annotation> methodAnnotation;
-
-    /**
-     * Returns the kind of an annotated element if it is annotated with one of the {@linkplain
-     * #moduleAnnotation() annotation types}.
-     *
-     * @throws IllegalArgumentException if the element is annotated with more than one of the
-     *     annotation types
-     */
-    static Optional<Kind> forAnnotatedElement(TypeElement element) {
-      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
-      for (Kind kind : values()) {
-        if (MoreElements.isAnnotationPresent(element, kind.moduleAnnotation())) {
-          kinds.add(kind);
-        }
-      }
-      checkArgument(
-          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return kinds.stream().findFirst();
-    }
-
-    Kind(
-        Class<? extends Annotation> moduleAnnotation,
-        Class<? extends Annotation> methodAnnotation) {
-      this.moduleAnnotation = moduleAnnotation;
-      this.methodAnnotation = methodAnnotation;
-    }
-
-    Optional<AnnotationMirror> getModuleAnnotationMirror(TypeElement element) {
-      return getAnnotationMirror(element, moduleAnnotation);
-    }
-
-    Class<? extends Annotation> moduleAnnotation() {
-      return moduleAnnotation;
-    }
-
-    Class<? extends Annotation> methodAnnotation() {
-      return methodAnnotation;
-    }
-
-    ImmutableSet<Kind> includesKinds() {
-      switch (this) {
-        case MODULE:
-          return Sets.immutableEnumSet(MODULE);
-        case PRODUCER_MODULE:
-          return Sets.immutableEnumSet(MODULE, PRODUCER_MODULE);
-        default:
-          throw new AssertionError(this);
-      }
-    }
+  /** The kind of the module. */
+  abstract ModuleKind kind();
+
+  /** Returns the keys of all bindings declared by this module. */
+  ImmutableSet<Key> allBindingKeys() {
+    return Stream.of(
+            bindings(),
+            delegateDeclarations(),
+            multibindingDeclarations(),
+            optionalDeclarations(),
+            subcomponentDeclarations())
+        .flatMap(Collection::stream)
+        .map(BindingDeclaration::key)
+        .collect(toImmutableSet());
   }
 
   static final class Factory {
@@ -197,7 +153,15 @@ ModuleDescriptor create(TypeElement moduleElement) {
           subcomponentDeclarationFactory.forModule(moduleElement),
           delegates.build(),
           optionalDeclarations.build(),
-          Kind.forAnnotatedElement(moduleElement).get());
+          ModuleKind.forAnnotatedElement(moduleElement).get());
+    }
+
+    /** Returns all the modules transitively included by given modules, including the arguments. */
+    ImmutableSet<ModuleDescriptor> transitiveModules(Iterable<TypeElement> modules) {
+      return ImmutableSet.copyOf(
+          Traverser.forGraph(
+                  (ModuleDescriptor module) -> transform(module.includedModules(), this::create))
+              .depthFirstPreOrder(transform(modules, this::create)));
     }
 
     @CanIgnoreReturnValue
diff --git a/java/dagger/internal/codegen/ModuleKind.java b/java/dagger/internal/codegen/ModuleKind.java
new file mode 100644
index 000000000..7087f882a
--- /dev/null
+++ b/java/dagger/internal/codegen/ModuleKind.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.EnumSet;
+import java.util.Optional;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+
+/** Enumeration of the kinds of modules. */
+enum ModuleKind {
+  /** {@code @Module} */
+  MODULE(Module.class, Provides.class),
+
+  /** {@code @ProducerModule} */
+  PRODUCER_MODULE(ProducerModule.class, Produces.class);
+
+  /** Returns the annotations for modules of the given kinds. */
+  static ImmutableSet<Class<? extends Annotation>> annotationsFor(Set<ModuleKind> kinds) {
+    return kinds.stream().map(ModuleKind::annotation).collect(toImmutableSet());
+  }
+
+  /**
+   * Returns the kind of an annotated element if it is annotated with one of the module {@linkplain
+   * #annotation() annotations}.
+   *
+   * @throws IllegalArgumentException if the element is annotated with more than one of the module
+   *     annotations
+   */
+  static Optional<ModuleKind> forAnnotatedElement(TypeElement element) {
+    Set<ModuleKind> kinds = EnumSet.noneOf(ModuleKind.class);
+    for (ModuleKind kind : values()) {
+      if (MoreElements.isAnnotationPresent(element, kind.annotation())) {
+        kinds.add(kind);
+      }
+    }
+
+    if (kinds.size() > 1) {
+      throw new IllegalArgumentException(
+          element + " cannot be annotated with more than one of " + annotationsFor(kinds));
+    }
+    return kinds.stream().findAny();
+  }
+
+  private final Class<? extends Annotation> moduleAnnotation;
+  private final Class<? extends Annotation> methodAnnotation;
+
+  ModuleKind(
+      Class<? extends Annotation> moduleAnnotation, Class<? extends Annotation> methodAnnotation) {
+    this.moduleAnnotation = moduleAnnotation;
+    this.methodAnnotation = methodAnnotation;
+  }
+
+  /**
+   * Returns the annotation mirror for this module kind on the given type.
+   *
+   * @throws IllegalArgumentException if the annotation is not present on the type
+   */
+  AnnotationMirror getModuleAnnotation(TypeElement element) {
+    Optional<AnnotationMirror> result = getAnnotationMirror(element, moduleAnnotation);
+    checkArgument(
+        result.isPresent(), "annotation %s is not present on type %s", moduleAnnotation, element);
+    return result.get();
+  }
+
+  /** Returns the annotation that marks a module of this kind. */
+  Class<? extends Annotation> annotation() {
+    return moduleAnnotation;
+  }
+
+  /** Returns the annotation for binding methods on this type of module. */
+  // TODO(cgdecker): Validate how this is used... is it really correct? Producer modules can also
+  // have @Provides methods.
+  Class<? extends Annotation> methodAnnotation() {
+    return methodAnnotation;
+  }
+
+  /** Returns the kinds of modules that a module of this kind is allowed to include. */
+  ImmutableSet<ModuleKind> legalIncludedModuleKinds() {
+    switch (this) {
+      case MODULE:
+        return Sets.immutableEnumSet(MODULE);
+      case PRODUCER_MODULE:
+        return Sets.immutableEnumSet(MODULE, PRODUCER_MODULE);
+    }
+    throw new AssertionError(this);
+  }
+}
diff --git a/java/dagger/internal/codegen/ModuleProcessingStep.java b/java/dagger/internal/codegen/ModuleProcessingStep.java
index 5e6609bfe..1ae025ffc 100644
--- a/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -21,6 +21,7 @@
 import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
@@ -43,12 +44,12 @@
  * A {@link ProcessingStep} that validates module classes and generates factories for binding
  * methods.
  */
-final class ModuleProcessingStep implements ProcessingStep {
+final class ModuleProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Messager messager;
   private final ModuleValidator moduleValidator;
   private final BindingFactory bindingFactory;
-  private final FactoryGenerator factoryGenerator;
-  private final ProducerFactoryGenerator producerFactoryGenerator;
+  private final SourceFileGenerator<ProvisionBinding> factoryGenerator;
+  private final SourceFileGenerator<ProductionBinding> producerFactoryGenerator;
   private final InaccessibleMapKeyProxyGenerator inaccessibleMapKeyProxyGenerator;
   private final DelegateDeclaration.Factory delegateDeclarationFactory;
   private final Set<TypeElement> processedModuleElements = Sets.newLinkedHashSet();
@@ -58,10 +59,11 @@
       Messager messager,
       ModuleValidator moduleValidator,
       BindingFactory bindingFactory,
-      FactoryGenerator factoryGenerator,
-      ProducerFactoryGenerator producerFactoryGenerator,
+      SourceFileGenerator<ProvisionBinding> factoryGenerator,
+      SourceFileGenerator<ProductionBinding> producerFactoryGenerator,
       InaccessibleMapKeyProxyGenerator inaccessibleMapKeyProxyGenerator,
       Factory delegateDeclarationFactory) {
+    super(MoreElements::asType);
     this.messager = messager;
     this.moduleValidator = moduleValidator;
     this.bindingFactory = bindingFactory;
@@ -77,19 +79,19 @@
   }
 
   @Override
-  public Set<Element> process(
+  public ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     List<TypeElement> modules = typesIn(elementsByAnnotation.values());
     moduleValidator.addKnownModules(modules);
-    for (TypeElement module : modules) {
-      if (processedModuleElements.add(module)) {
-        processModule(module);
-      }
-    }
-    return ImmutableSet.of();
+    return super.process(elementsByAnnotation);
   }
 
-  private void processModule(TypeElement module) {
+  @Override
+  protected void process(
+      TypeElement module, ImmutableSet<Class<? extends Annotation>> annotations) {
+    if (processedModuleElements.contains(module)) {
+      return;
+    }
     ValidationReport<TypeElement> report = moduleValidator.validate(module);
     report.printMessagesTo(messager);
     if (report.isClean()) {
@@ -103,6 +105,7 @@ private void processModule(TypeElement module) {
         }
       }
     }
+    processedModuleElements.add(module);
   }
 
   private <B extends ContributionBinding> void generate(
diff --git a/java/dagger/android/ActivityKey.java b/java/dagger/internal/codegen/ModuleValidation.java
similarity index 59%
rename from java/dagger/android/ActivityKey.java
rename to java/dagger/internal/codegen/ModuleValidation.java
index 22b94171d..209ba6feb 100644
--- a/java/dagger/android/ActivityKey.java
+++ b/java/dagger/internal/codegen/ModuleValidation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Dagger Authors.
+ * Copyright (C) 2018 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,21 +14,18 @@
  * limitations under the License.
  */
 
-package dagger.android;
+package dagger.internal.codegen;
 
-import static java.lang.annotation.ElementType.METHOD;
-
-import android.app.Activity;
-import dagger.MapKey;
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.inject.Qualifier;
 
-/** {@link MapKey} annotation to key bindings by a type of an {@link Activity}. */
-@Beta
-@MapKey
+/**
+ * Qualifier annotation for the {@link dagger.spi.BindingGraphPlugin}s that are used to implement
+ * core Dagger validation for module binding graphs.
+ */
 @Documented
-@Target(METHOD)
-public @interface ActivityKey {
-  Class<? extends Activity> value();
-}
+@Retention(RetentionPolicy.RUNTIME)
+@Qualifier
+@interface ModuleValidation {}
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 89715eaf0..6f115656d 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -27,7 +27,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
-import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentCreator;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
@@ -52,6 +52,7 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.Subcomponent;
+import dagger.model.BindingGraph;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import dagger.producers.ProductionSubcomponent;
@@ -111,6 +112,12 @@
   private final DaggerElements elements;
   private final AnyBindingMethodValidator anyBindingMethodValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BindingGraphFactory bindingGraphFactory;
+  private final BindingGraphConverter bindingGraphConverter;
+  private final BindingGraphPlugins moduleValidationPlugins;
+  private final BindingGraphPlugins spiPlugins;
+  private final CompilerOptions compilerOptions;
   private final Map<TypeElement, ValidationReport<TypeElement>> cache = new HashMap<>();
   private final Set<TypeElement> knownModules = new HashSet<>();
 
@@ -119,11 +126,23 @@
       Types types,
       DaggerElements elements,
       AnyBindingMethodValidator anyBindingMethodValidator,
-      MethodSignatureFormatter methodSignatureFormatter) {
+      MethodSignatureFormatter methodSignatureFormatter,
+      ComponentDescriptor.Factory componentDescriptorFactory,
+      BindingGraphFactory bindingGraphFactory,
+      BindingGraphConverter bindingGraphConverter,
+      @ModuleValidation BindingGraphPlugins moduleValidationPlugins,
+      BindingGraphPlugins spiPlugins,
+      CompilerOptions compilerOptions) {
     this.types = types;
     this.elements = elements;
     this.anyBindingMethodValidator = anyBindingMethodValidator;
     this.methodSignatureFormatter = methodSignatureFormatter;
+    this.componentDescriptorFactory = componentDescriptorFactory;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.bindingGraphConverter = bindingGraphConverter;
+    this.moduleValidationPlugins = moduleValidationPlugins;
+    this.spiPlugins = spiPlugins;
+    this.compilerOptions = compilerOptions;
   }
 
   /**
@@ -156,7 +175,7 @@ void addKnownModules(Collection<TypeElement> modules) {
   private ValidationReport<TypeElement> validateUncached(
       TypeElement module, Set<TypeElement> visitedModules) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(module);
-    ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(module).get();
+    ModuleKind moduleKind = ModuleKind.forAnnotatedElement(module).get();
 
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
@@ -202,7 +221,7 @@ void addKnownModules(Collection<TypeElement> modules) {
           String.format(
               "A @%s may not contain both non-static @%s methods and "
                   + "abstract @Binds or @Multibinds declarations",
-              moduleKind.moduleAnnotation().getSimpleName(),
+              moduleKind.annotation().getSimpleName(),
               moduleKind.methodAnnotation().getSimpleName()));
     }
 
@@ -218,14 +237,19 @@ void addKnownModules(Collection<TypeElement> modules) {
     validateNoScopeAnnotationsOnModuleElement(module, moduleKind, builder);
     validateSelfCycles(module, builder);
 
+    if (builder.build().isClean()
+        && !compilerOptions.moduleBindingValidationType().equals(ValidationType.NONE)) {
+      validateModuleBindings(module, builder);
+    }
+
     return builder.build();
   }
 
   private void validateReferencedSubcomponents(
       final TypeElement subject,
-      ModuleDescriptor.Kind moduleKind,
+      ModuleKind moduleKind,
       final ValidationReport.Builder<TypeElement> builder) {
-    final AnnotationMirror moduleAnnotation = moduleKind.getModuleAnnotationMirror(subject).get();
+    final AnnotationMirror moduleAnnotation = moduleKind.getModuleAnnotation(subject);
     // TODO(ronshapiro): use validateTypesAreDeclared when it is checked in
     for (TypeMirror subcomponentAttribute : getModuleSubcomponents(moduleAnnotation)) {
       subcomponentAttribute.accept(
@@ -277,7 +301,7 @@ private static void validateSubcomponentHasBuilder(
       TypeElement subcomponentAttribute,
       AnnotationMirror moduleAnnotation,
       ValidationReport.Builder<TypeElement> builder) {
-    if (getSubcomponentBuilder(subcomponentAttribute).isPresent()) {
+    if (getSubcomponentCreator(subcomponentAttribute).isPresent()) {
       return;
     }
     builder.addError(
@@ -322,7 +346,7 @@ private void validateModifiers(
   }
 
   private void validateMethodsWithSameName(
-      ModuleDescriptor.Kind moduleKind,
+      ModuleKind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
@@ -341,13 +365,14 @@ private void validateMethodsWithSameName(
 
   private void validateReferencedModules(
       TypeElement subject,
-      ModuleDescriptor.Kind moduleKind,
+      ModuleKind moduleKind,
       Set<TypeElement> visitedModules,
       ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
-    AnnotationMirror mirror = moduleKind.getModuleAnnotationMirror(subject).get();
+    AnnotationMirror mirror = moduleKind.getModuleAnnotation(subject);
     builder.addSubreport(
-        validateReferencedModules(subject, mirror, moduleKind.includesKinds(), visitedModules));
+        validateReferencedModules(
+            subject, mirror, moduleKind.legalIncludedModuleKinds(), visitedModules));
   }
 
   /**
@@ -368,14 +393,11 @@ private void validateReferencedModules(
   ValidationReport<TypeElement> validateReferencedModules(
       TypeElement annotatedType,
       AnnotationMirror annotation,
-      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds,
+      ImmutableSet<ModuleKind> validModuleKinds,
       Set<TypeElement> visitedModules) {
     ValidationReport.Builder<TypeElement> subreport = ValidationReport.about(annotatedType);
     ImmutableSet<? extends Class<? extends Annotation>> validModuleAnnotations =
-        validModuleKinds
-            .stream()
-            .map(ModuleDescriptor.Kind::moduleAnnotation)
-            .collect(toImmutableSet());
+        validModuleKinds.stream().map(ModuleKind::annotation).collect(toImmutableSet());
 
     for (AnnotationValue includedModule : getModules(annotatedType, annotation)) {
       asType(includedModule)
@@ -423,7 +445,7 @@ private void reportError(String format, Object... args) {
 
   private void validateProvidesOverrides(
       TypeElement subject,
-      ModuleDescriptor.Kind moduleKind,
+      ModuleKind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> allMethodsByName,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
@@ -487,7 +509,7 @@ private void validateProvidesOverrides(
 
   private void validateModuleVisibility(
       final TypeElement moduleElement,
-      ModuleDescriptor.Kind moduleKind,
+      ModuleKind moduleKind,
       final ValidationReport.Builder<?> reportBuilder) {
     Visibility moduleVisibility = Visibility.ofElement(moduleElement);
     if (moduleVisibility.equals(PRIVATE)) {
@@ -507,7 +529,7 @@ private void validateModuleVisibility(
           ImmutableSet<Element> nonPublicModules =
               FluentIterable.from(
                       getModuleIncludes(
-                          getAnnotationMirror(moduleElement, moduleKind.moduleAnnotation()).get()))
+                          getAnnotationMirror(moduleElement, moduleKind.annotation()).get()))
                   .transform(types::asElement)
                   .filter(element -> effectiveVisibilityOfElement(element).compareTo(PUBLIC) < 0)
                   .toSet();
@@ -528,14 +550,12 @@ private void validateModuleVisibility(
   }
 
   private void validateNoScopeAnnotationsOnModuleElement(
-      TypeElement module,
-      ModuleDescriptor.Kind moduleKind,
-      ValidationReport.Builder<TypeElement> report) {
+      TypeElement module, ModuleKind moduleKind, ValidationReport.Builder<TypeElement> report) {
     for (AnnotationMirror scope : getAnnotatedAnnotations(module, Scope.class)) {
       report.addError(
           String.format(
               "@%ss cannot be scoped. Did you mean to scope a method instead?",
-              moduleKind.moduleAnnotation().getSimpleName()),
+              moduleKind.annotation().getSimpleName()),
           module,
           scope);
     }
@@ -570,6 +590,20 @@ public Void visitArray(List<? extends AnnotationValue> values, AnnotationValue p
             null);
   }
 
+  private void validateModuleBindings(
+      TypeElement module, ValidationReport.Builder<TypeElement> report) {
+    BindingGraph bindingGraph =
+        bindingGraphConverter.convert(
+            bindingGraphFactory.create(componentDescriptorFactory.forTypeElement(module)));
+    if (moduleValidationPlugins.pluginsReportErrors(bindingGraph)
+        || spiPlugins.pluginsReportErrors(bindingGraph)) {
+      // Since the plugins use a DiagnosticReporter to report errors, the ValdiationReport won't
+      // have any Items for them. We have to tell the ValidationReport that some errors were
+      // reported for the subject.
+      report.markDirty();
+    }
+  }
+
   private static String formatListForErrorMessage(List<?> things) {
     switch (things.size()) {
       case 0:
diff --git a/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java b/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
index e9475895e..55ae57941 100644
--- a/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
+++ b/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
@@ -16,29 +16,28 @@
 
 package dagger.internal.codegen;
 
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
-import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 
 /**
- * A processing step that is responsible for generating a special module for a
- * {@link ProductionComponent} or {@link ProductionSubcomponent}.
+ * A processing step that is responsible for generating a special module for a {@link
+ * ProductionComponent} or {@link ProductionSubcomponent}.
  */
-final class MonitoringModuleProcessingStep implements ProcessingStep {
+final class MonitoringModuleProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Messager messager;
   private final MonitoringModuleGenerator monitoringModuleGenerator;
 
   @Inject
   MonitoringModuleProcessingStep(
       Messager messager, MonitoringModuleGenerator monitoringModuleGenerator) {
+    super(MoreElements::asType);
     this.messager = messager;
     this.monitoringModuleGenerator = monitoringModuleGenerator;
   }
@@ -49,11 +48,8 @@
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (Element element : elementsByAnnotation.values()) {
+  protected void process(
+      TypeElement element, ImmutableSet<Class<? extends Annotation>> annotations) {
       monitoringModuleGenerator.generate(MoreElements.asType(element), messager);
-    }
-    return ImmutableSet.of();
   }
 }
diff --git a/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
index 4f9c31d95..053506237 100644
--- a/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
+++ b/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -17,39 +17,33 @@
 package dagger.internal.codegen;
 
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
+import static javax.tools.Diagnostic.Kind.ERROR;
 
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import dagger.Binds;
-import dagger.Provides;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
-import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
-import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.tools.Diagnostic.Kind;
+import javax.lang.model.element.ExecutableElement;
 
 /**
  * Processing step that verifies that {@link IntoSet}, {@link ElementsIntoSet} and {@link IntoMap}
- * are not present on invalid elements.
+ * are not present on non-binding methods.
  */
-final class MultibindingAnnotationsProcessingStep implements ProcessingStep {
-
-  private static final ImmutableSet<Class<? extends Annotation>> VALID_BINDING_ANNOTATIONS =
-      ImmutableSet.of(Provides.class, Produces.class, Binds.class);
-
+final class MultibindingAnnotationsProcessingStep
+    extends TypeCheckingProcessingStep<ExecutableElement> {
+  private final AnyBindingMethodValidator anyBindingMethodValidator;
   private final Messager messager;
 
   @Inject
-  MultibindingAnnotationsProcessingStep(Messager messager) {
+  MultibindingAnnotationsProcessingStep(
+      AnyBindingMethodValidator anyBindingMethodValidator, Messager messager) {
+    super(MoreElements::asExecutable);
+    this.anyBindingMethodValidator = anyBindingMethodValidator;
     this.messager = messager;
   }
 
@@ -59,19 +53,16 @@
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (Entry<Class<? extends Annotation>, Element> entry : elementsByAnnotation.entries()) {
-      Element element = entry.getValue();
-      if (!isAnyAnnotationPresent(element, VALID_BINDING_ANNOTATIONS)) {
-        AnnotationMirror annotation = getAnnotationMirror(entry.getValue(), entry.getKey()).get();
-        messager.printMessage(
-            Kind.ERROR,
-            "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods",
-            element,
-            annotation);
-      }
+  protected void process(
+      ExecutableElement method, ImmutableSet<Class<? extends Annotation>> annotations) {
+    if (!anyBindingMethodValidator.isBindingMethod(method)) {
+      annotations.forEach(
+          annotation ->
+              messager.printMessage(
+                  ERROR,
+                  "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods",
+                  method,
+                  getAnnotationMirror(method, annotation).get()));
     }
-    return ImmutableSet.of();
   }
 }
diff --git a/java/dagger/internal/codegen/MultibindingExpression.java b/java/dagger/internal/codegen/MultibindingExpression.java
index fdfd525cd..34a19ab02 100644
--- a/java/dagger/internal/codegen/MultibindingExpression.java
+++ b/java/dagger/internal/codegen/MultibindingExpression.java
@@ -16,7 +16,7 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
@@ -31,19 +31,19 @@
 /** An abstract base class for multibinding {@link BindingExpression}s. */
 abstract class MultibindingExpression extends SimpleInvocationBindingExpression {
   private final ProvisionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
 
   MultibindingExpression(
-      ResolvedBindings resolvedBindings, GeneratedComponentModel generatedComponentModel) {
+      ResolvedBindings resolvedBindings, ComponentImplementation componentImplementation) {
     super(resolvedBindings);
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
   }
 
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
     Expression expression = buildDependencyExpression(requestingClass);
-    generatedComponentModel.registerImplementedMultibinding(binding);
+    componentImplementation.registerImplementedMultibinding(binding, bindingRequest());
     return expression;
   }
 
@@ -54,16 +54,15 @@ Expression getDependencyExpression(ClassName requestingClass) {
   protected abstract Expression buildDependencyExpression(ClassName requestingClass);
 
   /**
-   * Returns the subset of {@code dependencies} that represent multibinding
-   * contributions that were not included in a superclass implementation of this multibinding
-   * method. This is relevant only for ahead-of-time subcomponents. When not generating
-   * ahead-of-time subcomponents there is only one implementation of a multibinding expression and
-   * all {@link DependencyRequest}s from the argment are returned.
+   * Returns the subset of {@code dependencies} that represent multibinding contributions that were
+   * not included in a superclass implementation of this multibinding method. This is relevant only
+   * for ahead-of-time subcomponents. When not generating ahead-of-time subcomponents there is only
+   * one implementation of a multibinding expression and all {@link DependencyRequest}s from the
+   * argment are returned.
    */
   protected SetView<DependencyRequest> getNewContributions(
       ImmutableSet<DependencyRequest> dependencies) {
-    return Sets.difference(
-        dependencies, generatedComponentModel.superclassContributionsMade(binding.key()));
+    return Sets.difference(dependencies, superclassContributions());
   }
 
   /**
@@ -72,22 +71,23 @@ Expression getDependencyExpression(ClassName requestingClass) {
    * when generating ahead-of-time subcomponents.
    */
   protected Optional<CodeBlock> superMethodCall() {
-    if (generatedComponentModel.supermodel().isPresent()) {
+    if (componentImplementation.superclassImplementation().isPresent()) {
       Optional<ModifiableBindingMethod> method =
-          generatedComponentModel.getModifiableBindingMethod(
-              BindingRequest.forDependencyRequest(binding.key(), RequestKind.INSTANCE));
-      checkState(
-          method.isPresent(),
-          "Generating a multibinding super method call when no method has been registered for the "
-              + "binding. Binding is for a %s in %s",
-          binding.key(),
-          generatedComponentModel.name());
-      ImmutableSet<DependencyRequest> superclassContributions =
-          generatedComponentModel.superclassContributionsMade(binding.key());
-      if (!superclassContributions.isEmpty()) {
-        return Optional.of(CodeBlock.of("super.$L()", method.get().methodSpec().name));
+          componentImplementation.getModifiableBindingMethod(bindingRequest());
+      if (method.isPresent()) {
+        if (!superclassContributions().isEmpty()) {
+          return Optional.of(CodeBlock.of("super.$L()", method.get().methodSpec().name));
+        }
       }
     }
     return Optional.empty();
   }
+
+  private BindingRequest bindingRequest() {
+    return BindingRequest.bindingRequest(binding.key(), RequestKind.INSTANCE);
+  }
+
+  private ImmutableSet<DependencyRequest> superclassContributions() {
+    return componentImplementation.superclassContributionsMade(bindingRequest());
+  }
 }
diff --git a/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
new file mode 100644
index 000000000..e01d8d17a
--- /dev/null
+++ b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.Key;
+import java.util.Optional;
+
+/** An abstract factory creation expression for multibindings. */
+abstract class MultibindingFactoryCreationExpression
+    implements FrameworkInstanceCreationExpression {
+  private final ComponentImplementation componentImplementation;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final ContributionBinding binding;
+
+  MultibindingFactoryCreationExpression(
+      ContributionBinding binding,
+      ComponentImplementation componentImplementation,
+      ComponentBindingExpressions componentBindingExpressions) {
+    this.binding = checkNotNull(binding);
+    this.componentImplementation = checkNotNull(componentImplementation);
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+  }
+
+  /** Returns the expression for a dependency of this multibinding. */
+  protected final CodeBlock multibindingDependencyExpression(
+      FrameworkDependency frameworkDependency) {
+    CodeBlock expression =
+        componentBindingExpressions
+            .getDependencyExpression(
+                BindingRequest.bindingRequest(frameworkDependency), componentImplementation.name())
+            .codeBlock();
+    return useRawType()
+        ? CodeBlocks.cast(expression, frameworkDependency.frameworkClass())
+        : expression;
+  }
+
+  protected final ImmutableSet<FrameworkDependency> frameworkDependenciesToImplement() {
+    ImmutableSet<Key> alreadyImplementedKeys =
+        componentImplementation.superclassContributionsMade(bindingRequest()).stream()
+            .map(dependency -> dependency.key())
+            .collect(toImmutableSet());
+    return binding.frameworkDependencies().stream()
+        .filter(frameworkDependency -> !alreadyImplementedKeys.contains(frameworkDependency.key()))
+        .collect(toImmutableSet());
+  }
+
+  protected Optional<CodeBlock> superContributions() {
+    if (frameworkDependenciesToImplement().size() == binding.frameworkDependencies().size()) {
+      return Optional.empty();
+    }
+    ModifiableBindingMethod superMethod =
+        componentImplementation.getModifiableBindingMethod(bindingRequest()).get();
+    return Optional.of(CodeBlock.of("super.$N()", superMethod.methodSpec().name));
+  }
+
+  /** The binding request for this framework instance. */
+  protected final BindingRequest bindingRequest() {
+    return BindingRequest.bindingRequest(
+        binding.key(),
+        binding instanceof ProvisionBinding ? FrameworkType.PROVIDER : FrameworkType.PRODUCER_NODE);
+  }
+
+  /**
+   * Returns true if the {@linkplain ContributionBinding#key() key type} is inaccessible from the
+   * component, and therefore a raw type must be used.
+   */
+  protected final boolean useRawType() {
+    return !componentImplementation.isTypeAccessible(binding.key().type());
+  }
+
+  @Override
+  public final boolean useInnerSwitchingProvider() {
+    return !binding.dependencies().isEmpty();
+  }
+}
diff --git a/java/dagger/internal/codegen/NullableBindingValidator.java b/java/dagger/internal/codegen/NullableBindingValidator.java
index 951e4d410..1452c3ff8 100644
--- a/java/dagger/internal/codegen/NullableBindingValidator.java
+++ b/java/dagger/internal/codegen/NullableBindingValidator.java
@@ -18,11 +18,12 @@
 
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
@@ -43,14 +44,14 @@
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    for (BindingNode bindingNode : nullableBindings(bindingGraph)) {
-      for (DependencyEdge dependencyEdge : nonNullableDependencies(bindingGraph, bindingNode)) {
+    for (dagger.model.Binding binding : nullableBindings(bindingGraph)) {
+      for (DependencyEdge dependencyEdge : nonNullableDependencies(bindingGraph, binding)) {
         diagnosticReporter.reportDependency(
             compilerOptions.nullableValidationKind(),
             dependencyEdge,
             nullableToNonNullable(
-                bindingNode.key().toString(),
-                bindingNode.toString())); // will include the @Nullable
+                binding.key().toString(),
+                binding.toString())); // binding.toString() will include the @Nullable
       }
     }
   }
@@ -60,18 +61,18 @@ public String pluginName() {
     return "Dagger/Nullable";
   }
 
-  private ImmutableList<BindingNode> nullableBindings(BindingGraph bindingGraph) {
-    return bindingGraph.bindingNodes().stream()
-        .filter(bindingNode -> bindingNode.binding().isNullable())
+  private ImmutableList<dagger.model.Binding> nullableBindings(BindingGraph bindingGraph) {
+    return bindingGraph.bindings().stream()
+        .filter(binding -> binding.isNullable())
         .collect(toImmutableList());
   }
 
-  private ImmutableList<DependencyEdge> nonNullableDependencies(
-      BindingGraph bindingGraph, BindingNode bindingNode) {
-    return bindingGraph.inEdges(bindingNode).stream()
+  private ImmutableSet<DependencyEdge> nonNullableDependencies(
+      BindingGraph bindingGraph, dagger.model.Binding binding) {
+    return bindingGraph.network().inEdges(binding).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .filter(edge -> !edge.dependencyRequest().isNullable())
-        .collect(toImmutableList());
+        .collect(toImmutableSet());
   }
 
   @VisibleForTesting
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index 68941dd0f..682978522 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -63,7 +64,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
 
     CodeBlock dependencyExpression =
         componentBindingExpressions
-            .getDependencyExpression(dependency, requestingClass)
+            .getDependencyExpression(bindingRequest(dependency), requestingClass)
             .codeBlock();
 
     // If the dependency type is inaccessible, then we have to use Optional.<Object>of(...), or else
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index 784b8ec9b..9987e1ea0 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -26,11 +26,12 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.ABSENT_OPTIONAL_FIELD;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.ABSENT_OPTIONAL_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.PRESENT_FACTORY;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.ABSENT_OPTIONAL_FIELD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.ABSENT_OPTIONAL_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.PRESENT_FACTORY;
 import static dagger.internal.codegen.RequestKinds.requestTypeName;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
+import static dagger.internal.codegen.TypeNames.abstractProducerOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -60,6 +61,7 @@
 import dagger.producers.internal.Producers;
 import java.util.Comparator;
 import java.util.Map;
+import java.util.Optional;
 import java.util.TreeMap;
 import java.util.concurrent.Executor;
 import javax.inject.Provider;
@@ -67,10 +69,10 @@
 /** The nested class and static methods required by the component to implement optional bindings. */
 // TODO(dpb): Name members simply if a component uses only one of Guava or JDK Optional.
 final class OptionalFactories {
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
 
-  OptionalFactories(GeneratedComponentModel generatedComponentModel) {
-    this.generatedComponentModel = generatedComponentModel;
+  OptionalFactories(ComponentImplementation componentImplementation) {
+    this.componentImplementation = componentImplementation;
   }
 
   /**
@@ -113,7 +115,7 @@ CodeBlock absentOptionalProvider(ContributionBinding binding) {
             optionalKind,
             kind -> {
               MethodSpec method = absentOptionalProviderMethod(kind);
-              generatedComponentModel.addMethod(ABSENT_OPTIONAL_METHOD, method);
+              componentImplementation.addMethod(ABSENT_OPTIONAL_METHOD, method);
               return method;
             }));
   }
@@ -142,7 +144,7 @@ private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
                 optionalKind,
                 kind -> {
                   FieldSpec field = absentOptionalProviderField(kind);
-                  generatedComponentModel.addField(ABSENT_OPTIONAL_FIELD, field);
+                  componentImplementation.addField(ABSENT_OPTIONAL_FIELD, field);
                   return field;
                 }))
         .addCode("return provider;")
@@ -206,6 +208,44 @@ ParameterizedTypeName delegateType() {
       return frameworkType().frameworkClassOf(typeVariable());
     }
 
+    /** Returns the superclass the generated factory should have, if any. */
+    Optional<ParameterizedTypeName> superclass() {
+      switch (frameworkType()) {
+        case PRODUCER_NODE:
+          // TODO(cgdecker): This probably isn't a big issue for now, but it's possible this
+          // shouldn't be an AbstractProducer:
+          // - As AbstractProducer, it'll only call the delegate's get() method once and then cache
+          //   that result (essentially) rather than calling the delegate's get() method each time
+          //   its get() method is called (which was what it did before the cancellation change).
+          // - It's not 100% clear to me whether the view-creation methods should return a view of
+          //   the same view created by the delegate or if they should just return their own views.
+          return Optional.of(abstractProducerOf(optionalType()));
+        default:
+          return Optional.empty();
+      }
+    }
+
+    /** Returns the superinterface the generated factory should have, if any. */
+    Optional<ParameterizedTypeName> superinterface() {
+      switch (frameworkType()) {
+        case PROVIDER:
+          return Optional.of(factoryType());
+        default:
+          return Optional.empty();
+      }
+    }
+
+    /** Returns the name of the factory method to generate. */
+    String factoryMethodName() {
+      switch (frameworkType()) {
+        case PROVIDER:
+          return "get";
+        case PRODUCER_NODE:
+          return "compute";
+      }
+      throw new AssertionError(frameworkType());
+    }
+
     /** The name of the factory class. */
     String factoryClassName() {
       return new StringBuilder("Present")
@@ -253,7 +293,7 @@ CodeBlock presentOptionalFactory(ContributionBinding binding, CodeBlock delegate
             PresentFactorySpec.of(binding),
             spec -> {
               TypeSpec type = presentOptionalFactoryClass(spec);
-              generatedComponentModel.addType(PRESENT_FACTORY, type);
+              componentImplementation.addType(PRESENT_FACTORY, type);
               return type;
             }),
         delegateFactory);
@@ -263,12 +303,19 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
     FieldSpec delegateField =
         FieldSpec.builder(spec.delegateType(), "delegate", PRIVATE, FINAL).build();
     ParameterSpec delegateParameter = ParameterSpec.builder(delegateField.type, "delegate").build();
-    return classBuilder(spec.factoryClassName())
-        .addTypeVariable(spec.typeVariable())
-        .addModifiers(PRIVATE, STATIC, FINAL)
-        .addSuperinterface(spec.factoryType())
-        .addJavadoc(
-            "A {@code $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
+    TypeSpec.Builder factoryClassBuilder =
+        classBuilder(spec.factoryClassName())
+            .addTypeVariable(spec.typeVariable())
+            .addModifiers(PRIVATE, STATIC, FINAL)
+            .addJavadoc(
+                "A {@code $T} that uses a delegate {@code $T}.",
+                spec.factoryType(),
+                delegateField.type);
+
+    spec.superclass().ifPresent(factoryClassBuilder::superclass);
+    spec.superinterface().ifPresent(factoryClassBuilder::addSuperinterface);
+
+    return factoryClassBuilder
         .addField(delegateField)
         .addMethod(
             constructorBuilder()
@@ -299,7 +346,7 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
   private MethodSpec presentOptionalFactoryGetMethod(
       PresentFactorySpec spec, FieldSpec delegateField) {
     MethodSpec.Builder getMethodBuilder =
-        methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
+        methodBuilder(spec.factoryMethodName()).addAnnotation(Override.class).addModifiers(PUBLIC);
 
     switch (spec.frameworkType()) {
       case PROVIDER:
@@ -313,7 +360,7 @@ private MethodSpec presentOptionalFactoryGetMethod(
                             spec.valueKind(), CodeBlock.of("$N", delegateField))))
             .build();
 
-      case PRODUCER:
+      case PRODUCER_NODE:
         getMethodBuilder.returns(listenableFutureOf(spec.optionalType()));
 
         switch (spec.valueKind()) {
@@ -325,7 +372,7 @@ private MethodSpec presentOptionalFactoryGetMethod(
                     Futures.class,
                     spec.optionalKind()
                         .presentExpression(
-                            FrameworkType.PRODUCER.to(
+                            FrameworkType.PRODUCER_NODE.to(
                                 spec.valueKind(), CodeBlock.of("$N", delegateField))))
                 .build();
 
diff --git a/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
index cffcbc83e..9d53c0ec4 100644
--- a/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
+++ b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
@@ -29,17 +30,17 @@
     implements FrameworkInstanceCreationExpression {
   private final OptionalFactories optionalFactories;
   private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentBindingExpressions componentBindingExpressions;
 
   OptionalFactoryInstanceCreationExpression(
       OptionalFactories optionalFactories,
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions) {
     this.optionalFactories = optionalFactories;
     this.binding = binding;
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.componentBindingExpressions = componentBindingExpressions;
   }
 
@@ -51,7 +52,8 @@ public CodeBlock creationExpression() {
             binding,
             componentBindingExpressions
                 .getDependencyExpression(
-                    getOnlyElement(binding.frameworkDependencies()), generatedComponentModel.name())
+                    bindingRequest(getOnlyElement(binding.frameworkDependencies())),
+                    componentImplementation.name())
                 .codeBlock());
   }
 
diff --git a/java/dagger/internal/codegen/Optionals.java b/java/dagger/internal/codegen/Optionals.java
index f8963db36..1021c35ed 100644
--- a/java/dagger/internal/codegen/Optionals.java
+++ b/java/dagger/internal/codegen/Optionals.java
@@ -21,6 +21,7 @@
 
 import java.util.Comparator;
 import java.util.Optional;
+import java.util.function.Function;
 
 /** Utilities for {@link Optional}s. */
 final class Optionals {
@@ -48,5 +49,20 @@
         .orElse(Optional.empty());
   }
 
+  /**
+   * Walks a chain of present optionals as defined by successive calls to {@code nextFunction},
+   * returning the value of the final optional that is present. The first optional in the chain is
+   * the result of {@code nextFunction(start)}.
+   */
+  static <T> T rootmostValue(T start, Function<T, Optional<T>> nextFunction) {
+    T current = start;
+    for (Optional<T> next = nextFunction.apply(start);
+        next.isPresent();
+        next = nextFunction.apply(current)) {
+      current = next.get();
+    }
+    return current;
+  }
+
   private Optionals() {}
 }
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 88893fd8a..0d6fc666d 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -19,7 +19,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.PRIVATE_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.PRIVATE_METHOD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.squareup.javapoet.TypeName;
@@ -33,28 +33,29 @@
   private final ContributionBinding binding;
   private final BindingRequest request;
   private final BindingMethodImplementation methodImplementation;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private String methodName;
 
   PrivateMethodBindingExpression(
-      ResolvedBindings resolvedBindings,
+      ContributionBinding binding,
       BindingRequest request,
       BindingMethodImplementation methodImplementation,
-      GeneratedComponentModel generatedComponentModel) {
-    super(methodImplementation, generatedComponentModel);
-    this.binding = resolvedBindings.contributionBinding();
+      ComponentImplementation componentImplementation,
+      DaggerTypes types) {
+    super(request, methodImplementation, componentImplementation, types);
+    this.binding = checkNotNull(binding);
     this.request = checkNotNull(request);
     this.methodImplementation = checkNotNull(methodImplementation);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
   }
 
   @Override
   protected void addMethod() {
     if (methodName == null) {
       // Have to set methodName field before implementing the method in order to handle recursion.
-      methodName = generatedComponentModel.getUniqueMethodName(request, binding);
+      methodName = componentImplementation.getUniqueMethodName(request, binding);
       // TODO(user): Fix the order that these generated methods are written to the component.
-      generatedComponentModel.addMethod(
+      componentImplementation.addMethod(
           PRIVATE_METHOD,
           methodBuilder(methodName)
               .addModifiers(PRIVATE)
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
index 2c104f5ba..9bb0873d0 100644
--- a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
@@ -79,8 +79,8 @@ DaggerElements daggerElements() {
 
   @Provides
   @Reusable // to avoid parsing options more than once
-  CompilerOptions compilerOptions(DaggerElements elements) {
-    return CompilerOptions.create(processingEnvironment, elements);
+  CompilerOptions compilerOptions() {
+    return CompilerOptions.create(processingEnvironment);
   }
 
   @Module
diff --git a/java/dagger/internal/codegen/ProducerCreationExpression.java b/java/dagger/internal/codegen/ProducerCreationExpression.java
index 56e82a804..05d74f8d0 100644
--- a/java/dagger/internal/codegen/ProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/ProducerCreationExpression.java
@@ -43,7 +43,7 @@
   @Override
   public CodeBlock creationExpression() {
     return CodeBlock.of(
-        "new $T($L)",
+        "$T.create($L)",
         generatedClassNameForBinding(binding),
         componentBindingExpressions.getCreateMethodArgumentsCodeBlock(binding));
   }
diff --git a/java/dagger/internal/codegen/ProducerEntryPointView.java b/java/dagger/internal/codegen/ProducerEntryPointView.java
new file mode 100644
index 000000000..c796ea2eb
--- /dev/null
+++ b/java/dagger/internal/codegen/ProducerEntryPointView.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.FRAMEWORK_FIELD;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.model.RequestKind;
+import dagger.producers.Producer;
+import dagger.producers.internal.CancellationListener;
+import dagger.producers.internal.Producers;
+import java.util.Optional;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A factory of {@linkplain Producers#entryPointViewOf(Producer, CancellationListener) entry point
+ * views} of {@link Producer}s.
+ */
+final class ProducerEntryPointView {
+  private final DaggerTypes types;
+
+  ProducerEntryPointView(DaggerTypes types) {
+    this.types = types;
+  }
+
+  /**
+   * Returns an expression for an {@linkplain Producers#entryPointViewOf(Producer,
+   * CancellationListener) entry point view} of a producer if the component method returns a {@link
+   * Producer} or {@link com.google.common.util.concurrent.ListenableFuture}.
+   *
+   * <p>This is intended to be a replacement implementation for {@link
+   * BindingExpression#getDependencyExpressionForComponentMethod(ComponentMethodDescriptor,
+   * ComponentImplementation)}, and in cases where {@link Optional#empty()} is returned, callers
+   * should call {@code super.getDependencyExpressionForComponentMethod()}.
+   */
+  Optional<Expression> getProducerEntryPointField(
+      BindingExpression producerExpression,
+      ComponentMethodDescriptor componentMethod,
+      ComponentImplementation component) {
+    if (component.componentDescriptor().kind().isProducer()
+        && (componentMethod.dependencyRequest().get().kind().equals(RequestKind.FUTURE)
+            || componentMethod.dependencyRequest().get().kind().equals(RequestKind.PRODUCER))) {
+      return Optional.of(
+          Expression.create(
+              fieldType(componentMethod),
+              "$N",
+              createField(producerExpression, componentMethod, component)));
+    } else {
+      // If the component isn't a production component, it won't implement CancellationListener and
+      // as such we can't create an entry point. But this binding must also just be a Producer from
+      // Provider anyway in that case, so there shouldn't be an issue.
+      // TODO(b/116855531): Is it really intended that a non-production component can have Producer
+      // entry points?
+      return Optional.empty();
+    }
+  }
+
+  private FieldSpec createField(
+      BindingExpression producerExpression,
+      ComponentMethodDescriptor componentMethod,
+      ComponentImplementation component) {
+    // TODO(cgdecker): Use a FrameworkFieldInitializer for this?
+    // Though I don't think we need the once-only behavior of that, since I think
+    // getComponentMethodImplementation will only be called once anyway
+    String methodName = componentMethod.methodElement().getSimpleName().toString();
+    FieldSpec field =
+        FieldSpec.builder(
+                TypeName.get(fieldType(componentMethod)),
+                component.getUniqueFieldName(methodName + "EntryPoint"),
+                PRIVATE)
+            .build();
+    component.addField(FRAMEWORK_FIELD, field);
+
+    CodeBlock fieldInitialization =
+        CodeBlock.of(
+            "this.$N = $T.entryPointViewOf($L, this);",
+            field,
+            Producers.class,
+            producerExpression.getDependencyExpression(component.name()).codeBlock());
+    component.addInitialization(fieldInitialization);
+
+    return field;
+  }
+
+  // TODO(cgdecker): Can we use producerExpression.getDependencyExpression().type() instead of
+  // needing to (re)compute this?
+  private TypeMirror fieldType(ComponentMethodDescriptor componentMethod) {
+    return types.wrapType(componentMethod.dependencyRequest().get().key().type(), Producer.class);
+  }
+}
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 8cb913d54..4d3df446a 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -24,11 +24,13 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.TypeNames.FUTURES;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
 import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
@@ -41,6 +43,7 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -59,6 +62,7 @@
 import dagger.model.RequestKind;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducesMethodProducer;
+import dagger.producers.internal.Producers;
 import java.util.Map;
 import java.util.Optional;
 import javax.annotation.processing.Filer;
@@ -121,7 +125,7 @@ Element originatingElement(ProductionBinding binding) {
     UniqueNameSet uniqueFieldNames = new UniqueNameSet();
     ImmutableMap.Builder<Key, FieldSpec> fieldsBuilder = ImmutableMap.builder();
 
-    MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PUBLIC);
+    MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PRIVATE);
 
     Optional<FieldSpec> moduleField =
         binding.requiresModuleInstance()
@@ -133,43 +137,44 @@ Element originatingElement(ProductionBinding binding) {
                     TypeName.get(binding.bindingTypeElement().get().asType())))
             : Optional.empty();
 
-    String executorParameterName = null;
-    String monitorParameterName = null;
-    for (Map.Entry<Key, FrameworkField> entry :
-        generateBindingFieldsForDependencies(binding).entrySet()) {
-      Key key = entry.getKey();
-      FrameworkField bindingField = entry.getValue();
-      String fieldName = uniqueFieldNames.getUniqueName(bindingField.name());
-      if (key.equals(keyFactory.forProductionImplementationExecutor())) {
-        executorParameterName = fieldName;
-        constructorBuilder.addParameter(bindingField.type(), executorParameterName);
-        continue;
-      } else if (key.equals(keyFactory.forProductionComponentMonitor())) {
-        monitorParameterName = fieldName;
-        constructorBuilder.addParameter(bindingField.type(), monitorParameterName);
-        continue;
-      }
-      FieldSpec field =
-          addFieldAndConstructorParameter(
-              factoryBuilder, constructorBuilder, fieldName, bindingField.type());
-      fieldsBuilder.put(key, field);
-    }
+    String[] executorParameterName = new String[1];
+    String[] monitorParameterName = new String[1];
+    Map<Key, FrameworkField> bindingFieldsForDependencies =
+        generateBindingFieldsForDependencies(binding);
+    bindingFieldsForDependencies.forEach(
+        (key, bindingField) -> {
+          String fieldName = uniqueFieldNames.getUniqueName(bindingField.name());
+          if (key.equals(keyFactory.forProductionImplementationExecutor())) {
+            executorParameterName[0] = fieldName;
+            constructorBuilder.addParameter(bindingField.type(), executorParameterName[0]);
+          } else if (key.equals(keyFactory.forProductionComponentMonitor())) {
+            monitorParameterName[0] = fieldName;
+            constructorBuilder.addParameter(bindingField.type(), monitorParameterName[0]);
+          } else {
+            FieldSpec field =
+                addFieldAndConstructorParameter(
+                    factoryBuilder, constructorBuilder, fieldName, bindingField.type());
+            fieldsBuilder.put(key, field);
+          }
+        });
     ImmutableMap<Key, FieldSpec> fields = fieldsBuilder.build();
 
     constructorBuilder.addStatement(
         "super($N, $L, $N)",
-        verifyNotNull(monitorParameterName),
+        verifyNotNull(monitorParameterName[0]),
         producerTokenConstruction(generatedTypeName, binding),
-        verifyNotNull(executorParameterName));
+        verifyNotNull(executorParameterName[0]));
 
     if (binding.requiresModuleInstance()) {
-      assignField(constructorBuilder, moduleField.get());
-    }
-    
-    for (FieldSpec field : fields.values()) {
-      assignField(constructorBuilder, field);
+      assignField(constructorBuilder, moduleField.get(), null);
     }
 
+    fields.forEach(
+        (key, field) -> {
+          ParameterizedTypeName type = bindingFieldsForDependencies.get(key).type();
+          assignField(constructorBuilder, field, type);
+        });
+
     MethodSpec.Builder collectDependenciesBuilder =
         methodBuilder("collectDependencies")
             .addAnnotation(Override.class)
@@ -207,13 +212,15 @@ Element originatingElement(ProductionBinding binding) {
       callProducesMethod.addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED));
     }
 
+    MethodSpec constructor = constructorBuilder.build();
     factoryBuilder
         .superclass(
             ParameterizedTypeName.get(
                 ClassName.get(AbstractProducesMethodProducer.class),
                 futureTransform.applyArgType(),
                 providedTypeName))
-        .addMethod(constructorBuilder.build())
+        .addMethod(constructor)
+        .addMethod(staticFactoryMethod(binding, constructor))
         .addMethod(collectDependenciesBuilder.build())
         .addMethod(callProducesMethod.build());
 
@@ -223,6 +230,21 @@ Element originatingElement(ProductionBinding binding) {
     return Optional.of(factoryBuilder);
   }
 
+  private MethodSpec staticFactoryMethod(ProductionBinding binding, MethodSpec constructor) {
+    return MethodSpec.methodBuilder("create")
+        .addModifiers(PUBLIC, STATIC)
+        .returns(parameterizedGeneratedTypeNameForBinding(binding))
+        .addTypeVariables(bindingTypeElementTypeVariableNames(binding))
+        .addParameters(constructor.parameters)
+        .addStatement(
+            "return new $T($L)",
+            parameterizedGeneratedTypeNameForBinding(binding),
+            constructor.parameters.stream()
+                .map(p -> CodeBlock.of("$N", p.name))
+                .collect(toParametersCodeBlock()))
+        .build();
+  }
+
   // TODO(ronshapiro): consolidate versions of these
   private static FieldSpec addFieldAndConstructorParameter(
       TypeSpec.Builder typeBuilder,
@@ -235,8 +257,14 @@ private static FieldSpec addFieldAndConstructorParameter(
     return field;
   }
 
-  private static void assignField(MethodSpec.Builder constructorBuilder, FieldSpec field) {
-    constructorBuilder.addStatement("this.$1N = $1N", field);
+  private static void assignField(
+      MethodSpec.Builder constructorBuilder, FieldSpec field, ParameterizedTypeName type) {
+    if (type != null && type.rawType.equals(TypeNames.PRODUCER)) {
+      constructorBuilder.addStatement(
+          "this.$1N = $2T.nonCancellationPropagatingViewOf($1N)", field, Producers.class);
+    } else {
+      constructorBuilder.addStatement("this.$1N = $1N", field);
+    }
   }
 
   /** Returns a list of dependencies that are generated asynchronously. */
diff --git a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
index d35e6c2a0..5ad9236ab 100644
--- a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -28,15 +29,15 @@
 /** An {@link Producer} creation expression for provision bindings. */
 final class ProducerFromProviderCreationExpression implements FrameworkInstanceCreationExpression {
   private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentBindingExpressions componentBindingExpressions;
 
   ProducerFromProviderCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions) {
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
   }
 
@@ -46,8 +47,8 @@ public CodeBlock creationExpression() {
         RequestKind.PRODUCER,
         componentBindingExpressions
             .getDependencyExpression(
-                FrameworkDependency.create(binding.key(), FrameworkType.PROVIDER),
-                generatedComponentModel.name())
+                bindingRequest(binding.key(), FrameworkType.PROVIDER),
+                componentImplementation.name())
             .codeBlock());
   }
 
diff --git a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
new file mode 100644
index 000000000..5c7dd0165
--- /dev/null
+++ b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.squareup.javapoet.ClassName;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.model.Key;
+
+/** Binding expression for producer node instances. */
+final class ProducerNodeInstanceBindingExpression extends FrameworkInstanceBindingExpression {
+  /** The component defining this binding. */
+  private final ComponentImplementation componentImplementation;
+  private final Key key;
+  private final ProducerEntryPointView producerEntryPointView;
+
+  ProducerNodeInstanceBindingExpression(
+      ResolvedBindings resolvedBindings,
+      FrameworkInstanceSupplier frameworkInstanceSupplier,
+      DaggerTypes types,
+      DaggerElements elements,
+      ComponentImplementation componentImplementation) {
+    super(resolvedBindings, frameworkInstanceSupplier, types, elements);
+    this.componentImplementation = checkNotNull(componentImplementation);
+    this.key = resolvedBindings.key();
+    this.producerEntryPointView = new ProducerEntryPointView(types);
+  }
+
+  @Override
+  protected FrameworkType frameworkType() {
+    return FrameworkType.PRODUCER_NODE;
+  }
+
+  @Override
+  Expression getDependencyExpression(ClassName requestingClass) {
+    Expression result = super.getDependencyExpression(requestingClass);
+    componentImplementation.addCancellableProducerKey(key);
+    return result;
+  }
+
+  @Override
+  Expression getDependencyExpressionForComponentMethod(
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
+    return producerEntryPointView
+        .getProducerEntryPointField(this, componentMethod, component)
+        .orElseGet(
+            () -> super.getDependencyExpressionForComponentMethod(componentMethod, component));
+  }
+}
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index 15deac730..12a6c3ecf 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -104,11 +104,6 @@ static Builder builder() {
         .thrownTypes(ImmutableList.<TypeMirror>of());
   }
 
-  @Override
-  public final boolean isProduction() {
-    return true;
-  }
-
   @AutoValue.Builder
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<ProductionBinding, Builder> {
diff --git a/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java b/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
deleted file mode 100644
index a28981a72..000000000
--- a/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.STATIC;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.ParameterSpec;
-import com.squareup.javapoet.TypeSpec;
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.Production;
-import dagger.producers.ProductionScope;
-import dagger.producers.internal.ProductionImplementation;
-import java.util.Optional;
-import java.util.concurrent.Executor;
-import javax.annotation.processing.Filer;
-import javax.inject.Inject;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
-
-/** Generates a producer executor module for use with production components. */
-// TODO(beder): Replace this with a single class when the producers client library exists.
-final class ProductionExecutorModuleGenerator extends SourceFileGenerator<TypeElement> {
-
-  @Inject
-  ProductionExecutorModuleGenerator(Filer filer, Elements elements, SourceVersion sourceVersion) {
-    super(filer, elements, sourceVersion);
-  }
-
-  @Override
-  ClassName nameGeneratedType(TypeElement componentElement) {
-    return SourceFiles.generatedProductionExecutorModuleName(componentElement);
-  }
-
-  @Override
-  Element originatingElement(TypeElement componentElement) {
-    return componentElement;
-  }
-
-  @Override
-  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
-    return Optional.of(
-        classBuilder(generatedTypeName)
-            .addAnnotation(Module.class)
-            .addModifiers(FINAL)
-            .addMethod(
-                methodBuilder("executor")
-                    .returns(Executor.class)
-                    .addModifiers(STATIC)
-                    .addAnnotation(Provides.class)
-                    .addAnnotation(ProductionScope.class)
-                    .addAnnotation(ProductionImplementation.class)
-                    .addParameter(
-                        ParameterSpec.builder(Executor.class, "executor")
-                            .addAnnotation(Production.class)
-                            .build())
-                    .addStatement("return executor")
-                    .build()));
-  }
-}
diff --git a/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java b/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
deleted file mode 100644
index 07cd49083..000000000
--- a/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.inject.Inject;
-import javax.lang.model.element.Element;
-
-/**
- * A processing step that is responsible for generating a special module for a
- * {@link ProductionComponent} or {@link ProductionSubcomponent}.
- */
-final class ProductionExecutorModuleProcessingStep implements ProcessingStep {
-  private final Messager messager;
-  private final ProductionExecutorModuleGenerator productionExecutorModuleGenerator;
-
-  @Inject
-  ProductionExecutorModuleProcessingStep(
-      Messager messager, ProductionExecutorModuleGenerator productionExecutorModuleGenerator) {
-    this.messager = messager;
-    this.productionExecutorModuleGenerator = productionExecutorModuleGenerator;
-  }
-
-  @Override
-  public Set<? extends Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(ProductionComponent.class, ProductionSubcomponent.class);
-  }
-
-  @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (Element element : elementsByAnnotation.values()) {
-      productionExecutorModuleGenerator.generate(MoreElements.asType(element), messager);
-    }
-    return ImmutableSet.of();
-  }
-}
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index 09d29e18e..492cefc24 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -97,11 +97,6 @@ boolean shouldCheckForNull(CompilerOptions compilerOptions) {
         && compilerOptions.doCheckForNulls();
   }
 
-  @Override
-  public final boolean isProduction() {
-    return false;
-  }
-
   @AutoValue.Builder
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<ProvisionBinding, Builder> {
diff --git a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
index a9a9c7d2d..ce918624f 100644
--- a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
+++ b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
@@ -23,7 +23,6 @@
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Node;
 import dagger.spi.BindingGraphPlugin;
@@ -61,8 +60,8 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   private Stream<DependencyEdge> provisionDependenciesOnProductionBindings(
       BindingGraph bindingGraph) {
-    return bindingGraph.bindingNodes().stream()
-        .filter(bindingNode -> bindingNode.binding().isProduction())
+    return bindingGraph.bindings().stream()
+        .filter(binding -> binding.isProduction())
         .flatMap(binding -> incomingDependencies(binding, bindingGraph))
         .filter(edge -> !dependencyCanUseProduction(edge, bindingGraph));
   }
@@ -70,14 +69,15 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   /** Returns the dependencies on {@code binding}. */
   // TODO(dpb): Move to BindingGraph.
   private Stream<DependencyEdge> incomingDependencies(
-      BindingNode binding, BindingGraph bindingGraph) {
-    return bindingGraph.inEdges(binding).stream().flatMap(instancesOf(DependencyEdge.class));
+      dagger.model.Binding binding, BindingGraph bindingGraph) {
+    return bindingGraph.network().inEdges(binding).stream()
+        .flatMap(instancesOf(DependencyEdge.class));
   }
 
   private boolean dependencyCanUseProduction(DependencyEdge edge, BindingGraph bindingGraph) {
     return edge.isEntryPoint()
         ? entryPointCanUseProduction(edge.dependencyRequest().kind())
-        : bindingRequestingDependency(edge, bindingGraph).binding().isProduction();
+        : bindingRequestingDependency(edge, bindingGraph).isProduction();
   }
 
   /**
@@ -87,16 +87,16 @@ private boolean dependencyCanUseProduction(DependencyEdge edge, BindingGraph bin
    *     DependencyEdge#isEntryPoint() entry point}.
    */
   // TODO(dpb): Move to BindingGraph.
-  private BindingNode bindingRequestingDependency(
+  private dagger.model.Binding bindingRequestingDependency(
       DependencyEdge dependency, BindingGraph bindingGraph) {
     checkArgument(!dependency.isEntryPoint());
-    Node source = bindingGraph.incidentNodes(dependency).source();
+    Node source = bindingGraph.network().incidentNodes(dependency).source();
     verify(
-        source instanceof BindingNode,
-        "expected source of %s to be a binding node, but was: %s",
+        source instanceof dagger.model.Binding,
+        "expected source of %s to be a binding, but was: %s",
         dependency,
         source);
-    return (BindingNode) source;
+    return (dagger.model.Binding) source;
   }
 
   private String entryPointErrorMessage(DependencyEdge entryPoint) {
diff --git a/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
new file mode 100644
index 000000000..f76c49c67
--- /dev/null
+++ b/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.MissingBindingFactory;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.producers.internal.MissingBindingProducer;
+import java.util.Optional;
+
+/**
+ * A {@link BindingExpression} that implements a method that encapsulates a binding that is not part
+ * of the binding graph when generating a final concrete implementation of a subcomponent. The
+ * implementation throws an exception. It is assumed that a binding may remain missing in a valid
+ * binding graph, because it's possible for there to be dependencies that are passively pruned when
+ * a non-leaf binding is re-defined (such as when {@code @Provides} bindings override
+ * {@code @Inject} bindings).
+ *
+ * <p>This method should never be invoked. If it is the exception indicates an issue within Dagger
+ * itself.
+ */
+final class PrunedConcreteMethodBindingExpression extends BindingExpression {
+  private static final CodeBlock METHOD_IMPLEMENTATION =
+      CodeBlock.of(
+          "throw new $T($S);",
+          UnsupportedOperationException.class,
+          "This binding is not part of the final binding graph. The key was requested by a binding "
+              + "that was believed to possibly be part of the graph, but is no longer requested. "
+              + "If this exception is thrown, it is the result of a Dagger bug.");
+
+  PrunedConcreteMethodBindingExpression() {}
+
+  @Override
+  CodeBlock getModifiableBindingMethodImplementation(
+      ModifiableBindingMethod modifiableBindingMethod,
+      ComponentImplementation component,
+      DaggerTypes types) {
+    Optional<FrameworkType> frameworkType = modifiableBindingMethod.request().frameworkType();
+    if (frameworkType.isPresent()) {
+      // If we make initializations replaceable, we can do away with these classes and this logic
+      // since the pruned framework instances will no longer be initialized
+      switch (frameworkType.get()) {
+        case PROVIDER:
+          return missingFrameworkInstance(MissingBindingFactory.class);
+        case PRODUCER_NODE:
+          return missingFrameworkInstance(MissingBindingProducer.class);
+      }
+      throw new AssertionError(frameworkType);
+    }
+    return METHOD_IMPLEMENTATION;
+  }
+
+  private static CodeBlock missingFrameworkInstance(Class<?> factoryClass) {
+    return CodeBlock.builder().addStatement("return $T.create()", factoryClass).build();
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    throw new UnsupportedOperationException(
+        "Requesting a dependency expression for a pruned binding.");
+  }
+}
diff --git a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
deleted file mode 100644
index 0a42fb2ac..000000000
--- a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.REFERENCE_RELEASING_MANAGER_FIELD;
-import static dagger.internal.codegen.MemberSelect.localField;
-import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
-import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
-import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import dagger.internal.TypedReleasableReferenceManagerDecorator;
-import dagger.model.Scope;
-import java.util.HashMap;
-import java.util.Map;
-import javax.lang.model.element.AnnotationMirror;
-
-/**
- * Manages the {@link dagger.internal.ReferenceReleasingProviderManager} fields and the logic for
- * releasable bindings in the graph.
- *
- * <p>This class should only be created once at the root component and reused by all subcomponents.
- * This is because, currently, all {@link dagger.internal.ReferenceReleasingProviderManager} fields
- * are stored in the root component.
- */
-public class ReferenceReleasingManagerFields {
-  /**
-   * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
-   * indexed by their {@code CanReleaseReferences @CanReleaseReferences} scope.
-   */
-  private final Map<Scope, MemberSelect> referenceReleasingManagerFields = new HashMap<>();
-
-  private final BindingGraph graph;
-  private final GeneratedComponentModel generatedComponentModel;
-
-  ReferenceReleasingManagerFields(
-      BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
-      CompilerOptions compilerOptions) {
-    this.graph = checkNotNull(graph);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    if (!compilerOptions.aheadOfTimeSubcomponents()) {
-      checkArgument(graph.componentDescriptor().kind().isTopLevel());
-    }
-  }
-
-  /**
-   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
-   * decorates the {@code managerExpression} to supply {@code metadata}.
-   */
-  static CodeBlock typedReleasableReferenceManagerDecoratorExpression(
-      CodeBlock managerExpression, AnnotationMirror metadata) {
-    return CodeBlock.of(
-        "new $T<$T>($L, $L)",
-        TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
-        metadata.getAnnotationType(),
-        managerExpression,
-        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
-  }
-
-  /**
-   * Returns {@code true} if {@code scope} is in {@link
-   * BindingGraph#scopesRequiringReleasableReferenceManagers()} for the root graph.
-   */
-  boolean requiresReleasableReferences(Scope scope) {
-    return graph.scopesRequiringReleasableReferenceManagers().contains(scope);
-  }
-
-  /**
-   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
-   * object for a scope.
-   */
-  CodeBlock getExpression(Scope scope, ClassName requestingClass) {
-    return reentrantComputeIfAbsent(
-            referenceReleasingManagerFields, scope, this::createReferenceReleasingManagerField)
-        .getExpressionFor(requestingClass);
-  }
-
-  private MemberSelect createReferenceReleasingManagerField(Scope scope) {
-    FieldSpec field = referenceReleasingProxyManagerField(scope);
-    generatedComponentModel.addField(REFERENCE_RELEASING_MANAGER_FIELD, field);
-    return localField(generatedComponentModel.name(), field.name);
-  }
-
-  private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
-    String fieldName =
-        UPPER_CAMEL.to(LOWER_CAMEL, scope.scopeAnnotationElement().getSimpleName() + "References");
-    return FieldSpec.builder(
-            REFERENCE_RELEASING_PROVIDER_MANAGER,
-            generatedComponentModel.getUniqueFieldName(fieldName))
-        .addModifiers(PRIVATE, FINAL)
-        .initializer(
-            "new $T($T.class)",
-            REFERENCE_RELEASING_PROVIDER_MANAGER,
-            scope.scopeAnnotationElement())
-        .addJavadoc(
-            "The manager that releases references for the {@link $T} scope.\n",
-            scope.scopeAnnotationElement())
-        .build();
-  }
-}
diff --git a/java/dagger/internal/codegen/ReleasableReferenceManagerProviderCreationExpression.java b/java/dagger/internal/codegen/ReleasableReferenceManagerProviderCreationExpression.java
deleted file mode 100644
index 083244c19..000000000
--- a/java/dagger/internal/codegen/ReleasableReferenceManagerProviderCreationExpression.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
-import static dagger.internal.codegen.ReferenceReleasingManagerFields.typedReleasableReferenceManagerDecoratorExpression;
-import static dagger.internal.codegen.TypeNames.providerOf;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
-import dagger.model.Scope;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * A {@link dagger.releasablereferences.ReleasableReferenceManager
- * Provider<ReleasableReferenceManager>} creation expression.
- *
- * <p>The {@code get()} method just returns the component's {@link
- * dagger.internal.ReferenceReleasingProviderManager} field.
- */
-final class ReleasableReferenceManagerProviderCreationExpression
-    implements FrameworkInstanceCreationExpression {
-
-  private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
-
-  ReleasableReferenceManagerProviderCreationExpression(
-      ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields) {
-    this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
-  }
-
-  @Override
-  public CodeBlock creationExpression() {
-    TypeName keyType = TypeName.get(binding.key().type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyType))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyType)
-                    .addCode("return $L;", releasableReferenceManagerExpression())
-                    .build())
-            .build());
-  }
-
-  private CodeBlock releasableReferenceManagerExpression() {
-    // The scope is the value of the @ForReleasableReferences annotation.
-    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
-
-    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
-      /* The key's type is TypedReleasableReferenceManager<M>, so return
-       * new TypedReleasableReferenceManager(field, metadata). */
-      TypeMirror metadataType =
-          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
-      return typedReleasableReferenceManagerDecoratorExpression(
-          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name()),
-          scope.releasableReferencesMetadata(metadataType).get());
-    } else {
-      // The key's type is ReleasableReferenceManager, so return the field as is.
-      return referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name());
-    }
-  }
-
-  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
-    checkArgument(
-        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
-    return Scopes.scope(
-        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
-  }
-}
diff --git a/java/dagger/internal/codegen/ReleasableReferenceManagerSetProviderCreationExpression.java b/java/dagger/internal/codegen/ReleasableReferenceManagerSetProviderCreationExpression.java
deleted file mode 100644
index 078fd6b4a..000000000
--- a/java/dagger/internal/codegen/ReleasableReferenceManagerSetProviderCreationExpression.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ReferenceReleasingManagerFields.typedReleasableReferenceManagerDecoratorExpression;
-import static dagger.internal.codegen.TypeNames.providerOf;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
-import com.google.common.collect.ImmutableList;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
-import dagger.model.Scope;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Optional;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * A {@link ReleasableReferenceManager Provider<Set<ReleasableReferenceManager>>} creation
- * expression.
- *
- * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
- * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
- * include managers for all reference-releasing scopes whose metadata type is {@code M}.
- */
-final class ReleasableReferenceManagerSetProviderCreationExpression
-    implements FrameworkInstanceCreationExpression {
-  private final ContributionBinding binding;
-  private final BindingGraph graph;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
-
-  ReleasableReferenceManagerSetProviderCreationExpression(
-      ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields,
-      BindingGraph graph) {
-    this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
-    this.graph = checkNotNull(graph);
-  }
-
-  @Override
-  public CodeBlock creationExpression() {
-    TypeName keyType = TypeName.get(binding.key().type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyType))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyType)
-                    .addCode(
-                        "return new $T($T.asList($L));",
-                        HashSet.class,
-                        Arrays.class,
-                        makeParametersCodeBlock(releasableReferenceManagerExpressions()))
-                    .build())
-            .build());
-  }
-
-  private ImmutableList<CodeBlock> releasableReferenceManagerExpressions() {
-    SetType keyType = SetType.from(binding.key());
-    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
-    for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
-      CodeBlock releasableReferenceManagerExpression =
-          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name());
-
-      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
-        managerExpressions.add(releasableReferenceManagerExpression);
-      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
-        TypeMirror metadataType =
-            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
-        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
-        if (metadata.isPresent()) {
-          managerExpressions.add(
-              typedReleasableReferenceManagerDecoratorExpression(
-                  releasableReferenceManagerExpression, metadata.get()));
-        }
-      } else {
-        throw new IllegalArgumentException("inappropriate key: " + binding);
-      }
-    }
-    return managerExpressions.build();
-  }
-}
diff --git a/java/dagger/internal/codegen/RequestKinds.java b/java/dagger/internal/codegen/RequestKinds.java
index 1a1516e51..ab0197371 100644
--- a/java/dagger/internal/codegen/RequestKinds.java
+++ b/java/dagger/internal/codegen/RequestKinds.java
@@ -184,5 +184,19 @@ static boolean entryPointCanUseProduction(RequestKind requestKind) {
     throw new AssertionError();
   }
 
+  /**
+   * Returns true if {@code requestKind} is always derived from a {@link RequestKind#PROVIDER}
+   * instance.
+   */
+  static boolean isDerivedFromProvider(RequestKind requestKind) {
+    switch (requestKind) {
+      case LAZY:
+      case PROVIDER_OF_LAZY:
+        return true;
+      default:
+        return false;
+    }
+  }
+
   private RequestKinds() {}
 }
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index d1f73dd29..e6a3a6805 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
@@ -41,12 +42,12 @@
 
   SetBindingExpression(
       ResolvedBindings resolvedBindings,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(resolvedBindings, generatedComponentModel);
+    super(resolvedBindings, componentImplementation);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     this.graph = graph;
     this.componentBindingExpressions = componentBindingExpressions;
@@ -133,7 +134,7 @@ private DeclaredType immutableSetType() {
   private CodeBlock getContributionExpression(
       DependencyRequest dependency, ClassName requestingClass) {
     return componentBindingExpressions
-        .getDependencyExpression(dependency, requestingClass)
+        .getDependencyExpression(bindingRequest(dependency), requestingClass)
         .codeBlock();
   }
 
diff --git a/java/dagger/internal/codegen/SetFactoryCreationExpression.java b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
index 94975680f..d69f4a29b 100644
--- a/java/dagger/internal/codegen/SetFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
@@ -20,34 +20,31 @@
 import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 
 import com.squareup.javapoet.CodeBlock;
-import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
 import dagger.producers.Produced;
+import java.util.Optional;
 
 /** A factory creation expression for a multibound set. */
-// TODO(dpb): Resolve with MapFactoryCreationExpression.
-final class SetFactoryCreationExpression implements FrameworkInstanceCreationExpression {
+final class SetFactoryCreationExpression extends MultibindingFactoryCreationExpression {
 
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ComponentBindingExpressions componentBindingExpressions;
+  private final ComponentImplementation componentImplementation;
   private final BindingGraph graph;
   private final ContributionBinding binding;
 
   SetFactoryCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions,
       BindingGraph graph) {
+    super(binding, componentImplementation, componentBindingExpressions);
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.graph = checkNotNull(graph);
   }
 
   @Override
   public CodeBlock creationExpression() {
     CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
-    boolean useRawType = !generatedComponentModel.isTypeAccessible(binding.key().type());
-    if (!useRawType) {
+    if (!useRawType()) {
       SetType setType = SetType.from(binding.key());
       builder.add(
           "<$T>",
@@ -55,43 +52,51 @@ public CodeBlock creationExpression() {
               ? setType.unwrappedElementType(Produced.class)
               : setType.elementType());
     }
+
     int individualProviders = 0;
     int setProviders = 0;
     CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
+    String methodNameSuffix =
+        binding.bindingType().equals(BindingType.PROVISION) ? "Provider" : "Producer";
+
+    Optional<CodeBlock> superContributions = superContributions();
+    if (superContributions.isPresent()) {
+      // TODO(b/117833324): consider decomposing the Provider<Set<Provider>> and adding the
+      // individual contributions separately from the collection contributions. Though this may
+      // actually not be doable/desirable if the super provider instance is a DelegateFactory or
+      // another internal type that is not SetFactory
+      builderMethodCalls.add(".addCollection$N($L)", methodNameSuffix, superContributions.get());
+      setProviders++;
+    }
+
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesToImplement()) {
       ContributionType contributionType =
           graph.contributionBindings().get(frameworkDependency.key()).contributionType();
-      String methodName;
-      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
+      String methodNamePrefix;
       switch (contributionType) {
         case SET:
           individualProviders++;
-          methodName = "add" + methodNameSuffix;
+          methodNamePrefix = "add";
           break;
         case SET_VALUES:
           setProviders++;
-          methodName = "addCollection" + methodNameSuffix;
+          methodNamePrefix = "addCollection";
           break;
         default:
           throw new AssertionError(frameworkDependency + " is not a set multibinding");
       }
 
-      CodeBlock argument =
-          componentBindingExpressions
-              .getDependencyExpression(frameworkDependency, generatedComponentModel.name())
-              .codeBlock();
       builderMethodCalls.add(
-          ".$L($L)",
-          methodName,
-          useRawType ? CodeBlocks.cast(argument, frameworkDependency.frameworkClass()) : argument);
+          ".$N$N($L)",
+          methodNamePrefix,
+          methodNameSuffix,
+          multibindingDependencyExpression(frameworkDependency));
     }
     builder.add("builder($L, $L)", individualProviders, setProviders);
     builder.add(builderMethodCalls.build());
-    return builder.add(".build()").build();
-  }
 
-  @Override
-  public boolean useInnerSwitchingProvider() {
-    return !binding.dependencies().isEmpty();
+    componentImplementation.registerImplementedMultibinding(binding, bindingRequest());
+
+    return builder.add(".build()").build();
   }
 }
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index f35d0a0d6..fe04bade0 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -24,6 +24,8 @@
 import static dagger.internal.codegen.TypeNames.rawTypeName;
 
 import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
@@ -31,6 +33,7 @@
 import dagger.internal.codegen.InjectionMethods.ProvisionMethod;
 import dagger.model.DependencyRequest;
 import java.util.Optional;
+import java.util.function.Function;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
@@ -45,7 +48,8 @@
   private final ProvisionBinding provisionBinding;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final MembersInjectionMethods membersInjectionMethods;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
+  private final DaggerTypes types;
   private final DaggerElements elements;
 
   SimpleMethodBindingExpression(
@@ -53,7 +57,8 @@
       CompilerOptions compilerOptions,
       ComponentBindingExpressions componentBindingExpressions,
       MembersInjectionMethods membersInjectionMethods,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentRequirementExpressions componentRequirementExpressions,
+      DaggerTypes types,
       DaggerElements elements) {
     super(resolvedBindings);
     this.compilerOptions = compilerOptions;
@@ -64,24 +69,37 @@
     checkArgument(provisionBinding.bindingElement().isPresent());
     this.componentBindingExpressions = componentBindingExpressions;
     this.membersInjectionMethods = membersInjectionMethods;
-    this.componentRequirementFields = componentRequirementFields;
+    this.componentRequirementExpressions = componentRequirementExpressions;
+    this.types = types;
     this.elements = elements;
   }
 
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
-    return requiresInjectionMethod(provisionBinding, compilerOptions, requestingClass.packageName())
-        ? invokeInjectionMethod(requestingClass)
-        : invokeMethod(requestingClass);
+    ImmutableMap<DependencyRequest, Expression> arguments =
+        ImmutableMap.copyOf(
+            Maps.asMap(
+                provisionBinding.dependencies(),
+                request -> dependencyArgument(request, requestingClass)));
+    Function<DependencyRequest, CodeBlock> argumentsFunction =
+        request -> arguments.get(request).codeBlock();
+    return requiresInjectionMethod(
+            provisionBinding,
+            arguments.values().asList(),
+            compilerOptions,
+            requestingClass.packageName(),
+            types)
+        ? invokeInjectionMethod(argumentsFunction, requestingClass)
+        : invokeMethod(argumentsFunction, requestingClass);
   }
 
-  private Expression invokeMethod(ClassName requestingClass) {
+  private Expression invokeMethod(
+      Function<DependencyRequest, CodeBlock> argumentsFunction,
+      ClassName requestingClass) {
     // TODO(dpb): align this with the contents of InlineMethods.create
     CodeBlock arguments =
-        provisionBinding
-            .dependencies()
-            .stream()
-            .map(request -> dependencyArgument(request, requestingClass))
+        provisionBinding.dependencies().stream()
+            .map(argumentsFunction)
             .collect(toParametersCodeBlock());
     ExecutableElement method = asExecutable(provisionBinding.bindingElement().get());
     CodeBlock invocation;
@@ -113,20 +131,19 @@ private TypeName constructorTypeName(ClassName requestingClass) {
     return rawTypeName(typeName);
   }
 
-  private Expression invokeInjectionMethod(ClassName requestingClass) {
+  private Expression invokeInjectionMethod(
+      Function<DependencyRequest, CodeBlock> argumentsFunction, ClassName requestingClass) {
     return injectMembers(
         ProvisionMethod.invoke(
             provisionBinding,
-            request -> dependencyArgument(request, requestingClass),
+            argumentsFunction,
             requestingClass,
             moduleReference(requestingClass),
             compilerOptions));
   }
 
-  private CodeBlock dependencyArgument(DependencyRequest dependency, ClassName requestingClass) {
-    return componentBindingExpressions
-        .getDependencyArgumentExpression(dependency, requestingClass)
-        .codeBlock();
+  private Expression dependencyArgument(DependencyRequest dependency, ClassName requestingClass) {
+    return componentBindingExpressions.getDependencyArgumentExpression(dependency, requestingClass);
   }
 
   private Expression injectMembers(CodeBlock instance) {
@@ -155,9 +172,7 @@ private Expression injectMembers(CodeBlock instance) {
             .contributingModule()
             .map(Element::asType)
             .map(ComponentRequirement::forModule)
-            .map(
-                requirement ->
-                    componentRequirementFields.getExpression(requirement, requestingClass))
+            .map(module -> componentRequirementExpressions.getExpression(module, requestingClass))
         : Optional.empty();
   }
 
diff --git a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
index 944436225..18dc04dcb 100644
--- a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
+++ b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
@@ -16,7 +16,8 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.VOLATILE;
 
@@ -35,27 +36,27 @@
  */
 final class SingleCheckedMethodImplementation extends BindingMethodImplementation {
 
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ResolvedBindings resolvedBindings;
   private final ContributionBinding binding;
   private final BindingRequest request;
   private final Supplier<FieldSpec> field = Suppliers.memoize(this::createField);
 
   SingleCheckedMethodImplementation(
+      ComponentImplementation component,
       ResolvedBindings resolvedBindings,
       BindingRequest request,
       BindingExpression bindingExpression,
-      DaggerTypes types,
-      GeneratedComponentModel generatedComponentModel) {
-    super(resolvedBindings, request, bindingExpression, generatedComponentModel.name(), types);
-    this.generatedComponentModel = generatedComponentModel;
+      DaggerTypes types) {
+    super(component, resolvedBindings.contributionBinding(), request, bindingExpression, types);
+    this.componentImplementation = checkNotNull(component);
     this.resolvedBindings = resolvedBindings;
     this.binding = resolvedBindings.contributionBinding();
-    this.request = request;
+    this.request = checkNotNull(request);
   }
 
   @Override
-  CodeBlock body() {
+  CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
     String fieldExpression = field.get().name.equals("local") ? "this.local" : field.get().name;
 
     CodeBlock.Builder builder = CodeBlock.builder()
@@ -68,7 +69,7 @@ CodeBlock body() {
     }
 
     return builder
-        .addStatement("local = $L", simpleBindingExpression())
+        .addStatement("local = $L", simpleBindingExpression.get())
         .addStatement("$N = ($T) local", fieldExpression, returnType())
         .endControlFlow()
         .addStatement("return ($T) local", returnType())
@@ -77,7 +78,7 @@ CodeBlock body() {
 
   private FieldSpec createField() {
     String name =
-        generatedComponentModel.getUniqueFieldName(
+        componentImplementation.getUniqueFieldName(
             request.isRequestKind(RequestKind.INSTANCE)
                 ? BindingVariableNamer.name(binding)
                 : FrameworkField.forResolvedBindings(resolvedBindings, Optional.empty()).name());
@@ -88,7 +89,7 @@ private FieldSpec createField() {
     }
 
     FieldSpec field = builder.build();
-    generatedComponentModel.addField(PRIVATE_METHOD_SCOPED_FIELD, field);
+    componentImplementation.addField(PRIVATE_METHOD_SCOPED_FIELD, field);
     return field;
   }
 
diff --git a/java/dagger/internal/codegen/SourceFileGenerator.java b/java/dagger/internal/codegen/SourceFileGenerator.java
index 8c663c9c4..2409987a2 100644
--- a/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -51,6 +51,10 @@
     this.sourceVersion = checkNotNull(sourceVersion);
   }
 
+  SourceFileGenerator(SourceFileGenerator<T> delegate) {
+    this(delegate.filer, delegate.elements, delegate.sourceVersion);
+  }
+
   /**
    * Generates a source file to be compiled for {@code T}. Writes any generation exception to {@code
    * messager} and does not throw.
diff --git a/java/dagger/internal/codegen/SourceFileGeneratorsModule.java b/java/dagger/internal/codegen/SourceFileGeneratorsModule.java
new file mode 100644
index 000000000..2fe2a2f9b
--- /dev/null
+++ b/java/dagger/internal/codegen/SourceFileGeneratorsModule.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.codegen.SourceFileGeneratorsModule.ComponentModule;
+import dagger.internal.codegen.SourceFileGeneratorsModule.MembersInjectionModule;
+import dagger.internal.codegen.SourceFileGeneratorsModule.ProductionModule;
+import dagger.internal.codegen.SourceFileGeneratorsModule.ProvisionModule;
+
+@Module(
+    includes = {
+      ProvisionModule.class,
+      ProductionModule.class,
+      MembersInjectionModule.class,
+      ComponentModule.class
+    })
+interface SourceFileGeneratorsModule {
+  @Module
+  abstract class GeneratorModule<T, G extends SourceFileGenerator<T>> {
+    @Provides
+    SourceFileGenerator<T> generator(G generator, CompilerOptions compilerOptions) {
+      return compilerOptions.headerCompilation()
+          ? HjarSourceFileGenerator.wrap(generator)
+          : generator;
+    }
+  }
+
+  @Module
+  class ProvisionModule extends GeneratorModule<ProvisionBinding, FactoryGenerator> {}
+
+  @Module
+  class ProductionModule extends GeneratorModule<ProductionBinding, ProducerFactoryGenerator> {}
+
+  @Module
+  class MembersInjectionModule
+      extends GeneratorModule<MembersInjectionBinding, MembersInjectorGenerator> {}
+
+  @Module
+  class ComponentModule extends GeneratorModule<BindingGraph, ComponentGenerator> {}
+}
diff --git a/java/dagger/internal/codegen/BindingGraphPluginsModule.java b/java/dagger/internal/codegen/SpiModule.java
similarity index 71%
rename from java/dagger/internal/codegen/BindingGraphPluginsModule.java
rename to java/dagger/internal/codegen/SpiModule.java
index 0f34c7608..debf3df98 100644
--- a/java/dagger/internal/codegen/BindingGraphPluginsModule.java
+++ b/java/dagger/internal/codegen/SpiModule.java
@@ -24,16 +24,15 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.ServiceLoader;
-import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.inject.Singleton;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-/** Contains the bindings for {@link BindingGraphPlugins}. */
+/** Contains the bindings for {@link BindingGraphPlugins} from external SPI providers. */
 @Module
-abstract class BindingGraphPluginsModule {
-  private BindingGraphPluginsModule() {}
+abstract class SpiModule {
+  private SpiModule() {}
 
   @Provides
   @Singleton
@@ -45,7 +44,7 @@ static BindingGraphPlugins spiPlugins(
       @ProcessingOptions Map<String, String> processingOptions,
       DiagnosticReporterFactory diagnosticReporterFactory) {
     return new BindingGraphPlugins(
-        testingPlugins.orElseGet(BindingGraphPluginsModule::loadPlugins),
+        testingPlugins.orElseGet(SpiModule::loadPlugins),
         filer,
         types,
         elements,
@@ -53,20 +52,6 @@ static BindingGraphPlugins spiPlugins(
         diagnosticReporterFactory);
   }
 
-  @Provides
-  @Singleton
-  @Validation
-  static BindingGraphPlugins validationPlugins(
-      @Validation Set<BindingGraphPlugin> validationPlugins,
-      Filer filer,
-      Types types,
-      Elements elements,
-      @ProcessingOptions Map<String, String> processingOptions,
-      DiagnosticReporterFactory diagnosticReporterFactory) {
-    return new BindingGraphPlugins(
-        validationPlugins, filer, types, elements, processingOptions, diagnosticReporterFactory);
-  }
-
   private static ImmutableSet<BindingGraphPlugin> loadPlugins() {
     return ImmutableSet.copyOf(
         ServiceLoader.load(BindingGraphPlugin.class, BindingGraphPlugins.class.getClassLoader()));
diff --git a/java/dagger/internal/codegen/StaticSwitchingProviders.java b/java/dagger/internal/codegen/StaticSwitchingProviders.java
index f0918dec4..ecc5a5885 100644
--- a/java/dagger/internal/codegen/StaticSwitchingProviders.java
+++ b/java/dagger/internal/codegen/StaticSwitchingProviders.java
@@ -19,6 +19,7 @@
 import static com.squareup.javapoet.ClassName.OBJECT;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.TypeName.INT;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -50,10 +51,10 @@
   private final DaggerTypes types;
   private final ClassName owningComponent;
 
-  StaticSwitchingProviders(GeneratedComponentModel generatedComponentModel, DaggerTypes types) {
-    super(generatedComponentModel, types);
+  StaticSwitchingProviders(ComponentImplementation componentImplementation, DaggerTypes types) {
+    super(componentImplementation, types);
     this.types = types;
-    this.owningComponent = generatedComponentModel.name();
+    this.owningComponent = componentImplementation.name();
   }
 
   /**
@@ -104,7 +105,7 @@ public Key key() {
     }
 
     @Override
-    public Expression getProviderExpression(ClassName switchType, int switchId) {
+    public Expression getProviderExpression(ClassName switchingProviderClass, int switchId) {
       TypeMirror accessibleType = types.accessibleType(binding.contributedType(), owningComponent);
       // Java 7 type inference can't figure out that instance in
       // DoubleCheck.provider(new SwitchingProvider<>()) is Provider<T> and not Provider<Object>
@@ -119,20 +120,20 @@ public Expression getProviderExpression(ClassName switchType, int switchId) {
 
       return Expression.create(
           types.wrapType(accessibleType, Provider.class),
-          CodeBlock.of("new $T<$L>($L)", switchType, typeParameter, arguments));
+          CodeBlock.of("new $T<$L>($L)", switchingProviderClass, typeParameter, arguments));
     }
 
     @Override
-    public Expression getReturnExpression() {
+    public Expression getReturnExpression(ClassName switchingProviderClass) {
       return Expression.create(
           binding.contributedType(),
           CodeBlock.of(
               "$T.provideInstance($L)",
               generatedClassNameForBinding(binding),
-              getMethodArguments()));
+              getMethodArguments(switchingProviderClass)));
     }
 
-    private CodeBlock getMethodArguments() {
+    private CodeBlock getMethodArguments(ClassName switchingProviderClass) {
       int i = 0;
       ImmutableList.Builder<CodeBlock> arguments = ImmutableList.builder();
       if (binding.requiresModuleInstance()) {
@@ -141,7 +142,9 @@ private CodeBlock getMethodArguments() {
 
       for (FrameworkDependency dependency : binding.frameworkDependencies()) {
         TypeMirror type =
-            componentBindingExpressions.getDependencyExpression(dependency, owningComponent).type();
+            componentBindingExpressions
+                .getDependencyExpression(bindingRequest(dependency), switchingProviderClass)
+                .type();
         arguments.add(argument(type, i++));
       }
       return makeParametersCodeBlock(arguments.build());
diff --git a/java/dagger/internal/codegen/SubcomponentBuilderBindingEdgeImpl.java b/java/dagger/internal/codegen/SubcomponentBuilderBindingEdgeImpl.java
new file mode 100644
index 000000000..3035def7c
--- /dev/null
+++ b/java/dagger/internal/codegen/SubcomponentBuilderBindingEdgeImpl.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static java.util.stream.Collectors.joining;
+
+import com.google.common.collect.ImmutableSet;
+import dagger.model.BindingGraph.SubcomponentBuilderBindingEdge;
+import javax.lang.model.element.TypeElement;
+
+/** An implementation of {@link SubcomponentBuilderBindingEdge}. */
+final class SubcomponentBuilderBindingEdgeImpl implements SubcomponentBuilderBindingEdge {
+
+  private final ImmutableSet<TypeElement> declaringModules;
+
+  SubcomponentBuilderBindingEdgeImpl(Iterable<TypeElement> declaringModules) {
+    this.declaringModules = ImmutableSet.copyOf(declaringModules);
+  }
+
+  @Override
+  public ImmutableSet<TypeElement> declaringModules() {
+    return declaringModules;
+  }
+
+  @Override
+  public String toString() {
+    return "subcomponent declared by "
+        + (declaringModules.size() == 1
+            ? getOnlyElement(declaringModules).getQualifiedName()
+            : declaringModules.stream()
+                .map(TypeElement::getQualifiedName)
+                .collect(joining(", ", "{", "}")));
+  }
+}
diff --git a/java/dagger/internal/codegen/SubcomponentDeclaration.java b/java/dagger/internal/codegen/SubcomponentDeclaration.java
index dad6bbeb0..ed741b063 100644
--- a/java/dagger/internal/codegen/SubcomponentDeclaration.java
+++ b/java/dagger/internal/codegen/SubcomponentDeclaration.java
@@ -19,7 +19,7 @@
 import static com.google.auto.common.AnnotationMirrors.getAnnotationElementAndValue;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
-import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentCreator;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -28,7 +28,7 @@
 import java.util.Optional;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 
 /**
@@ -44,9 +44,6 @@
   @Override
   public abstract Key key();
 
-  @Override
-  abstract Optional<ExecutableElement > bindingElement();
-
   /**
    * The type element that defines the {@link dagger.Subcomponent} or {@link
    * dagger.producers.ProductionSubcomponent} for this declaration.
@@ -66,16 +63,16 @@
     ImmutableSet<SubcomponentDeclaration> forModule(TypeElement module) {
       ImmutableSet.Builder<SubcomponentDeclaration> declarations = ImmutableSet.builder();
       AnnotationMirror moduleAnnotation = getModuleAnnotation(module).get();
-      ExecutableElement subcomponentAttribute =
+      Element subcomponentAttribute =
           getAnnotationElementAndValue(moduleAnnotation, "subcomponents").getKey();
       for (TypeElement subcomponent :
           MoreTypes.asTypeElements(getModuleSubcomponents(moduleAnnotation))) {
         declarations.add(
             new AutoValue_SubcomponentDeclaration(
-                Optional.of(module),
-                keyFactory.forSubcomponentBuilder(
-                    getSubcomponentBuilder(subcomponent).get().asType()),
                 Optional.of(subcomponentAttribute),
+                Optional.of(module),
+                keyFactory.forSubcomponentCreator(
+                    getSubcomponentCreator(subcomponent).get().asType()),
                 subcomponent,
                 moduleAnnotation));
       }
diff --git a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
index 4c3cffa83..c29aa69e5 100644
--- a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
+++ b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
@@ -61,7 +61,11 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    bindingGraph.edges().stream()
+    if (bindingGraph.isModuleBindingGraph() || bindingGraph.isPartialBindingGraph()) {
+      // We don't know all the modules that might be owned by the child until we know the root.
+      return;
+    }
+    bindingGraph.network().edges().stream()
         .flatMap(instancesOf(ChildFactoryMethodEdge.class))
         .forEach(
             edge -> {
@@ -77,17 +81,14 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
       ChildFactoryMethodEdge edge, BindingGraph graph) {
     ImmutableSet<TypeElement> factoryMethodParameters =
         subgraphFactoryMethodParameters(edge, graph);
-    ComponentNode child = (ComponentNode) graph.incidentNodes(edge).target();
+    ComponentNode child = (ComponentNode) graph.network().incidentNodes(edge).target();
     SetView<TypeElement> modulesOwnedByChild = ownedModules(child, graph);
-    return graph.bindingNodes().stream()
+    return graph.bindings().stream()
         // bindings owned by child
-        .filter(node -> node.componentPath().equals(child.componentPath()))
+        .filter(binding -> binding.componentPath().equals(child.componentPath()))
         // that require a module instance
-        .filter(
-            node ->
-                node.binding() instanceof ContributionBinding
-                    && ((ContributionBinding) node.binding()).requiresModuleInstance())
-        .map(node -> node.binding().contributingModule().get())
+        .filter(binding -> binding.requiresModuleInstance())
+        .map(binding -> binding.contributingModule().get())
         .distinct()
         // module owned by child
         .filter(module -> modulesOwnedByChild.contains(module))
@@ -100,7 +101,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
       ChildFactoryMethodEdge edge, BindingGraph bindingGraph) {
-    ComponentNode parent = (ComponentNode) bindingGraph.incidentNodes(edge).source();
+    ComponentNode parent = (ComponentNode) bindingGraph.network().incidentNodes(edge).source();
     DeclaredType parentType = asDeclared(parent.componentPath().currentComponent().asType());
     ExecutableType factoryMethodType =
         asExecutable(types.asMemberOf(parentType, edge.factoryMethod()));
@@ -109,7 +110,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   private SetView<TypeElement> ownedModules(ComponentNode component, BindingGraph graph) {
     return Sets.difference(
-        ((ComponentNodeImpl) component).componentDescriptor().transitiveModuleTypes(),
+        ((ComponentNodeImpl) component).componentDescriptor().moduleTypes(),
         inheritedModules(component, graph));
   }
 
@@ -138,7 +139,13 @@ private void reportMissingModuleParameters(
         edge,
         "%s requires modules which have no visible default constructors. "
             + "Add the following modules as parameters to this method: %s",
-        graph.incidentNodes(edge).target().componentPath().currentComponent().getQualifiedName(),
+        graph
+            .network()
+            .incidentNodes(edge)
+            .target()
+            .componentPath()
+            .currentComponent()
+            .getQualifiedName(),
         Joiner.on(", ").join(missingModules));
   }
 }
diff --git a/java/dagger/internal/codegen/SubcomponentNames.java b/java/dagger/internal/codegen/SubcomponentNames.java
index c059ee3e1..494a9686e 100644
--- a/java/dagger/internal/codegen/SubcomponentNames.java
+++ b/java/dagger/internal/codegen/SubcomponentNames.java
@@ -62,8 +62,7 @@ String get(Key key) {
     ImmutableListMultimap<String, ComponentDescriptor> componentDescriptorsBySimpleName =
         Multimaps.index(
             graph.componentDescriptors(),
-            componentDescriptor ->
-                componentDescriptor.componentDefinitionType().getSimpleName().toString());
+            componentDescriptor -> componentDescriptor.typeElement().getSimpleName().toString());
     ImmutableMap<ComponentDescriptor, Namer> componentNamers =
         qualifiedNames(graph.componentDescriptors());
     Map<ComponentDescriptor, String> subcomponentImplSimpleNames = new LinkedHashMap<>();
@@ -82,12 +81,14 @@ String get(Key key) {
       KeyFactory keyFactory, ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
     ImmutableMap.Builder<Key, String> builder = ImmutableMap.builder();
     subcomponentNames.forEach(
-        (component, name) -> {
-          if (component.builderSpec().isPresent()) {
-            TypeMirror builderType = component.builderSpec().get().builderDefinitionType().asType();
-            builder.put(keyFactory.forSubcomponentBuilder(builderType), name);
-          }
-        });
+        (component, name) ->
+            component
+                .creatorDescriptor()
+                .ifPresent(
+                    creatorDescriptor -> {
+                      TypeMirror creatorType = creatorDescriptor.typeElement().asType();
+                      builder.put(keyFactory.forSubcomponentCreator(creatorType), name);
+                    }));
     return builder.build();
   }
 
@@ -125,7 +126,7 @@ String get(Key key) {
       Iterable<ComponentDescriptor> componentDescriptors) {
     ImmutableMap.Builder<ComponentDescriptor, Namer> builder = ImmutableMap.builder();
     for (ComponentDescriptor component : componentDescriptors) {
-      builder.put(component, new Namer(component.componentDefinitionType()));
+      builder.put(component, new Namer(component.typeElement()));
     }
     return builder.build();
   }
diff --git a/java/dagger/internal/codegen/SwitchingProviders.java b/java/dagger/internal/codegen/SwitchingProviders.java
index ba4dbc671..adb6b54b1 100644
--- a/java/dagger/internal/codegen/SwitchingProviders.java
+++ b/java/dagger/internal/codegen/SwitchingProviders.java
@@ -61,13 +61,13 @@
     Key key();
 
     /** Returns the {@link Expression} that returns the provided instance for this case. */
-    Expression getReturnExpression();
+    Expression getReturnExpression(ClassName switchingProviderClass);
 
     /**
      * Returns the {@link Expression} that returns the {@code SwitchProvider} instance for this
      * case.
      */
-    Expression getProviderExpression(ClassName switchType, int switchId);
+    Expression getProviderExpression(ClassName switchingProviderClass, int switchId);
   }
 
   /**
@@ -90,15 +90,15 @@
   private final Map<Key, SwitchingProviderBuilder> switchingProviderBuilders =
       new LinkedHashMap<>();
 
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ClassName owningComponent;
   private final DaggerTypes types;
   private final UniqueNameSet switchingProviderNames = new UniqueNameSet();
 
-  SwitchingProviders(GeneratedComponentModel generatedComponentModel, DaggerTypes types) {
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+  SwitchingProviders(ComponentImplementation componentImplementation, DaggerTypes types) {
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.types = checkNotNull(types);
-    this.owningComponent = checkNotNull(generatedComponentModel).name();
+    this.owningComponent = checkNotNull(componentImplementation).name();
   }
 
   /** Returns the {@link TypeSpec} for a {@code SwitchingProvider} based on the given builder. */
@@ -118,7 +118,7 @@ private SwitchingProviderBuilder getSwitchingProviderBuilder() {
       String name = switchingProviderNames.getUniqueName("SwitchingProvider");
       SwitchingProviderBuilder switchingProviderBuilder =
           new SwitchingProviderBuilder(owningComponent.nestedClass(name));
-      generatedComponentModel.addSwitchingProvider(switchingProviderBuilder::build);
+      componentImplementation.addSwitchingProvider(switchingProviderBuilder::build);
       return switchingProviderBuilder;
     }
     return getLast(switchingProviderBuilders.values());
@@ -147,7 +147,8 @@ Expression getProviderExpression(SwitchCase switchCase) {
     }
 
     private CodeBlock createSwitchCaseCodeBlock(SwitchCase switchCase) {
-      CodeBlock instanceCodeBlock = switchCase.getReturnExpression().box(types).codeBlock();
+      CodeBlock instanceCodeBlock =
+          switchCase.getReturnExpression(switchingProviderType).box(types).codeBlock();
 
       return CodeBlock.builder()
           // TODO(user): Is there something else more useful than the key?
diff --git a/javatests/dagger/android/functional/TestModule.java b/java/dagger/internal/codegen/SystemComponentsModule.java
similarity index 56%
rename from javatests/dagger/android/functional/TestModule.java
rename to java/dagger/internal/codegen/SystemComponentsModule.java
index dd3adaa0b..3f59b240f 100644
--- a/javatests/dagger/android/functional/TestModule.java
+++ b/java/dagger/internal/codegen/SystemComponentsModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Dagger Authors.
+ * Copyright (C) 2018 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,29 +14,18 @@
  * limitations under the License.
  */
 
-package dagger.android.functional;
+package dagger.internal.codegen;
 
+import com.google.common.base.Ticker;
 import dagger.Module;
 import dagger.Provides;
 
+/** Module to provide system-level dependencies (such as time-related objects). */
 @Module
-class TestModule {
-  int releasedWhenUiHiddenCalls;
-  int releasedWhenModerateCalls;
+interface SystemComponentsModule {
 
   @Provides
-  @ReleaseWhenUiHidden
-  @InScope(ReleaseWhenUiHidden.class)
-  Object releasedWhenUiHidden() {
-    ++releasedWhenUiHiddenCalls;
-    return new Object();
-  }
-
-  @Provides
-  @ReleaseWhenModerate
-  @InScope(ReleaseWhenModerate.class)
-  Object releasedWhenModerate() {
-    ++releasedWhenModerateCalls;
-    return new Object();
+  static Ticker ticker() {
+    return Ticker.systemTicker();
   }
 }
diff --git a/java/dagger/internal/codegen/TypeCheckingProcessingStep.java b/java/dagger/internal/codegen/TypeCheckingProcessingStep.java
new file mode 100644
index 000000000..00769b228
--- /dev/null
+++ b/java/dagger/internal/codegen/TypeCheckingProcessingStep.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.SetMultimap;
+import java.lang.annotation.Annotation;
+import java.util.function.Function;
+import javax.lang.model.element.Element;
+
+/**
+ * A {@link ProcessingStep} that processes one element at a time and defers any for which {@link
+ * TypeNotPresentException} is thrown.
+ */
+// TODO(dpb): Contribute to auto-common.
+abstract class TypeCheckingProcessingStep<E extends Element> implements ProcessingStep {
+  private final Function<Element, E> downcaster;
+
+  TypeCheckingProcessingStep(Function<Element, E> downcaster) {
+    this.downcaster = checkNotNull(downcaster);
+  }
+
+  @Override
+  public ImmutableSet<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> deferredElements = ImmutableSet.builder();
+    ImmutableSetMultimap.copyOf(elementsByAnnotation)
+        .inverse()
+        .asMap()
+        .forEach(
+            (element, annotations) -> {
+              try {
+                process(downcaster.apply(element), ImmutableSet.copyOf(annotations));
+              } catch (TypeNotPresentException e) {
+                deferredElements.add(element);
+              }
+            });
+    return deferredElements.build();
+  }
+
+  /**
+   * Processes one element. If this method throws {@link TypeNotPresentException}, the element will
+   * be deferred until the next round of processing.
+   *
+   * @param annotations the subset of {@link ProcessingStep#annotations()} that annotate {@code
+   *     element}
+   */
+  protected abstract void process(E element, ImmutableSet<Class<? extends Annotation>> annotations);
+}
diff --git a/java/dagger/internal/codegen/TypeNames.java b/java/dagger/internal/codegen/TypeNames.java
index d6b01c768..2b590d4b4 100644
--- a/java/dagger/internal/codegen/TypeNames.java
+++ b/java/dagger/internal/codegen/TypeNames.java
@@ -31,14 +31,12 @@
 import dagger.internal.MapProviderFactory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.ProviderOfLazy;
-import dagger.internal.ReferenceReleasingProvider;
-import dagger.internal.ReferenceReleasingProviderManager;
 import dagger.internal.SetFactory;
 import dagger.internal.SingleCheck;
-import dagger.internal.TypedReleasableReferenceManagerDecorator;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.DependencyMethodProducer;
 import dagger.producers.internal.MapOfProducedProducer;
 import dagger.producers.internal.MapOfProducerProducer;
 import dagger.producers.internal.MapProducer;
@@ -60,6 +58,7 @@
 
   static final ClassName ABSTRACT_PRODUCER = ClassName.get(AbstractProducer.class);
   static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
+  static final ClassName DEPENDENCY_METHOD_PRODUCER = ClassName.get(DependencyMethodProducer.class);
   static final ClassName DOUBLE_CHECK = ClassName.get(DoubleCheck.class);
   static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
@@ -85,17 +84,11 @@
   static final ClassName PROVIDER = ClassName.get(Provider.class);
   static final ClassName PROVIDER_OF_LAZY = ClassName.get(ProviderOfLazy.class);
   static final ClassName RUNNABLE = ClassName.get(Runnable.class);
-  static final ClassName REFERENCE_RELEASING_PROVIDER =
-      ClassName.get(ReferenceReleasingProvider.class);
-  static final ClassName REFERENCE_RELEASING_PROVIDER_MANAGER =
-      ClassName.get(ReferenceReleasingProviderManager.class);
   static final ClassName SET = ClassName.get(Set.class);
   static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
   static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
   static final ClassName SET_PRODUCER = ClassName.get(SetProducer.class);
   static final ClassName SINGLE_CHECK = ClassName.get(SingleCheck.class);
-  static final ClassName TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR =
-      ClassName.get(TypedReleasableReferenceManagerDecorator.class);
 
   /**
    * {@link TypeName#VOID} is lowercase-v {@code void} whereas this represents the class, {@link
@@ -139,6 +132,10 @@ static ParameterizedTypeName producerOf(TypeName typeName) {
     return ParameterizedTypeName.get(PRODUCER, typeName);
   }
 
+  static ParameterizedTypeName dependencyMethodProducerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(DEPENDENCY_METHOD_PRODUCER, typeName);
+  }
+
   static ParameterizedTypeName providerOf(TypeName typeName) {
     return ParameterizedTypeName.get(PROVIDER, typeName);
   }
diff --git a/java/dagger/internal/codegen/ValidationReport.java b/java/dagger/internal/codegen/ValidationReport.java
index ef2142144..0a3765a43 100644
--- a/java/dagger/internal/codegen/ValidationReport.java
+++ b/java/dagger/internal/codegen/ValidationReport.java
@@ -67,8 +67,20 @@
     return ImmutableSet.copyOf(SUBREPORTS.depthFirstPreOrder(this));
   }
 
-  /** Returns {@code true} if there are no errors in this report or any subreports. */
+  /**
+   * {@code true} if {@link #isClean()} should return {@code false} even if there are no error items
+   * in this report.
+   */
+  abstract boolean markedDirty();
+
+  /**
+   * Returns {@code true} if there are no errors in this report or any subreports and {@link
+   * #markedDirty()} is {@code false}.
+   */
   boolean isClean() {
+    if (markedDirty()) {
+      return false;
+    }
     for (Item item : items()) {
       switch (item.kind()) {
         case ERROR:
@@ -150,6 +162,7 @@ private static boolean isEnclosedIn(Element parent, Element child) {
     private final T subject;
     private final ImmutableSet.Builder<Item> items = ImmutableSet.builder();
     private final ImmutableSet.Builder<ValidationReport<?>> subreports = ImmutableSet.builder();
+    private boolean markedDirty;
 
     private Builder(T subject) {
       this.subject = subject;
@@ -253,6 +266,14 @@ T getSubject() {
       return this;
     }
 
+    /**
+     * If called, then {@link #isClean()} will return {@code false} even if there are no error items
+     * in the report.
+     */
+    void markDirty() {
+      this.markedDirty = true;
+    }
+
     Builder<T> addSubreport(ValidationReport<?> subreport) {
       subreports.add(subreport);
       return this;
@@ -260,7 +281,8 @@ T getSubject() {
 
     @CheckReturnValue
     ValidationReport<T> build() {
-      return new AutoValue_ValidationReport<>(subject, items.build(), subreports.build());
+      return new AutoValue_ValidationReport<>(
+          subject, items.build(), subreports.build(), markedDirty);
     }
   }
 }
diff --git a/java/dagger/model/BUILD b/java/dagger/model/BUILD
index a2c91a0e7..f91b9141d 100644
--- a/java/dagger/model/BUILD
+++ b/java/dagger/model/BUILD
@@ -39,7 +39,7 @@ java_library(
     javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     deps = [
         "//java/dagger:core",
-        "//java/dagger/internal/codegen:shared-with-spi",
+        "//java/dagger/internal/codegen:jdk-and-guava-extras",
         "//java/dagger/producers",
         "@google_bazel_common//third_party/java/auto:common",
         "@google_bazel_common//third_party/java/auto:value",
diff --git a/java/dagger/model/Binding.java b/java/dagger/model/Binding.java
index 3e0cad0ab..81aba00a9 100644
--- a/java/dagger/model/Binding.java
+++ b/java/dagger/model/Binding.java
@@ -17,6 +17,7 @@
 package dagger.model;
 
 import com.google.common.collect.ImmutableSet;
+import dagger.model.BindingGraph.MaybeBinding;
 import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -25,11 +26,20 @@
  * The association between a {@link Key} and the way in which instances of the key are provided.
  * Includes any {@linkplain DependencyRequest dependencies} that are needed in order to provide the
  * instances.
+ *
+ * <p>If a binding is owned by more than one component, there is one {@code Binding} for every
+ * owning component.
  */
-public interface Binding {
-  /** The binding's key. */
-  Key key();
+public interface Binding extends MaybeBinding {
+  @Override
+  ComponentPath componentPath();
 
+  /** @deprecated This always returns {@code Optional.of(this)}. */
+  @Override
+  @Deprecated
+  default Optional<Binding> binding() {
+    return Optional.of(this);
+  }
   /**
    * The dependencies of this binding. The order of the dependencies corresponds to the order in
    * which they will be injected when the binding is requested.
@@ -46,11 +56,7 @@
    * contribute a synthetic binding, but since multiple {@code @Multibinds} methods can coexist in
    * the same component (and contribute to one single binding), it has no binding element.
    */
-  // TODO(ronshapiro): examine whether this wildcard+bound have any benefit. In the processor code,
-  // we never actually refer to the overridden bindingElement methods directly in a way which needs
-  // anything more than an Element. Removing the wildcard would allow for simpler user-written code
-  // when the binding element is passed to a method.
-  Optional<? extends Element> bindingElement();
+  Optional<Element> bindingElement();
 
   /**
    * The {@link TypeElement} of the module which contributes this binding. Absent for bindings that
@@ -58,6 +64,12 @@
    */
   Optional<TypeElement> contributingModule();
 
+  /**
+   * Returns {@code true} if using this binding requires an instance of the {@link
+   * #contributingModule()}.
+   */
+  boolean requiresModuleInstance();
+
   /** The scope of this binding if it has one. */
   Optional<Scope> scope();
 
@@ -73,4 +85,5 @@
 
   /** The kind of binding this instance represents. */
   BindingKind kind();
+
 }
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 8c59f3b76..65e0bac1d 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -16,7 +16,6 @@
 
 package dagger.model;
 
-import static com.google.common.base.MoreObjects.toStringHelper;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Sets.intersection;
 import static com.google.common.graph.Graphs.inducedSubgraph;
@@ -35,21 +34,37 @@
 import com.google.common.graph.Network;
 import com.google.common.graph.NetworkBuilder;
 import dagger.Module;
-import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.Node;
 import java.util.Optional;
 import java.util.stream.Stream;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
 /**
- * The immutable graph of bindings, dependency requests, and components for a valid root component.
+ * A graph of bindings, dependency requests, and components.
+ *
+ * <p>A {@link BindingGraph} represents one of the following:
+ *
+ * <ul>
+ *   <li>an entire component hierarchy rooted at a {@link dagger.Component} or {@link
+ *       dagger.producers.ProductionComponent}
+ *   <li>a partial component hierarchy rooted at a {@link dagger.Subcomponent} or {@link
+ *       dagger.producers.ProductionSubcomponent} (only when {@code
+ *       -Adagger.experimentalAheadOfTimeSubcomponents=enabled} is passed to the compiler)
+ *   <li>the bindings installed by a {@link Module} or {@link dagger.producers.ProducerModule},
+ *       including all subcomponents generated by {@link Module#subcomponents()} ()} and {@link
+ *       dagger.producers.ProducerModule#subcomponents()} ()}
+ * </ul>
+ *
+ * In the case of a {@link BindingGraph} representing a module, the root {@link ComponentNode} will
+ * actually represent the module type, and there will be an entry point edge (with no request
+ * element) for every binding (except multibinding contributions) in the module, including its
+ * transitively included modules.
  *
  * <h3>Nodes</h3>
  *
- * <p>There is a <b>{@linkplain BindingNode binding node}</b> for each owned binding in the graph.
- * If a binding is owned by more than one component, there is one binding node for that binding for
- * every owning component.
+ * <p>There is a <b>{@link Binding}</b> for each owned binding in the graph. If a binding is owned
+ * by more than one component, there is one binding object for that binding for every owning
+ * component.
  *
  * <p>There is a <b>{@linkplain ComponentNode component node}</b> (without a binding) for each
  * component in the graph.
@@ -57,64 +72,94 @@
  * <h3>Edges</h3>
  *
  * <p>There is a <b>{@linkplain DependencyEdge dependency edge}</b> for each dependency request in
- * the graph. Its target node is the binding node for the binding that satisfies the request. For
- * entry point dependency requests, the source node is the component node for the component for
- * which it is an entry point. For other dependency requests, the source node is the binding node
- * for the binding that contains the request.
+ * the graph. Its target node is the binding for the binding that satisfies the request. For entry
+ * point dependency requests, the source node is the component node for the component for which it
+ * is an entry point. For other dependency requests, the source node is the binding for the binding
+ * that contains the request.
  *
  * <p>There is a <b>subcomponent edge</b> for each parent-child component relationship in the graph.
  * The target node is the component node for the child component. For subcomponents defined by a
  * {@linkplain SubcomponentBuilderBindingEdge subcomponent builder binding} (either a method on the
  * component or a set of {@code @Module.subcomponents} annotation values), the source node is the
- * binding node for the {@code @Subcomponent.Builder} type. For subcomponents defined by {@linkplain
+ * binding for the {@code @Subcomponent.Builder} type. For subcomponents defined by {@linkplain
  * ChildFactoryMethodEdge subcomponent factory methods}, the source node is the component node for
  * the parent.
  *
  * <p><b>Note that this API is experimental and will change.</b>
  */
-public final class BindingGraph extends ForwardingNetwork<Node, Edge> {
-  BindingGraph(Network<Node, Edge> network) {
-    super(ImmutableNetwork.copyOf(network));
+@AutoValue
+public abstract class BindingGraph {
+
+  static BindingGraph create(
+      Network<Node, Edge> network, boolean isModuleBindingGraph, boolean isPartialBindingGraph) {
+    return new AutoValue_BindingGraph(
+        ImmutableNetwork.copyOf(network), isModuleBindingGraph, isPartialBindingGraph);
   }
 
-  /** Returns the binding nodes. */
-  public ImmutableSet<BindingNode> bindingNodes() {
-    return nodes(BindingNode.class);
+  BindingGraph() {}
+
+  /** Returns the graph in its {@link Network} representation. */
+  public abstract ImmutableNetwork<Node, Edge> network();
+
+  @Override
+  public final String toString() {
+    return network().toString();
+  }
+
+  /**
+   * Returns {@code true} if this graph was constructed from a module for module binding validation.
+   *
+   * @see <a href="https://google.github.io/dagger/compiler-options#module-binding-validation">Module binding
+   *     validation</a>
+   */
+  // TODO(dpb): Figure out the relationship between this and isPartialBindingGraph(). Maybe this
+  // implies that?
+  public abstract boolean isModuleBindingGraph();
+
+  /**
+   * Returns {@code true} if this graph was constructed with a root subcomponent in ahead-of-time
+   * subcomponents mode.
+   */
+  public abstract boolean isPartialBindingGraph();
+
+  /** Returns the bindings. */
+  public final ImmutableSet<Binding> bindings() {
+    return nodes(Binding.class);
   }
 
-  /** Returns the binding nodes for a key. */
-  public ImmutableSet<BindingNode> bindingNodes(Key key) {
-    return nodeStream(BindingNode.class)
-        .filter(node -> node.key().equals(key))
+  /** Returns the bindings for a key. */
+  public final ImmutableSet<Binding> bindings(Key key) {
+    return nodeStream(Binding.class)
+        .filter(binding -> binding.key().equals(key))
         .collect(toImmutableSet());
   }
 
   /** Returns the nodes that represent missing bindings. */
-  public ImmutableSet<MissingBindingNode> missingBindingNodes() {
-    return nodes(MissingBindingNode.class);
+  public final ImmutableSet<MissingBinding> missingBindings() {
+    return nodes(MissingBinding.class);
   }
 
   /** Returns the component nodes. */
-  public ImmutableSet<ComponentNode> componentNodes() {
+  public final ImmutableSet<ComponentNode> componentNodes() {
     return nodes(ComponentNode.class);
   }
 
   /** Returns the component node for a component. */
-  public Optional<ComponentNode> componentNode(ComponentPath component) {
+  public final Optional<ComponentNode> componentNode(ComponentPath component) {
     return nodeStream(ComponentNode.class)
         .filter(node -> node.componentPath().equals(component))
         .findFirst();
   }
 
   /** Returns the component nodes for a component. */
-  public ImmutableSet<ComponentNode> componentNodes(TypeElement component) {
+  public final ImmutableSet<ComponentNode> componentNodes(TypeElement component) {
     return nodeStream(ComponentNode.class)
         .filter(node -> node.componentPath().currentComponent().equals(component))
         .collect(toImmutableSet());
   }
 
   /** Returns the component node for the root component. */
-  public ComponentNode rootComponentNode() {
+  public final ComponentNode rootComponentNode() {
     return nodeStream(ComponentNode.class)
         .filter(node -> node.componentPath().atRoot())
         .findFirst()
@@ -122,7 +167,7 @@ public ComponentNode rootComponentNode() {
   }
 
   /** Returns the dependency edges. */
-  public ImmutableSet<DependencyEdge> dependencyEdges() {
+  public final ImmutableSet<DependencyEdge> dependencyEdges() {
     return dependencyEdgeStream().collect(toImmutableSet());
   }
 
@@ -131,16 +176,16 @@ public ComponentNode rootComponentNode() {
    * DependencyRequest} will map to a single {@link DependencyEdge}. When conflicting bindings exist
    * for a key, the multimap will have several edges for that {@link DependencyRequest}. Graphs that
    * have no binding for a key will have an edge whose {@linkplain EndpointPair#target() target
-   * node} is a {@link MissingBindingNode}.
+   * node} is a {@link MissingBinding}.
    */
-  public ImmutableSetMultimap<DependencyRequest, DependencyEdge> dependencyEdges(
-      BindingNode bindingNode) {
-    return dependencyEdgeStream(bindingNode)
+  public final ImmutableSetMultimap<DependencyRequest, DependencyEdge> dependencyEdges(
+      Binding binding) {
+    return dependencyEdgeStream(binding)
         .collect(toImmutableSetMultimap(DependencyEdge::dependencyRequest, edge -> edge));
   }
 
   /** Returns the dependency edges for a dependency request. */
-  public ImmutableSet<DependencyEdge> dependencyEdges(DependencyRequest dependencyRequest) {
+  public final ImmutableSet<DependencyEdge> dependencyEdges(DependencyRequest dependencyRequest) {
     return dependencyEdgeStream()
         .filter(edge -> edge.dependencyRequest().equals(dependencyRequest))
         .collect(toImmutableSet());
@@ -150,26 +195,26 @@ public ComponentNode rootComponentNode() {
    * Returns the dependency edges for the entry points of a given {@code component}. Each edge's
    * source node is that component's component node.
    */
-  public ImmutableSet<DependencyEdge> entryPointEdges(ComponentPath component) {
+  public final ImmutableSet<DependencyEdge> entryPointEdges(ComponentPath component) {
     return dependencyEdgeStream(componentNode(component).get()).collect(toImmutableSet());
   }
 
   private Stream<DependencyEdge> dependencyEdgeStream(Node node) {
-    return outEdges(node).stream().flatMap(instancesOf(DependencyEdge.class));
+    return network().outEdges(node).stream().flatMap(instancesOf(DependencyEdge.class));
   }
 
   /**
    * Returns the dependency edges for all entry points for all components and subcomponents. Each
    * edge's source node is a component node.
    */
-  public ImmutableSet<DependencyEdge> entryPointEdges() {
+  public final ImmutableSet<DependencyEdge> entryPointEdges() {
     return entryPointEdgeStream().collect(toImmutableSet());
   }
 
-  /** Returns the binding nodes or missing binding nodes that directly satisfy entry points. */
-  public ImmutableSet<MaybeBindingNode> entryPointBindingNodes() {
+  /** Returns the binding or missing binding nodes that directly satisfy entry points. */
+  public final ImmutableSet<MaybeBinding> entryPointBindings() {
     return entryPointEdgeStream()
-        .map(edge -> (MaybeBindingNode) incidentNodes(edge).target())
+        .map(edge -> (MaybeBinding) network().incidentNodes(edge).target())
         .collect(toImmutableSet());
   }
 
@@ -177,29 +222,60 @@ public ComponentNode rootComponentNode() {
    * Returns the edges for entry points that transitively depend on a binding or missing binding for
    * a key. Never returns an empty set.
    */
-  public ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBindingNode(
-      MaybeBindingNode bindingNode) {
+  public final ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBinding(
+      MaybeBinding binding) {
     ImmutableNetwork<Node, DependencyEdge> dependencyGraph = dependencyGraph();
-    Network<Node, DependencyEdge> subgraphDependingOnBindingNode =
+    Network<Node, DependencyEdge> subgraphDependingOnBinding =
         inducedSubgraph(
-            dependencyGraph, reachableNodes(transpose(dependencyGraph).asGraph(), bindingNode));
+            dependencyGraph, reachableNodes(transpose(dependencyGraph).asGraph(), binding));
     ImmutableSet<DependencyEdge> entryPointEdges =
-        intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()).immutableCopy();
-    verify(!entryPointEdges.isEmpty(), "No entry points depend on binding %s", bindingNode);
+        intersection(entryPointEdges(), subgraphDependingOnBinding.edges()).immutableCopy();
+    verify(!entryPointEdges.isEmpty(), "No entry points depend on binding %s", binding);
     return entryPointEdges;
   }
 
+  /** Returns the bindings that directly request a given binding as a dependency. */
+  public final ImmutableSet<Binding> requestingBindings(MaybeBinding binding) {
+    return network().predecessors(binding).stream()
+        .flatMap(instancesOf(Binding.class))
+        .collect(toImmutableSet());
+  }
+
+  /**
+   * Returns the bindings that a given binding directly request as a dependency. Does not include
+   * any {@link MissingBinding}s.
+   *
+   * @see #requestedMaybeMissingBindings(Binding)
+   */
+  public final ImmutableSet<Binding> requestedBindings(Binding binding) {
+    return network().successors(binding).stream()
+        .flatMap(instancesOf(Binding.class))
+        .collect(toImmutableSet());
+  }
+
+  /**
+   * Returns the bindings or missing bindings that a given binding directly requests as a
+   * dependency.
+   *
+   * @see #requestedBindings(Binding)
+   */
+  public final ImmutableSet<MaybeBinding> requestedMaybeMissingBindings(Binding binding) {
+    return network().successors(binding).stream()
+        .flatMap(instancesOf(MaybeBinding.class))
+        .collect(toImmutableSet());
+  }
+
   // TODO(dpb): Make public. Cache.
   private ImmutableNetwork<Node, DependencyEdge> dependencyGraph() {
     MutableNetwork<Node, DependencyEdge> dependencyGraph =
-        NetworkBuilder.from(this)
-            .expectedNodeCount(nodes().size())
+        NetworkBuilder.from(network())
+            .expectedNodeCount(network().nodes().size())
             .expectedEdgeCount((int) dependencyEdgeStream().count())
             .build();
     dependencyEdgeStream()
         .forEach(
             edge -> {
-              EndpointPair<Node> endpoints = incidentNodes(edge);
+              EndpointPair<Node> endpoints = network().incidentNodes(edge);
               dependencyGraph.addEdge(endpoints.source(), endpoints.target(), edge);
             });
     return ImmutableNetwork.copyOf(dependencyGraph);
@@ -210,11 +286,11 @@ public ComponentNode rootComponentNode() {
   }
 
   private <N extends Node> Stream<N> nodeStream(Class<N> clazz) {
-    return nodes().stream().flatMap(instancesOf(clazz));
+    return network().nodes().stream().flatMap(instancesOf(clazz));
   }
 
   private Stream<DependencyEdge> dependencyEdgeStream() {
-    return edges().stream().flatMap(instancesOf(DependencyEdge.class));
+    return network().edges().stream().flatMap(instancesOf(DependencyEdge.class));
   }
 
   private Stream<DependencyEdge> entryPointEdgeStream() {
@@ -235,104 +311,53 @@ public ComponentNode rootComponentNode() {
    * element), this class does not override {@link #equals(Object)} to use value semantics.
    *
    * <p>For entry points, the source node is the {@link ComponentNode} that contains the entry
-   * point. Otherwise the source node is a {@link BindingNode}.
+   * point. Otherwise the source node is a {@link Binding}.
    *
-   * <p>For dependencies on missing bindings, the target node is a {@link MissingBindingNode}.
-   * Otherwise the target node is a {@link BindingNode}.
+   * <p>For dependencies on missing bindings, the target node is a {@link MissingBinding}. Otherwise
+   * the target node is a {@link Binding}.
    */
-  public static final class DependencyEdge implements Edge {
-
-    private final DependencyRequest dependencyRequest;
-    private final boolean entryPoint;
-
-    DependencyEdge(DependencyRequest dependencyRequest, boolean entryPoint) {
-      this.dependencyRequest = dependencyRequest;
-      this.entryPoint = entryPoint;
-    }
-
+  public interface DependencyEdge extends Edge {
     /** The dependency request. */
-    public DependencyRequest dependencyRequest() {
-      return dependencyRequest;
-    }
+    DependencyRequest dependencyRequest();
 
     /** Returns {@code true} if this edge represents an entry point. */
-    public boolean isEntryPoint() {
-      return entryPoint;
-    }
-
-    @Override
-    public String toString() {
-      return toStringHelper(this)
-          .add("dependencyRequest", dependencyRequest)
-          .add("entryPoint", entryPoint)
-          .toString();
-    }
+    boolean isEntryPoint();
   }
 
   /**
    * An edge that represents a subcomponent factory method linking a parent component to a child
    * subcomponent.
    */
-  public static final class ChildFactoryMethodEdge implements Edge {
-
-    private final ExecutableElement factoryMethod;
-
-    ChildFactoryMethodEdge(ExecutableElement factoryMethod) {
-      this.factoryMethod = factoryMethod;
-    }
-
+  public interface ChildFactoryMethodEdge extends Edge {
     /** The subcomponent factory method element. */
-    public ExecutableElement factoryMethod() {
-      return factoryMethod;
-    }
-
-    @Override
-    public String toString() {
-      return toStringHelper(this).add("factoryMethod", factoryMethod).toString();
-    }
+    ExecutableElement factoryMethod();
   }
 
   /**
    * An edge that represents the link between a parent component and a child subcomponent implied by
    * a subcomponent builder binding. The {@linkplain com.google.common.graph.EndpointPair#source()
-   * source node} of this edge is a {@link BindingNode} for the subcomponent builder {@link Key} and
-   * the {@linkplain com.google.common.graph.EndpointPair#target() target node} is a {@link
+   * source node} of this edge is a {@link Binding} for the subcomponent builder {@link Key} and the
+   * {@linkplain com.google.common.graph.EndpointPair#target() target node} is a {@link
    * ComponentNode} for the child subcomponent.
    */
-  public static final class SubcomponentBuilderBindingEdge implements Edge {
-
-    private final ImmutableSet<TypeElement> declaringModules;
-
-    SubcomponentBuilderBindingEdge(Iterable<TypeElement> declaringModules) {
-      this.declaringModules = ImmutableSet.copyOf(declaringModules);
-    }
-
+  public interface SubcomponentBuilderBindingEdge extends Edge {
     /**
      * The modules that {@linkplain Module#subcomponents() declare the subcomponent} that generated
      * this edge. Empty if the parent component has a subcomponent builder method and there are no
      * declaring modules.
      */
-    public ImmutableSet<TypeElement> declaringModules() {
-      return declaringModules;
-    }
-
-    @Override
-    public String toString() {
-      return toStringHelper(this).add("declaringModules", declaringModules).toString();
-    }
+    ImmutableSet<TypeElement> declaringModules();
   }
 
-  /** A node in the binding graph. Either a {@link BindingNode} or a {@link ComponentNode}. */
+  /** A node in the binding graph. Either a {@link Binding} or a {@link ComponentNode}. */
+  // TODO(dpb): Make all the node/edge types top-level.
   public interface Node {
     /** The component this node belongs to. */
     ComponentPath componentPath();
   }
 
-  /**
-   * A node in the binding graph that is either a {@link BindingNode} or a {@link
-   * MissingBindingNode}.
-   */
-  public interface MaybeBindingNode extends Node {
+  /** A node in the binding graph that is either a {@link Binding} or a {@link MissingBinding}. */
+  public interface MaybeBinding extends Node {
 
     /** The component that owns the binding, or in which the binding is missing. */
     @Override
@@ -342,38 +367,14 @@ public String toString() {
     Key key();
 
     /** The binding, or empty if missing. */
-    Optional<Binding> maybeBinding();
-  }
-
-  /**
-   * A <b>binding node</b> in the binding graph. If a binding is owned by more than one component,
-   * there is one binding node for that binding for every owning component.
-   */
-  public interface BindingNode extends MaybeBindingNode {
-
-    /** The component that owns the {@link #binding()}. */
-    @Override
-    ComponentPath componentPath();
-
-    /** The binding. */
-    Binding binding();
-
-    @Override
-    default Key key() {
-      return binding().key();
-    }
-
-    @Override
-    default Optional<Binding> maybeBinding() {
-      return Optional.of(binding());
-    }
+    Optional<Binding> binding();
   }
 
   /** A node in the binding graph that represents a missing binding for a key in a component. */
   @AutoValue
-  public abstract static class MissingBindingNode implements MaybeBindingNode {
-    static MissingBindingNode create(ComponentPath component, Key key) {
-      return new AutoValue_BindingGraph_MissingBindingNode(component, key);
+  public abstract static class MissingBinding implements MaybeBinding {
+    static MissingBinding create(ComponentPath component, Key key) {
+      return new AutoValue_BindingGraph_MissingBinding(component, key);
     }
 
     /** The component in which the binding is missing. */
@@ -383,8 +384,10 @@ static MissingBindingNode create(ComponentPath component, Key key) {
     /** The key for which there is no binding. */
     public abstract Key key();
 
+    /** @deprecated This always returns {@code Optional.empty()}. */
     @Override
-    public final Optional<Binding> maybeBinding() {
+    @Deprecated
+    public final Optional<Binding> binding() {
       return Optional.empty();
     }
 
diff --git a/java/dagger/model/BindingGraphProxies.java b/java/dagger/model/BindingGraphProxies.java
index 9c3b60150..cd7080636 100644
--- a/java/dagger/model/BindingGraphProxies.java
+++ b/java/dagger/model/BindingGraphProxies.java
@@ -17,14 +17,9 @@
 package dagger.model;
 
 import com.google.common.graph.Network;
-import dagger.model.BindingGraph.ChildFactoryMethodEdge;
-import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.MissingBindingNode;
+import dagger.model.BindingGraph.MissingBinding;
 import dagger.model.BindingGraph.Node;
-import dagger.model.BindingGraph.SubcomponentBuilderBindingEdge;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 
 /**
  * Exposes package-private constructors to the {@code dagger.internal.codegen} package. <em>This
@@ -33,30 +28,14 @@
  */
 public final class BindingGraphProxies {
   /** Creates a new {@link BindingGraph}. */
-  public static BindingGraph bindingGraph(Network<Node, Edge> network) {
-    return new BindingGraph(network);
+  public static BindingGraph bindingGraph(
+      Network<Node, Edge> network, boolean isModuleBindingGraph, boolean isPartialBindingGraph) {
+    return BindingGraph.create(network, isModuleBindingGraph, isPartialBindingGraph);
   }
 
-  /** Creates a new {@link MissingBindingNode}. */
-  public static MissingBindingNode missingBindingNode(ComponentPath component, Key key) {
-    return MissingBindingNode.create(component, key);
-  }
-
-  /** Creates a new {@link DependencyEdge}. */
-  public static DependencyEdge dependencyEdge(
-      DependencyRequest dependencyRequest, boolean entryPoint) {
-    return new DependencyEdge(dependencyRequest, entryPoint);
-  }
-
-  /** Creates a new {@link ChildFactoryMethodEdge}. */
-  public static ChildFactoryMethodEdge childFactoryMethodEdge(ExecutableElement factoryMethod) {
-    return new ChildFactoryMethodEdge(factoryMethod);
-  }
-
-  /** Creates a new {@link SubcomponentBuilderBindingEdge}. */
-  public static SubcomponentBuilderBindingEdge subcomponentBuilderBindingEdge(
-      Iterable<TypeElement> declaringModules) {
-    return new SubcomponentBuilderBindingEdge(declaringModules);
+  /** Creates a new {@link MissingBinding}. */
+  public static MissingBinding missingBindingNode(ComponentPath component, Key key) {
+    return MissingBinding.create(component, key);
   }
 
   private BindingGraphProxies() {}
diff --git a/java/dagger/model/BindingKind.java b/java/dagger/model/BindingKind.java
index 3ea2f9c93..0c9bb35b8 100644
--- a/java/dagger/model/BindingKind.java
+++ b/java/dagger/model/BindingKind.java
@@ -83,18 +83,6 @@
    */
   OPTIONAL,
 
-  /**
-   * A binding for a {@link dagger.releasablereferences.ReleasableReferenceManager} or {@link
-   * dagger.releasablereferences.TypedReleasableReferenceManager} object for a scope.
-   */
-  RELEASABLE_REFERENCE_MANAGER,
-
-  /**
-   * A binding for a set of {@link dagger.releasablereferences.ReleasableReferenceManager} or {@link
-   * dagger.releasablereferences.TypedReleasableReferenceManager} objects.
-   */
-  RELEASABLE_REFERENCE_MANAGERS,
-
   /**
    * A binding for {@link dagger.Binds}-annotated method that that delegates from requests for one
    * key to another.
diff --git a/java/dagger/model/ForwardingNetwork.java b/java/dagger/model/ForwardingNetwork.java
deleted file mode 100644
index aa4b538f9..000000000
--- a/java/dagger/model/ForwardingNetwork.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.model;
-
-import static dagger.internal.Preconditions.checkNotNull;
-
-import com.google.common.collect.ForwardingObject;
-import com.google.common.graph.ElementOrder;
-import com.google.common.graph.EndpointPair;
-import com.google.common.graph.Graph;
-import com.google.common.graph.Network;
-import java.util.Optional;
-import java.util.Set;
-
-/** A {@link Network} that delegates all methods to another instance. */
-// TODO(dpb): Move to com.google.common.graph.
-public class ForwardingNetwork<N, E> extends ForwardingObject implements Network<N, E> {
-
-  private final Network<N, E> delegate;
-
-  protected ForwardingNetwork(Network<N, E> delegate) {
-    this.delegate = checkNotNull(delegate);
-  }
-
-  @Override
-  protected final Network<N, E> delegate() {
-    return delegate;
-  }
-
-  @Override
-  public Set<N> nodes() {
-    return delegate().nodes();
-  }
-
-  @Override
-  public Set<E> edges() {
-    return delegate().edges();
-  }
-
-  @Override
-  public Graph<N> asGraph() {
-    return delegate().asGraph();
-  }
-
-  @Override
-  public boolean isDirected() {
-    return delegate().isDirected();
-  }
-
-  @Override
-  public boolean allowsParallelEdges() {
-    return delegate().allowsParallelEdges();
-  }
-
-  @Override
-  public boolean allowsSelfLoops() {
-    return delegate().allowsSelfLoops();
-  }
-
-  @Override
-  public ElementOrder<N> nodeOrder() {
-    return delegate().nodeOrder();
-  }
-
-  @Override
-  public ElementOrder<E> edgeOrder() {
-    return delegate().edgeOrder();
-  }
-
-  @Override
-  public Set<N> adjacentNodes(N node) {
-    return delegate().adjacentNodes(node);
-  }
-
-  @Override
-  public Set<N> predecessors(N node) {
-    return delegate().predecessors(node);
-  }
-
-  @Override
-  public Set<N> successors(N node) {
-    return delegate().successors(node);
-  }
-
-  @Override
-  public Set<E> incidentEdges(N node) {
-    return delegate().incidentEdges(node);
-  }
-
-  @Override
-  public Set<E> inEdges(N node) {
-    return delegate().inEdges(node);
-  }
-
-  @Override
-  public Set<E> outEdges(N node) {
-    return delegate().outEdges(node);
-  }
-
-  @Override
-  public int degree(N node) {
-    return delegate().degree(node);
-  }
-
-  @Override
-  public int inDegree(N node) {
-    return delegate().inDegree(node);
-  }
-
-  @Override
-  public int outDegree(N node) {
-    return delegate().outDegree(node);
-  }
-
-  @Override
-  public EndpointPair<N> incidentNodes(E edge) {
-    return delegate().incidentNodes(edge);
-  }
-
-  @Override
-  public Set<E> adjacentEdges(E edge) {
-    return delegate().adjacentEdges(edge);
-  }
-
-  @Override
-  public Set<E> edgesConnecting(N nodeU, N nodeV) {
-    return delegate().edgesConnecting(nodeU, nodeV);
-  }
-
-  @SuppressWarnings("MissingOverride") // Until Guava 23.0
-  public Optional<E> edgeConnecting(N nodeU, N nodeV) {
-    return Optional.ofNullable(edgeConnectingOrNull(nodeU, nodeV));
-  }
-
-  @SuppressWarnings("MissingOverride") // Until Guava 23.0
-  // @Nullable // TODO(ronshapiro): replace with the checker framework?
-  public E edgeConnectingOrNull(N nodeU, N nodeV) {
-    return delegate().edgeConnectingOrNull(nodeU, nodeV);
-  }
-
-  @Override
-  public boolean hasEdgeConnecting(N nodeU, N nodeV) {
-    return delegate().hasEdgeConnecting(nodeU, nodeV);
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    return delegate().equals(obj);
-  }
-
-  @Override
-  public int hashCode() {
-    return delegate().hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return delegate().toString();
-  }
-}
diff --git a/java/dagger/model/RequestKind.java b/java/dagger/model/RequestKind.java
index 2f3c75734..74a434633 100644
--- a/java/dagger/model/RequestKind.java
+++ b/java/dagger/model/RequestKind.java
@@ -16,6 +16,9 @@
 
 package dagger.model;
 
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+
 import dagger.Lazy;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
@@ -42,8 +45,8 @@
   PROVIDER_OF_LAZY,
 
   /**
-   * A request for a members injection. E.g. {@code void inject(FooType);}. Can only be requested by
-   * component interfaces.
+   * A request for a members injection. E.g. {@code void injectMembers(FooType);}. Can only be
+   * requested by component interfaces.
    */
   MEMBERS_INJECTION,
 
@@ -59,4 +62,24 @@
    */
   FUTURE,
   ;
+
+  /** Returns a string that represents requests of this kind for a key. */
+  public String format(Key key) {
+    switch (this) {
+      case INSTANCE:
+        return key.toString();
+
+      case PROVIDER_OF_LAZY:
+        return String.format("Provider<Lazy<%s>>", key);
+
+      case MEMBERS_INJECTION:
+        return String.format("injectMembers(%s)", key);
+
+      case FUTURE:
+        return String.format("ListenableFuture<%s>", key);
+
+      default:
+        return String.format("%s<%s>", UPPER_UNDERSCORE.to(UPPER_CAMEL, name()), key);
+    }
+  }
 }
diff --git a/java/dagger/model/Scope.java b/java/dagger/model/Scope.java
index 541a69f0b..7d255e1ca 100644
--- a/java/dagger/model/Scope.java
+++ b/java/dagger/model/Scope.java
@@ -16,7 +16,6 @@
 
 package dagger.model;
 
-import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 
@@ -25,16 +24,12 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.collect.ImmutableSet;
 import dagger.Reusable;
 import dagger.producers.ProductionScope;
-import dagger.releasablereferences.CanReleaseReferences;
 import java.lang.annotation.Annotation;
-import java.util.Optional;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 
 /** A representation of a {@link javax.inject.Scope}. */
 @AutoValue
@@ -93,41 +88,6 @@ private boolean isScope(Class<? extends Annotation> annotation) {
     return scopeAnnotationElement().getQualifiedName().contentEquals(annotation.getCanonicalName());
   }
 
-  /**
-   * Returns {@code true} for scopes that are annotated with {@link CanReleaseReferences} or some
-   * other annotation that is itself annotated with {@link CanReleaseReferences}.
-   */
-  // Implementation note: you need to check
-  // BindingGraph.scopesRequiringReleasableReferenceManagers() to see if a given binding graph
-  // actually binds a ReleasableReferenceManager for this scope.
-  public final boolean canReleaseReferences() {
-    return isAnnotationPresent(scopeAnnotationElement(), CanReleaseReferences.class)
-        || !releasableReferencesMetadata().isEmpty();
-  }
-
-  /**
-   * Returns the set of annotations on the scope that are themselves annotated with {@link
-   * CanReleaseReferences}. These annotations are used as metadata for {@link
-   * dagger.releasablereferences.TypedReleasableReferenceManager}.
-   */
-  public final ImmutableSet<AnnotationMirror> releasableReferencesMetadata() {
-    return ImmutableSet.copyOf(
-        getAnnotatedAnnotations(scopeAnnotationElement(), CanReleaseReferences.class));
-  }
-
-  /**
-   * Returns the {@linkplain #releasableReferencesMetadata() releasable references metadata}
-   * annotation of the given type, if there is one for this scope.
-   */
-  public final Optional<AnnotationMirror> releasableReferencesMetadata(TypeMirror metadataType) {
-    for (AnnotationMirror metadata : releasableReferencesMetadata()) {
-      if (MoreTypes.equivalence().equivalent(metadata.getAnnotationType(), metadataType)) {
-        return Optional.of(metadata);
-      }
-    }
-    return Optional.empty();
-  }
-
   /** Returns a debug representation of the scope. */
   @Override
   public String toString() {
diff --git a/java/dagger/model/testing/BUILD b/java/dagger/model/testing/BUILD
index 4e8b62d53..a9d5f1989 100644
--- a/java/dagger/model/testing/BUILD
+++ b/java/dagger/model/testing/BUILD
@@ -29,10 +29,10 @@ java_library(
     srcs = glob(["*.java"]),
     javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     deps = [
-        "//java/dagger/internal/codegen:shared-with-spi",
+        "//java/dagger/internal/codegen:jdk-and-guava-extras",
         "//java/dagger/model",
         "@google_bazel_common//third_party/java/auto:value",
-        "@google_bazel_common//third_party/java/checker_framework:annotations",
+        "@google_bazel_common//third_party/java/checker_framework_annotations",
         "@google_bazel_common//third_party/java/guava",
         "@google_bazel_common//third_party/java/truth",
     ],
diff --git a/java/dagger/model/testing/BindingGraphSubject.java b/java/dagger/model/testing/BindingGraphSubject.java
index d88f93d27..f251eb5e2 100644
--- a/java/dagger/model/testing/BindingGraphSubject.java
+++ b/java/dagger/model/testing/BindingGraphSubject.java
@@ -23,8 +23,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.truth.FailureMetadata;
 import com.google.common.truth.Subject;
+import dagger.model.Binding;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import javax.lang.model.type.TypeMirror;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
@@ -65,7 +65,7 @@ public void hasBindingWithKey(String qualifier, String type) {
    *
    * @param type the canonical name of the type, as returned by {@link TypeMirror#toString()}
    */
-  public BindingNodeSubject bindingWithKey(String type) {
+  public BindingSubject bindingWithKey(String type) {
     return bindingWithKeyString(keyString(type));
   }
 
@@ -76,28 +76,28 @@ public BindingNodeSubject bindingWithKey(String type) {
    *     javax.lang.model.element.AnnotationMirror AnnotationMirror.toString()}
    * @param type the canonical name of the type, as returned by {@link TypeMirror#toString()}
    */
-  public BindingNodeSubject bindingWithKey(String qualifier, String type) {
+  public BindingSubject bindingWithKey(String qualifier, String type) {
     return bindingWithKeyString(keyString(qualifier, type));
   }
 
-  private BindingNodeSubject bindingWithKeyString(String keyString) {
-    ImmutableSet<BindingNode> bindingNodes = getBindingNodes(keyString);
-    if (bindingNodes.isEmpty()) {
+  private BindingSubject bindingWithKeyString(String keyString) {
+    ImmutableSet<Binding> bindings = getBindingNodes(keyString);
+    if (bindings.isEmpty()) {
       fail("has binding with key", keyString);
     }
     // TODO(dpb): Handle multiple bindings for the same key.
-    if (bindingNodes.size() > 1) {
+    if (bindings.size() > 1) {
       failWithBadResults(
-          "has only one binding with key", keyString, "has the following bindings:", bindingNodes);
+          "has only one binding with key", keyString, "has the following bindings:", bindings);
     }
     return check("bindingWithKey(%s)", keyString)
-        .about(BindingNodeSubject::new)
-        .that(getOnlyElement(bindingNodes));
+        .about(BindingSubject::new)
+        .that(getOnlyElement(bindings));
   }
 
-  private ImmutableSet<BindingNode> getBindingNodes(String keyString) {
-    return actual().bindingNodes().stream()
-        .filter(node -> node.key().toString().equals(keyString))
+  private ImmutableSet<Binding> getBindingNodes(String keyString) {
+    return actual().bindings().stream()
+        .filter(binding -> binding.key().toString().equals(keyString))
         .collect(toImmutableSet());
   }
 
@@ -109,15 +109,15 @@ private static String keyString(String qualifier, String type) {
     return String.format("%s %s", qualifier, type);
   }
 
-  /** A Truth subject for a {@link BindingNode}. */
-  public final class BindingNodeSubject extends Subject<BindingNodeSubject, BindingNode> {
+  /** A Truth subject for a {@link Binding}. */
+  public final class BindingSubject extends Subject<BindingSubject, Binding> {
 
-    BindingNodeSubject(FailureMetadata metadata, @NullableDecl BindingNode actual) {
+    BindingSubject(FailureMetadata metadata, @NullableDecl Binding actual) {
       super(metadata, actual);
     }
 
     /**
-     * Asserts that the binding node depends on a binding with an unqualified key.
+     * Asserts that the binding depends on a binding with an unqualified key.
      *
      * @param type the canonical name of the type, as returned by {@link TypeMirror#toString()}
      */
@@ -126,7 +126,7 @@ public void dependsOnBindingWithKey(String type) {
     }
 
     /**
-     * Asserts that the binding node depends on a binding with a qualified key.
+     * Asserts that the binding depends on a binding with a qualified key.
      *
      * @param qualifier the canonical string form of the qualifier, as returned by {@link
      *     javax.lang.model.element.AnnotationMirror AnnotationMirror.toString()}
@@ -137,11 +137,9 @@ public void dependsOnBindingWithKey(String qualifier, String type) {
     }
 
     private void dependsOnBindingWithKeyString(String keyString) {
-      if (actualBindingGraph().successors(actual()).stream()
-          .filter(node -> node instanceof BindingNode)
-          .map(node -> (BindingNode) node)
-          .noneMatch(node -> node.key().toString().equals(keyString))) {
-        fail("has successor with key", keyString);
+      if (actualBindingGraph().requestedBindings(actual()).stream()
+          .noneMatch(binding -> binding.key().toString().equals(keyString))) {
+        fail("depends on binding with key", keyString);
       }
     }
 
diff --git a/java/dagger/producers/BUILD b/java/dagger/producers/BUILD
index 3af069b1b..ad065a1b9 100644
--- a/java/dagger/producers/BUILD
+++ b/java/dagger/producers/BUILD
@@ -46,7 +46,7 @@ java_library(
     ],
     deps = [
         "//java/dagger:core",
-        "@google_bazel_common//third_party/java/checker_framework:annotations",
+        "@google_bazel_common//third_party/java/checker_framework_annotations",
         "@google_bazel_common//third_party/java/error_prone:annotations",
         "@google_bazel_common//third_party/java/guava",
         "@google_bazel_common//third_party/java/jsr330_inject",
diff --git a/java/dagger/producers/CancellationPolicy.java b/java/dagger/producers/CancellationPolicy.java
new file mode 100644
index 000000000..70f4a43d8
--- /dev/null
+++ b/java/dagger/producers/CancellationPolicy.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.CLASS;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * Annotates a production component or subcomponent to specify its policy when a child component is
+ * cancelled.
+ *
+ * <p>When a future returned from an entry point on a production component is cancelled, the
+ * component is cancelled: all producers in the component (including those for other entry points)
+ * are cancelled.
+ *
+ * <p>When a child component is cancelled, its parent component <i>is not</i> cancelled unless the
+ * parent component is annotated with {@code @CancellationPolicy(fromSubcomponents = PROPAGATE)}. If
+ * that parent component has a parent (the grandparent of the cancelled child component), it will
+ * not be cancelled unless it also has a {@code @CancellationPolicy} annotation allowing
+ * cancellation to propagate to it from subcomponents.
+ */
+@Documented
+@Target(TYPE)
+@Retention(CLASS)
+@Beta
+public @interface CancellationPolicy {
+  /**
+   * Defines whether the annotated production component is cancelled when a child component is
+   * cancelled.
+   *
+   * <p>The default, if no cancellation policy annotation is provided, is {@link
+   * Propagation#IGNORE}.
+   */
+  Propagation fromSubcomponents();
+
+  /**
+   * Enumeration of the options for what happens to a parent component when one of its child
+   * components is cancelled.
+   */
+  enum Propagation {
+    /** Cancel the annotated component when a child component is cancelled. */
+    PROPAGATE,
+
+    /** Do not cancel the annotated component when a child component is cancelled. */
+    IGNORE
+  }
+}
diff --git a/java/dagger/producers/ProductionComponent.java b/java/dagger/producers/ProductionComponent.java
index 9af158838..77530b6f9 100644
--- a/java/dagger/producers/ProductionComponent.java
+++ b/java/dagger/producers/ProductionComponent.java
@@ -17,12 +17,14 @@
 package dagger.producers;
 
 import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
@@ -31,22 +33,24 @@
  * Annotates an interface or abstract class for which a fully-formed, dependency-injected
  * implementation is to be generated from a set of {@linkplain #modules modules}. The generated
  * class will have the name of the type annotated with {@code @ProductionComponent} prepended with
- * {@code Dagger}.  For example, {@code @ProductionComponent interface MyComponent {...}} will
+ * {@code Dagger}. For example, {@code @ProductionComponent interface MyComponent {...}} will
  * produce an implementation named {@code DaggerMyComponent}.
  *
  * <p>Each {@link Produces} method that contributes to the component will be called at most once per
- * component instance, no matter how many times that binding is used as a dependency.
- * TODO(beder): Decide on how scope works for producers.
+ * component instance, no matter how many times that binding is used as a dependency. TODO(beder):
+ * Decide on how scope works for producers.
  *
  * <h2>Component methods</h2>
  *
  * <p>Every type annotated with {@code @ProductionComponent} must contain at least one abstract
  * component method. Component methods must represent {@linkplain Producer production}.
  *
- * Production methods have no arguments and return either a {@link ListenableFuture} or
- * {@link Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or
- * {@link Produces produced}. Each may have a {@link Qualifier} annotation as well. The following
- * are all valid production method declarations: <pre><code>
+ * <p>Production methods have no arguments and return either a {@link ListenableFuture} or {@link
+ * Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or {@link
+ * Produces produced}. Each may have a {@link Qualifier} annotation as well. The following are all
+ * valid production method declarations:
+ *
+ * <pre><code>
  *   {@literal ListenableFuture<SomeType>} getSomeType();
  *   {@literal Producer<Set<SomeType>>} getSomeTypes();
  *   {@literal @Response ListenableFuture<Html>} getResponse();
@@ -60,9 +64,9 @@
  * and if the downstream producer injects a {@code Produced<T>}, then the downstream producer will
  * be run with the exception stored in the {@code Produced<T>}.
  *
- * <p>If a non-execution exception is thrown (e.g., an {@code InterruptedException} or
- * {@code CancellationException}), then exception is handled as in
- * {@link com.google.common.util.concurrent.Futures#transform}.
+ * <p>If a non-execution exception is thrown (e.g., an {@code InterruptedException} or {@code
+ * CancellationException}), then exception is handled as in {@link
+ * com.google.common.util.concurrent.Futures#transform}.
  * <!-- TODO(beder): Explain this more thoroughly, and update the javadocs of those utilities. -->
  *
  * <h2>Executor</h2>
@@ -74,6 +78,7 @@
  *
  * @since 2.0
  */
+@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
 @Documented
 @Target(TYPE)
 @Beta
diff --git a/java/dagger/producers/internal/AbstractProducer.java b/java/dagger/producers/internal/AbstractProducer.java
index 2af9470c1..3dcd906da 100644
--- a/java/dagger/producers/internal/AbstractProducer.java
+++ b/java/dagger/producers/internal/AbstractProducer.java
@@ -16,14 +16,17 @@
 
 package dagger.producers.internal;
 
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
+import com.google.common.util.concurrent.AbstractFuture;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import java.util.concurrent.atomic.AtomicBoolean;
 
-/**
- * An abstract {@link Producer} implementation that memoizes the result of its compute method.
- */
-public abstract class AbstractProducer<T> implements Producer<T> {
-  private volatile ListenableFuture<T> instance = null;
+/** An abstract {@link Producer} implementation that memoizes the result of its compute method. */
+public abstract class AbstractProducer<T> implements CancellableProducer<T> {
+  private final AtomicBoolean requested = new AtomicBoolean();
+  private final NonExternallyCancellableFuture<T> future = new NonExternallyCancellableFuture<T>();
 
   protected AbstractProducer() {}
 
@@ -32,19 +35,133 @@ protected AbstractProducer() {}
 
   @Override
   public final ListenableFuture<T> get() {
-    // double-check idiom from EJ2: Item 71
-    ListenableFuture<T> result = instance;
-    if (result == null) {
-      synchronized (this) {
-        result = instance;
-        if (result == null) {
-          instance = result = compute();
-          if (result == null) {
-            throw new NullPointerException("compute returned null");
-          }
-        }
-      }
+    if (requested.compareAndSet(false, true)) {
+      future.setFuture(compute());
     }
+    return future;
+  }
+
+  @Override
+  public final void cancel(boolean mayInterruptIfRunning) {
+    requested.set(true); // Avoid potentially starting the task later only to cancel it immediately.
+    future.doCancel(mayInterruptIfRunning);
+  }
+
+  @Override
+  public Producer<T> newDependencyView() {
+    return new NonCancellationPropagatingView();
+  }
+
+  @Override
+  public Producer<T> newEntryPointView(CancellationListener cancellationListener) {
+    NonCancellationPropagatingView result = new NonCancellationPropagatingView();
+    result.addCancellationListener(cancellationListener);
     return result;
   }
+
+  /**
+   * A view of this producer that returns a future that can be cancelled without cancelling the
+   * producer itself.
+   */
+  private final class NonCancellationPropagatingView implements Producer<T> {
+    /**
+     * An independently cancellable view of this node. Needs to be cancellable by normal future
+     * cancellation so that the view at an entry point can listen for its cancellation.
+     */
+    private final ListenableFuture<T> viewFuture = nonCancellationPropagating(future);
+
+    @SuppressWarnings("FutureReturnValueIgnored")
+    @Override
+    public ListenableFuture<T> get() {
+      AbstractProducer.this.get(); // force compute()
+      return viewFuture;
+    }
+
+    void addCancellationListener(final CancellationListener cancellationListener) {
+      viewFuture.addListener(
+          new Runnable() {
+            @Override
+            public void run() {
+              if (viewFuture.isCancelled()) {
+                boolean mayInterruptIfRunning =
+                    viewFuture instanceof NonCancellationPropagatingFuture
+                        && ((NonCancellationPropagatingFuture) viewFuture).interrupted();
+                cancellationListener.onProducerFutureCancelled(mayInterruptIfRunning);
+              }
+            }
+          },
+          directExecutor());
+    }
+  }
+
+  /** A settable future that can't be cancelled via normal future cancellation. */
+  private static final class NonExternallyCancellableFuture<T> extends AbstractFuture<T> {
+
+    @Override
+    public boolean setFuture(ListenableFuture<? extends T> future) {
+      return super.setFuture(future);
+    }
+
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+      return false;
+    }
+
+    /** Actually cancels this future. */
+    void doCancel(boolean mayInterruptIfRunning) {
+      super.cancel(mayInterruptIfRunning);
+    }
+  }
+
+  private static <T> ListenableFuture<T> nonCancellationPropagating(ListenableFuture<T> future) {
+    if (future.isDone()) {
+      return future;
+    }
+    NonCancellationPropagatingFuture<T> output = new NonCancellationPropagatingFuture<T>(future);
+    future.addListener(output, directExecutor());
+    return output;
+  }
+
+  /**
+   * Equivalent to {@code Futures.nonCancellationPropagating}, but allowing us to check whether or
+   * not {@code mayInterruptIfRunning} was set when cancelling it.
+   */
+  private static final class NonCancellationPropagatingFuture<T> extends AbstractFuture<T>
+      implements Runnable {
+    // TODO(cgdecker): This is copied directly from Producers.nonCancellationPropagating, but try
+    // to find out why this doesn't need to be volatile.
+    private ListenableFuture<T> delegate;
+
+    NonCancellationPropagatingFuture(final ListenableFuture<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void run() {
+      // This prevents cancellation from propagating because we don't call setFuture(delegate) until
+      // delegate is already done, so calling cancel() on this future won't affect it.
+      ListenableFuture<T> localDelegate = delegate;
+      if (localDelegate != null) {
+        setFuture(localDelegate);
+      }
+    }
+
+    @Override
+    protected String pendingToString() {
+      ListenableFuture<T> localDelegate = delegate;
+      if (localDelegate != null) {
+        return "delegate=[" + localDelegate + "]";
+      }
+      return null;
+    }
+
+    @Override
+    protected void afterDone() {
+      delegate = null;
+    }
+
+    public boolean interrupted() {
+      return super.wasInterrupted();
+    }
+  }
 }
diff --git a/java/dagger/producers/internal/CancellableProducer.java b/java/dagger/producers/internal/CancellableProducer.java
new file mode 100644
index 000000000..6a1475e5a
--- /dev/null
+++ b/java/dagger/producers/internal/CancellableProducer.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import dagger.producers.Producer;
+
+/** A {@link Producer} that can be cancelled directly even if it hasn't been started. */
+public interface CancellableProducer<T> extends Producer<T> {
+
+  /**
+   * Cancels this producer. If {@link #get()} has already been called, the future it returns will be
+   * cancelled if possible. If not, calling {@link #get()} will return a cancelled future and will
+   * not actually start the underlying operation.
+   *
+   * @param mayInterruptIfRunning the value that should be passed to {@code Future.cancel(boolean)}
+   *     for the futures for any running tasks when cancelling them
+   */
+  void cancel(boolean mayInterruptIfRunning);
+
+  /** Returns a new view of this producer for use as a dependency of another node. */
+  Producer<T> newDependencyView();
+
+  /**
+   * Returns a new view of this producer for use as an entry point.
+   *
+   * <p>When the view's future is cancelled, the given {@code cancellableListener} will be called.
+   */
+  Producer<T> newEntryPointView(CancellationListener cancellationListener);
+}
diff --git a/java/dagger/producers/internal/CancellationListener.java b/java/dagger/producers/internal/CancellationListener.java
new file mode 100644
index 000000000..182ddc6b3
--- /dev/null
+++ b/java/dagger/producers/internal/CancellationListener.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+/** A listener for producer future cancellation. */
+public interface CancellationListener {
+  /** Called when the future for a producer this listener has been added to is cancelled. */
+  // Note that this name is intentionally a bit verbose to make it unlikely that it will conflict
+  // with any user-defined methods on a component.
+  void onProducerFutureCancelled(boolean mayInterruptIfRunning);
+}
diff --git a/java/dagger/producers/internal/DelegateProducer.java b/java/dagger/producers/internal/DelegateProducer.java
new file mode 100644
index 000000000..55ab3a705
--- /dev/null
+++ b/java/dagger/producers/internal/DelegateProducer.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.DoubleCheck;
+import dagger.producers.Producer;
+import javax.inject.Provider;
+
+/**
+ * A DelegateProducer that is used to stitch Producer indirection during initialization across
+ * partial subcomponent implementations.
+ */
+public final class DelegateProducer<T> implements CancellableProducer<T> {
+  private CancellableProducer<T> delegate;
+
+  @Override
+  public ListenableFuture<T> get() {
+    return delegate.get();
+  }
+
+  // TODO(ronshapiro): remove this once we can reasonably expect generated code is no longer using
+  // this method
+  @Deprecated
+  public void setDelegatedProducer(Producer<T> delegate) {
+    setDelegate(this, delegate);
+  }
+
+  /**
+   * Sets {@code delegateProducer}'s delegate producer to {@code delegate}.
+   *
+   * <p>{@code delegateProducer} must be an instance of {@link DelegateProducer}, otherwise this
+   * method will throw a {@link ClassCastException}.
+   */
+  public static <T> void setDelegate(Producer<T> delegateProducer, Producer<T> delegate) {
+    checkNotNull(delegate);
+    DelegateProducer<T> asDelegateProducer = (DelegateProducer<T>) delegateProducer;
+    if (asDelegateProducer.delegate != null) {
+      throw new IllegalStateException();
+    }
+    asDelegateProducer.delegate = (CancellableProducer<T>) delegate;
+  }
+
+  @Override
+  public void cancel(boolean mayInterruptIfRunning) {
+    delegate.cancel(mayInterruptIfRunning);
+  }
+
+  @Override
+  public Producer<T> newDependencyView() {
+    return new ProducerView<T>() {
+      @Override
+      Producer<T> createDelegate() {
+        return delegate.newDependencyView();
+      }
+    };
+  }
+
+  @Override
+  public Producer<T> newEntryPointView(final CancellationListener cancellationListener) {
+    return new ProducerView<T>() {
+      @Override
+      Producer<T> createDelegate() {
+        return delegate.newEntryPointView(cancellationListener);
+      }
+    };
+  }
+
+  private abstract static class ProducerView<T> implements Producer<T> {
+    private final Provider<Producer<T>> delegate =
+        DoubleCheck.provider(
+            new Provider<Producer<T>>() {
+              @Override
+              public Producer<T> get() {
+                return createDelegate();
+              }
+            });
+
+    abstract Producer<T> createDelegate();
+
+    @Override
+    public ListenableFuture<T> get() {
+      return delegate.get().get();
+    }
+  }
+}
diff --git a/java/dagger/producers/internal/DependencyMethodProducer.java b/java/dagger/producers/internal/DependencyMethodProducer.java
new file mode 100644
index 000000000..be118f2d2
--- /dev/null
+++ b/java/dagger/producers/internal/DependencyMethodProducer.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
+import com.google.common.collect.MapMaker;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import java.util.Collections;
+import java.util.Set;
+
+/**
+ * Abstract class for implementing producers derived from methods on component dependencies.
+ *
+ * <p>Unlike most other {@link CancellableProducer} implementations, cancelling the future returned
+ * by a {@linkplain #newDependencyView dependency view} injected into an {@code @Produces} method
+ * will actually cancel the underlying future. This is because the future comes from outside the
+ * component's producer graph (including possibly from another object that isn't a component at
+ * all), so if we don't cancel it when the user asks to cancel it, there might just be no way to
+ * cancel it at all.
+ */
+public abstract class DependencyMethodProducer<T> implements CancellableProducer<T> {
+
+  /** Weak set of all incomplete futures this producer has returned. */
+  private final Set<ListenableFuture<T>> futures =
+      Collections.newSetFromMap(new MapMaker().weakKeys().<ListenableFuture<T>, Boolean>makeMap());
+
+  private boolean cancelled = false;
+
+  /** Calls a method on a component dependency to get a future. */
+  protected abstract ListenableFuture<T> callDependencyMethod();
+
+  @Override
+  public final ListenableFuture<T> get() {
+    synchronized (futures) {
+      if (cancelled) {
+        return Futures.immediateCancelledFuture();
+      }
+
+      final ListenableFuture<T> future = callDependencyMethod();
+      if (!future.isDone() && futures.add(future)) {
+        future.addListener(
+            new Runnable() {
+              @Override
+              public void run() {
+                synchronized (futures) {
+                  futures.remove(future);
+                }
+              }
+            },
+            directExecutor());
+      }
+      return future;
+    }
+  }
+
+  @Override
+  public final void cancel(boolean mayInterruptIfRunning) {
+    synchronized (futures) {
+      cancelled = true;
+      for (ListenableFuture<T> future : futures) {
+        // futures is a concurrent set so that the concurrent removal that will happen here is not
+        // a problem
+        future.cancel(mayInterruptIfRunning);
+      }
+    }
+  }
+
+  @Override
+  public final Producer<T> newDependencyView() {
+    return this;
+  }
+
+  @Override
+  public final Producer<T> newEntryPointView(final CancellationListener cancellationListener) {
+    return new Producer<T>() {
+      private final Set<ListenableFuture<T>> entryPointFutures =
+          Collections.newSetFromMap(
+              new MapMaker().weakKeys().<ListenableFuture<T>, Boolean>makeMap());
+
+      @Override
+      public ListenableFuture<T> get() {
+        final ListenableFuture<T> future = DependencyMethodProducer.this.get();
+        if (!future.isDone() && entryPointFutures.add(future)) {
+          future.addListener(
+              new Runnable() {
+                @Override
+                public void run() {
+                  entryPointFutures.remove(future);
+                  if (future.isCancelled()) {
+                    // TODO(cgdecker): Make this also propagate the actual value that was passed for
+                    // mayInterruptIfRunning
+                    cancellationListener.onProducerFutureCancelled(true);
+                  }
+                }
+              },
+              directExecutor());
+        }
+        return future;
+      }
+    };
+  }
+}
diff --git a/java/dagger/producers/internal/MapOfProducedProducer.java b/java/dagger/producers/internal/MapOfProducedProducer.java
index 10556d39f..2eda7f3f7 100644
--- a/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -39,10 +39,10 @@
  * methods.
  */
 public final class MapOfProducedProducer<K, V> extends AbstractProducer<Map<K, Produced<V>>> {
-  private final Map<K, Producer<V>> mapOfProducers;
+  private final Map<K, Producer<V>> contributingMap;
 
-  private MapOfProducedProducer(Map<K, Producer<V>> mapOfProducers) {
-    this.mapOfProducers = mapOfProducers;
+  private MapOfProducedProducer(Map<K, Producer<V>> contributingMap) {
+    this.contributingMap = contributingMap;
   }
 
   @Override
@@ -50,7 +50,7 @@ private MapOfProducedProducer(Map<K, Producer<V>> mapOfProducers) {
     return Futures.transform(
         Futures.allAsList(
             Iterables.transform(
-                mapOfProducers.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
+                contributingMap.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
         new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
           @Override
           public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
@@ -90,13 +90,17 @@ private MapOfProducedProducer(Map<K, Producer<V>> mapOfProducers) {
   }
 
   /** Returns a new {@link Builder}. */
-  public static <K, V> Builder<K, V> builder() {
-    return new Builder<>();
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<>(size);
   }
 
   /** A builder for {@link MapOfProducedProducer}. */
   public static final class Builder<K, V> {
-    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder;
+
+    private Builder(int size) {
+      mapBuilder = ImmutableMap.builderWithExpectedSize(size);
+    }
 
     /** Returns a new {@link MapOfProducedProducer}. */
     public MapOfProducedProducer<K, V> build() {
@@ -118,5 +122,13 @@ private MapOfProducedProducer(Map<K, Producer<V>> mapOfProducers) {
       mapBuilder.put(key, producerFromProvider(providerOfValue));
       return this;
     }
+
+    // TODO(b/118630627): make this accept MapOfProducedProducer<K, V>, and change all framework
+    // fields to be of that type so we don't need an unsafe cast
+    /** Adds contributions from a super-implementation of a component into this builder. */
+    public Builder<K, V> putAll(Producer<Map<K, Produced<V>>> mapOfProducedProducer) {
+      mapBuilder.putAll(((MapOfProducedProducer<K, V>) mapOfProducedProducer).contributingMap);
+      return this;
+    }
   }
 }
diff --git a/java/dagger/producers/internal/MapOfProducerProducer.java b/java/dagger/producers/internal/MapOfProducerProducer.java
index ef1659224..ce6a7949f 100644
--- a/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -17,9 +17,13 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.producers.internal.Producers.entryPointViewOf;
+import static dagger.producers.internal.Producers.nonCancellationPropagatingViewOf;
 import static dagger.producers.internal.Producers.producerFromProvider;
 
+import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
@@ -34,8 +38,8 @@
   private final ImmutableMap<K, Producer<V>> contributingMap;
 
   /** Returns a new {@link Builder}. */
-  public static <K, V> Builder<K, V> builder() {
-    return new Builder<>();
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<>(size);
   }
 
   private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
@@ -49,7 +53,11 @@ private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
 
   /** A builder for {@link MapOfProducerProducer} */
   public static final class Builder<K, V> {
-    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder;
+
+    private Builder(int size) {
+      mapBuilder = ImmutableMap.builderWithExpectedSize(size);
+    }
 
     /** Associates {@code key} with {@code producerOfValue}. */
     public Builder<K, V> put(K key, Producer<V> producerOfValue) {
@@ -67,9 +75,58 @@ private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
       return this;
     }
 
+    // TODO(b/118630627): make this accept MapOfProducerProducer<K, V>, and change all framework
+    // fields to be of that type so we don't need an unsafe cast
+    /** Adds contributions from a super-implementation of a component into this builder. */
+    public Builder<K, V> putAll(Producer<Map<K, Producer<V>>> mapProducerProducer) {
+      mapBuilder.putAll(((MapOfProducerProducer<K, V>) mapProducerProducer).contributingMap);
+      return this;
+    }
+
     /** Returns a new {@link MapOfProducerProducer}. */
     public MapOfProducerProducer<K, V> build() {
       return new MapOfProducerProducer<>(mapBuilder.build());
     }
   }
+
+  @Override
+  public Producer<Map<K, Producer<V>>> newDependencyView() {
+    return newTransformedValuesView(MapOfProducerProducer.<V>toDependencyView());
+  }
+
+  @Override
+  public Producer<Map<K, Producer<V>>> newEntryPointView(
+      CancellationListener cancellationListener) {
+    return newTransformedValuesView(
+        MapOfProducerProducer.<V>toEntryPointView(cancellationListener));
+  }
+
+  private Producer<Map<K, Producer<V>>> newTransformedValuesView(
+      Function<Producer<V>, Producer<V>> valueTransformationFunction) {
+    return Producers.<Map<K, Producer<V>>>immediateProducer(
+        ImmutableMap.copyOf(Maps.transformValues(contributingMap, valueTransformationFunction)));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Function<Producer<T>, Producer<T>> toDependencyView() {
+    return (Function) TO_DEPENDENCY_VIEW;
+  }
+
+  private static <T> Function<Producer<T>, Producer<T>> toEntryPointView(
+      final CancellationListener cancellationListener) {
+    return new Function<Producer<T>, Producer<T>>() {
+      @Override
+      public Producer<T> apply(Producer<T> input) {
+        return entryPointViewOf(input, cancellationListener);
+      }
+    };
+  }
+
+  private static final Function<Producer<?>, Producer<?>> TO_DEPENDENCY_VIEW =
+      new Function<Producer<?>, Producer<?>>() {
+        @Override
+        public Producer<?> apply(Producer<?> input) {
+          return nonCancellationPropagatingViewOf(input);
+        }
+      };
 }
diff --git a/java/dagger/producers/internal/MapProducer.java b/java/dagger/producers/internal/MapProducer.java
index 52875ef71..9cc000b40 100644
--- a/java/dagger/producers/internal/MapProducer.java
+++ b/java/dagger/producers/internal/MapProducer.java
@@ -37,20 +37,24 @@
  * {@code Map<K, V>} which is populated by calls to the delegate {@link Producer#get} methods.
  */
 public final class MapProducer<K, V> extends AbstractProducer<Map<K, V>> {
-  private final ImmutableMap<K, Producer<V>> mapOfProducers;
+  private final ImmutableMap<K, Producer<V>> contributingMap;
 
-  private MapProducer(ImmutableMap<K, Producer<V>> mapOfProducers) {
-    this.mapOfProducers = mapOfProducers;
+  private MapProducer(ImmutableMap<K, Producer<V>> contributingMap) {
+    this.contributingMap = contributingMap;
   }
 
   /** Returns a new {@link Builder}. */
-  public static <K, V> Builder<K, V> builder() {
-    return new Builder<>();
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<>(size);
   }
 
   /** A builder for {@link MapProducer} */
   public static final class Builder<K, V> {
-    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder;
+
+    private Builder(int size) {
+      mapBuilder = ImmutableMap.builderWithExpectedSize(size);
+    }
 
     /** Associates {@code key} with {@code producerOfValue}. */
     public Builder<K, V> put(K key, Producer<V> producerOfValue) {
@@ -68,6 +72,14 @@ private MapProducer(ImmutableMap<K, Producer<V>> mapOfProducers) {
       return this;
     }
 
+    // TODO(b/118630627): make this accept MapProducer<K, V>, and change all framework fields to be
+    // of that type so we don't need an unsafe cast
+    /** Adds contributions from a super-implementation of a component into this builder. */
+    public Builder<K, V> putAll(Producer<Map<K, V>> mapProducer) {
+      mapBuilder.putAll(((MapProducer<K, V>) mapProducer).contributingMap);
+      return this;
+    }
+
     /** Returns a new {@link MapProducer}. */
     public MapProducer<K, V> build() {
       return new MapProducer<>(mapBuilder.build());
@@ -77,7 +89,7 @@ private MapProducer(ImmutableMap<K, Producer<V>> mapOfProducers) {
   @Override
   protected ListenableFuture<Map<K, V>> compute() {
     final List<ListenableFuture<Map.Entry<K, V>>> listOfEntries = new ArrayList<>();
-    for (final Entry<K, Producer<V>> entry : mapOfProducers.entrySet()) {
+    for (final Entry<K, Producer<V>> entry : contributingMap.entrySet()) {
       listOfEntries.add(
           Futures.transform(entry.getValue().get(), new Function<V, Entry<K, V>>() {
             @Override
diff --git a/java/dagger/producers/internal/MissingBindingProducer.java b/java/dagger/producers/internal/MissingBindingProducer.java
new file mode 100644
index 000000000..5721569a0
--- /dev/null
+++ b/java/dagger/producers/internal/MissingBindingProducer.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+
+/**
+ * A {@link Producer} that always throws on calls to {@link Producer#get()}. This is necessary in
+ * ahead-of-time subcomponents mode, where modifiable binding methods need to return a {@code
+ * Producer<T>} to a framework instance initialization that is pruned and no longer in the binding
+ * graph, but was present in a superclass implementation. This class fulfills that requirement but
+ * is still practically unusable.
+ */
+public final class MissingBindingProducer<T> extends AbstractProducer<T> {
+  private static final MissingBindingProducer<Object> INSTANCE = new MissingBindingProducer<>();
+
+  private MissingBindingProducer() {}
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
+  public static <T> Producer<T> create() {
+    return (Producer) INSTANCE;
+  }
+
+  @Override
+  protected ListenableFuture<T> compute() {
+    throw new AssertionError(
+        "This binding is not part of the final binding graph. The key was requested by a binding "
+            + "that was believed to possibly be part of the graph, but is no longer requested. "
+            + "If this exception is thrown, it is the result of a Dagger bug.");
+  }
+}
diff --git a/java/dagger/producers/internal/Producers.java b/java/dagger/producers/internal/Producers.java
index 4de3354ee..b50a95ef2 100644
--- a/java/dagger/producers/internal/Producers.java
+++ b/java/dagger/producers/internal/Producers.java
@@ -126,7 +126,7 @@
    */
   public static <T> Producer<T> producerFromProvider(final Provider<T> provider) {
     checkNotNull(provider);
-    return new Producer<T>() {
+    return new CompletedProducer<T>() {
       @Override
       public ListenableFuture<T> get() {
         return Futures.immediateFuture(provider.get());
@@ -136,24 +136,76 @@
 
   /** Returns a producer that succeeds with the given value. */
   public static <T> Producer<T> immediateProducer(final T value) {
-    return new Producer<T>() {
+    final ListenableFuture<T> future = Futures.immediateFuture(value);
+    return new CompletedProducer<T>() {
       @Override
       public ListenableFuture<T> get() {
-        return Futures.immediateFuture(value);
+        return future;
       }
     };
   }
 
   /** Returns a producer that fails with the given exception. */
   public static <T> Producer<T> immediateFailedProducer(final Throwable throwable) {
-    return new Producer<T>() {
+    final ListenableFuture<T> future = Futures.immediateFailedFuture(throwable);
+    return new CompletedProducer<T>() {
       @Override
       public ListenableFuture<T> get() {
-        return Futures.immediateFailedFuture(throwable);
+        return future;
       }
     };
   }
 
+  /**
+   * Returns a new view of the given {@code producer} if and only if it is a {@link
+   * CancellableProducer}. Cancelling the returned producer's future will not cancel the underlying
+   * task for the given producer.
+   *
+   * @throws IllegalArgumentException if {@code producer} is not a {@code CancellableProducer}
+   */
+  public static <T> Producer<T> nonCancellationPropagatingViewOf(Producer<T> producer) {
+    // This is a hack until we change the types of Producer fields to be CancellableProducer or
+    // some other type.
+    if (producer instanceof CancellableProducer) {
+      return ((CancellableProducer<T>) producer).newDependencyView();
+    }
+    throw new IllegalArgumentException(
+        "nonCancellationPropagatingViewOf called with non-CancellableProducer: " + producer);
+  }
+
+  /**
+   * Returns a new view of the given {@code producer} for use as an entry point in a production
+   * component, if and only if it is a {@link CancellableProducer}. When the returned producer's
+   * future is cancelled, the given {@code cancellable} will also be cancelled.
+   *
+   * @throws IllegalArgumentException if {@code producer} is not a {@code CancellableProducer}
+   */
+  public static <T> Producer<T> entryPointViewOf(
+      Producer<T> producer, CancellationListener cancellationListener) {
+    // This is a hack until we change the types of Producer fields to be CancellableProducer or
+    // some other type.
+    if (producer instanceof CancellableProducer) {
+      return ((CancellableProducer<T>) producer).newEntryPointView(cancellationListener);
+    }
+    throw new IllegalArgumentException(
+        "entryPointViewOf called with non-CancellableProducer: " + producer);
+  }
+
+  /**
+   * Calls {@code cancel} on the given {@code producer} if it is a {@link CancellableProducer}.
+   *
+   * @throws IllegalArgumentException if {@code producer} is not a {@code CancellableProducer}
+   */
+  public static void cancel(Producer<?> producer, boolean mayInterruptIfRunning) {
+    // This is a hack until we change the types of Producer fields to be CancellableProducer or
+    // some other type.
+    if (producer instanceof CancellableProducer) {
+      ((CancellableProducer<?>) producer).cancel(mayInterruptIfRunning);
+    } else {
+      throw new IllegalArgumentException("cancel called with non-CancellableProducer: " + producer);
+    }
+  }
+
   private static final Producer<Map<Object, Object>> EMPTY_MAP_PRODUCER =
       Producers.<Map<Object, Object>>immediateProducer(ImmutableMap.of());
 
@@ -162,5 +214,24 @@
     return (Producer<Map<K, V>>) (Producer) EMPTY_MAP_PRODUCER;
   }
 
+  /**
+   * A {@link CancellableProducer} which can't be cancelled because it represents an
+   * already-completed task.
+   */
+  private abstract static class CompletedProducer<T> implements CancellableProducer<T> {
+    @Override
+    public void cancel(boolean mayInterruptIfRunning) {}
+
+    @Override
+    public Producer<T> newDependencyView() {
+      return this;
+    }
+
+    @Override
+    public Producer<T> newEntryPointView(CancellationListener cancellationListener) {
+      return this;
+    }
+  }
+
   private Producers() {}
 }
diff --git a/java/dagger/producers/internal/ProductionExecutorModule.java b/java/dagger/producers/internal/ProductionExecutorModule.java
new file mode 100644
index 000000000..e233ae917
--- /dev/null
+++ b/java/dagger/producers/internal/ProductionExecutorModule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.producers.Production;
+import dagger.producers.ProductionScope;
+import java.util.concurrent.Executor;
+
+/**
+ * Binds the {@code @ProductionImplementation Executor} binding in {@link ProductionScope} so that
+ * only on instance is ever used within production components.
+ */
+@Module
+public abstract class ProductionExecutorModule {
+  @Binds
+  @ProductionScope
+  @ProductionImplementation
+  abstract Executor productionImplementationExecutor(@Production Executor executor);
+
+  private ProductionExecutorModule() {}
+}
diff --git a/java/dagger/producers/internal/SetProducer.java b/java/dagger/producers/internal/SetProducer.java
index 4577db991..687b9ee3c 100644
--- a/java/dagger/producers/internal/SetProducer.java
+++ b/java/dagger/producers/internal/SetProducer.java
@@ -39,12 +39,7 @@
  */
 public final class SetProducer<T> extends AbstractProducer<Set<T>> {
   private static final Producer<Set<Object>> EMPTY_PRODUCER =
-      new Producer<Set<Object>>() {
-        @Override
-        public ListenableFuture<Set<Object>> get() {
-          return Futures.<Set<Object>>immediateFuture(ImmutableSet.<Object>of());
-        }
-      };
+      Producers.<Set<Object>>immediateProducer(ImmutableSet.<Object>of());
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
   public static <T> Producer<Set<T>> empty() {
diff --git a/java/dagger/releasablereferences/CanReleaseReferences.java b/java/dagger/releasablereferences/CanReleaseReferences.java
deleted file mode 100644
index b240b0442..000000000
--- a/java/dagger/releasablereferences/CanReleaseReferences.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.releasablereferences;
-
-import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * Annotates {@linkplain javax.inject.Scope scope annotations} to indicate that references to
- * objects stored within that scope can be <a
- * href="https://google.github.io/dagger/users-guide.html#releasable-references">released</a> during the lifetime
- * of the scope.
- *
- * <p>A scope can release references if it is annotated with {@code CanReleaseReferences} or if it
- * is annotated with an annotation that itself is annotated with {@code CanReleaseReferences}.
- *
- * <p>For example:
- *
- * <pre>
- *   {@literal @Documented}
- *   {@literal @Retention(RUNTIME)}
- *   {@literal @CanReleaseReferences}
- *   {@literal @Scope}
- *   public {@literal @interface} MyScope {}</pre>
- *
- * or:
- *
- * <pre>
- *   {@literal @CanReleaseReferences}
- *   public {@literal @interface} SomeAnnotation {}
- *
- *   {@literal @Documented}
- *   {@literal @Retention(RUNTIME)}
- *   {@literal @SomeAnnotation}
- *   {@literal @Scope}
- *   public {@literal @interface} MyScope {}</pre>
- *
- * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
- * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
- *
- * @since 2.8
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@Documented
-@GwtIncompatible
-@Target(ANNOTATION_TYPE)
-@Deprecated
-public @interface CanReleaseReferences {}
diff --git a/java/dagger/releasablereferences/ForReleasableReferences.java b/java/dagger/releasablereferences/ForReleasableReferences.java
deleted file mode 100644
index e8cd4a48a..000000000
--- a/java/dagger/releasablereferences/ForReleasableReferences.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.releasablereferences;
-
-import static java.lang.annotation.ElementType.FIELD;
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import java.lang.annotation.Annotation;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import javax.inject.Qualifier;
-
-/**
- * A {@link Qualifier} to inject a {@link ReleasableReferenceManager} or {@link
- * TypedReleasableReferenceManager} object for a particular scope.
- *
- * <p>For example:
- *
- * <pre>
- *   {@literal @Documented}
- *   {@literal @Retention(RUNTIME)}
- *   {@literal @CanReleaseReferences}
- *   {@literal @Scope}
- *   {@literal public @interface} MyScope {}
- *
- *   {@literal @CanReleaseReferences}
- *   {@literal public @interface} MyMetadata {
- *     int value();
- *   }
- *
- *   {@literal @Documented}
- *   {@literal @Retention(RUNTIME)}
- *   {@literal @MyMetadata}(15)
- *   {@literal @Scope}
- *   {@literal public @interface YourScope} {}
- *
- *   class MyClass {
- *     {@literal @Inject}
- *     MyClass(
- *         {@literal @ForReleasableReferences(MyScope.class)}
- *         ReleasableReferenceManager myScopeReferenceManager,
- *         {@literal @ForReleasableReferences(YourScope.class)}
- *         {@literal TypedReleasableReferenceManager<MyMetadata>} yourScopeReferenceManager) {
- *       // …
- *     }
- *   }
- * </pre>
- *
- * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
- * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
- *
- * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
- * @since 2.8
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@Documented
-@GwtIncompatible
-@Target({FIELD, PARAMETER, METHOD})
-@Retention(RUNTIME)
-@Qualifier
-@Deprecated
-public @interface ForReleasableReferences {
-  /** The {@linkplain CanReleaseReferences reference-releasing} scope annotation type. */
-  Class<? extends Annotation> value();
-}
diff --git a/java/dagger/releasablereferences/ReleasableReferenceManager.java b/java/dagger/releasablereferences/ReleasableReferenceManager.java
deleted file mode 100644
index 506bee25f..000000000
--- a/java/dagger/releasablereferences/ReleasableReferenceManager.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.releasablereferences;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import java.lang.annotation.Annotation;
-import java.lang.ref.WeakReference;
-import javax.inject.Provider;
-
-/**
- * An object that can <a href="https://google.github.io/dagger/users-guide.html#releasable-references">release or
- * restore strong references</a> held in a {@link CanReleaseReferences @CanReleaseReferences} scope.
- *
- * <p>Your top-level component can provide a {@link
- * ForReleasableReferences @ForReleasableReferences(Foo.class)} {@link ReleasableReferenceManager}
- * object for any {@link CanReleaseReferences @CanReleaseReferences}-annotated scope {@code Foo}
- * anywhere in your component hierarchy.
- *
- * <p>It can also provide a {@code Set<ReleasableReferenceManager>} that contains all such objects.
- *
- * <p>Each provider in the {@link CanReleaseReferences @CanReleaseReferences} {@link #scope()} can
- * be in any one of four states at a time:
- *
- * <ul>
- *   <li>In <b>uninitialized</b> state, the provider's strong reference and its {@link
- *       WeakReference} are both {@code null}.
- *   <li>In <b>cleared</b> state, the provider's strong reference is {@code null}, and its {@link
- *       WeakReference}'s value is {@code null}.
- *   <li>In <b>strong-reference</b> state, the provider's strong reference refers to the cached
- *       value, and its {@link WeakReference} is {@code null}.
- *   <li>In <b>weak-reference</b> state, the provider's strong reference is {@code null}, and its
- *       {@link WeakReference}'s value is not {@code null}.
- * </ul>
- *
- * <p>All providers within {@link #scope()} start in <b>uninitialized</b> state.
- *
- * <p>Calling {@link Provider#get()} on a provider within {@link #scope()} transitions it to
- * <b>strong-reference</b> state if it was in <b>uninitialized</b> or <b>empty</b> state.
- *
- * <p>{@link #releaseStrongReferences()} transitions all providers within {@link #scope()} that are
- * in <b>strong-reference</b> state to <b>weak-reference</b> state.
- *
- * <p>{@link #restoreStrongReferences()} transitions all providers within {@link #scope()} that are
- * in <b>weak-reference</b> state to <b>strong-reference</b> state.
- *
- * <p>If garbage collection clears the {@link WeakReference} for any provider within {@link
- * #scope()} that is in <b>weak-reference</b> state, that provider transitions to <b>cleared</b>
- * state.
- *
- * <p><img src="doc-files/ReleasableReferenceManager-statemachine.png"
- * alt="ReleasableReferenceManager state machine">
- *
- * <p>This interface is implemented by Dagger.
- *
- * @since 2.8
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@GwtIncompatible
-@Deprecated
-public interface ReleasableReferenceManager {
-
-  /** The scope whose references are managed by this object. */
-  Class<? extends Annotation> scope();
-
-  /**
-   * Releases the strong references held by all providers in this {@linkplain #scope() scope} to the
-   * objects previously returned by {@link Provider#get()}, leaving only {@link WeakReference}s.
-   *
-   * <p>If any such {@link WeakReference} is cleared during garbage collection, the next call to
-   * that {@link Provider#get()} will execute the underlying binding again, and the provider will
-   * hold a strong reference to the new returned value.
-   *
-   * <p>Calls to {@link Provider#get()} on any such provider return the weakly-referenced object
-   * until the {@link WeakReference} is cleared or {@link #restoreStrongReferences()} is called.
-   */
-  void releaseStrongReferences();
-
-  /**
-   * Restores strong references for all providers in this {@linkplain #scope() scope} that were
-   * previously {@linkplain #releaseStrongReferences() released} but whose {@link WeakReference} has
-   * not yet been cleared during garbage collection.
-   */
-  void restoreStrongReferences();
-}
diff --git a/java/dagger/releasablereferences/TypedReleasableReferenceManager.java b/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
deleted file mode 100644
index eb42b7898..000000000
--- a/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.releasablereferences;
-
-import dagger.internal.Beta;
-import dagger.internal.GwtIncompatible;
-import java.lang.annotation.Annotation;
-
-/**
- * A {@link ReleasableReferenceManager} for a scope that is annotated with an annotation that itself
- * is annotated with {@link CanReleaseReferences}. That annotation is available as {@link
- * #metadata()} and may be useful at runtime to decide when to release references held by the scope.
- *
- * <p>For example:
- *
- * <pre>
- *   {@literal @CanReleaseReferences}
- *   public {@literal @interface} SomeAnnotation {
- *     int value();
- *   }
- *
- *   {@literal @Documented}
- *   {@literal @Retention(RUNTIME)}
- *   {@literal @SomeAnnotation}(15)
- *   {@literal @Scope}
- *   public {@literal @interface} MyScope {}
- *
- *   // In a component that is (or has a subcomponent) annotated with {@literal @MyScope}:
- *   {@literal @Inject}
- *   void manager(
- *       {@literal @ForReferenceReleasingScope(MyScope.class)}
- *       {@literal TypedReferenceReleasingScope<SomeAnnotation>} manager) {
- *     manager.metadata().value(); // returns 15
- *   }</pre>
- *
- * <p>This interface is implemented by Dagger.
- *
- * @param <M> the type of the metadata annotation
- * @deprecated The releasable references feature is deprecated and scheduled for removal in July
- *     2018. If you use it or are planning to add usages, please
- *     comment on <a href="https://github.com/google/dagger/issues/1117">this bug</a>.
- */
-@Beta
-@GwtIncompatible
-@Deprecated
-public interface TypedReleasableReferenceManager<M extends Annotation>
-    extends ReleasableReferenceManager {
-
-  /**
-   * Returns the annotation on {@link #scope()} that is annotated with {@link CanReleaseReferences}.
-   */
-  M metadata();
-}
diff --git a/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png b/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png
deleted file mode 100644
index 6400f1d23..000000000
Binary files a/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png and /dev/null differ
diff --git a/java/dagger/releasablereferences/package-info.java b/java/dagger/releasablereferences/package-info.java
deleted file mode 100644
index a306bdbdc..000000000
--- a/java/dagger/releasablereferences/package-info.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * This package contains the API by which Dagger allows you <a
- * href="https://google.github.io/dagger/users-guide.html#releasable-references">release references</a> held within
- * some scopes.
- *
- * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
- * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
- *
- * @since 2.8
- */
-package dagger.releasablereferences;
diff --git a/java/dagger/spi/DiagnosticReporter.java b/java/dagger/spi/DiagnosticReporter.java
index 8c15149d6..f9ec41e06 100644
--- a/java/dagger/spi/DiagnosticReporter.java
+++ b/java/dagger/spi/DiagnosticReporter.java
@@ -21,7 +21,7 @@
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
-import dagger.model.BindingGraph.MaybeBindingNode;
+import dagger.model.BindingGraph.MaybeBinding;
 import javax.tools.Diagnostic;
 
 /**
@@ -53,7 +53,7 @@ void reportComponent(
    * Reports a diagnostic for a binding or missing binding. Includes information about how the
    * binding is reachable from entry points.
    */
-  void reportBinding(Diagnostic.Kind diagnosticKind, MaybeBindingNode bindingNode, String message);
+  void reportBinding(Diagnostic.Kind diagnosticKind, MaybeBinding binding, String message);
 
   /**
    * Reports a diagnostic for a binding or missing binding. Includes information about how the
@@ -62,7 +62,7 @@ void reportComponent(
   @FormatMethod
   void reportBinding(
       Diagnostic.Kind diagnosticKind,
-      MaybeBindingNode bindingNode,
+      MaybeBinding binding,
       String messageFormat,
       Object firstArg,
       Object... moreArgs);
diff --git a/javatests/dagger/BUILD b/javatests/dagger/BUILD
index 83257e800..3debec570 100644
--- a/javatests/dagger/BUILD
+++ b/javatests/dagger/BUILD
@@ -23,6 +23,7 @@ load("//:test_defs.bzl", "GenJavaTests")
 GenJavaTests(
     name = "core_tests",
     srcs = glob(["**/*.java"]),
+    functional = 0,
     javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     deps = [
         "//java/dagger:core",
diff --git a/javatests/dagger/android/BUILD b/javatests/dagger/android/BUILD
index 8fa3dc303..5bc3f454c 100644
--- a/javatests/dagger/android/BUILD
+++ b/javatests/dagger/android/BUILD
@@ -23,6 +23,7 @@ load("//:test_defs.bzl", "GenRobolectricTests")
 GenRobolectricTests(
     name = "android_tests",
     srcs = glob(["*.java"]),
+    functional = False,
     javacopts = DOCLINT_HTML_AND_SYNTAX,
     manifest_values = {"minSdkVersion": "17"},
     deps = [
diff --git a/javatests/dagger/android/DispatchingAndroidInjectorTest.java b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
index 544565a37..d0306b8ce 100644
--- a/javatests/dagger/android/DispatchingAndroidInjectorTest.java
+++ b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
@@ -21,7 +21,10 @@
 
 import android.app.Activity;
 import com.google.common.collect.ImmutableMap;
+import dagger.android.AndroidInjector.Factory;
 import dagger.android.DispatchingAndroidInjector.InvalidInjectorBindingException;
+import java.util.Map;
+import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
@@ -34,7 +37,7 @@
   @Test
   public void withClassKeys() {
     DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
-        new DispatchingAndroidInjector<>(
+        newDispatchingAndroidInjector(
             ImmutableMap.of(FooActivity.class, FooInjector.Factory::new), ImmutableMap.of());
 
     FooActivity activity = Robolectric.setupActivity(FooActivity.class);
@@ -44,7 +47,7 @@ public void withClassKeys() {
   @Test
   public void withStringKeys() {
     DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
-        new DispatchingAndroidInjector<>(
+        newDispatchingAndroidInjector(
             ImmutableMap.of(),
             ImmutableMap.of(FooActivity.class.getName(), FooInjector.Factory::new));
 
@@ -55,7 +58,7 @@ public void withStringKeys() {
   @Test
   public void withMixedKeys() {
     DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
-        new DispatchingAndroidInjector<>(
+        newDispatchingAndroidInjector(
             ImmutableMap.of(FooActivity.class, FooInjector.Factory::new),
             ImmutableMap.of(BarActivity.class.getName(), BarInjector.Factory::new));
 
@@ -68,8 +71,8 @@ public void withMixedKeys() {
   @Test
   public void maybeInject_returnsFalse_ifNoMatchingInjectorExists() {
     DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
-        new DispatchingAndroidInjector<>(ImmutableMap.of(), ImmutableMap.of());
-    
+        newDispatchingAndroidInjector(ImmutableMap.of(), ImmutableMap.of());
+
     BarActivity activity = Robolectric.setupActivity(BarActivity.class);
     assertThat(dispatchingAndroidInjector.maybeInject(activity)).isFalse();
   }
@@ -77,9 +80,8 @@ public void maybeInject_returnsFalse_ifNoMatchingInjectorExists() {
   @Test
   public void throwsIfFactoryCreateReturnsNull() {
     DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
-        new DispatchingAndroidInjector<>(
-            ImmutableMap.of(FooActivity.class, () -> null),
-            ImmutableMap.of());
+        newDispatchingAndroidInjector(
+            ImmutableMap.of(FooActivity.class, () -> null), ImmutableMap.of());
     FooActivity activity = Robolectric.setupActivity(FooActivity.class);
 
     try {
@@ -92,7 +94,7 @@ public void throwsIfFactoryCreateReturnsNull() {
   @Test
   public void throwsIfClassMismatched() {
     DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
-        new DispatchingAndroidInjector<>(
+        newDispatchingAndroidInjector(
             ImmutableMap.of(FooActivity.class, BarInjector.Factory::new), ImmutableMap.of());
     FooActivity activity = Robolectric.setupActivity(FooActivity.class);
 
@@ -103,6 +105,17 @@ public void throwsIfClassMismatched() {
     }
   }
 
+  private static <T> DispatchingAndroidInjector<T> newDispatchingAndroidInjector(
+      Map<Class<?>, Provider<Factory<?>>> injectorFactoriesWithClassKeys,
+      Map<String, Provider<AndroidInjector.Factory<?>>>
+          injectorFactoriesWithStringKeys) {
+    return new DispatchingAndroidInjector<>(
+        injectorFactoriesWithClassKeys,
+        injectorFactoriesWithStringKeys ,
+        ImmutableMap.of(),
+        ImmutableMap.of());
+  }
+
   static class FooActivity extends Activity {}
 
   static class BarActivity extends Activity {}
diff --git a/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java b/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
deleted file mode 100644
index df0c890bf..000000000
--- a/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.functional;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
-import static com.google.common.truth.Truth.assertThat;
-import static dagger.android.functional.AndroidMemorySensitiveReferenceManagerTest.AllWeakReferencesCleared.allWeakReferencesCleared;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.testing.GcFinalization;
-import com.google.common.testing.GcFinalization.FinalizationPredicate;
-import java.lang.ref.WeakReference;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-/** Functional tests of {@link dagger.android.AndroidMemorySensitiveReferenceManager}. */
-@RunWith(RobolectricTestRunner.class)
-public final class AndroidMemorySensitiveReferenceManagerTest {
-
-  private TestModule testModule;
-  private TestComponent component;
-
-  @Before
-  public void setUp() {
-    testModule = new TestModule();
-    component = DaggerTestComponent.builder().testModule(testModule).build();
-  }
-
-  @Test
-  public void scoped() {
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  @Test
-  public void onTrimMemory_aboveThresholds() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-
-    component.manager().onTrimMemory(TRIM_MEMORY_COMPLETE);
-    GcFinalization.awaitDone(
-        allWeakReferencesCleared(
-            component.releasedWhenUiHidden(), component.releasedWhenModerate()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(2);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(2);
-  }
-
-  @Test
-  public void onTrimMemory_atOneThresholdBelowAnother() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-
-    component.manager().onTrimMemory(TRIM_MEMORY_UI_HIDDEN);
-    GcFinalization.awaitDone(allWeakReferencesCleared(component.releasedWhenUiHidden()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(2);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  @Test
-  public void onTrimMemory_belowThresholds() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-
-    component.manager().onTrimMemory(TRIM_MEMORY_RUNNING_MODERATE);
-    GcFinalization.awaitDone(allWeakReferencesCleared(new Object()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  @Test
-  public void onTrimMemory_restore() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-
-    component.manager().onTrimMemory(TRIM_MEMORY_UI_HIDDEN);
-    component.manager().onTrimMemory(TRIM_MEMORY_RUNNING_MODERATE);
-    GcFinalization.awaitDone(allWeakReferencesCleared(new Object()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  static final class AllWeakReferencesCleared implements FinalizationPredicate {
-
-    private final ImmutableList<WeakReference<Object>> references;
-
-    AllWeakReferencesCleared(ImmutableList<WeakReference<Object>> references) {
-      this.references = references;
-    }
-
-    @Override
-    public boolean isDone() {
-      for (WeakReference<Object> reference : references) {
-        if (reference.get() != null) {
-          return false;
-        }
-      }
-      return true;
-    }
-
-    static AllWeakReferencesCleared allWeakReferencesCleared(Object... objects) {
-      ImmutableList.Builder<WeakReference<Object>> referencesBuilder = ImmutableList.builder();
-      for (Object object : objects) {
-        referencesBuilder.add(new WeakReference<>(object));
-      }
-      return new AllWeakReferencesCleared(referencesBuilder.build());
-    }
-  }
-}
diff --git a/javatests/dagger/android/functional/BUILD b/javatests/dagger/android/functional/BUILD
deleted file mode 100644
index fe80b6d47..000000000
--- a/javatests/dagger/android/functional/BUILD
+++ /dev/null
@@ -1,53 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   Functional test code for Dagger-Android
-
-package(default_visibility = ["//:src"])
-
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-)
-load("//:test_defs.bzl", "GenRobolectricTests")
-
-# Sample code to be tested in functional tests.
-android_library(
-    name = "code_under_test",
-    srcs = glob(
-        ["*.java"],
-        exclude = ["*Test.java"],
-    ),
-    javacopts = DOCLINT_HTML_AND_SYNTAX,
-    deps = [
-        # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
-        # used without a Guava and jsr305 deps.
-        "//:dagger_with_compiler",
-        "//:android",
-    ],
-)
-
-GenRobolectricTests(
-    name = "android_functional_tests",
-    srcs = glob(["*Test.java"]),
-    javacopts = DOCLINT_HTML_AND_SYNTAX,
-    deps = [
-        ":code_under_test",
-        "@google_bazel_common//third_party/java/guava",
-        "@google_bazel_common//third_party/java/guava:testlib",
-        "@google_bazel_common//third_party/java/junit",
-        "@google_bazel_common//third_party/java/truth",
-    ],
-)
diff --git a/javatests/dagger/android/functional/ReleaseWhenModerate.java b/javatests/dagger/android/functional/ReleaseWhenModerate.java
deleted file mode 100644
index c8971b42d..000000000
--- a/javatests/dagger/android/functional/ReleaseWhenModerate.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.functional;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import dagger.android.ReleaseReferencesAt;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import javax.inject.Scope;
-
-@Documented
-@Retention(RUNTIME)
-@Target({TYPE, METHOD})
-@ReleaseReferencesAt(TRIM_MEMORY_MODERATE)
-@Scope
-@interface ReleaseWhenModerate {}
diff --git a/javatests/dagger/android/functional/ReleaseWhenUiHidden.java b/javatests/dagger/android/functional/ReleaseWhenUiHidden.java
deleted file mode 100644
index ca22db44a..000000000
--- a/javatests/dagger/android/functional/ReleaseWhenUiHidden.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.functional;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import dagger.android.ReleaseReferencesAt;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import javax.inject.Scope;
-
-@Documented
-@Retention(RUNTIME)
-@Target({TYPE, METHOD})
-@ReleaseReferencesAt(TRIM_MEMORY_UI_HIDDEN)
-@Scope
-@interface ReleaseWhenUiHidden {}
diff --git a/javatests/dagger/android/functional/TestComponent.java b/javatests/dagger/android/functional/TestComponent.java
deleted file mode 100644
index 03d40755b..000000000
--- a/javatests/dagger/android/functional/TestComponent.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.functional;
-
-import dagger.Component;
-import dagger.android.AndroidMemorySensitiveReferenceManager;
-import javax.inject.Singleton;
-
-@Singleton
-@ReleaseWhenUiHidden
-@ReleaseWhenModerate
-@Component(modules = TestModule.class)
-interface TestComponent {
-  AndroidMemorySensitiveReferenceManager manager();
-
-  @InScope(ReleaseWhenUiHidden.class)
-  Object releasedWhenUiHidden();
-
-  @InScope(ReleaseWhenModerate.class)
-  Object releasedWhenModerate();
-}
diff --git a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
index d08bf0b78..cfa6e90b5 100644
--- a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
+++ b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
@@ -50,14 +50,6 @@
           "import android.app.Activity;",
           "",
           "public class BarActivity extends Activity {}");
-  private static final JavaFileObject BAZ_FRAGMENT =
-      JavaFileObjects.forSourceLines(
-          "test.BazFragment",
-          "package test;",
-          "",
-          "import android.app.Fragment;",
-          "",
-          "public class BazFragment extends Fragment {}");
 
   private static JavaFileObject moduleWithMethod(String... lines) {
     return JavaFileObjects.forSourceLines(
@@ -69,7 +61,7 @@ private static JavaFileObject moduleWithMethod(String... lines) {
         "import dagger.Module;",
         "import dagger.*;",
         "import dagger.android.*;",
-        "import dagger.multibindings.IntoMap;",
+        "import dagger.multibindings.*;",
         "import javax.inject.*;",
         "",
         "@Module",
@@ -87,15 +79,14 @@ public void rawFactoryType() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
+            "@ClassKey(FooActivity.class)",
             "abstract AndroidInjector.Factory bindRawFactory(FooActivity.Factory factory);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "@dagger.android.ActivityKey methods should bind "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
-                + "dagger.android.AndroidInjector.Factory");
+            "should bind dagger.android.AndroidInjector.Factory<?>, "
+                + "not dagger.android.AndroidInjector.Factory");
   }
 
   @Test
@@ -104,15 +95,14 @@ public void rawBuilderType() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
+            "@ClassKey(FooActivity.class)",
             "abstract AndroidInjector.Builder bindRawBuilder(FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "@dagger.android.ActivityKey methods should bind "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
-                + "dagger.android.AndroidInjector.Builder");
+            "should bind dagger.android.AndroidInjector.Factory<?>, "
+                + "not dagger.android.AndroidInjector.Builder");
   }
 
   @Test
@@ -121,16 +111,15 @@ public void bindsToBuilderNotFactory() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
-            "abstract AndroidInjector.Builder<? extends Activity> bindBuilder(",
+            "@ClassKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<?> bindBuilder(",
             "    FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "@dagger.android.ActivityKey methods should bind "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
-                + "dagger.android.AndroidInjector.Builder<? extends android.app.Activity>");
+            "should bind dagger.android.AndroidInjector.Factory<?>, not "
+                + "dagger.android.AndroidInjector.Builder<?>");
   }
 
   @Test
@@ -139,100 +128,16 @@ public void providesToBuilderNotFactory() {
         moduleWithMethod(
             "@Provides",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
-            "static AndroidInjector.Builder<? extends Activity> bindBuilder(",
-            "    FooActivity.Builder builder) {",
+            "@ClassKey(FooActivity.class)",
+            "static AndroidInjector.Builder<?> bindBuilder(FooActivity.Builder builder) {",
             "  return builder;",
             "}");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "@dagger.android.ActivityKey methods should bind "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
-                + "dagger.android.AndroidInjector.Builder<? extends android.app.Activity>");
-  }
-
-  @Test
-  public void mapKeyDoesntMatchCoreType() {
-    JavaFileObject module =
-        moduleWithMethod(
-            "@Binds",
-            "@IntoMap",
-            "@FragmentKey(BazFragment.class)",
-            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
-            "    FooActivity.Builder builder);");
-    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@dagger.android.FragmentKey methods should bind "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
-    assertThat(compilation)
-        .hadErrorContaining(
-            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
-        .inFile(module)
-        .onLine(LINES_BEFORE_METHOD + 3);
-  }
-
-  @Test
-  public void mapKeyDoesntMatchCoreType_AndroidInjectionKey() {
-    JavaFileObject module =
-        moduleWithMethod(
-            "@Binds",
-            "@IntoMap",
-            "@AndroidInjectionKey(\"test.BazFragment\")",
-            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
-            "    FooActivity.Builder builder);");
-    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "bindWrongFrameworkType(test.FooActivity.Builder) should bind "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
-    assertThat(compilation)
-        .hadErrorContaining(
-            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
-        .inFile(module)
-        .onLine(LINES_BEFORE_METHOD + 3);
-  }
-
-  @Test
-  public void mapKeyDoesntMatchCoreType_supportFragments() {
-    JavaFileObject supportFragment =
-        JavaFileObjects.forSourceLines(
-            "test.SupportFragment",
-            "package test;",
-            "",
-            "import android.support.v4.app.Fragment;",
-            "import dagger.android.AndroidInjector;",
-            "",
-            "public class SupportFragment extends Fragment {",
-            "  interface Factory extends AndroidInjector.Factory<SupportFragment> {}",
-            "}");
-
-    JavaFileObject module =
-        moduleWithMethod(
-            "@Binds",
-            "@IntoMap",
-            "@dagger.android.FragmentKey(BazFragment.class)",
-            "abstract AndroidInjector.Factory<? extends android.support.v4.app.Fragment> ",
-            "    bindWrongFrameworkType(SupportFragment.Factory factory);");
-    Compilation compilation = compile(module, BAZ_FRAGMENT, supportFragment);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@dagger.android.FragmentKey methods should bind "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
-                + "dagger.android.AndroidInjector.Factory<? extends "
-                + "android.support.v4.app.Fragment>");
-    assertThat(compilation)
-        .hadErrorContaining(
-            "test.SupportFragment.Factory does not implement AndroidInjector<test.BazFragment>")
-        .inFile(module)
-        .onLine(LINES_BEFORE_METHOD + 3);
+            "should bind dagger.android.AndroidInjector.Factory<?>, not "
+                + "dagger.android.AndroidInjector.Builder<?>");
   }
 
   @Test
@@ -241,15 +146,14 @@ public void bindsToConcreteTypeInsteadOfWildcard() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
+            "@ClassKey(FooActivity.class)",
             "abstract AndroidInjector.Builder<FooActivity> bindBuilder(",
             "    FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "@dagger.android.ActivityKey methods should bind "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+            "should bind dagger.android.AndroidInjector.Factory<?>, not "
                 + "dagger.android.AndroidInjector.Builder<test.FooActivity>");
   }
 
@@ -259,7 +163,7 @@ public void bindsToBaseTypeInsteadOfWildcard() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
+            "@ClassKey(FooActivity.class)",
             "abstract AndroidInjector.Builder<Activity> bindBuilder(",
             "    FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
@@ -274,9 +178,8 @@ public void bindsCorrectType() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
-            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
-            "    FooActivity.Builder builder);");
+            "@ClassKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory<?> bindCorrectType(FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).succeededWithoutWarnings();
   }
@@ -288,8 +191,19 @@ public void bindsCorrectType_AndroidInjectionKey() {
             "@Binds",
             "@IntoMap",
             "@AndroidInjectionKey(\"test.FooActivity\")",
-            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
-            "    FooActivity.Builder builder);");
+            "abstract AndroidInjector.Factory<?> bindCorrectType(FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsCorrectType_AndroidInjectionKey_unbounded() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.FooActivity\")",
+            "abstract AndroidInjector.Factory<?> bindCorrectType(FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).succeededWithoutWarnings();
   }
@@ -300,10 +214,9 @@ public void bindsWithScope() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
+            "@ClassKey(FooActivity.class)",
             "@Singleton",
-            "abstract AndroidInjector.Factory<? extends Activity> bindWithScope(",
-            "    FooActivity.Builder builder);");
+            "abstract AndroidInjector.Factory<?> bindWithScope(FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("should not be scoped");
@@ -316,10 +229,9 @@ public void bindsWithScope_suppressWarnings() {
             "@SuppressWarnings(\"dagger.android.ScopedInjectorFactory\")",
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
+            "@ClassKey(FooActivity.class)",
             "@Singleton",
-            "abstract AndroidInjector.Factory<? extends Activity> bindWithScope(",
-            "    FooActivity.Builder builder);");
+            "abstract AndroidInjector.Factory<?> bindWithScope(FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).succeededWithoutWarnings();
   }
@@ -330,9 +242,8 @@ public void mismatchedMapKey_bindsFactory() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(BarActivity.class)",
-            "abstract AndroidInjector.Factory<?> mismatchedFactory(",
-            "    FooActivity.Factory factory);");
+            "@ClassKey(BarActivity.class)",
+            "abstract AndroidInjector.Factory<?> mismatchedFactory(FooActivity.Factory factory);");
     Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -348,9 +259,8 @@ public void mismatchedMapKey_bindsBuilder() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(BarActivity.class)",
-            "abstract AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
-            "    FooActivity.Builder builder);");
+            "@ClassKey(BarActivity.class)",
+            "abstract AndroidInjector.Factory<?> mismatchedBuilder(FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -367,8 +277,7 @@ public void mismatchedMapKey_bindsBuilder_androidInjectionKey() {
             "@Binds",
             "@IntoMap",
             "@AndroidInjectionKey(\"test.BarActivity\")",
-            "abstract AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
-            "    FooActivity.Builder builder);");
+            "abstract AndroidInjector.Factory<?> mismatchedBuilder(FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -384,9 +293,8 @@ public void mismatchedMapKey_providesBuilder() {
         moduleWithMethod(
             "@Provides",
             "@IntoMap",
-            "@ActivityKey(BarActivity.class)",
-            "static AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
-            "    FooActivity.Builder builder) {",
+            "@ClassKey(BarActivity.class)",
+            "static AndroidInjector.Factory<?> mismatchedBuilder(FooActivity.Builder builder) {",
             "  return builder;",
             "}");
     Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
@@ -399,7 +307,7 @@ public void bindsQualifier_ignoresChecks() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
+            "@ClassKey(FooActivity.class)",
             "@Named(\"unused\")",
             // normally this should fail, since it is binding to a Builder not a Factory
             "abstract AndroidInjector.Builder<?> bindsBuilderWithQualifier(",
@@ -414,7 +322,7 @@ public void bindToPrimitive() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
+            "@AndroidInjectionKey(\"test.FooActivity\")",
             "abstract int bindInt(@Named(\"unused\") int otherInt);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).succeededWithoutWarnings();
@@ -426,7 +334,7 @@ public void bindToNonFrameworkClass() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
+            "@AndroidInjectionKey(\"test.FooActivity\")",
             "abstract Number bindInt(Integer integer);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).succeededWithoutWarnings();
@@ -438,7 +346,7 @@ public void invalidBindsMethod() {
         moduleWithMethod(
             "@Binds",
             "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
+            "@ClassKey(FooActivity.class)",
             "abstract AndroidInjector.Factory<?> bindCorrectType(",
             "    FooActivity.Builder builder, FooActivity.Builder builder2);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
diff --git a/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
index 7ac0d53ac..1718737cb 100644
--- a/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
+++ b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
@@ -156,30 +156,6 @@ public void parameterizedReturnType() {
         .onLineContaining("test()");
   }
 
-  @Test
-  public void notAFrameworkType() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.android.ContributesAndroidInjector;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @ContributesAndroidInjector",
-            "  abstract android.content.Intent intent();",
-            "}");
-
-    Compilation compilation = compile(module);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("is not a framework type")
-        .inFile(module)
-        .onLineContaining("intent()");
-  }
-
   @Test
   public void moduleIsntModule() {
     JavaFileObject module =
diff --git a/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
index 8cd1979ee..a84c7eba9 100644
--- a/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
+++ b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
@@ -68,13 +68,13 @@ public void conflictingMapKeys() {
             "interface TestModule {",
             "  @Binds",
             "  @IntoMap",
-            "  @ActivityKey(TestActivity.class)",
-            "  AndroidInjector.Factory<? extends Activity> classKey(TestInjectorFactory factory);",
+            "  @ClassKey(TestActivity.class)",
+            "  AndroidInjector.Factory<?> classKey(TestInjectorFactory factory);",
             "",
             "  @Binds",
             "  @IntoMap",
             "  @AndroidInjectionKey(\"test.TestActivity\")",
-            "  AndroidInjector.Factory<? extends Activity> stringKey(TestInjectorFactory factory);",
+            "  AndroidInjector.Factory<?> stringKey(TestInjectorFactory factory);",
             "}");
     JavaFileObject component =
         JavaFileObjects.forSourceLines(
diff --git a/javatests/dagger/android/support/BUILD b/javatests/dagger/android/support/BUILD
index 9b87d849b..6d8f43bb0 100644
--- a/javatests/dagger/android/support/BUILD
+++ b/javatests/dagger/android/support/BUILD
@@ -23,6 +23,7 @@ load("//:test_defs.bzl", "GenRobolectricTests")
 GenRobolectricTests(
     name = "android-support-tests",
     srcs = glob(["*.java"]),
+    functional = False,
     javacopts = DOCLINT_HTML_AND_SYNTAX,
     deps = [
         "//:dagger_with_compiler",
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
index 1382af1ed..fa05158f1 100644
--- a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -16,29 +16,20 @@
 
 package dagger.android.support.functional;
 
-import android.app.Activity;
-import android.app.Service;
-import android.content.BroadcastReceiver;
-import android.content.ContentProvider;
-import android.support.v4.app.Fragment;
 import dagger.Binds;
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
 import dagger.Subcomponent;
-import dagger.android.ActivityKey;
+import dagger.android.AndroidInjectionModule;
 import dagger.android.AndroidInjector;
-import dagger.android.BroadcastReceiverKey;
-import dagger.android.ContentProviderKey;
-import dagger.android.ServiceKey;
-import dagger.android.support.AndroidSupportInjectionModule;
 import dagger.android.support.DaggerApplication;
-import dagger.android.support.FragmentKey;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.InnerActivitySubcomponent.InnerActivityModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
+import dagger.multibindings.ClassKey;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
 
@@ -49,9 +40,7 @@
     return DaggerAllControllersAreDirectChildrenOfApplication_ApplicationComponent.create();
   }
 
-  @Component(
-    modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
-  )
+  @Component(modules = {ApplicationComponent.ApplicationModule.class, AndroidInjectionModule.class})
   interface ApplicationComponent
       extends AndroidInjector<AllControllersAreDirectChildrenOfApplication> {
     @Module(
@@ -76,56 +65,56 @@
 
       @Binds
       @IntoMap
-      @ActivityKey(TestActivity.class)
-      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
+      @ClassKey(TestActivity.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @ActivityKey(OuterClass.TestInnerClassActivity.class)
-      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForInnerActivity(
+      @ClassKey(OuterClass.TestInnerClassActivity.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForInnerActivity(
           InnerActivitySubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @FragmentKey(TestParentFragment.class)
-      abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForParentFragment(
+      @ClassKey(TestParentFragment.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForParentFragment(
           ParentFragmentSubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @FragmentKey(TestChildFragment.class)
-      abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForChildFragment(
+      @ClassKey(TestChildFragment.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForChildFragment(
           ChildFragmentSubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @FragmentKey(TestDialogFragment.class)
-      abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForDialogFragment(
+      @ClassKey(TestDialogFragment.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForDialogFragment(
           DialogFragmentSubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @ServiceKey(TestService.class)
-      abstract AndroidInjector.Factory<? extends Service> bindFactoryForService(
+      @ClassKey(TestService.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForService(
           ServiceSubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @ServiceKey(TestIntentService.class)
-      abstract AndroidInjector.Factory<? extends Service> bindFactoryForIntentService(
+      @ClassKey(TestIntentService.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForIntentService(
           IntentServiceSubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @BroadcastReceiverKey(TestBroadcastReceiver.class)
-      abstract AndroidInjector.Factory<? extends BroadcastReceiver> bindFactoryForBroadcastReceiver(
+      @ClassKey(TestBroadcastReceiver.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForBroadcastReceiver(
           BroadcastReceiverSubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @ContentProviderKey(TestContentProvider.class)
-      abstract AndroidInjector.Factory<? extends ContentProvider> bindFactoryForContentProvider(
+      @ClassKey(TestContentProvider.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForContentProvider(
           ContentProviderSubcomponent.Builder builder);
     }
 
diff --git a/javatests/dagger/android/support/functional/AndroidManifest.xml b/javatests/dagger/android/support/functional/AndroidManifest.xml
index c89d30667..2e40a354f 100644
--- a/javatests/dagger/android/support/functional/AndroidManifest.xml
+++ b/javatests/dagger/android/support/functional/AndroidManifest.xml
@@ -16,6 +16,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="dagger.android.support.functional">
 
+  <uses-sdk android:minSdkVersion="1" android:targetSdkVersion="26" />
+
   <application android:theme="@style/Theme.AppCompat"
       android:name=".UsesGeneratedModulesApplication">
     <activity android:name="dagger.android.support.functional.ParentOfFragmentActivity"/>
diff --git a/javatests/dagger/android/support/functional/BUILD b/javatests/dagger/android/support/functional/BUILD
index 8f899178f..ffb93618e 100644
--- a/javatests/dagger/android/support/functional/BUILD
+++ b/javatests/dagger/android/support/functional/BUILD
@@ -48,6 +48,7 @@ GenRobolectricTests(
         "//:dagger_with_compiler",
         "@androidsdk//com.android.support:support-fragment-25.0.0",
         "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/robolectric",
         "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
index 379c795f0..48e9a59bf 100644
--- a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -16,29 +16,20 @@
 
 package dagger.android.support.functional;
 
-import android.app.Activity;
-import android.app.Service;
-import android.content.BroadcastReceiver;
-import android.content.ContentProvider;
-import android.support.v4.app.Fragment;
 import dagger.Binds;
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
 import dagger.Subcomponent;
-import dagger.android.ActivityKey;
+import dagger.android.AndroidInjectionModule;
 import dagger.android.AndroidInjector;
-import dagger.android.BroadcastReceiverKey;
-import dagger.android.ContentProviderKey;
-import dagger.android.ServiceKey;
-import dagger.android.support.AndroidSupportInjectionModule;
 import dagger.android.support.DaggerApplication;
-import dagger.android.support.FragmentKey;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.InnerActivitySubcomponent.InnerActivityModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
+import dagger.multibindings.ClassKey;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
 
@@ -51,9 +42,7 @@
         .create();
   }
 
-  @Component(
-    modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
-  )
+  @Component(modules = {ApplicationComponent.ApplicationModule.class, AndroidInjectionModule.class})
   interface ApplicationComponent
       extends AndroidInjector<ComponentStructureFollowsControllerStructureApplication> {
     @Module(
@@ -75,38 +64,38 @@
 
       @Binds
       @IntoMap
-      @ActivityKey(TestActivity.class)
-      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
+      @ClassKey(TestActivity.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @ActivityKey(OuterClass.TestInnerClassActivity.class)
-      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForInnerActivity(
+      @ClassKey(OuterClass.TestInnerClassActivity.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForInnerActivity(
           InnerActivitySubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @ServiceKey(TestService.class)
-      abstract AndroidInjector.Factory<? extends Service> bindFactoryForService(
+      @ClassKey(TestService.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForService(
           ServiceSubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @ServiceKey(TestIntentService.class)
-      abstract AndroidInjector.Factory<? extends Service> bindFactoryForIntentService(
+      @ClassKey(TestIntentService.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForIntentService(
           IntentServiceSubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @BroadcastReceiverKey(TestBroadcastReceiver.class)
-      abstract AndroidInjector.Factory<? extends BroadcastReceiver> bindFactoryForBroadcastReceiver(
+      @ClassKey(TestBroadcastReceiver.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForBroadcastReceiver(
           BroadcastReceiverSubcomponent.Builder builder);
 
       @Binds
       @IntoMap
-      @ContentProviderKey(TestContentProvider.class)
-      abstract AndroidInjector.Factory<? extends ContentProvider> bindFactoryForContentProvider(
+      @ClassKey(TestContentProvider.class)
+      abstract AndroidInjector.Factory<?> bindFactoryForContentProvider(
           ContentProviderSubcomponent.Builder builder);
     }
 
@@ -122,14 +111,14 @@
 
         @Binds
         @IntoMap
-        @FragmentKey(TestParentFragment.class)
-        abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForParentFragment(
+        @ClassKey(TestParentFragment.class)
+        abstract AndroidInjector.Factory<?> bindFactoryForParentFragment(
             ParentFragmentSubcomponent.Builder builder);
 
         @Binds
         @IntoMap
-        @FragmentKey(TestDialogFragment.class)
-        abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForDialogFragment(
+        @ClassKey(TestDialogFragment.class)
+        abstract AndroidInjector.Factory<?> bindFactoryForDialogFragment(
             DialogFragmentSubcomponent.Builder builder);
       }
 
@@ -148,8 +137,8 @@
 
           @Binds
           @IntoMap
-          @FragmentKey(TestChildFragment.class)
-          abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForChildFragment(
+          @ClassKey(TestChildFragment.class)
+          abstract AndroidInjector.Factory<?> bindFactoryForChildFragment(
               ChildFragmentSubcomponent.Builder builder);
         }
 
diff --git a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
index cf340e319..002da8952 100644
--- a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
+++ b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
@@ -21,9 +21,9 @@
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
+import dagger.android.AndroidInjectionModule;
 import dagger.android.AndroidInjector;
 import dagger.android.ContributesAndroidInjector;
-import dagger.android.support.AndroidSupportInjectionModule;
 import dagger.android.support.DaggerApplication;
 import dagger.multibindings.IntoSet;
 import java.lang.annotation.Retention;
@@ -37,7 +37,7 @@
     return DaggerUsesGeneratedModulesApplication_ApplicationComponent.create();
   }
 
-  @Component(modules = {ApplicationModule.class, AndroidSupportInjectionModule.class})
+  @Component(modules = {ApplicationModule.class, AndroidInjectionModule.class})
   interface ApplicationComponent extends AndroidInjector<UsesGeneratedModulesApplication> {}
 
   @Module
diff --git a/javatests/dagger/functional/BUILD b/javatests/dagger/functional/BUILD
index bf6e066cb..f417bec06 100644
--- a/javatests/dagger/functional/BUILD
+++ b/javatests/dagger/functional/BUILD
@@ -28,9 +28,6 @@ GenJavaTests(
     name = "functional_tests",
     srcs = glob(
         ["**/*.java"],
-        exclude = [
-            "HjarTest.java",
-        ],
     ),
     javacopts = DOCLINT_HTML_AND_SYNTAX,
     lib_javacopts = SOURCE_7_TARGET_7,
diff --git a/javatests/dagger/functional/ReleasableReferencesComponents.java b/javatests/dagger/functional/ReleasableReferencesComponents.java
deleted file mode 100644
index 4717e8970..000000000
--- a/javatests/dagger/functional/ReleasableReferencesComponents.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional;
-
-import static dagger.functional.ReleasableReferencesComponents.Thing.thing;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import com.google.auto.value.AutoValue;
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.multibindings.ClassKey;
-import dagger.multibindings.IntoMap;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.lang.annotation.Retention;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Scope;
-
-final class ReleasableReferencesComponents {
-
-  interface ThingComponent {
-    /**
-     * A map whose keys are the scope annotations for each value. For unscoped values, the key is
-     * the module that contains the unscoped binding. So for {@link Parent}, the unscoped {@link
-     * Thing}'s key is {@link ParentModule ParentModule.class}; for {@link Child}, it is {@link
-     * ChildModule ChildModule.class}.
-     */
-    Map<Class<?>, Thing> things();
-  }
-
-  @ParentRegularScope
-  @ParentReleasableScope1
-  @ParentReleasableScope2
-  @Component(modules = ParentModule.class)
-  interface Parent extends ThingComponent {
-
-    Set<ReleasableReferenceManager> managers();
-
-    Set<TypedReleasableReferenceManager<Metadata1>> typedReleasableReferenceManagers1();
-
-    Set<TypedReleasableReferenceManager<Metadata2>> typedReleasableReferenceManagers2();
-
-    @ForReleasableReferences(ParentReleasableScope1.class)
-    ReleasableReferenceManager parentReleasableScope1Manager();
-
-    @ForReleasableReferences(ParentReleasableScope2.class)
-    ReleasableReferenceManager parentReleasableScope2Manager();
-
-    @ForReleasableReferences(ParentReleasableScope2.class)
-    TypedReleasableReferenceManager<Metadata1> parentReleasableScope2TypedReferenceManager();
-
-    @ForReleasableReferences(ChildReleasableScope1.class)
-    ReleasableReferenceManager childReleasableScope1Manager();
-
-    @ForReleasableReferences(ChildReleasableScope2.class)
-    ReleasableReferenceManager childReleasableScope2Manager();
-
-    @ForReleasableReferences(ChildReleasableScope2.class)
-    TypedReleasableReferenceManager<Metadata1> childReleasableScope2TypedReferenceManager1();
-
-    @ForReleasableReferences(ChildReleasableScope2.class)
-    TypedReleasableReferenceManager<Metadata2> childReleasableScope2TypedReferenceManager2();
-
-    Child child();
-  }
-
-  @AutoValue
-  abstract static class Thing {
-    abstract int count();
-
-    static Thing thing(int count) {
-      return new AutoValue_ReleasableReferencesComponents_Thing(count);
-    }
-  }
-
-  @ChildRegularScope
-  @ChildReleasableScope1
-  @ChildReleasableScope2
-  @ChildReleasableScope3
-  @Subcomponent(modules = ChildModule.class)
-  interface Child extends ThingComponent {}
-
-  @CanReleaseReferences
-  @interface Metadata1 {
-    String value();
-  }
-
-  @CanReleaseReferences
-  @interface Metadata2 {
-    String value();
-  }
-
-  @Retention(RUNTIME)
-  @Scope
-  @interface ParentRegularScope {}
-
-  @Retention(RUNTIME)
-  @Scope
-  @interface ChildRegularScope {}
-
-  @Retention(RUNTIME)
-  @CanReleaseReferences
-  @Scope
-  @interface ParentReleasableScope1 {}
-
-  @Retention(RUNTIME)
-  @Metadata1("ParentReleasableScope2")
-  @Scope
-  @interface ParentReleasableScope2 {}
-
-  @Retention(RUNTIME)
-  @Metadata2("ChildReleasableScope1")
-  @Scope
-  @interface ChildReleasableScope1 {}
-
-  @Retention(RUNTIME)
-  @Metadata1("ChildReleasableScope2.1")
-  @Metadata2("ChildReleasableScope2.2")
-  @Scope
-  @interface ChildReleasableScope2 {}
-
-  @Retention(RUNTIME)
-  @Metadata1("ChildReleasableScope3.1")
-  @Metadata2("ChildReleasableScope3.2")
-  @CanReleaseReferences
-  @Scope
-  @interface ChildReleasableScope3 {}
-
-  @Module
-  static final class ParentModule {
-    private int unscopedCount;
-    private int regularScopeCount;
-    private int releasableScope1Count;
-    private int releasableScope2Count;
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentModule.class)
-    Thing parentUnscopedThing() {
-      return thing(++unscopedCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentRegularScope.class)
-    @ParentRegularScope
-    Thing regularScopedThing() {
-      return thing(++regularScopeCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentReleasableScope1.class)
-    @ParentReleasableScope1
-    Thing releasableScope1Thing() {
-      return thing(++releasableScope1Count);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentReleasableScope2.class)
-    @ParentReleasableScope2
-    Thing releasableScope2Thing() {
-      return thing(++releasableScope2Count);
-    }
-  }
-
-  @Module
-  static final class ChildModule {
-    private int unscopedCount;
-    private int regularScopeCount;
-    private int releasableScope1Count;
-    private int releasableScope2Count;
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildModule.class)
-    Thing childUnscopedThing() {
-      return thing(++unscopedCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildRegularScope.class)
-    @ChildRegularScope
-    Thing regularScopedThing() {
-      return thing(++regularScopeCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildReleasableScope1.class)
-    @ChildReleasableScope1
-    Thing releasableScope1Thing() {
-      return thing(++releasableScope1Count);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildReleasableScope2.class)
-    @ChildReleasableScope2
-    Thing releasableScope2Thing() {
-      return thing(++releasableScope2Count);
-    }
-  }
-}
diff --git a/javatests/dagger/functional/ReleasableReferencesComponentsTest.java b/javatests/dagger/functional/ReleasableReferencesComponentsTest.java
deleted file mode 100644
index 2e30791f3..000000000
--- a/javatests/dagger/functional/ReleasableReferencesComponentsTest.java
+++ /dev/null
@@ -1,381 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional;
-
-import static com.google.common.truth.Truth.assertThat;
-import static dagger.functional.ReleasableReferencesComponents.Thing.thing;
-
-import com.google.auto.value.AutoAnnotation;
-import com.google.common.base.Function;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ListMultimap;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Multimaps;
-import com.google.common.testing.GcFinalization;
-import com.google.common.testing.GcFinalization.FinalizationPredicate;
-import dagger.functional.ReleasableReferencesComponents.Child;
-import dagger.functional.ReleasableReferencesComponents.ChildModule;
-import dagger.functional.ReleasableReferencesComponents.ChildRegularScope;
-import dagger.functional.ReleasableReferencesComponents.ChildReleasableScope1;
-import dagger.functional.ReleasableReferencesComponents.ChildReleasableScope2;
-import dagger.functional.ReleasableReferencesComponents.ChildReleasableScope3;
-import dagger.functional.ReleasableReferencesComponents.Metadata1;
-import dagger.functional.ReleasableReferencesComponents.Parent;
-import dagger.functional.ReleasableReferencesComponents.ParentModule;
-import dagger.functional.ReleasableReferencesComponents.ParentRegularScope;
-import dagger.functional.ReleasableReferencesComponents.ParentReleasableScope1;
-import dagger.functional.ReleasableReferencesComponents.ParentReleasableScope2;
-import dagger.functional.ReleasableReferencesComponents.Thing;
-import dagger.functional.ReleasableReferencesComponents.ThingComponent;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.lang.annotation.Annotation;
-import java.lang.ref.WeakReference;
-import java.util.Map;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class ReleasableReferencesComponentsTest {
-
-  private Parent component;
-  private ParentAsserts parentAsserts;
-  private ChildAsserts childAsserts;
-
-  @Before
-  public void setUp() {
-    component = DaggerReleasableReferencesComponents_Parent.create();
-    parentAsserts = new ParentAsserts(component);
-    childAsserts = parentAsserts.newChildAsserts();
-  }
-
-  @Test
-  public void releasableReferenceManagers() {
-    ImmutableMap<Class<? extends Annotation>, ReleasableReferenceManager> managers =
-        Maps.uniqueIndex(
-            component.managers(),
-            new Function<ReleasableReferenceManager, Class<? extends Annotation>>() {
-              @Override
-              public Class<? extends Annotation> apply(
-                  ReleasableReferenceManager releasableReferenceManager) {
-                return releasableReferenceManager.scope();
-              }
-            });
-    assertThat(managers)
-        .containsEntry(ParentReleasableScope1.class, component.parentReleasableScope1Manager());
-    assertThat(managers)
-        .containsEntry(ParentReleasableScope2.class, component.parentReleasableScope2Manager());
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope1.class, component.childReleasableScope1Manager());
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope2.class, component.childReleasableScope2Manager());
-    // Should contain a manager for ChildReleasableScope3 even though
-    // @ForReleasableReferences(Scope5.class) isn't needed.
-    assertThat(managers).containsKey(ChildReleasableScope3.class);
-  }
-
-  @Test
-  public void setOfTypedReleasableReferenceManagers() {
-    ListMultimap<Class<? extends Annotation>, Metadata1> managers =
-        Multimaps.transformValues(
-            Multimaps.index(
-                component.typedReleasableReferenceManagers1(),
-                new Function<TypedReleasableReferenceManager<?>, Class<? extends Annotation>>() {
-                  @Override
-                  public Class<? extends Annotation> apply(
-                      TypedReleasableReferenceManager<?> releasableReferenceManager) {
-                    return releasableReferenceManager.scope();
-                  }
-                }),
-            new Function<TypedReleasableReferenceManager<Metadata1>, Metadata1>() {
-              @Override
-              public Metadata1 apply(TypedReleasableReferenceManager<Metadata1> manager) {
-                return manager.metadata();
-              }
-            });
-    assertThat(managers)
-        .containsEntry(ParentReleasableScope2.class, metadata1("ParentReleasableScope2"));
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope2.class, metadata1("ChildReleasableScope2.1"));
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope3.class, metadata1("ChildReleasableScope3.1"));
-  }
-
-  @AutoAnnotation
-  static Metadata1 metadata1(String value) {
-    return new AutoAnnotation_ReleasableReferencesComponentsTest_metadata1(value);
-  }
-
-  @Test
-  public void basicScopingWorks() {
-    assertBindingCallCounts();
-    // assert again to make sure that the scoped bindings aren't called again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void releaseThenGc() {
-    assertBindingCallCounts();
-    component.parentReleasableScope1Manager().releaseStrongReferences(); // release scope 1
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ParentReleasableScope1.class); // GC
-    parentAsserts.expectedCallsForParentReleasableScope1Thing++; // expect scope 1 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void releaseThenRestoreThenGcThenRelease() {
-    assertBindingCallCounts();
-    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
-    assertBindingCallCounts(); // no change to scoped bindings
-    component.parentReleasableScope2Manager().restoreStrongReferences(); // restore scope 2
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
-    assertBindingCallCounts(); // no change to scoped bindings
-
-    // Releasing again and GCing again means the binding is executed again.
-    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ParentReleasableScope2.class); // GC
-    parentAsserts.expectedCallsForParentReleasableScope2Thing++; // expect scope 2 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void subcomponentReleaseThenGc() {
-    assertBindingCallCounts();
-    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
-    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void subcomponentReleaseThenRestoreThenGcThenRelease() {
-    assertBindingCallCounts();
-    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
-    assertBindingCallCounts(); // no change to scoped bindings
-    component.childReleasableScope2Manager().restoreStrongReferences(); // restore scope 4
-    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
-    assertBindingCallCounts(); // no change to scoped bindings
-    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ChildReleasableScope2.class); // GC
-    childAsserts.expectedCallsForChildReleasableScope2Thing++; // expect scope 4 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void twoInstancesOfSameSubcomponent() {
-    // Two instances of the same subcomponent.
-    ChildAsserts child2Asserts = parentAsserts.newChildAsserts();
-    childAsserts.assertBindingCallCounts();
-    child2Asserts.assertBindingCallCounts();
-
-    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
-    childAsserts.assertBindingCallCounts(); // no change to scoped bindings in child 1
-    child2Asserts.assertBindingCallCounts(); // no change to scoped bindings in child 2
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
-    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
-    childAsserts.assertBindingCallCounts(); // when calling child.things()
-    child2Asserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings yet again
-    child2Asserts.assertBindingCallCounts(); // when calling child2.things()
-  }
-
-  private void assertBindingCallCounts() {
-    parentAsserts.assertBindingCallCounts();
-    childAsserts.assertBindingCallCounts();
-  }
-
-  /**
-   * Tries to run garbage collection, and waits for the {@link WeakReference}s to the {@link Thing}s
-   * in the maps last returned by {@link Parent#things()} and {@link Child#things()} for {@code
-   * keys} to be cleared.
-   */
-  void gcAndWaitUntilWeakReferencesCleared(final Class<?>... keys) {
-    GcFinalization.awaitDone(
-        new FinalizationPredicate() {
-          @Override
-          public boolean isDone() {
-            for (Class<?> key : keys) {
-              if (parentAsserts.weakThingReferenceUncollected(key)
-                  || childAsserts.weakThingReferenceUncollected(key)) {
-                return false;
-              }
-            }
-            return true;
-          }
-        });
-  }
-
-  /**
-   * Asserts that the map of {@link Thing}s in a {@link ThingComponent} matches expected values. Can
-   * also tell when certain values in the map have been finalized.
-   */
-  private abstract static class ThingAsserts {
-
-    private final ThingComponent component;
-    private ImmutableMap<Class<?>, WeakReference<Thing>> weakThings = ImmutableMap.of();
-
-    protected ThingAsserts(ThingComponent component) {
-      this.component = component;
-    }
-
-    /**
-     * Asserts that {@code component.things()} returns an expected map. Each time this is called,
-     * the current values in the map are wrapped in {@link WeakReference}s so we can {@linkplain
-     * #weakThingReferenceUncollected(Object) check whether they've been cleared} later.
-     */
-    final void assertBindingCallCounts() {
-      Map<Class<?>, Thing> things = component.things();
-      assertThat(things).containsExactlyEntriesIn(expectedThingMap());
-      weakThings =
-          ImmutableMap.copyOf(
-              Maps.transformValues(
-                  things,
-                  new Function<Thing, WeakReference<Thing>>() {
-                    @Override
-                    public WeakReference<Thing> apply(Thing thing) {
-                      return new WeakReference<>(thing);
-                    }
-                  }));
-    }
-
-    /** Returns the expected map. */
-    protected abstract ImmutableMap<Class<?>, Thing> expectedThingMap();
-
-    /**
-     * Returns {@code true} if the {@link WeakReference} to the {@link Thing} in the map returned by
-     * the last call to {@link #assertBindingCallCounts()} for the given key has not been cleared.
-     */
-    boolean weakThingReferenceUncollected(Object key) {
-      WeakReference<Thing> weakThing = weakThings.get(key);
-      return weakThing != null && weakThing.get() != null;
-    }
-  }
-
-  /** Asserts for the {@link Thing}s returned by {@link Parent#things()}. */
-  private static final class ParentAsserts extends ThingAsserts {
-    final Parent parent;
-
-    /**
-     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ParentModule.class)
-     * Thing} provider to have been called.
-     */
-    int expectedCallsForParentUnscopedThing;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ParentRegularScope.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForParentRegularScopeThing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope1.class) Thing} provider to have
-     * been called.
-     */
-    int expectedCallsForParentReleasableScope1Thing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope2.class) Thing} provider to have
-     * been called.
-     */
-    int expectedCallsForParentReleasableScope2Thing = 1;
-
-    ParentAsserts(Parent parent) {
-      super(parent);
-      this.parent = parent;
-    }
-
-    /**
-     * Returns an object that can make assertions for the {@link Thing}s returned by {@link
-     * Child#things()}.
-     */
-    ChildAsserts newChildAsserts() {
-      return new ChildAsserts(this, parent.child());
-    }
-
-    @Override
-    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
-      ++expectedCallsForParentUnscopedThing; // unscoped Thing @Provides method is always called
-      return ImmutableMap.of(
-          ParentModule.class, thing(expectedCallsForParentUnscopedThing),
-          ParentRegularScope.class, thing(expectedCallsForParentRegularScopeThing),
-          ParentReleasableScope1.class, thing(expectedCallsForParentReleasableScope1Thing),
-          ParentReleasableScope2.class, thing(expectedCallsForParentReleasableScope2Thing));
-    }
-  }
-
-  /** Asserts for the {@link Thing}s returned by {@link Child#things()}. */
-  private static final class ChildAsserts extends ThingAsserts {
-    final ParentAsserts parentAsserts;
-
-    /**
-     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ChildModule.class)
-     * Thing} provider to have been called.
-     */
-    int expectedCallsForChildUnscopedThing;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ChildRegularScope.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForChildRegularScopeThing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope1.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForChildReleasableScope1Thing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope2.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForChildReleasableScope2Thing = 1;
-
-    ChildAsserts(ParentAsserts parentAsserts, Child child) {
-      super(child);
-      this.parentAsserts = parentAsserts;
-    }
-
-    @Override
-    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
-      ++expectedCallsForChildUnscopedThing; // unscoped Thing @Provides method is always called
-      return new ImmutableMap.Builder<Class<?>, Thing>()
-          .putAll(parentAsserts.expectedThingMap())
-          .put(ChildModule.class, thing(expectedCallsForChildUnscopedThing))
-          .put(ChildRegularScope.class, thing(expectedCallsForChildRegularScopeThing))
-          .put(ChildReleasableScope1.class, thing(expectedCallsForChildReleasableScope1Thing))
-          .put(ChildReleasableScope2.class, thing(expectedCallsForChildReleasableScope2Thing))
-          .build();
-    }
-  }
-}
diff --git a/javatests/dagger/functional/aot/DependsOnMissingArrayKey.java b/javatests/dagger/functional/aot/DependsOnMissingArrayKey.java
new file mode 100644
index 000000000..20a89d4f3
--- /dev/null
+++ b/javatests/dagger/functional/aot/DependsOnMissingArrayKey.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+
+/**
+ * Regression test for an ahead-of-time subcomponents bug where generating the name for a missing
+ * binding method for a key of an array type threw an exception.
+ */
+final class DependsOnMissingArrayKey {
+  @Module
+  abstract static class ModuleArrayDependencies {
+    @Provides
+    static int dependsOnMissingArrayType(int[] primitive, Object[] object, String[][] doubleArray) {
+      return 0;
+    }
+  }
+
+  @Subcomponent(modules = ModuleArrayDependencies.class)
+  interface HasMissingArrayBindings {
+    int dependsOnMissingArrayType();
+  }
+}
diff --git a/javatests/dagger/functional/aot/MissingBindingReplacedWithGeneratedInstance.java b/javatests/dagger/functional/aot/MissingBindingReplacedWithGeneratedInstance.java
new file mode 100644
index 000000000..1813ad2ae
--- /dev/null
+++ b/javatests/dagger/functional/aot/MissingBindingReplacedWithGeneratedInstance.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot;
+
+import dagger.Subcomponent;
+import javax.inject.Inject;
+
+/**
+ * This class demonstrates a regression where a missing binding method was generated in a leaf
+ * component and then satisfied in an ancestor with a generated instance binding. If the ancestor's
+ * generated instance method had the same name as the formerly-missing binding method, Dagger would
+ * generate code without a proper {@code DaggerOuter.this} reference:
+ *
+ * <pre>{@code
+ * public class DaggerAncestor implements Ancestor {
+ *   protected abstract Ancestor getAncestor();
+ *
+ *   protected abstract class LeafImpl extends DaggerLeaf {
+ *     {@literal @Override}
+ *     protected final Ancestor getAncestor() {
+ *       return getAncestor();
+ *       //     ^ should be DaggerAncestor.this.getAncestor()
+ *     }
+ *   }
+ * }
+ * }</pre>
+ */
+final class MissingBindingReplacedWithGeneratedInstance {
+  @Subcomponent
+  interface Leaf {
+    DependsOnGeneratedInstance dependsOnGeneratedInstance();
+  }
+
+  static class DependsOnGeneratedInstance {
+    @Inject DependsOnGeneratedInstance(Ancestor generatedInstance) {}
+  }
+
+  @Subcomponent
+  interface Ancestor {
+    Leaf child();
+  }
+}
diff --git a/javatests/dagger/functional/aot/ModifiedFrameworkInstancesTest.java b/javatests/dagger/functional/aot/ModifiedFrameworkInstancesTest.java
new file mode 100644
index 000000000..7084f83af
--- /dev/null
+++ b/javatests/dagger/functional/aot/ModifiedFrameworkInstancesTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.IntoSet;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ModifiedFrameworkInstancesTest {
+  static class DependsOnModifiableBinding {
+    @Inject
+    DependsOnModifiableBinding(Set<Integer> modifiableDependency) {}
+  }
+
+  @Module
+  interface ChildModule {
+    @Provides
+    @IntoSet
+    static int contribution() {
+      return 1;
+    }
+  }
+
+  @Subcomponent(modules = ChildModule.class)
+  interface Child {
+    Provider<DependsOnModifiableBinding> frameworkInstanceWithModifiedDependency();
+  }
+
+  @Module
+  interface ParentModule {
+    @Provides
+    @IntoSet
+    static int contribution() {
+      return 2;
+    }
+  }
+
+  @Component(modules = ParentModule.class)
+  interface Parent {
+    Child child();
+  }
+
+  @Test
+  public void dependsOnModifiedFrameworkInstance() {
+    DaggerModifiedFrameworkInstancesTest_Parent.create()
+        .child()
+        .frameworkInstanceWithModifiedDependency()
+        // Ensure that modified framework instances that are dependencies to other framework 
+        // instances from superclass implementations are initialized correctly. This fixes a
+        // regression where a null instance would be passed to the superclass initialization, and
+        // then a NullPointerException would be thrown when the factory attempted to satisfy the
+        // dependency in get(). If get() succeeds, this test should pass.
+        .get();
+  }
+}
diff --git a/javatests/dagger/functional/aot/PrunedBindingDependedOnInSuperInitializationTest.java b/javatests/dagger/functional/aot/PrunedBindingDependedOnInSuperInitializationTest.java
new file mode 100644
index 000000000..853e22b07
--- /dev/null
+++ b/javatests/dagger/functional/aot/PrunedBindingDependedOnInSuperInitializationTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class PrunedBindingDependedOnInSuperInitializationTest {
+  interface PrunedDependency {}
+
+  static class WillHavePrunedDependency {
+    @Inject WillHavePrunedDependency(PrunedDependency pruned) {}
+  }
+
+  @Subcomponent
+  interface Child {
+    Provider<WillHavePrunedDependency> frameworkInstance();
+  }
+
+  @Module
+  static class ParentModule {
+    @Provides
+    static WillHavePrunedDependency pruneDependency() {
+      return new WillHavePrunedDependency(new PrunedDependency() {});
+    }
+  }
+
+  @Component(modules = ParentModule.class)
+  interface Parent {
+    Child child();
+  }
+
+  @Test
+  public void prunedFrameworkInstanceBindingUsedInInitializationDoesntThrow() {
+    Parent parent = DaggerPrunedBindingDependedOnInSuperInitializationTest_Parent.create();
+    // This test ensures that pruned bindings that are used during unpruned initialization
+    // statements do not throw exceptions. If the subcomponent initialization succeeds, the test
+    // should pass
+    parent.child();
+  }
+}
diff --git a/javatests/dagger/functional/aot/ScopedBindsWithMissingDependency.java b/javatests/dagger/functional/aot/ScopedBindsWithMissingDependency.java
new file mode 100644
index 000000000..2723ac0d0
--- /dev/null
+++ b/javatests/dagger/functional/aot/ScopedBindsWithMissingDependency.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.Reusable;
+import dagger.Subcomponent;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.inject.Scope;
+
+/**
+ * A regression test for ahead-of-time subcomponents mode where a scoped {@link Binds} method whose
+ * dependency was missing in a partial subcomponent implementation threw an exception in the
+ * processor.
+ */
+final class ScopedBindsWithMissingDependency {
+
+  @Retention(RetentionPolicy.RUNTIME)
+  @Scope
+  @interface CustomScope {}
+
+  @Module
+  interface ScopedBindsWithMissingDependencyModule {
+    @Binds
+    @CustomScope
+    Object bindsCustomScopeToMissingDep(String missingDependency);
+
+    @Binds
+    @Reusable
+    CharSequence bindsReusableScopeToMissingDep(String missingDependency);
+  }
+
+  @CustomScope
+  @Subcomponent(modules = ScopedBindsWithMissingDependencyModule.class)
+  interface HasScopedBindsWithMissingDependency {
+    Object customScopedBindsWithMissingDependency();
+    CharSequence reusableScopedBindsWithMissingDependency();
+  }
+}
diff --git a/java/dagger/android/FragmentKey.java b/javatests/dagger/functional/aot/SubcomponentWithInaccessibleMissingBindingMethod.java
similarity index 54%
rename from java/dagger/android/FragmentKey.java
rename to javatests/dagger/functional/aot/SubcomponentWithInaccessibleMissingBindingMethod.java
index 3372a0645..689689cea 100644
--- a/java/dagger/android/FragmentKey.java
+++ b/javatests/dagger/functional/aot/SubcomponentWithInaccessibleMissingBindingMethod.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Dagger Authors.
+ * Copyright (C) 2018 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,21 +14,14 @@
  * limitations under the License.
  */
 
-package dagger.android;
+package dagger.functional.aot;
 
-import static java.lang.annotation.ElementType.METHOD;
+import dagger.Subcomponent;
+import dagger.functional.aot.sub.PublicTypeWithPackagePrivateMissingDep;
+import javax.inject.Provider;
 
-import android.app.Fragment;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-public @interface FragmentKey {
-  Class<? extends Fragment> value();
+@Subcomponent
+interface SubcomponentWithInaccessibleMissingBindingMethod {
+  PublicTypeWithPackagePrivateMissingDep instance();
+  Provider<PublicTypeWithPackagePrivateMissingDep> frameworkInstance();
 }
diff --git a/javatests/dagger/functional/aot/SubcomponentWithModifiedInaccessibleDependency.java b/javatests/dagger/functional/aot/SubcomponentWithModifiedInaccessibleDependency.java
new file mode 100644
index 000000000..06cebb9b3
--- /dev/null
+++ b/javatests/dagger/functional/aot/SubcomponentWithModifiedInaccessibleDependency.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot;
+
+import dagger.Subcomponent;
+import dagger.functional.aot.sub.BindsPackagePrivateModule;
+import dagger.functional.aot.sub.SubcomponentWithInaccessibleOptionalBindingMethod;
+
+/**
+ * See {@link dagger.functional.aot.sub.SubcomponentWithInaccessibleOptionalBindingMethod}. This
+ * subcomponent will induce a modified binding method for its single child for the key {@code
+ * Optional<dagger.functional.aot.sub.PackagePrivate>}. When it tries to reimplement it, it must use
+ * the publicly accessible type.
+ */
+@Subcomponent(modules = BindsPackagePrivateModule.class)
+interface SubcomponentWithModifiedInaccessibleDependency {
+  SubcomponentWithInaccessibleOptionalBindingMethod child();
+}
diff --git a/javatests/dagger/functional/aot/sub/BindsPackagePrivateModule.java b/javatests/dagger/functional/aot/sub/BindsPackagePrivateModule.java
new file mode 100644
index 000000000..2eee3c996
--- /dev/null
+++ b/javatests/dagger/functional/aot/sub/BindsPackagePrivateModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot.sub;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+public final class BindsPackagePrivateModule {
+  @Provides
+  static PackagePrivate packagePrivate() {
+    return new PackagePrivate();
+  }
+}
diff --git a/javatests/dagger/android/functional/InScope.java b/javatests/dagger/functional/aot/sub/PackagePrivate.java
similarity index 71%
rename from javatests/dagger/android/functional/InScope.java
rename to javatests/dagger/functional/aot/sub/PackagePrivate.java
index 295ee069c..c629f6e32 100644
--- a/javatests/dagger/android/functional/InScope.java
+++ b/javatests/dagger/functional/aot/sub/PackagePrivate.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Dagger Authors.
+ * Copyright (C) 2018 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,12 +14,6 @@
  * limitations under the License.
  */
 
-package dagger.android.functional;
+package dagger.functional.aot.sub;
 
-import java.lang.annotation.Annotation;
-import javax.inject.Qualifier;
-
-@Qualifier
-@interface InScope {
-  Class<? extends Annotation> value();
-}
+final class PackagePrivate {}
diff --git a/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateMissingDep.java b/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateMissingDep.java
new file mode 100644
index 000000000..b5ced6f61
--- /dev/null
+++ b/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateMissingDep.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot.sub;
+
+import javax.inject.Inject;
+
+public class PublicTypeWithPackagePrivateMissingDep {
+  @Inject
+  PublicTypeWithPackagePrivateMissingDep(PackagePrivate packagePrivate) {}
+}
diff --git a/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateOptionalDep.java b/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateOptionalDep.java
new file mode 100644
index 000000000..1d697233e
--- /dev/null
+++ b/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateOptionalDep.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot.sub;
+
+import java.util.Optional;
+import javax.inject.Inject;
+
+public class PublicTypeWithPackagePrivateOptionalDep {
+  @Inject
+  PublicTypeWithPackagePrivateOptionalDep(Optional<PackagePrivate> packagePrivateOptional) {}
+}
diff --git a/javatests/dagger/functional/aot/sub/SubcomponentWithInaccessibleOptionalBindingMethod.java b/javatests/dagger/functional/aot/sub/SubcomponentWithInaccessibleOptionalBindingMethod.java
new file mode 100644
index 000000000..d908b1c28
--- /dev/null
+++ b/javatests/dagger/functional/aot/sub/SubcomponentWithInaccessibleOptionalBindingMethod.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot.sub;
+
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.functional.aot.sub.SubcomponentWithInaccessibleOptionalBindingMethod.ExposesModifiablePackagePrivateBindingModule;
+import javax.inject.Provider;
+
+/**
+ * This component will generate a modifiable binding method for the key {@code
+ * Optional<PackagePrivate>} as a dependency of {@link PublicTypeWithPackagePrivateOptionalDep}.
+ * Even though this subcomponent implementation can refer to the parameterized type, a subclass
+ * implementation in another package will not be able to, and thus the return type must be reduced
+ * to the publicly accessible type. This is exhibited in {@link
+ * dagger.functional.aot.SubcomponentWithModifiedInaccessibleDependency}.
+ */
+@Subcomponent(modules = ExposesModifiablePackagePrivateBindingModule.class)
+public interface SubcomponentWithInaccessibleOptionalBindingMethod {
+  PublicTypeWithPackagePrivateOptionalDep instance();
+  Provider<PublicTypeWithPackagePrivateOptionalDep> frameworkInstance();
+
+  @Module
+  interface ExposesModifiablePackagePrivateBindingModule {
+    @BindsOptionalOf
+    PackagePrivate optional();
+  }
+}
diff --git a/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java b/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java
index 05162c2b2..f6c2818f4 100644
--- a/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java
+++ b/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java
@@ -157,6 +157,7 @@ public void testFailingReentrant() {
   }
 
   @Test(timeout = 5000)
+
   public void testGetFromMultipleThreads() throws Exception {
     AtomicInteger callCount = new AtomicInteger(0);
     AtomicInteger requestCount = new AtomicInteger(0);
diff --git a/javatests/dagger/functional/cycle/LongCycleTest.java b/javatests/dagger/functional/cycle/LongCycleTest.java
index 02250541a..fa62a7dac 100644
--- a/javatests/dagger/functional/cycle/LongCycleTest.java
+++ b/javatests/dagger/functional/cycle/LongCycleTest.java
@@ -43,10 +43,7 @@ public void longCycle() {
    */
   @Test
   public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
-    assume().that(System.getProperty("dagger.mode")).isNotEqualTo("FastInit");
-    assume()
-        .that(System.getProperty("dagger.mode"))
-        .isNotEqualTo("FastInitAndAheadOfTimeSubcomponents");
+    assume().that(System.getProperty("dagger.mode")).doesNotContain("FastInit");
     DaggerLongCycle_LongCycleComponent.class
         .getDeclaredMethod("initialize2", DaggerLongCycle_LongCycleComponent.Builder.class);
   }
diff --git a/javatests/dagger/functional/producers/ProducerFactoryTest.java b/javatests/dagger/functional/producers/ProducerFactoryTest.java
index 1134ffed4..b3980704c 100644
--- a/javatests/dagger/functional/producers/ProducerFactoryTest.java
+++ b/javatests/dagger/functional/producers/ProducerFactoryTest.java
@@ -26,6 +26,8 @@
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Producer;
+import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.CancellableProducer;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
@@ -74,7 +76,7 @@ public ProductionComponentMonitor get() {
   public void noArgMethod() throws Exception {
     ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
     Producer<String> producer =
-        new SimpleProducerModule_StrFactory(executorProvider, componentMonitorProvider);
+        SimpleProducerModule_StrFactory.create(executorProvider, componentMonitorProvider);
     assertThat(producer.get().get()).isEqualTo("str");
     InOrder order = inOrder(componentMonitor, monitor);
     order.verify(componentMonitor).producerMonitorFor(token);
@@ -87,9 +89,9 @@ public void noArgMethod() throws Exception {
   @Test
   public void singleArgMethod() throws Exception {
     SettableFuture<Integer> intFuture = SettableFuture.create();
-    Producer<Integer> intProducer = producerOfFuture(intFuture);
+    CancellableProducer<Integer> intProducer = producerOfFuture(intFuture);
     Producer<String> producer =
-        new SimpleProducerModule_StrWithArgFactory(
+        SimpleProducerModule_StrWithArgFactory.create(
             executorProvider, componentMonitorProvider, intProducer);
     assertThat(producer.get().isDone()).isFalse();
     intFuture.set(42);
@@ -103,9 +105,10 @@ public void successMonitor() throws Exception {
     SettableFuture<String> strFuture = SettableFuture.create();
     @SuppressWarnings("FutureReturnValueIgnored")
     SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
-    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    CancellableProducer<SettableFuture<String>> strFutureProducer =
+        producerOfFuture(strFutureFuture);
     Producer<String> producer =
-        new SimpleProducerModule_SettableFutureStrFactory(
+        SimpleProducerModule_SettableFutureStrFactory.create(
             executorProvider, componentMonitorProvider, strFutureProducer);
     assertThat(producer.get().isDone()).isFalse();
 
@@ -131,9 +134,10 @@ public void failureMonitor() throws Exception {
     SettableFuture<String> strFuture = SettableFuture.create();
     @SuppressWarnings("FutureReturnValueIgnored")
     SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
-    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    CancellableProducer<SettableFuture<String>> strFutureProducer =
+        producerOfFuture(strFutureFuture);
     Producer<String> producer =
-        new SimpleProducerModule_SettableFutureStrFactory(
+        SimpleProducerModule_SettableFutureStrFactory.create(
             executorProvider, componentMonitorProvider, strFutureProducer);
     assertThat(producer.get().isDone()).isFalse();
 
@@ -163,7 +167,7 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
     ProducerToken token = ProducerToken.create(SimpleProducerModule_ThrowingProducerFactory.class);
 
     Producer<String> producer =
-        new SimpleProducerModule_ThrowingProducerFactory(
+        SimpleProducerModule_ThrowingProducerFactory.create(
             executorProvider, componentMonitorProvider);
     assertThat(producer.get().isDone()).isTrue();
 
@@ -185,13 +189,13 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
 
   @Test(expected = NullPointerException.class)
   public void nullComponentMonitorProvider() throws Exception {
-    new SimpleProducerModule_StrFactory(executorProvider, null);
+    SimpleProducerModule_StrFactory.create(executorProvider, null);
   }
 
-  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
-    return new Producer<T>() {
+  private static <T> CancellableProducer<T> producerOfFuture(final ListenableFuture<T> future) {
+    return new AbstractProducer<T>() {
       @Override
-      public ListenableFuture<T> get() {
+      public ListenableFuture<T> compute() {
         return future;
       }
     };
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationComponent.java b/javatests/dagger/functional/producers/cancellation/CancellationComponent.java
new file mode 100644
index 000000000..f06829e0f
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationComponent.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.BindsInstance;
+import dagger.functional.producers.cancellation.CancellationComponent.Dependency;
+import dagger.producers.Producer;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import java.util.concurrent.Executor;
+import javax.inject.Named;
+
+@ProductionComponent(modules = CancellationModule.class, dependencies = Dependency.class)
+interface CancellationComponent {
+
+  @Named("ep1")
+  ListenableFuture<String> entryPoint1();
+
+  @Named("ep2")
+  Producer<String> entryPoint2();
+
+  @Named("ep3")
+  ListenableFuture<String> entryPoint3();
+
+  CancellationSubcomponent.Builder subcomponentBuilder();
+
+  @ProductionComponent.Builder
+  interface Builder {
+    Builder module(CancellationModule module);
+
+    Builder dependency(Dependency dependency);
+
+    @BindsInstance
+    Builder executor(@Production Executor executor);
+
+    CancellationComponent build();
+  }
+
+  final class Dependency {
+
+    final ProducerTester tester;
+
+    Dependency(ProducerTester tester) {
+      this.tester = checkNotNull(tester);
+    }
+
+    @SuppressWarnings("unused") // Dagger uses it
+    ListenableFuture<String> getDependencyFuture() {
+      return tester.start("dependencyFuture");
+    }
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationModule.java b/javatests/dagger/functional/producers/cancellation/CancellationModule.java
new file mode 100644
index 000000000..ff7ee791f
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationModule.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Provides;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Named;
+
+@SuppressWarnings("unused") // not actually using dependencies
+@ProducerModule(subcomponents = CancellationSubcomponent.class)
+final class CancellationModule {
+
+  private final ProducerTester tester;
+
+  CancellationModule(ProducerTester tester) {
+    this.tester = checkNotNull(tester);
+  }
+
+  @Produces
+  @Named("leaf1")
+  ListenableFuture<String> produceLeaf1() {
+    return tester.start("leaf1");
+  }
+
+  @Produces
+  @Named("leaf2")
+  ListenableFuture<String> produceLeaf2() {
+    return tester.start("leaf2");
+  }
+
+  @Produces
+  @Named("leaf3")
+  ListenableFuture<String> produceLeaf3() {
+    return tester.start("leaf3");
+  }
+
+  @Produces
+  @Named("foo")
+  ListenableFuture<String> produceFoo(@Named("leaf1") String leaf1, @Named("leaf2") String leaf2) {
+    return tester.start("foo");
+  }
+
+  @Produces
+  @Named("bar")
+  ListenableFuture<String> produceBar(@Named("leaf2") String leaf2, @Named("leaf3") String leaf3) {
+    return tester.start("bar");
+  }
+
+  @Produces
+  @Named("baz")
+  ListenableFuture<String> produceBaz(
+      @Named("foo") Producer<String> foo, @Named("bar") String bar) {
+    ListenableFuture<String> fooFuture = foo.get();
+    if (!fooFuture.isDone()) {
+      assertThat(fooFuture.cancel(true)).isTrue();
+      assertThat(fooFuture.isCancelled()).isTrue();
+    }
+    return tester.start("baz");
+  }
+
+  @Provides
+  @Named("providesDep")
+  static String provideProvidesDep() {
+    return "providesDep";
+  }
+
+  @Produces
+  @Named("qux")
+  ListenableFuture<String> produceQux(
+      @Named("baz") String baz, @Named("providesDep") String providesDep) {
+    return tester.start("qux");
+  }
+
+  @Produces
+  @Named("ep1")
+  ListenableFuture<String> produceEntryPoint1(@Named("qux") String qux) {
+    return tester.start("entryPoint1");
+  }
+
+  @Produces
+  @Named("ep2")
+  ListenableFuture<String> produceEntryPoint2(@Named("bar") String bar, String dependency) {
+    return tester.start("entryPoint2");
+  }
+
+  @Produces
+  @Named("ep3")
+  static ListenableFuture<String> produceEntryPoint3(Producer<String> dependencyProducer) {
+    ListenableFuture<String> dependencyFuture = dependencyProducer.get();
+    assertThat(dependencyFuture.isDone()).isFalse();
+    assertThat(dependencyFuture.cancel(true)).isTrue();
+    assertThat(dependencyFuture.isCancelled()).isTrue();
+    return dependencyFuture;
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationPolicyTest.java b/javatests/dagger/functional/producers/cancellation/CancellationPolicyTest.java
new file mode 100644
index 000000000..936072a48
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationPolicyTest.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.BindsInstance;
+import dagger.producers.CancellationPolicy;
+import dagger.producers.CancellationPolicy.Propagation;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.concurrent.Executor;
+import javax.inject.Named;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests for parent production components with a {@code CancellationPolicy} that allows subcomponent
+ * cancellation to propagate to them
+ */
+@RunWith(JUnit4.class)
+public final class CancellationPolicyTest {
+
+  @ProducerModule(subcomponents = Child.class)
+  static class ParentModule {
+    private final ProducerTester tester;
+
+    ParentModule(ProducerTester tester) {
+      this.tester = tester;
+    }
+
+    @Produces
+    @Named("a")
+    ListenableFuture<String> produceA() {
+      return tester.start("a");
+    }
+  }
+
+  interface Parent {
+    @Named("a")
+    ListenableFuture<String> a();
+
+    Child.Builder childBuilder();
+
+    interface Builder<P extends Parent, B extends Builder<P, B>> {
+      B module(ParentModule module);
+
+      @BindsInstance
+      B executor(@Production Executor executor);
+
+      P build();
+    }
+  }
+
+  @CancellationPolicy(fromSubcomponents = Propagation.PROPAGATE)
+  @ProductionComponent(modules = ParentModule.class)
+  interface PropagatingParent extends Parent {
+    @ProductionComponent.Builder
+    interface Builder extends Parent.Builder<PropagatingParent, Builder> {}
+  }
+
+  @CancellationPolicy(fromSubcomponents = Propagation.IGNORE)
+  @ProductionComponent(modules = ParentModule.class)
+  interface NonPropagatingParent extends Parent {
+    @ProductionComponent.Builder
+    interface Builder extends Parent.Builder<NonPropagatingParent, Builder> {}
+  }
+
+  @ProducerModule
+  static class ChildModule {
+    private final ProducerTester tester;
+
+    ChildModule(ProducerTester tester) {
+      this.tester = tester;
+    }
+
+    @Produces
+    @Named("b")
+    ListenableFuture<String> b(@Named("a") String a) {
+      return tester.start("b");
+    }
+  }
+
+  @ProductionSubcomponent(modules = ChildModule.class)
+  interface Child {
+    @Named("b")
+    ListenableFuture<String> b();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Builder module(ChildModule module);
+
+      Child build();
+    }
+  }
+
+  private final ProducerTester tester = new ProducerTester();
+
+  @Test
+  public void propagatingParent_childCancellationPropagatesToParent() {
+    PropagatingParent parent =
+        DaggerCancellationPolicyTest_PropagatingParent.builder()
+            .module(new ParentModule(tester))
+            .executor(MoreExecutors.directExecutor())
+            .build();
+    ListenableFuture<String> a = parent.a();
+
+    Child child = parent.childBuilder().module(new ChildModule(tester)).build();
+
+    ListenableFuture<String> b = child.b();
+
+    tester.assertStarted("a").only();
+
+    assertThat(a.isDone()).isFalse();
+    assertThat(b.isDone()).isFalse();
+
+    assertThat(b.cancel(true)).isTrue();
+    assertThat(b.isCancelled()).isTrue();
+
+    tester.assertCancelled("a");
+
+    assertThat(a.isCancelled()).isTrue();
+  }
+
+  @Test
+  public void nonPropagatingParent_childCancellationDoesNotPropagateToParent() throws Exception {
+    // This test is basically just checking that when the parent has fromSubcomponents = IGNORE, it
+    // behaves the same as having no @CancellationPolicy at all (as tested in
+    // ProducerSubcomponentCancellationTester)
+    NonPropagatingParent parent =
+        DaggerCancellationPolicyTest_NonPropagatingParent.builder()
+            .module(new ParentModule(tester))
+            .executor(MoreExecutors.directExecutor())
+            .build();
+    ListenableFuture<String> a = parent.a();
+
+    Child child = parent.childBuilder().module(new ChildModule(tester)).build();
+
+    ListenableFuture<String> b = child.b();
+
+    tester.assertStarted("a").only();
+
+    assertThat(a.isDone()).isFalse();
+    assertThat(b.isDone()).isFalse();
+
+    assertThat(b.cancel(true)).isTrue();
+    assertThat(b.isCancelled()).isTrue();
+
+    tester.assertNotCancelled("a");
+
+    assertThat(a.isDone()).isFalse();
+
+    tester.complete("a");
+    assertThat(a.isDone()).isTrue();
+    assertThat(a.get(1, MILLISECONDS)).isEqualTo("completed");
+
+    tester.assertNotStarted("b");
+  }
+}
diff --git a/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponent.java
similarity index 51%
rename from java/dagger/internal/codegen/ProducerInstanceBindingExpression.java
rename to javatests/dagger/functional/producers/cancellation/CancellationSubcomponent.java
index 3edc2b6db..63b1a9d68 100644
--- a/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java
+++ b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponent.java
@@ -14,25 +14,22 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.functional.producers.cancellation;
 
-/** Binding expression for producer instances. */
-final class ProducerInstanceBindingExpression extends FrameworkInstanceBindingExpression {
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionSubcomponent;
+import javax.inject.Named;
 
-  ProducerInstanceBindingExpression(
-      ResolvedBindings resolvedBindings,
-      FrameworkInstanceSupplier frameworkInstanceSupplier,
-      DaggerTypes types,
-      DaggerElements elements) {
-    super(
-        resolvedBindings,
-        frameworkInstanceSupplier,
-        types,
-        elements);
-  }
+@ProductionSubcomponent(modules = CancellationSubcomponentModule.class)
+interface CancellationSubcomponent {
+
+  @Named("subEntryPoint")
+  ListenableFuture<String> subcomponentEntryPoint();
+
+  @ProductionSubcomponent.Builder
+  interface Builder {
+    Builder module(CancellationSubcomponentModule module);
 
-  @Override
-  protected FrameworkType frameworkType() {
-    return FrameworkType.PRODUCER;
+    CancellationSubcomponent build();
   }
 }
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationSubcomponentModule.java b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponentModule.java
new file mode 100644
index 000000000..9cedad462
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponentModule.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Named;
+
+@SuppressWarnings("unused") // not actually using dependencies
+@ProducerModule
+final class CancellationSubcomponentModule {
+
+  private final ProducerTester tester;
+
+  CancellationSubcomponentModule(ProducerTester tester) {
+    this.tester = checkNotNull(tester);
+  }
+
+  @Produces
+  @Named("subLeaf")
+  ListenableFuture<String> produceSubLeaf() {
+    return tester.start("subLeaf");
+  }
+
+  @Produces
+  @Named("subTask1")
+  ListenableFuture<String> produceSubTask1(
+      @Named("subLeaf") String subLeaf, @Named("qux") String qux) {
+    return tester.start("subTask1");
+  }
+
+  @Produces
+  @Named("subTask2")
+  ListenableFuture<String> produceSubTask2(@Named("foo") String foo, Producer<String> dependency) {
+    ListenableFuture<String> dependencyFuture = dependency.get();
+    assertThat(dependencyFuture.cancel(true)).isTrue();
+    assertThat(dependencyFuture.isCancelled()).isTrue();
+    return tester.start("subTask2");
+  }
+
+  @Produces
+  @Named("subEntryPoint")
+  ListenableFuture<String> produceSubEntryPoint(
+      @Named("subTask1") String subTask1, @Named("subTask2") String subTask2) {
+    return tester.start("subEntryPoint");
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/ProducerCancellationTest.java b/javatests/dagger/functional/producers/cancellation/ProducerCancellationTest.java
new file mode 100644
index 000000000..23b31d2f5
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/ProducerCancellationTest.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.functional.producers.cancellation.CancellationComponent.Dependency;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests cancellation of tasks in production components. */
+@RunWith(JUnit4.class)
+public class ProducerCancellationTest {
+
+  private final ProducerTester tester = new ProducerTester();
+  private final CancellationComponent component =
+      DaggerCancellationComponent.builder()
+          .module(new CancellationModule(tester))
+          .dependency(new Dependency(tester))
+          .executor(MoreExecutors.directExecutor())
+          .build();
+
+  @Test
+  public void initialState() {
+    tester.assertNoStartedNodes();
+  }
+
+  @Test
+  public void cancellingOneEntryPoint_cancelsAllRunningNodes() {
+    ListenableFuture<String> entryPoint1 = component.entryPoint1();
+    tester.assertStarted("leaf2", "leaf3").only();
+
+    assertThat(entryPoint1.cancel(true)).isTrue();
+    assertThat(entryPoint1.isCancelled()).isTrue();
+
+    tester.assertCancelled("leaf2", "leaf3").only();
+
+    // The other entry points were also cancelled in the process, from the user's perspective.
+    assertThat(component.entryPoint2().get().isCancelled()).isTrue();
+    assertThat(component.entryPoint3().isCancelled()).isTrue();
+
+    // The underlying tasks weren't actually started, even though we just requested them above,
+    // because the node was cancelled already along with the component.
+    tester.assertNotStarted("entryPoint2", "entryPoint3");
+  }
+
+  @SuppressWarnings({"CheckReturnValue", "FutureReturnValueIgnored"})
+  @Test
+  public void cancellingNonEntryPointProducer_doesNotCancelUnderlyingTask() {
+    ListenableFuture<String> entryPoint1 = component.entryPoint1();
+    tester.assertStarted("leaf2", "leaf3").only();
+
+    tester.complete("leaf2", "leaf3");
+
+    tester.assertStarted("bar");
+
+    // foo's dependencies are complete, but it is not yet started because baz depends on
+    // Producer<foo>, so it won't be started until baz calls get() on it.
+    // baz not started yet because it needs bar to complete first.
+    tester.assertNotStarted("foo", "baz");
+
+    // Complete bar, triggering baz to run. It calls get() on the foo Producer, so that also starts
+    // once its dependency leaf1 is complete.
+    tester.complete("bar", "leaf1");
+    tester.assertStarted("baz", "foo");
+
+    // baz then cancelled the foo Producer's future, but that didn't cancel the underlying task.
+    tester.assertNotCancelled("foo");
+
+    // If we cancel the entry point, that does cancel the task.
+    entryPoint1.cancel(true);
+    tester.assertCancelled("foo");
+  }
+
+  @SuppressWarnings({"CheckReturnValue", "FutureReturnValueIgnored"})
+  @Test
+  public void cancellingProducerFromComponentDependency_cancelsUnderlyingTask() {
+    // Start leaf2/leaf3 tasks.
+    component.entryPoint1();
+    tester.assertStarted("leaf2", "leaf3").only();
+    tester.assertNotCancelled("leaf2", "leaf3");
+
+    // Nothing's requested dependencyFuture yet.
+    tester.assertNotStarted("dependencyFuture");
+
+    // entryPoint3 injects Producer of dependency future, then cancels that future. Then also
+    // returns that future as the entry point.
+    ListenableFuture<String> entryPoint = component.entryPoint3();
+
+    tester.assertStarted("dependencyFuture");
+    tester.assertCancelled("dependencyFuture");
+
+    // Even though the entry point future returned from the component is not the dependency future
+    // itself, the cancellation should have propagated out to it and cancelled it.
+    assertThat(entryPoint.isCancelled()).isTrue();
+
+    // And that cancellation should have cancelled the other tasks running in the component.
+    tester.assertCancelled("leaf2", "leaf3");
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/ProducerSubcomponentCancellationTest.java b/javatests/dagger/functional/producers/cancellation/ProducerSubcomponentCancellationTest.java
new file mode 100644
index 000000000..246bf9ffd
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/ProducerSubcomponentCancellationTest.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.functional.producers.cancellation.CancellationComponent.Dependency;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests cancellation of tasks in production subcomponents. */
+@RunWith(JUnit4.class)
+public class ProducerSubcomponentCancellationTest {
+
+  private final ProducerTester tester = new ProducerTester();
+  private final CancellationComponent component =
+      DaggerCancellationComponent.builder()
+          .module(new CancellationModule(tester))
+          .dependency(new Dependency(tester))
+          .executor(MoreExecutors.directExecutor())
+          .build();
+  private final CancellationSubcomponent subcomponent =
+      component.subcomponentBuilder().module(new CancellationSubcomponentModule(tester)).build();
+
+  @Test
+  public void initialState() {
+    tester.assertNoStartedNodes();
+  }
+
+  @Test
+  public void cancellingSubcomponent_doesNotCancelParent() throws Exception {
+    ListenableFuture<String> subcomponentEntryPoint = subcomponent.subcomponentEntryPoint();
+
+    // Subcomponent entry point depends on all leaves from the parent component and on the single
+    // leaf in the subcomponent itself, so they should all have started.
+    tester.assertStarted("leaf1", "leaf2", "leaf3", "subLeaf").only();
+
+    assertThat(subcomponentEntryPoint.cancel(true)).isTrue();
+    assertThat(subcomponentEntryPoint.isCancelled()).isTrue();
+
+    // None of the tasks running in the parent were cancelled.
+    tester.assertNotCancelled("leaf1", "leaf2", "leaf3");
+    tester.assertCancelled("subLeaf").only();
+
+    // Finish all the parent tasks to ensure that it can still complete normally.
+    tester.complete(
+        "dependencyFuture",
+        "leaf1",
+        "leaf2",
+        "leaf3",
+        "foo",
+        "bar",
+        "baz",
+        "qux",
+        "entryPoint1",
+        "entryPoint2");
+
+    assertThat(component.entryPoint1().get(1, MILLISECONDS)).isEqualTo("completed");
+    assertThat(component.entryPoint2().get().get(1, MILLISECONDS)).isEqualTo("completed");
+  }
+
+  @Test
+  public void cancellingSubcomponent_preventsUnstartedNodesFromStarting() {
+    ListenableFuture<String> subcomponentEntryPoint = subcomponent.subcomponentEntryPoint();
+
+    tester.complete("subLeaf");
+    tester.assertNotStarted("subTask1", "subTask2");
+
+    subcomponentEntryPoint.cancel(true);
+
+    // Complete the remaining dependencies of subTask1 and subTask2.
+    tester.complete("leaf1", "leaf2", "leaf3", "foo", "bar", "baz", "qux");
+
+    // Since the subcomponent was cancelled, they are not started.
+    tester.assertNotStarted("subTask1", "subTask2");
+  }
+
+  @Test
+  public void cancellingProducerFromComponentDependency_inSubcomponent_cancelsUnderlyingTask()
+      throws Exception {
+    // Request subcomponent's entry point.
+    ListenableFuture<String> subcomponentEntryPoint = subcomponent.subcomponentEntryPoint();
+
+    // Finish all parent tasks so that the subcomponent's tasks can start.
+    tester.complete("leaf1", "leaf2", "leaf3", "foo", "bar", "baz", "qux", "subLeaf");
+
+    tester.assertStarted("subTask1", "subTask2");
+    tester.assertNotCancelled("subTask1", "subTask2");
+
+    // When subTask2 runs, it cancels the dependency future.
+    // TODO(cgdecker): Is this what we want to happen?
+    // On the one hand, there's a policy of "futures from component dependencies come from outside
+    // our control and should be cancelled unconditionally". On the other hand, the dependency is
+    // coming from the parent component, and the policy is also not to cancel things belonging to
+    // the parent unless it allows that.
+    tester.assertCancelled("dependencyFuture");
+
+    // The future it returns didn't depend directly on that future, though, so the subcomponent
+    // should be able to complete normally.
+    tester.complete("subTask1", "subTask2", "subEntryPoint");
+
+    assertThat(subcomponentEntryPoint.get(1, MILLISECONDS)).isEqualTo("completed");
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/ProducerTester.java b/javatests/dagger/functional/producers/cancellation/ProducerTester.java
new file mode 100644
index 000000000..61ddaef35
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/ProducerTester.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.AbstractFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Predicate;
+
+/**
+ * Helper for testing producers.
+ *
+ * <p>Maintains a set of nodes (futures mapped to names) representing the results of different
+ * producer nodes and allows those nodes to be "started" (when returned from a producer method),
+ * completed, and cancelled, as well as to be queried for their state. Additionally, provides
+ * assertions about the state of nodes.
+ */
+final class ProducerTester {
+
+  private final Map<String, TestFuture> futures = new HashMap<>();
+
+  /** Starts the given node. */
+  ListenableFuture<String> start(String node) {
+    return getOrCreate(node).start();
+  }
+
+  private TestFuture getOrCreate(String node) {
+    TestFuture result = futures.get(node);
+    if (result == null) {
+      result = new TestFuture(node);
+      futures.put(node, result);
+    }
+    return result;
+  }
+
+  /** Returns whether or not the given node has been started. */
+  boolean isStarted(String node) {
+    return futures.containsKey(node) && futures.get(node).isStarted();
+  }
+
+  /** Completes of the given nodes. */
+  void complete(String... nodes) {
+    for (String node : nodes) {
+      getOrCreate(node).complete();
+    }
+  }
+
+  /** Returns whether or not the given node has been cancelled. */
+  boolean isCancelled(String node) {
+    TestFuture future = futures.get(node);
+    return future != null && future.isCancelled();
+  }
+
+  /** Asserts that the given nodes have been started. */
+  Only assertStarted(String... nodes) {
+    return assertAboutNodes(STARTED, nodes);
+  }
+
+  /** Asserts that the given nodes have been cancelled. */
+  Only assertCancelled(String... nodes) {
+    return assertAboutNodes(CANCELLED, nodes);
+  }
+
+  /** Asserts that the given nodes have not been started. */
+  Only assertNotStarted(String... nodes) {
+    return assertAboutNodes(not(STARTED), nodes);
+  }
+
+  /** Asserts that the given nodes have not been cancelled. */
+  Only assertNotCancelled(String... nodes) {
+    return assertAboutNodes(not(CANCELLED), nodes);
+  }
+
+  /** Asserts that no nodes in this tester have been started. */
+  void assertNoStartedNodes() {
+    for (TestFuture future : futures.values()) {
+      assertThat(future.isStarted()).named("%s is started", future).isFalse();
+    }
+  }
+
+  private Only assertAboutNodes(Predicate<? super TestFuture> assertion, String... nodes) {
+    ImmutableSet.Builder<TestFuture> builder = ImmutableSet.builder();
+    for (String node : nodes) {
+      TestFuture future = getOrCreate(node);
+      assertThat(assertion.test(future)).named("%s is %s", future, assertion).isTrue();
+      builder.add(future);
+    }
+    return new Only(builder.build(), assertion);
+  }
+
+  /**
+   * Fluent class for making a previous assertion more strict by specifying that whatever was
+   * asserted should be true only for the specified nodes and not for any others.
+   */
+  final class Only {
+
+    private final ImmutableSet<TestFuture> expected;
+    private final Predicate<? super TestFuture> assertion;
+
+    Only(ImmutableSet<TestFuture> expected, Predicate<? super TestFuture> assertion) {
+      this.expected = checkNotNull(expected);
+      this.assertion = checkNotNull(assertion);
+    }
+
+    /**
+     * Asserts that the previous assertion was not true for any node other than those that were
+     * specified.
+     */
+    void only() {
+      for (TestFuture future : futures.values()) {
+        if (!expected.contains(future)) {
+          assertThat(assertion.test(future)).named("%s is %s", future, assertion).isFalse();
+        }
+      }
+    }
+  }
+
+  /**
+   * A simple future for testing that can be marked as having been started and which can be
+   * completed with a result.
+   */
+  private static final class TestFuture extends AbstractFuture<String> {
+
+    private final String name;
+    private volatile boolean started;
+
+    private TestFuture(String name) {
+      this.name = checkNotNull(name);
+    }
+
+    /** Marks this future as having been started and returns it. */
+    TestFuture start() {
+      this.started = true;
+      return this;
+    }
+
+    /** Returns whether or not this future's task was started. */
+    boolean isStarted() {
+      return started;
+    }
+
+    /** Completes this future's task by setting a value for it. */
+    public void complete() {
+      super.set("completed");
+    }
+
+    @Override
+    public String toString() {
+      return name;
+    }
+  }
+
+  private static final Predicate<TestFuture> STARTED =
+      new Predicate<TestFuture>() {
+        @Override
+        public boolean test(TestFuture future) {
+          return future.isStarted();
+        }
+
+        @Override
+        public String toString() {
+          return "started";
+        }
+      };
+
+  private static final Predicate<TestFuture> CANCELLED =
+      new Predicate<TestFuture>() {
+        @Override
+        public boolean test(TestFuture future) {
+          return future.isCancelled();
+        }
+
+        @Override
+        public String toString() {
+          return "cancelled";
+        }
+      };
+
+  /** Version of Predicates.not with a toString() that's nicer for our assertion error messages. */
+  private static <T> Predicate<T> not(final Predicate<T> predicate) {
+    return new Predicate<T>() {
+      @Override
+      public boolean test(T input) {
+        return !predicate.test(input);
+      }
+
+      @Override
+      public String toString() {
+        return "not " + predicate;
+      }
+    };
+  }
+}
diff --git a/javatests/dagger/functional/spi/BUILD b/javatests/dagger/functional/spi/BUILD
index b88a841f1..fffaddbe9 100644
--- a/javatests/dagger/functional/spi/BUILD
+++ b/javatests/dagger/functional/spi/BUILD
@@ -42,6 +42,7 @@ GenJavaTests(
         ["*.java"],
         exclude = ["TestPlugin.java"],
     ),
+    functional = 0,
     test_only_deps = [
         "@google_bazel_common//third_party/java/truth",
         "@google_bazel_common//third_party/java/junit",
diff --git a/javatests/dagger/functional/subcomponent/SubcomponentTest.java b/javatests/dagger/functional/subcomponent/SubcomponentTest.java
index 8e72138fc..428de643d 100644
--- a/javatests/dagger/functional/subcomponent/SubcomponentTest.java
+++ b/javatests/dagger/functional/subcomponent/SubcomponentTest.java
@@ -86,10 +86,7 @@ public void multibindingContributions() {
 
   @Test
   public void unscopedProviders() {
-    assume().that(System.getProperty("dagger.mode")).isNotEqualTo("FastInit");
-    assume()
-        .that(System.getProperty("dagger.mode"))
-        .isNotEqualTo("FastInitAndAheadOfTimeSubcomponents");
+    assume().that(System.getProperty("dagger.mode")).doesNotContain("FastInit");
     assertThat(parentGetters.getUnscopedTypeProvider())
         .isSameAs(childComponent.getUnscopedTypeProvider());
     assertThat(parentGetters.getUnscopedTypeProvider())
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 9f3df36dd..e27bfbbfc 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.AHEAD_OF_TIME_SUBCOMPONENTS_MODE;
+import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
@@ -32,6 +33,12 @@
 
 @RunWith(JUnit4.class)
 public final class AheadOfTimeSubcomponentsTest {
+  private static final String PRUNED_METHOD_BODY =
+      "throw new UnsupportedOperationException(\"This binding is not part of the final binding "
+          + "graph. The key was requested by a binding that was believed to possibly be part of "
+          + "the graph, but is no longer requested. If this exception is thrown, it is the result "
+          + "of a Dagger bug.\");";
+
   @Test
   public void missingBindings_fromComponentMethod() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
@@ -98,11 +105,11 @@ public void missingBindings_fromComponentMethod() {
             "public abstract class DaggerAncestor implements Ancestor {",
             "  protected DaggerAncestor() {}",
             "",
-            "  public abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() { super(); }",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
             "",
             "    @Override",
-            "    public MissingInLeaf missingFromComponentMethod() {",
+            "    public final MissingInLeaf missingFromComponentMethod() {",
             "      return AncestorModule_SatisfiedInAncestorFactory.proxySatisfiedInAncestor();",
             "    }",
             "  }",
@@ -199,10 +206,11 @@ public void missingBindings_dependsOnMissingBinding() {
             "",
             "  @Override",
             "  public DependsOnMissingBinding dependsOnMissingBinding() {",
-            "    return new DependsOnMissingBinding(getMissingInLeaf());",
+            "    return DependsOnMissingBinding_Factory.newDependsOnMissingBinding(",
+            "        getMissingInLeaf());",
             "  }",
             "",
-            "  public abstract MissingInLeaf getMissingInLeaf();",
+            "  protected abstract Object getMissingInLeaf();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -235,7 +243,7 @@ public void missingBindings_dependsOnMissingBinding() {
             "}"));
     JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
+            "test.DaggerAncestor",
             "package test;",
             "",
             IMPORT_GENERATED_ANNOTATION,
@@ -244,11 +252,11 @@ public void missingBindings_dependsOnMissingBinding() {
             "public abstract class DaggerAncestor implements Ancestor {",
             "  protected DaggerAncestor() {}",
             "",
-            "  public abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() { super(); }",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
             "",
             "    @Override",
-            "    public MissingInLeaf getMissingInLeaf() {",
+            "    protected final Object getMissingInLeaf() {",
             "      return AncestorModule_SatisfiedInAncestorFactory.proxySatisfiedInAncestor();",
             "    }",
             "  }",
@@ -329,14 +337,14 @@ public void missingBindings_satisfiedInGreatAncestor() {
             "public abstract class DaggerGreatAncestor implements GreatAncestor {",
             "  protected DaggerGreatAncestor() {}",
             "",
-            "  public abstract class AncestorImpl extends DaggerAncestor {",
-            "    protected AncestorImpl() { super(); }",
+            "  protected abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() {}",
             "",
-            "    public abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      protected LeafImpl() { super(); }",
+            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() {}",
             "",
             "      @Override",
-            "      public MissingInLeaf getMissingInLeaf() {",
+            "      protected final Object getMissingInLeaf() {",
             "        return SatisfiesMissingBindingModule_SatisfyFactory.proxySatisfy();",
             "      }",
             "    }",
@@ -351,18 +359,18 @@ public void missingBindings_satisfiedInGreatAncestor() {
 
   @Test
   public void moduleInstanceDependency() {
-    JavaFileObject subcomponent =
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Sub",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
             "@Subcomponent(modules = TestModule.class)",
-            "interface Sub {",
+            "interface Leaf {",
             "  String string();",
-            "}");
-    JavaFileObject module =
+            "}"),
         JavaFileObjects.forSourceLines(
             "test.TestModule",
             "package test;",
@@ -373,70 +381,23 @@ public void moduleInstanceDependency() {
             "@Module",
             "class TestModule {",
             "  @Provides String provideString() { return \"florp\"; }",
-            "}");
-    JavaFileObject generatedSubcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSub",
-            "package test;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerSub implements Sub {",
-            "  private TestModule testModule;",
-            "",
-            "  protected DaggerSub() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.testModule = new TestModule();",
-            "  }",
-            "",
-            "  @Override",
-            "  public String string() {",
-            "    return TestModule_ProvideStringFactory.proxyProvideString(testModule);",
-            "  }",
-            "}");
-    Compilation compilation = compile(subcomponent, module);
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSub")
-        .hasSourceEquivalentTo(generatedSubcomponent);
-  }
-
-  @Test
-  public void generatedInstanceBinding() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            // "  Leaf leaf();", // TODO(b/72748365): enable this (and fix the bug that's causing
-            // this to stack overflow
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Leaf build();",
-            "  }",
             "}"));
     JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
             "test.DaggerLeaf",
             "package test;",
-            "",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf(Builder builder) {}",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return TestModule_ProvideStringFactory.proxyProvideString(testModule());",
+            "  }",
             "",
-            "  protected abstract static class Builder implements Leaf.Builder {}",
+            "  protected abstract TestModule testModule();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -453,7 +414,7 @@ public void generatedInstanceBinding() {
             "",
             "@Subcomponent",
             "interface Ancestor {",
-            "  Leaf.Builder leaf();",
+            "  Leaf leaf();",
             "}"));
     JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
@@ -465,12 +426,8 @@ public void generatedInstanceBinding() {
             "public abstract class DaggerAncestor implements Ancestor {",
             "  protected DaggerAncestor() {}",
             "",
-            "  protected abstract class LeafBuilder extends DaggerLeaf.Builder {}",
-            "",
-            "  public abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl(LeafBuilder builder) {",
-            "      super(builder);",
-            "    }",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
             "  }",
             "}");
     compilation = compile(filesToCompile.build());
@@ -478,1310 +435,1118 @@ public void generatedInstanceBinding() {
     assertThat(compilation)
         .generatedSourceFile("test.DaggerAncestor")
         .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void optionalBindings_satisfiedByDifferentAncestors() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(
-        filesToCompile, "Unsatisfied", "InGreatGrandchild", "InGrandchild", "InChild");
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.GreatGrandchild",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Optional;",
-            "",
-            "@Subcomponent(modules = GreatGrandchildModule.class)",
-            "interface GreatGrandchild {",
-            "  Optional<Unsatisfied> unsatisfied();",
-            "  Optional<InGreatGrandchild> satisfiedByGreatGrandchild();",
-            "  Optional<InGrandchild> satisfiedByGrandchild();",
-            "  Optional<InChild> satisfiedByChild();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    GreatGrandchild build();",
-            "  }",
-            "}"));
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchildModule",
+            "test.Root",
             "package test;",
             "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import java.util.Optional;",
+            "import dagger.Component;",
             "",
-            "@Module",
-            "abstract class GreatGrandchildModule {",
-            "  @BindsOptionalOf abstract Unsatisfied optionalUnsatisfied();",
-            "  @BindsOptionalOf abstract InGreatGrandchild optionalInGreatGrandchild();",
-            "  @Provides static InGreatGrandchild provideInGreatGrandchild() {",
-            "      return new InGreatGrandchild();",
-            "  }",
-            "  @BindsOptionalOf abstract InGrandchild optionalInGrandchild();",
-            "  @BindsOptionalOf abstract InChild optionalInChild();",
+            "@Component",
+            "interface Root {",
+            "  Ancestor ancestor();",
             "}"));
-
-    JavaFileObject generatedGreatGrandchild =
+    JavaFileObject generatedRoot =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGreatGrandchild",
+            "test.DaggerAncestor",
             "package test;",
-            "",
-            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
-            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
             "",
-            "  @Override",
-            "  public Optional<Unsatisfied> unsatisfied() {",
-            "    return Optional.<Unsatisfied>empty();",
+            "  public static Builder builder() {",
+            "    return new Builder();",
             "  }",
             "",
-            "  @Override",
-            "  public Optional<InGreatGrandchild> satisfiedByGreatGrandchild() {",
-            "    return Optional.of(",
-            "        GreatGrandchildModule_ProvideInGreatGrandchildFactory",
-            "            .proxyProvideInGreatGrandchild());",
+            "  public static Root create() {",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
-            "  public Optional<InGrandchild> satisfiedByGrandchild() {",
-            "    return Optional.<InGrandchild>empty();",
+            "  public Ancestor ancestor() {",
+            "    return new AncestorImpl();",
             "  }",
             "",
-            "  @Override",
-            "  public Optional<InChild> satisfiedByChild() {",
-            "    return Optional.<InChild>empty();",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
             "  }",
             "",
-            "  protected abstract static class Builder implements GreatGrandchild.Builder {}",
+            "  protected final class AncestorImpl extends DaggerAncestor {",
+            "    private AncestorImpl() {}",
+            "",
+            "    @Override",
+            "    public Leaf leaf() {",
+            "      return new LeafImpl();",
+            "    }",
+            "",
+            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      private TestModule testModule;",
+            "",
+            "      private LeafImpl() {",
+            "        this.testModule = new TestModule();",
+            "      }",
+            "",
+            "      @Override",
+            "      protected TestModule testModule() {",
+            "        return testModule;",
+            "      }",
+            "    }",
+            "  }",
             "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
 
+  @Test
+  public void moduleInstanceDependency_withModuleParams() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Grandchild",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = GrandchildModule.class)",
-            "interface Grandchild {",
-            "  GreatGrandchild.Builder greatGrandchild();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = TestModule.class)",
+            "interface Leaf {",
+            "  int getInt();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
+            "test.TestModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
             "",
             "@Module",
-            "abstract class GrandchildModule {",
-            "  @Provides static InGrandchild provideInGrandchild() { return new InGrandchild(); }",
+            "final class TestModule {",
+            "  private int i;",
+            "",
+            "  TestModule(int i) {}",
+            "",
+            "  @Provides int provideInt() {",
+            "    return i++;",
+            "  }",
             "}"));
-
-    JavaFileObject generatedGrandchild =
+    JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGrandchild",
+            "test.DaggerLeaf",
             "package test;",
-            "",
-            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandchild implements Grandchild {",
-            "  protected DaggerGrandchild() {}",
-            "",
-            "  protected abstract class GreatGrandchildBuilder",
-            "      extends DaggerGreatGrandchild.Builder {}",
-            "",
-            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
-            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "      super(builder);",
-            "    }",
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
             "",
-            "    @Override",
-            "    public Optional<InGrandchild> satisfiedByGrandchild() {",
-            "      return Optional.of(",
-            "          GrandchildModule_ProvideInGrandchildFactory.proxyProvideInGrandchild());",
-            "    }",
+            "  @Override",
+            "  public int getInt() {",
+            "    return testModule().provideInt();",
             "  }",
+            "",
+            "  protected abstract TestModule testModule();",
             "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Child",
+            "test.Ancestor",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf(TestModule module);",
             "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.ChildModule",
+            "test.Root",
             "package test;",
             "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
+            "import dagger.Component;",
             "",
-            "@Module",
-            "class ChildModule {",
-            "  @Provides static InChild provideInChild() { return new InChild(); }",
+            "@Component",
+            "interface Root {",
+            "  Ancestor ancestor();",
             "}"));
-
-    JavaFileObject generatedChild =
+    JavaFileObject generatedRoot =
         JavaFileObjects.forSourceLines(
-            "test.DaggerChild",
+            "test.DaggerRoot",
             "package test;",
             "",
-            "import java.util.Optional;",
+            "import dagger.internal.Preconditions;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerChild implements Child {",
-            "  protected DaggerChild() {}",
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
             "",
-            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
-            "    protected GrandchildImpl() {",
-            "      super();",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Ancestor ancestor() {",
+            "    return new AncestorImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  protected final class AncestorImpl extends DaggerAncestor {",
+            "    private AncestorImpl() {}",
+            "",
+            "    @Override",
+            "    public Leaf leaf(TestModule module) {",
+            "      return new LeafImpl(module);",
             "    }",
             "",
-            "    protected abstract class GreatGrandchildBuilder",
-            "        extends DaggerGrandchild.GreatGrandchildBuilder {}",
+            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      private TestModule testModule;",
             "",
-            "    public abstract class GreatGrandchildImpl",
-            "        extends DaggerGrandchild.GreatGrandchildImpl {",
-            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "        super(builder);",
+            "      private LeafImpl(TestModule module) {",
+            "        this.testModule = Preconditions.checkNotNull(module);",
             "      }",
             "",
             "      @Override",
-            "      public Optional<InChild> satisfiedByChild() {",
-            "        return Optional.of(ChildModule_ProvideInChildFactory.proxyProvideInChild());",
+            "      protected TestModule testModule() {",
+            "        return testModule;",
             "      }",
             "    }",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
-            .compile(filesToCompile.build());
+    compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerGreatGrandchild")
-        .hasSourceEquivalentTo(generatedGreatGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandchild")
-        .hasSourceEquivalentTo(generatedGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerChild")
-        .hasSourceEquivalentTo(generatedChild);
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
   }
 
   @Test
-  public void optionalBindings_methodDependencies() {
+  public void generatedInstanceBinding() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(
-        filesToCompile,
-        "NonComponentMethodInChild",
-        "NeedsOptionalNonComponentMethodInChild",
-        "AlsoNeedsOptionalNonComponentMethodInChild",
-        "ComponentMethodInGrandchild",
-        "NeedsOptionalComponentMethodInGrandchild",
-        "AlsoNeedsOptionalComponentMethodInGrandchild");
-
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchild",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
-            "import java.util.Optional;",
-            "",
-            "@Subcomponent(modules = GreatGrandchildModule.class)",
-            "interface GreatGrandchild {",
-            "  NeedsOptionalComponentMethodInGrandchild",
-            "      needsOptionalComponentMethodInGrandchild();",
-            "  Optional<ComponentMethodInGrandchild> componentMethod();",
-            "  NeedsOptionalNonComponentMethodInChild needsOptionalNonComponentMethodInChild();",
-            "  AlsoNeedsOptionalNonComponentMethodInChild",
-            "      alsoNeedsOptionalNonComponentMethodInChild();",
-            "  AlsoNeedsOptionalComponentMethodInGrandchild",
-            "      alsoNeedsOptionalComponentMethodInGrandchild();",
             "",
+            "@Subcomponent",
+            "interface Leaf {",
             "  @Subcomponent.Builder",
             "  interface Builder {",
-            "    GreatGrandchild build();",
+            "    Leaf build();",
             "  }",
             "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  public abstract static class Builder implements Leaf.Builder {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchildModule",
+            "test.Ancestor",
             "package test;",
             "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import java.util.Optional;",
+            "import dagger.Subcomponent;",
             "",
-            "@Module",
-            "abstract class GreatGrandchildModule {",
-            "  @Provides static NeedsOptionalNonComponentMethodInChild",
-            "      needsOptionalNonComponentMethodInChild(",
-            "          Optional<NonComponentMethodInChild> optionalNonComponentMethodInChild) {",
-            "    return new NeedsOptionalNonComponentMethodInChild();",
-            "  }",
-            "  @Provides static AlsoNeedsOptionalNonComponentMethodInChild",
-            "      alsoNeedsOptionalNonComponentMethodInChild(",
-            "          Optional<NonComponentMethodInChild> optionalNonComponentMethodInChild) {",
-            "    return new AlsoNeedsOptionalNonComponentMethodInChild();",
-            "  }",
-            "  @Provides static NeedsOptionalComponentMethodInGrandchild",
-            "      needsOptionalComponentMethodInGrandchild(",
-            "          Optional<ComponentMethodInGrandchild>",
-            "              optionalComponentMethodInGrandchild) {",
-            "    return new NeedsOptionalComponentMethodInGrandchild();",
-            "  }",
-            "  @Provides static AlsoNeedsOptionalComponentMethodInGrandchild",
-            "      alsoNeedsOptionalComponentMethodInGrandchild(",
-            "          Optional<ComponentMethodInGrandchild>",
-            "              optionalComponentMethodInGrandchild) {",
-            "    return new AlsoNeedsOptionalComponentMethodInGrandchild();",
-            "  }",
-            "  @BindsOptionalOf abstract ComponentMethodInGrandchild",
-            "      optionalComponentMethodInGrandchild();",
-            "  @BindsOptionalOf abstract NonComponentMethodInChild",
-            "      optionalNonComponentMethodInChild();",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf.Builder leaf();",
             "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
 
-    JavaFileObject generatedGreatGrandchild =
+    filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.DaggerGreatGrandchild",
+            "test.Root",
             "package test;",
             "",
-            "import java.util.Optional;",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Root {",
+            "  Ancestor ancestor();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
-            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
             "",
-            "  @Override",
-            "  public NeedsOptionalComponentMethodInGrandchild",
-            "      needsOptionalComponentMethodInGrandchild() {",
-            "    return GreatGrandchildModule_NeedsOptionalComponentMethodInGrandchildFactory",
-            "        .proxyNeedsOptionalComponentMethodInGrandchild(componentMethod());",
+            "  public static Builder builder() {",
+            "    return new Builder();",
             "  }",
             "",
-            "  @Override",
-            "  public Optional<ComponentMethodInGrandchild> componentMethod() {",
-            "    return Optional.<ComponentMethodInGrandchild>empty();",
+            "  public static Root create() {",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
-            "  public NeedsOptionalNonComponentMethodInChild",
-            "      needsOptionalNonComponentMethodInChild() {",
-            "    return GreatGrandchildModule_NeedsOptionalNonComponentMethodInChildFactory",
-            "        .proxyNeedsOptionalNonComponentMethodInChild(",
-            "            getOptionalOfNonComponentMethodInChild());",
+            "  public Ancestor ancestor() {",
+            "    return new AncestorImpl();",
             "  }",
             "",
-            "  @Override",
-            "  public AlsoNeedsOptionalNonComponentMethodInChild",
-            "      alsoNeedsOptionalNonComponentMethodInChild() {",
-            "    return",
-            "        GreatGrandchildModule_AlsoNeedsOptionalNonComponentMethodInChildFactory",
-            "            .proxyAlsoNeedsOptionalNonComponentMethodInChild(",
-            "                getOptionalOfNonComponentMethodInChild());",
-            "  }",
+            "  public static final class Builder {",
+            "    private Builder() {}",
             "",
-            "  @Override",
-            "  public AlsoNeedsOptionalComponentMethodInGrandchild",
-            "      alsoNeedsOptionalComponentMethodInGrandchild() {",
-            "    return GreatGrandchildModule_AlsoNeedsOptionalComponentMethodInGrandchildFactory",
-            "        .proxyAlsoNeedsOptionalComponentMethodInGrandchild(componentMethod());",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
             "  }",
             "",
-            "  public Optional<NonComponentMethodInChild>",
-            "      getOptionalOfNonComponentMethodInChild() {",
-            "    return Optional.<NonComponentMethodInChild>empty();",
-            "  }",
+            "  protected final class AncestorImpl extends DaggerAncestor {",
+            "    private AncestorImpl() {}",
+            "",
+            "    @Override",
+            "    public Leaf.Builder leaf() {",
+            "      return new LeafBuilder();",
+            "    }",
             "",
-            "  protected abstract static class Builder implements GreatGrandchild.Builder {}",
+            "    private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "      @Override",
+            "      public Leaf build() {",
+            "        return new LeafImpl(this);",
+            "      }",
+            "    }",
+            "",
+            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      private LeafImpl(LeafBuilder builder) {}",
+            "    }",
+            "  }",
             "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
 
+  @Test
+  public void prunedGeneratedInstanceBinding() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Grandchild",
+            "test.PrunedSubcomponent",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = GrandchildModule.class)",
-            "interface Grandchild {",
-            "  GreatGrandchild.Builder greatGrandchild();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent",
+            "interface PrunedSubcomponent {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    PrunedSubcomponent build();",
+            "  }",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
+            "test.InstallsPrunedSubcomponentModule",
             "package test;",
             "",
-            "import dagger.BindsOptionalOf;",
             "import dagger.Module;",
-            "import dagger.Provides;",
             "",
-            "@Module",
-            "abstract class GrandchildModule {",
-            "  @Provides static ComponentMethodInGrandchild provideComponentMethodInGrandchild() {",
-            "    return new ComponentMethodInGrandchild();",
-            "  }",
+            "@Module(subcomponents = PrunedSubcomponent.class)",
+            "interface InstallsPrunedSubcomponentModule {}"),
+        JavaFileObjects.forSourceLines(
+            "test.DependsOnPrunedSubcomponentBuilder",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class DependsOnPrunedSubcomponentBuilder {",
+            "  @Inject DependsOnPrunedSubcomponentBuilder(PrunedSubcomponent.Builder builder) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.MaybeLeaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = InstallsPrunedSubcomponentModule.class)",
+            "interface MaybeLeaf {",
+            "  DependsOnPrunedSubcomponentBuilder dependsOnPrunedSubcomponentBuilder();",
             "}"));
-
-    JavaFileObject generatedGrandchild =
+    JavaFileObject generatedMaybeLeaf =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGrandchild",
+            "test.DaggerMaybeLeaf",
             "package test;",
             "",
-            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandchild implements Grandchild {",
-            "  protected DaggerGrandchild() {}",
+            "public abstract class DaggerMaybeLeaf implements MaybeLeaf {",
+            "  protected DaggerMaybeLeaf() {}",
             "",
-            "  protected abstract class GreatGrandchildBuilder",
-            "      extends DaggerGreatGrandchild.Builder {}",
+            "  @Override",
+            "  public DependsOnPrunedSubcomponentBuilder dependsOnPrunedSubcomponentBuilder() {",
+            "    return DependsOnPrunedSubcomponentBuilder_Factory",
+            "        .newDependsOnPrunedSubcomponentBuilder(",
+            "            getPrunedSubcomponentBuilder());",
+            "  }",
             "",
-            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
-            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "      super(builder);",
-            "    }",
+            "  protected abstract Object getPrunedSubcomponentBuilder();",
             "",
-            "    @Override",
-            "    public Optional<ComponentMethodInGrandchild> componentMethod() {",
-            "      return Optional.of(GrandchildModule_ProvideComponentMethodInGrandchildFactory",
-            "          .proxyProvideComponentMethodInGrandchild());",
-            "    }",
+            "  protected abstract class PrunedSubcomponentImpl extends DaggerPrunedSubcomponent {",
+            "    protected PrunedSubcomponentImpl() {}",
             "  }",
             "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerMaybeLeaf")
+        .hasSourceEquivalentTo(generatedMaybeLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}"));
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.ChildModule",
+            "test.PrunesGeneratedInstanceModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
             "",
             "@Module",
-            "class ChildModule {",
-            "  @Provides static NonComponentMethodInChild provideNonComponentMethodInChild() {",
-            "    return new NonComponentMethodInChild();",
+            "interface PrunesGeneratedInstanceModule {",
+            "  @Provides",
+            "  static DependsOnPrunedSubcomponentBuilder pruneGeneratedInstance() {",
+            "    return new DependsOnPrunedSubcomponentBuilder(null);",
             "  }",
-            "}"));
-
-    JavaFileObject generatedChild =
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.DaggerChild",
+            "test.Root",
             "package test;",
             "",
-            "import java.util.Optional;",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = PrunesGeneratedInstanceModule.class)",
+            "interface Root {",
+            "  MaybeLeaf actuallyLeaf();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerChild implements Child {",
-            "  protected DaggerChild() {}",
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
             "",
-            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
-            "    protected GrandchildImpl() {",
-            "      super();",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public MaybeLeaf actuallyLeaf() {",
+            "    return new MaybeLeafImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
             "    }",
+            "  }",
             "",
-            "    protected abstract class GreatGrandchildBuilder",
-            "        extends DaggerGrandchild.GreatGrandchildBuilder {}",
+            "  protected final class MaybeLeafImpl extends DaggerMaybeLeaf {",
+            "    private MaybeLeafImpl() {}",
             "",
-            "    public abstract class GreatGrandchildImpl",
-            "        extends DaggerGrandchild.GreatGrandchildImpl {",
-            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "        super(builder);",
-            "      }",
+            "    @Override",
+            "    protected Object getPrunedSubcomponentBuilder() {",
+            "      " + PRUNED_METHOD_BODY,
+            "    }",
             "",
-            "      @Override",
-            "      public Optional<NonComponentMethodInChild>",
-            "          getOptionalOfNonComponentMethodInChild() {",
-            "        return Optional.of(ChildModule_ProvideNonComponentMethodInChildFactory",
-            "            .proxyProvideNonComponentMethodInChild());",
-            "      }",
+            "    @Override",
+            "    public DependsOnPrunedSubcomponentBuilder dependsOnPrunedSubcomponentBuilder() {",
+            "      return PrunesGeneratedInstanceModule_PruneGeneratedInstanceFactory",
+            "          .proxyPruneGeneratedInstance();",
             "    }",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
-            .compile(filesToCompile.build());
+    compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerGreatGrandchild")
-        .hasSourceEquivalentTo(generatedGreatGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandchild")
-        .hasSourceEquivalentTo(generatedGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerChild")
-        .hasSourceEquivalentTo(generatedChild);
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
   }
 
   @Test
-  public void optionalBindings_typeChanges() {
+  public void optionalBindings_boundAndSatisfiedInSameSubcomponent() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InChild");
-
+    createAncillaryClasses(filesToCompile, "SatisfiedInSub");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchild",
+            "test.Sub",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "import java.util.Optional;",
             "",
-            "@Subcomponent",
-            "interface GreatGrandchild {",
-            "  Optional<InChild> satisfiedByChildAndBoundInGrandchild();",
+            "@Subcomponent(modules = {SubModule.class, BindsSatisfiedInSubModule.class})",
+            "interface Sub {",
+            "  Optional<SatisfiedInSub> satisfiedInSub();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.SubModule",
+            "package test;",
             "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    GreatGrandchild build();",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class SubModule {",
+            "  @BindsOptionalOf abstract SatisfiedInSub optionalSatisfiedInSub();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.BindsSatisfiedInSubModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class BindsSatisfiedInSubModule {",
+            "  @Provides static SatisfiedInSub provideSatisfiedInSub() {",
+            "      return new SatisfiedInSub();",
             "  }",
             "}"));
-
-    JavaFileObject generatedGreatGrandchild =
+    JavaFileObject generatedSubcomponent =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGreatGrandchild",
+            "test.DaggerSub",
             "package test;",
             "",
+            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
-            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "public abstract class DaggerSub implements Sub {",
+            "  protected DaggerSub() {}",
             "",
-            "  protected abstract static class Builder implements GreatGrandchild.Builder {}",
+            "  @Override",
+            "  public Optional<SatisfiedInSub> satisfiedInSub() {",
+            "    return Optional.of(",
+            "        BindsSatisfiedInSubModule_ProvideSatisfiedInSubFactory",
+            "            .proxyProvideSatisfiedInSub());",
+            "  }",
             "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSub")
+        .hasSourceEquivalentTo(generatedSubcomponent);
+  }
 
+  @Test
+  public void optionalBindings_satisfiedInAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "SatisfiedInAncestor");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Grandchild",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
+            "import java.util.Optional;",
             "",
-            "@Subcomponent(modules = GrandchildModule.class)",
-            "interface Grandchild {",
-            "  GreatGrandchild.Builder greatGrandchild();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Optional<SatisfiedInAncestor> satisfiedInAncestor();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
+            "test.LeafModule",
             "package test;",
             "",
             "import dagger.BindsOptionalOf;",
             "import dagger.Module;",
-            "import dagger.Provides;",
-            "import java.util.Optional;",
             "",
             "@Module",
-            "abstract class GrandchildModule {",
-            "  @BindsOptionalOf abstract InChild optionalInChild();",
+            "abstract class LeafModule {",
+            "  @BindsOptionalOf abstract SatisfiedInAncestor optionalSatisfiedInAncestor();",
             "}"));
-
-    JavaFileObject generatedGrandchild =
+    JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGrandchild",
+            "test.DaggerLeaf",
             "package test;",
             "",
             "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandchild implements Grandchild {",
-            "  protected DaggerGrandchild() {}",
-            "",
-            "  protected abstract class GreatGrandchildBuilder",
-            "      extends DaggerGreatGrandchild.Builder {}",
-            "",
-            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
-            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "      super(builder);",
-            "    }",
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
             "",
-            "    @Override",
-            "    public Optional<InChild> satisfiedByChildAndBoundInGrandchild() {",
-            "      return Optional.<InChild>empty();",
-            "    }",
+            "  @Override",
+            "  public Optional<SatisfiedInAncestor> satisfiedInAncestor() {",
+            "    return Optional.<SatisfiedInAncestor>empty();",
             "  }",
             "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Child",
+            "test.Ancestor",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.ChildModule",
+            "test.AncestorModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
             "",
             "@Module",
-            "class ChildModule {",
-            "  @Provides static InChild provideInChild() { return new InChild(); }",
+            "abstract class AncestorModule {",
+            "  @Provides",
+            "  static SatisfiedInAncestor satisfiedInAncestor(){",
+            "    return new SatisfiedInAncestor();",
+            "  }",
             "}"));
-
-    JavaFileObject generatedChild =
+    JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerChild",
+            "test.DaggerAncestor",
             "package test;",
             "",
             "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerChild implements Child {",
-            "  protected DaggerChild() {}",
-            "",
-            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
-            "    protected GrandchildImpl() {",
-            "      super();",
-            "    }",
-            "",
-            "    protected abstract class GreatGrandchildBuilder",
-            "        extends DaggerGrandchild.GreatGrandchildBuilder {}",
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
             "",
-            "    public abstract class GreatGrandchildImpl",
-            "        extends DaggerGrandchild.GreatGrandchildImpl {",
-            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "        super(builder);",
-            "      }",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
             "",
-            "      @Override",
-            "      public Optional<InChild> satisfiedByChildAndBoundInGrandchild() {",
-            "        return Optional.of(ChildModule_ProvideInChildFactory.proxyProvideInChild());",
-            "      }",
+            "    @Override",
+            "    public final Optional<SatisfiedInAncestor> satisfiedInAncestor() {",
+            "      return Optional.of(AncestorModule_SatisfiedInAncestorFactory",
+            "          .proxySatisfiedInAncestor());",
             "    }",
+            "",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
-            .compile(filesToCompile.build());
+    compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerGreatGrandchild")
-        .hasSourceEquivalentTo(generatedGreatGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandchild")
-        .hasSourceEquivalentTo(generatedGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerChild")
-        .hasSourceEquivalentTo(generatedChild);
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
   }
 
   @Test
-  public void setMultibindings_satisfiedByDifferentAncestors() {
+  public void optionalBindings_satisfiedInGrandAncestor() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(
-        filesToCompile,
-        "InGreatGrandchild",
-        "InChild",
-        "InGreatGrandchildAndChild",
-        "InAllSubcomponents");
-
+    createAncillaryClasses(filesToCompile, "SatisfiedInGrandAncestor");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchild",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
-            "import java.util.Set;",
+            "import java.util.Optional;",
             "",
-            "@Subcomponent(modules = GreatGrandchildModule.class)",
-            "interface GreatGrandchild {",
-            "  Set<InGreatGrandchild> contributionsInGreatGrandchildOnly();",
-            "  Set<InChild> contributionsInChildOnly();",
-            "  Set<InGreatGrandchildAndChild> contributionsInGreatGrandchildAndChild();",
-            "  Set<InAllSubcomponents> contributionsAtAllLevels();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Optional<SatisfiedInGrandAncestor> satisfiedInGrandAncestor();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchildModule",
+            "test.LeafModule",
             "package test;",
             "",
+            "import dagger.BindsOptionalOf;",
             "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
             "",
             "@Module",
-            "class GreatGrandchildModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InGreatGrandchild provideInGreatGrandchild() {",
-            "    return new InGreatGrandchild();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InGreatGrandchildAndChild provideInGreatGrandchildAndChild() {",
-            "    return new InGreatGrandchildAndChild();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
-            "  }",
+            "abstract class LeafModule {",
+            "  @BindsOptionalOf",
+            "  abstract SatisfiedInGrandAncestor optionalSatisfiedInGrandAncestor();",
             "}"));
-
-    JavaFileObject generatedGreatGrandchild =
+    JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGreatGrandchild",
+            "test.DaggerLeaf",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            "",
+            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
-            "  protected DaggerGreatGrandchild() {}",
-            "",
-            "  @Override",
-            "  public Set<InGreatGrandchild> contributionsInGreatGrandchildOnly() {",
-            "    return ImmutableSet.<InGreatGrandchild>of(",
-            "        GreatGrandchildModule_ProvideInGreatGrandchildFactory",
-            "            .proxyProvideInGreatGrandchild());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Set<InGreatGrandchildAndChild> contributionsInGreatGrandchildAndChild() {",
-            "    return ImmutableSet.<InGreatGrandchildAndChild>of(",
-            "        GreatGrandchildModule_ProvideInGreatGrandchildAndChildFactory",
-            "            .proxyProvideInGreatGrandchildAndChild());",
-            "  }",
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
             "",
             "  @Override",
-            "  public Set<InAllSubcomponents> contributionsAtAllLevels() {",
-            "    return ImmutableSet.<InAllSubcomponents>of(",
-            "        GreatGrandchildModule_ProvideInAllSubcomponentsFactory",
-            "            .proxyProvideInAllSubcomponents());",
+            "  public Optional<SatisfiedInGrandAncestor> satisfiedInGrandAncestor() {",
+            "    return Optional.<SatisfiedInGrandAncestor>empty();",
             "  }",
             "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Grandchild",
+            "test.Ancestor",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = GrandchildModule.class)",
-            "interface Grandchild {",
-            "  GreatGrandchild greatGrandchild();",
-            "}"));
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import java.util.Arrays;",
-            "import java.util.Set;",
-            "import java.util.HashSet;",
-            "",
-            "@Module",
-            "class GrandchildModule {",
-            "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InAllSubcomponents> provideInAllSubcomponents() {",
-            "      return ImmutableSet.of(new InAllSubcomponents(), new InAllSubcomponents());",
-            "  }",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
             "}"));
-
-    JavaFileObject generatedGrandchild =
+    JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGrandchild",
+            "test.DaggerAncestor",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            "",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandchild implements Grandchild {",
-            "  protected DaggerGrandchild() {}",
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
             "",
-            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
-            "    protected GreatGrandchildImpl() {",
-            "      super();",
-            "    }",
-            "",
-            "    @Override",
-            "    public Set<InAllSubcomponents> contributionsAtAllLevels() {",
-            "      return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(2)",
-            "          .addAll(GrandchildModule_ProvideInAllSubcomponentsFactory",
-            "              .proxyProvideInAllSubcomponents())",
-            "          .addAll(super.contributionsAtAllLevels())",
-            "          .build();",
-            "    }",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
             "  }",
             "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Child",
+            "test.GreatAncestor",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = GreatAncestorModule.class)",
+            "interface GreatAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.ChildModule",
+            "test.GreatAncestorModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Arrays;",
-            "import java.util.HashSet;",
-            "import java.util.Set;",
             "",
             "@Module",
-            "class ChildModule {",
-            "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InChild> provideInChilds() {",
-            "    return new HashSet<InChild>(Arrays.asList(new InChild(), new InChild()));",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InGreatGrandchildAndChild provideInGreatGrandchildAndChild() {",
-            "    return new InGreatGrandchildAndChild();",
-            "  }",
-            "",
+            "abstract class GreatAncestorModule {",
             "  @Provides",
-            "  @IntoSet",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
+            "  static SatisfiedInGrandAncestor satisfiedInGrandAncestor(){",
+            "    return new SatisfiedInGrandAncestor();",
             "  }",
             "}"));
-
-    JavaFileObject generatedChild =
+    JavaFileObject generatedGreatAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerChild",
+            "test.DaggerGreatAncestor",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            "",
+            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerChild implements Child {",
-            "  protected DaggerChild() {}",
-            "",
-            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
-            "    protected GrandchildImpl() {",
-            "      super();",
-            "    }",
-            "",
-            "    public abstract class GreatGrandchildImpl extends",
-            "        DaggerGrandchild.GreatGrandchildImpl {",
-            "      protected GreatGrandchildImpl() {",
-            "        super();",
-            "      }",
+            "public abstract class DaggerGreatAncestor implements GreatAncestor {",
+            "  protected DaggerGreatAncestor() {}",
             "",
-            "      @Override",
-            "      public Set<InChild> contributionsInChildOnly() {",
-            "        return ImmutableSet.<InChild>copyOf(",
-            "            ChildModule_ProvideInChildsFactory.proxyProvideInChilds());",
-            "      }",
+            "  protected abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() {}",
             "",
-            "      @Override",
-            "      public Set<InGreatGrandchildAndChild>",
-            "          contributionsInGreatGrandchildAndChild() {",
-            "        return ImmutableSet.<InGreatGrandchildAndChild>builderWithExpectedSize(2)",
-            "            .add(ChildModule_ProvideInGreatGrandchildAndChildFactory",
-            "                .proxyProvideInGreatGrandchildAndChild())",
-            "            .addAll(super.contributionsInGreatGrandchildAndChild())",
-            "            .build();",
-            "      }",
+            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() {}",
             "",
             "      @Override",
-            "      public Set<InAllSubcomponents> contributionsAtAllLevels() {",
-            "        return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(3)",
-            "            .add(ChildModule_ProvideInAllSubcomponentsFactory",
-            "                .proxyProvideInAllSubcomponents())",
-            "            .addAll(super.contributionsAtAllLevels())",
-            "            .build();",
+            "      public final Optional<SatisfiedInGrandAncestor> satisfiedInGrandAncestor() {",
+            "        return Optional.of(",
+            "            GreatAncestorModule_SatisfiedInGrandAncestorFactory",
+            "                .proxySatisfiedInGrandAncestor());",
             "      }",
-            "",
             "    }",
+            "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
-            .compile(filesToCompile.build().toArray(new JavaFileObject[0]));
+    compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerGreatGrandchild")
-        .hasSourceEquivalentTo(generatedGreatGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandchild")
-        .hasSourceEquivalentTo(generatedGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerChild")
-        .hasSourceEquivalentTo(generatedChild);
+        .generatedSourceFile("test.DaggerGreatAncestor")
+        .hasSourceEquivalentTo(generatedGreatAncestor);
   }
 
   @Test
-  public void setMultibindings_methodDependencies() {
+  public void optionalBindings_nonComponentMethodDependencySatisfiedInAncestor() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
     createAncillaryClasses(
-        filesToCompile,
-        "InAllSubcomponents",
-        "RequiresInAllSubcomponents",
-        "NoContributions",
-        "RequiresNoContributions");
-
+        filesToCompile, "SatisfiedInAncestor", "RequiresOptionalSatisfiedInAncestor");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchild",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = GreatGrandchildModule.class)",
-            "interface GreatGrandchild {",
-            "  Set<InAllSubcomponents> contributionsAtAllLevels();",
-            "  RequiresNoContributions requiresNonComponentMethodSet();",
-            "  RequiresInAllSubcomponents requiresComponentMethodSet();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Builder module(GreatGrandchildModule module);",
+            "import java.util.Optional;",
             "",
-            "    GreatGrandchild build();",
-            "  }",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  RequiresOptionalSatisfiedInAncestor requiresOptionalSatisfiedInAncestor();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchildModule",
+            "test.LeafModule",
             "package test;",
             "",
+            "import dagger.BindsOptionalOf;",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
+            "import java.util.Optional;",
             "",
             "@Module",
-            "class GreatGrandchildModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
-            "  }",
-            "",
-            "  @Provides",
-            "  static RequiresNoContributions providesRequiresNonComponentMethodSet(",
-            "      Set<NoContributions> noContributions) {",
-            "    return new RequiresNoContributions();",
+            "abstract class LeafModule {",
+            "  @Provides static RequiresOptionalSatisfiedInAncestor",
+            "      provideRequiresOptionalSatisfiedInAncestor(",
+            "          Optional<SatisfiedInAncestor> satisfiedInAncestor) {",
+            "    return new RequiresOptionalSatisfiedInAncestor();",
             "  }",
             "",
-            "  @Provides",
-            "  static RequiresInAllSubcomponents providesRequiresComponentMethodSet(",
-            "      Set<InAllSubcomponents> inAllSubcomponents) {",
-            "    return new RequiresInAllSubcomponents();",
-            "  }",
+            "  @BindsOptionalOf abstract SatisfiedInAncestor optionalSatisfiedInAncestor();",
             "}"));
-
-    JavaFileObject generatedGreatGrandchild =
+    JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGreatGrandchild",
+            "test.DaggerLeaf",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            "",
+            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
-            "  protected DaggerGreatGrandchild(Builder builder) {}",
-            "",
-            "  @Override",
-            "  public Set<InAllSubcomponents> contributionsAtAllLevels() {",
-            "    return ImmutableSet.<InAllSubcomponents>of(",
-            "        GreatGrandchildModule_ProvideInAllSubcomponentsFactory",
-            "            .proxyProvideInAllSubcomponents());",
-            "  }",
-            "",
-            "  @Override",
-            "  public RequiresNoContributions requiresNonComponentMethodSet() {",
-            "    return GreatGrandchildModule_ProvidesRequiresNonComponentMethodSetFactory",
-            "        .proxyProvidesRequiresNonComponentMethodSet(getSet());",
-            "  }",
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
             "",
             "  @Override",
-            "  public RequiresInAllSubcomponents requiresComponentMethodSet() {",
-            "    return GreatGrandchildModule_ProvidesRequiresComponentMethodSetFactory",
-            "        .proxyProvidesRequiresComponentMethodSet(contributionsAtAllLevels());",
+            "  public RequiresOptionalSatisfiedInAncestor",
+            "      requiresOptionalSatisfiedInAncestor() {",
+            "    return LeafModule_ProvideRequiresOptionalSatisfiedInAncestorFactory",
+            "        .proxyProvideRequiresOptionalSatisfiedInAncestor(",
+            "            getOptionalOfSatisfiedInAncestor());",
             "  }",
             "",
-            "  public abstract Set<NoContributions> getSet();",
-            "",
-            "  protected abstract static class Builder implements GreatGrandchild.Builder {",
-            "",
-            "    @Override",
-            "    public Builder module(GreatGrandchildModule module) {",
-            "      return this;",
-            "    }",
+            "  protected Optional getOptionalOfSatisfiedInAncestor() {",
+            "    return Optional.<SatisfiedInAncestor>empty();",
             "  }",
             "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Grandchild",
+            "test.Ancestor",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = GrandchildModule.class)",
-            "interface Grandchild {",
-            "  GreatGrandchild.Builder greatGrandchild();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
+            "test.AncestorModule",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableSet;",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import java.util.Arrays;",
-            "import java.util.Set;",
-            "import java.util.HashSet;",
             "",
             "@Module",
-            "class GrandchildModule {",
+            "abstract class AncestorModule {",
             "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InAllSubcomponents> provideInAllSubcomponents() {",
-            "      return ImmutableSet.of(new InAllSubcomponents(), new InAllSubcomponents());",
+            "  static SatisfiedInAncestor satisfiedInAncestor(){",
+            "    return new SatisfiedInAncestor();",
             "  }",
             "}"));
-
-    JavaFileObject generatedGrandchild =
+    JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGrandchild",
+            "test.DaggerAncestor",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            "",
+            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandchild implements Grandchild {",
-            "  protected DaggerGrandchild() {}",
-            "",
-            "  protected abstract class GreatGrandchildBuilder extends",
-            "      DaggerGreatGrandchild.Builder {",
-            "    @Override",
-            "    public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
-            "      return this;",
-            "    }",
-            "  }",
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
             "",
-            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
-            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "      super(builder);",
-            "    }",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
             "",
             "    @Override",
-            "    public Set<InAllSubcomponents> contributionsAtAllLevels() {",
-            "      return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(2)",
-            "          .addAll(GrandchildModule_ProvideInAllSubcomponentsFactory",
-            "              .proxyProvideInAllSubcomponents())",
-            "          .addAll(super.contributionsAtAllLevels())",
-            "          .build();",
+            "    protected final Optional getOptionalOfSatisfiedInAncestor() {",
+            "      return Optional.of(",
+            "          AncestorModule_SatisfiedInAncestorFactory.proxySatisfiedInAncestor());",
             "    }",
-            "",
             "  }",
             "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
 
+  @Test
+  public void optionalBindings_boundInAncestorAndSatisfiedInGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "SatisfiedInGrandAncestor");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Child",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
+            "import java.util.Optional;",
             "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}"));
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.ChildModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class ChildModule {",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
-            "  }",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Optional<SatisfiedInGrandAncestor> boundInAncestorSatisfiedInGrandAncestor();",
             "}"));
-
-    JavaFileObject generatedChild =
+    JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
-            "test.DaggerChild",
+            "test.DaggerLeaf",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            "",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerChild implements Child {",
-            "  protected DaggerChild() {}",
-            "",
-            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
-            "    protected GrandchildImpl() {",
-            "      super();",
-            "    }",
-            "",
-            "    protected abstract class GreatGrandchildBuilder",
-            "        extends DaggerGrandchild.GreatGrandchildBuilder {",
-            "      @Override",
-            "      public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
-            "        return this;",
-            "      }",
-            "    }",
-            "",
-            "    public abstract class GreatGrandchildImpl extends",
-            "        DaggerGrandchild.GreatGrandchildImpl {",
-            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "        super(builder);",
-            "      }",
-            "",
-            "      @Override",
-            "      public Set<InAllSubcomponents> contributionsAtAllLevels() {",
-            "        return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(3)",
-            "            .add(ChildModule_ProvideInAllSubcomponentsFactory",
-            "                .proxyProvideInAllSubcomponents())",
-            "            .addAll(super.contributionsAtAllLevels())",
-            "            .build();",
-            "      }",
-            "",
-            "    }",
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
             "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
-            .compile(filesToCompile.build().toArray(new JavaFileObject[0]));
+    Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerGreatGrandchild")
-        .hasSourceEquivalentTo(generatedGreatGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandchild")
-        .hasSourceEquivalentTo(generatedGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerChild")
-        .hasSourceEquivalentTo(generatedChild);
-  }
-
-  @Test
-  public void setMultibindings_typeChanges() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InGrandchild");
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchild",
+            "test.Ancestor",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent",
-            "interface GreatGrandchild {",
-            "  InGrandchild missingWithSetDependency();",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
             "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    GreatGrandchild build();",
-            "  }",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class AncestorModule {",
+            "  @BindsOptionalOf",
+            "  abstract SatisfiedInGrandAncestor optionalSatisfiedInGrandAncestor();",
             "}"));
-
-    JavaFileObject generatedGreatGrandchild =
+    JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGreatGrandchild",
+            "test.DaggerAncestor",
             "package test;",
             "",
+            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
-            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
             "",
-            "  protected abstract static class Builder implements GreatGrandchild.Builder { }",
+            "    @Override",
+            "    public Optional<SatisfiedInGrandAncestor>",
+            "        boundInAncestorSatisfiedInGrandAncestor() {",
+            "      return Optional.<SatisfiedInGrandAncestor>empty();",
+            "    }",
+            "  }",
             "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Grandchild",
+            "test.GrandAncestor",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = GrandchildModule.class)",
-            "interface Grandchild {",
-            "  GreatGrandchild.Builder greatGrandchild();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
+            "test.GrandAncestorModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import java.util.Set;",
             "",
             "@Module",
-            "class GrandchildModule {",
-            "",
-            "  @Provides",
-            "  static InGrandchild provideInGrandchild(Set<Long> longs) {",
-            "    return new InGrandchild();",
+            "class GrandAncestorModule {",
+            "  @Provides static SatisfiedInGrandAncestor provideSatisfiedInGrandAncestor() {",
+            "    return new SatisfiedInGrandAncestor();",
             "  }",
             "}"));
-
-    JavaFileObject generatedGrandchild =
+    JavaFileObject generatedGrandAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGrandchild",
+            "test.DaggerGrandAncestor",
             "package test;",
             "",
-            "import java.util.Set;",
-            "",
+            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandchild implements Grandchild {",
-            "  protected DaggerGrandchild() {}",
-            "",
-            "  private InGrandchild getInGrandchild() {",
-            "    return GrandchildModule_ProvideInGrandchildFactory",
-            "        .proxyProvideInGrandchild(getSet());",
-            "  }",
-            "",
-            "  public abstract Set<Long> getSet();",
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
             "",
-            "  protected abstract class GreatGrandchildBuilder extends",
-            "      DaggerGreatGrandchild.Builder { }",
+            "  protected abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() {}",
             "",
-            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
-            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "      super(builder);",
-            "    }",
+            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() {}",
             "",
-            "    @Override",
-            "    public InGrandchild missingWithSetDependency() {",
-            "      return DaggerGrandchild.this.getInGrandchild();",
+            "      @Override",
+            "      public final Optional<SatisfiedInGrandAncestor>",
+            "          boundInAncestorSatisfiedInGrandAncestor() {",
+            "        return Optional.of(",
+            "            GrandAncestorModule_ProvideSatisfiedInGrandAncestorFactory",
+            "                .proxyProvideSatisfiedInGrandAncestor());",
+            "      }",
             "    }",
-            "",
             "  }",
             "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
 
+  @Test
+  public void setMultibindings_contributionsInLeaf() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeaf");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Child",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
+            "import java.util.Set;",
             "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<InLeaf> contributionsInLeaf();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.ChildModule",
+            "test.LeafModule",
             "package test;",
             "",
             "import dagger.Module;",
@@ -1789,16 +1554,16 @@ public void setMultibindings_typeChanges() {
             "import dagger.multibindings.IntoSet;",
             "",
             "@Module",
-            "class ChildModule {",
-            "",
+            "class LeafModule {",
             "  @Provides",
             "  @IntoSet",
-            "  static Long provideLong() { return 0L; }",
+            "  static InLeaf provideInLeaf() {",
+            "    return new InLeaf();",
+            "  }",
             "}"));
-
-    JavaFileObject generatedChild =
+    JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
-            "test.DaggerChild",
+            "test.DaggerLeaf",
             "package test;",
             "",
             "import com.google.common.collect.ImmutableSet;",
@@ -1807,660 +1572,5091 @@ public void setMultibindings_typeChanges() {
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerChild implements Child {",
-            "  protected DaggerChild() {}",
-            "",
-            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
-            "    protected GrandchildImpl() {",
-            "      super();",
-            "    }",
-            "",
-            "    @Override",
-            "    public Set<Long> getSet() {",
-            "      return ImmutableSet.<Long>of(",
-            "          ChildModule_ProvideLongFactory.proxyProvideLong());",
-            "    }",
-            "",
-            "    protected abstract class GreatGrandchildBuilder",
-            "        extends DaggerGrandchild.GreatGrandchildBuilder { }",
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
             "",
-            "    public abstract class GreatGrandchildImpl extends",
-            "        DaggerGrandchild.GreatGrandchildImpl {",
-            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "        super(builder);",
-            "      }",
-            "    }",
+            "  @Override",
+            "  public Set<InLeaf> contributionsInLeaf() {",
+            "    return ImmutableSet.<InLeaf>of(",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
-            .compile(filesToCompile.build().toArray(new JavaFileObject[0]));
+    Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerGreatGrandchild")
-        .hasSourceEquivalentTo(generatedGreatGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandchild")
-        .hasSourceEquivalentTo(generatedGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerChild")
-        .hasSourceEquivalentTo(generatedChild);
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
   }
 
   @Test
-  public void mapMultibindings_satisfiedByDifferentAncestors() {
+  public void setMultibindings_contributionsInAncestorOnly() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(
-        filesToCompile,
-        "InGreatGrandchild",
-        "InChild",
-        "InGreatGrandchildAndChild",
-        "InAllSubcomponents");
-
+    createAncillaryClasses(filesToCompile, "InAncestor");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchild",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
-            "import java.util.Map;",
+            "import java.util.Set;",
             "",
-            "@Subcomponent(modules = GreatGrandchildModule.class)",
-            "interface GreatGrandchild {",
-            "  Map<String, InGreatGrandchild> contributionsInGreatGrandchildOnly();",
-            "  Map<String, InChild> contributionsInChildOnly();",
-            "  Map<String, InGreatGrandchildAndChild> contributionsInGreatGrandchildAndChild();",
-            "  Map<String, InAllSubcomponents> contributionsAtAllLevels();",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Set<InAncestor> contributionsInAncestor();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
             "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Builder module(GreatGrandchildModule module);",
+            IMPORT_GENERATED_ANNOTATION,
             "",
-            "    GreatGrandchild build();",
-            "  }",
-            "}"));
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchildModule",
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
             "package test;",
             "",
+            "import com.google.common.collect.ImmutableSet;",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
             "",
             "@Module",
-            "class GreatGrandchildModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"great-grandchild\")",
-            "  static InGreatGrandchild provideInGreatGrandchild() {",
-            "    return new InGreatGrandchild();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"great-grandchild\")",
-            "  static InGreatGrandchildAndChild provideInGreatGrandchildAndChild() {",
-            "    return new InGreatGrandchildAndChild();",
-            "  }",
-            "",
+            "class AncestorModule {",
             "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"great-grandchild\")",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
+            "  @ElementsIntoSet",
+            "  static Set<InAncestor> provideInAncestors() {",
+            "    return ImmutableSet.of(new InAncestor(), new InAncestor());",
             "  }",
             "}"));
-
-    JavaFileObject generatedGreatGrandchild =
+    JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGreatGrandchild",
+            "test.DaggerAncestor",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
             "",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
-            "  protected DaggerGreatGrandchild(Builder builder) {}",
-            "",
-            "  @Override",
-            "  public Map<String, InGreatGrandchild> contributionsInGreatGrandchildOnly() {",
-            "    return ImmutableMap.<String, InGreatGrandchild>of(",
-            "        \"great-grandchild\",",
-            "        GreatGrandchildModule_ProvideInGreatGrandchildFactory",
-            "            .proxyProvideInGreatGrandchild());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<String, InGreatGrandchildAndChild>",
-            "      contributionsInGreatGrandchildAndChild() {",
-            "    return ImmutableMap.<String, InGreatGrandchildAndChild>of(",
-            "        \"great-grandchild\",",
-            "        GreatGrandchildModule_ProvideInGreatGrandchildAndChildFactory",
-            "            .proxyProvideInGreatGrandchildAndChild());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
-            "    return ImmutableMap.<String, InAllSubcomponents>of(",
-            "        \"great-grandchild\",",
-            "        GreatGrandchildModule_ProvideInAllSubcomponentsFactory",
-            "            .proxyProvideInAllSubcomponents());",
-            "  }",
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
             "",
-            "  protected abstract static class Builder implements GreatGrandchild.Builder {",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
             "",
             "    @Override",
-            "    public Builder module(GreatGrandchildModule module) {",
-            "      return this;",
+            "    public Set<InAncestor> contributionsInAncestor() {",
+            "      return ImmutableSet.<InAncestor>copyOf(",
+            "          AncestorModule_ProvideInAncestorsFactory.proxyProvideInAncestors());",
             "    }",
             "  }",
             "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
 
+  @Test
+  public void setMultibindings_contributionsInLeafAndAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Grandchild",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
+            "import java.util.Set;",
             "",
-            "@Subcomponent(modules = GrandchildModule.class)",
-            "interface Grandchild {",
-            "  GreatGrandchild.Builder greatGrandchild();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<InEachSubcomponent> contributionsInEachSubcomponent();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
+            "test.LeafModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
+            "import dagger.multibindings.IntoSet;",
             "",
             "@Module",
-            "class GrandchildModule {",
+            "class LeafModule {",
             "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"grandchild\")",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideAnotherInLeaf() {",
+            "    return new InEachSubcomponent();",
             "  }",
             "}"));
-
-    JavaFileObject generatedGrandchild =
+    JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGrandchild",
+            "test.DaggerLeaf",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandchild implements Grandchild {",
-            "  protected DaggerGrandchild() {}",
-            "",
-            "  protected abstract class GreatGrandchildBuilder extends",
-            "      DaggerGreatGrandchild.Builder {",
-            "    @Override",
-            "    public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
-            "      return this;",
-            "    }",
-            "  }",
-            "",
-            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
-            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "      super(builder);",
-            "    }",
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
             "",
-            "    @Override",
-            "    public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
-            "      return ImmutableMap.<String, InAllSubcomponents>builderWithExpectedSize(2)",
-            "          .put(\"grandchild\", GrandchildModule_ProvideInAllSubcomponentsFactory",
-            "              .proxyProvideInAllSubcomponents())",
-            "          .putAll(super.contributionsAtAllLevels())",
-            "          .build();",
-            "    }",
+            "  @Override",
+            "  public Set<InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "    return ImmutableSet.<InEachSubcomponent>of(",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf(),",
+            "        LeafModule_ProvideAnotherInLeafFactory.proxyProvideAnotherInLeaf());",
             "  }",
             "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Child",
+            "test.Ancestor",
             "package test;",
             "",
             "import dagger.Subcomponent;",
+            "import java.util.Set;",
             "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.ChildModule",
+            "test.AncestorModule",
             "package test;",
             "",
+            "import com.google.common.collect.ImmutableSet;",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
             "",
             "@Module",
-            "class ChildModule {",
-            "",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"child\")",
-            "  static InChild provideInChild() {",
-            "    return new InChild();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"child\")",
-            "  static InGreatGrandchildAndChild provideInGreatGrandchildAndChild() {",
-            "    return new InGreatGrandchildAndChild();",
-            "  }",
-            "",
+            "class AncestorModule {",
             "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"child\")",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
+            "  @ElementsIntoSet",
+            "  static Set<InEachSubcomponent> provideInAncestor() {",
+            "    return ImmutableSet.of(new InEachSubcomponent(), new InEachSubcomponent());",
             "  }",
             "}"));
-
-    JavaFileObject generatedChild =
+    JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerChild",
+            "test.DaggerAncestor",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerChild implements Child {",
-            "  protected DaggerChild() {}",
-            "",
-            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
-            "    protected GrandchildImpl() {",
-            "      super();",
-            "    }",
-            "",
-            "    protected abstract class GreatGrandchildBuilder",
-            "        extends DaggerGrandchild.GreatGrandchildBuilder {",
-            "      @Override",
-            "      public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
-            "        return this;",
-            "      }",
-            "    }",
-            "",
-            "    public abstract class GreatGrandchildImpl extends",
-            "        DaggerGrandchild.GreatGrandchildImpl {",
-            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "        super(builder);",
-            "      }",
-            "",
-            "      @Override",
-            "      public Map<String, InChild> contributionsInChildOnly() {",
-            "        return ImmutableMap.<String, InChild>of(",
-            "            \"child\", ChildModule_ProvideInChildFactory.proxyProvideInChild());",
-            "      }",
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
             "",
-            "      @Override",
-            "      public Map<String, InGreatGrandchildAndChild>",
-            "          contributionsInGreatGrandchildAndChild() {",
-            "        return",
-            "            ImmutableMap.<String, InGreatGrandchildAndChild>builderWithExpectedSize(",
-            "                2)",
-            "            .put(\"child\",",
-            "                ChildModule_ProvideInGreatGrandchildAndChildFactory",
-            "                    .proxyProvideInGreatGrandchildAndChild())",
-            "            .putAll(super.contributionsInGreatGrandchildAndChild())",
-            "            .build();",
-            "      }",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
             "",
-            "      @Override",
-            "      public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
-            "        return ImmutableMap.<String, InAllSubcomponents>builderWithExpectedSize(3)",
-            "            .put(\"child\",",
-            "                ChildModule_ProvideInAllSubcomponentsFactory",
-            "                    .proxyProvideInAllSubcomponents())",
-            "            .putAll(super.contributionsAtAllLevels())",
-            "            .build();",
-            "      }",
+            "    @Override",
+            "    public Set<InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "      return ImmutableSet.<InEachSubcomponent>builderWithExpectedSize(3)",
+            "          .addAll(AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
+            "          .addAll(super.contributionsInEachSubcomponent())",
+            "          .build();",
             "    }",
+            "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
-            .compile(filesToCompile.build().toArray(new JavaFileObject[0]));
+    compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerGreatGrandchild")
-        .hasSourceEquivalentTo(generatedGreatGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandchild")
-        .hasSourceEquivalentTo(generatedGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerChild")
-        .hasSourceEquivalentTo(generatedChild);
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
   }
 
   @Test
-  public void mapMultibindings_methodDependencies() {
+  public void setMultibindings_contributionsInLeafAndGrandAncestor() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(
-        filesToCompile,
-        "InAllSubcomponents",
-        "RequiresInAllSubcomponentsMap",
-        "Unsatisfied",
-        "RequiresUnsatisfiedMap");
-
+    createAncillaryClasses(filesToCompile, "InLeafAndGrandAncestor");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchild",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = GreatGrandchildModule.class)",
-            "interface GreatGrandchild {",
-            "  Map<String, InAllSubcomponents> contributionsAtAllLevels();",
-            "  RequiresUnsatisfiedMap requiresNonComponentMethodMap();",
-            "  RequiresInAllSubcomponentsMap requiresComponentMethodMap();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Builder module(GreatGrandchildModule module);",
+            "import java.util.Set;",
             "",
-            "    GreatGrandchild build();",
-            "  }",
-            "}"));
-
-    filesToCompile.add(
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.GreatGrandchildModule",
+            "test.LeafModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InLeafAndGrandAncestor provideInLeaf() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InLeafAndGrandAncestor provideAnotherInLeaf() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
+            "    return ImmutableSet.<InLeafAndGrandAncestor>of(",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf(),",
+            "        LeafModule_ProvideAnotherInLeafFactory.proxyProvideAnotherInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InLeafAndGrandAncestor> provideInGrandAncestor() {",
+            "    return ImmutableSet.of(new InLeafAndGrandAncestor(),",
+            "        new InLeafAndGrandAncestor());",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
+            "      return ImmutableSet.<InLeafAndGrandAncestor>builderWithExpectedSize(3)",
+            "          .addAll(GrandAncestorModule_ProvideInGrandAncestorFactory",
+            "              .proxyProvideInGrandAncestor())",
+            "          .addAll(super.contributionsInLeafAndGrandAncestor())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void setMultibindings_nonComponentMethodDependency() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAllSubcomponents", "RequresInAllSubcomponentsSet");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  RequresInAllSubcomponentsSet requiresNonComponentMethod();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "",
+            "  @Provides",
+            "  static RequresInAllSubcomponentsSet providesRequresInAllSubcomponentsSet(",
+            "      Set<InAllSubcomponents> inAllSubcomponents) {",
+            "    return new RequresInAllSubcomponentsSet();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public RequresInAllSubcomponentsSet requiresNonComponentMethod() {",
+            "    return LeafModule_ProvidesRequresInAllSubcomponentsSetFactory",
+            "        .proxyProvidesRequresInAllSubcomponentsSet(getSetOfInAllSubcomponents());",
+            "  }",
+            "",
+            "  protected Set getSetOfInAllSubcomponents() {",
+            "    return ImmutableSet.<InAllSubcomponents>of(",
+            "        LeafModule_ProvideInAllSubcomponentsFactory",
+            "            .proxyProvideInAllSubcomponents());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "      return new InAllSubcomponents();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected Set getSetOfInAllSubcomponents() {",
+            "      return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(2)",
+            "          .add(AncestorModule_ProvideInAllSubcomponentsFactory",
+            "              .proxyProvideInAllSubcomponents())",
+            "          .addAll(super.getSetOfInAllSubcomponents())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibindings_newSubclass() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAncestor", "RequiresInAncestorSet");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  RequiresInAncestorSet missingWithSetDependency();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "",
+            "  @Provides",
+            "  static RequiresInAncestorSet provideRequiresInAncestorSet(",
+            "      Set<InAncestor> inAncestors) {",
+            "    return new RequiresInAncestorSet();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAncestor provideInAncestor() {",
+            "    return new InAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            // TODO(b/117833324): because this is a private method, the return type shouldn't need
+            // to be the publicly accessible type. This may be easier to detect if we fold
+            // BindingMethodImplementation into MethodBindingExpression
+            "  private Object getRequiresInAncestorSet() {",
+            "    return AncestorModule_ProvideRequiresInAncestorSetFactory",
+            "        .proxyProvideRequiresInAncestorSet(getSetOfInAncestor());",
+            "  }",
+            "",
+            "  protected Set getSetOfInAncestor() {",
+            "    return ImmutableSet.<InAncestor>of(",
+            "        AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor());",
+            "  }",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public final RequiresInAncestorSet missingWithSetDependency() {",
+            "      return (RequiresInAncestorSet) DaggerAncestor.this.getRequiresInAncestorSet();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstanceFromAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile, "Multibound", "MissingInLeaf_WillDependOnFrameworkInstance");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<Multibound> instance();",
+            "  MissingInLeaf_WillDependOnFrameworkInstance willDependOnFrameworkInstance();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Multibound contribution() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<Multibound> instance() {",
+            "    return ImmutableSet.<Multibound>of(",
+            "        LeafModule_ContributionFactory.proxyContribution());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "interface AncestorModule {",
+            "  @Provides",
+            "  static MissingInLeaf_WillDependOnFrameworkInstance providedInAncestor(",
+            "      Provider<Set<Multibound>> frameworkInstance) {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Multibinds Set<Multibound> multibinds();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Set<Multibound>> setOfMultiboundProvider;",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    protected void configureInitialization() { ",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() { ",
+            "      this.setOfMultiboundProvider =",
+            "          SetFactory.<Multibound>builder(1, 0)",
+            "              .addProvider(LeafModule_ContributionFactory.create())",
+            "              .build();",
+            "    }",
+            "",
+            "    protected Provider getSetOfMultiboundProvider() {",
+            "      return setOfMultiboundProvider;",
+            "    }",
+            "",
+            "    @Override",
+            "    public final MissingInLeaf_WillDependOnFrameworkInstance ",
+            "        willDependOnFrameworkInstance() {",
+            "      return AncestorModule_ProvidedInAncestorFactory.proxyProvidedInAncestor(",
+            "          getSetOfMultiboundProvider());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibindings_contributionsInLeafAndAncestor_frameworkInstances() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideAnotherInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private Provider<Set<InEachSubcomponent>> setOfInEachSubcomponentProvider;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.setOfInEachSubcomponentProvider =",
+            "        SetFactory.<InEachSubcomponent>builder(2, 0)",
+            "            .addProvider(LeafModule_ProvideInLeafFactory.create())",
+            "            .addProvider(LeafModule_ProvideAnotherInLeafFactory.create())",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent() {",
+            "    return setOfInEachSubcomponentProvider;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InEachSubcomponent> provideInAncestor() {",
+            "    return ImmutableSet.of(new InEachSubcomponent(), new InEachSubcomponent());",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.DelegateFactory;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Set<InEachSubcomponent>> setOfInEachSubcomponentProvider = ",
+            "        new DelegateFactory<>();",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected void configureInitialization() {",
+            "      super.configureInitialization();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      DelegateFactory.setDelegate(",
+            "          setOfInEachSubcomponentProvider,",
+            "          SetFactory.<InEachSubcomponent>builder(0, 2)",
+            "              .addCollectionProvider(super.contributionsInEachSubcomponent())",
+            "              .addCollectionProvider(",
+            "                  AncestorModule_ProvideInAncestorFactory.create())",
+            "              .build());",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent() {",
+            "      return setOfInEachSubcomponentProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeaf() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InLeaf> contributionsInLeaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InLeaf provideInLeaf() {",
+            "    return new InLeaf();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InLeaf> contributionsInLeaf() {",
+            "    return ImmutableMap.<String, InLeaf>of(",
+            "        \"leafmodule\",",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInAncestorOnly() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Map<String, InAncestor> contributionsInAncestor();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InAncestor provideInAncestor() {",
+            "    return new InAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<String, InAncestor> contributionsInAncestor() {",
+            "      return ImmutableMap.<String, InAncestor>of(\"ancestormodule\",",
+            "          AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "    return ImmutableMap.<String, InEachSubcomponent>of(",
+            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InEachSubcomponent provideInAncestor() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "      return ImmutableMap.<String, InEachSubcomponent>builderWithExpectedSize(2)",
+            "          .put(\"ancestormodule\",",
+            "              AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
+            "          .putAll(super.contributionsInEachSubcomponent())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndAncestor_frameworkInstance() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Map<String, InEachSubcomponent>> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private Provider<Map<String, InEachSubcomponent>> ",
+            "    mapOfStringAndInEachSubcomponentProvider;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.mapOfStringAndInEachSubcomponentProvider =",
+            "        MapFactory.<String, InEachSubcomponent>builder(1)",
+            "            .put(\"leafmodule\", LeafModule_ProvideInLeafFactory.create())",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<Map<String, InEachSubcomponent>> ",
+            "      contributionsInEachSubcomponent() {",
+            "    return mapOfStringAndInEachSubcomponentProvider;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InEachSubcomponent provideInAncestor() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.DelegateFactory;",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Map<String, InEachSubcomponent>> ",
+            "      mapOfStringAndInEachSubcomponentProvider = new DelegateFactory<>();",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected void configureInitialization() { ",
+            "      super.configureInitialization();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() { ",
+            "      DelegateFactory.setDelegate(",
+            "          mapOfStringAndInEachSubcomponentProvider,",
+            "          MapFactory.<String, InEachSubcomponent>builder(2)",
+            "              .putAll(super.contributionsInEachSubcomponent())",
+            "              .put(",
+            "                  \"ancestormodule\",",
+            "                  AncestorModule_ProvideInAncestorFactory.create())",
+            "              .build());",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Map<String, InEachSubcomponent>> ",
+            "        contributionsInEachSubcomponent() {",
+            "      return mapOfStringAndInEachSubcomponentProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeafAndGrandAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InLeafAndGrandAncestor provideInLeaf() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
+            "    return ImmutableMap.<String, InLeafAndGrandAncestor>of(",
+            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"grandancestormodule\")",
+            "  static InLeafAndGrandAncestor provideInGrandAncestor() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  protected abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() {}",
+            "",
+            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() {}",
+            "",
+            "      @Override",
+            "      public Map<String, InLeafAndGrandAncestor>",
+            "          contributionsInLeafAndGrandAncestor() {",
+            "        return",
+            "            ImmutableMap.<String, InLeafAndGrandAncestor>builderWithExpectedSize(2)",
+            "                .put(\"grandancestormodule\",",
+            "                    GrandAncestorModule_ProvideInGrandAncestorFactory",
+            "                        .proxyProvideInGrandAncestor())",
+            "                .putAll(super.contributionsInLeafAndGrandAncestor())",
+            "                .build();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndAncestorWithoutGuava() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import java.util.Collections;",
+            "import java.util.Map",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "    return Collections.<String, InEachSubcomponent>singletonMap(",
+            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compileWithoutGuava(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InEachSubcomponent provideInAncestor() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.MapBuilder;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "      return MapBuilder.<String, InEachSubcomponent>newMapBuilder(2)",
+            "          .put(\"ancestormodule\",",
+            "              AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
+            "          .putAll(super.contributionsInEachSubcomponent())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compileWithoutGuava(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstanceFromAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile, "Multibound", "MissingInLeaf_WillDependOnFrameworkInstance");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<Integer, Multibound> instance();",
+            "  MissingInLeaf_WillDependOnFrameworkInstance willDependOnFrameworkInstance();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @IntKey(111)",
+            "  static Multibound contribution() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<Integer, Multibound> instance() {",
+            "    return ImmutableMap.<Integer, Multibound>of(",
+            "        111, LeafModule_ContributionFactory.proxyContribution());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "interface AncestorModule {",
+            "  @Provides",
+            "  static MissingInLeaf_WillDependOnFrameworkInstance providedInAncestor(",
+            "      Provider<Map<Integer, Multibound>> frameworkInstance) {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Multibinds Map<Integer, Multibound> multibinds();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Map<Integer, Multibound>> mapOfIntegerAndMultiboundProvider;",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    protected void configureInitialization() { ",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() { ",
+            "      this.mapOfIntegerAndMultiboundProvider =",
+            "          MapFactory.<Integer, Multibound>builder(1)",
+            "              .put(111, LeafModule_ContributionFactory.create())",
+            "              .build();",
+            "    }",
+            "",
+            "    protected Provider getMapOfIntegerAndMultiboundProvider() {",
+            "      return mapOfIntegerAndMultiboundProvider;",
+            "    }",
+            "",
+            "    @Override",
+            "    public final MissingInLeaf_WillDependOnFrameworkInstance ",
+            "        willDependOnFrameworkInstance() {",
+            "      return AncestorModule_ProvidedInAncestorFactory.proxyProvidedInAncestor(",
+            "          getMapOfIntegerAndMultiboundProvider());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_set() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Set<Multibound> set();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<Multibound> set();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<Multibound> set() {",
+            "    return ImmutableSet.<Multibound>of();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Set<Multibound> set() {",
+            "      return ImmutableSet.<Multibound>of(",
+            "          AncestorModule_FromAncestorFactory.proxyFromAncestor());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_set_frameworkInstance() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Set<Multibound> set();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Set<Multibound>> set();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Provider<Set<Multibound>> set() {",
+            "    return SetFactory.<Multibound>empty();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.DelegateFactory;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Set<Multibound>> setOfMultiboundProvider =",
+            "        new DelegateFactory<>();",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    protected void configureInitialization() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      DelegateFactory.setDelegate(",
+            "          setOfMultiboundProvider,",
+            "          SetFactory.<Multibound>builder(1, 0)",
+            "              .addProvider(AncestorModule_FromAncestorFactory.create())",
+            "              .build());",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Set<Multibound>> set() {",
+            "      return setOfMultiboundProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_map() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Map<Integer, Multibound> map();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<Integer, Multibound> map();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<Integer, Multibound> map() {",
+            "    return ImmutableMap.<Integer, Multibound>of();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @IntKey(111)",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<Integer, Multibound> map() {",
+            "      return ImmutableMap.<Integer, Multibound>of(",
+            "          111, AncestorModule_FromAncestorFactory.proxyFromAncestor());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_map_frameworkInstance() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Map<Integer, Multibound> map();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Map<Integer, Multibound>> map();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Provider<Map<Integer, Multibound>> map() {",
+            "    return MapFactory.<Integer, Multibound>emptyMapProvider();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
             "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @IntKey(111)",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.DelegateFactory;",
+            "import dagger.internal.MapFactory;",
             "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Map<Integer, Multibound>> mapOfIntegerAndMultiboundProvider =",
+            "        new DelegateFactory<>()",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    protected void configureInitialization() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      DelegateFactory.setDelegate(",
+            "          mapOfIntegerAndMultiboundProvider,",
+            "          MapFactory.<Integer, Multibound>builder(1)",
+            "              .put(111, AncestorModule_FromAncestorFactory.create())",
+            "              .build());",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Map<Integer, Multibound>> map() {",
+            "      return mapOfIntegerAndMultiboundProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void provisionOverInjection_providedInAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ProvidedInAncestor",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ProvidedInAncestor {",
+            "  @Inject",
+            "  ProvidedInAncestor(String string) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  ProvidedInAncestor injectedInLeaf();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public ProvidedInAncestor injectedInLeaf() {",
+            "    return new ProvidedInAncestor(getString());",
+            "  }",
+            "",
+            "  protected abstract String getString();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static ProvidedInAncestor provideProvidedInAncestor() {",
+            "    return new ProvidedInAncestor(\"static\");",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public final ProvidedInAncestor injectedInLeaf() {",
+            "      return AncestorModule_ProvideProvidedInAncestorFactory",
+            "          .proxyProvideProvidedInAncestor();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void provisionOverInjection_providedInGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ProvidedInGrandAncestor",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ProvidedInGrandAncestor {",
+            "  @Inject",
+            "  ProvidedInGrandAncestor(String string) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  ProvidedInGrandAncestor injectedInLeaf();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public ProvidedInGrandAncestor injectedInLeaf() {",
+            "    return new ProvidedInGrandAncestor(getString());",
+            "  }",
+            "",
+            "  protected abstract String getString();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides",
+            "  static ProvidedInGrandAncestor provideProvidedInGrandAncestor() {",
+            "    return new ProvidedInGrandAncestor(\"static\");",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  protected abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() {}",
+            "",
+            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() {}",
+            "",
+            "      @Override",
+            "      public final ProvidedInGrandAncestor injectedInLeaf() {",
+            "        return GrandAncestorModule_ProvideProvidedInGrandAncestorFactory",
+            "            .proxyProvideProvidedInGrandAncestor();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void provisionOverInjection_indirectDependency() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ProvidedInAncestor",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ProvidedInAncestor {",
+            "  @Inject",
+            "  ProvidedInAncestor(String string) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.InjectedInLeaf",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectedInLeaf {",
+            "  @Inject",
+            "  InjectedInLeaf(ProvidedInAncestor providedInAncestor) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  InjectedInLeaf injectedInLeaf();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public InjectedInLeaf injectedInLeaf() {",
+            "    return InjectedInLeaf_Factory.newInjectedInLeaf(getProvidedInAncestor());",
+            "  }",
+            "",
+            "  protected abstract String getString();",
+            "",
+            "  protected Object getProvidedInAncestor() {",
+            "    return new ProvidedInAncestor(getString());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static ProvidedInAncestor provideProvidedInAncestor() {",
+            "    return new ProvidedInAncestor(\"static\");",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected final Object getProvidedInAncestor() {",
+            "      return AncestorModule_ProvideProvidedInAncestorFactory",
+            "          .proxyProvideProvidedInAncestor();",
+            "    }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void provisionOverInjection_prunedIndirectDependency() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "PrunedDependency");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.InjectsPrunedDependency",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectsPrunedDependency {",
+            "  @Inject",
+            "  InjectsPrunedDependency(PrunedDependency prunedDependency) {}",
+            "",
+            "  private InjectsPrunedDependency() { }",
+            "",
+            "  static InjectsPrunedDependency create() { return new InjectsPrunedDependency(); }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  InjectsPrunedDependency injectsPrunedDependency();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public InjectsPrunedDependency injectsPrunedDependency() {",
+            "    return InjectsPrunedDependency_Factory.newInjectsPrunedDependency(",
+            "        getPrunedDependency());",
+            "  }",
+            "",
+            "  protected abstract Object getPrunedDependency();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = RootModule.class)",
+            "interface Root {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.RootModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class RootModule {",
+            "  @Provides",
+            "  static InjectsPrunedDependency injectsPrunedDependency() {",
+            "    return InjectsPrunedDependency.create();",
+            "  }",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf leaf() {",
+            "    return new LeafImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder rootModule(RootModule rootModule) {",
+            "      Preconditions.checkNotNull(rootModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  protected final class LeafImpl extends DaggerLeaf {",
+            "    private LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected Object getPrunedDependency() {",
+            "      " + PRUNED_METHOD_BODY,
+            "    }",
+            "",
+            "    @Override",
+            "    public InjectsPrunedDependency injectsPrunedDependency() {",
+            "      return RootModule_InjectsPrunedDependencyFactory",
+            "          .proxyInjectsPrunedDependency();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
+  @Test
+  public void provisionOverInjection_prunedDirectDependency_prunedInConcreteImplementation() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        // The binding for PrunedDependency will always exist, but will change from
+        // ModifiableBindingType.INJECTION to ModifiableBindingType.MISSING. We should correctly
+        // ignore this change leave the modifiable binding method alone
+        JavaFileObjects.forSourceLines(
+            "test.PrunedDependency",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class PrunedDependency {",
+            "  @Inject PrunedDependency() {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.InjectsPrunedDependency",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectsPrunedDependency {",
+            "  @Inject",
+            "  InjectsPrunedDependency(PrunedDependency prunedDependency) {}",
+            "",
+            "  private InjectsPrunedDependency() { }",
+            "",
+            "  static InjectsPrunedDependency create() { return new InjectsPrunedDependency(); }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  InjectsPrunedDependency injectsPrunedDependency();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public InjectsPrunedDependency injectsPrunedDependency() {",
+            "    return InjectsPrunedDependency_Factory.newInjectsPrunedDependency(",
+            "        getPrunedDependency());",
+            "  }",
+            "",
+            "  protected Object getPrunedDependency() {",
+            "    return new PrunedDependency();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = RootModule.class)",
+            "interface Root {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.RootModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class RootModule {",
+            "  @Provides",
+            "  static InjectsPrunedDependency injectsPrunedDependency() {",
+            "    return InjectsPrunedDependency.create();",
+            "  }",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf leaf() {",
+            "    return new LeafImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder rootModule(RootModule rootModule) {",
+            "      Preconditions.checkNotNull(rootModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  protected final class LeafImpl extends DaggerLeaf {",
+            "    private LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public InjectsPrunedDependency injectsPrunedDependency() {",
+            "      return RootModule_InjectsPrunedDependencyFactory",
+            "          .proxyInjectsPrunedDependency();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
+  @Test
+  public void provisionOverInjection_prunedDirectDependency_prunedInAbstractImplementation() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        // The binding for PrunedDependency will always exist, but will change from
+        // ModifiableBindingType.INJECTION to ModifiableBindingType.MISSING. We should correctly
+        // ignore this change leave the modifiable binding method alone
+        JavaFileObjects.forSourceLines(
+            "test.PrunedDependency",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class PrunedDependency {",
+            "  @Inject PrunedDependency() {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.InjectsPrunedDependency",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectsPrunedDependency {",
+            "  @Inject",
+            "  InjectsPrunedDependency(PrunedDependency prunedDependency) {}",
+            "",
+            "  private InjectsPrunedDependency() { }",
+            "",
+            "  static InjectsPrunedDependency create() { return new InjectsPrunedDependency(); }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  InjectsPrunedDependency injectsPrunedDependency();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public InjectsPrunedDependency injectsPrunedDependency() {",
+            "    return InjectsPrunedDependency_Factory.newInjectsPrunedDependency(",
+            "        getPrunedDependency());",
+            "  }",
+            "",
+            "  protected Object getPrunedDependency() {",
+            "    return new PrunedDependency();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static InjectsPrunedDependency injectsPrunedDependency() {",
+            "    return InjectsPrunedDependency.create();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public final InjectsPrunedDependency injectsPrunedDependency() {",
+            "      return AncestorModule_InjectsPrunedDependencyFactory",
+            "          .proxyInjectsPrunedDependency();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Root {",
+            "  Ancestor ancestor();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Ancestor ancestor() {",
+            "    return new AncestorImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  protected final class AncestorImpl extends DaggerAncestor {",
+            "    private AncestorImpl() {}",
+            "",
+            "    @Override",
+            "    public Leaf leaf() {",
+            "      return new LeafImpl();",
+            "    }",
+            "",
+            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      private LeafImpl() {}",
+            // even though DaggerAncestor.LeafImpl.getPrunedDependency() was
+            // ModifiableBindingType.MISSING, it doesn't need to be reimplemented because there was
+            // a base implementation
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
+  @Test
+  public void productionSubcomponentAndModifiableFrameworkInstance() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Response", "ResponseDependency");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionSubcomponent;",
+            "import java.util.Set;",
+            "",
+            "@ProductionSubcomponent(modules = ResponseProducerModule.class)",
+            "interface Leaf {",
+            "  ListenableFuture<Set<Response>> responses();",
+            "",
+            "  @ProductionSubcomponent.Builder",
+            "  interface Builder {",
+            "    Leaf build();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.ResponseProducerModule",
+            "package test;",
+            "",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class ResponseProducerModule {",
+            "  @Produces",
+            "  @IntoSet",
+            "  static Response response(ResponseDependency responseDependency) {",
+            "    return new Response();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.CancellationListener;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.internal.SetProducer;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.Set;",
+            "import java.util.concurrent.Executor;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf, CancellationListener {",
+            "  private Producer<Set<Response>> responsesEntryPoint;",
+            "",
+            "  private ResponseProducerModule_ResponseFactory responseProducer;",
+            "",
+            "  private Producer<Set<Response>> setOfResponseProducer;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.responseProducer =",
+            "        ResponseProducerModule_ResponseFactory.create(",
+            "            getProductionImplementationExecutorProvider(),",
+            "            getProductionComponentMonitorProvider(),",
+            "            getResponseDependencyProducer());",
+            "    this.setOfResponseProducer =",
+            "        SetProducer.<Response>builder(1, 0)",
+            "            .addProducer(getResponseProducer()).build();",
+            "    this.responsesEntryPoint =",
+            "        Producers.entryPointViewOf(getSetOfResponseProducer(), this);",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<Set<Response>> responses() {",
+            "    return responsesEntryPoint.get();",
+            "  }",
+            "",
+            "  protected abstract Provider<Executor>",
+            "      getProductionImplementationExecutorProvider();",
+            "",
+            "  protected abstract Provider<ProductionComponentMonitor>",
+            "      getProductionComponentMonitorProvider();",
+            "",
+            "  protected abstract Producer getResponseDependencyProducer();",
+            "",
+            "  protected Producer getResponseProducer() {",
+            "    return responseProducer;",
+            "  }",
+            "",
+            "  protected Producer getSetOfResponseProducer() {",
+            "    return setOfResponseProducer;",
+            "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            "    Producers.cancel(getSetOfResponseProducer(), mayInterruptIfRunning);",
+            "    Producers.cancel(getResponseProducer(), mayInterruptIfRunning);",
+            "  }",
+            "",
+            "  public abstract static class Builder implements Leaf.Builder {}",
+            "}");
+
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ExecutorModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.MoreExecutors;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@Module",
+            "final class ExecutorModule {",
+            "  @Provides",
+            "  @Production",
+            "  static Executor executor() {",
+            "    return MoreExecutors.directExecutor();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(",
+            "  modules = {",
+            "      ExecutorModule.class,",
+            "      ResponseDependencyProducerModule.class,",
+            "      RootMultibindingModule.class,",
+            "  })",
+            "interface Root {",
+            "  Leaf.Builder leaf();",
+            "",
+            "  @ProductionComponent.Builder",
+            "  interface Builder {",
+            "    Root build();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.ResponseDependencyProducerModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class ResponseDependencyProducerModule {",
+            "  @Produces",
+            "  static ListenableFuture<ResponseDependency> responseDependency() {",
+            "    return Futures.immediateFuture(new ResponseDependency());",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.RootMultibindingModule",
+            "package test;",
+            "",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class RootMultibindingModule {",
+            "  @Produces",
+            "  @IntoSet",
+            "  static Response response() {",
+            "    return new Response();",
+            "  }",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "import dagger.internal.DoubleCheck;",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.SetFactory;",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.CancellationListener;",
+            "import dagger.producers.internal.DelegateProducer;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.internal.SetProducer;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.Set;",
+            "import java.util.concurrent.Executor;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root, CancellationListener {",
+            "  private Provider<Executor> productionImplementationExecutorProvider;",
+            "",
+            "  private Provider<Root> rootProvider;",
+            "",
+            "  private Provider<ProductionComponentMonitor> monitorProvider;",
+            "",
+            "  private ResponseDependencyProducerModule_ResponseDependencyFactory",
+            "      responseDependencyProducer;",
+            "",
+            "  private RootMultibindingModule_ResponseFactory responseProducer;",
+            "",
+            "  private DaggerRoot(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Root.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.productionImplementationExecutorProvider =",
+            "        DoubleCheck.provider((Provider) ExecutorModule_ExecutorFactory.create());",
+            "    this.rootProvider = InstanceFactory.create((Root) this);",
+            "    this.monitorProvider =",
+            "        DoubleCheck.provider(",
+            "            Root_MonitoringModule_MonitorFactory.create(",
+            "                rootProvider,",
+            "                SetFactory.<ProductionComponentMonitor.Factory>empty()));",
+            "    this.responseDependencyProducer =",
+            "        ResponseDependencyProducerModule_ResponseDependencyFactory.create(",
+            "            productionImplementationExecutorProvider, monitorProvider);",
+            "    this.responseProducer =",
+            "        RootMultibindingModule_ResponseFactory.create(",
+            "            productionImplementationExecutorProvider, monitorProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf.Builder leaf() {",
+            "    return new LeafBuilder();",
+            "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            "    Producers.cancel(responseProducer, mayInterruptIfRunning);",
+            "    Producers.cancel(responseDependencyProducer, mayInterruptIfRunning);",
+            "  }",
+            "",
+            "  private static final class Builder implements Root.Builder {",
+            "    @Override",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "    @Override",
+            "    public Leaf build() {",
+            "      return new LeafImpl(this);",
+            "    }",
+            "  }",
+            "",
+            "  protected final class LeafImpl extends DaggerLeaf implements CancellationListener {",
+            "    private Producer<Set<Response>> setOfResponseProducer = new DelegateProducer<>();",
+            "",
+            "    private LeafImpl(LeafBuilder builder) {",
+            "      configureInitialization(builder);",
+            "      initialize(builder);",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize(final LeafBuilder builder) {",
+            "      DelegateProducer.setDelegate(",
+            "          setOfResponseProducer,",
+            "          SetProducer.<Response>builder(1, 1)",
+            "              .addCollectionProducer(super.getSetOfResponseProducer())",
+            "              .addProducer(DaggerRoot.this.responseProducer)",
+            "              .build());",
+            "    }",
+            "",
+            "    @Override",
+            "    protected Provider<Executor> getProductionImplementationExecutorProvider() {",
+            "      return DaggerRoot.this.productionImplementationExecutorProvider;",
+            "    }",
+            "",
+            "    @Override",
+            "    protected Provider<ProductionComponentMonitor>",
+            "        getProductionComponentMonitorProvider() {",
+            "      return DaggerRoot.this.monitorProvider;",
+            "    }",
+            "",
+            "    @Override",
+            "    protected Producer getResponseDependencyProducer() {",
+            "      return DaggerRoot.this.responseDependencyProducer;",
+            "    }",
+            "",
+            "    @Override",
+            "    protected Producer getSetOfResponseProducer() {",
+            "      return setOfResponseProducer;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
+  @Test
+  public void producesMethodInstalledInLeafAndAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent(modules = InstalledInLeafAndAncestorModule.class)",
+            "interface Leaf {",
+            "  Producer<Object> producer();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.InstalledInLeafAndAncestorModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class InstalledInLeafAndAncestorModule {",
+            "  @Produces",
+            "  static Object producer() {",
+            "    return new Object();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.CancellationListener;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Executor;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf, CancellationListener {",
+            "  private Producer<Object> producerEntryPoint;",
+            "",
+            "  private InstalledInLeafAndAncestorModule_ProducerFactory producerProducer;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.producerProducer =",
+            "        InstalledInLeafAndAncestorModule_ProducerFactory.create(",
+            "            getProductionImplementationExecutorProvider(),",
+            "            getProductionComponentMonitorProvider());",
+            "    this.producerEntryPoint = Producers.entryPointViewOf(getObjectProducer(), this);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Producer<Object> producer() {",
+            "    return producerEntryPoint;",
+            "  }",
+            "",
+            "  protected abstract Provider<Executor>",
+            "    getProductionImplementationExecutorProvider();",
+            "",
+            "  protected abstract Provider<ProductionComponentMonitor> ",
+            "      getProductionComponentMonitorProvider();",
+            "",
+            "  protected Producer<Object> getObjectProducer() {",
+            "    return producerProducer;",
+            "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            "    Producers.cancel(getObjectProducer(), mayInterruptIfRunning);",
+            "  }",
+            "}");
+
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent(modules = InstalledInLeafAndAncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.CancellationListener;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Executor;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor, CancellationListener {",
+            "  private InstalledInLeafAndAncestorModule_ProducerFactory producerProducer;",
+            "",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected void configureInitialization() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.producerProducer =",
+            "        InstalledInLeafAndAncestorModule_ProducerFactory.create(",
+            "            getProductionImplementationExecutorProvider(),",
+            "            getProductionComponentMonitorProvider());",
+            "  }",
+            "",
+            "  protected abstract Provider<Executor>",
+            "    getProductionImplementationExecutorProvider();",
+            "",
+            "  protected abstract Provider<ProductionComponentMonitor>",
+            "      getProductionComponentMonitorProvider();",
+            "",
+            "  protected Producer<Object> getObjectProducer() {",
+            "    return producerProducer;",
+            "  }",
+            "",
+            "  protected Producer<Object> getObjectProducer2() {",
+            "    return getObjectProducer();",
+            "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            "    Producers.cancel(getObjectProducer(), mayInterruptIfRunning);",
+            "  }",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf ",
+            "      implements CancellationListener {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected final Producer<Object> getObjectProducer() {",
+            "      return DaggerAncestor.this.getObjectProducer();",
+            "    }",
+            "",
+            "    @Override",
+            "    public final Producer<Object> producer() {",
+            "      return DaggerAncestor.this.getObjectProducer2();",
+            "    }",
+            "  }",
+            "}");
+
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void lazyOfModifiableBinding() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "MissingInLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Lazy;",
+            "import dagger.Subcomponent;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Lazy<MissingInLeaf> lazy();",
+            "  Provider<Lazy<MissingInLeaf>> providerOfLazy();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.Lazy;",
+            "import dagger.internal.DoubleCheck;",
+            "import dagger.internal.ProviderOfLazy;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Lazy<MissingInLeaf> lazy() {",
+            "    return DoubleCheck.lazy(getMissingInLeafProvider());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<Lazy<MissingInLeaf>> providerOfLazy() {",
+            "    return ProviderOfLazy.create(getMissingInLeafProvider());",
+            "  }",
+            "",
+            "  protected abstract Provider getMissingInLeafProvider();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static MissingInLeaf satisfiedInAncestor() { return new MissingInLeaf(); }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected final Provider getMissingInLeafProvider() {",
+            "      return AncestorModule_SatisfiedInAncestorFactory.create();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void missingBindingAccessInLeafAndAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile, "Missing", "DependsOnMissing", "ProvidedInAncestor_InducesSetBinding");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.Provides;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  static DependsOnMissing test(",
+            "      Missing missing,",
+            "      Provider<Missing> missingProvider,",
+            "      ProvidedInAncestor_InducesSetBinding missingInLeaf) {",
+            "    return new DependsOnMissing();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Object unresolvedSetBinding(",
+            "      Missing missing, Provider<Missing> missingProvider) {",
+            "    return new Object();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  DependsOnMissing instance();",
+            "  Provider<DependsOnMissing> frameworkInstance();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private LeafModule_TestFactory testProvider;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.testProvider =",
+            "        LeafModule_TestFactory.create(",
+            "            getMissingProvider(), getProvidedInAncestor_InducesSetBindingProvider());",
+            "  }",
+            "",
+            "  @Override",
+            "  public DependsOnMissing instance() {",
+            "    return LeafModule_TestFactory.proxyTest(",
+            "        getMissing(),",
+            "        getMissingProvider(),",
+            "        getProvidedInAncestor_InducesSetBinding());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<DependsOnMissing> frameworkInstance() {",
+            "    return testProvider;",
+            "  }",
+            "",
+            "  protected abstract Object getMissing();",
+            "  protected abstract Provider getMissingProvider();",
+            "  protected abstract Object getProvidedInAncestor_InducesSetBinding();",
+            "  protected abstract Provider getProvidedInAncestor_InducesSetBindingProvider();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.Provides;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface AncestorModule {",
+            "  @Provides",
+            "  static ProvidedInAncestor_InducesSetBinding providedInAncestor(",
+            "      Set<Object> setThatInducesMissingBindingInChildSubclassImplementation) {",
+            "    return new ProvidedInAncestor_InducesSetBinding();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Object setContribution() {",
+            "    return new Object();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.internal.DelegateFactory;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private LeafModule_UnresolvedSetBindingFactory unresolvedSetBindingProvider;",
+            "",
+            "    private Provider<Set<Object>> setOfObjectProvider;",
+            "",
+            "    private Provider<ProvidedInAncestor_InducesSetBinding> ",
+            "        providedInAncestorProvider = ",
+            "            new DelegateFactory<>();",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected void configureInitialization() {",
+            "      super.configureInitialization();",
+            "      initialize();",
+            "    }",
+            "",
+            "    private Object getObject() {",
+            "      return LeafModule_UnresolvedSetBindingFactory.proxyUnresolvedSetBinding(",
+            "          getMissing(), getMissingProvider());",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      this.unresolvedSetBindingProvider =",
+            "          LeafModule_UnresolvedSetBindingFactory.create(getMissingProvider());",
+            "      this.setOfObjectProvider =",
+            "          SetFactory.<Object>builder(2, 0)",
+            "              .addProvider(AncestorModule_SetContributionFactory.create())",
+            "              .addProvider(unresolvedSetBindingProvider)",
+            "              .build();",
+            "      DelegateFactory.setDelegate(",
+            "          providedInAncestorProvider,",
+            "          AncestorModule_ProvidedInAncestorFactory.create(getSetOfObjectProvider()));",
+
+            "    }",
+            "",
+            "    protected Set<Object> getSetOfObject() {",
+            "      return ImmutableSet.<Object>of(",
+            "          AncestorModule_SetContributionFactory.proxySetContribution(), getObject());",
+            "    }",
+            "",
+            "    @Override",
+            "    protected final Object getProvidedInAncestor_InducesSetBinding() {",
+            "      return AncestorModule_ProvidedInAncestorFactory.proxyProvidedInAncestor(",
+            "          getSetOfObject());",
+            "    }",
+            "",
+            "    protected Provider<Set<Object>> getSetOfObjectProvider() {",
+            "      return setOfObjectProvider;",
+            "    }",
+            "",
+            "    @Override",
+            "    protected final Provider getProvidedInAncestor_InducesSetBindingProvider() {",
+            "      return providedInAncestorProvider;",
+            "    }",
+            "  }",
+           "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void subcomponentBuilders() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InducesDependenciesOnBuilderFields");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  private final Object object;",
+            "",
+            "  LeafModule(Object object) {",
+            "    this.object = object;",
+            "  }",
+            "",
+            "  @Provides",
+            "  Object fromModule() {",
+            "    return object;",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingsModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "interface MultibindingsModule {",
+            "  @Binds",
+            "  @IntoSet",
+            "  String string(String string);",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Subcomponent;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = {LeafModule.class, MultibindingsModule.class})",
+            "interface Leaf {",
+            "  int bindsInstance();",
+            "  Object fromModule();",
+            "  InducesDependenciesOnBuilderFields inducesDependenciesOnBuilderFields();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder bindsInstance(int boundInstance);",
+            "    @BindsInstance Builder inducedInSubclass(String induced);",
+            "    Builder module(LeafModule module);",
+            "",
+            "    Leaf build();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private Integer bindsInstance;",
+            "  private LeafModule leafModule;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization(Builder builder) {",
+            "    this.bindsInstance = builder.bindsInstance;",
+            "    this.leafModule = builder.leafModule;",
+            "  }",
+            "",
+            "  @Override",
+            "  public int bindsInstance() {",
+            "    return bindsInstance;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Object fromModule() {",
+            "    return LeafModule_FromModuleFactory.proxyFromModule(leafModule());",
+            "  }",
+            "",
+            "  protected LeafModule leafModule() {",
+            "    return leafModule;",
+            "  }",
+            "",
+            "  public abstract static class Builder implements Leaf.Builder {",
+            "    public LeafModule leafModule;",
+            "    public Integer bindsInstance;",
+            "    public String inducedInSubclass;",
+            "",
+            "    @Override",
+            "    public Builder bindsInstance(int boundInstance) {",
+            "      this.bindsInstance = Preconditions.checkNotNull(boundInstance);",
+            "      return this;",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder inducedInSubclass(String induced) {",
+            "      this.inducedInSubclass = Preconditions.checkNotNull(induced);",
+            "      return this;",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder module(LeafModule module) {",
+            "      this.leafModule = Preconditions.checkNotNull(module);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = MultibindingInducingModule.class)",
+            "interface Ancestor {",
+            "  Leaf.Builder leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingInducingModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import dagger.Provides;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface MultibindingInducingModule {",
+            "  @Provides",
+            "  static InducesDependenciesOnBuilderFields induce(",
+            "      Set<String> multibindingWithBuilderFieldDeps) { ",
+            "    return new InducesDependenciesOnBuilderFields();",
+            "  }",
+            "",
+            "  @Multibinds",
+            "  Set<String> multibinding();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private String inducedInSubclass;",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected void configureInitialization(DaggerLeaf.Builder builder) {",
+            "      this.inducedInSubclass = builder.inducedInSubclass;",
+            "      super.configureInitialization(builder);",
+            "    }",
+            "",
+            "    protected Set<String> getSetOfString() {",
+            "      return ImmutableSet.<String>of(inducedInSubclass);",
+            "    }",
+            "",
+            "    @Override",
+            "    public final InducesDependenciesOnBuilderFields",
+            "        inducesDependenciesOnBuilderFields() {",
+            "      return MultibindingInducingModule_InduceFactory.proxyInduce(getSetOfString());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Root {",
+            "  Ancestor ancestor();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Ancestor ancestor() {",
+            "    return new AncestorImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  protected final class AncestorImpl extends DaggerAncestor {",
+            "    private AncestorImpl() {}",
+            "",
+            "    @Override",
+            "    public Leaf.Builder leaf() {",
+            "      return new LeafBuilder();",
+            "    }",
+            "",
+            "    private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "      @Override",
+            "      public Leaf build() {",
+            // TODO(b/117833324): Can we stick the validations into a method on the base class
+            // builder so that the contents of this method are just call to that and then new
+            // FooImpl? But repeated modules may make this more complicated, since those *should*
+            // be null
+            "        Preconditions.checkBuilderRequirement(leafModule, LeafModule.class);",
+            "        Preconditions.checkBuilderRequirement(bindsInstance, Integer.class);",
+            "        Preconditions.checkBuilderRequirement(inducedInSubclass, String.class);",
+            "        return new LeafImpl(this);",
+            "      }",
+            "    }",
+            "",
+            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      private LeafModule leafModule;",
+            "",
+            "      private LeafImpl(LeafBuilder builder) {",
+            "        this.leafModule = builder.leafModule;",
+            "        configureInitialization(builder);",
+            "      }",
+            "",
+            "      @Override",
+            "      protected LeafModule leafModule() {",
+            "        return leafModule;",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
+  @Test
+  public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Used", "Unused");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ModuleWithUsedBinding",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ModuleWithUsedBinding {",
+            "  @Provides",
+            "  Used used() {",
+            "    return new Used();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.ModuleWithUnusedBinding",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ModuleWithUnusedBinding {",
+            "  @Provides",
+            "  Unused unused() {",
+            "    return new Unused();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = {ModuleWithUsedBinding.class, ModuleWithUnusedBinding.class})",
+            "interface Leaf {",
+            "  Used used();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Leaf build();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private ModuleWithUsedBinding moduleWithUsedBinding;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization(Builder builder) {",
+            "    this.moduleWithUsedBinding = builder.moduleWithUsedBinding;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Used used() {",
+            "    return ModuleWithUsedBinding_UsedFactory.proxyUsed(",
+            "        moduleWithUsedBinding());",
+            "  }",
+            "",
+            "  protected ModuleWithUsedBinding moduleWithUsedBinding() {",
+            "    return moduleWithUsedBinding;",
+            "  }",
+            "",
+            "  public abstract static class Builder implements Leaf.Builder {",
+            "    public ModuleWithUsedBinding moduleWithUsedBinding;",
+            "    public ModuleWithUnusedBinding moduleWithUnusedBinding;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Root {",
+            "  Leaf.Builder leaf();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf.Builder leaf() {",
+            "    return new LeafBuilder();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "    @Override",
+            "    public Leaf build() {",
+            "      if (moduleWithUsedBinding == null) {",
+            "        this.moduleWithUsedBinding = new ModuleWithUsedBinding();",
+            "      }",
+            // ModuleWithUnusedBinding is not verified since it's not used
+            "      return new LeafImpl(this);",
+            "    }",
+            "  }",
+            "",
+            "  protected final class LeafImpl extends DaggerLeaf {",
+            "    private ModuleWithUsedBinding moduleWithUsedBinding;",
+            "",
+            "    private LeafImpl(LeafBuilder builder) {",
+            "      this.moduleWithUsedBinding = builder.moduleWithUsedBinding;",
+            "      configureInitialization(builder);",
+            "    }",
+            "",
+            "    @Override",
+            "    protected ModuleWithUsedBinding moduleWithUsedBinding() {",
+            "      return moduleWithUsedBinding;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
+  @Test
+  public void subcomponentBuilders_repeatedModule() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.RepeatedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class RepeatedModule {",
+            "  @Provides",
+            "  int i() {",
+            "    return 1;",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = RepeatedModule.class)",
+            "interface Leaf {",
+            "  int i();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder repeatedModule(RepeatedModule repeatedModule);",
+            "    Leaf build();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private RepeatedModule repeatedModule;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization(Builder builder) {",
+            "    this.repeatedModule = builder.repeatedModule;",
+            "  }",
+            "",
+            "  @Override",
+            "  public int i() {",
+            "    return repeatedModule().i();",
+            "  }",
+            "",
+            "  protected RepeatedModule repeatedModule() {",
+            "    return repeatedModule;",
+            "  }",
+            "",
+            "  public abstract static class Builder implements Leaf.Builder {",
+            "    public RepeatedModule repeatedModule;",
+            "",
+            "    @Override",
+            "    public Builder repeatedModule(RepeatedModule repeatedModule) {",
+            "      this.repeatedModule = Preconditions.checkNotNull(repeatedModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = RepeatedModule.class)",
+            "interface Root {",
+            "  Leaf.Builder leaf();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private RepeatedModule repeatedModule;",
+            "",
+            "  private DaggerRoot(Builder builder) {",
+            "    this.repeatedModule = builder.repeatedModule;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf.Builder leaf() {",
+            "    return new LeafBuilder();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private RepeatedModule repeatedModule;",
             "",
-            "@Module",
-            "class GreatGrandchildModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"great-grandchild\")",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      if (repeatedModule == null) {",
+            "        this.repeatedModule = new RepeatedModule();",
+            "      }",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "",
+            "    public Builder repeatedModule(RepeatedModule repeatedModule) {",
+            "      this.repeatedModule = Preconditions.checkNotNull(repeatedModule);",
+            "      return this;",
+            "    }",
             "  }",
             "",
-            "  @Provides",
-            "  static RequiresUnsatisfiedMap providesRequiresNonComponentMethodMap(",
-            "      Map<String, Unsatisfied> unsatisfiedMap) {",
-            "    return new RequiresUnsatisfiedMap();",
+            "  private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "    @Override",
+            "    public Leaf build() {",
+            "      return new LeafImpl(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public LeafBuilder repeatedModule(RepeatedModule repeatedModule) {",
+            "      throw new UnsupportedOperationException(",
+            "        String.format(",
+            "          \"%s cannot be set because it is inherited from the enclosing component\",",
+            "          RepeatedModule.class.getCanonicalName()));",
+            "    }",
             "  }",
             "",
-            "  @Provides",
-            "  static RequiresInAllSubcomponentsMap providesRequiresComponentMethodMap(",
-            "      Map<String, InAllSubcomponents> inAllSubcomponentsMap) {",
-            "    return new RequiresInAllSubcomponentsMap();",
+            "  protected final class LeafImpl extends DaggerLeaf {",
+            "    private LeafImpl(LeafBuilder builder) {",
+            "      configureInitialization(builder);",
+            "    }",
+            "",
+            "    @Override",
+            "    protected RepeatedModule repeatedModule() {",
+            "      return DaggerRoot.this.repeatedModule;",
+            "    }",
             "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
+  @Test
+  public void bindsWithMissingDependency() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "MissingInLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Binds;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Binds Object missingBindsDependency(MissingInLeaf missing);",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Object bindsWithMissingDependencyInLeaf();",
             "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
-    JavaFileObject generatedGreatGrandchild =
+    filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.DaggerGreatGrandchild",
+            "test.MissingInLeafModule",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "interface MissingInLeafModule {",
+            "  @Provides",
+            "  static MissingInLeaf boundInRoot() {",
+            "    return new MissingInLeaf();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = MissingInLeafModule.class)",
+            "interface Root {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
             "",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
-            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
             "",
-            "  @Override",
-            "  public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
-            "    return ImmutableMap.<String, InAllSubcomponents>of(",
-            "        \"great-grandchild\",",
-            "        GreatGrandchildModule_ProvideInAllSubcomponentsFactory",
-            "            .proxyProvideInAllSubcomponents());",
+            "  public static Builder builder() {",
+            "    return new Builder();",
             "  }",
             "",
-            "  @Override",
-            "  public RequiresUnsatisfiedMap requiresNonComponentMethodMap() {",
-            "    return GreatGrandchildModule_ProvidesRequiresNonComponentMethodMapFactory",
-            "        .proxyProvidesRequiresNonComponentMethodMap(getMap());",
+            "  public static Root create() {",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
-            "  public RequiresInAllSubcomponentsMap requiresComponentMethodMap() {",
-            "    return GreatGrandchildModule_ProvidesRequiresComponentMethodMapFactory",
-            "        .proxyProvidesRequiresComponentMethodMap(contributionsAtAllLevels());",
+            "  public Leaf leaf() {",
+            "    return new LeafImpl();",
             "  }",
             "",
-            "  public abstract Map<String, Unsatisfied> getMap();",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
             "",
-            "  protected abstract static class Builder implements GreatGrandchild.Builder {",
+            "  protected final class LeafImpl extends DaggerLeaf {",
+            "    private LeafImpl() {}",
             "",
             "    @Override",
-            "    public Builder module(GreatGrandchildModule module) {",
-            "      return this;",
+            "    public Object bindsWithMissingDependencyInLeaf() {",
+            "      return MissingInLeafModule_BoundInRootFactory.proxyBoundInRoot();",
             "    }",
             "  }",
             "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
 
+  @Test
+  public void bindsWithMissingDependency_pruned() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "MissingInLeaf");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Grandchild",
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Binds;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Binds Object missingBindsDependency(MissingInLeaf missing);",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.DependsOnBindsWithMissingDep",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class DependsOnBindsWithMissingDep {",
+            "  @Inject DependsOnBindsWithMissingDep(Object bindsWithMissingDep) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = GrandchildModule.class)",
-            "interface Grandchild {",
-            "  GreatGrandchild.Builder greatGrandchild();",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  DependsOnBindsWithMissingDep DependsOnBindsWithMissingDep();",
             "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public DependsOnBindsWithMissingDep DependsOnBindsWithMissingDep() {",
+            "    return new DependsOnBindsWithMissingDep(getObject());",
+            "  }",
+            "",
+            "  protected abstract Object getObject();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
+            "test.PrunesInjectConstructorModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
             "",
             "@Module",
-            "class GrandchildModule {",
+            "interface PrunesInjectConstructorModule {",
             "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"grandchild\")",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
+            "  static DependsOnBindsWithMissingDep pruneInjectConstructor() {",
+            "    return new DependsOnBindsWithMissingDep(new Object());",
             "  }",
-            "}"));
-
-    JavaFileObject generatedGrandchild =
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.DaggerGrandchild",
+            "test.Root",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = PrunesInjectConstructorModule.class)",
+            "interface Root {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
             "",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandchild implements Grandchild {",
-            "  protected DaggerGrandchild() {}",
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
             "",
-            "  protected abstract class GreatGrandchildBuilder extends",
-            "      DaggerGreatGrandchild.Builder {",
-            "    @Override",
-            "    public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
-            "      return this;",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf leaf() {",
+            "    return new LeafImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
             "    }",
             "  }",
             "",
-            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
-            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "      super(builder);",
+            "  protected final class LeafImpl extends DaggerLeaf {",
+            "    private LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected Object getObject() {",
+            "      " + PRUNED_METHOD_BODY,
             "    }",
             "",
             "    @Override",
-            "    public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
-            "      return ImmutableMap.<String, InAllSubcomponents>builderWithExpectedSize(2)",
-            "          .put(\"grandchild\",",
-            "              GrandchildModule_ProvideInAllSubcomponentsFactory",
-            "                  .proxyProvideInAllSubcomponents())",
-            "          .putAll(super.contributionsAtAllLevels())",
-            "          .build();",
+            "    public DependsOnBindsWithMissingDep DependsOnBindsWithMissingDep() {",
+            "      return PrunesInjectConstructorModule_PruneInjectConstructorFactory",
+            "          .proxyPruneInjectConstructor();",
             "    }",
             "  }",
             "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
 
+  @Test
+  public void modifiedProducerFromProvider() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "DependsOnModifiedProducerFromProvider");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Child",
+            "test.LeafModule",
             "package test;",
             "",
-            "import dagger.Subcomponent;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.Provides;",
+            "import java.util.Set;",
+            "",
+            "@ProducerModule",
+            "interface LeafModule {",
+            "  @Produces",
+            "  static DependsOnModifiedProducerFromProvider dependsOnModified(Set<String> set) {",
+            "    return new DependsOnModifiedProducerFromProvider();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.ProductionSubcomponent;",
+            "import java.util.Set;",
             "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
+            "@ProductionSubcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Producer<DependsOnModifiedProducerFromProvider>",
+            "      dependsOnModifiedProducerFromProvider();",
             "}"));
 
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.CancellationListener;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.Set;",
+            "import java.util.concurrent.Executor;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf, CancellationListener {",
+            "  private Producer<DependsOnModifiedProducerFromProvider>",
+            "      dependsOnModifiedProducerFromProviderEntryPoint;",
+            "  private LeafModule_DependsOnModifiedFactory dependsOnModifiedProducer;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.dependsOnModifiedProducer =",
+            "        LeafModule_DependsOnModifiedFactory.create(",
+            "            getProductionImplementationExecutorProvider(),",
+            "            getProductionComponentMonitorProvider(),",
+            "            getSetOfStringProducer());",
+            "    this.dependsOnModifiedProducerFromProviderEntryPoint =",
+            "        Producers.entryPointViewOf(",
+            "            getDependsOnModifiedProducerFromProviderProducer(), this);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Producer<DependsOnModifiedProducerFromProvider> ",
+            "      dependsOnModifiedProducerFromProvider() {",
+            "    return dependsOnModifiedProducerFromProviderEntryPoint;",
+            "  }",
+            "",
+            "  protected abstract Provider<Executor> ",
+            "      getProductionImplementationExecutorProvider();",
+            "",
+            "  protected abstract Provider<ProductionComponentMonitor>",
+            "      getProductionComponentMonitorProvider();",
+            "",
+            "  protected abstract Producer<Set<String>> getSetOfStringProducer();",
+            "",
+            "  protected Producer getDependsOnModifiedProducerFromProviderProducer() {",
+            "    return dependsOnModifiedProducer;",
+            "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            "    Producers.cancel(",
+            "      getDependsOnModifiedProducerFromProviderProducer(), mayInterruptIfRunning);",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.ChildModule",
+            "test.RootModule",
             "package test;",
             "",
+            "import dagger.multibindings.IntoSet;",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
+            "import dagger.producers.Production;",
+            "import java.util.Set;",
+            "import java.util.concurrent.Executor;",
             "",
             "@Module",
-            "class ChildModule {",
+            "interface RootModule {",
             "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"child\")",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
+            "  @IntoSet",
+            "  static String induceModificationInLeaf() {",
+            "    return new String();",
             "  }",
-            "}"));
-
-    JavaFileObject generatedChild =
+            "",
+            "  @Provides",
+            "  @Production",
+            "  static Executor productionExecutor() {",
+            "    return null;",
+            "  }",
+            "}"),
         JavaFileObjects.forSourceLines(
-            "test.DaggerChild",
+            "test.Root",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = RootModule.class)",
+            "interface Root {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
             "",
+            "import dagger.internal.DelegateFactory;",
+            "import dagger.internal.DoubleCheck;",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.SetFactory;",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.CancellationListener;",
+            "import dagger.producers.internal.DelegateProducer;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.Set;",
+            "import java.util.concurrent.Executor;",
             IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerChild implements Child {",
-            "  protected DaggerChild() {}",
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf leaf() {",
+            "    return new LeafImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
             "",
-            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
-            "    protected GrandchildImpl() {",
-            "      super();",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
             "    }",
+            "  }",
             "",
-            "    protected abstract class GreatGrandchildBuilder",
-            "        extends DaggerGrandchild.GreatGrandchildBuilder {",
-            "      @Override",
-            "      public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
-            "        return this;",
-            "      }",
+            "  protected final class LeafImpl extends DaggerLeaf implements CancellationListener {",
+            "    private Provider<Executor> productionImplementationExecutorProvider =",
+            "        new DelegateFactory<>();",
+            "    private Provider<Leaf> leafProvider;",
+            "    private Provider<ProductionComponentMonitor> monitorProvider =",
+            "        new DelegateFactory<>();",
+            "    private Provider<Set<String>> setOfStringProvider;",
+            "    private Producer<Set<String>> setOfStringProducer = new DelegateProducer<>();",
+            "",
+            "    private LeafImpl() {",
+            "      configureInitialization();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      DelegateFactory.setDelegate(",
+            "          productionImplementationExecutorProvider,",
+            "          DoubleCheck.provider(",
+            "              (Provider) RootModule_ProductionExecutorFactory.create()));",
+            "      this.leafProvider = InstanceFactory.create((Leaf) this);",
+            "      DelegateFactory.setDelegate(",
+            "          monitorProvider,",
+            "          DoubleCheck.provider(",
+            "              Leaf_MonitoringModule_MonitorFactory.create(",
+            "                  leafProvider, getSetOfFactoryProvider())));",
+            "      this.setOfStringProvider =",
+            "          SetFactory.<String>builder(1, 0)",
+            "              .addProvider(RootModule_InduceModificationInLeafFactory.create())",
+            "              .build();",
+            "      DelegateProducer.setDelegate(",
+            "          setOfStringProducer,",
+            "          Producers.producerFromProvider(getSetOfStringProvider()));",
+            "    }",
+            "",
+            "    @Override",
+            "    protected Provider<Executor> getProductionImplementationExecutorProvider() {",
+            "      return productionImplementationExecutorProvider;",
+            "    }",
+            "",
+            "    protected Provider<Set<ProductionComponentMonitor.Factory>> ",
+            "        getSetOfFactoryProvider() {",
+            "      return SetFactory.<ProductionComponentMonitor.Factory>empty();",
+            "    }",
+            "",
+            "    @Override",
+            "    protected Provider<ProductionComponentMonitor> ",
+            "        getProductionComponentMonitorProvider() {",
+            "      return monitorProvider;",
+            "    }",
+            "",
+            "    protected Provider<Set<String>> getSetOfStringProvider() {",
+            "      return setOfStringProvider;",
             "    }",
             "",
-            "    public abstract class GreatGrandchildImpl extends",
-            "        DaggerGrandchild.GreatGrandchildImpl {",
-            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
-            "        super(builder);",
-            "      }",
+            "    @Override",
+            "    protected Producer<Set<String>> getSetOfStringProducer() {",
+            "      return setOfStringProducer;",
+            "    }",
             "",
-            "      @Override",
-            "      public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
-            "        return ImmutableMap.<String, InAllSubcomponents>builderWithExpectedSize(3)",
-            "            .put(\"child\",",
-            "                ChildModule_ProvideInAllSubcomponentsFactory",
-            "                    .proxyProvideInAllSubcomponents())",
-            "            .putAll(super.contributionsAtAllLevels())",
-            "            .build();",
-            "      }",
+            "    @Override",
+            "    public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            "      super.onProducerFutureCancelled(mayInterruptIfRunning);",
+            "      Producers.cancel(getSetOfStringProducer(), mayInterruptIfRunning);",
             "    }",
+            "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
-            .compile(filesToCompile.build().toArray(new JavaFileObject[0]));
+    compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerGreatGrandchild")
-        .hasSourceEquivalentTo(generatedGreatGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandchild")
-        .hasSourceEquivalentTo(generatedGrandchild);
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerChild")
-        .hasSourceEquivalentTo(generatedChild);
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
   }
 
   @Test
-  public void provisionOverInjection_providedInAncestor() {
+  public void bindsMissingDep_Multibindings() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.ProvidedInAncestor",
+            "test.LeafModule",
             "package test;",
             "",
-            "import javax.inject.Inject;",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
             "",
-            "class ProvidedInAncestor {",
-            "  @Inject",
-            "  ProvidedInAncestor(String string) {}",
+            "@Module",
+            "interface LeafModule {",
+            "  @Binds",
+            "  @IntoSet",
+            "  CharSequence bindsMultibindingWithMissingDep(String string);",
             "}"),
         JavaFileObjects.forSourceLines(
             "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
+            "import java.util.Set;",
             "",
-            "@Subcomponent",
+            "@Subcomponent(modules = LeafModule.class)",
             "interface Leaf {",
-            "  ProvidedInAncestor injectedInLeaf();",
+            "  Set<CharSequence> set();",
             "}"));
+
     JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
             "test.DaggerLeaf",
             "package test;",
             "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
@@ -2468,84 +6664,64 @@ public void provisionOverInjection_providedInAncestor() {
             "  protected DaggerLeaf() {}",
             "",
             "  @Override",
-            "  public ProvidedInAncestor injectedInLeaf() {",
-            "    return new ProvidedInAncestor(getString());",
+            "  public Set<CharSequence> set() {",
+            "    return ImmutableSet.<CharSequence>of(getCharSequence());",
             "  }",
             "",
-            "  public abstract String getString();",
+            // The expected output here is subtle: the Key of
+            // LeafModule.bindsMultibindingWithMissingDep() is Set<CharSequence>, but the binding
+            // method should only be returning an individual CharSequence. Otherwise the
+            // ImmutableSet factory method above will fail.
+            // TODO(b/117833324): It would be great to get this method name to match the binding
+            // element name
+            "  protected abstract CharSequence getCharSequence();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerLeaf")
         .hasSourceEquivalentTo(generatedLeaf);
+  }
 
+  @Test
+  public void modifiableBindingMethods_namesDedupedAcrossImplementations() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Ancestor",
+            "foo.Thing",
+            "package foo;",
+            "", // force multi-line format
+            "public interface Thing extends CharSequence {}"),
+        JavaFileObjects.forSourceLines(
+            "bar.Thing",
+            "package bar;",
+            "", // force multi-line format
+            "public interface Thing extends Runnable {}"),
+        JavaFileObjects.forSourceLines(
+            "test.WillInduceSetOfRunnable",
             "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
+            "", // force multi-line format
+            "class WillInduceSetOfRunnable {}"),
         JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
+            "test.LeafModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
             "",
             "@Module",
-            "class AncestorModule {",
+            "interface LeafModule {",
             "  @Provides",
-            "  static ProvidedInAncestor provideProvidedInAncestor() {",
-            "    return new ProvidedInAncestor(\"static\");",
+            "  static CharSequence depOnFooThing(foo.Thing thing) {",
+            "    return thing.toString();",
             "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  public abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() { super(); }",
             "",
-            "    @Override",
-            "    public ProvidedInAncestor injectedInLeaf() {",
-            "      return AncestorModule_ProvideProvidedInAncestorFactory",
-            "          .proxyProvideProvidedInAncestor();",
-            "    }",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Runnable depOnBarThing(bar.Thing thing) {",
+            "    return () -> {};",
             "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void provisionOverInjection_providedInGrandAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.ProvidedInGrandAncestor",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class ProvidedInGrandAncestor {",
-            "  @Inject",
-            "  ProvidedInGrandAncestor(String string) {}",
             "}"),
         JavaFileObjects.forSourceLines(
             "test.Leaf",
@@ -2553,15 +6729,18 @@ public void provisionOverInjection_providedInGrandAncestor() {
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent",
+            "@Subcomponent(modules = LeafModule.class)",
             "interface Leaf {",
-            "  ProvidedInGrandAncestor injectedInLeaf();",
+            "  CharSequence inducesFoo();",
+            "  WillInduceSetOfRunnable willInduceSetOfRunnable();",
             "}"));
+
     JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
             "test.DaggerLeaf",
             "package test;",
             "",
+            "import foo.Thing;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
@@ -2569,11 +6748,11 @@ public void provisionOverInjection_providedInGrandAncestor() {
             "  protected DaggerLeaf() {}",
             "",
             "  @Override",
-            "  public ProvidedInGrandAncestor injectedInLeaf() {",
-            "    return new ProvidedInGrandAncestor(getString());",
+            "  public CharSequence inducesFoo() {",
+            "    return LeafModule_DepOnFooThingFactory.proxyDepOnFooThing(getThing());",
             "  }",
             "",
-            "  public abstract String getString();",
+            "  protected abstract Thing getThing();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -2582,29 +6761,66 @@ public void provisionOverInjection_providedInGrandAncestor() {
         .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface AncestorModule {",
+            "  @Provides",
+            "  static WillInduceSetOfRunnable induce(Set<Runnable> set) {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Multibinds Set<Runnable> runnables();",
+            "}"),
         JavaFileObjects.forSourceLines(
             "test.Ancestor",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent",
+            "@Subcomponent(modules = AncestorModule.class)",
             "interface Ancestor {",
             "  Leaf leaf();",
             "}"));
+
     JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
             "test.DaggerAncestor",
             "package test;",
             "",
+            "import bar.Thing;",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
             "public abstract class DaggerAncestor implements Ancestor {",
             "  protected DaggerAncestor() {}",
             "",
-            "  public abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() { super(); }",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    private Runnable getRunnable() {",
+            "      return LeafModule_DepOnBarThingFactory.proxyDepOnBarThing(getThing2());",
+            "    }",
+            "",
+            "    protected abstract Thing getThing2();",
+            "",
+            "    protected Set<Runnable> getSetOfRunnable() {",
+            "      return ImmutableSet.<Runnable>of(getRunnable());",
+            "    }",
+            "",
+            "    @Override",
+            "    public final WillInduceSetOfRunnable willInduceSetOfRunnable() {",
+            "      return AncestorModule_InduceFactory.proxyInduce(getSetOfRunnable());",
+            "    }",
             "  }",
             "}");
     compilation = compile(filesToCompile.build());
@@ -2612,87 +6828,179 @@ public void provisionOverInjection_providedInGrandAncestor() {
     assertThat(compilation)
         .generatedSourceFile("test.DaggerAncestor")
         .hasSourceEquivalentTo(generatedAncestor);
+  }
 
+  /**
+   * This test verifies that Dagger can find the appropriate child subcomponent
+   * super-implementation, even if it is not enclosed in the current component's
+   * super-implementation. This can happen if a subcomponent is installed with a module's {@code
+   * subcomponents} attribute, but the binding is not accessed in a super-implementation. To exhibit
+   * this, we use multibindings that reference the pruned subcomponent, but make the multibinding
+   * also unresolved in the base implementation. An ancestor component defines a binding that
+   * depends on the multibinding, which induces the previously unresolved multibinding
+   * contributions, which itself induces the previously unresolved subcomponent.
+   */
+  @Test
+  public void subcomponentInducedFromAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Inducer");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GrandAncestor",
+            "test.InducedSubcomponent",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = GrandAncestorModule.class)",
-            "interface GrandAncestor {",
-            "  Ancestor ancestor();",
+            "@Subcomponent",
+            "interface InducedSubcomponent {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    InducedSubcomponent build();",
+            "  }",
             "}"),
         JavaFileObjects.forSourceLines(
-            "test.GrandAncestorModule",
+            "test.MaybeLeaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = InducedSubcomponentModule.class)",
+            "interface MaybeLeaf {",
+            "  Inducer inducer();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.MaybeLeaf",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module(subcomponents = InducedSubcomponent.class)",
+            "interface InducedSubcomponentModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Object inducedSet(InducedSubcomponent.Builder builder) {",
+            "    return new Object();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedMaybeLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerMaybeLeaf implements MaybeLeaf {",
+            "  protected DaggerMaybeLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerMaybeLeaf")
+        .hasSourceEquivalentTo(generatedMaybeLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
             "",
             "@Module",
-            "class GrandAncestorModule {",
+            "interface AncestorModule {",
             "  @Provides",
-            "  static ProvidedInGrandAncestor provideProvidedInGrandAncestor() {",
-            "    return new ProvidedInGrandAncestor(\"static\");",
+            "  static Inducer inducer(Set<Object> set) {",
+            "    return null;",
             "  }",
+            "",
+            "  @Multibinds Set<Object> set();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  MaybeLeaf noLongerLeaf();",
             "}"));
-    JavaFileObject generatedGrandAncestor =
+
+    JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGrandAncestor",
+            "test.DaggerAncestor",
             "package test;",
             "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
-            "  protected DaggerGrandAncestor() {}",
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
             "",
-            "  public abstract class AncestorImpl extends DaggerAncestor {",
-            "    protected AncestorImpl() { super(); }",
+            "  protected abstract class MaybeLeafImpl extends DaggerMaybeLeaf {",
+            "    protected MaybeLeafImpl() {}",
             "",
-            "    public abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      protected LeafImpl() { super(); }",
+            "    private Object getObject() {",
+            "      return InducedSubcomponentModule_InducedSetFactory.proxyInducedSet(",
+            "          getInducedSubcomponentBuilder());",
+            "    }",
             "",
-            "      @Override",
-            "      public ProvidedInGrandAncestor injectedInLeaf() {",
-            "        return GrandAncestorModule_ProvideProvidedInGrandAncestorFactory",
-            "            .proxyProvideProvidedInGrandAncestor();",
-            "      }",
+            "    protected abstract Object getInducedSubcomponentBuilder();",
+            "",
+            "    protected Set<Object> getSetOfObject() {",
+            "      return ImmutableSet.<Object>of(getObject());",
+            "    }",
+            "",
+            "    @Override",
+            "    public final Inducer inducer() {",
+            "      return AncestorModule_InducerFactory.proxyInducer(getSetOfObject());",
+            "    }",
+            "",
+            "    protected abstract class InducedSubcomponentImpl extends",
+            "        DaggerInducedSubcomponent {",
+            //       ^ Note that this is DaggerInducedSubcomponent, not
+            //         DaggerMaybeLeaf.InducedSubcomponentImpl
+            "      protected InducedSubcomponentImpl() {}",
             "    }",
             "  }",
             "}");
     compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandAncestor")
-        .hasSourceEquivalentTo(generatedGrandAncestor);
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
   }
 
   @Test
-  public void provisionOverInjection_indirectDependency() {
+  public void rootScopedAtInjectConstructor_effectivelyMissingInSubcomponent() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "ProvidesMethodRootScoped");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.ProvidedInAncestor",
+            "test.RootScope",
             "package test;",
             "",
-            "import javax.inject.Inject;",
+            "import javax.inject.Scope;",
             "",
-            "class ProvidedInAncestor {",
-            "  @Inject",
-            "  ProvidedInAncestor(String string) {}",
-            "}"),
+            "@Scope",
+            "public @interface RootScope {}"),
         JavaFileObjects.forSourceLines(
-            "test.InjectedInLeaf",
+            "test.AtInjectRootScoped",
             "package test;",
             "",
             "import javax.inject.Inject;",
             "",
-            "class InjectedInLeaf {",
-            "  @Inject",
-            "  InjectedInLeaf(ProvidedInAncestor providedInAncestor) {}",
+            "@RootScope",
+            "class AtInjectRootScoped {",
+            "  @Inject AtInjectRootScoped() {}",
             "}"),
         JavaFileObjects.forSourceLines(
             "test.Leaf",
@@ -2702,8 +7010,9 @@ public void provisionOverInjection_indirectDependency() {
             "",
             "@Subcomponent",
             "interface Leaf {",
-            "  InjectedInLeaf injectedInLeaf();",
+            "  AtInjectRootScoped shouldBeEffectivelyMissingInLeaf();",
             "}"));
+
     JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
             "test.DaggerLeaf",
@@ -2714,17 +7023,6 @@ public void provisionOverInjection_indirectDependency() {
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public InjectedInLeaf injectedInLeaf() {",
-            "    return new InjectedInLeaf(getProvidedInAncestor());",
-            "  }",
-            "",
-            "  public abstract String getString();",
-            "",
-            "  public ProvidedInAncestor getProvidedInAncestor() {",
-            "    return new ProvidedInAncestor(getString());",
-            "  }",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -2734,56 +7032,38 @@ public void provisionOverInjection_indirectDependency() {
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Ancestor",
+            "test.Leaf",
             "package test;",
             "",
-            "import dagger.Subcomponent;",
+            "import dagger.Component;",
             "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
+            "@RootScope",
+            "@Component",
+            "interface Root {",
             "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  static ProvidedInAncestor provideProvidedInAncestor() {",
-            "    return new ProvidedInAncestor(\"static\");",
-            "  }",
             "}"));
-    JavaFileObject generatedAncestor =
+
+    JavaFileObject generatedRoot =
         JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
+            "test.DaggerRoot",
             "package test;",
             "",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  public abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {",
-            "      super();",
-            "    }",
-            "",
+            "public final class DaggerRoot implements Root {",
+            "  protected final class LeafImpl extends DaggerLeaf {",
             "    @Override",
-            "    public ProvidedInAncestor getProvidedInAncestor() {",
-            "      return AncestorModule_ProvideProvidedInAncestorFactory",
-            "          .proxyProvideProvidedInAncestor();",
+            "    public AtInjectRootScoped shouldBeEffectivelyMissingInLeaf() {",
+            "      return DaggerRoot.this.atInjectRootScopedProvider.get();",
             "    }",
+            "  }",
             "}");
     compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
+        .generatedSourceFile("test.DaggerRoot")
+        .containsElementsIn(generatedRoot);
   }
 
   private void createAncillaryClasses(
@@ -2804,9 +7084,10 @@ private static Compilation compile(Iterable<JavaFileObject> files) {
         .compile(files);
   }
 
-  private static Compilation compile(JavaFileObject... files) {
+  private static Compilation compileWithoutGuava(Iterable<JavaFileObject> files) {
     return daggerCompiler()
-        .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+        .withOptions(
+            AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts().append(CLASS_PATH_WITHOUT_GUAVA_OPTION))
         .compile(files);
   }
 }
diff --git a/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidationTest.java b/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidationTest.java
index c268fa0ac..fa44a6e3d 100644
--- a/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidationTest.java
+++ b/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidationTest.java
@@ -16,10 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
 
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
 import dagger.Module;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
@@ -27,6 +31,7 @@
 import javax.inject.Inject;
 import javax.inject.Qualifier;
 import javax.inject.Singleton;
+import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -97,19 +102,57 @@ public void tooManyQualifiers() {
   @Test
   public void intoSet() {
     assertThatMethod("@BindsOptionalOf @IntoSet abstract String intoSet();")
-        .hasError("Multibinding annotations");
+        .hasError("cannot have multibinding annotations");
   }
 
   @Test
   public void elementsIntoSet() {
     assertThatMethod("@BindsOptionalOf @ElementsIntoSet abstract Set<String> elementsIntoSet();")
-        .hasError("Multibinding annotations");
+        .hasError("cannot have multibinding annotations");
   }
 
   @Test
   public void intoMap() {
     assertThatMethod("@BindsOptionalOf @IntoMap abstract String intoMap();")
-        .hasError("Multibinding annotations");
+        .hasError("cannot have multibinding annotations");
+  }
+
+  /**
+   * Tests that @BindsOptionalOf @IntoMap actually causes module validation to fail.
+   *
+   * @see <a href="http://b/118434447">bug 118434447</a>
+   */
+  @Test
+  public void intoMapWithComponent() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @BindsOptionalOf @IntoMap Object object();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {}");
+
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("cannot have multibinding annotations")
+        .inFile(module)
+        .onLineContaining("object();");
   }
 
   /** An injectable value object. */
diff --git a/javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java b/javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java
deleted file mode 100644
index fda3a04c0..000000000
--- a/javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests for {@link CanReleaseReferencesValidator}. */
-@RunWith(JUnit4.class)
-public final class CanReleaseReferencesValidationTest {
-  @Test
-  public void annotatesSourceRetainedAnnotation() {
-    JavaFileObject annotation =
-        JavaFileObjects.forSourceLines(
-            "test.Metadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import java.lang.annotation.RetentionPolicy;",
-            "",
-            "@CanReleaseReferences",
-            "@Retention(RetentionPolicy.SOURCE)",
-            "@interface Metadata {}");
-    Compilation compilation = daggerCompiler().compile(annotation);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("SOURCE").inFile(annotation).onLine(8);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/CodeBlocksTest.java b/javatests/dagger/internal/codegen/CodeBlocksTest.java
index 43507c9ea..ec8df912a 100644
--- a/javatests/dagger/internal/codegen/CodeBlocksTest.java
+++ b/javatests/dagger/internal/codegen/CodeBlocksTest.java
@@ -18,7 +18,6 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static dagger.internal.codegen.CodeBlocks.javadocLinkTo;
-import static dagger.internal.codegen.CodeBlocks.joiningCodeBlocks;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static javax.lang.model.element.ElementKind.METHOD;
 
@@ -64,12 +63,6 @@ public void testToParametersCodeBlock_oneElement() {
     assertThat(Stream.of(objectO).collect(toParametersCodeBlock())).isEqualTo(objectO);
   }
 
-  @Test
-  public void testJoiningCodeBlocks() {
-    assertThat(Stream.of(objectO, stringS, intI).collect(joiningCodeBlocks("!")))
-        .isEqualTo(CodeBlock.of("$T o!$T s!$T i", Object.class, String.class, int.class));
-  }
-
   @Test
   public void testJavadocLinkTo() {
     ExecutableElement equals =
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index d04c359a7..cc385249d 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -44,8 +44,8 @@ public ComponentBuilderTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  private static final ErrorMessages.ComponentBuilderMessages MSGS =
-      ErrorMessages.ComponentBuilderMessages.INSTANCE;
+  private static final ErrorMessages.ComponentCreatorMessages MSGS =
+      ErrorMessages.ComponentCreatorMessages.INSTANCE;
 
   @Test
   public void testEmptyBuilder() {
@@ -226,7 +226,8 @@ public void testIgnoresModulesNotInApi() {
             "  private TestModule2 testModule2;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
+            "    this.testModule1 = builder.testModule1;",
+            "    this.testModule2 = builder.testModule2;",
             "  }",
             "",
             "  public static TestComponent.Builder builder() {",
@@ -237,12 +238,6 @@ public void testIgnoresModulesNotInApi() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.testModule1 = builder.testModule1;",
-            "    this.testModule2 = builder.testModule2;",
-            "  }",
-            "",
             "  @Override",
             "  public String string() {",
             "    return TestModule1_StringFactory.proxyString(testModule1);",
@@ -414,18 +409,13 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "  private Object object;",
             "",
             "  private DaggerSimpleComponent(Builder builder) {",
-            "    initialize(builder);",
+            "    this.object = builder.object;",
             "  }",
             "",
             "  public static SimpleComponent.Builder builder() {",
             "    return new Builder();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.object = builder.object;",
-            "  }",
-            "",
             "  @Override",
             "  public Object object() {",
             "    return object;",
@@ -436,10 +426,7 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "",
             "    @Override",
             "    public SimpleComponent build() {",
-            "      if (object == null) {",
-            "        throw new IllegalStateException(",
-            "            Object.class.getCanonicalName() + \" must be set\")",
-            "      }",
+            "      Preconditions.checkBuilderRequirement(object, Object.class);",
             "      return new DaggerSimpleComponent(this);",
             "    }",
             "",
diff --git a/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
index 757d5d7cc..d8c784ba2 100644
--- a/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
+++ b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
@@ -123,4 +123,52 @@ public void productionComponents_productionScopeImplicitOnBoth() {
         daggerCompiler().compile(component, subcomponent, parentModule, childModule);
     assertThat(compilation).succeeded();
   }
+
+  @Test
+  public void factoryMethodForSubcomponentWithBuilder_isNotAllowed() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module(subcomponents = Sub.class)",
+            "class TestModule {",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface C {",
+            "  Sub newSub();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(module, component, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "Components may not have factory methods for subcomponents that define a builder.");
+  }
 }
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 43603c3e8..5dde439bd 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -27,22 +27,17 @@
 import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.MembersInjector;
-import java.io.IOException;
-import java.io.Writer;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.ProcessingEnvironment;
-import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.inject.Inject;
 import javax.lang.model.SourceVersion;
@@ -385,7 +380,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 "    @Override",
                 "    public T get() {",
                 "      switch (id) {",
-                "        case 0: return (T) someInjectableType();",
+                "        case 0: return (T) DaggerSimpleComponent.this.someInjectableType();",
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
@@ -515,13 +510,12 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private TestModule testModule;",
                 "",
-                "  private B getB() {",
-                "    return TestModule_BFactory.proxyB(testModule, new C());",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    this.testModule = builder.testModule;",
                 "  }",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
-                "    this.testModule = builder.testModule;",
+                "  private B getB() {",
+                "    return TestModule_BFactory.proxyB(testModule, new C());",
                 "  }",
                 "",
                 "  @Override",
@@ -1213,6 +1207,10 @@ public void testDefaultPackage() {
                 "  private volatile Provider<A> aProvider;",
                 "  private AComponent aComponent;",
                 "",
+                "  private DaggerBComponent(Builder builder) {",
+                "    this.aComponent = builder.aComponent;",
+                "  }",
+                "",
                 "  private Provider<A> getAProvider() {",
                 "    Object local = aProvider;",
                 "    if (local == null) {",
@@ -1221,17 +1219,13 @@ public void testDefaultPackage() {
                 "    }",
                 "    return (Provider<A>) local;",
                 "  }")
-            .addLines(
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {")
             .addLinesIn(
                 DEFAULT_MODE,
-                "    this.aProvider = new test_AComponent_a(builder.aComponent);")
-            .addLinesIn(
-                FAST_INIT_MODE,
-                "    this.aComponent = builder.aComponent;")
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.aProvider = new test_AComponent_a(builder.aComponent);",
+                "  }")
             .addLines(
-                "  }",
                 "",
                 "  @Override",
                 "  public B b() {")
@@ -1248,10 +1242,7 @@ public void testDefaultPackage() {
                 "    private AComponent aComponent;",
                 "",
                 "    public BComponent build() {",
-                "      if (aComponent == null) {",
-                "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
-                "            + \" must be set\");",
-                "      }",
+                "      Preconditions.checkBuilderRequirement(aComponent, AComponent.class);",
                 "      return new DaggerBComponent(this);",
                 "    }",
                 "",
@@ -1286,7 +1277,8 @@ public void testDefaultPackage() {
                 "        case 0:",
                 "          return (T)",
                 "              Preconditions.checkNotNull(",
-                "                  aComponent.a(), " + NPE_FROM_COMPONENT_METHOD + ");",
+                "                  DaggerBComponent.this.aComponent.a(),",
+                "                  " + NPE_FROM_COMPONENT_METHOD + ");",
                 "        default:",
                 "          throw new AssertionError(id);",
                 "      }",
@@ -1355,8 +1347,7 @@ public void testDefaultPackage() {
             "  private TestModule testModule;",
             "  private other.test.TestModule testModule2;",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
+            "  private DaggerTestComponent(Builder builder) {",
             "    this.testModule = builder.testModule;",
             "    this.testModule2 = builder.testModule2;",
             "  }",
@@ -1479,8 +1470,7 @@ public void testDefaultPackage() {
             "public final class DaggerBComponent implements BComponent {",
             "  private AComponent aComponent;",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
+            "  private DaggerBComponent(Builder builder) {",
             "    this.aComponent = builder.aComponent;",
             "  }",
             "",
@@ -2582,37 +2572,4 @@ public boolean errorRaised() {
           });
     }
   }
-
-  /**
-   * A simple {@link Processor} that generates one source file.
-   */
-  private static final class GeneratingProcessor extends AbstractProcessor {
-    private final String generatedClassName;
-    private final String generatedSource;
-    private boolean processed;
-
-    GeneratingProcessor(String generatedClassName, String... source) {
-      this.generatedClassName = generatedClassName;
-      this.generatedSource = Joiner.on("\n").join(source);
-    }
-
-    @Override
-    public Set<String> getSupportedAnnotationTypes() {
-      return ImmutableSet.of("*");
-    }
-
-    @Override
-    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-      if (!processed) {
-        processed = true;
-        try (Writer writer =
-                processingEnv.getFiler().createSourceFile(generatedClassName).openWriter()) {
-          writer.append(generatedSource);
-        } catch (IOException e) {
-          throw new RuntimeException(e);
-        }
-      }
-      return false;
-    }
-  }
 }
diff --git a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
index 8148f4ccd..f44c5dc56 100644
--- a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
+++ b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
@@ -81,8 +81,7 @@ public void bindsInstance() {
                 "  private Integer i;",
                 "  private List<String> list;",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private DaggerTestComponent(Builder builder) {",
                 "    this.i = builder.i;",
                 "    this.list = builder.list;",
                 "  }",
@@ -103,14 +102,8 @@ public void bindsInstance() {
                 "",
                 "    @Override",
                 "    public TestComponent build() {",
-                "      if (i == null) {",
-                "        throw new IllegalStateException(",
-                "            Integer.class.getCanonicalName() + \" must be set\");",
-                "      }",
-                "      if (list == null) {",
-                "        throw new IllegalStateException(",
-                "            List.class.getCanonicalName() + \" must be set\");",
-                "      }",
+                "      Preconditions.checkBuilderRequirement(i, Integer.class);",
+                "      Preconditions.checkBuilderRequirement(list, List.class);",
                 "      return new DaggerTestComponent(this);",
                 "    }",
                 "",
@@ -258,8 +251,7 @@ public void componentInstances() {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private Dep dep;",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private DaggerTestComponent(Builder builder) {",
                 "    this.dep = builder.dep;",
                 "  }",
                 "",
@@ -373,8 +365,7 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private ParentModule parentModule;",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private DaggerTestComponent(Builder builder) {",
                 "    this.parentModule = builder.parentModule;",
                 "  }",
                 "",
@@ -402,6 +393,11 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private ParentModule parentModule;",
                 "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "    initialize(builder);",
+                "  }",
+                "",
                 "  @SuppressWarnings(\"unchecked\")",
                 "  private void initialize(final Builder builder) {",
                 "    this.setOfObjectProvider =",
@@ -411,7 +407,6 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "    this.reliesOnMultibindingProvider =",
                 "        ParentModule_ReliesOnMultibindingFactory.create(",
                 "            builder.parentModule, setOfObjectProvider);",
-                "    this.parentModule = builder.parentModule;",
                 "  }",
                 "",
                 "  private final class TestSubcomponentImpl implements TestSubcomponent {",
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index 15260e76c..4f0154d91 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -73,23 +73,6 @@ public DelegateBindingExpressionTest(CompilerMode compilerMode) {
           "  @Inject ReusableScoped() {}",
           "}");
 
-  private static final JavaFileObject RELEASABLE_SCOPED =
-      JavaFileObjects.forSourceLines(
-          "test.ReleasableScoped",
-          "package test;",
-          "",
-          "import dagger.releasablereferences.CanReleaseReferences;",
-          "import javax.inject.Scope;",
-          "import javax.inject.Inject;",
-          "",
-          "@ReleasableScoped.CustomScope",
-          "class ReleasableScoped {",
-          "  @Inject ReleasableScoped() {}",
-          "",
-          "  @CanReleaseReferences",
-          "  @Scope @interface CustomScope {}",
-          "}");
-
   private static final JavaFileObject UNSCOPED =
       JavaFileObjects.forSourceLines(
           "test.Unscoped",
@@ -107,12 +90,9 @@ public DelegateBindingExpressionTest(CompilerMode compilerMode) {
           "package test;",
           "",
           "import dagger.Component;",
-          "import dagger.releasablereferences.ForReleasableReferences;",
-          "import dagger.releasablereferences.ReleasableReferenceManager;",
           "",
           "@Component(modules = TestModule.class)",
           "@RegularScoped.CustomScope",
-          "@ReleasableScoped.CustomScope",
           "interface TestComponent {",
           "  @Qualifier(RegularScoped.class)",
           "  Object regular();",
@@ -120,15 +100,8 @@ public DelegateBindingExpressionTest(CompilerMode compilerMode) {
           "  @Qualifier(ReusableScoped.class)",
           "  Object reusable();",
           "",
-          "  @Qualifier(ReleasableScoped.class)",
-          "  Object releasable();",
-          "",
           "  @Qualifier(Unscoped.class)",
           "  Object unscoped();",
-          "",
-          // force a reference releasing provider to be created
-          "  @ForReleasableReferences(ReleasableScoped.CustomScope.class)",
-          "  ReleasableReferenceManager releasableReferenceManager();",
           "}");
 
   private static final JavaFileObject QUALIFIER =
@@ -159,9 +132,6 @@ public void toDoubleCheck() {
             "  @Binds @RegularScoped.CustomScope @Qualifier(ReusableScoped.class)",
             "  Object reusable(ReusableScoped delegate);",
             "",
-            "  @Binds @RegularScoped.CustomScope @Qualifier(ReleasableScoped.class)",
-            "  Object releasable(ReleasableScoped delegate);",
-            "",
             "  @Binds @RegularScoped.CustomScope @Qualifier(Unscoped.class)",
             "  Object unscoped(Unscoped delegate);",
             "}");
@@ -204,36 +174,20 @@ public void toDoubleCheck() {
                     "    return (ReusableScoped) local;",
                     "  }",
                     "")
-                .addLines(
-                    "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {")
                 .addLinesIn(
                     DEFAULT_MODE,
+                    "  @SuppressWarnings(\"unchecked\")",
+                    "  private void initialize(final Builder builder) {",
                     "    this.regularScopedProvider = ",
                     "        DoubleCheck.provider(RegularScoped_Factory.create());",
                     "    this.reusableScopedProvider = ",
                     "        SingleCheck.provider(ReusableScoped_Factory.create());",
                     "    this.reusableProvider = DoubleCheck.provider(",
-                    "        (Provider) reusableScopedProvider);")
-                .addLines(
-                    "    this.releasableScopedProvider = ",
-                    "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);")
-                .addLinesIn(
-                    DEFAULT_MODE,
-                    "    this.releasableProvider = DoubleCheck.provider(",
-                    "        (Provider) releasableScopedProvider);",
+                    "        (Provider) reusableScopedProvider);",
                     "    this.unscopedProvider = DoubleCheck.provider(",
-                    "        (Provider) Unscoped_Factory.create());")
-                .addLines(
-                    "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
-                    "        new Provider<ReleasableReferenceManager>() {",
-                    "          @Override",
-                    "          public ReleasableReferenceManager get() {",
-                    "            return customScopeReferences;",
-                    "          }",
-                    "        };",
-                    "  }",
+                    "        (Provider) Unscoped_Factory.create());",
+                    "  }")
+                .addLines( //
                     "}")
                 .build());
   }
@@ -257,9 +211,6 @@ public void toSingleCheck() {
             "  @Binds @Reusable @Qualifier(ReusableScoped.class)",
             "  Object reusable(ReusableScoped delegate);",
             "",
-            "  @Binds @Reusable @Qualifier(ReleasableScoped.class)",
-            "  Object releasable(ReleasableScoped delegate);",
-            "",
             "  @Binds @Reusable @Qualifier(Unscoped.class)",
             "  Object unscoped(Unscoped delegate);",
             "}");
@@ -302,156 +253,19 @@ public void toSingleCheck() {
                     "    return (ReusableScoped) local;",
                     "  }",
                     "")
-                .addLines(
-                    "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {")
                 .addLinesIn(
                     DEFAULT_MODE,
-                    "    this.regularScopedProvider = ",
-                    "        DoubleCheck.provider(RegularScoped_Factory.create());",
-                    "    this.reusableScopedProvider = ",
-                    "        SingleCheck.provider(ReusableScoped_Factory.create());")
-                .addLines(
-                    "    this.releasableScopedProvider = ",
-                    "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);")
-                .addLinesIn(
-                    DEFAULT_MODE,
-                    "    this.releasableProvider = SingleCheck.provider(",
-                    "        (Provider) releasableScopedProvider);",
-                    "    this.unscopedProvider = SingleCheck.provider(",
-                    "        (Provider) Unscoped_Factory.create());")
-                .addLines(
-                    "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
-                    "        new Provider<ReleasableReferenceManager>() {",
-                    "          @Override",
-                    "          public ReleasableReferenceManager get() {",
-                    "            return customScopeReferences;",
-                    "          }",
-                    "        };",
-                    "  }",
-                    "}")
-                .build());
-  }
-
-  @Test
-  public void toReleasableCheck() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "interface TestModule {",
-            "  @Binds @ReleasableScoped.CustomScope @Qualifier(RegularScoped.class)",
-            "  Object regular(RegularScoped delegate);",
-            "",
-            "  @Binds @ReleasableScoped.CustomScope @Qualifier(ReusableScoped.class)",
-            "  Object reusable(ReusableScoped delegate);",
-            "",
-            "  @Binds @ReleasableScoped.CustomScope @Qualifier(ReleasableScoped.class)",
-            "  Object releasable(ReleasableScoped delegate);",
-            "",
-            "  @Binds @ReleasableScoped.CustomScope @Qualifier(Unscoped.class)",
-            "  Object unscoped(Unscoped delegate);",
-            "}");
-
-    assertThatCompilationWithModule(module)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .containsElementsIn(
-            compilerMode
-                .javaFileBuilder("test.DaggerTestComponent")
-                .addLines(
-                    "package test;",
-                    "",
-                    GENERATED_ANNOTATION,
-                    "public final class DaggerTestComponent implements TestComponent {")
-                .addLinesIn(
-                    FAST_INIT_MODE,
-                    "  private volatile Object regularScoped = new MemoizedSentinel();",
-                    "  private volatile ReusableScoped reusableScoped;",
-                    "  private volatile Provider<Unscoped> unscopedProvider;",
-                    "",
-                    "  private RegularScoped getRegularScoped() {",
-                    "    Object local = regularScoped;",
-                    "    if (local instanceof MemoizedSentinel) {",
-                    "      synchronized (local) {",
-                    "        local = regularScoped;",
-                    "        if (local instanceof MemoizedSentinel) {",
-                    "          local = new RegularScoped();",
-                    "          regularScoped = DoubleCheck.reentrantCheck(regularScoped, local);",
-                    "        }",
-                    "      }",
-                    "    }",
-                    "    return (RegularScoped) local;",
-                    "  }",
-                    "",
-                    "  private ReusableScoped getReusableScoped() {",
-                    "    Object local = reusableScoped;",
-                    "    if (local == null) {",
-                    "      local = new ReusableScoped();",
-                    "      reusableScoped = (ReusableScoped) local;",
-                    "    }",
-                    "    return (ReusableScoped) local;",
-                    "  }",
-                    "",
-                    "  private Provider<Unscoped> getUnscopedProvider() {",
-                    "    Object local = unscopedProvider;",
-                    "    if (local == null) {",
-                    "      local = new SwitchingProvider<>(0);",
-                    "      unscopedProvider = (Provider<Unscoped>) local;",
-                    "    }",
-                    "    return (Provider<Unscoped>) local;",
-                    "  }",
-                    "")
-                .addLines(
                     "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {")
-                .addLinesIn(
-                    DEFAULT_MODE,
+                    "  private void initialize(final Builder builder) {",
                     "    this.regularScopedProvider = ",
                     "        DoubleCheck.provider(RegularScoped_Factory.create());",
                     "    this.reusableScopedProvider = ",
-                    "        SingleCheck.provider(ReusableScoped_Factory.create());")
-                .addLines(
-                    "    this.releasableScopedProvider = ",
-                    "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);")
-                .addLinesIn(
-                    DEFAULT_MODE,
-                    "    this.unscopedProvider =",
-                    "        ReferenceReleasingProvider.create(",
-                    "            (Provider) Unscoped_Factory.create(), customScopeReferences);")
-                .addLinesIn(
-                    FAST_INIT_MODE,
-                    "    this.unscopedProvider2 =",
-                    "        ReferenceReleasingProvider.create(",
-                    "            (Provider) getUnscopedProvider(), customScopeReferences);")
-                .addLines(
-                    "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
-                    "        new Provider<ReleasableReferenceManager>() {",
-                    "          @Override",
-                    "          public ReleasableReferenceManager get() {",
-                    "            return customScopeReferences;",
-                    "          }",
-                    "        };",
-                    "  }")
-                .addLinesIn(
-                    FAST_INIT_MODE,
-                    "  private final class SwitchingProvider<T> implements Provider<T> {",
-                    "    @SuppressWarnings(\"unchecked\")",
-                    "    @Override",
-                    "    public T get() {",
-                    "      switch (id) {",
-                    "        case 0: return (T) new Unscoped();",
-                    "        default: throw new AssertionError(id);",
-                    "      }",
-                    "    }",
+                    "        SingleCheck.provider(ReusableScoped_Factory.create());",
+                    "    this.unscopedProvider = SingleCheck.provider(",
+                    "        (Provider) Unscoped_Factory.create());",
                     "  }")
-                .addLines("}")
+                .addLines( //
+                    "}")
                 .build());
   }
 
@@ -473,9 +287,6 @@ public void toUnscoped() {
             "  @Binds @Qualifier(ReusableScoped.class)",
             "  Object reusable(ReusableScoped delegate);",
             "",
-            "  @Binds @Qualifier(ReleasableScoped.class)",
-            "  Object releasable(ReleasableScoped delegate);",
-            "",
             "  @Binds @Qualifier(Unscoped.class)",
             "  Object unscoped(Unscoped delegate);",
             "}");
@@ -518,27 +329,16 @@ public void toUnscoped() {
                     "    return (ReusableScoped) local;",
                     "  }",
                     "")
-                .addLines(
-                    "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {")
                 .addLinesIn(
                     DEFAULT_MODE,
+                    "  @SuppressWarnings(\"unchecked\")",
+                    "  private void initialize(final Builder builder) {",
                     "    this.regularScopedProvider = ",
                     "        DoubleCheck.provider(RegularScoped_Factory.create());",
                     "    this.reusableScopedProvider = ",
-                    "        SingleCheck.provider(ReusableScoped_Factory.create());")
-                .addLines(
-                    "    this.releasableScopedProvider = ",
-                    "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);",
-                    "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
-                    "        new Provider<ReleasableReferenceManager>() {",
-                    "          @Override",
-                    "          public ReleasableReferenceManager get() {",
-                    "            return customScopeReferences;",
-                    "          }",
-                    "        };",
-                    "  }",
+                    "        SingleCheck.provider(ReusableScoped_Factory.create());",
+                    "  }")
+                .addLines( //
                     "}")
                 .build());
   }
@@ -1125,9 +925,9 @@ public void providerWhenBindsScopeGreaterThanDependencyScope() {
                     "}")
                 .addLinesIn(
                     FAST_INIT_MODE,
-                    "  private volatile Provider<Object> bindStringProvider;",
-                    "  private volatile Object object = new MemoizedSentinel();",
                     "  private volatile String string;",
+                    "  private volatile Object object = new MemoizedSentinel();",
+                    "  private volatile Provider<Object> bindStringProvider;",
                     "",
                     "  private String getString() {",
                     "    Object local = string;",
@@ -1167,7 +967,7 @@ public void providerWhenBindsScopeGreaterThanDependencyScope() {
                     "    @Override",
                     "    public T get() {",
                     "      switch (id) {",
-                    "        case 0: return (T) getObject2();",
+                    "        case 0: return (T) DaggerTestComponent.this.getObject2();",
                     "        default: throw new AssertionError(id);",
                     "      }",
                     "    }",
@@ -1185,7 +985,6 @@ private CompilationSubject assertThatCompilationWithModule(JavaFileObject module
                 QUALIFIER,
                 REGULAR_SCOPED,
                 REUSABLE_SCOPED,
-                RELEASABLE_SCOPED,
                 UNSCOPED);
     assertThat(compilation).succeeded();
     return assertThat(compilation);
diff --git a/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
index 9fcaeacf7..4a57da3c7 100644
--- a/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
+++ b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
@@ -30,49 +30,73 @@
 @RunWith(JUnit4.class)
 public class DependencyCycleValidationTest {
   @Test public void cyclicDependency() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  static class A {",
-        "    @Inject A(C cParam) {}",
-        "  }",
-        "",
-        "  static class B {",
-        "    @Inject B(A aParam) {}",
-        "  }",
-        "",
-        "  static class C {",
-        "    @Inject C(B bParam) {}",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface CComponent {",
-        "    C getC();",
-        "  }",
-        "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Module",
+            "  interface MModule {",
+            "    @Binds Object object(C c);",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "}");
 
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.moduleBindingValidation=ERROR").compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             message(
                 "Found a dependency cycle:",
                 "    test.Outer.C is injected at",
-                "        test.Outer.A.<init>(cParam)",
+                "        test.Outer.A(cParam)",
                 "    test.Outer.A is injected at",
-                "        test.Outer.B.<init>(aParam)",
+                "        test.Outer.B(aParam)",
                 "    test.Outer.B is injected at",
-                "        test.Outer.C.<init>(bParam)",
+                "        test.Outer.C(bParam)",
                 "    test.Outer.C is provided at",
                 "        test.Outer.CComponent.getC()"))
         .inFile(component)
         .onLineContaining("interface CComponent");
+
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C(bParam)",
+                "It is requested at:",
+                "    test.Outer.MModule.object(c)"))
+        .inFile(component)
+        .onLineContaining("interface MModule");
   }
 
   @Test public void cyclicDependencyNotIncludingEntryPoint() {
@@ -116,13 +140,13 @@
             message(
                 "Found a dependency cycle:",
                 "    test.Outer.C is injected at",
-                "        test.Outer.A.<init>(cParam)",
+                "        test.Outer.A(cParam)",
                 "    test.Outer.A is injected at",
-                "        test.Outer.B.<init>(aParam)",
+                "        test.Outer.B(aParam)",
                 "    test.Outer.B is injected at",
-                "        test.Outer.C.<init>(bParam)",
+                "        test.Outer.C(bParam)",
                 "    test.Outer.C is injected at",
-                "        test.Outer.D.<init>(cParam)",
+                "        test.Outer.D(cParam)",
                 "    test.Outer.D is provided at",
                 "        test.Outer.DComponent.getD()"))
         .inFile(component)
@@ -181,11 +205,11 @@ public void cyclicDependencyNotBrokenByMapBinding() {
                 "    test.Outer.C is injected at",
                 "        test.Outer.CModule.c(c)",
                 "    java.util.Map<java.lang.String,test.Outer.C> is injected at",
-                "        test.Outer.A.<init>(cMap)",
+                "        test.Outer.A(cMap)",
                 "    test.Outer.A is injected at",
-                "        test.Outer.B.<init>(aParam)",
+                "        test.Outer.B(aParam)",
                 "    test.Outer.B is injected at",
-                "        test.Outer.C.<init>(bParam)",
+                "        test.Outer.C(bParam)",
                 "    test.Outer.C is provided at",
                 "        test.Outer.CComponent.getC()"))
         .inFile(component)
@@ -242,11 +266,11 @@ public void cyclicDependencyWithSetBinding() {
                 "    test.Outer.C is injected at",
                 "        test.Outer.CModule.c(c)",
                 "    java.util.Set<test.Outer.C> is injected at",
-                "        test.Outer.A.<init>(cSet)",
+                "        test.Outer.A(cSet)",
                 "    test.Outer.A is injected at",
-                "        test.Outer.B.<init>(aParam)",
+                "        test.Outer.B(aParam)",
                 "    test.Outer.B is injected at",
-                "        test.Outer.C.<init>(bParam)",
+                "        test.Outer.C(bParam)",
                 "    test.Outer.C is provided at",
                 "        test.Outer.CComponent.getC()"))
         .inFile(component)
@@ -296,13 +320,13 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
             message(
                 "Found a dependency cycle:",
                 "    test.Outer.C is injected at",
-                "        test.Outer.A.<init>(cParam)",
+                "        test.Outer.A(cParam)",
                 "    test.Outer.A is injected at",
-                "        test.Outer.B.<init>(aParam)",
+                "        test.Outer.B(aParam)",
                 "    test.Outer.B is injected at",
-                "        test.Outer.C.<init>(bParam)",
+                "        test.Outer.C(bParam)",
                 "    javax.inject.Provider<test.Outer.C> is injected at",
-                "        test.Outer.D.<init>(cParam)",
+                "        test.Outer.D(cParam)",
                 "    test.Outer.D is provided at",
                 "        test.Outer.DComponent.getD()"))
         .inFile(component)
@@ -413,7 +437,7 @@ public void cyclicDependencyInSubcomponentsWithChildren() {
             "interface Child {",
             "  String entry();",
             "",
-            "  Grandchild grandchild();",
+            "  Grandchild.Builder grandchild();",
             "",
             "  @Subcomponent.Builder",
             "  interface Builder {",
diff --git a/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java b/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java
index 232445785..ac54941e6 100644
--- a/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java
+++ b/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java
@@ -17,20 +17,36 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.Compiler.javac;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.TestUtils.message;
+import static org.junit.Assume.assumeFalse;
 
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class DuplicateBindingsValidationTest {
+
+  @Parameters(name = "moduleBindingValidation={0}")
+  public static ImmutableList<Object[]> parameters() {
+    return ImmutableList.copyOf(new Object[][] {{false}, {true}});
+  }
+
+  private final boolean moduleBindingValidation;
+
+  public DuplicateBindingsValidationTest(boolean moduleBindingValidation) {
+    this.moduleBindingValidation = moduleBindingValidation;
+  }
+
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
+    assumeFalse(moduleBindingValidation);
+
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
         "",
@@ -65,7 +81,8 @@
         "  }",
         "}");
 
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -78,35 +95,46 @@
   }
 
   @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  interface A {}",
-        "",
-        "  @Module",
-        "  static class Module1 {",
-        "    @Provides A provideA1() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module2 {",
-        "    @Provides String provideString() { return \"\"; }",
-        "    @Provides A provideA2(String s) { return new A() {}; }",
-        "  }",
-        "",
-        "  @Component(modules = { Module1.class, Module2.class})",
-        "  interface TestComponent {",
-        "    A getA();",
-        "  }",
-        "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  interface A {}",
+            "",
+            "  static class B {",
+            "    @Inject B(A a) {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module1 {",
+            "    @Provides A provideA1() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module2 {",
+            "    @Provides String provideString() { return \"\"; }",
+            "    @Provides A provideA2(String s) { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module(includes = { Module1.class, Module2.class})",
+            "  abstract static class Module3 {}",
+            "",
+            "  @Component(modules = { Module1.class, Module2.class})",
+            "  interface TestComponent {",
+            "    A getA();",
+            "    B getB();",
+            "  }",
+            "}");
 
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -116,6 +144,20 @@
                 "    @Provides test.Outer.A test.Outer.Module2.provideA2(String)"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
+
+    if (moduleBindingValidation) {
+      assertThat(compilation)
+          .hadErrorContaining(
+              message(
+                  "test.Outer.A is bound multiple times:",
+                  "    @Provides test.Outer.A test.Outer.Module1.provideA1()",
+                  "    @Provides test.Outer.A test.Outer.Module2.provideA2(String)"))
+          .inFile(component)
+          .onLineContaining("class Module3");
+    }
+
+    // The duplicate bindngs are also requested from B, but we don't want to report them again.
+    assertThat(compilation).hadErrorCount(moduleBindingValidation ? 2 : 1);
   }
 
   @Test
@@ -148,13 +190,17 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
             "    @Binds abstract A bindA2(B b);",
             "  }",
             "",
+            "  @Module(includes = { Module1.class, Module2.class})",
+            "  abstract static class Module3 {}",
+            "",
             "  @Component(modules = { Module1.class, Module2.class})",
             "  interface TestComponent {",
             "    A getA();",
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -164,6 +210,17 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
                 "    @Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
+
+    if (moduleBindingValidation) {
+      assertThat(compilation)
+          .hadErrorContaining(
+              message(
+                  "test.Outer.A is bound multiple times:",
+                  "    @Provides test.Outer.A test.Outer.Module1.provideA1()",
+                  "    @Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
+          .inFile(component)
+          .onLineContaining("class Module3");
+    }
   }
 
   @Test
@@ -201,13 +258,17 @@ public void duplicateExplicitBindings_multibindingsAndExplicitSets() {
             "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
             "  }",
             "",
+            "  @Module(includes = { TestModule1.class, TestModule2.class})",
+            "  abstract static class TestModule3 {}",
+            "",
             "  @Component(modules = { TestModule1.class, TestModule2.class })",
             "  interface TestComponent {",
             "    Set<String> getStringSet();",
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -222,7 +283,8 @@ public void duplicateExplicitBindings_multibindingsAndExplicitSets() {
                 "    Unique bindings and declarations:",
                 "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
         .inFile(component)
-        .onLineContaining("interface TestComponent");
+        .onLineContaining(
+            moduleBindingValidation ? "class TestModule3" : "interface TestComponent");
   }
 
   @Test
@@ -265,13 +327,17 @@ public void duplicateExplicitBindings_multibindingsAndExplicitMaps() {
             "    }",
             "  }",
             "",
+            "  @Module(includes = { TestModule1.class, TestModule2.class})",
+            "  abstract static class TestModule3 {}",
+            "",
             "  @Component(modules = { TestModule1.class, TestModule2.class })",
             "  interface TestComponent {",
             "    Map<String, String> getStringMap();",
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -289,7 +355,8 @@ public void duplicateExplicitBindings_multibindingsAndExplicitMaps() {
                 "    Unique bindings and declarations:",
                 "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
         .inFile(component)
-        .onLineContaining("interface TestComponent");
+        .onLineContaining(
+            moduleBindingValidation ? "class TestModule3" : "interface TestComponent");
   }
 
   @Test
@@ -317,13 +384,17 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Se
             "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
             "  }",
             "",
+            "  @Module(includes = { TestModule1.class, TestModule2.class})",
+            "  abstract static class TestModule3 {}",
+            "",
             "  @Component(modules = { TestModule1.class, TestModule2.class })",
             "  interface TestComponent {",
             "    Set<String> getStringSet();",
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -335,7 +406,8 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Se
                 "    Unique bindings and declarations:",
                 "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
         .inFile(component)
-        .onLineContaining("interface TestComponent");
+        .onLineContaining(
+            moduleBindingValidation ? "class TestModule3" : "interface TestComponent");
   }
 
   @Test
@@ -365,13 +437,17 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Ma
             "    }",
             "  }",
             "",
+            "  @Module(includes = { TestModule1.class, TestModule2.class})",
+            "  abstract static class TestModule3 {}",
+            "",
             "  @Component(modules = { TestModule1.class, TestModule2.class })",
             "  interface TestComponent {",
             "    Map<String, String> getStringMap();",
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -384,7 +460,8 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Ma
                 "    Unique bindings and declarations:",
                 "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
         .inFile(component)
-        .onLineContaining("interface TestComponent");
+        .onLineContaining(
+            moduleBindingValidation ? "class TestModule3" : "interface TestComponent");
   }
 
   @Test public void duplicateBindings_TruncateAfterLimit() {
@@ -461,6 +538,22 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Ma
             "    @Provides A provideA() { return new A() {}; }",
             "  }",
             "",
+            "  @Module(includes = {",
+            "    Module01.class,",
+            "    Module02.class,",
+            "    Module03.class,",
+            "    Module04.class,",
+            "    Module05.class,",
+            "    Module06.class,",
+            "    Module07.class,",
+            "    Module08.class,",
+            "    Module09.class,",
+            "    Module10.class,",
+            "    Module11.class,",
+            "    Module12.class",
+            "  })",
+            "  abstract static class Modules {}",
+            "",
             "  @Component(modules = {",
             "    Module01.class,",
             "    Module02.class,",
@@ -480,7 +573,8 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Ma
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -498,7 +592,7 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Ma
                 "    @Provides test.Outer.A test.Outer.Module10.provideA()",
                 "    and 2 others"))
         .inFile(component)
-        .onLineContaining("interface TestComponent");
+        .onLineContaining(moduleBindingValidation ? "class Modules" : "interface TestComponent");
   }
 
   @Test
@@ -516,9 +610,9 @@ public void childBindingConflictsWithParent() {
             "interface A {",
             "  Object conflict();",
             "",
-            "  B b();",
+            "  B.Builder b();",
             "",
-            "  @Module",
+            "  @Module(subcomponents = B.class)",
             "  static class AModule {",
             "    @Provides static Object abConflict() {",
             "      return \"a\";",
@@ -538,6 +632,11 @@ public void childBindingConflictsWithParent() {
             "interface B {",
             "  Object conflict();",
             "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    B build();",
+            "  }",
+            "",
             "  @Module",
             "  static class BModule {",
             "    @Provides static Object abConflict() {",
@@ -546,7 +645,10 @@ public void childBindingConflictsWithParent() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(aComponent, bComponent);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(moduleBindingValidationOption())
+            .compile(aComponent, bComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -555,7 +657,7 @@ public void childBindingConflictsWithParent() {
                 "    @Provides Object test.A.AModule.abConflict()",
                 "    @Provides Object test.B.BModule.abConflict()"))
         .inFile(aComponent)
-        .onLineContaining("interface A {");
+        .onLineContaining(moduleBindingValidation ? "class AModule" : "interface A {");
   }
 
   @Test
@@ -573,9 +675,9 @@ public void grandchildBindingConflictsWithGrandparent() {
             "interface A {",
             "  Object conflict();",
             "",
-            "  B b();",
+            "  B.Builder b();",
             "",
-            "  @Module",
+            "  @Module(subcomponents = B.class)",
             "  static class AModule {",
             "    @Provides static Object acConflict() {",
             "      return \"a\";",
@@ -591,7 +693,12 @@ public void grandchildBindingConflictsWithGrandparent() {
             "",
             "@Subcomponent",
             "interface B {",
-            "  C c();",
+            "  C.Builder c();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    B build();",
+            "  }",
             "}");
     JavaFileObject cComponent =
         JavaFileObjects.forSourceLines(
@@ -606,6 +713,11 @@ public void grandchildBindingConflictsWithGrandparent() {
             "interface C {",
             "  Object conflict();",
             "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    C build();",
+            "  }",
+            "",
             "  @Module",
             "  static class CModule {",
             "    @Provides static Object acConflict() {",
@@ -614,7 +726,10 @@ public void grandchildBindingConflictsWithGrandparent() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(moduleBindingValidationOption())
+            .compile(aComponent, bComponent, cComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -623,7 +738,7 @@ public void grandchildBindingConflictsWithGrandparent() {
                 "    @Provides Object test.A.AModule.acConflict()",
                 "    @Provides Object test.C.CModule.acConflict()"))
         .inFile(aComponent)
-        .onLineContaining("interface A {");
+        .onLineContaining(moduleBindingValidation ? "class AModule" : "interface A {");
   }
 
   @Test
@@ -652,9 +767,9 @@ public void grandchildBindingConflictsWithChild() {
             "interface B {",
             "  Object conflict();",
             "",
-            "  C c();",
+            "  C.Builder c();",
             "",
-            "  @Module",
+            "  @Module(subcomponents = C.class)",
             "  static class BModule {",
             "    @Provides static Object bcConflict() {",
             "      return \"b\";",
@@ -674,6 +789,11 @@ public void grandchildBindingConflictsWithChild() {
             "interface C {",
             "  Object conflict();",
             "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    C build();",
+            "  }",
+            "",
             "  @Module",
             "  static class CModule {",
             "    @Provides static Object bcConflict() {",
@@ -682,7 +802,10 @@ public void grandchildBindingConflictsWithChild() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(moduleBindingValidationOption())
+            .compile(aComponent, bComponent, cComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -690,8 +813,8 @@ public void grandchildBindingConflictsWithChild() {
                 "java.lang.Object is bound multiple times:",
                 "    @Provides Object test.B.BModule.bcConflict()",
                 "    @Provides Object test.C.CModule.bcConflict()"))
-        .inFile(aComponent)
-        .onLineContaining("interface A {");
+        .inFile(moduleBindingValidation ? bComponent : aComponent)
+        .onLineContaining(moduleBindingValidation ? "class BModule" : "interface A {");
   }
 
   @Test
@@ -708,9 +831,9 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
             "",
             "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
             "interface ParentConflictsWithChild {",
-            "  Child child();",
+            "  Child.Builder child();",
             "",
-            "  @Module",
+            "  @Module(subcomponents = Child.class)",
             "  static class ParentModule {",
             "    @Provides @Nullable static Object nullableParentChildConflict() {",
             "      return \"parent\";",
@@ -730,6 +853,11 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
             "interface Child {",
             "  Object parentChildConflictThatViolatesNullability();",
             "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "",
             "  @Module",
             "  static class ChildModule {",
             "    @Provides static Object nonNullableParentChildConflict() {",
@@ -739,9 +867,8 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
             "}");
 
     Compilation compilation =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
+        daggerCompiler()
+            .withOptions("-Adagger.nullableValidation=WARNING", moduleBindingValidationOption())
             .compile(parentConflictsWithChild, child);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -752,6 +879,79 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
                 "    @Provides @javax.annotation.Nullable Object"
                     + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
         .inFile(parentConflictsWithChild)
-        .onLine(9);
+        .onLineContaining(
+            moduleBindingValidation ? "class ParentModule" : "interface ParentConflictsWithChild");
+  }
+
+  private String moduleBindingValidationOption() {
+    return "-Adagger.moduleBindingValidation=" + (moduleBindingValidation ? "ERROR" : "NONE");
+  }
+
+  @Test
+  public void reportedInParentAndChild() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child.Builder childBuilder();",
+            "  String duplicated();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.Optional;",
+            "",
+            "@Module",
+            "interface ParentModule {",
+            "  @Provides static String one(Optional<Object> optional) { return \"one\"; }",
+            "  @Provides static String two() { return \"two\"; }",
+            "  @BindsOptionalOf Object optional();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  String duplicated();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.Optional;",
+            "",
+            "@Module",
+            "interface ChildModule {",
+            "  @Provides static Object object() { return \"object\"; }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(parent, parentModule, child, childModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("java.lang.String is bound multiple times")
+        .inFile(parent)
+        .onLineContaining("interface Parent");
+    assertThat(compilation).hadErrorCount(1);
   }
 }
diff --git a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
index cae7c0506..9c9838bfd 100644
--- a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
+++ b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
@@ -187,8 +187,8 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerSimpleComponent implements SimpleComponent {",
-                "  private volatile Provider<DependsOnScoped> dependsOnScopedProvider;",
                 "  private volatile Object scopedType = new MemoizedSentinel();",
+                "  private volatile Provider<DependsOnScoped> dependsOnScopedProvider;",
                 "",
                 "  private DaggerSimpleComponent(Builder builder) {}",
                 "",
@@ -250,7 +250,7 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "    @Override",
                 "    public T get() {",
                 "      switch (id) {",
-                "        case 0: return (T) getDependsOnScoped();",
+                "        case 0: return (T) DaggerSimpleComponent.this.getDependsOnScoped();",
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
diff --git a/javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java b/javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java
deleted file mode 100644
index e15c6dbc1..000000000
--- a/javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests validation of {@code @ForReleasableRefernces}. */
-@RunWith(JUnit4.class)
-public class ForReleasableReferencesValidationTest {
-  @Test
-  public void notAScope() {
-    JavaFileObject notAScope =
-        JavaFileObjects.forSourceLines(
-            "test.NotAScope", // force one-string-per-line format
-            "package test;",
-            "",
-            "@interface NotAScope {}");
-    JavaFileObject injects =
-        JavaFileObjects.forSourceLines(
-            "test.Injects",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "",
-            "interface Injects {",
-            "  @ForReleasableReferences(NotAScope.class) ReleasableReferenceManager manager();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(notAScope, injects);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "The value of @ForReleasableReferences must be a reference-releasing scope. "
-                + "Did you mean to annotate test.NotAScope with @javax.inject.Scope and "
-                + "@dagger.releasablereferences.CanReleaseReferences?")
-        .inFile(injects)
-        .onLine(7)
-        .atColumn(3);
-  }
-
-  @Test
-  public void notAReferenceReleasingScope() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@Retention(RUNTIME)",
-            "@Scope",
-            "@interface TestScope {}");
-    JavaFileObject injects =
-        JavaFileObjects.forSourceLines(
-            "test.Injects",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "",
-            "interface Injects {",
-            "  @ForReleasableReferences(TestScope.class) ReleasableReferenceManager manager();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(testScope, injects);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "The value of @ForReleasableReferences must be a reference-releasing scope. "
-                + "Did you mean to annotate test.TestScope with "
-                + "@dagger.releasablereferences.CanReleaseReferences?")
-        .inFile(injects)
-        .onLine(7)
-        .atColumn(3);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java b/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
index 37af821d9..3e6e3ad69 100644
--- a/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
+++ b/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
@@ -39,10 +39,10 @@
 
   @Test public void forProducer() {
     FrameworkTypeMapper mapper = FrameworkTypeMapper.FOR_PRODUCER;
-    assertThat(mapper.getFrameworkType(INSTANCE)).isEqualTo(FrameworkType.PRODUCER);
+    assertThat(mapper.getFrameworkType(INSTANCE)).isEqualTo(FrameworkType.PRODUCER_NODE);
     assertThat(mapper.getFrameworkType(LAZY)).isEqualTo(FrameworkType.PROVIDER);
     assertThat(mapper.getFrameworkType(PROVIDER)).isEqualTo(FrameworkType.PROVIDER);
-    assertThat(mapper.getFrameworkType(PRODUCER)).isEqualTo(FrameworkType.PRODUCER);
-    assertThat(mapper.getFrameworkType(PRODUCED)).isEqualTo(FrameworkType.PRODUCER);
+    assertThat(mapper.getFrameworkType(PRODUCER)).isEqualTo(FrameworkType.PRODUCER_NODE);
+    assertThat(mapper.getFrameworkType(PRODUCED)).isEqualTo(FrameworkType.PRODUCER_NODE);
   }
 }
diff --git a/javatests/dagger/internal/codegen/GeneratingProcessor.java b/javatests/dagger/internal/codegen/GeneratingProcessor.java
new file mode 100644
index 000000000..8e4e7b55b
--- /dev/null
+++ b/javatests/dagger/internal/codegen/GeneratingProcessor.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableSet;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.TypeElement;
+
+/** A simple {@link Processor} that generates one source file. */
+final class GeneratingProcessor extends AbstractProcessor {
+  private final String generatedClassName;
+  private final String generatedSource;
+  private boolean processed;
+
+  GeneratingProcessor(String generatedClassName, String... source) {
+    this.generatedClassName = generatedClassName;
+    this.generatedSource = Joiner.on("\n").join(source);
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    return ImmutableSet.of("*");
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    if (!processed) {
+      processed = true;
+      try (Writer writer =
+          processingEnv.getFiler().createSourceFile(generatedClassName).openWriter()) {
+        writer.append(generatedSource);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    }
+    return false;
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 05b4dc671..a761d52c0 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -130,10 +130,10 @@ public void mapBindingsWithEnumKey() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-                "  private volatile Provider<Map<PathEnum, Provider<Handler>>>",
-                "      mapOfPathEnumAndProviderOfHandlerProvider;",
                 "  private volatile Provider<Handler> provideAdminHandlerProvider;",
                 "  private volatile Provider<Handler> provideLoginHandlerProvider;",
+                "  private volatile Provider<Map<PathEnum, Provider<Handler>>>",
+                "      mapOfPathEnumAndProviderOfHandlerProvider;",
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
@@ -185,13 +185,14 @@ public void mapBindingsWithEnumKey() {
                 "    public T get() {",
                 "      switch (id) {",
                 "        case 0:",
-                "            return (T) getMapOfPathEnumAndProviderOfHandler();",
+                "            return (T) DaggerTestComponent.this",
+                "                 .getMapOfPathEnumAndProviderOfHandler();",
                 "        case 1:",
                 "            return (T) MapModuleOne_ProvideAdminHandlerFactory",
-                "                .proxyProvideAdminHandler(mapModuleOne);",
+                "                .proxyProvideAdminHandler(DaggerTestComponent.this.mapModuleOne);",
                 "        case 2:",
                 "            return (T) MapModuleTwo_ProvideLoginHandlerFactory",
-                "                .proxyProvideLoginHandler(mapModuleTwo);",
+                "                .proxyProvideLoginHandler(DaggerTestComponent.this.mapModuleTwo);",
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
@@ -535,10 +536,10 @@ public void mapBindingsWithStringKey() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-                "  private volatile Provider<Map<String, Provider<Handler>>>",
-                "      mapOfStringAndProviderOfHandlerProvider;",
                 "  private volatile Provider<Handler> provideAdminHandlerProvider;",
                 "  private volatile Provider<Handler> provideLoginHandlerProvider;",
+                "  private volatile Provider<Map<String, Provider<Handler>>>",
+                "      mapOfStringAndProviderOfHandlerProvider;",
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
@@ -590,13 +591,14 @@ public void mapBindingsWithStringKey() {
                 "    public T get() {",
                 "      switch (id) {",
                 "        case 0:",
-                "            return (T) getMapOfStringAndProviderOfHandler();",
+                "            return (T) DaggerTestComponent.this",
+                "                 .getMapOfStringAndProviderOfHandler();",
                 "        case 1:",
                 "            return (T) MapModuleOne_ProvideAdminHandlerFactory",
-                "                .proxyProvideAdminHandler(mapModuleOne);",
+                "                .proxyProvideAdminHandler(DaggerTestComponent.this.mapModuleOne);",
                 "        case 2:",
                 "            return (T) MapModuleTwo_ProvideLoginHandlerFactory",
-                "                .proxyProvideLoginHandler(mapModuleTwo);",
+                "                .proxyProvideLoginHandler(DaggerTestComponent.this.mapModuleTwo);",
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
@@ -733,13 +735,18 @@ public void mapBindingsWithWrappedKey() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-                "  private volatile Provider<Map<WrappedClassKey, Provider<Handler>>>",
-                "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
                 "  private volatile Provider<Handler> provideAdminHandlerProvider;",
                 "  private volatile Provider<Handler> provideLoginHandlerProvider;",
+                "  private volatile Provider<Map<WrappedClassKey, Provider<Handler>>>",
+                "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    this.mapModuleOne = builder.mapModuleOne;",
+                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "  }",
+                "",
                 "  private Provider<Handler>",
                 "        getMapOfWrappedClassKeyAndProviderOfHandlerProvider() {",
                 "        Object local = provideAdminHandlerProvider;",
@@ -769,12 +776,6 @@ public void mapBindingsWithWrappedKey() {
                 "        getMapOfWrappedClassKeyAndProviderOfHandlerProvider2());",
                 "  }",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
-                "    this.mapModuleOne = builder.mapModuleOne;",
-                "    this.mapModuleTwo = builder.mapModuleTwo;",
-                "  }",
-                "",
                 "  @Override",
                 "  public Provider<Map<WrappedClassKey, Provider<Handler>>> dispatcher() {",
                 "    Object local = mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
@@ -798,13 +799,14 @@ public void mapBindingsWithWrappedKey() {
                 "    public T get() {",
                 "      switch (id) {",
                 "        case 0:",
-                "            return (T) getMapOfWrappedClassKeyAndProviderOfHandler();",
+                "            return (T) DaggerTestComponent.this",
+                "                 .getMapOfWrappedClassKeyAndProviderOfHandler();",
                 "        case 1:",
                 "            return (T) MapModuleOne_ProvideAdminHandlerFactory",
-                "                .proxyProvideAdminHandler(mapModuleOne);",
+                "                .proxyProvideAdminHandler(DaggerTestComponent.this.mapModuleOne);",
                 "        case 2:",
                 "            return (T) MapModuleTwo_ProvideLoginHandlerFactory",
-                "                .proxyProvideLoginHandler(mapModuleTwo);",
+                "                .proxyProvideLoginHandler(DaggerTestComponent.this.mapModuleTwo);",
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
@@ -981,7 +983,7 @@ public void mapBindingsWithNonProviderValue() {
                 "    @Override",
                 "    public T get() {",
                 "      switch (id) {",
-                "        case 0: return (T) getMapOfPathEnumAndHandler();",
+                "        case 0: return (T) DaggerTestComponent.this.getMapOfPathEnumAndHandler();",
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
@@ -1088,104 +1090,4 @@ public void injectMapWithoutMapBinding() {
         .generatedSourceFile("test.DaggerTestComponent")
         .containsElementsIn(generatedComponent);
   }
-
-  @Test
-  public void mapBindingsWithDuplicateKeys() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.MapModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.StringKey;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "final class MapModule {",
-            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
-            "    return \"one\";",
-            "  }",
-            "",
-            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
-            "    return \"one again\";",
-            "  }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import java.util.Map;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component(modules = {MapModule.class})",
-            "interface TestComponent {",
-            "  Map<String, Object> objects();",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("The same map key is bound more than once");
-    assertThat(compilation).hadErrorContaining("provideObjectForAKey()");
-    assertThat(compilation).hadErrorContaining("provideObjectForAKeyAgain()");
-    assertThat(compilation).hadErrorCount(1);
-  }
-
-  @Test
-  public void mapBindingsWithInconsistentKeyAnnotations() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.MapModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.StringKey;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "final class MapModule {",
-            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
-            "    return \"one\";",
-            "  }",
-            "",
-            "  @Provides @IntoMap @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
-            "    return \"two\";",
-            "  }",
-            "}");
-    JavaFileObject stringKeyTwoFile =
-        JavaFileObjects.forSourceLines(
-            "test.StringKeyTwo",
-            "package test;",
-            "",
-            "import dagger.MapKey;",
-            "",
-            "@MapKey(unwrapValue = true)",
-            "public @interface StringKeyTwo {",
-            "  String value();",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import java.util.Map;",
-            "",
-            "@Component(modules = {MapModule.class})",
-            "interface TestComponent {",
-            "  Map<String, Object> objects();",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(module, stringKeyTwoFile, componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("uses more than one @MapKey annotation type");
-    assertThat(compilation).hadErrorContaining("provideObjectForAKey()");
-    assertThat(compilation).hadErrorContaining("provideObjectForBKey()");
-    assertThat(compilation).hadErrorCount(1);
-  }
 }
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
index 8d1b25dee..343f2613d 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -522,13 +522,19 @@ public void productionComponents() {
             "test.DaggerTestComponent",
             "package test;",
             "",
+            "import dagger.producers.internal.CancellationListener;",
+            "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
+            "public final class DaggerTestComponent implements TestComponent, "
+                + "CancellationListener {",
             "  @Override",
             "  public ListenableFuture<Map<String, String>> stringMap() {",
             "    return Futures.immediateFuture(",
             "        (Map<String, String>) ImmutableMap.<String, String>of());",
             "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {}",
             "}");
     Compilation compilation =
         daggerCompiler()
diff --git a/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java b/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java
new file mode 100644
index 000000000..b2ed61456
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MapMultibindingValidationTest {
+  @Test
+  public void duplicateMapKeys() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.StringKey;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "    return \"one\";",
+            "  }",
+            "",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
+            "    return \"one again\";",
+            "  }",
+            "}");
+
+    // If they're all there, report only Map<K, V>.
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                component(
+                    "Map<String, Object> objects();",
+                    "Map<String, Provider<Object>> objectProviders();",
+                    "Producer<Map<String, Producer<Object>>> objectProducers();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "The same map key is bound more than once for "
+                + "java.util.Map<java.lang.String,java.lang.Object>");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKey()");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKeyAgain()");
+    assertThat(compilation).hadErrorCount(1);
+
+    compilation =
+        daggerCompiler().withOptions("-Adagger.moduleBindingValidation=ERROR").compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "The same map key is bound more than once for "
+                + "java.util.Map<java.lang.String,javax.inject.Provider<java.lang.Object>>")
+        .inFile(module)
+        .onLineContaining("class MapModule");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKey()");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKeyAgain()");
+    assertThat(compilation).hadErrorCount(1);
+
+    // If there's Map<K, V> and Map<K, Provider<V>>, report only Map<K, V>.
+    compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                component(
+                    "Map<String, Object> objects();",
+                    "Map<String, Provider<Object>> objectProviders();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "The same map key is bound more than once for "
+                + "java.util.Map<java.lang.String,java.lang.Object>");
+    assertThat(compilation).hadErrorCount(1);
+
+    // If there's Map<K, V> and Map<K, Producer<V>>, report only Map<K, V>.
+    compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                component(
+                    "Map<String, Object> objects();",
+                    "Producer<Map<String, Producer<Object>>> objectProducers();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "The same map key is bound more than once for "
+                + "java.util.Map<java.lang.String,java.lang.Object>");
+    assertThat(compilation).hadErrorCount(1);
+
+    // If there's Map<K, Provider<V>> and Map<K, Producer<V>>, report only Map<K, Provider<V>>.
+    compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                component(
+                    "Map<String, Provider<Object>> objectProviders();",
+                    "Producer<Map<String, Producer<Object>>> objectProducers();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "The same map key is bound more than once for "
+                + "java.util.Map<java.lang.String,javax.inject.Provider<java.lang.Object>>");
+    assertThat(compilation).hadErrorCount(1);
+
+    compilation = daggerCompiler().compile(module, component("Map<String, Object> objects();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "The same map key is bound more than once for "
+                + "java.util.Map<java.lang.String,java.lang.Object>");
+    assertThat(compilation).hadErrorCount(1);
+
+    compilation =
+        daggerCompiler()
+            .compile(module, component("Map<String, Provider<Object>> objectProviders();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "The same map key is bound more than once for "
+                + "java.util.Map<java.lang.String,javax.inject.Provider<java.lang.Object>>");
+    assertThat(compilation).hadErrorCount(1);
+
+    compilation =
+        daggerCompiler()
+            .compile(
+                module, component("Producer<Map<String, Producer<Object>>> objectProducers();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "The same map key is bound more than once for "
+                + "java.util.Map<java.lang.String,dagger.producers.Producer<java.lang.Object>>");
+    assertThat(compilation).hadErrorCount(1);
+  }
+
+  @Test
+  public void inconsistentMapKeyAnnotations() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.StringKey;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "    return \"one\";",
+            "  }",
+            "",
+            "  @Provides @IntoMap @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
+            "    return \"two\";",
+            "  }",
+            "}");
+    JavaFileObject stringKeyTwoFile =
+        JavaFileObjects.forSourceLines(
+            "test.StringKeyTwo",
+            "package test;",
+            "",
+            "import dagger.MapKey;",
+            "",
+            "@MapKey(unwrapValue = true)",
+            "public @interface StringKeyTwo {",
+            "  String value();",
+            "}");
+
+    // If they're all there, report only Map<K, V>.
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                stringKeyTwoFile,
+                component(
+                    "Map<String, Object> objects();",
+                    "Map<String, Provider<Object>> objectProviders();",
+                    "Producer<Map<String, Producer<Object>>> objectProducers();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Map<java.lang.String,java.lang.Object>"
+                + " uses more than one @MapKey annotation type");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKey()");
+    assertThat(compilation).hadErrorContaining("provideObjectForBKey()");
+    assertThat(compilation).hadErrorCount(1);
+
+    compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .compile(module, stringKeyTwoFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Map<java.lang.String,javax.inject.Provider<java.lang.Object>>"
+                + " uses more than one @MapKey annotation type")
+        .inFile(module)
+        .onLineContaining("class MapModule");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKey()");
+    assertThat(compilation).hadErrorContaining("provideObjectForBKey()");
+    assertThat(compilation).hadErrorCount(1);
+
+    // If there's Map<K, V> and Map<K, Provider<V>>, report only Map<K, V>.
+    compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                stringKeyTwoFile,
+                component(
+                    "Map<String, Object> objects();",
+                    "Map<String, Provider<Object>> objectProviders();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Map<java.lang.String,java.lang.Object>"
+                + " uses more than one @MapKey annotation type");
+    assertThat(compilation).hadErrorCount(1);
+
+    // If there's Map<K, V> and Map<K, Producer<V>>, report only Map<K, V>.
+    compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                stringKeyTwoFile,
+                component(
+                    "Map<String, Object> objects();",
+                    "Producer<Map<String, Producer<Object>>> objectProducers();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Map<java.lang.String,java.lang.Object>"
+                + " uses more than one @MapKey annotation type");
+    assertThat(compilation).hadErrorCount(1);
+
+    // If there's Map<K, Provider<V>> and Map<K, Producer<V>>, report only Map<K, Provider<V>>.
+    compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                stringKeyTwoFile,
+                component(
+                    "Map<String, Provider<Object>> objectProviders();",
+                    "Producer<Map<String, Producer<Object>>> objectProducers();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Map<java.lang.String,javax.inject.Provider<java.lang.Object>>"
+                + " uses more than one @MapKey annotation type");
+    assertThat(compilation).hadErrorCount(1);
+
+    compilation =
+        daggerCompiler()
+            .compile(module, stringKeyTwoFile, component("Map<String, Object> objects();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Map<java.lang.String,java.lang.Object>"
+                + " uses more than one @MapKey annotation type");
+    assertThat(compilation).hadErrorCount(1);
+
+    compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                stringKeyTwoFile,
+                component("Map<String, Provider<Object>> objectProviders();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Map<java.lang.String,javax.inject.Provider<java.lang.Object>>"
+                + " uses more than one @MapKey annotation type");
+    assertThat(compilation).hadErrorCount(1);
+
+    compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                stringKeyTwoFile,
+                component("Producer<Map<String, Producer<Object>>> objectProducers();"));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Map<java.lang.String,dagger.producers.Producer<java.lang.Object>>"
+                + " uses more than one @MapKey annotation type");
+    assertThat(compilation).hadErrorCount(1);
+  }
+
+  private static JavaFileObject component(String... entryPoints) {
+    return JavaFileObjects.forSourceLines(
+        "test.TestComponent",
+        ImmutableList.<String>builder()
+            .add(
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "import dagger.producers.Producer;",
+                "import java.util.Map;",
+                "import javax.inject.Provider;",
+                "",
+                "@Component(modules = {MapModule.class})",
+                "interface TestComponent {")
+            .add(entryPoints)
+            .add("}")
+            .build());
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MissingBindingValidationTest.java b/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
index 66e81a8c7..661379459 100644
--- a/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
@@ -305,7 +305,7 @@ public void genericInjectClassWithWildcardDependencies() {
             message(
                 "test.TestClass.A cannot be provided without an @Provides-annotated method.",
                 "    test.TestClass.A is injected at",
-                "        test.TestClass.B.<init>(a)",
+                "        test.TestClass.B(a)",
                 "    test.TestClass.B is injected at",
                 "        test.TestClass.C.b",
                 "    test.TestClass.C is injected at",
@@ -360,7 +360,7 @@ public void bindsMethodAppearsInTrace() {
                 "java.lang.String cannot be provided without an @Inject constructor or an "
                     + "@Provides-annotated method.",
                 "    java.lang.String is injected at",
-                "        TestImplementation.<init>(missingBinding)",
+                "        TestImplementation(missingBinding)",
                 "    TestImplementation is injected at",
                 "        TestModule.bindTestInterface(implementation)",
                 "    TestInterface is provided at",
@@ -413,11 +413,11 @@ public void bindsMethodAppearsInTrace() {
             message(
                 "java.util.List cannot be provided without an @Provides-annotated method.",
                 "    java.util.List is injected at",
-                "        test.TestClass.<init>(list)",
+                "        test.TestClass(list)",
                 "    test.TestClass is injected at",
-                "        test.Generic.<init>(t)",
+                "        test.Generic(t)",
                 "    test.Generic<test.TestClass> is injected at",
-                "        test.UsesTest.<init>(genericTestClass)",
+                "        test.UsesTest(genericTestClass)",
                 "    test.UsesTest is provided at",
                 "        test.TestComponent.usesTest()"));
   }
@@ -467,11 +467,11 @@ public void bindsMethodAppearsInTrace() {
             message(
                 "java.util.List cannot be provided without an @Provides-annotated method.",
                 "    java.util.List is injected at",
-                "        test.TestClass.<init>(list)",
+                "        test.TestClass(list)",
                 "    test.TestClass is injected at",
                 "        test.Generic.t",
                 "    test.Generic<test.TestClass> is injected at",
-                "        test.UsesTest.<init>(genericTestClass)",
+                "        test.UsesTest(genericTestClass)",
                 "    test.UsesTest is provided at",
                 "        test.TestComponent.usesTest()"));
   }
diff --git a/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java b/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java
new file mode 100644
index 000000000..dee9a8ff7
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ModuleBindingValidationTest {
+  private static final JavaFileObject MODULE =
+      JavaFileObjects.forSourceLines(
+          "test.TestModule",
+          "package test;",
+          "",
+          "import dagger.Binds;",
+          "import dagger.Module;",
+          "",
+          "@Module",
+          "interface TestModule {",
+          "  @Binds Object toString(String string);",
+          "  @Binds Object toLong(Long l);",
+          "}");
+
+  private static final JavaFileObject INCLUDING_MODULE =
+      JavaFileObjects.forSourceLines(
+          "test.IncludingModule",
+          "package test;",
+          "",
+          "import dagger.Module;",
+          "",
+          "@Module(includes = TestModule.class)",
+          "interface IncludingModule {}");
+
+  @Test
+  public void moduleBindingValidationErrors() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .compile(MODULE, INCLUDING_MODULE);
+    assertThat(compilation).failed();
+
+    // Make sure the module-level error doesn't show a dependency trace afterwards (note the $).
+    assertThat(compilation)
+        .hadErrorContainingMatch(
+            message(
+                "^\\Q[Dagger/DuplicateBindings] java.lang.Object is bound multiple times:",
+                "    @Binds Object test.TestModule.toLong(Long)",
+                "    @Binds Object test.TestModule.toString(String)\\E$"))
+        .inFile(MODULE)
+        .onLineContaining("interface TestModule");
+
+    assertThat(compilation)
+        .hadErrorContaining("test.TestModule has errors")
+        .inFile(INCLUDING_MODULE)
+        .onLineContaining("TestModule.class");
+
+    // The duplicate bindings error is reported only once, for TestModule, and not again for
+    // IncludingModule.
+    assertThat(compilation).hadErrorCount(2);
+  }
+
+  @Test
+  public void moduleBindingValidationWarning() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=WARNING")
+            .compile(MODULE, INCLUDING_MODULE);
+    assertThat(compilation).succeeded();
+
+    assertThat(compilation)
+        .hadWarningContainingMatch(
+            message(
+                "^\\Q[Dagger/DuplicateBindings] java.lang.Object is bound multiple times:",
+                "    @Binds Object test.TestModule.toLong(Long)",
+                "    @Binds Object test.TestModule.toString(String)\\E$"))
+        .inFile(MODULE)
+        .onLineContaining("interface TestModule");
+
+    // Make sure the module-level error doesn't show a dependency trace.
+    assertThat(compilation)
+        .hadWarningContainingMatch(
+            message(
+                "^\\Q[Dagger/DuplicateBindings] java.lang.Object is bound multiple times:",
+                "    @Binds Object test.TestModule.toLong(Long)",
+                "    @Binds Object test.TestModule.toString(String)\\E$"))
+        .inFile(INCLUDING_MODULE)
+        .onLineContaining("interface IncludingModule");
+
+    // If module binding validation reports warnings, the duplicate bindings warning occurs twice:
+    // once for TestModule and once for IncludingModule, which includes it.
+    assertThat(compilation).hadWarningCount(2);
+  }
+
+  @Test
+  public void moduleBindingValidationNone() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=NONE")
+            .compile(MODULE, INCLUDING_MODULE);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MultibindingTest.java b/javatests/dagger/internal/codegen/MultibindingTest.java
index fb156cd57..2bf949470 100644
--- a/javatests/dagger/internal/codegen/MultibindingTest.java
+++ b/javatests/dagger/internal/codegen/MultibindingTest.java
@@ -58,7 +58,7 @@ public void providesWithTwoMultibindingAnnotations_failsToCompile() {
 
   @Test
   public void appliedOnInvalidMethods_failsToCompile() {
-    JavaFileObject component =
+    JavaFileObject someType =
         JavaFileObjects.forSourceLines(
             "test.SomeType",
             "package test;",
@@ -76,23 +76,23 @@ public void appliedOnInvalidMethods_failsToCompile() {
             "  @IntoMap Map<Integer, Double> map();",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation = daggerCompiler().compile(someType);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
-        .inFile(component)
-        .onLine(11);
+        .inFile(someType)
+        .onLineContaining("ints();");
     assertThat(compilation)
         .hadErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
-        .inFile(component)
-        .onLine(12);
+        .inFile(someType)
+        .onLineContaining("doubles();");
     assertThat(compilation)
         .hadErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
-        .inFile(component)
-        .onLine(13);
+        .inFile(someType)
+        .onLineContaining("map();");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/NullableBindingValidationTest.java b/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
index 710f77721..eb0dc2343 100644
--- a/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
@@ -387,4 +387,33 @@ public void nullCheckForOptionalProviderOfLazy() {
     Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
     assertThat(compilation).succeeded();
   }
+
+  @Test
+  public void moduleValidation() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides @Nullable static String nullableString() { return null; }",
+            "  @Binds abstract Object object(String string);",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .compile(module, NULLABLE);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@Provides @test.Nullable String test.TestModule.nullableString()"));
+  }
 }
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index 563a7c283..338b62eb1 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -246,9 +246,11 @@ public void requestForFuture() {
             "package test;",
             "",
             "import com.google.common.base.Optional;",
+            "import dagger.producers.internal.CancellationListener;",
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
+            "public final class DaggerTestComponent implements TestComponent, "
+                + "CancellationListener {",
             "  @Override",
             "  public ListenableFuture<Optional<Maybe>> maybe() {",
             "    return Futures.immediateFuture(",
@@ -260,6 +262,9 @@ public void requestForFuture() {
             "    return Futures.immediateFuture(Optional.<DefinitelyNot>absent());",
 
             "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {}",
             "}");
 
     Compilation compilation =
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index cd9a97779..0b4b2116f 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -373,7 +373,7 @@ public void publicModuleNonPublicIncludes() {
             "    extends AbstractProducesMethodProducer<Void, String> {",
             "  private final TestModule module;",
             "",
-            "  public TestModule_ProduceStringFactory(",
+            "  private TestModule_ProduceStringFactory(",
             "      TestModule module,",
             "      Provider<Executor> executorProvider,",
             "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
@@ -384,6 +384,14 @@ public void publicModuleNonPublicIncludes() {
             "    this.module = module;",
             "  }",
             "",
+            "  public static TestModule_ProduceStringFactory create(",
+            "      TestModule module,",
+            "      Provider<Executor> executorProvider,",
+            "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
+            "    return new TestModule_ProduceStringFactory(",
+            "        module, executorProvider, productionComponentMonitorProvider);",
+            "  }",
+            "",
             "  @Override protected ListenableFuture<Void> collectDependencies() {",
             "    return Futures.<Void>immediateFuture(null);",
             "  }",
@@ -438,7 +446,7 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "    extends AbstractProducesMethodProducer<Void, String> {",
             "  private final TestModule module;",
             "",
-            "  public TestModule_ProduceStringFactory(",
+            "  private TestModule_ProduceStringFactory(",
             "      TestModule module,",
             "      Provider<Executor> executorProvider,",
             "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
@@ -449,6 +457,14 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "    this.module = module;",
             "  }",
             "",
+            "  public static TestModule_ProduceStringFactory create(",
+            "      TestModule module,",
+            "      Provider<Executor> executorProvider,",
+            "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
+            "    return new TestModule_ProduceStringFactory(",
+            "        module, executorProvider, productionComponentMonitorProvider);",
+            "  }",
+            "",
             "  @Override protected ListenableFuture<Void> collectDependencies() {",
             "    return Futures.<Void>immediateFuture(null);",
             "  }",
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 4486dd733..3bb87e666 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -158,10 +158,23 @@ public void dependsOnProductionExecutor() {
             "}");
     Compilation compilation =
         daggerCompiler()
-            .withOptions(compilerMode.javacopts())
             .compile(moduleFile, producerModuleFile, componentFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("may not depend on the production executor");
+    assertThat(compilation)
+        .hadErrorContaining("java.lang.String may not depend on the production executor")
+        .inFile(componentFile)
+        .onLineContaining("interface SimpleComponent");
+
+    compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .compile(producerModuleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("java.lang.String may not depend on the production executor")
+        .inFile(producerModuleFile)
+        .onLineContaining("class SimpleModule");
+    // TODO(dpb): Report at the binding if enclosed in the module.
   }
 
   @Test
@@ -228,6 +241,7 @@ public void simpleComponent() {
                 "import dagger.internal.Preconditions;",
                 "import dagger.internal.SetFactory;",
                 "import dagger.producers.Producer;",
+                "import dagger.producers.internal.CancellationListener;",
                 "import dagger.producers.internal.Producers;",
                 "import dagger.producers.monitoring.ProductionComponentMonitor;",
                 "import java.util.concurrent.Executor;",
@@ -236,19 +250,21 @@ public void simpleComponent() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestClass_SimpleComponent",
-                "    implements TestClass.SimpleComponent {",
-                "  private volatile Provider<Executor> executorProvider;",
+                "    implements TestClass.SimpleComponent, CancellationListener {",
                 "  private volatile Object productionImplementationExecutor =",
                 "      new MemoizedSentinel();",
-                "  private volatile Provider<ProductionComponentMonitor> monitorProvider;",
+                "  private volatile Provider<Executor> productionImplementationExecutorProvider;",
                 "  private volatile Object productionComponentMonitor = new MemoizedSentinel();",
+                "  private volatile Provider<ProductionComponentMonitor> monitorProvider;",
                 "  private volatile Provider<TestClass.B> bProvider;",
                 "  private TestClass.BModule bModule;",
+                "  private Producer<TestClass.A> aEntryPoint;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
                 "  private Producer<TestClass.B> bProducer;",
                 "  private TestClass_AModule_AFactory aProducer;",
                 "",
                 "  private DaggerTestClass_SimpleComponent(Builder builder) {",
+                "    this.bModule = builder.bModule;",
                 "    initialize(builder);",
                 "  }",
                 "",
@@ -267,9 +283,7 @@ public void simpleComponent() {
                 "        local = productionImplementationExecutor;",
                 "        if (local instanceof MemoizedSentinel) {",
                 "          local =",
-                "              TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
-                "                  .proxyExecutor(",
-                "                      TestClass_BModule_ExecutorFactory.proxyExecutor(bModule));",
+                "              TestClass_BModule_ExecutorFactory.proxyExecutor(bModule);",
                 "          productionImplementationExecutor =",
                 "              DoubleCheck.reentrantCheck(",
                 "                  productionImplementationExecutor, local);",
@@ -280,10 +294,10 @@ public void simpleComponent() {
                 "  }",
                 "",
                 "  private Provider<Executor> getProductionImplementationExecutorProvider() {",
-                "    Object local = executorProvider;",
+                "    Object local = productionImplementationExecutorProvider;",
                 "    if (local == null) {",
                 "      local = new SwitchingProvider<>(0);",
-                "      executorProvider = (Provider<Executor>) local;",
+                "      productionImplementationExecutorProvider = (Provider<Executor>) local;",
                 "    }",
                 "    return (Provider<Executor>) local;",
                 "  }",
@@ -333,21 +347,27 @@ public void simpleComponent() {
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
                 "  private void initialize(final Builder builder) {",
-                "    this.bModule = builder.bModule;",
                 "    this.simpleComponentProvider =",
                 "        InstanceFactory.create((TestClass.SimpleComponent) this);",
                 "    this.bProducer = Producers.producerFromProvider(getBProvider());",
                 "    this.aProducer =",
-                "        new TestClass_AModule_AFactory(",
+                "        TestClass_AModule_AFactory.create(",
                 "            builder.aModule,",
                 "            getProductionImplementationExecutorProvider(),",
                 "            getProductionComponentMonitorProvider(),",
                 "            bProducer);",
+                "    this.aEntryPoint = Producers.entryPointViewOf(aProducer, this);",
                 "  }",
                 "",
                 "  @Override",
                 "  public ListenableFuture<TestClass.A> a() {",
-                "    return aProducer.get();",
+                "    return aEntryPoint.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+                "    Producers.cancel(aProducer, mayInterruptIfRunning);",
+                "    Producers.cancel(bProducer, mayInterruptIfRunning);",
                 "  }",
                 "",
                 "  public static final class Builder {",
@@ -375,16 +395,8 @@ public void simpleComponent() {
                 "      this.bModule = Preconditions.checkNotNull(bModule);",
                 "      return this;",
                 "    }",
-                "",
-                "    @Deprecated",
-                "    public Builder testClass_SimpleComponent_ProductionExecutorModule(",
-                "        TestClass_SimpleComponent_ProductionExecutorModule",
-                "            testClass_SimpleComponent_ProductionExecutorModule) {",
-                "      Preconditions.checkNotNull(",
-                "          testClass_SimpleComponent_ProductionExecutorModule);",
-                "      return this;",
-                "    }",
                 "  }",
+                "",
                 "  private final class SwitchingProvider<T> implements Provider<T> {",
                 "    private final int id;",
                 "",
@@ -396,9 +408,12 @@ public void simpleComponent() {
                 "    @Override",
                 "    public T get() {",
                 "      switch (id) {",
-                "        case 0: return (T) getProductionImplementationExecutor();",
-                "        case 1: return (T) getProductionComponentMonitor();",
-                "        case 2: return (T) getB();",
+                "        case 0: return (T) DaggerTestClass_SimpleComponent.this",
+                "            .getProductionImplementationExecutor();",
+                "        case 1: return (T)",
+                "            DaggerTestClass_SimpleComponent.this.getProductionComponentMonitor();",
+                "        case 2: return (T)",
+                "            DaggerTestClass_SimpleComponent.this.getB();",
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
@@ -417,6 +432,7 @@ public void simpleComponent() {
                 "import dagger.internal.Preconditions;",
                 "import dagger.internal.SetFactory;",
                 "import dagger.producers.Producer;",
+                "import dagger.producers.internal.CancellationListener;",
                 "import dagger.producers.internal.Producers;",
                 "import dagger.producers.monitoring.ProductionComponentMonitor;",
                 "import java.util.concurrent.Executor;",
@@ -425,9 +441,10 @@ public void simpleComponent() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestClass_SimpleComponent",
-                "    implements TestClass.SimpleComponent {",
+                "    implements TestClass.SimpleComponent, CancellationListener {",
+                "  private Producer<TestClass.A> aEntryPoint;",
                 "  private TestClass_BModule_ExecutorFactory executorProvider;",
-                "  private Provider<Executor> executorProvider2;",
+                "  private Provider<Executor> productionImplementationExecutorProvider;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
                 "  private Provider<ProductionComponentMonitor> monitorProvider;",
                 "  private TestClass_BModule_BFactory bProvider;",
@@ -451,10 +468,8 @@ public void simpleComponent() {
                 "  private void initialize(final Builder builder) {",
                 "    this.executorProvider =",
                 "        TestClass_BModule_ExecutorFactory.create(builder.bModule);",
-                "    this.executorProvider2 =",
-                "        DoubleCheck.provider(",
-                "            TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
-                "                .create(executorProvider));",
+                "    this.productionImplementationExecutorProvider =",
+                "        DoubleCheck.provider((Provider) executorProvider);",
                 "    this.simpleComponentProvider = ",
                 "        InstanceFactory.create((TestClass.SimpleComponent) this);",
                 "    this.monitorProvider =",
@@ -465,16 +480,23 @@ public void simpleComponent() {
                 "    this.bProvider = TestClass_BModule_BFactory.create(",
                 "        builder.bModule, TestClass_C_Factory.create());",
                 "    this.bProducer = Producers.producerFromProvider(bProvider);",
-                "    this.aProducer = new TestClass_AModule_AFactory(",
+                "    this.aProducer = TestClass_AModule_AFactory.create(",
                 "        builder.aModule,",
-                "        executorProvider2,",
+                "        productionImplementationExecutorProvider,",
                 "        monitorProvider,",
                 "        bProducer);",
+                "    this.aEntryPoint = Producers.entryPointViewOf(aProducer, this);",
                 "  }",
                 "",
                 "  @Override",
                 "  public ListenableFuture<TestClass.A> a() {",
-                "    return aProducer.get();",
+                "    return aEntryPoint.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+                "    Producers.cancel(aProducer, mayInterruptIfRunning);",
+                "    Producers.cancel(bProducer, mayInterruptIfRunning);",
                 "  }",
                 "",
                 "  public static final class Builder {",
@@ -502,14 +524,6 @@ public void simpleComponent() {
                 "      this.bModule = Preconditions.checkNotNull(bModule);",
                 "      return this;",
                 "    }",
-                "",
-                "    @Deprecated",
-                "    public Builder testClass_SimpleComponent_ProductionExecutorModule(",
-                "        TestClass_SimpleComponent_ProductionExecutorModule",
-                "            testClass_SimpleComponent_ProductionExecutorModule) {",
-                "      Preconditions.checkNotNull(testClass_SimpleComponent_ProductionExecutorModule);",
-                "      return this;",
-                "    }",
                 "  }",
                 "}");
     }
@@ -582,4 +596,137 @@ public void simpleComponent() {
         .inFile(component)
         .onLine(36);
   }
+
+  @Test
+  public void productionScope_provides() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.producers.ProductionScope;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides",
+            "  @ProductionScope",
+            "  static int i() {",
+            "    return 1;",
+            "  }",
+            "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(modules = TestModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent(modules = TestModule.class)",
+            "interface Child {",
+            "  int i();",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, parent, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .containsElementsIn(
+            new JavaFileBuilder(compilerMode, "test.DaggerRoot")
+                .addLines(
+                    "package test;",
+                    GENERATED_ANNOTATION,
+                    "public final class DaggerParent implements Parent, CancellationListener {",
+                    "  private final class ChildImpl implements Child, CancellationListener {",
+                    "    @Override",
+                    "    public int i() {")
+                .addLinesIn(
+                    CompilerMode.DEFAULT_MODE, //
+                    "      return DaggerParent.this.iProvider.get();")
+                .addLinesIn(
+                    CompilerMode.FAST_INIT_MODE, //
+                    "      return DaggerParent.this.getInteger();")
+                .addLines(
+                    "    }", //
+                    "  }", //
+                    "}")
+                .build());
+  }
+
+  @Test
+  public void productionScope_injectConstructor() {
+    JavaFileObject productionScoped =
+        JavaFileObjects.forSourceLines(
+            "test.ProductionScoped",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionScope;",
+            "import javax.inject.Inject;",
+            "",
+            "@ProductionScope",
+            "class ProductionScoped {",
+            "  @Inject ProductionScoped() {}",
+            "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent",
+            "interface Child {",
+            "  ProductionScoped productionScoped();",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(productionScoped, parent, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .containsElementsIn(
+            new JavaFileBuilder(compilerMode, "test.DaggerRoot")
+                .addLines(
+                    "package test;",
+                    GENERATED_ANNOTATION,
+                    "public final class DaggerParent implements Parent, CancellationListener {",
+                    "  private final class ChildImpl implements Child, CancellationListener {",
+                    "    @Override",
+                    "    public ProductionScoped productionScoped() {")
+                .addLinesIn(
+                    CompilerMode.DEFAULT_MODE, //
+                    "      return DaggerParent.this.productionScopedProvider.get();")
+                .addLinesIn(
+                    CompilerMode.FAST_INIT_MODE, //
+                    "      return DaggerParent.this.getProductionScoped();")
+                .addLines(
+                    "    }", //
+                    "  }", //
+                    "}")
+                .build());
+  }
 }
diff --git a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
index 1029c1cd5..7106dd9e7 100644
--- a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -110,39 +110,40 @@
   }
 
   @Test public void provisionDependsOnProduction() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import dagger.producers.ProductionComponent;",
-        "",
-        "final class TestClass {",
-        "  interface A {}",
-        "  interface B {}",
-        "",
-        "  @Module",
-        "  final class AModule {",
-        "    @Provides A a(B b) {",
-        "      return null;",
-        "    }",
-        "  }",
-        "",
-        "  @ProducerModule",
-        "  final class BModule {",
-        "    @Produces ListenableFuture<B> b() {",
-        "      return null;",
-        "    }",
-        "  }",
-        "",
-        "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class, BModule.class})",
-        "  interface AComponent {",
-        "    ListenableFuture<A> getA();",
-        "  }",
-        "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "  interface B {}",
+            "",
+            "  @ProducerModule(includes = BModule.class)",
+            "  final class AModule {",
+            "    @Provides A a(B b) {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  final class BModule {",
+            "    @Produces ListenableFuture<B> b() {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class})",
+            "  interface AComponent {",
+            "    ListenableFuture<A> getA();",
+            "  }",
+            "}");
 
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
@@ -150,6 +151,16 @@
         .hadErrorContaining("test.TestClass.A is a provision, which cannot depend on a production.")
         .inFile(component)
         .onLineContaining("interface AComponent");
+
+    compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.TestClass.A is a provision, which cannot depend on a production.")
+        .inFile(component)
+        .onLineContaining("class AModule");
   }
 
   @Test public void provisionEntryPointDependsOnProduction() {
diff --git a/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java b/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java
deleted file mode 100644
index ad039cad3..000000000
--- a/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java
+++ /dev/null
@@ -1,490 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.TestUtils.message;
-
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ReleasableReferenceManagerValidationTest {
-  @Test
-  public void missingReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@BadMetadata",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject otherScope =
-        JavaFileObjects.forSourceLines(
-            "test.OtherScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface OtherScope {}");
-    JavaFileObject yetAnotherScope =
-        JavaFileObjects.forSourceLines(
-            "test.YetAnotherScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface YetAnotherScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-    JavaFileObject badMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.BadMetadata", // force one-string-per-line format
-            "package test;",
-            "",
-            "@interface BadMetadata {}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponents",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "",
-            "interface TestComponents {",
-            "  @TestScope",
-            "  @YetAnotherScope",
-            "  @Component",
-            "  interface WrongScopeComponent {",
-            "    @ForReleasableReferences(OtherScope.class)",
-            "    ReleasableReferenceManager otherManager();",
-            "  }",
-            "",
-            "  @TestScope",
-            "  @YetAnotherScope",
-            "  @Component",
-            "  interface WrongMetadataComponent {",
-            "    @ForReleasableReferences(TestScope.class)",
-            "    TypedReleasableReferenceManager<TestMetadata> wrongMetadata();",
-            "  }",
-            "",
-            "  @TestScope",
-            "  @YetAnotherScope",
-            "  @Component",
-            "  interface BadMetadataComponent {",
-            "    @ForReleasableReferences(TestScope.class)",
-            "    TypedReleasableReferenceManager<BadMetadata> badManager();",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .compile(testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
-                + "dagger.releasablereferences.ReleasableReferenceManager "
-                + "because no component in test.TestComponents.WrongScopeComponent's "
-                + "component hierarchy is annotated with @test.OtherScope. "
-                + "The available reference-releasing scopes are "
-                + "[@test.TestScope, @test.YetAnotherScope].")
-        .inFile(component)
-        .onLineContaining("interface WrongScopeComponent");
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
-                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
-                + "because test.TestScope is not annotated with @test.TestMetadata")
-        .inFile(component)
-        .onLineContaining("interface WrongMetadataComponent");
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
-                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
-                + "because test.BadMetadata is not annotated with "
-                + "@dagger.releasablereferences.CanReleaseReferences")
-        .inFile(component)
-        .onLineContaining("interface BadMetadataComponent");
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict_ReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides @ForReleasableReferences(TestScope.class)",
-            "  static ReleasableReferenceManager rrm() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  ReleasableReferenceManager testManager();",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(testScope, testMetadata, testModule, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                message(
-                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager is bound multiple times:",
-                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
-                    "    binding for "
-                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager from the scope declaration"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLineContaining("interface TestComponent");
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict_TypedReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides @ForReleasableReferences(TestScope.class)",
-            "  static TypedReleasableReferenceManager<TestMetadata> typedRrm() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(testScope, testMetadata, testModule, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                message(
-                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "is bound multiple times:",
-                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "test.TestModule.typedRrm()",
-                    "    binding for "
-                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "from the scope declaration"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLineContaining("interface TestComponent");
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict_SetOfReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides",
-            "  static Set<ReleasableReferenceManager> rrmSet() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  Set<ReleasableReferenceManager> managers();",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(testScope, testMetadata, testModule, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
-                    + "is bound multiple times:",
-                "    @Provides "
-                    + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
-                    + "test.TestModule.rrmSet()",
-                "    Dagger-generated binding for "
-                    + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
-        .inFile(component)
-        .onLineContaining("interface TestComponent");
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict_SetOfTypedReleasableReferenceManagers() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides",
-            "  static Set<TypedReleasableReferenceManager<TestMetadata>> typedRrmSet() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(testScope, testMetadata, testModule, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                message(
-                    "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
-                        + "is bound multiple times:",
-                    "    @Provides "
-                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
-                        + "test.TestModule.typedRrmSet()",
-                    "    Dagger-generated binding for "
-                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLineContaining("interface TestComponent");
-  }
-}
diff --git a/javatests/dagger/internal/codegen/ScopingValidationTest.java b/javatests/dagger/internal/codegen/ScopingValidationTest.java
index cbe358013..c8322063f 100644
--- a/javatests/dagger/internal/codegen/ScopingValidationTest.java
+++ b/javatests/dagger/internal/codegen/ScopingValidationTest.java
@@ -237,7 +237,150 @@ public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
                 "    @test.PerTest class test.ScopedType",
                 "    @Provides @test.PerTest String test.ScopedModule.string()",
                 "    @Provides @test.Per(test.MyComponent.class) boolean "
-                    + "test.ScopedModule.bool()"));
+                    + "test.ScopedModule.bool()"))
+        .inFile(componentFile)
+        .onLineContaining("interface MyComponent");
+
+    compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .compile(componentFile, scopeFile, scopeWithAttribute, typeFile, moduleFile);
+    // The @Inject binding for ScopedType should not appear here, but the @Singleton binding should.
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ScopedModule contains bindings with different scopes:",
+                "    @Provides @test.PerTest String test.ScopedModule.string()",
+                "    @Provides @Singleton float test.ScopedModule.floatingPoint()",
+                "    @Provides @test.Per(test.MyComponent.class) boolean "
+                    + "test.ScopedModule.bool()"))
+        .inFile(moduleFile)
+        .onLineContaining("class ScopedModule");
+  }
+
+  @Test
+  public void moduleBindingValidationDoesNotReportForOneScope() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(
+                "-Adagger.moduleBindingValidation=ERROR",
+                "-Adagger.moduleHasDifferentScopesValidation=ERROR")
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "test.TestModule",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "import javax.inject.Singleton;",
+                    "",
+                    "@Module",
+                    "interface TestModule {",
+                    "  @Provides @Singleton static Object object() { return \"object\"; }",
+                    "  @Provides @Singleton static String string() { return \"string\"; }",
+                    "  @Provides static int integer() { return 4; }",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void moduleBindingValidationDoesNotReportInjectBindings() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(
+                "-Adagger.moduleBindingValidation=ERROR",
+                "-Adagger.moduleHasDifferentScopesValidation=ERROR")
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "test.UsedInRootRedScoped",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "@RedScope",
+                    "final class UsedInRootRedScoped {",
+                    "  @Inject UsedInRootRedScoped() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.UsedInRootBlueScoped",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "@BlueScope",
+                    "final class UsedInRootBlueScoped {",
+                    "  @Inject UsedInRootBlueScoped() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.RedScope",
+                    "package test;",
+                    "",
+                    "import javax.inject.Scope;",
+                    "",
+                    "@Scope",
+                    "@interface RedScope {}"),
+                JavaFileObjects.forSourceLines(
+                    "test.BlueScope",
+                    "package test;",
+                    "",
+                    "import javax.inject.Scope;",
+                    "",
+                    "@Scope",
+                    "@interface BlueScope {}"),
+                JavaFileObjects.forSourceLines(
+                    "test.TestModule",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "import javax.inject.Singleton;",
+                    "",
+                    "@Module(subcomponents = Child.class)",
+                    "interface TestModule {",
+                    "  @Provides @Singleton",
+                    "  static Object object(",
+                    "      UsedInRootRedScoped usedInRootRedScoped,",
+                    "      UsedInRootBlueScoped usedInRootBlueScoped) {",
+                    "    return \"object\";",
+                    "  }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.Child",
+                    "package test;",
+                    "",
+                    "import dagger.Subcomponent;",
+                    "",
+                    "@Subcomponent",
+                    "interface Child {",
+                    "  UsedInChildRedScoped usedInChildRedScoped();",
+                    "  UsedInChildBlueScoped usedInChildBlueScoped();",
+                    "",
+                    "  @Subcomponent.Builder",
+                    "  interface Builder {",
+                    "    Child child();",
+                    "  }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.UsedInChildRedScoped",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "@RedScope",
+                    "final class UsedInChildRedScoped {",
+                    "  @Inject UsedInChildRedScoped() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.UsedInChildBlueScoped",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "@BlueScope",
+                    "final class UsedInChildBlueScoped {",
+                    "  @Inject UsedInChildBlueScoped() {}",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index 0274d96d2..20ef6a2b6 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -329,12 +329,13 @@ public void productionComponents() {
             "import com.google.common.collect.ImmutableSet;",
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.internal.Preconditions;",
+            "import dagger.producers.internal.CancellationListener;",
             "import java.util.Set;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
+            "public final class DaggerTestComponent implements TestComponent, "
+                + "CancellationListener {",
             "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
@@ -355,20 +356,15 @@ public void productionComponents() {
             "    return Futures.immediateFuture(getSetOfString());",
             "  }",
             "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {}",
+            "",
             "  public static final class Builder {",
             "    private Builder() {}",
             "",
             "    public TestComponent build() {",
             "      return new DaggerTestComponent(this);",
             "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder testComponent_ProductionExecutorModule(",
-            "        TestComponent_ProductionExecutorModule",
-            "            testComponent_ProductionExecutorModule) {",
-            "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
-            "      return this;",
-            "    }",
             "  }",
             "}");
 
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 3cfed6971..e6fe41026 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -31,8 +31,8 @@
 @RunWith(JUnit4.class)
 public class SubcomponentBuilderValidationTest {
 
-  private static final ErrorMessages.SubcomponentBuilderMessages MSGS =
-      new ErrorMessages.SubcomponentBuilderMessages();
+  private static final ErrorMessages.SubcomponentCreatorMessages MSGS =
+      new ErrorMessages.SubcomponentCreatorMessages();
 
   @Test
   public void testRefSubcomponentAndSubBuilderFails() {
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 212e62aae..ca3fd35ae 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -540,7 +540,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "    private ChildModule childModule;",
                 "",
                 "    private ChildComponentImpl() {",
-                "      initialize();",
+                "      this.childModule = new ChildModule();",
                 "    }",
                 "")
             .addLinesIn(
@@ -567,11 +567,6 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "              DaggerParentComponent.this.getDep1(),",
                 "              DaggerParentComponent.this.getDep2()));")
             .addLines(
-                "    }",
-                "",
-                "    @SuppressWarnings(\"unchecked\")",
-                "    private void initialize() {",
-                "      this.childModule = new ChildModule();",
                 "    }",
                 "",
                 "    @Override",
@@ -1114,4 +1109,57 @@ public void duplicateBindingWithSubcomponentDeclaration() {
     assertThat(compilation)
         .hadErrorContaining("@Module(subcomponents = test.Sub.class) for test.TestModule");
   }
+
+  @Test
+  public void subcomponentDependsOnGeneratedType() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child.Builder childBuilder();",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child extends ChildSupertype {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+
+    JavaFileObject childSupertype =
+        JavaFileObjects.forSourceLines(
+            "test.ChildSupertype",
+            "package test;",
+            "",
+            "interface ChildSupertype {",
+            "  GeneratedType generatedType();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler(
+                new GeneratingProcessor(
+                    "test.GeneratedType",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "final class GeneratedType {",
+                    "  @Inject GeneratedType() {}",
+                    "}"))
+            .compile(parent, child, childSupertype);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
 }
diff --git a/javatests/dagger/internal/codegen/SwitchingProviderTest.java b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
index 721d322a1..cfd4706ee 100644
--- a/javatests/dagger/internal/codegen/SwitchingProviderTest.java
+++ b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
@@ -335,8 +335,8 @@ public void scopedBinds() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-                "  private volatile Provider<CharSequence> cProvider;",
                 "  private volatile Object charSequence = new MemoizedSentinel();",
+                "  private volatile Provider<CharSequence> cProvider;",
                 "",
                 "  private CharSequence getCharSequence() {",
                 "    Object local = charSequence;",
@@ -373,7 +373,7 @@ public void scopedBinds() {
                 "    public T get() {",
                 "      switch (id) {",
                 "        case 0:",
-                "          return (T) getCharSequence();",
+                "          return (T) DaggerTestComponent.this.getCharSequence();",
                 "        default:",
                 "          throw new AssertionError(id);",
                 "      }",
diff --git a/javatests/dagger/producers/BUILD b/javatests/dagger/producers/BUILD
index 58a8987c0..1e1bd6603 100644
--- a/javatests/dagger/producers/BUILD
+++ b/javatests/dagger/producers/BUILD
@@ -28,6 +28,7 @@ load("//:test_defs.bzl", "GenJavaTests")
 GenJavaTests(
     name = "producers_tests",
     srcs = glob(["**/*.java"]),
+    functional = 0,
     javacopts = SOURCE_7_TARGET_7 + DOCLINT_REFERENCES + DOCLINT_HTML_AND_SYNTAX,
     deps = [
         "//java/dagger/producers",
diff --git a/javatests/dagger/producers/internal/MapOfProducerProducerTest.java b/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
index 645a016b5..fe285ed5c 100644
--- a/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
+++ b/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
@@ -31,7 +31,7 @@
   @Test
   public void success() throws Exception {
     MapOfProducerProducer<Integer, String> mapOfProducerProducer =
-        MapOfProducerProducer.<Integer, String>builder()
+        MapOfProducerProducer.<Integer, String>builder(2)
             .put(15, Producers.<String>immediateProducer("fifteen"))
             .put(42, Producers.<String>immediateProducer("forty two"))
             .build();
@@ -47,7 +47,7 @@ public void success() throws Exception {
   public void failingContributionDoesNotFailMap() throws Exception {
     RuntimeException cause = new RuntimeException("monkey");
     MapOfProducerProducer<Integer, String> mapOfProducerProducer =
-        MapOfProducerProducer.<Integer, String>builder()
+        MapOfProducerProducer.<Integer, String>builder(2)
             .put(15, Producers.<String>immediateProducer("fifteen"))
             .put(42, Producers.<String>immediateFailedProducer(cause))
             .build();
diff --git a/javatests/dagger/producers/internal/MapProducerTest.java b/javatests/dagger/producers/internal/MapProducerTest.java
index ee7978b7b..d1e314f18 100644
--- a/javatests/dagger/producers/internal/MapProducerTest.java
+++ b/javatests/dagger/producers/internal/MapProducerTest.java
@@ -31,7 +31,7 @@
   @Test
   public void success() throws Exception {
     Producer<Map<Integer, String>> mapProducer =
-        MapProducer.<Integer, String>builder()
+        MapProducer.<Integer, String>builder(2)
             .put(15, Producers.immediateProducer("fifteen"))
             .put(42, Producers.immediateProducer("forty two"))
             .build();
@@ -45,7 +45,7 @@ public void success() throws Exception {
   public void failingContribution() throws Exception {
     RuntimeException cause = new RuntimeException("monkey");
     Producer<Map<Integer, String>> mapProducer =
-        MapProducer.<Integer, String>builder()
+        MapProducer.<Integer, String>builder(2)
             .put(15, Producers.immediateProducer("fifteen"))
             // TODO(ronshapiro): remove the type parameter when we drop java7 support
             .put(42, Producers.<String>immediateFailedProducer(cause))
diff --git a/javatests/dagger/spi/FailingPlugin.java b/javatests/dagger/spi/FailingPlugin.java
index a8ccf5b2d..39623355b 100644
--- a/javatests/dagger/spi/FailingPlugin.java
+++ b/javatests/dagger/spi/FailingPlugin.java
@@ -43,21 +43,28 @@ public void initOptions(Map<String, String> options) {
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
     if (options.containsKey("error_on_binding")) {
       String key = options.get("error_on_binding");
-      bindingGraph.bindingNodes().stream()
-          .filter(node -> node.key().toString().equals(key))
-          .forEach(node -> diagnosticReporter.reportBinding(ERROR, node, "Bad Binding!"));
+      bindingGraph.bindings().stream()
+          .filter(binding -> binding.key().toString().equals(key))
+          .forEach(
+              binding ->
+                  diagnosticReporter.reportBinding(ERROR, binding, "Bad Binding: %s", binding));
     }
 
     if (options.containsKey("error_on_component")) {
-      diagnosticReporter.reportComponent(ERROR, bindingGraph.rootComponentNode(), "Bad Component!");
+      diagnosticReporter.reportComponent(
+          ERROR,
+          bindingGraph.rootComponentNode(),
+          "Bad Component: %s",
+          bindingGraph.rootComponentNode());
     }
 
     if (options.containsKey("error_on_subcomponents")) {
-      bindingGraph
-          .componentNodes()
-          .stream()
-          .filter(node -> !node.componentPath().atRoot())
-          .forEach(node -> diagnosticReporter.reportComponent(ERROR, node, "Bad Subcomponent!"));
+      bindingGraph.componentNodes().stream()
+          .filter(componentNode -> !componentNode.componentPath().atRoot())
+          .forEach(
+              componentNode ->
+                  diagnosticReporter.reportComponent(
+                      ERROR, componentNode, "Bad Subcomponent: %s", componentNode));
     }
 
     if (options.containsKey("error_on_dependency")) {
@@ -70,7 +77,8 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
                       .get()
                       .getSimpleName()
                       .contentEquals(dependency))
-          .forEach(edge -> diagnosticReporter.reportDependency(ERROR, edge, "Bad Dependency!"));
+          .forEach(
+              edge -> diagnosticReporter.reportDependency(ERROR, edge, "Bad Dependency: %s", edge));
     }
   }
 
diff --git a/javatests/dagger/spi/SpiPluginTest.java b/javatests/dagger/spi/SpiPluginTest.java
index fd4d9d9fe..e0a78b2e0 100644
--- a/javatests/dagger/spi/SpiPluginTest.java
+++ b/javatests/dagger/spi/SpiPluginTest.java
@@ -31,6 +31,39 @@
 
 @RunWith(JUnit4.class)
 public final class SpiPluginTest {
+  @Test
+  public void moduleBinding() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Provides",
+            "  static int provideInt() {",
+            "    return 0;",
+            "  }",
+            "}");
+
+    Compilation compilation =
+        javac()
+            .withProcessors(new ComponentProcessor())
+            .withOptions(
+                "-Aerror_on_binding=java.lang.Integer",
+                "-Adagger.moduleBindingValidation=ERROR")
+            .compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message("[FailingPlugin] Bad Binding: @Provides int test.TestModule.provideInt()"))
+        .inFile(module)
+        .onLineContaining("interface TestModule");
+  }
+
   @Test
   public void dependencyTraceAtBinding() {
     JavaFileObject foo =
@@ -64,7 +97,7 @@ public void dependencyTraceAtBinding() {
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[FailingPlugin] Bad Binding!",
+                "[FailingPlugin] Bad Binding: @Inject test.Foo()",
                 "    test.Foo is provided at",
                 "        test.TestComponent.foo()"))
         .inFile(component)
@@ -152,7 +185,7 @@ public void dependencyTraceAtDependencyRequest() {
     assertThat(compilationFactory.compilationWithErrorOnDependency("entryPoint"))
         .hadErrorContaining(
             message(
-                "[FailingPlugin] Bad Dependency!",
+                "[FailingPlugin] Bad Dependency: test.TestComponent.entryPoint() (entry point)",
                 "    test.EntryPoint is provided at",
                 "        test.TestComponent.entryPoint()"))
         .inFile(component)
@@ -160,9 +193,9 @@ public void dependencyTraceAtDependencyRequest() {
     assertThat(compilationFactory.compilationWithErrorOnDependency("dup1"))
         .hadErrorContaining(
             message(
-                "[FailingPlugin] Bad Dependency!",
+                "[FailingPlugin] Bad Dependency: test.EntryPoint(…, dup1, …)",
                 "    test.Duplicated is injected at",
-                "        test.EntryPoint.<init>(…, dup1, …)",
+                "        test.EntryPoint(…, dup1, …)",
                 "    test.EntryPoint is provided at",
                 "        test.TestComponent.entryPoint()"))
         .inFile(component)
@@ -170,9 +203,9 @@ public void dependencyTraceAtDependencyRequest() {
     assertThat(compilationFactory.compilationWithErrorOnDependency("dup2"))
         .hadErrorContaining(
             message(
-                "[FailingPlugin] Bad Dependency!",
+                "[FailingPlugin] Bad Dependency: test.EntryPoint(…, dup2)",
                 "    test.Duplicated is injected at",
-                "        test.EntryPoint.<init>(…, dup2)",
+                "        test.EntryPoint(…, dup2)",
                 "    test.EntryPoint is provided at",
                 "        test.TestComponent.entryPoint()"))
         .inFile(component)
@@ -183,11 +216,11 @@ public void dependencyTraceAtDependencyRequest() {
     assertThat(inFooDepCompilation)
         .hadErrorContaining(
             message(
-                "[FailingPlugin] Bad Dependency!",
+                "[FailingPlugin] Bad Dependency: test.Foo(inFooDep)",
                 "    test.Duplicated is injected at",
-                "        test.Foo.<init>(inFooDep)",
+                "        test.Foo(inFooDep)",
                 "    test.Foo is injected at",
-                "        test.EntryPoint.<init>(foo, …)",
+                "        test.EntryPoint(foo, …)",
                 "    test.EntryPoint is provided at",
                 "        test.TestComponent.entryPoint()",
                 "The following other entry points also depend on it:",
@@ -246,7 +279,8 @@ public void dependencyTraceAtDependencyRequest_subcomponents() {
     assertThat(compilationFactory.compilationWithErrorOnDependency("childEntryPoint"))
         .hadErrorContaining(
             message(
-                "[FailingPlugin] Bad Dependency!",
+                "[FailingPlugin] Bad Dependency: "
+                    + "test.TestSubcomponent.childEntryPoint() (entry point)",
                 "    test.EntryPoint is provided at",
                 "        test.TestSubcomponent.childEntryPoint()"
                     + " [test.TestComponent → test.TestSubcomponent]"))
@@ -259,9 +293,9 @@ public void dependencyTraceAtDependencyRequest_subcomponents() {
             //         test.TestComponent
             // TODO(dpb): Or invert the order: Child → Parent
             message(
-                "[FailingPlugin] Bad Dependency!",
+                "[FailingPlugin] Bad Dependency: test.EntryPoint(foo)",
                 "    test.Foo is injected at",
-                "        test.EntryPoint.<init>(foo)",
+                "        test.EntryPoint(foo)",
                 "    test.EntryPoint is provided at",
                 "        test.TestSubcomponent.childEntryPoint() "
                     + "[test.TestComponent → test.TestSubcomponent]"))
@@ -288,7 +322,7 @@ public void errorOnComponent() {
             .compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("[FailingPlugin] Bad Component!")
+        .hadErrorContaining("[FailingPlugin] Bad Component: test.TestComponent")
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -324,7 +358,8 @@ public void errorOnSubcomponent() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "[FailingPlugin] Bad Subcomponent! [test.TestComponent → test.TestSubcomponent]")
+            "[FailingPlugin] Bad Subcomponent: test.TestComponent → test.TestSubcomponent "
+                + "[test.TestComponent → test.TestSubcomponent]")
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -431,13 +466,13 @@ public void shortestPathToBindingExistsThroughSubcomponentBuilder() {
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[FailingPlugin] Bad Binding!",
+                "[FailingPlugin] Bad Binding: @Inject test.ExposedOnSubcomponent()",
                 "    test.ExposedOnSubcomponent is injected at",
-                "        test.Chain3.<init>(exposedOnSubcomponent)",
+                "        test.Chain3(exposedOnSubcomponent)",
                 "    test.Chain3 is injected at",
-                "        test.Chain2.<init>(chain)",
+                "        test.Chain2(chain)",
                 "    test.Chain2 is injected at",
-                "        test.Chain1.<init>(chain)",
+                "        test.Chain1(chain)",
                 "    test.Chain1 is provided at",
                 "        test.TestComponent.chain()",
                 "The following other entry points also depend on it:",
diff --git a/test_defs.bzl b/test_defs.bzl
index db13354e4..32ba9e65d 100644
--- a/test_defs.bzl
+++ b/test_defs.bzl
@@ -18,7 +18,7 @@
 BUILD_VARIANTS = {
     "FastInit": ["-Adagger.fastInit=enabled"],
     "ExperimentalAndroidMode2": ["-Adagger.experimentalAndroidMode2=enabled"],
-    "ExperimentalAheadOfTimeSubcomponents": ["-Adagger.experimentalAheadOfTimeSubcomponents=enabled"],
+    "AheadOfTimeSubcomponents": ["-Adagger.experimentalAheadOfTimeSubcomponents=enabled"],
     "FastInitAndAheadOfTimeSubcomponents": [
         "-Adagger.fastInit=enabled",
         "-Adagger.experimentalAheadOfTimeSubcomponents=enabled",
@@ -60,6 +60,7 @@ def GenRobolectricTests(
         javacopts = None,
         lib_javacopts = None,
         test_javacopts = None,
+        functional = True,
         manifest_values = None):
     # TODO(ronshapiro): enable these with these instructions:
     # https://docs.bazel.build/versions/master/be/android.html#android_local_test_examples
@@ -91,6 +92,7 @@ def _GenTests(
         javacopts,
         lib_javacopts,
         test_javacopts,
+        functional,
         test_kwargs = test_kwargs,
     )
 
@@ -108,6 +110,7 @@ def _GenTests(
                 variant_javacopts,
                 lib_javacopts,
                 test_javacopts,
+                functional,
                 variant_name,
                 test_kwargs = test_kwargs,
             )
@@ -123,6 +126,7 @@ def _gen_tests(
         javacopts,
         lib_javacopts,
         test_javacopts,
+        functional,
         variant_name = None,
         test_kwargs = {}):
     if variant_name:
@@ -161,6 +165,8 @@ def _gen_tests(
             tags = tags,
             deps = deps,
         )
+        if functional:
+            _hjar_test(supporting_files_name, tags)
 
     for test_file in test_files:
         test_name = test_file.replace(".java", "")
@@ -180,3 +186,7 @@ def _gen_tests(
             deps = test_deps,
             **test_kwargs
         )
+
+
+def _hjar_test(name, tags):
+    pass
diff --git a/tools/simple_jar.bzl b/tools/simple_jar.bzl
index 71b3f7b1e..9df4fceb0 100644
--- a/tools/simple_jar.bzl
+++ b/tools/simple_jar.bzl
@@ -25,7 +25,14 @@ def simple_jar(name, srcs):
         outs = ["%s.jar" % name],
         cmd = """
         OUT="$$(pwd)/$@"
-        cd {package_name}
+        if [[ -e "{package_name}" ]]; then
+          cd "{package_name}"
+        elif [[ -e "external/{package_name}" ]]; then
+          cd "external/{package_name}"
+        else
+          echo "Cannot find {package_name} directory"
+          exit 1
+        fi
         zip "$$OUT" -r * &> /dev/null
         """.format(package_name = native.package_name()),
     )
diff --git a/util/deploy-to-maven-central.sh b/util/deploy-to-maven-central.sh
index 87dff6aff..1f721a162 100755
--- a/util/deploy-to-maven-central.sh
+++ b/util/deploy-to-maven-central.sh
@@ -41,10 +41,6 @@ git commit -m "$version_name docs"
 git push origin gh-pages
 cd ..
 rm -rf gh-pages
-for generated_pom_file in dagger*pom.xml; do
-  rm "${generated_pom_file}"
-  rm "${generated_pom_file}.asc"
-done
 
 git checkout --detach
 # Set the version string that is used as a tag in all of our libraries. If another repo depends on
diff --git a/util/execute-deploy.sh b/util/execute-deploy.sh
index 6908e97d1..115346809 100755
--- a/util/execute-deploy.sh
+++ b/util/execute-deploy.sh
@@ -85,13 +85,6 @@ deploy_library \
   java/dagger/android/support/support-javadoc.jar \
   java/dagger/android/support/pom.xml
 
-# b/37741866 and https://github.com/google/dagger/issues/715
-deploy_library \
-  java/dagger/android/support/libsupport.jar \
-  java/dagger/android/support/libsupport-src.jar \
-  java/dagger/android/support/support-javadoc.jar \
-  java/dagger/android/support/jarimpl-pom.xml
-
 deploy_library \
   shaded_android_processor.jar \
   java/dagger/android/processor/libprocessor-src.jar \
