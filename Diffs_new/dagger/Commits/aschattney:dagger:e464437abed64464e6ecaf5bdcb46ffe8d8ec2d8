diff --git a/android-support/pom.xml b/android-support/pom.xml
index 83a51b8f9..9c2d4951b 100644
--- a/android-support/pom.xml
+++ b/android-support/pom.xml
@@ -11,7 +11,7 @@
 
     <artifactId>dagger-android-support</artifactId>
     <name>Dagger for Android Support</name>
-    <packaging>jar</packaging>
+    <packaging>aar</packaging>
 
     <repositories>
         <repository>
@@ -28,8 +28,16 @@
         <dependency>
             <groupId>com.android.support</groupId>
             <artifactId>appcompat-v7</artifactId>
-            <version>24.1.1</version>
+            <version>24.2.0</version>
             <type>aar</type>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.android.support</groupId>
+            <artifactId>support-v4</artifactId>
+            <version>24.2.0</version>
+            <type>aar</type>
+            <scope>compile</scope>
         </dependency>
         <dependency>
             <groupId>com.google.android</groupId>
diff --git a/android-testcase/src/main/java/dagger/android/testcase/EspressoTestCase.java b/android-testcase/src/main/java/dagger/android/testcase/EspressoTestCase.java
index 56935c9c7..124426f27 100644
--- a/android-testcase/src/main/java/dagger/android/testcase/EspressoTestCase.java
+++ b/android-testcase/src/main/java/dagger/android/testcase/EspressoTestCase.java
@@ -12,14 +12,16 @@
 
     public T app()
     {
-        return app;
+        if (this.app == null) {
+            final DaggerRunner abstractRunner = (DaggerRunner) InstrumentationRegistry.getInstrumentation();
+            this.app = (T) abstractRunner.getApplication();
+        }
+        return this.app;
     }
 
     @Before
     public void setUp() throws Exception {
-        final DaggerRunner abstractRunner = (DaggerRunner) InstrumentationRegistry.getInstrumentation();
-        T app = (T) abstractRunner.getApplication();
-        this.app = app;
+
     }
 
     @After
diff --git a/android/pom.xml b/android/pom.xml
index 2423a6e18..ff91a3c25 100644
--- a/android/pom.xml
+++ b/android/pom.xml
@@ -40,6 +40,11 @@
   </repositories>
 
   <dependencies>
+    <dependency>
+      <groupId>javax.inject</groupId>
+      <artifactId>javax.inject</artifactId>
+      <scope>compile</scope>
+    </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index caef30ee6..32688123b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -42,12 +42,10 @@
 import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
 import static dagger.internal.codegen.MemberSelect.staticMethod;
+import static dagger.internal.codegen.SourceFiles.*;
 import static dagger.internal.codegen.Util.*;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scope.reusableScope;
-import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
@@ -160,6 +158,7 @@
   protected final MethodSpec.Builder constructor = constructorBuilder();
   protected Optional<ClassName> builderName = Optional.empty();
   private Map<Key, String> delegateFieldNames = new HashMap<>();
+  private Map<Key, String> mockFieldNames = new HashMap<>();
   private final OptionalFactories optionalFactories;
   private boolean done;
 
@@ -464,6 +463,7 @@ protected void addBuilder() {
 
     for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
       createDelegateFieldAndMethod(builderName(), componentBuilder, contributionBinding, delegateFieldNames, false);
+      createMockFieldAndMethod(builderName(), componentBuilder, contributionBinding, mockFieldNames, false);
     }
 
     return builderFields.build();
@@ -1221,6 +1221,7 @@ private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
   private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
     TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
     final String delegateFieldName = delegateFieldNames.get(binding.key());
+    final String mockFieldName = mockFieldNames.get(binding.key());
     switch (binding.bindingKind()) {
       case COMPONENT:
         return CodeBlock.of(
@@ -1354,7 +1355,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
       case PROVISION:
         {
           List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 2);
+              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 3);
           if (binding.requiresModuleInstance()) {
             arguments.add(
                 getComponentContributionExpression(
@@ -1363,6 +1364,9 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           arguments.addAll(getDependencyArguments(binding));
 
           if (delegateFieldName != null && bindingSupportsTestDelegate(binding)) {
+            if (mockFieldName != null) {
+              arguments.add(0, CodeBlock.of("builder.$L", mockFieldName));
+            }
             arguments.add(0, CodeBlock.of("builder.$L", delegateFieldName));
           }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/AppConfig.java b/compiler/src/main/java/dagger/internal/codegen/AppConfig.java
index 46d206095..e89394b66 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AppConfig.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AppConfig.java
@@ -1,8 +1,6 @@
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.sun.jdi.Mirror;
 import dagger.Config;
 
 import javax.lang.model.element.Element;
@@ -18,11 +16,13 @@
     private final TypeElement appClass;
     private final TypeElement baseAppClass;
     private boolean debug;
+    private final boolean generateExtendedComponents;
 
-    public AppConfig(TypeElement appClass, TypeElement baseAppClass, boolean debug) {
+    public AppConfig(TypeElement appClass, TypeElement baseAppClass, boolean debug, boolean generateExtendedComponents) {
         this.appClass = appClass;
         this.baseAppClass = baseAppClass;
         this.debug = debug;
+        this.generateExtendedComponents = generateExtendedComponents;
     }
 
     public TypeElement getAppClass() {
@@ -33,6 +33,10 @@ public TypeElement getBaseAppClass() {
         return baseAppClass;
     }
 
+    public boolean generateExtendedComponents() {
+        return generateExtendedComponents;
+    }
+
     public boolean debug() {
         return this.debug;
     }
@@ -49,7 +53,8 @@ public AppConfig create(Config config) {
             final TypeElement appClass = extractAppClassElement(config);
             final TypeElement baseAppClass = extractBaseAppClassElement(config);
             boolean debug = config.debug();
-            return new AppConfig(appClass, baseAppClass, debug);
+            boolean generateExtendedComponents = config.generateExtendedComponents();
+            return new AppConfig(appClass, baseAppClass, debug, generateExtendedComponents);
         }
 
         private TypeElement extractAppClassElement(Config config) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index b3ab3cb23..f3ec5deab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -98,16 +98,12 @@ ClassName nameGeneratedType(BindingGraph input) {
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
-    if (appConfigProvider.get().debug()) {
+    if (appConfigProvider.get().generateExtendedComponents()) {
       final ClassName name = componentName.topLevelClassName().peerClass("Test" + Joiner.on('_').join(componentName.simpleNames()));
-      System.out.println("generating test dagger component");
       final TypeSpec.Builder testComponentBuilder =
               new ComponentWriter(types, elements, keyFactory, compilerOptions, name, input, true).write();
-      System.out.println("DONE generating test dagger component");
       try {
-        System.out.println("adding to registry");
         testRegistry.addEncodedClass(name, buildJavaFile(name, testComponentBuilder));
-        System.out.println("DONE - adding to registry");
       } catch (IOException e) {
         throw new IllegalStateException(e);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 609fbcdf0..e6071baf9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -116,9 +116,11 @@ public SourceVersion getSupportedSourceVersion() {
     MapKeyValidator mapKeyValidator = new MapKeyValidator(elements);
 
     appConfigProvider = new AppConfig.Provider();
-    StubGenerator stubGenerator = new StubGenerator(filer, elements, types);
+    StubGenerator stubGenerator = new StubGenerator(filer, elements, types, appConfigProvider, testRegistry);
+    //MockGenerator mockGenerator = new MockGenerator(filer, elements, types, appConfigProvider, testRegistry);
     FactoryGenerator factoryGenerator = new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
-    multipleGenerator = new MultipleSourceFileGenerator<>(filer, elements, Arrays.asList(stubGenerator, factoryGenerator));
+    TestFactoryGenerator testFactoryGenerator = new TestFactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode, appConfigProvider, testRegistry);
+    multipleGenerator = new MultipleSourceFileGenerator<>(filer, elements, Arrays.asList(stubGenerator, factoryGenerator, testFactoryGenerator));
     membersInjectorGenerator = new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
     ComponentGenerator.Factory componentGeneratorFactory = new ComponentGenerator.Factory(filer, elements, types, keyFactory, compilerOptions, appConfigProvider, testRegistry);
     ProducerFactoryGenerator producerFactoryGenerator =
@@ -131,7 +133,7 @@ public SourceVersion getSupportedSourceVersion() {
     DependencyRequest.Factory dependencyRequestFactory =
             new DependencyRequest.Factory(keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
-            new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
+            new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory, appConfigProvider);
     ProductionBinding.Factory productionBindingFactory =
             new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
     MultibindingDeclaration.Factory multibindingDeclarationFactory =
@@ -248,15 +250,15 @@ public SourceVersion getSupportedSourceVersion() {
                 messager,
                 appConfigProvider,
                 testRegistry,
+                new TestClassGenerator.Factory(filer, elements),
                 new InjectorGenerator(filer, elements, messager, componentDescriptorFactory,
-                        bindingGraphFactory, new TestClassGenerator.Factory(filer, elements),
-                        testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory, testRegistry)),
+                        bindingGraphFactory,
+                        testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory, testRegistry, appConfigProvider)),
                 ComponentDescriptor.Kind.COMPONENT,
                 bindingGraphFactory,
                 componentDescriptorFactory,
                 new DecoratorGenerator(filer, elements, componentDescriptorFactory, bindingGraphFactory, testRegistry),
                 new DependencySpecGenerator(filer, elements, componentDescriptorFactory, bindingGraphFactory),
-                new DependencyInjectorGenerator(filer, elements, bindingGraphFactory, componentDescriptorFactory),
                 provisionBindingFactory,
                 new ApplicationGenerator(filer, types, elements, bindingGraphFactory, componentDescriptorFactory),
                 stubGenerator
diff --git a/compiler/src/main/java/dagger/internal/codegen/Decorator.java b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
index 2be03ecad..553714088 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Decorator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
@@ -15,18 +15,21 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.stream.Collectors;
 
 public class Decorator  extends SourceFileGenerator<ImmutableSet<BindingGraph>>{
 
     private BindingGraph.Factory factory;
     private ClassName testAppClassName;
     private TestRegistry testRegistry;
+    private final AppConfig.Provider appConfigProvider;
 
-    private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory, ClassName testAppClassName, TestRegistry testRegistry) {
+    private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory, ClassName testAppClassName, TestRegistry testRegistry, AppConfig.Provider appConfigProvider) {
         super(filer, elements);
         this.factory = factory;
         this.testAppClassName = testAppClassName;
         this.testRegistry = testRegistry;
+        this.appConfigProvider = appConfigProvider;
     }
 
     @Override
@@ -42,7 +45,7 @@ static ClassName className(BindingGraph input) {
         final ComponentDescriptor topDescriptor = getTopDescriptor(input.componentDescriptor());
         final TypeElement topComponent = topDescriptor.componentDefinitionType();
         final String componentName = input.componentDescriptor().componentDefinitionType().getSimpleName().toString();
-        return ClassName.get(topComponent).topLevelClassName().peerClass(componentName + "Decorator");
+        return ClassName.get(topComponent).topLevelClassName().peerClass(componentName + "DecoratorImpl");
     }
 
     @Override
@@ -95,7 +98,7 @@ static ClassName className(BindingGraph input) {
         }
         interfaceBuilder.addMethod(MethodSpec.methodBuilder("and")
                 .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
-                .returns(testAppClassName.topLevelClassName().peerClass("Decorator"))
+                .returns(testAppClassName.topLevelClassName().peerClass("GraphDecorator"))
                 .build());
         return interfaceBuilder;
     }
@@ -111,8 +114,13 @@ private void addDecoratorType(TypeSpec.Builder builder, String className, TypeNa
             final BindingGraph parentGraph = factory.create(topDescriptor);
             final ClassName name = ClassName.bestGuess(TriggerComponentInfo.resolveBuilderName(bindingGraph, parentGraph));
             final ClassName testName = ClassName.bestGuess(TriggerComponentInfo.resolveTestBuilderName(bindingGraph, parentGraph));
-            apply(builder, delegateRequirements, statements, counter, bindingGraph, CodeBlock.builder(), name);
-            applyTest(delegateRequirements, statements, CodeBlock.builder(), testName);
+            if (counter == 0) {
+                createFieldAndMethodImplementations(builder, bindingGraph, delegateRequirements);
+            }
+            apply(delegateRequirements, statements, CodeBlock.builder(), name);
+            if (appConfigProvider.get().generateExtendedComponents()) {
+                applyTest(delegateRequirements, statements, CodeBlock.builder(), testName);
+            }
             counter++;
         }
 
@@ -133,22 +141,40 @@ private void addDecoratorType(TypeSpec.Builder builder, String className, TypeNa
 
     }
 
-    private void apply(TypeSpec.Builder builder, ImmutableSet<ContributionBinding> delegateRequirements, List<CodeBlock> statements, int counter, BindingGraph bindingGraph, CodeBlock.Builder codeBuilder, ClassName name) {
-        codeBuilder.beginControlFlow("if (builder instanceof $T)", name);
-        codeBuilder.add(CodeBlock.of("$T impl = ($T) builder;\n", name, name));
+    private void createFieldAndMethodImplementations(TypeSpec.Builder builder, BindingGraph bindingGraph, ImmutableSet<ContributionBinding> delegateRequirements) {
         TypeName interfaceName = getAccessorTypeName(ClassName.bestGuess(testAppClassName.toString()),
                 bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString());
         for (ContributionBinding contributionBinding : delegateRequirements) {
-            if (counter == 0) {
-                Util.createDelegateField(builder, contributionBinding);
-                Util.createDelegateMethodImplementation(interfaceName, builder, contributionBinding);
-                if (!contributionBinding.dependencies().isEmpty()) {
-                    Util.createMockMethodImplementation(interfaceName, builder, contributionBinding);
-                }
+            Util.createDelegateField(builder, contributionBinding);
+            Util.createDelegateMethodImplementation(interfaceName, builder, contributionBinding);
+            if (!contributionBinding.dependencies().isEmpty()) {
+                Util.createMockField(builder, contributionBinding);
+                Util.createMockMethodImplementation(interfaceName, builder, contributionBinding);
             }
+        }
+    }
+
+    private void apply(ImmutableSet<ContributionBinding> delegateRequirements, List<CodeBlock> statements, CodeBlock.Builder codeBuilder, ClassName name) {
+
+        delegateRequirements = ImmutableSet.copyOf(delegateRequirements.stream()
+                .filter(Util::bindingSupportsTestDelegate)
+                .collect(Collectors.toList()));
+
+        if (delegateRequirements.isEmpty()) {
+            return;
+        }
+
+        codeBuilder.beginControlFlow("if (builder instanceof $T)", name);
+        codeBuilder.add(CodeBlock.of("$T impl = ($T) builder;\n", name, name));
+        for (ContributionBinding contributionBinding : delegateRequirements) {
             final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
             final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
             codeBuilder.add(CodeBlock.of("impl.$L(this.$L);\n", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
+            if (!contributionBinding.dependencies().isEmpty()) {
+                final String mockFieldName = Util.getMockFieldName(contributionBinding.key());
+                final ClassName mockTypeName = Util.getMockTypeName(contributionBinding.key());
+                codeBuilder.add(CodeBlock.of("impl.$L(this.$L);\n", Util.getMockMethodName(mockTypeName), mockFieldName));
+            }
         }
         codeBuilder.add(CodeBlock.of("return impl;\n"));
         codeBuilder.endControlFlow();
@@ -162,6 +188,11 @@ private void applyTest(ImmutableSet<ContributionBinding> delegateRequirements, L
             final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
             final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
             codeBuilder.add(CodeBlock.of("impl.$L(this.$L);\n", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
+            if (!contributionBinding.dependencies().isEmpty()) {
+                final String mockFieldName = Util.getMockFieldName(contributionBinding.key());
+                final ClassName mockTypeName = Util.getMockTypeName(contributionBinding.key());
+                codeBuilder.add(CodeBlock.of("impl.$L(this.$L);\n", Util.getMockMethodName(mockTypeName), mockFieldName));
+            }
         }
         codeBuilder.add(CodeBlock.of("return impl;\n"));
         codeBuilder.endControlFlow();
@@ -182,7 +213,7 @@ void generate(ImmutableSet<BindingGraph> input) throws SourceFileGenerationExcep
     }
 
     public static ClassName getAccessorTypeName(ClassName app, String componentName) {
-        return app.nestedClass(componentName + "Accessor");
+        return app.nestedClass(componentName + "Decorator");
     }
 
     private static ComponentDescriptor getTopDescriptor(ComponentDescriptor descriptor) {
@@ -198,16 +229,18 @@ private static ComponentDescriptor getTopDescriptor(ComponentDescriptor descript
         private final Elements elements;
         private final BindingGraph.Factory bindingGraphFactory;
         private TestRegistry testRegistry;
+        private final AppConfig.Provider appConfigProvider;
 
-        Factory(Filer filer, Elements elements, BindingGraph.Factory bindingGraphFactory, TestRegistry testRegistry) {
+        Factory(Filer filer, Elements elements, BindingGraph.Factory bindingGraphFactory, TestRegistry testRegistry, AppConfig.Provider appConfigProvider) {
             this.filer = filer;
             this.elements = elements;
             this.bindingGraphFactory = bindingGraphFactory;
             this.testRegistry = testRegistry;
+            this.appConfigProvider = appConfigProvider;
         }
 
         public Decorator create(ClassName testAppClassName) {
-            return new Decorator(filer, elements, bindingGraphFactory, testAppClassName, testRegistry);
+            return new Decorator(filer, elements, bindingGraphFactory, testAppClassName, testRegistry, appConfigProvider);
         }
 
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 0ac166e87..1ab2ae6b6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -39,6 +39,7 @@
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.internal.codegen.Util.getDelegateFieldName;
 import static dagger.internal.codegen.Util.getDelegateTypeName;
+import static dagger.internal.codegen.Util.getMockFieldName;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -80,7 +81,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
+class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
 
   private final CompilerOptions compilerOptions;
   private final InjectValidator injectValidator;
@@ -95,6 +96,10 @@
     this.injectValidator = injectValidator;
   }
 
+  protected boolean shouldCheckForDelegate(ContributionBinding binding) {
+    return Util.bindingSupportsTestDelegate(binding);
+  }
+
   @Override
   ClassName nameGeneratedType(ProvisionBinding binding) {
     return generatedClassNameForBinding(binding);
@@ -146,7 +151,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         break;
       case CLASS_CONSTRUCTOR:
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
-        if (Util.bindingSupportsTestDelegate(binding)) {
+        if (shouldCheckForDelegate(binding)) {
           addConstructorParameterAndTypeField(
                   getDelegateTypeName(binding.key()),
                   getDelegateFieldName(binding.key()),
@@ -154,6 +159,13 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
                   constructorBuilder.get(),
                   false
           );
+          addConstructorParameterAndTypeField(
+                  Util.providerOf(binding),
+                  getMockFieldName(binding.key()),
+                  factoryBuilder,
+                  constructorBuilder.get(),
+                  false
+          );
         }
         if (binding.requiresModuleInstance()) {
 
@@ -220,7 +232,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           case CLASS_CONSTRUCTOR:
             createMethodBuilder.addStatement(
                 "return new $T($L)",
-                parameterizedGeneratedTypeNameForBinding(binding),
+                this.parameterizedGeneratedTypeNameForBinding(binding),
                 makeParametersCodeBlock(
                     Lists.transform(params, input -> CodeBlock.of("$N", input))));
             break;
@@ -251,12 +263,17 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             .addAnnotation(Override.class)
             .addModifiers(PUBLIC);
 
-    final CodeBlock codeBlock = CodeBlock.of(getDelegateFieldName(binding.key()));
+    final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+    final String mockFieldName = !binding.dependencies().isEmpty() ? Util.getMockFieldName(binding.key()) : null;
+
     if (binding.bindingKind().equals(PROVISION)) {
-      if (Util.bindingSupportsTestDelegate(binding)) {
-        final String delegateFieldName = Util.getDelegateFieldName(binding.key());
-        getMethodBuilder.beginControlFlow("if ($L != null)", CodeBlock.of(delegateFieldName));
-        getMethodBuilder.addStatement("return $L.get($L)", CodeBlock.of(delegateFieldName), parametersCodeBlock);
+      if (shouldCheckForDelegate(binding)) {
+        getMethodBuilder.beginControlFlow("if ($L != null)", delegateFieldName);
+        getMethodBuilder.addStatement("return $L.get($L)", delegateFieldName, parametersCodeBlock);
+        if (mockFieldName != null) {
+          getMethodBuilder.nextControlFlow("else if ($L != null)", mockFieldName);
+          getMethodBuilder.addStatement("return $L.get()", mockFieldName);
+        }
         getMethodBuilder.nextControlFlow("else");
       }
       CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
@@ -272,7 +289,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
       getMethodBuilder.addStatement("return $L", providesMethodInvocation);
 
-      if (Util.bindingSupportsTestDelegate(binding)) {
+      if (shouldCheckForDelegate(binding)) {
         getMethodBuilder.endControlFlow();
       }
 
@@ -290,14 +307,22 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
       }*/
     } else if (binding.membersInjectionRequest().isPresent()) {
 
-      if (Util.bindingSupportsTestDelegate(binding)) {
-        getMethodBuilder.beginControlFlow("if ($L != null)", codeBlock);
+      if (shouldCheckForDelegate(binding)) {
+        getMethodBuilder.beginControlFlow("if ($L != null)", delegateFieldName);
         getMethodBuilder.addStatement(
                 "return $T.injectMembers($N, $L.get($L))",
                 MembersInjectors.class,
                 fields.get(binding.membersInjectionRequest().get().bindingKey()),
-                codeBlock,
+                delegateFieldName,
                 parametersCodeBlock);
+        if (mockFieldName != null) {
+          getMethodBuilder.nextControlFlow("else if ($L != null)", mockFieldName);
+          getMethodBuilder.addStatement(
+                  "return $T.injectMembers($N, $L.get())",
+                  MembersInjectors.class,
+                  fields.get(binding.membersInjectionRequest().get().bindingKey()),
+                  mockFieldName);
+        }
         getMethodBuilder.nextControlFlow("else");
       }
       getMethodBuilder.addStatement(
@@ -306,17 +331,21 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           fields.get(binding.membersInjectionRequest().get().bindingKey()),
           providedTypeName,
           parametersCodeBlock);
-      if (Util.bindingSupportsTestDelegate(binding)) {
+      if (shouldCheckForDelegate(binding)) {
         getMethodBuilder.endControlFlow();
       }
     } else {
-      if (Util.bindingSupportsTestDelegate(binding)) {
-        getMethodBuilder.beginControlFlow("if ($L != null)", codeBlock);
-        getMethodBuilder.addStatement("return $L.get($L)", codeBlock, parametersCodeBlock);
+      if (shouldCheckForDelegate(binding)) {
+        getMethodBuilder.beginControlFlow("if ($L != null)", delegateFieldName);
+        getMethodBuilder.addStatement("return $L.get($L)", delegateFieldName, parametersCodeBlock);
+        if (mockFieldName != null) {
+          getMethodBuilder.nextControlFlow("else if ($L != null)", mockFieldName);
+          getMethodBuilder.addStatement("return $L.get()", mockFieldName);
+        }
         getMethodBuilder.nextControlFlow("else");
       }
       getMethodBuilder.addStatement("return new $T($L)", providedTypeName, parametersCodeBlock);
-      if (Util.bindingSupportsTestDelegate(binding)) {
+      if (shouldCheckForDelegate(binding)) {
         getMethodBuilder.endControlFlow();
       }
     }
@@ -333,6 +362,10 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     return Optional.of(factoryBuilder);
   }
 
+  protected TypeName parameterizedGeneratedTypeNameForBinding(ProvisionBinding binding) {
+      return SourceFiles.parameterizedGeneratedTypeNameForBinding(binding);
+  }
+
   /**
    * Returns a method to proxy access to the binding's {@link Binding#bindingElement()}, which
    * behaves according to the description in {@link Proxies}. Use here is further restricted by
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index 8a49f2ca6..ef476578b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -27,16 +27,14 @@
     private Messager messager;
     private final ComponentDescriptor.Factory componentDescriptorFactory;
     private final BindingGraph.Factory bindingGraphFactory;
-    private TestClassGenerator.Factory testClassGeneratorFactory;
     private final TestRegistry registry;
     private Decorator.Factory decoratorFactory;
 
-    InjectorGenerator(Filer filer, Elements elements, Messager messager, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory, TestClassGenerator.Factory testClassGeneratorFactoty, TestRegistry registry, Decorator.Factory decoratorFactory) {
+    InjectorGenerator(Filer filer, Elements elements, Messager messager, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory, TestRegistry registry, Decorator.Factory decoratorFactory) {
         super(filer, elements);
         this.messager = messager;
         this.componentDescriptorFactory = componentDescriptorFactory;
         this.bindingGraphFactory = bindingGraphFactory;
-        this.testClassGeneratorFactory = testClassGeneratorFactoty;
         this.registry = registry;
         this.decoratorFactory = decoratorFactory;
     }
@@ -99,11 +97,6 @@ private void createDecoratorClasses(TypeSpec.Builder builder, Set<TypeElement> c
     private void createDecoratorClass(TypeSpec.Builder builder, ImmutableSet<BindingGraph> graphs,
                                       Decorator decorator, ClassName testAppClassName) {
         try {
-            /*messager.printMessage(Diagnostic.Kind.NOTE, "-----");
-            for (BindingGraph graph : graphs) {
-                messager.printMessage(Diagnostic.Kind.NOTE, String.valueOf(graph.componentType().getSimpleName().toString()));
-            }
-            messager.printMessage(Diagnostic.Kind.NOTE, "-----");*/
             decorator.generate(graphs);
             final Optional<BindingGraph> e = graphs.stream().findFirst();
             if (!e.isPresent()) {
@@ -113,7 +106,7 @@ private void createDecoratorClass(TypeSpec.Builder builder, ImmutableSet<Binding
             final String componentName = e.get().componentDescriptor().componentDefinitionType().getSimpleName().toString();
             final TypeName accessorName = Decorator.getAccessorTypeName(testAppClassName, componentName);
             final String fieldName = Util.lowerCaseFirstLetter(decoratorName.simpleName());
-            final String methodName = Util.lowerCaseFirstLetter(fieldName.replaceAll("Decorator$", ""));
+            final String methodName = Util.lowerCaseFirstLetter(fieldName.replaceAll("DecoratorImpl$", ""));
             final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, fieldName, Modifier.PRIVATE);
             final FieldSpec field = fieldBuilder.initializer("new $T(this)", decoratorName).build();
             builder.addField(field);
@@ -136,8 +129,6 @@ void generate(DI input) throws SourceFileGenerationException {
             if (builder.isPresent()) {
                 registry.addEncodedClass(input.getClassName(), buildJavaFile(input.getClassName(), builder.get()));
             }
-            final TestClassGenerator testClassGenerator = testClassGeneratorFactory.create(input.getAppClass());
-            testClassGenerator.generate(registry);
         } catch (IOException e) {
             throw new IllegalStateException(e);
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index e27d3b3c1..d405383b7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -1,27 +1,16 @@
 package dagger.internal.codegen;
 
-import com.google.auto.common.BasicAnnotationProcessor;
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.TypeName;
 import dagger.*;
 
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.MirroredTypeException;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
 import java.lang.annotation.Annotation;
 import java.util.*;
-import java.util.function.Consumer;
-import java.util.function.Function;
 import java.util.stream.Collectors;
 
 public class InjectorProcessingStep implements BasicProcessor.ProcessingStep {
@@ -30,12 +19,12 @@
     private final Messager messager;
     private TestRegistry testRegistry;
     private final AppConfig.Provider appConfigProvider;
+    private final TestClassGenerator.Factory testClassGeneratorFactory;
     private final InjectorGenerator injectorGenerator;
     private final ComponentDescriptor.Kind component;
     private final BindingGraph.Factory bindingGraphFactory;
     private final ComponentDescriptor.Factory componentDescriptorFactory;
     private DependencySpecGenerator dependencySpecGenerator;
-    private DependencyInjectorGenerator dependencyInjectorGenerator;
     private ProvisionBinding.Factory provisionBindingFactory;
     private ApplicationGenerator applicationGenerator;
     private StubGenerator stubGenerator;
@@ -45,12 +34,12 @@
     public InjectorProcessingStep(Types types, Messager messager,
                                   AppConfig.Provider appConfigProvider,
                                   TestRegistry testRegistry,
+                                  TestClassGenerator.Factory testClassGeneratorFactory,
                                   InjectorGenerator injectorGenerator,
                                   ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory,
                                   ComponentDescriptor.Factory componentDescriptorFactory,
                                   DecoratorGenerator decoratorGenerator,
                                   DependencySpecGenerator dependencySpecGenerator,
-                                  DependencyInjectorGenerator dependencyInjectorGenerator,
                                   ProvisionBinding.Factory provisionBindingFactory,
                                   ApplicationGenerator applicationGenerator,
                                   StubGenerator stubGenerator) {
@@ -58,12 +47,12 @@ public InjectorProcessingStep(Types types, Messager messager,
         this.messager = messager;
         this.appConfigProvider = appConfigProvider;
         this.testRegistry = testRegistry;
+        this.testClassGeneratorFactory = testClassGeneratorFactory;
         this.injectorGenerator = injectorGenerator;
         this.component = component;
         this.bindingGraphFactory = bindingGraphFactory;
         this.componentDescriptorFactory = componentDescriptorFactory;
         this.dependencySpecGenerator = dependencySpecGenerator;
-        this.dependencyInjectorGenerator = dependencyInjectorGenerator;
         this.provisionBindingFactory = provisionBindingFactory;
         this.applicationGenerator = applicationGenerator;
         this.stubGenerator = stubGenerator;
@@ -84,8 +73,6 @@ public InjectorProcessingStep(Types types, Messager messager,
 
         final AppConfig appConfig = appConfigProvider.get();
 
-        testRegistry.setDebug(appConfig.debug());
-
         Set<Element> rejectedElements = new LinkedHashSet<>();
 
         components.addAll(elementsByAnnotation.get(Component.class).stream()
@@ -116,13 +103,16 @@ public InjectorProcessingStep(Types types, Messager messager,
                         });
 
             }
-            final ClassName decoratorClassName = ClassName.get(appConfig.getAppClass()).topLevelClassName().peerClass("Decorator");
+            final ClassName decoratorClassName = ClassName.get(appConfig.getAppClass()).topLevelClassName().peerClass("GraphDecorator");
             final DI di = new DI(appConfig, components, injectorTypeList, decoratorClassName);
             this.decoratorGenerator.generate(di, messager);
             this.applicationGenerator.generate(di, messager);
             this.dependencySpecGenerator.generate(di, messager);
-            //this.dependencyInjectorGenerator.generate(di, messager);
             this.injectorGenerator.generate(di, messager);
+            if (appConfig.debug() || appConfig.generateExtendedComponents()) {
+                final TestClassGenerator testClassGenerator = testClassGeneratorFactory.create(di.getAppClass());
+                testClassGenerator.generate(testRegistry, messager);
+            }
         } else {
             throw new IllegalStateException(rejectedElements.toString());
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 21983a788..f26e3179d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -119,7 +119,7 @@
    * <p>Absent except for multibinding contributions.
    */
   abstract Optional<MultibindingContributionIdentifier> multibindingContributionIdentifier();
-  
+
   abstract Builder toBuilder();
 
   @Memoized
@@ -163,7 +163,7 @@ abstract Builder multibindingContributionIdentifier(
 
     abstract Key build();
   }
-  
+
   /**
    * An object that identifies a multibinding contribution method and the module class that
    * contributes it to the graph.
@@ -196,6 +196,11 @@ public String toString() {
     }
 
     public ClassName getDelegateTypeName() {
+      StringBuilder sb = internalGetTypeName();
+      return ClassName.bestGuess(String.format("delegates.%sDelegate", sb.toString()));
+    }
+
+    private StringBuilder internalGetTypeName() {
       final TypeMirror returnType = bindingMethod.getReturnType();
 
       // find qualifier annotations
@@ -252,12 +257,20 @@ public ClassName getDelegateTypeName() {
       }else {
         sb.append(capitalize(extractClassName(typeToString(returnType))));
       }
+      return sb;
+    }
 
-      return ClassName.bestGuess(String.format("delegates.%sDelegate", sb.toString()));
+    public String getDelegateFieldName() {
+      StringBuilder sb = internalGetFieldName();
+      return sb.toString() + "Delegate";
+    }
 
+    public String getMockFieldName() {
+      StringBuilder sb = internalGetFieldName();
+      return sb.toString() + "Mock";
     }
 
-    public String getDelegateFieldName() {
+    private StringBuilder internalGetFieldName() {
       final TypeMirror returnType = bindingMethod.getReturnType();
 
       // find qualifier annotations
@@ -314,8 +327,7 @@ public String getDelegateFieldName() {
       }else {
         sb.append(transformValue(extractClassName(typeToString(returnType)), sb));
       }
-
-      return sb.toString();
+      return sb;
     }
 
     protected String transformValue(String simpleMapValueName, StringBuilder sb) {
@@ -379,6 +391,11 @@ public boolean equals(Object obj) {
     public int hashCode() {
       return identifierString.hashCode();
     }
+
+    public ClassName getMockTypeName() {
+      StringBuilder sb = internalGetTypeName();
+      return ClassName.bestGuess(String.format("delegates.%sMock", sb.toString()));
+    }
   }
 
   /**
@@ -482,7 +499,7 @@ public String toString() {
   static final class Factory {
     private final Types types;
     private final Elements elements;
-    
+
     Factory(Types types, Elements elements) {
       this.types = checkNotNull(types);
       this.elements = checkNotNull(elements);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 5eefbb0dc..9a1b85d0c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -112,13 +112,15 @@ private static Builder builder() {
     private final Types types;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
-
+    private final AppConfig.Provider appConfigProvider;
     Factory(Elements elements, Types types, Key.Factory keyFactory,
-        DependencyRequest.Factory dependencyRequestFactory) {
+        DependencyRequest.Factory dependencyRequestFactory,
+            AppConfig.Provider appConfigProvider) {
       this.elements = elements;
       this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
+      this.appConfigProvider = appConfigProvider;
     }
 
     /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 1d73fb369..ed9be4aff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -144,6 +144,39 @@ static CodeBlock frameworkTypeUsageStatement(
     }
   }
 
+  static ClassName generatedTestClassNameForBinding(Binding binding) {
+    switch (binding.bindingType()) {
+      case PROVISION:
+      case PRODUCTION:
+        ContributionBinding contribution = (ContributionBinding) binding;
+        checkArgument(contribution.bindingTypeElement().isPresent());
+        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement().get());
+        switch (contribution.bindingKind()) {
+          case INJECTION:
+          case PROVISION:
+          case PRODUCTION:
+            return enclosingClassName
+                    .topLevelClassName()
+                    .peerClass(
+                            "Test" +
+                            classFileName(enclosingClassName)
+                                    + "_"
+                                    + factoryPrefix(contribution)
+                                    + "Factory");
+
+          default:
+            throw new AssertionError();
+        }
+
+      case MEMBERS_INJECTION:
+        return membersInjectorNameForType(
+                ((MembersInjectionBinding) binding).membersInjectedType());
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
   /**
    * Returns the generated factory or members injector name for a binding.
    */
@@ -187,6 +220,12 @@ static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
         : ParameterizedTypeName.get(className, Iterables.toArray(typeParameters, TypeName.class));
   }
 
+  static TypeName parameterizedGeneratedTestTypeNameForBinding(Binding binding) {
+    ClassName className = generatedTestClassNameForBinding(binding);
+    return className;
+  }
+
+
   static ClassName membersInjectorNameForType(TypeElement typeElement) {
     return siblingClassName(typeElement,  "_MembersInjector");
   }
@@ -211,7 +250,7 @@ private static ClassName siblingClassName(TypeElement typeElement, String suffix
     return className.topLevelClassName().peerClass(classFileName(className) + suffix);
   }
 
-  private static String factoryPrefix(ContributionBinding binding) {
+  static String factoryPrefix(ContributionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
         return "";
diff --git a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
index 44a059954..746faa745 100644
--- a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
@@ -1,14 +1,11 @@
 package dagger.internal.codegen;
 
-import com.google.auto.common.BasicAnnotationProcessor;
+import java.io.IOException;
 import java.util.Optional;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
+
 import com.squareup.javapoet.*;
-import dagger.Lazy;
 
 import javax.annotation.processing.Filer;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.util.Elements;
@@ -21,9 +18,13 @@
 public class StubGenerator extends SourceFileGenerator<ProvisionBinding> {
 
     private final List<String> generated = new ArrayList<>();
+    private final AppConfig.Provider appConfigProvider;
+    private final TestRegistry testRegistry;
 
-    StubGenerator(Filer filer, Elements elements, Types types) {
+    StubGenerator(Filer filer, Elements elements, Types types, AppConfig.Provider appConfigProvider, TestRegistry testRegistry) {
         super(filer, elements);
+        this.appConfigProvider = appConfigProvider;
+        this.testRegistry = testRegistry;
     }
 
     @Override
@@ -40,7 +41,7 @@ ClassName nameGeneratedType(ProvisionBinding input) {
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProvisionBinding input) {
 
         final String o = generatedTypeName.packageName() + "." + generatedTypeName.simpleName();
-        if (generated.contains(o) || !Util.bindingSupportsTestDelegate(input)) {
+        if (generated.contains(o) || !Util.generateTestDelegate(input)) {
             return Optional.empty();
         }
         generated.add(o);
@@ -48,13 +49,21 @@ ClassName nameGeneratedType(ProvisionBinding input) {
         methodBuilder.addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
         final TypeName contributedTypeName = ClassName.get(input.contributedType());
         methodBuilder.returns(contributedTypeName);
-        List<ParameterSpec> parameterSpecList = new ArrayList<>();
         HashMap<BindingKey, FrameworkField> fields = new HashMap<>();
         for (Map.Entry<BindingKey, FrameworkField> entry : generateBindingFieldsForDependencies(input).entrySet()) {
             FrameworkField bindingField = entry.getValue();
             fields.put(entry.getKey(), bindingField);
         }
 
+        List<ParameterSpec> parameterSpecList = this.buildMethodParamsList(input, fields);
+
+        return Optional.of(TypeSpec.interfaceBuilder(generatedTypeName)
+                .addModifiers(Modifier.PUBLIC)
+                .addMethod(methodBuilder.addParameters(parameterSpecList).build()));
+    }
+
+    protected List<ParameterSpec> buildMethodParamsList(ProvisionBinding input, HashMap<BindingKey, FrameworkField> fields) {
+        List<ParameterSpec> parameterSpecList = new ArrayList<>();
         for (DependencyRequest request : input.explicitDependencies()) {
             final FrameworkField frameworkField = fields.get(request.bindingKey());
             TypeName typeName = request.kind() == DependencyRequest.Kind.INSTANCE ?
@@ -66,10 +75,27 @@ ClassName nameGeneratedType(ProvisionBinding input) {
                     frameworkField.name();
             parameterSpecList.add(ParameterSpec.builder(typeName, name).build());
         }
+        return parameterSpecList;
+    }
 
-        return Optional.of(TypeSpec.interfaceBuilder(generatedTypeName)
-                .addModifiers(Modifier.PUBLIC)
-                .addMethod(methodBuilder.addParameters(parameterSpecList).build()));
+    @Override
+    void generate(ProvisionBinding input) throws SourceFileGenerationException {
+        final AppConfig appConfig = appConfigProvider.get();
+        if (!appConfig.debug()) {
+            ClassName generatedTypeName = nameGeneratedType(input);
+            Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
+            if (!type.isPresent()) {
+                return;
+            }
+            final ClassName className = nameGeneratedType(input);
+            try {
+                testRegistry.addEncodedClass(className, buildJavaFile(className, type.get()));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }else {
+            super.generate(input);
+        }
     }
 
     static TypeName frameworkTypeUsageStatement(TypeName type, DependencyRequest.Kind dependencyKind) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
index c393108f6..30f381696 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
@@ -33,10 +33,6 @@ ClassName nameGeneratedType(TestRegistry input) {
     @Override
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TestRegistry input) {
 
-        if (!input.isDebug()) {
-            return Optional.empty();
-        }
-
         uniqueNameSet = new UniqueNameSet();
         final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName);
         final Iterator<TestRegistry.EncodedClass> it = input.iterator();
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/TestFactoryGenerator.java
new file mode 100644
index 000000000..8515df31d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TestFactoryGenerator.java
@@ -0,0 +1,58 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.util.Elements;
+import java.io.IOException;
+import java.util.Optional;
+import static dagger.internal.codegen.SourceFiles.generatedTestClassNameForBinding;
+
+public class TestFactoryGenerator extends FactoryGenerator {
+    private final AppConfig.Provider appConfigProvider;
+    private final TestRegistry testRegistry;
+
+    TestFactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions, InjectValidator injectValidator, AppConfig.Provider appConfigProvider, TestRegistry testRegistry) {
+        super(filer, elements, compilerOptions, injectValidator);
+        this.appConfigProvider = appConfigProvider;
+        this.testRegistry = testRegistry;
+    }
+
+    @Override
+    protected boolean shouldCheckForDelegate(ContributionBinding binding) {
+        return Util.generateTestDelegate(binding);
+    }
+
+    @Override
+    protected TypeName parameterizedGeneratedTypeNameForBinding(ProvisionBinding binding) {
+        return SourceFiles.parameterizedGeneratedTestTypeNameForBinding(binding);
+    }
+
+    @Override
+    ClassName nameGeneratedType(ProvisionBinding binding) {
+        return generatedTestClassNameForBinding(binding);
+    }
+
+    @Override
+    void generate(ProvisionBinding input) throws SourceFileGenerationException {
+        final AppConfig appConfig = appConfigProvider.get();
+        if (!appConfig.debug() && appConfig.generateExtendedComponents()) {
+            ClassName generatedTypeName = nameGeneratedType(input);
+            Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
+            if (!type.isPresent()) {
+                return;
+            }
+            final ClassName className = nameGeneratedType(input);
+            try {
+                testRegistry.addEncodedClass(className, buildJavaFile(className, type.get()));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }else if(appConfig.generateExtendedComponents()){
+            super.generate(input);
+        }
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
index bea968ae0..4397f32d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
@@ -40,18 +40,6 @@ public ClassName getClassName() {
         return encodedClasses.iterator();
     }
 
-    public byte[] decodeClass(String value) {
-        return Base64.getDecoder().decode(value);
-    }
-
-    public void setDebug(boolean debug) {
-        this.debug = debug;
-    }
-
-    public boolean isDebug() {
-        return this.debug;
-    }
-
     public static class EncodedClass {
 
         public EncodedClass(String qualifiedName, String[] encodedParts) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 3104e1df7..52e17c445 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -330,6 +330,49 @@ static ClassName getDelegateTypeName(Key key) {
         return name;
     }
 
+    static ClassName getMockTypeName(Key key) {
+
+        if (key.multibindingContributionIdentifier().isPresent()) {
+            final Key.MultibindingContributionIdentifier identifier = key.multibindingContributionIdentifier().get();
+            return identifier.getMockTypeName();
+        }
+
+        final TypeMirror returnType = key.type();
+
+        // find qualifier annotations
+        final Optional<? extends AnnotationMirror> qualifier = key.qualifier();
+
+        String simpleQualifierName = "";
+        String simpleQualifierValue = "";
+
+        if (qualifier.isPresent()) {
+            Optional<String> qualifierValue = qualifier.get().getElementValues().entrySet().stream()
+                    .filter(e -> e.getKey().getSimpleName().contentEquals("value"))
+                    .filter(e -> e.getKey().getReturnType().toString().equals(String.class.getName()))
+                    .map(e -> e.getValue().getValue().toString())
+                    .findFirst();
+            simpleQualifierName = MoreAnnotationMirrors.simpleName(qualifier.get()).toString();
+            if (qualifierValue.isPresent()) {
+                simpleQualifierValue = qualifierValue.get();
+            }
+        }
+
+        StringBuilder sb = new StringBuilder();
+        if (qualifier.isPresent()) {
+            sb.append(capitalize(simpleQualifierName).trim());
+            if (!simpleQualifierValue.trim().isEmpty()) {
+                sb.append(capitalize(simpleQualifierValue).trim());
+            }else {
+                sb.append(capitalize(extractClassName(typeToString(returnType))).trim());
+            }
+        }else {
+            sb.append(capitalize(extractClassName(typeToString(returnType))).trim());
+        }
+
+        final ClassName name = ClassName.bestGuess(String.format("delegates.%sMock", sb.toString()));
+        return name;
+    }
+
     static String getDelegateFieldName(Key key) {
 
         if (key.multibindingContributionIdentifier().isPresent()) {
@@ -376,6 +419,52 @@ static String getDelegateFieldName(Key key) {
         return sb.toString();
     }
 
+    static String getMockFieldName(Key key) {
+
+        if (key.multibindingContributionIdentifier().isPresent()) {
+            final Key.MultibindingContributionIdentifier identifier = key.multibindingContributionIdentifier().get();
+            return identifier.getMockFieldName();
+        }
+
+        final TypeMirror returnType = key.type();
+
+        // find qualifier annotations
+        final Optional<? extends AnnotationMirror> qualifier = key.qualifier();
+
+        Optional<String> qualifierValue = Optional.empty();
+
+        String simpleQualifierName = "";
+        String simpleQualifierValue = "";
+
+        if (qualifier.isPresent()) {
+            qualifierValue = qualifier.get().getElementValues().entrySet().stream()
+                    .filter(e -> e.getKey().getSimpleName().toString().equals("value"))
+                    .filter(e -> e.getKey().getReturnType().toString().equals(String.class.getName()))
+                    .map(e -> e.getValue().getValue().toString())
+                    .findFirst();
+            simpleQualifierName = MoreAnnotationMirrors.simpleName(qualifier.get()).toString();
+            if (qualifierValue.isPresent()) {
+                simpleQualifierValue = qualifierValue.get();
+            }
+        }
+
+        StringBuilder sb = new StringBuilder();
+        if (qualifier.isPresent()) {
+            sb.append(lowerCaseFirstLetter(simpleQualifierName));
+            if (!simpleQualifierValue.isEmpty()) {
+                sb.append(transformValue(simpleQualifierValue, sb));
+            }else {
+                sb.append(transformValue(extractClassName(typeToString(returnType)), sb));
+            }
+        }else {
+            sb.append(lowerCaseFirstLetter(extractClassName(typeToString(returnType))));
+        }
+
+        sb.append("Mock");
+
+        return sb.toString();
+    }
+
     private static String transformValue(String simpleMapValueName, StringBuilder sb) {
         return sb.length() == 0 ? lowerCaseFirstLetter(simpleMapValueName) : capitalize(simpleMapValueName);
     }
@@ -672,8 +761,7 @@ public static void createDelegateField(TypeSpec.Builder classBuilder, Contributi
                 final FieldSpec fieldSpec = builder.build();
                 classBuilder.addField(fieldSpec);
             }
-        } catch (Exception e) {
-        }
+        } catch (Exception e) {}
     }
 
     public static void createDelegateFieldAndMethod(TypeName generatedTypeName, TypeSpec.Builder classBuilder, ContributionBinding binding, Map<Key, String> delegateFieldNames, boolean publicMethod) {
@@ -702,6 +790,39 @@ public static void createDelegateFieldAndMethod(TypeName generatedTypeName, Type
         }
     }
 
+    public static void createMockFieldAndMethod(TypeName generatedTypeName, TypeSpec.Builder classBuilder, ContributionBinding binding, Map<Key, String> mockFieldNames, boolean publicMethod) {
+        try {
+            if (binding.dependencies().isEmpty()) {
+                return;
+            }
+            if (bindingSupportsTestDelegate(binding)) {
+                final String mockFieldName = Util.getMockFieldName(binding.key());
+                final ClassName delegateType = Util.getMockTypeName(binding.key());
+                final FieldSpec.Builder builder = FieldSpec.builder(providerOf(binding), mockFieldName);
+                builder.addModifiers(Modifier.PRIVATE);
+                mockFieldNames.put(binding.key(), mockFieldName);
+                final FieldSpec fieldSpec = builder.build();
+                classBuilder.addField(fieldSpec);
+                final String methodName = getDelegateMethodName(delegateType);
+                final MethodSpec.Builder delegateMethodBuilder = MethodSpec.methodBuilder(methodName);
+                if (publicMethod) {
+                    delegateMethodBuilder.addModifiers(Modifier.PUBLIC);
+                }
+                classBuilder.addMethod(delegateMethodBuilder
+                        .returns(generatedTypeName)
+                        .addParameter(providerOf(binding), mockFieldName)
+                        .addStatement("this.$N = $L", fieldSpec, CodeBlock.of(mockFieldName))
+                        .addStatement("return this")
+                        .build());
+            }
+        } catch (Exception e) {
+        }
+    }
+
+    static TypeName providerOf(ContributionBinding binding) {
+        return ParameterizedTypeName.get(ClassName.get(Provider.class), ClassName.get(binding.key().type()));
+    }
+
     public static String getProvisionMethodName(ContributionBinding binding) {
         return "get" + getDelegateTypeName(binding.key()).simpleName().replaceAll("Delegate$", "");
     }
@@ -734,4 +855,24 @@ public static ClassName getDaggerComponentClassName(Element component) {
     public static final ClassName TYPENAME_ANDROID_APPLICATION = ClassName.bestGuess("android.app.Application");
     public static final ClassName TYPENAME_DAGGER_ANDROID_APPLICATION = TYPENAME_ANDROID_APPLICATION.topLevelClassName().peerClass("DaggerApplication");
 
+    public static boolean generateTestDelegate(ContributionBinding binding) {
+        return bindingCanBeProvidedInTest(binding) && !binding.genericParameter() && !binding.ignoreStubGeneration();
+    }
+
+    public static void createMockField(TypeSpec.Builder classBuilder, ContributionBinding binding) {
+        try {
+            if (bindingSupportsTestDelegate(binding)) {
+                final String delegateFieldName = Util.getMockFieldName(binding.key());
+                final ClassName delegateType = getMockTypeName(binding.key());
+                final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
+                builder.addModifiers(Modifier.PRIVATE);
+                final FieldSpec fieldSpec = builder.build();
+                classBuilder.addField(fieldSpec);
+            }
+        } catch (Exception e) {}
+    }
+
+    static String getMockMethodName(ClassName mockTypeName) {
+        return "with" + mockTypeName.simpleName().replaceAll("Delegate$", "Mock");
+    }
 }
diff --git a/core/src/main/java/dagger/Config.java b/core/src/main/java/dagger/Config.java
index ec83dea2a..0726b8449 100644
--- a/core/src/main/java/dagger/Config.java
+++ b/core/src/main/java/dagger/Config.java
@@ -14,4 +14,5 @@
     Class<?> applicationClass();
     String baseApplicationClass() default "android.app.Application";
     boolean debug() default false;
+    boolean generateExtendedComponents() default false;
 }
diff --git a/pom.xml b/pom.xml
index 83f39afb3..11b8e6ff3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -47,7 +47,7 @@
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <android.support.version>24.2.0</android.support.version>
-    <android.latest.version>25</android.latest.version>
+    <android.latest.version>26</android.latest.version>
   </properties>
 
   <scm>
