diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 3dd5c1d51..2eec92721 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -54,6 +54,10 @@ CODEGEN_SHARED_DEPS = [
 CODEGEN_DEPS = CODEGEN_SHARED_DEPS + [
     "@google_bazel_common//third_party/java/guava",
     ":shared-with-spi",
+    "@me_eugeniomarletti_kotlin_metadata_kotlin_metadata//jar",
+    "@me_eugeniomarletti_kotlin_metadata_kotlin_compiler_lite//jar",
+    "@org_jetbrains_kotlin_kotlin_stdlib//jar",
+    "@org_jetbrains_annotations//jar"
 ]
 
 # Code that is shared with the dagger.model and dagger.spi packages. This code is merged into both
@@ -127,6 +131,7 @@ java_library(
         "BindingTypeMapper.java",
         "BindingVariableNamer.java",  # needed by FrameworkField
         "BindsTypeChecker.java",
+        "CompanionObjectExecutableElement.java",
         "ComponentDescriptor.java",
         "ComponentRequirement.java",
         "ComponentTreeTraverser.java",
diff --git a/java/dagger/internal/codegen/CompanionObjectExecutableElement.java b/java/dagger/internal/codegen/CompanionObjectExecutableElement.java
new file mode 100644
index 000000000..6d456b707
--- /dev/null
+++ b/java/dagger/internal/codegen/CompanionObjectExecutableElement.java
@@ -0,0 +1,109 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * An {@link ExecutableElement} that delegates to a real one but reflects that it is an enclosed
+ * element of a Kotlin companion object, and thus should be considered part of the enclosing
+ * TypeElement with {@link #companionObjectName} accessing notation. This also reports itself as
+ * having a {@link Modifier#STATIC} modifier.
+ */
+final class CompanionObjectExecutableElement implements ExecutableElement {
+
+  private final ExecutableElement delegate;
+  final String companionObjectName;
+
+  CompanionObjectExecutableElement(ExecutableElement delegate, String companionObjectName) {
+    this.delegate = delegate;
+    this.companionObjectName = companionObjectName;
+  }
+
+  @Override public List<? extends TypeParameterElement> getTypeParameters() {
+    return delegate.getTypeParameters();
+  }
+
+  @Override public TypeMirror getReturnType() {
+    return delegate.getReturnType();
+  }
+
+  @Override public List<? extends VariableElement> getParameters() {
+    return delegate.getParameters();
+  }
+
+  @Override public TypeMirror getReceiverType() {
+    return delegate.getReceiverType();
+  }
+
+  @Override public boolean isVarArgs() {
+    return delegate.isVarArgs();
+  }
+
+  @Override public boolean isDefault() {
+    return delegate.isDefault();
+  }
+
+  @Override public List<? extends TypeMirror> getThrownTypes() {
+    return delegate.getThrownTypes();
+  }
+
+  @Override public AnnotationValue getDefaultValue() {
+    return delegate.getDefaultValue();
+  }
+
+  @Override public TypeMirror asType() {
+    return delegate.asType();
+  }
+
+  @Override public ElementKind getKind() {
+    return delegate.getKind();
+  }
+
+  @Override public Set<Modifier> getModifiers() {
+    return ImmutableSet.<Modifier>builder()
+        .addAll(delegate.getModifiers())
+        .add(Modifier.STATIC)
+        .build();
+  }
+
+  @Override public Name getSimpleName() {
+    return delegate.getSimpleName();
+  }
+
+  @Override public Element getEnclosingElement() {
+    return delegate.getEnclosingElement();
+  }
+
+  @Override public List<? extends Element> getEnclosedElements() {
+    return delegate.getEnclosedElements();
+  }
+
+  @Override public List<? extends AnnotationMirror> getAnnotationMirrors() {
+    return delegate.getAnnotationMirrors();
+  }
+
+  @Override public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
+    return delegate.getAnnotation(annotationType);
+  }
+
+  @Override public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
+    return delegate.getAnnotationsByType(annotationType);
+  }
+
+  @Override public <R, P> R accept(ElementVisitor<R, P> v, P p) {
+    return delegate.accept(v, p);
+  }
+}
diff --git a/java/dagger/internal/codegen/ModuleProcessingStep.java b/java/dagger/internal/codegen/ModuleProcessingStep.java
index 5e6609bfe..54365cf41 100644
--- a/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -16,10 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-import static javax.lang.model.util.ElementFilter.typesIn;
-
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
@@ -31,13 +27,25 @@
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
+import java.util.Collections;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
+import java.util.stream.Collectors;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import me.eugeniomarletti.kotlin.metadata.ClassData;
+import me.eugeniomarletti.kotlin.metadata.KotlinClassMetadata;
+import me.eugeniomarletti.kotlin.metadata.KotlinMetadata;
+import me.eugeniomarletti.kotlin.metadata.KotlinMetadataKt;
+import me.eugeniomarletti.kotlin.metadata.shadow.metadata.ProtoBuf;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
 
 /**
  * A {@link ProcessingStep} that validates module classes and generates factories for binding
@@ -93,6 +101,32 @@ private void processModule(TypeElement module) {
     ValidationReport<TypeElement> report = moduleValidator.validate(module);
     report.printMessagesTo(messager);
     if (report.isClean()) {
+      List<ExecutableElement> methods = methodsIn(module.getEnclosedElements());
+      KotlinMetadata metadata = KotlinMetadataKt.getKotlinMetadata(module);
+      if (metadata instanceof KotlinClassMetadata) {
+        KotlinClassMetadata classMetadata = (KotlinClassMetadata) metadata;
+        ClassData classData = classMetadata.getData();
+        ProtoBuf.Class classProto = classMetadata.getData().getClassProto();
+        if (classProto.hasCompanionObjectName()) {
+          final String companionObjectName = classData.getNameResolver()
+              .getString(classProto.getCompanionObjectName());
+          Optional<TypeElement> optionalCompanionObject = typesIn(Collections.singleton(module))
+              .stream()
+              .filter(t -> t.getSimpleName().toString().equals(companionObjectName))
+              .findFirst();
+
+          if (optionalCompanionObject.isPresent()) {
+            TypeElement companionObject = optionalCompanionObject.get();
+            List<ExecutableElement> companionObjectMethods = methodsIn(companionObject.getEnclosedElements())
+                .stream()
+                .map(m -> new CompanionObjectExecutableElement(m, companionObjectName))
+                .collect(Collectors.toList());
+            methods.addAll(companionObjectMethods);
+          } else {
+            // TODO(zsweers) This case shouldn't be possible. How should we error?
+          }
+        }
+      }
       for (ExecutableElement method : methodsIn(module.getEnclosedElements())) {
         if (isAnnotationPresent(method, Provides.class)) {
           generate(factoryGenerator, bindingFactory.providesMethodBinding(method, module));
