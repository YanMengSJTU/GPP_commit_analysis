diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 7eb4663ad..2b313cc6b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -82,6 +82,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_DELEGATE_BINDING;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
@@ -437,6 +438,10 @@ private void validateResolvedBinding(DependencyPath path) {
             validateMapKeySet(path, multibindings);
             validateMapKeyAnnotationTypes(path, multibindings);
           }
+          // Check the root, exposed dependency to make sure it's not marked with @Internal.
+          if (path.size() == 1) {
+            validateExposedDependencyIsNotInternal(resolvedBinding);
+          }
           break;
         case MEMBERS_INJECTION:
           if (!Iterables.all(
@@ -947,6 +952,20 @@ void validateComponentScope() {
       }
     }
 
+    private void validateExposedDependencyIsNotInternal(ResolvedBindings resolvedBindings) {
+      if (resolvedBindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+        ContributionBinding contributionBinding = (ContributionBinding) resolvedBindings.binding();
+        if (contributionBinding.bindingKind().equals(PROVISION)) {
+          ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+          if (provisionBinding.internal()) {
+            TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
+            reportBuilder.addError(String.format(ErrorMessages.EXPOSING_INTERNAL_DEPENDNECY,
+                    provisionBinding.bindingElement().toString()), componentType);
+          }
+        }
+      }
+    }
+
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportProviderMayNotDependOnProducer(DependencyPath path) {
       StringBuilder errorMessage = new StringBuilder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index cbb82fc58..32b949c8b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -198,6 +198,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_WITH_SAME_NAME =
       "Cannot have more than one @%s method with the same name in a single module";
 
+  static final String EXPOSING_INTERNAL_DEPENDNECY =
+      "%s is marked as @Internal and should not be exposed on a component.";
+
   static final String INCOMPATIBLE_MODULE_METHODS =
       "A @%1$s may not contain both non-static @%2$s methods and abstract @Binds or @Multibinds "
           + "declarations";
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 9817dd052..beacb60b1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -28,6 +28,7 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
+import dagger.Internal;
 import dagger.internal.Factory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.Preconditions;
@@ -175,6 +176,9 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             || binding.bindingKind() == INJECTION) {
           createMethodBuilder.addTypeVariables(typeParameters);
         }
+        if (binding.internal()) {
+          createMethodBuilder.addAnnotation(Internal.class);
+        }
         List<ParameterSpec> params =
             constructorBuilder.isPresent()
                 ? constructorBuilder.get().build().parameters : ImmutableList.<ParameterSpec>of();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 8a8ac1cfd..57a6bb82d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -22,6 +22,7 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import dagger.Internal;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -68,6 +69,8 @@ public BindingType bindingType() {
   @Override
   abstract Optional<Scope> scope();
 
+  abstract boolean internal();
+
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -133,7 +136,8 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
               ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
               : Optional.<ProvisionBinding>absent(),
-          scope);
+          scope,
+          false);
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -166,6 +170,9 @@ ProvisionBinding forProvidesMethod(
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
       Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
+
+      boolean internal = providesMethod.getAnnotation(Internal.class) != null;
+
       return new AutoValue_ProvisionBinding(
           ContributionType.fromBindingMethod(providesMethod),
           providesMethod,
@@ -177,7 +184,8 @@ ProvisionBinding forProvidesMethod(
           wrapOptionalInEquivalence(getMapKey(providesMethod)),
           Kind.PROVISION,
           Optional.<ProvisionBinding>absent(),
-          scope);
+          scope,
+          internal);
     }
 
     /**
@@ -205,7 +213,8 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
           wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())),
           Kind.SYNTHETIC_MAP,
           Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()));
+          Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()),
+          false);
     }
 
     /**
@@ -227,7 +236,8 @@ ProvisionBinding syntheticMultibinding(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.forMultibindingRequest(request),
           Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(request.requestElement()));
+          Scope.uniqueScopeOf(request.requestElement()),
+          false);
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
@@ -243,7 +253,8 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.COMPONENT,
           Optional.<ProvisionBinding>absent(),
-          Optional.<Scope>absent());
+          Optional.<Scope>absent(),
+          false);
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
@@ -262,7 +273,8 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.COMPONENT_PROVISION,
           Optional.<ProvisionBinding>absent(),
-          scope);
+          scope,
+          false);
     }
 
     ProvisionBinding forSubcomponentBuilderMethod(
@@ -282,7 +294,8 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.SUBCOMPONENT_BUILDER,
           Optional.<ProvisionBinding>absent(),
-          Optional.<Scope>absent());
+          Optional.<Scope>absent(),
+          false);
     }
 
     ProvisionBinding delegate(
@@ -299,7 +312,8 @@ ProvisionBinding delegate(
           delegateDeclaration.wrappedMapKey(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(delegateDeclaration.bindingElement()));
+          Scope.uniqueScopeOf(delegateDeclaration.bindingElement()),
+          delegate.internal());
     }
   }
 }
diff --git a/core/src/main/java/dagger/Internal.java b/core/src/main/java/dagger/Internal.java
new file mode 100644
index 000000000..04996c232
--- /dev/null
+++ b/core/src/main/java/dagger/Internal.java
@@ -0,0 +1,9 @@
+package dagger;
+
+import java.lang.annotation.*;
+
+import static java.lang.annotation.ElementType.*;
+import static java.lang.annotation.RetentionPolicy.*;
+
+@Target(METHOD) @Retention(RUNTIME)
+public @interface Internal { }
