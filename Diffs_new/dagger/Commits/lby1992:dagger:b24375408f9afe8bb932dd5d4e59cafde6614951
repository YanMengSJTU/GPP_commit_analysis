diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index 1b295b7e4..0695d81c2 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.DaggerElements.elementEncloses;
 import static dagger.internal.codegen.DaggerElements.elementToString;
@@ -197,16 +198,23 @@ private void reportAtEntryPointsWithDependencyTrace(
     private CharSequence dependencyTrace(DependencyEdge entryPoint, BindingNode bindingNode) {
       checkArgument(entryPoint.isEntryPoint());
       Node entryPointBinding = graph.incidentNodes(entryPoint).target();
-      ImmutableList<Node> shortestPath =
+      ImmutableList<Node> shortestBindingPath =
           shortestPath(
               node -> Sets.filter(graph.successors(node), BindingNode.class::isInstance),
               entryPointBinding,
               bindingNode);
+      verify(
+          !shortestBindingPath.isEmpty(),
+          "no dependency path from %s to %s in %s",
+          entryPoint,
+          bindingNode,
+          graph);
 
-      StringBuilder trace = new StringBuilder(shortestPath.size() * 100 /* a guess heuristic */);
-      for (int i = shortestPath.size() - 1; i > 0; i--) {
+      StringBuilder trace =
+          new StringBuilder(shortestBindingPath.size() * 100 /* a guess heuristic */);
+      for (int i = shortestBindingPath.size() - 1; i > 0; i--) {
         Set<Edge> dependenciesBetween =
-            graph.edgesConnecting(shortestPath.get(i - 1), shortestPath.get(i));
+            graph.edgesConnecting(shortestBindingPath.get(i - 1), shortestBindingPath.get(i));
         DependencyRequest dependencyRequest =
             // If a binding requests a key more than once, any of them should be fine to get to
             // the shortest path
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 7e49da620..9b1294205 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -30,7 +30,9 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.graph.EndpointPair;
 import com.google.common.graph.ImmutableNetwork;
+import com.google.common.graph.MutableNetwork;
 import com.google.common.graph.Network;
+import com.google.common.graph.NetworkBuilder;
 import dagger.Module;
 import dagger.model.BindingGraph.Edge;
 import dagger.model.BindingGraph.Node;
@@ -173,12 +175,30 @@ public ComponentNode rootComponentNode() {
   /** Returns the edges for entry points that transitively depend on a binding. */
   public ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBindingNode(
       BindingNode bindingNode) {
-    Network<Node, Edge> subgraphDependingOnBindingNode =
-        inducedSubgraph(this, reachableNodes(transpose(this).asGraph(), bindingNode));
+    ImmutableNetwork<Node, DependencyEdge> dependencyGraph = dependencyGraph();
+    Network<Node, DependencyEdge> subgraphDependingOnBindingNode =
+        inducedSubgraph(
+            dependencyGraph, reachableNodes(transpose(dependencyGraph).asGraph(), bindingNode));
     return ImmutableSet.copyOf(
         intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()));
   }
 
+  // TODO(dpb): Make public. Cache.
+  private ImmutableNetwork<Node, DependencyEdge> dependencyGraph() {
+    MutableNetwork<Node, DependencyEdge> dependencyGraph =
+        NetworkBuilder.from(this)
+            .expectedNodeCount(nodes().size())
+            .expectedEdgeCount((int) dependencyEdgeStream().count())
+            .build();
+    dependencyEdgeStream()
+        .forEach(
+            edge -> {
+              EndpointPair<Node> endpoints = incidentNodes(edge);
+              dependencyGraph.addEdge(endpoints.source(), endpoints.target(), edge);
+            });
+    return ImmutableNetwork.copyOf(dependencyGraph);
+  }
+
   private <N extends Node> ImmutableSet<N> nodes(Class<N> clazz) {
     return nodeStream(clazz).collect(toImmutableSet());
   }
