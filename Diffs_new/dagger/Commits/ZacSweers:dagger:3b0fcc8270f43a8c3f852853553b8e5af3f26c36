diff --git a/java/dagger/android/processor/AndroidMapKeyValidator.java b/java/dagger/android/processor/AndroidMapKeyValidator.java
index d58debb6a..4cdcd2a5c 100644
--- a/java/dagger/android/processor/AndroidMapKeyValidator.java
+++ b/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -69,11 +69,18 @@
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> deferredElements = ImmutableSet.builder();
     elementsByAnnotation
         .entries()
         .forEach(
-            entry -> validateMethod(entry.getKey(), MoreElements.asExecutable(entry.getValue())));
-    return ImmutableSet.of();
+            entry -> {
+              try {
+                validateMethod(entry.getKey(), MoreElements.asExecutable(entry.getValue()));
+              } catch (TypeNotPresentException e) {
+                deferredElements.add(entry.getValue());
+              }
+            });
+    return deferredElements.build();
   }
 
   private void validateMethod(Class<? extends Annotation> annotation, ExecutableElement method) {
diff --git a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
index 46e40ff6a..d25e7b444 100644
--- a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
+++ b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
@@ -91,10 +91,15 @@
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> deferredElements = ImmutableSet.builder();
     for (ExecutableElement method : methodsIn(elementsByAnnotation.values())) {
-      validator.createIfValid(method).ifPresent(this::generate);
+      try {
+        validator.createIfValid(method).ifPresent(this::generate);
+      } catch (TypeNotPresentException e) {
+        deferredElements.add(method);
+      }
     }
-    return ImmutableSet.of();
+    return deferredElements.build();
   }
 
   private void generate(AndroidInjectorDescriptor descriptor) {
diff --git a/java/dagger/grpc/server/processor/GrpcServiceProcessor.java b/java/dagger/grpc/server/processor/GrpcServiceProcessor.java
index 122718d5d..58495e2f1 100644
--- a/java/dagger/grpc/server/processor/GrpcServiceProcessor.java
+++ b/java/dagger/grpc/server/processor/GrpcServiceProcessor.java
@@ -63,16 +63,21 @@ public SourceVersion getSupportedSourceVersion() {
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> deferredElements = ImmutableSet.builder();
     for (TypeElement element : typesIn(elementsByAnnotation.get(GrpcService.class))) {
-      GrpcServiceModel grpcServiceModel = new GrpcServiceModel(processingEnv, element);
-      if (grpcServiceModel.validate()) {
-        write(new ServiceDefinitionTypeGenerator(grpcServiceModel), element);
-        write(new ProxyModuleGenerator(grpcServiceModel), element);
-        write(new GrpcServiceModuleGenerator(grpcServiceModel), element);
-        write(new UnscopedGrpcServiceModuleGenerator(grpcServiceModel), element);
+      try {
+        GrpcServiceModel grpcServiceModel = new GrpcServiceModel(processingEnv, element);
+        if (grpcServiceModel.validate()) {
+          write(new ServiceDefinitionTypeGenerator(grpcServiceModel), element);
+          write(new ProxyModuleGenerator(grpcServiceModel), element);
+          write(new GrpcServiceModuleGenerator(grpcServiceModel), element);
+          write(new UnscopedGrpcServiceModuleGenerator(grpcServiceModel), element);
+        }
+      } catch (TypeNotPresentException e) {
+        deferredElements.add(element);
       }
     }
-    return ImmutableSet.of();
+    return deferredElements.build();
   }
 
   private void write(SourceGenerator grpcServiceTypeWriter, final TypeElement element) {
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 1d3e32af1..2a0c07cee 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -105,6 +105,7 @@ java_library(
         "SimpleTypeAnnotationValue.java",
         "SourceFileGenerationException.java",  # Used in :writing and :processor
         "SourceFileGenerator.java",  # Needed by InjectBindingRegistry in :binding and also :writing
+        "TypeCheckingProcessingStep.java",
         "TypeNames.java",
         "TypeSpecs.java",
         "UniqueNameSet.java",
diff --git a/java/dagger/internal/codegen/BindingMethodProcessingStep.java b/java/dagger/internal/codegen/BindingMethodProcessingStep.java
index 50c2081a4..e6c4f8ed3 100644
--- a/java/dagger/internal/codegen/BindingMethodProcessingStep.java
+++ b/java/dagger/internal/codegen/BindingMethodProcessingStep.java
@@ -17,20 +17,17 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static javax.lang.model.util.ElementFilter.methodsIn;
 
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 
 /** A step that validates all binding methods that were not validated while processing modules. */
-final class BindingMethodProcessingStep implements ProcessingStep {
+final class BindingMethodProcessingStep extends TypeCheckingProcessingStep<ExecutableElement> {
 
   private final Messager messager;
   private final AnyBindingMethodValidator anyBindingMethodValidator;
@@ -38,6 +35,7 @@
   @Inject
   BindingMethodProcessingStep(
       Messager messager, AnyBindingMethodValidator anyBindingMethodValidator) {
+    super(MoreElements::asExecutable);
     this.messager = messager;
     this.anyBindingMethodValidator = anyBindingMethodValidator;
   }
@@ -48,18 +46,15 @@
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (ExecutableElement method : methodsIn(elementsByAnnotation.values())) {
-      checkArgument(
-          anyBindingMethodValidator.isBindingMethod(method),
-          "%s is not annotated with any of %s",
-          method,
-          annotations());
-      if (!anyBindingMethodValidator.wasAlreadyValidated(method)) {
-        anyBindingMethodValidator.validate(method).printMessagesTo(messager);
-      }
+  protected void process(
+      ExecutableElement method, ImmutableSet<Class<? extends Annotation>> annotations) {
+    checkArgument(
+        anyBindingMethodValidator.isBindingMethod(method),
+        "%s is not annotated with any of %s",
+        method,
+        annotations());
+    if (!anyBindingMethodValidator.wasAlreadyValidated(method)) {
+      anyBindingMethodValidator.validate(method).printMessagesTo(messager);
     }
-    return ImmutableSet.of();
   }
 }
diff --git a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index 87ddbf772..fc7fc71ec 100644
--- a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -24,10 +24,8 @@
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import dagger.BindsInstance;
 import java.lang.annotation.Annotation;
 import java.util.Set;
@@ -35,7 +33,6 @@
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -44,7 +41,7 @@
  * Processing step that validates that the {@code BindsInstance} annotation is applied to the
  * correct elements.
  */
-final class BindsInstanceProcessingStep implements ProcessingStep {
+final class BindsInstanceProcessingStep extends TypeCheckingProcessingStep<ExecutableElement> {
 
   private static final ImmutableSet<Class<? extends Annotation>> COMPONENT_ANNOTATIONS =
       Stream.of(ComponentDescriptor.Kind.values())
@@ -59,6 +56,7 @@
 
   @Inject
   BindsInstanceProcessingStep(Messager messager) {
+    super(MoreElements::asExecutable);
     this.messager = messager;
   }
 
@@ -68,10 +66,8 @@
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (Element element : elementsByAnnotation.get(BindsInstance.class)) {
-      ExecutableElement method = MoreElements.asExecutable(element);
+  protected void process(
+      ExecutableElement method, ImmutableSet<Class<? extends Annotation>> annotations) {
       ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
       if (!method.getModifiers().contains(ABSTRACT)) {
         report.addError("@BindsInstance methods must be abstract");
@@ -102,7 +98,5 @@
                 simpleName(componentAnnotation)));
       }
       report.build().printMessagesTo(messager);
-    }
-    return ImmutableSet.of();
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index a5e6df112..6b07406b2 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -22,7 +22,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static dagger.internal.codegen.ComponentGenerator.componentName;
-import static dagger.internal.codegen.ComponentProcessingStep.getElementsFromAnnotations;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -31,11 +30,9 @@
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
@@ -74,7 +71,7 @@
  * <p>The components emitted by this processing step include all of the API elements exposed by the
  * normal step. Method bodies are omitted as Turbine ignores them entirely.
  */
-final class ComponentHjarProcessingStep implements ProcessingStep {
+final class ComponentHjarProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Elements elements;
   private final SourceVersion sourceVersion;
   private final Types types;
@@ -92,6 +89,7 @@
       Messager messager,
       ComponentValidator componentValidator,
       Factory componentDescriptorFactory) {
+    super(MoreElements::asType);
     this.elements = elements;
     this.sourceVersion = sourceVersion;
     this.types = types;
@@ -107,33 +105,19 @@
   }
 
   @Override
-  public ImmutableSet<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-
-    ImmutableSet<Element> componentElements =
-        getElementsFromAnnotations(
-            elementsByAnnotation, Component.class, ProductionComponent.class);
-
-    for (Element element : componentElements) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      try {
-        // TODO(ronshapiro): component validation might not be necessary. We should measure it and
-        // figure out if it's worth seeing if removing it will still work. We could potentially
-        // add a new catch clause for any exception that's not TypeNotPresentException and ignore
-        // the component entirely in that case.
-        ComponentValidationReport validationReport =
-            componentValidator.validate(componentTypeElement, ImmutableSet.of(), ImmutableSet.of());
-        validationReport.report().printMessagesTo(messager);
-        if (validationReport.report().isClean()) {
-          new EmptyComponentGenerator(filer, elements, sourceVersion)
-              .generate(componentDescriptorFactory.forComponent(componentTypeElement), messager);
-        }
-      } catch (TypeNotPresentException e) {
-        rejectedElements.add(componentTypeElement);
-      }
+  protected void process(
+      TypeElement componentTypeElement, ImmutableSet<Class<? extends Annotation>> annotations) {
+    // TODO(ronshapiro): component validation might not be necessary. We should measure it and
+    // figure out if it's worth seeing if removing it will still work. We could potentially add a
+    // new catch clause for any exception that's not TypeNotPresentException and ignore the
+    // component entirely in that case.
+    ComponentValidationReport validationReport =
+        componentValidator.validate(componentTypeElement, ImmutableSet.of(), ImmutableSet.of());
+    validationReport.report().printMessagesTo(messager);
+    if (validationReport.report().isClean()) {
+      new EmptyComponentGenerator(filer, elements, sourceVersion)
+          .generate(componentDescriptorFactory.forComponent(componentTypeElement), messager);
     }
-    return rejectedElements.build();
   }
 
   private final class EmptyComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 0337702b6..2b9e28cf6 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -16,13 +16,11 @@
 
 package dagger.internal.codegen;
 
-import static javax.lang.model.util.ElementFilter.typesIn;
-
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
@@ -31,6 +29,7 @@
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
@@ -42,7 +41,7 @@
  * A {@link ProcessingStep} that is responsible for dealing with a component or production component
  * as part of the {@link ComponentProcessor}.
  */
-final class ComponentProcessingStep implements ProcessingStep {
+final class ComponentProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final BuilderValidator builderValidator;
@@ -54,6 +53,11 @@
   private final BindingGraphPlugins validationPlugins;
   private final BindingGraphPlugins spiPlugins;
   private final CompilerOptions compilerOptions;
+  private ImmutableSet<Element> subcomponentElements;
+  private ImmutableSet<Element> subcomponentBuilderElements;
+  private ImmutableMap<Element, ValidationReport<TypeElement>> builderReportsByComponent;
+  private ImmutableMap<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent;
+  private ImmutableMap<Element, ValidationReport<TypeElement>> reportsBySubcomponent;
 
   @Inject
   ComponentProcessingStep(
@@ -68,6 +72,7 @@
       @Validation BindingGraphPlugins validationPlugins,
       BindingGraphPlugins spiPlugins,
       CompilerOptions compilerOptions) {
+    super(MoreElements::asType);
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.builderValidator = builderValidator;
@@ -97,78 +102,60 @@
   @Override
   public ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-
-    ImmutableSet<Element> componentElements =
-        getElementsFromAnnotations(
-            elementsByAnnotation, Component.class, ProductionComponent.class);
-    ImmutableSet<Element> componentBuilderElements =
-        getElementsFromAnnotations(
-            elementsByAnnotation, Component.Builder.class, ProductionComponent.Builder.class);
-
-    ImmutableSet<Element> subcomponentElements =
+    subcomponentElements =
         getElementsFromAnnotations(
             elementsByAnnotation, Subcomponent.class, ProductionSubcomponent.class);
-    ImmutableSet<Element> subcomponentBuilderElements =
+    subcomponentBuilderElements =
         getElementsFromAnnotations(
             elementsByAnnotation, Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
 
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
-        processBuilders(componentBuilderElements);
-    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
-        processBuilders(subcomponentBuilderElements);
-    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
-        processSubcomponents(subcomponentElements, subcomponentBuilderElements);
+    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
 
-    for (TypeElement componentTypeElement : typesIn(componentElements)) {
-      try {
-        ComponentValidationReport validationReport =
-            componentValidator.validate(
-                componentTypeElement, subcomponentElements, subcomponentBuilderElements);
-        validationReport.report().printMessagesTo(messager);
-        if (!isClean(
-            validationReport,
-            builderReportsByComponent,
-            reportsBySubcomponent,
-            builderReportsBySubcomponent)) {
-          continue;
-        }
-        ComponentDescriptor componentDescriptor =
-            componentDescriptorFactory.forComponent(componentTypeElement);
-        ValidationReport<TypeElement> componentDescriptorReport =
-            componentDescriptorValidator.validate(componentDescriptor);
-        componentDescriptorReport.printMessagesTo(messager);
-        if (!componentDescriptorReport.isClean()) {
-          continue;
-        }
-        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-        if (isValid(bindingGraph)) {
-          generateComponent(bindingGraph);
-        }
-      } catch (TypeNotPresentException e) {
-        rejectedElements.add(componentTypeElement);
+    builderReportsByComponent =
+        processBuilders(
+            getElementsFromAnnotations(
+                elementsByAnnotation, Component.Builder.class, ProductionComponent.Builder.class),
+            rejectedElements);
+    builderReportsBySubcomponent = processBuilders(subcomponentBuilderElements, rejectedElements);
+    reportsBySubcomponent =
+        processSubcomponents(subcomponentElements, subcomponentBuilderElements, rejectedElements);
+
+    return rejectedElements.addAll(super.process(elementsByAnnotation)).build();
+  }
+
+  @Override
+  protected void process(
+      TypeElement element, ImmutableSet<Class<? extends Annotation>> annotations) {
+    if (annotations.contains(Component.class) || annotations.contains(ProductionComponent.class)) {
+      ComponentValidationReport validationReport =
+          componentValidator.validate(element, subcomponentElements, subcomponentBuilderElements);
+      validationReport.report().printMessagesTo(messager);
+      if (!isClean(validationReport)) {
+        return;
+      }
+      ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(element);
+      ValidationReport<TypeElement> componentDescriptorReport =
+          componentDescriptorValidator.validate(componentDescriptor);
+      componentDescriptorReport.printMessagesTo(messager);
+      if (!componentDescriptorReport.isClean()) {
+        return;
+      }
+      BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+      if (isValid(bindingGraph)) {
+        generateComponent(bindingGraph);
       }
     }
-
-    if (compilerOptions.aheadOfTimeSubcomponents()) {
-      for (TypeElement subcomponentTypeElement : typesIn(subcomponentElements)) {
-        if (!subcomponentIsClean(
-            subcomponentTypeElement, reportsBySubcomponent, builderReportsBySubcomponent)) {
-          continue;
-        }
-        try {
-          ComponentDescriptor componentDescriptor =
-              componentDescriptorFactory.forComponent(subcomponentTypeElement);
-          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-          // TODO(b/72748365): Do subgraph validation.
-          generateComponent(bindingGraph);
-        } catch (TypeNotPresentException e) {
-          rejectedElements.add(subcomponentTypeElement);
-        }
+    if (compilerOptions.aheadOfTimeSubcomponents()
+        && (annotations.contains(Subcomponent.class)
+            || annotations.contains(ProductionSubcomponent.class))) {
+      if (!subcomponentIsClean(element)) {
+        return;
       }
+      ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(element);
+      BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+      // TODO(b/72748365): Do subgraph validation.
+      generateComponent(bindingGraph);
     }
-
-    return rejectedElements.build();
   }
 
   private boolean isValid(BindingGraph bindingGraph) {
@@ -189,41 +176,48 @@ private void generateComponent(BindingGraph bindingGraph) {
             .values());
   }
 
-  private Map<Element, ValidationReport<TypeElement>> processBuilders(
-      Set<? extends Element> builderElements) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+  private ImmutableMap<Element, ValidationReport<TypeElement>> processBuilders(
+      Set<? extends Element> builderElements, ImmutableSet.Builder<Element> rejectedElements) {
+    // Can't use an ImmutableMap.Builder here because a component may have (invalidly) more than one
+    // builder type, and that would make ImmutableMap.Builder throw.
+    Map<Element, ValidationReport<TypeElement>> reports = new HashMap<>();
     for (Element element : builderElements) {
-      ValidationReport<TypeElement> report =
-          builderValidator.validate(MoreElements.asType(element));
-      report.printMessagesTo(messager);
-      builderReportsByComponent.put(element.getEnclosingElement(), report);
+      try {
+        ValidationReport<TypeElement> report =
+            builderValidator.validate(MoreElements.asType(element));
+        report.printMessagesTo(messager);
+        reports.put(element.getEnclosingElement(), report);
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(element);
+      }
     }
-    return builderReportsByComponent;
+    return ImmutableMap.copyOf(reports);
   }
 
-  private Map<Element, ValidationReport<TypeElement>> processSubcomponents(
+  private ImmutableMap<Element, ValidationReport<TypeElement>> processSubcomponents(
       Set<? extends Element> subcomponentElements,
-      Set<? extends Element> subcomponentBuilderElements) {
-    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent = Maps.newHashMap();
+      Set<? extends Element> subcomponentBuilderElements,
+      ImmutableSet.Builder<Element> rejectedElements) {
+    ImmutableMap.Builder<Element, ValidationReport<TypeElement>> reports = ImmutableMap.builder();
     for (Element element : subcomponentElements) {
-      ComponentValidationReport report =
-          componentValidator.validate(
-              MoreElements.asType(element), subcomponentElements, subcomponentBuilderElements);
-      report.report().printMessagesTo(messager);
-      reportsBySubcomponent.put(element, report.report());
+      try {
+        ComponentValidationReport report =
+            componentValidator.validate(
+                MoreElements.asType(element), subcomponentElements, subcomponentBuilderElements);
+        report.report().printMessagesTo(messager);
+        reports.put(element, report.report());
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(element);
+      }
     }
-    return reportsBySubcomponent;
+    return reports.build();
   }
 
   /**
    * Returns true if the component's report is clean, its builder report is clean, and all
    * referenced subcomponent reports and subcomponent builder reports are clean.
    */
-  private boolean isClean(
-      ComponentValidationReport report,
-      Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
-      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
-      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+  private boolean isClean(ComponentValidationReport report) {
     Element component = report.report().subject();
     ValidationReport<?> componentReport = report.report();
     if (!componentReport.isClean()) {
@@ -234,7 +228,7 @@ private boolean isClean(
       return false;
     }
     for (Element element : report.referencedSubcomponents()) {
-      if (!subcomponentIsClean(element, reportsBySubcomponent, builderReportsBySubcomponent)) {
+      if (!subcomponentIsClean(element)) {
         return false;
       }
     }
@@ -242,10 +236,7 @@ private boolean isClean(
   }
 
   /** Returns true if the reports associated with the subcomponent are clean. */
-  private boolean subcomponentIsClean(
-      Element subcomponentElement,
-      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
-      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+  private boolean subcomponentIsClean(Element subcomponentElement) {
     ValidationReport<?> subcomponentBuilderReport =
         builderReportsBySubcomponent.get(subcomponentElement);
     if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
diff --git a/java/dagger/internal/codegen/InjectProcessingStep.java b/java/dagger/internal/codegen/InjectProcessingStep.java
index 5ea414ef3..be8c975a1 100644
--- a/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -16,72 +16,61 @@
 
 package dagger.internal.codegen;
 
-import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.ElementKindVisitor6;
+import javax.lang.model.util.ElementKindVisitor8;
 
 /**
  * An annotation processor for generating Dagger implementation code based on the {@link Inject}
  * annotation.
  */
-final class InjectProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
-  private final InjectBindingRegistry injectBindingRegistry;
+// TODO(gak): add some error handling for bad source files
+final class InjectProcessingStep extends TypeCheckingProcessingStep<Element> {
+  private final ElementVisitor<Void, Void> visitor;
 
   @Inject
   InjectProcessingStep(InjectBindingRegistry injectBindingRegistry) {
-    this.injectBindingRegistry = injectBindingRegistry;
+    super(e -> e);
+    this.visitor =
+        new ElementKindVisitor8<Void, Void>() {
+          @Override
+          public Void visitExecutableAsConstructor(
+              ExecutableElement constructorElement, Void aVoid) {
+            injectBindingRegistry.tryRegisterConstructor(constructorElement);
+            return null;
+          }
+
+          @Override
+          public Void visitVariableAsField(VariableElement fieldElement, Void aVoid) {
+            injectBindingRegistry.tryRegisterMembersInjectedType(
+                MoreElements.asType(fieldElement.getEnclosingElement()));
+            return null;
+          }
+
+          @Override
+          public Void visitExecutableAsMethod(ExecutableElement methodElement, Void aVoid) {
+            injectBindingRegistry.tryRegisterMembersInjectedType(
+                MoreElements.asType(methodElement.getEnclosingElement()));
+            return null;
+          }
+        };
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(Inject.class);
+    return ImmutableSet.of(Inject.class);
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-    // TODO(gak): add some error handling for bad source files
-
-    for (Element injectElement : elementsByAnnotation.get(Inject.class)) {
-      try {
-        injectElement.accept(
-            new ElementKindVisitor6<Void, Void>() {
-              @Override
-              public Void visitExecutableAsConstructor(
-                  ExecutableElement constructorElement, Void v) {
-                injectBindingRegistry.tryRegisterConstructor(constructorElement);
-                return null;
-              }
-
-              @Override
-              public Void visitVariableAsField(VariableElement fieldElement, Void p) {
-                injectBindingRegistry.tryRegisterMembersInjectedType(
-                    MoreElements.asType(fieldElement.getEnclosingElement()));
-                return null;
-              }
-
-              @Override
-              public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-                injectBindingRegistry.tryRegisterMembersInjectedType(
-                    MoreElements.asType(methodElement.getEnclosingElement()));
-                return null;
-              }
-            },
-            null);
-      } catch (TypeNotPresentException e) {
-        rejectedElements.add(injectElement);
-      }
-    }
-
-    return rejectedElements.build();
+  protected void process(
+      Element injectElement, ImmutableSet<Class<? extends Annotation>> annotations) {
+    injectElement.accept(visitor, null);
   }
 }
diff --git a/java/dagger/internal/codegen/MapKeyProcessingStep.java b/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 7bf3ab5df..ff541c2e9 100644
--- a/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -18,12 +18,10 @@
 
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
 import static javax.lang.model.element.ElementKind.ANNOTATION_TYPE;
-import static javax.lang.model.util.ElementFilter.typesIn;
 
-import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import dagger.MapKey;
 import java.lang.annotation.Annotation;
 import java.util.Set;
@@ -39,7 +37,7 @@
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
  * implementation of annotations marked with {@link MapKey @MapKey} where necessary.
  */
-public class MapKeyProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+public class MapKeyProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Messager messager;
   private final Types types;
   private final MapKeyValidator mapKeyValidator;
@@ -53,6 +51,7 @@
       MapKeyValidator mapKeyValidator,
       AnnotationCreatorGenerator annotationCreatorGenerator,
       UnwrappedMapKeyGenerator unwrappedMapKeyGenerator) {
+    super(MoreElements::asType);
     this.messager = messager;
     this.types = types;
     this.mapKeyValidator = mapKeyValidator;
@@ -66,22 +65,19 @@
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (TypeElement mapKeyAnnotationType : typesIn(elementsByAnnotation.get(MapKey.class))) {
-      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(mapKeyAnnotationType);
-      mapKeyReport.printMessagesTo(messager);
+  protected void process(
+      TypeElement mapKeyAnnotationType, ImmutableSet<Class<? extends Annotation>> annotations) {
+    ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(mapKeyAnnotationType);
+    mapKeyReport.printMessagesTo(messager);
 
-      if (mapKeyReport.isClean()) {
-        MapKey mapkey = mapKeyAnnotationType.getAnnotation(MapKey.class);
-        if (!mapkey.unwrapValue()) {
-          annotationCreatorGenerator.generate(mapKeyAnnotationType, messager);
-        } else if (unwrappedValueKind(mapKeyAnnotationType).equals(ANNOTATION_TYPE)) {
-          unwrappedMapKeyGenerator.generate(mapKeyAnnotationType, messager);
-        }
+    if (mapKeyReport.isClean()) {
+      MapKey mapkey = mapKeyAnnotationType.getAnnotation(MapKey.class);
+      if (!mapkey.unwrapValue()) {
+        annotationCreatorGenerator.generate(mapKeyAnnotationType, messager);
+      } else if (unwrappedValueKind(mapKeyAnnotationType).equals(ANNOTATION_TYPE)) {
+        unwrappedMapKeyGenerator.generate(mapKeyAnnotationType, messager);
       }
     }
-    return ImmutableSet.of();
   }
 
   private ElementKind unwrappedValueKind(TypeElement mapKeyAnnotationType) {
diff --git a/java/dagger/internal/codegen/ModuleProcessingStep.java b/java/dagger/internal/codegen/ModuleProcessingStep.java
index 63fe008db..1ae025ffc 100644
--- a/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -21,6 +21,7 @@
 import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
@@ -43,7 +44,7 @@
  * A {@link ProcessingStep} that validates module classes and generates factories for binding
  * methods.
  */
-final class ModuleProcessingStep implements ProcessingStep {
+final class ModuleProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Messager messager;
   private final ModuleValidator moduleValidator;
   private final BindingFactory bindingFactory;
@@ -62,6 +63,7 @@
       SourceFileGenerator<ProductionBinding> producerFactoryGenerator,
       InaccessibleMapKeyProxyGenerator inaccessibleMapKeyProxyGenerator,
       Factory delegateDeclarationFactory) {
+    super(MoreElements::asType);
     this.messager = messager;
     this.moduleValidator = moduleValidator;
     this.bindingFactory = bindingFactory;
@@ -77,19 +79,19 @@
   }
 
   @Override
-  public Set<Element> process(
+  public ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     List<TypeElement> modules = typesIn(elementsByAnnotation.values());
     moduleValidator.addKnownModules(modules);
-    for (TypeElement module : modules) {
-      if (processedModuleElements.add(module)) {
-        processModule(module);
-      }
-    }
-    return ImmutableSet.of();
+    return super.process(elementsByAnnotation);
   }
 
-  private void processModule(TypeElement module) {
+  @Override
+  protected void process(
+      TypeElement module, ImmutableSet<Class<? extends Annotation>> annotations) {
+    if (processedModuleElements.contains(module)) {
+      return;
+    }
     ValidationReport<TypeElement> report = moduleValidator.validate(module);
     report.printMessagesTo(messager);
     if (report.isClean()) {
@@ -103,6 +105,7 @@ private void processModule(TypeElement module) {
         }
       }
     }
+    processedModuleElements.add(module);
   }
 
   private <B extends ContributionBinding> void generate(
diff --git a/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java b/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
index e9475895e..55ae57941 100644
--- a/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
+++ b/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
@@ -16,29 +16,28 @@
 
 package dagger.internal.codegen;
 
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
-import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 
 /**
- * A processing step that is responsible for generating a special module for a
- * {@link ProductionComponent} or {@link ProductionSubcomponent}.
+ * A processing step that is responsible for generating a special module for a {@link
+ * ProductionComponent} or {@link ProductionSubcomponent}.
  */
-final class MonitoringModuleProcessingStep implements ProcessingStep {
+final class MonitoringModuleProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Messager messager;
   private final MonitoringModuleGenerator monitoringModuleGenerator;
 
   @Inject
   MonitoringModuleProcessingStep(
       Messager messager, MonitoringModuleGenerator monitoringModuleGenerator) {
+    super(MoreElements::asType);
     this.messager = messager;
     this.monitoringModuleGenerator = monitoringModuleGenerator;
   }
@@ -49,11 +48,8 @@
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (Element element : elementsByAnnotation.values()) {
+  protected void process(
+      TypeElement element, ImmutableSet<Class<? extends Annotation>> annotations) {
       monitoringModuleGenerator.generate(MoreElements.asType(element), messager);
-    }
-    return ImmutableSet.of();
   }
 }
diff --git a/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
index 3afa469d9..053506237 100644
--- a/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
+++ b/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -17,12 +17,10 @@
 package dagger.internal.codegen;
 
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.tools.Diagnostic.Kind.ERROR;
 
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Multimaps;
-import com.google.common.collect.SetMultimap;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
@@ -30,21 +28,21 @@
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.tools.Diagnostic.Kind;
 
 /**
  * Processing step that verifies that {@link IntoSet}, {@link ElementsIntoSet} and {@link IntoMap}
  * are not present on non-binding methods.
  */
-final class MultibindingAnnotationsProcessingStep implements ProcessingStep {
+final class MultibindingAnnotationsProcessingStep
+    extends TypeCheckingProcessingStep<ExecutableElement> {
   private final AnyBindingMethodValidator anyBindingMethodValidator;
   private final Messager messager;
 
   @Inject
   MultibindingAnnotationsProcessingStep(
       AnyBindingMethodValidator anyBindingMethodValidator, Messager messager) {
+    super(MoreElements::asExecutable);
     this.anyBindingMethodValidator = anyBindingMethodValidator;
     this.messager = messager;
   }
@@ -55,22 +53,16 @@
   }
 
   @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    Multimaps.asMap(elementsByAnnotation)
-        .forEach(
-            (annotation, elements) -> {
-              for (ExecutableElement method : methodsIn(elements)) {
-                if (!anyBindingMethodValidator.isBindingMethod(method)) {
-                  messager.printMessage(
-                      Kind.ERROR,
-                      "Multibinding annotations may only be on "
-                          + "@Provides, @Produces, or @Binds methods",
-                      method,
-                      getAnnotationMirror(method, annotation).get());
-                }
-              }
-            });
-    return ImmutableSet.of();
+  protected void process(
+      ExecutableElement method, ImmutableSet<Class<? extends Annotation>> annotations) {
+    if (!anyBindingMethodValidator.isBindingMethod(method)) {
+      annotations.forEach(
+          annotation ->
+              messager.printMessage(
+                  ERROR,
+                  "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods",
+                  method,
+                  getAnnotationMirror(method, annotation).get()));
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/TypeCheckingProcessingStep.java b/java/dagger/internal/codegen/TypeCheckingProcessingStep.java
new file mode 100644
index 000000000..00769b228
--- /dev/null
+++ b/java/dagger/internal/codegen/TypeCheckingProcessingStep.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.SetMultimap;
+import java.lang.annotation.Annotation;
+import java.util.function.Function;
+import javax.lang.model.element.Element;
+
+/**
+ * A {@link ProcessingStep} that processes one element at a time and defers any for which {@link
+ * TypeNotPresentException} is thrown.
+ */
+// TODO(dpb): Contribute to auto-common.
+abstract class TypeCheckingProcessingStep<E extends Element> implements ProcessingStep {
+  private final Function<Element, E> downcaster;
+
+  TypeCheckingProcessingStep(Function<Element, E> downcaster) {
+    this.downcaster = checkNotNull(downcaster);
+  }
+
+  @Override
+  public ImmutableSet<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> deferredElements = ImmutableSet.builder();
+    ImmutableSetMultimap.copyOf(elementsByAnnotation)
+        .inverse()
+        .asMap()
+        .forEach(
+            (element, annotations) -> {
+              try {
+                process(downcaster.apply(element), ImmutableSet.copyOf(annotations));
+              } catch (TypeNotPresentException e) {
+                deferredElements.add(element);
+              }
+            });
+    return deferredElements.build();
+  }
+
+  /**
+   * Processes one element. If this method throws {@link TypeNotPresentException}, the element will
+   * be deferred until the next round of processing.
+   *
+   * @param annotations the subset of {@link ProcessingStep#annotations()} that annotate {@code
+   *     element}
+   */
+  protected abstract void process(E element, ImmutableSet<Class<? extends Annotation>> annotations);
+}
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 4005e463c..9dc9141ce 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -27,22 +27,17 @@
 import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.MembersInjector;
-import java.io.IOException;
-import java.io.Writer;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.ProcessingEnvironment;
-import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.inject.Inject;
 import javax.lang.model.SourceVersion;
@@ -2580,37 +2575,4 @@ public boolean errorRaised() {
           });
     }
   }
-
-  /**
-   * A simple {@link Processor} that generates one source file.
-   */
-  private static final class GeneratingProcessor extends AbstractProcessor {
-    private final String generatedClassName;
-    private final String generatedSource;
-    private boolean processed;
-
-    GeneratingProcessor(String generatedClassName, String... source) {
-      this.generatedClassName = generatedClassName;
-      this.generatedSource = Joiner.on("\n").join(source);
-    }
-
-    @Override
-    public Set<String> getSupportedAnnotationTypes() {
-      return ImmutableSet.of("*");
-    }
-
-    @Override
-    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-      if (!processed) {
-        processed = true;
-        try (Writer writer =
-                processingEnv.getFiler().createSourceFile(generatedClassName).openWriter()) {
-          writer.append(generatedSource);
-        } catch (IOException e) {
-          throw new RuntimeException(e);
-        }
-      }
-      return false;
-    }
-  }
 }
diff --git a/javatests/dagger/internal/codegen/GeneratingProcessor.java b/javatests/dagger/internal/codegen/GeneratingProcessor.java
new file mode 100644
index 000000000..8e4e7b55b
--- /dev/null
+++ b/javatests/dagger/internal/codegen/GeneratingProcessor.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableSet;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.TypeElement;
+
+/** A simple {@link Processor} that generates one source file. */
+final class GeneratingProcessor extends AbstractProcessor {
+  private final String generatedClassName;
+  private final String generatedSource;
+  private boolean processed;
+
+  GeneratingProcessor(String generatedClassName, String... source) {
+    this.generatedClassName = generatedClassName;
+    this.generatedSource = Joiner.on("\n").join(source);
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    return ImmutableSet.of("*");
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    if (!processed) {
+      processed = true;
+      try (Writer writer =
+          processingEnv.getFiler().createSourceFile(generatedClassName).openWriter()) {
+        writer.append(generatedSource);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    }
+    return false;
+  }
+}
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 212e62aae..79ed0b6c6 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -1114,4 +1114,57 @@ public void duplicateBindingWithSubcomponentDeclaration() {
     assertThat(compilation)
         .hadErrorContaining("@Module(subcomponents = test.Sub.class) for test.TestModule");
   }
+
+  @Test
+  public void subcomponentDependsOnGeneratedType() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child.Builder childBuilder();",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child extends ChildSupertype {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+
+    JavaFileObject childSupertype =
+        JavaFileObjects.forSourceLines(
+            "test.ChildSupertype",
+            "package test;",
+            "",
+            "interface ChildSupertype {",
+            "  GeneratedType generatedType();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler(
+                new GeneratingProcessor(
+                    "test.GeneratedType",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "final class GeneratedType {",
+                    "  @Inject GeneratedType() {}",
+                    "}"))
+            .compile(parent, child, childSupertype);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
 }
