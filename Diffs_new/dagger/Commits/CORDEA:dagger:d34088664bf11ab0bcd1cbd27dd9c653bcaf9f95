diff --git a/java/dagger/BindsInstance.java b/java/dagger/BindsInstance.java
index cd87db8a8..eab879600 100644
--- a/java/dagger/BindsInstance.java
+++ b/java/dagger/BindsInstance.java
@@ -17,6 +17,7 @@
 package dagger;
 
 import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import dagger.internal.Beta;
@@ -25,8 +26,9 @@
 import java.lang.annotation.Target;
 
 /**
- * Marks a method on a component builder or subcomponent builder that allows an instance to be bound
- * to some type within the component.
+ * Marks a method on a {@linkplain Component.Builder component builder} or a parameter on a
+ * {@linkplain Component.Factory component factory} as binding an instance to some key within the
+ * component.
  *
  * <p>For example:
  *
@@ -37,19 +39,28 @@
  *     {@literal @BindsInstance} Builder bar({@literal @Blue} Bar bar);
  *     ...
  *   }
+ *
+ *   // or
+ *
+ *   {@literal @Component.Factory}
+ *   interface Factory {
+ *     MyComponent newMyComponent(
+ *         {@literal @BindsInstance} Foo foo,
+ *         {@literal @BindsInstance @Blue} Bar bar);
+ *   }
  * </pre>
  *
- * <p>will allow clients of this builder to pass their own instances of {@code Foo} and {@code Bar},
- * and those instances can be injected within the component as {@code Foo} or {@code @Blue Bar},
- * respectively.
+ * <p>will allow clients of the builder or factory to pass their own instances of {@code Foo} and
+ * {@code Bar}, and those instances can be injected within the component as {@code Foo} or
+ * {@code @Blue Bar}, respectively.
  *
- * <p>{@code @BindsInstance} methods may not be passed null arguments unless the parameter is
- * annotated with {@code @Nullable}; in that case, both null and non-null arguments may be passed to
- * the method.
+ * <p>{@code @BindsInstance} arguments may not be {@code null} unless the parameter is annotated
+ * with {@code @Nullable}.
  *
- * <p>{@code @BindsInstance} methods must be called before building the component, unless their
- * parameter is marked {@code @Nullable}, in which case the component will act as though it was
- * called with a null argument. Primitives, of course, may not be marked {@code @Nullable}.
+ * <p>For builders, {@code @BindsInstance} methods must be called before building the component,
+ * unless their parameter is marked {@code @Nullable}, in which case the component will act as
+ * though it was called with a {@code null} argument. Primitives, of course, may not be marked
+ * {@code @Nullable}.
  *
  * <p>Binding an instance is equivalent to passing an instance to a module constructor and providing
  * that instance, but is often more efficient. When possible, binding object instances should be
@@ -57,6 +68,6 @@
  */
 @Documented
 @Retention(RUNTIME)
-@Target(METHOD)
+@Target({METHOD, PARAMETER})
 @Beta
 public @interface BindsInstance {}
diff --git a/java/dagger/Component.java b/java/dagger/Component.java
index abf24b96f..0fd498156 100644
--- a/java/dagger/Component.java
+++ b/java/dagger/Component.java
@@ -45,20 +45,24 @@
  * <a name="provision-methods"></a>
  * <h3>Provision methods</h3>
  *
- * <p>Provision methods have no parameters and return an {@link Inject injected} or
- * {@link Provides provided} type. Each method may have a {@link Qualifier} annotation as well. The
- * following are all valid provision method declarations: <pre><code>
+ * <p>Provision methods have no parameters and return an {@link Inject injected} or {@link Provides
+ * provided} type. Each method may have a {@link Qualifier} annotation as well. The following are
+ * all valid provision method declarations:
+ *
+ * <pre><code>
  *   SomeType getSomeType();
  *   {@literal Set<SomeType>} getSomeTypes();
  *   {@literal @PortNumber} int getPortNumber();
  * </code></pre>
  *
  * <p>Provision methods, like typical {@link Inject injection} sites, may use {@link Provider} or
- * {@link Lazy} to more explicitly control provision requests. A {@link Provider} allows the user
- * of the component to request provision any number of times by calling {@link Provider#get}. A
- * {@link Lazy} will only ever request a single provision, but will defer it until the first call to
- * {@link Lazy#get}. The following provision methods all request provision of the same type, but
- * each implies different semantics: <pre><code>
+ * {@link Lazy} to more explicitly control provision requests. A {@link Provider} allows the user of
+ * the component to request provision any number of times by calling {@link Provider#get}. A {@link
+ * Lazy} will only ever request a single provision, but will defer it until the first call to {@link
+ * Lazy#get}. The following provision methods all request provision of the same type, but each
+ * implies different semantics:
+ *
+ * <pre><code>
  *   SomeType getSomeType();
  *   {@literal Provider<SomeType>} getSomeTypeProvider();
  *   {@literal Lazy<SomeType>} getLazySomeType();
@@ -70,24 +74,30 @@
  * <p>Members-injection methods have a single parameter and inject dependencies into each of the
  * {@link Inject}-annotated fields and methods of the passed instance. A members-injection method
  * may be void or return its single parameter as a convenience for chaining. The following are all
- * valid members-injection method declarations: <pre><code>
+ * valid members-injection method declarations:
+ *
+ * <pre><code>
  *   void injectSomeType(SomeType someType);
  *   SomeType injectAndReturnSomeType(SomeType someType);
  * </code></pre>
  *
  * <p>A method with no parameters that returns a {@link MembersInjector} is equivalent to a members
  * injection method. Calling {@link MembersInjector#injectMembers} on the returned object will
- * perform the same work as a members injection method. For example: <pre><code>
+ * perform the same work as a members injection method. For example:
+ *
+ * <pre><code>
  *   {@literal MembersInjector<SomeType>} getSomeTypeMembersInjector();
  * </code></pre>
  *
  * <h4>A note about covariance</h4>
  *
- * <p>While a members-injection method for a type will accept instances of its subtypes, only
- * {@link Inject}-annotated members of the parameter type and its supertypes will be injected;
- * members of subtypes will not. For example, given the following types, only {@code a} and
- * {@code b} will be injected into an instance of {@code Child} when it is passed to the
- * members-injection method {@code injectSelf(Self instance)}: <pre><code>
+ * <p>While a members-injection method for a type will accept instances of its subtypes, only {@link
+ * Inject}-annotated members of the parameter type and its supertypes will be injected; members of
+ * subtypes will not. For example, given the following types, only {@code a} and {@code b} will be
+ * injected into an instance of {@code Child} when it is passed to the members-injection method
+ * {@code injectSelf(Self instance)}:
+ *
+ * <pre><code>
  *   class Parent {
  *     {@literal @}Inject A a;
  *   }
@@ -104,18 +114,23 @@
  * <a name="instantiation"></a>
  * <h2>Instantiation</h2>
  *
- * <p>Component implementations are primarily instantiated via a generated
- * <a href="http://en.wikipedia.org/wiki/Builder_pattern">builder</a>. An instance of the builder
- * is obtained using the {@code builder()} method on the component implementation.
- * If a nested {@code @Component.Builder} type exists in the component, the {@code builder()}
- * method will return a generated implementation of that type.  If no nested
- * {@code @Component.Builder} exists, the returned builder has a method to set each of the
- * {@linkplain #modules} and component {@linkplain #dependencies} named with the
- * <a href="http://en.wikipedia.org/wiki/CamelCase">lower camel case</a> version of the module
- * or dependency type. Each component dependency and module without a visible default constructor
- * must be set explicitly, but any module with a default or no-args constructor accessible to the
- * component implementation may be elided. This is an example usage of a component builder:
- * <pre><code>
+ * <p>Component implementations are primarily instantiated via a generated <a
+ * href="http://en.wikipedia.org/wiki/Builder_pattern">builder</a> or <a
+ * href="https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)">factory</a>.
+ *
+ * <p>If a nested {@link Builder @Component.Builder} or {@link Factory @Component.Factory} type
+ * exists in the component, Dagger will generate an implementation of that type. If neither exists,
+ * Dagger will generate a builder type that has a method to set each of the {@linkplain #modules}
+ * and component {@linkplain #dependencies} named with the <a
+ * href="http://en.wikipedia.org/wiki/CamelCase">lower camel case</a> version of the module or
+ * dependency type.
+ *
+ * <p>In either case, the Dagger-generated component type will have a static method, named either
+ * {@code builder()} or {@code factory()}, that returns a builder or factory instance.
+ *
+ * <p>Example of using a builder:
+ *
+ * <pre>{@code
  *   public static void main(String[] args) {
  *     OtherComponent otherComponent = ...;
  *     MyComponent component = DaggerMyComponent.builder()
@@ -127,21 +142,35 @@
  *         .myApplicationModule(new MyApplicationModule())
  *         .build();
  *   }
- * </code></pre>
+ * }</pre>
+ *
+ * <p>Example of using a factory:
+ *
+ * <pre>{@code
+ * public static void main(String[] args) {
+ *     OtherComponent otherComponent = ...;
+ *     MyComponent component = DaggerMyComponent.factory()
+ *         .create(otherComponent, new FlagsModule(args), new MyApplicationModule());
+ *     // Note that all parameters to a factory method are required, even if one is for a module
+ *     // that Dagger could instantiate. The only case where null is legal is for a
+ *     // @BindsInstance @Nullable parameter.
+ *   }
+ * }</pre>
  *
  * <p>In the case that a component has no component dependencies and only no-arg modules, the
- * generated component will also have a factory method {@code create()}.
- * {@code SomeComponent.create()} and {@code SomeComponent.builder().build()} are both valid and
+ * generated component will also have a factory method {@code create()}. {@code
+ * SomeComponent.create()} and {@code SomeComponent.builder().build()} are both valid and
  * equivalent.
  *
  * <a name="scope"></a>
  * <h2>Scope</h2>
  *
- * <p>Each Dagger component can be associated with a scope by annotating it with the
- * {@linkplain Scope scope annotation}. The component implementation ensures that there is only one
- * provision of each scoped binding per instance of the component. If the component declares a
- * scope, it may only contain unscoped bindings or bindings of that scope anywhere in the graph. For
- * example: <pre><code>
+ * <p>Each Dagger component can be associated with a scope by annotating it with the {@linkplain
+ * Scope scope annotation}. The component implementation ensures that there is only one provision of
+ * each scoped binding per instance of the component. If the component declares a scope, it may only
+ * contain unscoped bindings or bindings of that scope anywhere in the graph. For example:
+ *
+ * <pre><code>
  *   {@literal @}Singleton {@literal @}Component
  *   interface MyApplicationComponent {
  *     // this component can only inject types using unscoped or {@literal @}Singleton bindings
@@ -150,8 +179,8 @@
  *
  * <p>In order to get the proper behavior associated with a scope annotation, it is the caller's
  * responsibility to instantiate new component instances when appropriate. A {@link Singleton}
- * component, for instance, should only be instantiated once per application, while a
- * {@code RequestScoped} component should be instantiated once per request. Because components are
+ * component, for instance, should only be instantiated once per application, while a {@code
+ * RequestScoped} component should be instantiated once per request. Because components are
  * self-contained implementations, exiting a scope is as simple as dropping all references to the
  * component instance.
  *
@@ -166,20 +195,22 @@
  * <h3>Subcomponents</h3>
  *
  * <p>The simplest way to relate two components is by declaring a {@link Subcomponent}. A
- * subcomponent behaves exactly like a component, but has its implementation generated within
- * a parent component or subcomponent. That relationship allows the subcomponent implementation to
- * inherit the <em>entire</em> binding graph from its parent when it is declared. For that reason,
- * a subcomponent isn't evaluated for completeness until it is associated with a parent.
+ * subcomponent behaves exactly like a component, but has its implementation generated within a
+ * parent component or subcomponent. That relationship allows the subcomponent implementation to
+ * inherit the <em>entire</em> binding graph from its parent when it is declared. For that reason, a
+ * subcomponent isn't evaluated for completeness until it is associated with a parent.
  *
  * <p>Subcomponents are declared by listing the class in the {@link Module#subcomponents()}
  * attribute of one of the parent component's modules. This binds the {@link Subcomponent.Builder}
- * within the parent component.
+ * or {@link Subcomponent.Factory} for that subcomponent within the parent component.
  *
  * <p>Subcomponents may also be declared via a factory method on a parent component or subcomponent.
  * The method may have any name, but must return the subcomponent. The factory method's parameters
  * may be any number of the subcomponent's modules, but must at least include those without visible
  * no-arg constructors. The following is an example of a factory method that creates a
- * request-scoped subcomponent from a singleton-scoped parent: <pre><code>
+ * request-scoped subcomponent from a singleton-scoped parent:
+ *
+ * <pre><code>
  *   {@literal @}Singleton {@literal @}Component
  *   interface ApplicationComponent {
  *     // component methods...
@@ -193,11 +224,11 @@
  *
  * <p>While subcomponents are the simplest way to compose subgraphs of bindings, subcomponents are
  * tightly coupled with the parents; they may use any binding defined by their ancestor component
- * and subcomponents. As an alternative, components can use bindings only from another
- * <em>component interface</em> by declaring a {@linkplain #dependencies component dependency}. When
- * a type is used as a component dependency, each <a href="#provision-methods">provision method</a>
- * on the dependency is bound as a provider. Note that <em>only</em> the bindings exposed as
- * provision methods are available through component dependencies.
+ * and subcomponents. As an alternative, components can use bindings only from another <em>component
+ * interface</em> by declaring a {@linkplain #dependencies component dependency}. When a type is
+ * used as a component dependency, each <a href="#provision-methods">provision method</a> on the
+ * dependency is bound as a provider. Note that <em>only</em> the bindings exposed as provision
+ * methods are available through component dependencies.
  *
  * @since 2.0
  */
@@ -219,36 +250,112 @@
   Class<?>[] dependencies() default {};
 
   /**
-   * A builder for a component. Components may have a single nested static abstract class or
-   * interface annotated with {@code @Component.Builder}.  If they do, then the component's
-   * generated builder will match the API in the type.  Builders must follow some rules:
+   * A builder for a component.
+   *
+   * <p>A builder is a type with setter methods for the {@linkplain Component#modules modules},
+   * {@linkplain Component#dependencies dependencies} and {@linkplain BindsInstance bound instances}
+   * required by the component and a single no-argument build method that creates a new component
+   * instance.
+   *
+   * <p>Components may have a single nested {@code static abstract class} or {@code interface}
+   * annotated with {@code @Component.Builder}. If they do, then Dagger will generate a builder
+   * class that implements that type. Note that a component with a {@code @Component.Builder} may
+   * not also have a {@code @Component.Factory}.
+   *
+   * <p>Builder types must follow some rules:
+   *
    * <ul>
-   * <li> A single abstract method with no arguments must exist, and must return the component.
-   *      (This is typically the {@code build()} method.)
-   * <li> All other abstract methods must take a single argument and must return void,
-   *      the Builder type, or a supertype of the builder.
-   * <li> Each component dependency <b>must</b> have an abstract setter method.
-   * <li> Each module dependency that Dagger can't instantiate itself (e.g, the module
-   *      doesn't have a visible no-args constructor) <b>must</b> have an abstract setter method.
-   *      Other module dependencies (ones that Dagger can instantiate) are allowed, but not required.
-   * <li> Non-abstract methods are allowed, but ignored as far as validation and builder generation
-   *      are concerned.
+   *   <li>There <i>must</i> be exactly one abstract no-argument method that returns the component
+   *       type or one of its supertypes, called the "build method".
+   *   <li>There <i>may</i> be other other abstract methods, called "setter methods".
+   *   <li>Setter methods <i>must</i> take a single argument and return {@code void}, the builder
+   *       type or a supertype of the builder type.
+   *   <li>There <i>must</i> be a setter method for each {@linkplain Component#dependencies
+   *       component dependency}.
+   *   <li>There <i>must</i> be a setter method for each non-{@code abstract} {@linkplain
+   *       Component#modules module} that has non-{@code static} binding methods, unless Dagger can
+   *       instantiate that module with a visible no-argument constructor.
+   *   <li>There <i>may</i> be setter methods for modules that Dagger can instantiate or does not
+   *       need to instantiate.
+   *   <li>There <i>may</i> be setter methods annotated with {@code @BindsInstance}. These methods
+   *       bind the instance passed to them within the component. See {@link
+   *       BindsInstance @BindsInstance} for more information.
+   *   <li>There <i>may</i> be non-{@code abstract} methods, but they are ignored as far as
+   *       validation and builder generation are concerned.
    * </ul>
-   * 
-   * For example, this could be a valid Component with a Builder: <pre><code>
+   *
+   * For example, this could be a valid {@code Component} with a {@code Builder}:
+   *
+   * <pre><code>
    * {@literal @}Component(modules = {BackendModule.class, FrontendModule.class})
    * interface MyComponent {
    *   MyWidget myWidget();
-   *   
+   *
    *   {@literal @}Component.Builder
    *   interface Builder {
-   *     MyComponent build();
    *     Builder backendModule(BackendModule bm);
    *     Builder frontendModule(FrontendModule fm);
+   *     {@literal @}BindsInstance
+   *     Builder foo(Foo foo);
+   *     MyComponent build();
    *   }
    * }</code></pre>
    */
   @Target(TYPE)
   @Documented
   @interface Builder {}
+
+  /**
+   * A factory for a component.
+   *
+   * <p>A factory is a type with a single method that returns a new component instance each time it
+   * is called. The parameters of that method allow the caller to provide the {@linkplain
+   * Component#modules modules}, {@linkplain Component#dependencies dependencies} and {@linkplain
+   * BindsInstance bound instances} required by the component.
+   *
+   * <p>Components may have a single nested {@code static abstract class} or {@code interface}
+   * annotated with {@code @Component.Factory}. If they do, then Dagger will generate a factory
+   * class that will implement that type. Note that a component with a {@code @Component.Factory}
+   * may not also have a {@code @Component.Builder}.
+   *
+   * <p>Factory types must follow some rules:
+   *
+   * <ul>
+   *   <li>There <i>must</i> be exactly one abstract method, which must return the component type or
+   *       one of its supertypes.
+   *   <li>The method <i>must</i> have a parameter for each {@linkplain Component#dependencies
+   *       component dependency}.
+   *   <li>The method <i>must</i> have a parameter for each non-{@code abstract} {@linkplain
+   *       Component#modules module} that has non-{@code static} binding methods, unless Dagger can
+   *       instantiate that module with a visible no-argument constructor.
+   *   <li>The method <i>may</i> have parameters for modules that Dagger can instantiate or does not
+   *       need to instantiate.
+   *   <li>The method <i>may</i> have parameters annotated with {@code @BindsInstance}. These
+   *       parameters bind the instance passed for that parameter within the component. See {@link
+   *       BindsInstance @BindsInstance} for more information.
+   *   <li>There <i>may</i> be non-{@code abstract} methods, but they are ignored as far as
+   *       validation and factory generation are concerned.
+   * </ul>
+   *
+   * For example, this could be a valid {@code Component} with a {@code Factory}:
+   *
+   * <pre><code>
+   * {@literal @}Component(modules = {BackendModule.class, FrontendModule.class})
+   * interface MyComponent {
+   *   MyWidget myWidget();
+   *
+   *   {@literal @}Component.Factory
+   *   interface Factory {
+   *     MyComponent newMyComponent(
+   *         BackendModule bm, FrontendModule fm, {@literal @}BindsInstance Foo foo);
+   *   }
+   * }</code></pre>
+   *
+   * <p>For a root component, if a {@code @Component.Factory} is defined, the generated component
+   * type will have a {@code static} method named {@code factory()} that returns an instance of that
+   * factory.
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Factory {}
 }
diff --git a/java/dagger/Subcomponent.java b/java/dagger/Subcomponent.java
index 3b3921bcb..7223ab84a 100644
--- a/java/dagger/Subcomponent.java
+++ b/java/dagger/Subcomponent.java
@@ -41,14 +41,32 @@
    * here.
    */
   Class<?>[] modules() default {};
-  
+
   /**
-   * A builder for a subcomponent.  This follows all the rules of {@link Component.Builder}, except
-   * it must appear in classes annotated with {@link Subcomponent} instead of {@code Component}.
-   * Components can have methods that return a {@link Subcomponent.Builder}-annotated type,
-   * allowing the user to set modules on the subcomponent using their defined API.
+   * A builder for a subcomponent.
+   *
+   * <p>This follows all the rules of {@link Component.Builder}, except it must appear in classes
+   * annotated with {@link Subcomponent} instead of {@code Component}.
+   *
+   * <p>If a subcomponent defines a builder, its parent component(s) will have a binding for that
+   * builder type, allowing an instance or {@code Provider} of that builder to be injected or
+   * returned from a method on that component like any other binding.
    */
   @Target(TYPE)
   @Documented
   @interface Builder {}
+
+  /**
+   * A factory for a subcomponent.
+   *
+   * <p>This follows all the rules of {@link Component.Factory}, except it must appear in classes
+   * annotated with {@link Subcomponent} instead of {@code Component}.
+   *
+   * <p>If a subcomponent defines a factory, its parent component(s) will have a binding for that
+   * factory type, allowing an instance of that factory to be injected or returned from a method on
+   * that component like any other binding.
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Factory {}
 }
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 29c05a9ad..a48b1cdef 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -137,7 +137,9 @@ java_library(
         "BindingType.java",
         "BindsTypeChecker.java",
         "ChildFactoryMethodEdgeImpl.java",
+        "ComponentCreatorAnnotation.java",
         "ComponentCreatorDescriptor.java",
+        "ComponentCreatorKind.java",
         "ComponentDescriptor.java",
         "ComponentDescriptorFactory.java",
         "ComponentKind.java",
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 208db35ad..4e1d9933a 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -321,17 +321,19 @@ ContributionBinding componentDependencyMethodBinding(
 
   /**
    * Returns a {@link dagger.model.BindingKind#BOUND_INSTANCE} binding for a
-   * {@code @BindsInstance}-annotated builder method.
+   * {@code @BindsInstance}-annotated builder setter method or factory method parameter.
    */
-  ProvisionBinding boundInstanceBinding(
-      ComponentRequirement requirement, ExecutableElement method) {
-    checkArgument(method.getKind().equals(METHOD));
-    checkArgument(method.getParameters().size() == 1);
+  ProvisionBinding boundInstanceBinding(ComponentRequirement requirement, Element element) {
+    checkArgument(element instanceof VariableElement || element instanceof ExecutableElement);
+    VariableElement parameterElement =
+        element instanceof VariableElement
+            ? MoreElements.asVariable(element)
+            : getOnlyElement(MoreElements.asExecutable(element).getParameters());
     return ProvisionBinding.builder()
         .contributionType(ContributionType.UNIQUE)
-        .bindingElement(method)
+        .bindingElement(element)
         .key(requirement.key().get())
-        .nullableType(getNullableType(getOnlyElement(method.getParameters())))
+        .nullableType(getNullableType(parameterElement))
         .kind(BOUND_INSTANCE)
         .build();
   }
diff --git a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index 7441e448a..5ff1d14c5 100644
--- a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -20,7 +20,10 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentOrSubcomponentAnnotation;
 import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
+import static javax.lang.model.element.ElementKind.METHOD;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.TYPEVAR;
 
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
@@ -29,20 +32,22 @@
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
 
 /**
  * Processing step that validates that the {@code BindsInstance} annotation is applied to the
  * correct elements.
  */
-final class BindsInstanceProcessingStep extends TypeCheckingProcessingStep<ExecutableElement> {
+final class BindsInstanceProcessingStep extends TypeCheckingProcessingStep<Element> {
   private final Messager messager;
 
   @Inject
   BindsInstanceProcessingStep(Messager messager) {
-    super(MoreElements::asExecutable);
+    super(element -> element);
     this.messager = messager;
   }
 
@@ -52,9 +57,29 @@
   }
 
   @Override
-  protected void process(
-      ExecutableElement method, ImmutableSet<Class<? extends Annotation>> annotations) {
-    ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
+  protected void process(Element element, ImmutableSet<Class<? extends Annotation>> annotations) {
+    ValidationReport.Builder<Element> report = ValidationReport.about(element);
+
+    switch (element.getKind()) {
+      case METHOD:
+        ExecutableElement method = MoreElements.asExecutable(element);
+        validateBindsInstanceMethod(method, report);
+        break;
+      case PARAMETER:
+        VariableElement parameter = MoreElements.asVariable(element);
+        validateBindsInstanceParameterType(parameter, report);
+        validateBindsInstanceParameterEnclosingMethod(parameter, report);
+        break;
+      default:
+        // Shouldn't be possible given the target elements @BindsInstance allows.
+        throw new AssertionError();
+    }
+
+    report.build().printMessagesTo(messager);
+  }
+
+  private void validateBindsInstanceMethod(
+      ExecutableElement method, ValidationReport.Builder<Element> report) {
     if (!method.getModifiers().contains(ABSTRACT)) {
       report.addError("@BindsInstance methods must be abstract");
     }
@@ -62,10 +87,7 @@ protected void process(
       report.addError(
           "@BindsInstance methods should have exactly one parameter for the bound type");
     } else {
-      VariableElement parameter = getOnlyElement(method.getParameters());
-      if (FrameworkTypes.isFrameworkType(parameter.asType())) {
-        report.addError("@BindsInstance parameters may not be framework types", parameter);
-      }
+      validateBindsInstanceParameterType(getOnlyElement(method.getParameters()), report);
     }
     TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
     moduleAnnotation(enclosingType)
@@ -78,7 +100,6 @@ protected void process(
                         "@BindsInstance methods should not be included in @%1$ss. "
                             + "Did you mean to put it in a @%1$s.Builder?",
                         simpleName(componentAnnotation))));
-    report.build().printMessagesTo(messager);
   }
 
   private static String didYouMeanBinds(ModuleAnnotation moduleAnnotation) {
@@ -86,4 +107,33 @@ private static String didYouMeanBinds(ModuleAnnotation moduleAnnotation) {
         "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?",
         moduleAnnotation.annotationClass().getSimpleName());
   }
+
+  private void validateBindsInstanceParameterType(
+      VariableElement parameter, ValidationReport.Builder<Element> report) {
+    if (FrameworkTypes.isFrameworkType(parameter.asType())) {
+      report.addError("@BindsInstance parameters may not be framework types", parameter);
+    }
+  }
+
+  private void validateBindsInstanceParameterEnclosingMethod(
+      VariableElement parameter, ValidationReport.Builder<Element> report) {
+    Element enclosing = parameter.getEnclosingElement();
+    if (!enclosing.getKind().equals(METHOD)) {
+      report.addError(
+          "@BindsInstance should only be applied to methods or parameters of methods");
+      return;
+    }
+
+    ExecutableElement method = MoreElements.asExecutable(enclosing);
+    if (!method.getModifiers().contains(ABSTRACT)) {
+      report.addError("@BindsInstance parameters may only be used in abstract methods");
+    }
+
+    TypeKind returnKind = method.getReturnType().getKind();
+    if (!(returnKind.equals(DECLARED) || returnKind.equals(TYPEVAR))) {
+      report.addError(
+          "@BindsInstance parameters may not be used in methods with a void, array or "
+              + "primitive return type");
+    }
+  }
 }
diff --git a/java/dagger/internal/codegen/ComponentCreatorAnnotation.java b/java/dagger/internal/codegen/ComponentCreatorAnnotation.java
new file mode 100644
index 000000000..56b850036
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentCreatorAnnotation.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
+import static dagger.internal.codegen.ComponentCreatorKind.FACTORY;
+import static dagger.internal.codegen.ComponentKind.COMPONENT;
+import static dagger.internal.codegen.ComponentKind.PRODUCTION_COMPONENT;
+import static dagger.internal.codegen.ComponentKind.PRODUCTION_SUBCOMPONENT;
+import static dagger.internal.codegen.ComponentKind.SUBCOMPONENT;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import dagger.Component;
+import dagger.Subcomponent;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Simple representation of an annotation for a component creator type. Each annotation is for a
+ * specific component kind and creator kind.
+ */
+@AutoValue
+abstract class ComponentCreatorAnnotation {
+
+  private static final ImmutableMap<Class<? extends Annotation>, ComponentCreatorAnnotation>
+      ANNOTATIONS =
+          Maps.uniqueIndex(
+              ImmutableList.of(
+                  create(Component.Builder.class, COMPONENT, BUILDER),
+                  create(Component.Factory.class, COMPONENT, FACTORY),
+                  create(Subcomponent.Builder.class, SUBCOMPONENT, BUILDER),
+                  create(Subcomponent.Factory.class, SUBCOMPONENT, FACTORY),
+                  create(ProductionComponent.Builder.class, PRODUCTION_COMPONENT, BUILDER),
+                  create(ProductionComponent.Factory.class, PRODUCTION_COMPONENT, FACTORY),
+                  create(ProductionSubcomponent.Builder.class, PRODUCTION_SUBCOMPONENT, BUILDER),
+                  create(ProductionSubcomponent.Factory.class, PRODUCTION_SUBCOMPONENT, FACTORY)),
+              ComponentCreatorAnnotation::annotation);
+
+  /** Returns the set of all component creator annotations. */
+  static ImmutableSet<Class<? extends Annotation>> allAnnotations() {
+    return ANNOTATIONS.keySet();
+  }
+
+  /** Returns all creator annotations for the given {@code componentKind}. */
+  static ImmutableSet<Class<? extends Annotation>> creatorAnnotationsFor(
+      ComponentKind componentKind) {
+    return creatorAnnotationsFor(ImmutableSet.of(componentKind));
+  }
+
+  /** Returns all creator annotations for any of the given {@code componentKinds}. */
+  static ImmutableSet<Class<? extends Annotation>> creatorAnnotationsFor(
+      Set<ComponentKind> componentKinds) {
+    return ANNOTATIONS.values().stream()
+        .filter(annotation -> componentKinds.contains(annotation.componentKind()))
+        .map(ComponentCreatorAnnotation::annotation)
+        .collect(toImmutableSet());
+  }
+
+  /** Returns all creator annotations present on the given {@code type}. */
+  static ImmutableSet<ComponentCreatorAnnotation> getCreatorAnnotations(TypeElement type) {
+    return ImmutableSet.copyOf(
+        Maps.filterKeys(ANNOTATIONS, annotation -> isAnnotationPresent(type, annotation)).values());
+  }
+
+  /** The actual annotation. */
+  abstract Class<? extends Annotation> annotation();
+
+  /** The component kind the annotation is associated with. */
+  abstract ComponentKind componentKind();
+
+  /** The creator kind the annotation is associated with. */
+  abstract ComponentCreatorKind creatorKind();
+
+  @Override
+  public final String toString() {
+    return annotation().getName();
+  }
+
+  private static ComponentCreatorAnnotation create(
+      Class<? extends Annotation> annotation,
+      ComponentKind componentKind,
+      ComponentCreatorKind componentCreatorKind) {
+    return new AutoValue_ComponentCreatorAnnotation(
+        annotation, componentKind, componentCreatorKind);
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
index 37d6b8e4a..6e3d6a459 100644
--- a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
@@ -20,15 +20,22 @@
 import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ComponentCreatorAnnotation.getCreatorAnnotations;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
 import dagger.BindsInstance;
 import dagger.model.DependencyRequest;
+import java.util.List;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -43,6 +50,14 @@
 @AutoValue
 abstract class ComponentCreatorDescriptor {
 
+  /** Returns the annotation marking this creator. */
+  abstract ComponentCreatorAnnotation annotation();
+
+  /** The kind of this creator. */
+  final ComponentCreatorKind kind() {
+    return annotation().creatorKind();
+  }
+
   /** The annotated creator type. */
   abstract TypeElement typeElement();
 
@@ -50,15 +65,69 @@
   abstract ExecutableElement factoryMethod();
 
   /**
-   * Multimap of component requirements to the element that sets that requirements.
+   * Multimap of component requirements to setter methods that set that requirement.
+   *
+   * <p>In a valid creator, there will be exactly one element per component requirement, so this
+   * method should only be called when validating the descriptor.
+   */
+  abstract ImmutableSetMultimap<ComponentRequirement, ExecutableElement> unvalidatedSetterMethods();
+
+  /**
+   * Multimap of component requirements to factory method parameters that set that requirement.
    *
-   * <p>Validation must ensure that no more than one element exists that sets a given requirement.
+   * <p>In a valid creator, there will be exactly one element per component requirement, so this
+   * method should only be called when validating the descriptor.
+   */
+  abstract ImmutableSetMultimap<ComponentRequirement, VariableElement>
+      unvalidatedFactoryParameters();
+
+  /**
+   * Multimap of component requirements to elements (methods or parameters) that set that
+   * requirement.
+   *
+   * <p>In a valid creator, there will be exactly one element per component requirement, so this
+   * method should only be called when validating the descriptor.
+   */
+  final ImmutableSetMultimap<ComponentRequirement, Element> unvalidatedRequirementElements() {
+    // ComponentCreatorValidator ensures that there are either setter methods or factory method
+    // parameters, but not both, so we can cheat a little here since we know that only one of
+    // the two multimaps will be non-empty.
+    return ImmutableSetMultimap.copyOf( // no actual copy
+        unvalidatedSetterMethods().isEmpty()
+            ? unvalidatedFactoryParameters()
+            : unvalidatedSetterMethods());
+  }
+
+  /**
+   * Map of component requirements to elements (setter methods or factory method parameters) that
+   * set them.
    */
-  abstract ImmutableSetMultimap<ComponentRequirement, ExecutableElement> requirementElements();
+  @Memoized
+  ImmutableMap<ComponentRequirement, Element> requirementElements() {
+    return flatten(unvalidatedRequirementElements());
+  }
+
+  /** Map of component requirements to setter methods for those requirements. */
+  @Memoized
+  ImmutableMap<ComponentRequirement, ExecutableElement> setterMethods() {
+    return flatten(unvalidatedSetterMethods());
+  }
+
+  /** Map of component requirements to factory method parameters for those requirements. */
+  @Memoized
+  ImmutableMap<ComponentRequirement, VariableElement> factoryParameters() {
+    return flatten(unvalidatedFactoryParameters());
+  }
+
+  private static <K, V> ImmutableMap<K, V> flatten(Multimap<K, V> multimap) {
+    return ImmutableMap.copyOf(
+        Maps.transformValues(multimap.asMap(), values -> getOnlyElement(values)));
+  }
 
   /** Returns the set of component requirements this creator allows the user to set. */
   final ImmutableSet<ComponentRequirement> userSettableRequirements() {
-    return requirementElements().keySet();
+    // Note: they should have been validated at the point this is used, so this set is valid.
+    return unvalidatedRequirementElements().keySet();
   }
 
   /** Returns the set of requirements for modules and component dependencies for this creator. */
@@ -71,13 +140,13 @@
   /** Returns the set of bound instance requirements for this creator. */
   final ImmutableSet<ComponentRequirement> boundInstanceRequirements() {
     return userSettableRequirements().stream()
-        .filter(requirement -> requirement.isBoundInstance())
+        .filter(ComponentRequirement::isBoundInstance)
         .collect(toImmutableSet());
   }
 
   /** Returns the element in this creator that sets the given {@code requirement}. */
-  final ExecutableElement elementForRequirement(ComponentRequirement requirement) {
-    return getOnlyElement(requirementElements().get(requirement));
+  final Element elementForRequirement(ComponentRequirement requirement) {
+    return requirementElements().get(requirement);
   }
 
   /** Creates a new {@link ComponentCreatorDescriptor} for the given creator {@code type}. */
@@ -89,7 +158,7 @@ static ComponentCreatorDescriptor create(
     TypeElement typeElement = asTypeElement(type);
     TypeMirror componentType = typeElement.getEnclosingElement().asType();
 
-    ImmutableSetMultimap.Builder<ComponentRequirement, ExecutableElement> requirementElements =
+    ImmutableSetMultimap.Builder<ComponentRequirement, ExecutableElement> setterMethods =
         ImmutableSetMultimap.builder();
 
     ExecutableElement factoryMethod = null;
@@ -101,14 +170,31 @@ static ComponentCreatorDescriptor create(
       } else {
         VariableElement parameter = getOnlyElement(method.getParameters());
         TypeMirror parameterType = getOnlyElement(resolvedMethodType.getParameterTypes());
-        requirementElements.put(
+        setterMethods.put(
             requirement(method, parameter, parameterType, dependencyRequestFactory), method);
       }
     }
     verify(factoryMethod != null); // validation should have ensured this.
 
+    ImmutableSetMultimap.Builder<ComponentRequirement, VariableElement> factoryParameters =
+        ImmutableSetMultimap.builder();
+
+    ExecutableType resolvedFactoryMethodType =
+        MoreTypes.asExecutable(types.asMemberOf(type, factoryMethod));
+    List<? extends VariableElement> parameters = factoryMethod.getParameters();
+    List<? extends TypeMirror> parameterTypes = resolvedFactoryMethodType.getParameterTypes();
+    for (int i = 0; i < parameters.size(); i++) {
+      VariableElement parameter = parameters.get(i);
+      TypeMirror parameterType = parameterTypes.get(i);
+      factoryParameters.put(
+          requirement(factoryMethod, parameter, parameterType, dependencyRequestFactory),
+          parameter);
+    }
+
+    // Validation should have ensured exactly one creator annotation is present on the type.
+    ComponentCreatorAnnotation annotation = getOnlyElement(getCreatorAnnotations(typeElement));
     return new AutoValue_ComponentCreatorDescriptor(
-        typeElement, factoryMethod, requirementElements.build());
+        annotation, typeElement, factoryMethod, setterMethods.build(), factoryParameters.build());
   }
 
   private static ComponentRequirement requirement(
@@ -116,11 +202,18 @@ private static ComponentRequirement requirement(
       VariableElement parameter,
       TypeMirror type,
       DependencyRequestFactory dependencyRequestFactory) {
-    if (isAnnotationPresent(method, BindsInstance.class)) {
+    boolean methodIsBindsInstance = isAnnotationPresent(method, BindsInstance.class);
+    if (methodIsBindsInstance || isAnnotationPresent(parameter, BindsInstance.class)) {
       DependencyRequest request =
           dependencyRequestFactory.forRequiredResolvedVariable(parameter, type);
+      // Validation already ensured that only setter methods have @BindsInstance, so name the
+      // variable for the method in that case. Otherwise, name the variable for the parameter.
+      String variableName =
+          methodIsBindsInstance
+              ? method.getSimpleName().toString()
+              : parameter.getSimpleName().toString();
       return ComponentRequirement.forBoundInstance(
-          request.key(), request.isNullable(), method.getSimpleName().toString());
+          request.key(), request.isNullable(), variableName);
     }
 
     return moduleAnnotation(asTypeElement(type)).isPresent()
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
index 08b192d4a..fa8256a37 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
@@ -24,6 +24,7 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -34,6 +35,7 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
@@ -50,6 +52,7 @@
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 
 /** Factory for creating {@link ComponentCreatorImplementation} instances. */
@@ -70,34 +73,48 @@
       return Optional.empty();
     }
 
-    if (componentImplementation.superclassImplementation().isPresent()
-        && componentImplementation.isAbstract()) {
-      // The component builder in ahead-of-time mode is generated with the base subcomponent
-      // implementation, with the exception of the build method since that requires invoking the
-      // constructor of a subclass component implementation. Intermediate component implementations,
-      // because they still can't invoke the eventual constructor and have no additional extensions
-      // to the builder, can ignore generating a builder implementation.
+    Optional<ComponentCreatorDescriptor> creatorDescriptor =
+        componentImplementation.graph().componentDescriptor().creatorDescriptor();
+
+    if (componentImplementation.isAbstract()
+        && (hasNoSetterMethods(creatorDescriptor)
+            || componentImplementation.superclassImplementation().isPresent())) {
+      // 1. Factory-like creators (those with no setter methods) are only generated in concrete
+      //    components, because they only have a factory method and the factory method must call
+      //    a concrete component's constructor.
+      // 2. The component builder in ahead-of-time mode is generated with the base subcomponent
+      //    implementation, with the exception of the build method since that requires invoking the
+      //    constructor of a concrete component implementation. Intermediate component
+      //    implementations, because they still can't invoke the eventual constructor and have no
+      //    additional extensions to the builder, can ignore generating a builder implementation.
       return Optional.empty();
     }
 
     Builder builder =
-        componentImplementation.graph().componentDescriptor().creatorDescriptor().isPresent()
-            ? new BuilderForCreatorDescriptor(componentImplementation)
+        creatorDescriptor.isPresent()
+            ? new BuilderForCreatorDescriptor(componentImplementation, creatorDescriptor.get())
             : new BuilderForGeneratedRootComponentBuilder(componentImplementation);
     return Optional.of(builder.build());
   }
 
+  private static boolean hasNoSetterMethods(
+      Optional<ComponentCreatorDescriptor> creatorDescriptor) {
+    return creatorDescriptor.filter(descriptor -> descriptor.setterMethods().isEmpty()).isPresent();
+  }
+
   /** Base class for building a creator implementation. */
   private abstract class Builder {
     final ComponentImplementation componentImplementation;
+    final ComponentCreatorKind creatorKind;
     final ClassName className;
     final TypeSpec.Builder classBuilder;
 
     private ImmutableMap<ComponentRequirement, FieldSpec> fields;
 
-    Builder(ComponentImplementation componentImplementation) {
+    Builder(ComponentImplementation componentImplementation, ComponentCreatorKind creatorKind) {
       this.componentImplementation = componentImplementation;
-      this.className = componentImplementation.getCreatorName();
+      this.creatorKind = creatorKind;
+      this.className = componentImplementation.getCreatorName(creatorKind);
       this.classBuilder = classBuilder(className);
     }
 
@@ -117,6 +134,15 @@ final BindingGraph graph() {
       return componentImplementation.graph();
     }
 
+    /** Returns the requirements that have setter methods on the creator type. */
+    abstract ImmutableSet<ComponentRequirement> setterMethods();
+
+    /**
+     * Returns the component requirements that have factory method parameters, mapped to the name
+     * for that parameter.
+     */
+    abstract ImmutableMap<ComponentRequirement, String> factoryMethodParameters();
+
     /**
      * The {@link ComponentRequirement}s that this creator allows users to set. Values are a status
      * for each requirement indicating what's needed for that requirement in the implementation
@@ -154,9 +180,9 @@ private void setModifiers() {
       // If a base implementation is present, any fields are already defined there and don't need to
       // be created in this implementation.
       return componentImplementation
-        .baseCreatorImplementation()
-        .map(ComponentCreatorImplementation::fields)
-        .orElseGet(() -> addFields());
+          .baseCreatorImplementation()
+          .map(ComponentCreatorImplementation::fields)
+          .orElseGet(this::addFields);
     }
 
     private ImmutableMap<ComponentRequirement, FieldSpec> addFields() {
@@ -165,7 +191,7 @@ private void setModifiers() {
       UniqueNameSet fieldNames = new UniqueNameSet();
       ImmutableMap<ComponentRequirement, FieldSpec> result =
           Maps.toMap(
-              neededUserSettableRequirements(),
+              Sets.intersection(neededUserSettableRequirements(), setterMethods()),
               requirement ->
                   FieldSpec.builder(
                           TypeName.get(requirement.type()),
@@ -177,7 +203,7 @@ private void setModifiers() {
     }
 
     private void addSetterMethods() {
-      userSettableRequirements()
+      Maps.filterKeys(userSettableRequirements(), setterMethods()::contains)
           .forEach(
               (requirement, status) ->
                   createSetterMethod(requirement, status).ifPresent(classBuilder::addMethod));
@@ -257,46 +283,75 @@ MethodSpec factoryMethod() {
       MethodSpec.Builder factoryMethod = factoryMethodBuilder();
       factoryMethod.returns(ClassName.get(graph().componentTypeElement())).addModifiers(PUBLIC);
 
+      ImmutableMap<ComponentRequirement, String> factoryMethodParameters =
+          factoryMethodParameters();
       neededUserSettableRequirements()
           .forEach(
               requirement -> {
-                FieldSpec field = fields.get(requirement);
-                switch (requirement.nullPolicy(elements, types)) {
-                  case NEW:
-                    checkState(requirement.kind().isModule());
-                    factoryMethod
-                        .beginControlFlow("if ($N == null)", field)
-                        .addStatement("this.$N = $L", field, newModuleInstance(requirement))
-                        .endControlFlow();
-                    break;
-                  case THROW:
-                    // TODO(cgdecker,ronshapiro): ideally this should use the key instead of a class
-                    // for @BindsInstance requirements, but that's not easily proguardable.
-                    factoryMethod.addStatement(
-                        "$T.checkBuilderRequirement($N, $T.class)",
-                        Preconditions.class,
-                        field,
-                        TypeNames.rawTypeName(field.type));
-                    break;
-                  case ALLOW:
-                    break;
+                if (fields.containsKey(requirement)) {
+                  FieldSpec field = fields.get(requirement);
+                  addNullHandlingForField(requirement, field, factoryMethod);
+                } else {
+                  String parameterName = factoryMethodParameters.get(requirement);
+                  addNullHandlingForParameter(requirement, parameterName, factoryMethod);
                 }
               });
       factoryMethod.addStatement(
-          "return new $T($L)", componentImplementation.name(), componentConstructorArgs());
+          "return new $T($L)",
+          componentImplementation.name(),
+          componentConstructorArgs(factoryMethodParameters));
       return factoryMethod.build();
     }
 
+    private void addNullHandlingForField(
+        ComponentRequirement requirement, FieldSpec field, MethodSpec.Builder factoryMethod) {
+      switch (requirement.nullPolicy(elements, types)) {
+        case NEW:
+          checkState(requirement.kind().isModule());
+          factoryMethod
+              .beginControlFlow("if ($N == null)", field)
+              .addStatement("this.$N = $L", field, newModuleInstance(requirement))
+              .endControlFlow();
+          break;
+        case THROW:
+          // TODO(cgdecker,ronshapiro): ideally this should use the key instead of a class for
+          // @BindsInstance requirements, but that's not easily proguardable.
+          factoryMethod.addStatement(
+              "$T.checkBuilderRequirement($N, $T.class)",
+              Preconditions.class,
+              field,
+              TypeNames.rawTypeName(field.type));
+          break;
+        case ALLOW:
+          break;
+      }
+    }
+
+    private void addNullHandlingForParameter(
+        ComponentRequirement requirement, String parameter, MethodSpec.Builder factoryMethod) {
+      if (!requirement.nullPolicy(elements, types).equals(NullPolicy.ALLOW)) {
+        // Factory method parameters are always required unless they are a nullable
+        // binds-instance (i.e. ALLOW)
+        factoryMethod.addStatement("$T.checkNotNull($L)", Preconditions.class, parameter);
+      }
+    }
+
     /** Returns a builder for the creator's factory method. */
     protected abstract MethodSpec.Builder factoryMethodBuilder();
 
-    private CodeBlock componentConstructorArgs() {
+    private CodeBlock componentConstructorArgs(
+        ImmutableMap<ComponentRequirement, String> factoryMethodParameters) {
       return componentImplementation.requirements().stream()
           .map(
-              requirement ->
-                  fields.containsKey(requirement)
-                      ? CodeBlock.of("$N", fields.get(requirement))
-                      : newModuleInstance(requirement))
+              requirement -> {
+                if (fields.containsKey(requirement)) {
+                  return CodeBlock.of("$N", fields.get(requirement));
+                } else if (factoryMethodParameters.containsKey(requirement)) {
+                  return CodeBlock.of("$L", factoryMethodParameters.get(requirement));
+                } else {
+                  return newModuleInstance(requirement);
+                }
+              })
           .collect(toParametersCodeBlock());
     }
 
@@ -310,10 +365,11 @@ private CodeBlock newModuleInstance(ComponentRequirement requirement) {
   private final class BuilderForCreatorDescriptor extends Builder {
     final ComponentCreatorDescriptor creatorDescriptor;
 
-    BuilderForCreatorDescriptor(ComponentImplementation componentImplementation) {
-      super(componentImplementation);
-      this.creatorDescriptor =
-          componentImplementation.componentDescriptor().creatorDescriptor().get();
+    BuilderForCreatorDescriptor(
+        ComponentImplementation componentImplementation,
+        ComponentCreatorDescriptor creatorDescriptor) {
+      super(componentImplementation, creatorDescriptor.kind());
+      this.creatorDescriptor = creatorDescriptor;
     }
 
     @Override
@@ -334,10 +390,10 @@ protected Modifier visibility() {
 
     @Override
     protected void setSupertype() {
-      if (componentImplementation.baseImplementation().isPresent()) {
-        // If there's a superclass, extend the creator defined there.
+      if (componentImplementation.baseCreatorImplementation().isPresent()) {
+        // If an abstract base implementation for this creator exists, extend that class.
         classBuilder.superclass(
-            componentImplementation.baseImplementation().get().getCreatorName());
+            componentImplementation.baseCreatorImplementation().get().name());
       } else {
         addSupertype(classBuilder, creatorDescriptor.typeElement());
       }
@@ -348,14 +404,26 @@ protected void addConstructor() {
       // Just use the implicit no-arg public constructor.
     }
 
+    @Override
+    protected ImmutableSet<ComponentRequirement> setterMethods() {
+      return ImmutableSet.copyOf(creatorDescriptor.setterMethods().keySet());
+    }
+
+    @Override
+    protected ImmutableMap<ComponentRequirement, String> factoryMethodParameters() {
+      return ImmutableMap.copyOf(
+          Maps.transformValues(
+              creatorDescriptor.factoryParameters(),
+              element -> element.getSimpleName().toString()));
+    }
+
+    private DeclaredType creatorType() {
+      return asDeclared(creatorDescriptor.typeElement().asType());
+    }
+
     @Override
     protected MethodSpec.Builder factoryMethodBuilder() {
-      ExecutableElement factoryMethodElement = creatorDescriptor.factoryMethod();
-      // Note: we don't use the factoryMethodElement.getReturnType() as the return type
-      // because it might be a type variable.  We make use of covariant returns to allow
-      // us to return the component type, which will always be valid.
-      return methodBuilder(factoryMethodElement.getSimpleName().toString())
-          .addAnnotation(Override.class);
+      return MethodSpec.overriding(creatorDescriptor.factoryMethod(), creatorType(), types);
     }
 
     private RequirementStatus requirementStatus(ComponentRequirement requirement) {
@@ -401,13 +469,10 @@ private boolean hasBaseCreatorImplementation() {
 
     @Override
     protected MethodSpec.Builder setterMethodBuilder(ComponentRequirement requirement) {
-      ExecutableElement supertypeMethod = creatorDescriptor.elementForRequirement(requirement);
-      MethodSpec.Builder method =
-          MethodSpec.overriding(
-              supertypeMethod, asDeclared(creatorDescriptor.typeElement().asType()), types);
+      ExecutableElement supertypeMethod = creatorDescriptor.setterMethods().get(requirement);
+      MethodSpec.Builder method = MethodSpec.overriding(supertypeMethod, creatorType(), types);
       if (!supertypeMethod.getReturnType().getKind().equals(TypeKind.VOID)) {
-        // Take advantage of covariant returns so that we don't have to worry about setter methods
-        // that return type variables.
+        // Take advantage of covariant returns so that we don't have to worry about type variables
         method.returns(className);
       }
       return method;
@@ -420,16 +485,17 @@ private boolean hasBaseCreatorImplementation() {
    */
   private final class BuilderForGeneratedRootComponentBuilder extends Builder {
     BuilderForGeneratedRootComponentBuilder(ComponentImplementation componentImplementation) {
-      super(componentImplementation);
+      super(componentImplementation, BUILDER);
     }
 
     @Override
     protected ImmutableMap<ComponentRequirement, RequirementStatus> userSettableRequirements() {
       return Maps.toMap(
-          graph().componentDescriptor().dependenciesAndConcreteModules(),
-          requirement -> componentImplementation.requirements().contains(requirement)
-              ? RequirementStatus.NEEDED
-              : RequirementStatus.UNNEEDED);
+          setterMethods(),
+          requirement ->
+              componentImplementation.requirements().contains(requirement)
+                  ? RequirementStatus.NEEDED
+                  : RequirementStatus.UNNEEDED);
     }
 
     @Override
@@ -447,6 +513,16 @@ protected void addConstructor() {
       classBuilder.addMethod(constructorBuilder().addModifiers(PRIVATE).build());
     }
 
+    @Override
+    protected ImmutableSet<ComponentRequirement> setterMethods() {
+      return graph().componentDescriptor().dependenciesAndConcreteModules();
+    }
+
+    @Override
+    protected ImmutableMap<ComponentRequirement, String> factoryMethodParameters() {
+      return ImmutableMap.of();
+    }
+
     @Override
     protected MethodSpec.Builder factoryMethodBuilder() {
       return methodBuilder("build");
diff --git a/java/dagger/internal/codegen/ComponentCreatorKind.java b/java/dagger/internal/codegen/ComponentCreatorKind.java
new file mode 100644
index 000000000..dc203de2a
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentCreatorKind.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+
+import com.google.common.base.Ascii;
+
+/** Enumeration of the different kinds of component creators. */
+enum ComponentCreatorKind {
+  /** {@code @Component.Builder} or one of its subcomponent/production variants. */
+  BUILDER,
+
+  /** {@code @Component.Factory} or one of its subcomponent/production variants. */
+  FACTORY,
+  ;
+
+  /** Name to use as (or as part of) a type name for a creator of this kind. */
+  String typeName() {
+    return UPPER_UNDERSCORE.to(UPPER_CAMEL, name());
+  }
+
+  /** Name to use for a component's static method returning a creator of this kind. */
+  String methodName() {
+    return Ascii.toLowerCase(name());
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentCreatorValidator.java b/java/dagger/internal/codegen/ComponentCreatorValidator.java
index a61926bc7..3dfbcf6e5 100644
--- a/java/dagger/internal/codegen/ComponentCreatorValidator.java
+++ b/java/dagger/internal/codegen/ComponentCreatorValidator.java
@@ -17,8 +17,8 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ComponentCreatorAnnotation.getCreatorAnnotations;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -26,11 +26,11 @@
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ObjectArrays;
 import dagger.BindsInstance;
 import dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages;
-import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
 import javax.inject.Inject;
@@ -38,13 +38,13 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ExecutableType;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 
-/** Validates {@link dagger.Component.Builder} annotations. */
-class ComponentCreatorValidator {
+/** Validates types annotated with component creator annotations. */
+final class ComponentCreatorValidator {
 
   private final DaggerElements elements;
   private final DaggerTypes types;
@@ -55,153 +55,277 @@
     this.types = types;
   }
 
-  public ValidationReport<TypeElement> validate(TypeElement subject) {
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
+  /** Validates that the given {@code type} is potentially a valid component creator type. */
+  public ValidationReport<TypeElement> validate(TypeElement type) {
+    ValidationReport.Builder<TypeElement> report = ValidationReport.about(type);
 
-    ComponentKind componentKind = ComponentKind.forAnnotatedBuilderElement(subject).get();
+    ImmutableSet<ComponentCreatorAnnotation> creatorAnnotations = getCreatorAnnotations(type);
+    if (creatorAnnotations.size() > 1) {
+      String error =
+          "May not have more than one component Builder or Factory annotation on a type: found "
+              + creatorAnnotations;
+      report.addError(error);
+      return report.build();
+    }
+
+    // creatorAnnotations should never be empty because the validate method should only ever be
+    // called for types that have been found to have some creator annotation
+    ComponentCreatorAnnotation annotation = getOnlyElement(creatorAnnotations);
+    ComponentCreatorMessages messages = ErrorMessages.creatorMessagesFor(annotation);
 
-    Element componentElement = subject.getEnclosingElement();
-    ErrorMessages.ComponentCreatorMessages msgs = ErrorMessages.creatorMessagesFor(componentKind);
-    checkArgument(isAnnotationPresent(subject, componentKind.builderAnnotation().get()));
+    ComponentKind componentKind = annotation.componentKind();
+    ComponentCreatorKind creatorKind = annotation.creatorKind();
 
+    Element componentElement = type.getEnclosingElement();
     if (!isAnnotationPresent(componentElement, componentKind.annotation())) {
-      builder.addError(msgs.mustBeInComponent(), subject);
+      report.addError(messages.mustBeInComponent());
     }
 
-    switch (subject.getKind()) {
+    // If the type isn't a class or interface, don't validate anything else since the rest of the
+    // messages will be bogus.
+    if (validateIsClassOrInterface(type, report, messages)) {
+      validateTypeRequirements(type, report, messages);
+      switch (creatorKind) {
+        case FACTORY:
+          validateFactory(type, report, componentElement, messages);
+          break;
+        case BUILDER:
+          validateBuilder(type, report, componentElement, messages);
+      }
+    }
+
+    // Note: there's more validation in ComponentDescriptorValidator:
+    // - to make sure the setter methods/factory parameters mirror the deps
+    // - to make sure each type or key is set by only one method or parameter
+
+    return report.build();
+  }
+
+  /** Validates that the type is a class or interface type and returns true if it is. */
+  private boolean validateIsClassOrInterface(
+      TypeElement type,
+      ValidationReport.Builder<TypeElement> report,
+      ComponentCreatorMessages messages) {
+    switch (type.getKind()) {
       case CLASS:
-        List<? extends Element> allElements = subject.getEnclosedElements();
-        List<ExecutableElement> cxtors = ElementFilter.constructorsIn(allElements);
-        if (cxtors.size() != 1 || getOnlyElement(cxtors).getParameters().size() != 0) {
-          builder.addError(msgs.cxtorOnlyOneAndNoArgs(), subject);
-        }
-        break;
+        validateConstructor(type, report, messages);
+        return true;
       case INTERFACE:
-        break;
+        return true;
       default:
-        // If not the correct type, exit early since the rest of the messages will be bogus.
-        builder.addError(msgs.mustBeClassOrInterface(), subject);
-        return builder.build();
+        report.addError(messages.mustBeClassOrInterface());
     }
+    return false;
+  }
+
+  private void validateConstructor(
+      TypeElement type,
+      ValidationReport.Builder<TypeElement> report,
+      ComponentCreatorMessages messages) {
+    List<? extends Element> allElements = type.getEnclosedElements();
+    List<ExecutableElement> constructors = ElementFilter.constructorsIn(allElements);
 
-    if (!subject.getTypeParameters().isEmpty()) {
-      builder.addError(msgs.generics(), subject);
+    boolean valid = true;
+    if (constructors.size() != 1) {
+      valid = false;
+    } else {
+      ExecutableElement constructor = getOnlyElement(constructors);
+      valid = constructor.getParameters().isEmpty()
+          && !constructor.getModifiers().contains(PRIVATE);
     }
 
-    Set<Modifier> modifiers = subject.getModifiers();
+    if (!valid) {
+      report.addError(messages.invalidConstructor());
+    }
+  }
+
+  /** Validates basic requirements about the type that are common to both creator kinds. */
+  private void validateTypeRequirements(
+      TypeElement type,
+      ValidationReport.Builder<TypeElement> report,
+      ComponentCreatorMessages messages) {
+    if (!type.getTypeParameters().isEmpty()) {
+      report.addError(messages.generics());
+    }
+
+    Set<Modifier> modifiers = type.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addError(msgs.isPrivate(), subject);
+      report.addError(messages.isPrivate());
     }
     if (!modifiers.contains(STATIC)) {
-      builder.addError(msgs.mustBeStatic(), subject);
+      report.addError(messages.mustBeStatic());
     }
     // Note: Must be abstract, so no need to check for final.
     if (!modifiers.contains(ABSTRACT)) {
-      builder.addError(msgs.mustBeAbstract(), subject);
+      report.addError(messages.mustBeAbstract());
     }
+  }
 
-    ExecutableElement factoryMethod = null;
-    for (ExecutableElement method : elements.getUnimplementedMethods(subject)) {
-      ExecutableType resolvedMethodType =
-          MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
-      TypeMirror returnType = resolvedMethodType.getReturnType();
+  private void validateBuilder(
+      TypeElement type,
+      ValidationReport.Builder<TypeElement> report,
+      Element componentElement,
+      ComponentCreatorMessages messages) {
+    ExecutableElement buildMethod = null;
+    for (ExecutableElement method : elements.getUnimplementedMethods(type)) {
+      TypeMirror returnType = types.resolveExecutableType(method, type.asType()).getReturnType();
       switch (method.getParameters().size()) {
         case 0: // If this is potentially a build() method, validate it returns the correct type.
-          if (types.isSubtype(componentElement.asType(), returnType)) {
-            validateFactoryMethodReturnType(
-                builder,
-                // since types.isSubtype() passed, componentElement cannot be a PackageElement
-                MoreElements.asType(componentElement),
-                msgs,
-                method,
-                returnType);
-            if (factoryMethod != null) {
+          if (validateFactoryMethodReturnType(
+              report, type, componentElement, messages, method)) {
+            if (buildMethod != null) {
               // If we found more than one build-like method, fail.
               error(
-                  builder,
+                  report,
                   method,
-                  msgs.twoBuildMethods(),
-                  msgs.inheritedTwoBuildMethods(),
-                  factoryMethod);
+                  messages.twoFactoryMethods(),
+                  messages.inheritedTwoFactoryMethods(),
+                  buildMethod);
             }
-          } else {
-            error(
-                builder,
-                method,
-                msgs.buildMustReturnComponentType(),
-                msgs.inheritedBuildMustReturnComponentType());
           }
-          // We set the factoryMethod regardless of the return type to reduce error spam.
-          factoryMethod = method;
+          // We set the buildMethod regardless of the return type to reduce error spam.
+          buildMethod = method;
           break;
 
         case 1: // If this correctly had one parameter, make sure the return types are valid.
-          if (returnType.getKind() != TypeKind.VOID
-              && !types.isSubtype(subject.asType(), returnType)) {
-            error(
-                builder,
-                method,
-                msgs.methodsMustReturnVoidOrBuilder(),
-                msgs.inheritedMethodsMustReturnVoidOrBuilder());
-          }
-          if (!method.getTypeParameters().isEmpty()) {
-            error(
-                builder,
-                method,
-                msgs.methodsMayNotHaveTypeParameters(),
-                msgs.inheritedMethodsMayNotHaveTypeParameters());
-          }
-          if (!isAnyAnnotationPresent(method, BindsInstance.class)
-              && method.getParameters().get(0).asType().getKind().isPrimitive()) {
-            error(
-                builder,
-                method,
-                msgs.nonBindsInstanceMethodsMayNotTakePrimitives(),
-                msgs.inheritedNonBindsInstanceMethodsMayNotTakePrimitives());
-          }
+          validateSetterMethod(type, method, returnType, report, messages);
           break;
 
         default: // more than one parameter
           error(
-              builder, method, msgs.methodsMustTakeOneArg(), msgs.inheritedMethodsMustTakeOneArg());
+              report,
+              method,
+              messages.setterMethodsMustTakeOneArg(),
+              messages.inheritedSetterMethodsMustTakeOneArg());
           break;
       }
     }
 
-    if (factoryMethod == null) {
-      builder.addError(msgs.missingBuildMethod(), subject);
+    if (buildMethod == null) {
+      report.addError(messages.missingFactoryMethod());
+    } else {
+      validateNotGeneric(buildMethod, report, messages);
     }
+  }
 
-    // Note: there's more validation in ComponentDescriptorValidator:
-    // - to make sure the setter methods mirror the deps
-    // - to make sure each type or key is set by only one method
+  private void validateSetterMethod(
+      TypeElement type,
+      ExecutableElement method,
+      TypeMirror returnType,
+      ValidationReport.Builder<TypeElement> report,
+      ComponentCreatorMessages messages) {
+    if (returnType.getKind() != TypeKind.VOID && !types.isSubtype(type.asType(), returnType)) {
+      error(
+          report,
+          method,
+          messages.setterMethodsMustReturnVoidOrBuilder(),
+          messages.inheritedSetterMethodsMustReturnVoidOrBuilder());
+    }
+
+    validateNotGeneric(method, report, messages);
 
-    return builder.build();
+    if (!isAnyAnnotationPresent(method, BindsInstance.class)
+        && method.getParameters().get(0).asType().getKind().isPrimitive()) {
+      error(
+          report,
+          method,
+          messages.nonBindsInstanceParametersMayNotBePrimitives(),
+          messages.inheritedNonBindsInstanceParametersMayNotBePrimitives());
+    }
   }
 
-  private void validateFactoryMethodReturnType(
-      ValidationReport.Builder<TypeElement> builder,
-      TypeElement componentElement,
-      ComponentCreatorMessages msgs,
-      ExecutableElement method,
-      TypeMirror returnType) {
-    if (types.isSameType(componentElement.asType(), returnType)) {
+  private void validateFactory(
+      TypeElement type,
+      ValidationReport.Builder<TypeElement> report,
+      Element componentElement,
+      ComponentCreatorMessages messages) {
+    ImmutableList<ExecutableElement> abstractMethods =
+        elements.getUnimplementedMethods(type).asList();
+    switch (abstractMethods.size()) {
+      case 0:
+        report.addError(messages.missingFactoryMethod());
+        return;
+      case 1:
+        break; // good
+      default:
+        error(
+            report,
+            abstractMethods.get(1),
+            messages.twoFactoryMethods(),
+            messages.inheritedTwoFactoryMethods(),
+            abstractMethods.get(0));
+        return;
+    }
+
+    ExecutableElement method = getOnlyElement(abstractMethods);
+    validateNotGeneric(method, report, messages);
+
+    if (!validateFactoryMethodReturnType(report, type, componentElement, messages, method)) {
+      // If we can't determine that the single method is a valid factory method, don't bother
+      // validating its parameters.
       return;
     }
-    ImmutableSet<ExecutableElement> methodsOnlyInComponent =
-        methodsOnlyInComponent(componentElement);
-    if (!methodsOnlyInComponent.isEmpty()) {
-      builder.addWarning(
-          msgs.buildMethodReturnsSupertypeWithMissingMethods(
-              componentElement, builder.getSubject(), returnType, method, methodsOnlyInComponent),
-          method);
+
+    for (VariableElement parameter : method.getParameters()) {
+      if (!isAnnotationPresent(parameter, BindsInstance.class)
+          && parameter.asType().getKind().isPrimitive()) {
+        error(
+            report,
+            method,
+            messages.nonBindsInstanceParametersMayNotBePrimitives(),
+            messages.inheritedNonBindsInstanceParametersMayNotBePrimitives());
+      }
+    }
+  }
+
+  /**
+   * Validates that the factory method that actually returns a new component instance. Returns true
+   * if the return type was valid.
+   */
+  private boolean validateFactoryMethodReturnType(
+      ValidationReport.Builder<TypeElement> report,
+      TypeElement type,
+      Element componentElement,
+      ComponentCreatorMessages messages,
+      ExecutableElement method) {
+    TypeMirror returnType = types.resolveExecutableType(method, type.asType()).getReturnType();
+
+    if (!types.isSubtype(componentElement.asType(), returnType)) {
+      error(
+          report,
+          method,
+          messages.factoryMethodMustReturnComponentType(),
+          messages.inheritedFactoryMethodMustReturnComponentType());
+      return false;
+    }
+
+    if (isAnnotationPresent(method, BindsInstance.class)) {
+      error(
+          report,
+          method,
+          messages.factoryMethodMayNotBeAnnotatedWithBindsInstance(),
+          messages.inheritedFactoryMethodMayNotBeAnnotatedWithBindsInstance());
+      return false;
+    }
+
+    TypeElement componentType = MoreElements.asType(componentElement);
+    if (!types.isSameType(componentType.asType(), returnType)) {
+      ImmutableSet<ExecutableElement> methodsOnlyInComponent =
+          methodsOnlyInComponent(componentType);
+      if (!methodsOnlyInComponent.isEmpty()) {
+        report.addWarning(
+            messages.factoryMethodReturnsSupertypeWithMissingMethods(
+                componentType, report.getSubject(), returnType, method, methodsOnlyInComponent),
+            method);
+      }
     }
+    return true;
   }
 
   /**
    * Generates one of two error messages. If the method is enclosed in the subject, we target the
    * error to the method itself. Otherwise we target the error to the subject and list the method as
-   * an argumnent. (Otherwise we have no way of knowing if the method is being compiled in this pass
+   * an argument. (Otherwise we have no way of knowing if the method is being compiled in this pass
    * too, so javac might not be able to pinpoint it's line of code.)
    */
   /*
@@ -217,22 +341,29 @@ private void validateFactoryMethodReturnType(
    * class was included in this compile run.  But that's hard, and this is close enough.
    */
   private static void error(
-      ValidationReport.Builder<TypeElement> builder,
+      ValidationReport.Builder<TypeElement> report,
       ExecutableElement method,
       String enclosedError,
       String inheritedError,
       Object... extraArgs) {
-    if (method.getEnclosingElement().equals(builder.getSubject())) {
-      builder.addError(String.format(enclosedError, extraArgs), method);
+    if (method.getEnclosingElement().equals(report.getSubject())) {
+      report.addError(String.format(enclosedError, extraArgs), method);
     } else {
-      builder.addError(String.format(inheritedError, append(extraArgs, method)));
+      report.addError(String.format(inheritedError, ObjectArrays.concat(extraArgs, method)));
     }
   }
 
-  private static Object[] append(Object[] initial, Object additional) {
-    Object[] newArray = Arrays.copyOf(initial, initial.length + 1);
-    newArray[initial.length] = additional;
-    return newArray;
+  private void validateNotGeneric(
+      ExecutableElement method,
+      ValidationReport.Builder<TypeElement> report,
+      ComponentCreatorMessages messages) {
+    if (!method.getTypeParameters().isEmpty()) {
+      error(
+          report,
+          method,
+          messages.methodsMayNotHaveTypeParameters(),
+          messages.inheritedMethodsMayNotHaveTypeParameters());
+    }
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentDescriptorFactory.java b/java/dagger/internal/codegen/ComponentDescriptorFactory.java
index 9c50a025d..c2226b8b0 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorFactory.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorFactory.java
@@ -20,6 +20,7 @@
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
@@ -37,7 +38,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableBiMap;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import dagger.Lazy;
@@ -196,10 +196,13 @@ private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind)
       }
     }
 
-    ImmutableList<DeclaredType> enclosedCreators =
-        kind.builderAnnotation()
-            .map(builderAnnotation -> enclosedAnnotatedTypes(typeElement, builderAnnotation))
-            .orElse(ImmutableList.of());
+    // Validation should have ensured that this set will have at most one element.
+    ImmutableSet<DeclaredType> enclosedCreators =
+        creatorAnnotationsFor(kind).stream()
+            .flatMap(
+                creatorAnnotation ->
+                    enclosedAnnotatedTypes(typeElement, creatorAnnotation).stream())
+            .collect(toImmutableSet());
     Optional<ComponentCreatorDescriptor> creatorDescriptor =
         enclosedCreators.isEmpty()
             ? Optional.empty()
diff --git a/java/dagger/internal/codegen/ComponentDescriptorValidator.java b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
index fe60695a8..5a1e16858 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorValidator.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
@@ -19,6 +19,7 @@
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Predicates.in;
+import static com.google.common.collect.Collections2.transform;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
@@ -34,6 +35,7 @@
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toList;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.collect.ImmutableSet;
@@ -52,12 +54,16 @@
 import java.util.Map.Entry;
 import java.util.Optional;
 import java.util.Set;
+import java.util.StringJoiner;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -67,7 +73,7 @@
  *   <li>Validates scope hierarchy of component dependencies and subcompoennts.
  *   <li>Reports errors if there are component dependency cycles.
  *   <li>Reports errors if any abstract modules have non-abstract instance binding methods.
- *   <li>Validates component builder types.
+ *   <li>Validates component creator types.
  * </ul>
  */
 // TODO(dpb): Combine with ComponentHierarchyValidator.
@@ -271,7 +277,7 @@ private void validateCreators(ComponentDescriptor component) {
       }
 
       ComponentCreatorDescriptor creator = component.creatorDescriptor().get();
-      ComponentCreatorMessages msgs = ErrorMessages.creatorMessagesFor(component);
+      ComponentCreatorMessages messages = ErrorMessages.creatorMessagesFor(creator.annotation());
 
       // Requirements for modules and dependencies that the creator can set
       Set<ComponentRequirement> creatorModuleAndDependencyRequirements =
@@ -286,18 +292,18 @@ private void validateCreators(ComponentDescriptor component) {
           Sets.difference(
               creatorModuleAndDependencyRequirements, componentModuleAndDependencyRequirements);
 
+      DeclaredType container = asDeclared(creator.typeElement().asType());
       if (!inapplicableRequirementsOnCreator.isEmpty()) {
-        Collection<ExecutableElement> excessElements =
+        Collection<Element> excessElements =
             Multimaps.filterKeys(
-                    creator.requirementElements(), in(inapplicableRequirementsOnCreator))
+                    creator.unvalidatedRequirementElements(), in(inapplicableRequirementsOnCreator))
                 .values();
-        Optional<DeclaredType> container = Optional.of(asDeclared(creator.typeElement().asType()));
         String formatted =
             excessElements.stream()
-                .map(method -> methodSignatureFormatter.format(method, container))
+                .map(element -> formatElement(element, container))
                 .collect(joining(", ", "[", "]"));
         report(component)
-            .addError(String.format(msgs.extraSetters(), formatted), creator.typeElement());
+            .addError(String.format(messages.extraSetters(), formatted), creator.typeElement());
       }
 
       // Component requirements that the creator must be able to set
@@ -313,17 +319,17 @@ private void validateCreators(ComponentDescriptor component) {
         report(component)
             .addError(
                 String.format(
-                    msgs.missingSetters(),
+                    messages.missingSetters(),
                     missingRequirements.stream().map(ComponentRequirement::type).collect(toList())),
                 creator.typeElement());
       }
 
-      // Validate that declared builder requirements (modules, dependencies) have unique types.
-      ImmutableSetMultimap<Wrapper<TypeMirror>, ExecutableElement> declaredRequirementsByType =
+      // Validate that declared creator requirements (modules, dependencies) have unique types.
+      ImmutableSetMultimap<Wrapper<TypeMirror>, Element> declaredRequirementsByType =
           Multimaps.filterKeys(
-                  creator.requirementElements(), in(creatorModuleAndDependencyRequirements))
-              .entries()
-              .stream()
+                  creator.unvalidatedRequirementElements(),
+                  creatorModuleAndDependencyRequirements::contains)
+              .entries().stream()
               .collect(
                   toImmutableSetMultimap(entry -> entry.getKey().wrappedType(), Entry::getValue));
       declaredRequirementsByType
@@ -332,9 +338,16 @@ private void validateCreators(ComponentDescriptor component) {
               (typeWrapper, elementsForType) -> {
                 if (elementsForType.size() > 1) {
                   TypeMirror type = typeWrapper.get();
+                  // TODO(cgdecker): Attach this error message to the factory method rather than
+                  // the component type if the elements are factory method parameters AND the
+                  // factory method is defined by the factory type itself and not by a supertype.
                   report(component)
                       .addError(
-                          String.format(msgs.manyMethodsForType(), type, elementsForType),
+                          String.format(
+                              messages.multipleSettersForModuleOrDependencyType(),
+                              type,
+                              transform(
+                                  elementsForType, element -> formatElement(element, container))),
                           creator.typeElement());
                 }
               });
@@ -344,6 +357,43 @@ private void validateCreators(ComponentDescriptor component) {
       // for subcomponents.
     }
 
+    private String formatElement(Element element, DeclaredType container) {
+      // TODO(cgdecker): Extract some or all of this to another class?
+      // But note that it does different formatting for parameters than
+      // DaggerElements.elementToString(Element).
+      switch (element.getKind()) {
+        case METHOD:
+          return methodSignatureFormatter.format(
+              MoreElements.asExecutable(element), Optional.of(container));
+        case PARAMETER:
+          return formatParameter(MoreElements.asVariable(element), container);
+        default:
+          // This method shouldn't be called with any other type of element.
+          throw new AssertionError();
+      }
+    }
+
+    private String formatParameter(VariableElement parameter, DeclaredType container) {
+      // TODO(cgdecker): Possibly leave the type (and annotations?) off of the parameters here and
+      // just use their names, since the type will be redundant in the context of the error message.
+      StringJoiner joiner = new StringJoiner(" ");
+      parameter.getAnnotationMirrors().stream().map(Object::toString).forEach(joiner::add);
+      TypeMirror parameterType = resolveParameterType(parameter, container);
+      return joiner
+          .add(stripCommonTypePrefixes(parameterType.toString()))
+          .add(parameter.getSimpleName())
+          .toString();
+    }
+
+    private TypeMirror resolveParameterType(VariableElement parameter, DeclaredType container) {
+      ExecutableElement method =
+          MoreElements.asExecutable(parameter.getEnclosingElement());
+      int parameterIndex = method.getParameters().indexOf(parameter);
+
+      ExecutableType methodType = MoreTypes.asExecutable(types.asMemberOf(container, method));
+      return methodType.getParameterTypes().get(parameterIndex);
+    }
+
     /**
      * Validates that scopes do not participate in a scoping cycle - that is to say, scoped
      * components are in a hierarchical relationship terminating with Singleton.
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 199400ff0..4b4157c3b 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -364,10 +364,10 @@ void setCreatorImplementation(Optional<ComponentCreatorImplementation> creatorIm
    * Returns the name of the creator class for this component. It will be a sibling of this
    * generated class unless this is a top-level component, in which case it will be nested.
    */
-  ClassName getCreatorName() {
+  ClassName getCreatorName(ComponentCreatorKind kind) {
     return isNested()
-        ? name.peerClass(subcomponentNames.get(componentDescriptor()) + "Builder")
-        : name.nestedClass("Builder");
+        ? name.peerClass(subcomponentNames.get(componentDescriptor()) + kind.typeName())
+        : name.nestedClass(kind.typeName());
   }
 
   /** Returns the name of the nested implementation class for a child component. */
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index c9cd1a35b..a03275e71 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.CodeBlocks.parameterNames;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.BUILDER_METHOD;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.CANCELLATION_LISTENER_METHOD;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.COMPONENT_METHOD;
@@ -641,29 +642,45 @@ protected void addCreatorClass(TypeSpec creator) {
 
     @Override
     protected void addFactoryMethods() {
-      // Only top-level components have the factory builder() method.
-      // Mirror the user's creator API type if they had one.
+      // Top-level components have a static method that returns a builder or factory for the
+      // component. If the user defined a @Component.Builder or @Component.Factory, an
+      // implementation of their type is returned. Otherwise, an autogenerated Builder type is
+      // returned.
+      // TODO(cgdecker): Replace this abomination with a small class?
+      // Better yet, change things so that an autogenerated builder type has a descriptor of sorts
+      // just like a user-defined creator type.
+      ComponentCreatorKind creatorKind;
+      ClassName creatorType;
+      String factoryMethodName;
+      boolean noArgFactoryMethod;
+      if (creatorDescriptor().isPresent()) {
+        ComponentCreatorDescriptor descriptor = creatorDescriptor().get();
+        creatorKind = descriptor.kind();
+        creatorType = ClassName.get(descriptor.typeElement());
+        factoryMethodName = descriptor.factoryMethod().getSimpleName().toString();
+        noArgFactoryMethod = descriptor.factoryParameters().isEmpty();
+      } else {
+        creatorKind = BUILDER;
+        creatorType = componentCreatorName();
+        factoryMethodName = "build";
+        noArgFactoryMethod = true;
+      }
+
       MethodSpec creatorFactoryMethod =
-          methodBuilder("builder")
+          methodBuilder(creatorKind.methodName())
               .addModifiers(PUBLIC, STATIC)
-              .returns(
-                  creatorDescriptor()
-                      .map(creatorDescriptor -> ClassName.get(creatorDescriptor.typeElement()))
-                      .orElse(componentCreatorName()))
+              .returns(creatorType)
               .addStatement("return new $T()", componentCreatorName())
               .build();
       componentImplementation.addMethod(BUILDER_METHOD, creatorFactoryMethod);
-      if (canInstantiateAllRequirements()) {
-        CharSequence buildMethodName =
-            creatorDescriptor().isPresent()
-                ? creatorDescriptor().get().factoryMethod().getSimpleName()
-                : "build";
+      if (noArgFactoryMethod && canInstantiateAllRequirements()) {
         componentImplementation.addMethod(
             BUILDER_METHOD,
             methodBuilder("create")
                 .returns(ClassName.get(super.graph.componentTypeElement()))
                 .addModifiers(PUBLIC, STATIC)
-                .addStatement("return new Builder().$L()", buildMethodName)
+                .addStatement(
+                    "return new $L().$L()", creatorKind.typeName(), factoryMethodName)
                 .build());
       }
     }
diff --git a/java/dagger/internal/codegen/ComponentKind.java b/java/dagger/internal/codegen/ComponentKind.java
index 73af19a7b..b0f0a331c 100644
--- a/java/dagger/internal/codegen/ComponentKind.java
+++ b/java/dagger/internal/codegen/ComponentKind.java
@@ -18,9 +18,9 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Sets.immutableEnumSet;
-import static dagger.internal.codegen.DaggerStreams.presentValues;
+import static dagger.internal.codegen.DaggerStreams.stream;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static java.util.Arrays.stream;
+import static dagger.internal.codegen.DaggerStreams.valuesOf;
 import static java.util.EnumSet.allOf;
 
 import com.google.common.collect.ImmutableSet;
@@ -31,50 +31,44 @@
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
-import java.util.EnumSet;
 import java.util.Optional;
-import java.util.Set;
-import java.util.function.Function;
-import java.util.stream.Stream;
 import javax.lang.model.element.TypeElement;
 
 /** Enumeration of the different kinds of components. */
 enum ComponentKind {
   /** {@code @Component} */
-  COMPONENT(Component.class, Optional.of(Component.Builder.class), true, false),
+  COMPONENT(Component.class, true, false),
 
   /** {@code @Subcomponent} */
-  SUBCOMPONENT(Subcomponent.class, Optional.of(Subcomponent.Builder.class), false, false),
+  SUBCOMPONENT(Subcomponent.class, false, false),
 
   /** {@code @ProductionComponent} */
-  PRODUCTION_COMPONENT(
-      ProductionComponent.class, Optional.of(ProductionComponent.Builder.class), true, true),
+  PRODUCTION_COMPONENT(ProductionComponent.class, true, true),
 
   /** {@code @ProductionSubcomponent} */
-  PRODUCTION_SUBCOMPONENT(
-      ProductionSubcomponent.class, Optional.of(ProductionSubcomponent.Builder.class), false, true),
+  PRODUCTION_SUBCOMPONENT(ProductionSubcomponent.class, false, true),
 
   /**
    * Kind for a descriptor that was generated from a {@link Module} instead of a component type in
    * order to validate the module's bindings.
    */
-  MODULE(Module.class, Optional.empty(), true, false),
+  MODULE(Module.class, true, false),
 
   /**
    * Kind for a descriptor was generated from a {@link ProducerModule} instead of a component type
    * in order to validate the module's bindings.
    */
-  PRODUCER_MODULE(ProducerModule.class, Optional.empty(), true, true),
+  PRODUCER_MODULE(ProducerModule.class, true, true),
   ;
 
   private static final ImmutableSet<ComponentKind> ROOT_COMPONENT_KINDS =
-      stream(values())
+      valuesOf(ComponentKind.class)
           .filter(kind -> !kind.isForModuleValidation())
           .filter(kind -> kind.isRoot())
           .collect(toImmutableSet());
 
   private static final ImmutableSet<ComponentKind> SUBCOMPONENT_KINDS =
-      stream(values())
+      valuesOf(ComponentKind.class)
           .filter(kind -> !kind.isForModuleValidation())
           .filter(kind -> !kind.isRoot())
           .collect(toImmutableSet());
@@ -89,32 +83,25 @@
     return SUBCOMPONENT_KINDS;
   }
 
-  /** Returns the set of all annotations that mark components and their builders. */
-  static ImmutableSet<Class<? extends Annotation>> allComponentAndBuilderAnnotations() {
-    return stream(values())
+  /** Returns all annotations that mark a component type. */
+  static ImmutableSet<Class<? extends Annotation>> allAnnotations() {
+    return valuesOf(ComponentKind.class)
         .filter(kind -> !kind.isForModuleValidation())
-        .flatMap(kind -> Stream.of(kind.annotation(), kind.builderAnnotation().get()))
+        .map(ComponentKind::annotation)
         .collect(toImmutableSet());
   }
 
   /** Returns the annotations for components of the given kinds. */
-  static ImmutableSet<Class<? extends Annotation>> annotationsFor(Set<ComponentKind> kinds) {
-    return annotationsFor(kinds, kind -> Optional.of(kind.annotation()));
+  static ImmutableSet<Class<? extends Annotation>> annotationsFor(Iterable<ComponentKind> kinds) {
+    return stream(kinds).map(ComponentKind::annotation).collect(toImmutableSet());
   }
 
-  private static ImmutableSet<Class<? extends Annotation>> annotationsFor(
-      Set<ComponentKind> kinds,
-      Function<ComponentKind, Optional<Class<? extends Annotation>>> annotationFunction) {
-    return kinds.stream()
-        .map(annotationFunction)
-        .flatMap(presentValues())
+  /** Returns the set of component kinds the given {@code element} has annotations for. */
+  static ImmutableSet<ComponentKind> getComponentKinds(TypeElement element) {
+    return valuesOf(ComponentKind.class)
+        .filter(kind -> isAnnotationPresent(element, kind.annotation()))
         .collect(toImmutableSet());
   }
-  
-  /** Returns the annotations for builders for components of the given kinds. */
-  static ImmutableSet<Class<? extends Annotation>> builderAnnotationsFor(Set<ComponentKind> kinds) {
-    return annotationsFor(kinds, ComponentKind::builderAnnotation);
-  }
 
   /**
    * Returns the kind of an annotated element if it is annotated with one of the {@linkplain
@@ -124,54 +111,23 @@
    *     annotations
    */
   static Optional<ComponentKind> forAnnotatedElement(TypeElement element) {
-    return forAnnotatedElement(element, kind -> Optional.of(kind.annotation()));
-  }
-
-  private static Optional<ComponentKind> forAnnotatedElement(
-      TypeElement element,
-      Function<ComponentKind, Optional<Class<? extends Annotation>>> annotationFunction) {
-    Set<ComponentKind> kinds = EnumSet.noneOf(ComponentKind.class);
-    for (ComponentKind kind : values()) {
-      if (annotationFunction
-          .apply(kind)
-          .filter(annotation -> isAnnotationPresent(element, annotation))
-          .isPresent()) {
-        kinds.add(kind);
-      }
-    }
-
+    ImmutableSet<ComponentKind> kinds = getComponentKinds(element);
     if (kinds.size() > 1) {
       throw new IllegalArgumentException(
-          element
-              + " cannot be annotated with more than one of "
-              + annotationsFor(kinds, annotationFunction));
+          element + " cannot be annotated with more than one of " + annotationsFor(kinds));
     }
     return kinds.stream().findAny();
   }
-  
-  /**
-   * Returns the kind of an annotated element if it is annotated with one of the {@linkplain
-   * #builderAnnotation() builder annotations}.
-   *
-   * @throws IllegalArgumentException if the element is annotated with more than one of the builder
-   *     annotations
-   */
-  static Optional<ComponentKind> forAnnotatedBuilderElement(TypeElement element) {
-    return forAnnotatedElement(element, ComponentKind::builderAnnotation);
-  }
 
   private final Class<? extends Annotation> annotation;
-  private final Optional<Class<? extends Annotation>> builderAnnotation;
   private final boolean isRoot;
   private final boolean production;
 
   ComponentKind(
       Class<? extends Annotation> annotation,
-      Optional<Class<? extends Annotation>> builderAnnotation,
       boolean isRoot,
       boolean production) {
     this.annotation = annotation;
-    this.builderAnnotation = builderAnnotation;
     this.isRoot = isRoot;
     this.production = production;
   }
@@ -181,15 +137,6 @@
     return annotation;
   }
 
-  /**
-   * Returns the {@code @Builder} annotation type for this kind of component, or empty if the
-   * descriptor is {@linkplain #isForModuleValidation() for a module} in order to validate its
-   * bindings.
-   */
-  Optional<Class<? extends Annotation>> builderAnnotation() {
-    return builderAnnotation;
-  }
-
   /** Returns the kinds of modules that can be used with a component of this kind. */
   ImmutableSet<ModuleKind> legalModuleKinds() {
     return isProducer()
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index a25a55955..9df8b0b2d 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -16,9 +16,8 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.ComponentKind.allComponentAndBuilderAnnotations;
+import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
 import static dagger.internal.codegen.ComponentKind.annotationsFor;
-import static dagger.internal.codegen.ComponentKind.builderAnnotationsFor;
 import static dagger.internal.codegen.ComponentKind.rootComponentKinds;
 import static dagger.internal.codegen.ComponentKind.subcomponentKinds;
 import static java.util.Collections.disjoint;
@@ -30,6 +29,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import java.lang.annotation.Annotation;
 import java.util.HashMap;
@@ -56,9 +56,9 @@
   private final BindingGraphValidator bindingGraphValidator;
   private final CompilerOptions compilerOptions;
   private ImmutableSet<Element> subcomponentElements;
-  private ImmutableSet<Element> subcomponentBuilderElements;
-  private ImmutableMap<Element, ValidationReport<TypeElement>> builderReportsByComponent;
-  private ImmutableMap<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent;
+  private ImmutableSet<Element> subcomponentCreatorElements;
+  private ImmutableMap<Element, ValidationReport<TypeElement>> creatorReportsByComponent;
+  private ImmutableMap<Element, ValidationReport<TypeElement>> creatorReportsBySubcomponent;
   private ImmutableMap<Element, ValidationReport<TypeElement>> reportsBySubcomponent;
 
   @Inject
@@ -88,7 +88,7 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return allComponentAndBuilderAnnotations();
+    return Sets.union(ComponentKind.allAnnotations(), ComponentCreatorAnnotation.allAnnotations());
   }
 
   @Override
@@ -96,20 +96,20 @@
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     subcomponentElements =
         getElementsFromAnnotations(elementsByAnnotation, annotationsFor(subcomponentKinds()));
-    subcomponentBuilderElements =
+    subcomponentCreatorElements =
         getElementsFromAnnotations(
-            elementsByAnnotation, builderAnnotationsFor(subcomponentKinds()));
+            elementsByAnnotation, creatorAnnotationsFor(subcomponentKinds()));
 
     ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
 
-    builderReportsByComponent =
-        processBuilders(
+    creatorReportsByComponent =
+        processCreators(
             getElementsFromAnnotations(
-                elementsByAnnotation, builderAnnotationsFor(rootComponentKinds())),
+                elementsByAnnotation, creatorAnnotationsFor(rootComponentKinds())),
             rejectedElements);
-    builderReportsBySubcomponent = processBuilders(subcomponentBuilderElements, rejectedElements);
+    creatorReportsBySubcomponent = processCreators(subcomponentCreatorElements, rejectedElements);
     reportsBySubcomponent =
-        processSubcomponents(subcomponentElements, subcomponentBuilderElements, rejectedElements);
+        processSubcomponents(subcomponentElements, subcomponentCreatorElements, rejectedElements);
 
     return rejectedElements.addAll(super.process(elementsByAnnotation)).build();
   }
@@ -119,7 +119,7 @@ protected void process(
       TypeElement element, ImmutableSet<Class<? extends Annotation>> annotations) {
     if (!disjoint(annotations, annotationsFor(rootComponentKinds()))) {
       ComponentValidationReport validationReport =
-          componentValidator.validate(element, subcomponentElements, subcomponentBuilderElements);
+          componentValidator.validate(element, subcomponentElements, subcomponentCreatorElements);
       validationReport.report().printMessagesTo(messager);
       if (!isClean(validationReport)) {
         return;
@@ -166,7 +166,7 @@ private void generateComponent(BindingGraph bindingGraph) {
         Multimaps.filterKeys(elementsByAnnotation, Predicates.in(annotations)).values());
   }
 
-  private ImmutableMap<Element, ValidationReport<TypeElement>> processBuilders(
+  private ImmutableMap<Element, ValidationReport<TypeElement>> processCreators(
       Set<? extends Element> builderElements, ImmutableSet.Builder<Element> rejectedElements) {
     // Can't use an ImmutableMap.Builder here because a component may have (invalidly) more than one
     // builder type, and that would make ImmutableMap.Builder throw.
@@ -213,7 +213,7 @@ private boolean isClean(ComponentValidationReport report) {
     if (!componentReport.isClean()) {
       return false;
     }
-    ValidationReport<?> builderReport = builderReportsByComponent.get(component);
+    ValidationReport<?> builderReport = creatorReportsByComponent.get(component);
     if (builderReport != null && !builderReport.isClean()) {
       return false;
     }
@@ -228,7 +228,7 @@ private boolean isClean(ComponentValidationReport report) {
   /** Returns true if the reports associated with the subcomponent are clean. */
   private boolean subcomponentIsClean(Element subcomponentElement) {
     ValidationReport<?> subcomponentBuilderReport =
-        builderReportsBySubcomponent.get(subcomponentElement);
+        creatorReportsBySubcomponent.get(subcomponentElement);
     if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
       return false;
     }
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index c13eb21e1..a8f9e3543 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -22,15 +22,20 @@
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Multimaps.asMap;
+import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
+import static dagger.internal.codegen.ComponentKind.annotationsFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
-import static dagger.internal.codegen.DaggerStreams.presentValues;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages.builderMethodRequiresNoArgs;
+import static dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages.moreThanOneRefToSubcomponent;
 import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 import static java.util.Comparator.comparing;
 import static javax.lang.model.element.ElementKind.CLASS;
@@ -51,7 +56,6 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Reusable;
-import dagger.internal.codegen.ErrorMessages.SubcomponentCreatorMessages;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.producers.CancellationPolicy;
@@ -119,13 +123,40 @@
    * already included in the {@code validatedSubcomponents} set.
    */
   public ComponentValidationReport validate(
-      final TypeElement subject,
+      TypeElement subject,
       Set<? extends Element> validatedSubcomponents,
       Set<? extends Element> validatedSubcomponentCreators) {
     ValidationReport.Builder<TypeElement> report = ValidationReport.about(subject);
 
-    ComponentKind componentKind = ComponentKind.forAnnotatedElement(subject).get();
+    ImmutableSet<ComponentKind> componentKinds = ComponentKind.getComponentKinds(subject);
+    ImmutableSet<Element> allSubcomponents;
+    if (componentKinds.size() > 1) {
+      String error =
+          "Components may not be annotated with more than one component annotation: found "
+              + annotationsFor(componentKinds);
+      report.addError(error, subject);
+      allSubcomponents = ImmutableSet.of();
+    } else {
+      ComponentKind componentKind = getOnlyElement(componentKinds);
+      allSubcomponents =
+          validate(
+              subject,
+              componentKind,
+              validatedSubcomponents,
+              validatedSubcomponentCreators,
+              report);
+    }
+
+    return new AutoValue_ComponentValidator_ComponentValidationReport(
+        allSubcomponents, report.build());
+  }
 
+  private ImmutableSet<Element> validate(
+      TypeElement subject,
+      ComponentKind componentKind,
+      Set<? extends Element> validatedSubcomponents,
+      Set<? extends Element> validatedSubcomponentCreators,
+      ValidationReport.Builder<TypeElement> report) {
     if (isAnnotationPresent(subject, CancellationPolicy.class) && !componentKind.isProducer()) {
       report.addError(
           "@CancellationPolicy may only be applied to production components and subcomponents",
@@ -141,14 +172,13 @@ public ComponentValidationReport validate(
           subject);
     }
 
-    ImmutableList<DeclaredType> builders =
-        componentKind
-            .builderAnnotation()
-            .map(builderAnnotation -> enclosedAnnotatedTypes(subject, builderAnnotation))
-            .orElse(ImmutableList.of());
-    if (builders.size() > 1) {
+    ImmutableList<DeclaredType> creators =
+        creatorAnnotationsFor(componentKind).stream()
+            .flatMap(annotation -> enclosedAnnotatedTypes(subject, annotation).stream())
+            .collect(toImmutableList());
+    if (creators.size() > 1) {
       report.addError(
-          String.format(ErrorMessages.creatorMessagesFor(componentKind).moreThanOne(), builders),
+          String.format(ErrorMessages.componentMessagesFor(componentKind).moreThanOne(), creators),
           subject);
     }
 
@@ -184,13 +214,9 @@ public ComponentValidationReport validate(
                       componentKind.legalSubcomponentKinds().stream()
                           .map(ComponentKind::annotation)
                           .collect(toImmutableSet()));
-              Optional<AnnotationMirror> subcomponentBuilderAnnotation =
+              Optional<AnnotationMirror> subcomponentCreatorAnnotation =
                   checkForAnnotations(
-                      returnType,
-                      componentKind.legalSubcomponentKinds().stream()
-                          .map(ComponentKind::builderAnnotation)
-                          .flatMap(presentValues())
-                          .collect(toImmutableSet()));
+                      returnType, creatorAnnotationsFor(componentKind.legalSubcomponentKinds()));
               if (subcomponentAnnotation.isPresent()) {
                 referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
                 validateSubcomponentMethod(
@@ -201,7 +227,7 @@ public ComponentValidationReport validate(
                     parameterTypes,
                     returnType,
                     subcomponentAnnotation);
-              } else if (subcomponentBuilderAnnotation.isPresent()) {
+              } else if (subcomponentCreatorAnnotation.isPresent()) {
                 referencedSubcomponents.put(
                     MoreTypes.asElement(returnType).getEnclosingElement(), method);
                 validateSubcomponentCreatorMethod(
@@ -244,11 +270,7 @@ public ComponentValidationReport validate(
         .forEach(
             (subcomponent, methods) ->
                 report.addError(
-                    String.format(
-                        SubcomponentCreatorMessages.INSTANCE.moreThanOneRefToSubcomponent(),
-                        subcomponent,
-                        methods),
-                    subject));
+                    String.format(moreThanOneRefToSubcomponent(), subcomponent, methods), subject));
 
     AnnotationMirror componentMirror =
         getAnnotationMirror(subject, componentKind.annotation()).get();
@@ -273,9 +295,7 @@ public ComponentValidationReport validate(
       report.addItems(subreport.report().items());
       allSubcomponents.addAll(subreport.referencedSubcomponents());
     }
-
-    return new AutoValue_ComponentValidator_ComponentValidationReport(
-        allSubcomponents.build(), report.build());
+    return allSubcomponents.build();
   }
 
   private void checkConflictingEntryPoints(ValidationReport.Builder<TypeElement> report) {
@@ -437,9 +457,8 @@ private void validateSubcomponentCreatorMethod(
       List<? extends VariableElement> parameters,
       TypeMirror returnType,
       Set<? extends Element> validatedSubcomponentCreators) {
-
     if (!parameters.isEmpty()) {
-      report.addError(SubcomponentCreatorMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
+      report.addError(builderMethodRequiresNoArgs(), method);
     }
 
     // If we haven't already validated the subcomponent creator itself, validate it now.
diff --git a/java/dagger/internal/codegen/ConfigurationAnnotations.java b/java/dagger/internal/codegen/ConfigurationAnnotations.java
index cc25a41d3..8e2325f73 100644
--- a/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -20,8 +20,9 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.consumingIterable;
+import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
 import static dagger.internal.codegen.ComponentKind.annotationsFor;
-import static dagger.internal.codegen.ComponentKind.builderAnnotationsFor;
+import static dagger.internal.codegen.ComponentKind.rootComponentKinds;
 import static dagger.internal.codegen.ComponentKind.subcomponentKinds;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
@@ -39,9 +40,6 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Module;
-import dagger.Subcomponent;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.ArrayDeque;
 import java.util.List;
@@ -63,11 +61,11 @@
 final class ConfigurationAnnotations {
 
   static Optional<AnnotationMirror> getComponentAnnotation(TypeElement component) {
-    return getAnyAnnotation(component, Component.class, ProductionComponent.class);
+    return getAnyAnnotation(component, annotationsFor(rootComponentKinds()));
   }
 
   static Optional<AnnotationMirror> getSubcomponentAnnotation(TypeElement subcomponent) {
-    return getAnyAnnotation(subcomponent, Subcomponent.class, ProductionSubcomponent.class);
+    return getAnyAnnotation(subcomponent, annotationsFor(subcomponentKinds()));
   }
 
   static Optional<AnnotationMirror> getComponentOrSubcomponentAnnotation(TypeElement type) {
@@ -93,7 +91,7 @@ static boolean isSubcomponent(Element element) {
   }
 
   static boolean isSubcomponentCreator(Element element) {
-    return isAnyAnnotationPresent(element, builderAnnotationsFor(subcomponentKinds()));
+    return isAnyAnnotationPresent(element, creatorAnnotationsFor(subcomponentKinds()));
   }
 
   /**
diff --git a/java/dagger/internal/codegen/DaggerStreams.java b/java/dagger/internal/codegen/DaggerStreams.java
index ff4c44698..50d17a6de 100644
--- a/java/dagger/internal/codegen/DaggerStreams.java
+++ b/java/dagger/internal/codegen/DaggerStreams.java
@@ -24,12 +24,15 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Maps;
+import java.util.Collection;
+import java.util.EnumSet;
 import java.util.Map;
 import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 
 /** Utilities for streams. */
 public final class DaggerStreams {
@@ -99,6 +102,11 @@
     return f -> to.isInstance(f) ? Stream.of(to.cast(f)) : Stream.empty();
   }
 
+  /** Returns a stream of all values of the given {@code enumType}. */
+  public static <E extends Enum<E>> Stream<E> valuesOf(Class<E> enumType) {
+    return EnumSet.allOf(enumType).stream();
+  }
+
   /**
    * A function that you can use to extract the present values from a stream of {@link Optional}s.
    *
@@ -113,5 +121,15 @@
     return optional -> optional.map(Stream::of).orElse(Stream.empty());
   }
 
+  /**
+   * Returns a sequential {@link Stream} of the contents of {@code iterable}, delegating to {@link
+   * Collection#stream} if possible.
+   */
+  public static <T> Stream<T> stream(Iterable<T> iterable) {
+    return (iterable instanceof Collection)
+        ? ((Collection<T>) iterable).stream()
+        : StreamSupport.stream(iterable.spliterator(), false);
+  }
+
   private DaggerStreams() {}
 }
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index 28d1ce43a..57f763fd7 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -32,6 +32,7 @@
 import java.util.function.Predicate;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
@@ -250,6 +251,14 @@ protected Boolean defaultAction(TypeMirror e, Void aVoid) {
         null);
   }
 
+  /**
+   * Resolves the type of the given executable element as a member of the given type. This may
+   * resolve type variables to concrete types, etc.
+   */
+  public ExecutableType resolveExecutableType(ExecutableElement element, TypeMirror containerType) {
+    return MoreTypes.asExecutable(asMemberOf(MoreTypes.asDeclared(containerType), element));
+  }
+
   // Implementation of Types methods, delegating to types.
 
   @Override
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index d61d8a278..39cced950 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -16,55 +16,98 @@
 
 package dagger.internal.codegen;
 
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableMap;
 import java.util.Set;
+import java.util.function.Function;
+import java.util.function.UnaryOperator;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
-/**
- * The collection of error messages to be reported back to users.
- */
+/** The collection of error messages to be reported back to users. */
 final class ErrorMessages {
 
-  static ComponentCreatorMessages creatorMessagesFor(ComponentDescriptor component) {
-    return component.isProduction()
-        ? component.isSubcomponent()
-            ? ProductionSubcomponentCreatorMessages.INSTANCE
-            : ProductionComponentCreatorMessages.INSTANCE
-        : component.isSubcomponent()
-            ? SubcomponentCreatorMessages.INSTANCE
-            : ComponentCreatorMessages.INSTANCE;
+  private static final UnaryOperator<String> PRODUCTION =
+      s ->
+          s.replace("component", "production component")
+              .replace("Component", "ProductionComponent");
+
+  private static final UnaryOperator<String> SUBCOMPONENT =
+      s -> s.replace("component", "subcomponent").replace("Component", "Subcomponent");
+
+  private static final UnaryOperator<String> FACTORY = s -> s.replace("Builder", "Factory");
+
+  private static final ImmutableMap<ComponentKind, Function<String, String>>
+      COMPONENT_TRANSFORMATIONS =
+          ImmutableMap.of(
+              ComponentKind.COMPONENT, UnaryOperator.identity(),
+              ComponentKind.SUBCOMPONENT, SUBCOMPONENT,
+              ComponentKind.PRODUCTION_COMPONENT, PRODUCTION,
+              ComponentKind.PRODUCTION_SUBCOMPONENT, PRODUCTION.andThen(SUBCOMPONENT));
+
+  static ComponentMessages componentMessagesFor(ComponentKind componentKind) {
+    return new ComponentMessages(COMPONENT_TRANSFORMATIONS.get(componentKind));
+  }
+
+  static ComponentCreatorMessages creatorMessagesFor(ComponentCreatorAnnotation creatorAnnotation) {
+    return creatorMessagesFor(creatorAnnotation.componentKind(), creatorAnnotation.creatorKind());
   }
 
-  static ComponentCreatorMessages creatorMessagesFor(ComponentKind kind) {
-    switch(kind) {
-      case COMPONENT:
-        return ComponentCreatorMessages.INSTANCE;
-      case SUBCOMPONENT:
-        return SubcomponentCreatorMessages.INSTANCE;
-      case PRODUCTION_COMPONENT:
-        return ProductionComponentCreatorMessages.INSTANCE;
-      case PRODUCTION_SUBCOMPONENT:
-        return ProductionSubcomponentCreatorMessages.INSTANCE;
-      default:
-        throw new IllegalStateException(kind.toString());
+  @VisibleForTesting
+  static ComponentCreatorMessages creatorMessagesFor(
+      ComponentKind componentKind, ComponentCreatorKind creatorKind) {
+    Function<String, String> transformation = COMPONENT_TRANSFORMATIONS.get(componentKind);
+    switch (creatorKind) {
+      case BUILDER:
+        return new BuilderMessages(transformation);
+      case FACTORY:
+        return new FactoryMessages(transformation);
     }
+    throw new AssertionError();
   }
 
-  static class ComponentCreatorMessages {
-    static final ComponentCreatorMessages INSTANCE = new ComponentCreatorMessages();
+  private abstract static class Messages {
+    private final Function<String, String> transformation;
 
-    protected String process(String s) { return s; }
+    Messages(Function<String, String> transformation) {
+      this.transformation = transformation;
+    }
+
+    protected final String process(String s) {
+      return transformation.apply(s);
+    }
+  }
+
+  /** Errors for components. */
+  static final class ComponentMessages extends Messages {
+    ComponentMessages(Function<String, String> transformation) {
+      super(transformation);
+    }
 
-    /** Errors for component builders. */
     final String moreThanOne() {
-      return process("@Component has more than one @Component.Builder: %s");
+      return process("@Component has more than one @Component.Builder or @Component.Factory: %s");
+    }
+  }
+
+  /** Errors for component creators. */
+  abstract static class ComponentCreatorMessages extends Messages {
+    ComponentCreatorMessages(Function<String, String> transformation) {
+      super(transformation);
+    }
+
+    static String builderMethodRequiresNoArgs() {
+      return "Methods returning a @Component.Builder must have no arguments";
+    }
+
+    static String moreThanOneRefToSubcomponent() {
+      return "Only one method can create a given subcomponent. %s is created by: %s";
     }
 
-    final String cxtorOnlyOneAndNoArgs() {
+    final String invalidConstructor() {
       return process("@Component.Builder classes must have exactly one constructor,"
-          + " and it must not have any parameters");
+          + " and it must not be private or have any parameters");
     }
 
     final String generics() {
@@ -91,63 +134,45 @@ final String mustBeAbstract() {
       return process("@Component.Builder types must be abstract");
     }
 
-    final String missingBuildMethod() {
-      return process("@Component.Builder types must have exactly one no-args method that "
-          + " returns the @Component type");
-    }
+    abstract String missingFactoryMethod();
 
-    final String manyMethodsForType() {
-      return process("@Component.Builder types must not have more than one setter method per type,"
-          + " but %s is set by %s");
-    }
+    abstract String multipleSettersForModuleOrDependencyType();
 
-    final String extraSetters() {
-      return process(
-          "@Component.Builder has setters for modules or components that aren't required: %s");
-    }
+    abstract String extraSetters();
 
-    final String missingSetters() {
-      return process(
-          "@Component.Builder is missing setters for required modules or components: %s");
-    }
+    abstract String missingSetters();
 
-    final String twoBuildMethods() {
-      return process("@Component.Builder types must have exactly one zero-arg method, and that"
-          + " method must return the @Component type. Already found: %s");
-    }
+    abstract String twoFactoryMethods();
 
-    final String inheritedTwoBuildMethods() {
-      return process("@Component.Builder types must have exactly one zero-arg method, and that"
-          + " method must return the @Component type. Found %s and %s");
-    }
+    abstract String inheritedTwoFactoryMethods();
 
-    final String buildMustReturnComponentType() {
-      return process(
-          "@Component.Builder methods that have no arguments must return the @Component type or a "
-              + "supertype of the @Component");
+    abstract String factoryMethodMustReturnComponentType();
+
+    final String inheritedFactoryMethodMustReturnComponentType() {
+      return factoryMethodMustReturnComponentType() + ". Inherited method: %s";
     }
 
-    final String inheritedBuildMustReturnComponentType() {
-      return buildMustReturnComponentType() + ". Inherited method: %s";
+    abstract String factoryMethodMayNotBeAnnotatedWithBindsInstance();
+
+    final String inheritedFactoryMethodMayNotBeAnnotatedWithBindsInstance() {
+      return factoryMethodMayNotBeAnnotatedWithBindsInstance() + ". Inherited method: %s";
     }
 
-    final String methodsMustTakeOneArg() {
+    final String setterMethodsMustTakeOneArg() {
       return process("@Component.Builder methods must not have more than one argument");
     }
 
-    final String inheritedMethodsMustTakeOneArg() {
-      return process(
-          "@Component.Builder methods must not have more than one argument. Inherited method: %s");
+    final String inheritedSetterMethodsMustTakeOneArg() {
+      return setterMethodsMustTakeOneArg() + ". Inherited method: %s";
     }
 
-    final String methodsMustReturnVoidOrBuilder() {
+    final String setterMethodsMustReturnVoidOrBuilder() {
       return process("@Component.Builder setter methods must return void, the builder,"
           + " or a supertype of the builder");
     }
 
-    final String inheritedMethodsMustReturnVoidOrBuilder() {
-      return process("@Component.Builder setter methods must return void, the builder,"
-          + "or a supertype of the builder. Inherited method: %s");
+    final String inheritedSetterMethodsMustReturnVoidOrBuilder() {
+      return setterMethodsMustReturnVoidOrBuilder() + ". Inherited method: %s";
     }
 
     final String methodsMayNotHaveTypeParameters() {
@@ -155,23 +180,18 @@ final String methodsMayNotHaveTypeParameters() {
     }
 
     final String inheritedMethodsMayNotHaveTypeParameters() {
-      return process(
-          "@Component.Builder methods must not have type parameters. Inherited method: %s");
+      return methodsMayNotHaveTypeParameters() + ". Inherited method: %s";
     }
 
-    final String nonBindsInstanceMethodsMayNotTakePrimitives() {
-      return process(
-          "@Component.Builder methods that are not annotated with @BindsInstance "
-              + "must take either a module or a component dependency, not a primitive");
-    }
+    abstract String nonBindsInstanceParametersMayNotBePrimitives();
 
-    final String inheritedNonBindsInstanceMethodsMayNotTakePrimitives() {
-      return nonBindsInstanceMethodsMayNotTakePrimitives() + process(". Inherited method: %s");
+    final String inheritedNonBindsInstanceParametersMayNotBePrimitives() {
+      return nonBindsInstanceParametersMayNotBePrimitives() + ". Inherited method: %s";
     }
 
-    final String buildMethodReturnsSupertypeWithMissingMethods(
+    final String factoryMethodReturnsSupertypeWithMissingMethods(
         TypeElement component,
-        TypeElement componentCreator,
+        TypeElement componentBuilder,
         TypeMirror returnType,
         ExecutableElement buildMethod,
         Set<ExecutableElement> additionalMethods) {
@@ -179,7 +199,7 @@ final String buildMethodReturnsSupertypeWithMissingMethods(
           "%1$s.%2$s() returns %3$s, but %4$s declares additional component method(s): %5$s. In "
               + "order to provide type-safe access to these methods, override %2$s() to return "
               + "%4$s",
-          componentCreator.getQualifiedName(),
+          componentBuilder.getQualifiedName(),
           buildMethod.getSimpleName(),
           returnType,
           component.getQualifiedName(),
@@ -187,44 +207,132 @@ final String buildMethodReturnsSupertypeWithMissingMethods(
     }
   }
 
-  static final class SubcomponentCreatorMessages extends ComponentCreatorMessages {
-    @SuppressWarnings("hiding")
-    static final SubcomponentCreatorMessages INSTANCE = new SubcomponentCreatorMessages();
+  private static final class BuilderMessages extends ComponentCreatorMessages {
+    BuilderMessages(Function<String, String> transformation) {
+      super(transformation);
+    }
 
-    @Override protected String process(String s) {
-      return s.replaceAll("component", "subcomponent").replaceAll("Component", "Subcomponent");
+    @Override
+    String missingFactoryMethod() {
+      return process(
+          "@Component.Builder types must have exactly one no-args method that "
+              + " returns the @Component type");
     }
 
-    String builderMethodRequiresNoArgs() {
-      return "Methods returning a @Subcomponent.Builder must have no arguments";
+    @Override
+    String multipleSettersForModuleOrDependencyType() {
+      return process(
+          "@Component.Builder types must not have more than one setter method per module or "
+              + "dependency, but %s is set by %s");
     }
 
-    String moreThanOneRefToSubcomponent() {
-      return "Only one method can create a given subcomponent. %s is created by: %s";
+    @Override
+    String extraSetters() {
+      return process(
+          "@Component.Builder has setters for modules or components that aren't required: %s");
+    }
+
+    @Override
+    String missingSetters() {
+      return process(
+          "@Component.Builder is missing setters for required modules or components: %s");
+    }
+
+    @Override
+    String twoFactoryMethods() {
+      return process(
+          "@Component.Builder types must have exactly one zero-arg method, and that"
+              + " method must return the @Component type. Already found: %s");
+    }
+
+    @Override
+    String inheritedTwoFactoryMethods() {
+      return process(
+          "@Component.Builder types must have exactly one zero-arg method, and that"
+              + " method must return the @Component type. Found %s and %s");
+    }
+
+    @Override
+    String factoryMethodMustReturnComponentType() {
+      return process(
+          "@Component.Builder methods that have no arguments must return the @Component type or a "
+              + "supertype of the @Component");
     }
-  }
 
-  private static final class ProductionComponentCreatorMessages extends ComponentCreatorMessages {
-    @SuppressWarnings("hiding")
-    static final ProductionComponentCreatorMessages INSTANCE =
-        new ProductionComponentCreatorMessages();
+    @Override
+    String factoryMethodMayNotBeAnnotatedWithBindsInstance() {
+      return process(
+          "@Component.Builder no-arg build methods may not be annotated with @BindsInstance");
+    }
 
-    @Override protected String process(String s) {
-      return s.replaceAll("component", "production component")
-          .replaceAll("Component", "ProductionComponent");
+    @Override
+    String nonBindsInstanceParametersMayNotBePrimitives() {
+      return process(
+          "@Component.Builder methods that are not annotated with @BindsInstance "
+              + "must take either a module or a component dependency, not a primitive");
     }
   }
 
-  private static final class ProductionSubcomponentCreatorMessages
-      extends ComponentCreatorMessages {
-    @SuppressWarnings("hiding")
-    static final ProductionSubcomponentCreatorMessages INSTANCE =
-        new ProductionSubcomponentCreatorMessages();
+  private static final class FactoryMessages extends ComponentCreatorMessages {
+    FactoryMessages(Function<String, String> transformation) {
+      super(transformation.andThen(FACTORY));
+    }
+
+    @Override
+    String missingFactoryMethod() {
+      return process(
+          "@Component.Factory types must have exactly one method that "
+              + "returns the @Component type");
+    }
+
+    @Override
+    String multipleSettersForModuleOrDependencyType() {
+      return process(
+          "@Component.Factory methods must not have more than one parameter per module or "
+              + "dependency, but %s is set by %s");
+    }
+
+    @Override
+    String extraSetters() {
+      return process(
+          "@Component.Factory method has parameters for modules or components that aren't "
+              + "required: %s");
+    }
+
+    @Override
+    String missingSetters() {
+      return process(
+          "@Component.Factory method is missing parameters for required modules or components: %s");
+    }
+
+    @Override
+    String twoFactoryMethods() {
+      return process(
+          "@Component.Factory types must have exactly one abstract method. Already found: %s");
+    }
+
+    @Override
+    String inheritedTwoFactoryMethods() {
+      return twoFactoryMethods();
+    }
+
+    @Override
+    String factoryMethodMustReturnComponentType() {
+      return process(
+          "@Component.Factory abstract methods must return the @Component type or a "
+              + "supertype of the @Component");
+    }
+
+    @Override
+    String factoryMethodMayNotBeAnnotatedWithBindsInstance() {
+      return process("@Component.Factory method may not be annotated with @BindsInstance");
+    }
 
     @Override
-    protected String process(String s) {
-      return s.replaceAll("component", "production subcomponent")
-          .replaceAll("Component", "ProductionSubcomponent");
+    String nonBindsInstanceParametersMayNotBePrimitives() {
+      return process(
+          "@Component.Factory method parameters that are not annotated with @BindsInstance "
+              + "must be either a module or a component dependency, not a primitive");
     }
   }
 
diff --git a/java/dagger/producers/ProductionComponent.java b/java/dagger/producers/ProductionComponent.java
index 77530b6f9..2af8aef5b 100644
--- a/java/dagger/producers/ProductionComponent.java
+++ b/java/dagger/producers/ProductionComponent.java
@@ -20,6 +20,7 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Beta;
@@ -95,37 +96,22 @@
   Class<?>[] dependencies() default {};
 
   /**
-   * A builder for a component. Components may have a single nested static abstract class or
-   * interface annotated with {@code @ProductionComponent.Builder}. If they do, then the component's
-   * generated builder will match the API in the type.  Builders must follow some rules:
-   * <ul>
-   * <li> A single abstract method with no arguments must exist, and must return the component.
-   *      (This is typically the {@code build()} method.)
-   * <li> All other abstract methods must take a single argument and must return void,
-   *      the builder type, or a supertype of the builder.
-   * <li> Each component dependency <b>must</b> have an abstract setter method.
-   * <li> Each module dependency that Dagger can't instantiate itself (i.e., the module
-   *      doesn't have a visible no-args constructor) <b>must</b> have an abstract setter method.
-   *      Other module dependencies (ones that Dagger can instantiate) are allowed, but not
-   *      required.
-   * <li> Non-abstract methods are allowed, but ignored as far as validation and builder generation
-   *      are concerned.
-   * </ul>
+   * A builder for a production component.
    *
-   * For example, this could be a valid {@code ProductionComponent} with a builder: <pre><code>
-   * {@literal @}ProductionComponent(modules = {BackendModule.class, FrontendModule.class})
-   * interface MyComponent {
-   *   {@literal ListenableFuture<MyWidget>} myWidget();
-   *
-   *   {@literal @}ProductionComponent.Builder
-   *   interface Builder {
-   *     MyComponent build();
-   *     Builder backendModule(BackendModule bm);
-   *     Builder frontendModule(FrontendModule fm);
-   *   }
-   * }</code></pre>
+   * <p>This follows all the rules of {@link Component.Builder}, except it must appear in classes
+   * annotated with {@link ProductionComponent} instead of {@code Component}.
    */
   @Target(TYPE)
   @Documented
   @interface Builder {}
+
+  /**
+   * A factory for a production component.
+   *
+   * <p>This follows all the rules of {@link Component.Factory}, except it must appear in classes
+   * annotated with {@link ProductionComponent} instead of {@code Component}.
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Factory {}
 }
diff --git a/java/dagger/producers/ProductionSubcomponent.java b/java/dagger/producers/ProductionSubcomponent.java
index 60ce5dfc2..c03fc3bee 100644
--- a/java/dagger/producers/ProductionSubcomponent.java
+++ b/java/dagger/producers/ProductionSubcomponent.java
@@ -50,13 +50,30 @@
   Class<?>[] modules() default {};
 
   /**
-   * A builder for a subcomponent.  This follows all the rules of
-   * {@link ProductionComponent.Builder}, except it must appear in classes annotated with
-   * {@link ProductionSubcomponent} instead of {@code ProductionComponent}. Components can have
-   * methods that return a {@link ProductionSubcomponent.Builder}-annotated type, allowing the user
-   * to set modules on the subcomponent using their defined API.
+   * A builder for a production subcomponent.
+   *
+   * <p>This follows all the rules of {@link Component.Builder}, except it must appear in classes
+   * annotated with {@link ProductionSubcomponent} instead of {@code Component}.
+   *
+   * <p>If a subcomponent defines a builder, its parent component(s) will have a binding for that
+   * builder type, allowing an instance or {@code Provider} of that builder to be injected or
+   * returned from a method on that component like any other binding.
    */
   @Target(TYPE)
   @Documented
   @interface Builder {}
+
+  /**
+   * A factory for a production subcomponent.
+   *
+   * <p>This follows all the rules of {@link Component.Factory}, except it must appear in classes
+   * annotated with {@link ProductionSubcomponent} instead of {@code Component}.
+   *
+   * <p>If a subcomponent defines a factory, its parent component(s) will have a binding for that
+   * factory type, allowing an instance that factory to be injected or returned from a method on
+   * that component like any other binding.
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Factory {}
 }
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index e9b1f6d81..16d83c36e 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -719,8 +719,6 @@ public void generatedInstanceBinding() {
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
-            "",
-            "  public abstract static class Builder implements Leaf.Builder {}",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -813,7 +811,7 @@ public void generatedInstanceBinding() {
             "      return new LeafBuilder();",
             "    }",
             "",
-            "    private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "    private final class LeafBuilder implements Leaf.Builder {",
             "      @Override",
             "      public Leaf build() {",
             "        return new LeafImpl();",
@@ -2532,8 +2530,6 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "    Producers.cancel(getSetOfResponseProducer(), mayInterruptIfRunning);",
             "    Producers.cancel(responseProducer, mayInterruptIfRunning);",
             "  }",
-            "",
-            "  public abstract static class Builder implements Leaf.Builder {}",
             "}");
 
     Compilation compilation = compile(filesToCompile.build());
@@ -2689,7 +2685,7 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "    }",
             "  }",
             "",
-            "  private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "  private final class LeafBuilder implements Leaf.Builder {",
             "    @Override",
             "    public Leaf build() {",
             "      return new LeafImpl();",
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index 6f2d66b2b..f918971bd 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -18,8 +18,10 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
+import static dagger.internal.codegen.ComponentKind.COMPONENT;
+import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
@@ -45,60 +47,7 @@ public ComponentBuilderTest(CompilerMode compilerMode) {
   }
 
   private static final ErrorMessages.ComponentCreatorMessages MSGS =
-      ErrorMessages.ComponentCreatorMessages.INSTANCE;
-
-  @Test
-  public void testEmptyBuilder() {
-    JavaFileObject injectableTypeFile =
-        JavaFileObjects.forSourceLines(
-            "test.SomeInjectableType",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class SomeInjectableType {",
-            "  @Inject SomeInjectableType() {}",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "interface SimpleComponent {",
-            "  SomeInjectableType someInjectableType();",
-            "",
-            "  @Component.Builder",
-            "  static interface Builder {",
-            "     SimpleComponent build();",
-            "  }",
-            "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private static final class Builder implements SimpleComponent.Builder {",
-            "    @Override",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent();",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(injectableTypeFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .containsElementsIn(generatedComponent);
-  }
+      creatorMessagesFor(COMPONENT, BUILDER);
 
   @Test
   public void testUsesBuildAndSetterNames() {
@@ -168,118 +117,7 @@ public void testUsesBuildAndSetterNames() {
   }
 
   @Test
-  public void testIgnoresModulesNotInApi() {
-    JavaFileObject module1 =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule1",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule1 {",
-            "  @Provides String string() { return null; }",
-            "}");
-    JavaFileObject module2 =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule2",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule2 {",
-            "  @Provides Integer integer() { return null; }",
-            "}");
-
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = {TestModule1.class, TestModule2.class})",
-            "interface TestComponent {",
-            "  String string();",
-            "  Integer integer();",
-            "",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    Builder testModule1(TestModule1 testModule1);",
-            "    TestComponent build();",
-            "  }",
-            "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private final TestModule1 testModule1;",
-            "  private final TestModule2 testModule2;",
-            "",
-            "  private DaggerTestComponent(",
-            "      TestModule1 testModule1Param,",
-            "      TestModule2 testModule2Param) {",
-            "    this.testModule1 = testModule1Param;",
-            "    this.testModule2 = testModule2Param;",
-            "  }",
-            "",
-            "  public static TestComponent.Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public String string() {",
-            "    return TestModule1_StringFactory.string(testModule1);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Integer integer() {",
-            "    return TestModule2_IntegerFactory.integer(testModule2);",
-            "  }",
-            "",
-            "  private static final class Builder implements TestComponent.Builder {",
-            "    private TestModule1 testModule1;",
-            "",
-            "    @Override",
-            "    public Builder testModule1(TestModule1 testModule1) {",
-            "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
-            "      return this;",
-            "    }",
-            "",
-            "    @Override",
-            "    public TestComponent build() {",
-            "      if (testModule1 == null) {",
-            "        this.testModule1 = new TestModule1();",
-            "      }",
-            "      return new DaggerTestComponent(testModule1, new TestModule2());",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(module1, module2, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test
-  public void testMoreThanOneBuilderFails() {
+  public void testSetterMethodWithMoreThanOneArgFails() {
     JavaFileObject componentFile =
         JavaFileObjects.forSourceLines(
             "test.SimpleComponent",
@@ -289,30 +127,29 @@ public void testMoreThanOneBuilderFails() {
             "import javax.inject.Provider;",
             "",
             "@Component",
-            "interface SimpleComponent {",
-            "  @Component.Builder",
-            "  static interface Builder {",
-            "     SimpleComponent build();",
-            "  }",
-            "",
+            "abstract class SimpleComponent {",
             "  @Component.Builder",
-            "  interface Builder2 {",
-            "     SimpleComponent build();",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    Builder set(String s, Integer i);",
+            "    Builder set(Number n, Double d);",
             "  }",
             "}");
     Compilation compilation =
         daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                MSGS.moreThanOne(),
-                "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
-        .inFile(componentFile);
+        .hadErrorContaining(MSGS.setterMethodsMustTakeOneArg())
+        .inFile(componentFile)
+        .onLineContaining("Builder set(String s, Integer i);");
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.setterMethodsMustTakeOneArg())
+        .inFile(componentFile)
+        .onLineContaining("Builder set(Number n, Double d);");
   }
 
   @Test
-  public void testBuilderGenericsFails() {
+  public void testInheritedSetterMethodWithMoreThanOneArgFails() {
     JavaFileObject componentFile =
         JavaFileObjects.forSourceLines(
             "test.SimpleComponent",
@@ -322,130 +159,56 @@ public void testBuilderGenericsFails() {
             "import javax.inject.Provider;",
             "",
             "@Component",
-            "interface SimpleComponent {",
-            "  @Component.Builder",
-            "  interface Builder<T> {",
-            "     SimpleComponent build();",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    Builder set1(String s, Integer i);",
             "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.generics()).inFile(componentFile);
-  }
-
-  @Test
-  public void testBuilderNotInComponentFails() {
-    JavaFileObject builder =
-        JavaFileObjects.forSourceLines(
-            "test.Builder",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component.Builder",
-            "interface Builder {}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(builder);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.mustBeInComponent()).inFile(builder);
-  }
-
-  @Test
-  public void testBuilderMissingBuildMethodFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
             "",
-            "@Component",
-            "interface SimpleComponent {",
             "  @Component.Builder",
-            "  interface Builder {}",
+            "  interface Builder extends Parent {}",
             "}");
     Compilation compilation =
         daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.missingBuildMethod()).inFile(componentFile);
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.inheritedSetterMethodsMustTakeOneArg(),
+                "set1(java.lang.String,java.lang.Integer)"))
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
-  public void testBuilderBindsInstanceNoCreateGenerated() {
+  public void testSetterReturningNonVoidOrBuilderFails() {
     JavaFileObject componentFile =
         JavaFileObjects.forSourceLines(
             "test.SimpleComponent",
             "package test;",
             "",
-            "import dagger.BindsInstance;",
             "import dagger.Component;",
             "import javax.inject.Provider;",
             "",
             "@Component",
-            "interface SimpleComponent {",
-            "  Object object();",
-            "",
+            "abstract class SimpleComponent {",
             "  @Component.Builder",
             "  interface Builder {",
-            "    @BindsInstance Builder object(Object object);",
             "    SimpleComponent build();",
+            "    String set(Integer i);",
             "  }",
             "}");
-
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private final Object object;",
-            "",
-            "  private DaggerSimpleComponent(Object objectParam) {",
-            "    this.object = objectParam;",
-            "  }",
-            "",
-            "  public static SimpleComponent.Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Object object() {",
-            "    return object;",
-            "  }",
-            "",
-            "  private static final class Builder implements SimpleComponent.Builder {",
-            "    private Object object;",
-            "",
-            "    @Override",
-            "    public Builder object(Object object) {",
-            "      this.object = Preconditions.checkNotNull(object);",
-            "      return this;",
-            "    }",
-            "",
-            "    @Override",
-            "    public SimpleComponent build() {",
-            "      Preconditions.checkBuilderRequirement(object, Object.class);",
-            "      return new DaggerSimpleComponent(object);",
-            "    }",
-            "  }",
-            "}");
-
     Compilation compilation =
         daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation).failed();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
+        .hadErrorContaining(MSGS.setterMethodsMustReturnVoidOrBuilder())
+        .inFile(componentFile)
+        .onLineContaining("String set(Integer i);");
   }
 
   @Test
-  public void testPrivateBuilderFails() {
+  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
     JavaFileObject componentFile =
         JavaFileObjects.forSourceLines(
             "test.SimpleComponent",
@@ -456,38 +219,27 @@ public void testPrivateBuilderFails() {
             "",
             "@Component",
             "abstract class SimpleComponent {",
-            "  @Component.Builder",
-            "  private interface Builder {}",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.isPrivate()).inFile(componentFile);
-  }
-
-  @Test
-  public void testNonStaticBuilderFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    String set(Integer i);",
+            "  }",
             "",
-            "@Component",
-            "abstract class SimpleComponent {",
             "  @Component.Builder",
-            "  abstract class Builder {}",
+            "  interface Builder extends Parent {}",
             "}");
     Compilation compilation =
         daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.mustBeStatic()).inFile(componentFile);
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.inheritedSetterMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
-  public void testNonAbstractBuilderFails() {
+  public void testGenericsOnSetterMethodFails() {
     JavaFileObject componentFile =
         JavaFileObjects.forSourceLines(
             "test.SimpleComponent",
@@ -499,16 +251,22 @@ public void testNonAbstractBuilderFails() {
             "@Component",
             "abstract class SimpleComponent {",
             "  @Component.Builder",
-            "  static class Builder {}",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    <T> Builder set(T t);",
+            "  }",
             "}");
     Compilation compilation =
         daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.mustBeAbstract()).inFile(componentFile);
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+        .inFile(componentFile)
+        .onLineContaining("<T> Builder set(T t);");
   }
 
   @Test
-  public void testBuilderOneCxtorWithArgsFails() {
+  public void testGenericsOnInheritedSetterMethodFails() {
     JavaFileObject componentFile =
         JavaFileObjects.forSourceLines(
             "test.SimpleComponent",
@@ -519,764 +277,21 @@ public void testBuilderOneCxtorWithArgsFails() {
             "",
             "@Component",
             "abstract class SimpleComponent {",
-            "  @Component.Builder",
-            "  static abstract class Builder {",
-            "    Builder(String unused) {}",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    <T> Builder set(T t);",
             "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs()).inFile(componentFile);
-  }
-
-  @Test
-  public void testBuilderMoreThanOneCxtorFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
             "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
             "  @Component.Builder",
-            "  static abstract class Builder {",
-            "    Builder() {}",
-            "    Builder(String unused) {}",
-            "  }",
+            "  interface Builder extends Parent {}",
             "}");
     Compilation compilation =
         daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs()).inFile(componentFile);
-  }
-
-  @Test
-  public void testBuilderEnumFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  @Component.Builder",
-            "  enum Builder {}",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.mustBeClassOrInterface()).inFile(componentFile);
-  }
-
-  @Test
-  public void testBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    String build();",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(MSGS.buildMustReturnComponentType())
-        .inFile(componentFile)
-        .onLineContaining("String build();");
-  }
-
-  @Test
-  public void builderMethodTakesPrimitive() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  Object object();",
-            "",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    Builder primitive(long l);",
-            "    TestComponent build();",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@Component.Builder methods that are not annotated with @BindsInstance must take "
-                + "either a module or a component dependency, not a primitive")
-        .inFile(component)
-        .onLineContaining("primitive(long l);");
-  }
-
-  @Test
-  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  interface Parent {",
-            "    String build();",
-            "  }",
-            "",
-            "  @Component.Builder",
-            "  interface Builder extends Parent {}",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
-        .inFile(componentFile)
-        .onLineContaining("interface Builder");
-  }
-
-  @Test
-  public void testTwoBuildMethodsFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
-            "    SimpleComponent create();",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(String.format(MSGS.twoBuildMethods(), "build"))
-        .inFile(componentFile)
-        .onLineContaining("SimpleComponent create();");
-  }
-
-  @Test
-  public void testInheritedTwoBuildMethodsFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  interface Parent {",
-            "    SimpleComponent build();",
-            "    SimpleComponent create();",
-            "  }",
-            "",
-            "  @Component.Builder",
-            "  interface Builder extends Parent {}",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
-        .inFile(componentFile)
-        .onLineContaining("interface Builder");
-  }
-
-  @Test
-  public void testMoreThanOneArgFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
-            "    Builder set(String s, Integer i);",
-            "    Builder set(Number n, Double d);",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(MSGS.methodsMustTakeOneArg())
-        .inFile(componentFile)
-        .onLineContaining("Builder set(String s, Integer i);");
-    assertThat(compilation)
-        .hadErrorContaining(MSGS.methodsMustTakeOneArg())
-        .inFile(componentFile)
-        .onLineContaining("Builder set(Number n, Double d);");
-  }
-
-  @Test
-  public void testInheritedMoreThanOneArgFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  interface Parent {",
-            "    SimpleComponent build();",
-            "    Builder set1(String s, Integer i);",
-            "  }",
-            "",
-            "  @Component.Builder",
-            "  interface Builder extends Parent {}",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                MSGS.inheritedMethodsMustTakeOneArg(), "set1(java.lang.String,java.lang.Integer)"))
-        .inFile(componentFile)
-        .onLineContaining("interface Builder");
-  }
-
-  @Test
-  public void testSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
-            "    String set(Integer i);",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
-        .inFile(componentFile)
-        .onLineContaining("String set(Integer i);");
-  }
-
-  @Test
-  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  interface Parent {",
-            "    SimpleComponent build();",
-            "    String set(Integer i);",
-            "  }",
-            "",
-            "  @Component.Builder",
-            "  interface Builder extends Parent {}",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
-        .inFile(componentFile)
-        .onLineContaining("interface Builder");
-  }
-
-  @Test
-  public void testGenericsOnSetterMethodFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
-            "    <T> Builder set(T t);",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
-        .inFile(componentFile)
-        .onLineContaining("<T> Builder set(T t);");
-  }
-
-  @Test
-  public void testGenericsOnInheritedSetterMethodFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "abstract class SimpleComponent {",
-            "  interface Parent {",
-            "    SimpleComponent build();",
-            "    <T> Builder set(T t);",
-            "  }",
-            "",
-            "  @Component.Builder",
-            "  interface Builder extends Parent {}",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-        .inFile(componentFile)
-        .onLineContaining("interface Builder");
-  }
-
-  @Test
-  public void testMultipleSettersPerTypeFails() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  @Provides String s() { return \"\"; }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "abstract class SimpleComponent {",
-            "  abstract String s();",
-            "",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
-            "    void set1(TestModule s);",
-            "    void set2(TestModule s);",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                MSGS.manyMethodsForType(),
-                "test.TestModule",
-                "[set1(test.TestModule), set2(test.TestModule)]"))
-        .inFile(componentFile)
-        .onLineContaining("interface Builder");
-  }
-
-  @Test
-  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  @Provides String s() { return \"\"; }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "abstract class SimpleComponent {",
-            "  abstract String s();",
-            "",
-            "  interface Parent<T> {",
-            "    void set1(T t);",
-            "  }",
-            "",
-            "  @Component.Builder",
-            "  interface Builder extends Parent<TestModule> {",
-            "    SimpleComponent build();",
-            "    void set2(TestModule s);",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
-        .inFile(componentFile)
-        .onLineContaining("interface Builder");
-  }
-
-  @Test
-  public void testExtraSettersFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component(modules = AbstractModule.class)",
-            "abstract class SimpleComponent {",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
-            "    void abstractModule(AbstractModule abstractModule);",
-            "    void other(String s);",
-            "  }",
-            "}");
-    JavaFileObject abstractModule =
-        JavaFileObjects.forSourceLines(
-            "test.AbstractModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class AbstractModule {}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(componentFile, abstractModule);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                MSGS.extraSetters(),
-                "[void test.SimpleComponent.Builder.abstractModule(test.AbstractModule), "
-                    + "void test.SimpleComponent.Builder.other(String)]"))
-        .inFile(componentFile)
-        .onLineContaining("interface Builder");
-  }
-
-  @Test
-  public void testMissingSettersFail() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  TestModule(String unused) {}",
-            "  @Provides String s() { return null; }",
-            "}");
-    JavaFileObject module2File =
-        JavaFileObjects.forSourceLines(
-            "test.Test2Module",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class Test2Module {",
-            "  @Provides Integer i() { return null; }",
-            "}");
-    JavaFileObject module3File =
-        JavaFileObjects.forSourceLines(
-            "test.Test3Module",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class Test3Module {",
-            "  Test3Module(String unused) {}",
-            "  @Provides Double d() { return null; }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
-            "           dependencies = OtherComponent.class)",
-            "interface TestComponent {",
-            "  String string();",
-            "  Integer integer();",
-            "",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    TestComponent create();",
-            "  }",
-            "}");
-    JavaFileObject otherComponent =
-        JavaFileObjects.forSourceLines(
-            "test.OtherComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface OtherComponent {}");
-    Compilation compilation =
-        daggerCompiler()
-            .compile(moduleFile, module2File, module3File, componentFile, otherComponent);
-    assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            // Ignores Test2Module because we can construct it ourselves.
-            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
-            String.format(
-                MSGS.missingSetters(), "[test.TestModule, test.Test3Module, test.OtherComponent]"))
+            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
         .inFile(componentFile)
         .onLineContaining("interface Builder");
   }
-
-  @Test
-  public void covariantBuildMethodReturnType() {
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Foo {",
-            "  @Inject Foo() {}",
-            "}");
-    JavaFileObject supertype =
-        JavaFileObjects.forSourceLines(
-            "test.Supertype",
-            "package test;",
-            "",
-            "interface Supertype {",
-            "  Foo foo();",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.HasSupertype",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface HasSupertype extends Supertype {",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    Supertype build();",
-            "  }",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(foo, supertype, component);
-    assertThat(compilation).succeededWithoutWarnings();
-  }
-
-  @Test
-  public void covariantBuildMethodReturnType_hasNewMethod() {
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Foo {",
-            "  @Inject Foo() {}",
-            "}");
-    JavaFileObject bar =
-        JavaFileObjects.forSourceLines(
-            "test.Bar",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Bar {",
-            "  @Inject Bar() {}",
-            "}");
-    JavaFileObject supertype =
-        JavaFileObjects.forSourceLines(
-            "test.Supertype",
-            "package test;",
-            "",
-            "interface Supertype {",
-            "  Foo foo();",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.HasSupertype",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface HasSupertype extends Supertype {",
-            "  Bar bar();",
-            "",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    Supertype build();",
-            "  }",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(foo, bar, supertype, component);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .hadWarningContaining(
-            "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
-                + "declares additional component method(s): bar(). In order to provide type-safe "
-                + "access to these methods, override build() to return test.HasSupertype")
-        .inFile(component)
-        .onLine(11);
-  }
-
-  @Test
-  public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Foo {",
-            "  @Inject Foo() {}",
-            "}");
-    JavaFileObject bar =
-        JavaFileObjects.forSourceLines(
-            "test.Bar",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Bar {",
-            "  @Inject Bar() {}",
-            "}");
-    JavaFileObject supertype =
-        JavaFileObjects.forSourceLines(
-            "test.Supertype",
-            "package test;",
-            "",
-            "interface Supertype {",
-            "  Foo foo();",
-            "}");
-
-    JavaFileObject builderSupertype =
-        JavaFileObjects.forSourceLines(
-            "test.BuilderSupertype",
-            "package test;",
-            "",
-            "interface BuilderSupertype {",
-            "  Supertype build();",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.HasSupertype",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface HasSupertype extends Supertype {",
-            "  Bar bar();",
-            "",
-            "  @Component.Builder",
-            "  interface Builder extends BuilderSupertype {}",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(foo, bar, supertype, builderSupertype, component);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .hadWarningContaining(
-            "[test.BuilderSupertype.build()] test.HasSupertype.Builder.build() returns "
-                + "test.Supertype, but test.HasSupertype declares additional component method(s): "
-                + "bar(). In order to provide type-safe access to these methods, override build() "
-                + "to return test.HasSupertype");
-  }
 }
diff --git a/javatests/dagger/internal/codegen/ComponentCreatorTest.java b/javatests/dagger/internal/codegen/ComponentCreatorTest.java
new file mode 100644
index 000000000..aa0f2696c
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ComponentCreatorTest.java
@@ -0,0 +1,1325 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
+import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
+import static dagger.internal.codegen.ComponentCreatorKind.FACTORY;
+import static dagger.internal.codegen.ComponentKind.COMPONENT;
+import static dagger.internal.codegen.ErrorMessages.componentMessagesFor;
+import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+import static java.util.stream.Collectors.joining;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Stream;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+/** Tests for properties of component creators shared by both builders and factories. */
+@RunWith(Parameterized.class)
+public class ComponentCreatorTest {
+  @Parameters(name = "compilerMode={0}, creatorKind={1}")
+  public static Collection<Object[]> parameters() {
+    Set<List<Object>> params =
+        Sets.<Object>cartesianProduct(
+            Sets.immutableEnumSet(DEFAULT_MODE, FAST_INIT_MODE),
+            EnumSet.allOf(ComponentCreatorKind.class));
+    return ImmutableList.copyOf(Iterables.transform(params, Collection::toArray));
+  }
+
+  private final CompilerMode compilerMode;
+  private final ComponentCreatorKind creatorKind;
+
+  private final ErrorMessages.ComponentCreatorMessages messages;
+
+  public ComponentCreatorTest(CompilerMode compilerMode, ComponentCreatorKind creatorKind) {
+    this.compilerMode = compilerMode;
+    this.creatorKind = creatorKind;
+    this.messages = creatorMessagesFor(COMPONENT, creatorKind);
+  }
+
+  // For tests where code for both builders and factories can be largely equivalent, i.e. when there
+  // is nothing to set, just preprocess the lines to change code written for a builder to code for a
+  // factory.
+  // For more complicated code, use a JavaFileBuilder to add different code depending on the creator
+  // kind.
+
+  private String process(String... lines) {
+    Stream<String> stream = Arrays.stream(lines);
+    if (creatorKind.equals(FACTORY)) {
+      stream =
+          stream.map(
+              line ->
+                  line.replace("Builder", "Factory")
+                      .replace("builder", "factory")
+                      .replace("build", "create"));
+    }
+    return stream.collect(joining("\n"));
+  }
+
+  private JavaFileObject preprocessedJavaFile(String fullyQualifiedName, String... lines) {
+    return JavaFileObjects.forSourceString(fullyQualifiedName, process(lines));
+  }
+
+  /** Returns a file builder for the current creator kind. */
+  private JavaFileBuilder javaFileBuilder(String qualifiedName) {
+    return new JavaFileBuilder(qualifiedName).withSettings(compilerMode, creatorKind);
+  }
+
+  @Test
+  public void testEmptyCreator() {
+    JavaFileObject injectableTypeFile =
+        JavaFileObjects.forSourceLines(
+            "test.SomeInjectableType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class SomeInjectableType {",
+            "  @Inject SomeInjectableType() {}",
+            "}");
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  SomeInjectableType someInjectableType();",
+            "",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        preprocessedJavaFile(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private static final class Builder implements SimpleComponent.Builder {",
+            "    @Override",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent();",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .containsElementsIn(generatedComponent);
+  }
+
+  @Test
+  public void testCanInstantiateModulesUserCannotSet() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String string() { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        preprocessedJavaFile(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private final TestModule testModule;",
+            "",
+            "  private DaggerTestComponent(TestModule testModuleParam) {",
+            "    this.testModule = testModuleParam;",
+            "  }",
+            "",
+            "  public static TestComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return TestModule_StringFactory.string(testModule);",
+            "  }",
+            "",
+            "  private static final class Builder implements TestComponent.Builder {",
+            "    @Override",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(new TestModule());",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void testMoreThanOneCreatorOfSameTypeFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder2 {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                componentMessagesFor(COMPONENT).moreThanOne(),
+                process("[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]")))
+        .inFile(componentFile);
+  }
+
+  @Test
+  public void testBothBuilderAndFactoryFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "",
+            "  @Component.Factory",
+            "  interface Factory {",
+            "     SimpleComponent create();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                componentMessagesFor(COMPONENT).moreThanOne(),
+                "[test.SimpleComponent.Builder, test.SimpleComponent.Factory]"))
+        .inFile(componentFile);
+  }
+
+  @Test
+  public void testGenericCreatorTypeFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder<T> {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(messages.generics()).inFile(componentFile);
+  }
+
+  @Test
+  public void testCreatorNotInComponentFails() {
+    JavaFileObject builder =
+        preprocessedJavaFile(
+            "test.Builder",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component.Builder",
+            "interface Builder {}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(builder);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(messages.mustBeInComponent()).inFile(builder);
+  }
+
+  @Test
+  public void testCreatorMissingFactoryMethodFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {}",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.missingFactoryMethod())
+        .inFile(componentFile);
+  }
+
+  @Test
+  public void testCreatorWithBindsInstanceNoStaticCreateGenerated() {
+    JavaFileObject componentFile =
+        javaFileBuilder("test.SimpleComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.BindsInstance;",
+                "import dagger.Component;",
+                "import javax.inject.Provider;",
+                "",
+                "@Component",
+                "interface SimpleComponent {",
+                "  Object object();",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  @Component.Builder",
+                "  interface Builder {",
+                "    @BindsInstance Builder object(Object object);",
+                "    SimpleComponent build();",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  @Component.Factory",
+                "  interface Factory {",
+                "    SimpleComponent create(@BindsInstance Object object);",
+                "  }")
+            .addLines("}")
+            .build();
+
+    JavaFileObject generatedComponent =
+        javaFileBuilder("test.DaggerSimpleComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                IMPORT_GENERATED_ANNOTATION,
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private final Object object;",
+                "",
+                "  private DaggerSimpleComponent(Object objectParam) {",
+                "    this.object = objectParam;",
+                "  }",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  public static SimpleComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  public static SimpleComponent.Factory factory() {",
+                "    return new Factory();",
+                "  }")
+            .addLines(
+                "", //
+                "  @Override",
+                "  public Object object() {",
+                "    return object;",
+                "  }",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  private static final class Builder implements SimpleComponent.Builder {",
+                "    private Object object;",
+                "",
+                "    @Override",
+                "    public Builder object(Object object) {",
+                "      this.object = Preconditions.checkNotNull(object);",
+                "      return this;",
+                "    }",
+                "",
+                "    @Override",
+                "    public SimpleComponent build() {",
+                "      Preconditions.checkBuilderRequirement(object, Object.class);",
+                "      return new DaggerSimpleComponent(object);",
+                "    }",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  private static final class Factory implements SimpleComponent.Factory {",
+                "    @Override",
+                "    public SimpleComponent create(Object object) {",
+                "      Preconditions.checkNotNull(object);",
+                "      return new DaggerSimpleComponent(object);",
+                "    }",
+                "  }")
+            .addLines("}")
+            .build();
+
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void testCreatorWithPrimitiveBindsInstance() {
+    JavaFileObject componentFile =
+        javaFileBuilder("test.SimpleComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.BindsInstance;",
+                "import dagger.Component;",
+                "import javax.inject.Provider;",
+                "",
+                "@Component",
+                "interface SimpleComponent {",
+                "  int anInt();",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  @Component.Builder",
+                "  interface Builder {",
+                "    @BindsInstance Builder i(int i);",
+                "    SimpleComponent build();",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  @Component.Factory",
+                "  interface Factory {",
+                "    SimpleComponent create(@BindsInstance int i);",
+                "  }")
+            .addLines(
+                "}")
+            .build();
+
+    JavaFileObject generatedComponent =
+        javaFileBuilder("test.DaggerSimpleComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                IMPORT_GENERATED_ANNOTATION,
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private final Integer i;",
+                "",
+                "  private DaggerSimpleComponent(Integer iParam) {",
+                "    this.i = iParam;",
+                "  }",
+                "",
+                "  @Override",
+                "  public int anInt() {",
+                "    return i;",
+                "  }",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  private static final class Builder implements SimpleComponent.Builder {",
+                "    private Integer i;",
+                "",
+                "    @Override",
+                "    public Builder i(int i) {",
+                "      this.i = Preconditions.checkNotNull(i);",
+                "      return this;",
+                "    }",
+                "",
+                "    @Override",
+                "    public SimpleComponent build() {",
+                "      Preconditions.checkBuilderRequirement(i, Integer.class);",
+                "      return new DaggerSimpleComponent(i);",
+                "    }",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  private static final class Factory implements SimpleComponent.Factory {",
+                "    @Override",
+                "    public SimpleComponent create(int i) {",
+                "      Preconditions.checkNotNull(i);",
+                "      return new DaggerSimpleComponent(i);",
+                "    }",
+                "  }")
+            .addLines(
+                "}")
+            .build();
+
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .containsElementsIn(generatedComponent);
+  }
+
+  @Test
+  public void testPrivateCreatorFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  private interface Builder {}",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(messages.isPrivate()).inFile(componentFile);
+  }
+
+  @Test
+  public void testNonStaticCreatorFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  abstract class Builder {}",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(messages.mustBeStatic()).inFile(componentFile);
+  }
+
+  @Test
+  public void testNonAbstractCreatorFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static class Builder {}",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(messages.mustBeAbstract()).inFile(componentFile);
+  }
+
+  @Test
+  public void testCreatorOneConstructorWithArgsFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static abstract class Builder {",
+            "    Builder(String unused) {}",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.invalidConstructor())
+        .inFile(componentFile);
+  }
+
+  @Test
+  public void testCreatorMoreThanOneConstructorFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static abstract class Builder {",
+            "    Builder() {}",
+            "    Builder(String unused) {}",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.invalidConstructor())
+        .inFile(componentFile);
+  }
+
+  @Test
+  public void testCreatorEnumFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  enum Builder {}",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.mustBeClassOrInterface())
+        .inFile(componentFile);
+  }
+
+  @Test
+  public void testCreatorFactoryMethodReturnsWrongTypeFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    String build();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.factoryMethodMustReturnComponentType())
+        .inFile(componentFile)
+        .onLineContaining(process("String build();"));
+  }
+
+  @Test
+  public void testCreatorSetterForNonBindsInstancePrimitiveFails() {
+    JavaFileObject component =
+        javaFileBuilder("test.TestComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "",
+                "@Component",
+                "interface TestComponent {",
+                "  Object object();",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  @Component.Builder",
+                "  interface Builder {",
+                "    Builder primitive(long l);",
+                "    TestComponent build();",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  @Component.Factory",
+                "  interface Factory {",
+                "    TestComponent create(long l);",
+                "  }")
+            .addLines( //
+                "}")
+            .build();
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
+    assertThat(compilation).failed();
+
+    assertThat(compilation)
+        .hadErrorContaining(messages.nonBindsInstanceParametersMayNotBePrimitives())
+        .inFile(component)
+        .onLineContaining("(long l)");
+  }
+
+  @Test
+  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    String build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                messages.inheritedFactoryMethodMustReturnComponentType(), process("build")))
+        .inFile(componentFile)
+        .onLineContaining(process("interface Builder"));
+  }
+
+  @Test
+  public void testTwoFactoryMethodsFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    SimpleComponent newSimpleComponent();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(messages.twoFactoryMethods(), process("build")))
+        .inFile(componentFile)
+        .onLineContaining("SimpleComponent newSimpleComponent();");
+  }
+
+  @Test
+  public void testInheritedTwoBuildMethodsFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    SimpleComponent newSimpleComponent();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                messages.inheritedTwoFactoryMethods(), process("build()"), "newSimpleComponent()"))
+        .inFile(componentFile)
+        .onLineContaining(process("interface Builder"));
+  }
+
+  @Test
+  public void testMultipleSettersPerTypeFails() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        javaFileBuilder("test.SimpleComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "import javax.inject.Provider;",
+                "",
+                "@Component(modules = TestModule.class)",
+                "abstract class SimpleComponent {",
+                "  abstract String s();",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  @Component.Builder",
+                "  interface Builder {",
+                "    SimpleComponent build();",
+                "    void set1(TestModule s);",
+                "    void set2(TestModule s);",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  @Component.Factory",
+                "  interface Factory {",
+                "    SimpleComponent create(TestModule m1, TestModule m2);",
+                "  }")
+            .addLines( //
+                "}")
+            .build();
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
+    assertThat(compilation).failed();
+    String elements =
+        creatorKind.equals(BUILDER)
+            ? "[void test.SimpleComponent.Builder.set1(test.TestModule), "
+                + "void test.SimpleComponent.Builder.set2(test.TestModule)]"
+            : "[test.TestModule m1, test.TestModule m2]";
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                messages.multipleSettersForModuleOrDependencyType(), "test.TestModule", elements))
+        .inFile(componentFile)
+        .onLineContaining(process("interface Builder"));
+  }
+
+  @Test
+  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        javaFileBuilder("test.SimpleComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "import javax.inject.Provider;",
+                "",
+                "@Component(modules = TestModule.class)",
+                "abstract class SimpleComponent {",
+                "  abstract String s();",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  interface Parent<T> {",
+                "    void set1(T t);",
+                "  }",
+                "",
+                "  @Component.Builder",
+                "  interface Builder extends Parent<TestModule> {",
+                "    SimpleComponent build();",
+                "    void set2(TestModule s);",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  interface Parent<C, T> {",
+                "    C create(TestModule m1, T t);",
+                "  }",
+                "",
+                "  @Component.Factory",
+                "  interface Factory extends Parent<SimpleComponent, TestModule> {}")
+            .addLines( //
+                "}")
+            .build();
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
+    assertThat(compilation).failed();
+    String elements =
+        creatorKind.equals(BUILDER)
+            ? "[void test.SimpleComponent.Builder.set1(test.TestModule), "
+                + "void test.SimpleComponent.Builder.set2(test.TestModule)]"
+            : "[test.TestModule m1, test.TestModule t]";
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                messages.multipleSettersForModuleOrDependencyType(), "test.TestModule", elements))
+        .inFile(componentFile)
+        .onLineContaining(process("interface Builder"));
+  }
+
+  @Test
+  public void testExtraSettersFails() {
+    JavaFileObject componentFile =
+        javaFileBuilder("test.SimpleComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "import javax.inject.Provider;",
+                "",
+                "@Component(modules = AbstractModule.class)",
+                "abstract class SimpleComponent {")
+            .addLinesIf(
+                BUILDER,
+                "  @Component.Builder",
+                "  interface Builder {",
+                "    SimpleComponent build();",
+                "    void abstractModule(AbstractModule abstractModule);",
+                "    void other(String s);",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  @Component.Factory",
+                "  interface Factory {",
+                "    SimpleComponent create(AbstractModule abstractModule, String s);",
+                "  }")
+            .addLines("}")
+            .build();
+    JavaFileObject abstractModule =
+        JavaFileObjects.forSourceLines(
+            "test.AbstractModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class AbstractModule {}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(componentFile, abstractModule);
+    assertThat(compilation).failed();
+    String elements =
+        creatorKind.equals(BUILDER)
+            ? "[void test.SimpleComponent.Builder.abstractModule(test.AbstractModule), "
+                + "void test.SimpleComponent.Builder.other(String)]"
+            : "[test.AbstractModule abstractModule, String s]";
+    assertThat(compilation)
+        .hadErrorContaining(String.format(messages.extraSetters(), elements))
+        .inFile(componentFile)
+        .onLineContaining(process("interface Builder"));
+  }
+
+  @Test
+  public void testMissingSettersFail() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  TestModule(String unused) {}",
+            "  @Provides String s() { return null; }",
+            "}");
+    JavaFileObject module2File =
+        JavaFileObjects.forSourceLines(
+            "test.Test2Module",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class Test2Module {",
+            "  @Provides Integer i() { return null; }",
+            "}");
+    JavaFileObject module3File =
+        JavaFileObjects.forSourceLines(
+            "test.Test3Module",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class Test3Module {",
+            "  Test3Module(String unused) {}",
+            "  @Provides Double d() { return null; }",
+            "}");
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
+            "           dependencies = OtherComponent.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "  Integer integer();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    TestComponent create();",
+            "  }",
+            "}");
+    JavaFileObject otherComponent =
+        JavaFileObjects.forSourceLines(
+            "test.OtherComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface OtherComponent {}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(moduleFile, module2File, module3File, componentFile, otherComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            // Ignores Test2Module because we can construct it ourselves.
+            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
+            String.format(
+                messages.missingSetters(),
+                "[test.TestModule, test.Test3Module, test.OtherComponent]"))
+        .inFile(componentFile)
+        .onLineContaining(process("interface Builder"));
+  }
+
+  @Test
+  public void covariantFactoryMethodReturnType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject component =
+        preprocessedJavaFile(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(foo, supertype, component);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void covariantFactoryMethodReturnType_hasNewMethod() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject component =
+        preprocessedJavaFile(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, bar, supertype, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            process(
+                "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                    + "declares additional component method(s): bar(). In order to provide "
+                    + "type-safe access to these methods, override build() to return "
+                    + "test.HasSupertype"))
+        .inFile(component)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantFactoryMethodReturnType_hasNewMethod_factoryMethodInherited() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject creatorSupertype =
+        preprocessedJavaFile(
+            "test.CreatorSupertype",
+            "package test;",
+            "",
+            "interface CreatorSupertype {",
+            "  Supertype build();",
+            "}");
+
+    JavaFileObject component =
+        preprocessedJavaFile(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends CreatorSupertype {}",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, bar, supertype, creatorSupertype, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            process(
+                "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                    + "declares additional component method(s): bar(). In order to provide "
+                    + "type-safe access to these methods, override build() to return "
+                    + "test.HasSupertype"));
+  }
+
+  @Test
+  public void testGenericsOnFactoryMethodFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    <T> SimpleComponent build();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.methodsMayNotHaveTypeParameters())
+        .inFile(componentFile)
+        .onLineContaining(process("<T> SimpleComponent build();"));
+  }
+
+  @Test
+  public void testGenericsOnInheritedFactoryMethodFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    <T> SimpleComponent build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                messages.inheritedMethodsMayNotHaveTypeParameters(), process("<T>build()")))
+        .inFile(componentFile)
+        .onLineContaining(process("interface Builder"));
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ComponentFactoryTest.java b/javatests/dagger/internal/codegen/ComponentFactoryTest.java
new file mode 100644
index 000000000..aadc5ec57
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ComponentFactoryTest.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.ComponentCreatorKind.FACTORY;
+import static dagger.internal.codegen.ComponentKind.COMPONENT;
+import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+/** Tests for {@link dagger.Component.Factory} */
+@RunWith(Parameterized.class)
+public class ComponentFactoryTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public ComponentFactoryTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  private static final ErrorMessages.ComponentCreatorMessages MSGS =
+      creatorMessagesFor(COMPONENT, FACTORY);
+
+  @Test
+  public void testUsesParameterNames() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String string() { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "",
+            "  @Component.Factory",
+            "  interface Factory {",
+            "    TestComponent newTestComponent(TestModule mod);",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private static final class Factory implements TestComponent.Factory {",
+            "    @Override",
+            "    public TestComponent newTestComponent(TestModule mod) {",
+            "      Preconditions.checkNotNull(mod);",
+            "      return new DaggerTestComponent(mod);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(generatedComponent);
+  }
+
+  @Test
+  public void testSetterMethodFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Factory",
+            "  interface Factory {",
+            "    SimpleComponent create();",
+            "    Factory set(String s);",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.twoFactoryMethods(), "create()"))
+        .inFile(componentFile)
+        .onLineContaining("Factory set(String s);");
+  }
+
+  @Test
+  public void testInheritedSetterMethodFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent create();",
+            "    Parent set(String s);",
+            "  }",
+            "",
+            "  @Component.Factory",
+            "  interface Factory extends Parent {}",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.twoFactoryMethods(), "create()"))
+        .inFile(componentFile)
+        .onLineContaining("interface Factory");
+  }
+}
diff --git a/javatests/dagger/internal/codegen/JavaFileBuilder.java b/javatests/dagger/internal/codegen/JavaFileBuilder.java
index 9f2ef2797..f682b0c37 100644
--- a/javatests/dagger/internal/codegen/JavaFileBuilder.java
+++ b/javatests/dagger/internal/codegen/JavaFileBuilder.java
@@ -17,32 +17,57 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
 import javax.tools.JavaFileObject;
 
 /**
- * A fluent API to build a {@link JavaFileObject} appropriate for the current {@linkplain
- * CompilerMode compiler mode}.
+ * A fluent API to build a {@link JavaFileObject} appropriate for a current set of settings, such as
+ * compiler mode.
  *
  * <p>After creating a builder, you can add lines to the file. Call {@link #addLines(String...)} to
- * add lines irrespective of the compiler mode. If you want to add different lines for each mode,
- * call {@link #addLinesIn(CompilerMode, String...)}.
+ * add lines irrespective of the settings. If you want to add different lines for different possible
+ * settings, call {@link #addLinesIf(Object, String...)} to add those lines only if the given
+ * setting has been added via {@link #withSetting(Object)} or {@link #withSettings(Object...)}.
  */
 final class JavaFileBuilder {
-  private final CompilerMode compilerMode;
   private final String qualifiedName;
+  private final Set<Object> settings = new HashSet<>();
+
   private final ImmutableList.Builder<String> sourceLines = ImmutableList.builder();
 
   /** Creates a builder for a file whose top level type has a given qualified name. */
-  JavaFileBuilder(CompilerMode compilerMode, String qualifiedName) {
+  JavaFileBuilder(String qualifiedName) {
     checkArgument(!qualifiedName.isEmpty());
-    this.compilerMode = checkNotNull(compilerMode);
     this.qualifiedName = qualifiedName;
   }
 
+  // TODO(cgdecker): Get rid of the special constructor/method for CompilerMode
+
+  /** Creates a builder for a file whose top level type has a given qualified name. */
+  JavaFileBuilder(CompilerMode compilerMode, String qualifiedName) {
+    this(qualifiedName);
+    settings.add(compilerMode);
+  }
+
+  /** Adds the given setting as one that code should be generated for. */
+  JavaFileBuilder withSetting(Object setting) {
+    this.settings.add(setting);
+    return this;
+  }
+
+  /** Adds the given settings as one that code should be generated for. */
+  JavaFileBuilder withSettings(Object s1, Object s2, Object... more) {
+    settings.add(s1);
+    settings.add(s2);
+    Collections.addAll(settings, more);
+    return this;
+  }
+
   /** Adds lines no matter what the {@link CompilerMode} is. */
   JavaFileBuilder addLines(String... lines) {
     sourceLines.add(lines);
@@ -51,7 +76,12 @@ JavaFileBuilder addLines(String... lines) {
 
   /** Adds lines if in the given mode. */
   JavaFileBuilder addLinesIn(CompilerMode mode, String... lines) {
-    if (compilerMode.equals(mode)) {
+    return addLinesIf(mode, lines);
+  }
+
+  /** Adds lines if in the given setting is set. */
+  JavaFileBuilder addLinesIf(Object setting, String... lines) {
+    if (settings.contains(setting)) {
       sourceLines.add(lines);
     }
     return this;
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index e6fe41026..0e10dfb13 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -18,6 +18,11 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
+import static dagger.internal.codegen.ComponentKind.SUBCOMPONENT;
+import static dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages.moreThanOneRefToSubcomponent;
+import static dagger.internal.codegen.ErrorMessages.componentMessagesFor;
+import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
 import static dagger.internal.codegen.TestUtils.message;
 
 import com.google.testing.compile.Compilation;
@@ -31,8 +36,8 @@
 @RunWith(JUnit4.class)
 public class SubcomponentBuilderValidationTest {
 
-  private static final ErrorMessages.SubcomponentCreatorMessages MSGS =
-      new ErrorMessages.SubcomponentCreatorMessages();
+  private static final ErrorMessages.ComponentCreatorMessages MSGS =
+      creatorMessagesFor(SUBCOMPONENT, BUILDER);
 
   @Test
   public void testRefSubcomponentAndSubBuilderFails() {
@@ -64,7 +69,7 @@ public void testRefSubcomponentAndSubBuilderFails() {
     assertThat(compilation)
         .hadErrorContaining(
             String.format(
-                MSGS.moreThanOneRefToSubcomponent(), "test.ChildComponent", "[child(), builder()]"))
+                moreThanOneRefToSubcomponent(), "test.ChildComponent", "[child(), builder()]"))
         .inFile(componentFile);
   }
 
@@ -98,9 +103,7 @@ public void testRefSubBuilderTwiceFails() {
     assertThat(compilation)
         .hadErrorContaining(
             String.format(
-                MSGS.moreThanOneRefToSubcomponent(),
-                "test.ChildComponent",
-                "[builder1(), builder2()]"))
+                moreThanOneRefToSubcomponent(), "test.ChildComponent", "[builder1(), builder2()]"))
         .inFile(componentFile);
   }
 
@@ -138,7 +141,8 @@ public void testMoreThanOneBuilderFails() {
     assertThat(compilation)
         .hadErrorContaining(
             String.format(
-                MSGS.moreThanOne(), "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
+                componentMessagesFor(SUBCOMPONENT).moreThanOne(),
+                "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
         .inFile(childComponentFile);
   }
 
@@ -210,7 +214,7 @@ public void testBuilderMissingBuildMethodFails() {
     Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(MSGS.missingBuildMethod())
+        .hadErrorContaining(MSGS.missingFactoryMethod())
         .inFile(childComponentFile);
   }
 
@@ -282,7 +286,7 @@ public void testBuilderOneCxtorWithArgsFails() {
     Compilation compilation = daggerCompiler().compile(childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .hadErrorContaining(MSGS.invalidConstructor())
         .inFile(childComponentFile);
   }
 
@@ -304,7 +308,7 @@ public void testBuilderMoreThanOneCxtorFails() {
     Compilation compilation = daggerCompiler().compile(childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .hadErrorContaining(MSGS.invalidConstructor())
         .inFile(childComponentFile);
   }
 
@@ -344,7 +348,7 @@ public void testBuilderBuildReturnsWrongTypeFails() {
     Compilation compilation = daggerCompiler().compile(childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(MSGS.buildMustReturnComponentType())
+        .hadErrorContaining(MSGS.factoryMethodMustReturnComponentType())
         .inFile(childComponentFile)
         .onLine(9);
   }
@@ -368,7 +372,8 @@ public void testInheritedBuilderBuildReturnsWrongTypeFails() {
     Compilation compilation = daggerCompiler().compile(childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+        .hadErrorContaining(
+            String.format(MSGS.inheritedFactoryMethodMustReturnComponentType(), "build"))
         .inFile(childComponentFile)
         .onLine(12);
   }
@@ -391,7 +396,7 @@ public void testTwoBuildMethodsFails() {
     Compilation compilation = daggerCompiler().compile(childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
+        .hadErrorContaining(String.format(MSGS.twoFactoryMethods(), "build()"))
         .inFile(childComponentFile)
         .onLine(10);
   }
@@ -416,7 +421,7 @@ public void testInheritedTwoBuildMethodsFails() {
     Compilation compilation = daggerCompiler().compile(childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
+        .hadErrorContaining(String.format(MSGS.inheritedTwoFactoryMethods(), "build()", "create()"))
         .inFile(childComponentFile)
         .onLine(13);
   }
@@ -440,11 +445,11 @@ public void testMoreThanOneArgFails() {
     Compilation compilation = daggerCompiler().compile(childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(MSGS.methodsMustTakeOneArg())
+        .hadErrorContaining(MSGS.setterMethodsMustTakeOneArg())
         .inFile(childComponentFile)
         .onLine(10);
     assertThat(compilation)
-        .hadErrorContaining(MSGS.methodsMustTakeOneArg())
+        .hadErrorContaining(MSGS.setterMethodsMustTakeOneArg())
         .inFile(childComponentFile)
         .onLine(11);
   }
@@ -471,7 +476,8 @@ public void testInheritedMoreThanOneArgFails() {
     assertThat(compilation)
         .hadErrorContaining(
             String.format(
-                MSGS.inheritedMethodsMustTakeOneArg(), "set1(java.lang.String,java.lang.Integer)"))
+                MSGS.inheritedSetterMethodsMustTakeOneArg(),
+                "set1(java.lang.String,java.lang.Integer)"))
         .inFile(childComponentFile)
         .onLine(13);
   }
@@ -494,7 +500,7 @@ public void testSetterReturningNonVoidOrBuilderFails() {
     Compilation compilation = daggerCompiler().compile(childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+        .hadErrorContaining(MSGS.setterMethodsMustReturnVoidOrBuilder())
         .inFile(childComponentFile)
         .onLine(10);
   }
@@ -520,7 +526,8 @@ public void testInheritedSetterReturningNonVoidOrBuilderFails() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
+            String.format(
+                MSGS.inheritedSetterMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
         .inFile(childComponentFile)
         .onLine(13);
   }
@@ -623,9 +630,10 @@ public void testMultipleSettersPerTypeFails() {
     assertThat(compilation)
         .hadErrorContaining(
             String.format(
-                MSGS.manyMethodsForType(),
+                MSGS.multipleSettersForModuleOrDependencyType(),
                 "test.TestModule",
-                "[set1(test.TestModule), set2(test.TestModule)]"))
+                "[void test.ChildComponent.Builder.set1(test.TestModule), "
+                    + "void test.ChildComponent.Builder.set2(test.TestModule)]"))
         .inFile(childComponentFile)
         .onLine(10);
   }
@@ -682,7 +690,10 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
     assertThat(compilation)
         .hadErrorContaining(
             String.format(
-                MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
+                MSGS.multipleSettersForModuleOrDependencyType(),
+                "test.TestModule",
+                "[void test.ChildComponent.Builder.set1(test.TestModule), "
+                    + "void test.ChildComponent.Builder.set2(test.TestModule)]"))
         .inFile(childComponentFile)
         .onLine(14);
   }
