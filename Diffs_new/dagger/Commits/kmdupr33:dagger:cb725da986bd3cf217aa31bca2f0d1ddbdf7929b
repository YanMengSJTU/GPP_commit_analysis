diff --git a/java/dagger/internal/SetBuilder.java b/java/dagger/internal/SetBuilder.java
index 2ca84628d..16bc589f7 100644
--- a/java/dagger/internal/SetBuilder.java
+++ b/java/dagger/internal/SetBuilder.java
@@ -37,7 +37,7 @@ private SetBuilder(int estimatedSize) {
   /**
    * {@code estimatedSize} is the number of bindings which contribute to the set. They may each
    * provide {@code [0..n)} instances to the set. Because the final size is unknown, {@code
-   * contributions} are collected in a list and only hashed in {@link #create()}.
+   * contributions} are collected in a list and only hashed in {@link #build()}.
    */
   public static <T> SetBuilder<T> newSetBuilder(int estimatedSize) {
     return new SetBuilder<T>(estimatedSize);
@@ -53,7 +53,7 @@ private SetBuilder(int estimatedSize) {
     return this;
   }
 
-  public Set<T> create() {
+  public Set<T> build() {
     switch (contributions.size()) {
       case 0:
         return Collections.emptySet();
diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 84b999ddd..193022a0d 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -174,7 +174,7 @@
     this.optionalFactories = optionalFactories;
     this.bindingExpressionFactory =
         new BindingExpression.Factory(
-            name, this, childComponentNames(keyFactory, subcomponentNames), graph);
+            name, this, childComponentNames(keyFactory, subcomponentNames), graph, elements);
   }
 
   private static ImmutableMap<BindingKey, String> childComponentNames(
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index c271b2f4b..fd43c8fad 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -30,6 +30,7 @@
 import dagger.internal.DelegateFactory;
 import java.util.Optional;
 import java.util.function.BiConsumer;
+import javax.lang.model.util.Elements;
 
 /** The code expressions to declare, initialize, and/or access a binding in a component. */
 final class BindingExpression extends RequestFulfillment {
@@ -57,16 +58,19 @@
     private final HasBindingExpressions hasBindingExpressions;
     private final ImmutableMap<BindingKey, String> subcomponentNames;
     private final BindingGraph graph;
+    private final Elements elements;
 
     Factory(
         ClassName componentName,
         HasBindingExpressions hasBindingExpressions,
         ImmutableMap<BindingKey, String> subcomponentNames,
-        BindingGraph graph) {
+        BindingGraph graph,
+        Elements elements) {
       this.componentName = checkNotNull(componentName);
       this.hasBindingExpressions = checkNotNull(hasBindingExpressions);
       this.subcomponentNames = checkNotNull(subcomponentNames);
       this.graph = checkNotNull(graph);
+      this.elements = elements;
     }
 
     /** Creates a binding expression for a field. */
@@ -112,7 +116,8 @@ private RequestFulfillment createRequestFulfillment(
                   provisionBinding,
                   graph,
                   hasBindingExpressions,
-                  providerFieldRequestFulfillment);
+                  providerFieldRequestFulfillment,
+                  elements);
             case INJECTION:
             case PROVISION:
               if (provisionBinding.implicitDependencies().isEmpty()
diff --git a/java/dagger/internal/codegen/SetBindingRequestFulfillment.java b/java/dagger/internal/codegen/SetBindingRequestFulfillment.java
index f5368e52e..502a15b41 100644
--- a/java/dagger/internal/codegen/SetBindingRequestFulfillment.java
+++ b/java/dagger/internal/codegen/SetBindingRequestFulfillment.java
@@ -17,14 +17,19 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.squareup.javapoet.CodeBlock.of;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 
+import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
 import dagger.internal.SetBuilder;
 import java.util.Collections;
+import java.util.Set;
+import java.util.function.Function;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 
 /**
  * A {@link RequestFulfillment} for {@link
@@ -34,24 +39,46 @@
   private final ProvisionBinding binding;
   private final BindingGraph graph;
   private final HasBindingExpressions hasBindingExpressions;
+  private final Elements elements;
 
   SetBindingRequestFulfillment(
       BindingKey bindingKey,
       ProvisionBinding binding,
       BindingGraph graph,
       HasBindingExpressions hasBindingExpressions,
-      RequestFulfillment delegate) {
+      RequestFulfillment delegate,
+      Elements elements) {
     super(bindingKey, delegate);
     this.binding = binding;
     this.graph = graph;
     this.hasBindingExpressions = hasBindingExpressions;
+    this.elements = elements;
   }
 
   @Override
   CodeBlock getSimpleInvocation(DependencyRequest request, ClassName requestingClass) {
-    // TODO(ronshapiro): if you have ImmutableSet on your classpath, use ImmutableSet.Builder
-    // otherwise, we can consider providing our own static factories for multibinding cases where
-    // all of the dependencies are @IntoSet
+    Function<DependencyRequest, CodeBlock> getRequestFulfillmentForDependency =
+        dependency ->
+            hasBindingExpressions
+                .getBindingExpression(dependency.bindingKey())
+                .getSnippetForDependencyRequest(dependency, requestingClass);
+
+    // TODO(ronshapiro): We should also make an ImmutableSet version of SetFactory
+    boolean isImmutableSetAvailable = isImmutableSetAvailable();
+    // TODO(ronshapiro, gak): Use Sets.immutableEnumSet() if it's available?
+    if (isImmutableSetAvailable && binding.dependencies().stream().allMatch(this::isSingleValue)) {
+      return CodeBlock.builder()
+          .add("$T.", ImmutableSet.class)
+          .add(maybeTypeParameter(request, requestingClass))
+          .add(
+              "of($L)",
+              binding
+                  .dependencies()
+                  .stream()
+                  .map(getRequestFulfillmentForDependency)
+                  .collect(toParametersCodeBlock()))
+          .build();
+    }
     switch (binding.dependencies().size()) {
       case 0:
         return collectionsStaticFactoryInvocation(
@@ -59,22 +86,30 @@ CodeBlock getSimpleInvocation(DependencyRequest request, ClassName requestingCla
       case 1:
         {
           DependencyRequest dependency = getOnlyElement(binding.dependencies());
+          CodeBlock dependencySnippet =
+              getRequestFulfillmentForDependency(dependency, requestingClass);
           if (isSingleValue(dependency)) {
             return collectionsStaticFactoryInvocation(
-                request,
-                requestingClass,
-                CodeBlock.of(
-                    "singleton($L)",
-                    getRequestFulfillmentForDependency(dependency, requestingClass)));
+                request, requestingClass, CodeBlock.of("singleton($L)", dependencySnippet));
+          } else if (isImmutableSetAvailable) {
+            return CodeBlock.builder()
+                .add("$T.", ImmutableSet.class)
+                .add(maybeTypeParameter(request, requestingClass))
+                .add("copyOf($L)", dependencySnippet)
+                .build();
           }
         }
         // fall through
       default:
         CodeBlock.Builder instantiation = CodeBlock.builder();
         instantiation
-            .add("$T.", SetBuilder.class)
-            .add(maybeTypeParameter(request, requestingClass))
-            .add("newSetBuilder($L)", binding.dependencies().size());
+            .add("$T.", isImmutableSetAvailable ? ImmutableSet.class : SetBuilder.class)
+            .add(maybeTypeParameter(request, requestingClass));
+        if (isImmutableSetAvailable) {
+          instantiation.add("builder()");
+        } else {
+          instantiation.add("newSetBuilder($L)", binding.dependencies().size());
+        }
         for (DependencyRequest dependency : binding.dependencies()) {
           String builderMethod = isSingleValue(dependency) ? "add" : "addAll";
           instantiation.add(
@@ -82,7 +117,7 @@ CodeBlock getSimpleInvocation(DependencyRequest request, ClassName requestingCla
               builderMethod,
               getRequestFulfillmentForDependency(dependency, requestingClass));
         }
-        return instantiation.add(".create()").build();
+        return instantiation.add(".build()").build();
     }
   }
 
@@ -106,8 +141,8 @@ private static CodeBlock maybeTypeParameter(
       DependencyRequest request, ClassName requestingClass) {
     TypeMirror elementType = SetType.from(request.key()).elementType();
     return isTypeAccessibleFrom(elementType, requestingClass.packageName())
-        ? of("<$T>", elementType)
-        : of("");
+        ? CodeBlock.of("<$T>", elementType)
+        : CodeBlock.of("");
   }
 
   private boolean isSingleValue(DependencyRequest dependency) {
@@ -118,4 +153,21 @@ private boolean isSingleValue(DependencyRequest dependency) {
         .contributionType()
         .equals(ContributionType.SET);
   }
+
+  private boolean isImmutableSetAvailable() {
+    return elements.getTypeElement(ImmutableSet.class.getCanonicalName()) != null;
+  }
+
+  @Override
+  protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
+    if (isImmutableSetAvailable()) {
+      TypeMirror keyType = binding.key().type();
+      return CodeBlock.of(
+          "<$T>",
+          isTypeAccessibleFrom(keyType, requestingClass.packageName())
+              ? TypeName.get(keyType)
+              : ClassName.get(Set.class));
+    }
+    return CodeBlock.of("");
+  }
 }
diff --git a/java/dagger/internal/codegen/SimpleInvocationRequestFulfillment.java b/java/dagger/internal/codegen/SimpleInvocationRequestFulfillment.java
index 0e430112c..94e19bd92 100644
--- a/java/dagger/internal/codegen/SimpleInvocationRequestFulfillment.java
+++ b/java/dagger/internal/codegen/SimpleInvocationRequestFulfillment.java
@@ -34,6 +34,17 @@
 
   abstract CodeBlock getSimpleInvocation(DependencyRequest request, ClassName requestingClass);
 
+  /**
+   * Java 7 type inference is not as strong as in Java 8, and therefore some generated code must
+   * make type parameters for {@link Futures#immediateFuture(Object)} explicit.
+   *
+   * <p>For example, {@code javac7} cannot detect that Futures.immediateFuture(ImmutableSet.of(T))}
+   * can safely be assigned to {@code ListenableFuture<Set<T>>}.
+   */
+  protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
+    return CodeBlock.of("");
+  }
+
   @Override
   final CodeBlock getSnippetForDependencyRequest(
       DependencyRequest request, ClassName requestingClass) {
@@ -41,8 +52,11 @@ final CodeBlock getSnippetForDependencyRequest(
       case INSTANCE:
         return getSimpleInvocation(request, requestingClass);
       case FUTURE:
-        return CodeBlock.of(
-            "$T.immediateFuture($L)", Futures.class, getSimpleInvocation(request, requestingClass));
+        return CodeBlock.builder()
+            .add("$T.", Futures.class)
+            .add(explicitTypeParameter(requestingClass))
+            .add("immediateFuture($L)", getSimpleInvocation(request, requestingClass))
+            .build();
       default:
         return delegate.getSnippetForDependencyRequest(request, requestingClass);
     }
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
index 67cad21eb..640a955b8 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
@@ -16,11 +16,16 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
+import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static java.util.stream.Collectors.joining;
 
+import com.google.common.base.Splitter;
 import com.google.testing.compile.Compilation;
+import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -117,7 +122,7 @@ public void setBindings() {
             "    return SetBuilder.<String>newSetBuilder(2)",
             "        .addAll(EmptySetModule.emptySet())",
             "        .add(SetModule.string())",
-            "        .create();",
+            "        .build();",
             "  }",
             "",
             "  @Override",
@@ -140,8 +145,7 @@ public void setBindings() {
             "    }",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler().compile(emptySetModuleFile, setModuleFile, componentFile);
+    Compilation compilation = compiler().compile(emptySetModuleFile, setModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -261,7 +265,7 @@ public void inaccessible() {
             "        Collections.emptySet(),",
             "        SetBuilder.newSetBuilder(1)",
             "            .addAll(TestModule_EmptySetFactory.proxyEmptySet())",
-            "            .create());",
+            "            .build());",
             "  }",
             "",
             "  public static final class Builder {",
@@ -274,8 +278,7 @@ public void inaccessible() {
             "  }",
             "}");
     Compilation compilation =
-        daggerCompiler()
-            .compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
+        compiler().compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -424,110 +427,24 @@ public void subcomponentOmitsInheritedBindings() {
             "    }",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
+    Compilation compilation = compiler().compile(parent, parentModule, child);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerParent")
         .hasSourceEquivalentTo(expected);
   }
 
-  @Test
-  public void productionComponents() {
-    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import java.util.Collections;",
-        "import java.util.Set;",
-        "",
-        "@Module",
-        "abstract class EmptySetModule {",
-        "  @Provides @ElementsIntoSet",
-        "  static Set<String> emptySet() { ",
-        "    return Collections.emptySet();",
-        "  }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProductionComponent;",
-        "import java.util.Set;",
-        "",
-        "@ProductionComponent(modules = EmptySetModule.class)",
-        "interface TestComponent {",
-        "  ListenableFuture<Set<String>> strings();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.Futures;",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetBuilder;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Set<String>> setOfStringProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.setOfStringProvider =",
-            "        SetFactory.<String>builder(0, 1)",
-            "            .addCollectionProvider(EmptySetModule_EmptySetFactory.create())",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public ListenableFuture<Set<String>> strings() {",
-            "    return Futures.immediateFuture(",
-            "        SetBuilder.<String>newSetBuilder(1)",
-            "            .addAll(EmptySetModule.emptySet())",
-            "            .create());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder testComponent_ProductionExecutorModule(",
-            "        TestComponent_ProductionExecutorModule",
-            "            testComponent_ProductionExecutorModule) {",
-            "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(emptySetModuleFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(generatedComponent);
+  private Compiler compiler() {
+    return daggerCompiler().withOptions("-classpath", classpathWithoutGuava());
+  }
+
+  private static final String GUAVA = "guava";
+
+  private String classpathWithoutGuava() {
+    return Splitter.on(PATH_SEPARATOR.value())
+        .splitToList(JAVA_CLASS_PATH.value())
+        .stream()
+        .filter(jar -> !jar.contains(GUAVA))
+        .collect(joining(":"));
   }
 }
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
new file mode 100644
index 000000000..cdef59c6e
--- /dev/null
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -0,0 +1,545 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SetBindingRequestFulfillmentWithGuavaTest {
+  @Test
+  public void setBindings() {
+    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
+        "import dagger.multibindings.Multibinds;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "abstract class EmptySetModule {",
+        "  @Multibinds abstract Set<Object> objects();",
+        "",
+        "  @Provides @ElementsIntoSet",
+        "  static Set<String> emptySet() { ",
+        "    return Collections.emptySet();",
+        "  }",
+        "  @Provides @ElementsIntoSet",
+        "  static Set<Integer> onlyContributionIsElementsIntoSet() { ",
+        "    return Collections.emptySet();",
+        "  }",
+        "}");
+    JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntoSet;",
+        "",
+        "@Module",
+        "final class SetModule {",
+        "  @Provides @IntoSet static String string() { return \"\"; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Set;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {EmptySetModule.class, SetModule.class})",
+        "interface TestComponent {",
+        "  Set<String> strings();",
+        "  Set<Object> objects();",
+        "  Set<Integer> onlyContributionIsElementsIntoSet();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.internal.Preconditions;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Set<String>> setOfStringProvider;",
+            "  private Provider<Set<Integer>> setOfIntegerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.setOfStringProvider = ",
+            "        SetFactory.<String>builder(1, 1)",
+            "            .addCollectionProvider(EmptySetModule_EmptySetFactory.create())",
+            "            .addProvider(SetModule_StringFactory.create())",
+            "            .build();",
+            "    this.setOfIntegerProvider = ",
+            "        SetFactory.<Integer>builder(0, 1)",
+            "            .addCollectionProvider(",
+            "                EmptySetModule_OnlyContributionIsElementsIntoSetFactory.create())",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Set<String> strings() {",
+            "    return ImmutableSet.<String>builder()",
+            "        .addAll(EmptySetModule.emptySet())",
+            "        .add(SetModule.string())",
+            "        .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Set<Object> objects() {",
+            "    return ImmutableSet.<Object>of();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Set<Integer> onlyContributionIsElementsIntoSet() {",
+            "    return ImmutableSet.<Integer>copyOf(",
+            "        EmptySetModule.onlyContributionIsElementsIntoSet());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder setModule(SetModule setModule) {",
+            "      Preconditions.checkNotNull(setModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(emptySetModuleFile, setModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void inaccessible() {
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible",
+            "package other;",
+            "",
+            "class Inaccessible {}");
+    JavaFileObject inaccessible2 =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible2",
+            "package other;",
+            "",
+            "class Inaccessible2 {}");
+    JavaFileObject usesInaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessible",
+            "package other;",
+            "",
+            "import java.util.Set;",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessible {",
+            "  @Inject UsesInaccessible(Set<Inaccessible> set1, Set<Inaccessible2> set2) {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.TestModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Collections;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "public abstract class TestModule {",
+            "  @Multibinds abstract Set<Inaccessible> objects();",
+            "",
+            "  @Provides @ElementsIntoSet",
+            "  static Set<Inaccessible2> emptySet() { ",
+            "    return Collections.emptySet();",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "import other.TestModule;",
+            "import other.UsesInaccessible;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  UsesInaccessible usesInaccessible();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.SetFactory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import other.TestModule_EmptySetFactory;",
+            "import other.UsesInaccessible;",
+            "import other.UsesInaccessible_Factory;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private Provider setOfInaccessible2Provider;",
+            "  private Provider<UsesInaccessible> usesInaccessibleProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.setOfInaccessible2Provider =",
+            "        SetFactory.builder(0, 1)",
+            "            .addCollectionProvider((Provider) TestModule_EmptySetFactory.create())",
+            "            .build();",
+            "    this.usesInaccessibleProvider =",
+            "        UsesInaccessible_Factory.create(",
+            "            ((Factory) SetFactory.empty()), setOfInaccessible2Provider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public UsesInaccessible usesInaccessible() {",
+            "    return UsesInaccessible_Factory.newUsesInaccessible(",
+            "        ImmutableSet.of(),",
+            "        ImmutableSet.copyOf(TestModule_EmptySetFactory.proxyEmptySet()));",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides @IntoSet static Object parentObject() {",
+            "    return \"parent object\";",
+            "  }",
+            "",
+            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Set<Object> objectSet();",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.internal.MapFactory;",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private Provider<Object> parentKeyObjectProvider;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.parentKeyObjectProvider =",
+            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private ParentModule parentModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      if (parentModule == null) {",
+            "        this.parentModule = new ParentModule();",
+            "      }",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private Provider<Set<Object>> setOfObjectProvider;",
+            "    private Provider<Map<String, Provider<Object>>>",
+            "        mapOfStringAndProviderOfObjectProvider;",
+            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
+            "",
+            "    private ChildImpl() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      this.setOfObjectProvider = SetFactory.<Object>builder(1, 0)",
+            "          .addProvider(ParentModule_ParentObjectFactory.create()).build();",
+            "      this.mapOfStringAndProviderOfObjectProvider =",
+            "          MapProviderFactory.<String, Object>builder(1)",
+            "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
+            "              .build();",
+            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
+            "          mapOfStringAndProviderOfObjectProvider);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Set<Object> objectSet() {",
+            "      return ImmutableSet.<Object>of(ParentModule.parentObject());",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<String, Object> objectMap() {",
+            "      return mapOfStringAndObjectProvider.get();",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(expected);
+  }
+
+  @Test
+  public void productionComponents() {
+    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "abstract class EmptySetModule {",
+        "  @Provides @ElementsIntoSet",
+        "  static Set<String> emptySet() { ",
+        "    return Collections.emptySet();",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProductionComponent;",
+        "import java.util.Set;",
+        "",
+        "@ProductionComponent(modules = EmptySetModule.class)",
+        "interface TestComponent {",
+        "  ListenableFuture<Set<String>> strings();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.Preconditions;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Set<String>> setOfStringProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.setOfStringProvider =",
+            "        SetFactory.<String>builder(0, 1)",
+            "            .addCollectionProvider(EmptySetModule_EmptySetFactory.create())",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<Set<String>> strings() {",
+            "    return Futures.<Set<String>>immediateFuture(",
+
+            "        ImmutableSet.<String>copyOf(EmptySetModule.emptySet());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder testComponent_ProductionExecutorModule(",
+            "        TestComponent_ProductionExecutorModule",
+            "            testComponent_ProductionExecutorModule) {",
+            "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(emptySetModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
