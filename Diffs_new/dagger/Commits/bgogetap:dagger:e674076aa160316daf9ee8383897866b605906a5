diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 4538d1e9a..6de0ab79a 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -261,6 +261,7 @@ java_library(
         "MonitoringModuleProcessingStep.java",
         "OptionalBindingExpression.java",
         "OptionalFactories.java",
+        "OptionalFactoryInstanceCreationExpression.java",
         "PrivateMethodBindingExpression.java",
         "ProducerCreationExpression.java",
         "ProducerFactoryGenerator.java",
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 57a23ede9..7ac1d1804 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -18,14 +18,12 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
 import static dagger.internal.codegen.MemberSelect.staticFactoryCreation;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
@@ -40,7 +38,6 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
-import dagger.internal.MembersInjectors;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
 import dagger.model.DependencyRequest;
@@ -391,34 +388,11 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
             binding, generatedComponentModel, this);
 
       case OPTIONAL:
-        if (binding.explicitDependencies().isEmpty()) {
-          return () -> optionalFactories.absentOptionalProvider(binding);
-        } else {
-          return () ->
-              optionalFactories.presentOptionalFactory(
-                  binding,
-                  getDependencyExpression(
-                          getOnlyElement(binding.frameworkDependencies()),
-                          generatedComponentModel.name())
-                      .codeBlock());
-        }
+        return new OptionalFactoryInstanceCreationExpression(
+            optionalFactories, binding, generatedComponentModel, this);
 
       case MEMBERS_INJECTOR:
-        TypeMirror membersInjectedType =
-            getOnlyElement(MoreTypes.asDeclared(binding.key().type()).getTypeArguments());
-
-        if (((ProvisionBinding) binding).injectionSites().isEmpty()) {
-          return new InstanceFactoryCreationExpression(
-              // The type parameter can be removed when we drop Java 7 source support.
-              () -> CodeBlock.of("$T.<$T>noOp()", MembersInjectors.class, membersInjectedType));
-        } else {
-          return new InstanceFactoryCreationExpression(
-              () ->
-                  CodeBlock.of(
-                      "$T.create($L)",
-                      membersInjectorNameForType(MoreTypes.asTypeElement(membersInjectedType)),
-                      getCreateMethodArgumentsCodeBlock(binding)));
-        }
+        return new MembersInjectorProviderCreationExpression((ProvisionBinding) binding, this);
 
       default:
         throw new AssertionError(binding);
@@ -621,30 +595,28 @@ private boolean canUseDirectInstanceExpression(ResolvedBindings resolvedBindings
   /**
    * Returns a binding expression for {@link RequestKind#PROVIDER} requests.
    *
-   * <p>In default mode, {@code @Binds} bindings that don't {@linkplain
-   * #needsCaching(ResolvedBindings) need to be cached} can use a {@link DelegateBindingExpression}.
+   * <p>{@code @Binds} bindings that don't {@linkplain #needsCaching(ResolvedBindings) need to be
+   * cached} can use a {@link DelegateBindingExpression}.
    *
-   * <p>In Android mode, if {@linkplain #instanceBindingExpression(ResolvedBindings) instance
-   * binding expressions} don't call {@code Provider.get()} on the provider binding expression, and
-   * there's no simple factory, then return a {@link SwitchingProviders} binding expression wrapped
-   * in a method.
+   * <p>In Android mode, use an {@link InnerSwitchingProviders inner switching provider} unless that
+   * provider's case statement will simply call {@code get()} on another {@link Provider} (in which
+   * case, just use that Provider directly).
    *
    * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
    */
   private BindingExpression providerBindingExpression(ResolvedBindings resolvedBindings) {
-    if (compilerOptions.experimentalAndroidMode()) {
-      if (!frameworkInstanceCreationExpression(resolvedBindings).isSimpleFactory()
-          && !(instanceBindingExpression(resolvedBindings)
-              instanceof DerivedFromProviderBindingExpression)) {
-        return wrapInMethod(
-            resolvedBindings,
-            RequestKind.PROVIDER,
-            innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
-      }
-    } else if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
+    if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
         && !needsCaching(resolvedBindings)) {
       return new DelegateBindingExpression(
           resolvedBindings, RequestKind.PROVIDER, this, types, elements);
+    } else if (compilerOptions.experimentalAndroidMode()
+        && frameworkInstanceCreationExpression(resolvedBindings).useInnerSwitchingProvider()
+        && !(instanceBindingExpression(resolvedBindings)
+            instanceof DerivedFromProviderBindingExpression)) {
+      return wrapInMethod(
+          resolvedBindings,
+          RequestKind.PROVIDER,
+          innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
     }
     return frameworkInstanceBindingExpression(resolvedBindings, RequestKind.PROVIDER);
   }
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index f5531b3b7..9bc1d176a 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -59,12 +59,15 @@
     }
 
     /**
-     * Returns {@code true} if the factory created for a binding is not worth inlining because it's
-     * a singleton or an {@link dagger.internal.InstanceFactory} or a nested {@code Provider} for a
-     * component dependency provision method.
+     * Returns {@code true} if instead of using {@link #creationExpression()} to create a framework
+     * instance, a case in {@link InnerSwitchingProviders} should be created for this binding.
      */
-    default boolean isSimpleFactory() {
-      return false;
+    // TODO(ronshapiro): perhaps this isn't the right approach. Instead of saying "Use
+    // SetFactory.EMPTY because you will only get 1 class for all types of bindings that use
+    // SetFactory", maybe we should still use an inner switching provider but the same switching
+    // provider index for all cases.
+    default boolean useInnerSwitchingProvider() {
+      return true;
     }
   }
 
diff --git a/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java b/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java
index 3aefff16a..c9b26d755 100644
--- a/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java
@@ -51,7 +51,7 @@ public CodeBlock creationExpression() {
   }
 
   @Override
-  public boolean isSimpleFactory() {
-    return true;
+  public boolean useInnerSwitchingProvider() {
+    return false;
   }
 }
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index 4bc3921fc..b5804908b 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -91,4 +91,9 @@ public CodeBlock creationExpression() {
 
     return builder.build();
   }
+
+  @Override
+  public boolean useInnerSwitchingProvider() {
+    return !binding.dependencies().isEmpty();
+  }
 }
diff --git a/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java b/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java
index eecadefca..25d034a53 100644
--- a/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java
@@ -32,11 +32,10 @@
     implements FrameworkInstanceCreationExpression {
 
   private final ComponentBindingExpressions componentBindingExpressions;
-  private final ContributionBinding binding;
+  private final ProvisionBinding binding;
 
   MembersInjectorProviderCreationExpression(
-      ContributionBinding binding,
-      ComponentBindingExpressions componentBindingExpressions) {
+      ProvisionBinding binding, ComponentBindingExpressions componentBindingExpressions) {
     this.binding = checkNotNull(binding);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
   }
@@ -47,7 +46,7 @@ public CodeBlock creationExpression() {
         getOnlyElement(MoreTypes.asDeclared(binding.key().type()).getTypeArguments());
 
     CodeBlock membersInjector =
-        ((ProvisionBinding) binding).injectionSites().isEmpty()
+        binding.injectionSites().isEmpty()
             ? CodeBlock.of("$T.<$T>noOp()", MEMBERS_INJECTORS, membersInjectedType)
             : CodeBlock.of(
                 "$T.create($L)",
@@ -58,4 +57,9 @@ public CodeBlock creationExpression() {
     // (as it's rarely requested as a Provider).
     return CodeBlock.of("$T.create($L)", INSTANCE_FACTORY, membersInjector);
   }
+
+  @Override
+  public boolean useInnerSwitchingProvider() {
+    return !binding.injectionSites().isEmpty();
+  }
 }
diff --git a/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
new file mode 100644
index 000000000..cffcbc83e
--- /dev/null
+++ b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+
+/**
+ * A {@link FrameworkInstanceCreationExpression} for {@link dagger.model.BindingKind#OPTIONAL
+ * optional bindings}.
+ */
+final class OptionalFactoryInstanceCreationExpression
+    implements FrameworkInstanceCreationExpression {
+  private final OptionalFactories optionalFactories;
+  private final ContributionBinding binding;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentBindingExpressions componentBindingExpressions;
+
+  OptionalFactoryInstanceCreationExpression(
+      OptionalFactories optionalFactories,
+      ContributionBinding binding,
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions) {
+    this.optionalFactories = optionalFactories;
+    this.binding = binding;
+    this.generatedComponentModel = generatedComponentModel;
+    this.componentBindingExpressions = componentBindingExpressions;
+  }
+
+  @Override
+  public CodeBlock creationExpression() {
+    return binding.dependencies().isEmpty()
+        ? optionalFactories.absentOptionalProvider(binding)
+        : optionalFactories.presentOptionalFactory(
+            binding,
+            componentBindingExpressions
+                .getDependencyExpression(
+                    getOnlyElement(binding.frameworkDependencies()), generatedComponentModel.name())
+                .codeBlock());
+  }
+
+  @Override
+  public boolean useInnerSwitchingProvider() {
+    // Share providers for empty optionals from OptionalFactories so we don't have numerous
+    // switch cases that all return Optional.empty().
+    return !binding.dependencies().isEmpty();
+  }
+}
diff --git a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
index 05a0e41fe..ac4949800 100644
--- a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
@@ -56,4 +56,6 @@ public CodeBlock creationExpression() {
   public Optional<ClassName> alternativeFrameworkClass() {
     return Optional.of(ClassName.get(Producer.class));
   }
+
+  // TODO(ronshapiro): should this have a simple factory if the delegate expression is simple?
 }
diff --git a/java/dagger/internal/codegen/SetFactoryCreationExpression.java b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
index e1a161807..94975680f 100644
--- a/java/dagger/internal/codegen/SetFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
@@ -89,4 +89,9 @@ public CodeBlock creationExpression() {
     builder.add(builderMethodCalls.build());
     return builder.add(".build()").build();
   }
+
+  @Override
+  public boolean useInnerSwitchingProvider() {
+    return !binding.dependencies().isEmpty();
+  }
 }
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index 2be29852b..8ed23d776 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -818,27 +818,25 @@ public void castedToRawType() {
                     "}")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
-                    "  private volatile Provider<CharSequence> charSequenceProvider;",
-                    "  private volatile Provider<String> namedStringProvider;",
+                    "  private volatile Provider<String> provideStringProvider;",
                     "",
-                    "  @Override",
-                    "  public Provider<CharSequence> charSequence() {",
-                    "    Object local = charSequenceProvider;",
+                    "  private Provider<String> getStringProvider() {",
+                    "    Object local = provideStringProvider;",
                     "    if (local == null) {",
                     "      local = new SwitchingProvider<>(0);",
-                    "      charSequenceProvider = (Provider<CharSequence>) local;",
+                    "      provideStringProvider = (Provider<String>) local;",
                     "    }",
-                    "    return (Provider<CharSequence>) local;",
+                    "    return (Provider<String>) local;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<CharSequence> charSequence() {",
+                    "    return (Provider) getStringProvider();",
                     "  }",
                     "",
                     "  @Override",
                     "  public Provider<String> namedString() {",
-                    "    Object local = namedStringProvider;",
-                    "    if (local == null) {",
-                    "      local = new SwitchingProvider<>(1);",
-                    "      namedStringProvider = (Provider<String>) local;",
-                    "    }",
-                    "    return (Provider<String>) local;",
+                    "    return getStringProvider();",
                     "  }",
                     "",
                     "  private final class SwitchingProvider<T> implements Provider<T> {",
@@ -846,11 +844,8 @@ public void castedToRawType() {
                     "    @Override",
                     "    public T get() {",
                     "      switch (id) {",
-                    // TODO(cl/189031410): Dedupe identical cases in SwitchingProviders.
                     "        case 0:",
                     "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
-                    "        case 1:",
-                    "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
                     "        default:",
                     "            throw new AssertionError(id);",
                     "      }",
@@ -924,27 +919,25 @@ public void doubleBinds() {
                     "}")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
-                    "  private volatile Provider<CharSequence> charSequenceProvider;",
-                    "  private volatile Provider<Object> objectProvider;",
+                    "  private volatile Provider<String> provideStringProvider;",
                     "",
-                    "  @Override",
-                    "  public Provider<CharSequence> charSequence() {",
-                    "    Object local = charSequenceProvider;",
+                    "  private Provider<String> getStringProvider() {",
+                    "    Object local = provideStringProvider;",
                     "    if (local == null) {",
                     "      local = new SwitchingProvider<>(0);",
-                    "      charSequenceProvider = (Provider<CharSequence>) local;",
+                    "      provideStringProvider = (Provider<String>) local;",
                     "    }",
-                    "    return (Provider<CharSequence>) local;",
+                    "    return (Provider<String>) local;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<CharSequence> charSequence() {",
+                    "    return (Provider) getStringProvider();",
                     "  }",
                     "",
                     "  @Override",
                     "  public Provider<Object> object() {",
-                    "    Object local = objectProvider;",
-                    "    if (local == null) {",
-                    "      local = new SwitchingProvider<>(1);",
-                    "      objectProvider = (Provider<Object>) local;",
-                    "    }",
-                    "    return (Provider<Object>) local;",
+                    "    return (Provider) getStringProvider();",
                     "  }",
                     "",
                     "  private final class SwitchingProvider<T> implements Provider<T> {",
@@ -954,8 +947,6 @@ public void doubleBinds() {
                     "      switch (id) {",
                     "        case 0:",
                     "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
-                    "        case 1:",
-                    "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
                     "        default:",
                     "            throw new AssertionError(id);",
                     "      }",
@@ -1031,16 +1022,20 @@ public void inlineFactoryOfInacessibleType() {
                     "}")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
-                    "  private volatile Provider<Supertype> toProvider;",
+                    "  private volatile Provider subtypeProvider;",
                     "",
-                    "  @Override",
-                    "  public Provider<Supertype> supertypeProvider() {",
-                    "    Object local = toProvider;",
+                    "  private Provider getSubtypeProvider() {",
+                    "    Object local = subtypeProvider;",
                     "    if (local == null) {",
                     "      local = new SwitchingProvider<>(0);",
-                    "      toProvider = (Provider<Supertype>) local;",
+                    "      subtypeProvider = (Provider) local;",
                     "    }",
-                    "    return (Provider<Supertype>) local;",
+                    "    return (Provider) local;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<Supertype> supertypeProvider() {",
+                    "    return getSubtypeProvider();",
                     "  }",
                     "",
                     "  private final class SwitchingProvider<T> implements Provider<T> {",
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 1bde5eba6..fad441e49 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -226,16 +226,15 @@ public void simpleComponent() {
                 "test.DaggerTestClass_SimpleComponent",
                 "package test;",
                 "",
-                "import com.google.common.collect.ImmutableSet;",
                 "import com.google.common.util.concurrent.ListenableFuture;",
                 "import dagger.internal.DoubleCheck;",
                 "import dagger.internal.InstanceFactory;",
                 "import dagger.internal.MemoizedSentinel;",
                 "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetFactory;",
                 "import dagger.producers.Producer;",
                 "import dagger.producers.internal.Producers;",
                 "import dagger.producers.monitoring.ProductionComponentMonitor;",
-                "import java.util.Set;",
                 "import java.util.concurrent.Executor;",
                 IMPORT_GENERATED_ANNOTATION,
                 "import javax.inject.Provider;",
@@ -248,8 +247,6 @@ public void simpleComponent() {
                 "      new MemoizedSentinel();",
                 "  private volatile Provider<ProductionComponentMonitor> monitorProvider;",
                 "  private volatile Object productionComponentMonitor = new MemoizedSentinel();",
-                "  private volatile Provider<Set<ProductionComponentMonitor.Factory>>",
-                "      setOfFactoryProvider;",
                 "  private volatile Provider<TestClass.B> bProvider;",
                 "  private TestClass.BModule bModule;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
@@ -296,17 +293,6 @@ public void simpleComponent() {
                 "    return (Provider<Executor>) local;",
                 "  }",
                 "",
-                "  private Provider<Set<ProductionComponentMonitor.Factory>>",
-                "      getSetOfFactoryProvider() {",
-                "      Object local = setOfFactoryProvider;",
-                "      if (local == null) {",
-                "        local = new SwitchingProvider<>(2);",
-                "        setOfFactoryProvider =",
-                "            (Provider<Set<ProductionComponentMonitor.Factory>>) local;",
-                "      }",
-                "      return (Provider<Set<ProductionComponentMonitor.Factory>>) local;",
-                "  }",
-                "",
                 "  private ProductionComponentMonitor getProductionComponentMonitor() {",
                 "    Object local = productionComponentMonitor;",
                 "    if (local instanceof MemoizedSentinel) {",
@@ -317,7 +303,7 @@ public void simpleComponent() {
                 "              TestClass_SimpleComponent_MonitoringModule_MonitorFactory",
                 "                  .proxyMonitor(",
                 "                      simpleComponentProvider,",
-                "                      getSetOfFactoryProvider());",
+                "                      SetFactory.<ProductionComponentMonitor.Factory>empty());",
                 "          productionComponentMonitor =",
                 "              DoubleCheck.reentrantCheck(",
                 "                  productionComponentMonitor, local);",
@@ -344,7 +330,7 @@ public void simpleComponent() {
                 "  private Provider<TestClass.B> getBProvider() {",
                 "    Object local = bProvider;",
                 "    if (local == null) {",
-                "      local = new SwitchingProvider<>(3);",
+                "      local = new SwitchingProvider<>(2);",
                 "      bProvider = (Provider<TestClass.B>) local;",
                 "    }",
                 "    return (Provider<TestClass.B>) local;",
@@ -418,8 +404,7 @@ public void simpleComponent() {
                 "      switch (id) {",
                 "        case 0: return (T) getProductionImplementationExecutor();",
                 "        case 1: return (T) getProductionComponentMonitor();",
-                "        case 2: return (T) ImmutableSet.<ProductionComponentMonitor.Factory>of();",
-                "        case 3: return (T) getB();",
+                "        case 2: return (T) getB();",
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
diff --git a/javatests/dagger/internal/codegen/SwitchingProviderTest.java b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
index e6f7a4727..bb2a3316c 100644
--- a/javatests/dagger/internal/codegen/SwitchingProviderTest.java
+++ b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
@@ -18,35 +18,19 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
-import java.util.Collection;
-import javax.annotation.processing.Processor;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
+import org.junit.runners.JUnit4;
 
-@RunWith(Parameterized.class)
+@RunWith(JUnit4.class)
 public class SwitchingProviderTest {
-  @Parameters(name = "{0}")
-  public static Collection<Object[]> parameters() {
-    return CompilerMode.TEST_PARAMETERS;
-  }
-
-  private final CompilerMode compilerMode;
-
-  public SwitchingProviderTest(CompilerMode compilerMode) {
-    this.compilerMode = compilerMode;
-  }
-
   @Test
   public void switchingProviderTest() {
     ImmutableList.Builder<JavaFileObject> javaFileObjects = ImmutableList.builder();
@@ -81,14 +65,11 @@ public void switchingProviderTest() {
             "}"));
 
     JavaFileObject generatedComponent =
-        compilerMode
-            .javaFileBuilder("test.DaggerTestComponent")
-            .addLines(
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
                 "package test;",
                 GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {")
-            .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                "public final class DaggerTestComponent implements TestComponent {",
                 "  private final class SwitchingProvider<T> implements Provider<T> {",
                 "    @SuppressWarnings(\"unchecked\")",
                 "    private T get0() {",
@@ -213,19 +194,408 @@ public void switchingProviderTest() {
                 "        default: throw new AssertionError(id);",
                 "      }",
                 "    }",
-                "  }")
-            .build();
+                "  }",
+                "}");
 
-    Compilation compilation = daggerCompiler().compile(javaFileObjects.build());
+    Compilation compilation = compilerWithAndroidMode().compile(javaFileObjects.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
         .containsElementsIn(generatedComponent);
   }
 
-  private Compiler daggerCompiler(Processor... extraProcessors) {
+  @Test
+  public void unscopedBinds() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Provides",
+            "  static String s() {",
+            "    return new String();",
+            "  }",
+            "",
+            "  @Binds CharSequence c(String s);",
+            "  @Binds Object o(CharSequence c);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Provider<Object> objectProvider();",
+            "  Provider<CharSequence> charSequenceProvider();",
+            "}");
+
+    Compilation compilation = compilerWithAndroidMode().compile(module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private volatile Provider<String> sProvider;",
+                "",
+                "  private Provider<String> getStringProvider() {",
+                "    Object local = sProvider;",
+                "    if (local == null) {",
+                "      local = new SwitchingProvider<>(0);",
+                "      sProvider = (Provider<String>) local;",
+                "    }",
+                "    return (Provider<String>) local;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Object> objectProvider() {",
+                "    return (Provider) getStringProvider();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<CharSequence> charSequenceProvider() {",
+                "    return (Provider) getStringProvider();",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0:",
+                "          return (T) TestModule_SFactory.proxyS();",
+                "        default:",
+                "          throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void scopedBinds() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Provides",
+            "  static String s() {",
+            "    return new String();",
+            "  }",
+            "",
+            "  @Binds @Singleton Object o(CharSequence s);",
+            "  @Binds @Singleton CharSequence c(String s);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Provider<Object> objectProvider();",
+            "  Provider<CharSequence> charSequenceProvider();",
+            "}");
+
+    Compilation compilation = compilerWithAndroidMode().compile(module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private volatile Provider<CharSequence> cProvider;",
+                "  private volatile Object charSequence = new MemoizedSentinel();",
+                "",
+                "  private CharSequence getCharSequence() {",
+                "    Object local = charSequence;",
+                "    if (local instanceof MemoizedSentinel) {",
+                "      synchronized (local) {",
+                "        local = charSequence;",
+                "        if (local instanceof MemoizedSentinel) {",
+                "          local = TestModule_SFactory.proxyS();",
+                "          charSequence = DoubleCheck.reentrantCheck(charSequence, local);",
+                "        }",
+                "      }",
+                "    }",
+                "    return (CharSequence) local;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Object> objectProvider() {",
+                "    return (Provider) charSequenceProvider();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<CharSequence> charSequenceProvider() {",
+                "    Object local = cProvider;",
+                "    if (local == null) {",
+                "      local = new SwitchingProvider<>(0);",
+                "      cProvider = (Provider<CharSequence>) local;",
+                "    }",
+                "    return (Provider<CharSequence>) local;",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0:",
+                "          return (T) getCharSequence();",
+                "        default:",
+                "          throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void emptyMultibindings_avoidSwitchProviders() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.multibindings.Multibinds;",
+            "import dagger.Module;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Multibinds Set<String> set();",
+            "  @Multibinds Map<String, String> map();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Provider<Set<String>> setProvider();",
+            "  Provider<Map<String, String>> mapProvider();",
+            "}");
+
+    Compilation compilation = compilerWithAndroidMode().compile(module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  @Override",
+                "  public Provider<Set<String>> setProvider() {",
+                "    return SetFactory.<String>empty();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<String, String>> mapProvider() {",
+                "    return MapFactory.<String, String>emptyMapProvider();",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void memberInjectors() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "class Foo {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Provider<MembersInjector<Foo>> providerOfMembersInjector();",
+            "}");
+
+    Compilation compilation = compilerWithAndroidMode().compile(foo, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<MembersInjector<Foo>> fooMembersInjectorProvider;",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.fooMembersInjectorProvider = ",
+                "        InstanceFactory.create(MembersInjectors.<Foo>noOp());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<MembersInjector<Foo>> providerOfMembersInjector() {",
+                "    return fooMembersInjectorProvider;",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void optionals() {
+    JavaFileObject present =
+        JavaFileObjects.forSourceLines(
+            "test.Present",
+            "package test;",
+            "",
+            "class Present {}");
+    JavaFileObject absent =
+        JavaFileObjects.forSourceLines(
+            "test.Absent",
+            "package test;",
+            "",
+            "class Absent {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @BindsOptionalOf Present bindOptionalOfPresent();",
+            "  @BindsOptionalOf Absent bindOptionalOfAbsent();",
+            "",
+            "  @Provides static Present p() { return new Present(); }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Optional;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Provider<Optional<Present>> providerOfOptionalOfPresent();",
+            "  Provider<Optional<Absent>> providerOfOptionalOfAbsent();",
+            "}");
+
+    Compilation compilation = compilerWithAndroidMode().compile(present, absent, module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+
+                "  @SuppressWarnings(\"rawtypes\")",
+                "  private static final Provider ABSENT_JDK_OPTIONAL_PROVIDER =",
+                "      InstanceFactory.create(Optional.empty());",
+                "",
+                "  private volatile Provider<Optional<Present>> optionalOfPresentProvider;",
+                "",
+                "  private Provider<Optional<Absent>> optionalOfAbsentProvider;",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.optionalOfAbsentProvider = absentJdkOptionalProvider();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Optional<Present>> providerOfOptionalOfPresent() {",
+                "    Object local = optionalOfPresentProvider;",
+                "    if (local == null) {",
+                "      local = new SwitchingProvider<>(0);",
+                "      optionalOfPresentProvider = (Provider<Optional<Present>>) local;",
+                "    }",
+                "    return (Provider<Optional<Present>>) local;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Optional<Absent>> providerOfOptionalOfAbsent() {",
+                "    return optionalOfAbsentProvider;",
+                "  }",
+                "",
+                "  private static <T> Provider<Optional<T>> absentJdkOptionalProvider() {",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    Provider<Optional<T>> provider = ",
+                "          (Provider<Optional<T>>) ABSENT_JDK_OPTIONAL_PROVIDER;",
+                "    return provider;",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0: // java.util.Optional<test.Present>",
+                "          return (T) Optional.of(TestModule_PFactory.proxyP());",
+                "        default:",
+                "          throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  private Compiler compilerWithAndroidMode() {
     return javac()
-        .withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors))
-        .withOptions(compilerMode.javacopts());
+        .withProcessors(new ComponentProcessor())
+        .withOptions(CompilerMode.EXPERIMENTAL_ANDROID_MODE.javacopts());
   }
 }
