diff --git a/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java
index 02fef5d56..f7db11444 100644
--- a/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java
@@ -25,7 +25,7 @@
   /**
    * Renders the frame to the specified bitmap. The bitmap must have a width and height that is
    * at least as big as the specified width and height and it must be in RGBA_8888 color format.
-   *
+   * 把当前帧，绘制成width * height的尺寸（当前帧本身的比例可能不是width * height），然后放进bitmap中
    * @param width the width to render to (the image is scaled to this width)
    * @param height the height to render to (the image is scaled to this height)
    * @param bitmap the bitmap to render into
diff --git a/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryImpl.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryImpl.java
index 2673eab51..da5116ba2 100644
--- a/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryImpl.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryImpl.java
@@ -30,7 +30,7 @@
 import java.util.List;
 
 /**
- * Decoder for animated images.
+ * Decoder for animated images. 真正负责解码动图（GIF和WEBP）的解码，GIF解码后生成GifImage（未完全解码，只是解析了元数据），WEBP解码后生成WebPImage（未完全解码，只是解析了元数据）
  */
 public class AnimatedImageFactoryImpl implements AnimatedImageFactory {
 
diff --git a/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java
index 856df3bef..d4a31a63e 100644
--- a/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java
@@ -213,7 +213,7 @@ private void renderImageSupportsScaling(Canvas canvas, AnimatedImageFrame frame)
       prepareTempBitmapForThisSize(renderedWidth, renderedHeight);
       frame.renderFrame(frameWidth, frameHeight, mTempBitmap);
       // Temporary bitmap can be bigger than frame, so we should draw only rendered area of bitmap
-      mRenderSrcRect.set(0, 0, renderedWidth, renderedHeight);
+      mRenderSrcRect.set(0, 0, renderedWidth, renderedHeight); // todo 这里的尺寸应当是frameWidth和frameHeight呀
       mRenderDstRect.set(xOffset, yOffset, xOffset + renderedWidth, yOffset + renderedHeight);
 
       canvas.drawBitmap(mTempBitmap, mRenderSrcRect, mRenderDstRect, null);
diff --git a/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java
index 7bf0930be..0977fa11f 100644
--- a/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java
@@ -105,7 +105,7 @@ public void renderFrame(int frameNumber, Bitmap bitmap) {
       }
       mAnimatedDrawableBackend.renderFrame(index, canvas);
       mCallback.onIntermediateResult(index, bitmap);
-      if (disposalMethod == DisposalMethod.DISPOSE_TO_BACKGROUND) { //todo 这里为什么在renderFrame之后做呀???
+      if (disposalMethod == DisposalMethod.DISPOSE_TO_BACKGROUND) { // disposalMethod表示对当前帧的处理策略，这里为绘制下一帧做好准备
         disposeToBackground(canvas, frameInfo);
       }
     }
@@ -158,14 +158,14 @@ private int prepareCanvasWithClosestCachedFrame(int previousFrameNumber, Canvas
               if (frameInfo.disposalMethod == DisposalMethod.DISPOSE_TO_BACKGROUND) {
                 disposeToBackground(canvas, frameInfo); // 擦掉index帧覆盖的部分
               }
-              return index + 1;
+              return index + 1; // index帧REQUIRED的，且有缓存，则处理下DisposalMethod.DISPOSE_TO_BACKGROUND，就可以当做下一帧的背景了，所以从下一帧开始绘制
             } finally {
               startBitmap.close();
             }
           } else {
-            if (isKeyFrame(index)) {
+            if (isKeyFrame(index)) { // index没有缓存，但是是关键帧，则从index开始绘制
               return index;
-            } else {
+            } else { // 否则继续向前找
               // Keep going.
               break;
             }
@@ -231,7 +231,7 @@ private boolean isKeyFrame(int index) {
       return true;
     } else
       return prevFrameInfo.disposalMethod == DisposalMethod.DISPOSE_TO_BACKGROUND
-          && isFullFrame(prevFrameInfo);
+          && isFullFrame(prevFrameInfo); // 在绘制当前帧时，前一帧（Disposal Method = DisposalMethod.DISPOSE_TO_BACKGROUND）的区域会被恢复成背景色（恢复成背景色时，不会进行混合）
   }
 
   private boolean isFullFrame(AnimatedDrawableFrameInfo frameInfo) {
diff --git a/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java b/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java
index 460f89d04..5ccf2a444 100644
--- a/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java
+++ b/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java
@@ -157,7 +157,7 @@ public int getLoopCount() {
   public boolean drawFrame(
       Drawable parent,
       Canvas canvas,
-      int frameNumber) {
+      int frameNumber) { // 绘制动图的某一帧
     if (mFrameListener != null) {
       mFrameListener.onDrawFrameStart(this, frameNumber);
     }
@@ -169,7 +169,7 @@ public boolean drawFrame(
       mFrameListener.onFrameDropped(this, frameNumber);
     }
 
-    // Prepare next frames
+    // Prepare next frames 预加载下面3帧
     if (mBitmapFramePreparationStrategy != null && mBitmapFramePreparer != null) {
       mBitmapFramePreparationStrategy.prepareFrames(
           mBitmapFramePreparer,
@@ -180,7 +180,7 @@ public boolean drawFrame(
 
     return drawn;
   }
-
+  // 首先从缓冲中找当前帧；没有的话，找可重用的Bitmap，然后先把帧绘制到bitmap上，再把bitmap绘制Canvas；没有可重用的bitmap的话，则创建新bitmap，然后先把帧绘制到bitmap上，再把bitmap绘制Canvas；最后实在都不行的话，则返回上一帧数据
   private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType int frameType) {
     CloseableReference<Bitmap> bitmapReference = null;
     boolean drawn = false;
@@ -234,7 +234,7 @@ private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType i
     if (drawn || nextFrameType == FRAME_TYPE_UNKNOWN) {
       return drawn;
     } else {
-      return drawFrameOrFallback(canvas, frameNumber, nextFrameType);
+      return drawFrameOrFallback(canvas, frameNumber, nextFrameType); // 递归
     }
   }
 
diff --git a/animated-gif-lite/src/main/java/com/facebook/animated/giflite/decoder/GifMetadataStreamDecoder.java b/animated-gif-lite/src/main/java/com/facebook/animated/giflite/decoder/GifMetadataStreamDecoder.java
index 62e5ebc68..b9ce9d5bc 100644
--- a/animated-gif-lite/src/main/java/com/facebook/animated/giflite/decoder/GifMetadataStreamDecoder.java
+++ b/animated-gif-lite/src/main/java/com/facebook/animated/giflite/decoder/GifMetadataStreamDecoder.java
@@ -96,7 +96,7 @@ private void readGifInfo() throws IOException {
         case 0x21: // extension
           int extCode = readNextByte();
           switch (extCode) {
-            case 0xff: // application extension
+            case 0xff: // application extension 读取GIF循环次数：LoopCount
               readBlock();
               if (isNetscape()) {
                 readNetscapeExtension();
@@ -115,7 +115,7 @@ private void readGifInfo() throws IOException {
               skipExtension();
           }
           break;
-        case 0x2C: // image
+        case 0x2C: // image 图像块
           addFrame(control);
           skipImage();
           // count as a frame
@@ -134,7 +134,7 @@ private void addFrame(int[] control) {
   }
 
   private void validateAndIgnoreHeader() throws IOException {
-    readIntoBlock(0 /* offset */, 6 /* length */);
+    readIntoBlock(0 /* offset */, 6 /* length */); // 读取文件头
     boolean valid =
         'G' == (char) block[0]
             && 'I' == (char) block[1]
@@ -145,7 +145,7 @@ private void validateAndIgnoreHeader() throws IOException {
     if (!valid) {
       throw new IOException("Illegal header for gif");
     }
-
+    // 读取逻辑品父母标识符
     readTwoByteInt(); // width
     readTwoByteInt(); // height
 
@@ -156,7 +156,7 @@ private void validateAndIgnoreHeader() throws IOException {
     readNextByte(); // bgc index
     readNextByte(); // aspect ratio
 
-    if (hasGlobalColorTable) {
+    if (hasGlobalColorTable) { // 忽略全局颜色表
       ignoreColorTable(globalColorTableSize);
     }
   }
@@ -193,9 +193,9 @@ private void skipImage() throws IOException {
 
     int flags = readNextByte();
     boolean hasLct = (flags & 0x80) != 0;
-    if (hasLct) {
+    if (hasLct) { // 有局部颜色表
       int lctSize = 2 << (flags & 7);
-      ignoreColorTable(lctSize);
+      ignoreColorTable(lctSize); // 忽略局部颜色表
     }
     readNextByte();
     skipExtension();
diff --git a/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieDrawer.java b/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieDrawer.java
index 3f2631ead..56eaee80b 100644
--- a/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieDrawer.java
+++ b/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieDrawer.java
@@ -31,7 +31,7 @@ public MovieDrawer(Movie movie) {
     mCanvas = new Canvas();
   }
 
-  public synchronized void drawFrame(int movieTime, int w, int h, Bitmap bitmap) {
+  public synchronized void drawFrame(int movieTime, int w, int h, Bitmap bitmap) { // w和h是当前帧要渲染到的宽高，它不一定等于当前帧真实宽高
     mMovie.setTime(movieTime);
 
     if (mPreviousBitmap != null && mPreviousBitmap.isRecycled()) {
@@ -44,7 +44,7 @@ public synchronized void drawFrame(int movieTime, int w, int h, Bitmap bitmap) {
 
     mScaleHolder.updateViewPort(w, h);
 
-    mCanvas.save();
+    mCanvas.save(); // 采用长边对齐，短边留空白的方式，来进行scale（保持比例）
     mCanvas.scale(mScaleHolder.getScale(), mScaleHolder.getScale());
     mMovie.draw(mCanvas, mScaleHolder.getLeft(), mScaleHolder.getTop());
     mCanvas.restore();
diff --git a/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieFrame.java b/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieFrame.java
index a3ff113e3..faa9651fc 100644
--- a/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieFrame.java
+++ b/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieFrame.java
@@ -18,7 +18,7 @@
 public class MovieFrame implements AnimatedImageFrame {
 
   private final MovieDrawer mMovieDrawer;
-  private final int mFrameStart;
+  private final int mFrameStart; // 帧开始时间
   private final int mFrameDuration;
   private final int mFrameWidth;
   private final int mFrameHeight;
diff --git a/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieScaleHolder.java b/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieScaleHolder.java
index 1739aac15..dff063d0a 100644
--- a/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieScaleHolder.java
+++ b/animated-gif-lite/src/main/java/com/facebook/animated/giflite/draw/MovieScaleHolder.java
@@ -9,9 +9,9 @@
 
 class MovieScaleHolder {
 
-  private final int mMovieWidth;
+  private final int mMovieWidth; // Gif的完整尺寸
   private final int mMovieHeight;
-  private int mViewPortWidth;
+  private int mViewPortWidth; // 某帧要渲染到的宽高
   private int mViewPortHeight;
   private float mScale = 1f;
   private float mLeft = 0;
diff --git a/animated-gif/src/main/jni/gifimage/gif.cpp b/animated-gif/src/main/jni/gifimage/gif.cpp
index d110e37ce..a85f0b7de 100644
--- a/animated-gif/src/main/jni/gifimage/gif.cpp
+++ b/animated-gif/src/main/jni/gifimage/gif.cpp
@@ -611,7 +611,7 @@ jobject GifImage_nativeCreateFromByteVector(JNIEnv* pEnv, std::vector<uint8_t>&
   for (int i = 0; i < pGifFile->ImageCount; i++) {
     SavedImage* pSavedImage = &pGifFile->SavedImages[i];
     GraphicsControlBlock gcp;
-    if (getGraphicsControlBlockForImage(pSavedImage, &gcp)) {
+    if (getGraphicsControlBlockForImage(pSavedImage, &gcp)) { // 解析图形控制扩展，得到每帧的Duration，单位是10ms
       int frameDurationMs = gcp.DelayTime * 10;
       durationMs += frameDurationMs;
       frameDurationsMs.push_back(frameDurationMs);
@@ -625,7 +625,7 @@ jobject GifImage_nativeCreateFromByteVector(JNIEnv* pEnv, std::vector<uint8_t>&
   // Cache loop count
   spNativeContext->loopCount = spNativeContext->spGifWrapper->getLoopCount();
 
-  // Create the GifImage with the native context.
+  // Create the GifImage with the native context. 根据spNativeContext地址，创建Java层GifImage
   jobject ret = pEnv->NewObject(
       sClazzGifImage,
       sGifImageConstructor,
diff --git a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java
index 2d3422f6e..341012643 100644
--- a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java
@@ -343,7 +343,7 @@ private void parseMetaDataIfNeeded() {
   }
 
   /** Sets the encoded image meta data. */
-  public void parseMetaData() {
+  public void parseMetaData() { // 解析图片格式
     final ImageFormat imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(
         getInputStream());
     mImageFormat = imageFormat;
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DefaultImageDecoder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DefaultImageDecoder.java
index ef0f18d33..9f2f90a15 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DefaultImageDecoder.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DefaultImageDecoder.java
@@ -68,7 +68,7 @@ public CloseableImage decode(
       };
 
   @Nullable
-  private final Map<ImageFormat, ImageDecoder> mCustomDecoders;
+  private final Map<ImageFormat, ImageDecoder> mCustomDecoders; // 自定义解码器
 
   public DefaultImageDecoder(
       final ImageDecoder animatedGifDecoder,
@@ -103,7 +103,7 @@ public CloseableImage decode(
       final int length,
       final QualityInfo qualityInfo,
       final ImageDecodeOptions options) {
-    if (options.customImageDecoder != null) {
+    if (options.customImageDecoder != null) { // 优先使用定制解码器进行解码
       return options.customImageDecoder.decode(encodedImage, length, qualityInfo, options);
     }
     ImageFormat imageFormat = encodedImage.getImageFormat();
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java
index b3f00fab0..46d645b21 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java
@@ -474,7 +474,7 @@ protected synchronized boolean updateDecodeJob(EncodedImage encodedImage, @Statu
       if ((isNotLast(status) || statusHasFlag(status, IS_PARTIAL_RESULT))
           && !statusHasFlag(status, IS_PLACEHOLDER)
           && EncodedImage.isValid(encodedImage)
-          && encodedImage.getImageFormat() == DefaultImageFormats.JPEG) {
+          && encodedImage.getImageFormat() == DefaultImageFormats.JPEG) { // 解码jpeg
         if (!mProgressiveJpegParser.parseMoreData(encodedImage)) {
           return false;
         }
