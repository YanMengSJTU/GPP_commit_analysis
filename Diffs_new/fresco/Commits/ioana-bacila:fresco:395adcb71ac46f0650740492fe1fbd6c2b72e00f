diff --git a/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormat.java b/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormat.java
index 42651d7d5..f100d4827 100644
--- a/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormat.java
+++ b/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormat.java
@@ -1,38 +1,53 @@
-/*
- * Copyright (c) 2015-present, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- */
-
-package com.facebook.imageformat;
-
-/**
- * Enum representing all used image formats.
- */
-public enum ImageFormat {
-
-  WEBP_SIMPLE,
-  WEBP_LOSSLESS,
-  WEBP_EXTENDED,
-  WEBP_EXTENDED_WITH_ALPHA,
-  WEBP_ANIMATED,
-  JPEG,
-  PNG,
-  GIF,
-  BMP,
-  /**
-   * Unknown image. This is needed in case we fail to detect any type for particular image.
-   */
-  UNKNOWN;
-
-  public static boolean isWebpFormat(ImageFormat imageFormat) {
-    return imageFormat == WEBP_SIMPLE ||
-        imageFormat == WEBP_LOSSLESS ||
-        imageFormat == WEBP_EXTENDED ||
-        imageFormat == WEBP_EXTENDED_WITH_ALPHA ||
-        imageFormat == WEBP_ANIMATED;
-  }
-}
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imageformat;
+
+/**
+ * Enum representing all used image formats.
+ */
+public enum ImageFormat {
+
+  WEBP_SIMPLE,
+  WEBP_LOSSLESS,
+  WEBP_EXTENDED,
+  WEBP_EXTENDED_WITH_ALPHA,
+  WEBP_ANIMATED,
+
+  BPG_SIMPLE,
+  BPG_LOSSLESS,
+  BPG_EXTENDED,
+  BPG_EXTENDED_WITH_ALPHA,
+  BPG_ANIMATED,
+
+  JPEG,
+  PNG,
+  GIF,
+  BMP,
+  /**
+   * Unknown image. This is needed in case we fail to detect any type for particular image.
+   */
+  UNKNOWN;
+
+  public static boolean isWebpFormat(ImageFormat imageFormat) {
+    return imageFormat == WEBP_SIMPLE ||
+        imageFormat == WEBP_LOSSLESS ||
+        imageFormat == WEBP_EXTENDED ||
+        imageFormat == WEBP_EXTENDED_WITH_ALPHA ||
+        imageFormat == WEBP_ANIMATED;
+  }
+
+  public static boolean isBpgFormat(ImageFormat imageFormat) {
+      return imageFormat == BPG_SIMPLE ||
+              imageFormat == BPG_LOSSLESS ||
+              imageFormat == BPG_EXTENDED ||
+              imageFormat == BPG_EXTENDED_WITH_ALPHA ||
+              imageFormat == BPG_ANIMATED;
+  }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormatChecker.java b/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormatChecker.java
index e63f087e8..e50a29d10 100644
--- a/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormatChecker.java
+++ b/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormatChecker.java
@@ -1,335 +1,377 @@
-/*
- * Copyright (c) 2015-present, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- */
-
-package com.facebook.imageformat;
-
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-
-import com.facebook.common.internal.ByteStreams;
-import com.facebook.common.internal.Closeables;
-import com.facebook.common.internal.Ints;
-import com.facebook.common.internal.Preconditions;
-import com.facebook.common.internal.Throwables;
-import com.facebook.imagepipeline.webp.WebpSupportStatus;
-
-/**
- * Detects the format of an encoded image.
- */
-public class ImageFormatChecker {
-
-  private ImageFormatChecker() {}
-
-  /**
-   * Tries to match imageHeaderByte and headerSize against every known image format.
-   * If any match succeeds, corresponding ImageFormat is returned.
-   * @param imageHeaderBytes
-   * @param headerSize
-   * @return ImageFormat for given imageHeaderBytes or UNKNOWN if no such type could be recognized
-   */
-  private static ImageFormat doGetImageFormat(
-      final byte[] imageHeaderBytes,
-      final int headerSize) {
-    Preconditions.checkNotNull(imageHeaderBytes);
-
-    if (WebpSupportStatus.isWebpHeader(imageHeaderBytes, 0, headerSize)) {
-      return getWebpFormat(imageHeaderBytes, headerSize);
-    }
-
-    if (isJpegHeader(imageHeaderBytes, headerSize)) {
-      return ImageFormat.JPEG;
-    }
-
-    if (isPngHeader(imageHeaderBytes, headerSize)) {
-      return ImageFormat.PNG;
-    }
-
-    if (isGifHeader(imageHeaderBytes, headerSize)) {
-      return ImageFormat.GIF;
-    }
-
-    if (isBmpHeader(imageHeaderBytes, headerSize)) {
-      return ImageFormat.BMP;
-    }
-
-    return ImageFormat.UNKNOWN;
-  }
-
-  /**
-   * Reads up to MAX_HEADER_LENGTH bytes from is InputStream. If mark is supported by is, it is
-   * used to restore content of the stream after appropriate amount of data is read.
-   * Read bytes are stored in imageHeaderBytes, which should be capable of storing
-   * MAX_HEADER_LENGTH bytes.
-   * @param is
-   * @param imageHeaderBytes
-   * @return number of bytes read from is
-   * @throws IOException
-   */
-  private static int readHeaderFromStream(
-      final InputStream is,
-      final byte[] imageHeaderBytes)
-      throws IOException {
-    Preconditions.checkNotNull(is);
-    Preconditions.checkNotNull(imageHeaderBytes);
-    Preconditions.checkArgument(imageHeaderBytes.length >= MAX_HEADER_LENGTH);
-
-    // If mark is supported by the stream, use it to let the owner of the stream re-read the same
-    // data. Otherwise, just consume some data.
-    if (is.markSupported()) {
-      try {
-        is.mark(MAX_HEADER_LENGTH);
-        return ByteStreams.read(is, imageHeaderBytes, 0, MAX_HEADER_LENGTH);
-      } finally {
-        is.reset();
-      }
-    } else {
-      return ByteStreams.read(is, imageHeaderBytes, 0, MAX_HEADER_LENGTH);
-    }
-  }
-
-  /**
-   * Tries to read up to MAX_HEADER_LENGTH bytes from InputStream is and use read bytes to
-   * determine type of the image contained in is. If provided input stream does not support mark,
-   * then this method consumes data from is and it is not safe to read further bytes from is after
-   * this method returns. Otherwise, if mark is supported, it will be used to preserve oryginal
-   * content of is.
-   * @param is
-   * @return ImageFormat matching content of is InputStream or UNKNOWN if no type is suitable
-   * @throws IOException if exception happens during read
-   */
-  public static ImageFormat getImageFormat(final InputStream is) throws IOException {
-    Preconditions.checkNotNull(is);
-    final byte[] imageHeaderBytes = new byte[MAX_HEADER_LENGTH];
-    final int headerSize = readHeaderFromStream(is, imageHeaderBytes);
-    return doGetImageFormat(imageHeaderBytes, headerSize);
-  }
-
-  /*
-   * A variant of getImageFormat that wraps IOException with RuntimeException.
-   * This relieves clients of implementing dummy rethrow try-catch block.
-   */
-  public static ImageFormat getImageFormat_WrapIOException(final InputStream is) {
-    try {
-      return getImageFormat(is);
-    } catch (IOException ioe) {
-      throw Throwables.propagate(ioe);
-    }
-  }
-
-  /**
-   * Reads image header from a file indicated by provided filename and determines
-   * its format. This method does not throw IOException if one occurs. In this case,
-   * ImageFormat.UNKNOWN will be returned.
-   * @param filename
-   * @return ImageFormat for image stored in filename
-   */
-  public static ImageFormat getImageFormat(String filename) {
-    FileInputStream fileInputStream = null;
-    try {
-      fileInputStream = new FileInputStream(filename);
-      return getImageFormat(fileInputStream);
-    } catch (IOException ioe) {
-      return ImageFormat.UNKNOWN;
-    } finally {
-      Closeables.closeQuietly(fileInputStream);
-    }
-  }
-
-  /**
-   * Checks if byteArray interpreted as sequence of bytes has a subsequence equal to pattern
-   * starting at position equal to offset.
-   * @param byteArray
-   * @param offset
-   * @param pattern
-   * @return true if match succeeds, false otherwise
-   */
-  private static boolean matchBytePattern(
-      final byte[] byteArray,
-      final int offset,
-      final byte[] pattern) {
-    Preconditions.checkNotNull(byteArray);
-    Preconditions.checkNotNull(pattern);
-    Preconditions.checkArgument(offset >= 0);
-    if (pattern.length + offset > byteArray.length) {
-      return false;
-    }
-
-    for (int i = 0; i < pattern.length; ++i) {
-      if (byteArray[i + offset] != pattern[i]) {
-        return false;
-      }
-    }
-
-    return true;
-  }
-
-  /**
-   * Helper method that transforms provided string into it's byte representation
-   * using ASCII encoding
-   * @param value
-   * @return byte array representing ascii encoded value
-   */
-  private static byte[] asciiBytes(String value) {
-    Preconditions.checkNotNull(value);
-    try {
-      return value.getBytes("ASCII");
-    } catch (UnsupportedEncodingException uee) {
-      // won't happen
-      throw new RuntimeException("ASCII not found!", uee);
-    }
-  }
-
-
-  /**
-   * Each WebP header should cosist of at least 20 bytes and start
-   * with "RIFF" bytes followed by some 4 bytes and "WEBP" bytes.
-   * More detailed description if WebP can be found here:
-   * <a href="https://developers.google.com/speed/webp/docs/riff_container">
-   *   https://developers.google.com/speed/webp/docs/riff_container</a>
-   */
-  private static final int SIMPLE_WEBP_HEADER_LENGTH = 20;
-
-  /**
-   * Each VP8X WebP image has "features" byte following its ChunkHeader('VP8X')
-   */
-  private static final int EXTENDED_WEBP_HEADER_LENGTH = 21;
-
-  /**
-   * Determines type of WebP image. imageHeaderBytes has to be header of a WebP image
-   */
-  private static ImageFormat getWebpFormat(final byte[] imageHeaderBytes, final int headerSize) {
-    Preconditions.checkArgument(WebpSupportStatus.isWebpHeader(imageHeaderBytes, 0, headerSize));
-    if (WebpSupportStatus.isSimpleWebpHeader(imageHeaderBytes, 0)) {
-      return ImageFormat.WEBP_SIMPLE;
-    }
-
-    if (WebpSupportStatus.isLosslessWebpHeader(imageHeaderBytes, 0)) {
-      return ImageFormat.WEBP_LOSSLESS;
-    }
-
-    if (WebpSupportStatus.isExtendedWebpHeader(imageHeaderBytes, 0, headerSize)) {
-      if (WebpSupportStatus.isAnimatedWebpHeader(imageHeaderBytes, 0)) {
-        return ImageFormat.WEBP_ANIMATED;
-      }
-      if (WebpSupportStatus.isExtendedWebpHeaderWithAlpha(imageHeaderBytes, 0)) {
-        return ImageFormat.WEBP_EXTENDED_WITH_ALPHA;
-      }
-      return ImageFormat.WEBP_EXTENDED;
-    }
-
-    return ImageFormat.UNKNOWN;
-  }
-
-  /**
-   * Every JPEG image should start with SOI mark (0xFF, 0xD8) followed by beginning
-   * of another segment (0xFF)
-   */
-  private static final byte[] JPEG_HEADER = new byte[] {(byte)0xFF, (byte)0xD8, (byte)0xFF};
-
-  /**
-   * Checks if imageHeaderBytes starts with SOI (start of image) marker, followed by 0xFF.
-   * If headerSize is lower than 3 false is returned.
-   * Description of jpeg format can be found here:
-   * <a href="http://www.w3.org/Graphics/JPEG/itu-t81.pdf">
-   *   http://www.w3.org/Graphics/JPEG/itu-t81.pdf</a>
-   * Annex B deals with compressed data format
-   * @param imageHeaderBytes
-   * @param headerSize
-   * @return true if imageHeaderBytes starts with SOI_BYTES and headerSize >= 3
-   */
-  private static boolean isJpegHeader(final byte[] imageHeaderBytes, final int headerSize) {
-    return headerSize >= JPEG_HEADER.length && matchBytePattern(imageHeaderBytes, 0, JPEG_HEADER);
-  }
-
-
-  /**
-   * Every PNG image starts with 8 byte signature consisting of
-   * following bytes
-   */
-  private static final byte[] PNG_HEADER = new byte[] {
-      (byte) 0x89,
-      'P', 'N', 'G',
-      (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};
-
-  /**
-   * Checks if array consisting of first headerSize bytes of imageHeaderBytes
-   * starts with png signature. More information on PNG can be found there:
-   * <a href="http://en.wikipedia.org/wiki/Portable_Network_Graphics">
-   *   http://en.wikipedia.org/wiki/Portable_Network_Graphics</a>
-   * @param imageHeaderBytes
-   * @param headerSize
-   * @return true if imageHeaderBytes starts with PNG_HEADER
-   */
-  private static boolean isPngHeader(final byte[] imageHeaderBytes, final int headerSize) {
-    return headerSize >= PNG_HEADER.length && matchBytePattern(imageHeaderBytes, 0, PNG_HEADER);
-  }
-
-
-  /**
-   * Every gif image starts with "GIF" bytes followed by
-   * bytes indicating version of gif standard
-   */
-  private static final byte[] GIF_HEADER_87A = asciiBytes("GIF87a");
-  private static final byte[] GIF_HEADER_89A = asciiBytes("GIF89a");
-  private static final int GIF_HEADER_LENGTH = 6;
-
-  /**
-   * Checks if first headerSize bytes of imageHeaderBytes constitute a valid header for a gif image.
-   * Details on GIF header can be found <a href="http://www.w3.org/Graphics/GIF/spec-gif89a.txt">
-   *  on page 7</a>
-   * @param imageHeaderBytes
-   * @param headerSize
-   * @return true if imageHeaderBytes is a valid header for a gif image
-   */
-  private static boolean isGifHeader(final byte[] imageHeaderBytes, final int headerSize) {
-    if (headerSize < GIF_HEADER_LENGTH) {
-      return false;
-    }
-    return matchBytePattern(imageHeaderBytes, 0, GIF_HEADER_87A) ||
-        matchBytePattern(imageHeaderBytes, 0, GIF_HEADER_89A);
-  }
-
-  /**
-   * Every bmp image starts with "BM" bytes
-   */
-  private static final byte[] BMP_HEADER = asciiBytes("BM");
-
-  /**
-   * Checks if first headerSize bytes of imageHeaderBytes constitute a valid header for a bmp image.
-   * Details on BMP header can be found <a href="http://www.onicos.com/staff/iz/formats/bmp.html">
-   * </a>
-   * @param imageHeaderBytes
-   * @param headerSize
-   * @return true if imageHeaderBytes is a valid header for a bmp image
-   */
-  private static boolean isBmpHeader(final byte[] imageHeaderBytes, final int headerSize) {
-    if (headerSize < BMP_HEADER.length) {
-      return false;
-    }
-    return matchBytePattern(imageHeaderBytes, 0, BMP_HEADER);
-  }
-
-
-  /**
-   * Maximum header size for any image type.
-   *
-   * <p>This determines how much data {@link #getImageFormat(InputStream)
-   * reads from a stream. After changing any of the type detection algorithms, or adding a new one,
-   * this value should be edited.
-   */
-  private static final int MAX_HEADER_LENGTH = Ints.max(
-      EXTENDED_WEBP_HEADER_LENGTH,
-      SIMPLE_WEBP_HEADER_LENGTH,
-      JPEG_HEADER.length,
-      PNG_HEADER.length,
-      GIF_HEADER_LENGTH,
-      BMP_HEADER.length);
-}
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imageformat;
+
+import com.facebook.common.internal.ByteStreams;
+import com.facebook.common.internal.Closeables;
+import com.facebook.common.internal.Ints;
+import com.facebook.common.internal.Preconditions;
+import com.facebook.common.internal.Throwables;
+import com.facebook.imagepipeline.bpg.BpgHeaderInfo;
+import com.facebook.imagepipeline.webp.WebpSupportStatus;
+import com.facebook.imageutils.BytesPatternMatcher;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+
+/**
+ * Detects the format of an encoded image.
+ */
+public class ImageFormatChecker {
+
+  private ImageFormatChecker() {}
+
+  /**
+   * Tries to match imageHeaderByte and headerSize against every known image format.
+   * If any match succeeds, corresponding ImageFormat is returned.
+   * @param imageHeaderBytes
+   * @param headerSize
+   * @return ImageFormat for given imageHeaderBytes or UNKNOWN if no such type could be recognized
+   */
+  private static ImageFormat doGetImageFormat(
+      final byte[] imageHeaderBytes,
+      final int headerSize) {
+    Preconditions.checkNotNull(imageHeaderBytes);
+
+    if (WebpSupportStatus.isWebpHeader(imageHeaderBytes, 0, headerSize)) {
+      return getWebpFormat(imageHeaderBytes, headerSize);
+    }
+
+    if (BpgHeaderInfo.isBpgHeader(imageHeaderBytes)) {
+      return getBpgFormat(imageHeaderBytes);
+    }
+
+    if (isJpegHeader(imageHeaderBytes, headerSize)) {
+      return ImageFormat.JPEG;
+    }
+
+    if (isPngHeader(imageHeaderBytes, headerSize)) {
+      return ImageFormat.PNG;
+    }
+
+    if (isGifHeader(imageHeaderBytes, headerSize)) {
+      return ImageFormat.GIF;
+    }
+
+    if (isBmpHeader(imageHeaderBytes, headerSize)) {
+      return ImageFormat.BMP;
+    }
+
+    return ImageFormat.UNKNOWN;
+  }
+
+  /**
+   * Reads up to MAX_HEADER_LENGTH bytes from is InputStream. If mark is supported by is, it is
+   * used to restore content of the stream after appropriate amount of data is read.
+   * Read bytes are stored in imageHeaderBytes, which should be capable of storing
+   * MAX_HEADER_LENGTH bytes.
+   * @param is
+   * @param imageHeaderBytes
+   * @return number of bytes read from is
+   * @throws IOException
+   */
+  private static int readHeaderFromStream(
+      final InputStream is,
+      final byte[] imageHeaderBytes)
+      throws IOException {
+    Preconditions.checkNotNull(is);
+    Preconditions.checkNotNull(imageHeaderBytes);
+    Preconditions.checkArgument(imageHeaderBytes.length >= MAX_HEADER_LENGTH);
+
+    // If mark is supported by the stream, use it to let the owner of the stream re-read the same
+    // data. Otherwise, just consume some data.
+    if (is.markSupported()) {
+      try {
+        is.mark(MAX_HEADER_LENGTH);
+        return ByteStreams.read(is, imageHeaderBytes, 0, MAX_HEADER_LENGTH);
+      } finally {
+        is.reset();
+      }
+    } else {
+      return ByteStreams.read(is, imageHeaderBytes, 0, MAX_HEADER_LENGTH);
+    }
+  }
+
+  /**
+   * Tries to read up to MAX_HEADER_LENGTH bytes from InputStream is and use read bytes to
+   * determine type of the image contained in is. If provided input stream does not support mark,
+   * then this method consumes data from is and it is not safe to read further bytes from is after
+   * this method returns. Otherwise, if mark is supported, it will be used to preserve oryginal
+   * content of is.
+   * @param is
+   * @return ImageFormat matching content of is InputStream or UNKNOWN if no type is suitable
+   * @throws IOException if exception happens during read
+   */
+  public static ImageFormat getImageFormat(final InputStream is) throws IOException {
+    Preconditions.checkNotNull(is);
+    final byte[] imageHeaderBytes = new byte[MAX_HEADER_LENGTH];
+    final int headerSize = readHeaderFromStream(is, imageHeaderBytes);
+    return doGetImageFormat(imageHeaderBytes, headerSize);
+  }
+
+  /**
+   * Tries to read up to MAX_HEADER_LENGTH bytes from InputStream is and use read bytes to
+   * determine type of the image contained in is. If provided input stream does not support mark,
+   * then this method consumes data from is and it is not safe to read further bytes from is after
+   * this method returns. Otherwise, if mark is supported, it will be used to preserve oryginal
+   * content of is.
+   * @param is
+   * @return ImageFormat matching content of is InputStream or UNKNOWN if no type is suitable
+   * @throws IOException if exception happens during read
+   */
+  public static ImageFormat getImageFormat(byte[] imageHeaderBytes, final InputStream is) throws IOException {
+    Preconditions.checkNotNull(is);
+    final int headerSize = readHeaderFromStream(is, imageHeaderBytes);
+    return doGetImageFormat(imageHeaderBytes, headerSize);
+  }
+
+
+  /*
+   * A variant of getImageFormat that wraps IOException with RuntimeException.
+   * This relieves clients of implementing dummy rethrow try-catch block.
+   */
+  public static ImageFormat getImageFormat_WrapIOException(final InputStream is) {
+    try {
+      return getImageFormat(is);
+    } catch (IOException ioe) {
+      throw Throwables.propagate(ioe);
+    }
+  }
+
+  /*
+   * A variant of getImageFormat that wraps IOException with RuntimeException.
+   * This relieves clients of implementing dummy rethrow try-catch block.
+   */
+  public static ImageFormat getImageFormat_WrapIOException(final byte[] imageHeaderBytes, final InputStream is) {
+    try {
+      return getImageFormat(imageHeaderBytes, is);
+    } catch (IOException ioe) {
+      throw Throwables.propagate(ioe);
+    }
+  }
+
+  /**
+   * Reads image header from a file indicated by provided filename and determines
+   * its format. This method does not throw IOException if one occurs. In this case,
+   * ImageFormat.UNKNOWN will be returned.
+   * @param filename
+   * @return ImageFormat for image stored in filename
+   */
+  public static ImageFormat getImageFormat(String filename) {
+    FileInputStream fileInputStream = null;
+    try {
+      fileInputStream = new FileInputStream(filename);
+      return getImageFormat(fileInputStream);
+    } catch (IOException ioe) {
+      return ImageFormat.UNKNOWN;
+    } finally {
+      Closeables.closeQuietly(fileInputStream);
+    }
+  }
+
+  /**
+   * Helper method that transforms provided string into it's byte representation
+   * using ASCII encoding
+   * @param value
+   * @return byte array representing ascii encoded value
+   */
+  private static byte[] asciiBytes(String value) {
+    Preconditions.checkNotNull(value);
+    try {
+      return value.getBytes("ASCII");
+    } catch (UnsupportedEncodingException uee) {
+      // won't happen
+      throw new RuntimeException("ASCII not found!", uee);
+    }
+  }
+
+  /**
+   * Each WebP header should cosist of at least 20 bytes and start
+   * with "RIFF" bytes followed by some 4 bytes and "WEBP" bytes.
+   * More detailed description if WebP can be found here:
+   * <a href="https://developers.google.com/speed/webp/docs/riff_container">
+   *   https://developers.google.com/speed/webp/docs/riff_container</a>
+   */
+  private static final int SIMPLE_WEBP_HEADER_LENGTH = 20;
+
+  /**
+   * Each VP8X WebP image has "features" byte following its ChunkHeader('VP8X')
+   */
+  private static final int EXTENDED_WEBP_HEADER_LENGTH = 21;
+
+  /**
+   * Determines type of WebP image. imageHeaderBytes has to be header of a WebP image
+   */
+  private static ImageFormat getWebpFormat(final byte[] imageHeaderBytes, final int headerSize) {
+    Preconditions.checkArgument(WebpSupportStatus.isWebpHeader(imageHeaderBytes, 0, headerSize));
+    if (WebpSupportStatus.isSimpleWebpHeader(imageHeaderBytes, 0)) {
+      return ImageFormat.WEBP_SIMPLE;
+    }
+
+    if (WebpSupportStatus.isLosslessWebpHeader(imageHeaderBytes, 0)) {
+      return ImageFormat.WEBP_LOSSLESS;
+    }
+
+    if (WebpSupportStatus.isExtendedWebpHeader(imageHeaderBytes, 0, headerSize)) {
+      if (WebpSupportStatus.isAnimatedWebpHeader(imageHeaderBytes, 0)) {
+        return ImageFormat.WEBP_ANIMATED;
+      }
+      if (WebpSupportStatus.isExtendedWebpHeaderWithAlpha(imageHeaderBytes, 0)) {
+        return ImageFormat.WEBP_EXTENDED_WITH_ALPHA;
+      }
+      return ImageFormat.WEBP_EXTENDED;
+    }
+
+    return ImageFormat.UNKNOWN;
+  }
+
+  /**
+   * Each BPG header should consist of at least 16 bytes and start
+   * with "BPGû" bytes.
+   * More detailed description if WebP can be found here:
+   * <a href="http://bellard.org/bpg/bpg_spec.txt">
+   *   http://bellard.org/bpg/bpg_spec.txt</a>
+   */
+  private static final int SIMPLE_BPG_HEADER_LENGTH = 16;
+  private static final int EXTENDED_BPG_HEADER_LENGTH = 40;
+
+
+  /**
+   * Determines type of BPG image. imageHeaderBytes has to be header of a BPG image
+   */
+  private static ImageFormat getBpgFormat(final byte[] imageHeaderBytes) {
+    Preconditions.checkArgument(BpgHeaderInfo.isBpgHeader(imageHeaderBytes));
+    if (BpgHeaderInfo.isSimpleBpgImage(imageHeaderBytes)) {
+      return ImageFormat.BPG_SIMPLE;
+    }
+
+    if (BpgHeaderInfo.isExtendedBpgImage(imageHeaderBytes)) {
+      return ImageFormat.BPG_EXTENDED;
+    }
+
+    if (BpgHeaderInfo.isExtendedWithAlphaBpgImage(imageHeaderBytes)) {
+      return ImageFormat.BPG_EXTENDED_WITH_ALPHA;
+    }
+
+    if (BpgHeaderInfo.isAnimatedBpgImage(imageHeaderBytes)) {
+      return ImageFormat.BPG_ANIMATED;
+    }
+
+    return ImageFormat.UNKNOWN;
+  }
+
+  /**
+   * Every JPEG image should start with SOI mark (0xFF, 0xD8) followed by beginning
+   * of another segment (0xFF)
+   */
+  private static final byte[] JPEG_HEADER = new byte[] {(byte)0xFF, (byte)0xD8, (byte)0xFF};
+
+  /**
+   * Checks if imageHeaderBytes starts with SOI (start of image) marker, followed by 0xFF.
+   * If headerSize is lower than 3 false is returned.
+   * Description of jpeg format can be found here:
+   * <a href="http://www.w3.org/Graphics/JPEG/itu-t81.pdf">
+   *   http://www.w3.org/Graphics/JPEG/itu-t81.pdf</a>
+   * Annex B deals with compressed data format
+   * @param imageHeaderBytes
+   * @param headerSize
+   * @return true if imageHeaderBytes starts with SOI_BYTES and headerSize >= 3
+   */
+  private static boolean isJpegHeader(final byte[] imageHeaderBytes, final int headerSize) {
+    return headerSize >= JPEG_HEADER.length && BytesPatternMatcher.matchBytePattern(imageHeaderBytes, 0, JPEG_HEADER);
+  }
+
+
+  /**
+   * Every PNG image starts with 8 byte signature consisting of
+   * following bytes
+   */
+  private static final byte[] PNG_HEADER = new byte[] {
+      (byte) 0x89,
+      'P', 'N', 'G',
+      (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};
+
+  /**
+   * Checks if array consisting of first headerSize bytes of imageHeaderBytes
+   * starts with png signature. More information on PNG can be found there:
+   * <a href="http://en.wikipedia.org/wiki/Portable_Network_Graphics">
+   *   http://en.wikipedia.org/wiki/Portable_Network_Graphics</a>
+   * @param imageHeaderBytes
+   * @param headerSize
+   * @return true if imageHeaderBytes starts with PNG_HEADER
+   */
+  private static boolean isPngHeader(final byte[] imageHeaderBytes, final int headerSize) {
+    return headerSize >= PNG_HEADER.length && BytesPatternMatcher.matchBytePattern(imageHeaderBytes, 0, PNG_HEADER);
+  }
+
+
+  /**
+   * Every gif image starts with "GIF" bytes followed by
+   * bytes indicating version of gif standard
+   */
+  private static final byte[] GIF_HEADER_87A = asciiBytes("GIF87a");
+  private static final byte[] GIF_HEADER_89A = asciiBytes("GIF89a");
+  private static final int GIF_HEADER_LENGTH = 6;
+
+  /**
+   * Checks if first headerSize bytes of imageHeaderBytes constitute a valid header for a gif image.
+   * Details on GIF header can be found <a href="http://www.w3.org/Graphics/GIF/spec-gif89a.txt">
+   *  on page 7</a>
+   * @param imageHeaderBytes
+   * @param headerSize
+   * @return true if imageHeaderBytes is a valid header for a gif image
+   */
+  private static boolean isGifHeader(final byte[] imageHeaderBytes, final int headerSize) {
+    if (headerSize < GIF_HEADER_LENGTH) {
+      return false;
+    }
+    return BytesPatternMatcher.matchBytePattern(imageHeaderBytes, 0, GIF_HEADER_87A) ||
+        BytesPatternMatcher.matchBytePattern(imageHeaderBytes, 0, GIF_HEADER_89A);
+  }
+
+  /**
+   * Every bmp image starts with "BM" bytes
+   */
+  private static final byte[] BMP_HEADER = asciiBytes("BM");
+
+  /**
+   * Checks if first headerSize bytes of imageHeaderBytes constitute a valid header for a bmp image.
+   * Details on BMP header can be found <a href="http://www.onicos.com/staff/iz/formats/bmp.html">
+   * </a>
+   * @param imageHeaderBytes
+   * @param headerSize
+   * @return true if imageHeaderBytes is a valid header for a bmp image
+   */
+  private static boolean isBmpHeader(final byte[] imageHeaderBytes, final int headerSize) {
+    if (headerSize < BMP_HEADER.length) {
+      return false;
+    }
+    return BytesPatternMatcher.matchBytePattern(imageHeaderBytes, 0, BMP_HEADER);
+  }
+
+  /**
+   * Maximum header size for any image type.
+   *
+   * <p>This determines how much data {@link #getImageFormat(InputStream)
+   * reads from a stream. After changing any of the type detection algorithms, or adding a new one,
+   * this value should be edited.
+   */
+  private static final int MAX_HEADER_LENGTH = Ints.max(
+      EXTENDED_WEBP_HEADER_LENGTH,
+      SIMPLE_WEBP_HEADER_LENGTH,
+      SIMPLE_BPG_HEADER_LENGTH,
+      EXTENDED_BPG_HEADER_LENGTH,
+      JPEG_HEADER.length,
+      PNG_HEADER.length,
+      GIF_HEADER_LENGTH,
+      BMP_HEADER.length);
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/BpgHeaderInfo.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/BpgHeaderInfo.java
new file mode 100644
index 000000000..504559db1
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/BpgHeaderInfo.java
@@ -0,0 +1,105 @@
+package com.facebook.imagepipeline.bpg;
+
+import com.facebook.common.soloader.SoLoaderShim;
+import com.facebook.imagepipeline.bpg.enums.BpgImageFormat;
+import com.facebook.imagepipeline.bpg.enums.ColourSpace;
+import com.facebook.imageutils.BytesPatternMatcher;
+
+public class BpgHeaderInfo {
+  static {
+    SoLoaderShim.loadLibrary("libbpg");
+  }
+
+  /**
+   * Each BPG header should consist of at least 16 bytes and start
+   * with "BPGû" bytes.
+   * More detailed description if WebP can be found here:
+   * <a href="http://bellard.org/bpg/bpg_spec.txt">
+   *   http://bellard.org/bpg/bpg_spec.txt</a>
+   */
+  public static final int SIMPLE_BPG_MAX_HEADER_LENGTH = 16;
+  public static final int SIMPLE_BPG_MIN_HEADER_LENGTH = 5;
+  public static final int EXTENDED_BPG_HEADER_LENGTH = 40;
+
+  private static final byte[] BPG_HEADER = new byte[] {'B', 'P', 'G', (byte)0xFB};
+
+  private static final int BPG_FORMAT_POSITION = 4;
+  private static final int BPG_EXTENSION_FLAG_POSITION = 5;
+
+  public static  boolean isBpgHeader(final byte[] imageHeaderBytes) {
+    return BytesPatternMatcher.matchBytePattern(imageHeaderBytes, 0, BPG_HEADER);
+  }
+
+  public static boolean isSimpleBpgImage(final byte[] imageHeaderBytes) {
+    return (imageHeaderBytes[BPG_FORMAT_POSITION] >> 5) == 1
+      && imageHeaderBytes.length <= SIMPLE_BPG_MAX_HEADER_LENGTH
+      && imageHeaderBytes.length >= SIMPLE_BPG_MIN_HEADER_LENGTH ?
+      true : false;
+  }
+
+  public static boolean isAnimatedBpgImage(final byte[] imageHeaderBytes) {
+    int animation_flag = imageHeaderBytes[BPG_EXTENSION_FLAG_POSITION] & 1;
+    return animation_flag == 0 ? true : false;
+  }
+
+  public static boolean isExtendedBpgImage(final byte[] imageHeaderBytes) {
+    return ((imageHeaderBytes[BPG_EXTENSION_FLAG_POSITION] >> 3) & 1) == 1 ? true : false;
+  }
+
+  public static boolean isExtendedWithAlphaBpgImage(byte[] imageHeaderBytes) {
+    return (isExtendedBpgImage(imageHeaderBytes) &&
+            hasAlpha(imageHeaderBytes[BPG_FORMAT_POSITION],
+                     imageHeaderBytes[BPG_EXTENSION_FLAG_POSITION]));
+  }
+
+  public static boolean hasAlpha(byte alpha1, byte alpha2) {
+    boolean alphaFlag1  = ((alpha1 >> 4) & 1) == 1 ? true : false;
+    boolean alphaFlag2  = ((alpha2 >> 2) & 1) == 1 ? true : false;
+
+    return (alphaFlag1 && alphaFlag2);
+  }
+
+  /** The bpg format will not be opened by displaying .bpg files as it is not yet supported in Android.
+   *  The BPG will be displayed as BMP files which is platform independent.
+   *  The BPG images are a good encoding/decoding format as they are small in size and high quality
+   *  when displayed after being decoded to a machine readable file.
+   *  Android 5+ (Lollipop) does include support for HEVC format.
+   */
+  public static BpgImageFormat getBpgImageFormat(final int imgFormatByte){
+
+    switch (imgFormatByte) {
+      case -4:
+          return BpgImageFormat.BPG_FORMAT_420_VIDEO;
+      case -3:
+          return BpgImageFormat.BPG_FORMAT_422_VIDEO;
+      case 0:
+          return BpgImageFormat.BPG_FORMAT_GRAY;
+      case 1:
+          return BpgImageFormat.BPG_FORMAT_420;
+      case 2:
+          return BpgImageFormat.BPG_FORMAT_422;
+      case 3:
+          return BpgImageFormat.BPG_FORMAT_444;
+      default:
+          return null;
+    }
+  }
+
+  public static ColourSpace getColourSpace(final int colourSpaceByte) {
+
+    switch (colourSpaceByte) {
+      case 0:
+          return ColourSpace.BPG_CS_YCbCr;
+      case 1:
+          return ColourSpace.BPG_CS_RGB;
+      case 2:
+          return ColourSpace.BPG_CS_YCgCo;
+      case 3:
+          return ColourSpace.BPG_CS_YCbCr_BT709;
+      case 4:
+          return ColourSpace.BPG_CS_YCbCr_BT2020;
+      default:
+          return null;
+    }
+  }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/BpgImageInfo.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/BpgImageInfo.java
new file mode 100644
index 000000000..a51cc47fc
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/BpgImageInfo.java
@@ -0,0 +1,72 @@
+package com.facebook.imagepipeline.bpg;
+
+import com.facebook.common.soloader.SoLoaderShim;
+
+public class BpgImageInfo {
+  static {
+    SoLoaderShim.loadLibrary("libbpg");
+  }
+
+  int width;
+  int height;
+  int pictureDataLen;
+  byte format;
+  boolean hasAlpha;
+  byte colourSpace;
+  byte bitDepth;
+  boolean hasPremultipliedAlpha;
+  boolean hasWPlane;
+  boolean limitedRange;
+  boolean hasAnimation;
+  short loopCount;
+
+  public int getWidth() {
+    return width;
+  }
+
+  public int getHeight() {
+    return height;
+  }
+
+  public int getPictureDataLen() {
+    return pictureDataLen;
+  }
+
+  public byte getFormat() {
+    return format;
+  }
+
+  public boolean hasAlpha() {
+    return hasAlpha;
+  }
+
+  public byte getColourSpace() {
+    return colourSpace;
+  }
+
+  public byte getBitDepth() {
+    return bitDepth;
+  }
+
+  public boolean hasPremultipliedAlpha() {
+    return hasPremultipliedAlpha;
+  }
+
+  public boolean hasWPlane() {
+    return hasWPlane;
+  }
+
+  public boolean hasLimitedRange() {
+    return limitedRange;
+  }
+
+  public boolean hasAnimation() {
+    return hasAnimation;
+  }
+
+  public short hasLoopCount() {
+    return loopCount;
+  }
+
+  public native int getImageInfoFromBuf(byte[] headerBuf, int buf_len);
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/BpgSupportStatus.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/BpgSupportStatus.java
new file mode 100644
index 000000000..9bf9d4cf5
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/BpgSupportStatus.java
@@ -0,0 +1,35 @@
+package com.facebook.imagepipeline.bpg;
+
+public class BpgSupportStatus {
+  public static final boolean sIsBpgSupportRequired = false;
+
+  public static final boolean sIsSimpleWebpSupported = false;
+
+  public static final boolean sIsExtendedWebpSupported = isExtendedWebpSupported();
+
+  /**
+   * Checks whether underlying platform supports extended WebPs
+   */
+  private static boolean isExtendedWebpSupported() {
+     return false;
+  }
+
+  /**
+   *  The bpg format will not be opened by displaying .bpg files as it is not yet supported in Android.
+   *  The BPG will be displayed as BMP files which is platform independent.
+   *  The BPG images are a good encoding/decoding format as they are small in size and high quality
+   *  when displayed after being decoded to a machine readable file.
+   *  Android 5+ (Lollipop) does include support for HEVC format.
+   *
+   * See secion 5.1.2. Image Codecs for android 6:
+   * <a href="http://static.googleusercontent.com/media/source.android.com/ro//compatibility/android-cdd.pdf">
+   *   http://static.googleusercontent.com/media/source.android.com/ro//compatibility/android-cdd.pdf</a>
+   */
+  public static boolean isBpgPlatformSupported(
+      final byte[] imageHeaderBytes,
+      final int offset,
+      final int headerSize) {
+    return false;
+  }
+
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/enums/BpgImageFormat.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/enums/BpgImageFormat.java
new file mode 100644
index 000000000..3244d2f92
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/enums/BpgImageFormat.java
@@ -0,0 +1,20 @@
+package com.facebook.imagepipeline.bpg.enums;
+
+public enum BpgImageFormat {
+  BPG_FORMAT_GRAY(0),
+  BPG_FORMAT_420(1),
+  BPG_FORMAT_422(2),
+  BPG_FORMAT_444(3),
+  BPG_FORMAT_420_VIDEO(4),
+  BPG_FORMAT_422_VIDEO(5);
+
+  private int val;
+
+  BpgImageFormat(int i) {
+    this.val = i;
+  }
+
+  public int getVal() {
+        return val;
+      }
+}
\ No newline at end of file
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/enums/ColourSpace.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/enums/ColourSpace.java
new file mode 100644
index 000000000..78fa8dd49
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/bpg/enums/ColourSpace.java
@@ -0,0 +1,22 @@
+package com.facebook.imagepipeline.bpg.enums;
+
+public enum ColourSpace {
+  BPG_CS_YCbCr(0),
+  BPG_CS_RGB(1),
+  BPG_CS_YCgCo(2),
+  BPG_CS_YCbCr_BT709(3),
+  BPG_CS_YCbCr_BT2020(4),
+
+  // not supported in the 0.9.6 version
+  BPG_CS_BT2020_CT_LUMIN(5);
+
+  private int val;
+
+  ColourSpace(int i) {
+      this.val = i;
+  }
+
+  public int getVal() {
+        return val;
+      }
+}
\ No newline at end of file
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/BpgTranscoder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/BpgTranscoder.java
new file mode 100644
index 000000000..ee28c1c08
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/BpgTranscoder.java
@@ -0,0 +1,118 @@
+package com.facebook.imagepipeline.nativecode;
+
+import com.facebook.common.internal.DoNotStrip;
+import com.facebook.common.internal.Throwables;
+import com.facebook.imagepipeline.bpg.BpgImageInfo;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+@DoNotStrip
+public class BpgTranscoder {
+  static {
+    ImagePipelineNativeLoader.load();
+  }
+
+  public static void transcodeBpgToBmp(
+      final byte[] imageHeaderBytes,
+      InputStream inputStream,
+      OutputStream outputStream) {
+    try {
+      BpgImageInfo bpgImageInfo = new BpgImageInfo();
+      int imageHeaderSize = bpgImageInfo.
+                              getImageInfoFromBuf(
+                                  imageHeaderBytes,
+                                  imageHeaderBytes.length);
+      if (imageHeaderSize < 0) {
+        throw new RuntimeException("Could not decode the BPG header");
+      }
+
+      int imageBodySize = bpgImageInfo.getPictureDataLen();
+      byte[] imageBodyBytes = new byte[imageBodySize];
+
+      System.arraycopy(
+          imageHeaderBytes,
+          imageHeaderSize,
+          imageBodyBytes,
+          0,
+          imageHeaderBytes.length - imageHeaderSize);
+
+      int totalBytesToRead = imageBodySize - imageHeaderBytes.length;
+      if (fillBuffer(totalBytesToRead, imageBodyBytes, inputStream)
+              != totalBytesToRead) {
+        throw new RuntimeException("Could not read the BPG body");
+      }
+
+      outputStream.write(
+              decodeBodyBuffer(
+                  bpgImageInfo,
+                  imageBodyBytes,
+                  imageHeaderSize,
+                  imageBodySize));
+
+    } catch (IOException ioe) {
+      throw Throwables.propagate(ioe);
+    }
+
+  }
+
+  public static void transcodeFullBpgToBmp(
+      InputStream inputStream,
+      OutputStream outputStream) throws IOException {
+    byte[] buffer = new byte[1024];
+    int readBytes;
+
+    ByteArrayOutputStream bpgStream = new ByteArrayOutputStream();
+    while ((readBytes = inputStream.read(buffer, 0, buffer.length)) != -1) {
+      bpgStream.write(buffer, 0, readBytes);
+    }
+
+    outputStream.write(
+        decodeFullImageBuffer(
+            bpgStream.toByteArray(),
+            bpgStream.size()));
+
+  }
+
+  private static int fillBuffer(
+      int bytesToRead,
+      byte[] buffer,
+      InputStream inputStream) throws IOException {
+    int totalBytesRead = bytesToRead;
+    int readBytes;
+    int offset = buffer.length - bytesToRead;
+
+    while (totalBytesRead > 0) {
+      readBytes = inputStream.read(buffer, offset, 1024);
+      offset += readBytes;
+      totalBytesRead -= readBytes;
+    }
+
+    return offset;
+  }
+
+  /**
+   * Gets the full image size in bytes
+   * */
+  @DoNotStrip
+  public static native int getBmpBufferSize(int width, int height);
+
+  /**
+   * Decodes the image body bytes without the header
+   * */
+  public static native byte[] decodeBodyBuffer(BpgImageInfo bpgImageInfo, byte[] encBuffer, int idx, int encBufferSize);
+
+  //    /**
+  //     * Decodes the header bytes only and returns the information about the BPG image
+  //     * */
+  //    public static native BpgImageInfo decodeHeader(byte[] encBuffer, int encBufferSize);
+
+  /**
+   * Decodes full image with both header and body
+   * */
+  @DoNotStrip
+  public static native byte[] decodeFullImageBuffer(byte[] encBuffer, int encBufferSize);
+
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BpgTranscodeProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BpgTranscodeProducer.java
new file mode 100644
index 000000000..485363c4e
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BpgTranscodeProducer.java
@@ -0,0 +1,152 @@
+package com.facebook.imagepipeline.producers;
+
+import com.facebook.common.internal.Preconditions;
+import com.facebook.common.references.CloseableReference;
+import com.facebook.common.util.TriState;
+import com.facebook.imageformat.ImageFormat;
+import com.facebook.imageformat.ImageFormatChecker;
+import com.facebook.imagepipeline.bpg.BpgHeaderInfo;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.memory.PooledByteBuffer;
+import com.facebook.imagepipeline.memory.PooledByteBufferFactory;
+import com.facebook.imagepipeline.memory.PooledByteBufferOutputStream;
+import com.facebook.imagepipeline.nativecode.BpgTranscoder;
+
+import java.io.InputStream;
+import java.util.concurrent.Executor;
+
+public class BpgTranscodeProducer implements Producer<EncodedImage> {
+  private static final String PRODUCER_NAME = "BpgTranscodeProducer";
+
+  private final Executor mExecutor;
+  private final PooledByteBufferFactory mPooledByteBufferFactory;
+  private final Producer<EncodedImage> mInputProducer;
+
+  public BpgTranscodeProducer(
+      Executor executor,
+      PooledByteBufferFactory pooledByteBufferFactory,
+      Producer<EncodedImage> inputProducer) {
+    mExecutor = Preconditions.checkNotNull(executor);
+    mPooledByteBufferFactory = Preconditions.checkNotNull(pooledByteBufferFactory);
+    mInputProducer = Preconditions.checkNotNull(inputProducer);
+  }
+
+  @Override
+  public void produceResults(Consumer<EncodedImage> consumer, ProducerContext context) {
+    mInputProducer.produceResults(new BpgTranscodeConsumer(consumer, context), context);
+  }
+
+  private class BpgTranscodeConsumer extends DelegatingConsumer<EncodedImage, EncodedImage> {
+    private final ProducerContext mContext;
+    private TriState mShouldTranscodeWhenFinished;
+
+    public BpgTranscodeConsumer(
+        final Consumer<EncodedImage> consumer,
+        final ProducerContext context) {
+      super(consumer);
+      mContext = context;
+      mShouldTranscodeWhenFinished = TriState.UNSET;
+    }
+
+    @Override
+    protected void onNewResultImpl(EncodedImage newResult, boolean isLast) {
+      if (newResult != null) {
+        transcodeLastResult(newResult, getConsumer(), mContext);
+      } else {
+        getConsumer().onNewResult(newResult, isLast);
+      }
+    }
+  }
+
+  //TODO refactor
+  private void transcodeLastResult(
+      final EncodedImage originalResult,
+      final Consumer<EncodedImage> consumer,
+      final ProducerContext producerContext) {
+    Preconditions.checkNotNull(originalResult);
+    final EncodedImage encodedImageCopy = EncodedImage.cloneOrNull(originalResult);
+    final StatefulProducerRunnable<EncodedImage> runnable =
+        new StatefulProducerRunnable<EncodedImage>(
+            consumer,
+            producerContext.getListener(),
+            PRODUCER_NAME,
+            producerContext.getId()) {
+          @Override
+          protected EncodedImage getResult() throws Exception {
+            PooledByteBufferOutputStream outputStream = mPooledByteBufferFactory.newOutputStream();
+            try {
+              doTranscode(encodedImageCopy, outputStream);
+              CloseableReference<PooledByteBuffer> ref =
+                  CloseableReference.of(outputStream.toByteBuffer());
+              try {
+                EncodedImage encodedImage = new EncodedImage(ref);
+                encodedImage.copyMetaDataFrom(encodedImageCopy);
+                return encodedImage;
+              } finally {
+                CloseableReference.closeSafely(ref);
+              }
+            } finally {
+              outputStream.close();
+            }
+          }
+
+          @Override
+          protected void disposeResult(EncodedImage result) {
+            EncodedImage.closeSafely(result);
+          }
+
+          @Override
+          protected void onSuccess(EncodedImage result) {
+            EncodedImage.closeSafely(encodedImageCopy);
+            super.onSuccess(result);
+          }
+
+          @Override
+          protected void onFailure(Exception e) {
+            EncodedImage.closeSafely(encodedImageCopy);
+            super.onFailure(e);
+          }
+
+          @Override
+          protected void onCancellation() {
+            EncodedImage.closeSafely(encodedImageCopy);
+            super.onCancellation();
+          }
+        };
+    mExecutor.execute(runnable);
+  }
+
+
+  /**
+   *  bpg format cannot be opened as is on any android platform and it should be decoded to bitmaps
+   *  */
+  private static TriState shouldTranscode(final EncodedImage encodedImage) {
+    Preconditions.checkNotNull(encodedImage);
+    return TriState.YES;
+  }
+
+  private static void doTranscode(
+      final EncodedImage encodedImage,
+      final PooledByteBufferOutputStream outputStream) throws Exception {
+    InputStream imageInputStream = encodedImage.getInputStream();
+    final byte[] imageHeaderBytes = new byte[BpgHeaderInfo.EXTENDED_BPG_HEADER_LENGTH];
+    ImageFormat imageFormat = ImageFormatChecker
+                                .getImageFormat_WrapIOException(
+                                    imageHeaderBytes,
+                                    imageInputStream);
+    switch (imageFormat) {
+      case BPG_SIMPLE:
+      case BPG_EXTENDED:
+        BpgTranscoder.transcodeBpgToBmp(imageHeaderBytes, imageInputStream, outputStream);
+        break;
+
+      case BPG_LOSSLESS:
+      case BPG_EXTENDED_WITH_ALPHA:
+//        BpgTranscoder.transcodeBpgToPng(imageInputStream, outputStream);
+        //not supported yet
+        throw new IllegalArgumentException("Cannot decode to PNG yet");
+      default:
+        throw new IllegalArgumentException("Wrong image format");
+    }
+  }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imageutils/BytesPatternMatcher.java b/imagepipeline/src/main/java/com/facebook/imageutils/BytesPatternMatcher.java
new file mode 100644
index 000000000..a3c0e35fc
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imageutils/BytesPatternMatcher.java
@@ -0,0 +1,21 @@
+package com.facebook.imageutils;
+
+public class BytesPatternMatcher {
+
+  public static boolean matchBytePattern(
+          final byte[] byteArray,
+          final int offset,
+          final byte[] pattern) {
+    if (pattern.length + offset > byteArray.length) {
+      return false;
+    }
+
+    for (int i = 0; i < pattern.length; ++i) {
+      if (byteArray[i + offset] != pattern[i]) {
+        return false;
+      }
+    }
+
+    return true;
+  }
+}
