diff --git a/.lastsync b/.lastsync
deleted file mode 100644
index 3ca5c0403..000000000
--- a/.lastsync
+++ /dev/null
@@ -1 +0,0 @@
-86ee68f6add139d237b3b47d4f8360b0b25515e1
\ No newline at end of file
diff --git a/README.md b/README.md
index 8144091a8..ff772d8fd 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,6 @@
-# Fresco 
+# Fresco
+
+[![Build Status](https://circleci.com/gh/facebook/fresco.svg?style=shield)](https://circleci.com/gh/facebook/fresco)
 
 Fresco is a powerful system for displaying images in Android applications.
 
@@ -17,9 +19,9 @@ Find out more at our [website](http://frescolib.org/index.html).
 
 ## Requirements
 
-Fresco can be included in any Android application. 
+Fresco can be included in any Android application.
 
-Fresco supports Android 2.3 (Gingerbread) and later. 
+Fresco supports Android 2.3 (Gingerbread) and later.
 
 ## Using Fresco in your application
 
diff --git a/animated-base-support/.gitignore b/animated-base-support/.gitignore
new file mode 100644
index 000000000..8afd910ce
--- /dev/null
+++ b/animated-base-support/.gitignore
@@ -0,0 +1 @@
+nativedeps/
diff --git a/animated-base-support/build.gradle b/animated-base-support/build.gradle
new file mode 100644
index 000000000..9432d7984
--- /dev/null
+++ b/animated-base-support/build.gradle
@@ -0,0 +1,48 @@
+apply plugin: 'com.android.library'
+apply plugin: 'maven'
+
+project.group = GROUP
+version = VERSION_NAME
+
+
+dependencies {
+    provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
+    provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    compile "com.parse.bolts:bolts-android:${BOLTS_ANDROID_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
+    compile "com.nineoldandroids:library:${NINEOLDANDROID_VERSION}"
+    compile project(':fbcore')
+    compile project(':animated-base')
+
+    testCompile project(':animated-base')
+    testCompile project(':animated-base-test')
+    testCompile project(':imagepipeline-test')
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_CORE_VERSION}"
+    testCompile("org.powermock:powermock-api-mockito:${POWERMOCK_VERSION}") {
+        exclude group: 'org.mockito', module: 'mockito-all'
+    }
+    testCompile "org.powermock:powermock-module-junit4-rule:${POWERMOCK_VERSION}"
+    testCompile "org.powermock:powermock-classloading-xstream:${POWERMOCK_VERSION}"
+    testCompile("org.robolectric:robolectric:${ROBOLECTRIC_VERSION}") {
+        exclude group: 'commons-logging', module: 'commons-logging'
+        exclude group: 'org.apache.httpcomponents', module: 'httpclient'
+    }
+}
+apply from: rootProject.file('release.gradle')
+
+android {
+
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    lintOptions {
+        abortOnError false
+    }
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+artifacts.add('archives', sourcesJar)
diff --git a/animated-base-support/gradle.properties b/animated-base-support/gradle.properties
new file mode 100644
index 000000000..65693d72d
--- /dev/null
+++ b/animated-base-support/gradle.properties
@@ -0,0 +1,5 @@
+POM_NAME=AnimatedBaseSupport
+POM_DESCRIPTION=Base classes for animation support using NineOldAndroid
+POM_ARTIFACT_ID=animated-base-support
+POM_PACKAGING=aar
+
diff --git a/animated-base-support/src/main/AndroidManifest.xml b/animated-base-support/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..8a7184a83
--- /dev/null
+++ b/animated-base-support/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.imagepipeline.animated.support"
+    >
+
+  <uses-sdk
+      android:minSdkVersion="9"
+      android:targetSdkVersion="21"
+      />
+</manifest>
diff --git a/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawableSupport.java b/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawableSupport.java
new file mode 100644
index 000000000..c42e68e82
--- /dev/null
+++ b/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawableSupport.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.animated.base;
+
+import android.graphics.drawable.Animatable;
+
+import com.nineoldandroids.animation.ValueAnimator;
+
+/**
+ * An interface for animatable drawables that can be asked to construct a value animator.
+ */
+public interface AnimatableDrawableSupport extends Animatable {
+
+  /**
+   * An animator that will animate the drawable directly. The loop count and duration will
+   * be determined by metadata in the original image. Update listener is attached automatically.
+   *
+   * @return a new animator
+   */
+  ValueAnimator createValueAnimator();
+
+  /**
+   * An animator that will animate the drawable directly. The loop count will be set based on
+   * the specified duration. Update listener is attached automatically.
+   *
+   * @param maxDurationMs maximum duration animate
+   * @return a new animator
+   */
+  ValueAnimator createValueAnimator(int maxDurationMs);
+
+  /**
+   * Creates an animator update listener that will animate the drawable directly. This is useful
+   * when the drawable needs to be animated by an existing value animator.
+   * @return a new update listener
+   */
+  ValueAnimator.AnimatorUpdateListener createAnimatorUpdateListener();
+}
diff --git a/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableSupport.java b/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableSupport.java
new file mode 100644
index 000000000..41ed829ce
--- /dev/null
+++ b/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableSupport.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.animated.base;
+
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.drawable.Animatable;
+import android.graphics.drawable.Drawable;
+import android.view.animation.LinearInterpolator;
+
+import com.facebook.common.internal.VisibleForTesting;
+import com.facebook.common.logging.FLog;
+import com.facebook.common.references.CloseableReference;
+import com.facebook.common.time.MonotonicClock;
+import com.facebook.drawable.base.DrawableWithCaches;
+
+import com.nineoldandroids.animation.ValueAnimator;
+
+/**
+ * A {@link Drawable} that renders a animated image. The details of the format are abstracted by the
+ * {@link AnimatedDrawableBackend} interface. The drawable can work either as an {@link Animatable}
+ * where the client calls start/stop to animate it or it can work as a level-based drawable where
+ * the client drives the animation by calling {@link Drawable#setLevel}.
+ */
+public class AnimatedDrawableSupport extends AbstractAnimatedDrawable
+    implements AnimatableDrawableSupport {
+
+  public AnimatedDrawableSupport(
+      ScheduledExecutorService scheduledExecutorServiceForUiThread,
+      AnimatedDrawableCachingBackend animatedDrawableBackend,
+      AnimatedDrawableDiagnostics animatedDrawableDiagnostics,
+      MonotonicClock monotonicClock) {
+    super(scheduledExecutorServiceForUiThread,
+        animatedDrawableBackend,
+        animatedDrawableDiagnostics,
+        monotonicClock);
+  }
+
+
+  @Override
+  public ValueAnimator createValueAnimator(int maxDurationMs) {
+    ValueAnimator animator = createValueAnimator();
+    int repeatCount = Math.max((maxDurationMs / getAnimatedDrawableBackend().getDurationMs()), 1);
+    animator.setRepeatCount(repeatCount);
+    return animator;
+  }
+
+  @Override
+  public ValueAnimator createValueAnimator() {
+    int loopCount = getAnimatedDrawableBackend().getLoopCount();
+    ValueAnimator animator = new ValueAnimator();
+    animator.setIntValues(0, getDuration());
+    animator.setDuration(getDuration());
+    animator.setRepeatCount(loopCount != 0 ? loopCount : ValueAnimator.INFINITE);
+    animator.setRepeatMode(ValueAnimator.RESTART);
+    animator.setInterpolator(new LinearInterpolator());
+    animator.addUpdateListener(createAnimatorUpdateListener());
+    return animator;
+  }
+
+  @Override
+  public ValueAnimator.AnimatorUpdateListener createAnimatorUpdateListener() {
+    return new ValueAnimator.AnimatorUpdateListener() {
+      @Override
+      public void onAnimationUpdate(ValueAnimator animation) {
+        setLevel((Integer) animation.getAnimatedValue());
+      }
+    };
+  }
+
+}
diff --git a/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactoryImplSupport.java b/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactoryImplSupport.java
new file mode 100644
index 000000000..e19284cba
--- /dev/null
+++ b/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactoryImplSupport.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.animated.factory;
+
+import java.util.concurrent.ScheduledExecutorService;
+
+import android.content.res.Resources;
+import android.graphics.Rect;
+import android.os.SystemClock;
+import android.util.DisplayMetrics;
+import android.graphics.drawable.Drawable;
+
+import com.facebook.common.time.MonotonicClock;
+import com.facebook.imagepipeline.image.CloseableImage;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableBackend;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableCachingBackend;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableDiagnostics;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableOptions;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableSupport;
+import com.facebook.imagepipeline.animated.base.AnimatedImage;
+import com.facebook.imagepipeline.animated.base.AnimatedImageResult;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableBackendProvider;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableCachingBackendImplProvider;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableDiagnosticsImpl;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableDiagnosticsNoop;
+import com.facebook.imagepipeline.animated.util.AnimatedDrawableUtil;
+import com.facebook.imagepipeline.image.CloseableAnimatedImage;
+
+/**
+ * Factory for instances of {@link AnimatedDrawableSupport}.
+ */
+public class AnimatedDrawableFactoryImplSupport implements AnimatedDrawableFactory {
+
+  private final AnimatedDrawableBackendProvider mAnimatedDrawableBackendProvider;
+  private final AnimatedDrawableCachingBackendImplProvider mAnimatedDrawableCachingBackendProvider;
+  private final AnimatedDrawableUtil mAnimatedDrawableUtil;
+  private final ScheduledExecutorService mScheduledExecutorServiceForUiThread;
+  private final MonotonicClock mMonotonicClock;
+  private final Resources mResources;
+
+  public AnimatedDrawableFactoryImplSupport(
+      AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
+      AnimatedDrawableCachingBackendImplProvider animatedDrawableCachingBackendProvider,
+      AnimatedDrawableUtil animatedDrawableUtil,
+      ScheduledExecutorService scheduledExecutorService,
+      Resources resources) {
+    mAnimatedDrawableBackendProvider = animatedDrawableBackendProvider;
+    mAnimatedDrawableCachingBackendProvider = animatedDrawableCachingBackendProvider;
+    mAnimatedDrawableUtil = animatedDrawableUtil;
+    mScheduledExecutorServiceForUiThread = scheduledExecutorService;
+    mMonotonicClock = new MonotonicClock() {
+      @Override
+      public long now() {
+        // Must be SystemClock.uptimeMillis to be compatible with what Android's View uses.
+        return SystemClock.uptimeMillis();
+      }
+    };
+    mResources = resources;
+  }
+
+  /**
+   * Creates an {@link AnimatedDrawable} based on an {@link CloseableImage} which should be a
+   * CloseableAnimatedImage.
+   *
+   * @param closeableImage The CloseableAnimatedImage to use for the AnimatedDrawable
+   * @return a newly constructed {@link AnimatedDrawable}
+   */
+  @Override
+  public Drawable create(CloseableImage closeableImage) {
+    if (closeableImage instanceof CloseableAnimatedImage) {
+      final AnimatedImageResult result = ((CloseableAnimatedImage) closeableImage).getImageResult();
+      return create(result, AnimatedDrawableOptions.DEFAULTS);
+    } else {
+      throw new UnsupportedOperationException("Unrecognized image class: " + closeableImage);
+    }
+  }
+
+  /**
+   * Creates an {@link AnimatedDrawable} based on an {@link AnimatedImage}.
+   *
+   * @param animatedImageResult the result of the code
+   * @param options additional options
+   * @return a newly constructed {@link AnimatedDrawable}
+   */
+  private AnimatedDrawableSupport create(
+      AnimatedImageResult animatedImageResult,
+      AnimatedDrawableOptions options) {
+    AnimatedImage animatedImage = animatedImageResult.getImage();
+    Rect initialBounds = new Rect(0, 0, animatedImage.getWidth(), animatedImage.getHeight());
+    AnimatedDrawableBackend animatedDrawableBackend =
+        mAnimatedDrawableBackendProvider.get(animatedImageResult, initialBounds);
+    return createAnimatedDrawable(options, animatedDrawableBackend);
+  }
+
+  private AnimatedImageResult getImageIfCloseableAnimatedImage(CloseableImage image) {
+    if (image instanceof CloseableAnimatedImage) {
+      return ((CloseableAnimatedImage) image).getImageResult();
+    }
+    return null;
+  }
+
+  private AnimatedDrawableSupport createAnimatedDrawable(
+      AnimatedDrawableOptions options,
+      AnimatedDrawableBackend animatedDrawableBackend) {
+    DisplayMetrics displayMetrics = mResources.getDisplayMetrics();
+    AnimatedDrawableDiagnostics animatedDrawableDiagnostics;
+    AnimatedDrawableCachingBackend animatedDrawableCachingBackend =
+        mAnimatedDrawableCachingBackendProvider.get(
+            animatedDrawableBackend,
+            options);
+    if (options.enableDebugging) {
+      animatedDrawableDiagnostics =
+          new AnimatedDrawableDiagnosticsImpl(mAnimatedDrawableUtil, displayMetrics);
+    } else {
+      animatedDrawableDiagnostics = AnimatedDrawableDiagnosticsNoop.getInstance();
+    }
+
+    return new AnimatedDrawableSupport(
+        mScheduledExecutorServiceForUiThread,
+        animatedDrawableCachingBackend,
+        animatedDrawableDiagnostics,
+        mMonotonicClock);
+  }
+}
diff --git a/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactoryImplSupport.java b/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactoryImplSupport.java
new file mode 100644
index 000000000..8ff75514a
--- /dev/null
+++ b/animated-base-support/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactoryImplSupport.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+package com.facebook.imagepipeline.animated.factory;
+
+import java.util.concurrent.ScheduledExecutorService;
+import javax.annotation.concurrent.NotThreadSafe;
+
+import android.content.res.Resources;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableBackend;
+import com.facebook.imagepipeline.animated.factory.AnimatedDrawableFactory;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableBackendProvider;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableCachingBackendImpl;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableCachingBackendImplProvider;
+import com.facebook.imagepipeline.animated.util.AnimatedDrawableUtil;
+import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
+import com.facebook.imagepipeline.core.ExecutorSupplier;
+import com.facebook.common.internal.DoNotStrip;
+
+@NotThreadSafe
+@DoNotStrip
+public class AnimatedFactoryImplSupport extends AnimatedFactoryImpl {
+
+  public AnimatedFactoryImplSupport(
+      PlatformBitmapFactory platformBitmapFactory,
+      ExecutorSupplier executorSupplier) {
+    super(platformBitmapFactory,
+        executorSupplier);
+  }
+
+  @Override
+  protected AnimatedDrawableFactory createAnimatedDrawableFactory(
+      AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
+      AnimatedDrawableCachingBackendImplProvider animatedDrawableCachingBackendImplProvider,
+      AnimatedDrawableUtil animatedDrawableUtil,
+      ScheduledExecutorService scheduledExecutorService,
+      Resources resources) {
+    return new AnimatedDrawableFactoryImplSupport(
+        animatedDrawableBackendProvider,
+        animatedDrawableCachingBackendImplProvider,
+        animatedDrawableUtil,
+        scheduledExecutorService,
+        resources);
+  }
+
+}
diff --git a/animated-base-support/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableSupportTest.java b/animated-base-support/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableSupportTest.java
new file mode 100644
index 000000000..42e99b3d2
--- /dev/null
+++ b/animated-base-support/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableSupportTest.java
@@ -0,0 +1,310 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.animated.base;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+
+import com.facebook.common.references.CloseableReference;
+import com.facebook.common.references.ResourceReleaser;
+import com.facebook.imagepipeline.testing.FakeClock;
+import org.robolectric.RobolectricTestRunner;
+import com.facebook.imagepipeline.animated.testing.MyShadowBitmap;
+import com.facebook.imagepipeline.animated.testing.MyShadowCanvas;
+import com.facebook.imagepipeline.animated.testing.TestAnimatedDrawableSupportBackend;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableDiagnosticsNoop;
+import com.facebook.imagepipeline.testing.TestScheduledExecutorService;
+
+import com.nineoldandroids.animation.ValueAnimator;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static com.facebook.imagepipeline.animated.testing.TestAnimatedDrawableSupportBackend.pixelValue;
+import static org.junit.Assert.*;
+
+/**
+ * Tests for {@link AnimatedDrawable}.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {MyShadowCanvas.class, MyShadowBitmap.class})
+public class AnimatedDrawableSupportTest {
+
+  private static final int WIDTH = 200;
+  private static final int HEIGHT = 100;
+  private static final int[] FRAME_DURATIONS = new int[]{ 60, 30, 15, 30, 60 };
+  private static final int[] FRAME_DURATIONS_LONG = new int[]{ 10000, 10000 };
+
+  private FakeClock mFakeClock;
+  private TestScheduledExecutorService mTestScheduledExecutorService;
+  private TestAnimatedDrawableSupportBackend mBackend;
+  private TestAnimatedDrawableCachingBackend mCachingBackend;
+  private MyCallback mCallback;
+  private AnimatedDrawableSupport mDrawable;
+
+  @Before
+  public void setup() {
+    mFakeClock = new FakeClock();
+    mTestScheduledExecutorService = new TestScheduledExecutorService(mFakeClock);
+    mBackend = new TestAnimatedDrawableSupportBackend(WIDTH, HEIGHT, FRAME_DURATIONS);
+    mCachingBackend = new TestAnimatedDrawableCachingBackend(mBackend);
+    mCallback = new MyCallback(mFakeClock);
+    mDrawable = new AnimatedDrawableSupport(
+        mTestScheduledExecutorService,
+        mCachingBackend,
+        AnimatedDrawableDiagnosticsNoop.getInstance(),
+        mFakeClock);
+    mDrawable.setCallback(mCallback);
+  }
+
+  @Test
+  public void testIntrinsicDimensions() {
+    assertEquals(WIDTH, mDrawable.getIntrinsicWidth());
+    assertEquals(HEIGHT, mDrawable.getIntrinsicHeight());
+  }
+
+  @Test
+  public void testValueAnimator() {
+    ValueAnimator valueAnimator = mDrawable.createValueAnimator();
+    assertEquals(mBackend.getDurationMs(), valueAnimator.getDuration());
+    assertEquals(ValueAnimator.INFINITE, valueAnimator.getRepeatCount());
+  }
+
+  @Test
+  public void testScheduling() {
+    Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+    Canvas canvas = new Canvas(bitmap);
+    prepareDrawable();
+
+    // Spot check a pixel. Should be frame 0.
+    mDrawable.draw(canvas);
+    assertEquals(pixelValue(0, 10, 20), bitmap.getPixel(10, 20));
+
+    // Advance just before next frame.
+    mFakeClock.incrementBy(FRAME_DURATIONS[0] - 1);
+    mDrawable.draw(canvas);
+    assertEquals(pixelValue(0, 10, 20), bitmap.getPixel(10, 20));
+
+    // Advance just to second frame.
+    mFakeClock.incrementBy(1);
+    mDrawable.draw(canvas);
+    assertEquals(pixelValue(1, 10, 20), bitmap.getPixel(10, 20));
+
+    // Advance to the last millisecond of the last frame.
+    mFakeClock.incrementBy(FRAME_DURATIONS[1]);
+    mFakeClock.incrementBy(FRAME_DURATIONS[2]);
+    mFakeClock.incrementBy(FRAME_DURATIONS[3]);
+    mFakeClock.incrementBy(FRAME_DURATIONS[4] - 1);
+    mDrawable.draw(canvas);
+    assertEquals(pixelValue(4, 10, 20), bitmap.getPixel(10, 20));
+
+    // Make sure wrapping works.
+    mFakeClock.incrementBy(1);
+    mDrawable.draw(canvas);
+    assertEquals(pixelValue(0, 10, 20), bitmap.getPixel(10, 20));
+    assertEquals(1, mBackend.getDropCachesCallCount());
+  }
+
+  @Test
+  public void testDropCachesAfterDrawTimeout() {
+    Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+    Canvas canvas = new Canvas(bitmap);
+    prepareDrawable();
+
+    // Draw and advance to next frame.
+    mDrawable.draw(canvas);
+
+    // Make sure caches are dropped after couple seconds without a draw call.
+    assertFalse(mDrawable.isWaitingForDraw());
+    mFakeClock.incrementBy(60);
+    assertTrue(mDrawable.isWaitingForDraw());
+    mFakeClock.incrementBy(1940);
+    assertEquals(2, mBackend.getDropCachesCallCount());
+  }
+
+  @Test
+  public void testDropCachesAfterNextFrameTimeout() {
+    Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+    Canvas canvas = new Canvas(bitmap);
+    prepareDrawable();
+
+    // Draw and advance to next frame.
+    mDrawable.draw(canvas);
+
+    // Make sure caches are dropped after couple seconds.
+    assertFalse(mDrawable.isWaitingForDraw());
+    assertTrue(mDrawable.isWaitingForNextFrame());
+    mCallback.setDropCallbacks(true);
+    mFakeClock.incrementBy(2000);
+    assertEquals(2, mBackend.getDropCachesCallCount());
+  }
+
+  @Test
+  public void testDoNotDropCacheIfFramesAreLongDurationSpecialCase() {
+    mBackend = new TestAnimatedDrawableSupportBackend(WIDTH, HEIGHT, FRAME_DURATIONS_LONG);
+    mCachingBackend = new TestAnimatedDrawableCachingBackend(mBackend);
+    mCallback = new MyCallback(mFakeClock);
+    mDrawable = new AnimatedDrawableSupport(
+        mTestScheduledExecutorService,
+        mCachingBackend,
+        AnimatedDrawableDiagnosticsNoop.getInstance(),
+        mFakeClock);
+    mDrawable.setCallback(mCallback);
+
+    Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+    Canvas canvas = new Canvas(bitmap);
+    prepareDrawable();
+
+    // Draw and advance to next frame.
+    mDrawable.draw(canvas);
+
+    // After 10 seconds, it should move to the next frame. It shouldn't drop the caches though
+    // until it's 2 seconds after the invalidate.
+    assertFalse(mDrawable.isWaitingForDraw());
+    assertTrue(mDrawable.isWaitingForNextFrame());
+    assertEquals(0, mDrawable.getScheduledFrameNumber());
+    mFakeClock.incrementBy(10000);
+    assertTrue(mDrawable.isWaitingForDraw());
+    assertFalse(mDrawable.isWaitingForNextFrame());
+    assertEquals(1, mDrawable.getScheduledFrameNumber());
+    assertEquals(1, mBackend.getDropCachesCallCount());
+    mFakeClock.incrementBy(1000);
+    assertEquals(1, mBackend.getDropCachesCallCount());
+    mFakeClock.incrementBy(2000);
+    assertEquals(2, mBackend.getDropCachesCallCount());
+  }
+
+  private void prepareDrawable() {
+    mDrawable.start();
+    mFakeClock.incrementBy(0); // Just to trigger the callbacks to run.
+    mDrawable.setBounds(0, 0, 200, 100);
+    assertEquals(1, mBackend.getDropCachesCallCount());
+  }
+
+  private static class ScheduledRunnable {
+
+    final Runnable runnable;
+    final long when;
+
+    private ScheduledRunnable(Runnable runnable, long when) {
+      this.runnable = runnable;
+      this.when = when;
+    }
+  }
+
+  private static class TestAnimatedDrawableCachingBackend extends DelegatingAnimatedDrawableBackend
+      implements AnimatedDrawableCachingBackend {
+
+    public TestAnimatedDrawableCachingBackend(AnimatedDrawableBackend animatedDrawableBackend) {
+      super(animatedDrawableBackend);
+    }
+
+    @Override
+    public CloseableReference<Bitmap> getBitmapForFrame(int frameNumber) {
+      Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+      getDelegate().renderFrame(frameNumber, new Canvas(bitmap));
+      return CloseableReference.of(
+          bitmap,
+          new ResourceReleaser<Bitmap>() {
+            @Override
+            public void release(Bitmap value) {
+
+            }
+          });
+    }
+
+    @Override
+    public CloseableReference<Bitmap> getPreviewBitmap() {
+      return null;
+    }
+
+    @Override
+    public CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber) {
+      return null;
+    }
+
+    @Override
+    public void appendDebugOptionString(StringBuilder sb) {
+    }
+
+    @Override
+    public AnimatedDrawableCachingBackend forNewBounds(Rect bounds) {
+      return this;
+    }
+  }
+
+  private static class MyCallback implements Drawable.Callback {
+
+    private final FakeClock mFakeClock;
+    private final List<ScheduledRunnable> mScheduledRunnables = new ArrayList<>();
+    private boolean mDropCallbacks;
+
+    MyCallback(FakeClock fakeClock) {
+      mFakeClock = fakeClock;
+      mFakeClock.addListener(
+          new FakeClock.OnTickListener() {
+            @Override
+            public void onTick() {
+              runReadyTasks();
+            }
+          });
+    }
+
+    @Override
+    public void invalidateDrawable(Drawable who) {
+
+    }
+
+    @Override
+    public void scheduleDrawable(Drawable who, Runnable what, long when) {
+      mScheduledRunnables.add(new ScheduledRunnable(what, when));
+    }
+
+    @Override
+    public void unscheduleDrawable(Drawable who, Runnable what) {
+      Iterator<ScheduledRunnable> iterator = mScheduledRunnables.iterator();
+      while (iterator.hasNext()) {
+        ScheduledRunnable next = iterator.next();
+        if (next.runnable == what) {
+          iterator.remove();
+        }
+      }
+    }
+
+    void runReadyTasks() {
+      List<Runnable> toRun = new ArrayList<>();
+      long now = mFakeClock.now();
+      Iterator<ScheduledRunnable> iterator = mScheduledRunnables.iterator();
+      while (iterator.hasNext()) {
+        ScheduledRunnable next = iterator.next();
+        if (next.when <= now) {
+          iterator.remove();
+          toRun.add(next.runnable);
+        }
+      }
+      if (!mDropCallbacks) {
+        for (Runnable runnable : toRun) {
+          runnable.run();
+        }
+      }
+    }
+
+    void setDropCallbacks(boolean dropCallbacks) {
+      mDropCallbacks = dropCallbacks;
+    }
+  }
+}
diff --git a/animated-base-support/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableSupportBackend.java b/animated-base-support/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableSupportBackend.java
new file mode 100644
index 000000000..137b788d2
--- /dev/null
+++ b/animated-base-support/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableSupportBackend.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.animated.testing;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+
+import com.facebook.common.references.CloseableReference;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableBackend;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableFrameInfo;
+import com.facebook.imagepipeline.animated.base.AnimatedImageResult;
+
+/**
+ * Implementation of {@link AnimatedDrawableBackend} for unit tests.
+ */
+public class TestAnimatedDrawableSupportBackend implements AnimatedDrawableBackend {
+
+  private final int mWidth;
+  private final int mHeight;
+  private final int[] mFrameDurations;
+  private final int[] mAccumulatedDurationsMs;
+
+  private int mDropCachesCallCount;
+
+  public TestAnimatedDrawableSupportBackend(int width, int height, int[] frameDurations) {
+    mWidth = width;
+    mHeight = height;
+    mFrameDurations = frameDurations;
+    mAccumulatedDurationsMs = new int[mFrameDurations.length];
+    int accumulatedDurationMs = 0;
+    for (int i = 0; i < mAccumulatedDurationsMs.length; i++) {
+      mAccumulatedDurationsMs[i] = accumulatedDurationMs + mFrameDurations[i];
+      accumulatedDurationMs = mAccumulatedDurationsMs[i];
+    }
+  }
+
+  public static int pixelValue(int frameNumber, int x, int y) {
+    return ((frameNumber & 0xff) << 16) | ((x & 0xff) << 8) | ((y & 0xff));
+  }
+
+  @Override
+  public AnimatedImageResult getAnimatedImageResult() {
+    return null;
+  }
+
+  @Override
+  public int getDurationMs() {
+    return mAccumulatedDurationsMs[mAccumulatedDurationsMs.length - 1];
+  }
+
+  @Override
+  public int getFrameCount() {
+    return mFrameDurations.length;
+  }
+
+  @Override
+  public int getLoopCount() {
+    return 0;
+  }
+
+  @Override
+  public int getWidth() {
+    return mWidth;
+  }
+
+  @Override
+  public int getHeight() {
+    return mHeight;
+  }
+
+  @Override
+  public int getRenderedWidth() {
+    return mWidth;
+  }
+
+  @Override
+  public int getRenderedHeight() {
+    return mHeight;
+  }
+
+  @Override
+  public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
+    return new AnimatedDrawableFrameInfo(
+        frameNumber,
+        0,
+        0,
+        mWidth,
+        mHeight,
+        false,
+        AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_DO_NOT);
+  }
+
+  @Override
+  public void renderFrame(int frameNumber, Canvas canvas) {
+    int[] pixels = new int[mWidth * mHeight];
+    for (int i = 0; i < pixels.length; i++) {
+      // We store the frame number in the R, the x in the G, and the y in the B.
+      int x = i % mWidth;
+      int y = i / mWidth;
+      pixels[i] = pixelValue(frameNumber, x, y);
+    }
+    Bitmap bitmap = Bitmap.createBitmap(pixels, mWidth, mHeight, Bitmap.Config.ARGB_8888);
+    canvas.drawBitmap(bitmap, 0, 0, null);
+  }
+
+  @Override
+  public int getFrameForTimestampMs(int timestampMs) {
+    int accumulator = 0;
+    for (int i = 0; i < mFrameDurations.length; i++) {
+      if (timestampMs < accumulator + mFrameDurations[i]) {
+        return i;
+      }
+      accumulator += mFrameDurations[i];
+    }
+    return mFrameDurations.length - 1;
+  }
+
+  @Override
+  public int getTimestampMsForFrame(int frameNumber) {
+    return frameNumber == 0 ? 0 : mAccumulatedDurationsMs[frameNumber - 1];
+  }
+
+  @Override
+  public int getDurationMsForFrame(int frameNumber) {
+    return mFrameDurations[frameNumber];
+  }
+
+  @Override
+  public int getFrameForPreview() {
+    return 0;
+  }
+
+  @Override
+  public AnimatedDrawableBackend forNewBounds(Rect bounds) {
+    return this;
+  }
+
+  @Override
+  public int getMemoryUsage() {
+    return 0;
+  }
+
+  @Override
+  public CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber) {
+    return null;
+  }
+
+  @Override
+  public boolean hasPreDecodedFrame(int frameNumber) {
+    return false;
+  }
+
+  public int getDropCachesCallCount() {
+    return mDropCachesCallCount;
+  }
+
+  @Override
+  public void dropCaches() {
+    mDropCachesCallCount++;
+  }
+}
diff --git a/animated-base-test/.gitignore b/animated-base-test/.gitignore
new file mode 100644
index 000000000..8afd910ce
--- /dev/null
+++ b/animated-base-test/.gitignore
@@ -0,0 +1 @@
+nativedeps/
diff --git a/animated-base-test/build.gradle b/animated-base-test/build.gradle
new file mode 100644
index 000000000..176c27dc5
--- /dev/null
+++ b/animated-base-test/build.gradle
@@ -0,0 +1,44 @@
+apply plugin: 'com.android.library'
+apply plugin: 'maven'
+
+project.group = GROUP
+version = VERSION_NAME
+
+
+dependencies {
+    provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
+    provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    compile "com.parse.bolts:bolts-android:${BOLTS_ANDROID_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
+    compile "com.nineoldandroids:library:${NINEOLDANDROID_VERSION}"
+    compile project(':fbcore')
+
+    compile "junit:junit:${JUNIT_VERSION}"
+    compile "org.mockito:mockito-core:${MOCKITO_CORE_VERSION}"
+    compile("org.powermock:powermock-api-mockito:${POWERMOCK_VERSION}") {
+        exclude group: 'org.mockito', module: 'mockito-all'
+    }
+    compile "org.powermock:powermock-module-junit4-rule:${POWERMOCK_VERSION}"
+    compile "org.powermock:powermock-classloading-xstream:${POWERMOCK_VERSION}"
+    compile("org.robolectric:robolectric:${ROBOLECTRIC_VERSION}") {
+        exclude group: 'commons-logging', module: 'commons-logging'
+        exclude group: 'org.apache.httpcomponents', module: 'httpclient'
+    }
+}
+apply from: rootProject.file('release.gradle')
+
+android {
+
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    lintOptions {
+        abortOnError false
+    }
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+artifacts.add('archives', sourcesJar)
diff --git a/animated-base-test/gradle.properties b/animated-base-test/gradle.properties
new file mode 100644
index 000000000..1fcb822ea
--- /dev/null
+++ b/animated-base-test/gradle.properties
@@ -0,0 +1,5 @@
+POM_NAME=AnimatedBaseTest
+POM_DESCRIPTION=Utility classes for tests about animation support
+POM_ARTIFACT_ID=animated-base-test
+POM_PACKAGING=aar
+
diff --git a/animated-base-test/src/main/AndroidManifest.xml b/animated-base-test/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..eafe325e1
--- /dev/null
+++ b/animated-base-test/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.imagepipeline.animated.test"
+    >
+
+  <uses-sdk
+      android:minSdkVersion="9"
+      android:targetSdkVersion="21"
+      />
+</manifest>
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowBitmap.java b/animated-base-test/src/main/java/com/facebook/imagepipeline/animated/testing/MyShadowBitmap.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowBitmap.java
rename to animated-base-test/src/main/java/com/facebook/imagepipeline/animated/testing/MyShadowBitmap.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowCanvas.java b/animated-base-test/src/main/java/com/facebook/imagepipeline/animated/testing/MyShadowCanvas.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowCanvas.java
rename to animated-base-test/src/main/java/com/facebook/imagepipeline/animated/testing/MyShadowCanvas.java
diff --git a/animated-base/.gitignore b/animated-base/.gitignore
new file mode 100644
index 000000000..8afd910ce
--- /dev/null
+++ b/animated-base/.gitignore
@@ -0,0 +1 @@
+nativedeps/
diff --git a/animated-base/build.gradle b/animated-base/build.gradle
new file mode 100644
index 000000000..7ee935c33
--- /dev/null
+++ b/animated-base/build.gradle
@@ -0,0 +1,54 @@
+apply plugin: 'com.android.library'
+apply plugin: 'maven'
+
+project.group = GROUP
+version = VERSION_NAME
+
+
+dependencies {
+    provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
+    provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    compile "com.parse.bolts:bolts-android:${BOLTS_ANDROID_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
+    compile "com.nineoldandroids:library:${NINEOLDANDROID_VERSION}"
+    compile project(':fbcore')
+    compile project(':imagepipeline-base')
+    compile project(':imagepipeline')
+
+    testCompile project(':animated-base-test')
+    testCompile project(':imagepipeline-test')
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_CORE_VERSION}"
+    testCompile("org.powermock:powermock-api-mockito:${POWERMOCK_VERSION}") {
+        exclude group: 'org.mockito', module: 'mockito-all'
+    }
+    testCompile "org.powermock:powermock-module-junit4-rule:${POWERMOCK_VERSION}"
+    testCompile "org.powermock:powermock-classloading-xstream:${POWERMOCK_VERSION}"
+    testCompile("org.robolectric:robolectric:${ROBOLECTRIC_VERSION}") {
+        exclude group: 'commons-logging', module: 'commons-logging'
+        exclude group: 'org.apache.httpcomponents', module: 'httpclient'
+    }
+}
+apply from: rootProject.file('release.gradle')
+
+android {
+
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    lintOptions {
+        abortOnError false
+    }
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+
+task testJar(type: Jar) {
+    from android.sourceSets.test.java.srcDirs
+    classifier = 'sources'
+}
+
+artifacts.add('archives', sourcesJar)
diff --git a/animated-base/gradle.properties b/animated-base/gradle.properties
new file mode 100644
index 000000000..a44917f8e
--- /dev/null
+++ b/animated-base/gradle.properties
@@ -0,0 +1,5 @@
+POM_NAME=AnimatedBase
+POM_DESCRIPTION=Base classes for animation support
+POM_ARTIFACT_ID=animated-base
+POM_PACKAGING=aar
+
diff --git a/animated-base/src/main/AndroidManifest.xml b/animated-base/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..fd3b1f661
--- /dev/null
+++ b/animated-base/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.imagepipeline.animated"
+    >
+
+  <uses-sdk
+      android:minSdkVersion="9"
+      android:targetSdkVersion="21"
+      />
+</manifest>
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawable.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AbstractAnimatedDrawable.java
similarity index 93%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawable.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AbstractAnimatedDrawable.java
index e7b8237f1..e90c4caff 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawable.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AbstractAnimatedDrawable.java
@@ -29,15 +29,14 @@
 import com.facebook.common.time.MonotonicClock;
 import com.facebook.drawable.base.DrawableWithCaches;
 
-import com.nineoldandroids.animation.ValueAnimator;
-
 /**
  * A {@link Drawable} that renders a animated image. The details of the format are abstracted by the
  * {@link AnimatedDrawableBackend} interface. The drawable can work either as an {@link Animatable}
  * where the client calls start/stop to animate it or it can work as a level-based drawable where
  * the client drives the animation by calling {@link Drawable#setLevel}.
  */
-public class AnimatedDrawable extends Drawable implements AnimatableDrawable, DrawableWithCaches {
+public abstract class AbstractAnimatedDrawable extends Drawable
+    implements Animatable, DrawableWithCaches {
 
   private static final Class<?> TAG = AnimatedDrawable.class;
 
@@ -130,7 +129,7 @@ public void run() {
     }
   };
 
-  public AnimatedDrawable(
+  public AbstractAnimatedDrawable(
       ScheduledExecutorService scheduledExecutorServiceForUiThread,
       AnimatedDrawableCachingBackend animatedDrawableBackend,
       AnimatedDrawableDiagnostics animatedDrawableDiagnostics,
@@ -552,37 +551,6 @@ protected boolean onLevelChange(int level) {
     }
   }
 
-  @Override
-  public ValueAnimator createValueAnimator(int maxDurationMs) {
-    ValueAnimator animator = createValueAnimator();
-    int repeatCount = Math.max((maxDurationMs / mAnimatedDrawableBackend.getDurationMs()), 1);
-    animator.setRepeatCount(repeatCount);
-    return animator;
-  }
-
-  @Override
-  public ValueAnimator createValueAnimator() {
-    int loopCount = mAnimatedDrawableBackend.getLoopCount();
-    ValueAnimator animator = new ValueAnimator();
-    animator.setIntValues(0, mDurationMs);
-    animator.setDuration(mDurationMs);
-    animator.setRepeatCount(loopCount != 0 ? loopCount : ValueAnimator.INFINITE);
-    animator.setRepeatMode(ValueAnimator.RESTART);
-    animator.setInterpolator(new LinearInterpolator());
-    animator.addUpdateListener(createAnimatorUpdateListener());
-    return animator;
-  }
-
-  @Override
-  public ValueAnimator.AnimatorUpdateListener createAnimatorUpdateListener() {
-    return new ValueAnimator.AnimatorUpdateListener() {
-      @Override
-      public void onAnimationUpdate(ValueAnimator animation) {
-        setLevel((Integer) animation.getAnimatedValue());
-      }
-    };
-  }
-
   @Override
   public void dropCaches() {
     FLog.v(TAG, "(%s) Dropping caches", mLogId);
@@ -594,4 +562,13 @@ public void dropCaches() {
     }
     mAnimatedDrawableBackend.dropCaches();
   }
+
+  protected int getDuration() {
+    return mDurationMs;
+  }
+
+  protected AnimatedDrawableCachingBackend getAnimatedDrawableBackend() {
+    return mAnimatedDrawableBackend;
+  }
+
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawable.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawable.java
similarity index 96%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawable.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawable.java
index 2fbd8796f..83350925a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawable.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawable.java
@@ -9,10 +9,9 @@
 
 package com.facebook.imagepipeline.animated.base;
 
+import android.animation.ValueAnimator;
 import android.graphics.drawable.Animatable;
 
-import com.nineoldandroids.animation.ValueAnimator;
-
 /**
  * An interface for animatable drawables that can be asked to construct a value animator.
  */
diff --git a/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawable.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawable.java
new file mode 100644
index 000000000..90c781bdc
--- /dev/null
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawable.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.animated.base;
+
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+import android.animation.ValueAnimator;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.drawable.Animatable;
+import android.graphics.drawable.Drawable;
+import android.view.animation.LinearInterpolator;
+
+import com.facebook.common.internal.VisibleForTesting;
+import com.facebook.common.logging.FLog;
+import com.facebook.common.references.CloseableReference;
+import com.facebook.common.time.MonotonicClock;
+import com.facebook.drawable.base.DrawableWithCaches;
+
+/**
+ * A {@link Drawable} that renders a animated image. The details of the format are abstracted by the
+ * {@link AnimatedDrawableBackend} interface. The drawable can work either as an {@link Animatable}
+ * where the client calls start/stop to animate it or it can work as a level-based drawable where
+ * the client drives the animation by calling {@link Drawable#setLevel}.
+ */
+public class AnimatedDrawable extends AbstractAnimatedDrawable implements AnimatableDrawable {
+
+  public AnimatedDrawable(
+      ScheduledExecutorService scheduledExecutorServiceForUiThread,
+      AnimatedDrawableCachingBackend animatedDrawableBackend,
+      AnimatedDrawableDiagnostics animatedDrawableDiagnostics,
+      MonotonicClock monotonicClock) {
+    super(scheduledExecutorServiceForUiThread,
+        animatedDrawableBackend,
+        animatedDrawableDiagnostics,
+        monotonicClock);
+  }
+
+  @Override
+  public ValueAnimator createValueAnimator(int maxDurationMs) {
+    ValueAnimator animator = createValueAnimator();
+    int repeatCount = Math.max((maxDurationMs / getAnimatedDrawableBackend().getDurationMs()), 1);
+    animator.setRepeatCount(repeatCount);
+    return animator;
+  }
+
+  @Override
+  public ValueAnimator createValueAnimator() {
+    int loopCount = getAnimatedDrawableBackend().getLoopCount();
+    ValueAnimator animator = new ValueAnimator();
+    animator.setIntValues(0, getDuration());
+    animator.setDuration(getDuration());
+    animator.setRepeatCount(loopCount != 0 ? loopCount : ValueAnimator.INFINITE);
+    animator.setRepeatMode(ValueAnimator.RESTART);
+    animator.setInterpolator(new LinearInterpolator());
+    animator.addUpdateListener(createAnimatorUpdateListener());
+    return animator;
+  }
+
+  @Override
+  public ValueAnimator.AnimatorUpdateListener createAnimatorUpdateListener() {
+    return new ValueAnimator.AnimatorUpdateListener() {
+      @Override
+      public void onAnimationUpdate(ValueAnimator animation) {
+        setLevel((Integer) animation.getAnimatedValue());
+      }
+    };
+  }
+
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableBackend.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableBackend.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableBackend.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableBackend.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableCachingBackend.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableCachingBackend.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableCachingBackend.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableCachingBackend.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableDiagnostics.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableDiagnostics.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableDiagnostics.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableDiagnostics.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableFrameInfo.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableFrameInfo.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableFrameInfo.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableFrameInfo.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptions.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptions.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptions.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptions.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptionsBuilder.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptionsBuilder.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptionsBuilder.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptionsBuilder.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImage.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImage.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImage.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImage.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResult.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResult.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResult.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResult.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResultBuilder.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResultBuilder.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResultBuilder.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResultBuilder.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/DelegatingAnimatedDrawableBackend.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/base/DelegatingAnimatedDrawableBackend.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/DelegatingAnimatedDrawableBackend.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/base/DelegatingAnimatedDrawableBackend.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactory.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactoryImpl.java
similarity index 79%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactory.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactoryImpl.java
index c201d9995..bf46aad5a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactory.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactoryImpl.java
@@ -15,8 +15,10 @@
 import android.graphics.Rect;
 import android.os.SystemClock;
 import android.util.DisplayMetrics;
+import android.graphics.drawable.Drawable;
 
 import com.facebook.common.time.MonotonicClock;
+import com.facebook.imagepipeline.image.CloseableImage;
 import com.facebook.imagepipeline.animated.base.AnimatedDrawable;
 import com.facebook.imagepipeline.animated.base.AnimatedDrawableBackend;
 import com.facebook.imagepipeline.animated.base.AnimatedDrawableCachingBackend;
@@ -29,12 +31,12 @@
 import com.facebook.imagepipeline.animated.impl.AnimatedDrawableDiagnosticsImpl;
 import com.facebook.imagepipeline.animated.impl.AnimatedDrawableDiagnosticsNoop;
 import com.facebook.imagepipeline.animated.util.AnimatedDrawableUtil;
-
+import com.facebook.imagepipeline.image.CloseableAnimatedImage;
 
 /**
  * Factory for instances of {@link AnimatedDrawable}.
  */
-public class AnimatedDrawableFactory {
+public class AnimatedDrawableFactoryImpl implements AnimatedDrawableFactory {
 
   private final AnimatedDrawableBackendProvider mAnimatedDrawableBackendProvider;
   private final AnimatedDrawableCachingBackendImplProvider mAnimatedDrawableCachingBackendProvider;
@@ -43,7 +45,7 @@
   private final MonotonicClock mMonotonicClock;
   private final Resources mResources;
 
-  public AnimatedDrawableFactory(
+  public AnimatedDrawableFactoryImpl(
       AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
       AnimatedDrawableCachingBackendImplProvider animatedDrawableCachingBackendProvider,
       AnimatedDrawableUtil animatedDrawableUtil,
@@ -64,13 +66,20 @@ public long now() {
   }
 
   /**
-   * Creates an {@link AnimatedDrawable} based on an {@link AnimatedImage}.
+   * Creates an {@link AnimatedDrawable} based on an {@link CloseableImage} which should be a
+   * CloseableAnimatedImage.
    *
-   * @param animatedImageResult the result of the code
+   * @param closeableImage The CloseableAnimatedImage to use for the AnimatedDrawable
    * @return a newly constructed {@link AnimatedDrawable}
    */
-  public AnimatedDrawable create(AnimatedImageResult animatedImageResult) {
-    return create(animatedImageResult, AnimatedDrawableOptions.DEFAULTS);
+  @Override
+  public Drawable create(CloseableImage closeableImage) {
+    if (closeableImage instanceof CloseableAnimatedImage) {
+      final AnimatedImageResult result = ((CloseableAnimatedImage) closeableImage).getImageResult();
+      return create(result, AnimatedDrawableOptions.DEFAULTS);
+    } else {
+      throw new UnsupportedOperationException("Unrecognized image class: " + closeableImage);
+    }
   }
 
   /**
@@ -80,7 +89,7 @@ public AnimatedDrawable create(AnimatedImageResult animatedImageResult) {
    * @param options additional options
    * @return a newly constructed {@link AnimatedDrawable}
    */
-  public AnimatedDrawable create(
+  private AnimatedDrawable create(
       AnimatedImageResult animatedImageResult,
       AnimatedDrawableOptions options) {
     AnimatedImage animatedImage = animatedImageResult.getImage();
@@ -90,6 +99,13 @@ public AnimatedDrawable create(
     return createAnimatedDrawable(options, animatedDrawableBackend);
   }
 
+  private AnimatedImageResult getImageIfCloseableAnimatedImage(CloseableImage image) {
+    if (image instanceof CloseableAnimatedImage) {
+      return ((CloseableAnimatedImage) image).getImageResult();
+    }
+    return null;
+  }
+
   private AnimatedDrawable createAnimatedDrawable(
       AnimatedDrawableOptions options,
       AnimatedDrawableBackend animatedDrawableBackend) {
diff --git a/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactoryImpl.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactoryImpl.java
new file mode 100644
index 000000000..e847670d6
--- /dev/null
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactoryImpl.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+package com.facebook.imagepipeline.animated.factory;
+
+import java.util.concurrent.ScheduledExecutorService;
+import javax.annotation.concurrent.NotThreadSafe;
+
+import android.graphics.Rect;
+import android.app.ActivityManager;
+import android.content.Context;
+import android.content.res.Resources;
+import com.facebook.common.time.MonotonicClock;
+import com.facebook.common.time.RealtimeSinceBootClock;
+import com.facebook.common.executors.DefaultSerialExecutorService;
+import com.facebook.common.executors.SerialExecutorService;
+import com.facebook.common.executors.UiThreadImmediateExecutorService;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableBackend;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableOptions;
+import com.facebook.imagepipeline.animated.base.AnimatedImageResult;
+import com.facebook.imagepipeline.animated.factory.AnimatedDrawableFactory;
+import com.facebook.imagepipeline.animated.factory.AnimatedImageFactory;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableBackendImpl;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableBackendProvider;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableCachingBackendImpl;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableCachingBackendImplProvider;
+import com.facebook.imagepipeline.animated.util.AnimatedDrawableUtil;
+import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
+import com.facebook.imagepipeline.core.ExecutorSupplier;
+import com.facebook.common.internal.DoNotStrip;
+
+@NotThreadSafe
+@DoNotStrip
+public class AnimatedFactoryImpl implements AnimatedFactory {
+
+  private AnimatedDrawableBackendProvider mAnimatedDrawableBackendProvider;
+  private AnimatedDrawableUtil mAnimatedDrawableUtil;
+  private AnimatedDrawableFactory mAnimatedDrawableFactory;
+  private AnimatedImageFactory mAnimatedImageFactory;
+
+  private ExecutorSupplier mExecutorSupplier;
+
+  private PlatformBitmapFactory mPlatformBitmapFactory;
+
+  public AnimatedFactoryImpl(
+      PlatformBitmapFactory platformBitmapFactory,
+      ExecutorSupplier executorSupplier) {
+    this.mPlatformBitmapFactory = platformBitmapFactory;
+    this.mExecutorSupplier = executorSupplier;
+  }
+
+  private AnimatedDrawableFactory buildAnimatedDrawableFactory(
+      final SerialExecutorService serialExecutorService,
+      final ActivityManager activityManager,
+      final AnimatedDrawableUtil animatedDrawableUtil,
+      AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
+      ScheduledExecutorService scheduledExecutorService,
+      final MonotonicClock monotonicClock,
+      Resources resources) {
+    AnimatedDrawableCachingBackendImplProvider animatedDrawableCachingBackendImplProvider =
+        new AnimatedDrawableCachingBackendImplProvider() {
+          @Override
+          public AnimatedDrawableCachingBackendImpl get(
+              AnimatedDrawableBackend animatedDrawableBackend,
+              AnimatedDrawableOptions options) {
+            return new AnimatedDrawableCachingBackendImpl(
+                serialExecutorService,
+                activityManager,
+                animatedDrawableUtil,
+                monotonicClock,
+                animatedDrawableBackend,
+                options);
+          }
+        };
+
+    return createAnimatedDrawableFactory(
+        animatedDrawableBackendProvider,
+        animatedDrawableCachingBackendImplProvider,
+        animatedDrawableUtil,
+        scheduledExecutorService,
+        resources);
+  }
+
+  private AnimatedDrawableBackendProvider getAnimatedDrawableBackendProvider() {
+    if (mAnimatedDrawableBackendProvider == null) {
+      mAnimatedDrawableBackendProvider = new AnimatedDrawableBackendProvider() {
+        @Override
+        public AnimatedDrawableBackend get(AnimatedImageResult animatedImageResult, Rect bounds) {
+          return new AnimatedDrawableBackendImpl(
+              getAnimatedDrawableUtil(),
+              animatedImageResult,
+              bounds);
+        }
+      };
+    }
+    return mAnimatedDrawableBackendProvider;
+  }
+
+  @Override
+  public AnimatedDrawableFactory getAnimatedDrawableFactory(Context context) {
+    if (mAnimatedDrawableFactory == null) {
+      SerialExecutorService serialExecutorService =
+          new DefaultSerialExecutorService(mExecutorSupplier.forDecode());
+      ActivityManager activityManager =
+          (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+      mAnimatedDrawableFactory = buildAnimatedDrawableFactory(
+          serialExecutorService,
+          activityManager,
+          getAnimatedDrawableUtil(),
+          getAnimatedDrawableBackendProvider(),
+          UiThreadImmediateExecutorService.getInstance(),
+          RealtimeSinceBootClock.get(),
+          context.getResources());
+    }
+    return mAnimatedDrawableFactory;
+  }
+
+  // We need some of these methods public for now so internal code can use them.
+
+  private AnimatedDrawableUtil getAnimatedDrawableUtil() {
+    if (mAnimatedDrawableUtil == null) {
+      mAnimatedDrawableUtil = new AnimatedDrawableUtil();
+    }
+    return mAnimatedDrawableUtil;
+  }
+
+  private AnimatedImageFactory buildAnimatedImageFactory() {
+    AnimatedDrawableBackendProvider animatedDrawableBackendProvider =
+        new AnimatedDrawableBackendProvider() {
+          @Override
+          public AnimatedDrawableBackend get(AnimatedImageResult imageResult, Rect bounds) {
+            return new AnimatedDrawableBackendImpl(getAnimatedDrawableUtil(), imageResult, bounds);
+          }
+        };
+    return new AnimatedImageFactoryImpl(animatedDrawableBackendProvider, mPlatformBitmapFactory);
+  }
+
+  @Override
+  public AnimatedImageFactory getAnimatedImageFactory() {
+    if (mAnimatedImageFactory == null) {
+      mAnimatedImageFactory = buildAnimatedImageFactory();
+    }
+    return mAnimatedImageFactory;
+  }
+
+  protected AnimatedDrawableFactory createAnimatedDrawableFactory(
+      AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
+      AnimatedDrawableCachingBackendImplProvider animatedDrawableCachingBackendImplProvider,
+      AnimatedDrawableUtil animatedDrawableUtil,
+      ScheduledExecutorService scheduledExecutorService,
+      Resources resources) {
+    return new AnimatedDrawableFactoryImpl(
+        animatedDrawableBackendProvider,
+        animatedDrawableCachingBackendImplProvider,
+        animatedDrawableUtil,
+        scheduledExecutorService,
+        resources);
+  }
+}
diff --git a/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageDecoder.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageDecoder.java
new file mode 100644
index 000000000..d6a25f2f4
--- /dev/null
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageDecoder.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+package com.facebook.imagepipeline.animated.factory;
+
+import com.facebook.imagepipeline.animated.base.AnimatedImage;
+
+public interface AnimatedImageDecoder {
+
+  /**
+   * Factory method to create the AnimatedImage from the
+   * @param nativePtr The native pointer
+   * @param sizeInBytes The size in byte to allocate
+   * @return The AnimatedImage allocation
+   */
+  public AnimatedImage decode(long nativePtr, int sizeInBytes);
+
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactory.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryImpl.java
similarity index 85%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactory.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryImpl.java
index 7605ba1dd..ead981b00 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactory.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryImpl.java
@@ -23,12 +23,10 @@
 import com.facebook.imagepipeline.animated.impl.AnimatedImageCompositor;
 import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
 import com.facebook.imagepipeline.common.ImageDecodeOptions;
-import com.facebook.imagepipeline.gif.GifImage;
 import com.facebook.imagepipeline.image.CloseableAnimatedImage;
 import com.facebook.imagepipeline.image.CloseableImage;
 import com.facebook.imagepipeline.image.EncodedImage;
 import com.facebook.imagepipeline.memory.PooledByteBuffer;
-import com.facebook.imagepipeline.webp.WebPImage;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -36,12 +34,29 @@
 /**
  * Decoder for animated images.
  */
-public class AnimatedImageFactory {
+public class AnimatedImageFactoryImpl implements AnimatedImageFactory {
 
   private final AnimatedDrawableBackendProvider mAnimatedDrawableBackendProvider;
   private final PlatformBitmapFactory mBitmapFactory;
 
-  public AnimatedImageFactory(
+  static AnimatedImageDecoder sGifAnimatedImageDecoder = null;
+  static AnimatedImageDecoder sWebpAnimatedImageDecoder = null;
+
+  private static AnimatedImageDecoder loadIfPresent(final String className) {
+    try {
+      Class<?> clazz = Class.forName(className);
+      return (AnimatedImageDecoder) clazz.newInstance();
+    } catch (Throwable e) {
+      return null;
+    }
+  }
+
+  static {
+    sGifAnimatedImageDecoder = loadIfPresent("com.facebook.animated.gif.GifImage");
+    sWebpAnimatedImageDecoder = loadIfPresent("com.facebook.animated.webp.WebPImage");
+  }
+
+  public AnimatedImageFactoryImpl(
       AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
       PlatformBitmapFactory bitmapFactory) {
     mAnimatedDrawableBackendProvider = animatedDrawableBackendProvider;
@@ -59,12 +74,16 @@ public CloseableImage decodeGif(
       final EncodedImage encodedImage,
       final ImageDecodeOptions options,
       final Bitmap.Config bitmapConfig) {
+    if (sGifAnimatedImageDecoder == null) {
+      throw new UnsupportedOperationException("To encode animated gif please add the dependency " +
+          "to the animated-gif module");
+    }
     final CloseableReference<PooledByteBuffer> bytesRef = encodedImage.getByteBufferRef();
     Preconditions.checkNotNull(bytesRef);
     try {
       Preconditions.checkState(!options.forceOldAnimationCode);
       final PooledByteBuffer input = bytesRef.get();
-      GifImage gifImage = GifImage.create(input.getNativePtr(), input.size());
+      AnimatedImage gifImage = sGifAnimatedImageDecoder.decode(input.getNativePtr(), input.size());
 
       return getCloseableImage(options, gifImage, bitmapConfig);
     } finally {
@@ -83,12 +102,18 @@ public CloseableImage decodeWebP(
       final EncodedImage encodedImage,
       final ImageDecodeOptions options,
       final Bitmap.Config bitmapConfig) {
+    if (sWebpAnimatedImageDecoder == null) {
+      throw new UnsupportedOperationException("To encode animated webp please add the dependency " +
+          "to the animated-webp module");
+    }
     final CloseableReference<PooledByteBuffer> bytesRef = encodedImage.getByteBufferRef();
     Preconditions.checkNotNull(bytesRef);
     try {
       Preconditions.checkArgument(!options.forceOldAnimationCode);
       final PooledByteBuffer input = bytesRef.get();
-      WebPImage webPImage = WebPImage.create(input.getNativePtr(), input.size());
+      AnimatedImage webPImage = sWebpAnimatedImageDecoder.decode(
+          input.getNativePtr(),
+          input.size());
       return getCloseableImage(options, webPImage, bitmapConfig);
     } finally {
       CloseableReference.closeSafely(bytesRef);
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendProvider.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendProvider.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendProvider.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendProvider.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImpl.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImpl.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImpl.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImpl.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplProvider.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplProvider.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplProvider.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplProvider.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsImpl.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsImpl.java
similarity index 93%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsImpl.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsImpl.java
index 22e2bb6da..966fea3f7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsImpl.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsImpl.java
@@ -61,12 +61,12 @@ public void setBackend(AnimatedDrawableCachingBackend animatedDrawableBackend) {
 
   @Override
   public void onStartMethodBegin() {
-    mLastTimeStamp = SystemClock.elapsedRealtime();
+    mLastTimeStamp = SystemClock.uptimeMillis();
   }
 
   @Override
   public void onStartMethodEnd() {
-    long elapsedMs = SystemClock.elapsedRealtime() - mLastTimeStamp;
+    long elapsedMs = SystemClock.uptimeMillis() - mLastTimeStamp;
     if (elapsedMs > 3) {
       FLog.v(TAG, "onStart took %d", elapsedMs);
     }
@@ -74,12 +74,12 @@ public void onStartMethodEnd() {
 
   @Override
   public void onNextFrameMethodBegin() {
-    mLastTimeStamp = SystemClock.elapsedRealtime();
+    mLastTimeStamp = SystemClock.uptimeMillis();
   }
 
   @Override
   public void onNextFrameMethodEnd() {
-    long elapsedMs = SystemClock.elapsedRealtime() - mLastTimeStamp;
+    long elapsedMs = SystemClock.uptimeMillis() - mLastTimeStamp;
     if (elapsedMs > 3) {
       FLog.v(TAG, "onNextFrame took %d", elapsedMs);
     }
@@ -100,12 +100,12 @@ public void incrementDrawnFrames(int drawnFrames) {
 
   @Override
   public void onDrawMethodBegin() {
-    mLastTimeStamp = SystemClock.elapsedRealtime();
+    mLastTimeStamp = SystemClock.uptimeMillis();
   }
 
   @Override
   public void onDrawMethodEnd() {
-    long elapsedMs = SystemClock.elapsedRealtime() - mLastTimeStamp;
+    long elapsedMs = SystemClock.uptimeMillis() - mLastTimeStamp;
     FLog.v(TAG, "draw took %d", elapsedMs);
   }
 
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsNoop.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsNoop.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsNoop.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsNoop.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCache.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCache.java
similarity index 97%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCache.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCache.java
index 745dc9906..2f0b39b9f 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCache.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCache.java
@@ -15,6 +15,8 @@
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 
+import android.net.Uri;
+
 import com.facebook.cache.common.CacheKey;
 import com.facebook.common.internal.Objects;
 import com.facebook.common.internal.VisibleForTesting;
@@ -65,6 +67,11 @@ public boolean equals(Object o) {
     public int hashCode() {
       return mImageCacheKey.hashCode() * 1013 + mFrameIndex;
     }
+
+    @Override
+    public boolean containsUri(Uri uri) {
+      return mImageCacheKey.containsUri(uri);
+    }
   }
 
   private final CacheKey mImageCacheKey;
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/RollingStat.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/RollingStat.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/RollingStat.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/RollingStat.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/WhatToKeepCachedArray.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/WhatToKeepCachedArray.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/WhatToKeepCachedArray.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/WhatToKeepCachedArray.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtil.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtil.java
similarity index 97%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtil.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtil.java
index dbef7083a..1780776ed 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtil.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtil.java
@@ -16,10 +16,9 @@
 import android.os.Build;
 
 import com.facebook.common.util.ByteConstants;
-import com.facebook.imagepipeline.animated.base.AnimatedDrawable;
 
 /**
- * Utility methods for {@link AnimatedDrawable}.
+ * Utility methods for AnimatedDrawable.
  */
 public class AnimatedDrawableUtil {
 
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedBitmap.java b/animated-base/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedBitmap.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedBitmap.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedBitmap.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedImage.java b/animated-base/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedImage.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedImage.java
rename to animated-base/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedImage.java
diff --git a/animated-base/src/test/java/android/net/http/AndroidHttpClient.java b/animated-base/src/test/java/android/net/http/AndroidHttpClient.java
new file mode 100644
index 000000000..a25150e79
--- /dev/null
+++ b/animated-base/src/test/java/android/net/http/AndroidHttpClient.java
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+package android.net.http;
+
+public class AndroidHttpClient {
+}
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableTest.java b/animated-base/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableTest.java
similarity index 96%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableTest.java
rename to animated-base/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableTest.java
index 8bde8bc2e..859d8c96a 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableTest.java
+++ b/animated-base/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableTest.java
@@ -13,6 +13,7 @@
 import java.util.Iterator;
 import java.util.List;
 
+import android.animation.ValueAnimator;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Rect;
@@ -21,6 +22,8 @@
 import com.facebook.common.references.CloseableReference;
 import com.facebook.common.references.ResourceReleaser;
 import com.facebook.imagepipeline.testing.FakeClock;
+
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import com.facebook.imagepipeline.animated.testing.MyShadowBitmap;
 import com.facebook.imagepipeline.animated.testing.MyShadowCanvas;
@@ -28,11 +31,14 @@
 import com.facebook.imagepipeline.animated.impl.AnimatedDrawableDiagnosticsNoop;
 import com.facebook.imagepipeline.testing.TestScheduledExecutorService;
 
-import com.nineoldandroids.animation.ValueAnimator;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.shadows.ShadowValueAnimator;
+import org.robolectric.Shadows;
+import org.robolectric.util.ReflectionHelpers;
 
 import static com.facebook.imagepipeline.animated.testing.TestAnimatedDrawableBackend.pixelValue;
 import static org.junit.Assert.*;
@@ -80,8 +86,10 @@ public void testIntrinsicDimensions() {
   @Test
   public void testValueAnimator() {
     ValueAnimator valueAnimator = mDrawable.createValueAnimator();
+    ShadowValueAnimator shadowValueAnimator = Shadows.shadowOf(valueAnimator);
+    assertEquals(ValueAnimator.INFINITE, shadowValueAnimator.getActualRepeatCount());
     assertEquals(mBackend.getDurationMs(), valueAnimator.getDuration());
-    assertEquals(ValueAnimator.INFINITE, valueAnimator.getRepeatCount());
+
   }
 
   @Test
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplTest.java b/animated-base/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplTest.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplTest.java
rename to animated-base/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplTest.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCacheTest.java b/animated-base/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCacheTest.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCacheTest.java
rename to animated-base/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCacheTest.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableBackend.java b/animated-base/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableBackend.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableBackend.java
rename to animated-base/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableBackend.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtilTest.java b/animated-base/src/test/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtilTest.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtilTest.java
rename to animated-base/src/test/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtilTest.java
diff --git a/animated-base/src/test/java/com/facebook/imagepipeline/producers/AnimatedRepeatedPostprocessorProducerTest.java b/animated-base/src/test/java/com/facebook/imagepipeline/producers/AnimatedRepeatedPostprocessorProducerTest.java
new file mode 100644
index 000000000..0552ff9ad
--- /dev/null
+++ b/animated-base/src/test/java/com/facebook/imagepipeline/producers/AnimatedRepeatedPostprocessorProducerTest.java
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.producers;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import android.graphics.Bitmap;
+
+import com.facebook.common.internal.ImmutableMap;
+import com.facebook.common.references.CloseableReference;
+import com.facebook.common.references.ResourceReleaser;
+import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
+import com.facebook.imagepipeline.common.Priority;
+import com.facebook.imagepipeline.image.CloseableAnimatedImage;
+import com.facebook.imagepipeline.image.CloseableImage;
+import com.facebook.imagepipeline.image.CloseableStaticBitmap;
+import com.facebook.imagepipeline.producers.PostprocessorProducer.RepeatedPostprocessorConsumer;
+import com.facebook.imagepipeline.request.ImageRequest;
+import com.facebook.imagepipeline.request.RepeatedPostprocessor;
+import com.facebook.imagepipeline.request.RepeatedPostprocessorRunner;
+import com.facebook.imagepipeline.testing.FakeClock;
+import com.facebook.imagepipeline.testing.TestExecutorService;
+
+import org.junit.*;
+import org.junit.runner.*;
+import org.mockito.*;
+import org.mockito.invocation.*;
+import org.mockito.stubbing.*;
+import org.robolectric.*;
+import org.robolectric.annotation.*;
+
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.*;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest= Config.NONE)
+public class AnimatedRepeatedPostprocessorProducerTest {
+
+  private static final String POSTPROCESSOR_NAME = "postprocessor_name";
+  private static final Map<String, String> mExtraMap =
+      ImmutableMap.of(PostprocessorProducer.POSTPROCESSOR, POSTPROCESSOR_NAME);
+
+  @Mock public PlatformBitmapFactory mPlatformBitmapFactory;
+  @Mock public ProducerListener mProducerListener;
+  @Mock public Producer<CloseableReference<CloseableImage>> mInputProducer;
+  @Mock public Consumer<CloseableReference<CloseableImage>> mConsumer;
+  @Mock public RepeatedPostprocessor mPostprocessor;
+  @Mock public ResourceReleaser<Bitmap> mBitmapResourceReleaser;
+
+  @Mock public ImageRequest mImageRequest;
+
+  private SettableProducerContext mProducerContext;
+  private String mRequestId = "mRequestId";
+  private Bitmap mSourceBitmap;
+  private CloseableStaticBitmap mSourceCloseableStaticBitmap;
+  private CloseableReference<CloseableImage> mSourceCloseableImageRef;
+  private Bitmap mDestinationBitmap;
+  private CloseableReference<Bitmap> mDestinationCloseableBitmapRef;
+  private TestExecutorService mTestExecutorService;
+  private PostprocessorProducer mPostprocessorProducer;
+  private List<CloseableReference<CloseableImage>> mResults;
+
+  private InOrder mInOrder;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    mTestExecutorService = new TestExecutorService(new FakeClock());
+    mPostprocessorProducer =
+        new PostprocessorProducer(
+            mInputProducer,
+            mPlatformBitmapFactory,
+            mTestExecutorService);
+    mProducerContext =
+        new SettableProducerContext(
+            mImageRequest,
+            mRequestId,
+            mProducerListener,
+            mock(Object.class),
+            ImageRequest.RequestLevel.FULL_FETCH,
+            false /* isPrefetch */,
+            false /* isIntermediateResultExpected */,
+            Priority.MEDIUM);
+    when(mImageRequest.getPostprocessor()).thenReturn(mPostprocessor);
+    mResults = new ArrayList<>();
+    when(mPostprocessor.getName()).thenReturn(POSTPROCESSOR_NAME);
+    when(mProducerListener.requiresExtraMap(mRequestId)).thenReturn(true);
+    doAnswer(
+        new Answer<Object>() {
+          @Override
+          public Object answer(InvocationOnMock invocation) throws Throwable {
+            mResults.add(
+                ((CloseableReference<CloseableImage>) invocation.getArguments()[0]).clone());
+            return null;
+          }
+        }
+    ).when(mConsumer).onNewResult(any(CloseableReference.class), anyBoolean());
+    mInOrder = inOrder(mPostprocessor, mProducerListener, mConsumer);
+  }
+
+  @Test
+  public void testNonStaticBitmapIsPassedOn() {
+    RepeatedPostprocessorConsumer postprocessorConsumer = produceResults();
+    RepeatedPostprocessorRunner repeatedPostprocessorRunner = getRunner();
+
+    CloseableAnimatedImage sourceCloseableAnimatedImage = mock(CloseableAnimatedImage.class);
+    CloseableReference<CloseableImage> sourceCloseableImageRef =
+        CloseableReference.<CloseableImage>of(sourceCloseableAnimatedImage);
+    postprocessorConsumer.onNewResult(sourceCloseableImageRef, true);
+    sourceCloseableImageRef.close();
+    mTestExecutorService.runUntilIdle();
+
+    mInOrder.verify(mConsumer).onNewResult(any(CloseableReference.class), eq(false));
+    mInOrder.verifyNoMoreInteractions();
+
+    assertEquals(1, mResults.size());
+    CloseableReference<CloseableImage> res0 = mResults.get(0);
+    assertTrue(CloseableReference.isValid(res0));
+    assertSame(sourceCloseableAnimatedImage, res0.get());
+    res0.close();
+
+    performCancelAndVerifyOnCancellation();
+    verify(sourceCloseableAnimatedImage).close();
+  }
+
+  private void setupNewSourceImage() {
+    mSourceBitmap = mock(Bitmap.class);
+    mSourceCloseableStaticBitmap = mock(CloseableStaticBitmap.class);
+    when(mSourceCloseableStaticBitmap.getUnderlyingBitmap()).thenReturn(mSourceBitmap);
+    mSourceCloseableImageRef =
+        CloseableReference.<CloseableImage>of(mSourceCloseableStaticBitmap);
+  }
+
+  private void setupNewDestinationImage() {
+    mDestinationBitmap = mock(Bitmap.class);
+    mDestinationCloseableBitmapRef =
+        CloseableReference.of(mDestinationBitmap, mBitmapResourceReleaser);
+    doReturn(mDestinationCloseableBitmapRef)
+        .when(mPostprocessor).process(mSourceBitmap, mPlatformBitmapFactory);
+  }
+
+  private RepeatedPostprocessorConsumer produceResults() {
+    mPostprocessorProducer.produceResults(mConsumer, mProducerContext);
+    ArgumentCaptor<Consumer> consumerCaptor = ArgumentCaptor.forClass(Consumer.class);
+    verify(mInputProducer).produceResults(consumerCaptor.capture(), eq(mProducerContext));
+    return (RepeatedPostprocessorConsumer) consumerCaptor.getValue();
+  }
+
+  private RepeatedPostprocessorRunner getRunner() {
+    ArgumentCaptor<RepeatedPostprocessorRunner> captor =
+        ArgumentCaptor.forClass(RepeatedPostprocessorRunner.class);
+    mInOrder.verify(mPostprocessor).setCallback(captor.capture());
+    return captor.getValue();
+  }
+
+  private void performNewResult(RepeatedPostprocessorConsumer postprocessorConsumer, boolean run) {
+    setupNewSourceImage();
+    setupNewDestinationImage();
+    postprocessorConsumer.onNewResult(mSourceCloseableImageRef, true);
+    mSourceCloseableImageRef.close();
+    if (run) {
+      mTestExecutorService.runUntilIdle();
+    }
+  }
+
+  private void performUpdate(RepeatedPostprocessorRunner repeatedPostprocessorRunner, boolean run) {
+    setupNewDestinationImage();
+    repeatedPostprocessorRunner.update();
+    if (run) {
+      mTestExecutorService.runUntilIdle();
+    }
+  }
+
+  private void performUpdateDuringTheNextPostprocessing(
+      final RepeatedPostprocessorRunner repeatedPostprocessorRunner) {
+    doAnswer(
+        new Answer<CloseableReference<Bitmap>>() {
+          @Override
+          public CloseableReference<Bitmap> answer(InvocationOnMock invocation) throws Throwable {
+            CloseableReference<Bitmap> destBitmapRef = mDestinationCloseableBitmapRef;
+            performUpdate(repeatedPostprocessorRunner, false);
+            // the following call should be ignored
+            performUpdate(repeatedPostprocessorRunner, false);
+            return destBitmapRef;
+          }
+        }).when(mPostprocessor).process(mSourceBitmap, mPlatformBitmapFactory);
+  }
+
+  private void performFailure(RepeatedPostprocessorRunner repeatedPostprocessorRunner) {
+    setupNewDestinationImage();
+    doThrow(new RuntimeException())
+        .when(mPostprocessor).process(mSourceBitmap, mPlatformBitmapFactory);
+    repeatedPostprocessorRunner.update();
+    mTestExecutorService.runUntilIdle();
+  }
+
+  private void performCancelAndVerifyOnCancellation() {
+    performCancel();
+    mInOrder.verify(mConsumer).onCancellation();
+  }
+
+  private void performCancelAfterFinished() {
+    performCancel();
+    mInOrder.verify(mConsumer, never()).onCancellation();
+  }
+
+  private void performCancel() {
+    mProducerContext.cancel();
+    mTestExecutorService.runUntilIdle();
+  }
+
+  private void verifyNewResultProcessed(int index) {
+    verifyNewResultProcessed(index, mDestinationBitmap);
+  }
+
+  private void verifyNewResultProcessed(int index, Bitmap destBitmap) {
+    mInOrder.verify(mProducerListener).onProducerStart(mRequestId, PostprocessorProducer.NAME);
+    mInOrder.verify(mPostprocessor).process(mSourceBitmap, mPlatformBitmapFactory);
+    mInOrder.verify(mProducerListener).requiresExtraMap(mRequestId);
+    mInOrder.verify(mProducerListener)
+        .onProducerFinishWithSuccess(mRequestId, PostprocessorProducer.NAME, mExtraMap);
+    mInOrder.verify(mConsumer).onNewResult(any(CloseableReference.class), eq(false));
+    mInOrder.verifyNoMoreInteractions();
+
+    assertEquals(index + 1, mResults.size());
+    CloseableReference<CloseableImage> res0 = mResults.get(index);
+    assertTrue(CloseableReference.isValid(res0));
+    assertSame(destBitmap, ((CloseableStaticBitmap) res0.get()).getUnderlyingBitmap());
+    res0.close();
+    verify(mBitmapResourceReleaser).release(destBitmap);
+  }
+}
diff --git a/animated-base/src/test/java/com/facebook/imagepipeline/producers/AnimatedSingleUsePostprocessorProducerTest.java b/animated-base/src/test/java/com/facebook/imagepipeline/producers/AnimatedSingleUsePostprocessorProducerTest.java
new file mode 100644
index 000000000..0e6f817e7
--- /dev/null
+++ b/animated-base/src/test/java/com/facebook/imagepipeline/producers/AnimatedSingleUsePostprocessorProducerTest.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.producers;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import android.graphics.Bitmap;
+
+import com.facebook.common.internal.ImmutableMap;
+import com.facebook.common.references.CloseableReference;
+import com.facebook.common.references.ResourceReleaser;
+import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
+import com.facebook.imagepipeline.image.CloseableAnimatedImage;
+import com.facebook.imagepipeline.image.CloseableImage;
+import com.facebook.imagepipeline.image.CloseableStaticBitmap;
+import com.facebook.imagepipeline.producers.PostprocessorProducer.SingleUsePostprocessorConsumer;
+import com.facebook.imagepipeline.request.ImageRequest;
+import com.facebook.imagepipeline.request.Postprocessor;
+import com.facebook.imagepipeline.testing.FakeClock;
+import com.facebook.imagepipeline.testing.TestExecutorService;
+
+import org.junit.*;
+import org.junit.runner.*;
+import org.mockito.*;
+import org.mockito.invocation.*;
+import org.mockito.stubbing.*;
+import org.robolectric.*;
+import org.robolectric.annotation.*;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest= Config.NONE)
+public class AnimatedSingleUsePostprocessorProducerTest {
+
+  private static final String POSTPROCESSOR_NAME = "postprocessor_name";
+  private static final Map<String, String> mExtraMap =
+      ImmutableMap.of(PostprocessorProducer.POSTPROCESSOR, POSTPROCESSOR_NAME);
+
+  @Mock public PlatformBitmapFactory mPlatformBitmapFactory;
+  @Mock public ProducerContext mProducerContext;
+  @Mock public ProducerListener mProducerListener;
+  @Mock public Producer<CloseableReference<CloseableImage>> mInputProducer;
+  @Mock public Consumer<CloseableReference<CloseableImage>> mConsumer;
+  @Mock public Postprocessor mPostprocessor;
+  @Mock public ResourceReleaser<Bitmap> mBitmapResourceReleaser;
+
+  @Mock public ImageRequest mImageRequest;
+
+  private String mRequestId = "mRequestId";
+  private Bitmap mSourceBitmap;
+  private CloseableStaticBitmap mSourceCloseableStaticBitmap;
+  private CloseableReference<CloseableImage> mSourceCloseableImageRef;
+  private Bitmap mDestinationBitmap;
+  private CloseableReference<Bitmap> mDestinationCloseableBitmapRef;
+  private TestExecutorService mTestExecutorService;
+  private PostprocessorProducer mPostprocessorProducer;
+  private List<CloseableReference<CloseableImage>> mResults;
+
+  private InOrder mInOrder;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    mTestExecutorService = new TestExecutorService(new FakeClock());
+    mPostprocessorProducer =
+        new PostprocessorProducer(
+            mInputProducer,
+            mPlatformBitmapFactory,
+            mTestExecutorService);
+
+    when(mImageRequest.getPostprocessor()).thenReturn(mPostprocessor);
+    when(mProducerContext.getId()).thenReturn(mRequestId);
+    when(mProducerContext.getListener()).thenReturn(mProducerListener);
+    when(mProducerContext.getImageRequest()).thenReturn(mImageRequest);
+
+    mResults = new ArrayList<>();
+    when(mPostprocessor.getName()).thenReturn(POSTPROCESSOR_NAME);
+    when(mProducerListener.requiresExtraMap(mRequestId)).thenReturn(true);
+    doAnswer(
+        new Answer<Object>() {
+          @Override
+          public Object answer(InvocationOnMock invocation) throws Throwable {
+            mResults.add(
+                ((CloseableReference<CloseableImage>) invocation.getArguments()[0]).clone());
+            return null;
+          }
+        }
+    ).when(mConsumer).onNewResult(any(CloseableReference.class), anyBoolean());
+    mInOrder = inOrder(mPostprocessor, mProducerListener, mConsumer);
+
+    mSourceBitmap = mock(Bitmap.class);
+    mSourceCloseableStaticBitmap = mock(CloseableStaticBitmap.class);
+    when(mSourceCloseableStaticBitmap.getUnderlyingBitmap()).thenReturn(mSourceBitmap);
+    mSourceCloseableImageRef =
+        CloseableReference.<CloseableImage>of(mSourceCloseableStaticBitmap);
+    mDestinationBitmap = mock(Bitmap.class);
+    mDestinationCloseableBitmapRef =
+        CloseableReference.of(mDestinationBitmap, mBitmapResourceReleaser);
+  }
+
+  @Test
+  public void testNonStaticBitmapIsPassedOn() {
+    SingleUsePostprocessorConsumer postprocessorConsumer = produceResults();
+    CloseableAnimatedImage sourceCloseableAnimatedImage = mock(CloseableAnimatedImage.class);
+    CloseableReference<CloseableImage> sourceCloseableImageRef =
+        CloseableReference.<CloseableImage>of(sourceCloseableAnimatedImage);
+    postprocessorConsumer.onNewResult(sourceCloseableImageRef, true);
+    sourceCloseableImageRef.close();
+    mTestExecutorService.runUntilIdle();
+
+    mInOrder.verify(mConsumer).onNewResult(any(CloseableReference.class), eq(true));
+    mInOrder.verifyNoMoreInteractions();
+
+    assertEquals(1, mResults.size());
+    CloseableReference<CloseableImage> res0 = mResults.get(0);
+    assertTrue(CloseableReference.isValid(res0));
+    assertSame(sourceCloseableAnimatedImage, res0.get());
+    res0.close();
+
+    verify(sourceCloseableAnimatedImage).close();
+  }
+
+  private SingleUsePostprocessorConsumer produceResults() {
+    mPostprocessorProducer.produceResults(mConsumer, mProducerContext);
+    ArgumentCaptor<Consumer> consumerCaptor = ArgumentCaptor.forClass(Consumer.class);
+    verify(mInputProducer).produceResults(consumerCaptor.capture(), eq(mProducerContext));
+    return (SingleUsePostprocessorConsumer) consumerCaptor.getValue();
+  }
+}
diff --git a/animated-gif/.gitignore b/animated-gif/.gitignore
new file mode 100644
index 000000000..8afd910ce
--- /dev/null
+++ b/animated-gif/.gitignore
@@ -0,0 +1 @@
+nativedeps/
diff --git a/animated-gif/build.gradle b/animated-gif/build.gradle
new file mode 100644
index 000000000..6e7780208
--- /dev/null
+++ b/animated-gif/build.gradle
@@ -0,0 +1,151 @@
+apply plugin: 'com.android.library'
+apply plugin: 'maven'
+
+project.group = GROUP
+version = VERSION_NAME
+
+apply plugin: 'de.undercouch.download'
+import de.undercouch.gradle.tasks.download.Download
+
+import org.apache.tools.ant.taskdefs.condition.Os
+
+dependencies {
+    provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    compile "com.parse.bolts:bolts-android:${BOLTS_ANDROID_VERSION}"
+    compile "com.nineoldandroids:library:${NINEOLDANDROID_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
+    provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
+    compile project(':fbcore')
+    compile project(':animated-base')
+
+    testCompile project(':imagepipeline-base-test')
+    testCompile project(':imagepipeline-test')
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_CORE_VERSION}"
+    testCompile("org.powermock:powermock-api-mockito:${POWERMOCK_VERSION}") {
+        exclude group: 'org.mockito', module: 'mockito-all'
+    }
+    testCompile "org.powermock:powermock-module-junit4-rule:${POWERMOCK_VERSION}"
+    testCompile "org.powermock:powermock-classloading-xstream:${POWERMOCK_VERSION}"
+    testCompile("org.robolectric:robolectric:${ROBOLECTRIC_VERSION}") {
+        exclude group: 'commons-logging', module: 'commons-logging'
+        exclude group: 'org.apache.httpcomponents', module: 'httpclient'
+    }
+}
+apply from: rootProject.file('release.gradle')
+
+// We download various C++ open-source dependencies from SourceForge into nativedeps/downloads.
+// We then copy both downloaded code and our custom makefiles and headers into nativedeps/merge.
+
+def nativeDepsDir = new File("${projectDir}/nativedeps")
+def downloadsDir = new File("${nativeDepsDir}/downloads")
+def mergeDir = new File("${nativeDepsDir}/merge")
+
+task createNativeDepsDirectories {
+    nativeDepsDir.mkdirs()
+    downloadsDir.mkdirs()
+    mergeDir.mkdirs()
+}
+
+task downloadGiflib(dependsOn: createNativeDepsDirectories, type: Download) {
+    src 'http://downloads.sourceforge.net/project/giflib/giflib-5.1.1.tar.gz'
+    onlyIfNewer true
+    overwrite false
+    dest downloadsDir
+}
+
+task unpackGiflib(dependsOn: downloadGiflib, type: Copy) {
+    from tarTree(resources.gzip("${downloadGiflib.dest}/giflib-5.1.1.tar.gz"))
+    into "${downloadsDir}/giflib"
+}
+
+task copyGiflib(dependsOn: unpackGiflib, type: Copy) {
+    from "${unpackGiflib.destinationDir}/giflib-5.1.1/lib"
+    from 'src/main/jni/third-party/giflib'
+    include('*.c', '*.h', '*.mk')
+    into "${mergeDir}/giflib"
+}
+
+task fetchNativeDeps(dependsOn: [copyGiflib]) {
+}
+
+task removeNativeDeps(type: Delete) {
+    delete nativeDepsDir
+}
+allclean.dependsOn removeNativeDeps
+
+def getNdkBuildName() {
+    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
+        return "ndk-build.cmd"
+    } else {
+        return "ndk-build"
+    }
+}
+
+def getNdkBuildFullPath() {
+    // we allow to provide full path to ndk-build tool
+    if (hasProperty('ndk.command')) {
+        return property('ndk.command')
+    }
+    // or just a path to the containing directiry
+    if (hasProperty('ndk.path')) {
+        def path = property('ndk.path')
+        if (!path.endsWith(File.separator)) {
+            path += File.separator
+        }
+        return path + getNdkBuildName()
+    }
+    // if none of above is provided, we assume ndk-build is already in $PATH
+    return getNdkBuildName()
+}
+
+def makeNdkTasks(String name, Object[] deps) {
+    task "ndk_build_$name"(dependsOn: deps, type: Exec) {
+        inputs.file("src/main/jni/$name")
+        outputs.dir("$buildDir/$name")
+        commandLine getNdkBuildFullPath(),
+            'NDK_PROJECT_PATH=null',
+            'NDK_APPLICATION_MK=../Application.mk',
+            'NDK_OUT=' + temporaryDir,
+            "NDK_LIBS_OUT=$buildDir/$name",
+            '-C', file("src/main/jni/$name").absolutePath,
+            '--jobs', Runtime.getRuntime().availableProcessors()
+    }
+
+    task "ndk_clean_$name"(type: Exec) {
+        ignoreExitValue true
+        commandLine getNdkBuildFullPath(),
+            'NDK_PROJECT_PATH=null',
+            'NDK_APPLICATION_MK=../Application.mk',
+            'NDK_OUT=' + temporaryDir,
+            "NDK_LIBS_OUT=$buildDir/$name",
+            '-C', file("src/main/jni/$name").absolutePath,
+            'clean'
+    }
+
+    tasks.withType(JavaCompile) {
+        compileTask -> compileTask.dependsOn "ndk_build_$name"
+    }
+    clean.dependsOn "ndk_clean_$name"
+}
+
+android {
+    def ndkLibs = [['gifimage', [copyGiflib]]]
+
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    sourceSets {
+        main {
+            jni.srcDirs = []
+            jniLibs.srcDirs = ndkLibs.collect { "$buildDir/${it[0]}" }
+        }
+    }
+    ndkLibs.each { lib -> makeNdkTasks lib[0], lib[1] }
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+artifacts.add('archives', sourcesJar)
diff --git a/animated-gif/gradle.properties b/animated-gif/gradle.properties
new file mode 100644
index 000000000..1413151aa
--- /dev/null
+++ b/animated-gif/gradle.properties
@@ -0,0 +1,5 @@
+POM_NAME=AnimatedGif
+POM_DESCRIPTION=The classes to support animated gif
+POM_ARTIFACT_ID=animated-gif
+POM_PACKAGING=aar
+
diff --git a/animated-gif/src/main/AndroidManifest.xml b/animated-gif/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..97f8ab031
--- /dev/null
+++ b/animated-gif/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.animated.gif"
+    >
+
+  <uses-sdk
+      android:minSdkVersion="9"
+      android:targetSdkVersion="21"
+      />
+</manifest>
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifFrame.java b/animated-gif/src/main/java/com/facebook/animated/gif/GifFrame.java
similarity index 98%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifFrame.java
rename to animated-gif/src/main/java/com/facebook/animated/gif/GifFrame.java
index 0fd49f4e0..3f6ac7d00 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifFrame.java
+++ b/animated-gif/src/main/java/com/facebook/animated/gif/GifFrame.java
@@ -7,7 +7,7 @@
  * of patent rights can be found in the PATENTS file in the same directory.
  */
 
-package com.facebook.imagepipeline.gif;
+package com.facebook.animated.gif;
 
 import javax.annotation.concurrent.ThreadSafe;
 
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifImage.java b/animated-gif/src/main/java/com/facebook/animated/gif/GifImage.java
similarity index 92%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifImage.java
rename to animated-gif/src/main/java/com/facebook/animated/gif/GifImage.java
index b17b6165a..9fc24bbe7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifImage.java
+++ b/animated-gif/src/main/java/com/facebook/animated/gif/GifImage.java
@@ -7,7 +7,7 @@
  * of patent rights can be found in the PATENTS file in the same directory.
  */
 
-package com.facebook.imagepipeline.gif;
+package com.facebook.animated.gif;
 
 import javax.annotation.concurrent.ThreadSafe;
 
@@ -18,6 +18,7 @@
 import com.facebook.common.soloader.SoLoaderShim;
 import com.facebook.imagepipeline.animated.base.AnimatedDrawableFrameInfo;
 import com.facebook.imagepipeline.animated.base.AnimatedImage;
+import com.facebook.imagepipeline.animated.factory.AnimatedImageDecoder;
 
 /**
  * A representation of a GIF image. An instance of this class will hold a copy of the encoded
@@ -25,7 +26,8 @@
  * {@link GifFrame}.
  */
 @ThreadSafe
-public class GifImage implements AnimatedImage {
+@DoNotStrip
+public class GifImage implements AnimatedImage, AnimatedImageDecoder {
 
   private volatile static boolean sInitialized;
 
@@ -64,6 +66,15 @@ public static GifImage create(long nativePtr, int sizeInBytes) {
     return nativeCreateFromNativeMemory(nativePtr, sizeInBytes);
   }
 
+  @Override
+  public AnimatedImage decode(long nativePtr, int sizeInBytes) {
+    return GifImage.create(nativePtr, sizeInBytes);
+  }
+
+  @DoNotStrip
+  public GifImage() {
+  }
+
   /**
    * Constructs the image with the native pointer. This is called by native code.
    *
diff --git a/animated-gif/src/main/jni/Application.mk b/animated-gif/src/main/jni/Application.mk
new file mode 100644
index 000000000..f7f46e3b8
--- /dev/null
+++ b/animated-gif/src/main/jni/Application.mk
@@ -0,0 +1,27 @@
+# Copyright 2004-present Facebook. All Rights Reserved.
+APP_BUILD_SCRIPT := Android.mk
+
+APP_ABI := armeabi-v7a armeabi arm64-v8a x86 x86_64
+APP_PLATFORM := android-9
+
+APP_MK_DIR := $(dir $(lastword $(MAKEFILE_LIST)))
+NDK_MODULE_PATH := $(APP_MK_DIR)$(HOST_DIRSEP)$(APP_MK_DIR)../../../nativedeps/merge
+
+APP_STL := gnustl_static
+
+# Make sure every shared lib includes a .note.gnu.build-id header
+APP_LDFLAGS := -Wl,--build-id
+
+NDK_TOOLCHAIN_VERSION := 4.9
+
+
+# We link our libs with static stl implementation. Because of that we need to
+# hide all stl related symbols to make them unaccessible from the outside.
+# We also need to make sure that our library does not use any stl functions
+# coming from other stl implementations as well
+
+# Do not use weak symbols - this will hide symbols generated by templates
+FRESCO_CPP_CFLAGS := -fno-weak
+
+# This hides all symbols exported from libgnustl_static
+FRESCO_CPP_LDFLAGS := -Wl,--gc-sections,--exclude-libs,libgnustl_static.a
diff --git a/imagepipeline/src/main/jni/gifimage/Android.mk b/animated-gif/src/main/jni/gifimage/Android.mk
similarity index 100%
rename from imagepipeline/src/main/jni/gifimage/Android.mk
rename to animated-gif/src/main/jni/gifimage/Android.mk
diff --git a/imagepipeline/src/main/jni/gifimage/gif.cpp b/animated-gif/src/main/jni/gifimage/gif.cpp
similarity index 99%
rename from imagepipeline/src/main/jni/gifimage/gif.cpp
rename to animated-gif/src/main/jni/gifimage/gif.cpp
index c1dbe6092..1e03d7761 100644
--- a/imagepipeline/src/main/jni/gifimage/gif.cpp
+++ b/animated-gif/src/main/jni/gifimage/gif.cpp
@@ -225,9 +225,9 @@ static const PixelType32 TRANSPARENT {0, 0, 0, 0};
 
 // Class Names.
 static const char* const kGifImageClassPathName =
-    "com/facebook/imagepipeline/gif/GifImage";
+    "com/facebook/animated/gif/GifImage";
 static const char* const kGifFrameClassPathName =
-    "com/facebook/imagepipeline/gif/GifFrame";
+    "com/facebook/animated/gif/GifFrame";
 
 // Cached fields related to GifImage
 static jclass sClazzGifImage;
@@ -1175,10 +1175,10 @@ void GifFrame_nativeFinalize(JNIEnv* pEnv, jobject thiz) {
 
 static JNINativeMethod sGifImageMethods[] = {
   { "nativeCreateFromDirectByteBuffer",
-    "(Ljava/nio/ByteBuffer;)Lcom/facebook/imagepipeline/gif/GifImage;",
+    "(Ljava/nio/ByteBuffer;)Lcom/facebook/animated/gif/GifImage;",
     (void*)GifImage_nativeCreateFromDirectByteBuffer },
   { "nativeCreateFromNativeMemory",
-    "(JI)Lcom/facebook/imagepipeline/gif/GifImage;",
+    "(JI)Lcom/facebook/animated/gif/GifImage;",
     (void*)GifImage_nativeCreateFromNativeMemory },
   { "nativeGetWidth",
     "()I",
@@ -1202,7 +1202,7 @@ static JNINativeMethod sGifImageMethods[] = {
     "()I",
     (void*)GifImage_nativeGetLoopCount },
   { "nativeGetFrame",
-    "(I)Lcom/facebook/imagepipeline/gif/GifFrame;",
+    "(I)Lcom/facebook/animated/gif/GifFrame;",
     (void*)GifImage_nativeGetFrame },
   { "nativeGetSizeInBytes",
     "()I",
diff --git a/imagepipeline/src/main/jni/gifimage/jni.cpp b/animated-gif/src/main/jni/gifimage/jni.cpp
similarity index 100%
rename from imagepipeline/src/main/jni/gifimage/jni.cpp
rename to animated-gif/src/main/jni/gifimage/jni.cpp
diff --git a/imagepipeline/src/main/jni/gifimage/jni_helpers.cpp b/animated-gif/src/main/jni/gifimage/jni_helpers.cpp
similarity index 100%
rename from imagepipeline/src/main/jni/gifimage/jni_helpers.cpp
rename to animated-gif/src/main/jni/gifimage/jni_helpers.cpp
diff --git a/imagepipeline/src/main/jni/gifimage/jni_helpers.h b/animated-gif/src/main/jni/gifimage/jni_helpers.h
similarity index 100%
rename from imagepipeline/src/main/jni/gifimage/jni_helpers.h
rename to animated-gif/src/main/jni/gifimage/jni_helpers.h
diff --git a/imagepipeline/src/main/jni/third-party/giflib/Android.mk b/animated-gif/src/main/jni/third-party/giflib/Android.mk
similarity index 100%
rename from imagepipeline/src/main/jni/third-party/giflib/Android.mk
rename to animated-gif/src/main/jni/third-party/giflib/Android.mk
diff --git a/animated-gif/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryGifImplTest.java b/animated-gif/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryGifImplTest.java
new file mode 100644
index 000000000..04773d461
--- /dev/null
+++ b/animated-gif/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryGifImplTest.java
@@ -0,0 +1,273 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+
+package com.facebook.imagepipeline.animated.factory;
+
+import android.graphics.Bitmap;
+import android.graphics.Rect;
+
+import com.facebook.common.references.CloseableReference;
+import com.facebook.common.references.ResourceReleaser;
+import com.facebook.common.soloader.SoLoaderShim;
+import com.facebook.imageformat.ImageFormat;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableBackend;
+import com.facebook.imagepipeline.animated.base.AnimatedImageResult;
+import com.facebook.imagepipeline.animated.factory.AnimatedImageFactoryImpl;
+import com.facebook.imagepipeline.animated.impl.AnimatedDrawableBackendProvider;
+import com.facebook.imagepipeline.animated.impl.AnimatedImageCompositor;
+import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
+import com.facebook.imagepipeline.common.ImageDecodeOptions;
+import com.facebook.imagepipeline.image.CloseableAnimatedImage;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.memory.PooledByteBuffer;
+import com.facebook.imagepipeline.testing.MockBitmapFactory;
+import com.facebook.imagepipeline.testing.TrivialPooledByteBuffer;
+import com.facebook.animated.gif.GifImage;
+
+import org.junit.Rule;
+import org.powermock.core.classloader.annotations.PowerMockIgnore;
+import org.powermock.modules.junit4.rule.PowerMockRule;
+import org.robolectric.RobolectricTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PrepareOnlyThisForTest;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+/**
+ * Tests for {@link AnimatedImageFactory}
+ */
+@RunWith(RobolectricTestRunner.class)
+@PrepareOnlyThisForTest({
+    GifImage.class,
+    AnimatedImageFactoryImpl.class,
+    AnimatedImageCompositor.class})
+@PowerMockIgnore({ "org.mockito.*", "org.robolectric.*", "android.*" })
+public class AnimatedImageFactoryGifImplTest {
+
+  private static final Bitmap.Config DEFAULT_BITMAP_CONFIG = Bitmap.Config.ARGB_8888;
+
+  @Rule
+  public PowerMockRule rule = new PowerMockRule();
+
+  static {
+    SoLoaderShim.setInTestMode();
+  }
+
+  private static ResourceReleaser<PooledByteBuffer> FAKE_RESOURCE_RELEASER =
+      new ResourceReleaser<PooledByteBuffer>() {
+
+    @Override
+    public void release(PooledByteBuffer value) {
+    }
+  };
+
+  private static ResourceReleaser<Bitmap> FAKE_BITMAP_RESOURCE_RELEASER =
+      new ResourceReleaser<Bitmap>() {
+
+        @Override
+        public void release(Bitmap value) {
+        }
+      };
+
+  private AnimatedDrawableBackendProvider mMockAnimatedDrawableBackendProvider;
+  private PlatformBitmapFactory mMockBitmapFactory;
+  private AnimatedImageFactory mAnimatedImageFactory;
+
+  private GifImage mGifImageMock;
+
+  @Before
+  public void setup() {
+    PowerMockito.mockStatic(GifImage.class);
+    mGifImageMock = mock(GifImage.class);
+
+    mMockAnimatedDrawableBackendProvider = mock(AnimatedDrawableBackendProvider.class);
+    mMockBitmapFactory = mock(PlatformBitmapFactory.class);
+
+    mAnimatedImageFactory = new AnimatedImageFactoryImpl(
+        mMockAnimatedDrawableBackendProvider,
+        mMockBitmapFactory);
+
+    ((AnimatedImageFactoryImpl) mAnimatedImageFactory).sGifAnimatedImageDecoder = mGifImageMock;
+
+  }
+
+  @Test
+  public void testCreateDefaults() {
+    GifImage mockGifImage = mock(GifImage.class);
+
+    // Expect a call to GifImage.create
+    TrivialPooledByteBuffer byteBuffer = createByteBuffer();
+    when(mGifImageMock.decode(byteBuffer.getNativePtr(), byteBuffer.size()))
+        .thenReturn(mockGifImage);
+
+    EncodedImage encodedImage = new EncodedImage(
+        CloseableReference.of(byteBuffer, FAKE_RESOURCE_RELEASER));
+    encodedImage.setImageFormat(ImageFormat.UNKNOWN);
+
+    CloseableAnimatedImage closeableImage =
+        (CloseableAnimatedImage) mAnimatedImageFactory.decodeGif(
+            encodedImage,
+            ImageDecodeOptions.defaults(),
+            DEFAULT_BITMAP_CONFIG);
+
+    // Verify we got the right result
+    AnimatedImageResult imageResult = closeableImage.getImageResult();
+    assertSame(mockGifImage, imageResult.getImage());
+    assertNull(imageResult.getPreviewBitmap());
+    assertFalse(imageResult.hasDecodedFrame(0));
+
+    // Should not have interacted with these.
+    verifyZeroInteractions(mMockAnimatedDrawableBackendProvider);
+    verifyZeroInteractions(mMockBitmapFactory);
+  }
+
+  @Test
+  public void testCreateWithPreviewBitmap() throws Exception {
+    GifImage mockGifImage = mock(GifImage.class);
+
+    Bitmap mockBitmap = MockBitmapFactory.create(50, 50, DEFAULT_BITMAP_CONFIG);
+
+    // Expect a call to WebPImage.create
+    TrivialPooledByteBuffer byteBuffer = createByteBuffer();
+    when(mGifImageMock.decode(byteBuffer.getNativePtr(), byteBuffer.size()))
+        .thenReturn(mockGifImage);
+    when(mockGifImage.getWidth()).thenReturn(50);
+    when(mockGifImage.getHeight()).thenReturn(50);
+
+    // For decoding preview frame, expect some calls.
+    final AnimatedDrawableBackend mockAnimatedDrawableBackend =
+        createAnimatedDrawableBackendMock(1);
+    when(mMockAnimatedDrawableBackendProvider.get(
+        any(AnimatedImageResult.class),
+        isNull(Rect.class)))
+        .thenReturn(mockAnimatedDrawableBackend);
+    when(mMockBitmapFactory.createBitmap(50, 50, DEFAULT_BITMAP_CONFIG))
+        .thenReturn(CloseableReference.of(mockBitmap, FAKE_BITMAP_RESOURCE_RELEASER));
+    AnimatedImageCompositor mockCompositor = mock(AnimatedImageCompositor.class);
+    PowerMockito.whenNew(AnimatedImageCompositor.class)
+        .withAnyArguments()
+        .thenReturn(mockCompositor);
+
+    ImageDecodeOptions imageDecodeOptions = ImageDecodeOptions.newBuilder()
+        .setDecodePreviewFrame(true)
+        .build();
+    EncodedImage encodedImage = new EncodedImage(
+        CloseableReference.of(byteBuffer, FAKE_RESOURCE_RELEASER));
+    encodedImage.setImageFormat(ImageFormat.UNKNOWN);
+    CloseableAnimatedImage closeableImage =
+        (CloseableAnimatedImage) mAnimatedImageFactory.decodeGif(
+            encodedImage,
+            imageDecodeOptions,
+            DEFAULT_BITMAP_CONFIG);
+
+    // Verify we got the right result
+    AnimatedImageResult imageResult = closeableImage.getImageResult();
+    assertSame(mockGifImage, imageResult.getImage());
+    assertNotNull(imageResult.getPreviewBitmap());
+    assertFalse(imageResult.hasDecodedFrame(0));
+
+    // Should not have interacted with these.
+    verify(mMockAnimatedDrawableBackendProvider).get(
+        any(AnimatedImageResult.class),
+        isNull(Rect.class));
+    verifyNoMoreInteractions(mMockAnimatedDrawableBackendProvider);
+    verify(mMockBitmapFactory).createBitmap(50, 50, DEFAULT_BITMAP_CONFIG);
+    verifyNoMoreInteractions(mMockBitmapFactory);
+    verify(mockCompositor).renderFrame(0, mockBitmap);
+  }
+
+  @Test
+  public void testCreateWithDecodeAlFrames() throws Exception {
+    GifImage mockGifImage = mock(GifImage.class);
+
+    Bitmap mockBitmap1 = MockBitmapFactory.create(50, 50, DEFAULT_BITMAP_CONFIG);
+    Bitmap mockBitmap2 = MockBitmapFactory.create(50, 50, DEFAULT_BITMAP_CONFIG);
+
+    // Expect a call to GifImage.create
+    TrivialPooledByteBuffer byteBuffer = createByteBuffer();
+    when(mGifImageMock.decode(byteBuffer.getNativePtr(), byteBuffer.size()))
+        .thenReturn(mockGifImage);
+    when(mockGifImage.getWidth()).thenReturn(50);
+    when(mockGifImage.getHeight()).thenReturn(50);
+
+    // For decoding preview frame, expect some calls.
+    final AnimatedDrawableBackend mockAnimatedDrawableBackend =
+        createAnimatedDrawableBackendMock(2);
+
+    when(
+        mMockAnimatedDrawableBackendProvider.get(
+            any(AnimatedImageResult.class),
+            isNull(Rect.class)))
+        .thenReturn(mockAnimatedDrawableBackend);
+
+    when(mMockBitmapFactory.createBitmap(50, 50, DEFAULT_BITMAP_CONFIG))
+        .thenReturn(CloseableReference.of(mockBitmap1, FAKE_BITMAP_RESOURCE_RELEASER))
+        .thenReturn(CloseableReference.of(mockBitmap2, FAKE_BITMAP_RESOURCE_RELEASER));
+    AnimatedImageCompositor mockCompositor = mock(AnimatedImageCompositor.class);
+    PowerMockito.whenNew(AnimatedImageCompositor.class)
+        .withAnyArguments()
+        .thenReturn(mockCompositor);
+
+    ImageDecodeOptions imageDecodeOptions = ImageDecodeOptions.newBuilder()
+        .setDecodePreviewFrame(true)
+        .setDecodeAllFrames(true)
+        .build();
+
+    EncodedImage encodedImage = new EncodedImage(
+        CloseableReference.of(byteBuffer, FAKE_RESOURCE_RELEASER));
+    encodedImage.setImageFormat(ImageFormat.UNKNOWN);
+
+    CloseableAnimatedImage closeableImage =
+        (CloseableAnimatedImage) mAnimatedImageFactory.decodeGif(
+            encodedImage,
+            imageDecodeOptions,
+            DEFAULT_BITMAP_CONFIG);
+
+    // Verify we got the right result
+    AnimatedImageResult imageResult = closeableImage.getImageResult();
+    assertSame(mockGifImage, imageResult.getImage());
+    assertNotNull(imageResult.getDecodedFrame(0));
+    assertNotNull(imageResult.getDecodedFrame(1));
+    assertNotNull(imageResult.getPreviewBitmap());
+
+    // Should not have interacted with these.
+    verify(mMockAnimatedDrawableBackendProvider).get(
+        any(AnimatedImageResult.class),
+        isNull(Rect.class));
+    verifyNoMoreInteractions(mMockAnimatedDrawableBackendProvider);
+    verify(mMockBitmapFactory, times(2)).createBitmap(50, 50, DEFAULT_BITMAP_CONFIG);
+    verifyNoMoreInteractions(mMockBitmapFactory);
+    verify(mockCompositor).renderFrame(0, mockBitmap1);
+    verify(mockCompositor).renderFrame(1, mockBitmap2);
+  }
+
+  private TrivialPooledByteBuffer createByteBuffer() {
+    byte[] buf = new byte[16];
+    return new TrivialPooledByteBuffer(buf);
+  }
+
+  /**
+   * Creates the mock for the AnimatedDrawableBackend with the number of frame
+   * @param frameCount The number of frame to mock
+   */
+  private AnimatedDrawableBackend createAnimatedDrawableBackendMock(final int frameCount) {
+    // For decoding preview frame, expect some calls.
+    final AnimatedDrawableBackend mockAnimatedDrawableBackend = mock(AnimatedDrawableBackend.class);
+    when(mockAnimatedDrawableBackend.getFrameCount()).thenReturn(frameCount);
+    when(mockAnimatedDrawableBackend.getWidth()).thenReturn(50);
+    when(mockAnimatedDrawableBackend.getHeight()).thenReturn(50);
+    return mockAnimatedDrawableBackend;
+  }
+}
diff --git a/animated-webp/.gitignore b/animated-webp/.gitignore
new file mode 100644
index 000000000..8afd910ce
--- /dev/null
+++ b/animated-webp/.gitignore
@@ -0,0 +1 @@
+nativedeps/
diff --git a/animated-webp/build.gradle b/animated-webp/build.gradle
new file mode 100644
index 000000000..9f52d3934
--- /dev/null
+++ b/animated-webp/build.gradle
@@ -0,0 +1,153 @@
+apply plugin: 'com.android.library'
+apply plugin: 'maven'
+
+project.group = GROUP
+version = VERSION_NAME
+
+apply plugin: 'de.undercouch.download'
+import de.undercouch.gradle.tasks.download.Download
+
+import org.apache.tools.ant.taskdefs.condition.Os
+
+dependencies {
+    provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    compile "com.parse.bolts:bolts-android:${BOLTS_ANDROID_VERSION}"
+    compile "com.nineoldandroids:library:${NINEOLDANDROID_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
+    provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
+    compile project(':fbcore')
+    compile project(':imagepipeline-base')
+    compile project(':animated-base')
+
+    testCompile project(':imagepipeline-base-test')
+    testCompile project(':imagepipeline-test')
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_CORE_VERSION}"
+    testCompile("org.powermock:powermock-api-mockito:${POWERMOCK_VERSION}") {
+        exclude group: 'org.mockito', module: 'mockito-all'
+    }
+    testCompile "org.powermock:powermock-module-junit4-rule:${POWERMOCK_VERSION}"
+    testCompile "org.powermock:powermock-classloading-xstream:${POWERMOCK_VERSION}"
+    testCompile("org.robolectric:robolectric:${ROBOLECTRIC_VERSION}") {
+        exclude group: 'commons-logging', module: 'commons-logging'
+        exclude group: 'org.apache.httpcomponents', module: 'httpclient'
+    }
+}
+apply from: rootProject.file('release.gradle')
+
+// We download various C++ open-source dependencies from SourceForge into nativedeps/downloads.
+// We then copy both downloaded code and our custom makefiles and headers into nativedeps/merge.
+
+def nativeDepsDir = new File("${projectDir}/nativedeps")
+def downloadsDir = new File("${nativeDepsDir}/downloads")
+def mergeDir = new File("${nativeDepsDir}/merge")
+
+task createNativeDepsDirectories {
+    nativeDepsDir.mkdirs()
+    downloadsDir.mkdirs()
+    mergeDir.mkdirs()
+}
+
+task downloadLibwebp(dependsOn: createNativeDepsDirectories, type: Download) {
+    src 'https://github.com/webmproject/libwebp/archive/v0.4.3.tar.gz'
+    onlyIfNewer true
+    overwrite false
+    dest downloadsDir
+}
+
+task unpackLibwebp(dependsOn: downloadLibwebp, type: Copy) {
+    from tarTree(resources.gzip("${downloadLibwebp.dest}/v0.4.3.tar.gz"))
+    into "${downloadsDir}/libwebp"
+}
+
+task copyLibwebp(dependsOn: unpackLibwebp, type: Copy) {
+    from "${unpackLibwebp.destinationDir}/libwebp-0.4.3"
+    from 'src/main/jni/third-party/libwebp-0.4.3'
+    include('src/**/*.c', 'src/**/*.h', '*.mk')
+    into "${mergeDir}/libwebp-0.4.3"
+}
+
+task fetchNativeDeps(dependsOn: [copyLibwebp]) {
+}
+
+task removeNativeDeps(type: Delete) {
+    delete nativeDepsDir
+}
+allclean.dependsOn removeNativeDeps
+
+def getNdkBuildName() {
+    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
+        return "ndk-build.cmd"
+    } else {
+        return "ndk-build"
+    }
+}
+
+def getNdkBuildFullPath() {
+    // we allow to provide full path to ndk-build tool
+    if (hasProperty('ndk.command')) {
+        return property('ndk.command')
+    }
+    // or just a path to the containing directiry
+    if (hasProperty('ndk.path')) {
+        def path = property('ndk.path')
+        if (!path.endsWith(File.separator)) {
+            path += File.separator
+        }
+        return path + getNdkBuildName()
+    }
+    // if none of above is provided, we assume ndk-build is already in $PATH
+    return getNdkBuildName()
+}
+
+def makeNdkTasks(String name, Object[] deps) {
+    task "ndk_build_$name"(dependsOn: deps, type: Exec) {
+        inputs.file("src/main/jni/$name")
+        outputs.dir("$buildDir/$name")
+        commandLine getNdkBuildFullPath(),
+            'NDK_PROJECT_PATH=null',
+            'NDK_APPLICATION_MK=../Application.mk',
+            'NDK_OUT=' + temporaryDir,
+            "NDK_LIBS_OUT=$buildDir/$name",
+            '-C', file("src/main/jni/$name").absolutePath,
+            '--jobs', Runtime.getRuntime().availableProcessors()
+    }
+
+    task "ndk_clean_$name"(type: Exec) {
+        ignoreExitValue true
+        commandLine getNdkBuildFullPath(),
+            'NDK_PROJECT_PATH=null',
+            'NDK_APPLICATION_MK=../Application.mk',
+            'NDK_OUT=' + temporaryDir,
+            "NDK_LIBS_OUT=$buildDir/$name",
+            '-C', file("src/main/jni/$name").absolutePath,
+            'clean'
+    }
+
+    tasks.withType(JavaCompile) {
+        compileTask -> compileTask.dependsOn "ndk_build_$name"
+    }
+    clean.dependsOn "ndk_clean_$name"
+}
+
+
+android {
+    def ndkLibs = [['webpimage', [copyLibwebp]]]
+
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    sourceSets {
+        main {
+            jni.srcDirs = []
+            jniLibs.srcDirs = ndkLibs.collect { "$buildDir/${it[0]}" }
+        }
+    }
+    ndkLibs.each { lib -> makeNdkTasks lib[0], lib[1] }
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+artifacts.add('archives', sourcesJar)
diff --git a/animated-webp/gradle.properties b/animated-webp/gradle.properties
new file mode 100644
index 000000000..a39bd1b5c
--- /dev/null
+++ b/animated-webp/gradle.properties
@@ -0,0 +1,5 @@
+POM_NAME=AnimatedWebp
+POM_DESCRIPTION=The classes to support animated webp
+POM_ARTIFACT_ID=animated-webp
+POM_PACKAGING=aar
+
diff --git a/animated-webp/src/main/AndroidManifest.xml b/animated-webp/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..36d7ed7a3
--- /dev/null
+++ b/animated-webp/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.animated.webp"
+    >
+
+  <uses-sdk
+      android:minSdkVersion="9"
+      android:targetSdkVersion="21"
+      />
+</manifest>
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPFrame.java b/animated-webp/src/main/java/com/facebook/animated/webp/WebPFrame.java
similarity index 98%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPFrame.java
rename to animated-webp/src/main/java/com/facebook/animated/webp/WebPFrame.java
index 0df06d1e3..f86095c84 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPFrame.java
+++ b/animated-webp/src/main/java/com/facebook/animated/webp/WebPFrame.java
@@ -7,7 +7,7 @@
  * of patent rights can be found in the PATENTS file in the same directory.
  */
 
-package com.facebook.imagepipeline.webp;
+package com.facebook.animated.webp;
 
 import javax.annotation.concurrent.ThreadSafe;
 
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPImage.java b/animated-webp/src/main/java/com/facebook/animated/webp/WebPImage.java
similarity index 90%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPImage.java
rename to animated-webp/src/main/java/com/facebook/animated/webp/WebPImage.java
index f7b563f46..eff128492 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPImage.java
+++ b/animated-webp/src/main/java/com/facebook/animated/webp/WebPImage.java
@@ -7,7 +7,7 @@
  * of patent rights can be found in the PATENTS file in the same directory.
  */
 
-package com.facebook.imagepipeline.webp;
+package com.facebook.animated.webp;
 
 import javax.annotation.concurrent.ThreadSafe;
 
@@ -19,6 +19,7 @@
 import com.facebook.imagepipeline.animated.base.AnimatedDrawableFrameInfo;
 import com.facebook.imagepipeline.animated.base.AnimatedDrawableFrameInfo.DisposalMethod;
 import com.facebook.imagepipeline.animated.base.AnimatedImage;
+import com.facebook.imagepipeline.animated.factory.AnimatedImageDecoder;
 
 /**
  * A representation of a WebP image. An instance of this class will hold a copy of the encoded
@@ -26,7 +27,8 @@
  * {@link WebPFrame}.
  */
 @ThreadSafe
-public class WebPImage implements AnimatedImage {
+@DoNotStrip
+public class WebPImage implements AnimatedImage, AnimatedImageDecoder {
 
   private volatile static boolean sInitialized;
 
@@ -37,16 +39,20 @@
 
   private static synchronized void ensure() {
     if (!sInitialized) {
-      sInitialized = true;
       try {
         SoLoaderShim.loadLibrary("webp");
-      } catch(UnsatisfiedLinkError error) {
-        // Optional library not present
+      } catch(UnsatisfiedLinkError nle) {
+        // Head in the sand
       }
       SoLoaderShim.loadLibrary("webpimage");
+      sInitialized = true;
     }
   }
 
+  @DoNotStrip
+  public WebPImage() {
+  }
+
   /**
    * Constructs the image with the native pointer. This is called by native code.
    *
@@ -90,6 +96,11 @@ public static WebPImage create(long nativePtr, int sizeInBytes) {
     return nativeCreateFromNativeMemory(nativePtr, sizeInBytes);
   }
 
+  @Override
+  public AnimatedImage decode(long nativePtr, int sizeInBytes) {
+    return WebPImage.create(nativePtr, sizeInBytes);
+  }
+
   @Override
   public int getWidth() {
     return nativeGetWidth();
diff --git a/animated-webp/src/main/jni/Application.mk b/animated-webp/src/main/jni/Application.mk
new file mode 100644
index 000000000..f7f46e3b8
--- /dev/null
+++ b/animated-webp/src/main/jni/Application.mk
@@ -0,0 +1,27 @@
+# Copyright 2004-present Facebook. All Rights Reserved.
+APP_BUILD_SCRIPT := Android.mk
+
+APP_ABI := armeabi-v7a armeabi arm64-v8a x86 x86_64
+APP_PLATFORM := android-9
+
+APP_MK_DIR := $(dir $(lastword $(MAKEFILE_LIST)))
+NDK_MODULE_PATH := $(APP_MK_DIR)$(HOST_DIRSEP)$(APP_MK_DIR)../../../nativedeps/merge
+
+APP_STL := gnustl_static
+
+# Make sure every shared lib includes a .note.gnu.build-id header
+APP_LDFLAGS := -Wl,--build-id
+
+NDK_TOOLCHAIN_VERSION := 4.9
+
+
+# We link our libs with static stl implementation. Because of that we need to
+# hide all stl related symbols to make them unaccessible from the outside.
+# We also need to make sure that our library does not use any stl functions
+# coming from other stl implementations as well
+
+# Do not use weak symbols - this will hide symbols generated by templates
+FRESCO_CPP_CFLAGS := -fno-weak
+
+# This hides all symbols exported from libgnustl_static
+FRESCO_CPP_LDFLAGS := -Wl,--gc-sections,--exclude-libs,libgnustl_static.a
diff --git a/imagepipeline/src/main/jni/third-party/libwebp-0.4.3/Android.mk b/animated-webp/src/main/jni/third-party/libwebp-0.4.3/Android.mk
similarity index 100%
rename from imagepipeline/src/main/jni/third-party/libwebp-0.4.3/Android.mk
rename to animated-webp/src/main/jni/third-party/libwebp-0.4.3/Android.mk
diff --git a/imagepipeline/src/main/jni/webpimage/Android.mk b/animated-webp/src/main/jni/webpimage/Android.mk
similarity index 100%
rename from imagepipeline/src/main/jni/webpimage/Android.mk
rename to animated-webp/src/main/jni/webpimage/Android.mk
diff --git a/imagepipeline/src/main/jni/webpimage/jni.cpp b/animated-webp/src/main/jni/webpimage/jni.cpp
similarity index 100%
rename from imagepipeline/src/main/jni/webpimage/jni.cpp
rename to animated-webp/src/main/jni/webpimage/jni.cpp
diff --git a/imagepipeline/src/main/jni/webpimage/jni_helpers.cpp b/animated-webp/src/main/jni/webpimage/jni_helpers.cpp
similarity index 100%
rename from imagepipeline/src/main/jni/webpimage/jni_helpers.cpp
rename to animated-webp/src/main/jni/webpimage/jni_helpers.cpp
diff --git a/imagepipeline/src/main/jni/webpimage/jni_helpers.h b/animated-webp/src/main/jni/webpimage/jni_helpers.h
similarity index 100%
rename from imagepipeline/src/main/jni/webpimage/jni_helpers.h
rename to animated-webp/src/main/jni/webpimage/jni_helpers.h
diff --git a/imagepipeline/src/main/jni/webpimage/webp.cpp b/animated-webp/src/main/jni/webpimage/webp.cpp
similarity index 98%
rename from imagepipeline/src/main/jni/webpimage/webp.cpp
rename to animated-webp/src/main/jni/webpimage/webp.cpp
index 4a0f68314..1f1f2f139 100644
--- a/imagepipeline/src/main/jni/webpimage/webp.cpp
+++ b/animated-webp/src/main/jni/webpimage/webp.cpp
@@ -145,9 +145,9 @@ struct WebPFrameNativeContext {
 
 // Class Names.
 static const char* const kWebPImageClassPathName =
-    "com/facebook/imagepipeline/webp/WebPImage";
+    "com/facebook/animated/webp/WebPImage";
 static const char* const kWebPFrameClassPathName =
-    "com/facebook/imagepipeline/webp/WebPFrame";
+    "com/facebook/animated/webp/WebPFrame";
 
 // Cached fields related to WebPImage
 static jclass sClazzWebPImage;
@@ -782,10 +782,10 @@ void WebPFrame_nativeFinalize(JNIEnv* pEnv, jobject thiz) {
 
 static JNINativeMethod sWebPImageMethods[] = {
   { "nativeCreateFromDirectByteBuffer",
-    "(Ljava/nio/ByteBuffer;)Lcom/facebook/imagepipeline/webp/WebPImage;",
+    "(Ljava/nio/ByteBuffer;)Lcom/facebook/animated/webp/WebPImage;",
     (void*)WebPImage_nativeCreateFromDirectByteBuffer },
   { "nativeCreateFromNativeMemory",
-    "(JI)Lcom/facebook/imagepipeline/webp/WebPImage;",
+    "(JI)Lcom/facebook/animated/webp/WebPImage;",
     (void*)WebPImage_nativeCreateFromNativeMemory },
   { "nativeGetWidth",
     "()I",
@@ -809,7 +809,7 @@ static JNINativeMethod sWebPImageMethods[] = {
     "()I",
     (void*)WebPImage_nativeGetLoopCount },
   { "nativeGetFrame",
-    "(I)Lcom/facebook/imagepipeline/webp/WebPFrame;",
+    "(I)Lcom/facebook/animated/webp/WebPFrame;",
     (void*)WebPImage_nativeGetFrame },
   { "nativeGetSizeInBytes",
     "()I",
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryTest.java b/animated-webp/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryWebPImplTest.java
similarity index 83%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryTest.java
rename to animated-webp/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryWebPImplTest.java
index 0242ed86d..680ee689a 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryTest.java
+++ b/animated-webp/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryWebPImplTest.java
@@ -17,10 +17,11 @@
 import com.facebook.common.references.ResourceReleaser;
 import com.facebook.common.soloader.SoLoaderShim;
 import com.facebook.imageformat.ImageFormat;
+import com.facebook.imagepipeline.animated.base.AnimatedDrawableBackend;
 import com.facebook.imagepipeline.animated.base.AnimatedImageResult;
+import com.facebook.imagepipeline.animated.factory.AnimatedImageFactoryImpl;
 import com.facebook.imagepipeline.animated.impl.AnimatedDrawableBackendProvider;
 import com.facebook.imagepipeline.animated.impl.AnimatedImageCompositor;
-import com.facebook.imagepipeline.animated.testing.TestAnimatedDrawableBackend;
 import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
 import com.facebook.imagepipeline.common.ImageDecodeOptions;
 import com.facebook.imagepipeline.image.CloseableAnimatedImage;
@@ -28,7 +29,7 @@
 import com.facebook.imagepipeline.memory.PooledByteBuffer;
 import com.facebook.imagepipeline.testing.MockBitmapFactory;
 import com.facebook.imagepipeline.testing.TrivialPooledByteBuffer;
-import com.facebook.imagepipeline.webp.WebPImage;
+import com.facebook.animated.webp.WebPImage;
 
 import org.junit.Rule;
 import org.powermock.core.classloader.annotations.PowerMockIgnore;
@@ -50,10 +51,10 @@
 @RunWith(RobolectricTestRunner.class)
 @PrepareOnlyThisForTest({
     WebPImage.class,
-    AnimatedImageFactory.class,
+    AnimatedImageFactoryImpl.class,
     AnimatedImageCompositor.class})
 @PowerMockIgnore({ "org.mockito.*", "org.robolectric.*", "android.*" })
-public class AnimatedImageFactoryTest {
+public class AnimatedImageFactoryWebPImplTest {
 
   private static final Bitmap.Config DEFAULT_BITMAP_CONFIG = Bitmap.Config.ARGB_8888;
 
@@ -84,16 +85,22 @@ public void release(Bitmap value) {
   private PlatformBitmapFactory mMockBitmapFactory;
   private AnimatedImageFactory mAnimatedImageFactory;
 
+  private WebPImage mWebPImageMock;
+
   @Before
   public void setup() {
     PowerMockito.mockStatic(WebPImage.class);
+    mWebPImageMock = mock(WebPImage.class);
 
     mMockAnimatedDrawableBackendProvider = mock(AnimatedDrawableBackendProvider.class);
     mMockBitmapFactory = mock(PlatformBitmapFactory.class);
 
-    mAnimatedImageFactory = new AnimatedImageFactory(
+    mAnimatedImageFactory = new AnimatedImageFactoryImpl(
         mMockAnimatedDrawableBackendProvider,
         mMockBitmapFactory);
+
+    ((AnimatedImageFactoryImpl) mAnimatedImageFactory).sWebpAnimatedImageDecoder = mWebPImageMock;
+
   }
 
   @Test
@@ -102,7 +109,7 @@ public void testCreateDefaults() {
 
     // Expect a call to WebPImage.create
     TrivialPooledByteBuffer byteBuffer = createByteBuffer();
-    when(WebPImage.create(byteBuffer.getNativePtr(), byteBuffer.size()))
+    when(mWebPImageMock.decode(byteBuffer.getNativePtr(), byteBuffer.size()))
         .thenReturn(mockWebPImage);
 
     EncodedImage encodedImage = new EncodedImage(
@@ -134,16 +141,19 @@ public void testCreateWithPreviewBitmap() throws Exception {
 
     // Expect a call to WebPImage.create
     TrivialPooledByteBuffer byteBuffer = createByteBuffer();
-    when(WebPImage.create(byteBuffer.getNativePtr(), byteBuffer.size()))
+    when(mWebPImageMock.decode(byteBuffer.getNativePtr(), byteBuffer.size()))
         .thenReturn(mockWebPImage);
     when(mockWebPImage.getWidth()).thenReturn(50);
     when(mockWebPImage.getHeight()).thenReturn(50);
 
     // For decoding preview frame, expect some calls.
+    final AnimatedDrawableBackend mockAnimatedDrawableBackend =
+        createAnimatedDrawableBackendMock(1);
+
     when(mMockAnimatedDrawableBackendProvider.get(
             any(AnimatedImageResult.class),
             isNull(Rect.class)))
-        .thenReturn(new TestAnimatedDrawableBackend(50, 50, new int[]{100}));
+        .thenReturn(mockAnimatedDrawableBackend);
     when(mMockBitmapFactory.createBitmap(50, 50, DEFAULT_BITMAP_CONFIG))
         .thenReturn(CloseableReference.of(mockBitmap, FAKE_BITMAP_RESOURCE_RELEASER));
     AnimatedImageCompositor mockCompositor = mock(AnimatedImageCompositor.class);
@@ -188,17 +198,20 @@ public void testCreateWithDecodeAlFrames() throws Exception {
 
     // Expect a call to WebPImage.create
     TrivialPooledByteBuffer byteBuffer = createByteBuffer();
-    when(WebPImage.create(byteBuffer.getNativePtr(), byteBuffer.size()))
+    when(mWebPImageMock.decode(byteBuffer.getNativePtr(), byteBuffer.size()))
         .thenReturn(mockWebPImage);
     when(mockWebPImage.getWidth()).thenReturn(50);
     when(mockWebPImage.getHeight()).thenReturn(50);
 
     // For decoding preview frame, expect some calls.
+    final AnimatedDrawableBackend mockAnimatedDrawableBackend =
+        createAnimatedDrawableBackendMock(2);
     when(
         mMockAnimatedDrawableBackendProvider.get(
             any(AnimatedImageResult.class),
             isNull(Rect.class)))
-        .thenReturn(new TestAnimatedDrawableBackend(50, 50, new int[]{ 100, 200 }));
+        .thenReturn(mockAnimatedDrawableBackend);
+
     when(mMockBitmapFactory.createBitmap(50, 50, DEFAULT_BITMAP_CONFIG))
         .thenReturn(CloseableReference.of(mockBitmap1, FAKE_BITMAP_RESOURCE_RELEASER))
         .thenReturn(CloseableReference.of(mockBitmap2, FAKE_BITMAP_RESOURCE_RELEASER));
@@ -244,4 +257,17 @@ private TrivialPooledByteBuffer createByteBuffer() {
     byte[] buf = new byte[16];
     return new TrivialPooledByteBuffer(buf);
   }
+
+  /**
+   * Creates the mock for the AnimatedDrawableBackend with the number of frame
+   * @param frameCount The number of frame to mock
+   */
+  private AnimatedDrawableBackend createAnimatedDrawableBackendMock(final int frameCount) {
+    // For decoding preview frame, expect some calls.
+    final AnimatedDrawableBackend mockAnimatedDrawableBackend = mock(AnimatedDrawableBackend.class);
+    when(mockAnimatedDrawableBackend.getFrameCount()).thenReturn(frameCount);
+    when(mockAnimatedDrawableBackend.getWidth()).thenReturn(50);
+    when(mockAnimatedDrawableBackend.getHeight()).thenReturn(50);
+    return mockAnimatedDrawableBackend;
+  }
 }
diff --git a/build.gradle b/build.gradle
index 5033e1229..52bb17a24 100644
--- a/build.gradle
+++ b/build.gradle
@@ -16,6 +16,8 @@ buildscript {
 project.ext {
     buildToolsVersion = "${BUILD_TOOLS_VERSION}"
     compileSdkVersion = COMPILE_SDK_VERSION.toInteger()
+    minSdkVersion = MIN_SDK_VERSION;
+    targetSdkVersion = TARGET_SDK_VERSION;
 }
 
 subprojects {
diff --git a/circle.yml b/circle.yml
new file mode 100644
index 000000000..4d3456bb3
--- /dev/null
+++ b/circle.yml
@@ -0,0 +1,12 @@
+general:
+  branches:
+    ignore:
+      - gh-pages
+machine:
+  environment:
+    PATH: $ANDROID_NDK:$PATH
+test:
+  post:
+    # copy test report for Circle CI to display
+    - mkdir -p $CIRCLE_TEST_REPORTS/junit/
+    - find . -type f -regex ".*/build/test-results/debug/.*xml" -exec cp {} $CIRCLE_TEST_REPORTS/junit/ \;
diff --git a/drawee-backends/drawee-pipeline/src/main/gen/com/facebook/drawee/backends/pipeline/BuildConfig.java b/drawee-backends/drawee-pipeline/src/main/gen/com/facebook/drawee/backends/pipeline/BuildConfig.java
new file mode 100644
index 000000000..69e8400da
--- /dev/null
+++ b/drawee-backends/drawee-pipeline/src/main/gen/com/facebook/drawee/backends/pipeline/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.drawee.backends.pipeline;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/drawee-backends/drawee-pipeline/src/main/gen/com/facebook/drawee/backends/pipeline/Manifest.java b/drawee-backends/drawee-pipeline/src/main/gen/com/facebook/drawee/backends/pipeline/Manifest.java
new file mode 100644
index 000000000..c79b8940b
--- /dev/null
+++ b/drawee-backends/drawee-pipeline/src/main/gen/com/facebook/drawee/backends/pipeline/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.drawee.backends.pipeline;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/drawee-backends/drawee-pipeline/src/main/gen/com/facebook/drawee/backends/pipeline/R.java b/drawee-backends/drawee-pipeline/src/main/gen/com/facebook/drawee/backends/pipeline/R.java
new file mode 100644
index 000000000..7c5ffba95
--- /dev/null
+++ b/drawee-backends/drawee-pipeline/src/main/gen/com/facebook/drawee/backends/pipeline/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.drawee.backends.pipeline;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeController.java b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeController.java
index b3ff4b3a1..38f21cd8b 100644
--- a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeController.java
+++ b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeController.java
@@ -24,7 +24,6 @@
 import com.facebook.drawee.controller.AbstractDraweeController;
 import com.facebook.drawee.drawable.OrientedDrawable;
 import com.facebook.imagepipeline.animated.factory.AnimatedDrawableFactory;
-import com.facebook.imagepipeline.image.CloseableAnimatedImage;
 import com.facebook.imagepipeline.image.CloseableImage;
 import com.facebook.imagepipeline.image.CloseableStaticBitmap;
 import com.facebook.imagepipeline.image.EncodedImage;
@@ -113,9 +112,8 @@ protected Drawable createDrawable(CloseableReference<CloseableImage> image) {
       } else {
         return new OrientedDrawable(bitmapDrawable, closeableStaticBitmap.getRotationAngle());
       }
-    } else if (closeableImage instanceof CloseableAnimatedImage) {
-      return mAnimatedDrawableFactory.create(
-          ((CloseableAnimatedImage) closeableImage).getImageResult());
+    } else if (mAnimatedDrawableFactory != null) {
+      return mAnimatedDrawableFactory.create(closeableImage);
     } else {
       throw new UnsupportedOperationException("Unrecognized image class: " + closeableImage);
     }
diff --git a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilderSupplier.java b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilderSupplier.java
index d118d2856..5033ed58e 100644
--- a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilderSupplier.java
+++ b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilderSupplier.java
@@ -17,6 +17,8 @@
 import com.facebook.drawee.controller.ControllerListener;
 import com.facebook.imagepipeline.core.ImagePipeline;
 import com.facebook.imagepipeline.core.ImagePipelineFactory;
+import com.facebook.imagepipeline.animated.factory.AnimatedDrawableFactory;
+import com.facebook.imagepipeline.animated.factory.AnimatedFactory;
 
 import java.util.Set;
 
@@ -44,10 +46,17 @@ public PipelineDraweeControllerBuilderSupplier(
       Set<ControllerListener> boundControllerListeners) {
     mContext = context;
     mImagePipeline = imagePipelineFactory.getImagePipeline();
+
+    final AnimatedFactory animatedFactory = imagePipelineFactory.getAnimatedFactory();
+    AnimatedDrawableFactory animatedDrawableFactory = null;
+    if (animatedFactory != null) {
+      animatedDrawableFactory = animatedFactory.getAnimatedDrawableFactory(context);
+    }
+
     mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(
         context.getResources(),
         DeferredReleaser.getInstance(),
-        imagePipelineFactory.getAnimatedDrawableFactory(),
+        animatedDrawableFactory,
         UiThreadImmediateExecutorService.getInstance());
     mBoundControllerListeners = boundControllerListeners;
   }
diff --git a/drawee/build.gradle b/drawee/build.gradle
index a3735cdbe..9bac771c3 100644
--- a/drawee/build.gradle
+++ b/drawee/build.gradle
@@ -5,7 +5,7 @@ project.group = GROUP
 version = VERSION_NAME
 
 dependencies {
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
     provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
 
diff --git a/drawee/src/main/gen/com/facebook/drawee/BuildConfig.java b/drawee/src/main/gen/com/facebook/drawee/BuildConfig.java
new file mode 100644
index 000000000..c0d4a8f94
--- /dev/null
+++ b/drawee/src/main/gen/com/facebook/drawee/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.drawee;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/drawee/src/main/gen/com/facebook/drawee/Manifest.java b/drawee/src/main/gen/com/facebook/drawee/Manifest.java
new file mode 100644
index 000000000..077bac699
--- /dev/null
+++ b/drawee/src/main/gen/com/facebook/drawee/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.drawee;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/drawee/src/main/gen/com/facebook/drawee/R.java b/drawee/src/main/gen/com/facebook/drawee/R.java
new file mode 100644
index 000000000..bd99f5cce
--- /dev/null
+++ b/drawee/src/main/gen/com/facebook/drawee/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.drawee;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/drawee/src/main/java/com/facebook/drawee/components/DraweeEventTracker.java b/drawee/src/main/java/com/facebook/drawee/components/DraweeEventTracker.java
index 0d80b1195..e566762dd 100644
--- a/drawee/src/main/java/com/facebook/drawee/components/DraweeEventTracker.java
+++ b/drawee/src/main/java/com/facebook/drawee/components/DraweeEventTracker.java
@@ -40,7 +40,10 @@
     ON_DRAWABLE_SHOW,
     ON_DRAWABLE_HIDE,
     ON_ACTIVITY_START,
-    ON_ACTIVITY_STOP
+    ON_ACTIVITY_STOP,
+    ON_RUN_CLEAR_CONTROLLER,
+    ON_SCHEDULE_CLEAR_CONTROLLER,
+    ON_SAME_CONTROLLER_SKIPPED
   }
 
   private final Queue<Event> mEventQueue = new ArrayBlockingQueue<Event>(MAX_EVENTS_TO_TRACK);
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java
index 8b3adec55..00e7190eb 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java
@@ -212,6 +212,7 @@ public void setTransformCallback(@Nullable TransformCallback transformCallback)
   public void setAlpha(int alpha) {
     if (alpha != mPaint.getAlpha()) {
       mPaint.setAlpha(alpha);
+      super.setAlpha(alpha);
       invalidateSelf();
     }
   }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java
index 5b6fc90c4..ef4b596e9 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java
@@ -18,15 +18,18 @@
 import com.facebook.common.internal.Preconditions;
 import com.facebook.common.internal.VisibleForTesting;
 
+import static com.facebook.drawee.drawable.ScalingUtils.*;
+
 /**
- * Drawable that can scale underlying drawable based on specified {@link ScalingUtils.ScaleType}
+ * Drawable that can scale underlying drawable based on specified {@link ScaleType}
  * options.
  * <p/> Based on {@link android.widget.ImageView.ScaleType}.
  */
 public class ScaleTypeDrawable extends ForwardingDrawable {
 
   // Specified scale type.
-  @VisibleForTesting ScalingUtils.ScaleType mScaleType;
+  @VisibleForTesting ScaleType mScaleType;
+  @VisibleForTesting Object mScaleTypeState;
 
   // Specified focus point to use with FOCUS_CROP.
   @VisibleForTesting PointF mFocusPoint = null;
@@ -47,7 +50,7 @@
    * @param drawable underlying drawable to apply scale type on
    * @param scaleType scale type to be applied
    */
-  public ScaleTypeDrawable(Drawable drawable, ScalingUtils.ScaleType scaleType) {
+  public ScaleTypeDrawable(Drawable drawable, ScaleType scaleType) {
     super(Preconditions.checkNotNull(drawable));
     mScaleType = scaleType;
   }
@@ -56,7 +59,7 @@ public ScaleTypeDrawable(Drawable drawable, ScalingUtils.ScaleType scaleType) {
    * Gets the current scale type.
    * @return scale type
    */
-  public ScalingUtils.ScaleType getScaleType() {
+  public ScaleType getScaleType() {
     return mScaleType;
   }
 
@@ -64,8 +67,9 @@ public ScaleTypeDrawable(Drawable drawable, ScalingUtils.ScaleType scaleType) {
    * Sets the scale type.
    * @param scaleType scale type to set
    */
-  public void setScaleType(ScalingUtils.ScaleType scaleType) {
+  public void setScaleType(ScaleType scaleType) {
     mScaleType = scaleType;
+    mScaleTypeState = null;
     configureBounds();
     invalidateSelf();
   }
@@ -115,8 +119,16 @@ protected void onBoundsChange(Rect bounds) {
   }
 
   private void configureBoundsIfUnderlyingChanged() {
-    if (mUnderlyingWidth != getCurrent().getIntrinsicWidth() ||
-        mUnderlyingHeight != getCurrent().getIntrinsicHeight()) {
+    boolean scaleTypeChanged = false;
+    if (mScaleType instanceof StatefulScaleType) {
+      Object state = ((StatefulScaleType) mScaleType).getState();
+      scaleTypeChanged = (state == null || !state.equals(mScaleTypeState));
+      mScaleTypeState = state;
+    }
+    boolean underlyingChanged =
+        mUnderlyingWidth != getCurrent().getIntrinsicWidth() ||
+        mUnderlyingHeight != getCurrent().getIntrinsicHeight();
+    if (underlyingChanged || scaleTypeChanged) {
       configureBounds();
     }
   }
@@ -148,8 +160,8 @@ private void configureBoundsIfUnderlyingChanged() {
     }
 
     // If we're told to scale to fit, we just fill our entire view.
-    // (ScalingUtils.getTransform would do, but this is faster)
-    if (mScaleType == ScalingUtils.ScaleType.FIT_XY) {
+    // (ScaleType.getTransform would do, but this is faster)
+    if (mScaleType == ScaleType.FIT_XY) {
       underlyingDrawable.setBounds(bounds);
       mDrawMatrix = null;
       return;
@@ -157,14 +169,13 @@ private void configureBoundsIfUnderlyingChanged() {
 
     // We need to do the scaling ourselves, so have the underlying drawable use its preferred size.
     underlyingDrawable.setBounds(0, 0, underlyingWidth, underlyingHeight);
-    ScalingUtils.getTransform(
+    mScaleType.getTransform(
         mTempMatrix,
         bounds,
         underlyingWidth,
         underlyingHeight,
         (mFocusPoint != null) ? mFocusPoint.x : 0.5f,
-        (mFocusPoint != null) ? mFocusPoint.y : 0.5f,
-        mScaleType);
+        (mFocusPoint != null) ? mFocusPoint.y : 0.5f);
     mDrawMatrix = mTempMatrix;
   }
 
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java b/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java
index 206c0ff0d..e60e83da8 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java
@@ -24,56 +24,55 @@
    * To use matrix scaling, use a {@link MatrixDrawable}. An additional scale type (FOCUS_CROP) is
    * provided.
    * <p>
-   * Note: The enum values should be in sync with the scaleType attribute values in attrs.xml
    */
-  public enum ScaleType {
+  public interface ScaleType {
 
     /**
      * Scales width and height independently, so that the child matches the parent exactly.
      * This may change the aspect ratio of the child.
      */
-    FIT_XY,
+    static final ScaleType FIT_XY = ScaleTypeFitXY.INSTANCE;
 
     /**
      * Scales the child so that it fits entirely inside the parent. At least one dimension (width or
      * height) will fit exactly. Aspect ratio is preserved.
      * Child is aligned to the top-left corner of the parent.
      */
-    FIT_START,
+    static final ScaleType FIT_START = ScaleTypeFitStart.INSTANCE;
 
     /**
      * Scales the child so that it fits entirely inside the parent. At least one dimension (width or
      * height) will fit exactly. Aspect ratio is preserved.
      * Child is centered within the parent's bounds.
      */
-    FIT_CENTER,
+    static final ScaleType FIT_CENTER = ScaleTypeFitCenter.INSTANCE;
 
     /**
      * Scales the child so that it fits entirely inside the parent. At least one dimension (width or
      * height) will fit exactly. Aspect ratio is preserved.
      * Child is aligned to the bottom-right corner of the parent.
      */
-    FIT_END,
+    static final ScaleType FIT_END = ScaleTypeFitEnd.INSTANCE;
 
     /**
      * Performs no scaling.
      * Child is centered within parent's bounds.
      */
-    CENTER,
+    static final ScaleType CENTER = ScaleTypeCenter.INSTANCE;
 
     /**
      * Scales the child so that it fits entirely inside the parent. Unlike FIT_CENTER, if the child
      * is smaller, no up-scaling will be performed. Aspect ratio is preserved.
      * Child is centered within parent's bounds.
      */
-    CENTER_INSIDE,
+    static final ScaleType CENTER_INSIDE = ScaleTypeCenterInside.INSTANCE;
 
     /**
      * Scales the child so that both dimensions will be greater than or equal to the corresponding
      * dimension of the parent. At least one dimension (width or height) will fit exactly.
      * Child is centered within parent's bounds.
      */
-    CENTER_CROP,
+    static final ScaleType CENTER_CROP = ScaleTypeCenterCrop.INSTANCE;
 
     /**
      * Scales the child so that both dimensions will be greater than or equal to the corresponding
@@ -83,7 +82,25 @@
      * It is guaranteed that the focus point will be visible and centered as much as possible.
      * If the focus point is set to (0.5f, 0.5f), result will be equivalent to CENTER_CROP.
      */
-    FOCUS_CROP
+    static final ScaleType FOCUS_CROP = ScaleTypeFocusCrop.INSTANCE;
+
+    /**
+     * Gets transformation matrix based on the scale type.
+     * @param outTransform out matrix to store result
+     * @param parentBounds parent bounds
+     * @param childWidth child width
+     * @param childHeight child height
+     * @param focusX focus point x coordinate, relative [0...1]
+     * @param focusY focus point y coordinate, relative [0...1]
+     * @return same reference to the out matrix for convenience
+     */
+    Matrix getTransform(
+        Matrix outTransform,
+        Rect parentBounds,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY);
   }
 
   /**
@@ -96,7 +113,10 @@
    * @param focusY focus point y coordinate, relative [0...1]
    * @param scaleType scale type to be used
    * @return reference to the out matrix
+   *
+   * @deprecated use {@code ScaleType.getTransform}
    */
+  @Deprecated
   public static Matrix getTransform(
       final Matrix transform,
       final Rect parentBounds,
@@ -105,98 +125,306 @@ public static Matrix getTransform(
       final float focusX,
       final float focusY,
       final ScaleType scaleType) {
+    return scaleType.getTransform(transform, parentBounds, childWidth, childHeight, focusX, focusY);
+  }
+
+  /**
+   * A convenience base class that has some common logic.
+   */
+  public static abstract class AbstractScaleType implements ScaleType {
+
+    @Override
+    public Matrix getTransform(
+        Matrix outTransform,
+        Rect parentRect,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY) {
+      final float sX = (float) parentRect.width() / (float) childWidth;
+      final float sY = (float) parentRect.height() / (float) childHeight;
+      getTransformImpl(outTransform, parentRect, childWidth, childHeight, focusX, focusY, sX, sY);
+      return outTransform;
+    }
+
+    public abstract void getTransformImpl(
+        Matrix outTransform,
+        Rect parentRect,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY,
+        float scaleX,
+        float scaleY);
+  }
+
+  private static class ScaleTypeFitXY extends AbstractScaleType {
+    public static final ScaleType INSTANCE = new ScaleTypeFitXY();
+    @Override
+    public void getTransformImpl(
+        Matrix outTransform,
+        Rect parentRect,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY,
+        float scaleX,
+        float scaleY) {
+      float dx = parentRect.left;
+      float dy = parentRect.top;
+      outTransform.setScale(scaleX, scaleY);
+      outTransform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+    }
+  }
+
+  private static class ScaleTypeFitStart extends AbstractScaleType {
+    public static final ScaleType INSTANCE = new ScaleTypeFitStart();
+    @Override
+    public void getTransformImpl(
+        Matrix outTransform,
+        Rect parentRect,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY,
+        float scaleX,
+        float scaleY) {
+      float scale = Math.min(scaleX, scaleY);
+      float dx = parentRect.left;
+      float dy = parentRect.top;
+      outTransform.setScale(scale, scale);
+      outTransform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+    }
+  }
+
+  private static class ScaleTypeFitCenter extends AbstractScaleType {
+
+    public static final ScaleType INSTANCE = new ScaleTypeFitCenter();
+
+    @Override
+    public void getTransformImpl(
+        Matrix outTransform,
+        Rect parentRect,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY,
+        float scaleX,
+        float scaleY) {
+      float scale = Math.min(scaleX, scaleY);
+      float dx = parentRect.left + (parentRect.width() - childWidth * scale) * 0.5f;
+      float dy = parentRect.top + (parentRect.height() - childHeight * scale) * 0.5f;
+      outTransform.setScale(scale, scale);
+      outTransform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+    }
+  }
+
+  private static class ScaleTypeFitEnd extends AbstractScaleType {
+
+    public static final ScaleType INSTANCE = new ScaleTypeFitEnd();
+
+    @Override
+    public void getTransformImpl(
+        Matrix outTransform,
+        Rect parentRect,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY,
+        float scaleX,
+        float scaleY) {
+      float scale = Math.min(scaleX, scaleY);
+      float dx = parentRect.left + (parentRect.width() - childWidth * scale);
+      float dy = parentRect.top + (parentRect.height() - childHeight * scale);
+      outTransform.setScale(scale, scale);
+      outTransform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+    }
+  }
+
+  private static class ScaleTypeCenter extends AbstractScaleType {
+
+    public static final ScaleType INSTANCE = new ScaleTypeCenter();
+
+    @Override
+    public void getTransformImpl(
+        Matrix outTransform,
+        Rect parentRect,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY,
+        float scaleX,
+        float scaleY) {
+      float dx = parentRect.left + (parentRect.width() - childWidth) * 0.5f;
+      float dy = parentRect.top + (parentRect.height() - childHeight) * 0.5f;
+      outTransform.setTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+    }
+  }
+
+  private static class ScaleTypeCenterInside extends AbstractScaleType {
+
+    public static final ScaleType INSTANCE = new ScaleTypeCenterInside();
+
+    @Override
+    public void getTransformImpl(
+        Matrix outTransform,
+        Rect parentRect,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY,
+        float scaleX,
+        float scaleY) {
+      float scale = Math.min(Math.min(scaleX, scaleY), 1.0f);
+      float dx = parentRect.left + (parentRect.width() - childWidth * scale) * 0.5f;
+      float dy = parentRect.top + (parentRect.height() - childHeight * scale) * 0.5f;
+      outTransform.setScale(scale, scale);
+      outTransform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+    }
+  }
+
+  private static class ScaleTypeCenterCrop extends AbstractScaleType {
 
-    final int parentWidth = parentBounds.width();
-    final int parentHeight = parentBounds.height();
-
-    final float scaleX = (float) parentWidth / (float) childWidth;
-    final float scaleY = (float) parentHeight / (float) childHeight;
-
-    float scale = 1.0f;
-    float dx = 0;
-    float dy = 0;
-
-
-    switch (scaleType) {
-      case FIT_XY:
-        dx = parentBounds.left;
-        dy = parentBounds.top;
-        transform.setScale(scaleX, scaleY);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case FIT_START:
-        scale = Math.min(scaleX, scaleY);
-        dx = parentBounds.left;
-        dy = parentBounds.top;
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case FIT_CENTER:
-        scale = Math.min(scaleX, scaleY);
-        dx = parentBounds.left + (parentWidth - childWidth * scale) * 0.5f;
-        dy = parentBounds.top + (parentHeight - childHeight * scale) * 0.5f;
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case FIT_END:
-        scale = Math.min(scaleX, scaleY);
-        dx = parentBounds.left + (parentWidth - childWidth * scale);
-        dy = parentBounds.top + (parentHeight - childHeight * scale);
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case CENTER:
-        dx = parentBounds.left + (parentWidth - childWidth) * 0.5f;
-        dy = parentBounds.top + (parentHeight - childHeight) * 0.5f;
-        transform.setTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case CENTER_INSIDE:
-        scale = Math.min(Math.min(scaleX, scaleY), 1.0f);
-        dx = parentBounds.left + (parentWidth - childWidth * scale) * 0.5f;
-        dy = parentBounds.top + (parentHeight - childHeight * scale) * 0.5f;
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case CENTER_CROP:
-        if (scaleY > scaleX) {
-          scale = scaleY;
-          dx = parentBounds.left + (parentWidth - childWidth * scale) * 0.5f;
-          dy = parentBounds.top;
-        } else {
-          scale = scaleX;
-          dx = parentBounds.left;
-          dy = parentBounds.top + (parentHeight - childHeight * scale) * 0.5f;
-        }
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case FOCUS_CROP:
-        if (scaleY > scaleX) {
-          scale = scaleY;
-          dx = parentWidth * 0.5f - childWidth * scale * focusX;
-          dx = parentBounds.left + Math.max(Math.min(dx, 0), parentWidth - childWidth * scale);
-          dy = parentBounds.top;
-        } else {
-          scale = scaleX;
-          dx = parentBounds.left;
-          dy = parentHeight * 0.5f - childHeight * scale * focusY;
-          dy = parentBounds.top + Math.max(Math.min(dy, 0), parentHeight - childHeight * scale);
-        }
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      default:
-        throw new UnsupportedOperationException("Unsupported scale type: " + scaleType);
-    }
-
-    return transform;
+    public static final ScaleType INSTANCE = new ScaleTypeCenterCrop();
+
+    @Override
+    public void getTransformImpl(
+        Matrix outTransform,
+        Rect parentRect,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY,
+        float scaleX,
+        float scaleY) {
+      float scale, dx, dy;
+      if (scaleY > scaleX) {
+        scale = scaleY;
+        dx = parentRect.left + (parentRect.width() - childWidth * scale) * 0.5f;
+        dy = parentRect.top;
+      } else {
+        scale = scaleX;
+        dx = parentRect.left;
+        dy = parentRect.top + (parentRect.height() - childHeight * scale) * 0.5f;
+      }
+      outTransform.setScale(scale, scale);
+      outTransform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+    }
+  }
+
+  private static class ScaleTypeFocusCrop extends AbstractScaleType {
+
+    public static final ScaleType INSTANCE = new ScaleTypeFocusCrop();
+
+    @Override
+    public void getTransformImpl(
+        Matrix outTransform,
+        Rect parentRect,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY,
+        float scaleX,
+        float scaleY) {
+      float scale, dx, dy;
+      if (scaleY > scaleX) {
+        scale = scaleY;
+        dx = parentRect.width() * 0.5f - childWidth * scale * focusX;
+        dx = parentRect.left + Math.max(Math.min(dx, 0), parentRect.width() - childWidth * scale);
+        dy = parentRect.top;
+      } else {
+        scale = scaleX;
+        dx = parentRect.left;
+        dy = parentRect.height() * 0.5f - childHeight * scale * focusY;
+        dy = parentRect.top + Math.max(Math.min(dy, 0), parentRect.height() - childHeight * scale);
+      }
+      outTransform.setScale(scale, scale);
+      outTransform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+    }
+  }
+
+  /**
+   * Scaletypes that have some internal state and are not static.
+   */
+  public interface StatefulScaleType {
+
+    /**
+     * Returns the internal state. The returned object must be immutable!
+     *
+     * The returned state may be used for caching the result of {@code ScaleType.getTransform}.
+     * If null state is returned, the result will not be cached. If non-null state is returned,
+     * the old transformation may be used if produced with an equal state.
+     */
+    public Object getState();
+  }
+
+  /**
+   * Scale type that interpolates transform of the two underlying scale types.
+   */
+  public static class InterpolatingScaleType implements ScaleType, StatefulScaleType {
+
+    private final ScaleType mScaleTypeFrom;
+    private final ScaleType mScaleTypeTo;
+    private final float[] mMatrixValuesFrom = new float[9];
+    private final float[] mMatrixValuesTo = new float[9];
+    private final float[] mMatrixValuesInterpolated = new float[9];
+
+    private float mInterpolatingValue;
+
+    public InterpolatingScaleType(ScaleType scaleTypeFrom, ScaleType scaleTypeTo) {
+      mScaleTypeFrom = scaleTypeFrom;
+      mScaleTypeTo = scaleTypeTo;
+    }
+
+    public ScaleType getScaleTypeFrom() {
+      return mScaleTypeFrom;
+    }
+
+    public ScaleType getScaleTypeTo() {
+      return mScaleTypeTo;
+    }
+
+    /**
+     * Sets the interpolating value.
+     *
+     * Value of 0.0 will produce the transform same as ScaleTypeFrom.
+     * Value of 1.0 will produce the transform same as ScaleTypeTo.
+     * Inbetween values will produce a transform that is a linear combination between the two.
+     */
+    public void setValue(float value) {
+      mInterpolatingValue = value;
+    }
+
+    /**
+     * Gets the interpolating value.
+     */
+    public float getValue() {
+      return mInterpolatingValue;
+    }
+
+    @Override
+    public Object getState() {
+      return mInterpolatingValue;
+    }
+
+    @Override
+    public Matrix getTransform(
+        Matrix transform,
+        Rect parentBounds,
+        int childWidth,
+        int childHeight,
+        float focusX,
+        float focusY) {
+      mScaleTypeFrom.getTransform(transform, parentBounds, childWidth, childHeight, focusX, focusY);
+      transform.getValues(mMatrixValuesFrom);
+      mScaleTypeTo.getTransform(transform, parentBounds, childWidth, childHeight, focusX, focusY);
+      transform.getValues(mMatrixValuesTo);
+      for (int i = 0; i < 9; i++) {
+        mMatrixValuesInterpolated[i] = mMatrixValuesFrom[i] * (1 - mInterpolatingValue) +
+            mMatrixValuesTo[i] * mInterpolatingValue;
+      }
+      transform.setValues(mMatrixValuesInterpolated);
+      return transform;
+    }
   }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchy.java b/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchy.java
index 51407a880..3e2971123 100644
--- a/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchy.java
+++ b/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchy.java
@@ -235,7 +235,7 @@ private void fadeOutLayer(int index) {
   }
 
   private void setProgress(float progress) {
-    Drawable progressBarDrawable = getLayerParentDrawable(mProgressBarImageIndex).getDrawable();
+    Drawable progressBarDrawable = getParentDrawableAtIndex(mProgressBarImageIndex).getDrawable();
     if (progressBarDrawable == null) {
       return;
     }
@@ -333,7 +333,7 @@ public void setControllerOverlay(@Nullable Drawable drawable) {
    * whereas their children are created externally by the client code. When we need to change the
    * previously set drawable this is the parent whose child needs to be replaced.
    */
-  private DrawableParent getLayerParentDrawable(int index) {
+  private DrawableParent getParentDrawableAtIndex(int index) {
     DrawableParent parent = mFadeDrawable.getDrawableParentForIndex(index);
     if (parent.getDrawable() instanceof MatrixDrawable) {
       parent = (MatrixDrawable) parent.getDrawable();
@@ -345,16 +345,16 @@ private DrawableParent getLayerParentDrawable(int index) {
   }
 
   /**
-   * Sets the drawable at the specified index and keeps the old scale type.
+   * Sets the drawable at the specified index while keeping the old scale type and rounding.
    * In case the given drawable is null, scale type gets cleared too.
    */
-  private void setLayerChildDrawable(int index, @Nullable Drawable drawable) {
+  private void setChildDrawableAtIndex(int index, @Nullable Drawable drawable) {
     if (drawable == null) {
       mFadeDrawable.setDrawable(index, null);
       return;
     }
     drawable = WrappingUtils.maybeApplyLeafRounding(drawable, mRoundingParams, mResources);
-    getLayerParentDrawable(index).setDrawable(drawable);
+    getParentDrawableAtIndex(index).setDrawable(drawable);
   }
 
   /**
@@ -363,8 +363,8 @@ private void setLayerChildDrawable(int index, @Nullable Drawable drawable) {
    * In case there is a child, but the ScaleTypeDrawable does not exist,
    * the child will be wrapped with a new ScaleTypeDrawable.
    */
-  private ScaleTypeDrawable getLayerScaleTypeDrawable(int index) {
-    DrawableParent parent = getLayerParentDrawable(index);
+  private ScaleTypeDrawable getScaleTypeDrawableAtIndex(int index) {
+    DrawableParent parent = getParentDrawableAtIndex(index);
     if (parent instanceof ScaleTypeDrawable) {
       return (ScaleTypeDrawable) parent;
     } else {
@@ -372,6 +372,14 @@ private ScaleTypeDrawable getLayerScaleTypeDrawable(int index) {
     }
   }
 
+  /**
+   * Returns whether the given layer has a scale type drawable.
+   */
+  private boolean hasScaleTypeDrawableAtIndex(int index) {
+    DrawableParent parent = getParentDrawableAtIndex(index);
+    return (parent instanceof ScaleTypeDrawable);
+  }
+
   // Mutability
 
   /** Sets the fade duration. */
@@ -382,13 +390,20 @@ public void setFadeDuration(int durationMs) {
   /** Sets the actual image focus point. */
   public void setActualImageFocusPoint(PointF focusPoint) {
     Preconditions.checkNotNull(focusPoint);
-    getLayerScaleTypeDrawable(mActualImageIndex).setFocusPoint(focusPoint);
+    getScaleTypeDrawableAtIndex(mActualImageIndex).setFocusPoint(focusPoint);
   }
 
   /** Sets the actual image scale type. */
   public void setActualImageScaleType(ScaleType scaleType) {
     Preconditions.checkNotNull(scaleType);
-    getLayerScaleTypeDrawable(mActualImageIndex).setScaleType(scaleType);
+    getScaleTypeDrawableAtIndex(mActualImageIndex).setScaleType(scaleType);
+  }
+
+  public @Nullable ScaleType getActualImageScaleType() {
+    if (!hasScaleTypeDrawableAtIndex(mActualImageIndex)) {
+      return null;
+    }
+    return getScaleTypeDrawableAtIndex(mActualImageIndex).getScaleType();
   }
 
   /** Sets the color filter to be applied on the actual image. */
@@ -403,20 +418,20 @@ public void getActualImageBounds(RectF outBounds) {
 
   /** Sets a new placeholder drawable with old scale type. */
   public void setPlaceholderImage(@Nullable Drawable drawable) {
-    setLayerChildDrawable(mPlaceholderImageIndex, drawable);
+    setChildDrawableAtIndex(mPlaceholderImageIndex, drawable);
   }
 
   /** Sets a new placeholder drawable with scale type. */
   public void setPlaceholderImage(Drawable drawable, ScaleType scaleType) {
-    setLayerChildDrawable(mPlaceholderImageIndex, drawable);
-    getLayerScaleTypeDrawable(mPlaceholderImageIndex).setScaleType(scaleType);
+    setChildDrawableAtIndex(mPlaceholderImageIndex, drawable);
+    getScaleTypeDrawableAtIndex(mPlaceholderImageIndex).setScaleType(scaleType);
 
   }
 
   /** Sets the placeholder image focus point. */
   public void setPlaceholderImageFocusPoint(PointF focusPoint) {
     Preconditions.checkNotNull(focusPoint);
-    getLayerScaleTypeDrawable(mPlaceholderImageIndex).setFocusPoint(focusPoint);
+    getScaleTypeDrawableAtIndex(mPlaceholderImageIndex).setFocusPoint(focusPoint);
   }
 
   /**
@@ -430,35 +445,35 @@ public void setPlaceholderImage(int resourceId) {
 
   /** Sets a new failure drawable with old scale type. */
   public void setFailureImage(@Nullable Drawable drawable) {
-    setLayerChildDrawable(mFailureImageIndex, drawable);
+    setChildDrawableAtIndex(mFailureImageIndex, drawable);
   }
 
   /** Sets a new failure drawable with scale type. */
   public void setFailureImage(Drawable drawable, ScaleType scaleType) {
-    setLayerChildDrawable(mFailureImageIndex, drawable);
-    getLayerScaleTypeDrawable(mFailureImageIndex).setScaleType(scaleType);
+    setChildDrawableAtIndex(mFailureImageIndex, drawable);
+    getScaleTypeDrawableAtIndex(mFailureImageIndex).setScaleType(scaleType);
   }
 
   /** Sets a new retry drawable with old scale type. */
   public void setRetryImage(@Nullable Drawable drawable) {
-    setLayerChildDrawable(mRetryImageIndex, drawable);
+    setChildDrawableAtIndex(mRetryImageIndex, drawable);
   }
 
   /** Sets a new retry drawable with scale type. */
   public void setRetryImage(Drawable drawable, ScaleType scaleType) {
-    setLayerChildDrawable(mRetryImageIndex, drawable);
-    getLayerScaleTypeDrawable(mRetryImageIndex).setScaleType(scaleType);
+    setChildDrawableAtIndex(mRetryImageIndex, drawable);
+    getScaleTypeDrawableAtIndex(mRetryImageIndex).setScaleType(scaleType);
   }
 
   /** Sets a new progress bar drawable with old scale type. */
   public void setProgressBarImage(@Nullable Drawable drawable) {
-    setLayerChildDrawable(mProgressBarImageIndex, drawable);
+    setChildDrawableAtIndex(mProgressBarImageIndex, drawable);
   }
 
   /** Sets a new progress bar drawable with scale type. */
   public void setProgressBarImage(Drawable drawable, ScaleType scaleType) {
-    setLayerChildDrawable(mProgressBarImageIndex, drawable);
-    getLayerScaleTypeDrawable(mProgressBarImageIndex).setScaleType(scaleType);
+    setChildDrawableAtIndex(mProgressBarImageIndex, drawable);
+    getScaleTypeDrawableAtIndex(mProgressBarImageIndex).setScaleType(scaleType);
   }
 
   /** Sets the rounding params. */
@@ -466,7 +481,7 @@ public void setRoundingParams(RoundingParams roundingParams) {
     mRoundingParams = roundingParams;
     WrappingUtils.updateOverlayColorRounding(mTopLevelDrawable, mRoundingParams);
     for (int i = 0; i < mFadeDrawable.getNumberOfLayers(); i++) {
-      WrappingUtils.updateLeafRounding(getLayerParentDrawable(i), mRoundingParams, mResources);
+      WrappingUtils.updateLeafRounding(getParentDrawableAtIndex(i), mRoundingParams, mResources);
     }
   }
 
diff --git a/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilder.java b/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilder.java
index 7fefe09d3..6a475b4a9 100644
--- a/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilder.java
+++ b/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilder.java
@@ -28,8 +28,11 @@
 /**
  * Class to construct a {@link GenericDraweeHierarchy}.
  *
- * <p/> This class does not do deep copies of most of the input parameters. There should be one
- * instance of the hierarchy per DraweeView, so that each hierarchy has a unique set of drawables.
+ * <p/> Drawables must not be reused by multiple hierarchies. Each hierarchy needs to have its own
+ * drawable instances. Since this builder does not do deep copies of the input parameters, it is
+ * the caller's responsibility to pass a different drawable instances for each hierarchy built.
+ * Likewise, hierarchies must not be reused by multiple views. Each view needs to have its own
+ * instance of a hierarchy. The caller is responsible for building a new hierarchy for each view.
  */
 public class GenericDraweeHierarchyBuilder {
 
@@ -41,6 +44,8 @@
 
   private int mFadeDuration;
 
+  private float mDesiredAspectRatio;
+
   private Drawable mPlaceholderImage;
   private @Nullable ScaleType mPlaceholderImageScaleType;
 
@@ -79,33 +84,35 @@ public static GenericDraweeHierarchyBuilder newInstance(Resources resources) {
   private void init() {
     mFadeDuration = DEFAULT_FADE_DURATION;
 
+    mDesiredAspectRatio = 0;
+
     mPlaceholderImage = null;
-    mPlaceholderImageScaleType = null;
+    mPlaceholderImageScaleType = DEFAULT_SCALE_TYPE;
 
     mRetryImage = null;
-    mRetryImageScaleType = null;
+    mRetryImageScaleType = DEFAULT_SCALE_TYPE;
 
     mFailureImage = null;
-    mFailureImageScaleType = null;
+    mFailureImageScaleType = DEFAULT_SCALE_TYPE;
 
     mProgressBarImage = null;
-    mProgressBarImageScaleType = null;
+    mProgressBarImageScaleType = DEFAULT_SCALE_TYPE;
 
     mActualImageScaleType = DEFAULT_ACTUAL_IMAGE_SCALE_TYPE;
     mActualImageMatrix = null;
     mActualImageFocusPoint = null;
+    mActualImageColorFilter = null;
 
     mBackgrounds = null;
     mOverlays = null;
     mPressedStateOverlay = null;
 
     mRoundingParams = null;
-
-    mActualImageColorFilter = null;
   }
 
   /**
    * Resets this builder to its initial values making it reusable.
+   *
    * @return modified instance of this builder
    */
   public GenericDraweeHierarchyBuilder reset() {
@@ -115,7 +122,8 @@ public GenericDraweeHierarchyBuilder reset() {
 
   /**
    * Gets resources.
-   * @return
+   *
+   * @return resources
    */
   public Resources getResources() {
     return mResources;
@@ -123,7 +131,9 @@ public Resources getResources() {
 
   /**
    * Sets the duration of the fade animation.
-   * If not set, default value of 300ms will be used.
+   *
+   * If not set, the default value of 300ms will be used.
+   *
    * @param fadeDuration duration in milliseconds
    * @return modified instance of this builder
    */
@@ -132,23 +142,76 @@ public GenericDraweeHierarchyBuilder setFadeDuration(int fadeDuration) {
     return this;
   }
 
+  /**
+   * Gets the duration of the fade animation.
+   */
   public int getFadeDuration() {
     return mFadeDuration;
   }
 
   /**
-   * Sets the placeholder image, with default scale type CENTER_INSIDE. If no placeholder is set,
-   * a transparent ColorDrawable will be used.
+   * Sets the desired aspect ratio.
+   *
+   * Note, the hierarchy itself cannot enforce the aspect ratio.
+   * This is merely a suggestion to the view if it supports it.
+   *
+   * @param desiredAspectRatio the desired aspect ratio
+   * @return modified instance of this builder
+   */
+  public GenericDraweeHierarchyBuilder setDesiredAspectRatio(float desiredAspectRatio) {
+    mDesiredAspectRatio = desiredAspectRatio;
+    return this;
+  }
+
+  /**
+   * Gets the desired aspect ratio.
+   */
+  public float getDesiredAspectRatio() {
+    return mDesiredAspectRatio;
+  }
+
+  /**
+   * Sets the placeholder image.
+   *
    * @param placeholderDrawable drawable to be used as placeholder image
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setPlaceholderImage(Drawable placeholderDrawable) {
-    return setPlaceholderImage(placeholderDrawable, DEFAULT_SCALE_TYPE);
+  public GenericDraweeHierarchyBuilder setPlaceholderImage(@Nullable Drawable placeholderDrawable) {
+    mPlaceholderImage = placeholderDrawable;
+    return this;
+  }
+
+  /**
+   * Gets the placeholder image.
+   */
+  public @Nullable Drawable getPlaceholderImage() {
+    return mPlaceholderImage;
+  }
+
+  /**
+   * Sets the placeholder image scale type.
+   *
+   * If not set, the default value CENTER_INSIDE will be used.
+   *
+   * @param placeholderImageScaleType scale type for the placeholder image
+   * @return modified instance of this builder
+   */
+  public GenericDraweeHierarchyBuilder setPlaceholderImageScaleType(
+      @Nullable ScaleType placeholderImageScaleType) {
+    mPlaceholderImageScaleType = placeholderImageScaleType;
+    return this;
+  }
+
+  /**
+   * Gets the placeholder image scale type.
+   */
+  public @Nullable ScaleType getPlaceholderImageScaleType() {
+    return mPlaceholderImageScaleType;
   }
 
   /**
-   * Sets the placeholder image and scale type. If no placeholder is set, a transparent
-   * ColorDrawable will be used.
+   * Sets the placeholder image and its scale type.
+   *
    * @param placeholderDrawable drawable to be used as placeholder image
    * @param placeholderImageScaleType scale type for the placeholder image
    * @return modified instance of this builder
@@ -161,253 +224,364 @@ public GenericDraweeHierarchyBuilder setPlaceholderImage(
     return this;
   }
 
-  public Drawable getPlaceholderImage() {
-    return mPlaceholderImage;
+  /**
+   * Sets the retry image.
+   *
+   * @param retryDrawable drawable to be used as retry image
+   * @return modified instance of this builder
+   */
+  public GenericDraweeHierarchyBuilder setRetryImage(@Nullable Drawable retryDrawable) {
+    mRetryImage = retryDrawable;
+    return this;
   }
 
-  public @Nullable ScaleType getPlaceholderImageScaleType() {
-    return mPlaceholderImageScaleType;
+  /**
+   * Gets the retry image.
+   */
+  public @Nullable Drawable getRetryImage() {
+    return mRetryImage;
   }
 
   /**
-   * Sets the retry image, with default scale type CENTER_INSIDE.
-   * @param retryDrawable drawable to be used as retry image
+   * Sets the retry image scale type.
+   *
+   * If not set, the default value CENTER_INSIDE will be used.
+   *
+   * @param retryImageScaleType scale type for the retry image
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setRetryImage(Drawable retryDrawable) {
-    return setRetryImage(retryDrawable, DEFAULT_SCALE_TYPE);
+  public GenericDraweeHierarchyBuilder setRetryImageScaleType(
+      @Nullable ScaleType retryImageScaleType) {
+    mRetryImageScaleType = retryImageScaleType;
+    return this;
+  }
+
+  /**
+   * Gets the retry image scale type.
+   */
+  public @Nullable ScaleType getRetryImageScaleType() {
+    return mRetryImageScaleType;
   }
 
   /**
-   * Sets the retry image and scale type.
+   * Sets the retry image and its scale type.
+   *
    * @param retryDrawable drawable to be used as retry image
    * @param retryImageScaleType scale type for the retry image
    * @return modified instance of this builder
    */
   public GenericDraweeHierarchyBuilder setRetryImage(
       Drawable retryDrawable,
-      ScaleType retryImageScaleType) {
+      @Nullable ScaleType retryImageScaleType) {
     mRetryImage = retryDrawable;
     mRetryImageScaleType = retryImageScaleType;
     return this;
   }
 
-  public Drawable getRetryImage() {
-    return mRetryImage;
+  /**
+   * Sets the failure image.
+   *
+   * @param failureDrawable drawable to be used as failure image
+   * @return modified instance of this builder
+   */
+  public GenericDraweeHierarchyBuilder setFailureImage(@Nullable Drawable failureDrawable) {
+    mFailureImage = failureDrawable;
+    return this;
   }
 
-  public ScaleType getRetryImageScaleType() {
-    return mRetryImageScaleType;
+  /**
+   * Gets the failure image.
+   */
+  public @Nullable Drawable getFailureImage() {
+    return mFailureImage;
   }
 
   /**
-   * Sets the failure image, with default scale type CENTER_INSIDE.
-   * @param failureDrawable drawable to be used as failure image
+   * Sets the failure image scale type.
+   *
+   * If not set, the default value CENTER_INSIDE will be used.
+   *
+   * @param failureImageScaleType scale type for the failure image
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setFailureImage(Drawable failureDrawable) {
-    return setFailureImage(failureDrawable, DEFAULT_SCALE_TYPE);
+  public GenericDraweeHierarchyBuilder setFailureImageScaleType(
+      @Nullable ScaleType failureImageScaleType) {
+    mFailureImageScaleType = failureImageScaleType;
+    return this;
+  }
+
+  /**
+   * Gets the failure image scale type.
+   */
+  public @Nullable ScaleType getFailureImageScaleType() {
+    return mFailureImageScaleType;
   }
 
   /**
-   * Sets the failure image, and scale type.
+   * Sets the failure image and its scale type.
+   *
    * @param failureDrawable drawable to be used as failure image
    * @param failureImageScaleType scale type for the failure image
    * @return modified instance of this builder
    */
   public GenericDraweeHierarchyBuilder setFailureImage(
       Drawable failureDrawable,
-      ScaleType failureImageScaleType) {
+      @Nullable ScaleType failureImageScaleType) {
     mFailureImage = failureDrawable;
     mFailureImageScaleType = failureImageScaleType;
     return this;
   }
 
-  public Drawable getFailureImage() {
-    return mFailureImage;
-  }
-
-  public ScaleType getFailureImageScaleType() {
-    return mFailureImageScaleType;
+  /**
+   * Sets the progress bar image.
+   *
+   * @param progressBarDrawable drawable to be used as progress bar image
+   * @return modified instance of this builder
+   */
+  public GenericDraweeHierarchyBuilder setProgressBarImage(@Nullable Drawable progressBarDrawable) {
+    mProgressBarImage = progressBarDrawable;
+    return this;
   }
 
   /**
-   * Sets the progressBar image, with default scale type CENTER_INSIDE.
-   * @param progressBarImage drawable to be used as progressBar image
-   * @return modified instance of this builder
+   * Gets the progress bar image.
    */
-  public GenericDraweeHierarchyBuilder setProgressBarImage(Drawable progressBarImage) {
-    return setProgressBarImage(progressBarImage, DEFAULT_SCALE_TYPE);
+  public @Nullable Drawable getProgressBarImage() {
+    return mProgressBarImage;
   }
 
   /**
-   * Sets the progressBar image, and scale type.
-   * @param progressBarImage drawable to be used as progressBar image
-   * @param progressBarImageScaleType scale type for the progressBar image
+   * Sets the progress bar image scale type.
+   *
+   * If not set, the default value CENTER_INSIDE will be used.
+   *
+   * @param progressBarImageScaleType scale type for the progress bar image
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setProgressBarImage(
-      Drawable progressBarImage,
-      ScaleType progressBarImageScaleType) {
-    mProgressBarImage = progressBarImage;
+  public GenericDraweeHierarchyBuilder setProgressBarImageScaleType(
+      @Nullable ScaleType progressBarImageScaleType) {
     mProgressBarImageScaleType = progressBarImageScaleType;
     return this;
   }
 
-  public Drawable getProgressBarImage() {
-    return mProgressBarImage;
+  /**
+   * Gets the progress bar image scale type.
+   */
+  public @Nullable ScaleType getProgressBarImageScaleType() {
+    return mProgressBarImageScaleType;
   }
 
-  public ScaleType getProgressBarImageScaleType() {
-    return mProgressBarImageScaleType;
+  /**
+   * Sets the progress bar image and its scale type.
+   *
+   * @param progressBarDrawable drawable to be used as progress bar image
+   * @param progressBarImageScaleType scale type for the progress bar image
+   * @return modified instance of this builder
+   */
+  public GenericDraweeHierarchyBuilder setProgressBarImage(
+      Drawable progressBarDrawable,
+      @Nullable ScaleType progressBarImageScaleType) {
+    mProgressBarImage = progressBarDrawable;
+    mProgressBarImageScaleType = progressBarImageScaleType;
+    return this;
   }
 
   /**
-   * Sets the scale type, and removes the transformation matrix, for the actual image. If scale
-   * type is not set, and nor is a transformation matrix, then the actual image will be drawn
-   * with scale type CENTER_CROP.
+   * Sets the scale type for the actual image.
+   *
+   * If not set, the default value CENTER_CROP will be used.
+   *
    * @param actualImageScaleType scale type for the actual image
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setActualImageScaleType(ScaleType actualImageScaleType) {
+  public GenericDraweeHierarchyBuilder setActualImageScaleType(
+      @Nullable ScaleType actualImageScaleType) {
     mActualImageScaleType = actualImageScaleType;
     mActualImageMatrix = null;
     return this;
   }
 
-  public ScaleType getActualImageScaleType() {
+  /**
+   * Gets the scale type for the actual image.
+   */
+  public @Nullable ScaleType getActualImageScaleType() {
     return mActualImageScaleType;
   }
 
   /**
-   * Sets the transformation matrix, and removes the scale type, for the actual image. If matrix
-   * is not set, then the image will be drawn without a matrix being applied to it.
+   * Sets the transformation matrix, and removes the scale type, for the actual image.
+   *
    * @param actualImageMatrix matrix for the actual image
    * @return modified instance of this builder
-   * @deprecated this is likely not something you want
+   *
+   * @deprecated implement and set a custom {@link ScaleType} instead.
    */
   @Deprecated
-  public GenericDraweeHierarchyBuilder setActualImageMatrix(Matrix actualImageMatrix) {
+  public GenericDraweeHierarchyBuilder setActualImageMatrix(@Nullable Matrix actualImageMatrix) {
     mActualImageMatrix = actualImageMatrix;
     mActualImageScaleType = null;
     return this;
   }
 
-  public Matrix getActualImageMatrix() {
+  /**
+   * Gets the matrix for the actual image.
+   */
+  public @Nullable Matrix getActualImageMatrix() {
     return mActualImageMatrix;
   }
 
   /**
    * Sets the focus point for the actual image.
-   * If scale type FOCUS_CROP is used, focus point will attempted to be centered within a view.
-   * Each coordinate is a real number in [0,1] range, in the coordinate system where top-left
+   *
+   * If a focus point aware scale type is used (e.g. FOCUS_CROP), the focus point of the image
+   * will be attempted to be centered within a view.
+   * Each coordinate is a real number in [0, 1] range, in the coordinate system where top-left
    * corner of the image corresponds to (0, 0) and the bottom-right corner corresponds to (1, 1).
+   *
    * @param focusPoint focus point of the image
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setActualImageFocusPoint(PointF focusPoint) {
+  public GenericDraweeHierarchyBuilder setActualImageFocusPoint(@Nullable PointF focusPoint) {
     mActualImageFocusPoint = focusPoint;
     return this;
   }
 
-  public PointF getActualImageFocusPoint() {
+  /**
+   * Gets the focus point for the actual image.
+   */
+  public @Nullable PointF getActualImageFocusPoint() {
     return mActualImageFocusPoint;
   }
 
   /**
-   * Sets the color filter.
+   * Sets the color filter for the actual image.
    *
    * @param colorFilter color filter to be set
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setActualImageColorFilter(ColorFilter colorFilter) {
+  public GenericDraweeHierarchyBuilder setActualImageColorFilter(@Nullable ColorFilter colorFilter) {
     mActualImageColorFilter = colorFilter;
     return this;
   }
 
-  public ColorFilter getActualImageColorFilter() {
+  /**
+   * Gets the color filter for the actual image.
+   */
+  public @Nullable ColorFilter getActualImageColorFilter() {
     return mActualImageColorFilter;
   }
 
   /**
    * Sets the backgrounds.
+   *
    * Backgrounds are drawn in list order before the rest of the hierarchy and overlays. The
    * first background will be drawn at the bottom.
+   *
    * @param backgrounds background drawables
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setBackgrounds(List<Drawable> backgrounds) {
+  public GenericDraweeHierarchyBuilder setBackgrounds(@Nullable List<Drawable> backgrounds) {
     mBackgrounds = backgrounds;
     return this;
   }
 
   /**
    * Sets a single background.
+   *
    * @param background background drawable
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setBackground(Drawable background) {
-    mBackgrounds = Arrays.asList(background);
+  public GenericDraweeHierarchyBuilder setBackground(@Nullable Drawable background) {
+    if (background == null) {
+      mBackgrounds = null;
+    } else {
+      mBackgrounds = Arrays.asList(background);
+    }
     return this;
   }
 
-  public List<Drawable> getBackgrounds() {
+  /**
+   * Gets the backgrounds.
+   */
+  public @Nullable List<Drawable> getBackgrounds() {
     return mBackgrounds;
   }
 
   /**
    * Sets the overlays.
+   *
    * Overlays are drawn in list order after the backgrounds and the rest of the hierarchy. The
    * last overlay will be drawn at the top.
+   *
    * @param overlays overlay drawables
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setOverlays(List<Drawable> overlays) {
+  public GenericDraweeHierarchyBuilder setOverlays(@Nullable List<Drawable> overlays) {
     mOverlays = overlays;
     return this;
   }
 
   /**
    * Sets a single overlay.
+   *
    * @param overlay overlay drawable
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setOverlay(Drawable overlay) {
-    mOverlays = Arrays.asList(overlay);
+  public GenericDraweeHierarchyBuilder setOverlay(@Nullable Drawable overlay) {
+    if (overlay == null) {
+      mOverlays = null;
+    } else {
+      mOverlays = Arrays.asList(overlay);
+    }
     return this;
   }
 
-  public List<Drawable> getOverlays() {
+  /**
+   * Gets the overlays.
+   */
+  public @Nullable List<Drawable> getOverlays() {
     return mOverlays;
   }
 
   /**
-   * Sets Overlay for pressed state
+   * Sets the overlay for pressed state.
+   *
    * @param drawable for pressed state
    * @return
    */
-  public GenericDraweeHierarchyBuilder setPressedStateOverlay(Drawable drawable) {
-    StateListDrawable stateListDrawable = new StateListDrawable();
-    stateListDrawable.addState(new int[]{android.R.attr.state_pressed}, drawable);
-    mPressedStateOverlay = stateListDrawable;
+  public GenericDraweeHierarchyBuilder setPressedStateOverlay(@Nullable Drawable drawable) {
+    if (drawable == null) {
+      mPressedStateOverlay = null;
+    } else {
+      StateListDrawable stateListDrawable = new StateListDrawable();
+      stateListDrawable.addState(new int[]{android.R.attr.state_pressed}, drawable);
+      mPressedStateOverlay = stateListDrawable;
+    }
     return this;
   }
 
-  public Drawable getPressedStateOverlay() {
+  /**
+   * Gets the overlay for pressed state.
+   */
+  public @Nullable Drawable getPressedStateOverlay() {
     return mPressedStateOverlay;
   }
 
   /**
-   * Sets rounding params.
+   * Sets the rounding params.
    *
    * @param roundingParams rounding params to be set
    * @return modified instance of this builder
    */
-  public GenericDraweeHierarchyBuilder setRoundingParams(RoundingParams roundingParams) {
+  public GenericDraweeHierarchyBuilder setRoundingParams(@Nullable RoundingParams roundingParams) {
     mRoundingParams = roundingParams;
     return this;
   }
 
+  /**
+   * Gets the rounding params.
+   */
+  @Nullable
   public RoundingParams getRoundingParams() {
     return mRoundingParams;
   }
@@ -426,6 +600,9 @@ private void validate() {
     }
   }
 
+  /**
+   * Builds the hierarchy.
+   */
   public GenericDraweeHierarchy build() {
     validate();
     return new GenericDraweeHierarchy(this);
diff --git a/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyInflater.java b/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyInflater.java
new file mode 100644
index 000000000..c8b5fdf43
--- /dev/null
+++ b/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyInflater.java
@@ -0,0 +1,262 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.drawee.generic;
+
+import javax.annotation.Nullable;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.drawable.Drawable;
+import android.util.AttributeSet;
+
+import com.facebook.drawee.R;
+import com.facebook.drawee.drawable.AutoRotateDrawable;
+import static com.facebook.drawee.drawable.ScalingUtils.ScaleType;
+
+/**
+ * Inflater for the {@code GenericDraweeHierarchy}.
+ *
+ * Fading animation parameters:
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_fadeDuration
+ * Aspect ratio parameters:
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_viewAspectRatio
+ * Images & scale types parameters:
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_placeholderImage
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_placeholderImageScaleType
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_retryImage
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_retryImageScaleType
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_failureImage
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_failureImageScaleType
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_progressBarImage
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_progressBarImageScaleType
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_progressBarAutoRotateInterval
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_actualImageScaleType
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_backgroundImage
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_overlayImage
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_pressedStateOverlayImage
+ * Rounding parameters:
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_roundAsCircle
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_roundedCornerRadius
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_roundTopLeft
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_roundTopRight
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_roundBottomRight
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_roundBottomLeft
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_roundWithOverlayColor
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_roundingBorderWidth
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_roundingBorderColor
+ * @attr ref com.facebook.R.styleable#GenericDraweeHierarchy_roundingBorderPadding
+ */
+public class GenericDraweeHierarchyInflater {
+
+  /**
+   * Inflates a new hierarchy from XML.
+   */
+  public static GenericDraweeHierarchy inflateHierarchy(
+      Context context,
+      @Nullable AttributeSet attrs) {
+    return inflateBuilder(context, attrs).build();
+  }
+
+  /**
+   * Inflates a new hierarchy builder from XML.
+   * The builder can then be modified in order to override XML attributes if necessary.
+   */
+  public static GenericDraweeHierarchyBuilder inflateBuilder(
+      Context context,
+      @Nullable AttributeSet attrs) {
+    Resources resources = context.getResources();
+    GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(resources);
+    return updateBuilder(builder, context, attrs);
+  }
+
+  /**
+   * Updates the existing hierarchy builder based on the XML attributes.
+   *
+   * This method is useful if a custom view uses different default values. In that case a
+   * builder with adjusted default values can be passed to this method and only the properties
+   * explicitly specified in XML will be overridden.
+   * The builder can be modified afterwards in case some XML attributes needs to be overridden.
+   *
+   * @param builder a hierarchy builder to be updated
+   * @return the modified instance of the same builder
+   */
+  public static GenericDraweeHierarchyBuilder updateBuilder(
+      GenericDraweeHierarchyBuilder builder,
+      Context context,
+      @Nullable AttributeSet attrs) {
+    // these paramters cannot be applied immediately so we store them first
+    int progressBarAutoRotateInterval = 0;
+    int roundedCornerRadius = 0;
+    boolean roundTopLeft = true;
+    boolean roundTopRight = true;
+    boolean roundBottomLeft = true;
+    boolean roundBottomRight = true;
+
+    if (attrs != null) {
+      TypedArray gdhAttrs = context.obtainStyledAttributes(
+        attrs,
+        R.styleable.GenericDraweeHierarchy);
+      try {
+        final int indexCount = gdhAttrs.getIndexCount();
+        for (int i = 0; i < indexCount; i++) {
+          final int attr = gdhAttrs.getIndex(i);
+          // most popular ones first
+          if (attr == R.styleable.GenericDraweeHierarchy_actualImageScaleType) {
+            builder.setActualImageScaleType(getScaleTypeFromXml(gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_placeholderImage) {
+            builder.setPlaceholderImage(getDrawable(context, gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_pressedStateOverlayImage) {
+            builder.setPressedStateOverlay(getDrawable(context, gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_progressBarImage) {
+            builder.setProgressBarImage(getDrawable(context, gdhAttrs, attr));
+
+          // the remaining ones without any particular order
+          } else if (attr == R.styleable.GenericDraweeHierarchy_fadeDuration) {
+            builder.setFadeDuration(gdhAttrs.getInt(attr, 0));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_viewAspectRatio) {
+            builder.setDesiredAspectRatio(gdhAttrs.getFloat(attr, 0));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_placeholderImageScaleType) {
+            builder.setPlaceholderImageScaleType(getScaleTypeFromXml(gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_retryImage) {
+            builder.setRetryImage(getDrawable(context, gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_retryImageScaleType) {
+            builder.setRetryImageScaleType(getScaleTypeFromXml(gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_failureImage) {
+            builder.setFailureImage(getDrawable(context, gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_failureImageScaleType) {
+            builder.setFailureImageScaleType(getScaleTypeFromXml(gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_progressBarImageScaleType) {
+            builder.setProgressBarImageScaleType(getScaleTypeFromXml(gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_progressBarAutoRotateInterval) {
+            progressBarAutoRotateInterval =
+                gdhAttrs.getInteger(attr, progressBarAutoRotateInterval);
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_backgroundImage) {
+            builder.setBackground(getDrawable(context, gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_overlayImage) {
+            builder.setOverlay(getDrawable(context, gdhAttrs, attr));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_roundAsCircle) {
+            getRoundingParams(builder).setRoundAsCircle(gdhAttrs.getBoolean(attr, false));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_roundedCornerRadius) {
+            roundedCornerRadius = gdhAttrs.getDimensionPixelSize(attr, roundedCornerRadius);
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_roundTopLeft) {
+            roundTopLeft = gdhAttrs.getBoolean(attr, roundTopLeft);
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_roundTopRight) {
+            roundTopRight = gdhAttrs.getBoolean(attr, roundTopRight);
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_roundBottomLeft) {
+            roundBottomLeft = gdhAttrs.getBoolean(attr, roundBottomLeft);
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_roundBottomRight) {
+            roundBottomRight = gdhAttrs.getBoolean(attr, roundBottomRight);
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_roundWithOverlayColor) {
+            getRoundingParams(builder).setOverlayColor(gdhAttrs.getColor(attr, 0));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_roundingBorderWidth) {
+            getRoundingParams(builder).setBorderWidth(gdhAttrs.getDimensionPixelSize(attr, 0));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_roundingBorderColor) {
+            getRoundingParams(builder).setBorderColor(gdhAttrs.getColor(attr, 0));
+
+          } else if (attr == R.styleable.GenericDraweeHierarchy_roundingBorderPadding) {
+            getRoundingParams(builder).setPadding(gdhAttrs.getDimensionPixelSize(attr, 0));
+
+          }
+        }
+      } finally {
+        gdhAttrs.recycle();
+      }
+    }
+
+    // wrap progress bar if auto-rotating requested
+    if (builder.getProgressBarImage() != null && progressBarAutoRotateInterval > 0) {
+      builder.setProgressBarImage(
+        new AutoRotateDrawable(builder.getProgressBarImage(), progressBarAutoRotateInterval));
+    }
+
+    // set rounded corner radii if requested
+    if (roundedCornerRadius > 0) {
+      getRoundingParams(builder).setCornersRadii(
+        roundTopLeft ? roundedCornerRadius : 0,
+        roundTopRight ? roundedCornerRadius : 0,
+        roundBottomRight ? roundedCornerRadius : 0,
+        roundBottomLeft ? roundedCornerRadius : 0);
+    }
+    
+    return builder;
+  }
+
+  private static RoundingParams getRoundingParams(GenericDraweeHierarchyBuilder builder) {
+    if (builder.getRoundingParams() == null) {
+      builder.setRoundingParams(new RoundingParams());
+    }
+    return builder.getRoundingParams();
+  }
+
+  @Nullable
+  private static Drawable getDrawable(
+      Context context,
+      TypedArray gdhAttrs,
+      int attrId) {
+    int resourceId = gdhAttrs.getResourceId(attrId, 0);
+    return (resourceId == 0) ? null : context.getResources().getDrawable(resourceId);
+  }
+
+  /**
+   * Returns the scale type indicated in XML, or null if the special 'none' value was found.
+   * Important: these values need to be in sync with GenericDraweeHierarchy styleable attributes.
+   */
+  @Nullable
+  private static ScaleType getScaleTypeFromXml(
+      TypedArray gdhAttrs,
+      int attrId) {
+    switch (gdhAttrs.getInt(attrId, -2)) {
+      case -1: // none
+        return null;
+      case 0: // fitXY
+        return ScaleType.FIT_XY;
+      case 1: // fitStart
+        return ScaleType.FIT_START;
+      case 2: // fitCenter
+        return ScaleType.FIT_CENTER;
+      case 3: // fitEnd
+        return ScaleType.FIT_END;
+      case 4: // center
+        return ScaleType.CENTER;
+      case 5: // centerInside
+        return ScaleType.CENTER_INSIDE;
+      case 6: // centerCrop
+        return ScaleType.CENTER_CROP;
+      case 7: // focusCrop
+        return ScaleType.FOCUS_CROP;
+      default:
+        // this method is supposed to be called only when XML attribute is specified.
+        throw new RuntimeException("XML attribute not specified!");
+    }
+  }
+}
diff --git a/drawee/src/main/java/com/facebook/drawee/generic/RoundingParams.java b/drawee/src/main/java/com/facebook/drawee/generic/RoundingParams.java
index 2356c4a39..2f5286272 100644
--- a/drawee/src/main/java/com/facebook/drawee/generic/RoundingParams.java
+++ b/drawee/src/main/java/com/facebook/drawee/generic/RoundingParams.java
@@ -14,6 +14,7 @@
 import android.graphics.Color;
 
 import com.facebook.common.internal.Preconditions;
+import com.facebook.drawee.drawable.ScalingUtils;
 
 /**
  * Class that encapsulates rounding parameters.
@@ -29,10 +30,10 @@
     OVERLAY_COLOR,
 
     /**
-     * Uses BitmapShader to draw bitmap with rounded corners. Works only with BitmapDrawables and
-     * ColorDrawables.
-     * IMPORTANT: Only the actual image and the placeholder image will get rounded. Other images
-     * (such as retry, failure, progress bar, backgrounds, overlays, etc.) won't get rounded.
+     * Uses BitmapShader to draw the bitmap with rounded corners. This is the default rounding
+     * method. It doesn't support animations, and it does not support any scale types other than
+     * {@link ScalingUtils.ScaleType#CENTER_CROP}, {@link ScalingUtils.ScaleType#FOCUS_CROP} and
+     * {@link ScalingUtils.ScaleType#FIT_XY}.
      */
     BITMAP_ONLY
   }
@@ -182,6 +183,37 @@ public static RoundingParams fromCornersRadii(float[] radii) {
     return (new RoundingParams()).setCornersRadii(radii);
   }
 
+  /**
+   * Sets the border width
+   * @param color of the border
+   * @param width of the width
+   */
+  public RoundingParams setBorderWidth(float width) {
+    Preconditions.checkArgument(width >= 0, "the border width cannot be < 0");
+    mBorderWidth = width;
+    return this;
+  }
+
+  /** Gets the border width */
+  public float getBorderWidth() {
+    return mBorderWidth;
+  }
+
+  /**
+   * Sets the border color
+   * @param color of the border
+   * @param width of the width
+   */
+  public RoundingParams setBorderColor(int color) {
+    mBorderColor = color;
+    return this;
+  }
+
+  /** Gets the border color */
+  public int getBorderColor() {
+    return mBorderColor;
+  }
+
   /**
    * Sets the border around the rounded drawable
    * @param color of the border
@@ -204,16 +236,6 @@ public RoundingParams setPadding(float padding){
     return this;
   }
 
-  /** Gets the border width */
-  public float getBorderWidth() {
-    return mBorderWidth;
-  }
-
-  /** Gets the border color */
-  public int getBorderColor() {
-    return mBorderColor;
-  }
-
   /** Gets the padding size */
   public float getPadding() {
     return mPadding;
diff --git a/drawee/src/main/java/com/facebook/drawee/view/DraweeHolder.java b/drawee/src/main/java/com/facebook/drawee/view/DraweeHolder.java
index a944b0a46..65ce7c969 100644
--- a/drawee/src/main/java/com/facebook/drawee/view/DraweeHolder.java
+++ b/drawee/src/main/java/com/facebook/drawee/view/DraweeHolder.java
@@ -15,8 +15,6 @@
 import android.view.MotionEvent;
 import android.view.View;
 
-import com.facebook.common.activitylistener.ActivityListener;
-import com.facebook.common.activitylistener.BaseActivityListener;
 import com.facebook.common.activitylistener.ListenableActivity;
 import com.facebook.common.internal.Objects;
 import com.facebook.common.internal.Preconditions;
@@ -55,8 +53,11 @@
   private boolean mIsVisible = true;
   private boolean mIsActivityStarted = true;
   private DH mHierarchy;
+  // TODO(T6181423): this is not working reliably and we cannot afford photos-not-loading issues.
+  //private final ActivityListener mActivityListener;
+
   private DraweeController mController = null;
-  private final ActivityListener mActivityListener;
+
   private final DraweeEventTracker mEventTracker = new DraweeEventTracker();
 
   /**
@@ -92,6 +93,8 @@ public DraweeHolder(@Nullable DH hierarchy) {
     if (hierarchy != null) {
       setHierarchy(hierarchy);
     }
+    /*
+    // TODO(T6181423): this is not working reliably and we cannot afford photos-not-loading issues.
     mActivityListener = new BaseActivityListener() {
       @Override
       public void onStart(Activity activity) {
@@ -103,6 +106,7 @@ public void onStop(Activity activity) {
         setActivityStarted(false);
       }
     };
+    */
   }
 
   /**
@@ -237,7 +241,8 @@ public void setHierarchy(DH hierarchy) {
     mEventTracker.recordEvent(Event.ON_SET_HIERARCHY);
     setVisibilityCallback(null);
     mHierarchy = Preconditions.checkNotNull(hierarchy);
-    onVisibilityChange(mHierarchy.getTopLevelDrawable().isVisible());
+    Drawable drawable = mHierarchy.getTopLevelDrawable();
+    onVisibilityChange(drawable == null || drawable.isVisible());
     setVisibilityCallback(this);
     if (mController != null) {
       mController.setHierarchy(hierarchy);
@@ -265,6 +270,10 @@ public Drawable getTopLevelDrawable() {
     return mHierarchy == null ? null : mHierarchy.getTopLevelDrawable();
   }
 
+  protected DraweeEventTracker getDraweeEventTracker() {
+    return mEventTracker;
+  }
+
   private void attachController() {
     if (mIsControllerAttached) {
       return;
diff --git a/drawee/src/main/java/com/facebook/drawee/view/DraweeView.java b/drawee/src/main/java/com/facebook/drawee/view/DraweeView.java
index 8b9425181..9d4766c55 100644
--- a/drawee/src/main/java/com/facebook/drawee/view/DraweeView.java
+++ b/drawee/src/main/java/com/facebook/drawee/view/DraweeView.java
@@ -39,7 +39,7 @@
  * support ImageView's setImageXxx, setScaleType and similar methods. Extending ImageView is a short
  * term solution in order to inherit some of its implementation (padding calculations, etc.).
  * This class is likely to be converted to extend View directly in the future, so avoid using
- * ImageView's methods and properties (T5856175).
+ * ImageView's methods and properties.
  */
 public class DraweeView<DH extends DraweeHierarchy> extends ImageView {
 
diff --git a/drawee/src/main/java/com/facebook/drawee/view/GenericDraweeView.java b/drawee/src/main/java/com/facebook/drawee/view/GenericDraweeView.java
index 6696650e2..7e7f7b3a2 100644
--- a/drawee/src/main/java/com/facebook/drawee/view/GenericDraweeView.java
+++ b/drawee/src/main/java/com/facebook/drawee/view/GenericDraweeView.java
@@ -13,50 +13,18 @@
 
 import android.annotation.TargetApi;
 import android.content.Context;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.util.AttributeSet;
 
-import com.facebook.drawee.R;
-import com.facebook.drawee.drawable.AutoRotateDrawable;
-import com.facebook.drawee.drawable.ScalingUtils;
 import com.facebook.drawee.generic.GenericDraweeHierarchy;
 import com.facebook.drawee.generic.GenericDraweeHierarchyBuilder;
-import com.facebook.drawee.generic.RoundingParams;
+import com.facebook.drawee.generic.GenericDraweeHierarchyInflater;
 
 /**
- * DraweeView that creates GenericDraweeHierarchy based on XML attributes.
+ * DraweeView that uses GenericDraweeHierarchy.
  *
- * Fading animation parameters:
- * @attr ref com.facebook.R.styleable#GenericDraweeView_fadeDuration
- * Images & scale types parameters:
- * @attr ref com.facebook.R.styleable#GenericDraweeView_viewAspectRatio
- * @attr ref com.facebook.R.styleable#GenericDraweeView_placeholderImage
- * @attr ref com.facebook.R.styleable#GenericDraweeView_placeholderImageScaleType
- * @attr ref com.facebook.R.styleable#GenericDraweeView_retryImage
- * @attr ref com.facebook.R.styleable#GenericDraweeView_retryImageScaleType
- * @attr ref com.facebook.R.styleable#GenericDraweeView_failureImage
- * @attr ref com.facebook.R.styleable#GenericDraweeView_failureImageScaleType
- * @attr ref com.facebook.R.styleable#GenericDraweeView_progressBarImage
- * @attr ref com.facebook.R.styleable#GenericDraweeView_progressBarImageScaleType
- * @attr ref com.facebook.R.styleable#GenericDraweeView_progressBarAutoRotateInterval
- * @attr ref com.facebook.R.styleable#GenericDraweeView_actualImageScaleType
- * @attr ref com.facebook.R.styleable#GenericDraweeView_backgroundImage
- * @attr ref com.facebook.R.styleable#GenericDraweeView_overlayImage
- * @attr ref com.facebook.R.styleable#GenericDraweeView_pressedStateOverlayImage
- * Rounding parameters:
- * @attr ref com.facebook.R.styleable#GenericDraweeView_roundAsCircle
- * @attr ref com.facebook.R.styleable#GenericDraweeView_roundedCornerRadius
- * @attr ref com.facebook.R.styleable#GenericDraweeView_roundTopLeft
- * @attr ref com.facebook.R.styleable#GenericDraweeView_roundTopRight
- * @attr ref com.facebook.R.styleable#GenericDraweeView_roundBottomRight
- * @attr ref com.facebook.R.styleable#GenericDraweeView_roundBottomLeft
- * @attr ref com.facebook.R.styleable#GenericDraweeView_roundWithOverlayColor
- * @attr ref com.facebook.R.styleable#GenericDraweeView_roundingBorderWidth
- * @attr ref com.facebook.R.styleable#GenericDraweeView_roundingBorderColor
- * @attr ref com.facebook.R.styleable#GenericDraweeView_roundingBorderPadding
+ * The hierarchy can be set either programmatically or inflated from XML.
+ * See {@link GenericDraweeHierarchyInflater} for supported XML attributes.
  */
 public class GenericDraweeView extends DraweeView<GenericDraweeHierarchy> {
 
@@ -86,274 +54,10 @@ public GenericDraweeView(Context context, AttributeSet attrs, int defStyleAttr,
     inflateHierarchy(context, attrs);
   }
 
-  private void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {
-    Resources resources = context.getResources();
-
-    // fading animation defaults
-    int fadeDuration = GenericDraweeHierarchyBuilder.DEFAULT_FADE_DURATION;
-    // images & scale types defaults
-    int placeholderId = 0;
-    ScalingUtils.ScaleType placeholderScaleType
-        = GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
-    int retryImageId = 0;
-    ScalingUtils.ScaleType retryImageScaleType =
-        GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
-    int failureImageId = 0;
-    ScalingUtils.ScaleType failureImageScaleType =
-        GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
-    int progressBarId = 0;
-    ScalingUtils.ScaleType progressBarScaleType =
-        GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
-    ScalingUtils.ScaleType actualImageScaleType =
-        GenericDraweeHierarchyBuilder.DEFAULT_ACTUAL_IMAGE_SCALE_TYPE;
-    int backgroundId = 0;
-    int overlayId = 0;
-    int pressedStateOverlayId = 0;
-    // rounding defaults
-    boolean roundAsCircle = false;
-    int roundedCornerRadius = 0;
-    boolean roundTopLeft = true;
-    boolean roundTopRight = true;
-    boolean roundBottomRight = true;
-    boolean roundBottomLeft = true;
-    int roundWithOverlayColor = 0;
-    int roundingBorderWidth = 0;
-    int roundingBorderColor = 0;
-    int roundingBorderPadding = 0;
-    int progressBarAutoRotateInterval = 0;
-
-
-    if (attrs != null) {
-      TypedArray gdhAttrs = context.obtainStyledAttributes(
-          attrs,
-          R.styleable.GenericDraweeView);
-
-      try {
-        final int indexCount = gdhAttrs.getIndexCount();
-
-        for (int i = 0; i < indexCount; i++) {
-          final int idx = gdhAttrs.getIndex(i);
-
-          // most popular ones first
-          if (idx == R.styleable.GenericDraweeView_actualImageScaleType) {
-            // actual image scale type
-            actualImageScaleType = getScaleTypeFromXml(
-                gdhAttrs,
-                R.styleable.GenericDraweeView_actualImageScaleType,
-                actualImageScaleType);
-
-          } else if (idx == R.styleable.GenericDraweeView_placeholderImage) {
-            // placeholder image
-            placeholderId = gdhAttrs.getResourceId(
-                R.styleable.GenericDraweeView_placeholderImage,
-                placeholderId);
-
-          } else if (idx == R.styleable.GenericDraweeView_pressedStateOverlayImage) {
-            // pressedState overlay
-            pressedStateOverlayId = gdhAttrs.getResourceId(
-                R.styleable.GenericDraweeView_pressedStateOverlayImage,
-                pressedStateOverlayId);
-
-          } else if (idx == R.styleable.GenericDraweeView_progressBarImage) {
-            // progress bar image
-            progressBarId = gdhAttrs.getResourceId(
-                R.styleable.GenericDraweeView_progressBarImage,
-                progressBarId);
-
-          // the remaining ones without any particular order
-          } else if (idx == R.styleable.GenericDraweeView_fadeDuration) {
-            // fade duration
-            fadeDuration = gdhAttrs.getInt(
-                R.styleable.GenericDraweeView_fadeDuration,
-                fadeDuration);
-
-          } else if (idx == R.styleable.GenericDraweeView_viewAspectRatio) {
-            // aspect ratio
-            setAspectRatio(gdhAttrs.getFloat(
-                R.styleable.GenericDraweeView_viewAspectRatio,
-                getAspectRatio()));
-
-          } else if (idx == R.styleable.GenericDraweeView_placeholderImageScaleType) {
-            // placeholder image scale type
-            placeholderScaleType = getScaleTypeFromXml(
-                gdhAttrs,
-                R.styleable.GenericDraweeView_placeholderImageScaleType,
-                placeholderScaleType);
-
-          } else if (idx == R.styleable.GenericDraweeView_retryImage) {
-            // retry image
-            retryImageId = gdhAttrs.getResourceId(
-                R.styleable.GenericDraweeView_retryImage,
-                retryImageId);
-
-          } else if (idx == R.styleable.GenericDraweeView_retryImageScaleType) {
-            // retry image scale type
-            retryImageScaleType = getScaleTypeFromXml(
-                gdhAttrs,
-                R.styleable.GenericDraweeView_retryImageScaleType,
-                retryImageScaleType);
-
-          } else if (idx == R.styleable.GenericDraweeView_failureImage) {
-            // failure image
-            failureImageId = gdhAttrs.getResourceId(
-                R.styleable.GenericDraweeView_failureImage,
-                failureImageId);
-
-          } else if (idx == R.styleable.GenericDraweeView_failureImageScaleType) {
-            // failure image scale type
-            failureImageScaleType = getScaleTypeFromXml(
-                gdhAttrs,
-                R.styleable.GenericDraweeView_failureImageScaleType,
-                failureImageScaleType);
-
-          } else if (idx == R.styleable.GenericDraweeView_progressBarImageScaleType) {
-            // progress bar image scale type
-            progressBarScaleType = getScaleTypeFromXml(
-                gdhAttrs,
-                R.styleable.GenericDraweeView_progressBarImageScaleType,
-                progressBarScaleType);
-
-          } else if (idx == R.styleable.GenericDraweeView_progressBarAutoRotateInterval) {
-            // progress bar auto rotate interval
-            progressBarAutoRotateInterval = gdhAttrs.getInteger(
-                R.styleable.GenericDraweeView_progressBarAutoRotateInterval,
-                0);
-
-          } else if (idx == R.styleable.GenericDraweeView_backgroundImage) {
-            // background
-            backgroundId = gdhAttrs.getResourceId(
-                R.styleable.GenericDraweeView_backgroundImage,
-                backgroundId);
-
-          } else if (idx == R.styleable.GenericDraweeView_overlayImage) {
-            // overlay
-            overlayId = gdhAttrs.getResourceId(
-                R.styleable.GenericDraweeView_overlayImage,
-                overlayId);
-
-          } else if (idx == R.styleable.GenericDraweeView_roundAsCircle) {
-            // rounding parameters
-            roundAsCircle = gdhAttrs.getBoolean(
-                R.styleable.GenericDraweeView_roundAsCircle,
-                roundAsCircle);
-
-          } else if (idx == R.styleable.GenericDraweeView_roundedCornerRadius) {
-            roundedCornerRadius = gdhAttrs.getDimensionPixelSize(
-                R.styleable.GenericDraweeView_roundedCornerRadius,
-                roundedCornerRadius);
-
-          } else if (idx == R.styleable.GenericDraweeView_roundTopLeft) {
-            roundTopLeft = gdhAttrs.getBoolean(
-                R.styleable.GenericDraweeView_roundTopLeft,
-                roundTopLeft);
-
-          } else if (idx == R.styleable.GenericDraweeView_roundTopRight) {
-            roundTopRight = gdhAttrs.getBoolean(
-                R.styleable.GenericDraweeView_roundTopRight,
-                roundTopRight);
-
-          } else if (idx == R.styleable.GenericDraweeView_roundBottomRight) {
-            roundBottomRight = gdhAttrs.getBoolean(
-                R.styleable.GenericDraweeView_roundBottomRight,
-                roundBottomRight);
-
-          } else if (idx == R.styleable.GenericDraweeView_roundBottomLeft) {
-            roundBottomLeft = gdhAttrs.getBoolean(
-                R.styleable.GenericDraweeView_roundBottomLeft,
-                roundBottomLeft);
-
-          } else if (idx == R.styleable.GenericDraweeView_roundWithOverlayColor) {
-            roundWithOverlayColor = gdhAttrs.getColor(
-                R.styleable.GenericDraweeView_roundWithOverlayColor,
-                roundWithOverlayColor);
-
-          } else if (idx == R.styleable.GenericDraweeView_roundingBorderWidth) {
-            roundingBorderWidth = gdhAttrs.getDimensionPixelSize(
-                R.styleable.GenericDraweeView_roundingBorderWidth,
-                roundingBorderWidth);
-
-          } else if (idx == R.styleable.GenericDraweeView_roundingBorderColor) {
-            roundingBorderColor = gdhAttrs.getColor(
-                R.styleable.GenericDraweeView_roundingBorderColor,
-                roundingBorderColor);
-
-          } else if (idx == R.styleable.GenericDraweeView_roundingBorderPadding) {
-            roundingBorderPadding = gdhAttrs.getDimensionPixelSize(
-                R.styleable.GenericDraweeView_roundingBorderPadding,
-                roundingBorderPadding);
-
-          }
-        }
-      } finally {
-        gdhAttrs.recycle();
-      }
-    }
-
-    GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(resources);
-    // set fade duration
-    builder.setFadeDuration(fadeDuration);
-    // set images & scale types
-    if (placeholderId > 0) {
-      builder.setPlaceholderImage(resources.getDrawable(placeholderId), placeholderScaleType);
-    }
-    if (retryImageId > 0) {
-      builder.setRetryImage(resources.getDrawable(retryImageId), retryImageScaleType);
-    }
-    if (failureImageId > 0) {
-      builder.setFailureImage(resources.getDrawable(failureImageId), failureImageScaleType);
-    }
-    if (progressBarId > 0) {
-      Drawable progressBarDrawable = resources.getDrawable(progressBarId);
-      if (progressBarAutoRotateInterval > 0) {
-        progressBarDrawable =
-            new AutoRotateDrawable(progressBarDrawable, progressBarAutoRotateInterval);
-      }
-      builder.setProgressBarImage(progressBarDrawable, progressBarScaleType);
-    }
-    if (backgroundId > 0) {
-      builder.setBackground(resources.getDrawable(backgroundId));
-    }
-    if (overlayId > 0) {
-      builder.setOverlay(resources.getDrawable(overlayId));
-    }
-    if (pressedStateOverlayId > 0) {
-      builder.setPressedStateOverlay(getResources().getDrawable(pressedStateOverlayId));
-    }
-
-    builder.setActualImageScaleType(actualImageScaleType);
-    // set rounding parameters
-    if (roundAsCircle || roundedCornerRadius > 0) {
-      RoundingParams roundingParams = new RoundingParams();
-      roundingParams.setRoundAsCircle(roundAsCircle);
-      if (roundedCornerRadius > 0) {
-        roundingParams.setCornersRadii(
-            roundTopLeft ? roundedCornerRadius : 0,
-            roundTopRight ? roundedCornerRadius : 0,
-            roundBottomRight ? roundedCornerRadius : 0,
-            roundBottomLeft ? roundedCornerRadius : 0);
-      }
-      if (roundWithOverlayColor != 0) {
-        roundingParams.setOverlayColor(roundWithOverlayColor);
-      }
-      if (roundingBorderColor != 0 && roundingBorderWidth > 0) {
-        roundingParams.setBorder(roundingBorderColor, roundingBorderWidth);
-      }
-      if (roundingBorderPadding != 0) {
-        roundingParams.setPadding(roundingBorderPadding);
-      }
-      builder.setRoundingParams(roundingParams);
-    }
+  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {
+    GenericDraweeHierarchyBuilder builder =
+        GenericDraweeHierarchyInflater.inflateBuilder(context, attrs);
+    setAspectRatio(builder.getDesiredAspectRatio());
     setHierarchy(builder.build());
   }
-
-  /**
-   * Returns the scale type indicated in XML, or null if the special 'none' value was found.
-   */
-  private static ScalingUtils.ScaleType getScaleTypeFromXml(
-      TypedArray attrs,
-      int attrId,
-      ScalingUtils.ScaleType defaultScaleType) {
-    int index = attrs.getInt(attrId, -1);
-    return index < 0 ? defaultScaleType : ScalingUtils.ScaleType.values()[index];
-  }
 }
diff --git a/drawee/src/main/res/values/attrs.xml b/drawee/src/main/res/values/attrs.xml
index f0a526858..35ac03135 100644
--- a/drawee/src/main/res/values/attrs.xml
+++ b/drawee/src/main/res/values/attrs.xml
@@ -1,18 +1,19 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-  <declare-styleable name="GenericDraweeView">
+  <declare-styleable name="GenericDraweeHierarchy">
 
     <!-- Fade duration in milliseconds. -->
     <attr name="fadeDuration" format="integer"/>
 
-    <!-- Images -
-    Scale types must match values in ScaleType.fromString (ScalingUtils.java).
-    For drawables that should not be scaled, such as those with the android:tileMode
-    attribute set, use the value 'none'. -->
-
     <!-- Aspect ratio (width / height) of the view, not necessarily of the images. -->
     <attr name="viewAspectRatio" format="float"/>
 
+    <!-- Image branches -
+    Scale-type values must match those in GenericDraweeHierarchyInflater.getScaleTypeFromXml.
+    (GenericDraweeHierarchyInflater.java).
+    For drawables that should not be scaled, such as those with the android:tileMode
+    attribute set, use the value 'none'. -->
+
     <!-- A drawable or color to be be used as a placeholder. -->
     <attr name="placeholderImage" format="reference"/>
     <!-- Scale type of the placeholder image. Ignored if placeholderImage is not specified. -->
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/ScaleTypeDrawableTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/ScaleTypeDrawableTest.java
index eb414fb5f..5aed309ad 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/ScaleTypeDrawableTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/ScaleTypeDrawableTest.java
@@ -69,10 +69,14 @@ public void testBasics() {
 
   @Test
   public void testConfigureBounds_NoIntrinsicDimensions() {
-    for (ScaleType scaleType : ScaleType.values()) {
-      System.out.println("testConfigureBounds_NoIntrinsicDimensions: " + scaleType);
-      testConfigureBounds_NoIntrinsicDimensions(scaleType, mViewBounds);
-    }
+    testConfigureBounds_NoIntrinsicDimensions(ScaleType.FIT_XY, mViewBounds);
+    testConfigureBounds_NoIntrinsicDimensions(ScaleType.FIT_START, mViewBounds);
+    testConfigureBounds_NoIntrinsicDimensions(ScaleType.FIT_CENTER, mViewBounds);
+    testConfigureBounds_NoIntrinsicDimensions(ScaleType.FIT_END, mViewBounds);
+    testConfigureBounds_NoIntrinsicDimensions(ScaleType.CENTER, mViewBounds);
+    testConfigureBounds_NoIntrinsicDimensions(ScaleType.CENTER_INSIDE, mViewBounds);
+    testConfigureBounds_NoIntrinsicDimensions(ScaleType.CENTER_CROP, mViewBounds);
+    testConfigureBounds_NoIntrinsicDimensions(ScaleType.FOCUS_CROP, mViewBounds);
   }
 
   private void testConfigureBounds_NoIntrinsicDimensions(ScaleType scaleType, Rect viewBounds) {
@@ -91,10 +95,14 @@ private void testConfigureBounds_NoIntrinsicDimensions(ScaleType scaleType, Rect
 
   @Test
   public void testConfigureBounds_SameAsView() {
-    for (ScaleType scaleType : ScaleType.values()) {
-      System.out.println("testConfigureBounds_SameAsView: " + scaleType);
-      testConfigureBounds_SameAsView(scaleType, mViewBounds);
-    }
+    testConfigureBounds_SameAsView(ScaleType.FIT_XY, mViewBounds);
+    testConfigureBounds_SameAsView(ScaleType.FIT_START, mViewBounds);
+    testConfigureBounds_SameAsView(ScaleType.FIT_CENTER, mViewBounds);
+    testConfigureBounds_SameAsView(ScaleType.FIT_END, mViewBounds);
+    testConfigureBounds_SameAsView(ScaleType.CENTER, mViewBounds);
+    testConfigureBounds_SameAsView(ScaleType.CENTER_INSIDE, mViewBounds);
+    testConfigureBounds_SameAsView(ScaleType.CENTER_CROP, mViewBounds);
+    testConfigureBounds_SameAsView(ScaleType.FOCUS_CROP, mViewBounds);
   }
 
   private void testConfigureBounds_SameAsView(ScaleType scaleType, Rect viewBounds) {
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/ScalingUtilsTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/ScalingUtilsTest.java
index 8a167c24a..bff47af8c 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/ScalingUtilsTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/ScalingUtilsTest.java
@@ -218,14 +218,13 @@ private void test(
     }
 
     mActualMatrix.reset();
-    ScalingUtils.getTransform(
+    scaleType.getTransform(
         mActualMatrix,
         mParentBounds,
         childWidth,
         childHeight,
         focusX,
-        focusY,
-        scaleType);
+        focusY);
 
     AndroidGraphicsTestUtils.assertEquals(mExpectedMatrix, mActualMatrix);
   }
diff --git a/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilderTest.java b/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilderTest.java
index e088c2918..371f8ff48 100644
--- a/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilderTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilderTest.java
@@ -27,6 +27,8 @@
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.mock;
 
+import static com.facebook.drawee.drawable.ScalingUtils.ScaleType;
+
 @RunWith(RobolectricTestRunner.class)
 public class GenericDraweeHierarchyBuilderTest {
 
@@ -49,15 +51,16 @@
 
   private void testInitialState(GenericDraweeHierarchyBuilder builder) {
     assertEquals(300, builder.getFadeDuration());
+    assertEquals(0, builder.getDesiredAspectRatio(), 0);
     assertEquals(null, builder.getPlaceholderImage());
-    assertEquals(null, builder.getPlaceholderImageScaleType());
+    assertEquals(ScaleType.CENTER_INSIDE, builder.getPlaceholderImageScaleType());
     assertEquals(null, builder.getRetryImage());
-    assertEquals(null, builder.getRetryImageScaleType());
+    assertEquals(ScaleType.CENTER_INSIDE, builder.getRetryImageScaleType());
     assertEquals(null, builder.getFailureImage());
-    assertEquals(null, builder.getFailureImageScaleType());
+    assertEquals(ScaleType.CENTER_INSIDE, builder.getFailureImageScaleType());
     assertEquals(null, builder.getProgressBarImage());
-    assertEquals(null, builder.getProgressBarImageScaleType());
-    assertEquals(ScalingUtils.ScaleType.CENTER_CROP, builder.getActualImageScaleType());
+    assertEquals(ScaleType.CENTER_INSIDE, builder.getProgressBarImageScaleType());
+    assertEquals(ScaleType.CENTER_CROP, builder.getActualImageScaleType());
     assertEquals(null, builder.getActualImageMatrix());
     assertEquals(null, builder.getActualImageFocusPoint());
     assertEquals(null, builder.getBackgrounds());
@@ -76,33 +79,51 @@ public void testBuilder() throws Exception {
     builder.setFadeDuration(100);
     assertEquals(100, builder.getFadeDuration());
 
-    // test image setters with default scale type
+    // test desired aspect ratio
+    builder.setDesiredAspectRatio(1.33f);
+    assertEquals(1.33f, builder.getDesiredAspectRatio(), 0);
+
+    // test image setters without modifying scale type (default expected)
     builder.setPlaceholderImage(mPlaceholderDrawable1);
     builder.setRetryImage(mRetryDrawable1);
     builder.setFailureImage(mFailureDrawable1);
     builder.setProgressBarImage(mProgressBarDrawable1);
     assertEquals(mPlaceholderDrawable1, builder.getPlaceholderImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getPlaceholderImageScaleType());
+    assertEquals(ScaleType.CENTER_INSIDE, builder.getPlaceholderImageScaleType());
     assertEquals(mRetryDrawable1, builder.getRetryImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getRetryImageScaleType());
+    assertEquals(ScaleType.CENTER_INSIDE, builder.getRetryImageScaleType());
     assertEquals(mFailureDrawable1, builder.getFailureImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getFailureImageScaleType());
+    assertEquals(ScaleType.CENTER_INSIDE, builder.getFailureImageScaleType());
     assertEquals(mProgressBarDrawable1, builder.getProgressBarImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getProgressBarImageScaleType());
+    assertEquals(ScaleType.CENTER_INSIDE, builder.getProgressBarImageScaleType());
 
     // test image setters with explicit scale type
-    builder.setPlaceholderImage(mPlaceholderDrawable2, ScalingUtils.ScaleType.CENTER);
-    builder.setRetryImage(mRetryDrawable2, ScalingUtils.ScaleType.FIT_CENTER);
-    builder.setFailureImage(mFailureDrawable2, ScalingUtils.ScaleType.FIT_END);
-    builder.setProgressBarImage(mProgressBarDrawable2, ScalingUtils.ScaleType.CENTER_CROP);
+    builder.setPlaceholderImage(mPlaceholderDrawable2, ScaleType.CENTER);
+    builder.setRetryImage(mRetryDrawable2, ScaleType.FIT_CENTER);
+    builder.setFailureImage(mFailureDrawable2, ScaleType.FIT_END);
+    builder.setProgressBarImage(mProgressBarDrawable2, ScaleType.CENTER_CROP);
     assertEquals(mPlaceholderDrawable2, builder.getPlaceholderImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER, builder.getPlaceholderImageScaleType());
+    assertEquals(ScaleType.CENTER, builder.getPlaceholderImageScaleType());
     assertEquals(mRetryDrawable2, builder.getRetryImage());
-    assertEquals(ScalingUtils.ScaleType.FIT_CENTER, builder.getRetryImageScaleType());
+    assertEquals(ScaleType.FIT_CENTER, builder.getRetryImageScaleType());
     assertEquals(mFailureDrawable2, builder.getFailureImage());
-    assertEquals(ScalingUtils.ScaleType.FIT_END, builder.getFailureImageScaleType());
+    assertEquals(ScaleType.FIT_END, builder.getFailureImageScaleType());
     assertEquals(mProgressBarDrawable2, builder.getProgressBarImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER_CROP, builder.getProgressBarImageScaleType());
+    assertEquals(ScaleType.CENTER_CROP, builder.getProgressBarImageScaleType());
+
+    // test image setters without modifying scale type (previous scaletype expected)
+    builder.setPlaceholderImage(mPlaceholderDrawable1);
+    builder.setRetryImage(mRetryDrawable1);
+    builder.setFailureImage(mFailureDrawable1);
+    builder.setProgressBarImage(mProgressBarDrawable1);
+    assertEquals(mPlaceholderDrawable1, builder.getPlaceholderImage());
+    assertEquals(ScaleType.CENTER, builder.getPlaceholderImageScaleType());
+    assertEquals(mRetryDrawable1, builder.getRetryImage());
+    assertEquals(ScaleType.FIT_CENTER, builder.getRetryImageScaleType());
+    assertEquals(mFailureDrawable1, builder.getFailureImage());
+    assertEquals(ScaleType.FIT_END, builder.getFailureImageScaleType());
+    assertEquals(mProgressBarDrawable1, builder.getProgressBarImage());
+    assertEquals(ScaleType.CENTER_CROP, builder.getProgressBarImageScaleType());
 
     // test actual image matrix
     builder.setActualImageMatrix(mActualImageMatrix);
@@ -110,14 +131,14 @@ public void testBuilder() throws Exception {
     assertSame(null, builder.getActualImageScaleType());
 
     // test actual image scale type
-    builder.setActualImageScaleType(ScalingUtils.ScaleType.FIT_START);
-    assertEquals(ScalingUtils.ScaleType.FIT_START, builder.getActualImageScaleType());
+    builder.setActualImageScaleType(ScaleType.FIT_START);
+    assertEquals(ScaleType.FIT_START, builder.getActualImageScaleType());
 
     // test actual image focus point
     builder.setActualImageFocusPoint(mFocusPoint);
     AndroidGraphicsTestUtils.assertEquals(mFocusPoint, builder.getActualImageFocusPoint(), 0f);
-    builder.setActualImageScaleType(ScalingUtils.ScaleType.FOCUS_CROP);
-    assertSame(ScalingUtils.ScaleType.FOCUS_CROP, builder.getActualImageScaleType());
+    builder.setActualImageScaleType(ScaleType.FOCUS_CROP);
+    assertSame(ScaleType.FOCUS_CROP, builder.getActualImageScaleType());
     assertSame(null, builder.getActualImageMatrix());
 
     // test backgrounds & overlays
@@ -135,6 +156,13 @@ public void testBuilder() throws Exception {
     assertArrayEquals(builder.getBackgrounds().toArray(), new Drawable[]{mBackgroundDrawable2});
     assertArrayEquals(builder.getOverlays().toArray(), new Drawable[] {mOverlayDrawable2});
     assertEquals(builder.getPressedStateOverlay().getClass(), StateListDrawable.class);
+    // test clearing backgrounds & overlays
+    builder.setBackground(null);
+    assertNull(builder.getBackgrounds());
+    builder.setOverlay(null);
+    assertNull(builder.getOverlays());
+    builder.setPressedStateOverlay(null);
+    assertNull(builder.getPressedStateOverlay());
 
     // test rounding params
     builder.setRoundingParams(mRoundingParams);
diff --git a/fbcore/build.gradle b/fbcore/build.gradle
index fcac62447..412216e84 100644
--- a/fbcore/build.gradle
+++ b/fbcore/build.gradle
@@ -8,7 +8,7 @@ dependencies {
     provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
 
-    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    testCompile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
     testCompile "org.easytesting:fest-assert-core:${FEST_ASSERT_CORE_VERSION}"
     testCompile "org.mockito:mockito-core:${MOCKITO_CORE_VERSION}"
@@ -38,6 +38,14 @@ android {
       exclude 'META-INF/NOTICE'
       exclude 'META-INF/NOTICE.txt'
     }
+
+    sourceSets {
+        test {
+            resources {
+                exclude '**/BUCK'
+            }
+        }
+    }
 }
 
 task sourcesJar(type: Jar) {
diff --git a/fbcore/src/main/gen/com/facebook/fbcore/BuildConfig.java b/fbcore/src/main/gen/com/facebook/fbcore/BuildConfig.java
new file mode 100644
index 000000000..ddd86b953
--- /dev/null
+++ b/fbcore/src/main/gen/com/facebook/fbcore/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.fbcore;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/fbcore/src/main/gen/com/facebook/fbcore/Manifest.java b/fbcore/src/main/gen/com/facebook/fbcore/Manifest.java
new file mode 100644
index 000000000..1b6e065bd
--- /dev/null
+++ b/fbcore/src/main/gen/com/facebook/fbcore/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.fbcore;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/fbcore/src/main/gen/com/facebook/fbcore/R.java b/fbcore/src/main/gen/com/facebook/fbcore/R.java
new file mode 100644
index 000000000..52ea0f9f3
--- /dev/null
+++ b/fbcore/src/main/gen/com/facebook/fbcore/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.fbcore;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/fbcore/src/main/java/com/facebook/common/statfs/StatFsHelper.java b/fbcore/src/main/java/com/facebook/common/statfs/StatFsHelper.java
index 579542fb8..573b024cf 100644
--- a/fbcore/src/main/java/com/facebook/common/statfs/StatFsHelper.java
+++ b/fbcore/src/main/java/com/facebook/common/statfs/StatFsHelper.java
@@ -18,6 +18,8 @@
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
+import android.annotation.SuppressLint;
+import android.os.Build;
 import android.os.Environment;
 import android.os.StatFs;
 import android.os.SystemClock;
@@ -122,6 +124,7 @@ public boolean testLowDiskSpace(StorageType storageType, long freeSpaceThreshold
    * @param storageType Internal or external storage type
    * @return available space in bytes, 0 if no information is available
    */
+  @SuppressLint("DeprecatedMethod")
   public long getAvailableStorageSpace(StorageType storageType) {
     ensureInitialized();
 
@@ -129,8 +132,14 @@ public long getAvailableStorageSpace(StorageType storageType) {
 
     StatFs statFS = storageType == StorageType.INTERNAL ? mInternalStatFs : mExternalStatFs;
     if (statFS != null) {
-      long blockSize = statFS.getBlockSize();
-      long availableBlocks = statFS.getAvailableBlocks();
+      long blockSize, availableBlocks;
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+        blockSize = statFS.getBlockSizeLong();
+        availableBlocks = statFS.getAvailableBlocksLong();
+      } else {
+        blockSize = statFS.getBlockSize();
+        availableBlocks = statFS.getAvailableBlocks();
+      }
       return blockSize * availableBlocks;
     }
     return 0;
@@ -147,7 +156,7 @@ private void maybeUpdateStats() {
     // with a frequency of once in RESTAT_INTERVAL_MS
     if (lock.tryLock()) {
       try {
-        if ((SystemClock.elapsedRealtime() - mLastRestatTime) > RESTAT_INTERVAL_MS) {
+        if ((SystemClock.uptimeMillis() - mLastRestatTime) > RESTAT_INTERVAL_MS) {
           updateStats();
         }
       } finally {
@@ -184,7 +193,7 @@ public void resetStats() {
   private void updateStats() {
     mInternalStatFs = updateStatsHelper(mInternalStatFs, mInternalPath);
     mExternalStatFs = updateStatsHelper(mExternalStatFs, mExternalPath);
-    mLastRestatTime = SystemClock.elapsedRealtime();
+    mLastRestatTime = SystemClock.uptimeMillis();
   }
 
   /**
diff --git a/fbcore/src/main/java/com/facebook/common/time/AwakeTimeSinceBootClock.java b/fbcore/src/main/java/com/facebook/common/time/AwakeTimeSinceBootClock.java
new file mode 100644
index 000000000..b99e07dfa
--- /dev/null
+++ b/fbcore/src/main/java/com/facebook/common/time/AwakeTimeSinceBootClock.java
@@ -0,0 +1,38 @@
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+package com.facebook.common.time;
+
+import com.facebook.common.internal.DoNotStrip;
+
+/**
+ * A clock that returns number of milliseconds since boot. It guarantees that every next
+ * call to now() will return a value that is not less that was returned from previous call to now().
+ * This happens regardless system time changes, time zone changes, daylight saving changes etc.
+ *
+ * DO USE THIS CLOCK FOR PERFORMANCE MEASUREMENT.  IT STOPS TICKING WHILE THE DEVICE SLEEPS, THAT
+ * IS, WHILE THE DEVICE CANNOT RUN THE CODE WE ARE PURPORTEDLY MEASURING.
+ */
+@DoNotStrip
+public class AwakeTimeSinceBootClock implements MonotonicClock {
+  @DoNotStrip
+  private static final AwakeTimeSinceBootClock INSTANCE = new AwakeTimeSinceBootClock();
+
+  private AwakeTimeSinceBootClock() {
+  }
+
+  /**
+   * Returns a singleton instance of this clock.
+   * @return singleton instance
+   */
+  @DoNotStrip
+  public static AwakeTimeSinceBootClock get() {
+    return INSTANCE;
+  }
+
+  @Override
+  @DoNotStrip
+  public long now() {
+    // Guaranteed to be monotonic according to documentation.
+    return android.os.SystemClock.uptimeMillis();
+  }
+}
diff --git a/fbcore/src/main/java/com/facebook/common/time/RealtimeSinceBootClock.java b/fbcore/src/main/java/com/facebook/common/time/RealtimeSinceBootClock.java
index 06fc35171..8d7e3ff61 100644
--- a/fbcore/src/main/java/com/facebook/common/time/RealtimeSinceBootClock.java
+++ b/fbcore/src/main/java/com/facebook/common/time/RealtimeSinceBootClock.java
@@ -35,6 +35,6 @@ public static RealtimeSinceBootClock get() {
   @Override
   public long now() {
     // Guaranteed to be monotonic according to documentation.
-    return android.os.SystemClock.elapsedRealtime();
+    return android.os.SystemClock.elapsedRealtime/*sic*/();
   }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/util/UriUtil.java b/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
index b97c421ef..bc50e73ec 100644
--- a/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
+++ b/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
@@ -12,6 +12,8 @@
 import javax.annotation.Nullable;
 
 import android.net.Uri;
+import android.provider.ContactsContract;
+import android.provider.MediaStore;
 
 public class UriUtil {
 
@@ -31,6 +33,12 @@
    */
   public static final String LOCAL_CONTENT_SCHEME = "content";
 
+  /**
+   * URI prefix (including scheme) for contact photos
+   */
+  private static final String LOCAL_CONTACT_IMAGE_PREFIX =
+      Uri.withAppendedPath(ContactsContract.AUTHORITY_URI, "display_photo").getPath();
+
   /**
    * Asset scheme for URIs
    */
@@ -78,6 +86,28 @@ public static boolean isLocalContentUri(@Nullable Uri uri) {
     return LOCAL_CONTENT_SCHEME.equals(scheme);
   }
 
+  /**
+   * Checks if the given URI is a general Contact URI, and not a specific display photo.
+   * @param uri the URI to check
+   * @return true if the uri is a Contact URI, and is not already specifying a display photo.
+   */
+  public static boolean isLocalContactUri(Uri uri) {
+    return isLocalContentUri(uri)
+        && ContactsContract.AUTHORITY.equals(uri.getAuthority())
+        && !uri.getPath().startsWith(LOCAL_CONTACT_IMAGE_PREFIX);
+  }
+
+  /**
+   * Checks if the given URI is for a photo from the device's local media store.
+   * @param uri the URI to check
+   * @return true if the URI points to a media store photo
+   */
+  public static boolean isLocalCameraUri(Uri uri) {
+    String uriString = uri.toString();
+    return uriString.startsWith(MediaStore.Images.Media.EXTERNAL_CONTENT_URI.toString())
+        || uriString.startsWith(MediaStore.Images.Media.INTERNAL_CONTENT_URI.toString());
+  }
+
   /**
    * Check if uri represents local asset
    *
diff --git a/fbcore/src/main/java/com/facebook/datasource/DataSources.java b/fbcore/src/main/java/com/facebook/datasource/DataSources.java
index 4ad83ae24..2e6188bc3 100644
--- a/fbcore/src/main/java/com/facebook/datasource/DataSources.java
+++ b/fbcore/src/main/java/com/facebook/datasource/DataSources.java
@@ -26,6 +26,12 @@ private DataSources() {
     return simpleDataSource;
   }
 
+  public static <T> DataSource<T> immediateDataSource(T result) {
+    SimpleDataSource<T> simpleDataSource = SimpleDataSource.create();
+    simpleDataSource.setResult(result);
+    return simpleDataSource;
+  }
+
   public static <T> Supplier<DataSource<T>> getFailedDataSourceSupplier(final Throwable failure) {
     return new Supplier<DataSource<T>>() {
       @Override
diff --git a/fbcore/src/test/java/com/facebook/common/statfs/StatFsHelperTest.java b/fbcore/src/test/java/com/facebook/common/statfs/StatFsHelperTest.java
index 7c88bd18f..6b61cf54b 100644
--- a/fbcore/src/test/java/com/facebook/common/statfs/StatFsHelperTest.java
+++ b/fbcore/src/test/java/com/facebook/common/statfs/StatFsHelperTest.java
@@ -66,7 +66,7 @@ public void setUp() {
     mMockFileExternal = mock(File.class);
     mMockStatFsInternal = mock(StatFs.class);
     mMockStatFsExternal = mock(StatFs.class);
-    PowerMockito.when(SystemClock.elapsedRealtime()).thenReturn(System.currentTimeMillis());
+    PowerMockito.when(SystemClock.uptimeMillis()).thenReturn(System.currentTimeMillis());
   }
 
   private void expectInternalSetup() {
diff --git a/gradle.properties b/gradle.properties
index ee1195ae0..933a84134 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -22,10 +22,10 @@ VERSION_NAME=0.9.0
 GROUP=com.facebook.fresco
 
 # Deps for gradle
-BUILD_TOOLS_VERSION=23.0.0
+BUILD_TOOLS_VERSION=23.0.3
 COMPILE_SDK_VERSION=23
-ANDROID_GRADLE_PLUGIN_VERSION=1.3.1
-GRADLE_DOWNLOAD_TASK_VERSION=2.0.0
+ANDROID_GRADLE_PLUGIN_VERSION=1.5.0+
+GRADLE_DOWNLOAD_TASK_VERSION=2.1.0
 
 # Deps for libraries
 ANNOTATION_API_VERSION=1.2
@@ -33,20 +33,24 @@ BOLTS_ANDROID_VERSION=1.1.4
 FEST_ASSERT_CORE_VERSION=2.0M10
 JSR_305_VERSION=3.0.0
 JUNIT_VERSION=4.12
-OKHTTP_VERSION=2.6.0
-MOCKITO_CORE_VERSION=1.+
+OKHTTP_VERSION=2.7.4
+OKHTTP3_VERSION=3.0.1
+MOCKITO_CORE_VERSION=1.10.19
 NINEOLDANDROID_VERSION=2.4.0
-POWERMOCK_VERSION=1.6.2
+POWERMOCK_VERSION=1.6.4
 ROBOLECTRIC_VERSION=3.0
-SUPPORT_V4_VERSION=21.0.3
+SUPPORT_LIB_VERSION=23.1.1
 VOLLEY_VERSION=1.0.18
 
+# SDK versions for the samples
+MIN_SDK_VERSION=9
+TARGET_SDK_VERSION=23
+
 # Deps for comparison app
-APPCOMPAT_V7_VERSION=21.0.3
-GLIDE_VERSION=3.6.1
-UIL_VERSION=1.9.4
+GLIDE_VERSION=3.7.0
+UIL_VERSION=1.9.5
 PICASSO_VERSION=2.5.2
 AQUERY_VERSION=0.25.9
 
 # Deps for tools
-STETHO_VERSION=1.2.0
\ No newline at end of file
+STETHO_VERSION=1.2.0
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 2a6b29551..0ecc9c01f 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.7-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.11-all.zip
diff --git a/imagepipeline-backends/imagepipeline-okhttp/src/main/gen/com/facebook/imagepipeline/backends/okhttp/BuildConfig.java b/imagepipeline-backends/imagepipeline-okhttp/src/main/gen/com/facebook/imagepipeline/backends/okhttp/BuildConfig.java
new file mode 100644
index 000000000..a78ed042f
--- /dev/null
+++ b/imagepipeline-backends/imagepipeline-okhttp/src/main/gen/com/facebook/imagepipeline/backends/okhttp/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.imagepipeline.backends.okhttp;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/imagepipeline-backends/imagepipeline-okhttp/src/main/gen/com/facebook/imagepipeline/backends/okhttp/Manifest.java b/imagepipeline-backends/imagepipeline-okhttp/src/main/gen/com/facebook/imagepipeline/backends/okhttp/Manifest.java
new file mode 100644
index 000000000..9476f44e5
--- /dev/null
+++ b/imagepipeline-backends/imagepipeline-okhttp/src/main/gen/com/facebook/imagepipeline/backends/okhttp/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.imagepipeline.backends.okhttp;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/imagepipeline-backends/imagepipeline-okhttp/src/main/gen/com/facebook/imagepipeline/backends/okhttp/R.java b/imagepipeline-backends/imagepipeline-okhttp/src/main/gen/com/facebook/imagepipeline/backends/okhttp/R.java
new file mode 100644
index 000000000..9163e8191
--- /dev/null
+++ b/imagepipeline-backends/imagepipeline-okhttp/src/main/gen/com/facebook/imagepipeline/backends/okhttp/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.imagepipeline.backends.okhttp;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpImagePipelineConfigFactory.java b/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpImagePipelineConfigFactory.java
index 262b10c3e..1c7631eb5 100644
--- a/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpImagePipelineConfigFactory.java
+++ b/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpImagePipelineConfigFactory.java
@@ -10,13 +10,15 @@
 package com.facebook.imagepipeline.backends.okhttp;
 
 import android.content.Context;
-
 import com.facebook.imagepipeline.core.ImagePipelineConfig;
 import com.squareup.okhttp.OkHttpClient;
 
 /**
  * Factory for getting an {@link com.facebook.imagepipeline.core.ImagePipelineConfig} that uses
- * {@link com.facebook.imagepipeline.backends.okhttp.OkHttpNetworkFetcher}.
+ * {@link OkHttpNetworkFetcher}.
+ *
+ * @deprecated replaced with {@code
+ * com.facebook.imagepipeline.backends.okhttp3.OkHttpImagePipelineConfigFactory}.
  */
 public class OkHttpImagePipelineConfigFactory {
 
diff --git a/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpNetworkFetcher.java b/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpNetworkFetcher.java
index 807ac957e..05a6a0a64 100644
--- a/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpNetworkFetcher.java
+++ b/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpNetworkFetcher.java
@@ -12,7 +12,6 @@
 import android.net.Uri;
 import android.os.Looper;
 import android.os.SystemClock;
-
 import com.facebook.common.logging.FLog;
 import com.facebook.imagepipeline.image.EncodedImage;
 import com.facebook.imagepipeline.producers.BaseNetworkFetcher;
@@ -26,7 +25,6 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
-
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
@@ -34,6 +32,9 @@
 
 /**
  * Network fetcher that uses OkHttp as a backend.
+ *
+ * @deprecated replaced with {@code
+ * com.facebook.imagepipeline.backends.okhttp3.OkHttpNetworkFetcher}.
  */
 public class OkHttpNetworkFetcher extends
     BaseNetworkFetcher<OkHttpNetworkFetcher.OkHttpNetworkFetchState> {
@@ -77,13 +78,22 @@ public OkHttpNetworkFetchState createFetchState(
 
   @Override
   public void fetch(final OkHttpNetworkFetchState fetchState, final Callback callback) {
-    fetchState.submitTime = SystemClock.elapsedRealtime();
+    fetchState.submitTime = SystemClock.uptimeMillis();
     final Uri uri = fetchState.getUri();
-    final Request request = new Request.Builder()
+    final Request request;
+
+    try {
+     request = new Request.Builder()
         .cacheControl(new CacheControl.Builder().noStore().build())
         .url(uri.toString())
         .get()
         .build();
+    } catch (Exception e) {
+      // handle malformed Uri
+      callback.onFailure(e);
+      return;
+    }
+
     final Call call = mOkHttpClient.newCall(request);
 
     fetchState.getContext().addCallbacks(
@@ -106,7 +116,7 @@ public void onCancellationRequested() {
         new com.squareup.okhttp.Callback() {
           @Override
           public void onResponse(Response response) {
-            fetchState.responseTime = SystemClock.elapsedRealtime();
+            fetchState.responseTime = SystemClock.uptimeMillis();
             if (!response.isSuccessful()) {
               handleException(call, new IOException("Unexpected HTTP code " + response), callback);
               return;
@@ -138,7 +148,7 @@ public void onFailure(final Request request, final IOException e) {
 
   @Override
   public void onFetchCompletion(OkHttpNetworkFetchState fetchState, int byteSize) {
-    fetchState.fetchCompleteTime = SystemClock.elapsedRealtime();
+    fetchState.fetchCompleteTime = SystemClock.uptimeMillis();
   }
 
   @Override
diff --git a/imagepipeline-backends/imagepipeline-okhttp3/build.gradle b/imagepipeline-backends/imagepipeline-okhttp3/build.gradle
new file mode 100644
index 000000000..19f78dfaf
--- /dev/null
+++ b/imagepipeline-backends/imagepipeline-okhttp3/build.gradle
@@ -0,0 +1,36 @@
+apply plugin: 'com.android.library'
+
+project.group = GROUP
+version = VERSION_NAME
+
+dependencies {
+  compile "com.squareup.okhttp3:okhttp:${OKHTTP3_VERSION}"
+
+  compile project(':fbcore')
+  compile project(':imagepipeline')
+}
+apply from: rootProject.file('release.gradle')
+
+android {
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    packagingOptions {
+        exclude 'LICENSE'
+        exclude 'LICENSE.txt'
+        exclude 'META-INF/LICENSE'
+        exclude 'META-INF/LICENSE.txt'
+        exclude 'META-INF/NOTICE'
+        exclude 'META-INF/NOTICE.txt'
+    }
+    lintOptions {
+        warning 'InvalidPackage'
+    }
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+artifacts.add('archives', sourcesJar)
+
diff --git a/imagepipeline-backends/imagepipeline-okhttp3/gradle.properties b/imagepipeline-backends/imagepipeline-okhttp3/gradle.properties
new file mode 100644
index 000000000..5c2644a0d
--- /dev/null
+++ b/imagepipeline-backends/imagepipeline-okhttp3/gradle.properties
@@ -0,0 +1,5 @@
+POM_NAME=ImagePipeline-OkHttp 3 Integration
+POM_DESCRIPTION=An integration library to use OkHttp 3 as the networking layer in ImagePipeline
+POM_ARTIFACT_ID=imagepipeline-okhttp3
+POM_PACKAGING=aar
+
diff --git a/imagepipeline-backends/imagepipeline-okhttp3/src/main/AndroidManifest.xml b/imagepipeline-backends/imagepipeline-okhttp3/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..dd4de2537
--- /dev/null
+++ b/imagepipeline-backends/imagepipeline-okhttp3/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.imagepipeline.backends.okhttp3"
+    >
+
+  <uses-sdk
+      android:minSdkVersion="9"
+      android:targetSdkVersion="21"
+      />
+</manifest>
diff --git a/imagepipeline-backends/imagepipeline-okhttp3/src/main/java/com/facebook/imagepipeline/backends/okhttp3/OkHttpImagePipelineConfigFactory.java b/imagepipeline-backends/imagepipeline-okhttp3/src/main/java/com/facebook/imagepipeline/backends/okhttp3/OkHttpImagePipelineConfigFactory.java
new file mode 100644
index 000000000..043cd780a
--- /dev/null
+++ b/imagepipeline-backends/imagepipeline-okhttp3/src/main/java/com/facebook/imagepipeline/backends/okhttp3/OkHttpImagePipelineConfigFactory.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.backends.okhttp3;
+
+import android.content.Context;
+import com.facebook.imagepipeline.core.ImagePipelineConfig;
+import okhttp3.OkHttpClient;
+
+/**
+ * Factory for getting an {@link com.facebook.imagepipeline.core.ImagePipelineConfig} that uses
+ * {@link OkHttpNetworkFetcher}.
+ */
+public class OkHttpImagePipelineConfigFactory {
+
+  public static ImagePipelineConfig.Builder newBuilder(Context context, OkHttpClient okHttpClient) {
+    return ImagePipelineConfig.newBuilder(context)
+        .setNetworkFetcher(new OkHttpNetworkFetcher(okHttpClient));
+  }
+}
diff --git a/imagepipeline-backends/imagepipeline-okhttp3/src/main/java/com/facebook/imagepipeline/backends/okhttp3/OkHttpNetworkFetcher.java b/imagepipeline-backends/imagepipeline-okhttp3/src/main/java/com/facebook/imagepipeline/backends/okhttp3/OkHttpNetworkFetcher.java
new file mode 100644
index 000000000..e66f42f8c
--- /dev/null
+++ b/imagepipeline-backends/imagepipeline-okhttp3/src/main/java/com/facebook/imagepipeline/backends/okhttp3/OkHttpNetworkFetcher.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.backends.okhttp3;
+
+import android.net.Uri;
+import android.os.Looper;
+import android.os.SystemClock;
+import com.facebook.common.logging.FLog;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.producers.BaseNetworkFetcher;
+import com.facebook.imagepipeline.producers.BaseProducerContextCallbacks;
+import com.facebook.imagepipeline.producers.Consumer;
+import com.facebook.imagepipeline.producers.FetchState;
+import com.facebook.imagepipeline.producers.ProducerContext;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import okhttp3.CacheControl;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+/**
+ * Network fetcher that uses OkHttp 3 as a backend.
+ */
+public class OkHttpNetworkFetcher extends
+    BaseNetworkFetcher<OkHttpNetworkFetcher.OkHttpNetworkFetchState> {
+
+  public static class OkHttpNetworkFetchState extends FetchState {
+    public long submitTime;
+    public long responseTime;
+    public long fetchCompleteTime;
+
+    public OkHttpNetworkFetchState(
+        Consumer<EncodedImage> consumer,
+        ProducerContext producerContext) {
+      super(consumer, producerContext);
+    }
+  }
+
+  private static final String TAG = "OkHttpNetworkFetchProducer";
+  private static final String QUEUE_TIME = "queue_time";
+  private static final String FETCH_TIME = "fetch_time";
+  private static final String TOTAL_TIME = "total_time";
+  private static final String IMAGE_SIZE = "image_size";
+
+  private final OkHttpClient mOkHttpClient;
+
+  private Executor mCancellationExecutor;
+
+  /**
+   * @param okHttpClient client to use
+   */
+  public OkHttpNetworkFetcher(OkHttpClient okHttpClient) {
+    mOkHttpClient = okHttpClient;
+    mCancellationExecutor = okHttpClient.dispatcher().executorService();
+  }
+
+  @Override
+  public OkHttpNetworkFetchState createFetchState(
+      Consumer<EncodedImage> consumer,
+      ProducerContext context) {
+    return new OkHttpNetworkFetchState(consumer, context);
+  }
+
+  @Override
+  public void fetch(final OkHttpNetworkFetchState fetchState, final Callback callback) {
+    fetchState.submitTime = SystemClock.elapsedRealtime();
+    final Uri uri = fetchState.getUri();
+    final Request request = new Request.Builder()
+        .cacheControl(new CacheControl.Builder().noStore().build())
+        .url(uri.toString())
+        .get()
+        .build();
+    final Call call = mOkHttpClient.newCall(request);
+
+    fetchState.getContext().addCallbacks(
+        new BaseProducerContextCallbacks() {
+          @Override
+          public void onCancellationRequested() {
+            if (Looper.myLooper() != Looper.getMainLooper()) {
+              call.cancel();
+            } else {
+              mCancellationExecutor.execute(new Runnable() {
+                @Override public void run() {
+                  call.cancel();
+                }
+              });
+            }
+          }
+        });
+
+    call.enqueue(
+        new okhttp3.Callback() {
+          @Override
+          public void onResponse(Call call, Response response) throws IOException {
+            fetchState.responseTime = SystemClock.elapsedRealtime();
+            if (!response.isSuccessful()) {
+              handleException(call, new IOException("Unexpected HTTP code " + response), callback);
+              return;
+            }
+            final ResponseBody body = response.body();
+            try {
+              long contentLength = body.contentLength();
+              if (contentLength < 0) {
+                contentLength = 0;
+              }
+              callback.onResponse(body.byteStream(), (int) contentLength);
+            } catch (Exception e) {
+              handleException(call, e, callback);
+            } finally {
+              try {
+                body.close();
+              } catch (Exception e) {
+                FLog.w(TAG, "Exception when closing response body", e);
+              }
+            }
+          }
+
+          @Override
+          public void onFailure(Call call, IOException e) {
+            handleException(call, e, callback);
+          }
+        });
+  }
+
+  @Override
+  public void onFetchCompletion(OkHttpNetworkFetchState fetchState, int byteSize) {
+    fetchState.fetchCompleteTime = SystemClock.elapsedRealtime();
+  }
+
+  @Override
+  public Map<String, String> getExtraMap(OkHttpNetworkFetchState fetchState, int byteSize) {
+    Map<String, String> extraMap = new HashMap<>(4);
+    extraMap.put(QUEUE_TIME, Long.toString(fetchState.responseTime - fetchState.submitTime));
+    extraMap.put(FETCH_TIME, Long.toString(fetchState.fetchCompleteTime - fetchState.responseTime));
+    extraMap.put(TOTAL_TIME, Long.toString(fetchState.fetchCompleteTime - fetchState.submitTime));
+    extraMap.put(IMAGE_SIZE, Integer.toString(byteSize));
+    return extraMap;
+  }
+
+  /**
+   * Handles exceptions.
+   *
+   * <p> OkHttp notifies callers of cancellations via an IOException. If IOException is caught
+   * after request cancellation, then the exception is interpreted as successful cancellation
+   * and onCancellation is called. Otherwise onFailure is called.
+   */
+  private void handleException(final Call call, final Exception e, final Callback callback) {
+    if (call.isCanceled()) {
+      callback.onCancellation();
+    } else {
+      callback.onFailure(e);
+    }
+  }
+}
diff --git a/imagepipeline-base-test/.gitignore b/imagepipeline-base-test/.gitignore
new file mode 100644
index 000000000..8afd910ce
--- /dev/null
+++ b/imagepipeline-base-test/.gitignore
@@ -0,0 +1 @@
+nativedeps/
diff --git a/imagepipeline-base-test/build.gradle b/imagepipeline-base-test/build.gradle
new file mode 100644
index 000000000..6597b3413
--- /dev/null
+++ b/imagepipeline-base-test/build.gradle
@@ -0,0 +1,43 @@
+apply plugin: 'com.android.library'
+apply plugin: 'maven'
+
+project.group = GROUP
+version = VERSION_NAME
+
+dependencies {
+    provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    compile "com.parse.bolts:bolts-android:${BOLTS_ANDROID_VERSION}"
+    compile "com.nineoldandroids:library:${NINEOLDANDROID_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
+    provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
+    compile project(':fbcore')
+    compile project(':imagepipeline-base')
+}
+apply from: rootProject.file('release.gradle')
+
+android {
+
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+
+task jarTest (type: Jar) {
+    from android.sourceSets.test.java.srcDirs
+    include '**/*.java'
+    classifier = 'test'
+}
+
+configurations {
+    testOutput.extendsFrom (testCompile)
+}
+
+artifacts.add('archives', sourcesJar)
+artifacts.add('testOutput', jarTest)
+
+build.dependsOn jarTest
diff --git a/imagepipeline-base-test/gradle.properties b/imagepipeline-base-test/gradle.properties
new file mode 100644
index 000000000..443d9506b
--- /dev/null
+++ b/imagepipeline-base-test/gradle.properties
@@ -0,0 +1,5 @@
+POM_NAME=ImagePipelineBaseTest
+POM_DESCRIPTION=Contains utility classes for test in imagepipeline base
+POM_ARTIFACT_ID=imagepipeline-base-test
+POM_PACKAGING=aar
+
diff --git a/imagepipeline-base-test/src/main/AndroidManifest.xml b/imagepipeline-base-test/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..c1d21fbe3
--- /dev/null
+++ b/imagepipeline-base-test/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.imagepipelinebase.test"
+    >
+
+  <uses-sdk
+      android:minSdkVersion="9"
+      android:targetSdkVersion="21"
+      />
+</manifest>
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TrivialPooledByteBuffer.java b/imagepipeline-base-test/src/main/java/com/facebook/imagepipeline/testing/TrivialPooledByteBuffer.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TrivialPooledByteBuffer.java
rename to imagepipeline-base-test/src/main/java/com/facebook/imagepipeline/testing/TrivialPooledByteBuffer.java
diff --git a/imagepipeline-base/build.gradle b/imagepipeline-base/build.gradle
index a5d637a4f..065e7be90 100644
--- a/imagepipeline-base/build.gradle
+++ b/imagepipeline-base/build.gradle
@@ -8,7 +8,7 @@ dependencies {
     provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     compile "com.parse.bolts:bolts-android:${BOLTS_ANDROID_VERSION}"
     compile "com.nineoldandroids:library:${NINEOLDANDROID_VERSION}"
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
     provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
     compile project(':fbcore')
 
@@ -17,6 +17,7 @@ dependencies {
     testCompile("org.powermock:powermock-api-mockito:${POWERMOCK_VERSION}") {
         exclude group: 'org.mockito', module: 'mockito-all'
     }
+    testCompile "org.powermock:powermock-module-junit4:${POWERMOCK_VERSION}"
     testCompile "org.powermock:powermock-module-junit4-rule:${POWERMOCK_VERSION}"
     testCompile "org.powermock:powermock-classloading-xstream:${POWERMOCK_VERSION}"
     testCompile("org.robolectric:robolectric:${ROBOLECTRIC_VERSION}") {
@@ -31,10 +32,34 @@ android {
     buildToolsVersion rootProject.ext.buildToolsVersion
     compileSdkVersion rootProject.ext.compileSdkVersion
 
+    sourceSets {
+        test {
+            java {
+                exclude '**/EncodedImageTest.java'
+            }
+            resources {
+                exclude '**/BUCK'
+            }
+        }
+    }
 }
 
 task sourcesJar(type: Jar) {
     from android.sourceSets.main.java.srcDirs
     classifier = 'sources'
 }
+
+task jarTest (type: Jar) {
+    from android.sourceSets.test.java.srcDirs
+    include '**/*.java'
+    classifier = 'test'
+}
+
+configurations {
+    testOutput.extendsFrom (testCompile)
+}
+
 artifacts.add('archives', sourcesJar)
+artifacts.add('testOutput', jarTest)
+
+build.dependsOn jarTest
diff --git a/imagepipeline-base/gradle.properties b/imagepipeline-base/gradle.properties
index 909161058..a28ce93a0 100644
--- a/imagepipeline-base/gradle.properties
+++ b/imagepipeline-base/gradle.properties
@@ -1,4 +1,4 @@
-POM_NAME=ImagePipelineBse
+POM_NAME=ImagePipelineBase
 POM_DESCRIPTION=The library with common code between imagepipeline modules
 POM_ARTIFACT_ID=imagepipeline-base
 POM_PACKAGING=aar
diff --git a/imagepipeline-base/src/main/gen/com/facebook/imagepipelinebase/BuildConfig.java b/imagepipeline-base/src/main/gen/com/facebook/imagepipelinebase/BuildConfig.java
new file mode 100644
index 000000000..62e48c070
--- /dev/null
+++ b/imagepipeline-base/src/main/gen/com/facebook/imagepipelinebase/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.imagepipelinebase;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/imagepipeline-base/src/main/gen/com/facebook/imagepipelinebase/Manifest.java b/imagepipeline-base/src/main/gen/com/facebook/imagepipelinebase/Manifest.java
new file mode 100644
index 000000000..4db18d2eb
--- /dev/null
+++ b/imagepipeline-base/src/main/gen/com/facebook/imagepipelinebase/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.imagepipelinebase;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/imagepipeline-base/src/main/gen/com/facebook/imagepipelinebase/R.java b/imagepipeline-base/src/main/gen/com/facebook/imagepipelinebase/R.java
new file mode 100644
index 000000000..b9023b121
--- /dev/null
+++ b/imagepipeline-base/src/main/gen/com/facebook/imagepipelinebase/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.imagepipelinebase;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/imagepipeline-base/src/main/java/com/facebook/binaryresource/FileBinaryResource.java b/imagepipeline-base/src/main/java/com/facebook/binaryresource/FileBinaryResource.java
index 513384131..6a96dad57 100644
--- a/imagepipeline-base/src/main/java/com/facebook/binaryresource/FileBinaryResource.java
+++ b/imagepipeline-base/src/main/java/com/facebook/binaryresource/FileBinaryResource.java
@@ -61,9 +61,9 @@ public int hashCode() {
   }
 
   /*
-   * Factory method to create a wrapping BinaryResource without explicitly taking care of null.
-   * If the supplied file is null, instead of BinaryResource, null is returned.
-   */
+     * Factory method to create a wrapping BinaryResource without explicitly taking care of null.
+     * If the supplied file is null, instead of BinaryResource, null is returned.
+     */
   public static FileBinaryResource createOrNull(File file) {
     return (file != null) ? new FileBinaryResource(file) : null;
   }
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/common/CacheKey.java b/imagepipeline-base/src/main/java/com/facebook/cache/common/CacheKey.java
index 1d8e6784e..3e7f1a0be 100644
--- a/imagepipeline-base/src/main/java/com/facebook/cache/common/CacheKey.java
+++ b/imagepipeline-base/src/main/java/com/facebook/cache/common/CacheKey.java
@@ -9,6 +9,8 @@
 
 package com.facebook.cache.common;
 
+import android.net.Uri;
+
 /**
  * Strongly typed cache key to be used instead of {@link Object}.
  *
@@ -24,4 +26,11 @@
 
   /** This method must be implemented with accordance to the {@link #equals} method. */
   int hashCode();
+
+  /**
+   * Returns true if this key was constructed from this {@link Uri}.
+   *
+   * Used for cases like deleting all keys for a given uri.
+   */
+  boolean containsUri(Uri uri);
 }
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/common/MultiCacheKey.java b/imagepipeline-base/src/main/java/com/facebook/cache/common/MultiCacheKey.java
new file mode 100644
index 000000000..8dd2ab920
--- /dev/null
+++ b/imagepipeline-base/src/main/java/com/facebook/cache/common/MultiCacheKey.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+package com.facebook.cache.common;
+
+import java.util.List;
+
+import android.net.Uri;
+
+import com.facebook.common.internal.Preconditions;
+
+/**
+ * A cache key that wraps multiple cache keys.
+ *
+ * Note: {@code equals} and {@code hashcode} are implemented in a way that two MultiCacheKeys are
+ * equal if and only if the underlying list of cache keys is equal. That implies AllOf semantics.
+ * Unfortunately, it is not possible to implement AnyOf semantics for {@code equals} because the
+ * transitivity requirement wouldn't be satisfied. I.e. we would have:
+ * {A} = {A, B}, {A, B} = {B}, but {A} != {B}.
+ *
+ * It is fine to use this key with AnyOf semantics, but one should be aware of {@code equals} and
+ * {@code hashcode} behavior, and should implement AnyOf logic manually.
+ */
+public class MultiCacheKey implements CacheKey {
+
+  final List<CacheKey> mCacheKeys;
+
+  public MultiCacheKey(List<CacheKey> cacheKeys) {
+    mCacheKeys = Preconditions.checkNotNull(cacheKeys);
+  }
+
+  public List<CacheKey> getCacheKeys() {
+    return mCacheKeys;
+  }
+
+  @Override
+  public String toString() {
+    return "MultiCacheKey:" + mCacheKeys.toString();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true;
+    }
+    if (o instanceof MultiCacheKey) {
+      final MultiCacheKey otherKey = (MultiCacheKey) o;
+      return mCacheKeys.equals(otherKey.mCacheKeys);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return mCacheKeys.hashCode();
+  }
+
+  @Override
+  public boolean containsUri(Uri uri) {
+    for (int i = 0; i < mCacheKeys.size(); i++) {
+      if (mCacheKeys.get(i).containsUri(uri)) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/common/SimpleCacheKey.java b/imagepipeline-base/src/main/java/com/facebook/cache/common/SimpleCacheKey.java
index 40fcadb63..0cb531e7f 100644
--- a/imagepipeline-base/src/main/java/com/facebook/cache/common/SimpleCacheKey.java
+++ b/imagepipeline-base/src/main/java/com/facebook/cache/common/SimpleCacheKey.java
@@ -9,6 +9,8 @@
 
 package com.facebook.cache.common;
 
+import android.net.Uri;
+
 import com.facebook.common.internal.Preconditions;
 
 /**
@@ -45,4 +47,9 @@ public boolean equals(Object o) {
   public int hashCode() {
     return mKey.hashCode();
   }
+
+  @Override
+  public boolean containsUri(Uri uri) {
+    return mKey.contains(uri.toString());
+  }
 }
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DefaultDiskStorage.java b/imagepipeline-base/src/main/java/com/facebook/cache/disk/DefaultDiskStorage.java
index 1002b7b16..4fe585ffb 100644
--- a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DefaultDiskStorage.java
+++ b/imagepipeline-base/src/main/java/com/facebook/cache/disk/DefaultDiskStorage.java
@@ -9,6 +9,8 @@
 
 package com.facebook.cache.disk;
 
+import javax.annotation.Nullable;
+
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
@@ -19,6 +21,7 @@
 import java.util.Locale;
 import java.util.concurrent.TimeUnit;
 
+import com.facebook.binaryresource.BinaryResource;
 import com.facebook.binaryresource.FileBinaryResource;
 import com.facebook.cache.common.CacheErrorLogger;
 import com.facebook.cache.common.WriterCallback;
@@ -149,47 +152,6 @@ private void recreateDirectoryIfVersionChanges() {
     }
   }
 
-  @Override
-  public void updateResource(
-      final String resourceId,
-      final FileBinaryResource fileBinaryResource,
-      final WriterCallback callback,
-      final Object debugInfo)
-    throws IOException {
-    File file = fileBinaryResource.getFile();
-    FileOutputStream fileStream = null;
-    try {
-      fileStream = new FileOutputStream(file);
-    } catch (FileNotFoundException fne) {
-      mCacheErrorLogger.logError(
-          CacheErrorLogger.CacheErrorCategory.WRITE_UPDATE_FILE_NOT_FOUND,
-          TAG,
-          "updateResource",
-          fne);
-      throw fne;
-    }
-
-    long length = -1;
-    try {
-      CountingOutputStream countingStream = new CountingOutputStream(fileStream);
-      callback.write(countingStream);
-      // just in case underlying stream's close method doesn't flush:
-      // we flush it manually and inside the try/catch
-      countingStream.flush();
-      length = countingStream.getCount();
-    } finally {
-      // if it fails to close (or write the last piece) we really want to know
-      // Normally we would want this to be quiet because a closing exception would hide one
-      // inside the try/finally, but now we really want to know if something fails at flush or close
-      fileStream.close();
-    }
-    // this code should never throw, but if filesystem doesn't fail on a failing/uncomplete close
-    // we want to know and manually fail
-    if (file.length() != length) {
-      throw new IncompleteFileException(length, file.length());
-    }
-  }
-
   private static class IncompleteFileException extends IOException {
     public final long expected;
     public final long actual;
@@ -244,7 +206,7 @@ public void preVisitDirectory(File directory) {
     public void visitFile(File file) {
       FileInfo info = getShardFileInfo(file);
       if (info != null && info.type == FileType.CONTENT) {
-        result.add(new EntryImpl(file));
+        result.add(new EntryImpl(info.resourceId, file));
       }
     }
 
@@ -345,7 +307,7 @@ private void mkdirs(File directory, String message) throws IOException {
   }
 
   @Override
-  public FileBinaryResource createTemporary(
+  public Inserter insert(
       String resourceId,
       Object debugInfo)
       throws IOException {
@@ -353,62 +315,24 @@ public FileBinaryResource createTemporary(
     FileInfo info = new FileInfo(FileType.TEMP, resourceId);
     File parent = getSubdirectory(info.resourceId);
     if (!parent.exists()) {
-      mkdirs(parent, "createTemporary");
+      mkdirs(parent, "insert");
     }
 
     try {
       File file = info.createTempFile(parent);
-      return FileBinaryResource.createOrNull(file);
+      return new InserterImpl(resourceId, file);
     } catch (IOException ioe) {
       mCacheErrorLogger.logError(
           CacheErrorLogger.CacheErrorCategory.WRITE_CREATE_TEMPFILE,
           TAG,
-          "createTemporary",
+          "insert",
           ioe);
       throw ioe;
     }
   }
 
   @Override
-  public FileBinaryResource commit(
-      String resourceId,
-      FileBinaryResource tempFileResource,
-      Object debugInfo)
-      throws IOException {
-
-    File tempFile = tempFileResource.getFile();
-    File targetFile = getContentFileFor(resourceId);
-
-    try {
-      FileUtils.rename(tempFile, targetFile);
-    } catch (FileUtils.RenameException re) {
-      CacheErrorLogger.CacheErrorCategory category;
-      Throwable cause = re.getCause();
-      if (cause == null) {
-        category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_OTHER;
-      } else if (cause instanceof FileUtils.ParentDirNotFoundException) {
-        category =
-            CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_TEMPFILE_PARENT_NOT_FOUND;
-      } else if (cause instanceof FileNotFoundException) {
-        category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_TEMPFILE_NOT_FOUND;
-      } else {
-        category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_OTHER;
-      }
-      mCacheErrorLogger.logError(
-          category,
-          TAG,
-          "commit",
-          re);
-      throw re;
-    }
-    if (targetFile.exists()) {
-      targetFile.setLastModified(mClock.now());
-    }
-    return FileBinaryResource.createOrNull(targetFile);
-  }
-
-  @Override
-  public FileBinaryResource getResource(String resourceId, Object debugInfo) {
+  public BinaryResource getResource(String resourceId, Object debugInfo) {
     final File file = getContentFileFor(resourceId);
     if (file.exists()) {
       file.setLastModified(mClock.now());
@@ -417,8 +341,7 @@ public FileBinaryResource getResource(String resourceId, Object debugInfo) {
     return null;
   }
 
-  @Override
-  public String getFilename(String resourceId) {
+  private String getFilename(String resourceId) {
     FileInfo fileInfo = new FileInfo(FileType.CONTENT, resourceId);
     String path = getSubdirectoryPath(fileInfo.resourceId);
     return fileInfo.toPath(path);
@@ -534,18 +457,25 @@ private String typeOfBytes(byte[] bytes) {
    * Implementation of Entry listed by entriesIterator.
    */
   @VisibleForTesting
-  class EntryImpl implements Entry {
+  static class EntryImpl implements Entry {
+    private final String id;
     private final FileBinaryResource resource;
     private long size;
     private long timestamp;
 
-    private EntryImpl(File cachedFile) {
+    private EntryImpl(String id, File cachedFile) {
       Preconditions.checkNotNull(cachedFile);
+      this.id = Preconditions.checkNotNull(id);
       this.resource = FileBinaryResource.createOrNull(cachedFile);
       this.size = -1;
       this.timestamp = -1;
     }
 
+    @Override
+    public String getId() {
+      return id;
+    }
+
     @Override
     public long getTimestamp() {
       if (timestamp < 0) {
@@ -639,6 +569,7 @@ public File createTempFile(File parent) throws IOException {
       return f;
     }
 
+    @Nullable
     public static FileInfo fromFile(File file) {
       String name = file.getName();
       int pos = name.lastIndexOf('.');
@@ -662,4 +593,91 @@ public static FileInfo fromFile(File file) {
       return new FileInfo(type, resourceId);
     }
   }
+
+  @VisibleForTesting
+  /* package protected */ class InserterImpl implements Inserter {
+
+    private final String mResourceId;
+
+    @VisibleForTesting
+    /* package protected*/ final File mTemporaryFile;
+
+    public InserterImpl(String resourceId, File temporaryFile) {
+      mResourceId = resourceId;
+      mTemporaryFile = temporaryFile;
+    }
+
+    @Override
+    public void writeData(WriterCallback callback, Object debugInfo) throws IOException {
+      FileOutputStream fileStream;
+      try {
+        fileStream = new FileOutputStream(mTemporaryFile);
+      } catch (FileNotFoundException fne) {
+        mCacheErrorLogger.logError(
+            CacheErrorLogger.CacheErrorCategory.WRITE_UPDATE_FILE_NOT_FOUND,
+            TAG,
+            "updateResource",
+            fne);
+        throw fne;
+      }
+
+      long length;
+      try {
+        CountingOutputStream countingStream = new CountingOutputStream(fileStream);
+        callback.write(countingStream);
+        // just in case underlying stream's close method doesn't flush:
+        // we flush it manually and inside the try/catch
+        countingStream.flush();
+        length = countingStream.getCount();
+      } finally {
+        // if it fails to close (or write the last piece) we really want to know
+        // Normally we would want this to be quiet because a closing exception would hide one
+        // inside the try, but now we really want to know if something fails at flush or close
+        fileStream.close();
+      }
+      // this code should never throw, but if filesystem doesn't fail on a failing/uncomplete close
+      // we want to know and manually fail
+      if (mTemporaryFile.length() != length) {
+        throw new IncompleteFileException(length, mTemporaryFile.length());
+      }
+    }
+
+    @Override
+    public BinaryResource commit(Object debugInfo) throws IOException {
+      // the temp resource must be ours!
+      File targetFile = getContentFileFor(mResourceId);
+
+      try {
+        FileUtils.rename(mTemporaryFile, targetFile);
+      } catch (FileUtils.RenameException re) {
+        CacheErrorLogger.CacheErrorCategory category;
+        Throwable cause = re.getCause();
+        if (cause == null) {
+          category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_OTHER;
+        } else if (cause instanceof FileUtils.ParentDirNotFoundException) {
+          category =
+              CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_TEMPFILE_PARENT_NOT_FOUND;
+        } else if (cause instanceof FileNotFoundException) {
+          category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_TEMPFILE_NOT_FOUND;
+        } else {
+          category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_OTHER;
+        }
+        mCacheErrorLogger.logError(
+            category,
+            TAG,
+            "commit",
+            re);
+        throw re;
+      }
+      if (targetFile.exists()) {
+        targetFile.setLastModified(mClock.now());
+      }
+      return FileBinaryResource.createOrNull(targetFile);
+    }
+
+    @Override
+    public boolean cleanUp() {
+      return !mTemporaryFile.exists() || mTemporaryFile.delete();
+    }
+  }
 }
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskCacheFactory.java b/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskCacheFactory.java
deleted file mode 100644
index 44c4a6280..000000000
--- a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskCacheFactory.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (c) 2015-present, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- */
-
-package com.facebook.cache.disk;
-
-/**
- * Factory class for building a {@link DiskStorageCache}.
- */
-public class DiskCacheFactory {
-
-  /**
-   * Creates a new {@link DiskStorageCache} from the given {@link DiskCacheConfig}
-   */
-  public static DiskStorageCache newDiskStorageCache(DiskCacheConfig diskCacheConfig) {
-    DiskStorageSupplier diskStorageSupplier = newDiskStorageSupplier(diskCacheConfig);
-    DiskStorageCache.Params params = new DiskStorageCache.Params(
-        diskCacheConfig.getMinimumSizeLimit(),
-        diskCacheConfig.getLowDiskSpaceSizeLimit(),
-        diskCacheConfig.getDefaultSizeLimit());
-    return new DiskStorageCache(
-        diskStorageSupplier,
-        diskCacheConfig.getEntryEvictionComparatorSupplier(),
-        params,
-        diskCacheConfig.getCacheEventListener(),
-        diskCacheConfig.getCacheErrorLogger(),
-        diskCacheConfig.getDiskTrimmableRegistry());
-  }
-
-  private static DiskStorageSupplier newDiskStorageSupplier(DiskCacheConfig diskCacheConfig) {
-    return new DefaultDiskStorageSupplier(
-        diskCacheConfig.getVersion(),
-        diskCacheConfig.getBaseDirectoryPathSupplier(),
-        diskCacheConfig.getBaseDirectoryName(),
-        diskCacheConfig.getCacheErrorLogger());
-  }
-}
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorage.java b/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorage.java
index 4d62a43e3..9fbe9627f 100644
--- a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorage.java
+++ b/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorage.java
@@ -16,7 +16,7 @@
 import java.util.List;
 import java.util.Map;
 
-import com.facebook.binaryresource.FileBinaryResource;
+import com.facebook.binaryresource.BinaryResource;
 import com.facebook.cache.common.WriterCallback;
 
 /**
@@ -60,14 +60,7 @@ public DiskDumpInfo() {
    * @return the resource with the specified name. NULL if not found
    * @throws IOException for unexpected behavior.
    */
-  FileBinaryResource getResource(String resourceId, Object debugInfo) throws IOException;
-
-  /**
-   * Get the filename of the resource with the specified name
-   * @param resourceId id of the resource
-   * @return the name of the resource
-   */
-  String getFilename(String resourceId);
+  BinaryResource getResource(String resourceId, Object debugInfo) throws IOException;
 
   /**
    * Does a resource with this name exist?
@@ -98,44 +91,10 @@ public DiskDumpInfo() {
    * from this method.
    * @param resourceId id of the resource
    * @param debugInfo helper object for debugging
-   * @return the temporary resource created
+   * @return the Inserter object with methods to write data, commit or cancel the insertion
    * @exception IOException on errors during this operation
    */
-  FileBinaryResource createTemporary(String resourceId, Object debugInfo) throws IOException;
-
-  /**
-   * Update the contents of the resource. Executes outside the session lock.
-   * The resource must exist. The writer callback will be provided with an
-   * OutputStream to write to. For high efficiency client should make sure that data
-   * is written in big chunks (for example by employing BufferedInputStream or writing all data
-   * at once).
-   * @param resourceId id of the resource
-   * @param resource the existing resource (which will be overwritten)
-   * @param callback the write callback
-   * @param debugInfo helper object for debugging
-   * @throws IOException
-   */
-  void updateResource(
-      String resourceId,
-      FileBinaryResource resource,
-      WriterCallback callback,
-      Object debugInfo)
-      throws IOException;
-
-  /**
-   * Commits the resource created by createTemporary() into the cache.
-   * Once this is called the entry will be available to clients of the cache.
-   * @param resourceId the id of the resource
-   * @param temporary the temporary resource
-   * @param debugInfo debug object for debugging
-   * @return the permanent resource created
-   * @exception IOException on errors during the commit
-   */
-  FileBinaryResource commit(
-      String resourceId,
-      FileBinaryResource temporary,
-      Object debugInfo)
-      throws IOException;
+  Inserter insert(String resourceId, Object debugInfo) throws IOException;
 
   /**
    * Get all entries currently in the storage
@@ -169,10 +128,49 @@ FileBinaryResource commit(
   DiskDumpInfo getDumpInfo() throws IOException;
 
   interface Entry {
+    /** the id representing the resource */
+    String getId();
     /** calculated on first time and never changes so it can be used as immutable **/
     long getTimestamp();
     /** calculated on first time and never changes so it can be used as immutable **/
     long getSize();
-    FileBinaryResource getResource();
+    BinaryResource getResource();
+  }
+
+  /**
+   * This is a builder-like interface returned when calling insert.
+   * It holds all the operations carried through an {@link #insert} operation:
+   * - writing data
+   * - commiting
+   * - clean up
+   */
+  interface Inserter {
+
+    /**
+     * Update the contents of the resource to be inserted. Executes outside the session lock.
+     * The writer callback will be provided with an OutputStream to write to.
+     * For high efficiency client should make sure that data is written in big chunks
+     * (for example by employing BufferedInputStream or writing all data at once).
+     * @param callback the write callback
+     * @param debugInfo helper object for debugging
+     * @throws IOException
+     */
+    void writeData(WriterCallback callback, Object debugInfo) throws IOException;
+
+    /**
+     * Commits the insertion into the cache.
+     * Once this is called the entry will be available to clients of the cache.
+     * @param debugInfo debug object for debugging
+     * @return the final resource created
+     * @exception IOException on errors during the commit
+     */
+    BinaryResource commit(Object debugInfo) throws IOException;
+
+    /**
+     * Discards the insertion process.
+     * If resource was already committed the call is ignored.
+     * @return true if cleanUp is successful (or noop), false if something couldn't be dealt with
+     */
+    boolean cleanUp();
   }
 }
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorageCache.java b/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorageCache.java
index 3a5d0efe5..619e1d8ca 100644
--- a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorageCache.java
+++ b/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorageCache.java
@@ -13,21 +13,21 @@
 import javax.annotation.concurrent.GuardedBy;
 import javax.annotation.concurrent.ThreadSafe;
 
-import java.io.File;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
-import android.os.SystemClock;
-
 import com.facebook.binaryresource.BinaryResource;
-import com.facebook.binaryresource.FileBinaryResource;
 import com.facebook.cache.common.CacheErrorLogger;
 import com.facebook.cache.common.CacheEventListener;
 import com.facebook.cache.common.CacheKey;
+import com.facebook.cache.common.MultiCacheKey;
 import com.facebook.cache.common.WriterCallback;
 import com.facebook.common.disk.DiskTrimmable;
 import com.facebook.common.disk.DiskTrimmableRegistry;
@@ -35,6 +35,7 @@
 import com.facebook.common.logging.FLog;
 import com.facebook.common.statfs.StatFsHelper;
 import com.facebook.common.time.Clock;
+import com.facebook.common.time.SystemClock;
 import com.facebook.common.util.SecureHashUtil;
 
 /**
@@ -62,6 +63,10 @@
 
   private final CacheEventListener mCacheEventListener;
 
+  @GuardedBy("mLock")
+  // Maps CacheKey to the resource id that is stored on disk (if any).
+  @VisibleForTesting final Map<CacheKey, String> mIndex;
+
   @GuardedBy("mLock")
   private long mCacheSizeLastUpdateTime;
 
@@ -69,7 +74,7 @@
 
   private final StatFsHelper mStatFsHelper;
 
-  private final DiskStorageSupplier mStorageSupplier;
+  private final DiskStorage mStorage;
   private final EntryEvictionComparatorSupplier mEntryEvictionComparatorSupplier;
   private final CacheErrorLogger mCacheErrorLogger;
 
@@ -139,7 +144,7 @@ public Params(
   }
 
   public DiskStorageCache(
-      DiskStorageSupplier diskStorageSupplier,
+      DiskStorage diskStorage,
       EntryEvictionComparatorSupplier entryEvictionComparatorSupplier,
       Params params,
       CacheEventListener cacheEventListener,
@@ -150,7 +155,7 @@ public DiskStorageCache(
     this.mCacheSizeLimit = params.mDefaultCacheSizeLimit;
     this.mStatFsHelper = StatFsHelper.getInstance();
 
-    this.mStorageSupplier = diskStorageSupplier;
+    this.mStorage = diskStorage;
     this.mEntryEvictionComparatorSupplier = entryEvictionComparatorSupplier;
 
     this.mCacheSizeLastUpdateTime = UNINITIALIZED;
@@ -165,21 +170,18 @@ public DiskStorageCache(
     if (diskTrimmableRegistry != null) {
       diskTrimmableRegistry.registerDiskTrimmable(this);
     }
-    this.mClock = com.facebook.common.time.SystemClock.get();
+    this.mClock = SystemClock.get();
+    this.mIndex = new HashMap<>();
   }
 
   @Override
   public DiskStorage.DiskDumpInfo getDumpInfo() throws IOException {
-    return mStorageSupplier.get().getDumpInfo();
+    return mStorage.getDumpInfo();
   }
 
   @Override
   public boolean isEnabled() {
-    try {
-      return mStorageSupplier.get().isEnabled();
-    } catch (IOException e) {
-      return false;
-    }
+    return mStorage.isEnabled();
   }
 
   /**
@@ -196,11 +198,27 @@ public boolean isEnabled() {
   public BinaryResource getResource(final CacheKey key) {
     try {
       synchronized (mLock) {
-        FileBinaryResource resource = mStorageSupplier.get().getResource(getResourceId(key), key);
+        String resourceId = null;
+        BinaryResource resource = null;
+        if (mIndex.containsKey(key)) {
+          resourceId = mIndex.get(key);
+          resource = mStorage.getResource(resourceId, key);
+        } else {
+          List<String> resourceIds = getResourceIds(key);
+          for (int i = 0; i < resourceIds.size(); i++) {
+            resourceId = resourceIds.get(i);
+            resource = mStorage.getResource(resourceId, key);
+            if (resource != null) {
+              break;
+            }
+          }
+        }
         if (resource == null) {
           mCacheEventListener.onMiss();
+          mIndex.remove(key);
         } else {
           mCacheEventListener.onHit();
+          mIndex.put(key, resourceId);
         }
         return resource;
       }
@@ -229,7 +247,25 @@ public BinaryResource getResource(final CacheKey key) {
   public boolean probe(final CacheKey key) {
     try {
       synchronized (mLock) {
-        return mStorageSupplier.get().touch(getResourceId(key), key);
+        String resourceId = null;
+        boolean retval = false;
+        if (mIndex.containsKey(key)) {
+          resourceId = mIndex.get(key);
+          retval = mStorage.touch(resourceId, key);
+        } else {
+          List<String> resourceIds = getResourceIds(key);
+          for (int i = 0; i < resourceIds.size(); i++) {
+            resourceId = resourceIds.get(i);
+            retval = mStorage.touch(resourceId, key);
+            if (retval) {
+              break;
+            }
+          }
+        }
+        if (retval) {
+          mIndex.put(key, resourceId);
+        }
+        return retval;
       }
     } catch (IOException e) {
       mCacheEventListener.onReadException();
@@ -240,36 +276,26 @@ public boolean probe(final CacheKey key) {
   /**
    * Creates a temp file for writing outside the session lock
    */
-  private FileBinaryResource createTemporaryResource(
+  private DiskStorage.Inserter startInsert(
       final String resourceId,
       final CacheKey key)
       throws IOException {
     maybeEvictFilesInCacheDir();
-    return mStorageSupplier.get().createTemporary(resourceId, key);
-  }
-
-  private void deleteTemporaryResource(FileBinaryResource fileResource) {
-    File tempFile = fileResource.getFile();
-
-    if (tempFile.exists()) {
-      FLog.e(TAG, "Temp file still on disk: %s ", tempFile);
-      if (!tempFile.delete()) {
-        FLog.e(TAG, "Failed to delete temp file: %s", tempFile);
-      }
-    }
+    return mStorage.insert(resourceId, key);
   }
 
   /**
    * Commits the provided temp file to the cache, renaming it to match
    * the cache's hashing convention.
    */
-  private FileBinaryResource commitResource(
-      final String resourceId,
+  private BinaryResource endInsert(
+      final DiskStorage.Inserter inserter,
       final CacheKey key,
-      final FileBinaryResource temporary) throws IOException {
+      String resourceId) throws IOException {
     synchronized (mLock) {
-      FileBinaryResource resource = mStorageSupplier.get().commit(resourceId, temporary, key);
+      BinaryResource resource = inserter.commit(key);
       mCacheStats.increment(resource.size(), 1);
+      mIndex.put(key, resourceId);
       return resource;
     }
   }
@@ -279,16 +305,26 @@ public BinaryResource insert(CacheKey key, WriterCallback callback) throws IOExc
     // Write to a temp file, then move it into place. This allows more parallelism
     // when writing files.
     mCacheEventListener.onWriteAttempt();
-    final String resourceId = getResourceId(key);
+    String resourceId;
+    synchronized (mLock) {
+      // for multiple resource ids associated with the same image, we only write one file
+      if (mIndex.containsKey(key)) {
+        resourceId = mIndex.get(key);
+      } else {
+        resourceId = getResourceIds(key).get(0);
+      }
+    }
     try {
       // getting the file is synchronized
-      FileBinaryResource temporary = createTemporaryResource(resourceId, key);
+      DiskStorage.Inserter inserter = startInsert(resourceId, key);
       try {
-        mStorageSupplier.get().updateResource(resourceId, temporary, callback, key);
+        inserter.writeData(callback, key);
         // Committing the file is synchronized
-        return commitResource(resourceId, key, temporary);
+        return endInsert(inserter, key, resourceId);
       } finally {
-        deleteTemporaryResource(temporary);
+        if (!inserter.cleanUp()) {
+          FLog.e(TAG, "Failed to delete temp file");
+        }
       }
     } catch (IOException ioe) {
       mCacheEventListener.onWriteException();
@@ -301,7 +337,18 @@ public BinaryResource insert(CacheKey key, WriterCallback callback) throws IOExc
   public void remove(CacheKey key) {
     synchronized (mLock) {
       try {
-        mStorageSupplier.get().remove(getResourceId(key));
+        String resourceId = null;
+        if (mIndex.containsKey(key)) {
+          resourceId = mIndex.get(key);
+          mStorage.remove(resourceId);
+        } else {
+          List<String> resourceIds = getResourceIds(key);
+          for (int i = 0; i < resourceIds.size(); i++) {
+            resourceId = resourceIds.get(i);
+            mStorage.remove(resourceId);
+          }
+        }
+        mIndex.remove(key);
       } catch (IOException e) {
         mCacheErrorLogger.logError(
             CacheErrorLogger.CacheErrorCategory.DELETE_FILE,
@@ -323,15 +370,15 @@ public long clearOldEntries(long cacheExpirationMs) {
     synchronized (mLock) {
       try {
         long now = mClock.now();
-        DiskStorage storage = mStorageSupplier.get();
-        Collection<DiskStorage.Entry> allEntries = storage.getEntries();
+        Collection<DiskStorage.Entry> allEntries = mStorage.getEntries();
         int itemsRemovedCount = 0;
         long itemsRemovedSize = 0L;
         for (DiskStorage.Entry entry : allEntries) {
           // entry age of zero is disallowed.
           long entryAgeMs = Math.max(1, Math.abs(now - entry.getTimestamp()));
           if (entryAgeMs >= cacheExpirationMs) {
-            long entryRemovedSize = storage.remove(entry);
+            long entryRemovedSize = mStorage.remove(entry);
+            mIndex.values().remove(entry.getId());
             if (entryRemovedSize > 0) {
               itemsRemovedCount++;
               itemsRemovedSize += entryRemovedSize;
@@ -340,7 +387,7 @@ public long clearOldEntries(long cacheExpirationMs) {
             oldestRemainingEntryAgeMs = Math.max(oldestRemainingEntryAgeMs, entryAgeMs);
           }
         }
-        storage.purgeUnexpectedResources();
+        mStorage.purgeUnexpectedResources();
         if (itemsRemovedCount > 0) {
           maybeUpdateFileCacheSize();
           mCacheStats.increment(-itemsRemovedSize, -itemsRemovedCount);
@@ -401,10 +448,9 @@ private void maybeEvictFilesInCacheDir() throws IOException {
   private void evictAboveSize(
       long desiredSize,
       CacheEventListener.EvictionReason reason) throws IOException {
-    DiskStorage storage = mStorageSupplier.get();
     Collection<DiskStorage.Entry> entries;
     try {
-      entries = getSortedEntries(storage.getEntries());
+      entries = getSortedEntries(mStorage.getEntries());
     } catch (IOException ioe) {
       mCacheErrorLogger.logError(
           CacheErrorLogger.CacheErrorCategory.EVICTION,
@@ -421,14 +467,15 @@ private void evictAboveSize(
       if (sumItemSizes > (deleteSize)) {
         break;
       }
-      long deletedSize = storage.remove(entry);
+      long deletedSize = mStorage.remove(entry);
+      mIndex.values().remove(entry.getId());
       if (deletedSize > 0) {
         itemCount ++;
         sumItemSizes += deletedSize;
       }
     }
     mCacheStats.increment(-sumItemSizes, -itemCount);
-    storage.purgeUnexpectedResources();
+    mStorage.purgeUnexpectedResources();
     reportEviction(reason, itemCount, sumItemSizes);
   }
 
@@ -481,7 +528,8 @@ public long getSize() {
   public void clearAll() {
     synchronized (mLock) {
       try {
-        mStorageSupplier.get().clearAll();
+        mStorage.clearAll();
+        mIndex.clear();
       } catch (IOException ioe) {
         mCacheErrorLogger.logError(
             CacheErrorLogger.CacheErrorCategory.EVICTION,
@@ -494,11 +542,44 @@ public void clearAll() {
     }
   }
 
+  @Override
+  public boolean hasKeySync(CacheKey key) {
+    synchronized (mLock) {
+      return mIndex.containsKey(key);
+    }
+  }
+
+  @Override
   public boolean hasKey(final CacheKey key) {
-    try {
-      return mStorageSupplier.get().contains(getResourceId(key), key);
-    } catch (IOException e) {
-      return false;
+    synchronized (mLock) {
+      if (hasKeySync(key)) {
+        return true;
+      }
+      try {
+        String resourceId = null;
+        boolean retval = false;
+        if (mIndex.containsKey(key)) {
+          resourceId = mIndex.get(key);
+          retval = mStorage.contains(resourceId, key);
+        } else {
+          List<String> resourceIds = getResourceIds(key);
+          for (int i = 0; i < resourceIds.size(); i++) {
+            resourceId = resourceIds.get(i);
+            retval = mStorage.contains(resourceId, key);
+            if (retval) {
+              break;
+            }
+          }
+        }
+        if (retval) {
+          mIndex.put(key, resourceId);
+        } else {
+          mIndex.remove(key);
+        }
+        return retval;
+      } catch (IOException e) {
+        return false;
+      }
     }
   }
 
@@ -551,7 +632,7 @@ private void trimBy(final double trimRatio) {
   @GuardedBy("mLock")
   private boolean maybeUpdateFileCacheSize() {
     boolean result = false;
-    long now = SystemClock.elapsedRealtime();
+    long now = mClock.now();
     if ((!mCacheStats.isInitialized()) ||
         mCacheSizeLastUpdateTime == UNINITIALIZED ||
         (now - mCacheSizeLastUpdateTime) > FILECACHE_SIZE_UPDATE_PERIOD_MS) {
@@ -573,8 +654,7 @@ private void calcFileCacheSize() {
     long now = mClock.now();
     long timeThreshold = now + FUTURE_TIMESTAMP_THRESHOLD_MS;
     try {
-      DiskStorage storage = mStorageSupplier.get();
-      Collection<DiskStorage.Entry> entries = storage.getEntries();
+      Collection<DiskStorage.Entry> entries = mStorage.getEntries();
       for (DiskStorage.Entry entry: entries) {
         count++;
         size += entry.getSize();
@@ -607,9 +687,20 @@ private void calcFileCacheSize() {
   }
 
   @VisibleForTesting
-  String getResourceId(final CacheKey key) {
+  static List<String> getResourceIds(final CacheKey key) {
     try {
-      return SecureHashUtil.makeSHA1HashBase64(key.toString().getBytes("UTF-8"));
+      final List<String> ids;
+      if (key instanceof MultiCacheKey) {
+        List<CacheKey> keys = ((MultiCacheKey) key).getCacheKeys();
+        ids = new ArrayList<>(keys.size());
+        for (int i = 0; i < keys.size(); i++) {
+           ids.add(SecureHashUtil.makeSHA1HashBase64(keys.get(i).toString().getBytes("UTF-8")));
+        }
+      } else {
+        ids = new ArrayList<>(1);
+        ids.add(SecureHashUtil.makeSHA1HashBase64(key.toString().getBytes("UTF-8")));
+      }
+      return ids;
     } catch (UnsupportedEncodingException e) {
       // This should never happen. All VMs support UTF-8
       throw new RuntimeException(e);
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorageSupplier.java b/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorageSupplier.java
deleted file mode 100644
index 70bf69561..000000000
--- a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DiskStorageSupplier.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2015-present, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the root directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- */
-
-package com.facebook.cache.disk;
-
-import java.io.IOException;
-
-/**
- * An interface to supply a DiskStorage instance
- */
-public interface DiskStorageSupplier {
-
-  /**
-   * Get a concrete instance of DiskStorage
-   * @return an instance of DiskStorage
-   * @throws IOException
-   */
-  DiskStorage get() throws IOException;
-}
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DefaultDiskStorageSupplier.java b/imagepipeline-base/src/main/java/com/facebook/cache/disk/DynamicDefaultDiskStorage.java
similarity index 59%
rename from imagepipeline-base/src/main/java/com/facebook/cache/disk/DefaultDiskStorageSupplier.java
rename to imagepipeline-base/src/main/java/com/facebook/cache/disk/DynamicDefaultDiskStorage.java
index ddcc24e0c..80de24273 100644
--- a/imagepipeline-base/src/main/java/com/facebook/cache/disk/DefaultDiskStorageSupplier.java
+++ b/imagepipeline-base/src/main/java/com/facebook/cache/disk/DynamicDefaultDiskStorage.java
@@ -13,7 +13,9 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.util.Collection;
 
+import com.facebook.binaryresource.BinaryResource;
 import com.facebook.cache.common.CacheErrorLogger;
 import com.facebook.common.file.FileTree;
 import com.facebook.common.file.FileUtils;
@@ -25,8 +27,8 @@
 /**
  * A supplier of a DiskStorage concrete implementation.
  */
-public class DefaultDiskStorageSupplier implements DiskStorageSupplier {
-  private static final Class<?> TAG = DefaultDiskStorageSupplier.class;
+public class DynamicDefaultDiskStorage implements DiskStorage {
+  private static final Class<?> TAG = DynamicDefaultDiskStorage.class;
 
   private final int mVersion;
   private final Supplier<File> mBaseDirectoryPathSupplier;
@@ -40,16 +42,16 @@
    * Represents the current 'cached' state.
    */
   @VisibleForTesting static class State {
-    public final @Nullable DiskStorage storage;
+    public final @Nullable DiskStorage delegate;
     public final @Nullable File rootDirectory;
 
-    @VisibleForTesting State(@Nullable File rootDirectory, @Nullable DiskStorage storage) {
-      this.storage = storage;
+    @VisibleForTesting State(@Nullable File rootDirectory, @Nullable DiskStorage delegate) {
+      this.delegate = delegate;
       this.rootDirectory = rootDirectory;
     }
   }
 
-  public DefaultDiskStorageSupplier(
+  public DynamicDefaultDiskStorage(
       int version,
       Supplier<File> baseDirectoryPathSupplier,
       String baseDirectoryName,
@@ -61,32 +63,97 @@ public DefaultDiskStorageSupplier(
     mCurrentState = new State(null, null);
   }
 
+  @Override
+  public boolean isEnabled() {
+    try {
+      return get().isEnabled();
+    } catch (IOException ioe) {
+      return false;
+    }
+  }
+
+  @Override
+  public BinaryResource getResource(String resourceId, Object debugInfo) throws IOException {
+    return get().getResource(resourceId, debugInfo);
+  }
+
+  @Override
+  public boolean contains(String resourceId, Object debugInfo) throws IOException {
+    return get().contains(resourceId, debugInfo);
+  }
+
+  @Override
+  public boolean touch(String resourceId, Object debugInfo) throws IOException {
+    return get().touch(resourceId, debugInfo);
+  }
+
+  @Override
+  public void purgeUnexpectedResources() {
+    try {
+      get().purgeUnexpectedResources();
+    } catch (IOException ioe) {
+      // this method in fact should throu IOException
+      // for now we will swallow the exception as it's done in DefaultDiskStorage
+      FLog.e(TAG, "purgeUnexpectedResources", ioe);
+    }
+  }
+
+  @Override
+  public Inserter insert(String resourceId, Object debugInfo) throws IOException {
+    return get().insert(resourceId, debugInfo);
+  }
+
+  @Override
+  public Collection<Entry> getEntries() throws IOException {
+    return get().getEntries();
+  }
+
+  @Override
+  public long remove(Entry entry) throws IOException {
+    return get().remove(entry);
+  }
+
+  @Override
+  public long remove(String resourceId) throws IOException {
+    return get().remove(resourceId);
+  }
+
+  @Override
+  public void clearAll() throws IOException {
+    get().clearAll();
+  }
+
+  @Override
+  public DiskDumpInfo getDumpInfo() throws IOException {
+    return get().getDumpInfo();
+  }
+
   /**
    * Gets a concrete disk-storage instance. If nothing has changed since the last call, then
    * the last state is returned
    * @return an instance of the appropriate DiskStorage class
    * @throws IOException
    */
-  @Override
-  public synchronized DiskStorage get() throws IOException {
+  @VisibleForTesting
+  /* package protected */ synchronized DiskStorage get() throws IOException {
     if (shouldCreateNewStorage()) {
       // discard anything we created
       deleteOldStorageIfNecessary();
       createStorage();
     }
-    return Preconditions.checkNotNull(mCurrentState.storage);
+    return Preconditions.checkNotNull(mCurrentState.delegate);
   }
 
   private boolean shouldCreateNewStorage() {
     State currentState = mCurrentState;
-    return (currentState.storage == null ||
+    return (currentState.delegate == null ||
         currentState.rootDirectory == null ||
         !currentState.rootDirectory.exists());
   }
 
   @VisibleForTesting
   void deleteOldStorageIfNecessary() {
-    if (mCurrentState.storage != null && mCurrentState.rootDirectory != null) {
+    if (mCurrentState.delegate != null && mCurrentState.rootDirectory != null) {
       // LATER: Actually delegate this call to the storage. We shouldn't be
       // making an end-run around it
       FileTree.deleteRecursively(mCurrentState.rootDirectory);
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/disk/FileCache.java b/imagepipeline-base/src/main/java/com/facebook/cache/disk/FileCache.java
index 801e2077e..6e4b59efe 100644
--- a/imagepipeline-base/src/main/java/com/facebook/cache/disk/FileCache.java
+++ b/imagepipeline-base/src/main/java/com/facebook/cache/disk/FileCache.java
@@ -34,6 +34,16 @@
    */
   BinaryResource getResource(CacheKey key);
 
+  /**
+   * Returns true if the key is in the in-memory key index.
+   *
+   * Not guaranteed to be correct. The cache may yet have this key even if this returns false.
+   * But if it returns true, it definitely has it.
+   *
+   * Avoids a disk read.
+   */
+  boolean hasKeySync(CacheKey key);
+
   boolean hasKey(CacheKey key);
   boolean probe(CacheKey key);
 
diff --git a/imagepipeline-base/src/main/java/com/facebook/cache/disk/ScoreBasedEvictionComparatorSupplier.java b/imagepipeline-base/src/main/java/com/facebook/cache/disk/ScoreBasedEvictionComparatorSupplier.java
new file mode 100644
index 000000000..8a3cf74b8
--- /dev/null
+++ b/imagepipeline-base/src/main/java/com/facebook/cache/disk/ScoreBasedEvictionComparatorSupplier.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.cache.disk;
+
+import com.facebook.common.internal.VisibleForTesting;
+
+/**
+ * Evicts cache items based on a mix of their size and timestamp.
+ */
+public class ScoreBasedEvictionComparatorSupplier implements EntryEvictionComparatorSupplier {
+
+  private final float mAgeWeight;
+  private final float mSizeWeight;
+
+  public ScoreBasedEvictionComparatorSupplier(float ageWeight, float sizeWeight) {
+    mAgeWeight = ageWeight;
+    mSizeWeight = sizeWeight;
+  }
+
+  @Override
+  public EntryEvictionComparator get() {
+    return new EntryEvictionComparator() {
+
+      long now = System.currentTimeMillis();
+
+      /**
+       * Return <0 if lhs should be evicted before rhs.
+       */
+      @Override
+      public int compare(DiskStorage.Entry lhs, DiskStorage.Entry rhs) {
+        float score1 = calculateScore(lhs, now);
+        float score2 = calculateScore(rhs, now);
+        return score1 < score2 ? 1 : ((score2 == score1) ? 0 : -1);
+      }
+    };
+  }
+
+  /**
+   * Calculates an eviction score.
+   *
+   * Entries with a higher eviction score should be evicted first.
+   */
+  @VisibleForTesting
+  float calculateScore(DiskStorage.Entry entry, long now) {
+    long ageMs = now - entry.getTimestamp();
+    long bytes = entry.getSize();
+    return mAgeWeight * ageMs + mSizeWeight * bytes;
+  }
+}
diff --git a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactory.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactory.java
new file mode 100644
index 000000000..7cf52d4a3
--- /dev/null
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactory.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.animated.factory;
+
+
+import android.graphics.drawable.Drawable;
+
+import com.facebook.imagepipeline.image.CloseableImage;
+
+/**
+ * Factory for instances of {@link AnimatedDrawable}.
+ */
+public interface AnimatedDrawableFactory {
+
+  /**
+   * Creates an {@link AnimatedDrawable} based on an {@link AnimatedImage}.
+   *
+   * @param closeableImage the result of the code
+   * @return a newly constructed {@link Drawable}
+   */
+  Drawable create(CloseableImage closeableImage);
+
+
+}
diff --git a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactory.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactory.java
new file mode 100644
index 000000000..dd26e9c72
--- /dev/null
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactory.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+package com.facebook.imagepipeline.animated.factory;
+
+import javax.annotation.concurrent.NotThreadSafe;
+import java.util.concurrent.ScheduledExecutorService;
+
+import android.content.Context;
+import android.content.res.Resources;
+import com.facebook.common.time.MonotonicClock;
+import com.facebook.common.executors.SerialExecutorService;
+import com.facebook.imagepipeline.animated.factory.AnimatedDrawableFactory;
+import com.facebook.imagepipeline.animated.factory.AnimatedImageFactory;
+
+@NotThreadSafe
+public interface AnimatedFactory {
+
+  AnimatedDrawableFactory getAnimatedDrawableFactory(Context context);
+
+  AnimatedImageFactory getAnimatedImageFactory();
+
+}
diff --git a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactoryProvider.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactoryProvider.java
new file mode 100644
index 000000000..50e846259
--- /dev/null
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedFactoryProvider.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+package com.facebook.imagepipeline.animated.factory;
+
+import java.lang.reflect.Constructor;
+
+import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
+import com.facebook.imagepipeline.core.ExecutorSupplier;
+
+public class AnimatedFactoryProvider {
+
+  private static boolean sImplLoaded;
+
+  private static AnimatedFactory sImpl = null;
+
+  public static AnimatedFactory getAnimatedFactory(
+      PlatformBitmapFactory platformBitmapFactory,
+      ExecutorSupplier executorSupplier) {
+    if (!sImplLoaded) {
+      try {
+        final Class<?> clazz =
+            Class.forName("com.facebook.imagepipeline.animated.factory.AnimatedFactoryImplSupport");
+        final Constructor<?> constructor = clazz.getConstructor(
+            PlatformBitmapFactory.class,
+            ExecutorSupplier.class);
+        sImpl = (AnimatedFactory) constructor.newInstance(
+            platformBitmapFactory,
+            executorSupplier);
+      } catch (Throwable e) {
+        // Head in the sand
+      }
+      if (sImpl != null) {
+        sImplLoaded = true;
+        return sImpl;
+      }
+      try {
+        final Class<?> clazz =
+            Class.forName("com.facebook.imagepipeline.animated.factory.AnimatedFactoryImpl");
+        final Constructor<?> constructor = clazz.getConstructor(
+            PlatformBitmapFactory.class,
+            ExecutorSupplier.class);
+        sImpl = (AnimatedFactory) constructor.newInstance(
+            platformBitmapFactory,
+            executorSupplier);
+      } catch (Throwable e) {
+        // Head in the sand
+      }
+      sImplLoaded = true;
+    }
+    return sImpl;
+  }
+
+}
diff --git a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactory.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactory.java
new file mode 100644
index 000000000..5a0f1c582
--- /dev/null
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.animated.factory;
+
+import android.graphics.Bitmap;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.common.ImageDecodeOptions;
+import com.facebook.imagepipeline.image.CloseableImage;
+
+/**
+ * Decoder for animated images.
+ */
+public interface AnimatedImageFactory {
+
+  /**
+   * Decodes a GIF into a CloseableImage.
+   * @param encodedImage encoded image (native byte array holding the encoded bytes and meta data)
+   * @param options the options for the decode
+   * @param bitmapConfig the Bitmap.Config used to generate the output bitmaps
+   * @return a {@link CloseableImage} for the GIF image
+   */
+  public CloseableImage decodeGif(
+      final EncodedImage encodedImage,
+      final ImageDecodeOptions options,
+      final Bitmap.Config bitmapConfig);
+
+  /**
+   * Decode a WebP into a CloseableImage.
+   * @param encodedImage encoded image (native byte array holding the encoded bytes and meta data)
+   * @param options the options for the decode
+   * @param bitmapConfig the Bitmap.Config used to generate the output bitmaps
+   * @return a {@link CloseableImage} for the WebP image
+   */
+  public CloseableImage decodeWebP(
+      final EncodedImage encodedImage,
+      final ImageDecodeOptions options,
+      final Bitmap.Config bitmapConfig);
+
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/PlatformBitmapFactory.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/bitmaps/PlatformBitmapFactory.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/PlatformBitmapFactory.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/bitmaps/PlatformBitmapFactory.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapCountingMemoryCacheFactory.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/BitmapCountingMemoryCacheFactory.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapCountingMemoryCacheFactory.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/BitmapCountingMemoryCacheFactory.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheTrimStrategy.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheTrimStrategy.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheTrimStrategy.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheTrimStrategy.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingLruMap.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/CountingLruMap.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingLruMap.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/CountingLruMap.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
similarity index 99%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
index dc3c76194..5d91aed7e 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
@@ -131,7 +131,7 @@ public CountingMemoryCache(
     mCacheTrimStrategy = cacheTrimStrategy;
     mMemoryCacheParamsSupplier = memoryCacheParamsSupplier;
     mMemoryCacheParams = mMemoryCacheParamsSupplier.get();
-    mLastCacheParamsCheck = SystemClock.elapsedRealtime();
+    mLastCacheParamsCheck = SystemClock.uptimeMillis();
   }
 
   private ValueDescriptor<Entry<K, V>> wrapValueDescriptor(
@@ -363,10 +363,10 @@ public void trim(MemoryTrimType trimType) {
    * Updates the cache params (constraints) if enough time has passed since the last update.
    */
   private synchronized void maybeUpdateCacheParams() {
-    if (mLastCacheParamsCheck + PARAMS_INTERCHECK_INTERVAL_MS > SystemClock.elapsedRealtime()) {
+    if (mLastCacheParamsCheck + PARAMS_INTERCHECK_INTERVAL_MS > SystemClock.uptimeMillis()) {
       return;
     }
-    mLastCacheParamsCheck = SystemClock.elapsedRealtime();
+    mLastCacheParamsCheck = SystemClock.uptimeMillis();
     mMemoryCacheParams = mMemoryCacheParamsSupplier.get();
   }
 
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCache.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/MemoryCache.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCache.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/MemoryCache.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheParams.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheParams.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheParams.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheParams.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/ValueDescriptor.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/ValueDescriptor.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/cache/ValueDescriptor.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/ValueDescriptor.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptions.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptions.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptions.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptions.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptionsBuilder.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptionsBuilder.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptionsBuilder.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptionsBuilder.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/Priority.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/Priority.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/common/Priority.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/Priority.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ResizeOptions.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/ResizeOptions.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/common/ResizeOptions.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/ResizeOptions.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/TooManyBitmapsException.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/TooManyBitmapsException.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/common/TooManyBitmapsException.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/TooManyBitmapsException.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DefaultExecutorSupplier.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/core/DefaultExecutorSupplier.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/core/DefaultExecutorSupplier.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/core/DefaultExecutorSupplier.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ExecutorSupplier.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/core/ExecutorSupplier.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/core/ExecutorSupplier.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/core/ExecutorSupplier.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/PriorityThreadFactory.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/core/PriorityThreadFactory.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/core/PriorityThreadFactory.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/core/PriorityThreadFactory.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/ByteArrayPool.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/ByteArrayPool.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/memory/ByteArrayPool.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/ByteArrayPool.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Pool.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/Pool.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Pool.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/Pool.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStream.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStream.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStream.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStream.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBuffer.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteBuffer.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBuffer.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteBuffer.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferFactory.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferFactory.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferFactory.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferFactory.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStream.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStream.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStream.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStream.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferOutputStream.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferOutputStream.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferOutputStream.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferOutputStream.java
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteStreams.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteStreams.java
similarity index 100%
rename from imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteStreams.java
rename to imagepipeline-base/src/main/java/com/facebook/imagepipeline/memory/PooledByteStreams.java
diff --git a/imagepipeline-base/src/test/java/com/facebook/cache/disk/DefaultDiskStorageTest.java b/imagepipeline-base/src/test/java/com/facebook/cache/disk/DefaultDiskStorageTest.java
index 4b8432699..b143dd9f7 100644
--- a/imagepipeline-base/src/test/java/com/facebook/cache/disk/DefaultDiskStorageTest.java
+++ b/imagepipeline-base/src/test/java/com/facebook/cache/disk/DefaultDiskStorageTest.java
@@ -22,6 +22,7 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
+import com.facebook.binaryresource.BinaryResource;
 import com.facebook.binaryresource.FileBinaryResource;
 import com.facebook.cache.common.CacheErrorLogger;
 import com.facebook.cache.common.WriterCallback;
@@ -39,9 +40,10 @@
 import org.powermock.core.classloader.annotations.PowerMockIgnore;
 import org.powermock.core.classloader.annotations.PrepareOnlyThisForTest;
 import org.powermock.modules.junit4.rule.PowerMockRule;
-import org.robolectric.*;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -119,7 +121,7 @@ public void testBasicOperations() throws Exception {
     final String resourceId2 = "R2";
 
     // no file - get should fail
-    FileBinaryResource resource1 = storage.getResource(resourceId1, null);
+    BinaryResource resource1 = storage.getResource(resourceId1, null);
     Assert.assertNull(resource1);
 
     // write out the file now
@@ -128,13 +130,14 @@ public void testBasicOperations() throws Exception {
     // get should succeed now
     resource1 = storage.getResource(resourceId1, null);
     Assert.assertNotNull(resource1);
-    Assert.assertArrayEquals(key1Contents, Files.toByteArray(resource1.getFile()));
+    File underlyingFile = ((FileBinaryResource) resource1).getFile();
+    Assert.assertArrayEquals(key1Contents, Files.toByteArray(underlyingFile));
     // remove the file now - get should fail again
-    Assert.assertTrue(resource1.getFile().delete());
+    Assert.assertTrue(underlyingFile.delete());
     resource1 = storage.getResource(resourceId1, null);
     Assert.assertNull(resource1);
     // no file
-    FileBinaryResource resource2 = storage.getResource(resourceId2, null);
+    BinaryResource resource2 = storage.getResource(resourceId2, null);
     Assert.assertNull(resource2);
   }
 
@@ -280,6 +283,46 @@ public void testRemoveById() throws Exception {
     assertFalse(storage.contains(resourceId3, null));
   }
 
+  @Test
+  public void testEntryIds() throws Exception {
+    DefaultDiskStorage storage = getStorageSupplier(1).get();
+
+    final byte[] value1 = new byte[101];
+    final byte[] value2 = new byte[102];
+    final byte[] value3 = new byte[103];
+    value1[80] = 123;
+    value2[80] = 45;
+    value3[80] = 67;
+    writeFileToStorage(storage, "resourceId1", value1);
+    writeFileToStorage(storage, "resourceId2", value2);
+    writeFileToStorage(storage, "resourceId3", value3);
+
+    // check that resources are retrieved by the right name, before testing getEntries
+    BinaryResource res1 = storage.getResource("resourceId1", null);
+    BinaryResource res2 = storage.getResource("resourceId2", null);
+    BinaryResource res3 = storage.getResource("resourceId3", null);
+    assertArrayEquals(value1, res1.read());
+    assertArrayEquals(value2, res2.read());
+    assertArrayEquals(value3, res3.read());
+
+    // obtain entries and sort by name
+    List<DiskStorage.Entry> entries = new ArrayList<>(storage.getEntries());
+    Collections.sort(entries, new Comparator<DiskStorage.Entry>() {
+      @Override
+      public int compare(DiskStorage.Entry lhs, DiskStorage.Entry rhs) {
+        return lhs.getId().compareTo(rhs.getId());
+      }
+    });
+
+    assertEquals(3, entries.size());
+    assertEquals("resourceId1", entries.get(0).getId());
+    assertEquals("resourceId2", entries.get(1).getId());
+    assertEquals("resourceId3", entries.get(2).getId());
+    assertArrayEquals(value1, entries.get(0).getResource().read());
+    assertArrayEquals(value2, entries.get(1).getResource().read());
+    assertArrayEquals(value3, entries.get(2).getResource().read());
+  }
+
   @Test
   public void testEntryImmutable() throws Exception {
     DefaultDiskStorage storage = getStorageSupplier(1).get();
@@ -309,7 +352,8 @@ public void testTempFileEviction() throws IOException {
     DefaultDiskStorage storage = getStorageSupplier(1).get();
 
     final String resourceId1 = "resource1";
-    final File tempFile = storage.createTemporary(resourceId1, null).getFile();
+    DiskStorage.Inserter inserter = storage.insert(resourceId1, null);
+    final File tempFile = ((DefaultDiskStorage.InserterImpl) inserter).mTemporaryFile;
 
     // Make sure that we don't evict a recent temp file
     purgeUnexpectedFiles(storage);
@@ -330,7 +374,7 @@ public void testTempFileEviction() throws IOException {
    */
   @Test
   public void testPurgeUnexpectedFiles() throws Exception {
-    final DiskStorage storage = getStorageSupplier(1).get();
+    final DefaultDiskStorage storage = getStorageSupplier(1).get();
 
     final String resourceId = "file1";
     final byte[] CONTENT = "content".getBytes("UTF-8");
@@ -412,15 +456,15 @@ public void testDirectoryIsNuked() throws Exception {
   public void testDirectoryIsNotNuked() throws Exception {
     Assert.assertEquals(0, mDirectory.listFiles().length);
 
-    final DiskStorage storage = getStorageSupplier(1).get();
+    final DefaultDiskStorage storage = getStorageSupplier(1).get();
     final String resourceId = "file1";
 
     final byte[] CONTENT = "content".getBytes("UTF-8");
 
     // create a file so we know version directory really exists
-    FileBinaryResource temporary = storage.createTemporary(resourceId, null);
-    writeToResource(storage, resourceId, temporary, CONTENT);
-    storage.commit(resourceId, temporary, null);
+    DiskStorage.Inserter inserter = storage.insert(resourceId, null);
+    writeToResource(inserter, CONTENT);
+    inserter.commit(null);
 
     // assign some previous date to the "now" used for file creation
     long lastModified = mDirectory.lastModified() - 1000;
@@ -444,7 +488,7 @@ public void testDirectoryIsNotNuked() throws Exception {
    */
   @Test
   public void testIterationAndRemoval() throws Exception {
-    DiskStorage storage = getStorageSupplier(1).get();
+    DefaultDiskStorage storage = getStorageSupplier(1).get();
     final String resourceId0 = "file0";
     final String resourceId1 = "file1";
     final String resourceId2 = "file2";
@@ -486,48 +530,47 @@ public void testIterationAndRemoval() throws Exception {
   }
 
   private static FileBinaryResource writeToStorage(
-      final DiskStorage storage,
+      final DefaultDiskStorage storage,
       final String resourceId,
       final byte[] value) throws IOException {
-    FileBinaryResource temporary = storage.createTemporary(resourceId, null);
-    writeToResource(storage, resourceId, temporary, value);
-    FileBinaryResource resource = storage.commit(resourceId, temporary, null);
-    return resource;
+    DiskStorage.Inserter inserter = storage.insert(resourceId, null);
+    writeToResource(inserter, value);
+    return (FileBinaryResource) inserter.commit(null);
   }
 
   private static File writeFileToStorage(
-      DiskStorage storage,
+      DefaultDiskStorage storage,
       String resourceId,
       byte[] value) throws IOException {
     return writeToStorage(storage, resourceId, value).getFile();
   }
 
   private static File write(
-      DiskStorage storage,
+      DefaultDiskStorage storage,
       String resourceId,
       byte[] content) throws IOException {
-    FileBinaryResource temporary = storage.createTemporary(resourceId, null);
-    File file = temporary.getFile();
+    DiskStorage.Inserter inserter = storage.insert(resourceId, null);
+    File file = ((DefaultDiskStorage.InserterImpl) inserter).mTemporaryFile;
     FileOutputStream fos = new FileOutputStream(file);
     try {
       fos.write(content);
     } finally {
       fos.close();
     }
-    return storage.commit(resourceId, temporary, null).getFile();
+    return ((FileBinaryResource) inserter.commit(null)).getFile();
   }
 
   private static void writeToResource(
-      DiskStorage storage,
-      String resourceId,
-      FileBinaryResource resource,
+      DiskStorage.Inserter inserter,
       final byte[] content) throws IOException {
-    storage.updateResource(resourceId, resource, new WriterCallback() {
-      @Override
-      public void write(OutputStream os) throws IOException {
-        os.write(content);
-      }
-    }, null);
+    inserter.writeData(
+        new WriterCallback() {
+            @Override
+            public void write(OutputStream os) throws IOException {
+              os.write(content);
+            }
+        },
+        null);
   }
 
   private void purgeUnexpectedFiles(DefaultDiskStorage storage)
@@ -564,7 +607,7 @@ private void findNewFiles(
    * @param storage
    */
   private static List<DefaultDiskStorage.EntryImpl> retrieveEntries(
-      DiskStorage storage)
+      DefaultDiskStorage storage)
       throws IOException {
     List<DiskStorage.Entry> entries = new ArrayList<>(storage.getEntries());
 
@@ -578,7 +621,7 @@ public int compare(DefaultDiskStorage.Entry a, DefaultDiskStorage.Entry b) {
     });
     List<DefaultDiskStorage.EntryImpl> newEntries = new ArrayList<>();
     for (DiskStorage.Entry entry: entries) {
-      newEntries.add((DefaultDiskStorage.EntryImpl)entry);
+      newEntries.add((DefaultDiskStorage.EntryImpl) entry);
     }
     return newEntries;
   }
diff --git a/imagepipeline-base/src/test/java/com/facebook/cache/disk/DiskStorageCacheTest.java b/imagepipeline-base/src/test/java/com/facebook/cache/disk/DiskStorageCacheTest.java
index 0f7108190..6ec9e9e1a 100644
--- a/imagepipeline-base/src/test/java/com/facebook/cache/disk/DiskStorageCacheTest.java
+++ b/imagepipeline-base/src/test/java/com/facebook/cache/disk/DiskStorageCacheTest.java
@@ -34,7 +34,6 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
 import org.powermock.api.mockito.PowerMockito;
 import org.powermock.core.classloader.annotations.PowerMockIgnore;
 import org.powermock.core.classloader.annotations.PrepareOnlyThisForTest;
@@ -73,7 +72,7 @@
   private static final int TESTCACHE_NEXT_VERSION = TESTCACHE_CURRENT_VERSION + 1;
 
   private File mCacheDirectory;
-  private DiskStorageSupplier mStorageSupplier;
+  private DiskStorage mStorage;
   private DiskStorageCache mCache;
   private DiskTrimmableRegistry mDiskTrimmableRegistry;
   private CacheEventListener mCacheEventListener;
@@ -98,8 +97,8 @@ public void setUp() {
               mCacheDirectory.getAbsolutePath(),
               mCacheDirectory.exists() ? "already exists" : "does not exist"));
     }
-    mStorageSupplier = createDiskStorageSupplier(TESTCACHE_VERSION_START_OF_VERSIONING);
-    mCache = createDiskCache(mStorageSupplier);
+    mStorage = createDiskStorage(TESTCACHE_VERSION_START_OF_VERSIONING);
+    mCache = createDiskCache(mStorage);
     verify(mDiskTrimmableRegistry).registerDiskTrimmable(mCache);
   }
 
@@ -107,15 +106,15 @@ public void setUp() {
   private static final long FILE_CACHE_MAX_SIZE_HIGH_LIMIT = 200;
   private static final long FILE_CACHE_MAX_SIZE_LOW_LIMIT = 200;
 
-  private DiskStorageSupplier createDiskStorageSupplier(int version) {
-    return new DefaultDiskStorageSupplier(
+  private static DiskStorage createDiskStorage(int version) {
+    return new DynamicDefaultDiskStorage(
         version,
         Suppliers.of(RuntimeEnvironment.application.getApplicationContext().getCacheDir()),
         CACHE_TYPE,
         mock(CacheErrorLogger.class));
   }
 
-  private DiskStorageCache createDiskCache(DiskStorageSupplier diskStorageSupplier) {
+  private DiskStorageCache createDiskCache(DiskStorage diskStorage) {
     DiskStorageCache.Params diskStorageCacheParams =
         new DiskStorageCache.Params(
             0,
@@ -123,7 +122,7 @@ private DiskStorageCache createDiskCache(DiskStorageSupplier diskStorageSupplier
             FILE_CACHE_MAX_SIZE_HIGH_LIMIT);
 
     return new DiskStorageCache(
-        diskStorageSupplier,
+        diskStorage,
         new DefaultEntryEvictionComparatorSupplier(),
         diskStorageCacheParams,
         mCacheEventListener,
@@ -156,13 +155,13 @@ public void testCacheEventListener() throws Exception {
 
 
   private BinaryResource getResource(
-      DiskStorageSupplier supplier,
+      DiskStorage storage,
       final CacheKey key) throws IOException {
-     return supplier.get().getResource(mCache.getResourceId(key), key);
+     return storage.getResource(mCache.getResourceIds(key).get(0), key);
   }
 
   private BinaryResource getResource(final CacheKey key) throws IOException {
-    return mStorageSupplier.get().getResource(mCache.getResourceId(key), key);
+    return mStorage.getResource(mCache.getResourceIds(key).get(0), key);
   }
 
   private byte[] getContents(BinaryResource resource) throws IOException {
@@ -199,14 +198,6 @@ public void testCacheFile() throws Exception {
     assertArrayEquals(value1, getContents(getResource(key1)));
 
     // 1. Touch the LRU file, and assert that it succeeds.
-    // Note: It might seem more natural to increment the clock before calling
-    // MediaCache.insertCachedMedia() to apply a desired timestamp to the
-    // files. But the time is being explicitly modified here so that any
-    // failures in setting/re-setting file timestamps are caught by the assert,
-    // instead of being hidden inside MediaCache code that can lead to
-    // intermittent test failures which are very tricky to debug.
-    // Note: For MediaCache.markForLru() to update the lru time, the clock
-    // needs to be incremented by at least MediaCache.CACHE_UPDATE_PERIOD_MS
     when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(2));
     assertTrue(mCache.probe(key1));
 
@@ -398,19 +389,19 @@ public void testVersioning() throws IOException {
     value[0] = 'v';
 
     // Set up cache with version == 1
-    DiskStorageSupplier storageSupplier1 = createDiskStorageSupplier(TESTCACHE_CURRENT_VERSION);
-    DiskStorageCache cache1 = createDiskCache(storageSupplier1);
+    DiskStorage storage1 = createDiskStorage(TESTCACHE_CURRENT_VERSION);
+    DiskStorageCache cache1 = createDiskCache(storage1);
 
     // Write test data to cache 1
     cache1.insert(key, WriterCallbacks.from(value));
 
     // Get cached file
-    BinaryResource resource1 = getResource(storageSupplier1, key);
+    BinaryResource resource1 = getResource(storage1, key);
     assertNotNull(resource1);
 
     // Set up cache with version == 2
-    DiskStorageSupplier storageSupplier2 =
-        createDiskStorageSupplier(TESTCACHE_NEXT_VERSION);
+    DiskStorage storageSupplier2 =
+        createDiskStorage(TESTCACHE_NEXT_VERSION);
     DiskStorageCache cache2 = createDiskCache(storageSupplier2);
 
     // Write test data to cache 2
@@ -456,10 +447,8 @@ public void write(OutputStream os) throws IOException {
   public void testIsEnabled() throws Exception {
     DiskStorage storageMock = mock(DiskStorage.class);
     when(storageMock.isEnabled()).thenReturn(true).thenReturn(false);
-    DiskStorageSupplier supplierMock = mock(DiskStorageSupplier.class);
-    when(supplierMock.get()).thenReturn(storageMock);
 
-    DiskStorageCache cache = createDiskCache(supplierMock);
+    DiskStorageCache cache = createDiskCache(storageMock);
     assertTrue(cache.isEnabled());
     assertFalse(cache.isEnabled());
   }
@@ -483,4 +472,100 @@ public void run() {
     return thread;
   }
 
+  @Test
+  public void testInsertionInIndex() throws Exception {
+    CacheKey key = putOneThingInCache();
+    assertTrue(mCache.hasKeySync(key));
+    assertTrue(mCache.hasKey(key));
+  }
+
+  @Test
+  public void testDoesntHaveKey() {
+    CacheKey key = new SimpleCacheKey("foo");
+    assertFalse(mCache.hasKeySync(key));
+    assertFalse(mCache.hasKey(key));
+  }
+
+  @Test
+  public void testHasKeyNotInIndex() throws Exception {
+    CacheKey key = putOneThingInCache();
+    // A new cache object in the same directory. Equivalent to a process restart
+    DiskStorageCache cache2 = createDiskCache(mStorage);
+    assertFalse(cache2.hasKeySync(key));
+    assertTrue(cache2.hasKey(key));
+    // Now that we checked disk, index should be updated
+    assertTrue(cache2.hasKeySync(key));
+  }
+
+  @Test
+  public void testReadRestoresIndex() throws Exception {
+    CacheKey key = putOneThingInCache();
+    DiskStorageCache cache2 = createDiskCache(mStorage);
+    assertFalse(cache2.hasKeySync(key));
+    assertNotNull(cache2.getResource(key));
+    // Now that we checked disk, index should be updated
+    assertTrue(cache2.hasKeySync(key));
+  }
+
+  @Test
+  public void testProbeRestoresIndex() throws Exception {
+    CacheKey key = putOneThingInCache();
+    DiskStorageCache cache2 = createDiskCache(mStorage);
+    assertFalse(cache2.hasKeySync(key));
+    assertTrue(cache2.probe(key));
+    assertTrue(cache2.hasKeySync(key));
+  }
+
+  @Test
+  public void testClearIndex() throws Exception {
+    CacheKey key = putOneThingInCache();
+    mCache.clearAll();
+    assertFalse(mCache.hasKeySync(key));
+    assertFalse(mCache.hasKey(key));
+  }
+
+  @Test
+  public void testRemoveFileClearsIndex() throws Exception {
+    CacheKey key = putOneThingInCache();
+    mStorage.clearAll();
+    assertNull(mCache.getResource(key));
+    assertFalse(mCache.hasKeySync(key));
+  }
+
+  @Test
+  public void testSizeEvictionClearsIndex() throws Exception {
+    when(mClock.now()).thenReturn(TimeUnit.MILLISECONDS.convert(1, TimeUnit.DAYS));
+    CacheKey key1 = putOneThingInCache();
+    CacheKey key2 = new SimpleCacheKey("bar");
+    CacheKey key3 = new SimpleCacheKey("duck");
+    byte[] value2 = new byte[(int) FILE_CACHE_MAX_SIZE_HIGH_LIMIT];
+    value2[80] = 'c';
+    WriterCallback callback = WriterCallbacks.from(value2);
+    when(mClock.now()).thenReturn(TimeUnit.MILLISECONDS.convert(2, TimeUnit.DAYS));
+    mCache.insert(key2, callback);
+    // now over limit. Next write will evict key1
+    when(mClock.now()).thenReturn(TimeUnit.MILLISECONDS.convert(3, TimeUnit.DAYS));
+    mCache.insert(key3, callback);
+    assertFalse(mCache.hasKeySync(key1));
+    assertFalse(mCache.hasKey(key1));
+    assertTrue(mCache.hasKeySync(key3));
+    assertTrue(mCache.hasKey(key3));
+  }
+
+  @Test
+  public void testTimeEvictionClearsIndex() throws Exception {
+    when(mClock.now()).thenReturn(5l);
+    CacheKey key = putOneThingInCache();
+    mCache.clearOldEntries(4);
+    assertFalse(mCache.hasKeySync(key));
+    assertFalse(mCache.hasKey(key));
+  }
+
+  private CacheKey putOneThingInCache() throws IOException {
+    CacheKey key = new SimpleCacheKey("foo");
+    byte[] value1 = new byte[101];
+    value1[80] = 'c';
+    mCache.insert(key, WriterCallbacks.from(value1));
+    return key;
+  }
 }
diff --git a/imagepipeline-base/src/test/java/com/facebook/cache/disk/DefaultDiskStorageSupplierTest.java b/imagepipeline-base/src/test/java/com/facebook/cache/disk/DynamicDefaultDiskStorageTest.java
similarity index 76%
rename from imagepipeline-base/src/test/java/com/facebook/cache/disk/DefaultDiskStorageSupplierTest.java
rename to imagepipeline-base/src/test/java/com/facebook/cache/disk/DynamicDefaultDiskStorageTest.java
index a7c7ab57a..d09c8b3c5 100644
--- a/imagepipeline-base/src/test/java/com/facebook/cache/disk/DefaultDiskStorageSupplierTest.java
+++ b/imagepipeline-base/src/test/java/com/facebook/cache/disk/DynamicDefaultDiskStorageTest.java
@@ -27,10 +27,10 @@
 import static org.mockito.Mockito.mock;
 
 /**
- * Test out methods in DefaultDiskStorageSupplier
+ * Test out methods in DynamicDefaultDiskStorage
  */
 @RunWith(RobolectricTestRunner.class)
-public class DefaultDiskStorageSupplierTest {
+public class DynamicDefaultDiskStorageTest {
 
   private int mVersion;
   private String mBaseDirectoryName;
@@ -45,8 +45,8 @@ public void setUp() {
     mCacheErrorLogger = mock(CacheErrorLogger.class);
   }
 
-  private DefaultDiskStorageSupplier createSupplier(boolean useFilesDirInsteadOfCacheDir) {
-    return new DefaultDiskStorageSupplier(
+  private DynamicDefaultDiskStorage createStorage(boolean useFilesDirInsteadOfCacheDir) {
+    return new DynamicDefaultDiskStorage(
         mVersion,
         useFilesDirInsteadOfCacheDir ?
             Suppliers.of(mContext.getFilesDir()) :
@@ -55,15 +55,15 @@ private DefaultDiskStorageSupplier createSupplier(boolean useFilesDirInsteadOfCa
         mCacheErrorLogger);
   }
 
-  private DefaultDiskStorageSupplier createInternalCacheDirSupplier() {
-    return createSupplier(false);
+  private DynamicDefaultDiskStorage createInternalCacheDirStorage() {
+    return createStorage(false);
   }
 
-  private DefaultDiskStorageSupplier createInternalFilesDirSupplier() {
-    return createSupplier(true);
+  private DynamicDefaultDiskStorage createInternalFilesDirStorage() {
+    return createStorage(true);
   }
 
-  private File getStorageSubdirectory(File rootDir, int version) {
+  private static File getStorageSubdirectory(File rootDir, int version) {
     return new File(rootDir, DefaultDiskStorage.getVersionSubdirectoryName(version));
   }
 
@@ -71,29 +71,29 @@ private File getStorageSubdirectory(File rootDir, int version) {
   public void testGet_InternalCacheDir() throws Exception {
     File cacheDir = mContext.getCacheDir();
 
-    DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
+    DynamicDefaultDiskStorage storage = createInternalCacheDirStorage();
 
     // initial state
-    Assert.assertNull(supplier.mCurrentState.storage);
+    Assert.assertNull(storage.mCurrentState.delegate);
 
     // after first initialization
-    DiskStorage storage = supplier.get();
-    Assert.assertEquals(storage, supplier.mCurrentState.storage);
-    Assert.assertTrue(storage instanceof DefaultDiskStorage);
+    DiskStorage delegate = storage.get();
+    Assert.assertEquals(delegate, storage.mCurrentState.delegate);
+    Assert.assertTrue(delegate instanceof DefaultDiskStorage);
 
     File baseDir = new File(cacheDir, mBaseDirectoryName);
     Assert.assertTrue(baseDir.exists());
     Assert.assertTrue(getStorageSubdirectory(baseDir, 1).exists());
 
     // no change => should get back the same storage instance
-    DiskStorage storage2 = supplier.get();
-    Assert.assertEquals(storage, storage2);
+    DiskStorage storage2 = storage.get();
+    Assert.assertEquals(delegate, storage2);
 
     // root directory has been moved (proxy for delete). So we should get back a different instance
     File baseDirOrig = baseDir.getAbsoluteFile();
     Assert.assertTrue(baseDirOrig.renameTo(new File(cacheDir, "dummydir")));
-    DiskStorage storage3 = supplier.get();
-    Assert.assertNotSame(storage, storage3);
+    DiskStorage storage3 = storage.get();
+    Assert.assertNotSame(delegate, storage3);
     Assert.assertTrue(storage3 instanceof DefaultDiskStorage);
     Assert.assertTrue(baseDir.exists());
     Assert.assertTrue(getStorageSubdirectory(baseDir, 1).exists());
@@ -103,14 +103,14 @@ public void testGet_InternalCacheDir() throws Exception {
   public void testGet_InternalFilesDir() throws Exception {
     File dir = mContext.getFilesDir();
 
-    DefaultDiskStorageSupplier supplier = createInternalFilesDirSupplier();
+    DynamicDefaultDiskStorage supplier = createInternalFilesDirStorage();
 
     // initial state
-    Assert.assertNull(supplier.mCurrentState.storage);
+    Assert.assertNull(supplier.mCurrentState.delegate);
 
     // after first initialization
     DiskStorage storage = supplier.get();
-    Assert.assertEquals(storage, supplier.mCurrentState.storage);
+    Assert.assertEquals(storage, supplier.mCurrentState.delegate);
     Assert.assertTrue(storage instanceof DefaultDiskStorage);
 
     File baseDir = new File(dir, mBaseDirectoryName);
@@ -133,8 +133,8 @@ public void testGet_InternalFilesDir() throws Exception {
 
   @Test
   public void testCreateRootDirectoryIfNecessary() throws Exception {
-    DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
-    Assert.assertNull(supplier.mCurrentState.storage);
+    DynamicDefaultDiskStorage supplier = createInternalCacheDirStorage();
+    Assert.assertNull(supplier.mCurrentState.delegate);
     File baseDir = new File(mContext.getCacheDir(), mBaseDirectoryName);
 
     // directory is clean
@@ -168,11 +168,11 @@ public void testCreateRootDirectoryIfNecessary() throws Exception {
 
   @Test
   public void testDeleteStorage() throws Exception {
-    DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
-    Assert.assertNull(supplier.mCurrentState.storage);
-    supplier.deleteOldStorageIfNecessary();
+    DynamicDefaultDiskStorage storage = createInternalCacheDirStorage();
+    Assert.assertNull(storage.mCurrentState.delegate);
+    storage.deleteOldStorageIfNecessary();
 
-    DefaultDiskStorage storage = (DefaultDiskStorage)supplier.get();
+    storage.get();
     File versionDir = getStorageSubdirectory(
         new File(mContext.getCacheDir(), mBaseDirectoryName),
         mVersion);
@@ -180,7 +180,7 @@ public void testDeleteStorage() throws Exception {
     File dummyFile = new File(versionDir, "dummy");
     Assert.assertTrue(dummyFile.createNewFile());
     Assert.assertTrue(dummyFile.exists());
-    supplier.deleteOldStorageIfNecessary();
+    storage.deleteOldStorageIfNecessary();
     Assert.assertFalse(dummyFile.exists());
     Assert.assertFalse(versionDir.exists());
     Assert.assertFalse(versionDir.getParentFile().exists());
@@ -188,7 +188,7 @@ public void testDeleteStorage() throws Exception {
 
   @Test
   public void testCreateStorage() throws Exception {
-    DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
+    DynamicDefaultDiskStorage storage = createInternalCacheDirStorage();
 
     File baseDir = new File(mContext.getCacheDir(), mBaseDirectoryName);
     File versionDir = getStorageSubdirectory(
@@ -197,7 +197,7 @@ public void testCreateStorage() throws Exception {
 
     Assert.assertFalse(versionDir.exists());
     Assert.assertFalse(baseDir.exists());
-    supplier.get();
+    storage.get();
     Assert.assertTrue(baseDir.exists());
     Assert.assertTrue(versionDir.exists());
   }
diff --git a/imagepipeline-base/src/test/java/com/facebook/cache/disk/ScoreBasedEvictionComparatorSupplierTest.java b/imagepipeline-base/src/test/java/com/facebook/cache/disk/ScoreBasedEvictionComparatorSupplierTest.java
new file mode 100644
index 000000000..edd3f874e
--- /dev/null
+++ b/imagepipeline-base/src/test/java/com/facebook/cache/disk/ScoreBasedEvictionComparatorSupplierTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.cache.disk;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.modules.junit4.PowerMockRunner;
+
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+/**
+ * Test for the score-based eviction comparator.
+ */
+@RunWith(PowerMockRunner.class)
+@PrepareForTest({System.class})
+public class ScoreBasedEvictionComparatorSupplierTest {
+
+  private static final long RANDOM_SEED = 42;
+
+  private List<DiskStorage.Entry> entries;
+
+  @Before
+  public void setUp() {
+    Random random = new Random(RANDOM_SEED);
+
+    PowerMockito.mockStatic(System.class);
+    when(System.currentTimeMillis()).thenReturn(0l);
+
+    entries = new ArrayList<>();
+    for (int i = 0; i < 100; i++) {
+      DiskStorage.Entry entry = mock(DiskStorage.Entry.class);
+      when(entry.getTimestamp()).thenReturn(random.nextLong());
+      when(entry.getSize()).thenReturn(random.nextLong());
+      entries.add(entry);
+    }
+  }
+
+  @Test
+  public void testTimestampOnlyOrder() {
+    doTest(1f, 0f);
+    for (int i = 0; i < entries.size() - 1; i++) {
+      assertTrue(entries.get(i).getTimestamp() < entries.get(i + 1).getTimestamp());
+    }
+  }
+
+  @Test
+  public void testSizeOnlyOrder() {
+    doTest(0f, 1f);
+    for (int i = 0; i < entries.size() - 1; i++) {
+      assertTrue(entries.get(i).getSize() > entries.get(i + 1).getSize());
+    }
+  }
+
+  @Test
+  public void testEqualOrder() {
+    doTest(1f, 1f);
+  }
+
+  @Test
+  public void testWeightedOrder() {
+    doTest(2f, 3f);
+  }
+
+  private void doTest(float ageWeight, float sizeWeight) {
+    ScoreBasedEvictionComparatorSupplier supplier =
+        new ScoreBasedEvictionComparatorSupplier(ageWeight, sizeWeight);
+    Collections.sort(entries, supplier.get());
+
+    for (int i = 0; i < entries.size() - 1; i++) {
+      assertTrue(supplier.calculateScore(entries.get(i), 0) >
+          supplier.calculateScore(entries.get(i + 1), 0));
+    }
+  }
+}
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/CountingLruMapTest.java b/imagepipeline-base/src/test/java/com/facebook/imagepipeline/cache/CountingLruMapTest.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/cache/CountingLruMapTest.java
rename to imagepipeline-base/src/test/java/com/facebook/imagepipeline/cache/CountingLruMapTest.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/CountingMemoryCacheTest.java b/imagepipeline-base/src/test/java/com/facebook/imagepipeline/cache/CountingMemoryCacheTest.java
similarity index 99%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/cache/CountingMemoryCacheTest.java
rename to imagepipeline-base/src/test/java/com/facebook/imagepipeline/cache/CountingMemoryCacheTest.java
index c4d75c5c9..9ecad98a4 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/CountingMemoryCacheTest.java
+++ b/imagepipeline-base/src/test/java/com/facebook/imagepipeline/cache/CountingMemoryCacheTest.java
@@ -63,7 +63,7 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     PowerMockito.mockStatic(SystemClock.class);
-    PowerMockito.when(SystemClock.elapsedRealtime()).thenReturn(0L);
+    PowerMockito.when(SystemClock.uptimeMillis()).thenReturn(0L);
     mValueDescriptor =
         new ValueDescriptor<Integer>() {
           @Override
@@ -402,7 +402,7 @@ public void testUpdatesCacheParams() {
     mCache.get(KEY);
     inOrder.verify(mParamsSupplier).get();
 
-    PowerMockito.when(SystemClock.elapsedRealtime())
+    PowerMockito.when(SystemClock.uptimeMillis())
         .thenReturn(CountingMemoryCache.PARAMS_INTERCHECK_INTERVAL_MS - 1);
     mCache.get(KEY);
     inOrder.verify(mParamsSupplier, never()).get();
@@ -420,7 +420,7 @@ public void testUpdatesCacheParams() {
         CACHE_ENTRY_MAX_SIZE);
     when(mParamsSupplier.get()).thenReturn(mParams);
 
-    PowerMockito.when(SystemClock.elapsedRealtime())
+    PowerMockito.when(SystemClock.uptimeMillis())
         .thenReturn(CountingMemoryCache.PARAMS_INTERCHECK_INTERVAL_MS);
     mCache.get(KEY);
     inOrder.verify(mParamsSupplier).get();
@@ -499,7 +499,7 @@ public void testTrimming() {
     MemoryTrimType memoryTrimType = MemoryTrimType.OnCloseToDalvikHeapLimit;
     mParams = new MemoryCacheParams(1100, 10, 1100, 10, 110);
     when(mParamsSupplier.get()).thenReturn(mParams);
-    PowerMockito.when(SystemClock.elapsedRealtime())
+    PowerMockito.when(SystemClock.uptimeMillis())
         .thenReturn(CountingMemoryCache.PARAMS_INTERCHECK_INTERVAL_MS);
     InOrder inOrder = inOrder(mReleaser);
 
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/image/EncodedImageTest.java b/imagepipeline-base/src/test/java/com/facebook/imagepipeline/image/EncodedImageTest.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/image/EncodedImageTest.java
rename to imagepipeline-base/src/test/java/com/facebook/imagepipeline/image/EncodedImageTest.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/image/images/image.jpg b/imagepipeline-base/src/test/resources/com/facebook/imagepipeline/image/images/image.jpg
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/image/images/image.jpg
rename to imagepipeline-base/src/test/resources/com/facebook/imagepipeline/image/images/image.jpg
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/image/images/image.png b/imagepipeline-base/src/test/resources/com/facebook/imagepipeline/image/images/image.png
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/image/images/image.png
rename to imagepipeline-base/src/test/resources/com/facebook/imagepipeline/image/images/image.png
diff --git a/imagepipeline-test/.gitignore b/imagepipeline-test/.gitignore
new file mode 100644
index 000000000..8afd910ce
--- /dev/null
+++ b/imagepipeline-test/.gitignore
@@ -0,0 +1 @@
+nativedeps/
diff --git a/imagepipeline-test/build.gradle b/imagepipeline-test/build.gradle
new file mode 100644
index 000000000..4a81b5eb7
--- /dev/null
+++ b/imagepipeline-test/build.gradle
@@ -0,0 +1,46 @@
+apply plugin: 'com.android.library'
+apply plugin: 'maven'
+
+project.group = GROUP
+version = VERSION_NAME
+
+dependencies {
+    provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    compile "com.parse.bolts:bolts-android:${BOLTS_ANDROID_VERSION}"
+    compile "com.nineoldandroids:library:${NINEOLDANDROID_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
+    provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
+    compile project(':fbcore')
+    compile project(':imagepipeline-base')
+
+    compile "junit:junit:${JUNIT_VERSION}"
+    compile "org.mockito:mockito-core:${MOCKITO_CORE_VERSION}"
+    compile("org.powermock:powermock-api-mockito:${POWERMOCK_VERSION}") {
+        exclude group: 'org.mockito', module: 'mockito-all'
+    }
+    compile "org.powermock:powermock-module-junit4-rule:${POWERMOCK_VERSION}"
+    compile "org.powermock:powermock-classloading-xstream:${POWERMOCK_VERSION}"
+    compile("org.robolectric:robolectric:${ROBOLECTRIC_VERSION}") {
+        exclude group: 'commons-logging', module: 'commons-logging'
+        exclude group: 'org.apache.httpcomponents', module: 'httpclient'
+    }
+}
+apply from: rootProject.file('release.gradle')
+
+android {
+
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    lintOptions {
+        abortOnError false
+    }
+
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+
+artifacts.add('archives', sourcesJar)
diff --git a/imagepipeline-test/gradle.properties b/imagepipeline-test/gradle.properties
new file mode 100644
index 000000000..af53f51f0
--- /dev/null
+++ b/imagepipeline-test/gradle.properties
@@ -0,0 +1,5 @@
+POM_NAME=ImagePipelineTest
+POM_DESCRIPTION=The library which contains utility classes for tests
+POM_ARTIFACT_ID=imagepipeline-test
+POM_PACKAGING=aar
+
diff --git a/imagepipeline-test/src/main/AndroidManifest.xml b/imagepipeline-test/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..c01eba83d
--- /dev/null
+++ b/imagepipeline-test/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.imagepipelinebase"
+    >
+
+  <uses-sdk
+      android:minSdkVersion="9"
+      android:targetSdkVersion="21"
+      />
+</manifest>
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/DeltaQueue.java b/imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/DeltaQueue.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/testing/DeltaQueue.java
rename to imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/DeltaQueue.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/FakeClock.java b/imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/FakeClock.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/testing/FakeClock.java
rename to imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/FakeClock.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/MockBitmapFactory.java b/imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/MockBitmapFactory.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/testing/MockBitmapFactory.java
rename to imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/MockBitmapFactory.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/ScheduledQueue.java b/imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/ScheduledQueue.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/testing/ScheduledQueue.java
rename to imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/ScheduledQueue.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TestExecutorService.java b/imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/TestExecutorService.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TestExecutorService.java
rename to imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/TestExecutorService.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TestScheduledExecutorService.java b/imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/TestScheduledExecutorService.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TestScheduledExecutorService.java
rename to imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/TestScheduledExecutorService.java
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TestScheduledFuture.java b/imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/TestScheduledFuture.java
similarity index 100%
rename from imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TestScheduledFuture.java
rename to imagepipeline-test/src/main/java/com/facebook/imagepipeline/testing/TestScheduledFuture.java
diff --git a/imagepipeline/build.gradle b/imagepipeline/build.gradle
index 95fcfd238..25b5d4aaf 100644
--- a/imagepipeline/build.gradle
+++ b/imagepipeline/build.gradle
@@ -13,16 +13,19 @@ dependencies {
     provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     compile "com.parse.bolts:bolts-android:${BOLTS_ANDROID_VERSION}"
     compile "com.nineoldandroids:library:${NINEOLDANDROID_VERSION}"
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
     provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
     compile project(':fbcore')
     compile project(':imagepipeline-base')
 
+    testCompile project(':imagepipeline-test')
+    testCompile project(':imagepipeline-base-test')
     testCompile "junit:junit:${JUNIT_VERSION}"
     testCompile "org.mockito:mockito-core:${MOCKITO_CORE_VERSION}"
     testCompile("org.powermock:powermock-api-mockito:${POWERMOCK_VERSION}") {
         exclude group: 'org.mockito', module: 'mockito-all'
     }
+    testCompile "org.powermock:powermock-module-junit4:${POWERMOCK_VERSION}"
     testCompile "org.powermock:powermock-module-junit4-rule:${POWERMOCK_VERSION}"
     testCompile "org.powermock:powermock-classloading-xstream:${POWERMOCK_VERSION}"
     testCompile("org.robolectric:robolectric:${ROBOLECTRIC_VERSION}") {
@@ -45,13 +48,6 @@ task createNativeDepsDirectories {
     mergeDir.mkdirs()
 }
 
-task downloadGiflib(dependsOn: createNativeDepsDirectories, type: Download) {
-    src 'http://downloads.sourceforge.net/project/giflib/giflib-5.1.1.tar.gz'
-    onlyIfNewer true
-    overwrite false
-    dest downloadsDir
-}
-
 task downloadLibjpeg(dependsOn: createNativeDepsDirectories, type: Download) {
     src 'http://downloads.sourceforge.net/project/libjpeg-turbo/1.3.1/libjpeg-turbo-1.3.1.tar.gz'
     onlyIfNewer true
@@ -59,35 +55,11 @@ task downloadLibjpeg(dependsOn: createNativeDepsDirectories, type: Download) {
     dest downloadsDir
 }
 
-task downloadLibwebp(dependsOn: createNativeDepsDirectories, type: Download) {
-    src 'https://github.com/webmproject/libwebp/archive/v0.4.3.tar.gz'
-    onlyIfNewer true
-    overwrite false
-    dest downloadsDir
-}
-
-task unpackGiflib(dependsOn: downloadGiflib, type: Copy) {
-    from tarTree(resources.gzip("${downloadGiflib.dest}/giflib-5.1.1.tar.gz"))
-    into "${downloadsDir}/giflib"
-}
-
 task unpackLibjpeg(dependsOn: downloadLibjpeg, type: Copy) {
     from tarTree(resources.gzip("${downloadLibjpeg.dest}/libjpeg-turbo-1.3.1.tar.gz"))
     into "${downloadsDir}/libjpeg"
 }
 
-task unpackLibwebp(dependsOn: downloadLibwebp, type: Copy) {
-    from tarTree(resources.gzip("${downloadLibwebp.dest}/v0.4.3.tar.gz"))
-    into "${downloadsDir}/libwebp"
-}
-
-task copyGiflib(dependsOn: unpackGiflib, type: Copy) {
-    from "${unpackGiflib.destinationDir}/giflib-5.1.1/lib"
-    from 'src/main/jni/third-party/giflib'
-    include('*.c', '*.h', '*.mk')
-    into "${mergeDir}/giflib"
-}
-
 task copyLibjpeg(dependsOn: unpackLibjpeg, type: Copy) {
     from "${unpackLibjpeg.destinationDir}/libjpeg-turbo-1.3.1"
     from 'src/main/jni/third-party/libjpeg-turbo-1.3.x'
@@ -95,14 +67,7 @@ task copyLibjpeg(dependsOn: unpackLibjpeg, type: Copy) {
     into "${mergeDir}/libjpeg-turbo-1.3.x"
 }
 
-task copyLibwebp(dependsOn: unpackLibwebp, type: Copy) {
-    from "${unpackLibwebp.destinationDir}/libwebp-0.4.3"
-    from 'src/main/jni/third-party/libwebp-0.4.3'
-    include('src/**/*.c', 'src/**/*.h', '*.mk')
-    into "${mergeDir}/libwebp-0.4.3"
-}
-
-task fetchNativeDeps(dependsOn: [copyGiflib, copyLibjpeg, copyLibwebp]) {
+task fetchNativeDeps(dependsOn: [copyLibjpeg]) {
 }
 
 task removeNativeDeps(type: Delete) {
@@ -169,10 +134,8 @@ def makeNdkTasks(String name, Object[] deps) {
 android {
     def ndkLibs = [
         ['bitmaps', []],
-        ['gifimage', [copyGiflib]],
-        ['imagepipeline', [copyLibjpeg, copyLibwebp]],
-        ['memchunk', []],
-        ['webpimage', [copyLibwebp]]]
+        ['imagepipeline', [copyLibjpeg]],
+        ['memchunk', []]]
 
     buildToolsVersion rootProject.ext.buildToolsVersion
     compileSdkVersion rootProject.ext.compileSdkVersion
@@ -187,6 +150,11 @@ android {
                 exclude '**/LocalVideoThumbnailProducerTest.java'
                 exclude '**/DecodeProducerTest.java'
                 exclude '**/ProgressiveJpegParserTest.java'
+                exclude '**/AnimatedImageFactoryTest.java'
+
+            }
+            resources {
+                exclude '**/BUCK'
             }
         }
     }
diff --git a/imagepipeline/src/main/gen/com/facebook/imagepipeline/BuildConfig.java b/imagepipeline/src/main/gen/com/facebook/imagepipeline/BuildConfig.java
new file mode 100644
index 000000000..c9a4e5c06
--- /dev/null
+++ b/imagepipeline/src/main/gen/com/facebook/imagepipeline/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.imagepipeline;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/imagepipeline/src/main/gen/com/facebook/imagepipeline/Manifest.java b/imagepipeline/src/main/gen/com/facebook/imagepipeline/Manifest.java
new file mode 100644
index 000000000..45b62c7a3
--- /dev/null
+++ b/imagepipeline/src/main/gen/com/facebook/imagepipeline/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.imagepipeline;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/imagepipeline/src/main/gen/com/facebook/imagepipeline/R.java b/imagepipeline/src/main/gen/com/facebook/imagepipeline/R.java
new file mode 100644
index 000000000..2267cadb2
--- /dev/null
+++ b/imagepipeline/src/main/gen/com/facebook/imagepipeline/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.imagepipeline;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheKey.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheKey.java
index 39e47c4b9..fee36cd7f 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheKey.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheKey.java
@@ -14,6 +14,8 @@
 
 import java.util.Locale;
 
+import android.net.Uri;
+
 import com.facebook.cache.common.CacheKey;
 import com.facebook.common.internal.Objects;
 import com.facebook.common.internal.Preconditions;
@@ -77,6 +79,11 @@ public int hashCode() {
     return mHash;
   }
 
+  @Override
+  public boolean containsUri(Uri uri) {
+    return getSourceUriString().contains(uri.toString());
+  }
+
   public String getSourceUriString() {
     return mSourceString;
   }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
index 9d6262d97..a13c101b7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
@@ -63,23 +63,32 @@ public BufferedDiskCache(
   }
 
   /**
-   * Performs a key-value look up in the disk cache. If the value is not found in the staging area,
-   * then a disk cache check is scheduled on a background thread. Any error manifests itself as a
+   * Returns true if the key is in the in-memory key index.
+   *
+   * Not guaranteed to be correct. The cache may yet have this key even if this returns false.
+   * But if it returns true, it definitely has it.
+   *
+   * Avoids a disk read.
+   */
+  public boolean containsSync(CacheKey key) {
+      return mStagingArea.containsKey(key) || mFileCache.hasKeySync(key);
+  }
+
+  /**
+   * Performs a key-value look up in the disk cache. If no value is found in the staging area,
+   * then disk cache checks are scheduled on a background thread. Any error manifests itself as a
    * cache miss, i.e. the returned Task resolves to false.
    * @param key
-   * @return Task that resolves to true if the element is found, or false otherwise
+   * @return Task that resolves to true if an element is found, or false otherwise
    */
   public Task<Boolean> contains(final CacheKey key) {
-    Preconditions.checkNotNull(key);
-
-    final EncodedImage pinnedImage = mStagingArea.get(key);
-    if (pinnedImage != null) {
-      pinnedImage.close();
-      FLog.v(TAG, "Found image for %s in staging area", key.toString());
-      mImageCacheStatsTracker.onStagingAreaHit();
+    if (containsSync(key)) {
       return Task.forResult(true);
     }
+    return containsAsync(key);
+  }
 
+  private Task<Boolean> containsAsync(final CacheKey key) {
     try {
       return Task.call(
           new Callable<Boolean>() {
@@ -118,22 +127,20 @@ public Boolean call() throws Exception {
   /**
    * Performs key-value look up in disk cache. If value is not found in disk cache staging area
    * then disk cache read is scheduled on background thread. Any error manifests itself as
-   * cache miss, i.e. the returned future resolves to null.
+   * cache miss, i.e. the returned task resolves to null.
    * @param key
-   * @return ListenableFuture that resolves to cached element or null if one cannot be retrieved;
-   *   returned future never rethrows any exception
+   * @return Task that resolves to cached element or null if one cannot be retrieved;
+   *   returned task never rethrows any exception
    */
-  public Task<EncodedImage> get(final CacheKey key, final AtomicBoolean isCancelled) {
-    Preconditions.checkNotNull(key);
-    Preconditions.checkNotNull(isCancelled);
-
+  public Task<EncodedImage> get(CacheKey key, AtomicBoolean isCancelled) {
     final EncodedImage pinnedImage = mStagingArea.get(key);
     if (pinnedImage != null) {
-      FLog.v(TAG, "Found image for %s in staging area", key.toString());
-      mImageCacheStatsTracker.onStagingAreaHit();
-      return Task.forResult(pinnedImage);
+      return foundPinnedImage(key, pinnedImage);
     }
+    return getAsync(key, isCancelled);
+  }
 
+  private Task<EncodedImage> getAsync(final CacheKey key, final AtomicBoolean isCancelled) {
     try {
       return Task.call(
           new Callable<EncodedImage>() {
@@ -280,6 +287,12 @@ public Void call() throws Exception {
     }
   }
 
+  private Task<EncodedImage> foundPinnedImage(CacheKey key, EncodedImage pinnedImage) {
+    FLog.v(TAG, "Found image for %s in staging area", key.toString());
+    mImageCacheStatsTracker.onStagingAreaHit();
+    return Task.forResult(pinnedImage);
+  }
+
   /**
    * Performs disk cache read. In case of any exception null is returned.
    */
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CacheKeyFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CacheKeyFactory.java
index 659895675..8b7135765 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CacheKeyFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CacheKeyFactory.java
@@ -9,6 +9,8 @@
 
 package com.facebook.imagepipeline.cache;
 
+import java.util.List;
+
 import android.net.Uri;
 
 import com.facebook.cache.common.CacheKey;
@@ -27,15 +29,10 @@
   /**
    * @return {@link CacheKey} for doing post-processed bitmap cache lookups in the pipeline.
    */
-  public CacheKey getPostprocessedBitmapCacheKey(ImageRequest request);
+  CacheKey getPostprocessedBitmapCacheKey(ImageRequest request);
 
   /**
    * @return {@link CacheKey} for doing encoded image lookups in the pipeline.
    */
   CacheKey getEncodedCacheKey(ImageRequest request);
-
-  /**
-   * @return a {@link String} that unambiguously indicates the source of the image.
-   */
-  Uri getCacheKeySourceUri(Uri sourceUri);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultCacheKeyFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultCacheKeyFactory.java
index aa629c503..4717636aa 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultCacheKeyFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultCacheKeyFactory.java
@@ -9,6 +9,9 @@
 
 package com.facebook.imagepipeline.cache;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import android.net.Uri;
 
 import com.facebook.cache.common.CacheKey;
@@ -70,8 +73,10 @@ public CacheKey getEncodedCacheKey(ImageRequest request) {
     return new SimpleCacheKey(getCacheKeySourceUri(request.getSourceUri()).toString());
   }
 
-  @Override
-  public Uri getCacheKeySourceUri(Uri sourceUri) {
+  /**
+   * @return a {@link String} that unambiguously indicates the source of the image.
+   */
+  protected Uri getCacheKeySourceUri(Uri sourceUri) {
     return sourceUri;
   }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/StagingArea.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/StagingArea.java
index a506a9022..145128a08 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/StagingArea.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/StagingArea.java
@@ -158,6 +158,33 @@ public synchronized EncodedImage get(final CacheKey key) {
     return storedEncodedImage;
   }
 
+  /**
+   * Determine if an valid entry for the key exists in the staging area.
+   */
+  public synchronized boolean containsKey(CacheKey key) {
+    Preconditions.checkNotNull(key);
+    if (!mMap.containsKey(key)) {
+      return false;
+    }
+    EncodedImage storedEncodedImage = mMap.get(key);
+    synchronized (storedEncodedImage) {
+      if (!EncodedImage.isValid(storedEncodedImage)) {
+        // Reference is not valid, this means that someone cleared reference while it was still in
+        // use. Log error
+        // TODO: 3697790
+        mMap.remove(key);
+        FLog.w(
+            TAG,
+            "Found closed reference %d for key %s (%d)",
+            System.identityHashCode(storedEncodedImage),
+            key.toString(),
+            System.identityHashCode(key));
+        return false;
+      }
+      return true;
+    }
+  }
+
   /**
    * Simple 'debug' logging of stats.
    */
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DiskStorageCacheFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DiskStorageCacheFactory.java
new file mode 100644
index 000000000..b0e6cba5b
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DiskStorageCacheFactory.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.core;
+
+import com.facebook.cache.disk.DiskCacheConfig;
+import com.facebook.cache.disk.DiskStorage;
+import com.facebook.cache.disk.DiskStorageCache;
+import com.facebook.cache.disk.FileCache;
+
+/**
+ * Factory for the default implementation of the FileCache.
+ */
+public class DiskStorageCacheFactory implements FileCacheFactory {
+  private DiskStorageFactory mDiskStorageFactory;
+
+  public DiskStorageCacheFactory(DiskStorageFactory diskStorageFactory) {
+    mDiskStorageFactory = diskStorageFactory;
+  }
+
+  public static DiskStorageCache buildDiskStorageCache(
+      DiskCacheConfig diskCacheConfig,
+      DiskStorage diskStorage) {
+    DiskStorageCache.Params params = new DiskStorageCache.Params(
+        diskCacheConfig.getMinimumSizeLimit(),
+        diskCacheConfig.getLowDiskSpaceSizeLimit(),
+        diskCacheConfig.getDefaultSizeLimit());
+    return new DiskStorageCache(
+        diskStorage,
+        diskCacheConfig.getEntryEvictionComparatorSupplier(),
+        params,
+        diskCacheConfig.getCacheEventListener(),
+        diskCacheConfig.getCacheErrorLogger(),
+        diskCacheConfig.getDiskTrimmableRegistry());
+  }
+
+  @Override
+  public FileCache get(DiskCacheConfig diskCacheConfig) {
+    return buildDiskStorageCache(diskCacheConfig, mDiskStorageFactory.get(diskCacheConfig));
+  }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DiskStorageFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DiskStorageFactory.java
new file mode 100644
index 000000000..1410fa6c8
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DiskStorageFactory.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+package com.facebook.imagepipeline.core;
+
+import com.facebook.cache.disk.DiskCacheConfig;
+import com.facebook.cache.disk.DiskStorage;
+
+/**
+ * Represents a factory for the DiskStorage to use in the ImagePipeline.
+ * Used by ImagePipelineConfig/Factory
+ */
+public interface DiskStorageFactory {
+  DiskStorage get(DiskCacheConfig diskCacheConfig);
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DynamicDefaultDiskStorageFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DynamicDefaultDiskStorageFactory.java
new file mode 100644
index 000000000..78da4cf38
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DynamicDefaultDiskStorageFactory.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+package com.facebook.imagepipeline.core;
+
+import com.facebook.cache.disk.DiskCacheConfig;
+import com.facebook.cache.disk.DiskStorage;
+import com.facebook.cache.disk.DynamicDefaultDiskStorage;
+
+/**
+ * Factory for the default implementation of the DiskStorage.
+ */
+public class DynamicDefaultDiskStorageFactory implements DiskStorageFactory {
+
+  @Override
+  public DiskStorage get(DiskCacheConfig diskCacheConfig) {
+    return new DynamicDefaultDiskStorage(
+        diskCacheConfig.getVersion(),
+        diskCacheConfig.getBaseDirectoryPathSupplier(),
+        diskCacheConfig.getBaseDirectoryName(),
+        diskCacheConfig.getCacheErrorLogger());
+  }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/FileCacheFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/FileCacheFactory.java
new file mode 100644
index 000000000..c4f63ecb9
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/FileCacheFactory.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.core;
+
+import com.facebook.cache.disk.DiskCacheConfig;
+import com.facebook.cache.disk.FileCache;
+
+/**
+ * Represents a factory for the FileCache to use in the ImagePipeline.
+ * Used by ImagePipelineConfig/Factory
+ */
+public interface FileCacheFactory {
+  FileCache get(DiskCacheConfig diskCacheConfig);
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
index f80cf1e87..148502048 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
@@ -27,7 +27,6 @@
 import com.facebook.datasource.DataSource;
 import com.facebook.datasource.DataSources;
 import com.facebook.datasource.SimpleDataSource;
-import com.facebook.imagepipeline.cache.BitmapMemoryCacheKey;
 import com.facebook.imagepipeline.cache.BufferedDiskCache;
 import com.facebook.imagepipeline.cache.MemoryCache;
 import com.facebook.imagepipeline.cache.CacheKeyFactory;
@@ -294,18 +293,9 @@ public String toString() {
    * @param uri The uri of the image to evict
    */
   public void evictFromMemoryCache(final Uri uri) {
-    Predicate<CacheKey> bitmapCachePredicate = predicateForUri(uri);
-    mBitmapMemoryCache.removeAll(bitmapCachePredicate);
-
-    final String cacheKeySourceString = mCacheKeyFactory.getCacheKeySourceUri(uri).toString();
-    Predicate<CacheKey> encodedCachePredicate =
-        new Predicate<CacheKey>() {
-          @Override
-          public boolean apply(CacheKey key) {
-            return key.toString().equals(cacheKeySourceString);
-          }
-        };
-    mEncodedMemoryCache.removeAll(encodedCachePredicate);
+    Predicate<CacheKey> predicate = predicateForUri(uri);
+    mBitmapMemoryCache.removeAll(predicate);
+    mEncodedMemoryCache.removeAll(predicate);
   }
 
   /**
@@ -324,7 +314,7 @@ public void evictFromDiskCache(final Uri uri) {
    * @param imageRequest The imageRequest for the image to evict from disk cache
    */
   public void evictFromDiskCache(final ImageRequest imageRequest) {
-    final CacheKey cacheKey = mCacheKeyFactory.getEncodedCacheKey(imageRequest);
+    CacheKey cacheKey = mCacheKeyFactory.getEncodedCacheKey(imageRequest);
     mMainBufferedDiskCache.remove(cacheKey);
     mSmallImageBufferedDiskCache.remove(cacheKey);
   }
@@ -501,15 +491,11 @@ public Void then(Task<Boolean> task) throws Exception {
     }
   }
 
-  private Predicate<CacheKey> predicateForUri(Uri uri) {
-    final String cacheKeySourceString = mCacheKeyFactory.getCacheKeySourceUri(uri).toString();
+  private Predicate<CacheKey> predicateForUri(final Uri uri) {
     return new Predicate<CacheKey>() {
           @Override
           public boolean apply(CacheKey key) {
-            if (key instanceof BitmapMemoryCacheKey) {
-              return ((BitmapMemoryCacheKey) key).getSourceUriString().equals(cacheKeySourceString);
-            }
-            return false;
+            return key.containsUri(uri);
           }
         };
   }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineConfig.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineConfig.java
index 7f2512196..94f09265d 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineConfig.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineConfig.java
@@ -11,7 +11,6 @@
 
 import javax.annotation.Nullable;
 
-import java.io.File;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
@@ -20,13 +19,11 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 
-import com.facebook.cache.disk.DefaultEntryEvictionComparatorSupplier;
 import com.facebook.cache.disk.DiskCacheConfig;
 import com.facebook.common.internal.Preconditions;
 import com.facebook.common.internal.Supplier;
 import com.facebook.common.memory.MemoryTrimmableRegistry;
 import com.facebook.common.memory.NoOpMemoryTrimmableRegistry;
-import com.facebook.common.util.ByteConstants;
 import com.facebook.imagepipeline.animated.factory.AnimatedImageFactory;
 import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
 import com.facebook.imagepipeline.cache.DefaultBitmapMemoryCacheParamsSupplier;
@@ -76,8 +73,10 @@
   private final boolean mWebpSupportEnabled;
   private final boolean mDecodeFileDescriptorEnabled;
   private final boolean mDecodeMemoryFileEnabled;
+  private final FileCacheFactory mFileCacheFactory;
   private final Supplier<MemoryCacheParams> mEncodedMemoryCacheParamsSupplier;
   private final ExecutorSupplier mExecutorSupplier;
+  private final int mForceSmallCacheThresholdBytes;
   private final ImageCacheStatsTracker mImageCacheStatsTracker;
   @Nullable private final ImageDecoder mImageDecoder;
   private final Supplier<Boolean> mIsPrefetchEnabledSupplier;
@@ -110,12 +109,16 @@ private ImagePipelineConfig(Builder builder) {
     mDecodeFileDescriptorEnabled = builder.mDownsampleEnabled &&
         builder.mDecodeFileDescriptorEnabled;
     mDecodeMemoryFileEnabled = builder.mDecodeMemoryFileEnabled;
+    mFileCacheFactory = builder.mFileCacheFactory == null ?
+        new DiskStorageCacheFactory(new DynamicDefaultDiskStorageFactory()) :
+        builder.mFileCacheFactory;
     mDownsampleEnabled = builder.mDownsampleEnabled;
     mWebpSupportEnabled = builder.mWebpSupportEnabled && sWebpLibraryPresent;
     mEncodedMemoryCacheParamsSupplier =
         builder.mEncodedMemoryCacheParamsSupplier == null ?
             new DefaultEncodedMemoryCacheParamsSupplier() :
             builder.mEncodedMemoryCacheParamsSupplier;
+    mForceSmallCacheThresholdBytes = builder.mForceSmallCacheThresholdBytes;
     mImageCacheStatsTracker =
         builder.mImageCacheStatsTracker == null ?
             NoOpImageCacheStatsTracker.getInstance() :
@@ -201,6 +204,10 @@ public boolean isDecodeMemoryFileEnabled() {
     return mDecodeMemoryFileEnabled;
   }
 
+  public FileCacheFactory getFileCacheFactory() {
+    return mFileCacheFactory;
+  }
+
   public boolean isDownsampleEnabled() {
     return mDownsampleEnabled;
   }
@@ -217,6 +224,10 @@ public ExecutorSupplier getExecutorSupplier() {
     return mExecutorSupplier;
   }
 
+  public int getForceSmallCacheThresholdBytes() {
+    return mForceSmallCacheThresholdBytes;
+  }
+
   public ImageCacheStatsTracker getImageCacheStatsTracker() {
     return mImageCacheStatsTracker;
   }
@@ -284,6 +295,7 @@ public static Builder newBuilder(Context context) {
     private boolean mDecodeMemoryFileEnabled;
     private Supplier<MemoryCacheParams> mEncodedMemoryCacheParamsSupplier;
     private ExecutorSupplier mExecutorSupplier;
+    private int mForceSmallCacheThresholdBytes = 0;
     private ImageCacheStatsTracker mImageCacheStatsTracker;
     private ImageDecoder mImageDecoder;
     private Supplier<Boolean> mIsPrefetchEnabledSupplier;
@@ -296,6 +308,7 @@ public static Builder newBuilder(Context context) {
     private Set<RequestListener> mRequestListeners;
     private boolean mResizeAndRotateEnabledForNetwork = true;
     private DiskCacheConfig mSmallImageDiskCacheConfig;
+    private FileCacheFactory mFileCacheFactory;
 
     private Builder(Context context) {
       // Doesn't use a setter as always required.
@@ -334,6 +347,20 @@ public Builder setDecodeMemoryFileEnabled(boolean decodeMemoryFileEnabled) {
       return this;
     }
 
+    public Builder setFileCacheFactory(FileCacheFactory fileCacheFactory) {
+      mFileCacheFactory = fileCacheFactory;
+      return this;
+    }
+
+    /**
+     * @deprecated use {@link Builder.setFileCacheFactory} instead
+     */
+    @Deprecated
+    public Builder setDiskStorageFactory(DiskStorageFactory diskStorageFactory) {
+      setFileCacheFactory(new DiskStorageCacheFactory(diskStorageFactory));
+      return this;
+    }
+
     public Builder setDownsampleEnabled(boolean downsampleEnabled) {
       mDownsampleEnabled = downsampleEnabled;
       return this;
@@ -356,6 +383,18 @@ public Builder setExecutorSupplier(ExecutorSupplier executorSupplier) {
       return this;
     }
 
+    /**
+     * If this value is nonnegative, then all network-downloaded images below this size
+     * will be written to the small image cache.
+     *
+     * <p>This will require the image pipeline to do up to two disk reads, instead of one, before
+     * going out to network. Use only if this pattern makes sense for your application.
+     */
+    public Builder setForceSmallCacheThresholdBytes(int forceSmallCacheThresholdBytes) {
+      mForceSmallCacheThresholdBytes = forceSmallCacheThresholdBytes;
+      return this;
+    }
+
     public Builder setImageCacheStatsTracker(ImageCacheStatsTracker imageCacheStatsTracker) {
       mImageCacheStatsTracker = imageCacheStatsTracker;
       return this;
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
index 06d3d13de..dc252814a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
@@ -20,25 +20,18 @@
 import android.os.Build;
 
 import com.facebook.cache.common.CacheKey;
-import com.facebook.cache.disk.DiskCacheFactory;
+import com.facebook.cache.disk.DiskCacheConfig;
+import com.facebook.cache.disk.DiskStorage;
 import com.facebook.cache.disk.DiskStorageCache;
+import com.facebook.cache.disk.FileCache;
 import com.facebook.common.executors.DefaultSerialExecutorService;
 import com.facebook.common.executors.SerialExecutorService;
 import com.facebook.common.executors.UiThreadImmediateExecutorService;
 import com.facebook.common.internal.AndroidPredicates;
 import com.facebook.common.internal.Preconditions;
-import com.facebook.common.time.MonotonicClock;
-import com.facebook.common.time.RealtimeSinceBootClock;
-import com.facebook.imagepipeline.animated.base.AnimatedDrawableBackend;
-import com.facebook.imagepipeline.animated.base.AnimatedDrawableOptions;
-import com.facebook.imagepipeline.animated.base.AnimatedImageResult;
-import com.facebook.imagepipeline.animated.factory.AnimatedDrawableFactory;
+import com.facebook.common.time.AwakeTimeSinceBootClock;
 import com.facebook.imagepipeline.animated.factory.AnimatedImageFactory;
-import com.facebook.imagepipeline.animated.impl.AnimatedDrawableBackendImpl;
-import com.facebook.imagepipeline.animated.impl.AnimatedDrawableBackendProvider;
-import com.facebook.imagepipeline.animated.impl.AnimatedDrawableCachingBackendImpl;
-import com.facebook.imagepipeline.animated.impl.AnimatedDrawableCachingBackendImplProvider;
-import com.facebook.imagepipeline.animated.util.AnimatedDrawableUtil;
+import com.facebook.imagepipeline.animated.factory.AnimatedFactoryProvider;
 import com.facebook.imagepipeline.bitmaps.ArtBitmapFactory;
 import com.facebook.imagepipeline.bitmaps.EmptyJpegGenerator;
 import com.facebook.imagepipeline.bitmaps.GingerbreadBitmapFactory;
@@ -60,6 +53,7 @@
 import com.facebook.imagepipeline.platform.KitKatPurgeableDecoder;
 import com.facebook.imagepipeline.platform.PlatformDecoder;
 import com.facebook.imagepipeline.producers.ThreadHandoffProducerQueue;
+import com.facebook.imagepipeline.animated.factory.AnimatedFactory;
 
 /**
  * Factory class for the image pipeline.
@@ -101,133 +95,38 @@ public static void shutDown() {
   }
 
   private final ImagePipelineConfig mConfig;
-
-  private AnimatedDrawableBackendProvider mAnimatedDrawableBackendProvider;
-  private AnimatedDrawableUtil mAnimatedDrawableUtil;
-  private AnimatedDrawableFactory mAnimatedDrawableFactory;
-  private AnimatedImageFactory mAnimatedImageFactory;
   private CountingMemoryCache<CacheKey, CloseableImage>
       mBitmapCountingMemoryCache;
   private MemoryCache<CacheKey, CloseableImage> mBitmapMemoryCache;
   private CountingMemoryCache<CacheKey, PooledByteBuffer> mEncodedCountingMemoryCache;
   private MemoryCache<CacheKey, PooledByteBuffer> mEncodedMemoryCache;
   private BufferedDiskCache mMainBufferedDiskCache;
-  private DiskStorageCache mMainDiskStorageCache;
+  private FileCache mMainFileCache;
   private ImageDecoder mImageDecoder;
   private ImagePipeline mImagePipeline;
   private ProducerFactory mProducerFactory;
   private ProducerSequenceFactory mProducerSequenceFactory;
   private BufferedDiskCache mSmallImageBufferedDiskCache;
-  private DiskStorageCache mSmallImageDiskStorageCache;
+  private FileCache mSmallImageFileCache;
 
   private PlatformBitmapFactory mPlatformBitmapFactory;
   private PlatformDecoder mPlatformDecoder;
 
+  private AnimatedFactory mAnimatedFactory;
+
   public ImagePipelineFactory(ImagePipelineConfig config) {
     mConfig = Preconditions.checkNotNull(config);
     mThreadHandoffProducerQueue = new ThreadHandoffProducerQueue(
         config.getExecutorSupplier().forLightweightBackgroundTasks());
   }
 
-  public static AnimatedDrawableFactory buildAnimatedDrawableFactory(
-      final SerialExecutorService serialExecutorService,
-      final ActivityManager activityManager,
-      final AnimatedDrawableUtil animatedDrawableUtil,
-      AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
-      ScheduledExecutorService scheduledExecutorService,
-      final MonotonicClock monotonicClock,
-      Resources resources) {
-    AnimatedDrawableCachingBackendImplProvider animatedDrawableCachingBackendImplProvider =
-        new AnimatedDrawableCachingBackendImplProvider() {
-          @Override
-          public AnimatedDrawableCachingBackendImpl get(
-              AnimatedDrawableBackend animatedDrawableBackend,
-              AnimatedDrawableOptions options) {
-            return new AnimatedDrawableCachingBackendImpl(
-                serialExecutorService,
-                activityManager,
-                animatedDrawableUtil,
-                monotonicClock,
-                animatedDrawableBackend,
-                options);
-          }
-        };
-
-
-    return new AnimatedDrawableFactory(
-        animatedDrawableBackendProvider,
-        animatedDrawableCachingBackendImplProvider,
-        animatedDrawableUtil,
-        scheduledExecutorService,
-        resources);
-  }
-
-  public AnimatedDrawableBackendProvider getAnimatedDrawableBackendProvider() {
-    if (mAnimatedDrawableBackendProvider == null) {
-      mAnimatedDrawableBackendProvider = new AnimatedDrawableBackendProvider() {
-        @Override
-        public AnimatedDrawableBackend get(AnimatedImageResult animatedImageResult, Rect bounds) {
-          return new AnimatedDrawableBackendImpl(
-              getAnimatedDrawableUtil(),
-              animatedImageResult,
-              bounds);
-        }
-      };
+  public AnimatedFactory getAnimatedFactory() {
+    if (mAnimatedFactory == null) {
+      mAnimatedFactory = AnimatedFactoryProvider.getAnimatedFactory(
+          getPlatformBitmapFactory(),
+          mConfig.getExecutorSupplier());
     }
-    return mAnimatedDrawableBackendProvider;
-  }
-
-  public AnimatedDrawableFactory getAnimatedDrawableFactory() {
-    if (mAnimatedDrawableFactory == null) {
-      SerialExecutorService serialExecutorService =
-          new DefaultSerialExecutorService(mConfig.getExecutorSupplier().forDecode());
-      ActivityManager activityManager =
-          (ActivityManager) mConfig.getContext().getSystemService(Context.ACTIVITY_SERVICE);
-      mAnimatedDrawableFactory = buildAnimatedDrawableFactory(
-          serialExecutorService,
-          activityManager,
-          getAnimatedDrawableUtil(),
-          getAnimatedDrawableBackendProvider(),
-          UiThreadImmediateExecutorService.getInstance(),
-          RealtimeSinceBootClock.get(),
-          mConfig.getContext().getResources());
-    }
-    return mAnimatedDrawableFactory;
-  }
-
-  // We need some of these methods public for now so internal code can use them.
-
-  private AnimatedDrawableUtil getAnimatedDrawableUtil() {
-    if (mAnimatedDrawableUtil == null) {
-      mAnimatedDrawableUtil = new AnimatedDrawableUtil();
-    }
-    return mAnimatedDrawableUtil;
-  }
-
-  public static AnimatedImageFactory buildAnimatedImageFactory(
-      final AnimatedDrawableUtil animatedDrawableUtil,
-      PlatformBitmapFactory platformBitmapFactory) {
-    AnimatedDrawableBackendProvider animatedDrawableBackendProvider =
-        new AnimatedDrawableBackendProvider() {
-          @Override
-          public AnimatedDrawableBackend get(AnimatedImageResult imageResult, Rect bounds) {
-            return new AnimatedDrawableBackendImpl(animatedDrawableUtil, imageResult, bounds);
-          }
-        };
-   return new AnimatedImageFactory(animatedDrawableBackendProvider, platformBitmapFactory);
-  }
-
-  private AnimatedImageFactory getAnimatedImageFactory() {
-    if (mAnimatedImageFactory == null) {
-      if (mConfig.getAnimatedImageFactory() != null) {
-        mAnimatedImageFactory = mConfig.getAnimatedImageFactory();
-      } else {
-        mAnimatedImageFactory = buildAnimatedImageFactory(
-            getAnimatedDrawableUtil(),
-            getPlatformBitmapFactory());
-      }
-    }
-    return mAnimatedImageFactory;
+    return mAnimatedFactory;
   }
 
   public CountingMemoryCache<CacheKey, CloseableImage>
@@ -251,6 +150,18 @@ private AnimatedImageFactory getAnimatedImageFactory() {
     return mBitmapMemoryCache;
   }
 
+  /**
+   * Creates a new {@link DiskStorageCache} from the given {@link DiskCacheConfig}
+   *
+   * @deprecated use {@link DiskStorageCacheFactory.buildDiskStorageCache}
+   */
+  @Deprecated
+  public static DiskStorageCache buildDiskStorageCache(
+      DiskCacheConfig diskCacheConfig,
+      DiskStorage diskStorage) {
+    return DiskStorageCacheFactory.buildDiskStorageCache(diskCacheConfig, diskStorage);
+  }
+
   public CountingMemoryCache<CacheKey, PooledByteBuffer> getEncodedCountingMemoryCache() {
     if (mEncodedCountingMemoryCache == null) {
       mEncodedCountingMemoryCache =
@@ -276,8 +187,15 @@ private ImageDecoder getImageDecoder() {
       if (mConfig.getImageDecoder() != null) {
         mImageDecoder = mConfig.getImageDecoder();
       } else {
+        final AnimatedFactory animatedFactory = getAnimatedFactory();
+        final AnimatedImageFactory animatedImageFactory;
+        if (animatedFactory != null) {
+          animatedImageFactory = getAnimatedFactory().getAnimatedImageFactory();
+        } else {
+          animatedImageFactory = null;
+        }
         mImageDecoder = new ImageDecoder(
-            getAnimatedImageFactory(),
+            animatedImageFactory,
             getPlatformDecoder(),
             mConfig.getBitmapConfig());
       }
@@ -289,7 +207,7 @@ private BufferedDiskCache getMainBufferedDiskCache() {
     if (mMainBufferedDiskCache == null) {
       mMainBufferedDiskCache =
           new BufferedDiskCache(
-              getMainDiskStorageCache(),
+              getMainFileCache(),
               mConfig.getPoolFactory().getPooledByteBufferFactory(),
               mConfig.getPoolFactory().getPooledByteStreams(),
               mConfig.getExecutorSupplier().forLocalStorageRead(),
@@ -299,12 +217,20 @@ private BufferedDiskCache getMainBufferedDiskCache() {
     return mMainBufferedDiskCache;
   }
 
-  public DiskStorageCache getMainDiskStorageCache() {
-    if (mMainDiskStorageCache == null) {
-      mMainDiskStorageCache =
-          DiskCacheFactory.newDiskStorageCache(mConfig.getMainDiskCacheConfig());
+  /**
+   * @deprecated use {@link ImagePipelineFactory.getMainFileCache}
+   */
+  @Deprecated
+  public FileCache getMainDiskStorageCache() {
+    return getMainFileCache();
+  }
+
+  public FileCache getMainFileCache() {
+    if (mMainFileCache == null) {
+      DiskCacheConfig diskCacheConfig = mConfig.getMainDiskCacheConfig();
+      mMainFileCache = mConfig.getFileCacheFactory().get(diskCacheConfig);
     }
-    return mMainDiskStorageCache;
+    return mMainFileCache;
   }
 
   public ImagePipeline getImagePipeline() {
@@ -407,7 +333,8 @@ private ProducerFactory getProducerFactory() {
               getSmallImageBufferedDiskCache(),
               mConfig.getCacheKeyFactory(),
               getPlatformBitmapFactory(),
-              mConfig.isDecodeFileDescriptorEnabled());
+              mConfig.isDecodeFileDescriptorEnabled(),
+              mConfig.getForceSmallCacheThresholdBytes());
     }
     return mProducerFactory;
   }
@@ -426,19 +353,27 @@ private ProducerSequenceFactory getProducerSequenceFactory() {
     return mProducerSequenceFactory;
   }
 
-  public DiskStorageCache getSmallImageDiskStorageCache() {
-    if (mSmallImageDiskStorageCache == null) {
-      mSmallImageDiskStorageCache =
-          DiskCacheFactory.newDiskStorageCache(mConfig.getSmallImageDiskCacheConfig());
+  /**
+   * @deprecated use {@link ImagePipelineFactory.getSmallImageFileCache}
+   */
+  @Deprecated
+  public FileCache getSmallImageDiskStorageCache() {
+    return getSmallImageFileCache();
+  }
+
+  public FileCache getSmallImageFileCache() {
+    if (mSmallImageFileCache == null) {
+      DiskCacheConfig diskCacheConfig = mConfig.getSmallImageDiskCacheConfig();
+      mSmallImageFileCache = mConfig.getFileCacheFactory().get(diskCacheConfig);
     }
-    return mSmallImageDiskStorageCache;
+    return mSmallImageFileCache;
   }
 
   private BufferedDiskCache getSmallImageBufferedDiskCache() {
     if (mSmallImageBufferedDiskCache == null) {
       mSmallImageBufferedDiskCache =
           new BufferedDiskCache(
-              getSmallImageDiskStorageCache(),
+              getSmallImageFileCache(),
               mConfig.getPoolFactory().getPooledByteBufferFactory(),
               mConfig.getPoolFactory().getPooledByteStreams(),
               mConfig.getExecutorSupplier().forLocalStorageRead(),
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
index acf6525f3..c7071d696 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
@@ -39,6 +39,7 @@
 import com.facebook.imagepipeline.producers.EncodedMemoryCacheProducer;
 import com.facebook.imagepipeline.producers.LocalAssetFetchProducer;
 import com.facebook.imagepipeline.producers.LocalContentUriFetchProducer;
+import com.facebook.imagepipeline.producers.LocalContentUriThumbnailFetchProducer;
 import com.facebook.imagepipeline.producers.LocalExifThumbnailProducer;
 import com.facebook.imagepipeline.producers.LocalFileFetchProducer;
 import com.facebook.imagepipeline.producers.LocalResourceFetchProducer;
@@ -52,9 +53,11 @@
 import com.facebook.imagepipeline.producers.ResizeAndRotateProducer;
 import com.facebook.imagepipeline.producers.SwallowResultProducer;
 import com.facebook.imagepipeline.producers.ThreadHandoffProducer;
+import com.facebook.imagepipeline.producers.ThreadHandoffProducerQueue;
 import com.facebook.imagepipeline.producers.ThrottlingProducer;
+import com.facebook.imagepipeline.producers.ThumbnailBranchProducer;
+import com.facebook.imagepipeline.producers.ThumbnailProducer;
 import com.facebook.imagepipeline.producers.WebpTranscodeProducer;
-import com.facebook.imagepipeline.producers.ThreadHandoffProducerQueue;
 
 public class ProducerFactory {
   // Local dependencies
@@ -80,6 +83,7 @@
   private final MemoryCache<CacheKey, PooledByteBuffer> mEncodedMemoryCache;
   private final MemoryCache<CacheKey, CloseableImage> mBitmapMemoryCache;
   private final CacheKeyFactory mCacheKeyFactory;
+  private final int mForceSmallCacheThresholdBytes;
 
   // Postproc dependencies
   private final PlatformBitmapFactory mPlatformBitmapFactory;
@@ -99,7 +103,9 @@ public ProducerFactory(
       BufferedDiskCache smallImageBufferedDiskCache,
       CacheKeyFactory cacheKeyFactory,
       PlatformBitmapFactory platformBitmapFactory,
-      boolean decodeFileDescriptorEnabled) {
+      boolean decodeFileDescriptorEnabled,
+      int forceSmallCacheThresholdBytes) {
+    mForceSmallCacheThresholdBytes = forceSmallCacheThresholdBytes;
     mContentResolver = context.getApplicationContext().getContentResolver();
     mResources = context.getApplicationContext().getResources();
     mAssetManager = context.getApplicationContext().getAssets();
@@ -171,17 +177,23 @@ public DiskCacheProducer newDiskCacheProducer(
         mDefaultBufferedDiskCache,
         mSmallImageBufferedDiskCache,
         mCacheKeyFactory,
-        inputProducer);
+        inputProducer,
+        mForceSmallCacheThresholdBytes);
   }
 
   public EncodedCacheKeyMultiplexProducer newEncodedCacheKeyMultiplexProducer(
       Producer<EncodedImage> inputProducer) {
-    return new EncodedCacheKeyMultiplexProducer(mCacheKeyFactory, inputProducer);
+    return new EncodedCacheKeyMultiplexProducer(
+        mCacheKeyFactory,
+        inputProducer);
   }
 
   public EncodedMemoryCacheProducer newEncodedMemoryCacheProducer(
       Producer<EncodedImage> inputProducer) {
-    return new EncodedMemoryCacheProducer(mEncodedMemoryCache, mCacheKeyFactory, inputProducer);
+    return new EncodedMemoryCacheProducer(
+        mEncodedMemoryCache,
+        mCacheKeyFactory,
+        inputProducer);
   }
 
   public LocalAssetFetchProducer newLocalAssetFetchProducer() {
@@ -192,7 +204,7 @@ public LocalAssetFetchProducer newLocalAssetFetchProducer() {
         mDecodeFileDescriptorEnabled);
   }
 
-  public LocalContentUriFetchProducer newContentUriFetchProducer() {
+  public LocalContentUriFetchProducer newLocalContentUriFetchProducer() {
     return new LocalContentUriFetchProducer(
         mExecutorSupplier.forLocalStorageRead(),
         mPooledByteBufferFactory,
@@ -200,6 +212,14 @@ public LocalContentUriFetchProducer newContentUriFetchProducer() {
         mDecodeFileDescriptorEnabled);
   }
 
+    public LocalContentUriThumbnailFetchProducer newLocalContentUriThumbnailFetchProducer() {
+    return new LocalContentUriThumbnailFetchProducer(
+        mExecutorSupplier.forLocalStorageRead(),
+        mPooledByteBufferFactory,
+        mContentResolver,
+        mDecodeFileDescriptorEnabled);
+  }
+
   public LocalExifThumbnailProducer newLocalExifThumbnailProducer() {
     return new LocalExifThumbnailProducer(
         mExecutorSupplier.forLocalStorageRead(),
@@ -207,6 +227,11 @@ public LocalExifThumbnailProducer newLocalExifThumbnailProducer() {
         mContentResolver);
   }
 
+  public ThumbnailBranchProducer newThumbnailBranchProducer(
+      ThumbnailProducer<EncodedImage>[] thumbnailProducers) {
+    return new ThumbnailBranchProducer(thumbnailProducers);
+  }
+
   public LocalFileFetchProducer newLocalFileFetchProducer() {
     return new LocalFileFetchProducer(
         mExecutorSupplier.forLocalStorageRead(),
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
index dc031b5b7..1d1c0c9b8 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
@@ -39,11 +39,11 @@
 import com.facebook.imagepipeline.producers.RemoveImageTransformMetaDataProducer;
 import com.facebook.imagepipeline.producers.SwallowResultProducer;
 import com.facebook.imagepipeline.producers.ThreadHandoffProducer;
+import com.facebook.imagepipeline.producers.ThreadHandoffProducerQueue;
 import com.facebook.imagepipeline.producers.ThrottlingProducer;
+import com.facebook.imagepipeline.producers.ThumbnailBranchProducer;
+import com.facebook.imagepipeline.producers.ThumbnailProducer;
 import com.facebook.imagepipeline.request.ImageRequest;
-import com.facebook.imagepipeline.producers.ThreadHandoffProducerQueue;
-
-import static com.facebook.common.webp.WebpSupportStatus.sWebpLibraryPresent;
 
 public class ProducerSequenceFactory {
   private static final int MAX_SIMULTANEOUS_FILE_FETCH_AND_RESIZE = 5;
@@ -208,13 +208,13 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    * disk cache -> (webp transcode) -> network fetch.
    */
   private synchronized Producer<EncodedImage>
-      getBackgroundNetworkFetchToEncodedMemorySequence() {
+  getBackgroundNetworkFetchToEncodedMemorySequence() {
     if (mBackgroundNetworkFetchToEncodedMemorySequence == null) {
       // Use hand-off producer to ensure that we don't do any unnecessary work on the UI thread.
       mBackgroundNetworkFetchToEncodedMemorySequence =
           mProducerFactory.newBackgroundThreadHandoffProducer(
-                  getCommonNetworkFetchToEncodedMemorySequence(),
-                  mThreadHandoffProducerQueue);
+              getCommonNetworkFetchToEncodedMemorySequence(),
+              mThreadHandoffProducerQueue);
     }
     return mBackgroundNetworkFetchToEncodedMemorySequence;
   }
@@ -227,7 +227,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
     if (mNetworkFetchToEncodedMemoryPrefetchSequence == null) {
       mNetworkFetchToEncodedMemoryPrefetchSequence =
           mProducerFactory.newSwallowResultProducer(
-                  getBackgroundNetworkFetchToEncodedMemorySequence());
+              getBackgroundNetworkFetchToEncodedMemorySequence());
     }
     return mNetworkFetchToEncodedMemoryPrefetchSequence;
   }
@@ -261,7 +261,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    *   (webp transcode) -> local file fetch.
    */
   private synchronized Producer<CloseableReference<CloseableImage>>
-      getLocalImageFileFetchSequence() {
+  getLocalImageFileFetchSequence() {
     if (mLocalImageFileFetchSequence == null) {
       LocalFileFetchProducer localFileFetchProducer =
           mProducerFactory.newLocalFileFetchProducer();
@@ -276,7 +276,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    * local video thumbnail
    */
   private synchronized Producer<CloseableReference<CloseableImage>>
-      getLocalVideoFileFetchSequence() {
+  getLocalVideoFileFetchSequence() {
     if (mLocalVideoFileFetchSequence == null) {
       LocalVideoThumbnailProducer localVideoThumbnailProducer =
           mProducerFactory.newLocalVideoThumbnailProducer();
@@ -290,17 +290,25 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    * bitmap cache get ->
    * background thread hand-off -> multiplex -> bitmap cache -> decode ->
    * branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
+   *   -> thumbnail resize and rotate -> thumbnail branch
+   *     -> local content thumbnail creation
+   *     -> exif thumbnail creation
    *   -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
    *   (webp transcode) -> local content uri fetch.
    */
   private synchronized Producer<CloseableReference<CloseableImage>>
-      getLocalContentUriFetchSequence() {
+  getLocalContentUriFetchSequence() {
     if (mLocalContentUriFetchSequence == null) {
       LocalContentUriFetchProducer localContentUriFetchProducer =
-          mProducerFactory.newContentUriFetchProducer();
-      mLocalContentUriFetchSequence =
-          newBitmapCacheGetToLocalTransformSequence(localContentUriFetchProducer);
+          mProducerFactory.newLocalContentUriFetchProducer();
+
+      ThumbnailProducer<EncodedImage>[] thumbnailProducers = new ThumbnailProducer[2];
+      thumbnailProducers[0] = mProducerFactory.newLocalContentUriThumbnailFetchProducer();
+      thumbnailProducers[1] = mProducerFactory.newLocalExifThumbnailProducer();
+
+      mLocalContentUriFetchSequence = newBitmapCacheGetToLocalTransformSequence(
+          localContentUriFetchProducer,
+          thumbnailProducers);
     }
     return mLocalContentUriFetchSequence;
   }
@@ -314,7 +322,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    *   (webp transcode) -> local resource fetch.
    */
   private synchronized Producer<CloseableReference<CloseableImage>>
-      getLocalResourceFetchSequence() {
+  getLocalResourceFetchSequence() {
     if (mLocalResourceFetchSequence == null) {
       LocalResourceFetchProducer localResourceFetchProducer =
           mProducerFactory.newLocalResourceFetchProducer();
@@ -369,9 +377,24 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    */
   private Producer<CloseableReference<CloseableImage>> newBitmapCacheGetToLocalTransformSequence(
       Producer<EncodedImage> inputProducer) {
+    ThumbnailProducer<EncodedImage>[] defaultThumbnailProducers = new ThumbnailProducer[1];
+    defaultThumbnailProducers[0] = mProducerFactory.newLocalExifThumbnailProducer();
+    return newBitmapCacheGetToLocalTransformSequence(inputProducer, defaultThumbnailProducers);
+  }
+
+  /**
+   * Creates a new fetch sequence that just needs the source producer.
+   * @param inputProducer the source producer
+   * @param thumbnailProducers the thumbnail producers from which to request the image before
+   * falling back to the full image producer sequence
+   * @return the new sequence
+   */
+  private Producer<CloseableReference<CloseableImage>> newBitmapCacheGetToLocalTransformSequence(
+      Producer<EncodedImage> inputProducer,
+      ThumbnailProducer<EncodedImage>[] thumbnailProducers) {
     inputProducer = newEncodedCacheMultiplexToTranscodeSequence(inputProducer);
     Producer<EncodedImage> inputProducerAfterDecode =
-        newLocalTransformationsSequence(inputProducer);
+        newLocalTransformationsSequence(inputProducer, thumbnailProducers);
     return newBitmapCacheGetToDecodeSequence(inputProducerAfterDecode);
   }
 
@@ -392,7 +415,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    * @return encoded cache multiplex to webp transcode sequence
    */
   private Producer<EncodedImage> newEncodedCacheMultiplexToTranscodeSequence(
-          Producer<EncodedImage> inputProducer) {
+      Producer<EncodedImage> inputProducer) {
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2 && !mWebpSupportEnabled) {
       inputProducer = mProducerFactory.newWebpTranscodeProducer(inputProducer);
     }
@@ -422,15 +445,18 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
 
   /**
    * Branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
+   *   -> thumbnail resize and rotate -> thumbnail producers as provided
    *   -> local image resize and rotate -> add meta data producer
    * @param inputProducer producer providing the input to add meta data producer
+   * @param thumbnailProducers the thumbnail producers from which to request the image before
+   * falling back to the full image producer sequence
    * @return local transformations sequence
    */
   private Producer<EncodedImage> newLocalTransformationsSequence(
-      Producer<EncodedImage> inputProducer) {
+      Producer<EncodedImage> inputProducer,
+      ThumbnailProducer<EncodedImage>[] thumbnailProducers) {
     Producer<EncodedImage> localImageProducer =
-        mProducerFactory.newAddImageTransformMetaDataProducer(inputProducer);
+        ProducerFactory.newAddImageTransformMetaDataProducer(inputProducer);
     if (!mDownsampleEnabled) {
       localImageProducer =
           mProducerFactory.newResizeAndRotateProducer(localImageProducer);
@@ -440,17 +466,23 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
         mProducerFactory.newThrottlingProducer(
             MAX_SIMULTANEOUS_FILE_FETCH_AND_RESIZE,
             localImageProducer);
-    Producer<EncodedImage> localExifThumbnailProducer =
-        mProducerFactory.newLocalExifThumbnailProducer();
-    if (!mDownsampleEnabled) {
-      localExifThumbnailProducer =
-          mProducerFactory.newResizeAndRotateProducer(localExifThumbnailProducer);
-    }
     return mProducerFactory.newBranchOnSeparateImagesProducer(
-        localExifThumbnailProducer,
+        newLocalThumbnailProducer(thumbnailProducers),
         localImageThrottlingProducer);
   }
 
+  private Producer<EncodedImage> newLocalThumbnailProducer(
+      ThumbnailProducer<EncodedImage>[] thumbnailProducers) {
+    ThumbnailBranchProducer thumbnailBranchProducer =
+        mProducerFactory.newThumbnailBranchProducer(thumbnailProducers);
+
+    if (mDownsampleEnabled) {
+      return thumbnailBranchProducer;
+    } else {
+      return mProducerFactory.newResizeAndRotateProducer(thumbnailBranchProducer);
+    }
+  }
+
   /**
    * post-processor producer -> copy producer -> inputProducer
    */
@@ -476,6 +508,6 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
           mProducerFactory.newSwallowResultProducer(inputProducer);
       mCloseableImagePrefetchSequences.put(inputProducer, swallowResultProducer);
     }
-      return mCloseableImagePrefetchSequences.get(inputProducer);
+    return mCloseableImagePrefetchSequences.get(inputProducer);
   }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/RequestLoggingListener.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/RequestLoggingListener.java
index 309bfb119..c836c5634 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/RequestLoggingListener.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/RequestLoggingListener.java
@@ -217,6 +217,6 @@ private static long getElapsedTime(@Nullable Long startTime, long endTime) {
   }
 
   private static long getTime() {
-    return SystemClock.elapsedRealtime();
+    return SystemClock.uptimeMillis();
   }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BasePool.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BasePool.java
index 82e77345b..7414bbc76 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BasePool.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BasePool.java
@@ -725,7 +725,7 @@ private void logStats() {
   @NotThreadSafe
   @VisibleForTesting
   static class Counter {
-    private static final String TAG = "com.facebook.imagepipeline.common.BasePool.Counter";
+    private static final String TAG = "com.facebook.imagepipeline.memory.BasePool.Counter";
 
     int mCount;
     int mNumBytes;
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Bucket.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Bucket.java
index cf72a7035..6f0980a79 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Bucket.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Bucket.java
@@ -43,8 +43,6 @@
 @NotThreadSafe
 @VisibleForTesting
 class Bucket<V> {
-  private static final String TAG = "com.facebook.imagepipeline.common.Bucket";
-
   public final int mItemSize; // size in bytes of items in this bucket
   public final int mMaxLength; // 'max' length for this bucket
   final Queue mFreeList; // the free list for this bucket, subclasses can vary type
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/Bitmaps.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/Bitmaps.java
index 0fe32529c..c032bb089 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/Bitmaps.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/Bitmaps.java
@@ -17,6 +17,8 @@
 import com.facebook.common.soloader.SoLoaderShim;
 import com.facebook.imageutils.BitmapUtil;
 
+import java.nio.ByteBuffer;
+
 /**
  * Utility methods for handling Bitmaps.
  */
@@ -40,6 +42,15 @@ public static void pinBitmap(Bitmap bitmap) {
     nativePinBitmap(bitmap);
   }
 
+  public static ByteBuffer getByteBuffer(Bitmap bitmap, long start, long size) {
+    Preconditions.checkNotNull(bitmap);
+    return nativeGetByteBuffer(bitmap, start, size);
+  }
+
+  public static void releaseByteBuffer(Bitmap bitmap) {
+    Preconditions.checkNotNull(bitmap);
+    nativeReleaseByteBuffer(bitmap);
+  }
 
   /**
    * This blits the pixel data from src to dest.
@@ -85,9 +96,15 @@ public static void reconfigureBitmap(
     bitmap.reconfigure(width, height, bitmapConfig);
   }
 
+  @DoNotStrip
+  private static native ByteBuffer nativeGetByteBuffer(Bitmap bitmap, long start, long size);
+
   @DoNotStrip
   private static native void nativePinBitmap(Bitmap bitmap);
 
+  @DoNotStrip
+  private static native void nativeReleaseByteBuffer(Bitmap bitmap);
+
   @DoNotStrip
   private static native void nativeCopyBitmap(
       Bitmap dest,
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducer.java
index e4335a8e5..c1f7b30eb 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducer.java
@@ -51,11 +51,14 @@ private OnFirstImageConsumer(
     @Override
     protected void onNewResultImpl(EncodedImage newResult, boolean isLast) {
       ImageRequest request = mProducerContext.getImageRequest();
-      boolean isGoodEnough = isResultGoodEnough(newResult, request);
+      boolean isGoodEnough =
+          ThumbnailSizeChecker.isImageBigEnough(newResult, request.getResizeOptions());
       if (newResult != null && (isGoodEnough || request.getLocalThumbnailPreviewsEnabled())) {
         getConsumer().onNewResult(newResult, isLast && isGoodEnough);
       }
       if (isLast && !isGoodEnough) {
+        EncodedImage.closeSafely(newResult);
+
         mInputProducer2.produceResults(getConsumer(), mProducerContext);
       }
     }
@@ -64,14 +67,5 @@ protected void onNewResultImpl(EncodedImage newResult, boolean isLast) {
     protected void onFailureImpl(Throwable t) {
       mInputProducer2.produceResults(getConsumer(), mProducerContext);
     }
-
-    private boolean isResultGoodEnough(EncodedImage encodedImage, ImageRequest imageRequest) {
-      if (encodedImage == null) {
-        return false;
-      }
-
-      return encodedImage.getWidth() >= imageRequest.getPreferredWidth() &&
-          encodedImage.getHeight() >= imageRequest.getPreferredHeight();
-    }
   }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java
index 8d6f52ea4..9a5853e42 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java
@@ -9,17 +9,17 @@
 
 package com.facebook.imagepipeline.producers;
 
+import java.util.Map;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.Map;
 
+import com.facebook.cache.common.CacheKey;
 import com.facebook.common.internal.ImmutableMap;
 import com.facebook.common.internal.VisibleForTesting;
 import com.facebook.imagepipeline.cache.BufferedDiskCache;
 import com.facebook.imagepipeline.cache.CacheKeyFactory;
 import com.facebook.imagepipeline.image.EncodedImage;
 import com.facebook.imagepipeline.request.ImageRequest;
-import com.facebook.cache.common.CacheKey;
 
 import bolts.Continuation;
 import bolts.Task;
@@ -42,16 +42,21 @@
   private final BufferedDiskCache mSmallImageBufferedDiskCache;
   private final CacheKeyFactory mCacheKeyFactory;
   private final Producer<EncodedImage> mInputProducer;
+  private final boolean mChooseCacheByImageSize;
+  private final int mForceSmallCacheThresholdBytes;
 
   public DiskCacheProducer(
       BufferedDiskCache defaultBufferedDiskCache,
       BufferedDiskCache smallImageBufferedDiskCache,
       CacheKeyFactory cacheKeyFactory,
-      Producer<EncodedImage> inputProducer) {
+      Producer<EncodedImage> inputProducer,
+      int forceSmallCacheThresholdBytes) {
     mDefaultBufferedDiskCache = defaultBufferedDiskCache;
     mSmallImageBufferedDiskCache = smallImageBufferedDiskCache;
     mCacheKeyFactory = cacheKeyFactory;
     mInputProducer = inputProducer;
+    mForceSmallCacheThresholdBytes = forceSmallCacheThresholdBytes;
+    mChooseCacheByImageSize = (forceSmallCacheThresholdBytes > 0);
   }
 
   public void produceResults(
@@ -63,61 +68,97 @@ public void produceResults(
       return;
     }
 
-    final ProducerListener listener = producerContext.getListener();
-    final String requestId = producerContext.getId();
-    listener.onProducerStart(requestId, PRODUCER_NAME);
+    producerContext.getListener().onProducerStart(producerContext.getId(), PRODUCER_NAME);
 
     final CacheKey cacheKey = mCacheKeyFactory.getEncodedCacheKey(imageRequest);
-    final BufferedDiskCache cache =
-        imageRequest.getImageType() == ImageRequest.ImageType.SMALL
-            ? mSmallImageBufferedDiskCache
-            : mDefaultBufferedDiskCache;
-    Continuation<EncodedImage, Void> continuation = new Continuation<EncodedImage, Void>() {
-          @Override
-          public Void then(Task<EncodedImage> task)
-              throws Exception {
-            if (task.isCancelled() ||
-                (task.isFaulted() && task.getError() instanceof CancellationException)) {
-              listener.onProducerFinishWithCancellation(requestId, PRODUCER_NAME, null);
-              consumer.onCancellation();
-            } else if (task.isFaulted()) {
-              listener.onProducerFinishWithFailure(requestId, PRODUCER_NAME, task.getError(), null);
-              maybeStartInputProducer(
-                  consumer,
-                  new DiskCacheConsumer(consumer, cache, cacheKey),
-                  producerContext);
-            } else {
-              EncodedImage cachedReference = task.getResult();
-              if (cachedReference != null) {
-                listener.onProducerFinishWithSuccess(
-                    requestId,
-                    PRODUCER_NAME,
-                    getExtraMap(listener, requestId, true));
-                consumer.onProgressUpdate(1);
-                consumer.onNewResult(cachedReference, true);
-                cachedReference.close();
-              } else {
-                listener.onProducerFinishWithSuccess(
-                    requestId,
-                    PRODUCER_NAME,
-                    getExtraMap(listener, requestId, false));
-                maybeStartInputProducer(
-                    consumer,
-                    new DiskCacheConsumer(consumer, cache, cacheKey),
-                    producerContext);
-              }
-            }
-            return null;
+    boolean isSmallRequest = (imageRequest.getImageType() == ImageRequest.ImageType.SMALL);
+    final BufferedDiskCache preferredCache = isSmallRequest ?
+        mSmallImageBufferedDiskCache : mDefaultBufferedDiskCache;
+    final AtomicBoolean isCancelled = new AtomicBoolean(false);
+    Task<EncodedImage> diskLookupTask;
+    if (mChooseCacheByImageSize) {
+      boolean alreadyInSmall = mSmallImageBufferedDiskCache.containsSync(cacheKey);
+      boolean alreadyInMain = mDefaultBufferedDiskCache.containsSync(cacheKey);
+      final BufferedDiskCache firstCache;
+      final BufferedDiskCache secondCache ;
+      if (alreadyInSmall || !alreadyInMain) {
+        firstCache = mSmallImageBufferedDiskCache;
+        secondCache = mDefaultBufferedDiskCache;
+      } else {
+        firstCache = mDefaultBufferedDiskCache;
+        secondCache = mSmallImageBufferedDiskCache;
+      }
+      diskLookupTask = firstCache.get(cacheKey, isCancelled);
+      diskLookupTask = diskLookupTask.continueWithTask(
+          new Continuation<EncodedImage, Task<EncodedImage>>() {
+        @Override
+        public Task<EncodedImage> then(Task<EncodedImage> task) throws Exception {
+          if (isTaskCancelled(task) || (!task.isFaulted() && task.getResult() != null)) {
+            return task;
           }
-        };
-
-    AtomicBoolean isCancelled = new AtomicBoolean(false);
-    final Task<EncodedImage> diskCacheLookupTask =
-        cache.get(cacheKey, isCancelled);
-    diskCacheLookupTask.continueWith(continuation);
+          return secondCache.get(cacheKey, isCancelled);
+        }
+      });
+    } else {
+      diskLookupTask = preferredCache.get(cacheKey, isCancelled);
+    }
+    Continuation<EncodedImage, Void> continuation =
+        onFinishDiskReads(consumer, preferredCache, cacheKey, producerContext);
+    diskLookupTask.continueWith(continuation);
     subscribeTaskForRequestCancellation(isCancelled, producerContext);
   }
 
+  private Continuation<EncodedImage, Void> onFinishDiskReads(
+      final Consumer<EncodedImage> consumer,
+      final BufferedDiskCache preferredCache,
+      final CacheKey preferredCacheKey,
+      final ProducerContext producerContext) {
+    final String requestId = producerContext.getId();
+    final ProducerListener listener = producerContext.getListener();
+    return new Continuation<EncodedImage, Void>() {
+      @Override
+      public Void then(Task<EncodedImage> task)
+          throws Exception {
+        if (isTaskCancelled(task)) {
+          listener.onProducerFinishWithCancellation(requestId, PRODUCER_NAME, null);
+          consumer.onCancellation();
+        } else if (task.isFaulted()) {
+          listener.onProducerFinishWithFailure(requestId, PRODUCER_NAME, task.getError(), null);
+          maybeStartInputProducer(
+              consumer,
+              new DiskCacheConsumer(consumer, preferredCache, preferredCacheKey),
+              producerContext);
+        } else {
+          EncodedImage cachedReference = task.getResult();
+          if (cachedReference != null) {
+            listener.onProducerFinishWithSuccess(
+                requestId,
+                PRODUCER_NAME,
+                getExtraMap(listener, requestId, true));
+            consumer.onProgressUpdate(1);
+            consumer.onNewResult(cachedReference, true);
+            cachedReference.close();
+          } else {
+            listener.onProducerFinishWithSuccess(
+                requestId,
+                PRODUCER_NAME,
+                getExtraMap(listener, requestId, false));
+            maybeStartInputProducer(
+                consumer,
+                new DiskCacheConsumer(consumer, preferredCache, preferredCacheKey),
+                producerContext);
+          }
+        }
+        return null;
+      }
+    };
+  }
+
+  private static boolean isTaskCancelled(Task<?> task) {
+    return task.isCancelled() ||
+        (task.isFaulted() && task.getError() instanceof CancellationException);
+  }
+
   private void maybeStartInputProducer(
       Consumer<EncodedImage> consumerOfDiskCacheProducer,
       Consumer<EncodedImage> consumerOfInputProducer,
@@ -177,7 +218,16 @@ private DiskCacheConsumer(
     @Override
     public void onNewResultImpl(EncodedImage newResult, boolean isLast) {
       if (newResult != null && isLast) {
-        mCache.put(mCacheKey, newResult);
+        if (mChooseCacheByImageSize) {
+          int size = newResult.getSize();
+          if (size > 0 && size < mForceSmallCacheThresholdBytes) {
+            mSmallImageBufferedDiskCache.put(mCacheKey, newResult);
+          } else {
+            mDefaultBufferedDiskCache.put(mCacheKey, newResult);
+          }
+        } else {
+          mCache.put(mCacheKey, newResult);
+        }
       }
       getConsumer().onNewResult(newResult, isLast);
     }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedCacheKeyMultiplexProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedCacheKeyMultiplexProducer.java
index d74adb66b..cc7d90125 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedCacheKeyMultiplexProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedCacheKeyMultiplexProducer.java
@@ -24,7 +24,9 @@
 
   private final CacheKeyFactory mCacheKeyFactory;
 
-  public EncodedCacheKeyMultiplexProducer(CacheKeyFactory cacheKeyFactory, Producer inputProducer) {
+  public EncodedCacheKeyMultiplexProducer(
+      CacheKeyFactory cacheKeyFactory,
+      Producer inputProducer) {
     super(inputProducer);
     mCacheKeyFactory = cacheKeyFactory;
   }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java
index 6dd440d32..797c10ae4 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java
@@ -9,17 +9,19 @@
 
 package com.facebook.imagepipeline.producers;
 
-import android.net.Uri;
-
-import com.facebook.imagepipeline.image.EncodedImage;
-
-import java.io.InputStream;
+import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
+import java.util.Locale;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 
+import android.net.Uri;
+
+import com.facebook.common.internal.VisibleForTesting;
+import com.facebook.imagepipeline.image.EncodedImage;
+
 /**
  * Network fetcher that uses the simplest Android stack.
  *
@@ -29,11 +31,20 @@
 public class HttpUrlConnectionNetworkFetcher extends BaseNetworkFetcher<FetchState> {
 
   private static final int NUM_NETWORK_THREADS = 3;
+  private static final int MAX_REDIRECTS = 5;
+
+  public static final int HTTP_TEMPORARY_REDIRECT = 307;
+  public static final int HTTP_PERMANENT_REDIRECT = 308;
 
   private final ExecutorService mExecutorService;
 
   public HttpUrlConnectionNetworkFetcher() {
-    mExecutorService = Executors.newFixedThreadPool(NUM_NETWORK_THREADS);
+    this(Executors.newFixedThreadPool(NUM_NETWORK_THREADS));
+  }
+
+  @VisibleForTesting
+  HttpUrlConnectionNetworkFetcher(ExecutorService executorService) {
+    mExecutorService = executorService;
   }
 
   @Override
@@ -47,36 +58,7 @@ public void fetch(final FetchState fetchState, final Callback callback) {
         new Runnable() {
           @Override
           public void run() {
-            HttpURLConnection connection = null;
-            Uri uri = fetchState.getUri();
-            String scheme = uri.getScheme();
-            String uriString = fetchState.getUri().toString();
-            while (true) {
-              String nextUriString;
-              String nextScheme;
-              InputStream is;
-              try {
-                URL url = new URL(uriString);
-                connection = (HttpURLConnection) url.openConnection();
-                nextUriString = connection.getHeaderField("Location");
-                nextScheme = (nextUriString == null) ? null : Uri.parse(nextUriString).getScheme();
-                if (nextUriString == null || nextScheme.equals(scheme)) {
-                  is = connection.getInputStream();
-                  callback.onResponse(is, -1);
-                  break;
-                }
-                uriString = nextUriString;
-                scheme = nextScheme;
-              } catch (Exception e) {
-                callback.onFailure(e);
-                break;
-              } finally {
-                if (connection != null) {
-                  connection.disconnect();
-                }
-              }
-          }
-
+            fetchSync(fetchState, callback);
           }
         });
     fetchState.getContext().addCallbacks(
@@ -89,4 +71,84 @@ public void onCancellationRequested() {
           }
         });
   }
+
+  @VisibleForTesting
+  void fetchSync(FetchState fetchState, Callback callback) {
+    HttpURLConnection connection = null;
+
+    try {
+      connection = downloadFrom(fetchState.getUri(), MAX_REDIRECTS);
+
+      if (connection != null) {
+        callback.onResponse(connection.getInputStream(), -1);
+      }
+    } catch (IOException e) {
+      callback.onFailure(e);
+    } finally {
+      if (connection != null) {
+        connection.disconnect();
+      }
+    }
+
+  }
+
+  private HttpURLConnection downloadFrom(Uri uri, int maxRedirects) throws IOException {
+    HttpURLConnection connection = openConnectionTo(uri);
+    int responseCode = connection.getResponseCode();
+
+    if (isHttpSuccess(responseCode)) {
+        return connection;
+
+    } else if (isHttpRedirect(responseCode)) {
+        String nextUriString = connection.getHeaderField("Location");
+        connection.disconnect();
+
+        Uri nextUri = (nextUriString == null) ? null : Uri.parse(nextUriString);
+        String originalScheme = uri.getScheme();
+
+        if (maxRedirects > 0 && nextUri != null && !nextUri.getScheme().equals(originalScheme)) {
+          return downloadFrom(nextUri, maxRedirects - 1);
+        } else {
+          String message = maxRedirects == 0
+              ? error("URL %s follows too many redirects", uri.toString())
+              : error("URL %s returned %d without a valid redirect", uri.toString(), responseCode);
+          throw new IOException(message);
+        }
+
+    } else {
+        connection.disconnect();
+        throw new IOException(String
+            .format("Image URL %s returned HTTP code %d", uri.toString(), responseCode));
+    }
+  }
+
+  @VisibleForTesting
+  static HttpURLConnection openConnectionTo(Uri uri) throws IOException {
+    URL url = new URL(uri.toString());
+    return (HttpURLConnection) url.openConnection();
+  }
+
+  private static boolean isHttpSuccess(int responseCode) {
+    return (responseCode >= HttpURLConnection.HTTP_OK &&
+        responseCode < HttpURLConnection.HTTP_MULT_CHOICE);
+  }
+
+  private static boolean isHttpRedirect(int responseCode) {
+    switch (responseCode) {
+      case HttpURLConnection.HTTP_MULT_CHOICE:
+      case HttpURLConnection.HTTP_MOVED_PERM:
+      case HttpURLConnection.HTTP_MOVED_TEMP:
+      case HttpURLConnection.HTTP_SEE_OTHER:
+      case HTTP_TEMPORARY_REDIRECT:
+      case HTTP_PERMANENT_REDIRECT:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  private static String error(String format, Object... args) {
+    return String.format(Locale.getDefault(), format, args);
+  }
+
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducer.java
index 81d630a99..296287c0c 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducer.java
@@ -9,53 +9,36 @@
 
 package com.facebook.imagepipeline.producers;
 
+import javax.annotation.Nullable;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.Executor;
+
 import android.content.ContentResolver;
 import android.database.Cursor;
-import android.graphics.Rect;
-import android.media.ExifInterface;
 import android.net.Uri;
 import android.provider.ContactsContract;
 import android.provider.MediaStore;
 
 import com.facebook.common.internal.VisibleForTesting;
-import com.facebook.common.logging.FLog;
-import com.facebook.imagepipeline.common.ResizeOptions;
+import com.facebook.common.util.UriUtil;
 import com.facebook.imagepipeline.image.EncodedImage;
 import com.facebook.imagepipeline.memory.PooledByteBufferFactory;
 import com.facebook.imagepipeline.request.ImageRequest;
-import com.facebook.imageutils.JfifUtil;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.Executor;
-
-import javax.annotation.Nullable;
 
 /**
  * Represents a local content Uri fetch producer.
  */
 public class LocalContentUriFetchProducer extends LocalFetchProducer {
 
-  private static final Class<?> TAG = LocalContentUriFetchProducer.class;
-
   @VisibleForTesting static final String PRODUCER_NAME = "LocalContentUriFetchProducer";
-  private static final String DISPLAY_PHOTO_PATH =
-      Uri.withAppendedPath(ContactsContract.AUTHORITY_URI, "display_photo").getPath();
   private static final String[] PROJECTION = new String[] {
       MediaStore.Images.Media._ID,
       MediaStore.Images.ImageColumns.DATA
   };
-  private static final String[] THUMBNAIL_PROJECTION = new String[] {
-      MediaStore.Images.Thumbnails.DATA
-  };
-
-  private static final Rect MINI_THUMBNAIL_DIMENSIONS = new Rect(0, 0, 512, 384);
-  private static final Rect MICRO_THUMBNAIL_DIMENSIONS = new Rect(0, 0, 96, 96);
-  private static final float ACCEPTABLE_REQUESTED_TO_ACTUAL_SIZE_RATIO = 4.0f/3;
-
-  private static final int NO_THUMBNAIL = 0;
 
   private final ContentResolver mContentResolver;
 
@@ -71,7 +54,7 @@ public LocalContentUriFetchProducer(
   @Override
   protected EncodedImage getEncodedImage(ImageRequest imageRequest) throws IOException {
     Uri uri = imageRequest.getSourceUri();
-    if (isContactUri(uri)) {
+    if (UriUtil.isLocalContactUri(uri)) {
       final InputStream inputStream;
       if (uri.toString().endsWith("/photo")) {
         inputStream =  mContentResolver.openInputStream(uri);
@@ -87,8 +70,8 @@ protected EncodedImage getEncodedImage(ImageRequest imageRequest) throws IOExcep
           EncodedImage.UNKNOWN_STREAM_SIZE);
     }
 
-    if (isCameraUri(uri)) {
-      EncodedImage cameraImage = getCameraImage(uri, imageRequest.getResizeOptions());
+    if (UriUtil.isLocalCameraUri(uri)) {
+      EncodedImage cameraImage = getCameraImage(uri);
       if (cameraImage != null) {
         return cameraImage;
       }
@@ -99,25 +82,7 @@ protected EncodedImage getEncodedImage(ImageRequest imageRequest) throws IOExcep
         EncodedImage.UNKNOWN_STREAM_SIZE);
   }
 
-  /**
-   * Checks if the given URI is a general Contact URI, and not a specific display photo.
-   * @param uri the URI to check
-   * @return true if the uri is a a Contact URI, and is not already specifying a display photo.
-   */
-  private static boolean isContactUri(Uri uri) {
-    return ContactsContract.AUTHORITY.equals(uri.getAuthority()) &&
-        !uri.getPath().startsWith(DISPLAY_PHOTO_PATH);
-  }
-
-  private static boolean isCameraUri(Uri uri) {
-    String uriString = uri.toString();
-    return uriString.startsWith(MediaStore.Images.Media.EXTERNAL_CONTENT_URI.toString()) ||
-        uriString.startsWith(MediaStore.Images.Media.INTERNAL_CONTENT_URI.toString());
-  }
-
-  private @Nullable EncodedImage getCameraImage(
-      Uri uri,
-      ResizeOptions resizeOptions) throws IOException{
+  private @Nullable EncodedImage getCameraImage(Uri uri) throws IOException {
     Cursor cursor = mContentResolver.query(uri, PROJECTION, null, null, null);
     if (cursor == null) {
       return null;
@@ -129,14 +94,6 @@ private static boolean isCameraUri(Uri uri) {
       cursor.moveToFirst();
       final String pathname =
           cursor.getString(cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA));
-      if (resizeOptions != null) {
-        int imageIdColumnIndex = cursor.getColumnIndex(MediaStore.Images.Media._ID);
-        EncodedImage thumbnail = getThumbnail(resizeOptions, cursor.getInt(imageIdColumnIndex));
-        if (thumbnail != null) {
-          thumbnail.setRotationAngle(getRotationAngle(pathname));
-          return thumbnail;
-        }
-      }
       if (pathname != null) {
         return getEncodedImage(new FileInputStream(pathname), getLength(pathname));
       }
@@ -146,61 +103,6 @@ private static boolean isCameraUri(Uri uri) {
     return null;
   }
 
-  // Gets the smallest possible thumbnail that is bigger than the requested size in the resize
-  // options or null if either the thumbnails are smaller than the requested size or there are no
-  // stored thumbnails.
-  private EncodedImage getThumbnail(ResizeOptions resizeOptions, int imageId) throws IOException{
-    int thumbnailKind = getThumbnailKind(resizeOptions);
-    if (thumbnailKind == NO_THUMBNAIL) {
-      return null;
-    }
-    Cursor thumbnailCursor = null;
-    try {
-      thumbnailCursor = MediaStore.Images.Thumbnails.queryMiniThumbnail(
-          mContentResolver,
-          imageId,
-          thumbnailKind,
-          THUMBNAIL_PROJECTION);
-      if (thumbnailCursor == null) {
-         return null;
-      }
-      thumbnailCursor.moveToFirst();
-      if (thumbnailCursor.getCount() > 0) {
-        final String thumbnailUri = thumbnailCursor.getString(
-            thumbnailCursor.getColumnIndex(MediaStore.Images.Thumbnails.DATA));
-        if (new File(thumbnailUri).exists()) {
-          return getEncodedImage(new FileInputStream(thumbnailUri), getLength(thumbnailUri));
-        }
-      }
-    } finally {
-      if (thumbnailCursor != null) {
-        thumbnailCursor.close();
-      }
-    }
-    return null;
-  }
-
-  // Returns the smallest possible thumbnail kind that has an acceptable size (meaning the resize
-  // options requested size is smaller than 4/3 its size).
-  // We can add a small interval of acceptance over the size of the thumbnail since the quality lost
-  // when scaling it to fit a view will not be significant.
-  private static int getThumbnailKind(ResizeOptions resizeOptions) {
-    if (isThumbnailBigEnough(resizeOptions, MICRO_THUMBNAIL_DIMENSIONS)) {
-      return MediaStore.Images.Thumbnails.MICRO_KIND;
-    } else if (isThumbnailBigEnough(resizeOptions, MINI_THUMBNAIL_DIMENSIONS)) {
-      return MediaStore.Images.Thumbnails.MINI_KIND;
-    }
-    return NO_THUMBNAIL;
-  }
-
-  @VisibleForTesting
-  static boolean isThumbnailBigEnough(ResizeOptions resizeOptions, Rect thumbnailDimensions) {
-    return resizeOptions.width <=
-        thumbnailDimensions.width() * ACCEPTABLE_REQUESTED_TO_ACTUAL_SIZE_RATIO
-        && resizeOptions.height <=
-        thumbnailDimensions.height() * ACCEPTABLE_REQUESTED_TO_ACTUAL_SIZE_RATIO;
-  }
-
   private static int getLength(String pathname) {
     return pathname == null ? -1 : (int) new File(pathname).length();
   }
@@ -209,17 +111,4 @@ private static int getLength(String pathname) {
   protected String getProducerName() {
     return PRODUCER_NAME;
   }
-
-  private static int getRotationAngle(String pathname) {
-    if (pathname != null) {
-      try {
-        ExifInterface exif = new ExifInterface(pathname);
-        return JfifUtil.getAutoRotateAngleFromOrientation(exif.getAttributeInt(
-            ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL));
-      } catch (IOException ioe) {
-        FLog.e(TAG, ioe, "Unable to retrieve thumbnail rotation for %s", pathname);
-      }
-    }
-    return 0;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriThumbnailFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriThumbnailFetchProducer.java
new file mode 100644
index 000000000..3df9955f1
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriThumbnailFetchProducer.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.producers;
+
+import javax.annotation.Nullable;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.concurrent.Executor;
+
+import android.content.ContentResolver;
+import android.database.Cursor;
+import android.graphics.Rect;
+import android.media.ExifInterface;
+import android.net.Uri;
+import android.provider.MediaStore;
+
+import com.facebook.common.internal.VisibleForTesting;
+import com.facebook.common.logging.FLog;
+import com.facebook.common.util.UriUtil;
+import com.facebook.imagepipeline.common.ResizeOptions;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.memory.PooledByteBufferFactory;
+import com.facebook.imagepipeline.request.ImageRequest;
+import com.facebook.imageutils.JfifUtil;
+
+/**
+ * Represents a local content Uri fetch producer.
+ */
+public class LocalContentUriThumbnailFetchProducer extends LocalFetchProducer
+    implements ThumbnailProducer<EncodedImage> {
+
+  private static final Class<?> TAG = LocalContentUriThumbnailFetchProducer.class;
+
+  @VisibleForTesting static final String PRODUCER_NAME = "LocalContentUriThumbnailFetchProducer";
+  private static final String[] PROJECTION = new String[] {
+      MediaStore.Images.Media._ID,
+      MediaStore.Images.ImageColumns.DATA
+  };
+  private static final String[] THUMBNAIL_PROJECTION = new String[] {
+      MediaStore.Images.Thumbnails.DATA
+  };
+
+  private static final Rect MINI_THUMBNAIL_DIMENSIONS = new Rect(0, 0, 512, 384);
+  private static final Rect MICRO_THUMBNAIL_DIMENSIONS = new Rect(0, 0, 96, 96);
+
+  private static final int NO_THUMBNAIL = 0;
+
+  private final ContentResolver mContentResolver;
+
+  public LocalContentUriThumbnailFetchProducer(
+      Executor executor,
+      PooledByteBufferFactory pooledByteBufferFactory,
+      ContentResolver contentResolver,
+      boolean decodeFileDescriptorEnabled) {
+    super(executor, pooledByteBufferFactory,decodeFileDescriptorEnabled);
+    mContentResolver = contentResolver;
+  }
+
+  @Override
+  public boolean canProvideImageForSize(ResizeOptions resizeOptions) {
+    return ThumbnailSizeChecker.isImageBigEnough(
+        MINI_THUMBNAIL_DIMENSIONS.width(),
+        MINI_THUMBNAIL_DIMENSIONS.height(),
+        resizeOptions);
+  }
+
+  @Override
+  protected EncodedImage getEncodedImage(ImageRequest imageRequest) throws IOException {
+    Uri uri = imageRequest.getSourceUri();
+
+    if (UriUtil.isLocalCameraUri(uri)) {
+      EncodedImage cameraImage = getCameraImage(uri, imageRequest.getResizeOptions());
+      if (cameraImage != null) {
+        return cameraImage;
+      }
+    }
+
+    return null;
+  }
+
+  private @Nullable EncodedImage getCameraImage(
+      Uri uri,
+      ResizeOptions resizeOptions) throws IOException {
+    Cursor cursor = mContentResolver.query(uri, PROJECTION, null, null, null);
+    if (cursor == null) {
+      return null;
+    }
+    try {
+      if (cursor.getCount() == 0) {
+        return null;
+      }
+      cursor.moveToFirst();
+      final String pathname =
+          cursor.getString(cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA));
+      if (resizeOptions != null) {
+        int imageIdColumnIndex = cursor.getColumnIndex(MediaStore.Images.Media._ID);
+        EncodedImage thumbnail = getThumbnail(resizeOptions, cursor.getInt(imageIdColumnIndex));
+        if (thumbnail != null) {
+          thumbnail.setRotationAngle(getRotationAngle(pathname));
+          return thumbnail;
+        }
+      }
+    } finally {
+      cursor.close();
+    }
+    return null;
+  }
+
+  // Gets the smallest possible thumbnail that is bigger than the requested size in the resize
+  // options or null if either the thumbnails are smaller than the requested size or there are no
+  // stored thumbnails.
+  private EncodedImage getThumbnail(ResizeOptions resizeOptions, int imageId) throws IOException {
+    int thumbnailKind = getThumbnailKind(resizeOptions);
+    if (thumbnailKind == NO_THUMBNAIL) {
+      return null;
+    }
+    Cursor thumbnailCursor = null;
+    try {
+      thumbnailCursor = MediaStore.Images.Thumbnails.queryMiniThumbnail(
+          mContentResolver,
+          imageId,
+          thumbnailKind,
+          THUMBNAIL_PROJECTION);
+      if (thumbnailCursor == null) {
+         return null;
+      }
+      thumbnailCursor.moveToFirst();
+      if (thumbnailCursor.getCount() > 0) {
+        final String thumbnailUri = thumbnailCursor.getString(
+            thumbnailCursor.getColumnIndex(MediaStore.Images.Thumbnails.DATA));
+        if (new File(thumbnailUri).exists()) {
+          return getEncodedImage(new FileInputStream(thumbnailUri), getLength(thumbnailUri));
+        }
+      }
+    } finally {
+      if (thumbnailCursor != null) {
+        thumbnailCursor.close();
+      }
+    }
+    return null;
+  }
+
+  // Returns the smallest possible thumbnail kind that has an acceptable size (meaning the resize
+  // options requested size is smaller than 4/3 its size).
+  // We can add a small interval of acceptance over the size of the thumbnail since the quality lost
+  // when scaling it to fit a view will not be significant.
+  private static int getThumbnailKind(ResizeOptions resizeOptions) {
+    if (ThumbnailSizeChecker.isImageBigEnough(
+        MICRO_THUMBNAIL_DIMENSIONS.width(),
+        MICRO_THUMBNAIL_DIMENSIONS.height(),
+        resizeOptions)) {
+      return MediaStore.Images.Thumbnails.MICRO_KIND;
+    } else if (ThumbnailSizeChecker.isImageBigEnough(
+        MINI_THUMBNAIL_DIMENSIONS.width(),
+        MINI_THUMBNAIL_DIMENSIONS.height(),
+        resizeOptions)) {
+      return MediaStore.Images.Thumbnails.MINI_KIND;
+    } else {
+      return NO_THUMBNAIL;
+    }
+  }
+
+  private static int getLength(String pathname) {
+    return pathname == null ? -1 : (int) new File(pathname).length();
+  }
+
+  @Override
+  protected String getProducerName() {
+    return PRODUCER_NAME;
+  }
+
+  private static int getRotationAngle(String pathname) {
+    if (pathname != null) {
+      try {
+        ExifInterface exif = new ExifInterface(pathname);
+        return JfifUtil.getAutoRotateAngleFromOrientation(exif.getAttributeInt(
+            ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL));
+      } catch (IOException ioe) {
+        FLog.e(TAG, ioe, "Unable to retrieve thumbnail rotation for %s", pathname);
+      }
+    }
+    return 0;
+  }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalExifThumbnailProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalExifThumbnailProducer.java
index 7bc7b1d5e..6f04a5bda 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalExifThumbnailProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalExifThumbnailProducer.java
@@ -26,6 +26,7 @@
 import com.facebook.common.references.CloseableReference;
 import com.facebook.common.util.UriUtil;
 import com.facebook.imageformat.ImageFormat;
+import com.facebook.imagepipeline.common.ResizeOptions;
 import com.facebook.imagepipeline.image.EncodedImage;
 import com.facebook.imagepipeline.memory.PooledByteBuffer;
 import com.facebook.imagepipeline.memory.PooledByteBufferFactory;
@@ -40,7 +41,9 @@
  * <p>At present, these thumbnails are retrieved on the java heap before being put into native
  * memory.
  */
-public class LocalExifThumbnailProducer implements Producer<EncodedImage> {
+public class LocalExifThumbnailProducer implements ThumbnailProducer<EncodedImage> {
+
+  private static final int COMMON_EXIF_THUMBNAIL_MAX_DIMENSION = 512;
 
   @VisibleForTesting static final String PRODUCER_NAME = "LocalExifThumbnailProducer";
   @VisibleForTesting static final String CREATED_THUMBNAIL = "createdThumbnail";
@@ -58,6 +61,25 @@ public LocalExifThumbnailProducer(
     mContentResolver = contentResolver;
   }
 
+  /**
+   * Checks whether the producer may be able to produce images of the specified size. This makes no
+   * promise about being able to produce images for a particular source, only generally being able
+   * to produce output of the desired resolution.
+   *
+   * <p> In this case, assumptions are made about the common size of EXIF thumbnails which is that
+   * they may be up to 512 pixels in each dimension.
+   *
+   * @param resizeOptions the resize options from the current request
+   * @return true if the producer can meet these needs
+  */
+  @Override
+  public boolean canProvideImageForSize(ResizeOptions resizeOptions) {
+    return ThumbnailSizeChecker.isImageBigEnough(
+        COMMON_EXIF_THUMBNAIL_MAX_DIMENSION,
+        COMMON_EXIF_THUMBNAIL_MAX_DIMENSION,
+        resizeOptions);
+  }
+
   @Override
   public void produceResults(
       final Consumer<EncodedImage> consumer,
@@ -172,5 +194,4 @@ private String getRealPathFromUri(final Uri srcUri) {
     final File file = new File(realPath);
     return file.exists() && file.canRead();
   }
-
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java
index f1d023d31..6b47aa410 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java
@@ -136,7 +136,7 @@ private static float calculateProgress(int downloaded, int total) {
   private void maybeHandleIntermediateResult(
       PooledByteBufferOutputStream pooledOutputStream,
       FetchState fetchState) {
-    final long nowMs = SystemClock.elapsedRealtime();
+    final long nowMs = SystemClock.uptimeMillis();
     if (shouldPropagateIntermediateResults(fetchState) &&
         nowMs - fetchState.getLastIntermediateResultTimeMs() >= TIME_BETWEEN_PARTIAL_RESULTS_MS) {
       fetchState.setLastIntermediateResultTimeMs(nowMs);
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThumbnailBranchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThumbnailBranchProducer.java
new file mode 100644
index 000000000..917ca16c7
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThumbnailBranchProducer.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.producers;
+
+import com.facebook.common.internal.Preconditions;
+import com.facebook.imagepipeline.common.ResizeOptions;
+import com.facebook.imagepipeline.image.EncodedImage;
+
+/**
+ * Producer that will attempt to retrieve a thumbnail from one or more producers.
+ *
+ * <p>The producer will try to get a result from each producer only if there is a good chance of it
+ * being able to produce a sufficient result.
+ *
+ * <p> If no underlying producer can provide a suitable result, null result is returned to the
+ * consumer
+ */
+public class ThumbnailBranchProducer implements Producer<EncodedImage> {
+
+  private final ThumbnailProducer<EncodedImage>[] mThumbnailProducers;
+
+  public ThumbnailBranchProducer(ThumbnailProducer<EncodedImage>... thumbnailProducers) {
+    mThumbnailProducers = Preconditions.checkNotNull(thumbnailProducers);
+    Preconditions.checkElementIndex(0, mThumbnailProducers.length);
+  }
+
+  @Override
+  public void produceResults(
+      final Consumer<EncodedImage> consumer,
+      final ProducerContext context) {
+    if (context.getImageRequest().getResizeOptions() == null) {
+      consumer.onNewResult(null, true);
+    } else {
+      boolean requested = produceResultsFromThumbnailProducer(0, consumer, context);
+      if (!requested) {
+        consumer.onNewResult(null, true);
+      }
+    }
+  }
+
+  private class ThumbnailConsumer extends DelegatingConsumer<EncodedImage, EncodedImage> {
+
+    private final ProducerContext mProducerContext;
+    private final int mProducerIndex;
+    private final ResizeOptions mResizeOptions;
+
+    public ThumbnailConsumer(
+        final Consumer<EncodedImage> consumer,
+        final ProducerContext producerContext, int producerIndex) {
+      super(consumer);
+      mProducerContext = producerContext;
+      mProducerIndex = producerIndex;
+      mResizeOptions = mProducerContext.getImageRequest().getResizeOptions();
+    }
+
+    @Override
+    protected void onNewResultImpl(EncodedImage newResult, boolean isLast) {
+      if (newResult != null &&
+          (!isLast || ThumbnailSizeChecker.isImageBigEnough(newResult, mResizeOptions))) {
+        getConsumer().onNewResult(newResult, isLast);
+      } else if (isLast) {
+        EncodedImage.closeSafely(newResult);
+
+        boolean fallback = produceResultsFromThumbnailProducer(
+            mProducerIndex + 1,
+            getConsumer(),
+            mProducerContext);
+
+        if (!fallback) {
+          getConsumer().onNewResult(null, true);
+        }
+      }
+    }
+
+    @Override
+    protected void onFailureImpl(Throwable t) {
+      boolean fallback =
+          produceResultsFromThumbnailProducer(mProducerIndex + 1, getConsumer(), mProducerContext);
+
+      if (!fallback) {
+        getConsumer().onFailure(t);
+      }
+    }
+  }
+
+  private boolean produceResultsFromThumbnailProducer(
+      int startIndex,
+      Consumer<EncodedImage> consumer,
+      ProducerContext context) {
+    int producerIndex =
+        findFirstProducerForSize(startIndex, context.getImageRequest().getResizeOptions());
+
+    if (producerIndex == -1) {
+      return false;
+    }
+
+    mThumbnailProducers[producerIndex]
+        .produceResults(new ThumbnailConsumer(consumer, context, producerIndex), context);
+    return true;
+  }
+
+  private int findFirstProducerForSize(int startIndex, ResizeOptions resizeOptions) {
+    for (int i = startIndex; i < mThumbnailProducers.length; i++) {
+      if (mThumbnailProducers[i].canProvideImageForSize(resizeOptions)) {
+        return i;
+      }
+    }
+
+    return -1;
+  }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThumbnailProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThumbnailProducer.java
new file mode 100644
index 000000000..9279d42dd
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThumbnailProducer.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.producers;
+
+import com.facebook.imagepipeline.common.ResizeOptions;
+
+/**
+ * Implemented producers can be queried for whether they are likely to be able to produce a result
+ * of the desired size.
+ *
+ * <p> {@link #produceResults(Consumer, ProducerContext)} may send a null image to the consumer,
+ * even if an image is available, if the ultimate image is smaller than wanted. This may happen even
+ * if the producer thought it would be able to satisfy the request.
+ */
+public interface ThumbnailProducer<T> extends Producer<T> {
+
+  /**
+   * Checks whether the producer may be able to produce images of the specified size. This makes no
+   * promise about being able to produce images for a particular source, only generally being able
+   * to produce output of the desired resolution.
+   *
+   * @param resizeOptions the resize options from the current request
+   * @return true if the producer can meet these needs
+   */
+  boolean canProvideImageForSize(ResizeOptions resizeOptions);
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThumbnailSizeChecker.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThumbnailSizeChecker.java
new file mode 100644
index 000000000..1ae1478b9
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThumbnailSizeChecker.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.producers;
+
+import com.facebook.imagepipeline.common.ResizeOptions;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imageutils.BitmapUtil;
+
+/**
+ * Utility class to consistently check whether a given thumbnail size will be sufficient for a given
+ * request with {@link com.facebook.imagepipeline.common.ResizeOptions}.
+ */
+public final class ThumbnailSizeChecker {
+
+  /**
+   * The ratio between the requested size and the minimum thumbnail size which will be considered
+   * big enough. This will allow a thumbnail which is actually 75% of the requested size to be used
+   * and scaled up.
+   */
+  public static final float ACCEPTABLE_REQUESTED_TO_ACTUAL_SIZE_RATIO = 4.0f/3;
+
+  private static final int ROTATED_90_DEGREES_CLOCKWISE = 90;
+  private static final int ROTATED_90_DEGREES_COUNTER_CLOCKWISE = 270;
+
+  /**
+   * Checks whether the producer may be able to produce images of the specified size. This makes no
+   * promise about being able to produce images for a particular source, only generally being able
+   * to produce output of the desired resolution.
+   *
+   * @param width the desired width
+   * @param height the desired height
+   * @return true if the producer can meet these needs
+   */
+  public static boolean isImageBigEnough(int width, int height, ResizeOptions resizeOptions) {
+    if (resizeOptions == null) {
+      return getAcceptableSize(width) >= BitmapUtil.MAX_BITMAP_SIZE
+          && getAcceptableSize(height) >= (int) BitmapUtil.MAX_BITMAP_SIZE;
+    } else {
+      return getAcceptableSize(width) >= resizeOptions.width
+          && getAcceptableSize(height) >= resizeOptions.height;
+    }
+  }
+
+  public static boolean isImageBigEnough(EncodedImage encodedImage, ResizeOptions resizeOptions) {
+    if (encodedImage == null) {
+      return false;
+    }
+
+    switch (encodedImage.getRotationAngle()) {
+      case ROTATED_90_DEGREES_CLOCKWISE:
+      case ROTATED_90_DEGREES_COUNTER_CLOCKWISE:
+        // Swap width and height when checking size as this will be rotated
+        return isImageBigEnough(encodedImage.getHeight(), encodedImage.getWidth(), resizeOptions);
+      default:
+        return isImageBigEnough(encodedImage.getWidth(), encodedImage.getHeight(), resizeOptions);
+    }
+  }
+
+  public static int getAcceptableSize(int size) {
+    return (int) (size * ACCEPTABLE_REQUESTED_TO_ACTUAL_SIZE_RATIO);
+  }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequestBuilder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequestBuilder.java
index ffef95ece..091ea3588 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequestBuilder.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequestBuilder.java
@@ -37,6 +37,7 @@
   private boolean mLocalThumbnailPreviewsEnabled = false;
   private Priority mRequestPriority = Priority.HIGH;
   private @Nullable Postprocessor mPostprocessor = null;
+  private boolean mDiskCacheEnabled = true;
 
   /**
    * Creates a new request builder instance. The setting will be done according to the source type.
@@ -206,14 +207,19 @@ public ImageRequestBuilder setLocalThumbnailPreviewsEnabled(boolean enabled) {
     return this;
   }
 
-  /** Returns whether the use of local thumbnails for previews is enabled */
+  /** Returns whether the use of local thumbnails for previews is enabled. */
   public boolean isLocalThumbnailPreviewsEnabled() {
     return mLocalThumbnailPreviewsEnabled;
   }
 
-  /** Returns whether the use of the disk cache is enabled */
+  /** Disables disk cache for this request, regardless where the image will come from. */
+  public void disableDiskCache() {
+    mDiskCacheEnabled = false;
+  }
+
+  /** Returns whether the use of the disk cache is enabled, which is partly dependent on the URI. */
   public boolean isDiskCacheEnabled() {
-    return UriUtil.isNetworkUri(mSourceUri);
+    return mDiskCacheEnabled && UriUtil.isNetworkUri(mSourceUri);
   }
 
   /**
@@ -226,7 +232,7 @@ public ImageRequestBuilder setRequestPriority(Priority requestPriority) {
     return this;
   }
 
-  /** Returns the request priority */
+  /** Returns the request priority. */
   public Priority getRequestPriority() {
     return mRequestPriority;
   }
diff --git a/imagepipeline/src/main/jni/Application.mk b/imagepipeline/src/main/jni/Application.mk
index 1b8034d0d..f7f46e3b8 100644
--- a/imagepipeline/src/main/jni/Application.mk
+++ b/imagepipeline/src/main/jni/Application.mk
@@ -12,7 +12,7 @@ APP_STL := gnustl_static
 # Make sure every shared lib includes a .note.gnu.build-id header
 APP_LDFLAGS := -Wl,--build-id
 
-NDK_TOOLCHAIN_VERSION := 4.8
+NDK_TOOLCHAIN_VERSION := 4.9
 
 
 # We link our libs with static stl implementation. Because of that we need to
@@ -24,4 +24,4 @@ NDK_TOOLCHAIN_VERSION := 4.8
 FRESCO_CPP_CFLAGS := -fno-weak
 
 # This hides all symbols exported from libgnustl_static
-FRESCO_CPP_LDFLAGS := -Wl,--exclude-libs,libgnustl_static.a
+FRESCO_CPP_LDFLAGS := -Wl,--gc-sections,--exclude-libs,libgnustl_static.a
diff --git a/imagepipeline/src/main/jni/bitmaps/Bitmaps.c b/imagepipeline/src/main/jni/bitmaps/Bitmaps.c
index 6edcba364..2951d739e 100644
--- a/imagepipeline/src/main/jni/bitmaps/Bitmaps.c
+++ b/imagepipeline/src/main/jni/bitmaps/Bitmaps.c
@@ -75,6 +75,54 @@ static void Bitmaps_pinBitmap(
   }
 }
 
+static jobject Bitmaps_getByteBuffer(
+  JNIEnv* env,
+  jclass clazz,
+  jobject bitmap,
+  jlong offset,
+  jlong size) {
+  UNUSED(clazz);
+  void* pixelPtr;
+  AndroidBitmapInfo bitmapInfo;
+
+  int rc = AndroidBitmap_getInfo(env, bitmap, &bitmapInfo);
+  if (rc != ANDROID_BITMAP_RESULT_SUCCESS) {
+    safe_throw_exception(env, "Failed to get Bitmap info");
+    return NULL;
+  }
+
+  if (bitmapInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888) {
+    safe_throw_exception(env, "Unexpected bitmap format");
+    return NULL;
+  }
+
+  jlong arrayLength = bitmapInfo.width * bitmapInfo.height * 4;
+  if (offset < 0 || size < 0 || offset > arrayLength || arrayLength - offset < size) {
+    safe_throw_exception(env, "Index out of bounds");
+    return NULL;
+  }
+
+  rc = AndroidBitmap_lockPixels(env, bitmap, &pixelPtr);
+  if (rc != ANDROID_BITMAP_RESULT_SUCCESS) {
+    safe_throw_exception(env, "Failed to lock Bitmap pixels");
+    return NULL;
+  }
+
+  pixelPtr = (void*) ((uint8_t*) pixelPtr + offset);
+  return (*env)->NewDirectByteBuffer(env, pixelPtr, size);
+}
+
+static void Bitmaps_releaseByteBuffer(
+  JNIEnv* env,
+  jclass clazz,
+  jobject bitmap) {
+  UNUSED(clazz);
+  int rc = AndroidBitmap_unlockPixels(env, bitmap);
+  if (rc != ANDROID_BITMAP_RESULT_SUCCESS) {
+    safe_throw_exception(env, "Failed to unlock Bitmap pixels");
+  }
+}
+
 /**
  * Efficiently copies pixels between bitmaps.
  */
@@ -130,6 +178,12 @@ static JNINativeMethod bitmaps_native_methods[] = {
   { "nativeCopyBitmap",
     "(Landroid/graphics/Bitmap;ILandroid/graphics/Bitmap;II)V",
     (void*) Bitmaps_copyBitmap },
+  { "nativeGetByteBuffer",
+    "(Landroid/graphics/Bitmap;JJ)Ljava/nio/ByteBuffer;",
+    (void*) Bitmaps_getByteBuffer },
+  { "nativeReleaseByteBuffer",
+    "(Landroid/graphics/Bitmap;)V",
+    (void*) Bitmaps_releaseByteBuffer },
 };
 
 __attribute__((visibility("default")))
diff --git a/imagepipeline/src/main/jni/imagepipeline/Android.mk b/imagepipeline/src/main/jni/imagepipeline/Android.mk
index d50417f34..9e61457b3 100644
--- a/imagepipeline/src/main/jni/imagepipeline/Android.mk
+++ b/imagepipeline/src/main/jni/imagepipeline/Android.mk
@@ -26,8 +26,6 @@ LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)
 LOCAL_LDLIBS := -llog
 LOCAL_LDFLAGS += $(FRESCO_CPP_LDFLAGS)
 
-LOCAL_SHARED_LIBRARIES += webp
-
 LOCAL_STATIC_LIBRARIES += fb_jpegturbo
 LOCAL_LDFLAGS += -Wl,--exclude-libs,libfb_jpegturbo.a
 
@@ -37,5 +35,4 @@ LOCAL_STATIC_LIBRARIES += fb_png
 LOCAL_LDFLAGS += -Wl,--exclude-libs,libfb_png.a
 
 include $(BUILD_SHARED_LIBRARY)
-$(call import-module,libwebp-0.4.3)
 $(call import-module,libjpeg-turbo-1.3.x)
diff --git a/imagepipeline/src/main/jni/third-party/libjpeg-turbo-1.3.x/Android.mk b/imagepipeline/src/main/jni/third-party/libjpeg-turbo-1.3.x/Android.mk
index 374a9f899..966024502 100644
--- a/imagepipeline/src/main/jni/third-party/libjpeg-turbo-1.3.x/Android.mk
+++ b/imagepipeline/src/main/jni/third-party/libjpeg-turbo-1.3.x/Android.mk
@@ -28,5 +28,5 @@ include $(CLEAR_VARS)
 LOCAL_MODULE:= fb_jpegturbo
 LOCAL_SRC_FILES := $(JPEGTURBO_SRC_FILES)
 LOCAL_CFLAGS := $(JPEGTURBO_CFLAGS)
-LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH) 
+LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)
 include $(BUILD_STATIC_LIBRARY)
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/BufferedDiskCacheTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/BufferedDiskCacheTest.java
index 3c45b2ea7..841490bd5 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/BufferedDiskCacheTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/BufferedDiskCacheTest.java
@@ -11,11 +11,14 @@
 
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import com.facebook.binaryresource.BinaryResource;
 import com.facebook.cache.common.CacheKey;
+import com.facebook.cache.common.MultiCacheKey;
 import com.facebook.cache.common.SimpleCacheKey;
 import com.facebook.cache.common.WriterCallback;
 import com.facebook.cache.disk.FileCache;
@@ -28,20 +31,32 @@
 import com.facebook.imagepipeline.testing.TestExecutorService;
 
 import bolts.Task;
-import org.junit.*;
-import org.junit.runner.*;
-import org.mockito.*;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
-import org.powermock.core.classloader.annotations.*;
-import org.powermock.modules.junit4.rule.*;
-import org.robolectric.*;
-import org.robolectric.annotation.*;
-
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
+import org.mockito.MockitoAnnotations;
+import org.powermock.core.classloader.annotations.PowerMockIgnore;
+import org.powermock.core.classloader.annotations.PrepareOnlyThisForTest;
+import org.powermock.modules.junit4.rule.PowerMockRule;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.same;
+import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.powermock.api.mockito.PowerMockito.*;
+import static org.powermock.api.mockito.PowerMockito.mockStatic;
 
 @RunWith(RobolectricTestRunner.class)
 @PowerMockIgnore({ "org.mockito.*", "org.robolectric.*", "android.*" })
@@ -60,7 +75,7 @@
   @Rule
   public PowerMockRule rule = new PowerMockRule();
 
-  private CacheKey mCacheKey;
+  private MultiCacheKey mCacheKey;
   private AtomicBoolean mIsCancelled;
   private BufferedDiskCache mBufferedDiskCache;
   private CloseableReference<PooledByteBuffer> mCloseableReference;
@@ -73,7 +88,12 @@ public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
     mCloseableReference = CloseableReference.of(mPooledByteBuffer);
     mEncodedImage = new EncodedImage(mCloseableReference);
-    mCacheKey = new SimpleCacheKey("http://test.uri");
+    List<CacheKey> keys = new ArrayList<>();
+    keys.add(new SimpleCacheKey("http://test.uri"));
+    keys.add(new SimpleCacheKey("http://tyrone.uri"));
+    keys.add(new SimpleCacheKey("http://ian.uri"));
+    mCacheKey = new MultiCacheKey(keys);
+
     mIsCancelled = new AtomicBoolean(false);
     FakeClock fakeClock = new FakeClock();
     mReadPriorityExecutor = new TestExecutorService(fakeClock);
@@ -96,6 +116,24 @@ public void setUp() throws Exception {
         mImageCacheStatsTracker);
   }
 
+  @Test
+  public void testHasKeySyncFromFileCache() {
+    when(mFileCache.hasKeySync(mCacheKey)).thenReturn(true);
+    assertTrue(mBufferedDiskCache.containsSync(mCacheKey));
+  }
+
+  @Test
+  public void testHasKeySyncFromStagingArea() {
+    when(mStagingArea.containsKey(mCacheKey)).thenReturn(true);
+    assertTrue(mBufferedDiskCache.containsSync(mCacheKey));
+  }
+
+  @Test
+  public void testDoesntAlwaysHaveKeySync() {
+    when(mFileCache.hasKey(mCacheKey)).thenReturn(true);
+    assertFalse(mBufferedDiskCache.containsSync(mCacheKey));
+  }
+
   @Test
   public void testQueriesDiskCache() throws Exception {
     when(mFileCache.getResource(eq(mCacheKey))).thenReturn(mBinaryResource);
@@ -109,6 +147,19 @@ public void testQueriesDiskCache() throws Exception {
     assertSame(mPooledByteBuffer, readTask.getResult().getByteBufferRef().get());
   }
 
+  @Test
+  public void testListQueriesDiskCache() throws Exception {
+    when(mFileCache.getResource(eq(mCacheKey))).thenReturn(mBinaryResource);
+    Task<EncodedImage> readTask = mBufferedDiskCache.get(mCacheKey, mIsCancelled);
+    mReadPriorityExecutor.runUntilIdle();
+    verify(mFileCache).getResource(eq(mCacheKey));
+    assertEquals(
+        2,
+        readTask.getResult().getByteBufferRef()
+            .getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+    assertSame(mPooledByteBuffer, readTask.getResult().getByteBufferRef().get());
+  }
+
   @Test
   public void testCacheGetCancellation() throws Exception {
     when(mFileCache.getResource(eq(mCacheKey))).thenReturn(mBinaryResource);
@@ -158,6 +209,14 @@ public void testCacheMiss() throws Exception {
     assertNull(readTask.getResult());
   }
 
+  @Test
+  public void testCacheMissList() throws Exception {
+    Task<EncodedImage> readTask = mBufferedDiskCache.get(mCacheKey, mIsCancelled);
+    mReadPriorityExecutor.runUntilIdle();
+    verify(mFileCache).getResource(eq(mCacheKey));
+    assertNull(readTask.getResult());
+  }
+
   @Test
   public void testPutBumpsRefCountBeforeSubmit() {
     mBufferedDiskCache.put(mCacheKey, mEncodedImage);
@@ -178,7 +237,7 @@ public void testPins() {
   }
 
   @Test
-  public void testServesPinned() throws Exception {
+  public void testFromStagingArea() throws Exception {
     when(mStagingArea.get(mCacheKey)).thenReturn(mEncodedImage);
     assertEquals(2, mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
     assertSame(
@@ -188,7 +247,7 @@ public void testServesPinned() throws Exception {
   }
 
   @Test
-  public void testServesPinned2() throws Exception {
+  public void testFromStagingAreaLater() throws Exception {
     Task<EncodedImage> readTask = mBufferedDiskCache.get(mCacheKey, mIsCancelled);
     assertFalse(readTask.isCompleted());
 
@@ -219,7 +278,7 @@ public void testUnpins() {
   }
 
   @Test
-  public void testPins2() {
+  public void testContainsFromStagingAreaLater() {
     Task<Boolean> readTask = mBufferedDiskCache.contains(mCacheKey);
     assertFalse(readTask.isCompleted());
     when(mStagingArea.get(mCacheKey)).thenReturn(mEncodedImage);
@@ -228,13 +287,13 @@ public void testPins2() {
   }
 
   @Test
-  public void testUnpins2() {
+  public void testRemoveFromStagingArea() {
     mBufferedDiskCache.remove(mCacheKey);
     verify(mStagingArea).remove(mCacheKey);
   }
 
   @Test
-  public void testUpins3() {
+  public void testClearFromStagingArea() {
     mBufferedDiskCache.clearAll();
     verify(mStagingArea).clearAll();
   }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/StagingAreaTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/StagingAreaTest.java
index 8ed66e3b8..67aaa2876 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/StagingAreaTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/cache/StagingAreaTest.java
@@ -42,6 +42,19 @@ public void setUp() {
     mStagingArea.put(mCacheKey, mEncodedImage);
   }
 
+  @Test
+  public void testContains() {
+    assertTrue(mStagingArea.containsKey(mCacheKey));
+    assertFalse(mStagingArea.containsKey(new SimpleCacheKey("http://this.is.not.uri")));
+  }
+
+  @Test
+  public void testDoesntContainInvalid() {
+    mEncodedImage.close();
+    assertTrue(mStagingArea.containsKey(mCacheKey));
+    assertTrue(EncodedImage.isValid(mStagingArea.get(mCacheKey)));
+  }
+
   @Test
   public void testGetValue() {
     assertSame(
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ImagePipelineTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ImagePipelineTest.java
index 2135e49ff..6128627de 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ImagePipelineTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ImagePipelineTest.java
@@ -9,9 +9,13 @@
 
 package com.facebook.imagepipeline.core;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import android.net.Uri;
 
 import com.facebook.cache.common.CacheKey;
+import com.facebook.cache.common.MultiCacheKey;
 import com.facebook.cache.common.SimpleCacheKey;
 import com.facebook.common.internal.Sets;
 import com.facebook.common.internal.Supplier;
@@ -284,7 +288,6 @@ public void testIdIncrementsOnEachRequest() {
   public void testEvictFromMemoryCache() {
     String uriString = "http://dummy/string";
     Uri uri = Uri.parse(uriString);
-    when(mCacheKeyFactory.getCacheKeySourceUri(uri)).thenReturn(uri);
     mImagePipeline.evictFromMemoryCache(uri);
 
     CacheKey dummyCacheKey = mock(CacheKey.class);
@@ -296,8 +299,8 @@ public void testEvictFromMemoryCache() {
         bitmapCachePredicateCaptor.getValue();
     BitmapMemoryCacheKey bitmapMemoryCacheKey1 = mock(BitmapMemoryCacheKey.class);
     BitmapMemoryCacheKey bitmapMemoryCacheKey2 = mock(BitmapMemoryCacheKey.class);
-    when(bitmapMemoryCacheKey1.getSourceUriString()).thenReturn(uriString);
-    when(bitmapMemoryCacheKey2.getSourceUriString()).thenReturn("rubbish");
+    when(bitmapMemoryCacheKey1.containsUri(uri)).thenReturn(true);
+    when(bitmapMemoryCacheKey2.containsUri(uri)).thenReturn(false);
     assertTrue(bitmapMemoryCacheKeyPredicate.apply(bitmapMemoryCacheKey1));
     assertFalse(bitmapMemoryCacheKeyPredicate.apply(bitmapMemoryCacheKey2));
     assertFalse(bitmapMemoryCacheKeyPredicate.apply(dummyCacheKey));
@@ -319,15 +322,19 @@ public void testEvictFromDiskCache() {
     String uriString = "http://dummy/string";
     Uri uri = Uri.parse(uriString);
     CacheKey dummyCacheKey = mock(CacheKey.class);
-    when(mCacheKeyFactory.getEncodedCacheKey(any(ImageRequest.class))).thenReturn(dummyCacheKey);
+    List<CacheKey> list = new ArrayList<>();
+    list.add(dummyCacheKey);
+    MultiCacheKey multiKey = new MultiCacheKey(list);
+    when(mCacheKeyFactory.getEncodedCacheKey(any(ImageRequest.class))).thenReturn(multiKey);
     mImagePipeline.evictFromDiskCache(uri);
-    verify(mMainDiskStorageCache).remove(dummyCacheKey);
-    verify(mSmallImageDiskStorageCache).remove(dummyCacheKey);
+    verify(mMainDiskStorageCache).remove(multiKey);
+    verify(mSmallImageDiskStorageCache).remove(multiKey);
   }
 
   @Test
   public void testClearMemoryCaches() {
     String uriString = "http://dummy/string";
+    Uri uri = Uri.parse(uriString);
     CacheKey dummyCacheKey = mock(CacheKey.class);
 
     mImagePipeline.clearMemoryCaches();
@@ -339,8 +346,8 @@ public void testClearMemoryCaches() {
         bitmapCachePredicateCaptor.getValue();
     BitmapMemoryCacheKey bitmapMemoryCacheKey1 = mock(BitmapMemoryCacheKey.class);
     BitmapMemoryCacheKey bitmapMemoryCacheKey2 = mock(BitmapMemoryCacheKey.class);
-    when(bitmapMemoryCacheKey1.getSourceUriString()).thenReturn(uriString);
-    when(bitmapMemoryCacheKey2.getSourceUriString()).thenReturn("rubbish");
+    when(bitmapMemoryCacheKey1.containsUri(uri)).thenReturn(true);
+    when(bitmapMemoryCacheKey2.containsUri(uri)).thenReturn(false);
     assertTrue(bitmapMemoryCacheKeyPredicate.apply(bitmapMemoryCacheKey1));
     assertTrue(bitmapMemoryCacheKeyPredicate.apply(bitmapMemoryCacheKey2));
     assertTrue(bitmapMemoryCacheKeyPredicate.apply(dummyCacheKey));
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ProducerSequenceFactoryTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ProducerSequenceFactoryTest.java
index 2faadb5b3..401846bd1 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ProducerSequenceFactoryTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ProducerSequenceFactoryTest.java
@@ -15,38 +15,30 @@
 import com.facebook.common.references.CloseableReference;
 import com.facebook.common.util.UriUtil;
 import com.facebook.imagepipeline.image.CloseableImage;
-import com.facebook.imagepipeline.image.EncodedImage;
 import com.facebook.imagepipeline.memory.PooledByteBuffer;
-import com.facebook.imagepipeline.producers.DecodeProducer;
-import com.facebook.imagepipeline.producers.LocalAssetFetchProducer;
-import com.facebook.imagepipeline.producers.LocalContentUriFetchProducer;
-import com.facebook.imagepipeline.producers.LocalExifThumbnailProducer;
-import com.facebook.imagepipeline.producers.LocalFileFetchProducer;
-import com.facebook.imagepipeline.producers.LocalResourceFetchProducer;
-import com.facebook.imagepipeline.producers.LocalVideoThumbnailProducer;
-import com.facebook.imagepipeline.producers.NetworkFetcher;
-import com.facebook.imagepipeline.producers.PostprocessorProducer;
 import com.facebook.imagepipeline.producers.Producer;
-import com.facebook.imagepipeline.producers.ResizeAndRotateProducer;
-import com.facebook.imagepipeline.producers.ThreadHandoffProducer;
-import com.facebook.imagepipeline.producers.ThrottlingProducer;
-import com.facebook.imagepipeline.producers.WebpTranscodeProducer;
 import com.facebook.imagepipeline.request.ImageRequest;
 import com.facebook.imagepipeline.request.Postprocessor;
 
-import com.facebook.imagepipeline.producers.ThreadHandoffProducerQueue;
-import org.junit.*;
-import org.junit.runner.*;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.mockito.Mock;
-import org.mockito.*;
-import org.powermock.api.mockito.*;
-import org.powermock.core.classloader.annotations.*;
-import org.powermock.modules.junit4.rule.*;
-import org.robolectric.*;
-import org.robolectric.annotation.*;
-
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
+import org.mockito.MockitoAnnotations;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PowerMockIgnore;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.modules.junit4.rule.PowerMockRule;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.mockito.Mockito.RETURNS_MOCKS;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 /**
  * Tests {@link ProducerSequenceFactory}.
@@ -59,7 +51,6 @@
 
   @Mock public ImageRequest mImageRequest;
   @Mock public Postprocessor mPostprocessor;
-  @Mock public NetworkFetcher mNetworkFetcher;
   private final String mDummyMime = "dummy_mime";
   private Uri mUri;
   private ProducerSequenceFactory mProducerSequenceFactory;
@@ -72,8 +63,10 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     PowerMockito.mockStatic(UriUtil.class, MediaUtils.class);
 
+    ProducerFactory producerFactory = mock(ProducerFactory.class, RETURNS_MOCKS);
+
     mProducerSequenceFactory =
-        new ProducerSequenceFactory(new MockProducerFactory(), null, true, true, false, null);
+        new ProducerSequenceFactory(producerFactory, null, true, true, false, null);
 
     when(mImageRequest.getLowestPermittedRequestLevel())
         .thenReturn(ImageRequest.RequestLevel.FULL_FETCH);
@@ -251,94 +244,4 @@ public void testPostprocess() {
         mProducerSequenceFactory.mPostprocessorSequences.get(
             mProducerSequenceFactory.mBackgroundNetworkFetchToEncodedMemorySequence));
   }
-
-  private static class MockProducerFactory extends ProducerFactory {
-
-    public MockProducerFactory() {
-      super(
-          RuntimeEnvironment.application,
-          null,
-          null,
-          null,
-          false,
-          false,
-          null,
-          null,
-          null,
-          null,
-          null,
-          null,
-          null,
-          null,
-          false);
-    }
-
-    @Override
-    public LocalVideoThumbnailProducer newLocalVideoThumbnailProducer() {
-      return mock(LocalVideoThumbnailProducer.class);
-    }
-
-    @Override
-    public <T> ThreadHandoffProducer<T> newBackgroundThreadHandoffProducer(
-        Producer<T> inputProducer,
-        ThreadHandoffProducerQueue inputThreadHandoffProducerQueue) {
-      return mock(ThreadHandoffProducer.class);
-    }
-
-    @Override
-    public LocalFileFetchProducer newLocalFileFetchProducer() {
-      return mock(LocalFileFetchProducer.class);
-    }
-
-    @Override
-    public LocalResourceFetchProducer newLocalResourceFetchProducer() {
-      return mock(LocalResourceFetchProducer.class);
-    }
-
-    @Override
-    public WebpTranscodeProducer newWebpTranscodeProducer(
-        Producer<EncodedImage> inputProducer) {
-      return mock(WebpTranscodeProducer.class);
-    }
-
-    @Override
-    public ResizeAndRotateProducer newResizeAndRotateProducer(
-        Producer<EncodedImage> inputProducer) {
-      return mock(ResizeAndRotateProducer.class);
-    }
-
-    @Override
-    public <T> ThrottlingProducer<T> newThrottlingProducer(
-        int maxSimultaneousRequests,
-        Producer<T> inputProducer) {
-      return mock(ThrottlingProducer.class);
-    }
-
-    @Override
-    public LocalExifThumbnailProducer newLocalExifThumbnailProducer() {
-      return mock(LocalExifThumbnailProducer.class);
-    }
-
-    @Override
-    public DecodeProducer newDecodeProducer(Producer<EncodedImage> inputProducer) {
-      return mock(DecodeProducer.class);
-    }
-
-    @Override
-    public LocalAssetFetchProducer newLocalAssetFetchProducer() {
-      return mock(LocalAssetFetchProducer.class);
-    }
-
-    @Override
-    public LocalContentUriFetchProducer newContentUriFetchProducer() {
-      return mock(LocalContentUriFetchProducer.class);
-    }
-
-    @Override
-    public PostprocessorProducer newPostprocessorProducer(
-        Producer<CloseableReference<CloseableImage>> inputProducer) {
-      return mock(PostprocessorProducer.class);
-    }
-  }
-
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducerTest.java
index 457c3a9ec..61af1bb64 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducerTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducerTest.java
@@ -11,6 +11,7 @@
 
 import com.facebook.common.references.CloseableReference;
 import com.facebook.imageformat.ImageFormat;
+import com.facebook.imagepipeline.common.ResizeOptions;
 import com.facebook.imagepipeline.image.EncodedImage;
 import com.facebook.imagepipeline.memory.PooledByteBuffer;
 import com.facebook.imagepipeline.request.ImageRequest;
@@ -58,6 +59,7 @@ public void setUp() {
     when(mProducerContext.getImageRequest()).thenReturn(mImageRequest);
     when(mImageRequest.getPreferredWidth()).thenReturn(WIDTH);
     when(mImageRequest.getPreferredHeight()).thenReturn(HEIGHT);
+    when(mImageRequest.getResizeOptions()).thenReturn(new ResizeOptions(WIDTH, HEIGHT));
     when(mImageRequest.getLocalThumbnailPreviewsEnabled()).thenReturn(true);
     mIntermediateResult = mock(EncodedImage.class);
     mFirstProducerFinalResult = mock(EncodedImage.class);
@@ -116,23 +118,23 @@ public void testFirstProducerResultNotGoodEnough() {
     EncodedImage firstProducerEncodedImage = new EncodedImage(
         mFirstProducerFinalResult.getByteBufferRef());
     firstProducerEncodedImage.setRotationAngle(-1);
-    firstProducerEncodedImage.setWidth(WIDTH - 1);
-    firstProducerEncodedImage.setHeight(HEIGHT - 1);
+    firstProducerEncodedImage.setWidth(WIDTH / 2);
+    firstProducerEncodedImage.setHeight(HEIGHT / 2);
     mFirstProducerConsumer.onNewResult(firstProducerEncodedImage, true);
     verify(mConsumer).onNewResult(firstProducerEncodedImage, false);
 
     EncodedImage intermediateEncodedImage = new EncodedImage(
         mIntermediateResult.getByteBufferRef());
     intermediateEncodedImage.setRotationAngle(-1);
-    intermediateEncodedImage.setWidth(WIDTH - 1);
-    intermediateEncodedImage.setHeight(HEIGHT - 1);
+    intermediateEncodedImage.setWidth(WIDTH / 2);
+    intermediateEncodedImage.setHeight(HEIGHT / 2);
     mSecondProducerConsumer.onNewResult(intermediateEncodedImage, false);
     verify(mConsumer).onNewResult(intermediateEncodedImage, false);
     EncodedImage secondProducerEncodedImage = new EncodedImage(
         mSecondProducerFinalResult.getByteBufferRef());
     secondProducerEncodedImage.setRotationAngle(-1);
-    secondProducerEncodedImage.setWidth(WIDTH - 1);
-    secondProducerEncodedImage.setHeight(HEIGHT - 1);
+    secondProducerEncodedImage.setWidth(WIDTH / 2);
+    secondProducerEncodedImage.setHeight(HEIGHT / 2);
     mSecondProducerConsumer.onNewResult(secondProducerEncodedImage, true);
     verify(mConsumer).onNewResult(secondProducerEncodedImage, true);
   }
@@ -170,8 +172,8 @@ public void testFirstProducerReturnsTwoResultsThumbnailsNotAllowed() {
         mIntermediateResult.getByteBufferRef());
     intermediateEncodedImage.setImageFormat(ImageFormat.JPEG);
     intermediateEncodedImage.setRotationAngle(-1);
-    intermediateEncodedImage.setWidth(WIDTH - 1);
-    intermediateEncodedImage.setHeight(HEIGHT - 1);
+    intermediateEncodedImage.setWidth(WIDTH / 2);
+    intermediateEncodedImage.setHeight(HEIGHT / 2);
     mFirstProducerConsumer.onNewResult(intermediateEncodedImage, false);
     verify(mConsumer, never()).onNewResult(intermediateEncodedImage, false);
     EncodedImage finalEncodedImage = new EncodedImage(
@@ -191,23 +193,23 @@ public void testFirstProducerResultNotGoodEnoughThumbnailsNotAllowed() {
     EncodedImage firstProducerEncodedImage = new EncodedImage(
         mFirstProducerFinalResult.getByteBufferRef());
     firstProducerEncodedImage.setRotationAngle(-1);
-    firstProducerEncodedImage.setWidth(WIDTH - 1);
-    firstProducerEncodedImage.setHeight(HEIGHT - 1);
+    firstProducerEncodedImage.setWidth(WIDTH / 2);
+    firstProducerEncodedImage.setHeight(HEIGHT / 2);
     mFirstProducerConsumer.onNewResult(firstProducerEncodedImage, true);
     verify(mConsumer, never()).onNewResult(firstProducerEncodedImage, false);
 
     EncodedImage intermediateEncodedImage = new EncodedImage(
         mIntermediateResult.getByteBufferRef());
     intermediateEncodedImage.setRotationAngle(-1);
-    intermediateEncodedImage.setWidth(WIDTH - 1);
-    intermediateEncodedImage.setHeight(HEIGHT - 1);
+    intermediateEncodedImage.setWidth(WIDTH / 2);
+    intermediateEncodedImage.setHeight(HEIGHT / 2);
     mSecondProducerConsumer.onNewResult(intermediateEncodedImage, false);
     verify(mConsumer).onNewResult(intermediateEncodedImage, false);
     EncodedImage secondProducerEncodedImage = new EncodedImage(
         mFirstProducerFinalResult.getByteBufferRef());
     secondProducerEncodedImage.setRotationAngle(-1);
-    secondProducerEncodedImage.setWidth(WIDTH - 1);
-    secondProducerEncodedImage.setHeight(HEIGHT - 1);
+    secondProducerEncodedImage.setWidth(WIDTH / 2);
+    secondProducerEncodedImage.setHeight(HEIGHT / 2);
     mSecondProducerConsumer.onNewResult(secondProducerEncodedImage, true);
     verify(mConsumer).onNewResult(secondProducerEncodedImage, true);
   }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/DiskCacheProducerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/DiskCacheProducerTest.java
index 1a575ecbf..1cd847331 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/DiskCacheProducerTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/DiskCacheProducerTest.java
@@ -9,10 +9,13 @@
 
 package com.facebook.imagepipeline.producers;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import com.facebook.cache.common.CacheKey;
+import com.facebook.cache.common.MultiCacheKey;
 import com.facebook.cache.common.SimpleCacheKey;
 import com.facebook.common.internal.ImmutableMap;
 import com.facebook.common.references.CloseableReference;
@@ -53,6 +56,7 @@
       ImmutableMap.of(DiskCacheProducer.VALUE_FOUND, "true");
   private static final Map EXPECTED_MAP_ON_CACHE_MISS =
       ImmutableMap.of(DiskCacheProducer.VALUE_FOUND, "false");
+  private static final int FORCE_SMALL_CACHE_THRESHOLD = 2048;
 
   @Mock public CacheKeyFactory mCacheKeyFactory;
   @Mock public Producer mInputProducer;
@@ -66,7 +70,7 @@
   private SettableProducerContext mProducerContext;
   private SettableProducerContext mLowestLevelProducerContext;
   private final String mRequestId = "mRequestId";
-  private CacheKey mCacheKey;
+  private MultiCacheKey mCacheKey;
   private PooledByteBuffer mIntermediatePooledByteBuffer;
   private PooledByteBuffer mFinalPooledByteBuffer;
   private CloseableReference<PooledByteBuffer> mIntermediateImageReference;
@@ -76,6 +80,7 @@
   private Task.TaskCompletionSource mTaskCompletionSource;
   private ArgumentCaptor<AtomicBoolean> mIsCancelled;
   private DiskCacheProducer mDiskCacheProducer;
+  private DiskCacheProducer mForceSmallCacheProducer;
 
   @Before
   public void setUp() {
@@ -84,8 +89,17 @@ public void setUp() {
         mDefaultBufferedDiskCache,
         mSmallImageBufferedDiskCache,
         mCacheKeyFactory,
-        mInputProducer);
-    mCacheKey = new SimpleCacheKey("http://dummy.uri");
+        mInputProducer,
+        -1);
+    mForceSmallCacheProducer = new DiskCacheProducer(
+        mDefaultBufferedDiskCache,
+        mSmallImageBufferedDiskCache,
+        mCacheKeyFactory,
+        mInputProducer,
+        FORCE_SMALL_CACHE_THRESHOLD);
+    List<CacheKey> keys = new ArrayList<>(1);
+    keys.add(new SimpleCacheKey("http://dummy.uri"));
+    mCacheKey = new MultiCacheKey(keys);
     mIntermediatePooledByteBuffer = mock(PooledByteBuffer.class);
     mFinalPooledByteBuffer = mock(PooledByteBuffer.class);
     mIntermediateImageReference = CloseableReference.of(mIntermediatePooledByteBuffer);
@@ -351,6 +365,119 @@ public void testDiskCacheGetCancelled() {
         any(Map.class));
   }
 
+  @Test
+  public void testSmallImageInSmallCache() {
+    setupDiskCacheGetNotFound(mSmallImageBufferedDiskCache);
+    setupDiskCacheGetNotFound(mDefaultBufferedDiskCache);
+    setupInputProducerSuccess();
+    when(mFinalPooledByteBuffer.size()).thenReturn(FORCE_SMALL_CACHE_THRESHOLD - 1);
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mSmallImageBufferedDiskCache).put(mCacheKey, mFinalEncodedImage);
+    verify(mDefaultBufferedDiskCache, never()).put(eq(mCacheKey), any(EncodedImage.class));
+  }
+
+  @Test
+  public void testBigImageInDefaultCache() {
+    setupDiskCacheGetNotFound(mSmallImageBufferedDiskCache);
+    setupDiskCacheGetNotFound(mDefaultBufferedDiskCache);
+    setupInputProducerSuccess();
+    when(mFinalPooledByteBuffer.size()).thenReturn(FORCE_SMALL_CACHE_THRESHOLD);
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mDefaultBufferedDiskCache).put(mCacheKey, mFinalEncodedImage);
+    verify(mSmallImageBufferedDiskCache, never()).put(eq(mCacheKey), any(EncodedImage.class));
+  }
+
+  @Test
+  public void testIgnoresSmallHintOnWrite() {
+    when(mImageRequest.getImageType()).thenReturn(ImageRequest.ImageType.SMALL);
+    setupDiskCacheGetNotFound(mSmallImageBufferedDiskCache);
+    setupDiskCacheGetNotFound(mDefaultBufferedDiskCache);
+    setupInputProducerSuccess();
+    when(mFinalPooledByteBuffer.size()).thenReturn(FORCE_SMALL_CACHE_THRESHOLD);
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mDefaultBufferedDiskCache).put(mCacheKey, mFinalEncodedImage);
+    verify(mSmallImageBufferedDiskCache, never()).put(eq(mCacheKey), any(EncodedImage.class));
+  }
+
+  @Test
+  public void testChecksSmallCacheFirst() {
+    setupDiskCacheGetSuccess(mSmallImageBufferedDiskCache);
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mDefaultBufferedDiskCache, never())
+        .get(any(MultiCacheKey.class), any(AtomicBoolean.class));
+  }
+
+  @Test
+  public void testAvoidsDiskReadWhenFoundInIndex() {
+    when(mDefaultBufferedDiskCache.containsSync(mCacheKey)).thenReturn(true);
+    setupDiskCacheGetSuccess(mDefaultBufferedDiskCache);
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mSmallImageBufferedDiskCache, never())
+        .get(any(MultiCacheKey.class), any(AtomicBoolean.class));
+  }
+
+  @Test
+  public void testReadsTwiceWhenNecessary() {
+    setupDiskCacheGetNotFound(mSmallImageBufferedDiskCache);
+    setupDiskCacheGetSuccess(mDefaultBufferedDiskCache);
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mSmallImageBufferedDiskCache).get(eq(mCacheKey), any(AtomicBoolean.class));
+    verify(mDefaultBufferedDiskCache).get(eq(mCacheKey), any(AtomicBoolean.class));
+  }
+
+  @Test
+  public void testIgnoresSmallHintIndex() {
+    when(mImageRequest.getImageType()).thenReturn(ImageRequest.ImageType.SMALL);
+    when(mDefaultBufferedDiskCache.containsSync(mCacheKey)).thenReturn(true);
+    setupDiskCacheGetSuccess(mDefaultBufferedDiskCache);
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mSmallImageBufferedDiskCache, never())
+        .get(any(MultiCacheKey.class), any(AtomicBoolean.class));
+    verify(mConsumer).onNewResult(mFinalEncodedImage, true);
+  }
+
+  @Test
+  public void testIgnoresSmallHintDisk() {
+    when(mImageRequest.getImageType()).thenReturn(ImageRequest.ImageType.SMALL);
+    setupDiskCacheGetNotFound(mSmallImageBufferedDiskCache);
+    setupDiskCacheGetSuccess(mDefaultBufferedDiskCache);
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mConsumer).onNewResult(mFinalEncodedImage, true);
+  }
+
+  @Test
+  public void testSmallFailureDoesntStopDefaultRead() {
+    setupDiskCacheGetFailure(mSmallImageBufferedDiskCache);
+    setupDiskCacheGetSuccess(mDefaultBufferedDiskCache);
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mConsumer).onNewResult(mFinalEncodedImage, true);
+    verify(mProducerListener).onProducerFinishWithSuccess(
+        mRequestId, PRODUCER_NAME, EXPECTED_MAP_ON_CACHE_HIT);
+  }
+
+  @Test
+  public void testSmallFailureDoesntStopNetwork() {
+    setupDiskCacheGetFailure(mSmallImageBufferedDiskCache);
+    setupDiskCacheGetNotFound(mDefaultBufferedDiskCache);
+    setupInputProducerSuccess();
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mConsumer).onNewResult(mFinalEncodedImage, true);
+    verify(mProducerListener).onProducerFinishWithSuccess(
+        mRequestId, PRODUCER_NAME, EXPECTED_MAP_ON_CACHE_MISS);
+  }
+
+  @Test
+  public void testCancellationStopsSecondRead() {
+    setupDiskCacheGetWait(mSmallImageBufferedDiskCache);
+    mForceSmallCacheProducer.produceResults(mConsumer, mProducerContext);
+    mTaskCompletionSource.setCancelled();
+    verify(mDefaultBufferedDiskCache, never())
+        .get(any(MultiCacheKey.class), any(AtomicBoolean.class));
+    verifyNoMoreInteractions(mInputProducer);
+    verify(mProducerListener).onProducerFinishWithCancellation(
+        mRequestId, PRODUCER_NAME, null);
+  }
+
   private void setupDiskCacheGetWait(BufferedDiskCache bufferedDiskCache) {
     mTaskCompletionSource = Task.create();
     when(bufferedDiskCache.get(eq(mCacheKey), mIsCancelled.capture()))
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducerTest.java
index f57e7cf9c..31301e3e1 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducerTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducerTest.java
@@ -16,6 +16,7 @@
 import java.util.Map;
 
 import com.facebook.cache.common.CacheKey;
+import com.facebook.cache.common.MultiCacheKey;
 import com.facebook.cache.common.SimpleCacheKey;
 import com.facebook.common.internal.ImmutableMap;
 import com.facebook.common.references.CloseableReference;
@@ -57,7 +58,7 @@
   @Mock public ImageRequest mImageRequest;
   @Mock public ProducerListener mProducerListener;
   @Mock public Exception mException;
-  private CacheKey mCacheKey;
+  private MultiCacheKey mCacheKey;
   private PooledByteBuffer mPooledByteBuffer1;
   private PooledByteBuffer mPooledByteBuffer2;
   private CloseableReference<PooledByteBuffer> mFinalImageReference;
@@ -74,7 +75,6 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     mEncodedMemoryCacheProducer =
         new EncodedMemoryCacheProducer(mMemoryCache, mCacheKeyFactory, mInputProducer);
-    mCacheKey = new SimpleCacheKey("http://dummy.uri");
     mPooledByteBuffer1 = mock(PooledByteBuffer.class);
     mPooledByteBuffer2 = mock(PooledByteBuffer.class);
     mFinalImageReference = CloseableReference.of(mPooledByteBuffer1);
@@ -83,6 +83,10 @@ public void setUp() {
     mFinalEncodedImage = new EncodedImage(mFinalImageReference);
     mIntermediateEncodedImage = new EncodedImage(mIntermediateImageReference);
     mFinalEncodedImageClone = new EncodedImage(mFinalImageReferenceClone);
+    List<CacheKey> list = new ArrayList<>();
+    list.add(new SimpleCacheKey("http://dummy.uri"));
+    mCacheKey = new MultiCacheKey(list);
+    when(mCacheKeyFactory.getEncodedCacheKey(mImageRequest)).thenReturn(mCacheKey);
 
     when(mMemoryCache.cache(mCacheKey, mFinalImageReference)).thenReturn(mFinalImageReferenceClone);
     when(mProducerContext.getImageRequest()).thenReturn(mImageRequest);
@@ -91,7 +95,7 @@ public void setUp() {
     when(mProducerContext.getId()).thenReturn(mRequestId);
     when(mProducerContext.getLowestPermittedRequestLevel())
         .thenReturn(ImageRequest.RequestLevel.FULL_FETCH);
-    when(mCacheKeyFactory.getEncodedCacheKey(mImageRequest)).thenReturn(mCacheKey);
+
   }
 
   @Test
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcherTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcherTest.java
new file mode 100644
index 000000000..89723d722
--- /dev/null
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcherTest.java
@@ -0,0 +1,230 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.producers;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.LinkedList;
+import java.util.Queue;
+
+import android.net.Uri;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.modules.junit4.PowerMockRunner;
+
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(PowerMockRunner.class)
+@PrepareForTest({ HttpUrlConnectionNetworkFetcher.class, Uri.class })
+public class HttpUrlConnectionNetworkFetcherTest {
+
+  public static final String INITIAL_TEST_URL = "http://localhost/";
+  public static final String HTTPS_URL = "https://localhost/";
+
+  @Mock private FetchState mMockFetchState;
+  @Mock private ProducerContext mMockProducerContext;
+  @Mock private NetworkFetcher.Callback mMockCallback;
+
+  private HttpUrlConnectionNetworkFetcher mFetcher;
+  private Queue<HttpURLConnection> mConnectionsQueue;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+
+    mFetcher = new HttpUrlConnectionNetworkFetcher();
+    mConnectionsQueue = new LinkedList<>();
+    mockUrlConnections();
+    mockUriParse();
+    mockFetchState();
+  }
+
+  private void mockUrlConnections() throws Exception {
+    URL mockUrl = PowerMockito.mock(URL.class);
+    PowerMockito.whenNew(URL.class).withAnyArguments().thenReturn(mockUrl);
+
+    PowerMockito.when(mockUrl.openConnection()).then(new Answer<URLConnection>() {
+      @Override
+      public URLConnection answer(InvocationOnMock invocation) throws Throwable {
+        return mConnectionsQueue.poll();
+      }
+    });
+  }
+
+  private void mockUriParse() {
+    PowerMockito.mockStatic(Uri.class);
+    PowerMockito.when(Uri.parse(anyString())).then(new Answer<Uri>() {
+      @Override
+      public Uri answer(InvocationOnMock invocation) throws Throwable {
+        return mockUri((String) invocation.getArguments()[0]);
+      }
+    });
+  }
+
+  private Uri mockUri(final String url) {
+    Uri mockUri = mock(Uri.class);
+    when(mockUri.toString()).thenReturn(url);
+    when(mockUri.getScheme()).then(new Answer<String>() {
+      @Override
+      public String answer(InvocationOnMock invocation) throws Throwable {
+        return url.substring(0, url.indexOf(':'));
+      }
+    });
+    return mockUri;
+  }
+
+  private void mockFetchState() {
+    when(mMockFetchState.getContext()).thenReturn(mMockProducerContext);
+    when(mMockFetchState.getUri()).then(new Answer<Uri>() {
+      @Override
+      public Uri answer(InvocationOnMock invocation) throws Throwable {
+        return mockUri(INITIAL_TEST_URL);
+      }
+    });
+  }
+
+  @Test
+  public void testFetchSendsSuccessToCallback() throws IOException {
+    InputStream mockInputStream = mock(InputStream.class);
+    HttpURLConnection mockConnection = mockSuccessWithStream(mockInputStream);
+
+    runFetch();
+
+    InOrder inOrder = inOrder(mMockCallback, mockConnection);
+    inOrder.verify(mockConnection).getInputStream();
+    inOrder.verify(mMockCallback).onResponse(mockInputStream, -1);
+    inOrder.verify(mockConnection).disconnect();
+
+    verifyNoMoreInteractions(mMockCallback);
+  }
+
+  @Test
+  public void testFetchSendsErrorToCallbackAfterHttpError() throws IOException {
+    HttpURLConnection mockResponse = mockFailure();
+
+    runFetch();
+
+    verify(mMockCallback).onFailure(any(IOException.class));
+    verify(mockResponse).disconnect();
+
+    verifyNoMoreInteractions(mMockCallback);
+  }
+
+  @Test
+  public void testFetchSendsSuccessToCallbackAfterRedirect() throws IOException {
+    HttpURLConnection mockRedirect = mockRedirectTo(HTTPS_URL);
+
+    InputStream mockInputStream = mock(InputStream.class);
+    HttpURLConnection mockRedirectedConnection = mockSuccessWithStream(mockInputStream);
+
+    runFetch();
+
+    verify(mockRedirect).disconnect();
+
+    InOrder inOrder = inOrder(mMockCallback, mockRedirectedConnection);
+    inOrder.verify(mMockCallback).onResponse(mockInputStream, -1);
+    inOrder.verify(mockRedirectedConnection).disconnect();
+
+    verifyNoMoreInteractions(mMockCallback);
+  }
+
+  @Test
+  public void testFetchSendsErrorToCallbackAfterRedirectToSameLocation() throws IOException {
+    HttpURLConnection mockRedirect = mockRedirectTo(INITIAL_TEST_URL);
+    HttpURLConnection mockSuccess = mockSuccess();
+
+    runFetch();
+
+    verify(mMockCallback).onFailure(any(IOException.class));
+    verify(mockRedirect).disconnect();
+    verifyZeroInteractions(mockSuccess);
+
+    verifyNoMoreInteractions(mMockCallback);
+  }
+
+  @Test
+  public void testFetchSendsErrorToCallbackAfterTooManyRedirects() throws IOException {
+    mockRedirectTo(HTTPS_URL);
+    mockRedirectTo(INITIAL_TEST_URL);
+    mockRedirectTo(HTTPS_URL);
+    mockRedirectTo(INITIAL_TEST_URL);
+    mockRedirectTo(HTTPS_URL);
+    mockRedirectTo(INITIAL_TEST_URL);
+    HttpURLConnection mockResponseAfterSixRedirects = mockSuccess();
+
+    runFetch();
+
+    verify(mMockCallback).onFailure(any(IOException.class));
+    verifyZeroInteractions(mockResponseAfterSixRedirects);
+
+    verifyNoMoreInteractions(mMockCallback);
+  }
+
+  private HttpURLConnection mockSuccess() throws IOException {
+    return mockSuccessWithStream(mock(InputStream.class));
+  }
+
+  private HttpURLConnection mockSuccessWithStream(InputStream is) throws IOException {
+    HttpURLConnection mockResponse = mock(HttpURLConnection.class);
+    when(mockResponse.getResponseCode()).thenReturn(200);
+    when(mockResponse.getInputStream()).thenReturn(is);
+
+    queueConnection(mockResponse);
+
+    return mockResponse;
+  }
+
+  private HttpURLConnection mockFailure() throws IOException {
+    HttpURLConnection mockResponse = mock(HttpURLConnection.class);
+    when(mockResponse.getResponseCode()).thenReturn(404);
+
+    queueConnection(mockResponse);
+
+    return mockResponse;
+  }
+
+  private HttpURLConnection mockRedirectTo(String redirectUrl) throws IOException {
+    HttpURLConnection mockResponse = mock(HttpURLConnection.class);
+    when(mockResponse.getResponseCode()).thenReturn(301);
+    when(mockResponse.getHeaderField("Location")).thenReturn(redirectUrl);
+
+    queueConnection(mockResponse);
+
+    return mockResponse;
+  }
+
+  private void queueConnection(HttpURLConnection connection) {
+    mConnectionsQueue.add(connection);
+  }
+
+  private void runFetch() {
+    mFetcher.fetchSync(mMockFetchState, mMockCallback);
+  }
+
+}
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducerTest.java
index c17a8eb70..4e0d5d2ee 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducerTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducerTest.java
@@ -121,25 +121,4 @@ public void testFetchLocalContentUriFailsByThrowing() throws Exception {
     verify(mProducerListener).onProducerFinishWithFailure(
         mRequestId, PRODUCER_NAME, mException, null);
   }
-
-  @Test
-  public void testIsSmallerThanThumbnail() {
-    ResizeOptions resizeOptions = new ResizeOptions(400, 800);
-    assertFalse(LocalContentUriFetchProducer.isThumbnailBigEnough(
-            resizeOptions, new Rect(0, 0, 50, 50)));
-    assertFalse(LocalContentUriFetchProducer.isThumbnailBigEnough(
-            resizeOptions, new Rect(0, 0, 500, 500)));
-    assertFalse(LocalContentUriFetchProducer.isThumbnailBigEnough(
-            resizeOptions, new Rect(0, 0, 100, 1000)));
-    assertFalse(LocalContentUriFetchProducer.isThumbnailBigEnough(
-            resizeOptions, new Rect(0, 0, 299, 600)));
-    assertFalse(LocalContentUriFetchProducer.isThumbnailBigEnough(
-            resizeOptions, new Rect(0, 0, 300, 599)));
-    assertTrue(LocalContentUriFetchProducer.isThumbnailBigEnough(
-            resizeOptions, new Rect(0, 0, 300, 600)));
-    assertTrue(LocalContentUriFetchProducer.isThumbnailBigEnough(
-            resizeOptions, new Rect(0, 0, 400, 800)));
-    assertTrue(LocalContentUriFetchProducer.isThumbnailBigEnough(
-            resizeOptions, new Rect(0, 0, 1000, 1000)));
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/LocalContentUriThumbnailFetchProducerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/LocalContentUriThumbnailFetchProducerTest.java
new file mode 100644
index 000000000..d72b3d125
--- /dev/null
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/LocalContentUriThumbnailFetchProducerTest.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.producers;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+
+import android.content.ContentResolver;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.MediaStore;
+
+import com.facebook.imagepipeline.common.Priority;
+import com.facebook.imagepipeline.common.ResizeOptions;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.memory.PooledByteBuffer;
+import com.facebook.imagepipeline.memory.PooledByteBufferFactory;
+import com.facebook.imagepipeline.request.ImageRequest;
+import com.facebook.imagepipeline.testing.FakeClock;
+import com.facebook.imagepipeline.testing.TestExecutorService;
+
+import org.junit.*;
+import org.junit.runner.*;
+import org.mockito.*;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PowerMockIgnore;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.modules.junit4.rule.PowerMockRule;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.*;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+/**
+ * Basic tests for LocalContentUriThumbnailFetchProducer
+ */
+@RunWith(RobolectricTestRunner.class)
+@PowerMockIgnore({ "org.mockito.*", "org.robolectric.*", "android.*" })
+@PrepareForTest({ LocalContentUriThumbnailFetchProducer.class, MediaStore.Images.class })
+@Config(manifest= Config.NONE)
+public class LocalContentUriThumbnailFetchProducerTest {
+  private static final String PRODUCER_NAME = LocalContentUriThumbnailFetchProducer.PRODUCER_NAME;
+  private static final String THUMBNAIL_FILE_NAME = "////sdcard/thumb.jpg";
+  private static final long THUMBNAIL_FILE_SIZE = 1374;
+
+  @Rule public PowerMockRule mPowerMockRule = new PowerMockRule();
+
+  @Mock public PooledByteBufferFactory mPooledByteBufferFactory;
+  @Mock public ContentResolver mContentResolver;
+  @Mock public Consumer<EncodedImage> mConsumer;
+  @Mock public ImageRequest mImageRequest;
+  @Mock public ProducerListener mProducerListener;
+  @Mock public Exception mException;
+  @Mock public Cursor mCursor;
+  @Mock public File mThumbnailFile;
+
+  private TestExecutorService mExecutor;
+  private SettableProducerContext mProducerContext;
+  private final String mRequestId = "mRequestId";
+  private Uri mContentUri;
+  private LocalContentUriThumbnailFetchProducer mLocalContentUriThumbnailFetchProducer;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+
+    mExecutor = new TestExecutorService(new FakeClock());
+    mLocalContentUriThumbnailFetchProducer = new LocalContentUriThumbnailFetchProducer(
+        mExecutor,
+        mPooledByteBufferFactory,
+        mContentResolver,
+        false);
+    mContentUri = Uri.parse("content://media/external/images/media/1");
+
+    mProducerContext = new SettableProducerContext(
+        mImageRequest,
+        mRequestId,
+        mProducerListener,
+        mock(Object.class),
+        ImageRequest.RequestLevel.FULL_FETCH,
+        false,
+        true,
+        Priority.MEDIUM);
+    when(mImageRequest.getSourceUri()).thenReturn(mContentUri);
+
+    mockMediaStoreCursor();
+    mockThumbnailFile();
+    mockContentResolver();
+  }
+
+  private void mockMediaStoreCursor() {
+    PowerMockito.mockStatic(MediaStore.Images.Thumbnails.class, File.class);
+    PowerMockito.when(MediaStore.Images.Thumbnails
+        .queryMiniThumbnail(any(ContentResolver.class), anyLong(), anyInt(), any(String[].class)))
+        .thenReturn(mCursor);
+
+    final int dataColumnIndex = 5;
+    when(mCursor.getColumnIndex(MediaStore.Images.Thumbnails.DATA)).thenReturn(dataColumnIndex);
+    when(mCursor.getString(dataColumnIndex)).thenReturn(THUMBNAIL_FILE_NAME);
+    when(mCursor.getCount()).thenReturn(1);
+  }
+
+  private void mockThumbnailFile() throws Exception {
+    PowerMockito.whenNew(File.class)
+        .withArguments(THUMBNAIL_FILE_NAME)
+        .thenReturn(mThumbnailFile);
+    when(mThumbnailFile.exists()).thenReturn(true);
+    when(mThumbnailFile.length()).thenReturn(THUMBNAIL_FILE_SIZE);
+
+    PowerMockito.whenNew(FileInputStream.class)
+        .withArguments(THUMBNAIL_FILE_NAME)
+        .thenReturn(mock(FileInputStream.class));
+
+    EncodedImage encodedImage = mock(EncodedImage.class);
+    when(encodedImage.getSize()).thenReturn((int) THUMBNAIL_FILE_SIZE);
+
+    PowerMockito.whenNew(EncodedImage.class)
+        .withAnyArguments()
+        .thenReturn(encodedImage);
+  }
+
+  private void mockContentResolver() throws Exception {
+    when(mContentResolver.query(
+        eq(mContentUri),
+        any(String[].class),
+        any(String.class),
+        any(String[].class),
+        any(String.class))).thenReturn(mCursor);
+    when(mContentResolver.openInputStream(mContentUri)).thenReturn(mock(InputStream.class));
+  }
+
+  @Test
+  public void testLocalContentUriFetchCancelled() {
+    mockResizeOptions(512, 384);
+
+    produceResults();
+
+    mProducerContext.cancel();
+    verify(mProducerListener).onProducerStart(mRequestId, PRODUCER_NAME);
+    verify(mProducerListener).onProducerFinishWithCancellation(mRequestId, PRODUCER_NAME, null);
+    verify(mConsumer).onCancellation();
+    mExecutor.runUntilIdle();
+    verifyZeroInteractions(mPooledByteBufferFactory);
+  }
+
+  @Test
+  public void testFetchLocalContentUri() throws Exception {
+    mockResizeOptions(512, 384);
+
+    PooledByteBuffer pooledByteBuffer = mock(PooledByteBuffer.class);
+    when(mPooledByteBufferFactory.newByteBuffer(any(InputStream.class)))
+        .thenReturn(pooledByteBuffer);
+
+    produceResultsAndRunUntilIdle();
+
+    assertConsumerReceivesImage();
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testFetchLocalContentUriFailsByThrowing() throws Exception {
+    mockResizeOptions(512, 384);
+
+    when(mPooledByteBufferFactory.newByteBuffer(any(InputStream.class))).thenThrow(mException);
+    verify(mConsumer).onFailure(mException);
+    verify(mProducerListener).onProducerStart(mRequestId, PRODUCER_NAME);
+    verify(mProducerListener).onProducerFinishWithFailure(
+        mRequestId, PRODUCER_NAME, mException, null);
+  }
+
+  @Test
+  public void testIsLargerThanThumbnailMaxSize() {
+    mockResizeOptions(1000, 384);
+
+    produceResultsAndRunUntilIdle();
+
+    assertConsumerReceivesNull();
+  }
+
+  @Test
+  public void testWithoutResizeOptions() {
+    produceResultsAndRunUntilIdle();
+
+    assertConsumerReceivesNull();
+  }
+
+  private void mockResizeOptions(int width, int height) {
+    ResizeOptions resizeOptions = new ResizeOptions(width, height);
+    when(mImageRequest.getResizeOptions()).thenReturn(resizeOptions);
+  }
+
+  private void produceResults() {
+    mLocalContentUriThumbnailFetchProducer.produceResults(mConsumer, mProducerContext);
+  }
+
+  private void produceResultsAndRunUntilIdle() {
+    mLocalContentUriThumbnailFetchProducer.produceResults(mConsumer, mProducerContext);
+    mExecutor.runUntilIdle();
+  }
+
+  private void assertConsumerReceivesNull() {
+    verify(mConsumer).onNewResult(null, true);
+    verifyNoMoreInteractions(mConsumer);
+
+    verifyZeroInteractions(mPooledByteBufferFactory);
+  }
+
+  private void assertConsumerReceivesImage() {
+    ArgumentCaptor<EncodedImage> resultCaptor = ArgumentCaptor.forClass(EncodedImage.class);
+    verify(mConsumer).onNewResult(resultCaptor.capture(), eq(true));
+
+    assertNotNull(resultCaptor.getValue());
+    assertEquals(THUMBNAIL_FILE_SIZE, resultCaptor.getValue().getSize());
+
+    verifyNoMoreInteractions(mConsumer);
+  }
+}
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/NetworkFetchProducerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/NetworkFetchProducerTest.java
index 43928f35c..4ce746be3 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/NetworkFetchProducerTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/NetworkFetchProducerTest.java
@@ -123,7 +123,7 @@ public void testExceptionInFetchImage() {
   @Test(timeout = 5000)
   public void testNoIntermediateResults() throws Exception {
     long currentTime = 86400l;
-    when(SystemClock.elapsedRealtime()).thenReturn(currentTime);
+    when(SystemClock.uptimeMillis()).thenReturn(currentTime);
     NetworkFetcher.Callback callback = performFetch();
 
     when(mNetworkFetcher.shouldPropagate(any(FetchState.class))).thenReturn(false);
@@ -161,7 +161,7 @@ public void testNoIntermediateResults() throws Exception {
   @Test(timeout = 5000)
   public void testDownloadHandler() throws Exception {
     long currentTime = 86400l;
-    when(SystemClock.elapsedRealtime()).thenReturn(currentTime);
+    when(SystemClock.uptimeMillis()).thenReturn(currentTime);
     NetworkFetcher.Callback callback = performFetch();
 
     when(mNetworkFetcher.shouldPropagate(any(FetchState.class))).thenReturn(true);
@@ -196,7 +196,7 @@ public void testDownloadHandler() throws Exception {
 
     // Read another 1024 bytes - this time bump timer. Consumer should be notified
     currentTime += NetworkFetchProducer.TIME_BETWEEN_PARTIAL_RESULTS_MS;
-    when(SystemClock.elapsedRealtime()).thenReturn(currentTime);
+    when(SystemClock.uptimeMillis()).thenReturn(currentTime);
     inputStream.increaseBytesToRead(1024);
     inputStream.waitUntilReadingThreadBlocked();
     verify(mProducerListener, times(2)).onProducerEvent(
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/RepeatedPostprocessorProducerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/RepeatedPostprocessorProducerTest.java
index a1998da59..bbc32c710 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/RepeatedPostprocessorProducerTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/RepeatedPostprocessorProducerTest.java
@@ -20,7 +20,6 @@
 import com.facebook.common.references.ResourceReleaser;
 import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
 import com.facebook.imagepipeline.common.Priority;
-import com.facebook.imagepipeline.image.CloseableAnimatedImage;
 import com.facebook.imagepipeline.image.CloseableImage;
 import com.facebook.imagepipeline.image.CloseableStaticBitmap;
 import com.facebook.imagepipeline.producers.PostprocessorProducer.RepeatedPostprocessorConsumer;
@@ -132,31 +131,6 @@ public void testIntermediateImageIsNotProcessed() {
     verify(mSourceCloseableStaticBitmap).close();
   }
 
-  @Test
-  public void testNonStaticBitmapIsPassedOn() {
-    RepeatedPostprocessorConsumer postprocessorConsumer = produceResults();
-    RepeatedPostprocessorRunner repeatedPostprocessorRunner = getRunner();
-
-    CloseableAnimatedImage sourceCloseableAnimatedImage = mock(CloseableAnimatedImage.class);
-    CloseableReference<CloseableImage> sourceCloseableImageRef =
-        CloseableReference.<CloseableImage>of(sourceCloseableAnimatedImage);
-    postprocessorConsumer.onNewResult(sourceCloseableImageRef, true);
-    sourceCloseableImageRef.close();
-    mTestExecutorService.runUntilIdle();
-
-    mInOrder.verify(mConsumer).onNewResult(any(CloseableReference.class), eq(false));
-    mInOrder.verifyNoMoreInteractions();
-
-    assertEquals(1, mResults.size());
-    CloseableReference<CloseableImage> res0 = mResults.get(0);
-    assertTrue(CloseableReference.isValid(res0));
-    assertSame(sourceCloseableAnimatedImage, res0.get());
-    res0.close();
-
-    performCancelAndVerifyOnCancellation();
-    verify(sourceCloseableAnimatedImage).close();
-  }
-
   @Test
   public void testPostprocessSuccessful() {
     RepeatedPostprocessorConsumer postprocessorConsumer = produceResults();
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/SingleUsePostprocessorProducerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/SingleUsePostprocessorProducerTest.java
index e1f18cda4..073ace270 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/SingleUsePostprocessorProducerTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/SingleUsePostprocessorProducerTest.java
@@ -19,7 +19,6 @@
 import com.facebook.common.references.CloseableReference;
 import com.facebook.common.references.ResourceReleaser;
 import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
-import com.facebook.imagepipeline.image.CloseableAnimatedImage;
 import com.facebook.imagepipeline.image.CloseableImage;
 import com.facebook.imagepipeline.image.CloseableStaticBitmap;
 import com.facebook.imagepipeline.producers.PostprocessorProducer.SingleUsePostprocessorConsumer;
@@ -123,28 +122,6 @@ public void testIntermediateImageIsNotProcessed() {
 
   }
 
-  @Test
-  public void testNonStaticBitmapIsPassedOn() {
-    SingleUsePostprocessorConsumer postprocessorConsumer = produceResults();
-    CloseableAnimatedImage sourceCloseableAnimatedImage = mock(CloseableAnimatedImage.class);
-    CloseableReference<CloseableImage> sourceCloseableImageRef =
-        CloseableReference.<CloseableImage>of(sourceCloseableAnimatedImage);
-    postprocessorConsumer.onNewResult(sourceCloseableImageRef, true);
-    sourceCloseableImageRef.close();
-    mTestExecutorService.runUntilIdle();
-
-    mInOrder.verify(mConsumer).onNewResult(any(CloseableReference.class), eq(true));
-    mInOrder.verifyNoMoreInteractions();
-
-    assertEquals(1, mResults.size());
-    CloseableReference<CloseableImage> res0 = mResults.get(0);
-    assertTrue(CloseableReference.isValid(res0));
-    assertSame(sourceCloseableAnimatedImage, res0.get());
-    res0.close();
-
-    verify(sourceCloseableAnimatedImage).close();
-  }
-
   @Test
   public void testSuccess() {
     SingleUsePostprocessorConsumer postprocessorConsumer = produceResults();
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/ThumbnailBranchProducerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/ThumbnailBranchProducerTest.java
new file mode 100644
index 000000000..7a5735176
--- /dev/null
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/ThumbnailBranchProducerTest.java
@@ -0,0 +1,276 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.producers;
+
+import java.io.IOException;
+import java.lang.reflect.Array;
+
+import com.facebook.imagepipeline.common.ResizeOptions;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.request.ImageRequest;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ThumbnailBranchProducerTest {
+
+  private static final int[] THUMBNAIL_WIDTHS = {100, 400, 800};
+  private static final int[] THUMBNAIL_HEIGHTS = {100, 600, 400};
+
+  private static final EncodedImage THROW_FAILURE = mock(EncodedImage.class);
+
+  @Mock private ProducerContext mProducerContext;
+  @Mock private ImageRequest mImageRequest;
+  @Mock private Consumer<EncodedImage> mImageConsumer;
+  private ThumbnailProducer<EncodedImage>[] mThumbnailProducers;
+
+  private ThumbnailBranchProducer mProducer;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    when(mProducerContext.getImageRequest()).thenReturn(mImageRequest);
+
+    mThumbnailProducers =
+        (ThumbnailProducer<EncodedImage>[]) Array.newInstance(ThumbnailProducer.class, 3);
+    for (int i = 0; i < mThumbnailProducers.length; i++) {
+      mThumbnailProducers[i] = mock(ThumbnailProducer.class);
+      mockProducerToSupportSize(mThumbnailProducers[i], THUMBNAIL_WIDTHS[i], THUMBNAIL_HEIGHTS[i]);
+    }
+
+    mProducer = new ThumbnailBranchProducer(mThumbnailProducers);
+  }
+
+  @Test
+  public void testNullReturnedIfNoResizeOptions() {
+    mProducer.produceResults(mImageConsumer, mProducerContext);
+
+    verify(mImageConsumer).onNewResult(null, true);
+    verifyZeroInteractions((Object[]) mThumbnailProducers);
+  }
+
+  @Test
+  public void testFirstProducerUsedIfSufficientForResizeOptions() {
+    mockRequestWithResizeOptions(THUMBNAIL_WIDTHS[0], THUMBNAIL_HEIGHTS[0]);
+
+    EncodedImage firstImage = mockEncodedImage(THUMBNAIL_WIDTHS[0], THUMBNAIL_HEIGHTS[0], 0);
+    mockProducersToProduce(firstImage);
+
+    mProducer.produceResults(mImageConsumer, mProducerContext);
+
+    verify(mImageConsumer).onNewResult(firstImage, true);
+    verifyZeroInteractions(mThumbnailProducers[1], mThumbnailProducers[2]);
+  }
+
+  @Test
+  public void testSecondProducerUsedIfSufficientForResizeOptions() {
+    mockRequestWithResizeOptions(THUMBNAIL_WIDTHS[0] + 50, THUMBNAIL_HEIGHTS[0] + 50);
+
+    EncodedImage secondImage = mockEncodedImage(THUMBNAIL_WIDTHS[1], THUMBNAIL_HEIGHTS[1], 0);
+    mockProducersToProduce(
+        mockEncodedImage(THUMBNAIL_WIDTHS[0] + 50, THUMBNAIL_HEIGHTS[0] + 50, 0),
+        secondImage);
+
+    mProducer.produceResults(mImageConsumer, mProducerContext);
+
+    verify(mImageConsumer).onNewResult(secondImage, true);
+    verifyZeroInteractions(mThumbnailProducers[2]);
+  }
+
+  @Test
+  public void testFinalProducerUsedIfFirstTwoReturnNullOrFailure() {
+    mockRequestWithResizeOptions(THUMBNAIL_WIDTHS[0] - 50, THUMBNAIL_HEIGHTS[0] - 50);
+
+    EncodedImage thirdImage = mockEncodedImage(THUMBNAIL_WIDTHS[2], THUMBNAIL_HEIGHTS[2], 0);
+    mockProducersToProduce(THROW_FAILURE, null, thirdImage);
+
+    mProducer.produceResults(mImageConsumer, mProducerContext);
+
+    verify(mImageConsumer).onNewResult(thirdImage, true);
+    verifyAllProducersRequestedForResults();
+  }
+
+  @Test
+  public void testNullReturnedIfNoProducerSufficientForResizeOptions() {
+    int width = THUMBNAIL_WIDTHS[2] + 50;
+    int height = THUMBNAIL_HEIGHTS[2] + 50;
+    mockRequestWithResizeOptions(width, height);
+
+    mProducer.produceResults(mImageConsumer, mProducerContext);
+
+    verify(mImageConsumer).onNewResult(null, true);
+    ResizeOptions resizeOptions = new ResizeOptions(width, height);
+    verify(mThumbnailProducers[0]).canProvideImageForSize(resizeOptions);
+    verify(mThumbnailProducers[1]).canProvideImageForSize(resizeOptions);
+    verify(mThumbnailProducers[2]).canProvideImageForSize(resizeOptions);
+    verifyNoMoreInteractions((Object[]) mThumbnailProducers);
+  }
+
+  @Test
+  public void testNullReturnedIfAllProducersFailOrReturnNullEndingWithNull() {
+    int width = THUMBNAIL_WIDTHS[0] - 10;
+    int height = THUMBNAIL_HEIGHTS[0] - 10;
+    mockRequestWithResizeOptions(width, height);
+
+    mockProducersToProduce(null, THROW_FAILURE, null);
+
+    mProducer.produceResults(mImageConsumer, mProducerContext);
+
+    verify(mImageConsumer).onNewResult(null, true);
+    verifyAllProducersRequestedForResults();
+  }
+
+  @Test
+  public void testFailureReturnedIfAllProducersFailOrReturnNullEndingWithFailure() {
+    int width = THUMBNAIL_WIDTHS[0];
+    int height = THUMBNAIL_HEIGHTS[0];
+    mockRequestWithResizeOptions(width, height);
+
+    mockProducersToProduce(null, null, THROW_FAILURE);
+
+    mProducer.produceResults(mImageConsumer, mProducerContext);
+
+    verify(mImageConsumer).onFailure(any(Throwable.class));
+    verifyAllProducersRequestedForResults();
+  }
+
+  @Test
+  public void testFinalProducerUsedIfFirstTwoReturnTooSmallImages() {
+    int desiredWidth = THUMBNAIL_WIDTHS[0] - 50;
+    int desiredHeight = THUMBNAIL_HEIGHTS[0] - 50;
+    mockRequestWithResizeOptions(desiredWidth, desiredHeight);
+
+    EncodedImage thirdImage = mockEncodedImage(THUMBNAIL_WIDTHS[2], THUMBNAIL_HEIGHTS[2], 0);
+    mockProducersToProduce(
+        mockEncodedImage(desiredWidth / 2, desiredHeight / 2, 0),
+        mockEncodedImage(desiredWidth / 2, desiredHeight / 2, 0),
+        thirdImage);
+
+    mProducer.produceResults(mImageConsumer, mProducerContext);
+
+    verify(mImageConsumer).onNewResult(thirdImage, true);
+    verifyAllProducersRequestedForResults();
+  }
+
+  @Test
+  public void testSecondProducerUsedIfImageBigEnoughWhenRotated() {
+    mockRequestWithResizeOptions(THUMBNAIL_WIDTHS[1], THUMBNAIL_HEIGHTS[1]);
+
+    EncodedImage secondImage =
+        mockEncodedImage(THUMBNAIL_HEIGHTS[1] * 3 / 4, THUMBNAIL_WIDTHS[1] * 3 / 4, 90);
+    mockProducersToProduce(
+        mockEncodedImage(THUMBNAIL_WIDTHS[0], THUMBNAIL_HEIGHTS[0], 0),
+        secondImage);
+
+    mProducer.produceResults(mImageConsumer, mProducerContext);
+
+    verify(mImageConsumer).onNewResult(secondImage, true);
+    verifyZeroInteractions(mThumbnailProducers[2]);
+  }
+
+  @Test
+  public void testNullReturnedIfLastImageNotBigEnoughWhenRotated() {
+    mockRequestWithResizeOptions(THUMBNAIL_WIDTHS[2], THUMBNAIL_HEIGHTS[2]);
+
+    mockProducersToProduce(
+        mockEncodedImage(THUMBNAIL_WIDTHS[0], THUMBNAIL_HEIGHTS[0], 0),
+        mockEncodedImage(THUMBNAIL_WIDTHS[1], THUMBNAIL_HEIGHTS[1], 0),
+        mockEncodedImage(THUMBNAIL_HEIGHTS[2] / 2, THUMBNAIL_WIDTHS[2] / 2, 90));
+
+    mProducer.produceResults(mImageConsumer, mProducerContext);
+
+    verify(mImageConsumer).onNewResult(null, true);
+    verify(mThumbnailProducers[2]).produceResults(any(Consumer.class), any(ProducerContext.class));
+  }
+
+  private void mockRequestWithResizeOptions(int width, int height) {
+    ResizeOptions resizeOptions = new ResizeOptions(width, height);
+    when(mImageRequest.getResizeOptions()).thenReturn(resizeOptions);
+  }
+
+  private static EncodedImage mockEncodedImage(int width, int height, int rotationAngle) {
+    EncodedImage mockImage = mock(EncodedImage.class);
+    when(mockImage.getWidth()).thenReturn(width);
+    when(mockImage.getHeight()).thenReturn(height);
+    when(mockImage.getRotationAngle()).thenReturn(rotationAngle);
+    return mockImage;
+  }
+
+  private static void mockProducerToSupportSize(
+      ThumbnailProducer<EncodedImage> mockProducer,
+      final int width,
+      final int height) {
+    when(mockProducer.canProvideImageForSize(any(ResizeOptions.class))).then(new Answer<Boolean>() {
+      @Override
+      public Boolean answer(InvocationOnMock invocation) throws Throwable {
+        ResizeOptions resizeOptions = (ResizeOptions) invocation.getArguments()[0];
+        return resizeOptions.width <= width && resizeOptions.height <= height;
+      }
+    });
+  }
+
+  private void mockProducersToProduce(final EncodedImage... images) {
+    for (int i = 0; i < images.length; i++) {
+      final EncodedImage image = images[i];
+      whenProduceResultsCalledTrigger(mThumbnailProducers[i], new ConsumerCallback() {
+        @Override
+        public void callback(Consumer<EncodedImage> consumer) {
+          if (image == THROW_FAILURE) {
+            consumer.onFailure(new IOException("IMAGE FAILED"));
+          } else {
+            consumer.onNewResult(image, true);
+          }
+        }
+      });
+    }
+  }
+
+  private static void whenProduceResultsCalledTrigger(
+      ThumbnailProducer<EncodedImage> mockProducer,
+      final ConsumerCallback callback) {
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocation) throws Throwable {
+        Consumer<EncodedImage> consumer = (Consumer<EncodedImage>) invocation.getArguments()[0];
+        callback.callback(consumer);
+        return null;
+      }
+    }).when(mockProducer).produceResults(any(Consumer.class), any(ProducerContext.class));
+  }
+
+  private void verifyAllProducersRequestedForResults() {
+    verify(mThumbnailProducers[0]).produceResults(any(Consumer.class), any(ProducerContext.class));
+    verify(mThumbnailProducers[1]).produceResults(any(Consumer.class), any(ProducerContext.class));
+    verify(mThumbnailProducers[2]).produceResults(any(Consumer.class), any(ProducerContext.class));
+  }
+
+  private interface ConsumerCallback {
+
+    void callback(Consumer<EncodedImage> consumer);
+  }
+}
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/ThumbnailSizeCheckerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/ThumbnailSizeCheckerTest.java
new file mode 100644
index 000000000..74bc69d6d
--- /dev/null
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/ThumbnailSizeCheckerTest.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.imagepipeline.producers;
+
+import com.facebook.imagepipeline.common.ResizeOptions;
+import com.facebook.imagepipeline.image.EncodedImage;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class ThumbnailSizeCheckerTest {
+
+  private static final int BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS = 1536;
+
+  private static final int[] IMAGE_WIDTHS = { 75, 300, 450 };
+  private static final int[] IMAGE_HEIGHTS = { 150, 300, 100 };
+  private static final int[] REQUEST_WIDTHS = { 100, 400, 600 };
+  private static final int[] REQUEST_HEIGHTS = { 200, 400, 133 };
+  private static final int TEST_COUNT = IMAGE_WIDTHS.length;
+
+  @Test
+  public void testWithWidthAndHeightAndResizeOptionsNotMoreThan133PercentOfActual() {
+    for (int i = 0; i < TEST_COUNT; i++) {
+      ResizeOptions resizeOptions = new ResizeOptions(REQUEST_WIDTHS[i], REQUEST_HEIGHTS[i]);
+      assertTrue(ThumbnailSizeChecker
+          .isImageBigEnough(IMAGE_WIDTHS[i], IMAGE_HEIGHTS[i], resizeOptions));
+    }
+  }
+
+  @Test
+  public void testWithWidthAndHeightAndResizeOptionsWithWidthMoreThan133PercentOfActual() {
+    testWithWidthAndHeightNotBigEnoughForResizeOptions(1, 0);
+  }
+
+  @Test
+  public void testWithWidthAndHeightAndResizeOptionsWithHeightMoreThan133PercentOfActual() {
+    testWithWidthAndHeightNotBigEnoughForResizeOptions(0, 1);
+  }
+
+  private static void testWithWidthAndHeightNotBigEnoughForResizeOptions(
+      int additionalRequestWidth,
+      int additionalRequestHeight) {
+    for (int i = 0; i < TEST_COUNT; i++) {
+      ResizeOptions resizeOptions = new ResizeOptions(
+          REQUEST_WIDTHS[i] + additionalRequestWidth,
+          REQUEST_HEIGHTS[i] + additionalRequestHeight);
+      assertFalse(ThumbnailSizeChecker
+          .isImageBigEnough(IMAGE_WIDTHS[i], IMAGE_HEIGHTS[i], resizeOptions));
+    }
+  }
+
+  @Test
+  public void testWithLargeEnoughWidthAndHeightWhenNoResizeOptions() {
+    assertTrue(ThumbnailSizeChecker.isImageBigEnough(
+        BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS,
+        BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS,
+        null));
+  }
+
+  @Test
+  public void testWithInsufficientWidthWhenNoResizeOptions() {
+    assertFalse(ThumbnailSizeChecker.isImageBigEnough(
+        BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS - 1,
+        BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS,
+        null));
+  }
+
+  @Test
+  public void testWithInsufficientHeightWhenNoResizeOptions() {
+    assertFalse(ThumbnailSizeChecker.isImageBigEnough(
+        BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS,
+        BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS - 1,
+        null));
+  }
+
+  @Test
+  public void testWithImageAndResizeOptionsNotMoreThan133PercentOfActual() {
+    testWithImageBigEnoughForResizeOptions(IMAGE_WIDTHS, IMAGE_HEIGHTS, 0);
+  }
+
+  @Test
+  public void testWithRotatedImageAndResizeOptionsNotMoreThan133PercentOfActual() {
+    testWithImageBigEnoughForResizeOptions(IMAGE_HEIGHTS, IMAGE_WIDTHS, 90);
+  }
+
+  private static void testWithImageBigEnoughForResizeOptions(
+      int[] imageWidths,
+      int[] imageHeights,
+      int startRotation) {
+    for (int rotation = startRotation; rotation < 360; rotation += 180) {
+      for (int i = 0; i < TEST_COUNT; i++) {
+        EncodedImage encodedImage = mockImage(imageWidths[i], imageHeights[i], rotation);
+        ResizeOptions resizeOptions = new ResizeOptions(REQUEST_WIDTHS[i], REQUEST_HEIGHTS[i]);
+        assertTrue(ThumbnailSizeChecker.isImageBigEnough(encodedImage, resizeOptions));
+      }
+    }
+  }
+
+  @Test
+  public void testWithImageAndResizeOptionsWithWidthMoreThan133PercentOfActual() {
+    testWithImageNotBigEnoughForResizeOptions(IMAGE_WIDTHS, IMAGE_HEIGHTS, 0, 1, 0);
+  }
+
+  @Test
+  public void testWithImageAndResizeOptionsWithHeightMoreThan133PercentOfActual() {
+    testWithImageNotBigEnoughForResizeOptions(IMAGE_WIDTHS, IMAGE_HEIGHTS, 0, 0, 1);
+  }
+
+  @Test
+  public void testWithRotatedImageAndResizeOptionsWithWidthMoreThan133PercentOfActual() {
+    testWithImageNotBigEnoughForResizeOptions(IMAGE_HEIGHTS, IMAGE_WIDTHS, 90, 1, 0);
+  }
+
+  @Test
+  public void testWithRotatedImageAndResizeOptionsWithHeightMoreThan133PercentOfActual() {
+    testWithImageNotBigEnoughForResizeOptions(IMAGE_HEIGHTS, IMAGE_WIDTHS, 90, 0, 1);
+  }
+
+  private static void testWithImageNotBigEnoughForResizeOptions(
+      int[] imageWidths,
+      int[] imageHeights,
+      int startRotation,
+      int additionalRequestWidth,
+      int additionalRequestHeight) {
+    for (int rotation = startRotation; rotation < 360; rotation += 180) {
+      for (int i = 0; i < TEST_COUNT; i++) {
+        ResizeOptions resizeOptions = new ResizeOptions(
+            REQUEST_WIDTHS[i] + additionalRequestWidth,
+            REQUEST_HEIGHTS[i] + additionalRequestHeight);
+        EncodedImage encodedImage = mockImage(imageWidths[i], imageHeights[i], rotation);
+        assertFalse(ThumbnailSizeChecker.isImageBigEnough(encodedImage, resizeOptions));
+      }
+    }
+  }
+
+  @Test
+  public void testWithLargeEnoughImageWhenNoResizeOptions() {
+    for (int rotation = 0; rotation < 360; rotation += 90) {
+      assertTrue(ThumbnailSizeChecker.isImageBigEnough(
+          mockImage(
+          BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS,
+          BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS,
+          rotation),
+          null));
+    }
+  }
+
+  @Test
+  public void testImageWithInsufficientWidthWhenNoResizeOptions() {
+    for (int rotation = 0; rotation < 360; rotation += 90) {
+      EncodedImage mockImage = mockImage(
+          BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS - 1,
+          BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS,
+          rotation);
+      assertFalse(ThumbnailSizeChecker.isImageBigEnough(mockImage, null));
+    }
+  }
+
+  @Test
+  public void testImageWithInsufficientHeightWhenNoResizeOptions() {
+    for (int rotation = 0; rotation < 360; rotation += 90) {
+      EncodedImage mockImage = mockImage(
+          BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS,
+          BIG_ENOUGH_SIZE_FOR_NO_RESIZE_OPTIONS - 1,
+          rotation);
+      assertFalse(ThumbnailSizeChecker.isImageBigEnough(mockImage, null));
+    }
+  }
+
+  private static EncodedImage mockImage(int width, int height, int rotation) {
+    EncodedImage image = mock(EncodedImage.class);
+    when(image.getWidth()).thenReturn(width);
+    when(image.getHeight()).thenReturn(height);
+    when(image.getRotationAngle()).thenReturn(rotation);
+    return image;
+  }
+}
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/request/ImageRequestBuilderCacheEnabledTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/request/ImageRequestBuilderCacheEnabledTest.java
new file mode 100644
index 000000000..6353ef429
--- /dev/null
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/request/ImageRequestBuilderCacheEnabledTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+package com.facebook.imagepipeline.request;
+
+import java.util.Arrays;
+import java.util.Collection;
+
+import android.net.Uri;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.ParameterizedRobolectricTestRunner;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(ParameterizedRobolectricTestRunner.class)
+public class ImageRequestBuilderCacheEnabledTest {
+
+  @ParameterizedRobolectricTestRunner.Parameters(name = "URI of scheme \"{0}://\"")
+  public static Collection<Object[]> data() {
+    return Arrays.asList(
+        new Object[][]{
+            {"asset", false},
+            {"content", false},
+            {"data", false},
+            {"file", false},
+            {"http", true},
+            {"https", true},
+            {"res", false},
+        });
+  }
+
+  private final String mUriScheme;
+  private final boolean mExpectedDefaultDiskCacheEnabled;
+
+  public ImageRequestBuilderCacheEnabledTest(
+      String uriScheme,
+      Boolean expectedDefaultDiskCacheEnabled) {
+    mUriScheme = uriScheme;
+    mExpectedDefaultDiskCacheEnabled = expectedDefaultDiskCacheEnabled;
+  }
+
+  @Test
+  public void testIsDiskCacheEnabledByDefault() throws Exception {
+    ImageRequestBuilder imageRequestBuilder = createBuilder();
+    assertEquals(mExpectedDefaultDiskCacheEnabled, imageRequestBuilder.isDiskCacheEnabled());
+  }
+
+  @Test
+  public void testIsDiskCacheDisabledIfRequested() throws Exception {
+    ImageRequestBuilder imageRequestBuilder = createBuilder();
+    imageRequestBuilder.disableDiskCache();
+    assertEquals(false, imageRequestBuilder.isDiskCacheEnabled());
+  }
+
+  private ImageRequestBuilder createBuilder() {
+    return ImageRequestBuilder.newBuilderWithSource(Uri.parse(mUriScheme + "://request"));
+  }
+}
diff --git a/imagepipeline/src/test/resources/com/facebook/imagepipeline/image/images/image.jpg b/imagepipeline/src/test/resources/com/facebook/imagepipeline/image/images/image.jpg
deleted file mode 100644
index 28b527898..000000000
Binary files a/imagepipeline/src/test/resources/com/facebook/imagepipeline/image/images/image.jpg and /dev/null differ
diff --git a/imagepipeline/src/test/resources/com/facebook/imagepipeline/image/images/image.png b/imagepipeline/src/test/resources/com/facebook/imagepipeline/image/images/image.png
deleted file mode 100644
index f088bf46d..000000000
Binary files a/imagepipeline/src/test/resources/com/facebook/imagepipeline/image/images/image.png and /dev/null differ
diff --git a/run_comparison.py b/run_comparison.py
index 6437dbb7f..442c247a5 100755
--- a/run_comparison.py
+++ b/run_comparison.py
@@ -20,7 +20,7 @@
 
 To select a subset of the libraries, use the -s option with a
 space-separated list. Available options are fresco, fresco-okhttp,
-glide, volley, drawee-volley, uil, and picasso.
+glide, volley, drawee-volley, uil, picasso, and aquery.
 
 To see the comparison for only network or local images, use -d network or -d local.
 
@@ -56,7 +56,8 @@
     'picasso',
     'uil',
     'volley',
-    'drawee-volley'
+    'drawee-volley',
+    'aquery',
 )
 
 TEST_SOURCES = (
diff --git a/samples/animation/.gitignore b/samples/animation/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/samples/animation/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/samples/animation/build.gradle b/samples/animation/build.gradle
new file mode 100644
index 000000000..b3fa0cbdd
--- /dev/null
+++ b/samples/animation/build.gradle
@@ -0,0 +1,49 @@
+apply plugin: 'com.android.application'
+
+dependencies {
+    provided "com.android.support:support-annotations:${SUPPORT_LIB_VERSION}"
+    compile project(':drawee-backends:drawee-pipeline')
+    // Include this in order to see static Webp
+    compile project(':static-webp')
+    // Include this in order to see animated gif
+    compile project(':animated-gif')
+    // Include this in order to see animated webp
+    compile project(':animated-webp')
+    // Add this if you want to support gingerbread
+    compile project(':animated-base-support')
+}
+
+android {
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    defaultConfig {
+        applicationId "com.facebook.samples.demo"
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
+        versionCode 1
+        versionName "${VERSION_NAME}"
+
+        testApplicationId "com.facebook.samples.demo.test"
+        testInstrumentationRunner "android.test.InstrumentationTestRunner"
+    }
+    buildTypes {
+        release {
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), '../../proguard-fresco.pro'
+        }
+    }
+
+    lintOptions {
+        warning 'InvalidPackage'
+    }
+
+    splits {
+        abi {
+            enable true
+            reset()
+            include 'x86', 'x86_64', 'arm64-v8a', 'armeabi-v7a', 'armeabi'
+            universalApk false
+        }
+    }
+}
diff --git a/samples/animation/src/main/AndroidManifest.xml b/samples/animation/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..f601ecdc2
--- /dev/null
+++ b/samples/animation/src/main/AndroidManifest.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.samples.animation" >
+
+  <uses-permission android:name="android.permission.INTERNET" />
+
+  <uses-sdk
+      android:minSdkVersion="9"
+      android:targetSdkVersion="21"
+      />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name">
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/samples/animation/src/main/java/com/facebook/samples/animation/MainActivity.java b/samples/animation/src/main/java/com/facebook/samples/animation/MainActivity.java
new file mode 100644
index 000000000..8aae58285
--- /dev/null
+++ b/samples/animation/src/main/java/com/facebook/samples/animation/MainActivity.java
@@ -0,0 +1,140 @@
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.samples.animation;
+
+
+import java.util.HashSet;
+import java.util.Set;
+import android.widget.ToggleButton;
+import android.widget.CompoundButton;
+
+import android.app.Activity;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Animatable;
+import android.net.Uri;
+import android.os.Bundle;
+
+import com.facebook.common.logging.FLog;
+import com.facebook.drawee.backends.pipeline.Fresco;
+import com.facebook.drawee.interfaces.DraweeController;
+import com.facebook.drawee.view.SimpleDraweeView;
+import com.facebook.imagepipeline.core.ImagePipelineConfig;
+import com.facebook.imagepipeline.listener.RequestListener;
+import com.facebook.imagepipeline.listener.RequestLoggingListener;
+import com.facebook.drawee.controller.BaseControllerListener;
+import com.facebook.imagepipeline.image.ImageInfo;
+
+public class MainActivity extends Activity {
+
+  private SimpleDraweeView mAnimatedGifView;
+  private SimpleDraweeView mAnimatedWebpView;
+
+  private Animatable animatableGif;
+
+  private Animatable animatableWebp;
+
+
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    FLog.setMinimumLoggingLevel(FLog.VERBOSE);
+    Set<RequestListener> listeners = new HashSet<>();
+    listeners.add(new RequestLoggingListener());
+    ImagePipelineConfig config = ImagePipelineConfig.newBuilder(this)
+        .setRequestListeners(listeners)
+        .setBitmapsConfig(Bitmap.Config.ARGB_8888)
+        .build();
+    Fresco.initialize(this, config);
+    setContentView(R.layout.activity_main);
+
+
+    final ToggleButton gifToggle = (ToggleButton) findViewById(R.id.toggle_gif);
+    gifToggle.setEnabled(false);
+    mAnimatedGifView = (SimpleDraweeView) findViewById(R.id.animated_gif);
+    Uri animatedGifUri =
+        Uri.parse("http://s3.amazonaws.com/giphygifs/media/4aBQ9oNjgEQ2k/giphy.gif");
+
+    DraweeController gifController = Fresco.newDraweeControllerBuilder()
+        .setUri(animatedGifUri)
+        .setControllerListener(new BaseControllerListener<ImageInfo>() {
+          @Override
+          public void onFinalImageSet(
+              String id,
+              ImageInfo imageInfo,
+              Animatable anim) {
+            if (anim != null) {
+              animatableGif = anim;
+              // app-specific logic to enable animation starting
+              gifToggle.setEnabled(true);
+            }
+          }
+        })
+        .build();
+    mAnimatedGifView.setController(gifController);
+
+    gifToggle.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+      public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        if (animatableGif == null) {
+          return;
+        }
+        if (isChecked) {
+          animatableGif.start();
+        } else {
+          animatableGif.stop();
+        }
+      }
+    });
+
+
+
+
+
+    final ToggleButton webpToggle = (ToggleButton) findViewById(R.id.toggle_webp);
+    webpToggle.setEnabled(false);
+    mAnimatedWebpView = (SimpleDraweeView) findViewById(R.id.animated_webp);
+    Uri animatedWebpUri = Uri.parse("http://www.gstatic.com/webp/animated/1.webp");
+    DraweeController webpController = Fresco.newDraweeControllerBuilder()
+        .setUri(animatedWebpUri)
+        .setControllerListener(new BaseControllerListener<ImageInfo>() {
+          @Override
+          public void onFinalImageSet(
+              String id,
+              ImageInfo imageInfo,
+              Animatable anim) {
+            if (anim != null) {
+              animatableWebp = anim;
+              // app-specific logic to enable animation starting
+              webpToggle.setEnabled(true);
+            }
+          }
+        })
+        .build();
+    mAnimatedWebpView.setController(webpController);
+
+    webpToggle.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+      public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        if (animatableWebp == null) {
+          return;
+        }
+        if (isChecked) {
+          animatableWebp.start();
+        } else {
+          animatableWebp.stop();
+        }
+      }
+    });
+
+  }
+}
diff --git a/samples/animation/src/main/res/layout/activity_main.xml b/samples/animation/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..2a73b8eb4
--- /dev/null
+++ b/samples/animation/src/main/res/layout/activity_main.xml
@@ -0,0 +1,36 @@
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:fresco="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:baselineAligned="false"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    tools:context="com.facebook.demo.MainActivity">
+  <com.facebook.drawee.view.SimpleDraweeView
+      android:id="@+id/animated_gif"
+      android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="1"
+      fresco:actualImageScaleType="fitCenter"/>
+  <ToggleButton
+      android:id="@+id/toggle_gif"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:text="ToggleButton"/>
+  <com.facebook.drawee.view.SimpleDraweeView
+      android:id="@+id/animated_webp"
+      android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="1"
+      fresco:actualImageScaleType="fitCenter"/>
+  <ToggleButton
+      android:id="@+id/toggle_webp"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:text="ToggleButton"/>
+</LinearLayout>
diff --git a/samples/animation/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/animation/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..b3fd7c9c0
Binary files /dev/null and b/samples/animation/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/animation/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/animation/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..f97029d7a
Binary files /dev/null and b/samples/animation/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/animation/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/animation/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..69f968ef4
Binary files /dev/null and b/samples/animation/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/animation/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/animation/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..f0f72126f
Binary files /dev/null and b/samples/animation/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/animation/src/main/res/values/dimens.xml b/samples/animation/src/main/res/values/dimens.xml
new file mode 100644
index 000000000..acf94cc67
--- /dev/null
+++ b/samples/animation/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+  <!-- Default screen margins, per the Android Design guidelines. -->
+  <dimen name="activity_horizontal_margin">16dp</dimen>
+  <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/samples/animation/src/main/res/values/strings.xml b/samples/animation/src/main/res/values/strings.xml
new file mode 100644
index 000000000..9bc202eab
--- /dev/null
+++ b/samples/animation/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+  <string name="app_name">Fresco Animation Demo</string>
+</resources>
diff --git a/samples/comparison/build.gradle b/samples/comparison/build.gradle
index 06c8683f6..e36e0ac4a 100644
--- a/samples/comparison/build.gradle
+++ b/samples/comparison/build.gradle
@@ -2,12 +2,12 @@ apply plugin: 'com.android.application'
 
 dependencies {
     provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
-    compile "com.android.support:appcompat-v7:${APPCOMPAT_V7_VERSION}"
+    compile "com.android.support:appcompat-v7:${SUPPORT_LIB_VERSION}"
     compile "com.github.bumptech.glide:glide:${GLIDE_VERSION}"
     compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
     compile "com.nostra13.universalimageloader:universal-image-loader:${UIL_VERSION}"
     compile "com.squareup.picasso:picasso:${PICASSO_VERSION}"
-    compile 'com.android.support:recyclerview-v7:21.+'
+    compile "com.android.support:recyclerview-v7:${SUPPORT_LIB_VERSION}"
     compile "com.googlecode.android-query:android-query:${AQUERY_VERSION}"
     compile "com.facebook.stetho:stetho-okhttp:${STETHO_VERSION}"
 
@@ -28,8 +28,8 @@ android {
 
     defaultConfig {
         applicationId "com.facebook.samples.comparison"
-        minSdkVersion 9
-        targetSdkVersion 21
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
         versionCode 1
         versionName "${VERSION_NAME}"
 
diff --git a/samples/comparison/src/androidTest/java/com/facebook/samples/comparison/test/ScrollTest.java b/samples/comparison/src/androidTest/java/com/facebook/samples/comparison/test/ScrollTest.java
index 20ae490d7..7a3ab63a5 100644
--- a/samples/comparison/src/androidTest/java/com/facebook/samples/comparison/test/ScrollTest.java
+++ b/samples/comparison/src/androidTest/java/com/facebook/samples/comparison/test/ScrollTest.java
@@ -86,6 +86,10 @@ public void testDraweeVolleyNetwork() throws Exception {
     runScenario(MainActivity.VOLLEY_INDEX, MainActivity.NETWORK_INDEX, true);
   }
 
+  public void testAqueryNetwork() throws Exception {
+    runScenario(MainActivity.AQUERY_INDEX, MainActivity.NETWORK_INDEX, false);
+  }
+
   public void testFrescoLocal() throws Exception {
     runScenario(MainActivity.FRESCO_INDEX, MainActivity.LOCAL_INDEX, true);
   }
@@ -106,6 +110,10 @@ public void testUilLocal() throws Exception {
     runScenario(MainActivity.UIL_INDEX, MainActivity.LOCAL_INDEX, false);
   }
 
+  public void testAqueryLocal() throws Exception {
+    runScenario(MainActivity.AQUERY_INDEX, MainActivity.LOCAL_INDEX, false);
+  }
+
   /**
    * Runs the test for given library.
    */
diff --git a/samples/comparison/src/main/AndroidManifest.xml b/samples/comparison/src/main/AndroidManifest.xml
index 0b0c2134a..6be04c076 100644
--- a/samples/comparison/src/main/AndroidManifest.xml
+++ b/samples/comparison/src/main/AndroidManifest.xml
@@ -12,7 +12,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme"
         android:name="com.facebook.samples.comparison.ComparisonApp">
diff --git a/samples/comparison/src/main/gen/com/facebook/samples/comparison/BuildConfig.java b/samples/comparison/src/main/gen/com/facebook/samples/comparison/BuildConfig.java
new file mode 100644
index 000000000..84902e1c7
--- /dev/null
+++ b/samples/comparison/src/main/gen/com/facebook/samples/comparison/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.comparison;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/samples/comparison/src/main/gen/com/facebook/samples/comparison/Manifest.java b/samples/comparison/src/main/gen/com/facebook/samples/comparison/Manifest.java
new file mode 100644
index 000000000..000731b5b
--- /dev/null
+++ b/samples/comparison/src/main/gen/com/facebook/samples/comparison/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.comparison;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/samples/comparison/src/main/gen/com/facebook/samples/comparison/R.java b/samples/comparison/src/main/gen/com/facebook/samples/comparison/R.java
new file mode 100644
index 000000000..0a792859b
--- /dev/null
+++ b/samples/comparison/src/main/gen/com/facebook/samples/comparison/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.comparison;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/samples/comparison/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/comparison/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..b3fd7c9c0
Binary files /dev/null and b/samples/comparison/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/comparison/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/comparison/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..f97029d7a
Binary files /dev/null and b/samples/comparison/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/comparison/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/comparison/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..69f968ef4
Binary files /dev/null and b/samples/comparison/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/comparison/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/comparison/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..f0f72126f
Binary files /dev/null and b/samples/comparison/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/demo/build.gradle b/samples/demo/build.gradle
index 574566626..ae8fcee94 100644
--- a/samples/demo/build.gradle
+++ b/samples/demo/build.gradle
@@ -1,9 +1,14 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    provided 'com.android.support:support-annotations:+'
+    provided "com.android.support:support-annotations:${SUPPORT_LIB_VERSION}"
     compile project(':drawee-backends:drawee-pipeline')
+    // Include this in order to see static Webp
     compile project(':static-webp')
+    // Include this in order to see animated gif
+    compile project(':animated-gif')
+    // Include this in order to see animated webp
+    compile project(':animated-webp')
 }
 
 android {
@@ -12,8 +17,8 @@ android {
 
     defaultConfig {
         applicationId "com.facebook.samples.demo"
-        minSdkVersion 9
-        targetSdkVersion 21
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
         versionCode 1
         versionName "${VERSION_NAME}"
 
diff --git a/samples/demo/src/main/gen/com/facebook/samples/demo/BuildConfig.java b/samples/demo/src/main/gen/com/facebook/samples/demo/BuildConfig.java
new file mode 100644
index 000000000..72e7e4f50
--- /dev/null
+++ b/samples/demo/src/main/gen/com/facebook/samples/demo/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.demo;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/samples/demo/src/main/gen/com/facebook/samples/demo/Manifest.java b/samples/demo/src/main/gen/com/facebook/samples/demo/Manifest.java
new file mode 100644
index 000000000..eb0282a9d
--- /dev/null
+++ b/samples/demo/src/main/gen/com/facebook/samples/demo/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.demo;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/samples/demo/src/main/gen/com/facebook/samples/demo/R.java b/samples/demo/src/main/gen/com/facebook/samples/demo/R.java
new file mode 100644
index 000000000..bed020481
--- /dev/null
+++ b/samples/demo/src/main/gen/com/facebook/samples/demo/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.demo;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/samples/demo/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/demo/src/main/res/mipmap-hdpi/ic_launcher.png
index cde69bccc..b3fd7c9c0 100644
Binary files a/samples/demo/src/main/res/mipmap-hdpi/ic_launcher.png and b/samples/demo/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/demo/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/demo/src/main/res/mipmap-mdpi/ic_launcher.png
index c133a0cbd..f97029d7a 100644
Binary files a/samples/demo/src/main/res/mipmap-mdpi/ic_launcher.png and b/samples/demo/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/demo/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/demo/src/main/res/mipmap-xhdpi/ic_launcher.png
index bfa42f0e7..69f968ef4 100644
Binary files a/samples/demo/src/main/res/mipmap-xhdpi/ic_launcher.png and b/samples/demo/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png
index 324e72cdd..f0f72126f 100644
Binary files a/samples/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png and b/samples/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/gestures/src/main/gen/com/facebook/samples/gestures/BuildConfig.java b/samples/gestures/src/main/gen/com/facebook/samples/gestures/BuildConfig.java
new file mode 100644
index 000000000..e134881b6
--- /dev/null
+++ b/samples/gestures/src/main/gen/com/facebook/samples/gestures/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.gestures;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/samples/gestures/src/main/gen/com/facebook/samples/gestures/Manifest.java b/samples/gestures/src/main/gen/com/facebook/samples/gestures/Manifest.java
new file mode 100644
index 000000000..ea178c54f
--- /dev/null
+++ b/samples/gestures/src/main/gen/com/facebook/samples/gestures/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.gestures;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/samples/gestures/src/main/gen/com/facebook/samples/gestures/R.java b/samples/gestures/src/main/gen/com/facebook/samples/gestures/R.java
new file mode 100644
index 000000000..7f0121595
--- /dev/null
+++ b/samples/gestures/src/main/gen/com/facebook/samples/gestures/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.gestures;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/samples/gestures/src/main/java/com/facebook/samples/gestures/MultiPointerGestureDetector.java b/samples/gestures/src/main/java/com/facebook/samples/gestures/MultiPointerGestureDetector.java
index a5077f31e..97594ee32 100644
--- a/samples/gestures/src/main/java/com/facebook/samples/gestures/MultiPointerGestureDetector.java
+++ b/samples/gestures/src/main/java/com/facebook/samples/gestures/MultiPointerGestureDetector.java
@@ -25,20 +25,21 @@
 
   /** The listener for receiving notifications when gestures occur. */
   public interface Listener {
-    /** Responds to the beginning of a gesture. */
+    /** A callback called right before the gesture is about to start. */
     public void onGestureBegin(MultiPointerGestureDetector detector);
 
-    /** Responds to the update of a gesture in progress. */
+    /** A callback called each time the gesture gets updated. */
     public void onGestureUpdate(MultiPointerGestureDetector detector);
 
-    /** Responds to the end of a gesture. */
+    /** A callback called right after the gesture has finished. */
     public void onGestureEnd(MultiPointerGestureDetector detector);
   }
 
   private static final int MAX_POINTERS = 2;
 
   private boolean mGestureInProgress;
-  private int mCount;
+  private int mPointerCount;
+  private int mNewPointerCount;
   private final int mId[] = new int[MAX_POINTERS];
   private final float mStartX[] = new float[MAX_POINTERS];
   private final float mStartY[] = new float[MAX_POINTERS];
@@ -69,7 +70,7 @@ public void setListener(Listener listener) {
    */
   public void reset() {
     mGestureInProgress = false;
-    mCount = 0;
+    mPointerCount = 0;
     for (int i = 0; i < MAX_POINTERS; i++) {
       mId[i] = MotionEvent.INVALID_POINTER_ID;
     }
@@ -83,15 +84,21 @@ protected boolean shouldStartGesture() {
     return true;
   }
 
+  /**
+   * Starts a new gesture and calls the listener just before starting it.
+   */
   private void startGesture() {
     if (!mGestureInProgress) {
-      mGestureInProgress = true;
       if (mListener != null) {
         mListener.onGestureBegin(this);
       }
+      mGestureInProgress = true;
     }
   }
 
+  /**
+   * Stops the current gesture and calls the listener right after stopping it.
+   */
   private void stopGesture() {
     if (mGestureInProgress) {
       mGestureInProgress = false;
@@ -119,6 +126,44 @@ private int getPressedPointerIndex(MotionEvent event, int i) {
     return (i < count) ? i : -1;
   }
 
+  /**
+   * Gets the number of pressed pointers (fingers down).
+   */
+  private static int getPressedPointerCount(MotionEvent event) {
+    int count = event.getPointerCount();
+    int action = event.getActionMasked();
+    if (action == MotionEvent.ACTION_UP ||
+        action == MotionEvent.ACTION_POINTER_UP) {
+      count--;
+    }
+    return count;
+  }
+
+  private void updatePointersOnTap(MotionEvent event) {
+    mPointerCount = 0;
+    for (int i = 0; i < MAX_POINTERS; i++) {
+      int index = getPressedPointerIndex(event, i);
+      if (index == -1) {
+        mId[i] = MotionEvent.INVALID_POINTER_ID;
+      } else {
+        mId[i] = event.getPointerId(index);
+        mCurrentX[i] = mStartX[i] = event.getX(index);
+        mCurrentY[i] = mStartY[i] = event.getY(index);
+        mPointerCount++;
+      }
+    }
+  }
+
+  private void updatePointersOnMove(MotionEvent event) {
+    for (int i = 0; i < MAX_POINTERS; i++) {
+      int index = event.findPointerIndex(mId[i]);
+      if (index != -1) {
+        mCurrentX[i] = event.getX(index);
+        mCurrentY[i] = event.getY(index);
+      }
+    }
+  }
+
   /**
    * Handles the given motion event.
    * @param event event to handle
@@ -128,15 +173,9 @@ public boolean onTouchEvent(final MotionEvent event) {
     switch (event.getActionMasked()) {
       case MotionEvent.ACTION_MOVE: {
         // update pointers
-        for (int i = 0; i < MAX_POINTERS; i++) {
-          int index = event.findPointerIndex(mId[i]);
-          if (index != -1) {
-            mCurrentX[i] = event.getX(index);
-            mCurrentY[i] = event.getY(index);
-          }
-        }
+        updatePointersOnMove(event);
         // start a new gesture if not already started
-        if (!mGestureInProgress && shouldStartGesture()) {
+        if (!mGestureInProgress && mPointerCount > 0 && shouldStartGesture()) {
           startGesture();
         }
         // notify listener
@@ -150,30 +189,18 @@ public boolean onTouchEvent(final MotionEvent event) {
       case MotionEvent.ACTION_POINTER_DOWN:
       case MotionEvent.ACTION_POINTER_UP:
       case MotionEvent.ACTION_UP: {
-        // we'll restart the current gesture (if any) whenever the number of pointers changes
-        // NOTE: we only restart existing gestures here, new gestures are started in ACTION_MOVE
-        boolean wasGestureInProgress = mGestureInProgress;
+        // restart gesture whenever the number of pointers changes
+        mNewPointerCount = getPressedPointerCount(event);
         stopGesture();
-        reset();
-        // update pointers
-        for (int i = 0; i < MAX_POINTERS; i++) {
-          int index = getPressedPointerIndex(event, i);
-          if (index == -1) {
-            break;
-          }
-          mId[i] = event.getPointerId(index);
-          mCurrentX[i] = mStartX[i] = event.getX(index);
-          mCurrentY[i] = mStartY[i] = event.getY(index);
-          mCount++;
-        }
-        // restart the gesture (if any) if there are still pointers left
-        if (wasGestureInProgress && mCount > 0) {
+        updatePointersOnTap(event);
+        if (mPointerCount > 0 && shouldStartGesture()) {
           startGesture();
         }
         break;
       }
 
       case MotionEvent.ACTION_CANCEL: {
+        mNewPointerCount = 0;
         stopGesture();
         reset();
         break;
@@ -182,7 +209,7 @@ public boolean onTouchEvent(final MotionEvent event) {
     return true;
   }
 
-  /** Restarts the current gesture */
+  /** Restarts the current gesture (if any).  */
   public void restartGesture() {
     if (!mGestureInProgress) {
       return;
@@ -195,14 +222,19 @@ public void restartGesture() {
     startGesture();
   }
 
-  /** Gets whether gesture is in progress or not */
+  /** Gets whether there is a gesture in progress */
   public boolean isGestureInProgress() {
     return mGestureInProgress;
   }
 
+  /** Gets the number of pointers after the current gesture */
+  public int getNewPointerCount() {
+    return mNewPointerCount;
+  }
+
   /** Gets the number of pointers in the current gesture */
-  public int getCount() {
-    return mCount;
+  public int getPointerCount() {
+    return mPointerCount;
   }
 
   /**
diff --git a/samples/gestures/src/main/java/com/facebook/samples/gestures/TransformGestureDetector.java b/samples/gestures/src/main/java/com/facebook/samples/gestures/TransformGestureDetector.java
index 33916f6fa..7cebf58eb 100644
--- a/samples/gestures/src/main/java/com/facebook/samples/gestures/TransformGestureDetector.java
+++ b/samples/gestures/src/main/java/com/facebook/samples/gestures/TransformGestureDetector.java
@@ -25,13 +25,13 @@
 
   /** The listener for receiving notifications when gestures occur. */
   public interface Listener {
-    /** Responds to the beginning of a gesture. */
+    /** A callback called right before the gesture is about to start. */
     public void onGestureBegin(TransformGestureDetector detector);
 
-    /** Responds to the update of a gesture in progress. */
+    /** A callback called each time the gesture gets updated. */
     public void onGestureUpdate(TransformGestureDetector detector);
 
-    /** Responds to the end of a gesture. */
+    /** A callback called right after the gesture has finished. */
     public void onGestureEnd(TransformGestureDetector detector);
   }
 
@@ -102,41 +102,51 @@ private float calcAverage(float[] arr, int len) {
     return (len > 0) ? sum / len : 0;
   }
 
-  /** Restarts the current gesture */
+  /** Restarts the current gesture (if any).  */
   public void restartGesture() {
     mDetector.restartGesture();
   }
 
-  /** Gets whether gesture is in progress or not */
+  /** Gets whether there is a gesture in progress */
   public boolean isGestureInProgress() {
     return mDetector.isGestureInProgress();
   }
 
+  /** Gets the number of pointers after the current gesture */
+  public int getNewPointerCount() {
+    return mDetector.getNewPointerCount();
+  }
+
+  /** Gets the number of pointers in the current gesture */
+  public int getPointerCount() {
+    return mDetector.getPointerCount();
+  }
+
   /** Gets the X coordinate of the pivot point */
   public float getPivotX() {
-    return calcAverage(mDetector.getStartX(), mDetector.getCount());
+    return calcAverage(mDetector.getStartX(), mDetector.getPointerCount());
   }
 
   /** Gets the Y coordinate of the pivot point */
   public float getPivotY() {
-    return calcAverage(mDetector.getStartY(), mDetector.getCount());
+    return calcAverage(mDetector.getStartY(), mDetector.getPointerCount());
   }
 
   /** Gets the X component of the translation */
   public float getTranslationX() {
-    return calcAverage(mDetector.getCurrentX(), mDetector.getCount()) -
-        calcAverage(mDetector.getStartX(), mDetector.getCount());
+    return calcAverage(mDetector.getCurrentX(), mDetector.getPointerCount()) -
+        calcAverage(mDetector.getStartX(), mDetector.getPointerCount());
   }
 
   /** Gets the Y component of the translation */
   public float getTranslationY() {
-    return calcAverage(mDetector.getCurrentY(), mDetector.getCount()) -
-        calcAverage(mDetector.getStartY(), mDetector.getCount());
+    return calcAverage(mDetector.getCurrentY(), mDetector.getPointerCount()) -
+        calcAverage(mDetector.getStartY(), mDetector.getPointerCount());
   }
 
   /** Gets the scale */
   public float getScale() {
-    if (mDetector.getCount() < 2) {
+    if (mDetector.getPointerCount() < 2) {
       return 1;
     } else {
       float startDeltaX = mDetector.getStartX()[1] - mDetector.getStartX()[0];
@@ -151,7 +161,7 @@ public float getScale() {
 
   /** Gets the rotation in radians */
   public float getRotation() {
-    if (mDetector.getCount() < 2) {
+    if (mDetector.getPointerCount() < 2) {
       return 0;
     } else {
       float startDeltaX = mDetector.getStartX()[1] - mDetector.getStartX()[0];
diff --git a/samples/gestures/src/test/java/com/facebook/samples/gestures/MultiPointerGestureDetectorTest.java b/samples/gestures/src/test/java/com/facebook/samples/gestures/MultiPointerGestureDetectorTest.java
index 303118e18..a8ba87573 100644
--- a/samples/gestures/src/test/java/com/facebook/samples/gestures/MultiPointerGestureDetectorTest.java
+++ b/samples/gestures/src/test/java/com/facebook/samples/gestures/MultiPointerGestureDetectorTest.java
@@ -63,7 +63,7 @@ public void testSinglePointer() {
     mGestureDetector.onTouchEvent(event1);
     mGestureDetector.onTouchEvent(event2);
     assertTrue(mGestureDetector.isGestureInProgress());
-    assertEquals(1, mGestureDetector.getCount());
+    assertEquals(1, mGestureDetector.getPointerCount());
     assertEquals(100f, mGestureDetector.getStartX()[0], 0);
     assertEquals(300f, mGestureDetector.getStartY()[0], 0);
     assertEquals(150f, mGestureDetector.getCurrentX()[0], 0);
@@ -73,7 +73,7 @@ public void testSinglePointer() {
 
     mGestureDetector.onTouchEvent(event3);
     assertTrue(mGestureDetector.isGestureInProgress());
-    assertEquals(1, mGestureDetector.getCount());
+    assertEquals(1, mGestureDetector.getPointerCount());
     assertEquals(100f, mGestureDetector.getStartX()[0], 0);
     assertEquals(300f, mGestureDetector.getStartY()[0], 0);
     assertEquals(200f, mGestureDetector.getCurrentX()[0], 0);
@@ -82,7 +82,7 @@ public void testSinglePointer() {
 
     mGestureDetector.onTouchEvent(event4);
     assertFalse(mGestureDetector.isGestureInProgress());
-    assertEquals(0, mGestureDetector.getCount());
+    assertEquals(0, mGestureDetector.getPointerCount());
     inOrder.verify(mListener).onGestureEnd(mGestureDetector);
     inOrder.verifyNoMoreInteractions();
 
@@ -110,7 +110,7 @@ public void testTwoPointers() {
     mGestureDetector.onTouchEvent(event1);
     mGestureDetector.onTouchEvent(event2);
     assertTrue(mGestureDetector.isGestureInProgress());
-    assertEquals(1, mGestureDetector.getCount());
+    assertEquals(1, mGestureDetector.getPointerCount());
     assertEquals(100f, mGestureDetector.getStartX()[0], 0);
     assertEquals(300f, mGestureDetector.getStartY()[0], 0);
     assertEquals(150f, mGestureDetector.getCurrentX()[0], 0);
@@ -120,7 +120,7 @@ public void testTwoPointers() {
 
     mGestureDetector.onTouchEvent(event3);
     assertTrue(mGestureDetector.isGestureInProgress());
-    assertEquals(2, mGestureDetector.getCount());
+    assertEquals(2, mGestureDetector.getPointerCount());
     assertEquals(150f, mGestureDetector.getStartX()[0], 0);
     assertEquals(350f, mGestureDetector.getStartY()[0], 0);
     assertEquals(150f, mGestureDetector.getCurrentX()[0], 0);
@@ -134,7 +134,7 @@ public void testTwoPointers() {
 
     mGestureDetector.onTouchEvent(event4);
     assertTrue(mGestureDetector.isGestureInProgress());
-    assertEquals(2, mGestureDetector.getCount());
+    assertEquals(2, mGestureDetector.getPointerCount());
     assertEquals(150f, mGestureDetector.getStartX()[0], 0);
     assertEquals(350f, mGestureDetector.getStartY()[0], 0);
     assertEquals(200f, mGestureDetector.getCurrentX()[0], 0);
@@ -147,7 +147,7 @@ public void testTwoPointers() {
 
     mGestureDetector.onTouchEvent(event5);
     assertTrue(mGestureDetector.isGestureInProgress());
-    assertEquals(1, mGestureDetector.getCount());
+    assertEquals(1, mGestureDetector.getPointerCount());
     assertEquals(550f, mGestureDetector.getStartX()[0], 0);
     assertEquals(650f, mGestureDetector.getStartY()[0], 0);
     assertEquals(550f, mGestureDetector.getCurrentX()[0], 0);
@@ -157,7 +157,7 @@ public void testTwoPointers() {
 
     mGestureDetector.onTouchEvent(event6);
     assertTrue(mGestureDetector.isGestureInProgress());
-    assertEquals(1, mGestureDetector.getCount());
+    assertEquals(1, mGestureDetector.getPointerCount());
     assertEquals(550f, mGestureDetector.getStartX()[0], 0);
     assertEquals(650f, mGestureDetector.getStartY()[0], 0);
     assertEquals(600f, mGestureDetector.getCurrentX()[0], 0);
@@ -166,7 +166,7 @@ public void testTwoPointers() {
 
     mGestureDetector.onTouchEvent(event7);
     assertFalse(mGestureDetector.isGestureInProgress());
-    assertEquals(0, mGestureDetector.getCount());
+    assertEquals(0, mGestureDetector.getPointerCount());
     inOrder.verify(mListener).onGestureEnd(mGestureDetector);
     inOrder.verifyNoMoreInteractions();
 
diff --git a/samples/gestures/src/test/java/com/facebook/samples/gestures/TransformGestureDetectorTest.java b/samples/gestures/src/test/java/com/facebook/samples/gestures/TransformGestureDetectorTest.java
index 2864675bb..2e5a97be1 100644
--- a/samples/gestures/src/test/java/com/facebook/samples/gestures/TransformGestureDetectorTest.java
+++ b/samples/gestures/src/test/java/com/facebook/samples/gestures/TransformGestureDetectorTest.java
@@ -39,7 +39,7 @@
   public void setup() {
     mListener = mock(TransformGestureDetector.Listener.class);
     mMultiPointerGestureDetector = mock(MultiPointerGestureDetector.class);
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(0);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(0);
     when(mMultiPointerGestureDetector.getStartX()).thenReturn(new float[] {100f, 200f});
     when(mMultiPointerGestureDetector.getStartY()).thenReturn(new float[] {500f, 600f});
     when(mMultiPointerGestureDetector.getCurrentX()).thenReturn(new float[] {10f, 20f});
@@ -97,47 +97,47 @@ public void testIsGestureInProgress() {
 
   @Test
   public void testPivot() {
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(0);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(0);
     assertEquals(0, mGestureDetector.getPivotX(), 0);
     assertEquals(0, mGestureDetector.getPivotY(), 0);
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(1);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(1);
     assertEquals(100, mGestureDetector.getPivotX(), 0);
     assertEquals(500, mGestureDetector.getPivotY(), 0);
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(2);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(2);
     assertEquals(150, mGestureDetector.getPivotX(), 0);
     assertEquals(550, mGestureDetector.getPivotY(), 0);
   }
 
   @Test
   public void testTranslation() {
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(0);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(0);
     assertEquals(0, mGestureDetector.getTranslationX(), 0);
     assertEquals(0, mGestureDetector.getTranslationY(), 0);
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(1);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(1);
     assertEquals(-90, mGestureDetector.getTranslationX(), 0);
     assertEquals(-450, mGestureDetector.getTranslationY(), 0);
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(2);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(2);
     assertEquals(-135, mGestureDetector.getTranslationX(), 0);
     assertEquals(-505, mGestureDetector.getTranslationY(), 0);
   }
 
   @Test
   public void testScale() {
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(0);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(0);
     assertEquals(1, mGestureDetector.getScale(), 0);
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(1);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(1);
     assertEquals(1, mGestureDetector.getScale(), 0);
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(2);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(2);
     assertEquals(0.1f, mGestureDetector.getScale(), 1e-6);
   }
 
   @Test
   public void testRotation() {
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(0);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(0);
     assertEquals(0, mGestureDetector.getRotation(), 0);
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(1);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(1);
     assertEquals(0, mGestureDetector.getRotation(), 0);
-    when(mMultiPointerGestureDetector.getCount()).thenReturn(2);
+    when(mMultiPointerGestureDetector.getPointerCount()).thenReturn(2);
     assertEquals((float)-Math.PI/2, mGestureDetector.getRotation(), 1e-6);
   }
 
diff --git a/samples/round/build.gradle b/samples/round/build.gradle
index bd5ce4e9b..2b19d715c 100644
--- a/samples/round/build.gradle
+++ b/samples/round/build.gradle
@@ -10,8 +10,8 @@ android {
 
     defaultConfig {
         applicationId "com.facebook.samples.round"
-        minSdkVersion 9
-        targetSdkVersion 21
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
         versionCode 1
         versionName "${VERSION_NAME}"
 
diff --git a/samples/round/src/main/java/com/facebook/fresco/samples/round/MainActivity.java b/samples/round/src/main/java/com/facebook/fresco/samples/round/MainActivity.java
index e405a9da6..fdcdcdfc1 100644
--- a/samples/round/src/main/java/com/facebook/fresco/samples/round/MainActivity.java
+++ b/samples/round/src/main/java/com/facebook/fresco/samples/round/MainActivity.java
@@ -12,6 +12,9 @@
 
 package com.facebook.samples.round;
 
+import java.util.HashSet;
+import java.util.Set;
+
 import android.app.Activity;
 import android.graphics.Color;
 import android.graphics.PointF;
@@ -26,9 +29,6 @@
 import com.facebook.drawee.generic.RoundingParams;
 import com.facebook.drawee.view.SimpleDraweeView;
 
-import java.util.HashSet;
-import java.util.Set;
-
 public class MainActivity extends Activity {
 
   private static final Uri URI = Uri.parse(
@@ -38,9 +38,20 @@
   private static final float FOCUS_X = 0.454f;
   private static final float FOCUS_Y = 0.266f;
   private static final int RADIUS = 50;
+  private static final Set<ScaleType> SUPPORTS_BITMAP_ROUNDING;
 
   private LinearLayout mUnroundedColumn;
   private LinearLayout mRoundedColumn;
+  private LinearLayout.LayoutParams mChildLayoutParams;
+  private RoundingParams mRoundingBitmapOnly;
+  private RoundingParams mRoundingOverlayColor;
+
+  static {
+    SUPPORTS_BITMAP_ROUNDING = new HashSet<>();
+    SUPPORTS_BITMAP_ROUNDING.add(ScaleType.CENTER_CROP);
+    SUPPORTS_BITMAP_ROUNDING.add(ScaleType.CENTER);
+    SUPPORTS_BITMAP_ROUNDING.add(ScaleType.FOCUS_CROP);
+  }
 
   @Override
   protected void onCreate(Bundle savedInstanceState) {
@@ -52,41 +63,46 @@ protected void onCreate(Bundle savedInstanceState) {
 
     mUnroundedColumn = (LinearLayout) findViewById(R.id.unrounded);
     mRoundedColumn = (LinearLayout) findViewById(R.id.rounded);
-    LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(WIDTH, HEIGHT);
+    mChildLayoutParams = new LinearLayout.LayoutParams(WIDTH, HEIGHT);
 
-    RoundingParams bitmapOnly = RoundingParams.fromCornersRadius(RADIUS)
+    mRoundingBitmapOnly = RoundingParams.fromCornersRadius(RADIUS)
         .setRoundingMethod(RoundingParams.RoundingMethod.BITMAP_ONLY);
-    RoundingParams overlayColor = RoundingParams.fromCornersRadius(RADIUS)
+    mRoundingOverlayColor = RoundingParams.fromCornersRadius(RADIUS)
         .setRoundingMethod(RoundingParams.RoundingMethod.OVERLAY_COLOR)
         .setOverlayColor(Color.WHITE);
+
     GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());
 
-    Set<ScaleType> useBitmapOnly = new HashSet<>();
-    useBitmapOnly.add(ScaleType.CENTER_CROP);
-    useBitmapOnly.add(ScaleType.CENTER);
-    useBitmapOnly.add(ScaleType.FOCUS_CROP);
-
-    for (ScaleType scaleType : ScaleType.values()) {
-      builder.setActualImageScaleType(scaleType);
-      if (scaleType == ScaleType.FOCUS_CROP) {
-        builder.setActualImageFocusPoint(new PointF(FOCUS_X, FOCUS_Y));
-      }
-      builder.setRoundingParams(null);
-      SimpleDraweeView unroundedImage = new SimpleDraweeView(this, builder.build());
-
-      if (useBitmapOnly.contains(scaleType)) {
-        builder.setRoundingParams(bitmapOnly);
-      } else {
-        builder.setRoundingParams(overlayColor);
-      }
-      SimpleDraweeView roundedImage = new SimpleDraweeView(this, builder.build());
-
-      unroundedImage.setLayoutParams(params);
-      roundedImage.setLayoutParams(params);
-      mUnroundedColumn.addView(unroundedImage);
-      mRoundedColumn.addView(roundedImage);
-      unroundedImage.setImageURI(URI);
-      roundedImage.setImageURI(URI);
+    addImageWithScaleType(ScaleType.FIT_XY, builder);
+    addImageWithScaleType(ScaleType.FIT_START, builder);
+    addImageWithScaleType(ScaleType.FIT_CENTER, builder);
+    addImageWithScaleType(ScaleType.FIT_END, builder);
+    addImageWithScaleType(ScaleType.CENTER, builder);
+    addImageWithScaleType(ScaleType.CENTER_INSIDE, builder);
+    addImageWithScaleType(ScaleType.CENTER_CROP, builder);
+    addImageWithScaleType(ScaleType.FOCUS_CROP, builder);
+  }
+
+  private void addImageWithScaleType(ScaleType scaleType, GenericDraweeHierarchyBuilder builder) {
+    builder.setActualImageScaleType(scaleType);
+    if (scaleType == ScaleType.FOCUS_CROP) {
+      builder.setActualImageFocusPoint(new PointF(FOCUS_X, FOCUS_Y));
     }
+    builder.setRoundingParams(null);
+    SimpleDraweeView unroundedImage = new SimpleDraweeView(this, builder.build());
+
+    if (SUPPORTS_BITMAP_ROUNDING.contains(scaleType)) {
+      builder.setRoundingParams(mRoundingBitmapOnly);
+    } else {
+      builder.setRoundingParams(mRoundingOverlayColor);
+    }
+    SimpleDraweeView roundedImage = new SimpleDraweeView(this, builder.build());
+
+    unroundedImage.setLayoutParams(mChildLayoutParams);
+    roundedImage.setLayoutParams(mChildLayoutParams);
+    mUnroundedColumn.addView(unroundedImage);
+    mRoundedColumn.addView(roundedImage);
+    unroundedImage.setImageURI(URI);
+    roundedImage.setImageURI(URI);
   }
 }
diff --git a/samples/round/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/round/src/main/res/mipmap-hdpi/ic_launcher.png
index cde69bccc..b3fd7c9c0 100644
Binary files a/samples/round/src/main/res/mipmap-hdpi/ic_launcher.png and b/samples/round/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/round/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/round/src/main/res/mipmap-mdpi/ic_launcher.png
index c133a0cbd..f97029d7a 100644
Binary files a/samples/round/src/main/res/mipmap-mdpi/ic_launcher.png and b/samples/round/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/round/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/round/src/main/res/mipmap-xhdpi/ic_launcher.png
index bfa42f0e7..69f968ef4 100644
Binary files a/samples/round/src/main/res/mipmap-xhdpi/ic_launcher.png and b/samples/round/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/round/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/round/src/main/res/mipmap-xxhdpi/ic_launcher.png
index 324e72cdd..f0f72126f 100644
Binary files a/samples/round/src/main/res/mipmap-xxhdpi/ic_launcher.png and b/samples/round/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/transition/build.gradle b/samples/transition/build.gradle
index ebf2ad1a9..67c17a9aa 100644
--- a/samples/transition/build.gradle
+++ b/samples/transition/build.gradle
@@ -7,7 +7,7 @@ android {
     defaultConfig {
         applicationId "com.facebook.samples.transitions"
         minSdkVersion 21
-        targetSdkVersion 23
+        targetSdkVersion rootProject.ext.targetSdkVersion
         versionCode 1
         versionName "1.0"
     }
@@ -26,7 +26,6 @@ android {
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     testCompile 'junit:junit:4.12'
-    compile 'com.android.support:appcompat-v7:21.0.3'
     compile project(':drawee-backends:drawee-pipeline')
 
 }
diff --git a/samples/transition/src/main/gen/com/facebook/samples/transitions/BuildConfig.java b/samples/transition/src/main/gen/com/facebook/samples/transitions/BuildConfig.java
new file mode 100644
index 000000000..524b20e8e
--- /dev/null
+++ b/samples/transition/src/main/gen/com/facebook/samples/transitions/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.transitions;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/samples/transition/src/main/gen/com/facebook/samples/transitions/Manifest.java b/samples/transition/src/main/gen/com/facebook/samples/transitions/Manifest.java
new file mode 100644
index 000000000..28f9ab949
--- /dev/null
+++ b/samples/transition/src/main/gen/com/facebook/samples/transitions/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.transitions;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/samples/transition/src/main/gen/com/facebook/samples/transitions/R.java b/samples/transition/src/main/gen/com/facebook/samples/transitions/R.java
new file mode 100644
index 000000000..cd202d24d
--- /dev/null
+++ b/samples/transition/src/main/gen/com/facebook/samples/transitions/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.transitions;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/samples/transition/src/main/java/com/facebook/samples/transitions/DestinationActivity.java b/samples/transition/src/main/java/com/facebook/samples/transitions/DestinationActivity.java
index 0f61e468d..fbcbb7114 100644
--- a/samples/transition/src/main/java/com/facebook/samples/transitions/DestinationActivity.java
+++ b/samples/transition/src/main/java/com/facebook/samples/transitions/DestinationActivity.java
@@ -12,10 +12,10 @@
 
 package com.facebook.samples.transitions;
 
+import android.app.Activity;
 import android.os.Bundle;
-import android.support.v7.app.AppCompatActivity;
 
-public class DestinationActivity extends AppCompatActivity {
+public class DestinationActivity extends Activity {
 
   @Override
   protected void onCreate(Bundle savedInstanceState) {
diff --git a/samples/transition/src/main/java/com/facebook/samples/transitions/SourceActivity.java b/samples/transition/src/main/java/com/facebook/samples/transitions/SourceActivity.java
index f4751746a..d75e70f7c 100644
--- a/samples/transition/src/main/java/com/facebook/samples/transitions/SourceActivity.java
+++ b/samples/transition/src/main/java/com/facebook/samples/transitions/SourceActivity.java
@@ -12,10 +12,10 @@
 
 package com.facebook.samples.transitions;
 
+import android.app.Activity;
 import android.app.ActivityOptions;
 import android.content.Intent;
 import android.os.Bundle;
-import android.support.v7.app.AppCompatActivity;
 import android.view.View;
 
 import com.facebook.drawee.view.SimpleDraweeView;
@@ -27,8 +27,7 @@
 import java.util.Set;
 import java.util.HashSet;
 
-
-public class SourceActivity extends AppCompatActivity {
+public class SourceActivity extends Activity {
 
   private SimpleDraweeView mSimpleDraweeView;
 
diff --git a/samples/transition/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/transition/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..b3fd7c9c0
Binary files /dev/null and b/samples/transition/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/transition/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/transition/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..f97029d7a
Binary files /dev/null and b/samples/transition/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/transition/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/transition/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..69f968ef4
Binary files /dev/null and b/samples/transition/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/transition/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/transition/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..f0f72126f
Binary files /dev/null and b/samples/transition/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/transition/src/main/res/values-v21/styles.xml b/samples/transition/src/main/res/values-v21/styles.xml
index c8c726cea..c5abf0249 100644
--- a/samples/transition/src/main/res/values-v21/styles.xml
+++ b/samples/transition/src/main/res/values-v21/styles.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
 
-    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
+    <style name="AppTheme" parent="android:Theme.Material.Light.NoActionBar">
         <item name="android:windowContentTransitions">true</item>
         <item name="android:windowAllowEnterTransitionOverlap">true</item>
         <item name="android:windowAllowReturnTransitionOverlap">true</item>
diff --git a/samples/transition/src/main/res/values/styles.xml b/samples/transition/src/main/res/values/styles.xml
index 5885930df..41702608f 100644
--- a/samples/transition/src/main/res/values/styles.xml
+++ b/samples/transition/src/main/res/values/styles.xml
@@ -1,11 +1,6 @@
 <resources>
 
     <!-- Base application theme. -->
-    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
-        <!-- Customize your theme here. -->
-        <item name="colorPrimary">@color/colorPrimary</item>
-        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
-        <item name="colorAccent">@color/colorAccent</item>
-    </style>
+    <style name="AppTheme" parent="android:Theme.Holo.Light.NoActionBar" />
 
 </resources>
diff --git a/samples/uriapp/build.gradle b/samples/uriapp/build.gradle
index b505a9979..314cb9484 100644
--- a/samples/uriapp/build.gradle
+++ b/samples/uriapp/build.gradle
@@ -9,8 +9,8 @@ android {
     compileSdkVersion rootProject.ext.compileSdkVersion
     defaultConfig {
         applicationId "com.facebook.samples.uriapp"
-        minSdkVersion 9
-        targetSdkVersion 21
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
         versionCode 1
         versionName "${VERSION_NAME}"
 
diff --git a/samples/uriapp/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/uriapp/src/main/res/mipmap-hdpi/ic_launcher.png
index cde69bccc..b3fd7c9c0 100644
Binary files a/samples/uriapp/src/main/res/mipmap-hdpi/ic_launcher.png and b/samples/uriapp/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/uriapp/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/uriapp/src/main/res/mipmap-mdpi/ic_launcher.png
index c133a0cbd..f97029d7a 100644
Binary files a/samples/uriapp/src/main/res/mipmap-mdpi/ic_launcher.png and b/samples/uriapp/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/uriapp/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/uriapp/src/main/res/mipmap-xhdpi/ic_launcher.png
index bfa42f0e7..69f968ef4 100644
Binary files a/samples/uriapp/src/main/res/mipmap-xhdpi/ic_launcher.png and b/samples/uriapp/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/uriapp/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/uriapp/src/main/res/mipmap-xxhdpi/ic_launcher.png
index 324e72cdd..f0f72126f 100644
Binary files a/samples/uriapp/src/main/res/mipmap-xxhdpi/ic_launcher.png and b/samples/uriapp/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/zoomable/build.gradle b/samples/zoomable/build.gradle
index 3222787ee..975077ac8 100644
--- a/samples/zoomable/build.gradle
+++ b/samples/zoomable/build.gradle
@@ -4,6 +4,7 @@ dependencies {
     compile project(':drawee-backends:drawee-pipeline')
     compile project(':samples:gestures')
     compile "com.nineoldandroids:library:${NINEOLDANDROID_VERSION}"
+    provided "com.android.support:support-annotations:${SUPPORT_LIB_VERSION}"
     provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
 }
 
diff --git a/samples/zoomable/src/main/gen/com/facebook/samples/zoomable/BuildConfig.java b/samples/zoomable/src/main/gen/com/facebook/samples/zoomable/BuildConfig.java
new file mode 100644
index 000000000..c29ace52c
--- /dev/null
+++ b/samples/zoomable/src/main/gen/com/facebook/samples/zoomable/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.zoomable;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/samples/zoomable/src/main/gen/com/facebook/samples/zoomable/Manifest.java b/samples/zoomable/src/main/gen/com/facebook/samples/zoomable/Manifest.java
new file mode 100644
index 000000000..fdd826946
--- /dev/null
+++ b/samples/zoomable/src/main/gen/com/facebook/samples/zoomable/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.zoomable;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/samples/zoomable/src/main/gen/com/facebook/samples/zoomable/R.java b/samples/zoomable/src/main/gen/com/facebook/samples/zoomable/R.java
new file mode 100644
index 000000000..769933c73
--- /dev/null
+++ b/samples/zoomable/src/main/gen/com/facebook/samples/zoomable/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.samples.zoomable;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/samples/zoomable/src/main/java/com/facebook/samples/zoomable/AnimatedZoomableController.java b/samples/zoomable/src/main/java/com/facebook/samples/zoomable/AnimatedZoomableController.java
new file mode 100644
index 000000000..ad19d5212
--- /dev/null
+++ b/samples/zoomable/src/main/java/com/facebook/samples/zoomable/AnimatedZoomableController.java
@@ -0,0 +1,227 @@
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+package com.facebook.samples.zoomable;
+
+import javax.annotation.Nullable;
+
+import android.graphics.Matrix;
+import android.graphics.PointF;
+import android.view.animation.DecelerateInterpolator;
+
+import com.facebook.common.internal.Preconditions;
+import com.facebook.common.logging.FLog;
+import com.facebook.samples.gestures.TransformGestureDetector;
+
+import com.nineoldandroids.animation.Animator;
+import com.nineoldandroids.animation.AnimatorListenerAdapter;
+import com.nineoldandroids.animation.ValueAnimator;
+
+/**
+ * ZoomableController that adds animation capabilities to DefaultZoomableController.
+ */
+public class AnimatedZoomableController extends DefaultZoomableController {
+
+  private static final Class<?> TAG = AnimatedZoomableController.class;
+
+  private boolean mIsAnimating;
+  private final ValueAnimator mValueAnimator;
+  private final float[] mStartValues = new float[9];
+  private final float[] mStopValues = new float[9];
+  private final float[] mCurrentValues = new float[9];
+  private final Matrix mNewTransform = new Matrix();
+  private final Matrix mWorkingTransform = new Matrix();
+
+  public static AnimatedZoomableController newInstance() {
+    return new AnimatedZoomableController(TransformGestureDetector.newInstance());
+  }
+
+  public AnimatedZoomableController(TransformGestureDetector transformGestureDetector) {
+    super(transformGestureDetector);
+    mValueAnimator = ValueAnimator.ofFloat(0, 1);
+    mValueAnimator.setInterpolator(new DecelerateInterpolator());
+  }
+
+  @Override
+  public void reset() {
+    FLog.v(TAG, "reset");
+    stopAnimation();
+    mWorkingTransform.reset();
+    mNewTransform.reset();
+    super.reset();
+  }
+
+  /**
+   * Returns true if the zoomable transform is identity matrix, and the controller is idle.
+   */
+  @Override
+  public boolean isIdentity() {
+    return !isAnimating() && super.isIdentity();
+  }
+
+  /**
+   * Zooms to the desired scale and positions the image so that the given image point corresponds
+   * to the given view point.
+   *
+   * <p>If this method is called while an animation or gesture is already in progress,
+   * the current animation or gesture will be stopped first.
+   *
+   * @param scale desired scale, will be limited to {min, max} scale factor
+   * @param imagePoint 2D point in image's relative coordinate system (i.e. 0 <= x, y <= 1)
+   * @param viewPoint 2D point in view's absolute coordinate system
+   */
+  @Override
+  public void zoomToPoint(
+      float scale,
+      PointF imagePoint,
+      PointF viewPoint) {
+    zoomToPoint(scale, imagePoint, viewPoint, LIMIT_ALL, 0, null);
+  }
+
+  /**
+   * Zooms to the desired scale and positions the image so that the given image point corresponds
+   * to the given view point.
+   *
+   * <p>If this method is called while an animation or gesture is already in progress,
+   * the current animation or gesture will be stopped first.
+   *
+   * @param scale desired scale, will be limited to {min, max} scale factor
+   * @param imagePoint 2D point in image's relative coordinate system (i.e. 0 <= x, y <= 1)
+   * @param viewPoint 2D point in view's absolute coordinate system
+   * @param limitFlags whether to limit translation and/or scale.
+   * @param durationMs length of animation of the zoom, or 0 if no animation desired
+   * @param onAnimationComplete code to run when the animation completes. Ignored if durationMs=0
+   */
+  public void zoomToPoint(
+      float scale,
+      PointF imagePoint,
+      PointF viewPoint,
+      @LimitFlag int limitFlags,
+      long durationMs,
+      @Nullable Runnable onAnimationComplete) {
+    FLog.v(TAG, "zoomToPoint: duration %d ms", durationMs);
+    calculateZoomToPointTransform(
+        mNewTransform,
+        scale,
+        imagePoint,
+        viewPoint,
+        limitFlags);
+    setTransform(mNewTransform, durationMs, onAnimationComplete);
+  }
+
+  /**
+   * Sets a new zoomable transformation and animates to it if desired.
+   *
+   * <p>If this method is called while an animation or gesture is already in progress,
+   * the current animation or gesture will be stopped first.
+   *
+   * @param newTransform new transform to make active
+   * @param durationMs duration of the animation, or 0 to not animate
+   * @param onAnimationComplete code to run when the animation completes. Ignored if durationMs=0
+   */
+  public void setTransform(
+      Matrix newTransform,
+      long durationMs,
+      @Nullable Runnable onAnimationComplete) {
+    FLog.v(TAG, "setTransform: duration %d ms", durationMs);
+    if (durationMs <= 0) {
+      setTransformImmediate(newTransform);
+    } else {
+      setTransformAnimated(newTransform, durationMs, onAnimationComplete);
+    }
+  }
+
+  private void setTransformImmediate(final Matrix newTransform) {
+    FLog.v(TAG, "setTransformImmediate");
+    stopAnimation();
+    mWorkingTransform.set(newTransform);
+    super.setTransform(newTransform);
+    getDetector().restartGesture();
+  }
+
+  private void setTransformAnimated(
+      final Matrix newTransform,
+      long durationMs,
+      @Nullable final Runnable onAnimationComplete) {
+    FLog.v(TAG, "setTransformAnimated: duration %d ms", durationMs);
+    stopAnimation();
+    Preconditions.checkArgument(durationMs > 0);
+    Preconditions.checkState(!isAnimating());
+    mIsAnimating = true;
+    mValueAnimator.setDuration(durationMs);
+    getTransform().getValues(mStartValues);
+    newTransform.getValues(mStopValues);
+    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+      @Override
+      public void onAnimationUpdate(ValueAnimator valueAnimator) {
+        calculateInterpolation(mWorkingTransform, (float) valueAnimator.getAnimatedValue());
+        AnimatedZoomableController.super.setTransform(mWorkingTransform);
+      }
+    });
+    mValueAnimator.addListener(new AnimatorListenerAdapter() {
+      @Override
+      public void onAnimationCancel(Animator animation) {
+        FLog.v(TAG, "setTransformAnimated: animation cancelled");
+        onAnimationStopped();
+      }
+      @Override
+      public void onAnimationEnd(Animator animation) {
+        FLog.v(TAG, "setTransformAnimated: animation finished");
+        onAnimationStopped();
+      }
+      private void onAnimationStopped() {
+        if (onAnimationComplete != null) {
+          onAnimationComplete.run();
+        }
+        mIsAnimating = false;
+        getDetector().restartGesture();
+      }
+    });
+    mValueAnimator.start();
+  }
+
+  private void stopAnimation() {
+    if (!mIsAnimating) {
+      return;
+    }
+    FLog.v(TAG, "stopAnimation");
+    mValueAnimator.cancel();
+    mValueAnimator.removeAllUpdateListeners();
+    mValueAnimator.removeAllListeners();
+  }
+
+  private boolean isAnimating() {
+    return mIsAnimating;
+  }
+
+  @Override
+  public void onGestureBegin(TransformGestureDetector detector) {
+    FLog.v(TAG, "onGestureBegin");
+    stopAnimation();
+    super.onGestureBegin(detector);
+  }
+
+  @Override
+  public void onGestureUpdate(TransformGestureDetector detector) {
+    FLog.v(TAG, "onGestureUpdate %s", isAnimating() ? "(ignored)" : "");
+    if (isAnimating()) {
+      return;
+    }
+    super.onGestureUpdate(detector);
+  }
+
+  private void calculateInterpolation(Matrix outMatrix, float fraction) {
+    for (int i = 0; i < 9; i++) {
+      mCurrentValues[i] = (1 - fraction) * mStartValues[i] + fraction * mStopValues[i];
+    }
+    outMatrix.setValues(mCurrentValues);
+  }
+}
diff --git a/samples/zoomable/src/main/java/com/facebook/samples/zoomable/DefaultZoomableController.java b/samples/zoomable/src/main/java/com/facebook/samples/zoomable/DefaultZoomableController.java
index 49ba30ccb..37c192311 100644
--- a/samples/zoomable/src/main/java/com/facebook/samples/zoomable/DefaultZoomableController.java
+++ b/samples/zoomable/src/main/java/com/facebook/samples/zoomable/DefaultZoomableController.java
@@ -12,27 +12,42 @@
 
 package com.facebook.samples.zoomable;
 
-import javax.annotation.Nullable;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 import android.graphics.Matrix;
 import android.graphics.PointF;
 import android.graphics.RectF;
+import android.support.annotation.IntDef;
 import android.view.MotionEvent;
-import android.view.animation.DecelerateInterpolator;
 
-import com.facebook.common.internal.Preconditions;
+import com.facebook.common.logging.FLog;
 import com.facebook.samples.gestures.TransformGestureDetector;
 
-import com.nineoldandroids.animation.Animator;
-import com.nineoldandroids.animation.AnimatorListenerAdapter;
-import com.nineoldandroids.animation.ValueAnimator;
-
 /**
  * Zoomable controller that calculates transformation based on touch events.
  */
 public class DefaultZoomableController
     implements ZoomableController, TransformGestureDetector.Listener {
 
+  @IntDef(flag=true, value={
+      LIMIT_NONE,
+      LIMIT_TRANSLATION_X,
+      LIMIT_TRANSLATION_Y,
+      LIMIT_SCALE,
+      LIMIT_ALL
+  })
+  @Retention(RetentionPolicy.SOURCE)
+  public @interface LimitFlag {}
+
+  public static final int LIMIT_NONE = 0;
+  public static final int LIMIT_TRANSLATION_X = 1;
+  public static final int LIMIT_TRANSLATION_Y = 2;
+  public static final int LIMIT_SCALE = 4;
+  public static final int LIMIT_ALL = LIMIT_TRANSLATION_X | LIMIT_TRANSLATION_Y | LIMIT_SCALE;
+
+  private static final Class<?> TAG = DefaultZoomableController.class;
+
   private static final RectF IDENTITY_RECT = new RectF(0, 0, 1, 1);
 
   private TransformGestureDetector mGestureDetector;
@@ -45,47 +60,45 @@
   private boolean mIsTranslationEnabled = true;
 
   private float mMinScaleFactor = 1.0f;
-  private float mMaxScaleFactor = Float.POSITIVE_INFINITY;
+  private float mMaxScaleFactor = 2.0f;
 
+  // View bounds, in view-absolute coordinates
   private final RectF mViewBounds = new RectF();
+  // Non-transformed image bounds, in view-absolute coordinates
   private final RectF mImageBounds = new RectF();
+  // Transformed image bounds, in view-absolute coordinates
   private final RectF mTransformedImageBounds = new RectF();
+
   private final Matrix mPreviousTransform = new Matrix();
   private final Matrix mActiveTransform = new Matrix();
   private final Matrix mActiveTransformInverse = new Matrix();
   private final float[] mTempValues = new float[9];
   private final RectF mTempRect = new RectF();
 
-  private final ValueAnimator mValueAnimator;
-  private final float[] mAnimationStartValues = new float[9];
-  private final float[] mAnimationDestValues = new float[9];
-  private final float[] mAnimationCurrValues = new float[9];
-  private final Matrix mNewTransform = new Matrix();
-
-  public DefaultZoomableController(TransformGestureDetector gestureDetector) {
-    mGestureDetector = gestureDetector;
-    mGestureDetector.setListener(this);
-    mValueAnimator = ValueAnimator.ofFloat(0, 1);
-    mValueAnimator.setInterpolator(new DecelerateInterpolator());
-  }
-
   public static DefaultZoomableController newInstance() {
     return new DefaultZoomableController(TransformGestureDetector.newInstance());
   }
 
-  @Override
-  public void setListener(Listener listener) {
-    mListener = listener;
+  public DefaultZoomableController(TransformGestureDetector gestureDetector) {
+    mGestureDetector = gestureDetector;
+    mGestureDetector.setListener(this);
   }
 
   /** Rests the controller. */
   public void reset() {
+    FLog.v(TAG, "reset");
     mGestureDetector.reset();
     mPreviousTransform.reset();
     mActiveTransform.reset();
     onTransformChanged();
   }
 
+  /** Sets the zoomable listener. */
+  @Override
+  public void setListener(Listener listener) {
+    mListener = listener;
+  }
+
   /** Sets whether the controller is enabled or not. */
   @Override
   public void setEnabled(boolean enabled) {
@@ -95,7 +108,7 @@ public void setEnabled(boolean enabled) {
     }
   }
 
-  /** Returns whether the controller is enabled or not. */
+  /** Gets whether the controller is enabled or not. */
   @Override
   public boolean isEnabled() {
     return mIsEnabled;
@@ -131,16 +144,39 @@ public boolean isTranslationEnabled() {
     return  mIsTranslationEnabled;
   }
 
-  /** Gets the image bounds before zoomable transformation is applied. */
-  public RectF getImageBounds() {
-    return mImageBounds;
+  /**
+   * Sets the minimum scale factor allowed.
+   * <p> Hierarchy's scaling (if any) is not taken into account.
+   */
+  public void setMinScaleFactor(float minScaleFactor) {
+    mMinScaleFactor = minScaleFactor;
   }
 
-  protected RectF getTransformedImageBounds() {
-    return mTransformedImageBounds;
+  /** Gets the minimum scale factor allowed. */
+  public float getMinScaleFactor() {
+    return mMinScaleFactor;
+  }
+
+  /**
+   * Sets the maximum scale factor allowed.
+   * <p> Hierarchy's scaling (if any) is not taken into account.
+   */
+  public void setMaxScaleFactor(float maxScaleFactor) {
+    mMaxScaleFactor = maxScaleFactor;
   }
 
-  /** Sets the image bounds before zoomable transformation is applied. */
+  /** Gets the maximum scale factor allowed. */
+  public float getMaxScaleFactor() {
+    return mMaxScaleFactor;
+  }
+
+  /** Gets the current scale factor. */
+  @Override
+  public float getScaleFactor() {
+    return getMatrixScaleFactor(mActiveTransform);
+  }
+
+  /** Sets the image bounds, in view-absolute coordinates. */
   @Override
   public void setImageBounds(RectF imageBounds) {
     if (!imageBounds.equals(mImageBounds)) {
@@ -149,9 +185,14 @@ public void setImageBounds(RectF imageBounds) {
     }
   }
 
-  /** Gets the view bounds. */
-  public RectF getViewBounds() {
-    return mViewBounds;
+  /** Gets the non-transformed image bounds, in view-absolute coordinates. */
+  public RectF getImageBounds() {
+    return mImageBounds;
+  }
+
+  /** Gets the transformed image bounds, in view-absolute coordinates */
+  private RectF getTransformedImageBounds() {
+    return mTransformedImageBounds;
   }
 
   /** Sets the view bounds. */
@@ -160,38 +201,40 @@ public void setViewBounds(RectF viewBounds) {
     mViewBounds.set(viewBounds);
   }
 
-  /** Gets the minimum scale factor allowed. */
-  public float getMinScaleFactor() {
-    return mMinScaleFactor;
+  /** Gets the view bounds. */
+  public RectF getViewBounds() {
+    return mViewBounds;
   }
 
   /**
-   * Sets the minimum scale factor allowed.
-   * <p>
-   * Note that the hierarchy performs scaling as well, which
-   * is not accounted here, so the actual scale factor may differ.
+   * Returns true if the zoomable transform is identity matrix.
    */
-  public void setMinScaleFactor(float minScaleFactor) {
-    mMinScaleFactor = minScaleFactor;
+  @Override
+  public boolean isIdentity() {
+    return isMatrixIdentity(mActiveTransform, 1e-3f);
   }
 
-  /** Gets the maximum scale factor allowed. */
-  public float getMaxScaleFactor() {
-    return mMaxScaleFactor;
+  /**
+   * Gets the matrix that transforms image-absolute coordinates to view-absolute coordinates.
+   * The zoomable transformation is taken into account.
+   *
+   * Internal matrix is exposed for performance reasons and is not to be modified by the callers.
+   */
+  @Override
+  public Matrix getTransform() {
+    return mActiveTransform;
   }
 
   /**
-   * Sets the maximum scale factor allowed.
-   * <p>
-   * Note that the hierarchy performs scaling as well, which
-   * is not accounted here, so the actual scale factor may differ.
+   * Gets the matrix that transforms image-relative coordinates to view-absolute coordinates.
+   * The zoomable transformation is taken into account.
    */
-  public void setMaxScaleFactor(float maxScaleFactor) {
-    mMaxScaleFactor = maxScaleFactor;
+  public void getImageRelativeToViewAbsoluteTransform(Matrix outMatrix) {
+    outMatrix.setRectToRect(IDENTITY_RECT, mTransformedImageBounds, Matrix.ScaleToFit.FILL);
   }
 
   /**
-   * Maps point from the view's to the image's relative coordinate system.
+   * Maps point from view-absolute to image-relative coordinates.
    * This takes into account the zoomable transformation.
    */
   public PointF mapViewToImage(PointF viewPoint) {
@@ -205,7 +248,7 @@ public PointF mapViewToImage(PointF viewPoint) {
   }
 
   /**
-   * Maps point from the image's relative to the view's coordinate system.
+   * Maps point from image-relative to view-absolute coordinates.
    * This takes into account the zoomable transformation.
    */
   public PointF mapImageToView(PointF imagePoint) {
@@ -218,9 +261,9 @@ public PointF mapImageToView(PointF imagePoint) {
   }
 
   /**
-   * Maps array of 2D points from absolute to the image's relative coordinate system,
-   * and writes the transformed points back into the array.
-   * Points are represented by float array of [x0, y0, x1, y1, ...].
+   * Maps array of 2D points from view-absolute to image-relative coordinates.
+   * This does NOT take into account the zoomable transformation.
+   * Points are represented by a float array of [x0, y0, x1, y1, ...].
    *
    * @param destPoints destination array (may be the same as source array)
    * @param srcPoints source array
@@ -234,8 +277,8 @@ private void mapAbsoluteToRelative(float[] destPoints, float[] srcPoints, int nu
   }
 
   /**
-   * Maps array of 2D points from relative to the image's absolute coordinate system,
-   * and writes the transformed points back into the array
+   * Maps array of 2D points from image-relative to view-absolute coordinates.
+   * This does NOT take into account the zoomable transformation.
    * Points are represented by float array of [x0, y0, x1, y1, ...].
    *
    * @param destPoints destination array (may be the same as source array)
@@ -250,237 +293,272 @@ private void mapRelativeToAbsolute(float[] destPoints, float[] srcPoints, int nu
   }
 
   /**
-   * Gets the zoomable transformation
-   * Internal matrix is exposed for performance reasons and is not to be modified by the callers.
-   */
-  @Override
-  public Matrix getTransform() {
-    return mActiveTransform;
-  }
-
-  /**
-   * Returns the matrix that fully transforms the image from image-relative coordinates
-   * to scaled view-absolute coordinates.
-   */
-  public void getImageRelativeToViewAbsoluteTransform(Matrix outMatrix) {
-    mActiveTransform.mapRect(mTempRect, mImageBounds);
-    outMatrix.setRectToRect(IDENTITY_RECT, mTempRect, Matrix.ScaleToFit.FILL);
-  }
-
-  // TODO(balazsbalazs) resolve issues with interrupting an existing animation/gesture with
-  // a new animation or transform
-
-  /**
-   * Sets a new zoom transformation.
+   * Zooms to the desired scale and positions the image so that the given image point corresponds
+   * to the given view point.
    *
-   * <p>If this method is called while an animation or gesture is already in progress,
-   * this will currently result in undefined behavior.
-   */
-  public void setTransform(Matrix newTransform) {
-    setTransform(newTransform, 0, null);
-  }
-
-  /**
-   * Sets a new zoomable transformation and animates to it if desired.
-   *
-   * <p>If this method is called while an animation or gesture is already in progress,
-   * this will currently result in undefined behavior.
-   *
-   * @param newTransform new transform to make active
-   * @param durationMs duration of the animation, or 0 to not animate
-   * @param onAnimationComplete code to run when the animation completes. Ignored if durationMs=0
+   * @param scale desired scale, will be limited to {min, max} scale factor
+   * @param imagePoint 2D point in image's relative coordinate system (i.e. 0 <= x, y <= 1)
+   * @param viewPoint 2D point in view's absolute coordinate system
    */
-  public void setTransform(
-      Matrix newTransform,
-      long durationMs,
-      @Nullable Runnable onAnimationComplete) {
-    if (mGestureDetector.isGestureInProgress()) {
-      mGestureDetector.reset();
-    }
-    cancelAnimation();
-    if (durationMs <= 0) {
-      mActiveTransform.set(newTransform);
-      onTransformChanged();
-    } else {
-      setTransformAnimated(newTransform, durationMs, onAnimationComplete);
-    }
-  }
-
-  /** Do not call this method directly; call it only from setTransform. */
-  private void setTransformAnimated(
-      final Matrix newTransform,
-      long durationMs,
-      @Nullable final Runnable onAnimationComplete) {
-    Preconditions.checkArgument(durationMs > 0);
-    Preconditions.checkState(!mValueAnimator.isRunning());
-    mValueAnimator.setDuration(durationMs);
-    mActiveTransform.getValues(mAnimationStartValues);
-    newTransform.getValues(mAnimationDestValues);
-    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
-      @Override
-      public void onAnimationUpdate(ValueAnimator valueAnimator) {
-        float fraction = (float) valueAnimator.getAnimatedValue();
-        for (int i = 0; i < mAnimationCurrValues.length; i++) {
-          mAnimationCurrValues[i] = (1 - fraction) * mAnimationStartValues[i] +
-              fraction * mAnimationDestValues[i];
-        }
-        mActiveTransform.setValues(mAnimationCurrValues);
-        onTransformChanged();
-      }
-    });
-    if (onAnimationComplete != null) {
-      mValueAnimator.addListener(new AnimatorListenerAdapter() {
-        @Override
-        public void onAnimationEnd(Animator animation) {
-          onAnimationComplete.run();
-        }
-      });
-    }
-    mValueAnimator.start();
-  }
-
-  private void cancelAnimation() {
-    mValueAnimator.removeAllUpdateListeners();
-    mValueAnimator.removeAllListeners();
-    if (mValueAnimator.isRunning()) {
-      mValueAnimator.cancel();
-    }
-  }
-
-  /** Notifies controller of the received touch event.  */
-  @Override
-  public boolean onTouchEvent(MotionEvent event) {
-    if (mIsEnabled) {
-      return mGestureDetector.onTouchEvent(event);
-    }
-    return false;
-  }
-
-  protected void onTransformChanged() {
-    mActiveTransform.mapRect(mTransformedImageBounds, mImageBounds);
-    if (mListener != null && isEnabled()) {
-      mListener.onTransformChanged(mActiveTransform);
-    }
+  public void zoomToPoint(float scale, PointF imagePoint, PointF viewPoint) {
+    FLog.v(TAG, "zoomToPoint");
+    calculateZoomToPointTransform(mActiveTransform, scale, imagePoint, viewPoint, LIMIT_ALL);
+    onTransformChanged();
   }
 
   /**
-   * Zooms to the desired scale and positions the view so that imagePoint is in the center.
-   *
-   * <p>If this method is called while an animation or gesture is already in progress,
-   * this will currently result in undefined behavior.
+   * Calculates the zoom transformation that would zoom to the desired scale and position the image
+   * so that the given image point corresponds to the given view point.
    *
+   * @param outTransform the matrix to store the result to
    * @param scale desired scale, will be limited to {min, max} scale factor
    * @param imagePoint 2D point in image's relative coordinate system (i.e. 0 <= x, y <= 1)
    * @param viewPoint 2D point in view's absolute coordinate system
-   * @param limitTransX  Whether to adjust the transform to prevent black bars from appearing on
-   *                     the left or right.
-   * @param limitTransY Whether to adjust the transform to prevent black bars from appearing on
-   *                    the top or bottom.
-   * @param durationMs length of animation of the zoom, or 0 if no animation desired
-   * @param onAnimationComplete code to execute when the animation is complete.
-   *                            Ignored if durationMs=0
+   * @param limitFlags whether to limit translation and/or scale.
+   * @return whether or not the transform has been corrected due to limitation
    */
-  public void zoomToImagePoint(
+  protected boolean calculateZoomToPointTransform(
+      Matrix outTransform,
       float scale,
       PointF imagePoint,
       PointF viewPoint,
-      boolean limitTransX,
-      boolean limitTransY,
-      long durationMs,
-      @Nullable Runnable onAnimationComplete) {
-    scale = limit(scale, mMinScaleFactor, mMaxScaleFactor);
+      @LimitFlag int limitFlags) {
     float[] viewAbsolute = mTempValues;
     viewAbsolute[0] = imagePoint.x;
     viewAbsolute[1] = imagePoint.y;
     mapRelativeToAbsolute(viewAbsolute, viewAbsolute, 1);
     float distanceX = viewPoint.x - viewAbsolute[0];
     float distanceY = viewPoint.y - viewAbsolute[1];
-    mNewTransform.setScale(scale, scale, viewAbsolute[0], viewAbsolute[1]);
-    mNewTransform.postTranslate(distanceX, distanceY);
-    limitTranslation(mNewTransform, limitTransX, limitTransY);
+    boolean transformCorrected = false;
+    outTransform.setScale(scale, scale, viewAbsolute[0], viewAbsolute[1]);
+    transformCorrected |= limitScale(outTransform, viewAbsolute[0], viewAbsolute[1], limitFlags);
+    outTransform.postTranslate(distanceX, distanceY);
+    transformCorrected |= limitTranslation(outTransform, limitFlags);
+    return transformCorrected;
+  }
+
+  /** Sets a new zoom transformation. */
+  public void setTransform(Matrix newTransform) {
+    FLog.v(TAG, "setTransform");
+    mActiveTransform.set(newTransform);
+    onTransformChanged();
+  }
 
-    setTransform(mNewTransform, durationMs, onAnimationComplete);
+  /** Gets the gesture detector. */
+  protected TransformGestureDetector getDetector() {
+    return mGestureDetector;
+  }
+
+  /** Notifies controller of the received touch event.  */
+  @Override
+  public boolean onTouchEvent(MotionEvent event) {
+    FLog.v(TAG, "onTouchEvent: action: ", event.getAction());
+    if (mIsEnabled) {
+      return mGestureDetector.onTouchEvent(event);
+    }
+    return false;
   }
 
   /* TransformGestureDetector.Listener methods  */
 
   @Override
   public void onGestureBegin(TransformGestureDetector detector) {
+    FLog.v(TAG, "onGestureBegin");
     mPreviousTransform.set(mActiveTransform);
-    // TODO(balazsbalazs): animation should be cancelled here
   }
 
   @Override
   public void onGestureUpdate(TransformGestureDetector detector) {
-    mActiveTransform.set(mPreviousTransform);
+    FLog.v(TAG, "onGestureUpdate");
+    boolean transformCorrected = calculateGestureTransform(mActiveTransform, LIMIT_ALL);
+    onTransformChanged();
+    if (transformCorrected) {
+      mGestureDetector.restartGesture();
+    }
+  }
+
+  @Override
+  public void onGestureEnd(TransformGestureDetector detector) {
+    FLog.v(TAG, "onGestureEnd");
+  }
+
+  /**
+   * Calculates the zoom transformation based on the current gesture.
+   *
+   * @param outTransform the matrix to store the result to
+   * @param limitTypes whether to limit translation and/or scale.
+   * @return whether or not the transform has been corrected due to limitation
+   */
+  protected boolean calculateGestureTransform(
+      Matrix outTransform,
+      @LimitFlag int limitTypes) {
+    TransformGestureDetector detector = mGestureDetector;
+    boolean transformCorrected = false;
+    outTransform.set(mPreviousTransform);
     if (mIsRotationEnabled) {
       float angle = detector.getRotation() * (float) (180 / Math.PI);
-      mActiveTransform.postRotate(angle, detector.getPivotX(), detector.getPivotY());
+      outTransform.postRotate(angle, detector.getPivotX(), detector.getPivotY());
     }
     if (mIsScaleEnabled) {
       float scale = detector.getScale();
-      mActiveTransform.postScale(scale, scale, detector.getPivotX(), detector.getPivotY());
+      outTransform.postScale(scale, scale, detector.getPivotX(), detector.getPivotY());
     }
-    limitScale(detector.getPivotX(), detector.getPivotY());
+    transformCorrected |=
+        limitScale(outTransform, detector.getPivotX(), detector.getPivotY(), limitTypes);
     if (mIsTranslationEnabled) {
-      mActiveTransform.postTranslate(detector.getTranslationX(), detector.getTranslationY());
-    }
-    if (limitTranslation(mActiveTransform, true, true)) {
-      mGestureDetector.restartGesture();
+      outTransform.postTranslate(detector.getTranslationX(), detector.getTranslationY());
     }
-    onTransformChanged();
+    transformCorrected |= limitTranslation(outTransform, limitTypes);
+    return transformCorrected;
   }
 
-  @Override
-  public void onGestureEnd(TransformGestureDetector detector) {
-    mPreviousTransform.set(mActiveTransform);
-  }
-
-  /** Gets the current scale factor. */
-  @Override
-  public float getScaleFactor() {
-    mActiveTransform.getValues(mTempValues);
-    return mTempValues[Matrix.MSCALE_X];
+  private void onTransformChanged() {
+    mActiveTransform.mapRect(mTransformedImageBounds, mImageBounds);
+    if (mListener != null && isEnabled()) {
+      mListener.onTransformChanged(mActiveTransform);
+    }
   }
 
-  private void limitScale(float pivotX, float pivotY) {
-    float currentScale = getScaleFactor();
+  /**
+   * Keeps the scaling factor within the specified limits.
+   *
+   * @param pivotX x coordinate of the pivot point
+   * @param pivotY y coordinate of the pivot point
+   * @param limitTypes whether to limit scale.
+   * @return whether limiting has been applied or not
+   */
+  private boolean limitScale(
+      Matrix transform,
+      float pivotX,
+      float pivotY,
+      @LimitFlag int limitTypes) {
+    if (!shouldLimit(limitTypes, LIMIT_SCALE)) {
+      return false;
+    }
+    float currentScale = getMatrixScaleFactor(transform);
     float targetScale = limit(currentScale, mMinScaleFactor, mMaxScaleFactor);
     if (targetScale != currentScale) {
       float scale = targetScale / currentScale;
-      mActiveTransform.postScale(scale, scale, pivotX, pivotY);
+      transform.postScale(scale, scale, pivotX, pivotY);
+      return true;
     }
+    return false;
   }
 
   /**
-   * Keeps the view inside the image if possible, if not (i.e. image is smaller than view)
-   * centers the image.
-   * @param limitX whether to apply the limit on the x-axis
-   * @param limitY whether to apply the limit on the y-axis
-   * @return whether adjustments were needed or not
+   * Limits the translation so that there are no empty spaces on the sides if possible.
+   *
+   * <p> The image is attempted to be centered within the view bounds if the transformed image is
+   * smaller. There will be no empty spaces within the view bounds if the transformed image is
+   * bigger. This applies to each dimension (horizontal and vertical) independently.
+   *
+   * @param limitTypes whether to limit translation along the specific axis.
+   * @return whether limiting has been applied or not
    */
-  private boolean limitTranslation(Matrix newTransform, boolean limitX, boolean limitY) {
-    RectF bounds = mTransformedImageBounds;
-    bounds.set(mImageBounds);
-    newTransform.mapRect(bounds);
-    float offsetLeft = limitX ?
-        getOffset(bounds.left, bounds.width(), mViewBounds.width()) : bounds.left;
-    float offsetTop = limitY ?
-        getOffset(bounds.top, bounds.height(), mViewBounds.height()) : bounds.top;
-    if (offsetLeft != bounds.left || offsetTop != bounds.top) {
-      newTransform.postTranslate(offsetLeft - bounds.left, offsetTop - bounds.top);
+  private boolean limitTranslation(Matrix transform, @LimitFlag int limitTypes) {
+    if (!shouldLimit(limitTypes, LIMIT_TRANSLATION_X | LIMIT_TRANSLATION_Y)) {
+      return false;
+    }
+    RectF b = mTempRect;
+    b.set(mImageBounds);
+    transform.mapRect(b);
+    float offsetLeft = shouldLimit(limitTypes, LIMIT_TRANSLATION_X) ?
+        getOffset(b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX()) : 0;
+    float offsetTop = shouldLimit(limitTypes, LIMIT_TRANSLATION_Y) ?
+        getOffset(b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY()) : 0;
+    if (offsetLeft != 0 || offsetTop != 0) {
+      transform.postTranslate(offsetLeft, offsetTop);
       return true;
     }
     return false;
   }
 
-  private float getOffset(float offset, float imageDimension, float viewDimension) {
-    float diff = viewDimension - imageDimension;
-    return (diff > 0) ? diff / 2 : limit(offset, diff, 0);
+  /**
+   * Checks whether the specified limit flag is present in the limits provided.
+   *
+   * <p> If the flag contains multiple flags together using a bitwise OR, this only checks that at
+   * least one of the flags is included.
+   *
+   * @param limits the limits to apply
+   * @param flag the limit flag(s) to check for
+   * @return true if the flag (or one of the flags) is included in the limits
+   */
+  private static boolean shouldLimit(@LimitFlag int limits, @LimitFlag int flag) {
+    return (limits & flag) != LIMIT_NONE;
+  }
+
+  /**
+   * Returns the offset necessary to make sure that:
+   * - the image is centered within the limit if the image is smaller than the limit
+   * - there is no empty space on left/right if the image is bigger than the limit
+   */
+  private float getOffset(
+      float imageStart,
+      float imageEnd,
+      float limitStart,
+      float limitEnd,
+      float limitCenter) {
+    float imageWidth = imageEnd - imageStart, limitWidth = limitEnd - limitStart;
+    float limitInnerWidth = Math.min(limitCenter - limitStart, limitEnd - limitCenter) * 2;
+    // center if smaller than limitInnerWidth
+    if (imageWidth < limitInnerWidth) {
+      return limitCenter - (imageEnd + imageStart) / 2;
+    }
+    // to the edge if in between and limitCenter is not (limitLeft + limitRight) / 2
+    if (imageWidth < limitWidth) {
+      if (limitCenter < (limitStart + limitEnd) / 2) {
+        return limitStart - imageStart;
+      } else {
+        return limitEnd - imageEnd;
+      }
+    }
+    // to the edge if larger than limitWidth and empty space visible
+    if (imageStart > limitStart) {
+      return limitStart - imageStart;
+    }
+    if (imageEnd < limitEnd) {
+      return limitEnd - imageEnd;
+    }
+    return 0;
   }
 
+  /**
+   * Limits the value to the given min and max range.
+   */
   private float limit(float value, float min, float max) {
     return Math.min(Math.max(min, value), max);
   }
 
+  /**
+   * Gets the scale factor for the given matrix.
+   * This method assumes the equal scaling factor for X and Y axis.
+   */
+  private float getMatrixScaleFactor(Matrix transform) {
+    transform.getValues(mTempValues);
+    return mTempValues[Matrix.MSCALE_X];
+  }
+
+  /**
+   * Same as {@code Matrix.isIdentity()}, but with tolerance {@code eps}.
+   */
+  private boolean isMatrixIdentity(Matrix transform, float eps) {
+    // Checks whether the given matrix is close enough to the identity matrix:
+    //   1 0 0
+    //   0 1 0
+    //   0 0 1
+    // Or equivalently to the zero matrix, after subtracting 1.0f from the diagonal elements:
+    //   0 0 0
+    //   0 0 0
+    //   0 0 0
+    transform.getValues(mTempValues);
+    mTempValues[0] -= 1.0f; // m00
+    mTempValues[4] -= 1.0f; // m11
+    mTempValues[8] -= 1.0f; // m22
+    for (int i = 0; i < 9; i++) {
+      if (Math.abs(mTempValues[i]) > eps) {
+        return false;
+      }
+    }
+    return true;
+  }
 }
diff --git a/samples/zoomable/src/main/java/com/facebook/samples/zoomable/GestureListenerWrapper.java b/samples/zoomable/src/main/java/com/facebook/samples/zoomable/GestureListenerWrapper.java
new file mode 100644
index 000000000..5f0686684
--- /dev/null
+++ b/samples/zoomable/src/main/java/com/facebook/samples/zoomable/GestureListenerWrapper.java
@@ -0,0 +1,76 @@
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+package com.facebook.samples.zoomable;
+
+import android.view.GestureDetector;
+import android.view.MotionEvent;
+
+/**
+ * Wrapper for SimpleOnGestureListener as GestureDetector does not allow changing its listener.
+ */
+class GestureListenerWrapper extends GestureDetector.SimpleOnGestureListener {
+
+  private GestureDetector.SimpleOnGestureListener mDelegate;
+
+  public GestureListenerWrapper() {
+    mDelegate = new GestureDetector.SimpleOnGestureListener();
+  }
+
+  public void setListener(GestureDetector.SimpleOnGestureListener listener) {
+    mDelegate = listener;
+  }
+
+  @Override
+  public void onLongPress(MotionEvent e) {
+    mDelegate.onLongPress(e);
+  }
+
+  @Override
+  public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
+    return mDelegate.onScroll(e1, e2, distanceX, distanceY);
+  }
+
+  @Override
+  public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
+    return mDelegate.onFling(e1, e2, velocityX, velocityY);
+  }
+
+  @Override
+  public void onShowPress(MotionEvent e) {
+    mDelegate.onShowPress(e);
+  }
+
+  @Override
+  public boolean onDown(MotionEvent e) {
+    return mDelegate.onDown(e);
+  }
+
+  @Override
+  public boolean onDoubleTap(MotionEvent e) {
+    return mDelegate.onDoubleTap(e);
+  }
+
+  @Override
+  public boolean onDoubleTapEvent(MotionEvent e) {
+    return mDelegate.onDoubleTapEvent(e);
+  }
+
+  @Override
+  public boolean onSingleTapConfirmed(MotionEvent e) {
+    return mDelegate.onSingleTapConfirmed(e);
+  }
+
+  @Override
+  public boolean onSingleTapUp(MotionEvent e) {
+    return mDelegate.onSingleTapUp(e);
+  }
+}
diff --git a/samples/zoomable/src/main/java/com/facebook/samples/zoomable/ZoomableController.java b/samples/zoomable/src/main/java/com/facebook/samples/zoomable/ZoomableController.java
index 23d6cd58c..9bb987646 100644
--- a/samples/zoomable/src/main/java/com/facebook/samples/zoomable/ZoomableController.java
+++ b/samples/zoomable/src/main/java/com/facebook/samples/zoomable/ZoomableController.java
@@ -25,7 +25,7 @@
   /**
    * Listener interface.
    */
-  public interface Listener {
+  interface Listener {
 
     /**
      * Notifies the view that the transform changed.
@@ -65,6 +65,11 @@
    */
   float getScaleFactor();
 
+  /**
+   * Returns true if the zoomable transform is identity matrix, and the controller is idle.
+   */
+  boolean isIdentity();
+
   /**
    * Gets the current transform.
    *
diff --git a/samples/zoomable/src/main/java/com/facebook/samples/zoomable/ZoomableDraweeView.java b/samples/zoomable/src/main/java/com/facebook/samples/zoomable/ZoomableDraweeView.java
index 5b161c1a1..175250716 100644
--- a/samples/zoomable/src/main/java/com/facebook/samples/zoomable/ZoomableDraweeView.java
+++ b/samples/zoomable/src/main/java/com/facebook/samples/zoomable/ZoomableDraweeView.java
@@ -15,11 +15,13 @@
 import javax.annotation.Nullable;
 
 import android.content.Context;
+import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.RectF;
 import android.graphics.drawable.Animatable;
 import android.util.AttributeSet;
+import android.view.GestureDetector;
 import android.view.MotionEvent;
 
 import com.facebook.common.internal.Preconditions;
@@ -27,7 +29,10 @@
 import com.facebook.drawee.controller.AbstractDraweeController;
 import com.facebook.drawee.controller.BaseControllerListener;
 import com.facebook.drawee.controller.ControllerListener;
+import com.facebook.drawee.drawable.ScalingUtils;
 import com.facebook.drawee.generic.GenericDraweeHierarchy;
+import com.facebook.drawee.generic.GenericDraweeHierarchyBuilder;
+import com.facebook.drawee.generic.GenericDraweeHierarchyInflater;
 import com.facebook.drawee.interfaces.DraweeController;
 import com.facebook.drawee.view.DraweeView;
 
@@ -36,8 +41,7 @@
  * <p>
  * Once the image loads, pinch-to-zoom and translation gestures are enabled.
  */
-public class ZoomableDraweeView extends DraweeView<GenericDraweeHierarchy>
-    implements ZoomableController.Listener {
+public class ZoomableDraweeView extends DraweeView<GenericDraweeHierarchy> {
 
   private static final Class<?> TAG = ZoomableDraweeView.class;
 
@@ -46,6 +50,10 @@
   private final RectF mImageBounds = new RectF();
   private final RectF mViewBounds = new RectF();
 
+  private DraweeController mHugeImageController;
+  private ZoomableController mZoomableController;
+  private GestureDetector mTapGestureDetector;
+
   private final ControllerListener mControllerListener = new BaseControllerListener<Object>() {
     @Override
     public void onFinalImageSet(
@@ -61,67 +69,146 @@ public void onRelease(String id) {
     }
   };
 
-  private DraweeController mHugeImageController;
-  private ZoomableController mZoomableController = DefaultZoomableController.newInstance();
+  private final ZoomableController.Listener mZoomableListener = new ZoomableController.Listener() {
+    @Override
+    public void onTransformChanged(Matrix transform) {
+      ZoomableDraweeView.this.onTransformChanged(transform);
+    }
+  };
+
+  private final GestureListenerWrapper mTapListenerWrapper = new GestureListenerWrapper();
+
+  public ZoomableDraweeView(Context context, GenericDraweeHierarchy hierarchy) {
+    super(context);
+    setHierarchy(hierarchy);
+    init();
+  }
 
   public ZoomableDraweeView(Context context) {
     super(context);
+    inflateHierarchy(context, null);
     init();
   }
 
   public ZoomableDraweeView(Context context, AttributeSet attrs) {
     super(context, attrs);
+    inflateHierarchy(context, attrs);
     init();
   }
 
   public ZoomableDraweeView(Context context, AttributeSet attrs, int defStyle) {
     super(context, attrs, defStyle);
+    inflateHierarchy(context, attrs);
     init();
   }
 
+  protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {
+    Resources resources = context.getResources();
+    GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(resources)
+        .setActualImageScaleType(ScalingUtils.ScaleType.FIT_CENTER);
+    GenericDraweeHierarchyInflater.updateBuilder(builder, context, attrs);
+    setAspectRatio(builder.getDesiredAspectRatio());
+    setHierarchy(builder.build());
+  }
+
   private void init() {
-    mZoomableController.setListener(this);
+    mZoomableController = AnimatedZoomableController.newInstance();
+    mZoomableController.setListener(mZoomableListener);
+    mTapGestureDetector = new GestureDetector(getContext(), mTapListenerWrapper);
   }
 
   /**
-   * Returns the matrix that matches the zoom selected by user gestures,
-   * but does not include the base scaling of the image itself. Transforms
-   * from view-absolute to view-absolute coordinates.
+   * Gets the original image bounds, in view-absolute coordinates.
+   *
+   * <p> The original image bounds are those reported by the hierarchy. The hierarchy itself may
+   * apply scaling on its own (e.g. due to scale type) so the reported bounds are not necessarily
+   * the same as the actual bitmap dimensions. In other words, the original image bounds correspond
+   * to the image bounds within this view when no zoomable transformation is applied, but including
+   * the potential scaling of the hierarchy.
+   * Having the actual bitmap dimensions abstracted away from this view greatly simplifies
+   * implementation because the actual bitmap may change (e.g. when a high-res image arrives and
+   * replaces the previously set low-res image). With proper hierarchy scaling (e.g. FIT_CENTER),
+   * this underlying change will not affect this view nor the zoomable transformation in any way.
    */
-  public void getTransformMatrix(Matrix outMatrix) {
-    outMatrix.set(mZoomableController.getTransform());
+  protected void getImageBounds(RectF outBounds) {
+    getHierarchy().getActualImageBounds(outBounds);
   }
 
   /**
-   * Gets the bounds of the image, in view-absolute coordinates,
-   * including the effects of user gestures.
+   * Gets the bounds used to limit the translation, in view-absolute coordinates.
+   *
+   * <p> These bounds are passed to the zoomable controller in order to limit the translation. The
+   * image is attempted to be centered within the limit bounds if the transformed image is smaller.
+   * There will be no empty spaces within the limit bounds if the transformed image is bigger.
+   * This applies to each dimension (horizontal and vertical) independently.
+   * <p> Unless overridden by a subclass, these bounds are same as the view bounds.
    */
-  public void getTransformedBounds(RectF outBounds) {
-    getPlainBounds(outBounds);
-    Matrix matrix = mZoomableController.getTransform();
-    matrix.mapRect(outBounds);
+  protected void getLimitBounds(RectF outBounds) {
+    outBounds.set(0, 0, getWidth(), getHeight());
   }
 
   /**
-   * Gets the bounds of the image, in view-absolute coordinates,
-   * but not including the effets of user gestures.
+   * Sets a custom zoomable controller, instead of using the default one.
    */
-  public void getPlainBounds(RectF outBounds) {
-    getHierarchy().getActualImageBounds(outBounds);
-  }
-
   public void setZoomableController(ZoomableController zoomableController) {
     Preconditions.checkNotNull(zoomableController);
     mZoomableController.setListener(null);
     mZoomableController = zoomableController;
-    mZoomableController.setListener(this);
+    mZoomableController.setListener(mZoomableListener);
+  }
+
+  /**
+   * Gets the zoomable controller.
+   *
+   * <p> Zoomable controller can be used to zoom to point, or to map point from view to image
+   * coordinates for instance.
+   */
+  public ZoomableController getZoomableController() {
+    return mZoomableController;
+  }
+
+  /**
+   * Sets the tap listener.
+   */
+  public void setTapListener(GestureDetector.SimpleOnGestureListener tapListener) {
+    mTapListenerWrapper.setListener(tapListener);
+  }
+
+  /**
+   * Sets whether long-press tap detection is enabled.
+   * Unfortunately, long-press conflicts with onDoubleTapEvent.
+   */
+  public void setIsLongpressEnabled(boolean enabled) {
+    mTapGestureDetector.setIsLongpressEnabled(enabled);
   }
 
+  /**
+   * Sets the image controller.
+   */
   @Override
   public void setController(@Nullable DraweeController controller) {
     setControllers(controller, null);
   }
 
+  /**
+   * Sets the controllers for the normal and huge image.
+   *
+   * <p> The huge image controller is used after the image gets scaled above a certain threshold.
+   *
+   * <p> IMPORTANT: in order to avoid a flicker when switching to the huge image, the huge image
+   * controller should have the normal-image-uri set as its low-res-uri.
+   *
+   * @param controller controller to be initially used
+   * @param hugeImageController controller to be used after the client starts zooming-in
+   */
+  public void setControllers(
+      @Nullable DraweeController controller,
+      @Nullable DraweeController hugeImageController) {
+    setControllersInternal(null, null);
+    mZoomableController.setEnabled(false);
+    setControllersInternal(controller, hugeImageController);
+  }
+
   private void setControllersInternal(
       @Nullable DraweeController controller,
       @Nullable DraweeController hugeImageController) {
@@ -131,23 +218,6 @@ private void setControllersInternal(
     super.setController(controller);
   }
 
-    /**
-     * Sets the controllers for the normal and huge image.
-     *
-     * <p> IMPORTANT: in order to avoid a flicker when switching to the huge image, the huge image
-     * controller should have the normal-image-uri set as its low-res-uri.
-     *
-     * @param controller controller to be initially used
-     * @param hugeImageController controller to be used after the client starts zooming-in
-     */
-  public void setControllers(
-      @Nullable DraweeController controller,
-      @Nullable DraweeController hugeImageController) {
-    setControllersInternal(null, null);
-    mZoomableController.setEnabled(false);
-    setControllersInternal(controller, hugeImageController);
-  }
-
   private void maybeSetHugeImageController() {
     if (mHugeImageController != null &&
         mZoomableController.getScaleFactor() > HUGE_IMAGE_SCALE_FACTOR_THRESHOLD) {
@@ -179,15 +249,24 @@ protected void onDraw(Canvas canvas) {
 
   @Override
   public boolean onTouchEvent(MotionEvent event) {
+    int a = event.getActionMasked();
+    FLog.v(TAG, "onTouchEvent: %d, view %x, received", a, this.hashCode());
+    if (mTapGestureDetector.onTouchEvent(event)) {
+      FLog.v(TAG, "onTouchEvent: %d, view %x, handled by tap gesture detector", a, this.hashCode());
+      return true;
+    }
     if (mZoomableController.onTouchEvent(event)) {
-      if (mZoomableController.getScaleFactor() > 1.0f) {
+      if (!mZoomableController.isIdentity()) {
         getParent().requestDisallowInterceptTouchEvent(true);
       }
-      FLog.v(TAG, "onTouchEvent: view %x, handled by zoomable controller", this.hashCode());
+      FLog.v(TAG, "onTouchEvent: %d, view %x, handled by zoomable controller", a, this.hashCode());
       return true;
     }
-    FLog.v(TAG, "onTouchEvent: view %x, handled by the super", this.hashCode());
-    return super.onTouchEvent(event);
+    if (super.onTouchEvent(event)) {
+      FLog.v(TAG, "onTouchEvent: %d, view %x, handled by the super", a, this.hashCode());
+      return true;
+    }
+    return false;
   }
 
   @Override
@@ -210,16 +289,15 @@ private void onRelease() {
     mZoomableController.setEnabled(false);
   }
 
-  @Override
-  public void onTransformChanged(Matrix transform) {
-    FLog.v(TAG, "onTransformChanged: view %x", this.hashCode());
+  protected void onTransformChanged(Matrix transform) {
+    FLog.v(TAG, "onTransformChanged: view %x, transform: %s", this.hashCode(), transform);
     maybeSetHugeImageController();
     invalidate();
   }
 
-  private void updateZoomableControllerBounds() {
-    getPlainBounds(mImageBounds);
-    mViewBounds.set(0, 0, getWidth(), getHeight());
+  protected void updateZoomableControllerBounds() {
+    getImageBounds(mImageBounds);
+    getLimitBounds(mViewBounds);
     mZoomableController.setImageBounds(mImageBounds);
     mZoomableController.setViewBounds(mViewBounds);
     FLog.v(
diff --git a/settings.gradle b/settings.gradle
index a1a223cf0..bfa18fcf5 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -3,6 +3,7 @@ include ':drawee-backends:drawee-pipeline'
 include ':drawee-backends:drawee-volley'
 include ':fbcore'
 include ':imagepipeline'
+include ':samples:animation'
 include ':samples:comparison'
 include ':samples:gestures'
 include ':samples:demo'
@@ -12,5 +13,13 @@ include ':samples:zoomable'
 include ':samples:transition'
 include ':tools:stetho'
 include ':imagepipeline-backends:imagepipeline-okhttp'
+include ':imagepipeline-backends:imagepipeline-okhttp3'
 include ':static-webp'
 include ':imagepipeline-base'
+include ':imagepipeline-base-test'
+include ':imagepipeline-test'
+include ':animated-base'
+include ':animated-base-support'
+include ':animated-base-test'
+include ':animated-webp'
+include ':animated-gif'
diff --git a/static-webp/build.gradle b/static-webp/build.gradle
index 4d0c5fa01..8e592928f 100644
--- a/static-webp/build.gradle
+++ b/static-webp/build.gradle
@@ -13,7 +13,7 @@ dependencies {
     provided "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
     provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     compile "com.parse.bolts:bolts-android:${BOLTS_ANDROID_VERSION}"
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:support-v4:${SUPPORT_LIB_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
     compile project(':fbcore')
     compile project(':imagepipeline-base')
diff --git a/static-webp/src/main/jni/Application.mk b/static-webp/src/main/jni/Application.mk
index 1b8034d0d..f7f46e3b8 100644
--- a/static-webp/src/main/jni/Application.mk
+++ b/static-webp/src/main/jni/Application.mk
@@ -12,7 +12,7 @@ APP_STL := gnustl_static
 # Make sure every shared lib includes a .note.gnu.build-id header
 APP_LDFLAGS := -Wl,--build-id
 
-NDK_TOOLCHAIN_VERSION := 4.8
+NDK_TOOLCHAIN_VERSION := 4.9
 
 
 # We link our libs with static stl implementation. Because of that we need to
@@ -24,4 +24,4 @@ NDK_TOOLCHAIN_VERSION := 4.8
 FRESCO_CPP_CFLAGS := -fno-weak
 
 # This hides all symbols exported from libgnustl_static
-FRESCO_CPP_LDFLAGS := -Wl,--exclude-libs,libgnustl_static.a
+FRESCO_CPP_LDFLAGS := -Wl,--gc-sections,--exclude-libs,libgnustl_static.a
diff --git a/tools/stetho/src/main/gen/com/facebook/fresco/stetho/BuildConfig.java b/tools/stetho/src/main/gen/com/facebook/fresco/stetho/BuildConfig.java
new file mode 100644
index 000000000..1a57c6ceb
--- /dev/null
+++ b/tools/stetho/src/main/gen/com/facebook/fresco/stetho/BuildConfig.java
@@ -0,0 +1,8 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.fresco.stetho;
+
+/* This stub is only used by the IDE. It is NOT the BuildConfig class actually packed into the APK */
+public final class BuildConfig {
+  public final static boolean DEBUG = Boolean.parseBoolean(null);
+}
\ No newline at end of file
diff --git a/tools/stetho/src/main/gen/com/facebook/fresco/stetho/Manifest.java b/tools/stetho/src/main/gen/com/facebook/fresco/stetho/Manifest.java
new file mode 100644
index 000000000..3c59c51bc
--- /dev/null
+++ b/tools/stetho/src/main/gen/com/facebook/fresco/stetho/Manifest.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.fresco.stetho;
+
+/* This stub is only used by the IDE. It is NOT the Manifest class actually packed into the APK */
+public final class Manifest {
+}
\ No newline at end of file
diff --git a/tools/stetho/src/main/gen/com/facebook/fresco/stetho/R.java b/tools/stetho/src/main/gen/com/facebook/fresco/stetho/R.java
new file mode 100644
index 000000000..78832c281
--- /dev/null
+++ b/tools/stetho/src/main/gen/com/facebook/fresco/stetho/R.java
@@ -0,0 +1,7 @@
+/*___Generated_by_IDEA___*/
+
+package com.facebook.fresco.stetho;
+
+/* This stub is only used by the IDE. It is NOT the R class actually packed into the APK */
+public final class R {
+}
\ No newline at end of file
diff --git a/tools/stetho/src/main/java/com/facebook/imagepipeline/stetho/BaseFrescoStethoPlugin.java b/tools/stetho/src/main/java/com/facebook/imagepipeline/stetho/BaseFrescoStethoPlugin.java
index 727fb4157..f2bf01d73 100644
--- a/tools/stetho/src/main/java/com/facebook/imagepipeline/stetho/BaseFrescoStethoPlugin.java
+++ b/tools/stetho/src/main/java/com/facebook/imagepipeline/stetho/BaseFrescoStethoPlugin.java
@@ -63,8 +63,8 @@ protected BaseFrescoStethoPlugin(ImagePipelineFactory factory) {
   protected void initialize(ImagePipelineFactory factory) {
     mBitmapMemoryCacheInspector = new CountingMemoryCacheInspector<>(
         factory.getBitmapCountingMemoryCache());
-    mMainFileCache = factory.getMainDiskStorageCache();
-    mSmallFileCache = factory.getSmallImageDiskStorageCache();
+    mMainFileCache = factory.getMainFileCache();
+    mSmallFileCache = factory.getSmallImageFileCache();
     mInitialized = true;
   }
 
