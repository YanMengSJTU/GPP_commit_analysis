diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheProducer.java
index 9a0706af0..93a27ca93 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheProducer.java
@@ -167,6 +167,7 @@ public void onNewResultImpl(
                 .onNewResult((newCachedResult != null) ? newCachedResult : newResult, status);
           } finally {
             CloseableReference.closeSafely(newCachedResult);
+            CloseableReference.closeSafely(newResult);
           }
         } finally {
           if (FrescoSystrace.isTracing()) {
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/PostprocessedBitmapMemoryCacheProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/PostprocessedBitmapMemoryCacheProducer.java
index 63e99d13b..6e468be67 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/PostprocessedBitmapMemoryCacheProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/PostprocessedBitmapMemoryCacheProducer.java
@@ -132,6 +132,7 @@ protected void onNewResultImpl(
             (newCachedResult != null) ? newCachedResult : newResult, status);
       } finally {
         CloseableReference.closeSafely(newCachedResult);
+        CloseableReference.closeSafely(newResult);
       }
     }
   }
diff --git a/samples/optimizeconfig/.gitignore b/samples/optimizeconfig/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/samples/optimizeconfig/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/samples/optimizeconfig/build.gradle b/samples/optimizeconfig/build.gradle
new file mode 100644
index 000000000..6e8f8a6aa
--- /dev/null
+++ b/samples/optimizeconfig/build.gradle
@@ -0,0 +1,55 @@
+apply plugin: 'com.android.application'
+
+android {
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    defaultConfig {
+        applicationId "com.facebook.samples.optimizeconfig"
+        minSdkVersion rootProject.ext.samplesMinSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
+        versionCode 1
+        versionName "${VERSION_NAME}"
+
+        testApplicationId "com.facebook.samples.optimizeconfig.test"
+        testInstrumentationRunner "android.test.InstrumentationTestRunner"
+    }
+
+    flavorDimensions "main"
+
+    productFlavors {
+        internal
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt')
+        }
+    }
+
+    lintOptions {
+        warning 'InvalidPackage'
+        abortOnError false
+    }
+
+    splits {
+        abi {
+            enable true
+            reset()
+            include 'armeabi-v7a'
+            universalApk false
+        }
+    }
+}
+
+configurations {
+    internalCompile
+}
+
+dependencies {
+    implementation "androidx.legacy:legacy-support-core-ui:${versions.androidx.legacy_support_core_ui}"
+    implementation "com.squareup.okhttp3:okhttp:3.11.0"
+
+    internalImplementation project(':drawee-backends:drawee-pipeline')
+}
diff --git a/samples/optimizeconfig/src/main/AndroidManifest.xml b/samples/optimizeconfig/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..5aa678199
--- /dev/null
+++ b/samples/optimizeconfig/src/main/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.samples.optimizeconfig" >
+
+  <uses-permission android:name="android.permission.INTERNET" />
+
+    <application
+        android:name=".OptimizeConfigApplication"
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name">
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/config/CustomBitmapMemoryCacheParamsSupplier.java b/samples/optimizeconfig/src/main/java/com/facebook/config/CustomBitmapMemoryCacheParamsSupplier.java
new file mode 100644
index 000000000..2e43781ed
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/config/CustomBitmapMemoryCacheParamsSupplier.java
@@ -0,0 +1,61 @@
+package com.facebook.config;
+
+import android.app.ActivityManager;
+import android.os.Build;
+import com.facebook.common.internal.Supplier;
+import com.facebook.common.util.ByteConstants;
+import com.facebook.imagepipeline.cache.MemoryCacheParams;
+import java.util.concurrent.TimeUnit;
+
+public class CustomBitmapMemoryCacheParamsSupplier implements Supplier<MemoryCacheParams> {
+
+  private ActivityManager activityManager;
+
+  public CustomBitmapMemoryCacheParamsSupplier(ActivityManager activityManager) {
+    this.activityManager = activityManager;
+  }
+
+  @Override
+  public MemoryCacheParams get() {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP
+        && Build.VERSION.SDK_INT <= Build.VERSION_CODES.M) {
+      int maxCacheSize = Math.min(getMaxCacheSize(), 16 * ByteConstants.MB);
+      int maxCacheEntrySize = 2 * ByteConstants.MB;
+      int entries = maxCacheSize / maxCacheEntrySize * 2;
+      return new MemoryCacheParams(
+          maxCacheSize,
+          entries,
+          maxCacheSize,
+          entries,
+          maxCacheEntrySize,
+          TimeUnit.MINUTES.toMillis(5));
+    } else {
+      return new MemoryCacheParams(
+          getMaxCacheSize(),
+          256,
+          Integer.MAX_VALUE,
+          Integer.MAX_VALUE,
+          Integer.MAX_VALUE,
+          TimeUnit.MINUTES.toMillis(5));
+    }
+  }
+
+  private int getMaxCacheSize() {
+    final int maxMemory =
+        Math.min(activityManager.getMemoryClass() * ByteConstants.MB, Integer.MAX_VALUE);
+
+    if (maxMemory < 32 * ByteConstants.MB) {
+      return 4 * ByteConstants.MB;
+    } else if (maxMemory < 64 * ByteConstants.MB) {
+      return 6 * ByteConstants.MB;
+    } else {
+      // We don't want to use more ashmem on Gingerbread for now, since it doesn't respond well to
+      // native memory pressure (doesn't throw exceptions, crashes app, crashes phone)
+      if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.GINGERBREAD) {
+        return 8 * ByteConstants.MB;
+      } else {
+        return maxMemory / 8;
+      }
+    }
+  }
+}
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/config/CustomPoolFactory.java b/samples/optimizeconfig/src/main/java/com/facebook/config/CustomPoolFactory.java
new file mode 100644
index 000000000..41107232b
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/config/CustomPoolFactory.java
@@ -0,0 +1,66 @@
+package com.facebook.config;
+
+import android.os.Build;
+import android.util.SparseIntArray;
+import com.facebook.common.util.ByteConstants;
+import com.facebook.imagepipeline.memory.BitmapPool;
+import com.facebook.imagepipeline.memory.PoolConfig;
+import com.facebook.imagepipeline.memory.PoolFactory;
+import com.facebook.imagepipeline.memory.PoolParams;
+
+public class CustomPoolFactory {
+
+  public final static PoolFactory getPoolFactory() {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP
+        && Build.VERSION.SDK_INT <= Build.VERSION_CODES.M) {
+      PoolParams poolParams = DefaultBitmapPoolParams.get();
+      PoolConfig.Builder builder = PoolConfig.newBuilder();
+      builder.setBitmapPoolParams(poolParams);
+      return new PoolFactory(builder.build());
+    } else {
+      return new PoolFactory(PoolConfig.newBuilder().build());
+    }
+  }
+
+  /**
+   * Provides pool parameters for {@link BitmapPool}
+   */
+  private static class DefaultBitmapPoolParams {
+
+    /**
+     * We are not reusing Bitmaps and want to free them as soon as possible.
+     */
+    private static final int MAX_SIZE_SOFT_CAP = 0;
+    /**
+     * This will cause all get/release calls to behave like alloc/free calls i.e. no pooling.
+     */
+    private static final SparseIntArray DEFAULT_BUCKETS = new SparseIntArray(0);
+
+    private DefaultBitmapPoolParams() {
+    }
+
+    /**
+     * Our Bitmaps live in ashmem, meaning that they are pinned in androids' shared native
+     * memory. Therefore, we are not constrained by the max heap size of the dalvik heap, but we
+     * want to make sure we don't use too much memory on low end devices, so that we don't force
+     * other background process to be evicted.
+     */
+    private static int getMaxSizeHardCap() {
+      int maxMemory = (int) Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
+      maxMemory = Math.min(maxMemory / 4, 64 * ByteConstants.MB);
+      return maxMemory;
+    }
+
+    public static PoolParams get() {
+      return new PoolParams(
+          MAX_SIZE_SOFT_CAP,
+          getMaxSizeHardCap(),
+          DEFAULT_BUCKETS,
+          0,
+          2 * ByteConstants.MB,
+//                    Integer.MAX_VALUE,
+          PoolParams.IGNORE_THREADS
+      );
+    }
+  }
+}
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/config/DelegateSSLSocket.java b/samples/optimizeconfig/src/main/java/com/facebook/config/DelegateSSLSocket.java
new file mode 100644
index 000000000..51d5c5c67
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/config/DelegateSSLSocket.java
@@ -0,0 +1,327 @@
+package com.facebook.config;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.InetAddress;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.nio.channels.SocketChannel;
+import javax.net.ssl.HandshakeCompletedListener;
+import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocket;
+
+public class DelegateSSLSocket extends SSLSocket {
+
+  protected final SSLSocket delegate;
+
+  public DelegateSSLSocket(SSLSocket delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public String[] getSupportedCipherSuites() {
+    return delegate.getSupportedCipherSuites();
+  }
+
+  @Override
+  public String[] getEnabledCipherSuites() {
+    return delegate.getEnabledCipherSuites();
+  }
+
+  @Override
+  public void setEnabledCipherSuites(String[] suites) {
+    delegate.setEnabledCipherSuites(suites);
+  }
+
+  @Override
+  public String[] getSupportedProtocols() {
+    return delegate.getSupportedProtocols();
+  }
+
+  @Override
+  public String[] getEnabledProtocols() {
+    return delegate.getEnabledProtocols();
+  }
+
+  @Override
+  public void setEnabledProtocols(String[] protocols) {
+    delegate.setEnabledProtocols(protocols);
+  }
+
+  @Override
+  public SSLSession getSession() {
+    return delegate.getSession();
+  }
+
+  @Override
+  public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
+    delegate.addHandshakeCompletedListener(listener);
+  }
+
+  @Override
+  public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
+    delegate.removeHandshakeCompletedListener(listener);
+  }
+
+  @Override
+  public void startHandshake() throws IOException {
+    delegate.startHandshake();
+  }
+
+  @Override
+  public boolean getUseClientMode() {
+    return delegate.getUseClientMode();
+  }
+
+  @Override
+  public void setUseClientMode(boolean mode) {
+    delegate.setUseClientMode(mode);
+  }
+
+  @Override
+  public boolean getNeedClientAuth() {
+    return delegate.getNeedClientAuth();
+  }
+
+  @Override
+  public void setNeedClientAuth(boolean need) {
+    delegate.setNeedClientAuth(need);
+  }
+
+  @Override
+  public boolean getWantClientAuth() {
+    return delegate.getWantClientAuth();
+  }
+
+  @Override
+  public void setWantClientAuth(boolean want) {
+    delegate.setWantClientAuth(want);
+  }
+
+  @Override
+  public boolean getEnableSessionCreation() {
+    return delegate.getEnableSessionCreation();
+  }
+
+  @Override
+  public void setEnableSessionCreation(boolean flag) {
+    delegate.setEnableSessionCreation(flag);
+  }
+
+  @Override
+  public void bind(SocketAddress localAddr) throws IOException {
+    delegate.bind(localAddr);
+  }
+
+  @Override
+  public synchronized void close() throws IOException {
+    delegate.close();
+  }
+
+  @Override
+  public void connect(SocketAddress remoteAddr) throws IOException {
+    delegate.connect(remoteAddr);
+  }
+
+  @Override
+  public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
+    delegate.connect(remoteAddr, timeout);
+  }
+
+  @Override
+  public SocketChannel getChannel() {
+    return delegate.getChannel();
+  }
+
+  @Override
+  public InetAddress getInetAddress() {
+    return delegate.getInetAddress();
+  }
+
+  @Override
+  public InputStream getInputStream() throws IOException {
+    return delegate.getInputStream();
+  }
+
+  @Override
+  public boolean getKeepAlive() throws SocketException {
+    return delegate.getKeepAlive();
+  }
+
+  @Override
+  public void setKeepAlive(boolean keepAlive) throws SocketException {
+    delegate.setKeepAlive(keepAlive);
+  }
+
+  @Override
+  public InetAddress getLocalAddress() {
+    return delegate.getLocalAddress();
+  }
+
+  @Override
+  public int getLocalPort() {
+    return delegate.getLocalPort();
+  }
+
+  @Override
+  public SocketAddress getLocalSocketAddress() {
+    return delegate.getLocalSocketAddress();
+  }
+
+  @Override
+  public boolean getOOBInline() throws SocketException {
+    return delegate.getOOBInline();
+  }
+
+  @Override
+  public void setOOBInline(boolean oobinline) throws SocketException {
+    delegate.setOOBInline(oobinline);
+  }
+
+  @Override
+  public OutputStream getOutputStream() throws IOException {
+    return delegate.getOutputStream();
+  }
+
+  @Override
+  public int getPort() {
+    return delegate.getPort();
+  }
+
+  @Override
+  public synchronized int getReceiveBufferSize() throws SocketException {
+    return delegate.getReceiveBufferSize();
+  }
+
+  @Override
+  public synchronized void setReceiveBufferSize(int size) throws SocketException {
+    delegate.setReceiveBufferSize(size);
+  }
+
+  @Override
+  public SocketAddress getRemoteSocketAddress() {
+    return delegate.getRemoteSocketAddress();
+  }
+
+  @Override
+  public boolean getReuseAddress() throws SocketException {
+    return delegate.getReuseAddress();
+  }
+
+  @Override
+  public void setReuseAddress(boolean reuse) throws SocketException {
+    delegate.setReuseAddress(reuse);
+  }
+
+  @Override
+  public synchronized int getSendBufferSize() throws SocketException {
+    return delegate.getSendBufferSize();
+  }
+
+  @Override
+  public synchronized void setSendBufferSize(int size) throws SocketException {
+    delegate.setSendBufferSize(size);
+  }
+
+  @Override
+  public int getSoLinger() throws SocketException {
+    return delegate.getSoLinger();
+  }
+
+  @Override
+  public synchronized int getSoTimeout() throws SocketException {
+    return delegate.getSoTimeout();
+  }
+
+  @Override
+  public synchronized void setSoTimeout(int timeout) throws SocketException {
+    delegate.setSoTimeout(timeout);
+  }
+
+  @Override
+  public boolean getTcpNoDelay() throws SocketException {
+    return delegate.getTcpNoDelay();
+  }
+
+  @Override
+  public void setTcpNoDelay(boolean on) throws SocketException {
+    delegate.setTcpNoDelay(on);
+  }
+
+  @Override
+  public int getTrafficClass() throws SocketException {
+    return delegate.getTrafficClass();
+  }
+
+  @Override
+  public void setTrafficClass(int value) throws SocketException {
+    delegate.setTrafficClass(value);
+  }
+
+  @Override
+  public boolean isBound() {
+    return delegate.isBound();
+  }
+
+  @Override
+  public boolean isClosed() {
+    return delegate.isClosed();
+  }
+
+  @Override
+  public boolean isConnected() {
+    return delegate.isConnected();
+  }
+
+  @Override
+  public boolean isInputShutdown() {
+    return delegate.isInputShutdown();
+  }
+
+  @Override
+  public boolean isOutputShutdown() {
+    return delegate.isOutputShutdown();
+  }
+
+  @Override
+  public void sendUrgentData(int value) throws IOException {
+    delegate.sendUrgentData(value);
+  }
+
+  @Override
+  public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
+    delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
+  }
+
+  @Override
+  public void setSoLinger(boolean on, int timeout) throws SocketException {
+    delegate.setSoLinger(on, timeout);
+  }
+
+  @Override
+  public void setSSLParameters(SSLParameters p) {
+    delegate.setSSLParameters(p);
+  }
+
+  @Override
+  public void shutdownInput() throws IOException {
+    delegate.shutdownInput();
+  }
+
+  @Override
+  public void shutdownOutput() throws IOException {
+    delegate.shutdownOutput();
+  }
+
+  @Override
+  public String toString() {
+    return delegate.toString();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return delegate.equals(o);
+  }
+}
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/config/HttpsConnectionUtil.java b/samples/optimizeconfig/src/main/java/com/facebook/config/HttpsConnectionUtil.java
new file mode 100644
index 000000000..45d74598d
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/config/HttpsConnectionUtil.java
@@ -0,0 +1,108 @@
+package com.facebook.config;
+
+import android.os.Build;
+import java.security.GeneralSecurityException;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * Created on 28/03/2017.
+ */
+
+public final class HttpsConnectionUtil {
+
+  private static HostnameVerifier sHostnameVerifier;
+  private static SSLContext sSSLContext;
+  private static X509TrustManager sX509TrustManager;
+
+  static {
+    sHostnameVerifier = new AllTrustHostnameVerifier();
+    try {
+      sSSLContext = SSLContext.getInstance("TLS");
+      sX509TrustManager = new AllTrustX509TrustManager();
+      sSSLContext.init(null, new TrustManager[]{sX509TrustManager}, null);
+    } catch (GeneralSecurityException gse) {
+      gse.printStackTrace();
+    }
+  }
+
+  public static HostnameVerifier getHostnameVerifier() {
+    return sHostnameVerifier;
+  }
+
+  public static X509TrustManager getX509TrustManager() {
+    return sX509TrustManager;
+  }
+
+  public static void setAllTrust() {
+    trustAllHostnames();
+    trustAllHttpsCertificates();
+  }
+
+  public static void setAllTrust(HttpsURLConnection httpsURLConnection) {
+    if (httpsURLConnection == null) {
+      return;
+    }
+    httpsURLConnection.setHostnameVerifier(sHostnameVerifier);
+    httpsURLConnection.setSSLSocketFactory(getSslSocketFactory());
+  }
+
+  public static SSLSocketFactory getSslSocketFactory() {
+    return Build.VERSION.SDK_INT <= 19 ? new TLSSocketFactory(sSSLContext.getSocketFactory())
+        : sSSLContext.getSocketFactory();
+  }
+
+  /**
+   * Set the default Hostname Verifier to an instance of a fake class that
+   * trust all hostnames.
+   */
+  private static void trustAllHostnames() {
+    HttpsURLConnection.setDefaultHostnameVerifier(sHostnameVerifier);
+  }
+
+  /**
+   * Set the default X509 Trust Manager to an instance of a fake class that
+   * trust all certificates, even the self-signed ones.
+   */
+  private static void trustAllHttpsCertificates() {
+    if (sSSLContext != null) {
+      HttpsURLConnection.setDefaultSSLSocketFactory(getSslSocketFactory());
+    }
+  }
+
+  private static class AllTrustHostnameVerifier implements HostnameVerifier {
+
+    @Override
+    public boolean verify(String hostname, SSLSession session) {
+      return true;
+    }
+  }
+
+  private static class AllTrustX509TrustManager implements X509TrustManager {
+
+    @Override
+    public void checkClientTrusted(X509Certificate[] chain, String authType)
+        throws CertificateException {
+      // do nothing
+    }
+
+    @Override
+    public void checkServerTrusted(X509Certificate[] chain, String authType)
+        throws CertificateException {
+      // do nothing
+    }
+
+    @Override
+    public X509Certificate[] getAcceptedIssuers() {
+      return new X509Certificate[0];
+    }
+
+  }
+}
\ No newline at end of file
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/config/ImagePipelineConfigUtils.java b/samples/optimizeconfig/src/main/java/com/facebook/config/ImagePipelineConfigUtils.java
new file mode 100644
index 000000000..974967922
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/config/ImagePipelineConfigUtils.java
@@ -0,0 +1,178 @@
+package com.facebook.config;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.os.Build;
+import android.os.Environment;
+import com.facebook.cache.disk.DiskCacheConfig;
+import com.facebook.common.disk.NoOpDiskTrimmableRegistry;
+import com.facebook.common.memory.MemoryTrimType;
+import com.facebook.common.memory.MemoryTrimmable;
+import com.facebook.common.memory.MemoryTrimmableRegistry;
+import com.facebook.common.util.ByteConstants;
+import com.facebook.imagepipeline.core.ImagePipelineConfig;
+import com.facebook.imagepipeline.core.ImagePipelineFactory;
+import com.facebook.imagepipeline.listener.BaseRequestListener;
+import com.facebook.imagepipeline.listener.RequestListener;
+import com.facebook.imagepipeline.producers.NetworkFetchProducer;
+import com.facebook.imagepipeline.request.ImageRequest;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.WeakHashMap;
+import okhttp3.OkHttpClient;
+
+public class ImagePipelineConfigUtils {
+
+  public static final String IMAGE_PIPELINE_CACHE_DIR = "image_cache";
+  //分配的可用内存
+  private static final int MAX_HEAP_SIZE = (int) Runtime.getRuntime().maxMemory();
+  //使用的缓存数量
+  private static final int MAX_MEMORY_CACHE_SIZE = MAX_HEAP_SIZE / 8;
+  //默认图极低磁盘空间缓存的最大值
+  private static final int MAX_DISK_CACHE_VERYLOW_SIZE = 20 * ByteConstants.MB;
+  //默认图低磁盘空间缓存的最大值
+  private static final int MAX_DISK_CACHE_LOW_SIZE = 60 * ByteConstants.MB;
+  //默认图磁盘缓存的最大值
+  private static final int MAX_DISK_CACHE_SIZE = 100 * ByteConstants.MB;
+
+  private static MyMemoryTrimmableRegistry sMemoryTrimmableRegistry;
+
+  public static ImagePipelineConfig getDefaultImagePipelineConfig(final Context context) {
+
+    //默认图片的磁盘配置
+    DiskCacheConfig diskCacheConfig = DiskCacheConfig
+        .newBuilder(context)
+        .setBaseDirectoryPath(Environment.getExternalStorageDirectory().getAbsoluteFile())//缓存图片基路径
+        .setBaseDirectoryPath(context.getExternalCacheDir()) //文件目录
+        .setBaseDirectoryName(IMAGE_PIPELINE_CACHE_DIR)//文件夹名
+        .setMaxCacheSize(MAX_DISK_CACHE_SIZE)//默认缓存的最大大小。
+        .setMaxCacheSizeOnLowDiskSpace(MAX_DISK_CACHE_LOW_SIZE)//缓存的最大大小,使用设备时低磁盘空间。
+        .setMaxCacheSizeOnVeryLowDiskSpace(MAX_DISK_CACHE_VERYLOW_SIZE)//缓存的最大大小,当设备极低磁盘空间
+        .setDiskTrimmableRegistry(NoOpDiskTrimmableRegistry.getInstance())
+        .build();
+
+    final Context appContext = context.getApplicationContext();
+    RequestListener requestListener = new BaseRequestListener() {
+      @Override
+      public void onRequestFailure(
+          ImageRequest request,
+          String requestId,
+          Throwable throwable,
+          boolean isPrefetch) {
+        if (throwable instanceof IOException) {
+          try {
+            //TODO 图片加载错误上报
+          } catch (Throwable e) {
+          }
+        }
+      }
+
+      @Override
+      public void onProducerFinishWithFailure(
+          String requestId,
+          String producerName,
+          Throwable t,
+          Map<String, String> extraMap) {
+        if (NetworkFetchProducer.PRODUCER_NAME.equals(producerName)) {
+          //TODO 网络图片加载错误上报
+          if (t instanceof IOException) {
+          }
+        }
+      }
+    };
+
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        //dns 配置
+        .dns(new OkHttpDns())
+        //SSL 配置，忽略证书
+        .sslSocketFactory(
+            HttpsConnectionUtil.getSslSocketFactory(),
+            HttpsConnectionUtil.getX509TrustManager())
+        .hostnameVerifier(HttpsConnectionUtil.getHostnameVerifier())
+        .build();
+
+    Set<RequestListener> requestListeners = new HashSet<RequestListener>(1);
+    requestListeners.add(requestListener);
+    ActivityManager activityManager =
+        (ActivityManager) appContext.getSystemService(Context.ACTIVITY_SERVICE);
+    //缓存图片配置
+    ImagePipelineConfig.Builder configBuilder = ImagePipelineConfig.newBuilder(context)
+        .setBitmapsConfig(Bitmap.Config.ARGB_8888)
+        //OKhttp
+        .setNetworkFetcher(new OkHttpNetworkFetcher(okHttpClient))
+        //关键1
+        .setBitmapMemoryCacheParamsSupplier(new CustomBitmapMemoryCacheParamsSupplier(
+            activityManager))
+        //关键2
+        .setEncodedMemoryCacheParamsSupplier(new CustomBitmapMemoryCacheParamsSupplier(
+            activityManager))
+        //关键3
+        .setPoolFactory(CustomPoolFactory.getPoolFactory())
+        .setMainDiskCacheConfig(diskCacheConfig)
+        .setRequestListeners(requestListeners)
+        .setResizeAndRotateEnabledForNetwork(true);
+    // http://frescolib.org/docs/resizing-rotating.html#resizing bug on Android 4.4 (KitKat)
+    if (Build.VERSION.SDK_INT != 19) {
+      configBuilder.setDownsampleEnabled(true);
+    }
+
+    sMemoryTrimmableRegistry = new MyMemoryTrimmableRegistry();
+    sMemoryTrimmableRegistry.registerMemoryTrimmable(new MemoryTrimmable() {
+      @Override
+      public void trim(MemoryTrimType trimType) {
+        final double suggestedTrimRatio = trimType.getSuggestedTrimRatio();
+        if (MemoryTrimType.OnCloseToDalvikHeapLimit.getSuggestedTrimRatio() == suggestedTrimRatio
+            || MemoryTrimType.OnSystemLowMemoryWhileAppInBackground.getSuggestedTrimRatio()
+            == suggestedTrimRatio
+            || MemoryTrimType.OnSystemLowMemoryWhileAppInForeground.getSuggestedTrimRatio()
+            == suggestedTrimRatio
+        ) {
+          ImagePipelineFactory.getInstance().getImagePipeline().clearMemoryCaches();
+        }
+      }
+    });
+    configBuilder.setMemoryTrimmableRegistry(sMemoryTrimmableRegistry);
+
+    return configBuilder.build();
+  }
+
+  /**
+   * {@link android.content.ComponentCallbacks2}
+   */
+  public static void onTrimMemory(int level) {
+    if (sMemoryTrimmableRegistry != null) {
+      sMemoryTrimmableRegistry.trim(level);
+    }
+  }
+
+  public static class MyMemoryTrimmableRegistry implements MemoryTrimmableRegistry {
+
+    private final Set<MemoryTrimmable> sTrimmables =
+        Collections.newSetFromMap(new WeakHashMap<MemoryTrimmable, Boolean>());
+
+    @Override
+    public void registerMemoryTrimmable(MemoryTrimmable trimmable) {
+      sTrimmables.add(trimmable);
+    }
+
+    @Override
+    public void unregisterMemoryTrimmable(MemoryTrimmable trimmable) {
+      sTrimmables.remove(trimmable);
+    }
+
+    /**
+     * {@link android.content.ComponentCallbacks2}
+     */
+    void trim(int level) {
+      for (MemoryTrimmable trimmable : sTrimmables) {
+        if (trimmable != null) {
+          trimmable.trim(MemoryTrimType.OnCloseToDalvikHeapLimit);
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/config/NoSSLv3SocketFactory.java b/samples/optimizeconfig/src/main/java/com/facebook/config/NoSSLv3SocketFactory.java
new file mode 100644
index 000000000..45a1bd625
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/config/NoSSLv3SocketFactory.java
@@ -0,0 +1,104 @@
+package com.facebook.config;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * An {@link SSLSocket} that doesn't allow {@code SSLv3} only connections
+ * <p>fixes https://github.com/koush/ion/issues/386</p>
+ * <p>Android bug report: https://code.google.com/p/android/issues/detail?id=78187</p>
+ * Copy Volley
+ */
+public class NoSSLv3SocketFactory extends SSLSocketFactory {
+
+  private final SSLSocketFactory delegate;
+
+  public NoSSLv3SocketFactory() {
+    this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();
+  }
+
+  public NoSSLv3SocketFactory(SSLSocketFactory delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public String[] getDefaultCipherSuites() {
+    return delegate.getDefaultCipherSuites();
+  }
+
+  @Override
+  public String[] getSupportedCipherSuites() {
+    return delegate.getSupportedCipherSuites();
+  }
+
+  private Socket makeSocketSafe(Socket socket) {
+    if (socket instanceof SSLSocket) {
+      socket = new NoSSLv3SSLSocket((SSLSocket) socket);
+    }
+    return socket;
+  }
+
+  @Override
+  public Socket createSocket(Socket s, String host, int port, boolean autoClose)
+      throws IOException {
+    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
+  }
+
+  @Override
+  public Socket createSocket(String host, int port) throws IOException {
+    return makeSocketSafe(delegate.createSocket(host, port));
+  }
+
+  @Override
+  public Socket createSocket(String host, int port, InetAddress localHost, int localPort)
+      throws IOException {
+    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
+  }
+
+  @Override
+  public Socket createSocket(InetAddress host, int port) throws IOException {
+    return makeSocketSafe(delegate.createSocket(host, port));
+  }
+
+  @Override
+  public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort)
+      throws IOException {
+    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
+  }
+
+  private static class NoSSLv3SSLSocket extends DelegateSSLSocket {
+
+    private NoSSLv3SSLSocket(SSLSocket delegate) {
+      super(delegate);
+
+    }
+
+    @Override
+    public void setEnabledProtocols(String[] protocols) {
+      if (protocols != null && protocols.length == 1 && "SSLv3".equals(protocols[0])) {
+        // see issue https://code.google.com/p/android/issues/detail?id=78187
+        List<String> enabledProtocols =
+            new ArrayList<String>(Arrays.asList(delegate.getEnabledProtocols()));
+        if (enabledProtocols.size() > 1) {
+          enabledProtocols.remove("SSLv3");
+          System.out.println("Removed SSLv3 from enabled protocols");
+        } else {
+          System.out
+              .println("SSL stuck with protocol available for " + String.valueOf(enabledProtocols));
+        }
+        protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
+      }
+
+      super.setEnabledProtocols(protocols);
+
+    }
+
+  }
+}
\ No newline at end of file
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/config/OkHttpDns.java b/samples/optimizeconfig/src/main/java/com/facebook/config/OkHttpDns.java
new file mode 100644
index 000000000..b97471fc3
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/config/OkHttpDns.java
@@ -0,0 +1,30 @@
+package com.facebook.config;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.List;
+import okhttp3.Dns;
+
+/**
+ * Created on 10/07/2017.
+ */
+
+public class OkHttpDns implements Dns {
+
+  @Override
+  public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    try {
+      //TODO return custom http dns ip
+    } catch (Throwable throwable) {
+      throwable.printStackTrace();
+    }
+    List<InetAddress> list = SYSTEM.lookup(hostname);
+    String ip = null;
+    if (list.size() > 0) {
+      ip = list.get(0).getHostAddress();
+    }
+    // return system ip
+    return list;
+  }
+
+}
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/config/OkHttpNetworkFetcher.java b/samples/optimizeconfig/src/main/java/com/facebook/config/OkHttpNetworkFetcher.java
new file mode 100644
index 000000000..9323de8b7
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/config/OkHttpNetworkFetcher.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the root directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ */
+
+package com.facebook.config;
+
+import android.net.Uri;
+import android.os.Looper;
+import android.os.SystemClock;
+import com.facebook.common.logging.FLog;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.producers.BaseNetworkFetcher;
+import com.facebook.imagepipeline.producers.BaseProducerContextCallbacks;
+import com.facebook.imagepipeline.producers.Consumer;
+import com.facebook.imagepipeline.producers.FetchState;
+import com.facebook.imagepipeline.producers.ProducerContext;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import okhttp3.CacheControl;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+//import com.facebook.imagepipeline.common.BytesRange;
+
+/**
+ * Network fetcher that uses OkHttp 3 as a backend.
+ * 暂时不支持BytesRange，升级版本后才能支持
+ */
+public class OkHttpNetworkFetcher extends
+    BaseNetworkFetcher<OkHttpNetworkFetcher.OkHttpNetworkFetchState> {
+
+  private static final String TAG = "OkHttpNetworkFetchProducer";
+  private static final String QUEUE_TIME = "queue_time";
+  private static final String FETCH_TIME = "fetch_time";
+  private static final String TOTAL_TIME = "total_time";
+  private static final String IMAGE_SIZE = "image_size";
+  private final Call.Factory mCallFactory;
+  private Executor mCancellationExecutor;
+
+  /**
+   * @param okHttpClient client to use
+   */
+  public OkHttpNetworkFetcher(OkHttpClient okHttpClient) {
+    this(okHttpClient, okHttpClient.dispatcher().executorService());
+  }
+
+  /**
+   * @param callFactory custom {@link Call.Factory} for fetching image from the network
+   * @param cancellationExecutor executor on which fetching cancellation is performed if
+   * cancellation is requested from the UI Thread
+   */
+  public OkHttpNetworkFetcher(Call.Factory callFactory, Executor cancellationExecutor) {
+    mCallFactory = callFactory;
+    mCancellationExecutor = cancellationExecutor;
+  }
+
+  @Override
+  public OkHttpNetworkFetchState createFetchState(
+      Consumer<EncodedImage> consumer,
+      ProducerContext context) {
+    return new OkHttpNetworkFetchState(consumer, context);
+  }
+
+  @Override
+  public void fetch(final OkHttpNetworkFetchState fetchState, final Callback callback) {
+    fetchState.submitTime = SystemClock.elapsedRealtime();
+    final Uri uri = fetchState.getUri();
+
+    try {
+      final Request.Builder requestBuilder = new Request.Builder()
+          .cacheControl(new CacheControl.Builder().noStore().build())
+          .url(uri.toString())
+          .get();
+
+//      final BytesRange bytesRange = fetchState.getContext().getImageRequest().getBytesRange();
+//      if (bytesRange != null) {
+//        requestBuilder.addHeader("Range", bytesRange.toHttpRangeHeaderValue());
+//      }
+
+      fetchWithRequest(fetchState, callback, requestBuilder.build());
+    } catch (Exception e) {
+      // handle error while creating the request
+      callback.onFailure(e);
+    }
+  }
+
+  @Override
+  public void onFetchCompletion(OkHttpNetworkFetchState fetchState, int byteSize) {
+    fetchState.fetchCompleteTime = SystemClock.elapsedRealtime();
+  }
+
+  @Override
+  public Map<String, String> getExtraMap(OkHttpNetworkFetchState fetchState, int byteSize) {
+    Map<String, String> extraMap = new HashMap<String, String>(4);
+    extraMap.put(QUEUE_TIME, Long.toString(fetchState.responseTime - fetchState.submitTime));
+    extraMap.put(FETCH_TIME, Long.toString(fetchState.fetchCompleteTime - fetchState.responseTime));
+    extraMap.put(TOTAL_TIME, Long.toString(fetchState.fetchCompleteTime - fetchState.submitTime));
+    extraMap.put(IMAGE_SIZE, Integer.toString(byteSize));
+    return extraMap;
+  }
+
+  protected void fetchWithRequest(
+      final OkHttpNetworkFetchState fetchState,
+      final Callback callback,
+      final Request request) {
+    final Call call = mCallFactory.newCall(request);
+
+    fetchState.getContext().addCallbacks(
+        new BaseProducerContextCallbacks() {
+          @Override
+          public void onCancellationRequested() {
+            if (Looper.myLooper() != Looper.getMainLooper()) {
+              call.cancel();
+            } else {
+              mCancellationExecutor.execute(new Runnable() {
+                @Override
+                public void run() {
+                  call.cancel();
+                }
+              });
+            }
+          }
+        });
+
+    call.enqueue(
+        new okhttp3.Callback() {
+          @Override
+          public void onResponse(Call call, Response response) throws IOException {
+            fetchState.responseTime = SystemClock.elapsedRealtime();
+            final ResponseBody body = response.body();
+            try {
+              if (!response.isSuccessful()) {
+                handleException(
+                    call,
+                    new IOException("Unexpected HTTP code " + response),
+                    callback);
+                return;
+              }
+              long contentLength = body.contentLength();
+              if (contentLength < 0) {
+                contentLength = 0;
+              }
+              callback.onResponse(body.byteStream(), (int) contentLength);
+            } catch (Exception e) {
+              handleException(call, e, callback);
+            } finally {
+              try {
+                body.close();
+              } catch (Exception e) {
+                FLog.w(TAG, "Exception when closing response body", e);
+              }
+            }
+          }
+
+          @Override
+          public void onFailure(Call call, IOException e) {
+            handleException(call, e, callback);
+          }
+        });
+  }
+
+  /**
+   * Handles exceptions.
+   *
+   * <p> OkHttp notifies callers of cancellations via an IOException. If IOException is caught
+   * after request cancellation, then the exception is interpreted as successful cancellation
+   * and onCancellation is called. Otherwise onFailure is called.
+   */
+  private void handleException(final Call call, final Exception e, final Callback callback) {
+    if (call.isCanceled()) {
+      callback.onCancellation();
+    } else {
+      callback.onFailure(e);
+    }
+  }
+
+  public static class OkHttpNetworkFetchState extends FetchState {
+
+    public long submitTime;
+    public long responseTime;
+    public long fetchCompleteTime;
+
+    public OkHttpNetworkFetchState(
+        Consumer<EncodedImage> consumer,
+        ProducerContext producerContext) {
+      super(consumer, producerContext);
+    }
+  }
+}
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/config/TLSSocketFactory.java b/samples/optimizeconfig/src/main/java/com/facebook/config/TLSSocketFactory.java
new file mode 100644
index 000000000..32f816036
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/config/TLSSocketFactory.java
@@ -0,0 +1,91 @@
+package com.facebook.config;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * Created on 01/06/2017.
+ */
+
+public class TLSSocketFactory extends SSLSocketFactory {
+
+  private final SSLSocketFactory delegate;
+  private String[] enableProtocols;
+
+  public TLSSocketFactory() {
+    this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();
+  }
+
+  public TLSSocketFactory(SSLSocketFactory delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public String[] getDefaultCipherSuites() {
+    return delegate.getDefaultCipherSuites();
+  }
+
+  @Override
+  public String[] getSupportedCipherSuites() {
+    return delegate.getDefaultCipherSuites();
+  }
+
+  private Socket enableTLS(Socket socket) {
+    if (socket instanceof SSLSocket) {
+      SSLSocket sslSocket = (SSLSocket) socket;
+      if (enableProtocols == null) {
+        String[] supported = sslSocket.getSupportedProtocols();
+        List<String> newEnable = new ArrayList<String>();
+        for (String tmp : supported) {
+          if (!tmp.toLowerCase().contains("ssl")) {
+            newEnable.add(tmp);
+          }
+        }
+        //Not only ssl
+        if (newEnable.size() > 0) {
+          enableProtocols = newEnable.toArray(new String[newEnable.size()]);
+        }
+      }
+      if (enableProtocols != null) {
+        sslSocket.setEnabledProtocols(enableProtocols);
+      }
+      return sslSocket;
+    }
+    return socket;
+  }
+
+  @Override
+  public Socket createSocket(Socket s, String host, int port, boolean autoClose)
+      throws IOException {
+    return enableTLS(delegate.createSocket(s, host, port, autoClose));
+  }
+
+  @Override
+  public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
+    return enableTLS(delegate.createSocket(host, port));
+  }
+
+  @Override
+  public Socket createSocket(String host, int port, InetAddress localHost, int localPort)
+      throws IOException, UnknownHostException {
+    return enableTLS(delegate.createSocket(host, port, localHost, localPort));
+  }
+
+  @Override
+  public Socket createSocket(InetAddress host, int port) throws IOException {
+    return enableTLS(delegate.createSocket(host, port));
+  }
+
+  @Override
+  public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort)
+      throws IOException {
+    return enableTLS(delegate.createSocket(address, port, localAddress, localPort));
+  }
+}
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/samples/optimizeconfig/MainActivity.java b/samples/optimizeconfig/src/main/java/com/facebook/samples/optimizeconfig/MainActivity.java
new file mode 100644
index 000000000..7ebbba864
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/samples/optimizeconfig/MainActivity.java
@@ -0,0 +1,26 @@
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.facebook.samples.optimizeconfig;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+public class MainActivity extends Activity {
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+    //TODO 完善图片加载
+  }
+}
diff --git a/samples/optimizeconfig/src/main/java/com/facebook/samples/optimizeconfig/OptimizeConfigApplication.java b/samples/optimizeconfig/src/main/java/com/facebook/samples/optimizeconfig/OptimizeConfigApplication.java
new file mode 100644
index 000000000..abc244f79
--- /dev/null
+++ b/samples/optimizeconfig/src/main/java/com/facebook/samples/optimizeconfig/OptimizeConfigApplication.java
@@ -0,0 +1,64 @@
+/*
+ * This file provided by Facebook is for non-commercial testing and evaluation
+ * purposes only.  Facebook reserves all rights not expressly granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+package com.facebook.samples.optimizeconfig;
+
+import android.app.Application;
+import android.content.Context;
+import com.facebook.common.logging.FLog;
+import com.facebook.config.ImagePipelineConfigUtils;
+import com.facebook.drawee.backends.pipeline.Fresco;
+import com.facebook.imagepipeline.core.ImagePipelineConfig;
+
+/**
+ * Optimize Config Application implementation where we set up Fresco
+ */
+public class OptimizeConfigApplication extends Application {
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    init(this);
+  }
+
+  private void init(Context context) {
+    if (context == null) {
+      throw new IllegalArgumentException("context cannot be null.");
+    }
+    Context appContext = context.getApplicationContext();
+    ImagePipelineConfig config = ImagePipelineConfigUtils.getDefaultImagePipelineConfig(appContext);
+    Fresco.initialize(appContext, config);
+    if (BuildConfig.DEBUG) {
+      FLog.setMinimumLoggingLevel(FLog.INFO);
+    } else {
+      FLog.setMinimumLoggingLevel(FLog.ERROR);
+    }
+  }
+
+  @Override
+  public void onLowMemory() {
+    super.onLowMemory();
+    try {
+      Fresco.getImagePipeline().clearMemoryCaches();
+    } catch (Throwable t) {
+    }
+  }
+
+  @Override
+  public void onTrimMemory(int level) {
+    super.onTrimMemory(level);
+    try {
+      ImagePipelineConfigUtils.onTrimMemory(level);
+    } catch (Throwable t) {
+
+    }
+  }
+}
diff --git a/samples/optimizeconfig/src/main/res/layout/activity_main.xml b/samples/optimizeconfig/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..e65a7c5f3
--- /dev/null
+++ b/samples/optimizeconfig/src/main/res/layout/activity_main.xml
@@ -0,0 +1,17 @@
+<LinearLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent"
+  android:baselineAligned="false"
+  android:orientation="horizontal"
+  tools:context=".MainActivity"
+  >
+  <androidx.viewpager.widget.ViewPager
+      android:id="@+id/pager"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      >
+
+  </androidx.viewpager.widget.ViewPager>
+</LinearLayout>
diff --git a/samples/optimizeconfig/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/optimizeconfig/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..b3fd7c9c0
Binary files /dev/null and b/samples/optimizeconfig/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/optimizeconfig/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/optimizeconfig/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..f97029d7a
Binary files /dev/null and b/samples/optimizeconfig/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/optimizeconfig/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/optimizeconfig/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..69f968ef4
Binary files /dev/null and b/samples/optimizeconfig/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/optimizeconfig/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/optimizeconfig/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..f0f72126f
Binary files /dev/null and b/samples/optimizeconfig/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/optimizeconfig/src/main/res/values/colors.xml b/samples/optimizeconfig/src/main/res/values/colors.xml
new file mode 100644
index 000000000..80bf2e856
--- /dev/null
+++ b/samples/optimizeconfig/src/main/res/values/colors.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="failure">#ffff3333</color>
+    <color name="transparent">#00000000</color>
+</resources>
diff --git a/samples/optimizeconfig/src/main/res/values/strings.xml b/samples/optimizeconfig/src/main/res/values/strings.xml
new file mode 100644
index 000000000..f702c14f5
--- /dev/null
+++ b/samples/optimizeconfig/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+  <string name="app_name">Fresco Optimize Config Example</string>
+</resources>
diff --git a/samples/optimizeconfig/src/main/res/values/styles.xml b/samples/optimizeconfig/src/main/res/values/styles.xml
new file mode 100644
index 000000000..1768555c7
--- /dev/null
+++ b/samples/optimizeconfig/src/main/res/values/styles.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <style name="sample_layout">
+    <item name="android:layout_width">match_parent</item>
+    <item name="android:layout_height">0dp</item>
+    <item name="android:layout_weight">1</item>
+  </style>
+
+  <style name="drawee">
+    <item name="android:layout_width">match_parent</item>
+    <item name="android:layout_height">match_parent</item>
+    <item name="actualImageScaleType">fitCenter</item>
+    <item name="failureImage">@color/failure</item>
+  </style>
+
+  <style name="label">
+    <item name="android:layout_width">match_parent</item>
+    <item name="android:layout_height">wrap_content</item>
+    <item name="android:layout_gravity">bottom</item>
+    <item name="android:padding">2dp</item>
+    <item name="android:background">#99000000</item>
+    <item name="android:textColor">#cccccc</item>
+    <item name="android:textSize">12sp</item>
+  </style>
+</resources>
diff --git a/settings.gradle b/settings.gradle
index 36a593cac..b1f5258ef 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -26,6 +26,7 @@ include ':samples:scrollperf'
 include ':samples:showcase'
 include ':samples:zoomable'
 include ':samples:zoomableapp'
+include ':samples:optimizeconfig'
 include ':static-webp'
 include ':tools:flipper'
 include ':tools:stetho'
