diff --git a/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeControllerBuilder.java b/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeControllerBuilder.java
index e73391460..601526309 100644
--- a/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeControllerBuilder.java
+++ b/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeControllerBuilder.java
@@ -343,7 +343,7 @@ protected static String generateUniqueControllerId() {
       List<Supplier<DataSource<IMAGE>>> suppliers = new ArrayList<>(2);
       suppliers.add(supplier);
       suppliers.add(getDataSourceSupplierForRequest(controller, controllerId, mLowResImageRequest));
-      supplier = IncreasingQualityDataSourceSupplier.create(suppliers);
+      supplier = IncreasingQualityDataSourceSupplier.create(suppliers, false);
     }
 
     // no image requests; use null data source supplier
diff --git a/fbcore/src/main/java/com/facebook/datasource/IncreasingQualityDataSourceSupplier.java b/fbcore/src/main/java/com/facebook/datasource/IncreasingQualityDataSourceSupplier.java
index c4e14fd5a..cc82d4e37 100644
--- a/fbcore/src/main/java/com/facebook/datasource/IncreasingQualityDataSourceSupplier.java
+++ b/fbcore/src/main/java/com/facebook/datasource/IncreasingQualityDataSourceSupplier.java
@@ -35,21 +35,41 @@
 public class IncreasingQualityDataSourceSupplier<T> implements Supplier<DataSource<T>> {
 
   private final List<Supplier<DataSource<T>>> mDataSourceSuppliers;
+  private final boolean mDataSourceLazy;
 
-  private IncreasingQualityDataSourceSupplier(List<Supplier<DataSource<T>>> dataSourceSuppliers) {
+  private IncreasingQualityDataSourceSupplier(
+      List<Supplier<DataSource<T>>> dataSourceSuppliers, boolean dataSourceLazy) {
     Preconditions.checkArgument(!dataSourceSuppliers.isEmpty(), "List of suppliers is empty!");
     mDataSourceSuppliers = dataSourceSuppliers;
+    mDataSourceLazy = dataSourceLazy;
   }
 
   /**
    * Creates a new data source supplier with increasing-quality strategy.
+   *
    * <p>Note: for performance reasons the list doesn't get cloned, so the caller of this method
    * should not modify the list once passed in here.
+   *
    * @param dataSourceSuppliers list of underlying suppliers
    */
   public static <T> IncreasingQualityDataSourceSupplier<T> create(
       List<Supplier<DataSource<T>>> dataSourceSuppliers) {
-    return new IncreasingQualityDataSourceSupplier<T>(dataSourceSuppliers);
+    return create(dataSourceSuppliers, false);
+  }
+
+  /**
+   * Creates a new data source supplier with increasing-quality strategy with optional lazy state
+   * creation.
+   *
+   * <p>Note: for performance reasons the list doesn't get cloned, so the caller of this method
+   * should not modify the list once passed in here.
+   *
+   * @param dataSourceSuppliers list of underlying suppliers
+   * @param dataSourceLazy if true, the state of data source would be created only if necessary
+   */
+  public static <T> IncreasingQualityDataSourceSupplier<T> create(
+      List<Supplier<DataSource<T>>> dataSourceSuppliers, boolean dataSourceLazy) {
+    return new IncreasingQualityDataSourceSupplier<T>(dataSourceSuppliers, dataSourceLazy);
   }
 
   @Override
@@ -88,24 +108,39 @@ public String toString() {
     private @Nullable ArrayList<DataSource<T>> mDataSources;
     @GuardedBy("IncreasingQualityDataSource.this")
     private int mIndexOfDataSourceWithResult;
-    private final int mNumberOfDataSources;
-    private final AtomicInteger mFinishedDataSources;
+
+    private int mNumberOfDataSources;
+    private AtomicInteger mFinishedDataSources;
     private @Nullable Throwable mDelayedError;
 
     public IncreasingQualityDataSource() {
-      mFinishedDataSources = new AtomicInteger(0);
-      final int n = mDataSourceSuppliers.size();
-      mNumberOfDataSources = n;
-      mIndexOfDataSourceWithResult = n;
-      mDataSources = new ArrayList<>(n);
-      for (int i = 0; i < n; i++) {
-        DataSource<T> dataSource = mDataSourceSuppliers.get(i).get();
-        mDataSources.add(dataSource);
-        dataSource.subscribe(new InternalDataSubscriber(i), CallerThreadExecutor.getInstance());
-        // there's no point in creating data sources of lower quality
-        // if the data source of a higher quality has some result already
-        if (dataSource.hasResult()) {
-          break;
+      if (!mDataSourceLazy) {
+        ensureDataSourceInitialized();
+      }
+    }
+
+    private void ensureDataSourceInitialized() {
+      if (mFinishedDataSources != null) {
+        return;
+      }
+
+      synchronized (IncreasingQualityDataSource.this) {
+        if (mFinishedDataSources == null) {
+          mFinishedDataSources = new AtomicInteger(0);
+          final int n = mDataSourceSuppliers.size();
+          mNumberOfDataSources = n;
+          mIndexOfDataSourceWithResult = n;
+          mDataSources = new ArrayList<>(n);
+          for (int i = 0; i < n; i++) {
+            DataSource<T> dataSource = mDataSourceSuppliers.get(i).get();
+            mDataSources.add(dataSource);
+            dataSource.subscribe(new InternalDataSubscriber(i), CallerThreadExecutor.getInstance());
+            // there's no point in creating data sources of lower quality
+            // if the data source of a higher quality has some result already
+            if (dataSource.hasResult()) {
+              break;
+            }
+          }
         }
       }
     }
@@ -128,18 +163,30 @@ public IncreasingQualityDataSource() {
     @Override
     @Nullable
     public synchronized T getResult() {
+      if (mDataSourceLazy) {
+        ensureDataSourceInitialized();
+      }
+
       DataSource<T> dataSourceWithResult = getDataSourceWithResult();
       return (dataSourceWithResult != null) ? dataSourceWithResult.getResult() : null;
     }
 
     @Override
     public synchronized boolean hasResult() {
+      if (mDataSourceLazy) {
+        ensureDataSourceInitialized();
+      }
+
       DataSource<T> dataSourceWithResult = getDataSourceWithResult();
       return (dataSourceWithResult != null) && dataSourceWithResult.hasResult();
     }
 
     @Override
     public boolean close() {
+      if (mDataSourceLazy) {
+        ensureDataSourceInitialized();
+      }
+
       ArrayList<DataSource<T>> dataSources;
       synchronized (IncreasingQualityDataSource.this) {
         // it's fine to call {@code super.close()} within a synchronized block because we don't
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
index c078ca52c..0b0c59335 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
@@ -61,6 +61,7 @@
   private final ThreadHandoffProducerQueue mThreadHandoffProducerQueue;
   private final Supplier<Boolean> mSuppressBitmapPrefetchingSupplier;
   private AtomicLong mIdCounter;
+  private final Supplier<Boolean> mLazyDataSource;
 
   public ImagePipeline(
       ProducerSequenceFactory producerSequenceFactory,
@@ -72,7 +73,8 @@ public ImagePipeline(
       BufferedDiskCache smallImageBufferedDiskCache,
       CacheKeyFactory cacheKeyFactory,
       ThreadHandoffProducerQueue threadHandoffProducerQueue,
-      Supplier<Boolean> suppressBitmapPrefetchingSupplier) {
+      Supplier<Boolean> suppressBitmapPrefetchingSupplier,
+      Supplier<Boolean> lazyDataSource) {
     mIdCounter = new AtomicLong();
     mProducerSequenceFactory = producerSequenceFactory;
     mRequestListener = new ForwardingRequestListener(requestListeners);
@@ -84,6 +86,7 @@ public ImagePipeline(
     mCacheKeyFactory = cacheKeyFactory;
     mThreadHandoffProducerQueue = threadHandoffProducerQueue;
     mSuppressBitmapPrefetchingSupplier = suppressBitmapPrefetchingSupplier;
+    mLazyDataSource = lazyDataSource;
   }
 
   /**
@@ -662,6 +665,10 @@ public boolean isPaused() {
     return mThreadHandoffProducerQueue.isQueueing();
   }
 
+  public Supplier<Boolean> isLazyDataSource() {
+    return mLazyDataSource;
+  }
+
   /**
    * @return The CacheKeyFactory implementation used by ImagePipeline
    */
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineExperiments.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineExperiments.java
index 231633edd..01ffdb1ce 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineExperiments.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineExperiments.java
@@ -48,6 +48,7 @@
   private final boolean mPartialImageCachingEnabled;
   private final Supplier<Boolean> mSmartResizingEnabled;
   private final ProducerFactoryMethod mProducerFactoryMethod;
+  private final Supplier<Boolean> mLazyDataSource;
 
   private ImagePipelineExperiments(Builder builder) {
     mWebpSupportEnabled = builder.mWebpSupportEnabled;
@@ -78,6 +79,7 @@ public Boolean get() {
     } else {
       mProducerFactoryMethod = builder.mProducerFactoryMethod;
     }
+    mLazyDataSource = builder.mLazyDataSource;
   }
 
   public boolean isExternalCreatedBitmapLogEnabled() {
@@ -141,6 +143,10 @@ public boolean getBitmapPrepareToDrawForPrefetch() {
     return mBitmapPrepareToDrawForPrefetch;
   }
 
+  public Supplier<Boolean> isLazyDataSource() {
+    return mLazyDataSource;
+  }
+
   public static class Builder {
 
     private final ImagePipelineConfig.Builder mConfigBuilder;
@@ -159,6 +165,7 @@ public boolean getBitmapPrepareToDrawForPrefetch() {
     private boolean mPartialImageCachingEnabled = false;
     private Supplier<Boolean> mSmartResizingEnabled = Suppliers.BOOLEAN_FALSE;
     private ProducerFactoryMethod mProducerFactoryMethod;
+    public Supplier<Boolean> mLazyDataSource;
 
     public Builder(ImagePipelineConfig.Builder configBuilder) {
       mConfigBuilder = configBuilder;
@@ -284,6 +291,12 @@ public boolean isPartialImageCachingEnabled() {
       return mConfigBuilder;
     }
 
+    /** Stores an alternative lazy method to instantiate the data souce. */
+    public ImagePipelineConfig.Builder setLazyDataSource(Supplier<Boolean> lazyDataSource) {
+      mLazyDataSource = lazyDataSource;
+      return mConfigBuilder;
+    }
+
     public ImagePipelineExperiments build() {
       return new ImagePipelineExperiments(this);
     }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
index 0c2179527..9c42abdb4 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
@@ -256,7 +256,8 @@ public ImagePipeline getImagePipeline() {
               getSmallImageBufferedDiskCache(),
               mConfig.getCacheKeyFactory(),
               mThreadHandoffProducerQueue,
-              Suppliers.of(false));
+              Suppliers.of(false),
+              mConfig.getExperiments().isLazyDataSource());
     }
     return mImagePipeline;
   }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ImagePipelineTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ImagePipelineTest.java
index 3013853ca..641fb831e 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ImagePipelineTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/core/ImagePipelineTest.java
@@ -63,6 +63,7 @@
 
   private Supplier<Boolean> mPrefetchEnabledSupplier;
   private Supplier<Boolean> mSuppressBitmapPrefetchingSupplier;
+  private Supplier<Boolean> mLazyDataSourceSupplier;
   private ImagePipeline mImagePipeline;
   private MemoryCache<CacheKey, CloseableImage> mBitmapMemoryCache;
   private MemoryCache<CacheKey, PooledByteBuffer> mEncodedMemoryCache;
@@ -77,8 +78,10 @@ public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
     mPrefetchEnabledSupplier = mock(Supplier.class);
     mSuppressBitmapPrefetchingSupplier = mock(Supplier.class);
+    mLazyDataSourceSupplier = mock(Supplier.class);
     when(mPrefetchEnabledSupplier.get()).thenReturn(true);
     when(mSuppressBitmapPrefetchingSupplier.get()).thenReturn(false);
+    when(mLazyDataSourceSupplier.get()).thenReturn(false);
     mRequestListener1 = mock(RequestListener.class);
     mRequestListener2 = mock(RequestListener.class);
     mBitmapMemoryCache = mock(MemoryCache.class);
@@ -86,17 +89,19 @@ public void setUp() throws Exception {
     mMainDiskStorageCache = mock(BufferedDiskCache.class);
     mSmallImageDiskStorageCache = mock(BufferedDiskCache.class);
     mThreadHandoffProducerQueue= mock(ThreadHandoffProducerQueue.class);
-    mImagePipeline = new ImagePipeline(
-        mProducerSequenceFactory,
-        Sets.newHashSet(mRequestListener1, mRequestListener2),
-        mPrefetchEnabledSupplier,
-        mBitmapMemoryCache,
-        mEncodedMemoryCache,
-        mMainDiskStorageCache,
-        mSmallImageDiskStorageCache,
-        mCacheKeyFactory,
-        mThreadHandoffProducerQueue,
-        mSuppressBitmapPrefetchingSupplier);
+    mImagePipeline =
+        new ImagePipeline(
+            mProducerSequenceFactory,
+            Sets.newHashSet(mRequestListener1, mRequestListener2),
+            mPrefetchEnabledSupplier,
+            mBitmapMemoryCache,
+            mEncodedMemoryCache,
+            mMainDiskStorageCache,
+            mSmallImageDiskStorageCache,
+            mCacheKeyFactory,
+            mThreadHandoffProducerQueue,
+            mSuppressBitmapPrefetchingSupplier,
+            mLazyDataSourceSupplier);
 
     when(mImageRequest.getProgressiveRenderingEnabled()).thenReturn(true);
     when(mImageRequest.getPriority()).thenReturn(Priority.HIGH);
