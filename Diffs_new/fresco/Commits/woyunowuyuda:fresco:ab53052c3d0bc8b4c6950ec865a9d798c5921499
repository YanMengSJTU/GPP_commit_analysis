diff --git a/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java b/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java
index 3fffcdb00..28d4c5d0e 100644
--- a/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java
+++ b/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java
@@ -9,22 +9,32 @@
 import static java.lang.annotation.RetentionPolicy.SOURCE;
 
 import android.graphics.Bitmap;
+import android.graphics.BitmapShader;
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
+import android.graphics.Matrix;
 import android.graphics.Paint;
+import android.graphics.Path;
 import android.graphics.Rect;
+import android.graphics.Shader;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.IntDef;
 import android.support.annotation.IntRange;
+import android.util.SparseArray;
+
 import com.facebook.common.logging.FLog;
 import com.facebook.common.references.CloseableReference;
+import com.facebook.drawee.drawable.DrawableUtils;
 import com.facebook.fresco.animation.backend.AnimationBackend;
 import com.facebook.fresco.animation.backend.AnimationBackendDelegateWithInactivityCheck;
 import com.facebook.fresco.animation.backend.AnimationInformation;
 import com.facebook.fresco.animation.bitmap.preparation.BitmapFramePreparationStrategy;
 import com.facebook.fresco.animation.bitmap.preparation.BitmapFramePreparer;
+import com.facebook.fresco.animation.drawable.RoundedAnimationDrawable;
 import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
 import java.lang.annotation.Retention;
+import java.lang.ref.WeakReference;
+
 import javax.annotation.Nullable;
 
 /**
@@ -98,6 +108,10 @@
   @Nullable
   private final BitmapFramePreparer mBitmapFramePreparer;
   private final Paint mPaint;
+  private final Paint mRoundPaint;
+  private final Paint mBorderPaint;
+  private final SparseArray<WeakReference<BitmapShader>> mShaderCache;
+  private int mPreBitmapHashCode;
 
   @Nullable
   private Rect mBounds;
@@ -121,7 +135,11 @@ public BitmapAnimationBackend(
     mBitmapFramePreparationStrategy = bitmapFramePreparationStrategy;
     mBitmapFramePreparer = bitmapFramePreparer;
 
+    mShaderCache = new SparseArray<>(15);
+    mBorderPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    mRoundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
     mPaint = new Paint(Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG);
+    mBorderPaint.setStyle(Paint.Style.STROKE);
     updateBitmapDimensions();
   }
 
@@ -162,7 +180,7 @@ public boolean drawFrame(
       mFrameListener.onDrawFrameStart(this, frameNumber);
     }
 
-    boolean drawn = drawFrameOrFallback(canvas, frameNumber, FRAME_TYPE_CACHED);
+    boolean drawn = drawFrameOrFallback(parent, canvas, frameNumber, FRAME_TYPE_CACHED);
 
     // We could not draw anything
     if (!drawn && mFrameListener != null) {
@@ -181,7 +199,11 @@ public boolean drawFrame(
     return drawn;
   }
 
-  private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType int frameType) {
+  private boolean drawFrameOrFallback(
+          Drawable drawable,
+          Canvas canvas,
+          int frameNumber,
+          @FrameType int frameType) {
     CloseableReference<Bitmap> bitmapReference = null;
     boolean drawn = false;
     int nextFrameType = FRAME_TYPE_UNKNOWN;
@@ -190,7 +212,7 @@ private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType i
       switch (frameType) {
         case FRAME_TYPE_CACHED:
           bitmapReference = mBitmapFrameCache.getCachedFrame(frameNumber);
-          drawn = drawBitmapAndCache(frameNumber, bitmapReference, canvas, FRAME_TYPE_CACHED);
+          drawn = drawBitmapAndCache(drawable, frameNumber, bitmapReference, canvas, FRAME_TYPE_CACHED);
           nextFrameType = FRAME_TYPE_REUSED;
           break;
 
@@ -199,7 +221,7 @@ private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType i
               mBitmapFrameCache.getBitmapToReuseForFrame(frameNumber, mBitmapWidth, mBitmapHeight);
           // Try to render the frame and draw on the canvas immediately after
           drawn = renderFrameInBitmap(frameNumber, bitmapReference) &&
-              drawBitmapAndCache(frameNumber, bitmapReference, canvas, FRAME_TYPE_REUSED);
+              drawBitmapAndCache(drawable, frameNumber, bitmapReference, canvas, FRAME_TYPE_REUSED);
           nextFrameType = FRAME_TYPE_CREATED;
           break;
 
@@ -215,13 +237,13 @@ private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType i
           }
           // Try to render the frame and draw on the canvas immediately after
           drawn = renderFrameInBitmap(frameNumber, bitmapReference) &&
-              drawBitmapAndCache(frameNumber, bitmapReference, canvas, FRAME_TYPE_CREATED);
+              drawBitmapAndCache(drawable, frameNumber, bitmapReference, canvas, FRAME_TYPE_CREATED);
           nextFrameType = FRAME_TYPE_FALLBACK;
           break;
 
         case FRAME_TYPE_FALLBACK:
           bitmapReference = mBitmapFrameCache.getFallbackFrame(frameNumber);
-          drawn = drawBitmapAndCache(frameNumber, bitmapReference, canvas, FRAME_TYPE_FALLBACK);
+          drawn = drawBitmapAndCache(drawable, frameNumber, bitmapReference, canvas, FRAME_TYPE_FALLBACK);
           break;
 
         default:
@@ -234,18 +256,22 @@ private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType i
     if (drawn || nextFrameType == FRAME_TYPE_UNKNOWN) {
       return drawn;
     } else {
-      return drawFrameOrFallback(canvas, frameNumber, nextFrameType);
+      return drawFrameOrFallback(drawable, canvas, frameNumber, nextFrameType);
     }
   }
 
   @Override
   public void setAlpha(@IntRange(from = 0, to = 255) int alpha) {
     mPaint.setAlpha(alpha);
+    mRoundPaint.setAlpha(alpha);
+    mBorderPaint.setAlpha(alpha);
   }
 
   @Override
   public void setColorFilter(@Nullable ColorFilter colorFilter) {
     mPaint.setColorFilter(colorFilter);
+    mRoundPaint.setColorFilter(colorFilter);
+    mBorderPaint.setColorFilter(colorFilter);
   }
 
   @Override
@@ -330,6 +356,7 @@ private boolean renderFrameInBitmap(
    * @return true if the bitmap has been drawn
    */
   private boolean drawBitmapAndCache(
+      Drawable drawable,
       int frameNumber,
       @Nullable CloseableReference<Bitmap> bitmapReference,
       Canvas canvas,
@@ -337,10 +364,10 @@ private boolean drawBitmapAndCache(
     if (!CloseableReference.isValid(bitmapReference)) {
       return false;
     }
-    if (mBounds == null) {
-      canvas.drawBitmap(bitmapReference.get(), 0f, 0f, mPaint);
+    if (drawable instanceof RoundedAnimationDrawable) {
+      drawRoundBitmap((RoundedAnimationDrawable) drawable, canvas, bitmapReference);
     } else {
-      canvas.drawBitmap(bitmapReference.get(), null, mBounds, mPaint);
+      drawNormalBitmap(canvas, bitmapReference);
     }
 
     // Notify the cache that a frame has been rendered.
@@ -357,4 +384,60 @@ private boolean drawBitmapAndCache(
     }
     return true;
   }
+
+  private void drawNormalBitmap(
+          Canvas canvas,
+          CloseableReference<Bitmap> bitmapReference) {
+    if (mBounds == null) {
+      canvas.drawBitmap(bitmapReference.get(), 0f, 0f, mPaint);
+    } else {
+      canvas.drawBitmap(bitmapReference.get(), null, mBounds, mPaint);
+    }
+  }
+
+  private void drawRoundBitmap(
+          RoundedAnimationDrawable drawable,
+          Canvas canvas,
+          CloseableReference<Bitmap> bitmapReference) {
+    if (!drawable.shouldRound()) {
+      drawNormalBitmap(canvas, bitmapReference);
+    } else {
+      drawable.updateTransform();
+      drawable.updatePath();
+      updatePaint(bitmapReference.get(), drawable);
+      int saveCount = canvas.save();
+      canvas.concat(drawable.getInverseParent());
+      canvas.drawPath(drawable.getPath(), mRoundPaint);
+      float borderWidth = drawable.getBorderWidth();
+      if (borderWidth > 0) {
+        int borderColor = drawable.getBorderColor();
+        Path borderPath = drawable.getBorderPath();
+        mBorderPaint.setStrokeWidth(borderWidth);
+        mBorderPaint.setColor(DrawableUtils.multiplyColorAlpha(borderColor, mRoundPaint.getAlpha()));
+        canvas.drawPath(borderPath, mBorderPaint);
+      }
+      canvas.restoreToCount(saveCount);
+    }
+  }
+
+  private void updatePaint(Bitmap bitmap, RoundedAnimationDrawable drawable) {
+    Matrix transform = drawable.getTransform();
+    boolean matrixChanged = drawable.getTransformChanged();
+    int bitmapHashCode = bitmap.hashCode();
+    if (bitmapHashCode != mPreBitmapHashCode) {
+      WeakReference<BitmapShader> shaderReference = mShaderCache.get(bitmapHashCode);
+      if (shaderReference != null && shaderReference.get() != null) {
+        mRoundPaint.setShader(shaderReference.get());
+      } else {
+        BitmapShader shader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
+        mShaderCache.put(bitmapHashCode, new WeakReference<>(shader));
+        mRoundPaint.setShader(shader);
+      }
+      matrixChanged = true;
+      mPreBitmapHashCode = bitmapHashCode;
+    }
+    if (matrixChanged) {
+      mRoundPaint.getShader().setLocalMatrix(transform);
+    }
+  }
 }
diff --git a/animated-drawable/src/main/java/com/facebook/fresco/animation/drawable/AnimatedDrawable2.java b/animated-drawable/src/main/java/com/facebook/fresco/animation/drawable/AnimatedDrawable2.java
index d5a87a329..3425723c9 100644
--- a/animated-drawable/src/main/java/com/facebook/fresco/animation/drawable/AnimatedDrawable2.java
+++ b/animated-drawable/src/main/java/com/facebook/fresco/animation/drawable/AnimatedDrawable2.java
@@ -11,7 +11,6 @@
 import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.graphics.drawable.Animatable;
-import android.graphics.drawable.Drawable;
 import android.os.SystemClock;
 import com.facebook.common.logging.FLog;
 import com.facebook.drawable.base.DrawableWithCaches;
@@ -26,7 +25,7 @@
  * Experimental new animated drawable that uses a supplied
  * {@link AnimationBackend} for drawing frames.
  */
-public class AnimatedDrawable2 extends Drawable implements Animatable, DrawableWithCaches {
+public class AnimatedDrawable2 extends RoundedAnimationDrawable implements Animatable, DrawableWithCaches {
 
   /**
    * {@link #draw(Canvas)} listener that is notified for each draw call. Can be used for debugging.
diff --git a/animated-drawable/src/main/java/com/facebook/fresco/animation/drawable/RoundedAnimationDrawable.java b/animated-drawable/src/main/java/com/facebook/fresco/animation/drawable/RoundedAnimationDrawable.java
new file mode 100644
index 000000000..ae6b28ce7
--- /dev/null
+++ b/animated-drawable/src/main/java/com/facebook/fresco/animation/drawable/RoundedAnimationDrawable.java
@@ -0,0 +1,325 @@
+/*
+ * Copyright (c) 2015-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+package com.facebook.fresco.animation.drawable;
+
+import android.graphics.Color;
+import android.graphics.Matrix;
+import android.graphics.Path;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
+
+import com.facebook.common.internal.Preconditions;
+import com.facebook.common.internal.VisibleForTesting;
+import com.facebook.drawee.drawable.Rounded;
+import com.facebook.drawee.drawable.TransformAwareDrawable;
+import com.facebook.drawee.drawable.TransformCallback;
+
+import java.util.Arrays;
+
+public abstract class RoundedAnimationDrawable extends Drawable
+    implements Rounded, TransformAwareDrawable {
+
+  protected boolean mIsCircle = false;
+  protected boolean mRadiiNonZero = false;
+  protected float mBorderWidth = 0;
+  protected final Path mPath = new Path();
+  protected boolean mIsShaderTransformDirty = true;
+  protected int mBorderColor = Color.TRANSPARENT;
+  protected final Path mBorderPath = new Path();
+
+  private final float[] mCornerRadii = new float[8];
+  @VisibleForTesting final float[] mBorderRadii = new float[8];
+  @VisibleForTesting @Nullable float[] mInsideBorderRadii;
+
+  @VisibleForTesting final RectF mRootBounds = new RectF();
+  @VisibleForTesting final RectF mPrevRootBounds = new RectF();
+  @VisibleForTesting final RectF mBitmapBounds = new RectF();
+  @VisibleForTesting final RectF mDrawableBounds = new RectF();
+  @VisibleForTesting @Nullable RectF mInsideBorderBounds;
+
+  @VisibleForTesting final Matrix mBoundsTransform = new Matrix();
+  @VisibleForTesting final Matrix mPrevBoundsTransform = new Matrix();
+
+  @VisibleForTesting final Matrix mParentTransform = new Matrix();
+  @VisibleForTesting final Matrix mPrevParentTransform = new Matrix();
+  @VisibleForTesting final Matrix mInverseParentTransform = new Matrix();
+
+  @VisibleForTesting @Nullable Matrix mInsideBorderTransform;
+  @VisibleForTesting @Nullable Matrix mPrevInsideBorderTransform;
+
+  @VisibleForTesting final Matrix mTransform = new Matrix();
+  private float mPadding = 0;
+  private boolean mScaleDownInsideBorders = false;
+
+  private boolean mIsPathDirty = true;
+
+  private @Nullable
+  TransformCallback mTransformCallback;
+
+  /**
+   * Sets whether to round as circle.
+   *
+   * @param isCircle whether or not to round as circle
+   */
+  @Override
+  public void setCircle(boolean isCircle) {
+    mIsCircle = isCircle;
+    mIsPathDirty = true;
+    invalidateSelf();
+  }
+
+  /** Returns whether or not this drawable rounds as circle. */
+  @Override
+  public boolean isCircle() {
+    return mIsCircle;
+  }
+
+  /**
+   * Specify radius for the corners of the rectangle. If this is > 0, then the
+   * drawable is drawn in a round-rectangle, rather than a rectangle.
+   * @param radius the radius for the corners of the rectangle
+   */
+  @Override
+  public void setRadius(float radius) {
+    Preconditions.checkState(radius >= 0);
+    Arrays.fill(mCornerRadii, radius);
+    mRadiiNonZero = (radius != 0);
+    mIsPathDirty = true;
+    invalidateSelf();
+  }
+
+  /**
+   * Specify radii for each of the 4 corners. For each corner, the array
+   * contains 2 values, [X_radius, Y_radius]. The corners are ordered
+   * top-left, top-right, bottom-right, bottom-left
+   * @param radii the x and y radii of the corners
+   */
+  @Override
+  public void setRadii(float[] radii) {
+    if (radii == null) {
+      Arrays.fill(mCornerRadii, 0);
+      mRadiiNonZero = false;
+    } else {
+      Preconditions.checkArgument(radii.length == 8, "radii should have exactly 8 values");
+      System.arraycopy(radii, 0, mCornerRadii, 0, 8);
+      mRadiiNonZero = false;
+      for (int i = 0; i < 8; i++) {
+        mRadiiNonZero |= (radii[i] > 0);
+      }
+    }
+    mIsPathDirty = true;
+    invalidateSelf();
+  }
+
+  /** Gets the radii. */
+  @Override
+  public float[] getRadii() {
+    return mCornerRadii;
+  }
+
+  /**
+   * Sets the border
+   * @param color of the border
+   * @param width of the border
+   */
+  @Override
+  public void setBorder(int color, float width) {
+    if (mBorderColor != color || mBorderWidth != width) {
+      mBorderColor = color;
+      mBorderWidth = width;
+      mIsPathDirty = true;
+      invalidateSelf();
+    }
+  }
+
+  /** Gets the border color. */
+  @Override
+  public int getBorderColor() {
+    return mBorderColor;
+  }
+
+  /** Gets the border width. */
+  @Override
+  public float getBorderWidth() {
+    return mBorderWidth;
+  }
+
+  /**
+   * Sets the padding for the bitmap.
+   * @param padding
+   */
+  @Override
+  public void setPadding(float padding) {
+    if (mPadding != padding) {
+      mPadding = padding;
+      mIsPathDirty = true;
+      invalidateSelf();
+    }
+  }
+
+  /** Gets the padding. */
+  @Override
+  public float getPadding() {
+    return mPadding;
+  }
+
+  /**
+   * Sets whether image should be scaled down inside borders.
+   *
+   * @param scaleDownInsideBorders
+   */
+  @Override
+  public void setScaleDownInsideBorders(boolean scaleDownInsideBorders) {
+    if (mScaleDownInsideBorders != scaleDownInsideBorders) {
+      mScaleDownInsideBorders = scaleDownInsideBorders;
+      mIsPathDirty = true;
+      invalidateSelf();
+    }
+  }
+
+  /** Gets whether image should be scaled down inside borders. */
+  @Override
+  public boolean getScaleDownInsideBorders() {
+    return mScaleDownInsideBorders;
+  }
+
+  /** TransformAwareDrawable method */
+  @Override
+  public void setTransformCallback(@Nullable TransformCallback transformCallback) {
+    mTransformCallback = transformCallback;
+  }
+
+  public void updateTransform() {
+    if (mTransformCallback != null) {
+      mTransformCallback.getTransform(mParentTransform);
+      mTransformCallback.getRootBounds(mRootBounds);
+    } else {
+      mParentTransform.reset();
+      mRootBounds.set(getBounds());
+    }
+
+    mBitmapBounds.set(0, 0, getIntrinsicWidth(), getIntrinsicHeight());
+    mDrawableBounds.set(getBounds());
+    mBoundsTransform.setRectToRect(mBitmapBounds, mDrawableBounds, Matrix.ScaleToFit.FILL);
+    if (mScaleDownInsideBorders) {
+      if (mInsideBorderBounds == null) {
+        mInsideBorderBounds = new RectF(mRootBounds);
+      } else {
+        mInsideBorderBounds.set(mRootBounds);
+      }
+      mInsideBorderBounds.inset(mBorderWidth, mBorderWidth);
+      if (mInsideBorderTransform == null) {
+        mInsideBorderTransform = new Matrix();
+      }
+      mInsideBorderTransform.setRectToRect(
+          mRootBounds, mInsideBorderBounds, Matrix.ScaleToFit.FILL);
+    } else if (mInsideBorderTransform != null) {
+      mInsideBorderTransform.reset();
+    }
+
+    if (!mParentTransform.equals(mPrevParentTransform)
+        || !mBoundsTransform.equals(mPrevBoundsTransform)
+        || (mInsideBorderTransform != null
+        && !mInsideBorderTransform.equals(mPrevInsideBorderTransform))) {
+      mIsShaderTransformDirty = true;
+
+      mParentTransform.invert(mInverseParentTransform);
+      mTransform.set(mParentTransform);
+      if (mScaleDownInsideBorders) {
+        mTransform.postConcat(mInsideBorderTransform);
+      }
+      mTransform.preConcat(mBoundsTransform);
+
+      mPrevParentTransform.set(mParentTransform);
+      mPrevBoundsTransform.set(mBoundsTransform);
+      if (mScaleDownInsideBorders) {
+        if (mPrevInsideBorderTransform == null) {
+          mPrevInsideBorderTransform = new Matrix(mInsideBorderTransform);
+        } else {
+          mPrevInsideBorderTransform.set(mInsideBorderTransform);
+        }
+      } else if (mPrevInsideBorderTransform != null) {
+        mPrevInsideBorderTransform.reset();
+      }
+    }
+
+    if (!mRootBounds.equals(mPrevRootBounds)) {
+      mIsPathDirty = true;
+      mPrevRootBounds.set(mRootBounds);
+    }
+  }
+
+  public void updatePath() {
+    if (mIsPathDirty) {
+      mBorderPath.reset();
+      mRootBounds.inset(mBorderWidth / 2, mBorderWidth / 2);
+      if (mIsCircle) {
+        float radius = Math.min(mRootBounds.width(), mRootBounds.height()) / 2;
+        mBorderPath.addCircle(
+            mRootBounds.centerX(), mRootBounds.centerY(), radius, Path.Direction.CW);
+      } else {
+        for (int i = 0; i < mBorderRadii.length; i++) {
+          mBorderRadii[i] = mCornerRadii[i] + mPadding - mBorderWidth / 2;
+        }
+        mBorderPath.addRoundRect(mRootBounds, mBorderRadii, Path.Direction.CW);
+      }
+      mRootBounds.inset(-mBorderWidth / 2, -mBorderWidth / 2);
+
+      mPath.reset();
+      float totalPadding = mPadding + (mScaleDownInsideBorders ? mBorderWidth : 0);
+      mRootBounds.inset(totalPadding, totalPadding);
+      if (mIsCircle) {
+        mPath.addCircle(
+            mRootBounds.centerX(),
+            mRootBounds.centerY(),
+            Math.min(mRootBounds.width(), mRootBounds.height()) / 2,
+            Path.Direction.CW);
+      } else if (mScaleDownInsideBorders) {
+        if (mInsideBorderRadii == null) {
+          mInsideBorderRadii = new float[8];
+        }
+        for (int i = 0; i < mBorderRadii.length; i++) {
+          mInsideBorderRadii[i] = mCornerRadii[i] - mBorderWidth;
+        }
+        mPath.addRoundRect(mRootBounds, mInsideBorderRadii, Path.Direction.CW);
+      } else {
+        mPath.addRoundRect(mRootBounds, mCornerRadii, Path.Direction.CW);
+      }
+      mRootBounds.inset(-(totalPadding), -(totalPadding));
+      mPath.setFillType(Path.FillType.WINDING);
+      mIsPathDirty = false;
+    }
+  }
+
+  /**
+   * If both the radii and border width are zero, there is nothing to round.
+   */
+  public boolean shouldRound() {
+    return (mIsCircle || mRadiiNonZero || mBorderWidth > 0);
+  }
+
+  public Matrix getInverseParent() {
+    return mInverseParentTransform;
+  }
+
+  public Path getPath() {
+    return mPath;
+  }
+
+  public Path getBorderPath() {
+    return mBorderPath;
+  }
+
+  public Matrix getTransform() {
+    return mTransform;
+  }
+
+  public boolean getTransformChanged() {
+    return mIsShaderTransformDirty;
+  }
+}
