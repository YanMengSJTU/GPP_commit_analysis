diff --git a/animated-base/src/main/java/com/facebook/fresco/animation/bitmap/cache/FrescoFrameCache.java b/animated-base/src/main/java/com/facebook/fresco/animation/bitmap/cache/FrescoFrameCache.java
index dd7e34e62..c661f725e 100644
--- a/animated-base/src/main/java/com/facebook/fresco/animation/bitmap/cache/FrescoFrameCache.java
+++ b/animated-base/src/main/java/com/facebook/fresco/animation/bitmap/cache/FrescoFrameCache.java
@@ -48,7 +48,9 @@ public FrescoFrameCache(AnimatedFrameCache animatedFrameCache, boolean enableBit
   @Nullable
   @Override
   public synchronized CloseableReference<Bitmap> getCachedFrame(int frameNumber) {
-    return convertToBitmapReferenceAndClose(mAnimatedFrameCache.get(frameNumber));
+    CloseableReference<Bitmap> closeableReference = convertToBitmapReferenceAndClose(mAnimatedFrameCache.get(frameNumber));
+    FLog.e(TAG, "getCachedFrame frameNumber = " + frameNumber + " ref = " + closeableReference);
+    return closeableReference;
   }
 
   @Nullable
diff --git a/animated-base/src/main/java/com/facebook/fresco/animation/factory/AnimatedFactoryV2Impl.java b/animated-base/src/main/java/com/facebook/fresco/animation/factory/AnimatedFactoryV2Impl.java
index 11e17324e..4a7835403 100644
--- a/animated-base/src/main/java/com/facebook/fresco/animation/factory/AnimatedFactoryV2Impl.java
+++ b/animated-base/src/main/java/com/facebook/fresco/animation/factory/AnimatedFactoryV2Impl.java
@@ -109,7 +109,7 @@ private ExperimentalBitmapAnimationDrawableFactory createDrawableFactory() {
     Supplier<Integer> cachingStrategySupplier = new Supplier<Integer>() {
       @Override
       public Integer get() {
-        return ExperimentalBitmapAnimationDrawableFactory.CACHING_STRATEGY_FRESCO_CACHE_NO_REUSING;
+        return ExperimentalBitmapAnimationDrawableFactory.CACHING_STRATEGY_FRESCO_CACHE;
       }
     };
 
diff --git a/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCache.java b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCache.java
index 37abdefcf..21ea98f6b 100644
--- a/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCache.java
+++ b/animated-base/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedFrameCache.java
@@ -11,6 +11,7 @@
 import com.facebook.cache.common.CacheKey;
 import com.facebook.common.internal.Objects;
 import com.facebook.common.internal.VisibleForTesting;
+import com.facebook.common.logging.FLog;
 import com.facebook.common.references.CloseableReference;
 import com.facebook.imagepipeline.cache.CountingMemoryCache;
 import com.facebook.imagepipeline.image.CloseableImage;
@@ -26,6 +27,8 @@
  */
 public class AnimatedFrameCache {
 
+  private static final Class<?> TAG = AnimatedFrameCache.class;
+
   @VisibleForTesting
   static class FrameKey implements CacheKey {
 
@@ -95,6 +98,7 @@ public void onExclusivityChanged(CacheKey key, boolean isExclusive) {
   }
 
   public synchronized void onReusabilityChange(CacheKey key, boolean isReusable) {
+    FLog.e(TAG, "onReusabilityChange cache key = " + key + " isReusable = " + isReusable);
     if (isReusable) {
       mFreeItemsPool.add(key);
     } else {
@@ -114,7 +118,8 @@ public synchronized void onReusabilityChange(CacheKey key, boolean isReusable) {
   public CloseableReference<CloseableImage> cache(
       int frameIndex,
       CloseableReference<CloseableImage> imageRef) {
-    return mBackingCache.cache(keyFor(frameIndex), imageRef, mEntryStateObserver);
+    CloseableReference<CloseableImage> ref = mBackingCache.cache(keyFor(frameIndex), imageRef, mEntryStateObserver);
+    return ref;
   }
 
   /**
@@ -169,6 +174,6 @@ private synchronized CacheKey popFirstFreeItemKey() {
   }
 
   private FrameKey keyFor(int frameIndex)   {
-    return new FrameKey(mImageCacheKey, frameIndex % 2);
+    return new FrameKey(mImageCacheKey, frameIndex);
   }
 }
diff --git a/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java b/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java
index 460f89d04..50514c90a 100644
--- a/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java
+++ b/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/BitmapAnimationBackend.java
@@ -195,6 +195,10 @@ private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType i
           break;
 
         case FRAME_TYPE_REUSED:
+          if (true) {
+            nextFrameType = FRAME_TYPE_FALLBACK;
+            break;
+          }
           bitmapReference =
               mBitmapFrameCache.getBitmapToReuseForFrame(frameNumber, mBitmapWidth, mBitmapHeight);
           // Try to render the frame and draw on the canvas immediately after
@@ -204,6 +208,10 @@ private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType i
           break;
 
         case FRAME_TYPE_CREATED:
+          if (true) {
+            nextFrameType = FRAME_TYPE_FALLBACK;
+            break;
+          }
           try {
             bitmapReference =
                 mPlatformBitmapFactory.createBitmap(mBitmapWidth, mBitmapHeight, mBitmapConfig);
@@ -217,6 +225,7 @@ private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType i
           drawn = renderFrameInBitmap(frameNumber, bitmapReference) &&
               drawBitmapAndCache(frameNumber, bitmapReference, canvas, FRAME_TYPE_CREATED);
           nextFrameType = FRAME_TYPE_FALLBACK;
+          FLog.e(TAG, "createBitmap FRAME_TYPE_CREATED");
           break;
 
         case FRAME_TYPE_FALLBACK:
diff --git a/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/preparation/DefaultBitmapFramePreparer.java b/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/preparation/DefaultBitmapFramePreparer.java
index 00a494044..3d1286422 100644
--- a/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/preparation/DefaultBitmapFramePreparer.java
+++ b/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/preparation/DefaultBitmapFramePreparer.java
@@ -7,7 +7,9 @@
 package com.facebook.fresco.animation.bitmap.preparation;
 
 import android.graphics.Bitmap;
+import android.util.Log;
 import android.util.SparseArray;
+import android.widget.ZoomButtonsController.OnZoomListener;
 import com.facebook.common.logging.FLog;
 import com.facebook.common.references.CloseableReference;
 import com.facebook.fresco.animation.backend.AnimationBackend;
@@ -59,6 +61,7 @@ public boolean prepareFrame(
       }
       // Check if already cached.
       if (bitmapFrameCache.contains(frameNumber)) {
+      // if (bitmapFrameCache.contains(frameNumber) && false) {
         FLog.v(TAG, "Frame %d is cached already.", frameNumber);
         return true;
       }
@@ -102,6 +105,7 @@ public void run() {
       try {
         // If we have a cached frame already, we don't need to do anything.
         if (mBitmapFrameCache.contains(mFrameNumber)) {
+        // if (mBitmapFrameCache.contains(mFrameNumber) && false) {
           FLog.v(TAG, "Frame %d is cached already.", mFrameNumber);
           return;
         }
@@ -135,6 +139,7 @@ private boolean prepareFrameAndCache(
                     mAnimationBackend.getIntrinsicWidth(),
                     mAnimationBackend.getIntrinsicHeight());
             nextFrameType = BitmapAnimationBackend.FRAME_TYPE_CREATED;
+            FLog.e(TAG.getSimpleName(), "prepareFrameAndCache: FRAME_TYPE_REUSED");
             break;
 
           case BitmapAnimationBackend.FRAME_TYPE_CREATED:
@@ -150,6 +155,7 @@ private boolean prepareFrameAndCache(
               FLog.w(TAG, "Failed to create frame bitmap", e);
               return false;
             }
+            FLog.e(TAG.getSimpleName(), "prepareFrameAndCache: FRAME_TYPE_CREATED");
             nextFrameType = BitmapAnimationBackend.FRAME_TYPE_UNKNOWN;
             break;
           default:
@@ -181,6 +187,7 @@ private boolean renderFrameAndCache(
         return false;
       }
       FLog.v(TAG, "Frame %d ready.", mFrameNumber);
+      FLog.v(TAG, "Frame %d frameType.", frameType);
       // Cache the frame
       synchronized (mPendingFrameDecodeJobs) {
         mBitmapFrameCache.onFramePrepared(mFrameNumber, bitmapReference, frameType);
diff --git a/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/preparation/FixedNumberBitmapFramePreparationStrategy.java b/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/preparation/FixedNumberBitmapFramePreparationStrategy.java
index a6c62978a..805b40d8c 100644
--- a/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/preparation/FixedNumberBitmapFramePreparationStrategy.java
+++ b/animated-drawable/src/main/java/com/facebook/fresco/animation/bitmap/preparation/FixedNumberBitmapFramePreparationStrategy.java
@@ -26,7 +26,7 @@ public FixedNumberBitmapFramePreparationStrategy() {
   }
 
   public FixedNumberBitmapFramePreparationStrategy(int framesToPrepare) {
-    mFramesToPrepare = framesToPrepare;
+    mFramesToPrepare = 1;
   }
 
   @Override
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 5318c053e..427069be1 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip
+distributionUrl=https\://apk.izuiyou.com/repositories/gradle-5.6.2-all.zip
diff --git a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
index 34512bdf3..40302a816 100644
--- a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
@@ -13,6 +13,7 @@
 import com.facebook.common.internal.Predicate;
 import com.facebook.common.internal.Supplier;
 import com.facebook.common.internal.VisibleForTesting;
+import com.facebook.common.logging.FLog;
 import com.facebook.common.memory.MemoryTrimType;
 import com.facebook.common.memory.MemoryTrimmable;
 import com.facebook.common.references.CloseableReference;
@@ -40,6 +41,8 @@
 @ThreadSafe
 public class CountingMemoryCache<K, V> implements MemoryCache<K, V>, MemoryTrimmable {
 
+  private static final Class<?> TAG = CountingMemoryCache.class;
+
   /**
    * Interface used to specify the trimming strategy for the cache.
    */
@@ -187,13 +190,18 @@ public int getSizeInBytes(Entry<K, V> entry) {
       if (canCacheNewValue(valueRef.get())) {
         Entry<K, V> newEntry = Entry.of(key, valueRef, observer);
         mCachedEntries.put(key, newEntry);
+        FLog.e(TAG, "cache entry key = " + key);
         clientRef = newClientReference(newEntry);
       }
     }
+
     CloseableReference.closeSafely(oldRefToClose);
     maybeNotifyExclusiveEntryRemoval(oldExclusive);
+    // maybeNotifyExclusiveEntryInsertion(oldExclusive);
+
 
     maybeEvictEntries();
+    FLog.e(TAG, "cache count = " + mCachedEntries.getCount());
     return clientRef;
   }
 
@@ -395,6 +403,7 @@ private void maybeEvictEntries() {
       int maxSize = Math.min(
           mMemoryCacheParams.maxEvictionQueueSize,
           mMemoryCacheParams.maxCacheSize - getInUseSizeInBytes());
+      FLog.e(TAG, "get cache size = " + (getInUseSizeInBytes() / 1024) + "kb cache count = " + getInUseCount());
       oldEntries = trimExclusivelyOwnedEntries(maxCount, maxSize);
       makeOrphans(oldEntries);
     }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultBitmapMemoryCacheParamsSupplier.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultBitmapMemoryCacheParamsSupplier.java
index 78135b67e..e279d0416 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultBitmapMemoryCacheParamsSupplier.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultBitmapMemoryCacheParamsSupplier.java
@@ -16,7 +16,7 @@
  * Supplies {@link MemoryCacheParams} for the bitmap memory cache.
  */
 public class DefaultBitmapMemoryCacheParamsSupplier implements Supplier<MemoryCacheParams> {
-  private static final int MAX_CACHE_ENTRIES = 256;
+  private static final int MAX_CACHE_ENTRIES = 1256;
   private static final int MAX_EVICTION_QUEUE_SIZE = Integer.MAX_VALUE;
   private static final int MAX_EVICTION_QUEUE_ENTRIES = Integer.MAX_VALUE;
   private static final int MAX_CACHE_ENTRY_SIZE = Integer.MAX_VALUE;
@@ -50,7 +50,7 @@ private int getMaxCacheSize() {
       if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
         return 8 * ByteConstants.MB;
       } else {
-        return maxMemory / 4;
+        return maxMemory;
       }
     }
   }
diff --git a/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/imageformat/webp/ImageFormatWebpListFragment.java b/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/imageformat/webp/ImageFormatWebpListFragment.java
index 7655eb135..e5f0d2476 100644
--- a/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/imageformat/webp/ImageFormatWebpListFragment.java
+++ b/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/imageformat/webp/ImageFormatWebpListFragment.java
@@ -33,14 +33,16 @@
 import com.facebook.fresco.samples.showcase.R;
 import com.facebook.fresco.samples.showcase.misc.CheckerBoardDrawable;
 import com.facebook.fresco.samples.showcase.misc.ImageUriProvider;
+import com.facebook.imagepipeline.common.ResizeOptions;
+import com.facebook.imagepipeline.request.ImageRequest;
+import com.facebook.imagepipeline.request.ImageRequestBuilder;
 
 /**
  * This fragment displays different WebP images.
  *
- * For being able to do this in your applications, you need to add the following dependencies
- * to your build.gradle file (where X.X.X matches the used Fresco version):
- * - implementation 'com.facebook.fresco:animated-webp:X.X.X'
- * - implementation 'com.facebook.fresco:webpsupport:X.X.X'
+ * For being able to do this in your applications, you need to add the following dependencies to
+ * your build.gradle file (where X.X.X matches the used Fresco version): - implementation
+ * 'com.facebook.fresco:animated-webp:X.X.X' - implementation 'com.facebook.fresco:webpsupport:X.X.X'
  */
 public class ImageFormatWebpListFragment extends BaseShowcaseFragment {
 
@@ -55,16 +57,17 @@ public View onCreateView(
 
   @Override
   public void onViewCreated(final View view, @Nullable Bundle savedInstanceState) {
-    final ImageUriProvider imageUriProvider = ImageUriProvider.getInstance(getContext());
 
     RecyclerView recyclerView = view.findViewById(R.id.recycler_view);
+    recyclerView.setItemViewCacheSize(0);
 
     recyclerView.setLayoutManager(new LinearLayoutManager(getContext()));
     recyclerView.setAdapter(new RecyclerView.Adapter<ItemHolder>() {
       @NonNull
       @Override
       public ItemHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) {
-        return new ItemHolder(LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.webp_animated_recycler_item, viewGroup, false)) {
+        return new ItemHolder(LayoutInflater.from(viewGroup.getContext())
+            .inflate(R.layout.webp_animated_recycler_item, viewGroup, false)) {
         };
       }
 
@@ -97,22 +100,54 @@ public ItemHolder(@NonNull View itemView) {
       avatar = itemView.findViewById(R.id.avatar);
       tiara = itemView.findViewById(R.id.tiara);
 
+      // avatar.setVisibility(View.GONE);
       tiara.setVisibility(View.GONE);
     }
 
+    public void recycler() {
+
+    }
+
+    private void attachOrDetch(boolean attach) {
+      if (avatar.getController() != null) {
+        if (attach) {
+          avatar.getController().onAttach();
+        } else {
+          avatar.getController().onDetach();
+        }
+      }
+      if (tiara.getController() != null) {
+        if (attach) {
+          tiara.getController().onAttach();
+        } else {
+          tiara.getController().onDetach();
+        }
+      }
+    }
+
     public void setData() {
-      Uri avatarUri = Uri.parse("https://zyvipres.izuiyou.com/avatars/v1/fenghuolun/animation_1571755309217475342.webp");
+      Uri avatarUri = Uri.parse(
+          "https://zyvipres.izuiyou.com/avatars/v1/fenghuolun/animation_1571755309217475342.webp");
+      ImageRequest avatarRequest = ImageRequestBuilder.newBuilderWithSource(avatarUri)
+          .setResizeOptions(new ResizeOptions(150, 150))
+          .build();
       DraweeController avatarController = Fresco.newDraweeControllerBuilder()
-              .setUri(avatarUri)
-              .setAutoPlayAnimations(true)
-              .build();
+          .setUri(avatarUri)
+          .setImageRequest(avatarRequest)
+          .setAutoPlayAnimations(true)
+          .setOldController(avatar.getController())
+          .build();
       avatar.setController(avatarController);
 
-      Uri tiaraUri = Uri.parse("https://zyvipres.izuiyou.com/heads/v1/star/animation_1571390393082421020.webp");
+      Uri tiaraUri = Uri
+          .parse("https://zyvipres.izuiyou.com/heads/v1/star/animation_1571390393082421020.webp");
+      ImageRequest tiaraRequest = ImageRequestBuilder.newBuilderWithSource(tiaraUri)
+          .setResizeOptions(new ResizeOptions(150, 150))
+          .build();
       DraweeController tiaraController = Fresco.newDraweeControllerBuilder()
-              .setUri(tiaraUri)
-              .setAutoPlayAnimations(true)
-              .build();
+          .setImageRequest(tiaraRequest)
+          .setAutoPlayAnimations(true)
+          .build();
       tiara.setController(tiaraController);
     }
   }
