diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
index 9d6262d97..0d060e2e2 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
@@ -188,46 +188,61 @@ public EncodedImage call()
     }
   }
 
+  public void put(
+	  final CacheKey key,
+	  EncodedImage encodedImage) {
+	  put(key, encodedImage, false);
+  }
   /**
    * Associates encodedImage with given key in disk cache. Disk write is performed on background
    * thread, so the caller of this method is not blocked
    */
   public void put(
       final CacheKey key,
-      EncodedImage encodedImage) {
+      EncodedImage encodedImage,
+      boolean sync) {
     Preconditions.checkNotNull(key);
     Preconditions.checkArgument(EncodedImage.isValid(encodedImage));
 
-    // Store encodedImage in staging area
-    mStagingArea.put(key, encodedImage);
+    if (sync) {
+      writeToDiskCache(key, encodedImage);
+    }
+    else
+    {
+      // Store encodedImage in staging area
+      mStagingArea.put(key, encodedImage);
 
-    // Write to disk cache. This will be executed on background thread, so increment the ref count.
-    // When this write completes (with success/failure), then we will bump down the ref count
-    // again.
-    final EncodedImage finalEncodedImage = EncodedImage.cloneOrNull(encodedImage);
-    try {
-      mWriteExecutor.execute(
-          new Runnable() {
-            @Override
-            public void run() {
-              try {
-                writeToDiskCache(key, finalEncodedImage);
-              } finally {
-                mStagingArea.remove(key, finalEncodedImage);
-                EncodedImage.closeSafely(finalEncodedImage);
-              }
+      // Write to disk cache. This will be executed on background thread, so increment the ref count.
+      // When this write completes (with success/failure), then we will bump down the ref count
+      // again.
+      final EncodedImage finalEncodedImage = EncodedImage.cloneOrNull(encodedImage);
+      try
+      {
+        mWriteExecutor.execute(new Runnable()
+        {
+          @Override
+          public void run()
+          {
+            try
+            {
+              writeToDiskCache(key, finalEncodedImage);
             }
-          });
-    } catch (Exception exception) {
-      // We failed to enqueue cache write. Log failure and decrement ref count
-      // TODO: 3697790
-      FLog.w(
-          TAG,
-          exception,
-          "Failed to schedule disk-cache write for %s",
-          key.toString());
-      mStagingArea.remove(key, encodedImage);
-      EncodedImage.closeSafely(finalEncodedImage);
+            finally
+            {
+              mStagingArea.remove(key, finalEncodedImage);
+              EncodedImage.closeSafely(finalEncodedImage);
+            }
+          }
+        });
+      }
+      catch (Exception exception)
+      {
+        // We failed to enqueue cache write. Log failure and decrement ref count
+        // TODO: 3697790
+        FLog.w(TAG, exception, "Failed to schedule disk-cache write for %s", key.toString());
+        mStagingArea.remove(key, encodedImage);
+        EncodedImage.closeSafely(finalEncodedImage);
+      }
     }
   }
 
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
index f80cf1e87..4b4b38947 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
@@ -11,6 +11,7 @@
 
 import javax.annotation.concurrent.ThreadSafe;
 
+import java.io.File;
 import java.lang.Exception;
 import java.util.Set;
 import java.util.concurrent.CancellationException;
@@ -288,6 +289,33 @@ public String toString() {
       return DataSources.immediateFailedDataSource(exception);
     }
   }
+  public DataSource<File> fetchImageFile(
+      ImageRequest imageRequest,
+      Object callerContext) {
+      Preconditions.checkNotNull(imageRequest.getSourceUri());
+      try {
+        Producer<File> producerSequence =
+                mProducerSequenceFactory.getImageFileProducerSequence(imageRequest);
+        // The resize options are used to determine whether images are going to be downsampled during
+        // decode or not. For the case where the image has to be downsampled and it's a local image it
+        // will be kept as a FileInputStream until decoding instead of reading it in memory. Since
+        // this method returns an encoded image, it should always be read into memory. Therefore, the
+        // resize options are ignored to avoid treating the image as if it was to be downsampled
+        // during decode.
+        if (imageRequest.getResizeOptions() != null) {
+          imageRequest = ImageRequestBuilder.fromRequest(imageRequest)
+                  .setResizeOptions(null)
+                  .build();
+        }
+        return submitImageFileFetchRequest(
+                producerSequence,
+                imageRequest,
+                ImageRequest.RequestLevel.FULL_FETCH,
+                callerContext);
+      } catch (Exception exception) {
+        return DataSources.immediateFailedDataSource(exception);
+      }
+  }
 
   /**
    * Removes all images with the specified {@link Uri} from memory cache.
@@ -500,7 +528,33 @@ public Void then(Task<Boolean> task) throws Exception {
       return DataSources.immediateFailedDataSource(exception);
     }
   }
-
+  private DataSource<File> submitImageFileFetchRequest(
+          Producer<File> producerSequence,
+          ImageRequest imageRequest,
+          ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,
+          Object callerContext) {
+    try {
+      ImageRequest.RequestLevel lowestPermittedRequestLevel =
+              ImageRequest.RequestLevel.getMax(
+                      imageRequest.getLowestPermittedRequestLevel(),
+                      lowestPermittedRequestLevelOnSubmit);
+      SettableProducerContext settableProducerContext = new SettableProducerContext(
+              imageRequest,
+              generateUniqueFutureId(),
+              mRequestListener,
+              callerContext,
+              lowestPermittedRequestLevel,
+        /* isPrefetch */ true,
+        /* isIntermediateResultExpected */ false,
+              Priority.LOW);
+      return ProducerToDataSourceAdapter.create(
+              producerSequence,
+              settableProducerContext,
+              mRequestListener);
+    } catch (Exception exception) {
+      return DataSources.immediateFailedDataSource(exception);
+    }
+  }
   private Predicate<CacheKey> predicateForUri(Uri uri) {
     final String cacheKeySourceString = mCacheKeyFactory.getCacheKeySourceUri(uri).toString();
     return new Predicate<CacheKey>() {
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
index acf6525f3..bdf4d694c 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
@@ -37,6 +37,7 @@
 import com.facebook.imagepipeline.producers.DiskCacheProducer;
 import com.facebook.imagepipeline.producers.EncodedCacheKeyMultiplexProducer;
 import com.facebook.imagepipeline.producers.EncodedMemoryCacheProducer;
+import com.facebook.imagepipeline.producers.ImageFileFetchProducer;
 import com.facebook.imagepipeline.producers.LocalAssetFetchProducer;
 import com.facebook.imagepipeline.producers.LocalContentUriFetchProducer;
 import com.facebook.imagepipeline.producers.LocalExifThumbnailProducer;
@@ -128,6 +129,9 @@ public static AddImageTransformMetaDataProducer newAddImageTransformMetaDataProd
       Producer<EncodedImage> inputProducer) {
     return new AddImageTransformMetaDataProducer(inputProducer);
   }
+  public static ImageFileFetchProducer newImageFileFetchProducer(final Producer<EncodedImage> pInputProducer) {
+    return new ImageFileFetchProducer(pInputProducer);
+  }
 
   public BitmapMemoryCacheGetProducer newBitmapMemoryCacheGetProducer(
       Producer<CloseableReference<CloseableImage>> inputProducer) {
@@ -166,12 +170,14 @@ public DecodeProducer newDecodeProducer(Producer<EncodedImage> inputProducer) {
   }
 
   public DiskCacheProducer newDiskCacheProducer(
-      Producer<EncodedImage> inputProducer) {
+      Producer<EncodedImage> inputProducer,
+      boolean isWriteDiskSync) {
     return new DiskCacheProducer(
         mDefaultBufferedDiskCache,
         mSmallImageBufferedDiskCache,
         mCacheKeyFactory,
-        inputProducer);
+        inputProducer,
+        isWriteDiskSync);
   }
 
   public EncodedCacheKeyMultiplexProducer newEncodedCacheKeyMultiplexProducer(
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
index dc031b5b7..a3b311c5e 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
@@ -9,6 +9,7 @@
 
 package com.facebook.imagepipeline.core;
 
+import java.io.File;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -60,6 +61,7 @@
   @VisibleForTesting Producer<EncodedImage> mBackgroundNetworkFetchToEncodedMemorySequence;
   @VisibleForTesting Producer<CloseableReference<PooledByteBuffer>> mEncodedImageProducerSequence;
   @VisibleForTesting Producer<Void> mNetworkFetchToEncodedMemoryPrefetchSequence;
+  @VisibleForTesting Producer<File> mImageFileFetchSequence;
   private Producer<EncodedImage> mCommonNetworkFetchToEncodedMemorySequence;
   @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalImageFileFetchSequence;
   @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalVideoFileFetchSequence;
@@ -103,7 +105,7 @@ public ProducerSequenceFactory(
     synchronized (this) {
       if (mEncodedImageProducerSequence == null) {
         mEncodedImageProducerSequence = new RemoveImageTransformMetaDataProducer(
-            getBackgroundNetworkFetchToEncodedMemorySequence());
+            getBackgroundNetworkFetchToEncodedMemorySequence(false));
       }
     }
     return mEncodedImageProducerSequence;
@@ -123,6 +125,18 @@ public ProducerSequenceFactory(
     return getNetworkFetchToEncodedMemoryPrefetchSequence();
   }
 
+  public synchronized Producer<File> getImageFileProducerSequence(ImageRequest imageRequest) {
+    validateEncodedImageRequest(imageRequest);
+	  if (mImageFileFetchSequence == null) {
+		  Producer<EncodedImage> inputProducer =
+				  mProducerFactory.newDiskCacheProducer(mProducerFactory.newNetworkFetchProducer(mNetworkFetcher), true);
+		  mImageFileFetchSequence =
+				  ProducerFactory.newImageFileFetchProducer(inputProducer);
+
+	  }
+	  return mImageFileFetchSequence;
+  }
+
   private static void validateEncodedImageRequest(ImageRequest imageRequest) {
     Preconditions.checkNotNull(imageRequest);
     Preconditions.checkArgument(UriUtil.isNetworkUri(imageRequest.getSourceUri()));
@@ -140,7 +154,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   public Producer<CloseableReference<CloseableImage>> getDecodedImageProducerSequence(
       ImageRequest imageRequest) {
     Producer<CloseableReference<CloseableImage>> pipelineSequence =
-        getBasicDecodedImageSequence(imageRequest);
+        getBasicDecodedImageSequence(imageRequest, false);
     if (imageRequest.getPostprocessor() != null) {
       return getPostprocessorSequence(pipelineSequence);
     } else {
@@ -156,17 +170,18 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    */
   public Producer<Void> getDecodedImagePrefetchProducerSequence(
       ImageRequest imageRequest) {
-    return getDecodedImagePrefetchSequence(getBasicDecodedImageSequence(imageRequest));
+    return getDecodedImagePrefetchSequence(getBasicDecodedImageSequence(imageRequest, false));
   }
 
   private Producer<CloseableReference<CloseableImage>> getBasicDecodedImageSequence(
-      ImageRequest imageRequest) {
+      ImageRequest imageRequest,
+      boolean isWriteDiskSync) {
     Preconditions.checkNotNull(imageRequest);
 
     Uri uri = imageRequest.getSourceUri();
     Preconditions.checkNotNull(uri, "Uri is null.");
     if (UriUtil.isNetworkUri(uri)) {
-      return getNetworkFetchSequence();
+      return getNetworkFetchSequence(isWriteDiskSync);
     } else if (UriUtil.isLocalFileUri(uri)) {
       if (MediaUtils.isVideo(MediaUtils.extractMime(uri.getPath()))) {
         return getLocalVideoFileFetchSequence();
@@ -195,10 +210,11 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    * background thread hand-off -> multiplex -> bitmap cache -> decode -> multiplex ->
    * encoded cache -> disk cache -> (webp transcode) -> network fetch.
    */
-  private synchronized Producer<CloseableReference<CloseableImage>> getNetworkFetchSequence() {
+  private synchronized Producer<CloseableReference<CloseableImage>> getNetworkFetchSequence(
+      boolean isWriteDiskSync) {
     if (mNetworkFetchSequence == null) {
       mNetworkFetchSequence =
-          newBitmapCacheGetToDecodeSequence(getCommonNetworkFetchToEncodedMemorySequence());
+          newBitmapCacheGetToDecodeSequence(getCommonNetworkFetchToEncodedMemorySequence(isWriteDiskSync));
     }
     return mNetworkFetchSequence;
   }
@@ -208,12 +224,12 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    * disk cache -> (webp transcode) -> network fetch.
    */
   private synchronized Producer<EncodedImage>
-      getBackgroundNetworkFetchToEncodedMemorySequence() {
+      getBackgroundNetworkFetchToEncodedMemorySequence(boolean isWriteDiskSync) {
     if (mBackgroundNetworkFetchToEncodedMemorySequence == null) {
       // Use hand-off producer to ensure that we don't do any unnecessary work on the UI thread.
       mBackgroundNetworkFetchToEncodedMemorySequence =
           mProducerFactory.newBackgroundThreadHandoffProducer(
-                  getCommonNetworkFetchToEncodedMemorySequence(),
+                  getCommonNetworkFetchToEncodedMemorySequence(isWriteDiskSync),
                   mThreadHandoffProducerQueue);
     }
     return mBackgroundNetworkFetchToEncodedMemorySequence;
@@ -227,7 +243,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
     if (mNetworkFetchToEncodedMemoryPrefetchSequence == null) {
       mNetworkFetchToEncodedMemoryPrefetchSequence =
           mProducerFactory.newSwallowResultProducer(
-                  getBackgroundNetworkFetchToEncodedMemorySequence());
+                  getBackgroundNetworkFetchToEncodedMemorySequence(false));
     }
     return mNetworkFetchToEncodedMemoryPrefetchSequence;
   }
@@ -235,11 +251,12 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   /**
    * multiplex -> encoded cache -> disk cache -> (webp transcode) -> network fetch.
    */
-  private synchronized Producer<EncodedImage> getCommonNetworkFetchToEncodedMemorySequence() {
+  private synchronized Producer<EncodedImage> getCommonNetworkFetchToEncodedMemorySequence(
+      boolean isWriteDiskSync) {
     if (mCommonNetworkFetchToEncodedMemorySequence == null) {
       Producer<EncodedImage> inputProducer =
           newEncodedCacheMultiplexToTranscodeSequence(
-              mProducerFactory.newNetworkFetchProducer(mNetworkFetcher));
+              mProducerFactory.newNetworkFetchProducer(mNetworkFetcher), isWriteDiskSync);
       mCommonNetworkFetchToEncodedMemorySequence =
           ProducerFactory.newAddImageTransformMetaDataProducer(inputProducer);
 
@@ -369,7 +386,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    */
   private Producer<CloseableReference<CloseableImage>> newBitmapCacheGetToLocalTransformSequence(
       Producer<EncodedImage> inputProducer) {
-    inputProducer = newEncodedCacheMultiplexToTranscodeSequence(inputProducer);
+    inputProducer = newEncodedCacheMultiplexToTranscodeSequence(inputProducer, false);
     Producer<EncodedImage> inputProducerAfterDecode =
         newLocalTransformationsSequence(inputProducer);
     return newBitmapCacheGetToDecodeSequence(inputProducerAfterDecode);
@@ -392,11 +409,11 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    * @return encoded cache multiplex to webp transcode sequence
    */
   private Producer<EncodedImage> newEncodedCacheMultiplexToTranscodeSequence(
-          Producer<EncodedImage> inputProducer) {
+          Producer<EncodedImage> inputProducer, boolean isWriteDiskSync) {
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2 && !mWebpSupportEnabled) {
       inputProducer = mProducerFactory.newWebpTranscodeProducer(inputProducer);
     }
-    inputProducer = mProducerFactory.newDiskCacheProducer(inputProducer);
+    inputProducer = mProducerFactory.newDiskCacheProducer(inputProducer, isWriteDiskSync);
     EncodedMemoryCacheProducer encodedMemoryCacheProducer =
         mProducerFactory.newEncodedMemoryCacheProducer(inputProducer);
     return mProducerFactory.newEncodedCacheKeyMultiplexProducer(encodedMemoryCacheProducer);
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java
index 8d6f52ea4..b29d8dbe8 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java
@@ -42,16 +42,26 @@
   private final BufferedDiskCache mSmallImageBufferedDiskCache;
   private final CacheKeyFactory mCacheKeyFactory;
   private final Producer<EncodedImage> mInputProducer;
-
+  private final boolean mIsWriteDiskSync;
+
+	public DiskCacheProducer(
+			BufferedDiskCache defaultBufferedDiskCache,
+			BufferedDiskCache smallImageBufferedDiskCache,
+			CacheKeyFactory cacheKeyFactory,
+			Producer<EncodedImage> inputProducer) {
+		this(defaultBufferedDiskCache, smallImageBufferedDiskCache, cacheKeyFactory, inputProducer, false);
+	}
   public DiskCacheProducer(
       BufferedDiskCache defaultBufferedDiskCache,
       BufferedDiskCache smallImageBufferedDiskCache,
       CacheKeyFactory cacheKeyFactory,
-      Producer<EncodedImage> inputProducer) {
+      Producer<EncodedImage> inputProducer,
+      boolean isWriteDiskSync) {
     mDefaultBufferedDiskCache = defaultBufferedDiskCache;
     mSmallImageBufferedDiskCache = smallImageBufferedDiskCache;
     mCacheKeyFactory = cacheKeyFactory;
     mInputProducer = inputProducer;
+    mIsWriteDiskSync = isWriteDiskSync;
   }
 
   public void produceResults(
@@ -177,7 +187,7 @@ private DiskCacheConsumer(
     @Override
     public void onNewResultImpl(EncodedImage newResult, boolean isLast) {
       if (newResult != null && isLast) {
-        mCache.put(mCacheKey, newResult);
+        mCache.put(mCacheKey, newResult, mIsWriteDiskSync);
       }
       getConsumer().onNewResult(newResult, isLast);
     }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageFileFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageFileFetchProducer.java
new file mode 100644
index 000000000..fa2bee0ca
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageFileFetchProducer.java
@@ -0,0 +1,70 @@
+package com.facebook.imagepipeline.producers;
+
+import com.facebook.binaryresource.BinaryResource;
+import com.facebook.binaryresource.FileBinaryResource;
+import com.facebook.cache.common.CacheKey;
+import com.facebook.imagepipeline.cache.DefaultCacheKeyFactory;
+import com.facebook.imagepipeline.core.ImagePipelineFactory;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.request.ImageRequest;
+
+import java.io.File;
+
+/**
+ * @author zlin @ Zhihu Inc.
+ * @since 12-22-2015
+ */
+public class ImageFileFetchProducer implements Producer<File>
+{
+	private final Producer<EncodedImage> mInputProducer;
+
+	public ImageFileFetchProducer(final Producer<EncodedImage> pInputProducer)
+	{
+		mInputProducer = pInputProducer;
+	}
+
+	@Override
+	public void produceResults(final Consumer<File> consumer, final ProducerContext context)
+	{
+		mInputProducer.produceResults(new ImageFileFetchConsumer(consumer, context.getImageRequest()), context);
+	}
+
+	private static class ImageFileFetchConsumer extends DelegatingConsumer<EncodedImage, File>
+	{
+		ImageRequest mImageRequest;
+
+		private ImageFileFetchConsumer(Consumer<File> consumer, ImageRequest imageRequest)
+		{
+			super(consumer);
+			mImageRequest = imageRequest;
+		}
+
+		@Override
+		protected void onNewResultImpl(EncodedImage newResult, boolean isLast)
+		{
+			File localFile = null;
+			CacheKey cacheKey = DefaultCacheKeyFactory.getInstance().getEncodedCacheKey(mImageRequest);
+			BinaryResource resource = null;
+			if (ImagePipelineFactory.getInstance().getMainDiskStorageCache().hasKey(cacheKey))
+			{
+				resource = ImagePipelineFactory.getInstance().getMainDiskStorageCache().getResource(cacheKey);
+			}
+			else if (ImagePipelineFactory.getInstance().getSmallImageDiskStorageCache().hasKey(cacheKey))
+			{
+				resource = ImagePipelineFactory.getInstance().getSmallImageDiskStorageCache().getResource(cacheKey);
+			}
+			if (resource != null)
+			{
+				localFile = ((FileBinaryResource) resource).getFile();
+			}
+			if (localFile != null && localFile.exists())
+			{
+				getConsumer().onNewResult(localFile, isLast);
+			}
+			else
+			{
+				getConsumer().onFailure(new IllegalStateException("cache file not found"));
+			}
+		}
+	}
+}
