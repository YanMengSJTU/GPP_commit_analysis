diff --git a/imagepipeline-backends/imagepipeline-okhttp3/src/main/java/com/facebook/imagepipeline/backends/okhttp3/OkHttpNetworkFetcher.java b/imagepipeline-backends/imagepipeline-okhttp3/src/main/java/com/facebook/imagepipeline/backends/okhttp3/OkHttpNetworkFetcher.java
index 447734166..e5db3e977 100644
--- a/imagepipeline-backends/imagepipeline-okhttp3/src/main/java/com/facebook/imagepipeline/backends/okhttp3/OkHttpNetworkFetcher.java
+++ b/imagepipeline-backends/imagepipeline-okhttp3/src/main/java/com/facebook/imagepipeline/backends/okhttp3/OkHttpNetworkFetcher.java
@@ -87,9 +87,9 @@ public void fetch(final OkHttpNetworkFetchState fetchState, final Callback callb
     fetchState.submitTime = SystemClock.elapsedRealtime();
     final Uri uri = fetchState.getUri();
     final Request request = new Request.Builder()
-        .cacheControl(new CacheControl.Builder().noStore().build())
-        .url(uri.toString())
-        .get()
+        .cacheControl(new CacheControl.Builder().noStore().build())//no-cache
+        .url(uri.toString())//url
+        .get()//GET Request
         .build();
     fetchWithRequest(fetchState, callback, request);
   }
@@ -113,8 +113,9 @@ protected void fetchWithRequest(
       final OkHttpNetworkFetchState fetchState,
       final Callback callback,
       final Request request) {
-    final Call call = mCallFactory.newCall(request);
+    final Call call = mCallFactory.newCall(request);//创建请求
 
+    //cancel
     fetchState.getContext().addCallbacks(
         new BaseProducerContextCallbacks() {
           @Override
@@ -131,18 +132,17 @@ public void onCancellationRequested() {
           }
         });
 
+    //将请求入队列
     call.enqueue(
         new okhttp3.Callback() {
           @Override
           public void onResponse(Call call, Response response) throws IOException {
-            fetchState.responseTime = SystemClock.elapsedRealtime();
+            fetchState.responseTime = SystemClock.elapsedRealtime();//标记响应时间
             final ResponseBody body = response.body();
             try {
-              if (!response.isSuccessful()) {
-                handleException(
-                    call,
-                    new IOException("Unexpected HTTP code " + response),
-                    callback);
+              if (!response.isSuccessful()) {//没有成功
+                //处理异常
+                handleException(call, new IOException("Unexpected HTTP code " + response), callback);
                 return;
               }
 
@@ -150,8 +150,11 @@ public void onResponse(Call call, Response response) throws IOException {
               if (contentLength < 0) {
                 contentLength = 0;
               }
+
+              //回调字节流
               callback.onResponse(body.byteStream(), (int) contentLength);
             } catch (Exception e) {
+              //处理异常
               handleException(call, e, callback);
             } finally {
               try {
@@ -164,6 +167,7 @@ public void onResponse(Call call, Response response) throws IOException {
 
           @Override
           public void onFailure(Call call, IOException e) {
+            //处理异常
             handleException(call, e, callback);
           }
         });
diff --git a/imagepipeline-backends/imagepipeline-volley/src/main/java/com/facebook/imagepipeline/backends/volley/VolleyNetworkFetcher.java b/imagepipeline-backends/imagepipeline-volley/src/main/java/com/facebook/imagepipeline/backends/volley/VolleyNetworkFetcher.java
index 5f927d9a7..0694c10d1 100644
--- a/imagepipeline-backends/imagepipeline-volley/src/main/java/com/facebook/imagepipeline/backends/volley/VolleyNetworkFetcher.java
+++ b/imagepipeline-backends/imagepipeline-volley/src/main/java/com/facebook/imagepipeline/backends/volley/VolleyNetworkFetcher.java
@@ -73,19 +73,21 @@ public VolleyNetworkFetchState createFetchState(
 
   @Override
   public void fetch(final VolleyNetworkFetchState fetchState, final Callback callback) {
-    fetchState.submitTime = SystemClock.elapsedRealtime();
+    fetchState.submitTime = SystemClock.elapsedRealtime();//标记任务提交时间
 
     final RawRequest request = new RawRequest(
         fetchState.getUri().toString(),
         new Response.Listener<byte[]>() {
           @Override
           public void onResponse(byte[] bytes) {
-            fetchState.responseTime = SystemClock.uptimeMillis();
+            fetchState.responseTime = SystemClock.uptimeMillis();//标记任务响应时间
 
             try {
               InputStream is = new ByteArrayInputStream(bytes);
+              //回调输入流
               callback.onResponse(is, bytes.length);
             } catch (IOException e) {
+              //失败回调
               callback.onFailure(e);
             }
           }
@@ -93,6 +95,7 @@ public void onResponse(byte[] bytes) {
         new Response.ErrorListener() {
           @Override
           public void onErrorResponse(VolleyError volleyError) {
+            //失败回调
             callback.onFailure(volleyError);
           }
         });
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
index d89ce3058..1e18ba908 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
@@ -568,6 +568,7 @@ public Void then(Task<Boolean> task) throws Exception {
               !UriUtil.isNetworkUri(imageRequest.getSourceUri()),
           imageRequest.getPriority());
 
+      //创建并且加载图片
       return CloseableProducerToDataSourceAdapter.create(
           producerSequence,
           settableProducerContext,
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/FetchState.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/FetchState.java
index 3e5797324..f6a49eba7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/FetchState.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/FetchState.java
@@ -15,48 +15,54 @@
 
 /**
  * Used by {@link NetworkFetcher} to encapsulate the state of one network fetch.
- *
+ * <p>
  * <p>Implementations can subclass this to store additional fetch-scoped fields.
  */
 public class FetchState {
 
-  private final Consumer<EncodedImage> mConsumer;
-  private final ProducerContext mContext;
-  private long mLastIntermediateResultTimeMs;
-
-  public FetchState(
-      Consumer<EncodedImage> consumer,
-      ProducerContext context) {
-    mConsumer = consumer;
-    mContext = context;
-    mLastIntermediateResultTimeMs = 0;
-  }
-
-  public Consumer<EncodedImage> getConsumer() {
-    return mConsumer;
-  }
-
-  public ProducerContext getContext() {
-    return mContext;
-  }
-
-  public String getId() {
-    return mContext.getId();
-  }
-
-  public ProducerListener getListener() {
-    return mContext.getListener();
-  }
-
-  public Uri getUri() {
-    return mContext.getImageRequest().getSourceUri();
-  }
-
-  public long getLastIntermediateResultTimeMs() {
-    return mLastIntermediateResultTimeMs;
-  }
-
-  public void setLastIntermediateResultTimeMs(long lastIntermediateResultTimeMs) {
-    mLastIntermediateResultTimeMs = lastIntermediateResultTimeMs;
-  }
+    /**
+     * 消费者
+     */
+    private final Consumer<EncodedImage> mConsumer;
+    /**
+     * 生产者上下文
+     */
+    private final ProducerContext mContext;
+    private long mLastIntermediateResultTimeMs;
+
+    public FetchState(
+            Consumer<EncodedImage> consumer,
+            ProducerContext context) {
+        mConsumer = consumer;
+        mContext = context;
+        mLastIntermediateResultTimeMs = 0;
+    }
+
+    public Consumer<EncodedImage> getConsumer() {
+        return mConsumer;
+    }
+
+    public ProducerContext getContext() {
+        return mContext;
+    }
+
+    public String getId() {
+        return mContext.getId();
+    }
+
+    public ProducerListener getListener() {
+        return mContext.getListener();
+    }
+
+    public Uri getUri() {
+        return mContext.getImageRequest().getSourceUri();
+    }
+
+    public long getLastIntermediateResultTimeMs() {
+        return mLastIntermediateResultTimeMs;
+    }
+
+    public void setLastIntermediateResultTimeMs(long lastIntermediateResultTimeMs) {
+        mLastIntermediateResultTimeMs = lastIntermediateResultTimeMs;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java
index 797c10ae4..5b3285448 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java
@@ -24,131 +24,139 @@
 
 /**
  * Network fetcher that uses the simplest Android stack.
- *
+ * <p>
  * <p> Apps requiring more sophisticated networking should implement their own
  * {@link NetworkFetcher}.
  */
 public class HttpUrlConnectionNetworkFetcher extends BaseNetworkFetcher<FetchState> {
 
-  private static final int NUM_NETWORK_THREADS = 3;
-  private static final int MAX_REDIRECTS = 5;
-
-  public static final int HTTP_TEMPORARY_REDIRECT = 307;
-  public static final int HTTP_PERMANENT_REDIRECT = 308;
-
-  private final ExecutorService mExecutorService;
-
-  public HttpUrlConnectionNetworkFetcher() {
-    this(Executors.newFixedThreadPool(NUM_NETWORK_THREADS));
-  }
-
-  @VisibleForTesting
-  HttpUrlConnectionNetworkFetcher(ExecutorService executorService) {
-    mExecutorService = executorService;
-  }
-
-  @Override
-  public FetchState createFetchState(Consumer<EncodedImage> consumer, ProducerContext context) {
-    return new FetchState(consumer, context);
-  }
-
-  @Override
-  public void fetch(final FetchState fetchState, final Callback callback) {
-    final Future<?> future = mExecutorService.submit(
-        new Runnable() {
-          @Override
-          public void run() {
-            fetchSync(fetchState, callback);
-          }
-        });
-    fetchState.getContext().addCallbacks(
-        new BaseProducerContextCallbacks() {
-          @Override
-          public void onCancellationRequested() {
-            if (future.cancel(false)) {
-              callback.onCancellation();
+    private static final int NUM_NETWORK_THREADS = 3;
+    private static final int MAX_REDIRECTS = 5;
+
+    public static final int HTTP_TEMPORARY_REDIRECT = 307;
+    public static final int HTTP_PERMANENT_REDIRECT = 308;
+
+    private final ExecutorService mExecutorService;
+
+    public HttpUrlConnectionNetworkFetcher() {
+        this(Executors.newFixedThreadPool(NUM_NETWORK_THREADS));
+    }
+
+    @VisibleForTesting
+    HttpUrlConnectionNetworkFetcher(ExecutorService executorService) {
+        mExecutorService = executorService;
+    }
+
+    @Override
+    public FetchState createFetchState(Consumer<EncodedImage> consumer, ProducerContext context) {
+        return new FetchState(consumer, context);
+    }
+
+    @Override
+    public void fetch(final FetchState fetchState, final Callback callback) {
+        /**
+         * 向ExecutorService提交一个任务
+         */
+        final Future<?> future = mExecutorService.submit(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        fetchSync(fetchState, callback);
+                    }
+                });
+        fetchState.getContext().addCallbacks(
+                new BaseProducerContextCallbacks() {
+                    @Override
+                    public void onCancellationRequested() {
+                        if (future.cancel(false)) {
+                            callback.onCancellation();
+                        }
+                    }
+                });
+    }
+
+    @VisibleForTesting
+    void fetchSync(FetchState fetchState, Callback callback) {
+        HttpURLConnection connection = null;
+
+        try {
+            connection = downloadFrom(fetchState.getUri(), MAX_REDIRECTS);
+
+            if (connection != null) {
+                //回调输入流
+                callback.onResponse(connection.getInputStream(), -1);
             }
-          }
-        });
-  }
-
-  @VisibleForTesting
-  void fetchSync(FetchState fetchState, Callback callback) {
-    HttpURLConnection connection = null;
-
-    try {
-      connection = downloadFrom(fetchState.getUri(), MAX_REDIRECTS);
-
-      if (connection != null) {
-        callback.onResponse(connection.getInputStream(), -1);
-      }
-    } catch (IOException e) {
-      callback.onFailure(e);
-    } finally {
-      if (connection != null) {
-        connection.disconnect();
-      }
+        } catch (IOException e) {
+            //回调失败
+            callback.onFailure(e);
+        } finally {
+            if (connection != null) {
+                connection.disconnect();
+            }
+        }
+
     }
 
-  }
+    private HttpURLConnection downloadFrom(Uri uri, int maxRedirects) throws IOException {
+        HttpURLConnection connection = openConnectionTo(uri);
+        int responseCode = connection.getResponseCode();
 
-  private HttpURLConnection downloadFrom(Uri uri, int maxRedirects) throws IOException {
-    HttpURLConnection connection = openConnectionTo(uri);
-    int responseCode = connection.getResponseCode();
+        if (isHttpSuccess(responseCode)) {//请求成功
+            return connection;
 
-    if (isHttpSuccess(responseCode)) {
-        return connection;
+        }
+        else if (isHttpRedirect(responseCode)) {//url跳转
+            String nextUriString = connection.getHeaderField("Location");//获取跳转url
+            connection.disconnect();
 
-    } else if (isHttpRedirect(responseCode)) {
-        String nextUriString = connection.getHeaderField("Location");
-        connection.disconnect();
+            Uri nextUri = (nextUriString == null) ? null : Uri.parse(nextUriString);
+            String originalScheme = uri.getScheme();
 
-        Uri nextUri = (nextUriString == null) ? null : Uri.parse(nextUriString);
-        String originalScheme = uri.getScheme();
+            if (maxRedirects > 0 && nextUri != null && !nextUri.getScheme().equals(originalScheme)) {
+                return downloadFrom(nextUri, maxRedirects - 1);
+            }
+            else {
+                String message = maxRedirects == 0
+                        ? error("URL %s follows too many redirects", uri.toString())
+                        : error("URL %s returned %d without a valid redirect", uri.toString(), responseCode);
+                throw new IOException(message);
+            }
 
-        if (maxRedirects > 0 && nextUri != null && !nextUri.getScheme().equals(originalScheme)) {
-          return downloadFrom(nextUri, maxRedirects - 1);
-        } else {
-          String message = maxRedirects == 0
-              ? error("URL %s follows too many redirects", uri.toString())
-              : error("URL %s returned %d without a valid redirect", uri.toString(), responseCode);
-          throw new IOException(message);
         }
+        else {
+            connection.disconnect();
+            throw new IOException(String
+                    .format("Image URL %s returned HTTP code %d", uri.toString(), responseCode));
+        }
+    }
+
+    @VisibleForTesting
+    static HttpURLConnection openConnectionTo(Uri uri) throws IOException {
+        URL url = new URL(uri.toString());
+        return (HttpURLConnection) url.openConnection();
+    }
 
-    } else {
-        connection.disconnect();
-        throw new IOException(String
-            .format("Image URL %s returned HTTP code %d", uri.toString(), responseCode));
+    private static boolean isHttpSuccess(int responseCode) {
+        return (responseCode >= HttpURLConnection.HTTP_OK &&
+                responseCode < HttpURLConnection.HTTP_MULT_CHOICE);
     }
-  }
-
-  @VisibleForTesting
-  static HttpURLConnection openConnectionTo(Uri uri) throws IOException {
-    URL url = new URL(uri.toString());
-    return (HttpURLConnection) url.openConnection();
-  }
-
-  private static boolean isHttpSuccess(int responseCode) {
-    return (responseCode >= HttpURLConnection.HTTP_OK &&
-        responseCode < HttpURLConnection.HTTP_MULT_CHOICE);
-  }
-
-  private static boolean isHttpRedirect(int responseCode) {
-    switch (responseCode) {
-      case HttpURLConnection.HTTP_MULT_CHOICE:
-      case HttpURLConnection.HTTP_MOVED_PERM:
-      case HttpURLConnection.HTTP_MOVED_TEMP:
-      case HttpURLConnection.HTTP_SEE_OTHER:
-      case HTTP_TEMPORARY_REDIRECT:
-      case HTTP_PERMANENT_REDIRECT:
-        return true;
-      default:
-        return false;
+
+    private static boolean isHttpRedirect(int responseCode) {
+        switch (responseCode) {
+            case HttpURLConnection.HTTP_MULT_CHOICE:
+            case HttpURLConnection.HTTP_MOVED_PERM:
+            case HttpURLConnection.HTTP_MOVED_TEMP:
+            case HttpURLConnection.HTTP_SEE_OTHER:
+            case HTTP_TEMPORARY_REDIRECT:
+            case HTTP_PERMANENT_REDIRECT:
+                return true;
+            default:
+                return false;
+        }
     }
-  }
 
-  private static String error(String format, Object... args) {
-    return String.format(Locale.getDefault(), format, args);
-  }
+    private static String error(String format, Object... args) {
+        return String.format(Locale.getDefault(), format, args);
+    }
 
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java
index 633b15afb..96e04c519 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java
@@ -27,175 +27,191 @@
 
 /**
  * A producer to actually fetch images from the network.
- *
+ * <p>
  * <p> Downloaded bytes may be passed to the consumer as they are downloaded, but not more often
  * than {@link #TIME_BETWEEN_PARTIAL_RESULTS_MS}.
-
+ * <p>
  * <p>Clients should provide an instance of {@link NetworkFetcher} to make use of their networking
  * stack. Use {@link HttpUrlConnectionNetworkFetcher} as a model.
  */
 public class NetworkFetchProducer implements Producer<EncodedImage> {
 
-  public static final String PRODUCER_NAME = "NetworkFetchProducer";
-  public static final String INTERMEDIATE_RESULT_PRODUCER_EVENT = "intermediate_result";
-  private static final int READ_SIZE = 16 * 1024;
-
-  /**
-   * Time between two consecutive partial results are propagated upstream
-   *
-   * TODO 5399646: make this configurable
-   */
-  @VisibleForTesting static final long TIME_BETWEEN_PARTIAL_RESULTS_MS = 100;
-
-  private final PooledByteBufferFactory mPooledByteBufferFactory;
-  private final ByteArrayPool mByteArrayPool;
-  private final NetworkFetcher mNetworkFetcher;
-
-  public NetworkFetchProducer(
-      PooledByteBufferFactory pooledByteBufferFactory,
-      ByteArrayPool byteArrayPool,
-      NetworkFetcher networkFetcher) {
-    mPooledByteBufferFactory = pooledByteBufferFactory;
-    mByteArrayPool = byteArrayPool;
-    mNetworkFetcher = networkFetcher;
-  }
-
-  @Override
-  public void produceResults(Consumer<EncodedImage> consumer, ProducerContext context) {
-    context.getListener()
-        .onProducerStart(context.getId(), PRODUCER_NAME);
-    final FetchState fetchState = mNetworkFetcher.createFetchState(consumer, context);
-    mNetworkFetcher.fetch(
-        fetchState, new NetworkFetcher.Callback() {
-          @Override
-          public void onResponse(InputStream response, int responseLength) throws IOException {
-            NetworkFetchProducer.this.onResponse(fetchState, response, responseLength);
-          }
-
-          @Override
-          public void onFailure(Throwable throwable) {
-            NetworkFetchProducer.this.onFailure(fetchState, throwable);
-          }
-
-          @Override
-          public void onCancellation() {
-            NetworkFetchProducer.this.onCancellation(fetchState);
-          }
-        });
-  }
-
-  private void onResponse(
-      FetchState fetchState,
-      InputStream responseData,
-      int responseContentLength)
-      throws IOException {
-    final PooledByteBufferOutputStream pooledOutputStream;
-    if (responseContentLength > 0) {
-      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);
-    } else {
-      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();
+    public static final String PRODUCER_NAME = "NetworkFetchProducer";
+    public static final String INTERMEDIATE_RESULT_PRODUCER_EVENT = "intermediate_result";
+    private static final int READ_SIZE = 16 * 1024;
+
+    /**
+     * Time between two consecutive partial results are propagated upstream
+     * <p>
+     * TODO 5399646: make this configurable
+     */
+    @VisibleForTesting
+    static final long TIME_BETWEEN_PARTIAL_RESULTS_MS = 100;
+
+    private final PooledByteBufferFactory mPooledByteBufferFactory;
+    private final ByteArrayPool mByteArrayPool;
+    private final NetworkFetcher mNetworkFetcher;
+
+    public NetworkFetchProducer(
+            PooledByteBufferFactory pooledByteBufferFactory,
+            ByteArrayPool byteArrayPool,
+            NetworkFetcher networkFetcher) {
+        mPooledByteBufferFactory = pooledByteBufferFactory;
+        mByteArrayPool = byteArrayPool;
+        mNetworkFetcher = networkFetcher;
+    }
+
+    @Override
+    public void produceResults(Consumer<EncodedImage> consumer, ProducerContext context) {
+        context.getListener()
+               .onProducerStart(context.getId(), PRODUCER_NAME);
+        /**
+         * 创建一个fetchState
+         */
+        final FetchState fetchState = mNetworkFetcher.createFetchState(consumer, context);
+
+        /**
+         * 使用NetworkFetcher下载图片,默认使用是http来下载
+         * TODO 但是在哪里构造的呢？因为有Volley,OkHttp,Http三种类型，应该是有一定的策略的
+         */
+        mNetworkFetcher.fetch(
+                fetchState, new NetworkFetcher.Callback() {
+                    @Override
+                    public void onResponse(InputStream response, int responseLength) throws IOException {
+                        NetworkFetchProducer.this.onResponse(fetchState, response, responseLength);
+                    }
+
+                    @Override
+                    public void onFailure(Throwable throwable) {
+                        NetworkFetchProducer.this.onFailure(fetchState, throwable);
+                    }
+
+                    @Override
+                    public void onCancellation() {
+                        NetworkFetchProducer.this.onCancellation(fetchState);
+                    }
+                });
     }
-    final byte[] ioArray = mByteArrayPool.get(READ_SIZE);
-    try {
-      int length;
-      while ((length = responseData.read(ioArray)) >= 0) {
-        if (length > 0) {
-          pooledOutputStream.write(ioArray, 0, length);
-          maybeHandleIntermediateResult(pooledOutputStream, fetchState);
-          float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);
-          fetchState.getConsumer().onProgressUpdate(progress);
+
+    private void onResponse(
+            FetchState fetchState,//fetch状态
+            InputStream responseData,//输入流
+            int responseContentLength)
+            throws IOException {
+        final PooledByteBufferOutputStream pooledOutputStream;
+        if (responseContentLength > 0) {
+            pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);
+        }
+        else {
+            pooledOutputStream = mPooledByteBufferFactory.newOutputStream();
+        }
+        final byte[] ioArray = mByteArrayPool.get(READ_SIZE);
+        try {
+            int length;
+            while ((length = responseData.read(ioArray)) >= 0) {
+                if (length > 0) {
+                    pooledOutputStream.write(ioArray, 0, length);
+                    maybeHandleIntermediateResult(pooledOutputStream, fetchState);
+                    float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);
+                    //更新图片加载的进度
+                    fetchState.getConsumer().onProgressUpdate(progress);
+                }
+            }
+            mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());//标记fetchTime
+            //通知消费者已经有结果了
+            handleFinalResult(pooledOutputStream, fetchState);
+        } finally {
+            mByteArrayPool.release(ioArray);
+            pooledOutputStream.close();
         }
-      }
-      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());
-      handleFinalResult(pooledOutputStream, fetchState);
-    } finally {
-      mByteArrayPool.release(ioArray);
-      pooledOutputStream.close();
     }
-  }
-
-  private static float calculateProgress(int downloaded, int total) {
-    if (total > 0) {
-      return (float) downloaded / total;
-    } else {
-      // If we don't know the total number of bytes, we approximate the progress by an exponential
-      // that approaches 1. Here are some values of the progress, given the number of bytes:
-      // 0.5 kB ~  1%
-      // 2.5 kB ~  5%
-      //   5 kB ~ 10%
-      //  14 kB ~ 25%
-      //  34 kB ~ 50%
-      //  68 kB ~ 75%
-      // 113 kB ~ 90%
-      // 147 kB ~ 95%
-      // 225 kB ~ 99%
-      return 1 - (float) Math.exp(-downloaded / 5e4);
+
+    private static float calculateProgress(int downloaded, int total) {
+        if (total > 0) {
+            return (float) downloaded / total;
+        }
+        else {
+            // If we don't know the total number of bytes, we approximate the progress by an exponential
+            // that approaches 1. Here are some values of the progress, given the number of bytes:
+            // 0.5 kB ~  1%
+            // 2.5 kB ~  5%
+            //   5 kB ~ 10%
+            //  14 kB ~ 25%
+            //  34 kB ~ 50%
+            //  68 kB ~ 75%
+            // 113 kB ~ 90%
+            // 147 kB ~ 95%
+            // 225 kB ~ 99%
+            return 1 - (float) Math.exp(-downloaded / 5e4);
+        }
     }
-  }
-
-  private void maybeHandleIntermediateResult(
-      PooledByteBufferOutputStream pooledOutputStream,
-      FetchState fetchState) {
-    final long nowMs = SystemClock.uptimeMillis();
-    if (shouldPropagateIntermediateResults(fetchState) &&
-        nowMs - fetchState.getLastIntermediateResultTimeMs() >= TIME_BETWEEN_PARTIAL_RESULTS_MS) {
-      fetchState.setLastIntermediateResultTimeMs(nowMs);
-      fetchState.getListener()
-          .onProducerEvent(fetchState.getId(), PRODUCER_NAME, INTERMEDIATE_RESULT_PRODUCER_EVENT);
-      notifyConsumer(pooledOutputStream, false, fetchState.getConsumer());
+
+    private void maybeHandleIntermediateResult(
+            PooledByteBufferOutputStream pooledOutputStream,
+            FetchState fetchState) {
+        final long nowMs = SystemClock.uptimeMillis();
+        if (shouldPropagateIntermediateResults(fetchState) &&
+                nowMs - fetchState.getLastIntermediateResultTimeMs() >= TIME_BETWEEN_PARTIAL_RESULTS_MS) {
+            fetchState.setLastIntermediateResultTimeMs(nowMs);
+            fetchState.getListener()
+                      .onProducerEvent(fetchState.getId(), PRODUCER_NAME, INTERMEDIATE_RESULT_PRODUCER_EVENT);
+            notifyConsumer(pooledOutputStream, false, fetchState.getConsumer());
+        }
     }
-  }
-
-  private void handleFinalResult(
-      PooledByteBufferOutputStream pooledOutputStream,
-      FetchState fetchState) {
-    Map<String, String> extraMap = getExtraMap(fetchState, pooledOutputStream.size());
-    fetchState.getListener()
-        .onProducerFinishWithSuccess(fetchState.getId(), PRODUCER_NAME, extraMap);
-    notifyConsumer(pooledOutputStream, true, fetchState.getConsumer());
-  }
-
-  private void notifyConsumer(
-      PooledByteBufferOutputStream pooledOutputStream,
-      boolean isFinal,
-      Consumer<EncodedImage> consumer) {
-    CloseableReference<PooledByteBuffer> result =
-        CloseableReference.of(pooledOutputStream.toByteBuffer());
-    EncodedImage encodedImage = null;
-    try {
-      encodedImage = new EncodedImage(result);
-      encodedImage.parseMetaData();
-      consumer.onNewResult(encodedImage, isFinal);
-    } finally {
-      EncodedImage.closeSafely(encodedImage);
-      CloseableReference.closeSafely(result);
+
+    private void handleFinalResult(
+            PooledByteBufferOutputStream pooledOutputStream,
+            FetchState fetchState) {
+        Map<String, String> extraMap = getExtraMap(fetchState, pooledOutputStream.size());
+        fetchState.getListener()
+                  .onProducerFinishWithSuccess(fetchState.getId(), PRODUCER_NAME, extraMap);
+        notifyConsumer(pooledOutputStream, true, fetchState.getConsumer());
+    }
+
+    private void notifyConsumer(
+            PooledByteBufferOutputStream pooledOutputStream,
+            boolean isFinal,
+            Consumer<EncodedImage> consumer) {
+        CloseableReference<PooledByteBuffer> result =
+                CloseableReference.of(pooledOutputStream.toByteBuffer());
+        EncodedImage encodedImage = null;
+        try {
+            //解析图片
+            encodedImage = new EncodedImage(result);
+            encodedImage.parseMetaData();
+
+            //通知新的结果
+            consumer.onNewResult(encodedImage, isFinal);
+        } finally {
+            EncodedImage.closeSafely(encodedImage);
+            CloseableReference.closeSafely(result);
+        }
     }
-  }
-
-  private void onFailure(FetchState fetchState, Throwable e) {
-    fetchState.getListener()
-        .onProducerFinishWithFailure(fetchState.getId(), PRODUCER_NAME, e, null);
-    fetchState.getConsumer().onFailure(e);
-  }
-
-  private void onCancellation(FetchState fetchState) {
-    fetchState.getListener()
-        .onProducerFinishWithCancellation(fetchState.getId(), PRODUCER_NAME, null);
-    fetchState.getConsumer().onCancellation();
-  }
-
-  private boolean shouldPropagateIntermediateResults(FetchState fetchState) {
-    if (!fetchState.getContext().getImageRequest().getProgressiveRenderingEnabled()) {
-      return false;
+
+    private void onFailure(FetchState fetchState, Throwable e) {
+        fetchState.getListener()
+                  .onProducerFinishWithFailure(fetchState.getId(), PRODUCER_NAME, e, null);
+        fetchState.getConsumer().onFailure(e);
     }
-    return mNetworkFetcher.shouldPropagate(fetchState);
-  }
 
-  @Nullable
-  private Map<String, String> getExtraMap(FetchState fetchState, int byteSize) {
-    if (!fetchState.getListener().requiresExtraMap(fetchState.getId())) {
-      return null;
+    private void onCancellation(FetchState fetchState) {
+        fetchState.getListener()
+                  .onProducerFinishWithCancellation(fetchState.getId(), PRODUCER_NAME, null);
+        fetchState.getConsumer().onCancellation();
+    }
+
+    private boolean shouldPropagateIntermediateResults(FetchState fetchState) {
+        if (!fetchState.getContext().getImageRequest().getProgressiveRenderingEnabled()) {
+            return false;
+        }
+        return mNetworkFetcher.shouldPropagate(fetchState);
+    }
+
+    @Nullable
+    private Map<String, String> getExtraMap(FetchState fetchState, int byteSize) {
+        if (!fetchState.getListener().requiresExtraMap(fetchState.getId())) {
+            return null;
+        }
+        return mNetworkFetcher.getExtraMap(fetchState, byteSize);
     }
-    return mNetworkFetcher.getExtraMap(fetchState, byteSize);
-  }
 }
