diff --git a/fresco-large/build.gradle b/fresco-large/build.gradle
index e816b034d..05e39b229 100644
--- a/fresco-large/build.gradle
+++ b/fresco-large/build.gradle
@@ -4,6 +4,7 @@ apply plugin: 'maven'
 project.group = GROUP
 
 dependencies {
+    provided "com.android.support:support-core-utils:${SUPPORT_LIB_VERSION}"
     provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     compile project(':drawee-backends:drawee-pipeline')
 
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/CloseableLargeImage.java b/fresco-large/src/main/java/com/hippo/fresco/large/CloseableLargeImage.java
index 167255308..6c4b1ab20 100644
--- a/fresco-large/src/main/java/com/hippo/fresco/large/CloseableLargeImage.java
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/CloseableLargeImage.java
@@ -14,13 +14,11 @@
 public class CloseableLargeImage extends CloseableImage {
 
   private CloseableReference<ImageRegionDecoder> decoderReference;
-  private final int length;
   private final int width;
   private final int height;
 
-  public CloseableLargeImage(ImageRegionDecoder decoder, int length) {
+  public CloseableLargeImage(ImageRegionDecoder decoder) {
     this.decoderReference = CloseableReference.of(decoder);
-    this.length = length >= 0 ? length : 0;
     this.width = decoder.getWidth();
     this.height = decoder.getHeight();
   }
@@ -42,7 +40,7 @@ public int getHeight() {
 
   @Override
   public int getSizeInBytes() {
-    return length;
+    return decoderReference.get().getSize();
   }
 
   @Override
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/LargeImageDecoder.java b/fresco-large/src/main/java/com/hippo/fresco/large/LargeImageDecoder.java
index 42147165b..f3ee84afb 100644
--- a/fresco-large/src/main/java/com/hippo/fresco/large/LargeImageDecoder.java
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/LargeImageDecoder.java
@@ -94,7 +94,8 @@ public CloseableImage decode(EncodedImage encodedImage, int length, QualityInfo
           ImageRegionDecoder decoder =
               factory.createImageRegionDecoder(encodedImage, options);
           if (decoder != null) {
-            return new CloseableLargeImage(decoder, encodedImage.getSize());
+            decoder.generatePreview(thresholdWidth, thresholdHeight);
+            return new CloseableLargeImage(decoder);
           }
         }
       }
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageRegionDecoder.java b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageRegionDecoder.java
index b667bec44..a45bc10a8 100644
--- a/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageRegionDecoder.java
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageRegionDecoder.java
@@ -10,16 +10,66 @@
 
 import android.graphics.Bitmap;
 import android.graphics.Rect;
+import android.support.annotation.CallSuper;
 
-public interface ImageRegionDecoder extends Closeable {
+import com.facebook.drawee.backends.pipeline.Fresco;
+import com.facebook.imagepipeline.image.EncodedImage;
 
-  int getWidth();
+public abstract class ImageRegionDecoder implements Closeable {
 
-  int getHeight();
+  private Bitmap preview;
+  private int previewSample;
+
+  public abstract int getWidth();
+
+  public abstract int getHeight();
 
   @Nullable
-  Bitmap decode(Rect rect, int sample);
+  public abstract Bitmap decode(Rect rect, int sample);
+
+  private int getSample(int maxWidth, int maxHeight) {
+    int widthScale = (int) Math.floor((float) getWidth() / (float) maxWidth);
+    int heightScale = (int) Math.floor((float) getHeight() / (float) maxHeight);
+    return Math.max(1, Math.max(nextPow2(widthScale), nextPow2(heightScale)));
+  }
 
+  public void generatePreview(int maxWidth, int maxHeight) {
+    Rect rect = new Rect(0, 0, getWidth(), getHeight());
+    previewSample = getSample(maxWidth, maxHeight);
+    preview = decode(rect, previewSample);
+  }
+
+  @Nullable
+  public Bitmap getPreview() {
+    return preview;
+  }
+
+  public int getPreviewSample() {
+    return previewSample;
+  }
+
+  @CallSuper
+  public int getSize() {
+    return preview.getRowBytes() * preview.getHeight();
+  }
+
+  @CallSuper
   @Override
-  void close();
+  public void close() {
+    if (preview != null) {
+      preview.recycle();
+      preview = null;
+    }
+  }
+
+  private static int nextPow2(int n) {
+    if (n == 0) return 1;
+    n -= 1;
+    n |= n >> 1;
+    n |= n >> 2;
+    n |= n >> 4;
+    n |= n >> 8;
+    n |= n >> 16;
+    return n + 1;
+  }
 }
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/decoder/SkiaImageRegionDecoder.java b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/SkiaImageRegionDecoder.java
index 4c02bd78d..6af780816 100644
--- a/fresco-large/src/main/java/com/hippo/fresco/large/decoder/SkiaImageRegionDecoder.java
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/SkiaImageRegionDecoder.java
@@ -11,7 +11,7 @@
 import android.graphics.BitmapRegionDecoder;
 import android.graphics.Rect;
 
-public class SkiaImageRegionDecoder implements ImageRegionDecoder {
+public class SkiaImageRegionDecoder extends ImageRegionDecoder {
 
   private BitmapRegionDecoder decoder;
 
@@ -39,6 +39,7 @@ public Bitmap decode(Rect rect, int sample) {
 
   @Override
   public void close() {
+    super.close();
     decoder.recycle();
   }
 }
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/drawable/SubsamplingDrawable.java b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/SubsamplingDrawable.java
index 2c2e92fbf..7dfabd5fe 100644
--- a/fresco-large/src/main/java/com/hippo/fresco/large/drawable/SubsamplingDrawable.java
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/SubsamplingDrawable.java
@@ -22,7 +22,6 @@
 import android.graphics.RectF;
 import android.graphics.drawable.Drawable;
 import android.os.AsyncTask;
-import android.util.Log;
 import android.util.SparseArray;
 
 import com.facebook.common.references.CloseableReference;
@@ -37,7 +36,8 @@
   private static final boolean DEBUG = false;
 
   private static final int MAX_TILE_SIZE = 512;
-  private static final int FULL_SIZE = MAX_TILE_SIZE * 2;
+
+  private static final int INVALID_SAMPLE = -1;
 
   private ImageRegionDecoder decoder;
   private DecoderReleaser releaser;
@@ -63,21 +63,14 @@
   private int windowOffsetY;
 
   // The visible rect of the image
-  private RectF visibleRectF = new RectF();
-  private Rect visibleRect = new Rect();
-
-  // Sample for current rendered image
-  private int currentSample;
-  // Sample for image fill windows
-  private int fullSample;
-  // Whether draw full sample tiles
-  private boolean drawFullSampleTiles;
-  private final SparseArray<List<Tile>> tilesMap = new SparseArray<>();
+  private final RectF visibleRectF = new RectF();
+  private final Rect visibleRect = new Rect();
 
-  // Full sample tiles count
-  private int fullSampleSize;
-  // Decoded full sample tiles count
-  private int fullSampleDecoderSize;
+  private final PreviewTile preview;
+  private final int previewSample;
+
+  private int currentSample = INVALID_SAMPLE;
+  private final SparseArray<List<Tile>> tilesMap = new SparseArray<>();
 
   private float[] debugPoints;
   private float[] debugLines;
@@ -94,7 +87,8 @@ public SubsamplingDrawable(CloseableReference<ImageRegionDecoder> decoderReferen
     width = decoder.getWidth();
     height = decoder.getHeight();
 
-    setUpFullTiles();
+    previewSample = decoder.getPreviewSample();
+    preview = new PreviewTile(decoder.getPreview(), previewSample);
 
     if (DEBUG) {
       debugPoints = new float[8];
@@ -106,24 +100,6 @@ public SubsamplingDrawable(CloseableReference<ImageRegionDecoder> decoderReferen
     }
   }
 
-  private void setUpFullTiles() {
-    // Get the sample to fill window
-    int fullSample = calculateSample(width / FULL_SIZE, height / FULL_SIZE);
-    this.fullSample = fullSample;
-
-    // Get the tile list to fill window
-    List<Tile> fullTileList = createTileList(fullSample);
-    tilesMap.put(fullSample, fullTileList);
-
-    fullSampleDecoderSize = 0;
-    fullSampleSize = fullTileList.size();
-
-    // Ensure the fill-window tiles list loaded
-    for (Tile tile : fullTileList) {
-      tile.load();
-    }
-  }
-
   public void translate(float dx, float dy) {
     matrix.postTranslate(dx, dy);
     matrixValueDirty = true;
@@ -175,10 +151,6 @@ protected void onBoundsChange(Rect bounds) {
     windowOffsetY = bounds.top;
   }
 
-  private static int calculateSample(int scaleX, int scaleY) {
-    return calculateSample(Math.max(scaleX, scaleY));
-  }
-
   private static int calculateSample(int scale) {
     int sample = Math.max(1, scale);
     return prevPow2(sample);
@@ -192,9 +164,7 @@ private void gc() {
         continue;
       }
 
-      if (sample == fullSample) {
-        // Always keep it
-      } else if (sample == currentSample) {
+      if (sample == currentSample) {
         // Only recycle invisible tiles for current sample
         for (Tile tile : list) {
           if (!tile.isVisible()) {
@@ -250,11 +220,23 @@ private static int getMatrixScale(float[] matrix) {
   }
 
   private int getCurrentSample() {
-    float[] matrixValue = getMatrixValue();
-    int scale = getMatrixScale(matrixValue);
-    currentSample = calculateSample(scale);
-    // Current sample can't be bigger than full sample
-    currentSample = Math.min(currentSample, fullSample);
+    if (previewSample == 1) {
+      // The preview is the most clear, no need tiles
+      currentSample = INVALID_SAMPLE;
+    } else {
+      float[] matrixValue = getMatrixValue();
+      // Get scale from matrix
+      int scale = getMatrixScale(matrixValue);
+      // Get the sample
+      int sample = calculateSample(scale);
+
+      if (sample >= previewSample) {
+        // No need to create tiles which is
+        currentSample = INVALID_SAMPLE;
+      } else {
+        currentSample = sample;
+      }
+    }
     return currentSample;
   }
 
@@ -271,66 +253,32 @@ private Rect getVisibleRect() {
     return visibleRect;
   }
 
-  // Gets the tile which is in full sample and contains this tile
-  private Tile getTheFullSampleTile(Tile tile) {
-    if (tile.sample == fullSample) {
-      return tile;
-    }
-
-    for (Tile fullSampleTile : tilesMap.get(fullSample)) {
-      if (fullSampleTile.contains(tile)) {
-        return fullSampleTile;
-      }
-    }
-
-    throw new RuntimeException("getTheFullSampleTile() should always returns a tile.");
-  }
-
   private void drawTiles(Canvas canvas) {
     // Get current sample
     int currentSample = getCurrentSample();
 
-    // Get tile list for current sample
-    List<Tile> currentTileList = tilesMap.get(currentSample);
-    if (currentTileList == null) {
-      currentTileList = createTileList(currentSample);
-      tilesMap.put(currentSample, currentTileList);
-    }
-
-    // Get visible rect in the image
-    Rect visibleRect = getVisibleRect();
-
-    if (currentSample == fullSample) {
-      // Current sample is full sample
-      // No need to use the full sample tile to fill unloaded current sample tile
-      drawFullSampleTiles = false;
-
-      for (Tile tile : currentTileList) {
-        if (tile.updateVisibility(visibleRect)) {
-          tile.load();
-          tile.draw(canvas, paint, matrix, tempMatrix);
-        }
-      }
+    if (currentSample == INVALID_SAMPLE) {
+      // No current sample, just draw preview
+      preview.draw(canvas, paint, matrix, tempMatrix);
     } else {
-      // Current sample is not full sample
-      // Use the full sample tile to fill unloaded current sample tile
-      drawFullSampleTiles = true;
-
-      // Reset visibility of all tiles in full sample tiles
-      List<Tile> fullTileList = tilesMap.get(fullSample);
-      for (Tile tile : fullTileList) {
-        tile.setVisibility(false);
+      // Get tile list for current sample
+      List<Tile> currentTileList = tilesMap.get(currentSample);
+      if (currentTileList == null) {
+        currentTileList = createTileList(currentSample);
+        tilesMap.put(currentSample, currentTileList);
       }
 
+      // Get visible rect in the image
+      Rect visibleRect = getVisibleRect();
+
+      boolean hasDrawnPreview = false;
       for (Tile tile : currentTileList) {
         if (tile.updateVisibility(visibleRect) && !tile.isLoaded()) {
           tile.load();
-          // The tile doesn't have a bitmap, try to draw a bitmap in full sample tile
-          Tile fullSampleTile = getTheFullSampleTile(tile);
           // Use the visible to mark drew tile to avoid draw it twice
-          if (!fullSampleTile.isVisible()) {
-            fullSampleTile.setVisibility(true);
-            fullSampleTile.draw(canvas, paint, matrix, tempMatrix);
+          if (!hasDrawnPreview) {
+            hasDrawnPreview = true;
+            preview.draw(canvas, paint, matrix, tempMatrix);
           }
         }
       }
@@ -347,7 +295,7 @@ private void drawTiles(Canvas canvas) {
 
   @Override
   public void draw(@Nonnull Canvas canvas) {
-    if (windowWidth > 0 && windowHeight > 0 && fullSampleSize == fullSampleDecoderSize) {
+    if (windowWidth > 0 && windowHeight > 0) {
       drawTiles(canvas);
     }
   }
@@ -419,6 +367,25 @@ private void release() {
     }
   }
 
+  private class PreviewTile {
+
+    private Bitmap bitmap;
+    private int sample;
+
+    public PreviewTile(Bitmap bitmap, int sample) {
+      this.bitmap = bitmap;
+      this.sample = sample;
+    }
+
+    public void draw(Canvas canvas, Paint paint, Matrix matrix, Matrix temp) {
+      if (bitmap != null) {
+        temp.set(matrix);
+        temp.preScale(sample, sample);
+        canvas.drawBitmap(bitmap, temp, paint);
+      }
+    }
+  }
+
   private class Tile {
     public int sample;
     public Rect rect;
@@ -560,16 +527,7 @@ private void onLoaded(Bitmap bitmap) {
       this.task = null;
       this.failed = bitmap == null;
 
-      if (sample == fullSample) {
-        ++fullSampleDecoderSize;
-        if (fullSampleSize == fullSampleDecoderSize) {
-          // All full sample tiles is loaded
-          invalidateSelf();
-        }
-      }
-
-      if (bitmap != null && visible &&
-          (sample == currentSample || (sample == fullSample && drawFullSampleTiles))) {
+      if (bitmap != null && visible && sample == currentSample) {
         invalidateSelf();
       }
     }
