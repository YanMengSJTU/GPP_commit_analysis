diff --git a/.idea/codeStyles/codeStyleSettings.xml b/.idea/codeStyles/codeStyleSettings.xml
deleted file mode 100644
index 6a77eef4a..000000000
--- a/.idea/codeStyles/codeStyleSettings.xml
+++ /dev/null
@@ -1,123 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectCodeStyleSettingsManager">
-    <option name="PER_PROJECT_SETTINGS">
-      <value>
-        <option name="OTHER_INDENT_OPTIONS">
-          <value>
-            <option name="INDENT_SIZE" value="2" />
-            <option name="CONTINUATION_INDENT_SIZE" value="4" />
-            <option name="TAB_SIZE" value="2" />
-            <option name="USE_TAB_CHARACTER" value="false" />
-            <option name="SMART_TABS" value="false" />
-            <option name="LABEL_INDENT_SIZE" value="0" />
-            <option name="LABEL_INDENT_ABSOLUTE" value="false" />
-            <option name="USE_RELATIVE_INDENTS" value="false" />
-          </value>
-        </option>
-        <option name="FIELD_NAME_PREFIX" value="m" />
-        <option name="STATIC_FIELD_NAME_PREFIX" value="s" />
-        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="10000" />
-        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="10000" />
-        <option name="IMPORT_LAYOUT_TABLE">
-          <value>
-            <package name="" withSubpackages="true" static="true" />
-            <emptyLine />
-            <package name="" withSubpackages="true" static="false" />
-          </value>
-        </option>
-        <option name="RIGHT_MARGIN" value="100" />
-        <option name="JD_ALIGN_PARAM_COMMENTS" value="false" />
-        <option name="JD_ALIGN_EXCEPTION_COMMENTS" value="false" />
-        <option name="JD_P_AT_EMPTY_LINES" value="false" />
-        <option name="JD_DO_NOT_WRAP_ONE_LINE_COMMENTS" value="true" />
-        <option name="FORMATTER_TAGS_ENABLED" value="true" />
-        <option name="WRAP_COMMENTS" value="true" />
-        <AndroidXmlCodeStyleSettings>
-          <option name="USE_CUSTOM_SETTINGS" value="true" />
-          <option name="LAYOUT_SETTINGS">
-            <value>
-              <option name="WRAP_ATTRIBUTES" value="1" />
-              <option name="INSERT_LINE_BREAK_AFTER_LAST_ATTRIBUTE" value="true" />
-            </value>
-          </option>
-          <option name="MANIFEST_SETTINGS">
-            <value>
-              <option name="WRAP_ATTRIBUTES" value="1" />
-            </value>
-          </option>
-          <option name="VALUE_RESOURCE_FILE_SETTINGS">
-            <value>
-              <option name="WRAP_ATTRIBUTES" value="1" />
-            </value>
-          </option>
-          <option name="OTHER_SETTINGS">
-            <value>
-              <option name="WRAP_ATTRIBUTES" value="1" />
-            </value>
-          </option>
-        </AndroidXmlCodeStyleSettings>
-        <XML>
-          <option name="XML_TEXT_WRAP" value="0" />
-          <option name="XML_KEEP_BLANK_LINES" value="1" />
-          <option name="XML_ALIGN_ATTRIBUTES" value="false" />
-          <option name="XML_SPACE_INSIDE_EMPTY_TAG" value="true" />
-          <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
-        </XML>
-        <codeStyleSettings language="JAVA">
-          <option name="KEEP_BLANK_LINES_IN_DECLARATIONS" value="1" />
-          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
-          <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="1" />
-          <option name="BLANK_LINES_AFTER_CLASS_HEADER" value="1" />
-          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
-          <option name="CALL_PARAMETERS_WRAP" value="5" />
-          <option name="CALL_PARAMETERS_LPAREN_ON_NEXT_LINE" value="true" />
-          <option name="METHOD_PARAMETERS_WRAP" value="5" />
-          <option name="METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE" value="true" />
-          <option name="RESOURCE_LIST_WRAP" value="5" />
-          <option name="RESOURCE_LIST_LPAREN_ON_NEXT_LINE" value="true" />
-          <option name="EXTENDS_LIST_WRAP" value="1" />
-          <option name="THROWS_LIST_WRAP" value="1" />
-          <option name="EXTENDS_KEYWORD_WRAP" value="1" />
-          <option name="THROWS_KEYWORD_WRAP" value="1" />
-          <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
-          <option name="BINARY_OPERATION_WRAP" value="1" />
-          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
-          <option name="TERNARY_OPERATION_WRAP" value="1" />
-          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
-          <option name="FOR_STATEMENT_WRAP" value="5" />
-          <option name="FOR_STATEMENT_LPAREN_ON_NEXT_LINE" value="true" />
-          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
-          <option name="ASSIGNMENT_WRAP" value="1" />
-          <option name="ASSERT_STATEMENT_WRAP" value="1" />
-          <option name="FIELD_ANNOTATION_WRAP" value="1" />
-          <option name="PARAMETER_ANNOTATION_WRAP" value="1" />
-          <option name="VARIABLE_ANNOTATION_WRAP" value="1" />
-          <option name="ENUM_CONSTANTS_WRAP" value="1" />
-          <indentOptions>
-            <option name="INDENT_SIZE" value="2" />
-            <option name="CONTINUATION_INDENT_SIZE" value="4" />
-            <option name="TAB_SIZE" value="2" />
-          </indentOptions>
-        </codeStyleSettings>
-        <codeStyleSettings language="JavaScript">
-          <option name="WRAP_COMMENTS" value="true" />
-          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
-        </codeStyleSettings>
-        <codeStyleSettings language="TypeScript">
-          <option name="WRAP_COMMENTS" value="true" />
-          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
-        </codeStyleSettings>
-        <codeStyleSettings language="XML">
-          <option name="FORCE_REARRANGE_MODE" value="1" />
-          <indentOptions>
-            <option name="INDENT_SIZE" value="2" />
-            <option name="CONTINUATION_INDENT_SIZE" value="4" />
-            <option name="TAB_SIZE" value="2" />
-          </indentOptions>
-        </codeStyleSettings>
-      </value>
-    </option>
-    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/fbcore/src/main/java/com/facebook/common/util/UriUtil.java b/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
index 5e2617740..50daa7b3f 100644
--- a/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
+++ b/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
@@ -24,6 +24,11 @@
   public static final String HTTP_SCHEME = "http";
   public static final String HTTPS_SCHEME = "https";
 
+  /**
+   * Embedded scheme for URIs
+   */
+  public static final String EMBEDDED_SCHEME = "embedded";
+
   /**
    * File scheme for URIs
    */
@@ -79,6 +84,11 @@ public static URL uriToUrl(@Nullable Uri uri) {
     }
   }
 
+  public static boolean isEmbeddedUri(@Nullable Uri uri){
+    final String scheme = getSchemeOrNull(uri);
+    return EMBEDDED_SCHEME.equals(scheme);
+  }
+
   /**
    * Check if uri represents network resource
    *
diff --git a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/SourceUriType.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/SourceUriType.java
index 82773f648..b24395031 100644
--- a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/SourceUriType.java
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/common/SourceUriType.java
@@ -7,6 +7,7 @@
 package com.facebook.imagepipeline.common;
 
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_DATA;
+import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_EMBEDDED_RESOURCE;
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_LOCAL_ASSET;
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_LOCAL_CONTENT;
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_LOCAL_FILE;
@@ -22,8 +23,7 @@
 import java.lang.annotation.Retention;
 
 /**
- * This is the interface we use in order to define different types of Uri an ImageRequest
- * can have.
+ * This is the interface we use in order to define different types of Uri an ImageRequest can have.
  */
 @Retention(SOURCE)
 @IntDef({
@@ -36,7 +36,8 @@
     SOURCE_TYPE_LOCAL_ASSET,
     SOURCE_TYPE_LOCAL_RESOURCE,
     SOURCE_TYPE_DATA,
-    SOURCE_TYPE_QUALIFIED_RESOURCE
+    SOURCE_TYPE_QUALIFIED_RESOURCE,
+    SOURCE_TYPE_EMBEDDED_RESOURCE
 })
 public @interface SourceUriType {
 
@@ -50,4 +51,5 @@
   int SOURCE_TYPE_LOCAL_RESOURCE = 6;
   int SOURCE_TYPE_DATA = 7;
   int SOURCE_TYPE_QUALIFIED_RESOURCE = 8;
+  int SOURCE_TYPE_EMBEDDED_RESOURCE = 9;
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
index e9b5671a2..fb8ac7c95 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
@@ -34,6 +34,7 @@
 import com.facebook.imagepipeline.producers.DecodeProducer;
 import com.facebook.imagepipeline.producers.DiskCacheReadProducer;
 import com.facebook.imagepipeline.producers.DiskCacheWriteProducer;
+import com.facebook.imagepipeline.producers.EmbeddedProducer;
 import com.facebook.imagepipeline.producers.EncodedCacheKeyMultiplexProducer;
 import com.facebook.imagepipeline.producers.EncodedMemoryCacheProducer;
 import com.facebook.imagepipeline.producers.LocalAssetFetchProducer;
@@ -361,4 +362,10 @@ public BitmapPrepareProducer newBitmapPrepareProducer(
         mBitmapPrepareToDrawMaxSizeBytes,
         mBitmapPrepareToDrawForPrefetch);
   }
+
+  public EmbeddedProducer newEmbeddedProducer() {
+    return new EmbeddedProducer(
+        mExecutorSupplier.forLocalStorageRead(),
+        mContentResolver);
+  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
index 15cb9d6f1..76adcb799 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
@@ -8,6 +8,7 @@
 package com.facebook.imagepipeline.core;
 
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_DATA;
+import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_EMBEDDED_RESOURCE;
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_LOCAL_ASSET;
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_LOCAL_CONTENT;
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_LOCAL_IMAGE_FILE;
@@ -30,6 +31,7 @@
 import com.facebook.imagepipeline.producers.BitmapMemoryCacheProducer;
 import com.facebook.imagepipeline.producers.DecodeProducer;
 import com.facebook.imagepipeline.producers.DiskCacheReadProducer;
+import com.facebook.imagepipeline.producers.EmbeddedProducer;
 import com.facebook.imagepipeline.producers.EncodedMemoryCacheProducer;
 import com.facebook.imagepipeline.producers.LocalAssetFetchProducer;
 import com.facebook.imagepipeline.producers.LocalContentUriFetchProducer;
@@ -70,30 +72,49 @@
   private final ImageTranscoderFactory mImageTranscoderFactory;
 
   // Saved sequences
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mNetworkFetchSequence;
-  @VisibleForTesting Producer<EncodedImage> mBackgroundLocalFileFetchToEncodedMemorySequence;
-  @VisibleForTesting Producer<EncodedImage> mBackgroundNetworkFetchToEncodedMemorySequence;
-  @VisibleForTesting Producer<CloseableReference<PooledByteBuffer>>
+  @VisibleForTesting
+  Producer<CloseableReference<CloseableImage>> mNetworkFetchSequence;
+  @VisibleForTesting
+  Producer<EncodedImage> mBackgroundLocalFileFetchToEncodedMemorySequence;
+  @VisibleForTesting
+  Producer<EncodedImage> mBackgroundNetworkFetchToEncodedMemorySequence;
+  @VisibleForTesting
+  Producer<CloseableReference<PooledByteBuffer>>
       mLocalFileEncodedImageProducerSequence;
-  @VisibleForTesting Producer<CloseableReference<PooledByteBuffer>>
+  @VisibleForTesting
+  Producer<CloseableReference<PooledByteBuffer>>
       mNetworkEncodedImageProducerSequence;
-  @VisibleForTesting Producer<Void> mLocalFileFetchToEncodedMemoryPrefetchSequence;
-  @VisibleForTesting Producer<Void> mNetworkFetchToEncodedMemoryPrefetchSequence;
+  @VisibleForTesting
+  Producer<Void> mLocalFileFetchToEncodedMemoryPrefetchSequence;
+  @VisibleForTesting
+  Producer<Void> mNetworkFetchToEncodedMemoryPrefetchSequence;
   private Producer<EncodedImage> mCommonNetworkFetchToEncodedMemorySequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalImageFileFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalVideoFileFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalContentUriFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalResourceFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalAssetFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mDataFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mQualifiedResourceFetchSequence;
-  @VisibleForTesting Map<
+  @VisibleForTesting
+  Producer<CloseableReference<CloseableImage>> mLocalImageFileFetchSequence;
+  @VisibleForTesting
+  Producer<CloseableReference<CloseableImage>> mLocalVideoFileFetchSequence;
+  @VisibleForTesting
+  Producer<CloseableReference<CloseableImage>> mLocalContentUriFetchSequence;
+  @VisibleForTesting
+  Producer<CloseableReference<CloseableImage>> mLocalResourceFetchSequence;
+  @VisibleForTesting
+  Producer<CloseableReference<CloseableImage>> mLocalAssetFetchSequence;
+  @VisibleForTesting
+  Producer<CloseableReference<CloseableImage>> mDataFetchSequence;
+  @VisibleForTesting
+  Producer<CloseableReference<CloseableImage>> mQualifiedResourceFetchSequence;
+  @VisibleForTesting
+  Producer<CloseableReference<CloseableImage>> mEmbeddedFetchSequence;
+  @VisibleForTesting
+  Map<
       Producer<CloseableReference<CloseableImage>>,
       Producer<CloseableReference<CloseableImage>>>
       mPostprocessorSequences;
-  @VisibleForTesting Map<Producer<CloseableReference<CloseableImage>>, Producer<Void>>
+  @VisibleForTesting
+  Map<Producer<CloseableReference<CloseableImage>>, Producer<Void>>
       mCloseableImagePrefetchSequences;
-  @VisibleForTesting Map<
+  @VisibleForTesting
+  Map<
       Producer<CloseableReference<CloseableImage>>,
       Producer<CloseableReference<CloseableImage>>>
       mBitmapPrepareSequences;
@@ -151,7 +172,7 @@ public ProducerSequenceFactory(
               "Unsupported uri scheme for encoded image fetch! Uri is: "
                   + getShortenedUriString(uri));
       }
-    } finally{
+    } finally {
       FrescoSystrace.endSection();
     }
   }
@@ -162,9 +183,11 @@ public ProducerSequenceFactory(
   public Producer<CloseableReference<PooledByteBuffer>>
   getNetworkFetchEncodedImageProducerSequence() {
     synchronized (this) {
-      FrescoSystrace.beginSection("ProducerSequenceFactory#getNetworkFetchEncodedImageProducerSequence");
+      FrescoSystrace
+          .beginSection("ProducerSequenceFactory#getNetworkFetchEncodedImageProducerSequence");
       if (mNetworkEncodedImageProducerSequence == null) {
-        FrescoSystrace.beginSection("ProducerSequenceFactory#getNetworkFetchEncodedImageProducerSequence:init");
+        FrescoSystrace.beginSection(
+            "ProducerSequenceFactory#getNetworkFetchEncodedImageProducerSequence:init");
         mNetworkEncodedImageProducerSequence = new RemoveImageTransformMetaDataProducer(
             getBackgroundNetworkFetchToEncodedMemorySequence());
         FrescoSystrace.endSection();
@@ -180,9 +203,11 @@ public ProducerSequenceFactory(
   public Producer<CloseableReference<PooledByteBuffer>>
   getLocalFileFetchEncodedImageProducerSequence() {
     synchronized (this) {
-      FrescoSystrace.beginSection("ProducerSequenceFactory#getLocalFileFetchEncodedImageProducerSequence");
+      FrescoSystrace
+          .beginSection("ProducerSequenceFactory#getLocalFileFetchEncodedImageProducerSequence");
       if (mLocalFileEncodedImageProducerSequence == null) {
-        FrescoSystrace.beginSection("ProducerSequenceFactory#getLocalFileFetchEncodedImageProducerSequence:init");
+        FrescoSystrace.beginSection(
+            "ProducerSequenceFactory#getLocalFileFetchEncodedImageProducerSequence:init");
         mLocalFileEncodedImageProducerSequence = new RemoveImageTransformMetaDataProducer(
             getBackgroundLocalFileFetchToEncodeMemorySequence());
         FrescoSystrace.endSection();
@@ -195,9 +220,9 @@ public ProducerSequenceFactory(
   /**
    * Returns a sequence that can be used for a prefetch request for an encoded image.
    *
-   * <p>Guaranteed to return the same sequence as
-   * {@code getEncodedImageProducerSequence(request)}, except that it is pre-pended with a
-   * {@link SwallowResultProducer}.
+   * <p>Guaranteed to return the same sequence as {@code getEncodedImageProducerSequence(request)},
+   * except that it is pre-pended with a {@link SwallowResultProducer}.
+   *
    * @param imageRequest the request that will be submitted
    * @return the sequence that should be used to process the request
    */
@@ -276,6 +301,8 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
       Preconditions.checkNotNull(uri, "Uri is null.");
 
       switch (imageRequest.getSourceUriType()) {
+        case SOURCE_TYPE_EMBEDDED_RESOURCE:
+          return getEmbeddedFetchSequence();
         case SOURCE_TYPE_NETWORK:
           return getNetworkFetchSequence();
         case SOURCE_TYPE_LOCAL_VIDEO_FILE:
@@ -299,15 +326,25 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
           throw new IllegalArgumentException(
               "Unsupported uri scheme! Uri is: " + getShortenedUriString(uri));
       }
-    } finally{
+    } finally {
       FrescoSystrace.endSection();
     }
   }
 
+  private synchronized Producer<CloseableReference<CloseableImage>> getEmbeddedFetchSequence() {
+    if (mEmbeddedFetchSequence == null) {
+      EmbeddedProducer embeddedProducer =
+          mProducerFactory.newEmbeddedProducer();
+      mEmbeddedFetchSequence =
+          newBitmapCacheGetToBitmapCacheSequence(embeddedProducer);
+    }
+    return mEmbeddedFetchSequence;
+  }
+
   /**
-   * swallow result if prefetch -> bitmap cache get ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode -> multiplex ->
-   * encoded cache -> disk cache -> (webp transcode) -> network fetch.
+   * swallow result if prefetch -> bitmap cache get -> background thread hand-off -> multiplex ->
+   * bitmap cache -> decode -> multiplex -> encoded cache -> disk cache -> (webp transcode) ->
+   * network fetch.
    */
   private synchronized Producer<CloseableReference<CloseableImage>> getNetworkFetchSequence() {
     FrescoSystrace.beginSection("ProducerSequenceFactory#getNetworkFetchSequence");
@@ -322,13 +359,15 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * background-thread hand-off -> multiplex -> encoded cache ->
-   * disk cache -> (webp transcode) -> network fetch.
+   * background-thread hand-off -> multiplex -> encoded cache -> disk cache -> (webp transcode) ->
+   * network fetch.
    */
   private synchronized Producer<EncodedImage> getBackgroundNetworkFetchToEncodedMemorySequence() {
-    FrescoSystrace.beginSection("ProducerSequenceFactory#getBackgroundNetworkFetchToEncodedMemorySequence");
+    FrescoSystrace
+        .beginSection("ProducerSequenceFactory#getBackgroundNetworkFetchToEncodedMemorySequence");
     if (mBackgroundNetworkFetchToEncodedMemorySequence == null) {
-      FrescoSystrace.beginSection("ProducerSequenceFactory#getBackgroundNetworkFetchToEncodedMemorySequence:init");
+      FrescoSystrace.beginSection(
+          "ProducerSequenceFactory#getBackgroundNetworkFetchToEncodedMemorySequence:init");
       // Use hand-off producer to ensure that we don't do any unnecessary work on the UI thread.
       mBackgroundNetworkFetchToEncodedMemorySequence =
           mProducerFactory.newBackgroundThreadHandoffProducer(
@@ -341,13 +380,15 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * swallow-result -> background-thread hand-off -> multiplex -> encoded cache ->
-   * disk cache -> (webp transcode) -> network fetch.
+   * swallow-result -> background-thread hand-off -> multiplex -> encoded cache -> disk cache ->
+   * (webp transcode) -> network fetch.
    */
   private synchronized Producer<Void> getNetworkFetchToEncodedMemoryPrefetchSequence() {
-    FrescoSystrace.beginSection("ProducerSequenceFactory#getNetworkFetchToEncodedMemoryPrefetchSequence");
+    FrescoSystrace
+        .beginSection("ProducerSequenceFactory#getNetworkFetchToEncodedMemoryPrefetchSequence");
     if (mNetworkFetchToEncodedMemoryPrefetchSequence == null) {
-      FrescoSystrace.beginSection("ProducerSequenceFactory#getNetworkFetchToEncodedMemoryPrefetchSequence:init");
+      FrescoSystrace.beginSection(
+          "ProducerSequenceFactory#getNetworkFetchToEncodedMemoryPrefetchSequence:init");
       mNetworkFetchToEncodedMemoryPrefetchSequence =
           ProducerFactory.newSwallowResultProducer(
               getBackgroundNetworkFetchToEncodedMemorySequence());
@@ -361,9 +402,11 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
    * multiplex -> encoded cache -> disk cache -> (webp transcode) -> network fetch.
    */
   private synchronized Producer<EncodedImage> getCommonNetworkFetchToEncodedMemorySequence() {
-    FrescoSystrace.beginSection("ProducerSequenceFactory#getCommonNetworkFetchToEncodedMemorySequence");
+    FrescoSystrace
+        .beginSection("ProducerSequenceFactory#getCommonNetworkFetchToEncodedMemorySequence");
     if (mCommonNetworkFetchToEncodedMemorySequence == null) {
-      FrescoSystrace.beginSection("ProducerSequenceFactory#getCommonNetworkFetchToEncodedMemorySequence:init");
+      FrescoSystrace.beginSection(
+          "ProducerSequenceFactory#getCommonNetworkFetchToEncodedMemorySequence:init");
       Producer<EncodedImage> inputProducer =
           newEncodedCacheMultiplexToTranscodeSequence(
               mProducerFactory.newNetworkFetchProducer(mNetworkFetcher));
@@ -382,13 +425,15 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * swallow-result -> background-thread hand-off -> multiplex -> encoded cache ->
-   * disk cache -> (webp transcode) -> local file fetch.
+   * swallow-result -> background-thread hand-off -> multiplex -> encoded cache -> disk cache ->
+   * (webp transcode) -> local file fetch.
    */
   private synchronized Producer<Void> getLocalFileFetchToEncodedMemoryPrefetchSequence() {
-    FrescoSystrace.beginSection("ProducerSequenceFactory#getLocalFileFetchToEncodedMemoryPrefetchSequence");
+    FrescoSystrace
+        .beginSection("ProducerSequenceFactory#getLocalFileFetchToEncodedMemoryPrefetchSequence");
     if (mLocalFileFetchToEncodedMemoryPrefetchSequence == null) {
-      FrescoSystrace.beginSection("ProducerSequenceFactory#getLocalFileFetchToEncodedMemoryPrefetchSequence:init");
+      FrescoSystrace.beginSection(
+          "ProducerSequenceFactory#getLocalFileFetchToEncodedMemoryPrefetchSequence:init");
       mLocalFileFetchToEncodedMemoryPrefetchSequence =
           ProducerFactory.newSwallowResultProducer(
               getBackgroundLocalFileFetchToEncodeMemorySequence());
@@ -399,13 +444,15 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * background-thread hand-off -> multiplex -> encoded cache ->
-   * disk cache -> (webp transcode) -> local file fetch
+   * background-thread hand-off -> multiplex -> encoded cache -> disk cache -> (webp transcode) ->
+   * local file fetch
    */
   private synchronized Producer<EncodedImage> getBackgroundLocalFileFetchToEncodeMemorySequence() {
-    FrescoSystrace.beginSection("ProducerSequenceFactory#getBackgroundLocalFileFetchToEncodeMemorySequence");
+    FrescoSystrace
+        .beginSection("ProducerSequenceFactory#getBackgroundLocalFileFetchToEncodeMemorySequence");
     if (mBackgroundLocalFileFetchToEncodedMemorySequence == null) {
-      FrescoSystrace.beginSection("ProducerSequenceFactory#getBackgroundLocalFileFetchToEncodeMemorySequence:init");
+      FrescoSystrace.beginSection(
+          "ProducerSequenceFactory#getBackgroundLocalFileFetchToEncodeMemorySequence:init");
       final LocalFileFetchProducer localFileFetchProducer =
           mProducerFactory.newLocalFileFetchProducer();
 
@@ -423,12 +470,10 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * bitmap cache get ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode ->
-   * branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
-   *   -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
-   *   (webp transcode) -> local file fetch.
+   * bitmap cache get -> background thread hand-off -> multiplex -> bitmap cache -> decode -> branch
+   * on separate images -> exif resize and rotate -> exif thumbnail creation -> local image resize
+   * and rotate -> add meta data producer -> multiplex -> encoded cache -> (webp transcode) -> local
+   * file fetch.
    */
   private synchronized Producer<CloseableReference<CloseableImage>>
   getLocalImageFileFetchSequence() {
@@ -442,8 +487,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * Bitmap cache get -> thread hand off -> multiplex -> bitmap cache ->
-   * local video thumbnail
+   * Bitmap cache get -> thread hand off -> multiplex -> bitmap cache -> local video thumbnail
    */
   private synchronized Producer<CloseableReference<CloseableImage>>
   getLocalVideoFileFetchSequence() {
@@ -457,14 +501,10 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * bitmap cache get ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode ->
-   * branch on separate images
-   *   -> thumbnail resize and rotate -> thumbnail branch
-   *     -> local content thumbnail creation
-   *     -> exif thumbnail creation
-   *   -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
-   *   (webp transcode) -> local content uri fetch.
+   * bitmap cache get -> background thread hand-off -> multiplex -> bitmap cache -> decode -> branch
+   * on separate images -> thumbnail resize and rotate -> thumbnail branch -> local content
+   * thumbnail creation -> exif thumbnail creation -> local image resize and rotate -> add meta data
+   * producer -> multiplex -> encoded cache -> (webp transcode) -> local content uri fetch.
    */
   private synchronized Producer<CloseableReference<CloseableImage>>
   getLocalContentUriFetchSequence() {
@@ -484,12 +524,10 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * bitmap cache get ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode ->
-   * branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
-   *   -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
-   *   (webp transcode) -> qualified resource fetch.
+   * bitmap cache get -> background thread hand-off -> multiplex -> bitmap cache -> decode -> branch
+   * on separate images -> exif resize and rotate -> exif thumbnail creation -> local image resize
+   * and rotate -> add meta data producer -> multiplex -> encoded cache -> (webp transcode) ->
+   * qualified resource fetch.
    */
   private synchronized Producer<CloseableReference<CloseableImage>>
   getQualifiedResourceFetchSequence() {
@@ -503,12 +541,10 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * bitmap cache get ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode ->
-   * branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
-   *   -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
-   *   (webp transcode) -> local resource fetch.
+   * bitmap cache get -> background thread hand-off -> multiplex -> bitmap cache -> decode -> branch
+   * on separate images -> exif resize and rotate -> exif thumbnail creation -> local image resize
+   * and rotate -> add meta data producer -> multiplex -> encoded cache -> (webp transcode) -> local
+   * resource fetch.
    */
   private synchronized Producer<CloseableReference<CloseableImage>>
   getLocalResourceFetchSequence() {
@@ -522,12 +558,10 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * bitmap cache get ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode ->
-   * branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
-   *   -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
-   *   (webp transcode) -> local asset fetch.
+   * bitmap cache get -> background thread hand-off -> multiplex -> bitmap cache -> decode -> branch
+   * on separate images -> exif resize and rotate -> exif thumbnail creation -> local image resize
+   * and rotate -> add meta data producer -> multiplex -> encoded cache -> (webp transcode) -> local
+   * asset fetch.
    */
   private synchronized Producer<CloseableReference<CloseableImage>> getLocalAssetFetchSequence() {
     if (mLocalAssetFetchSequence == null) {
@@ -540,9 +574,8 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * bitmap cache get ->
-   * background thread hand-off -> bitmap cache -> decode -> resize and rotate -> (webp transcode)
-   * -> data fetch.
+   * bitmap cache get -> background thread hand-off -> bitmap cache -> decode -> resize and rotate
+   * -> (webp transcode) -> data fetch.
    */
   private synchronized Producer<CloseableReference<CloseableImage>> getDataFetchSequence() {
     if (mDataFetchSequence == null) {
@@ -561,6 +594,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
 
   /**
    * Creates a new fetch sequence that just needs the source producer.
+   *
    * @param inputProducer the source producer
    * @return the new sequence
    */
@@ -573,6 +607,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
 
   /**
    * Creates a new fetch sequence that just needs the source producer.
+   *
    * @param inputProducer the source producer
    * @param thumbnailProducers the thumbnail producers from which to request the image before
    * falling back to the full image producer sequence
@@ -589,6 +624,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
 
   /**
    * Same as {@code newBitmapCacheGetToBitmapCacheSequence} but with an extra DecodeProducer.
+   *
    * @param inputProducer producer providing the input to the decode
    * @return bitmap cache get to decode sequence
    */
@@ -604,6 +640,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
 
   /**
    * encoded cache multiplex -> encoded cache -> (disk cache) -> (webp transcode)
+   *
    * @param inputProducer producer providing the input to the transcode
    * @return encoded cache multiplex to webp transcode sequence
    */
@@ -638,6 +675,7 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
 
   /**
    * Bitmap cache get -> thread hand off -> multiplex -> bitmap cache
+   *
    * @param inputProducer producer providing the input to the bitmap cache
    * @return bitmap cache get to bitmap cache sequence
    */
@@ -655,9 +693,9 @@ private static void validateEncodedImageRequest(ImageRequest imageRequest) {
   }
 
   /**
-   * Branch on separate images
-   *   -> thumbnail resize and rotate -> thumbnail producers as provided
-   *   -> local image resize and rotate -> add meta data producer
+   * Branch on separate images -> thumbnail resize and rotate -> thumbnail producers as provided ->
+   * local image resize and rotate -> add meta data producer
+   *
    * @param inputProducer producer providing the input to add meta data producer
    * @param thumbnailProducers the thumbnail producers from which to request the image before
    * falling back to the full image producer sequence
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EmbeddedProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EmbeddedProducer.java
new file mode 100644
index 000000000..d82b6d2fe
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EmbeddedProducer.java
@@ -0,0 +1,148 @@
+package com.facebook.imagepipeline.producers;
+
+import android.annotation.TargetApi;
+import android.content.ContentResolver;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.media.MediaMetadataRetriever;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.provider.DocumentsContract;
+import android.provider.MediaStore;
+import android.support.annotation.Nullable;
+import com.facebook.common.internal.ImmutableMap;
+import com.facebook.common.internal.VisibleForTesting;
+import com.facebook.common.references.CloseableReference;
+import com.facebook.common.util.UriUtil;
+import com.facebook.imagepipeline.bitmaps.SimpleBitmapReleaser;
+import com.facebook.imagepipeline.image.CloseableImage;
+import com.facebook.imagepipeline.image.CloseableStaticBitmap;
+import com.facebook.imagepipeline.image.ImmutableQualityInfo;
+import com.facebook.imagepipeline.request.ImageRequest;
+import java.util.Map;
+import java.util.concurrent.Executor;
+
+public class EmbeddedProducer implements Producer<CloseableReference<CloseableImage>> {
+
+  public static final String PRODUCER_NAME = "AudioThumbnailProducer";
+  @VisibleForTesting
+  static final String CREATED_THUMBNAIL = "createdThumbnail";
+  private final Executor mExecutor;
+  private final ContentResolver mContentResolver;
+
+  public EmbeddedProducer(Executor executor, ContentResolver contentResolver) {
+    mExecutor = executor;
+    mContentResolver = contentResolver;
+  }
+
+  @TargetApi(VERSION_CODES.GINGERBREAD_MR1)
+  @Override
+  public void produceResults(
+      final Consumer<CloseableReference<CloseableImage>> consumer,
+      final ProducerContext producerContext) {
+    final ProducerListener listener = producerContext.getListener();
+    final String requestId = producerContext.getId();
+    final ImageRequest imageRequest = producerContext.getImageRequest();
+    final StatefulProducerRunnable cancellableProducerRunnable =
+        new StatefulProducerRunnable<CloseableReference<CloseableImage>>(
+            consumer,
+            listener,
+            PRODUCER_NAME,
+            requestId) {
+          @Override
+          protected void onSuccess(CloseableReference<CloseableImage> result) {
+            super.onSuccess(result);
+            listener.onUltimateProducerReached(requestId, PRODUCER_NAME, result != null);
+          }
+
+          @Override
+          protected void onFailure(Exception e) {
+            super.onFailure(e);
+            listener.onUltimateProducerReached(requestId, PRODUCER_NAME, false);
+          }
+
+
+          @Override
+          protected CloseableReference<CloseableImage> getResult() throws Exception {
+            String path = getLocalFilePath(imageRequest);
+            if (path == null) {
+              return null;
+            }
+            byte[] bitmapData;
+            MediaMetadataRetriever retriever = new MediaMetadataRetriever();
+            try {
+              retriever.setDataSource(path);
+              bitmapData = retriever.getEmbeddedPicture();
+            } finally {
+              retriever.release();
+            }
+            if (bitmapData == null) {
+              return null;
+            }
+            Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
+            if (bitmap == null) {
+              return null;
+            }
+            return CloseableReference.<CloseableImage>of(
+                new CloseableStaticBitmap(
+                    bitmap,
+                    SimpleBitmapReleaser.getInstance(),
+                    ImmutableQualityInfo.FULL_QUALITY,
+                    0));
+          }
+
+          @Override
+          protected Map<String, String> getExtraMapOnSuccess(
+              final CloseableReference<CloseableImage> result) {
+            return ImmutableMap.of(CREATED_THUMBNAIL, String.valueOf(result != null));
+          }
+
+          @Override
+          protected void disposeResult(CloseableReference<CloseableImage> result) {
+            CloseableReference.closeSafely(result);
+          }
+        };
+    producerContext.addCallbacks(
+        new BaseProducerContextCallbacks() {
+          @Override
+          public void onCancellationRequested() {
+            cancellableProducerRunnable.cancel();
+          }
+        });
+    mExecutor.execute(cancellableProducerRunnable);
+  }
+
+  @Nullable
+  private String getLocalFilePath(ImageRequest imageRequest) {
+    final Uri uri = imageRequest.getSourceUri();
+    return uri != null ? uri.getPath() : null;
+//    if (UriUtil.isLocalFileUri(uri)) {
+//      return imageRequest.getSourceFile().getPath();
+//    } else if (UriUtil.isLocalContentUri(uri)) {
+//      String selection = null;
+//      String[] selectionArgs = null;
+//      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
+//          && "com.android.providers.media.documents".equals(uri.getAuthority())) {
+//        String documentId = DocumentsContract.getDocumentId(uri);
+//        uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
+//        selection = MediaStore.Audio.Media._ID + "=?";
+//        selectionArgs = new String[]{documentId.split(":")[1]};
+//      }
+//      Cursor cursor =
+//          mContentResolver.query(
+//              uri, new String[]{MediaStore.Audio.Media.DATA}, selection, selectionArgs, null);
+//      try {
+//        if (cursor != null && cursor.moveToFirst()) {
+//          return cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATA));
+//        }
+//      } finally {
+//        if (cursor != null) {
+//          cursor.close();
+//        }
+//      }
+//    }
+//    return null;
+  }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequest.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequest.java
index 5a9ae3dd1..d3d19a853 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequest.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequest.java
@@ -8,6 +8,7 @@
 package com.facebook.imagepipeline.request;
 
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_DATA;
+import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_EMBEDDED_RESOURCE;
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_LOCAL_ASSET;
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_LOCAL_CONTENT;
 import static com.facebook.imagepipeline.common.SourceUriType.SOURCE_TYPE_LOCAL_IMAGE_FILE;
@@ -40,51 +41,84 @@
 @Immutable
 public class ImageRequest {
 
-  /** Cache choice */
+  /**
+   * Cache choice
+   */
   private final CacheChoice mCacheChoice;
 
-  /** Source Uri */
+  /**
+   * Source Uri
+   */
   private final Uri mSourceUri;
 
-  private final @SourceUriType int mSourceUriType;
+  private final @SourceUriType
+  int mSourceUriType;
 
-  /** Source File - for local fetches only, lazily initialized */
+  /**
+   * Source File - for local fetches only, lazily initialized
+   */
   private File mSourceFile;
 
-  /** If set - the client will receive intermediate results */
+  /**
+   * If set - the client will receive intermediate results
+   */
   private final boolean mProgressiveRenderingEnabled;
 
-  /** If set the client will receive thumbnail previews for local images, before the whole image */
+  /**
+   * If set the client will receive thumbnail previews for local images, before the whole image
+   */
   private final boolean mLocalThumbnailPreviewsEnabled;
 
   private final ImageDecodeOptions mImageDecodeOptions;
 
-  /** resize options */
-  private final @Nullable ResizeOptions mResizeOptions;
+  /**
+   * resize options
+   */
+  private final @Nullable
+  ResizeOptions mResizeOptions;
 
-  /** rotation options */
+  /**
+   * rotation options
+   */
   private final RotationOptions mRotationOptions;
 
-  /** Range of bytes to request from the network */
-  private final @Nullable BytesRange mBytesRange;
+  /**
+   * Range of bytes to request from the network
+   */
+  private final @Nullable
+  BytesRange mBytesRange;
 
-  /** Priority levels of this request. */
+  /**
+   * Priority levels of this request.
+   */
   private final Priority mRequestPriority;
 
-  /** Lowest level that is permitted to fetch an image from */
+  /**
+   * Lowest level that is permitted to fetch an image from
+   */
   private final RequestLevel mLowestPermittedRequestLevel;
 
-  /** Whether the disk cache should be used for this request */
+  /**
+   * Whether the disk cache should be used for this request
+   */
   private final boolean mIsDiskCacheEnabled;
 
-  /** Whether the memory cache should be used for this request */
+  /**
+   * Whether the memory cache should be used for this request
+   */
   private final boolean mIsMemoryCacheEnabled;
 
-  /** Postprocessor to run on the output bitmap. */
-  private final @Nullable Postprocessor mPostprocessor;
+  /**
+   * Postprocessor to run on the output bitmap.
+   */
+  private final @Nullable
+  Postprocessor mPostprocessor;
 
-  /** Request listener to use for this image request */
-  private final @Nullable RequestListener mRequestListener;
+  /**
+   * Request listener to use for this image request
+   */
+  private final @Nullable
+  RequestListener mRequestListener;
 
   public static ImageRequest fromFile(@Nullable File file) {
     return (file == null) ? null : ImageRequest.fromUri(UriUtil.getUriForFile(file));
@@ -131,7 +165,8 @@ public Uri getSourceUri() {
     return mSourceUri;
   }
 
-  public @SourceUriType int getSourceUriType() {
+  public @SourceUriType
+  int getSourceUriType() {
     return mSourceUriType;
   }
 
@@ -143,7 +178,8 @@ public int getPreferredHeight() {
     return (mResizeOptions != null) ? mResizeOptions.height : (int) BitmapUtil.MAX_BITMAP_SIZE;
   }
 
-  public @Nullable ResizeOptions getResizeOptions() {
+  public @Nullable
+  ResizeOptions getResizeOptions() {
     return mResizeOptions;
   }
 
@@ -199,11 +235,13 @@ public synchronized File getSourceFile() {
     return mSourceFile;
   }
 
-  public @Nullable Postprocessor getPostprocessor() {
+  public @Nullable
+  Postprocessor getPostprocessor() {
     return mPostprocessor;
   }
 
-  public @Nullable RequestListener getRequestListener() {
+  public @Nullable
+  RequestListener getRequestListener() {
     return mRequestListener;
   }
 
@@ -304,15 +342,19 @@ public static RequestLevel getMax(RequestLevel requestLevel1, RequestLevel reque
 
   /**
    * This is a utility method which returns the type of Uri
+   *
    * @param uri The Uri to test
    * @return The type of the given Uri if available or SOURCE_TYPE_UNKNOWN if not
    */
-  private static @SourceUriType int getSourceUriType(final Uri uri) {
+  private static @SourceUriType
+  int getSourceUriType(final Uri uri) {
     if (uri == null) {
       return SOURCE_TYPE_UNKNOWN;
     }
     if (UriUtil.isNetworkUri(uri)) {
       return SOURCE_TYPE_NETWORK;
+    } else if (UriUtil.isEmbeddedUri(uri)) {
+      return SOURCE_TYPE_EMBEDDED_RESOURCE;
     } else if (UriUtil.isLocalFileUri(uri)) {
       if (MediaUtils.isVideo(MediaUtils.extractMime(uri.getPath()))) {
         return SOURCE_TYPE_LOCAL_VIDEO_FILE;
@@ -327,7 +369,7 @@ public static RequestLevel getMax(RequestLevel requestLevel1, RequestLevel reque
       return SOURCE_TYPE_LOCAL_RESOURCE;
     } else if (UriUtil.isDataUri(uri)) {
       return SOURCE_TYPE_DATA;
-    } else if (UriUtil.isQualifiedResourceUri(uri))  {
+    } else if (UriUtil.isQualifiedResourceUri(uri)) {
       return SOURCE_TYPE_QUALIFIED_RESOURCE;
     } else {
       return SOURCE_TYPE_UNKNOWN;
diff --git a/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/drawee/DraweeSimpleFragment.java b/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/drawee/DraweeSimpleFragment.java
index 76554a979..347c9f903 100644
--- a/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/drawee/DraweeSimpleFragment.java
+++ b/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/drawee/DraweeSimpleFragment.java
@@ -40,7 +40,8 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
     final Uri uri = imageUriProvider.createSampleUri(ImageUriProvider.ImageSize.M);
 
     SimpleDraweeView simpleDraweeView = (SimpleDraweeView) view.findViewById(R.id.drawee_view);
-    simpleDraweeView.setImageURI(uri);
+//    simpleDraweeView.setImageURI("embedded:///storage/emulated/0/Android/data/remix.myplayer/cache/embedded/Adele - Rolling In The Deep.jpg");
+    simpleDraweeView.setImageURI("embedded:///storage/emulated/0/Music/Linkin park/Faint.mp3");
   }
 
   @Override
