diff --git a/fbcore/src/main/java/com/facebook/common/memory/PooledByteBufferInputStream.java b/fbcore/src/main/java/com/facebook/common/memory/PooledByteBufferInputStream.java
index 946c9b1c7..98beefe88 100644
--- a/fbcore/src/main/java/com/facebook/common/memory/PooledByteBufferInputStream.java
+++ b/fbcore/src/main/java/com/facebook/common/memory/PooledByteBufferInputStream.java
@@ -28,7 +28,6 @@
 
   @VisibleForTesting
   int mOffset; // current offset in the chunk
-
   @VisibleForTesting
   int mMark; // position of 'mark' if any
 
diff --git a/imagepipeline-base/src/main/java/com/facebook/imageformat/ImageFormatCheckerUtils.java b/imagepipeline-base/src/main/java/com/facebook/imageformat/ImageFormatCheckerUtils.java
index 185dec172..a4e1973bf 100644
--- a/imagepipeline-base/src/main/java/com/facebook/imageformat/ImageFormatCheckerUtils.java
+++ b/imagepipeline-base/src/main/java/com/facebook/imageformat/ImageFormatCheckerUtils.java
@@ -67,22 +67,33 @@ public static boolean startsWithPattern(
    */
   public static int indexOfPattern(
       final byte[] byteArray,
-      final byte[] pattern) {
+      final int byteArrayLen,
+      final byte[] pattern,
+      final int patternLen) {
     Preconditions.checkNotNull(byteArray);
     Preconditions.checkNotNull(pattern);
-    if (pattern.length > byteArray.length) {
+    if (patternLen > byteArrayLen) {
       return -1;
     }
 
-    for (int i = 0; i < (byteArray.length - pattern.length); i++) {
-      if (byteArray[i] == pattern[0]) {
-        for (int j = 1; j < pattern.length; j++) {
-          if (byteArray[i + j] != pattern[j]) {
-            break;
-          }
-          if (j == pattern.length - 1) {
-            return i;
-          }
+    byte first = pattern[0];
+    int max = byteArrayLen - patternLen;
+
+    for (int i = 0; i <= max; i++) {
+      // Look for first byte
+      if (byteArray[i] != first) {
+        while (++i <= max && byteArray[i] != first);
+      }
+
+      // Found first byte, now look for the rest
+      if (i <= max) {
+        int j = i + 1;
+        int end = j + patternLen - 1;
+        for (int k = 1; j < end && byteArray[j] == pattern[k]; j++, k++);
+
+        if (j == end) {
+          // found whole pattern
+          return i;
         }
       }
     }
diff --git a/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/imageformat/svg/SvgDecoderExample.java b/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/imageformat/svg/SvgDecoderExample.java
index 751b05a7e..f8a82e2b7 100644
--- a/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/imageformat/svg/SvgDecoderExample.java
+++ b/samples/showcase/src/main/java/com/facebook/fresco/samples/showcase/imageformat/svg/SvgDecoderExample.java
@@ -38,7 +38,7 @@
 
   // We do not include the closing ">" since there can be additional information
   private static final String HEADER_TAG = "<svg";
-  private static final String[] POSSIBLE_HEADER_TAGS = { "<?xml" };
+  private static final byte[][] POSSIBLE_HEADER_TAGS = { ImageFormatCheckerUtils.asciiBytes("<?xml") };
 
   public static class SvgFormatChecker implements ImageFormat.FormatChecker {
 
@@ -58,14 +58,14 @@ public ImageFormat determineFormat(byte[] headerBytes, int headerSize) {
       if (ImageFormatCheckerUtils.startsWithPattern(headerBytes, HEADER)) {
         return SVG_FORMAT;
       }
-      for (String possibleHeaderTag : POSSIBLE_HEADER_TAGS) {
-        byte[] possibleHeader = ImageFormatCheckerUtils.asciiBytes(possibleHeaderTag);
-        if (ImageFormatCheckerUtils.startsWithPattern(headerBytes, possibleHeader) &&
-            ImageFormatCheckerUtils.indexOfPattern(headerBytes, HEADER) > -1) {
+      for (byte[] possibleHeaderTag : POSSIBLE_HEADER_TAGS) {
+        if (ImageFormatCheckerUtils.startsWithPattern(headerBytes, possibleHeaderTag) &&
+            ImageFormatCheckerUtils.indexOfPattern(headerBytes, headerBytes.length, HEADER, HEADER.length) > -1) {
           return SVG_FORMAT;
         }
       }
       return null;
+
     }
   }
 
