diff --git a/build.gradle b/build.gradle
index 13ac1404e..d2bfd9728 100644
--- a/build.gradle
+++ b/build.gradle
@@ -26,7 +26,7 @@ subprojects {
     }
 
     afterEvaluate { project ->
-      allclean.dependsOn(project.tasks.matching {it.name == 'clean'})
+        allclean.dependsOn(project.tasks.matching { it.name == 'clean' })
     }
 }
 
diff --git a/drawee-backends/drawee-pipeline/src/main/AndroidManifest.xml b/drawee-backends/drawee-pipeline/src/main/AndroidManifest.xml
index 3653bbe1c..0ceb0deae 100644
--- a/drawee-backends/drawee-pipeline/src/main/AndroidManifest.xml
+++ b/drawee-backends/drawee-pipeline/src/main/AndroidManifest.xml
@@ -1,11 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook.drawee.backends.pipeline"
-    >
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.drawee.backends.pipeline">
 
-  <uses-sdk
-      android:minSdkVersion="9"
-      android:targetSdkVersion="21"
-      />
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
 </manifest>
diff --git a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/Fresco.java b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/Fresco.java
index 55cc48a19..55cd27175 100644
--- a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/Fresco.java
+++ b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/Fresco.java
@@ -18,55 +18,68 @@
 
 /**
  * Fresco entry point.
- *
+ * <p>
  * <p/> You must initialize this class before use. The simplest way is to just do
  * {#code Fresco.initialize(Context)}.
  */
 public class Fresco {
-  private static PipelineDraweeControllerBuilderSupplier sDraweeControllerBuilderSupplier;
+    private static PipelineDraweeControllerBuilderSupplier sDraweeControllerBuilderSupplier;
 
-  private Fresco() {}
+    private Fresco() {
+    }
 
-  /** Initializes Fresco with the default config. */
-  public static void initialize(Context context) {
-    ImagePipelineFactory.initialize(context);
-    initializeDrawee(context);
-  }
+    /**
+     * Initializes Fresco with the default config.
+     */
+    public static void initialize(Context context) {
+        ImagePipelineFactory.initialize(context);
+        initializeDrawee(context);
+    }
 
-  /** Initializes Fresco with the specified config. */
-  public static void initialize(Context context, ImagePipelineConfig imagePipelineConfig) {
-    ImagePipelineFactory.initialize(imagePipelineConfig);
-    initializeDrawee(context);
-  }
+    /**
+     * Initializes Fresco with the specified config.
+     */
+    public static void initialize(Context context, ImagePipelineConfig imagePipelineConfig) {
+        ImagePipelineFactory.initialize(imagePipelineConfig);
+        initializeDrawee(context);
+    }
 
-  private static void initializeDrawee(Context context) {
-    sDraweeControllerBuilderSupplier = new PipelineDraweeControllerBuilderSupplier(context);
-    SimpleDraweeView.initialize(sDraweeControllerBuilderSupplier);
-  }
+    private static void initializeDrawee(Context context) {
+        sDraweeControllerBuilderSupplier = new PipelineDraweeControllerBuilderSupplier(context);
+        SimpleDraweeView.initialize(sDraweeControllerBuilderSupplier);
+    }
 
-  /** Gets the supplier of Fresco Drawee controller builders. */
-  public static PipelineDraweeControllerBuilderSupplier getDraweeControllerBuilderSupplier() {
-    return sDraweeControllerBuilderSupplier;
-  }
+    /**
+     * Gets the supplier of Fresco Drawee controller builders.
+     */
+    public static PipelineDraweeControllerBuilderSupplier getDraweeControllerBuilderSupplier() {
+        return sDraweeControllerBuilderSupplier;
+    }
 
-  /** Returns a new instance of Fresco Drawee controller builder. */
-  public static PipelineDraweeControllerBuilder newDraweeControllerBuilder() {
-    return sDraweeControllerBuilderSupplier.get();
-  }
+    /**
+     * Returns a new instance of Fresco Drawee controller builder.
+     */
+    public static PipelineDraweeControllerBuilder newDraweeControllerBuilder() {
+        return sDraweeControllerBuilderSupplier.get();
+    }
 
-  public static ImagePipelineFactory getImagePipelineFactory() {
-    return ImagePipelineFactory.getInstance();
-  }
+    public static ImagePipelineFactory getImagePipelineFactory() {
+        return ImagePipelineFactory.getInstance();
+    }
 
-  /** Gets the image pipeline instance. */
-  public static ImagePipeline getImagePipeline() {
-    return getImagePipelineFactory().getImagePipeline();
-  }
+    /**
+     * Gets the image pipeline instance.
+     */
+    public static ImagePipeline getImagePipeline() {
+        return getImagePipelineFactory().getImagePipeline();
+    }
 
-  /** Shuts Fresco down. */
-  public static void shutDown() {
-    sDraweeControllerBuilderSupplier = null;
-    SimpleDraweeView.shutDown();
-    ImagePipelineFactory.shutDown();
-  }
+    /**
+     * Shuts Fresco down.
+     */
+    public static void shutDown() {
+        sDraweeControllerBuilderSupplier = null;
+        SimpleDraweeView.shutDown();
+        ImagePipelineFactory.shutDown();
+    }
 }
diff --git a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeController.java b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeController.java
index 85a819942..59e0475b8 100644
--- a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeController.java
+++ b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeController.java
@@ -39,106 +39,107 @@
  * The data source is automatically obtained and closed based on attach / detach calls.
  */
 public class PipelineDraweeController
-    extends AbstractDraweeController<CloseableReference<CloseableImage>, ImageInfo> {
-
-  private static final Class<?> TAG = PipelineDraweeController.class;
-
-  // Components
-  private final Resources mResources;
-  private final AnimatedDrawableFactory mAnimatedDrawableFactory;
-
-  // Constant state (non-final because controllers can be reused)
-  private Supplier<DataSource<CloseableReference<CloseableImage>>> mDataSourceSupplier;
-
-  public PipelineDraweeController(
-      Resources resources,
-      DeferredReleaser deferredReleaser,
-      AnimatedDrawableFactory animatedDrawableFactory,
-      Executor uiThreadExecutor,
-      Supplier<DataSource<CloseableReference<CloseableImage>>> dataSourceSupplier,
-      String id,
-      Object callerContext) {
-      super(deferredReleaser, uiThreadExecutor, id, callerContext);
-    mResources = resources;
-    mAnimatedDrawableFactory = animatedDrawableFactory;
-    init(dataSourceSupplier);
-  }
-
-  /**
-   * Initializes this controller with the new data source supplier, id and caller context.
-   * This allows for reusing of the existing controller instead of instantiating a new one.
-   * This method should be called when the controller is in detached state.
-   * @param dataSourceSupplier data source supplier
-   * @param id unique id for this controller
-   * @param callerContext tag and context for this controller
-   */
-  public void initialize(
-      Supplier<DataSource<CloseableReference<CloseableImage>>> dataSourceSupplier,
-      String id,
-      Object callerContext) {
-    super.initialize(id, callerContext);
-    init(dataSourceSupplier);
-  }
-
-  private void init(Supplier<DataSource<CloseableReference<CloseableImage>>> dataSourceSupplier) {
-    mDataSourceSupplier = dataSourceSupplier;
-  }
-
-  protected Resources getResources() {
-    return mResources;
-  }
-
-  @Override
-  protected DataSource<CloseableReference<CloseableImage>> getDataSource() {
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(TAG, "controller %x: getDataSource", System.identityHashCode(this));
+        extends AbstractDraweeController<CloseableReference<CloseableImage>, ImageInfo> {
+
+    private static final Class<?> TAG = PipelineDraweeController.class;
+
+    // Components
+    private final Resources mResources;
+    private final AnimatedDrawableFactory mAnimatedDrawableFactory;
+
+    // Constant state (non-final because controllers can be reused)
+    private Supplier<DataSource<CloseableReference<CloseableImage>>> mDataSourceSupplier;
+
+    public PipelineDraweeController(
+            Resources resources,
+            DeferredReleaser deferredReleaser,
+            AnimatedDrawableFactory animatedDrawableFactory,
+            Executor uiThreadExecutor,
+            Supplier<DataSource<CloseableReference<CloseableImage>>> dataSourceSupplier,
+            String id,
+            Object callerContext) {
+        super(deferredReleaser, uiThreadExecutor, id, callerContext);
+        mResources = resources;
+        mAnimatedDrawableFactory = animatedDrawableFactory;
+        init(dataSourceSupplier);
     }
-    return mDataSourceSupplier.get();
-  }
-
-  @Override
-  protected Drawable createDrawable(CloseableReference<CloseableImage> image) {
-    Preconditions.checkState(CloseableReference.isValid(image));
-    CloseableImage closeableImage = image.get();
-    if (closeableImage instanceof CloseableStaticBitmap) {
-      CloseableStaticBitmap closeableStaticBitmap = (CloseableStaticBitmap) closeableImage;
-      return new BitmapDrawable(mResources, closeableStaticBitmap.getUnderlyingBitmap());
-    } else if (closeableImage instanceof CloseableAnimatedImage) {
-      return mAnimatedDrawableFactory.create(
-          ((CloseableAnimatedImage) closeableImage).getImageResult());
-    } else {
-      throw new UnsupportedOperationException("Unrecognized image class: " + closeableImage);
+
+    /**
+     * Initializes this controller with the new data source supplier, id and caller context.
+     * This allows for reusing of the existing controller instead of instantiating a new one.
+     * This method should be called when the controller is in detached state.
+     *
+     * @param dataSourceSupplier data source supplier
+     * @param id                 unique id for this controller
+     * @param callerContext      tag and context for this controller
+     */
+    public void initialize(
+            Supplier<DataSource<CloseableReference<CloseableImage>>> dataSourceSupplier,
+            String id,
+            Object callerContext) {
+        super.initialize(id, callerContext);
+        init(dataSourceSupplier);
+    }
+
+    private void init(Supplier<DataSource<CloseableReference<CloseableImage>>> dataSourceSupplier) {
+        mDataSourceSupplier = dataSourceSupplier;
+    }
+
+    protected Resources getResources() {
+        return mResources;
+    }
+
+    @Override
+    protected DataSource<CloseableReference<CloseableImage>> getDataSource() {
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(TAG, "controller %x: getDataSource", System.identityHashCode(this));
+        }
+        return mDataSourceSupplier.get();
+    }
+
+    @Override
+    protected Drawable createDrawable(CloseableReference<CloseableImage> image) {
+        Preconditions.checkState(CloseableReference.isValid(image));
+        CloseableImage closeableImage = image.get();
+        if (closeableImage instanceof CloseableStaticBitmap) {
+            CloseableStaticBitmap closeableStaticBitmap = (CloseableStaticBitmap) closeableImage;
+            return new BitmapDrawable(mResources, closeableStaticBitmap.getUnderlyingBitmap());
+        } else if (closeableImage instanceof CloseableAnimatedImage) {
+            return mAnimatedDrawableFactory.create(
+                    ((CloseableAnimatedImage) closeableImage).getImageResult());
+        } else {
+            throw new UnsupportedOperationException("Unrecognized image class: " + closeableImage);
+        }
     }
-  }
-
-  @Override
-  protected ImageInfo getImageInfo(CloseableReference<CloseableImage> image) {
-    Preconditions.checkState(CloseableReference.isValid(image));
-    return image.get();
-  }
-
-  @Override
-  protected int getImageHash(@Nullable CloseableReference<CloseableImage> image) {
-    return (image != null) ? image.getValueHash() : 0;
-  }
-
-  @Override
-  protected void releaseImage(@Nullable CloseableReference<CloseableImage> image) {
-    CloseableReference.closeSafely(image);
-  }
-
-  @Override
-  protected void releaseDrawable(@Nullable Drawable drawable) {
-    if (drawable instanceof DrawableWithCaches) {
-      ((DrawableWithCaches) drawable).dropCaches();
+
+    @Override
+    protected ImageInfo getImageInfo(CloseableReference<CloseableImage> image) {
+        Preconditions.checkState(CloseableReference.isValid(image));
+        return image.get();
+    }
+
+    @Override
+    protected int getImageHash(@Nullable CloseableReference<CloseableImage> image) {
+        return (image != null) ? image.getValueHash() : 0;
+    }
+
+    @Override
+    protected void releaseImage(@Nullable CloseableReference<CloseableImage> image) {
+        CloseableReference.closeSafely(image);
+    }
+
+    @Override
+    protected void releaseDrawable(@Nullable Drawable drawable) {
+        if (drawable instanceof DrawableWithCaches) {
+            ((DrawableWithCaches) drawable).dropCaches();
+        }
+    }
+
+    @Override
+    public String toString() {
+        return Objects.toStringHelper(this)
+                .add("super", super.toString())
+                .add("dataSourceSupplier", mDataSourceSupplier)
+                .toString();
     }
-  }
-
-  @Override
-  public String toString() {
-    return Objects.toStringHelper(this)
-        .add("super", super.toString())
-        .add("dataSourceSupplier", mDataSourceSupplier)
-        .toString();
-  }
 }
diff --git a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilder.java b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilder.java
index 2e222e133..3eaad8cea 100644
--- a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilder.java
+++ b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilder.java
@@ -29,62 +29,62 @@
  * <p/> See {@link AbstractDraweeControllerBuilder} for more details.
  */
 public class PipelineDraweeControllerBuilder extends AbstractDraweeControllerBuilder<
-    PipelineDraweeControllerBuilder,
-    ImageRequest,
-    CloseableReference<CloseableImage>,
-    ImageInfo> {
+        PipelineDraweeControllerBuilder,
+        ImageRequest,
+        CloseableReference<CloseableImage>,
+        ImageInfo> {
 
-  private final ImagePipeline mImagePipeline;
-  private final PipelineDraweeControllerFactory mPipelineDraweeControllerFactory;
+    private final ImagePipeline mImagePipeline;
+    private final PipelineDraweeControllerFactory mPipelineDraweeControllerFactory;
 
-  public PipelineDraweeControllerBuilder(
-      Context context,
-      PipelineDraweeControllerFactory pipelineDraweeControllerFactory,
-      ImagePipeline imagePipeline,
-      Set<ControllerListener> boundControllerListeners) {
-    super(context, boundControllerListeners);
-    mImagePipeline = imagePipeline;
-    mPipelineDraweeControllerFactory = pipelineDraweeControllerFactory;
-  }
+    public PipelineDraweeControllerBuilder(
+            Context context,
+            PipelineDraweeControllerFactory pipelineDraweeControllerFactory,
+            ImagePipeline imagePipeline,
+            Set<ControllerListener> boundControllerListeners) {
+        super(context, boundControllerListeners);
+        mImagePipeline = imagePipeline;
+        mPipelineDraweeControllerFactory = pipelineDraweeControllerFactory;
+    }
 
-  @Override
-  public PipelineDraweeControllerBuilder setUri(Uri uri) {
-    return super.setImageRequest(ImageRequest.fromUri(uri));
-  }
+    @Override
+    public PipelineDraweeControllerBuilder setUri(Uri uri) {
+        return super.setImageRequest(ImageRequest.fromUri(uri));
+    }
 
-  @Override
-  protected PipelineDraweeController obtainController() {
-    DraweeController oldController = getOldController();
-    PipelineDraweeController controller;
-    if (oldController instanceof PipelineDraweeController) {
-      controller = (PipelineDraweeController) oldController;
-      controller.initialize(
-          obtainDataSourceSupplier(),
-          generateUniqueControllerId(),
-          getCallerContext());
-    } else {
-      controller = mPipelineDraweeControllerFactory.newController(
-          obtainDataSourceSupplier(),
-          generateUniqueControllerId(),
-          getCallerContext());
+    @Override
+    protected PipelineDraweeController obtainController() {
+        DraweeController oldController = getOldController();
+        PipelineDraweeController controller;
+        if (oldController instanceof PipelineDraweeController) {
+            controller = (PipelineDraweeController) oldController;
+            controller.initialize(
+                    obtainDataSourceSupplier(),
+                    generateUniqueControllerId(),
+                    getCallerContext());
+        } else {
+            controller = mPipelineDraweeControllerFactory.newController(
+                    obtainDataSourceSupplier(),
+                    generateUniqueControllerId(),
+                    getCallerContext());
+        }
+        return controller;
     }
-    return controller;
-  }
 
-  @Override
-  protected DataSource<CloseableReference<CloseableImage>> getDataSourceForRequest(
-      ImageRequest imageRequest,
-      Object callerContext,
-      boolean bitmapCacheOnly) {
-    if (bitmapCacheOnly) {
-      return mImagePipeline.fetchImageFromBitmapCache(imageRequest, callerContext);
-    } else {
-      return mImagePipeline.fetchDecodedImage(imageRequest, callerContext);
+    @Override
+    protected DataSource<CloseableReference<CloseableImage>> getDataSourceForRequest(
+            ImageRequest imageRequest,
+            Object callerContext,
+            boolean bitmapCacheOnly) {
+        if (bitmapCacheOnly) {
+            return mImagePipeline.fetchImageFromBitmapCache(imageRequest, callerContext);
+        } else {
+            return mImagePipeline.fetchDecodedImage(imageRequest, callerContext);
+        }
     }
-  }
 
-  @Override
-  protected PipelineDraweeControllerBuilder getThis() {
-    return this;
-  }
+    @Override
+    protected PipelineDraweeControllerBuilder getThis() {
+        return this;
+    }
 }
diff --git a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilderSupplier.java b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilderSupplier.java
index d118d2856..16db7c882 100644
--- a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilderSupplier.java
+++ b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerBuilderSupplier.java
@@ -21,43 +21,43 @@
 import java.util.Set;
 
 public class PipelineDraweeControllerBuilderSupplier implements
-    Supplier<PipelineDraweeControllerBuilder> {
-
-  private final Context mContext;
-  private final ImagePipeline mImagePipeline;
-  private final PipelineDraweeControllerFactory mPipelineDraweeControllerFactory;
-  private final Set<ControllerListener> mBoundControllerListeners;
-
-  public PipelineDraweeControllerBuilderSupplier(Context context) {
-    this(context, ImagePipelineFactory.getInstance());
-  }
-
-  public PipelineDraweeControllerBuilderSupplier(
-      Context context,
-      ImagePipelineFactory imagePipelineFactory) {
-    this(context, imagePipelineFactory, null);
-  }
-
-  public PipelineDraweeControllerBuilderSupplier(
-      Context context,
-      ImagePipelineFactory imagePipelineFactory,
-      Set<ControllerListener> boundControllerListeners) {
-    mContext = context;
-    mImagePipeline = imagePipelineFactory.getImagePipeline();
-    mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(
-        context.getResources(),
-        DeferredReleaser.getInstance(),
-        imagePipelineFactory.getAnimatedDrawableFactory(),
-        UiThreadImmediateExecutorService.getInstance());
-    mBoundControllerListeners = boundControllerListeners;
-  }
-
-  @Override
-  public PipelineDraweeControllerBuilder get() {
-    return new PipelineDraweeControllerBuilder(
-        mContext,
-        mPipelineDraweeControllerFactory,
-        mImagePipeline,
-        mBoundControllerListeners);
-  }
+        Supplier<PipelineDraweeControllerBuilder> {
+
+    private final Context mContext;
+    private final ImagePipeline mImagePipeline;
+    private final PipelineDraweeControllerFactory mPipelineDraweeControllerFactory;
+    private final Set<ControllerListener> mBoundControllerListeners;
+
+    public PipelineDraweeControllerBuilderSupplier(Context context) {
+        this(context, ImagePipelineFactory.getInstance());
+    }
+
+    public PipelineDraweeControllerBuilderSupplier(
+            Context context,
+            ImagePipelineFactory imagePipelineFactory) {
+        this(context, imagePipelineFactory, null);
+    }
+
+    public PipelineDraweeControllerBuilderSupplier(
+            Context context,
+            ImagePipelineFactory imagePipelineFactory,
+            Set<ControllerListener> boundControllerListeners) {
+        mContext = context;
+        mImagePipeline = imagePipelineFactory.getImagePipeline();
+        mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory(
+                context.getResources(),
+                DeferredReleaser.getInstance(),
+                imagePipelineFactory.getAnimatedDrawableFactory(),
+                UiThreadImmediateExecutorService.getInstance());
+        mBoundControllerListeners = boundControllerListeners;
+    }
+
+    @Override
+    public PipelineDraweeControllerBuilder get() {
+        return new PipelineDraweeControllerBuilder(
+                mContext,
+                mPipelineDraweeControllerFactory,
+                mImagePipeline,
+                mBoundControllerListeners);
+    }
 }
diff --git a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerFactory.java b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerFactory.java
index a8f9a264b..cc4aeb647 100644
--- a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerFactory.java
+++ b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/PipelineDraweeControllerFactory.java
@@ -25,33 +25,33 @@
  */
 public class PipelineDraweeControllerFactory {
 
-  private Resources mResources;
-  private DeferredReleaser mDeferredReleaser;
-  private AnimatedDrawableFactory mAnimatedDrawableFactory;
-  private Executor mUiThreadExecutor;
-
-  public PipelineDraweeControllerFactory(
-      Resources resources,
-      DeferredReleaser deferredReleaser,
-      AnimatedDrawableFactory animatedDrawableFactory,
-      Executor uiThreadExecutor) {
-    mResources = resources;
-    mDeferredReleaser = deferredReleaser;
-    mAnimatedDrawableFactory = animatedDrawableFactory;
-    mUiThreadExecutor = uiThreadExecutor;
-  }
-
-  public PipelineDraweeController newController(
-      Supplier<DataSource<CloseableReference<CloseableImage>>> dataSourceSupplier,
-      String id,
-      Object callerContext) {
-    return new PipelineDraweeController(
-        mResources,
-        mDeferredReleaser,
-        mAnimatedDrawableFactory,
-        mUiThreadExecutor,
-        dataSourceSupplier,
-        id,
-        callerContext);
-  }
+    private Resources mResources;
+    private DeferredReleaser mDeferredReleaser;
+    private AnimatedDrawableFactory mAnimatedDrawableFactory;
+    private Executor mUiThreadExecutor;
+
+    public PipelineDraweeControllerFactory(
+            Resources resources,
+            DeferredReleaser deferredReleaser,
+            AnimatedDrawableFactory animatedDrawableFactory,
+            Executor uiThreadExecutor) {
+        mResources = resources;
+        mDeferredReleaser = deferredReleaser;
+        mAnimatedDrawableFactory = animatedDrawableFactory;
+        mUiThreadExecutor = uiThreadExecutor;
+    }
+
+    public PipelineDraweeController newController(
+            Supplier<DataSource<CloseableReference<CloseableImage>>> dataSourceSupplier,
+            String id,
+            Object callerContext) {
+        return new PipelineDraweeController(
+                mResources,
+                mDeferredReleaser,
+                mAnimatedDrawableFactory,
+                mUiThreadExecutor,
+                dataSourceSupplier,
+                id,
+                callerContext);
+    }
 }
diff --git a/drawee-backends/drawee-volley/src/main/AndroidManifest.xml b/drawee-backends/drawee-volley/src/main/AndroidManifest.xml
index 97a656dec..b432154a2 100644
--- a/drawee-backends/drawee-volley/src/main/AndroidManifest.xml
+++ b/drawee-backends/drawee-volley/src/main/AndroidManifest.xml
@@ -1,11 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook.drawee.backends.volley"
-    >
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.drawee.backends.volley">
 
-  <uses-sdk
-      android:minSdkVersion="9"
-      android:targetSdkVersion="21"
-      />
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
 </manifest>
diff --git a/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDataSource.java b/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDataSource.java
index 508dc61ca..95923f26e 100644
--- a/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDataSource.java
+++ b/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDataSource.java
@@ -21,49 +21,50 @@
  * {@link DataSource} that wraps Volley {@link ImageLoader}.
  */
 public class VolleyDataSource extends AbstractDataSource<Bitmap> {
-  private ImageLoader.ImageContainer mImageContainer;
+    private ImageLoader.ImageContainer mImageContainer;
 
-  public VolleyDataSource(
-      final ImageLoader imageLoader,
-      final Uri imageRequest,
-      final boolean bitmapCacheOnly) {
+    public VolleyDataSource(
+            final ImageLoader imageLoader,
+            final Uri imageRequest,
+            final boolean bitmapCacheOnly) {
 
-    // TODO: add VolleyImageRequest {uri, resizeOptions, bitmapCacheOnly, ...}
-    String uriString = imageRequest.toString();
-    int maxWidth = 0;
-    int maxHeight = 0;
+        // TODO: add VolleyImageRequest {uri, resizeOptions, bitmapCacheOnly, ...}
+        String uriString = imageRequest.toString();
+        int maxWidth = 0;
+        int maxHeight = 0;
 
-    if (bitmapCacheOnly) {
-      if (!imageLoader.isCached(uriString, maxWidth, maxHeight)) {
-        mImageContainer = null;
-        setFailure(new NullPointerException("Image not found in bitmap-cache."));
-        return;
-      }
-    }
-
-    mImageContainer = imageLoader.get(
-        uriString,
-        new ImageLoader.ImageListener() {
-          @Override
-          public void onErrorResponse(VolleyError error) {
-            setFailure(error.getCause());
-          }
-          @Override
-          public void onResponse(final ImageLoader.ImageContainer response, boolean isImmediate) {
-            if (response.getBitmap() != null) {
-              setResult(response.getBitmap(), true);
+        if (bitmapCacheOnly) {
+            if (!imageLoader.isCached(uriString, maxWidth, maxHeight)) {
+                mImageContainer = null;
+                setFailure(new NullPointerException("Image not found in bitmap-cache."));
+                return;
             }
-          }
-        },
-        maxWidth,
-        maxHeight);
-  }
+        }
+
+        mImageContainer = imageLoader.get(
+                uriString,
+                new ImageLoader.ImageListener() {
+                    @Override
+                    public void onErrorResponse(VolleyError error) {
+                        setFailure(error.getCause());
+                    }
+
+                    @Override
+                    public void onResponse(final ImageLoader.ImageContainer response, boolean isImmediate) {
+                        if (response.getBitmap() != null) {
+                            setResult(response.getBitmap(), true);
+                        }
+                    }
+                },
+                maxWidth,
+                maxHeight);
+    }
 
-  @Override
-  public boolean close() {
-    if (mImageContainer != null) {
-      mImageContainer.cancelRequest();
+    @Override
+    public boolean close() {
+        if (mImageContainer != null) {
+            mImageContainer.cancelRequest();
+        }
+        return super.close();
     }
-    return super.close();
-  }
 }
diff --git a/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeController.java b/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeController.java
index 1280118a6..1c6c58dfa 100644
--- a/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeController.java
+++ b/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeController.java
@@ -32,85 +32,86 @@
  * The data source is automatically obtained and closed based on attach / detach calls.
  */
 public class VolleyDraweeController
-    extends AbstractDraweeController<Bitmap, Bitmap> {
-
-  // Components
-  private final Resources mResources;
-
-  // Constant state (non-final because controllers can be reused)
-  private Supplier<DataSource<Bitmap>> mDataSourceSupplier;
-
-  public VolleyDraweeController(
-      Resources resources,
-      DeferredReleaser deferredReleaser,
-      Executor uiThreadExecutor,
-      Supplier<DataSource<Bitmap>> dataSourceSupplier,
-      String id,
-      Object callerContext) {
-    super(deferredReleaser, uiThreadExecutor, id, callerContext);
-    mResources = resources;
-    init(dataSourceSupplier);
-  }
-
-  /**
-   * Initializes this controller with the new data source supplier, id and caller context.
-   * This allows for reusing of the existing controller instead of instantiating a new one.
-   * This method should be called when the controller is in detached state.
-   * @param dataSourceSupplier data source supplier
-   * @param id unique id for this controller
-   * @param callerContext tag and context for this controller
-   */
-  public void initialize(
-      Supplier<DataSource<Bitmap>> dataSourceSupplier,
-      String id,
-      Object callerContext) {
-    super.initialize(id, callerContext);
-    init(dataSourceSupplier);
-  }
-
-  private void init(Supplier<DataSource<Bitmap>> dataSourceSupplier) {
-    mDataSourceSupplier = dataSourceSupplier;
-  }
-
-  protected Resources getResources() {
-    return mResources;
-  }
-
-  @Override
-  protected DataSource<Bitmap> getDataSource() {
-    return mDataSourceSupplier.get();
-  }
-
-  @Override
-  protected Drawable createDrawable(Bitmap image) {
-    return new BitmapDrawable(mResources, Preconditions.checkNotNull(image));
-  }
-
-  @Override
-  protected Bitmap getImageInfo(Bitmap image) {
-    return image;
-  }
-
-  @Override
-  protected int getImageHash(@Nullable Bitmap image) {
-    return (image != null) ? image.hashCode() : 0;
-  }
-
-  @Override
-  protected void releaseImage(@Nullable Bitmap image) {
-    // no-op
-  }
-
-  @Override
-  protected void releaseDrawable(@Nullable Drawable drawable) {
-    // no-op
-  }
-
-  @Override
-  public String toString() {
-    return Objects.toStringHelper(this)
-        .add("super", super.toString())
-        .add("dataSourceSupplier", mDataSourceSupplier)
-        .toString();
-  }
+        extends AbstractDraweeController<Bitmap, Bitmap> {
+
+    // Components
+    private final Resources mResources;
+
+    // Constant state (non-final because controllers can be reused)
+    private Supplier<DataSource<Bitmap>> mDataSourceSupplier;
+
+    public VolleyDraweeController(
+            Resources resources,
+            DeferredReleaser deferredReleaser,
+            Executor uiThreadExecutor,
+            Supplier<DataSource<Bitmap>> dataSourceSupplier,
+            String id,
+            Object callerContext) {
+        super(deferredReleaser, uiThreadExecutor, id, callerContext);
+        mResources = resources;
+        init(dataSourceSupplier);
+    }
+
+    /**
+     * Initializes this controller with the new data source supplier, id and caller context.
+     * This allows for reusing of the existing controller instead of instantiating a new one.
+     * This method should be called when the controller is in detached state.
+     *
+     * @param dataSourceSupplier data source supplier
+     * @param id                 unique id for this controller
+     * @param callerContext      tag and context for this controller
+     */
+    public void initialize(
+            Supplier<DataSource<Bitmap>> dataSourceSupplier,
+            String id,
+            Object callerContext) {
+        super.initialize(id, callerContext);
+        init(dataSourceSupplier);
+    }
+
+    private void init(Supplier<DataSource<Bitmap>> dataSourceSupplier) {
+        mDataSourceSupplier = dataSourceSupplier;
+    }
+
+    protected Resources getResources() {
+        return mResources;
+    }
+
+    @Override
+    protected DataSource<Bitmap> getDataSource() {
+        return mDataSourceSupplier.get();
+    }
+
+    @Override
+    protected Drawable createDrawable(Bitmap image) {
+        return new BitmapDrawable(mResources, Preconditions.checkNotNull(image));
+    }
+
+    @Override
+    protected Bitmap getImageInfo(Bitmap image) {
+        return image;
+    }
+
+    @Override
+    protected int getImageHash(@Nullable Bitmap image) {
+        return (image != null) ? image.hashCode() : 0;
+    }
+
+    @Override
+    protected void releaseImage(@Nullable Bitmap image) {
+        // no-op
+    }
+
+    @Override
+    protected void releaseDrawable(@Nullable Drawable drawable) {
+        // no-op
+    }
+
+    @Override
+    public String toString() {
+        return Objects.toStringHelper(this)
+                .add("super", super.toString())
+                .add("dataSourceSupplier", mDataSourceSupplier)
+                .toString();
+    }
 }
diff --git a/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerBuilder.java b/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerBuilder.java
index 6119b9cbd..dad728995 100644
--- a/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerBuilder.java
+++ b/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerBuilder.java
@@ -26,58 +26,58 @@
  * <p/> See {@link AbstractDraweeControllerBuilder} for more details.
  */
 public class VolleyDraweeControllerBuilder extends AbstractDraweeControllerBuilder<
-    VolleyDraweeControllerBuilder,
-    Uri,
-    Bitmap,
-    Bitmap> {
+        VolleyDraweeControllerBuilder,
+        Uri,
+        Bitmap,
+        Bitmap> {
 
-  private final ImageLoader mImageLoader;
-  private final VolleyDraweeControllerFactory mVolleyDraweeControllerFactory;
+    private final ImageLoader mImageLoader;
+    private final VolleyDraweeControllerFactory mVolleyDraweeControllerFactory;
 
-  public VolleyDraweeControllerBuilder(
-      Context context,
-      ImageLoader imageLoader,
-      VolleyDraweeControllerFactory volleyDraweeControllerFactory,
-      Set<ControllerListener> boundControllerListeners) {
-    super(context, boundControllerListeners);
-    mImageLoader = imageLoader;
-    mVolleyDraweeControllerFactory = volleyDraweeControllerFactory;
-  }
+    public VolleyDraweeControllerBuilder(
+            Context context,
+            ImageLoader imageLoader,
+            VolleyDraweeControllerFactory volleyDraweeControllerFactory,
+            Set<ControllerListener> boundControllerListeners) {
+        super(context, boundControllerListeners);
+        mImageLoader = imageLoader;
+        mVolleyDraweeControllerFactory = volleyDraweeControllerFactory;
+    }
 
-  @Override
-  protected VolleyDraweeController obtainController() {
-    DraweeController oldController = getOldController();
-    VolleyDraweeController controller;
-    if (oldController instanceof VolleyDraweeController) {
-      controller = (VolleyDraweeController) oldController;
-      controller.initialize(
-          obtainDataSourceSupplier(),
-          generateUniqueControllerId(),
-          getCallerContext());
-    } else {
-      controller = mVolleyDraweeControllerFactory.newController(
-          obtainDataSourceSupplier(),
-          generateUniqueControllerId(),
-          getCallerContext());
+    @Override
+    protected VolleyDraweeController obtainController() {
+        DraweeController oldController = getOldController();
+        VolleyDraweeController controller;
+        if (oldController instanceof VolleyDraweeController) {
+            controller = (VolleyDraweeController) oldController;
+            controller.initialize(
+                    obtainDataSourceSupplier(),
+                    generateUniqueControllerId(),
+                    getCallerContext());
+        } else {
+            controller = mVolleyDraweeControllerFactory.newController(
+                    obtainDataSourceSupplier(),
+                    generateUniqueControllerId(),
+                    getCallerContext());
+        }
+        return controller;
     }
-    return controller;
-  }
 
-  @Override
-  protected DataSource<Bitmap> getDataSourceForRequest(
-      final Uri imageRequest,
-      final Object callerContext,
-      final boolean bitmapCacheOnly) {
-    return new VolleyDataSource(mImageLoader, imageRequest, bitmapCacheOnly);
-  }
+    @Override
+    protected DataSource<Bitmap> getDataSourceForRequest(
+            final Uri imageRequest,
+            final Object callerContext,
+            final boolean bitmapCacheOnly) {
+        return new VolleyDataSource(mImageLoader, imageRequest, bitmapCacheOnly);
+    }
 
-  @Override
-  public VolleyDraweeControllerBuilder setUri(Uri uri) {
-    return setImageRequest(uri);
-  }
+    @Override
+    public VolleyDraweeControllerBuilder setUri(Uri uri) {
+        return setImageRequest(uri);
+    }
 
-  @Override
-  protected VolleyDraweeControllerBuilder getThis() {
-    return this;
-  }
+    @Override
+    protected VolleyDraweeControllerBuilder getThis() {
+        return this;
+    }
 }
diff --git a/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerBuilderSupplier.java b/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerBuilderSupplier.java
index 1598e82e6..607ffb3de 100644
--- a/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerBuilderSupplier.java
+++ b/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerBuilderSupplier.java
@@ -23,38 +23,38 @@
  * Supplier of Volley Drawee controller builders.
  */
 public class VolleyDraweeControllerBuilderSupplier implements
-    Supplier<VolleyDraweeControllerBuilder> {
-
-  private final Context mContext;
-  private final ImageLoader mImageLoader;
-  private final VolleyDraweeControllerFactory mVolleyDraweeControllerFactory;
-  private final Set<ControllerListener> mBoundControllerListeners;
-
-  public VolleyDraweeControllerBuilderSupplier(
-      Context context,
-      ImageLoader imageLoader) {
-    this(context, imageLoader, null);
-  }
-
-  public VolleyDraweeControllerBuilderSupplier(
-      Context context,
-      ImageLoader imageLoader,
-      Set<ControllerListener> boundControllerListeners) {
-    mContext = context;
-    mImageLoader = imageLoader;
-    mVolleyDraweeControllerFactory = new VolleyDraweeControllerFactory(
-        context.getResources(),
-        DeferredReleaser.getInstance(),
-        UiThreadExecutorService.getInstance());
-    mBoundControllerListeners = boundControllerListeners;
-  }
-
-  @Override
-  public VolleyDraweeControllerBuilder get() {
-    return new VolleyDraweeControllerBuilder(
-        mContext,
-        mImageLoader,
-        mVolleyDraweeControllerFactory,
-        mBoundControllerListeners);
-  }
+        Supplier<VolleyDraweeControllerBuilder> {
+
+    private final Context mContext;
+    private final ImageLoader mImageLoader;
+    private final VolleyDraweeControllerFactory mVolleyDraweeControllerFactory;
+    private final Set<ControllerListener> mBoundControllerListeners;
+
+    public VolleyDraweeControllerBuilderSupplier(
+            Context context,
+            ImageLoader imageLoader) {
+        this(context, imageLoader, null);
+    }
+
+    public VolleyDraweeControllerBuilderSupplier(
+            Context context,
+            ImageLoader imageLoader,
+            Set<ControllerListener> boundControllerListeners) {
+        mContext = context;
+        mImageLoader = imageLoader;
+        mVolleyDraweeControllerFactory = new VolleyDraweeControllerFactory(
+                context.getResources(),
+                DeferredReleaser.getInstance(),
+                UiThreadExecutorService.getInstance());
+        mBoundControllerListeners = boundControllerListeners;
+    }
+
+    @Override
+    public VolleyDraweeControllerBuilder get() {
+        return new VolleyDraweeControllerBuilder(
+                mContext,
+                mImageLoader,
+                mVolleyDraweeControllerFactory,
+                mBoundControllerListeners);
+    }
 }
diff --git a/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerFactory.java b/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerFactory.java
index 04bfea94a..7862bfb5b 100644
--- a/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerFactory.java
+++ b/drawee-backends/drawee-volley/src/main/java/com/facebook/drawee/backends/volley/VolleyDraweeControllerFactory.java
@@ -23,29 +23,29 @@
  */
 public class VolleyDraweeControllerFactory {
 
-  private Resources mResources;
-  private DeferredReleaser mDeferredReleaser;
-  private Executor mUiThreadExecutor;
-
-  public VolleyDraweeControllerFactory(
-      Resources resources,
-      DeferredReleaser deferredReleaser,
-      Executor uiThreadExecutor) {
-    mResources = resources;
-    mDeferredReleaser = deferredReleaser;
-    mUiThreadExecutor = uiThreadExecutor;
-  }
-
-  public VolleyDraweeController newController(
-      Supplier<DataSource<Bitmap>> dataSourceSupplier,
-      String id,
-      Object callerContext) {
-    return new VolleyDraweeController(
-        mResources,
-        mDeferredReleaser,
-        mUiThreadExecutor,
-        dataSourceSupplier,
-        id,
-        callerContext);
-  }
+    private Resources mResources;
+    private DeferredReleaser mDeferredReleaser;
+    private Executor mUiThreadExecutor;
+
+    public VolleyDraweeControllerFactory(
+            Resources resources,
+            DeferredReleaser deferredReleaser,
+            Executor uiThreadExecutor) {
+        mResources = resources;
+        mDeferredReleaser = deferredReleaser;
+        mUiThreadExecutor = uiThreadExecutor;
+    }
+
+    public VolleyDraweeController newController(
+            Supplier<DataSource<Bitmap>> dataSourceSupplier,
+            String id,
+            Object callerContext) {
+        return new VolleyDraweeController(
+                mResources,
+                mDeferredReleaser,
+                mUiThreadExecutor,
+                dataSourceSupplier,
+                id,
+                callerContext);
+    }
 }
diff --git a/drawee/build.gradle b/drawee/build.gradle
index 56fbfe638..8115d68b7 100644
--- a/drawee/build.gradle
+++ b/drawee/build.gradle
@@ -25,7 +25,6 @@ apply from: rootProject.file('release.gradle')
 
 def generatedTestSources = "$buildDir/generated-src/test"
 
-
 // Gradle and Buck need different versions of the test runner.
 // For gradle, WithTestDefaultsRunner just is a direct sub-class of RobolectricTestRunner.
 task generateTestSources {
diff --git a/drawee/src/main/AndroidManifest.xml b/drawee/src/main/AndroidManifest.xml
index e3ea40cfe..e7ae0d426 100644
--- a/drawee/src/main/AndroidManifest.xml
+++ b/drawee/src/main/AndroidManifest.xml
@@ -1,11 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook.drawee"
-    >
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.drawee">
 
-  <uses-sdk
-      android:minSdkVersion="9"
-      android:targetSdkVersion="21"
-      />
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
 </manifest>
diff --git a/drawee/src/main/java/com/facebook/drawee/components/DeferredReleaser.java b/drawee/src/main/java/com/facebook/drawee/components/DeferredReleaser.java
index 0eed5fee2..e6c55d39a 100644
--- a/drawee/src/main/java/com/facebook/drawee/components/DeferredReleaser.java
+++ b/drawee/src/main/java/com/facebook/drawee/components/DeferredReleaser.java
@@ -32,65 +32,67 @@
  */
 public class DeferredReleaser {
 
-  private static DeferredReleaser sInstance = null;
+    private static DeferredReleaser sInstance = null;
 
-  public static synchronized DeferredReleaser getInstance() {
-    if (sInstance == null) {
-      sInstance = new DeferredReleaser();
+    public static synchronized DeferredReleaser getInstance() {
+        if (sInstance == null) {
+            sInstance = new DeferredReleaser();
+        }
+        return sInstance;
     }
-    return sInstance;
-  }
 
-  public interface Releasable {
-    public void release();
-  }
-
-  private final Set<Releasable> mPendingReleasables;
-  private final Handler mUiHandler;
+    public interface Releasable {
+        public void release();
+    }
 
-  public DeferredReleaser() {
-    mPendingReleasables =  new HashSet<Releasable>();
-    mUiHandler = new Handler(Looper.getMainLooper());
-  }
+    private final Set<Releasable> mPendingReleasables;
+    private final Handler mUiHandler;
 
-  /*
-   * Walks through the set of pending releasables, and calls release on them.
-   * Resets the pending list to an empty list when done.
-   */
-  private final Runnable releaseRunnable = new Runnable() {
-    @Override
-    public void run() {
-      for (Releasable releasable : mPendingReleasables) {
-        releasable.release();
-      }
-      mPendingReleasables.clear();
+    public DeferredReleaser() {
+        mPendingReleasables = new HashSet<Releasable>();
+        mUiHandler = new Handler(Looper.getMainLooper());
     }
-  };
 
-  /**
-   * Schedules deferred release.
-   * <p>
-   * The object will be released after the current Looper's loop,
-   * unless {@code cancelDeferredRelease} is called before then.
-   * @param releasable Object to release.
-   */
-  public void scheduleDeferredRelease(Releasable releasable) {
-    if (!mPendingReleasables.add(releasable)) {
-      return;
-    }
-    // Posting to the UI queue is an O(n) operation, so we only do it once.
-    // The one runnable does all the releases.
-    if (mPendingReleasables.size() == 1) {
-      mUiHandler.post(releaseRunnable);
+    /*
+     * Walks through the set of pending releasables, and calls release on them.
+     * Resets the pending list to an empty list when done.
+     */
+    private final Runnable releaseRunnable = new Runnable() {
+        @Override
+        public void run() {
+            for (Releasable releasable : mPendingReleasables) {
+                releasable.release();
+            }
+            mPendingReleasables.clear();
+        }
+    };
+
+    /**
+     * Schedules deferred release.
+     * <p>
+     * The object will be released after the current Looper's loop,
+     * unless {@code cancelDeferredRelease} is called before then.
+     *
+     * @param releasable Object to release.
+     */
+    public void scheduleDeferredRelease(Releasable releasable) {
+        if (!mPendingReleasables.add(releasable)) {
+            return;
+        }
+        // Posting to the UI queue is an O(n) operation, so we only do it once.
+        // The one runnable does all the releases.
+        if (mPendingReleasables.size() == 1) {
+            mUiHandler.post(releaseRunnable);
+        }
     }
-  }
 
-  /**
-   * Cancels a pending release for this object.
-   * @param releasable Object to cancel release of.
-   */
-  public void cancelDeferredRelease(Releasable releasable) {
-    mPendingReleasables.remove(releasable);
-  }
+    /**
+     * Cancels a pending release for this object.
+     *
+     * @param releasable Object to cancel release of.
+     */
+    public void cancelDeferredRelease(Releasable releasable) {
+        mPendingReleasables.remove(releasable);
+    }
 
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/components/DraweeEventTracker.java b/drawee/src/main/java/com/facebook/drawee/components/DraweeEventTracker.java
index 0d80b1195..6fe9e751d 100644
--- a/drawee/src/main/java/com/facebook/drawee/components/DraweeEventTracker.java
+++ b/drawee/src/main/java/com/facebook/drawee/components/DraweeEventTracker.java
@@ -18,42 +18,42 @@
  */
 public class DraweeEventTracker {
 
-  private static final int MAX_EVENTS_TO_TRACK = 20;
-
-  public static enum Event {
-    ON_SET_HIERARCHY,
-    ON_CLEAR_HIERARCHY,
-    ON_SET_CONTROLLER,
-    ON_CLEAR_OLD_CONTROLLER,
-    ON_CLEAR_CONTROLLER,
-    ON_INIT_CONTROLLER,
-    ON_ATTACH_CONTROLLER,
-    ON_DETACH_CONTROLLER,
-    ON_RELEASE_CONTROLLER,
-    ON_DATASOURCE_SUBMIT,
-    ON_DATASOURCE_RESULT,
-    ON_DATASOURCE_RESULT_INT,
-    ON_DATASOURCE_FAILURE,
-    ON_DATASOURCE_FAILURE_INT,
-    ON_HOLDER_ATTACH,
-    ON_HOLDER_DETACH,
-    ON_DRAWABLE_SHOW,
-    ON_DRAWABLE_HIDE,
-    ON_ACTIVITY_START,
-    ON_ACTIVITY_STOP
-  }
-
-  private final Queue<Event> mEventQueue = new ArrayBlockingQueue<Event>(MAX_EVENTS_TO_TRACK);
-
-  public void recordEvent(Event event) {
-    if (mEventQueue.size() + 1 > MAX_EVENTS_TO_TRACK) {
-      mEventQueue.poll();
+    private static final int MAX_EVENTS_TO_TRACK = 20;
+
+    public static enum Event {
+        ON_SET_HIERARCHY,
+        ON_CLEAR_HIERARCHY,
+        ON_SET_CONTROLLER,
+        ON_CLEAR_OLD_CONTROLLER,
+        ON_CLEAR_CONTROLLER,
+        ON_INIT_CONTROLLER,
+        ON_ATTACH_CONTROLLER,
+        ON_DETACH_CONTROLLER,
+        ON_RELEASE_CONTROLLER,
+        ON_DATASOURCE_SUBMIT,
+        ON_DATASOURCE_RESULT,
+        ON_DATASOURCE_RESULT_INT,
+        ON_DATASOURCE_FAILURE,
+        ON_DATASOURCE_FAILURE_INT,
+        ON_HOLDER_ATTACH,
+        ON_HOLDER_DETACH,
+        ON_DRAWABLE_SHOW,
+        ON_DRAWABLE_HIDE,
+        ON_ACTIVITY_START,
+        ON_ACTIVITY_STOP
     }
-    mEventQueue.add(event);
-  }
 
-  @Override
-  public String toString() {
-    return mEventQueue.toString();
-  }
+    private final Queue<Event> mEventQueue = new ArrayBlockingQueue<Event>(MAX_EVENTS_TO_TRACK);
+
+    public void recordEvent(Event event) {
+        if (mEventQueue.size() + 1 > MAX_EVENTS_TO_TRACK) {
+            mEventQueue.poll();
+        }
+        mEventQueue.add(event);
+    }
+
+    @Override
+    public String toString() {
+        return mEventQueue.toString();
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/components/RetryManager.java b/drawee/src/main/java/com/facebook/drawee/components/RetryManager.java
index dc40a5e49..1d8d27f07 100644
--- a/drawee/src/main/java/com/facebook/drawee/components/RetryManager.java
+++ b/drawee/src/main/java/com/facebook/drawee/components/RetryManager.java
@@ -13,50 +13,50 @@
  * Manages retries for an image.
  */
 public class RetryManager {
-  private static final int MAX_TAP_TO_RETRY_ATTEMPTS = 4;
-
-  private boolean mTapToRetryEnabled;
-  private int mMaxTapToRetryAttempts;
-  private int mTapToRetryAttempts;
-
-  public RetryManager() {
-    init();
-  }
-
-  public static RetryManager newInstance() {
-    return new RetryManager();
-  }
-
-  /**
-   * Initializes component to its initial state.
-   */
-  public void init() {
-    mTapToRetryEnabled = false;
-    mMaxTapToRetryAttempts = MAX_TAP_TO_RETRY_ATTEMPTS;
-    reset();
-  }
-
-  /**
-   * Resets component.
-   * This will reset the number of attempts.
-   */
-  public void reset() {
-    mTapToRetryAttempts = 0;
-  }
-
-  public boolean isTapToRetryEnabled() {
-    return mTapToRetryEnabled;
-  }
-
-  public void setTapToRetryEnabled(boolean tapToRetryEnabled) {
-    mTapToRetryEnabled = tapToRetryEnabled;
-  }
-
-  public boolean shouldRetryOnTap() {
-    return mTapToRetryEnabled && mTapToRetryAttempts < mMaxTapToRetryAttempts;
-  }
-
-  public void notifyTapToRetry() {
-    mTapToRetryAttempts++;
-  }
+    private static final int MAX_TAP_TO_RETRY_ATTEMPTS = 4;
+
+    private boolean mTapToRetryEnabled;
+    private int mMaxTapToRetryAttempts;
+    private int mTapToRetryAttempts;
+
+    public RetryManager() {
+        init();
+    }
+
+    public static RetryManager newInstance() {
+        return new RetryManager();
+    }
+
+    /**
+     * Initializes component to its initial state.
+     */
+    public void init() {
+        mTapToRetryEnabled = false;
+        mMaxTapToRetryAttempts = MAX_TAP_TO_RETRY_ATTEMPTS;
+        reset();
+    }
+
+    /**
+     * Resets component.
+     * This will reset the number of attempts.
+     */
+    public void reset() {
+        mTapToRetryAttempts = 0;
+    }
+
+    public boolean isTapToRetryEnabled() {
+        return mTapToRetryEnabled;
+    }
+
+    public void setTapToRetryEnabled(boolean tapToRetryEnabled) {
+        mTapToRetryEnabled = tapToRetryEnabled;
+    }
+
+    public boolean shouldRetryOnTap() {
+        return mTapToRetryEnabled && mTapToRetryAttempts < mMaxTapToRetryAttempts;
+    }
+
+    public void notifyTapToRetry() {
+        mTapToRetryAttempts++;
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java b/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java
index 0d583658a..156dfa63e 100644
--- a/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java
+++ b/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java
@@ -37,563 +37,620 @@
 /**
  * Abstract Drawee controller that implements common functionality
  * regardless of the backend used to fetch the image.
- *
+ * <p>
  * All methods should be called on the main UI thread.
  *
- * @param <T> image type (e.g. Bitmap)
+ * @param <T>    image type (e.g. Bitmap)
  * @param <INFO> image info type (can be same as T)
  */
 @NotThreadSafe
 public abstract class AbstractDraweeController<T, INFO> implements
-    DraweeController,
-    DeferredReleaser.Releasable,
-    GestureDetector.ClickListener {
-
-  /**
-   * This class is used to allow an optimization of not creating a ForwardingControllerListener
-   * when there is only a single controller listener.
-   */
-  private static class InternalForwardingListener<INFO> extends ForwardingControllerListener<INFO> {
-    public static <INFO> InternalForwardingListener<INFO> createInternal(
-        ControllerListener<? super INFO> listener1,
-        ControllerListener<? super INFO> listener2) {
-      InternalForwardingListener<INFO> forwarder = new InternalForwardingListener<INFO>();
-      forwarder.addListener(listener1);
-      forwarder.addListener(listener2);
-      return forwarder;
-    }
-  }
-
-  private static final Class<?> TAG = AbstractDraweeController.class;
-
-  // Components
-  private final DraweeEventTracker mEventTracker = new DraweeEventTracker();
-  private final DeferredReleaser mDeferredReleaser;
-  private final Executor mUiThreadImmediateExecutor;
-
-  // Optional components
-  private @Nullable RetryManager mRetryManager;
-  private @Nullable GestureDetector mGestureDetector;
-  private @Nullable ControllerListener<INFO> mControllerListener;
-
-  // Hierarchy
-  private @Nullable SettableDraweeHierarchy mSettableDraweeHierarchy;
-  private @Nullable Drawable mControllerOverlay;
-
-  // Constant state (non-final because controllers can be reused)
-  private String mId;
-  private Object mCallerContext;
-
-  // Mutable state
-  private boolean mIsAttached;
-  private boolean mIsRequestSubmitted;
-  private boolean mHasFetchFailed;
-  private @Nullable DataSource<T> mDataSource;
-  private @Nullable T mFetchedImage;
-  private @Nullable Drawable mDrawable;
-
-  public AbstractDraweeController(
-      DeferredReleaser deferredReleaser,
-      Executor uiThreadImmediateExecutor,
-      String id,
-      Object callerContext) {
-    mDeferredReleaser = deferredReleaser;
-    mUiThreadImmediateExecutor = uiThreadImmediateExecutor;
-    init(id, callerContext);
-  }
-
-  /**
-   * Initializes this controller with the new id and caller context.
-   * This allows for reusing of the existing controller instead of instantiating a new one.
-   * This method should be called when the controller is in detached state.
-   * @param id unique id for this controller
-   * @param callerContext tag and context for this controller
-   */
-  protected void initialize(String id, Object callerContext) {
-    init(id, callerContext);
-  }
-
-  private void init(String id, Object callerContext) {
-    mEventTracker.recordEvent(Event.ON_INIT_CONTROLLER);
-    // cancel deferred release
-    if (mDeferredReleaser != null) {
-      mDeferredReleaser.cancelDeferredRelease(this);
-    }
-    // reinitialize mutable state (fetch state)
-    mIsAttached = false;
-    releaseFetch();
-    // reinitialize optional components
-    if (mRetryManager != null) {
-      mRetryManager.init();
-    }
-    if (mGestureDetector != null) {
-      mGestureDetector.init();
-      mGestureDetector.setClickListener(this);
-    }
-    if (mControllerListener instanceof InternalForwardingListener) {
-      ((InternalForwardingListener) mControllerListener).clearListeners();
-    } else {
-      mControllerListener = null;
-    }
-    // clear hierarchy and controller overlay
-    if (mSettableDraweeHierarchy != null) {
-      mSettableDraweeHierarchy.reset();
-      mSettableDraweeHierarchy.setControllerOverlay(null);
-      mSettableDraweeHierarchy = null;
-    }
-    mControllerOverlay = null;
-    // reinitialize constant state
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(TAG, "controller %x %s -> %s: initialize", System.identityHashCode(this), mId, id);
-    }
-    mId = id;
-    mCallerContext = callerContext;
-  }
-
-  @Override
-  public void release() {
-    mEventTracker.recordEvent(Event.ON_RELEASE_CONTROLLER);
-    if (mRetryManager != null) {
-      mRetryManager.reset();
-    }
-    if (mGestureDetector != null) {
-      mGestureDetector.reset();
-    }
-    if (mSettableDraweeHierarchy != null) {
-      mSettableDraweeHierarchy.reset();
-    }
-    releaseFetch();
-  }
-
-  private void releaseFetch() {
-    boolean wasRequestSubmitted = mIsRequestSubmitted;
-    mIsRequestSubmitted = false;
-    mHasFetchFailed = false;
-    if (mDataSource != null) {
-      mDataSource.close();
-      mDataSource = null;
-    }
-    if (mDrawable != null) {
-      releaseDrawable(mDrawable);
-    }
-    mDrawable = null;
-    if (mFetchedImage != null) {
-      logMessageAndImage("release", mFetchedImage);
-      releaseImage(mFetchedImage);
-      mFetchedImage = null;
-    }
-    if (wasRequestSubmitted) {
-      getControllerListener().onRelease(mId);
-    }
-  }
-
-  /** Gets the controller id. */
-  public String getId() {
-    return mId;
-  }
-
-  /** Gets the analytic tag & caller context */
-  public Object getCallerContext() {
-    return mCallerContext;
-  }
-
-  /** Gets retry manager. */
-  protected @Nullable RetryManager getRetryManager() {
-    return mRetryManager;
-  }
-
-  /** Sets retry manager. */
-  protected void setRetryManager(@Nullable RetryManager retryManager) {
-    mRetryManager = retryManager;
-  }
-
-  /** Gets gesture detector. */
-  protected @Nullable GestureDetector getGestureDetector() {
-    return mGestureDetector;
-  }
-
-  /** Sets gesture detector. */
-  protected void setGestureDetector(@Nullable GestureDetector gestureDetector) {
-    mGestureDetector = gestureDetector;
-    if (mGestureDetector != null) {
-      mGestureDetector.setClickListener(this);
-    }
-  }
-
-  /** Adds controller listener. */
-  public void addControllerListener(ControllerListener<? super INFO> controllerListener) {
-    Preconditions.checkNotNull(controllerListener);
-    if (mControllerListener instanceof InternalForwardingListener) {
-      ((InternalForwardingListener<INFO>) mControllerListener).addListener(controllerListener);
-      return;
-    }
-    if (mControllerListener != null) {
-      mControllerListener = InternalForwardingListener.createInternal(
-          mControllerListener,
-          controllerListener);
-      return;
-    }
-    // Listener only receives <INFO>, it never produces one.
-    // That means if it can accept <? super INFO>, it can very well accept <INFO>.
-    mControllerListener = (ControllerListener<INFO>) controllerListener;
-  }
-
-  /** Removes controller listener. */
-  public void removeControllerListener(ControllerListener<? super INFO> controllerListener) {
-    Preconditions.checkNotNull(controllerListener);
-    if (mControllerListener instanceof InternalForwardingListener) {
-      ((InternalForwardingListener<INFO>) mControllerListener).removeListener(controllerListener);
-      return;
-    }
-    if (mControllerListener == controllerListener) {
-      mControllerListener = null;
-    }
-  }
-
-  /** Gets controller listener for internal use. */
-  protected ControllerListener<INFO> getControllerListener() {
-    if (mControllerListener == null) {
-      return BaseControllerListener.getNoOpListener();
-    }
-    return mControllerListener;
-  }
-
-  /** Gets the hierarchy */
-  @Override
-  public @Nullable
-  DraweeHierarchy getHierarchy() {
-    return mSettableDraweeHierarchy;
-  }
-
-  /**
-   * Sets the hierarchy.
-   *
-   * <p>The controller should be detached when this method is called.
-   * @param hierarchy This must be an instance of {@link SettableDraweeHierarchy}
-   */
-  @Override
-  public void setHierarchy(@Nullable DraweeHierarchy hierarchy) {
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(
-          TAG,
-          "controller %x %s: setHierarchy: %s",
-          System.identityHashCode(this),
-          mId,
-          hierarchy);
-    }
-    mEventTracker.recordEvent(
-        (hierarchy != null) ? Event.ON_SET_HIERARCHY : Event.ON_CLEAR_HIERARCHY);
-    // force release in case request was submitted
-    if (mIsRequestSubmitted) {
-      mDeferredReleaser.cancelDeferredRelease(this);
-      release();
-    }
-    // clear the existing hierarchy
-    if (mSettableDraweeHierarchy != null) {
-      mSettableDraweeHierarchy.setControllerOverlay(null);
-      mSettableDraweeHierarchy = null;
-    }
-    // set the new hierarchy
-    if (hierarchy != null) {
-      Preconditions.checkArgument(hierarchy instanceof SettableDraweeHierarchy);
-      mSettableDraweeHierarchy = (SettableDraweeHierarchy) hierarchy;
-      mSettableDraweeHierarchy.setControllerOverlay(mControllerOverlay);
-    }
-  }
-
-  /** Sets the controller overlay */
-  protected void setControllerOverlay(@Nullable Drawable controllerOverlay) {
-    mControllerOverlay = controllerOverlay;
-    if (mSettableDraweeHierarchy != null) {
-      mSettableDraweeHierarchy.setControllerOverlay(mControllerOverlay);
-    }
-  }
-
-  /** Gets the controller overlay */
-  protected @Nullable Drawable getControllerOverlay() {
-    return mControllerOverlay;
-  }
-
-  @Override
-  public void onAttach() {
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(
-          TAG,
-          "controller %x %s: onAttach: %s",
-          System.identityHashCode(this),
-          mId,
-          mIsRequestSubmitted ? "request already submitted" : "request needs submit");
-    }
-    mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);
-    Preconditions.checkNotNull(mSettableDraweeHierarchy);
-    mDeferredReleaser.cancelDeferredRelease(this);
-    mIsAttached = true;
-    if (!mIsRequestSubmitted) {
-      submitRequest();
-    }
-  }
-
-  @Override
-  public void onDetach() {
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(TAG, "controller %x %s: onDetach", System.identityHashCode(this), mId);
-    }
-    mEventTracker.recordEvent(Event.ON_DETACH_CONTROLLER);
-    mIsAttached = false;
-    mDeferredReleaser.scheduleDeferredRelease(this);
-  }
-
-  @Override
-  public boolean onTouchEvent(MotionEvent event) {
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(TAG, "controller %x %s: onTouchEvent %s", System.identityHashCode(this), mId, event);
-    }
-    if (mGestureDetector == null) {
-      return false;
-    }
-    if (mGestureDetector.isCapturingGesture() || shouldHandleGesture()) {
-      mGestureDetector.onTouchEvent(event);
-      return true;
-    }
-    return false;
-  }
-
-  /** Returns whether the gesture should be handled by the controller */
-  protected boolean shouldHandleGesture() {
-    return shouldRetryOnTap();
-  }
-
-  private boolean shouldRetryOnTap() {
-    // We should only handle touch event if we are expecting some gesture.
-    // For example, we expect click when fetch fails and tap-to-retry is enabled.
-    return mHasFetchFailed && mRetryManager != null && mRetryManager.shouldRetryOnTap();
-  }
-
-  @Override
-  public boolean onClick() {
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(TAG, "controller %x %s: onClick", System.identityHashCode(this), mId);
-    }
-    if (shouldRetryOnTap()) {
-      mRetryManager.notifyTapToRetry();
-      mSettableDraweeHierarchy.reset();
-      submitRequest();
-      return true;
-    }
-    return false;
-  }
-
-  protected void submitRequest() {
-    mEventTracker.recordEvent(Event.ON_DATASOURCE_SUBMIT);
-    getControllerListener().onSubmit(mId, mCallerContext);
-    mSettableDraweeHierarchy.setProgress(0, true);
-    mIsRequestSubmitted = true;
-    mHasFetchFailed = false;
-    mDataSource = getDataSource();
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(
-          TAG,
-          "controller %x %s: submitRequest: dataSource: %x",
-          System.identityHashCode(this),
-          mId,
-          System.identityHashCode(mDataSource));
-    }
-    final String id = mId;
-    final boolean wasImmediate = mDataSource.hasResult();
-    final DataSubscriber<T> dataSubscriber =
-        new BaseDataSubscriber<T>() {
-          @Override
-          public void onNewResultImpl(DataSource<T> dataSource) {
-            // isFinished must be obtained before image, otherwise we might set intermediate result
-            // as final image.
-            boolean isFinished = dataSource.isFinished();
-            float progress = dataSource.getProgress();
-            T image = dataSource.getResult();
-            if (image != null) {
-              onNewResultInternal(id, dataSource, image, progress, isFinished, wasImmediate);
-            } else if (isFinished) {
-              onFailureInternal(id, dataSource, new NullPointerException(), /* isFinished */ true);
+        DraweeController,
+        DeferredReleaser.Releasable,
+        GestureDetector.ClickListener {
+
+    /**
+     * This class is used to allow an optimization of not creating a ForwardingControllerListener
+     * when there is only a single controller listener.
+     */
+    private static class InternalForwardingListener<INFO> extends ForwardingControllerListener<INFO> {
+        public static <INFO> InternalForwardingListener<INFO> createInternal(
+                ControllerListener<? super INFO> listener1,
+                ControllerListener<? super INFO> listener2) {
+            InternalForwardingListener<INFO> forwarder = new InternalForwardingListener<INFO>();
+            forwarder.addListener(listener1);
+            forwarder.addListener(listener2);
+            return forwarder;
+        }
+    }
+
+    private static final Class<?> TAG = AbstractDraweeController.class;
+
+    // Components
+    private final DraweeEventTracker mEventTracker = new DraweeEventTracker();
+    private final DeferredReleaser mDeferredReleaser;
+    private final Executor mUiThreadImmediateExecutor;
+
+    // Optional components
+    private
+    @Nullable
+    RetryManager mRetryManager;
+    private
+    @Nullable
+    GestureDetector mGestureDetector;
+    private
+    @Nullable
+    ControllerListener<INFO> mControllerListener;
+
+    // Hierarchy
+    private
+    @Nullable
+    SettableDraweeHierarchy mSettableDraweeHierarchy;
+    private
+    @Nullable
+    Drawable mControllerOverlay;
+
+    // Constant state (non-final because controllers can be reused)
+    private String mId;
+    private Object mCallerContext;
+
+    // Mutable state
+    private boolean mIsAttached;
+    private boolean mIsRequestSubmitted;
+    private boolean mHasFetchFailed;
+    private
+    @Nullable
+    DataSource<T> mDataSource;
+    private
+    @Nullable
+    T mFetchedImage;
+    private
+    @Nullable
+    Drawable mDrawable;
+
+    public AbstractDraweeController(
+            DeferredReleaser deferredReleaser,
+            Executor uiThreadImmediateExecutor,
+            String id,
+            Object callerContext) {
+        mDeferredReleaser = deferredReleaser;
+        mUiThreadImmediateExecutor = uiThreadImmediateExecutor;
+        init(id, callerContext);
+    }
+
+    /**
+     * Initializes this controller with the new id and caller context.
+     * This allows for reusing of the existing controller instead of instantiating a new one.
+     * This method should be called when the controller is in detached state.
+     *
+     * @param id            unique id for this controller
+     * @param callerContext tag and context for this controller
+     */
+    protected void initialize(String id, Object callerContext) {
+        init(id, callerContext);
+    }
+
+    private void init(String id, Object callerContext) {
+        mEventTracker.recordEvent(Event.ON_INIT_CONTROLLER);
+        // cancel deferred release
+        if (mDeferredReleaser != null) {
+            mDeferredReleaser.cancelDeferredRelease(this);
+        }
+        // reinitialize mutable state (fetch state)
+        mIsAttached = false;
+        releaseFetch();
+        // reinitialize optional components
+        if (mRetryManager != null) {
+            mRetryManager.init();
+        }
+        if (mGestureDetector != null) {
+            mGestureDetector.init();
+            mGestureDetector.setClickListener(this);
+        }
+        if (mControllerListener instanceof InternalForwardingListener) {
+            ((InternalForwardingListener) mControllerListener).clearListeners();
+        } else {
+            mControllerListener = null;
+        }
+        // clear hierarchy and controller overlay
+        if (mSettableDraweeHierarchy != null) {
+            mSettableDraweeHierarchy.reset();
+            mSettableDraweeHierarchy.setControllerOverlay(null);
+            mSettableDraweeHierarchy = null;
+        }
+        mControllerOverlay = null;
+        // reinitialize constant state
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(TAG, "controller %x %s -> %s: initialize", System.identityHashCode(this), mId, id);
+        }
+        mId = id;
+        mCallerContext = callerContext;
+    }
+
+    @Override
+    public void release() {
+        mEventTracker.recordEvent(Event.ON_RELEASE_CONTROLLER);
+        if (mRetryManager != null) {
+            mRetryManager.reset();
+        }
+        if (mGestureDetector != null) {
+            mGestureDetector.reset();
+        }
+        if (mSettableDraweeHierarchy != null) {
+            mSettableDraweeHierarchy.reset();
+        }
+        releaseFetch();
+    }
+
+    private void releaseFetch() {
+        boolean wasRequestSubmitted = mIsRequestSubmitted;
+        mIsRequestSubmitted = false;
+        mHasFetchFailed = false;
+        if (mDataSource != null) {
+            mDataSource.close();
+            mDataSource = null;
+        }
+        if (mDrawable != null) {
+            releaseDrawable(mDrawable);
+        }
+        mDrawable = null;
+        if (mFetchedImage != null) {
+            logMessageAndImage("release", mFetchedImage);
+            releaseImage(mFetchedImage);
+            mFetchedImage = null;
+        }
+        if (wasRequestSubmitted) {
+            getControllerListener().onRelease(mId);
+        }
+    }
+
+    /**
+     * Gets the controller id.
+     */
+    public String getId() {
+        return mId;
+    }
+
+    /**
+     * Gets the analytic tag & caller context
+     */
+    public Object getCallerContext() {
+        return mCallerContext;
+    }
+
+    /**
+     * Gets retry manager.
+     */
+    protected
+    @Nullable
+    RetryManager getRetryManager() {
+        return mRetryManager;
+    }
+
+    /**
+     * Sets retry manager.
+     */
+    protected void setRetryManager(@Nullable RetryManager retryManager) {
+        mRetryManager = retryManager;
+    }
+
+    /**
+     * Gets gesture detector.
+     */
+    protected
+    @Nullable
+    GestureDetector getGestureDetector() {
+        return mGestureDetector;
+    }
+
+    /**
+     * Sets gesture detector.
+     */
+    protected void setGestureDetector(@Nullable GestureDetector gestureDetector) {
+        mGestureDetector = gestureDetector;
+        if (mGestureDetector != null) {
+            mGestureDetector.setClickListener(this);
+        }
+    }
+
+    /**
+     * Adds controller listener.
+     */
+    public void addControllerListener(ControllerListener<? super INFO> controllerListener) {
+        Preconditions.checkNotNull(controllerListener);
+        if (mControllerListener instanceof InternalForwardingListener) {
+            ((InternalForwardingListener<INFO>) mControllerListener).addListener(controllerListener);
+            return;
+        }
+        if (mControllerListener != null) {
+            mControllerListener = InternalForwardingListener.createInternal(
+                    mControllerListener,
+                    controllerListener);
+            return;
+        }
+        // Listener only receives <INFO>, it never produces one.
+        // That means if it can accept <? super INFO>, it can very well accept <INFO>.
+        mControllerListener = (ControllerListener<INFO>) controllerListener;
+    }
+
+    /**
+     * Removes controller listener.
+     */
+    public void removeControllerListener(ControllerListener<? super INFO> controllerListener) {
+        Preconditions.checkNotNull(controllerListener);
+        if (mControllerListener instanceof InternalForwardingListener) {
+            ((InternalForwardingListener<INFO>) mControllerListener).removeListener(controllerListener);
+            return;
+        }
+        if (mControllerListener == controllerListener) {
+            mControllerListener = null;
+        }
+    }
+
+    /**
+     * Gets controller listener for internal use.
+     */
+    protected ControllerListener<INFO> getControllerListener() {
+        if (mControllerListener == null) {
+            return BaseControllerListener.getNoOpListener();
+        }
+        return mControllerListener;
+    }
+
+    /**
+     * Gets the hierarchy
+     */
+    @Override
+    public
+    @Nullable
+    DraweeHierarchy getHierarchy() {
+        return mSettableDraweeHierarchy;
+    }
+
+    /**
+     * Sets the hierarchy.
+     * <p>
+     * <p>The controller should be detached when this method is called.
+     *
+     * @param hierarchy This must be an instance of {@link SettableDraweeHierarchy}
+     */
+    @Override
+    public void setHierarchy(@Nullable DraweeHierarchy hierarchy) {
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(
+                    TAG,
+                    "controller %x %s: setHierarchy: %s",
+                    System.identityHashCode(this),
+                    mId,
+                    hierarchy);
+        }
+        mEventTracker.recordEvent(
+                (hierarchy != null) ? Event.ON_SET_HIERARCHY : Event.ON_CLEAR_HIERARCHY);
+        // force release in case request was submitted
+        if (mIsRequestSubmitted) {
+            mDeferredReleaser.cancelDeferredRelease(this);
+            release();
+        }
+        // clear the existing hierarchy
+        if (mSettableDraweeHierarchy != null) {
+            mSettableDraweeHierarchy.setControllerOverlay(null);
+            mSettableDraweeHierarchy = null;
+        }
+        // set the new hierarchy
+        if (hierarchy != null) {
+            Preconditions.checkArgument(hierarchy instanceof SettableDraweeHierarchy);
+            mSettableDraweeHierarchy = (SettableDraweeHierarchy) hierarchy;
+            mSettableDraweeHierarchy.setControllerOverlay(mControllerOverlay);
+        }
+    }
+
+    /**
+     * Sets the controller overlay
+     */
+    protected void setControllerOverlay(@Nullable Drawable controllerOverlay) {
+        mControllerOverlay = controllerOverlay;
+        if (mSettableDraweeHierarchy != null) {
+            mSettableDraweeHierarchy.setControllerOverlay(mControllerOverlay);
+        }
+    }
+
+    /**
+     * Gets the controller overlay
+     */
+    protected
+    @Nullable
+    Drawable getControllerOverlay() {
+        return mControllerOverlay;
+    }
+
+    @Override
+    public void onAttach() {
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(
+                    TAG,
+                    "controller %x %s: onAttach: %s",
+                    System.identityHashCode(this),
+                    mId,
+                    mIsRequestSubmitted ? "request already submitted" : "request needs submit");
+        }
+        mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);
+        Preconditions.checkNotNull(mSettableDraweeHierarchy);
+        mDeferredReleaser.cancelDeferredRelease(this);
+        mIsAttached = true;
+        if (!mIsRequestSubmitted) {
+            submitRequest();
+        }
+    }
+
+    @Override
+    public void onDetach() {
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(TAG, "controller %x %s: onDetach", System.identityHashCode(this), mId);
+        }
+        mEventTracker.recordEvent(Event.ON_DETACH_CONTROLLER);
+        mIsAttached = false;
+        mDeferredReleaser.scheduleDeferredRelease(this);
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(TAG, "controller %x %s: onTouchEvent %s", System.identityHashCode(this), mId, event);
+        }
+        if (mGestureDetector == null) {
+            return false;
+        }
+        if (mGestureDetector.isCapturingGesture() || shouldHandleGesture()) {
+            mGestureDetector.onTouchEvent(event);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Returns whether the gesture should be handled by the controller
+     */
+    protected boolean shouldHandleGesture() {
+        return shouldRetryOnTap();
+    }
+
+    private boolean shouldRetryOnTap() {
+        // We should only handle touch event if we are expecting some gesture.
+        // For example, we expect click when fetch fails and tap-to-retry is enabled.
+        return mHasFetchFailed && mRetryManager != null && mRetryManager.shouldRetryOnTap();
+    }
+
+    @Override
+    public boolean onClick() {
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(TAG, "controller %x %s: onClick", System.identityHashCode(this), mId);
+        }
+        if (shouldRetryOnTap()) {
+            mRetryManager.notifyTapToRetry();
+            mSettableDraweeHierarchy.reset();
+            submitRequest();
+            return true;
+        }
+        return false;
+    }
+
+    protected void submitRequest() {
+        mEventTracker.recordEvent(Event.ON_DATASOURCE_SUBMIT);
+        getControllerListener().onSubmit(mId, mCallerContext);
+        mSettableDraweeHierarchy.setProgress(0, true);
+        mIsRequestSubmitted = true;
+        mHasFetchFailed = false;
+        mDataSource = getDataSource();
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(
+                    TAG,
+                    "controller %x %s: submitRequest: dataSource: %x",
+                    System.identityHashCode(this),
+                    mId,
+                    System.identityHashCode(mDataSource));
+        }
+        final String id = mId;
+        final boolean wasImmediate = mDataSource.hasResult();
+        final DataSubscriber<T> dataSubscriber =
+                new BaseDataSubscriber<T>() {
+                    @Override
+                    public void onNewResultImpl(DataSource<T> dataSource) {
+                        // isFinished must be obtained before image, otherwise we might set intermediate result
+                        // as final image.
+                        boolean isFinished = dataSource.isFinished();
+                        float progress = dataSource.getProgress();
+                        T image = dataSource.getResult();
+                        if (image != null) {
+                            onNewResultInternal(id, dataSource, image, progress, isFinished, wasImmediate);
+                        } else if (isFinished) {
+                            onFailureInternal(id, dataSource, new NullPointerException(), /* isFinished */ true);
+                        }
+                    }
+
+                    @Override
+                    public void onFailureImpl(DataSource<T> dataSource) {
+                        onFailureInternal(id, dataSource, dataSource.getFailureCause(), /* isFinished */ true);
+                    }
+
+                    @Override
+                    public void onProgressUpdate(DataSource<T> dataSource) {
+                        boolean isFinished = dataSource.isFinished();
+                        float progress = dataSource.getProgress();
+                        onProgressUpdateInternal(id, dataSource, progress, isFinished);
+                    }
+                };
+        mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);
+    }
+
+    private void onNewResultInternal(
+            String id,
+            DataSource<T> dataSource,
+            @Nullable T image,
+            float progress,
+            boolean isFinished,
+            boolean wasImmediate) {
+        // ignore late callbacks (data source that returned the new result is not the one we expected)
+        if (!isExpectedDataSource(id, dataSource)) {
+            logMessageAndImage("ignore_old_datasource @ onNewResult", image);
+            releaseImage(image);
+            dataSource.close();
+            return;
+        }
+        mEventTracker.recordEvent(
+                isFinished ? Event.ON_DATASOURCE_RESULT : Event.ON_DATASOURCE_RESULT_INT);
+        // create drawable
+        Drawable drawable;
+        try {
+            drawable = createDrawable(image);
+        } catch (Exception exception) {
+            logMessageAndImage("drawable_failed @ onNewResult", image);
+            releaseImage(image);
+            onFailureInternal(id, dataSource, exception, isFinished);
+            return;
+        }
+        T previousImage = mFetchedImage;
+        Drawable previousDrawable = mDrawable;
+        mFetchedImage = image;
+        mDrawable = drawable;
+        try {
+            // set the new image
+            if (isFinished) {
+                logMessageAndImage("set_final_result @ onNewResult", image);
+                mDataSource = null;
+                mSettableDraweeHierarchy.setImage(drawable, 1f, wasImmediate);
+                getControllerListener().onFinalImageSet(id, getImageInfo(image), getAnimatable());
+                // IMPORTANT: do not execute any instance-specific code after this point
+            } else {
+                logMessageAndImage("set_intermediate_result @ onNewResult", image);
+                mSettableDraweeHierarchy.setImage(drawable, progress, wasImmediate);
+                getControllerListener().onIntermediateImageSet(id, getImageInfo(image));
+                // IMPORTANT: do not execute any instance-specific code after this point
+            }
+        } finally {
+            if (previousDrawable != null && previousDrawable != drawable) {
+                releaseDrawable(previousDrawable);
+            }
+            if (previousImage != null && previousImage != image) {
+                logMessageAndImage("release_previous_result @ onNewResult", previousImage);
+                releaseImage(previousImage);
             }
-          }
-          @Override
-          public void onFailureImpl(DataSource<T> dataSource) {
-            onFailureInternal(id, dataSource, dataSource.getFailureCause(), /* isFinished */ true);
-          }
-          @Override
-          public void onProgressUpdate(DataSource<T> dataSource) {
-            boolean isFinished = dataSource.isFinished();
-            float progress = dataSource.getProgress();
-            onProgressUpdateInternal(id, dataSource, progress, isFinished);
-          }
-        };
-    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);
-  }
-
-  private void onNewResultInternal(
-      String id,
-      DataSource<T> dataSource,
-      @Nullable T image,
-      float progress,
-      boolean isFinished,
-      boolean wasImmediate) {
-    // ignore late callbacks (data source that returned the new result is not the one we expected)
-    if (!isExpectedDataSource(id, dataSource)) {
-      logMessageAndImage("ignore_old_datasource @ onNewResult", image);
-      releaseImage(image);
-      dataSource.close();
-      return;
-    }
-    mEventTracker.recordEvent(
-        isFinished ? Event.ON_DATASOURCE_RESULT : Event.ON_DATASOURCE_RESULT_INT);
-    // create drawable
-    Drawable drawable;
-    try {
-      drawable = createDrawable(image);
-    } catch (Exception exception) {
-      logMessageAndImage("drawable_failed @ onNewResult", image);
-      releaseImage(image);
-      onFailureInternal(id, dataSource, exception, isFinished);
-      return;
-    }
-    T previousImage = mFetchedImage;
-    Drawable previousDrawable = mDrawable;
-    mFetchedImage = image;
-    mDrawable = drawable;
-    try {
-      // set the new image
-      if (isFinished) {
-        logMessageAndImage("set_final_result @ onNewResult", image);
-        mDataSource = null;
-        mSettableDraweeHierarchy.setImage(drawable, 1f, wasImmediate);
-        getControllerListener().onFinalImageSet(id, getImageInfo(image), getAnimatable());
-        // IMPORTANT: do not execute any instance-specific code after this point
-      } else {
-        logMessageAndImage("set_intermediate_result @ onNewResult", image);
-        mSettableDraweeHierarchy.setImage(drawable, progress, wasImmediate);
-        getControllerListener().onIntermediateImageSet(id, getImageInfo(image));
-        // IMPORTANT: do not execute any instance-specific code after this point
-      }
-    } finally {
-      if (previousDrawable != null && previousDrawable != drawable) {
-        releaseDrawable(previousDrawable);
-      }
-      if (previousImage != null && previousImage != image) {
-        logMessageAndImage("release_previous_result @ onNewResult", previousImage);
-        releaseImage(previousImage);
-      }
-    }
-  }
-
-  private void onFailureInternal(
-      String id,
-      DataSource<T> dataSource,
-      Throwable throwable,
-      boolean isFinished) {
-    // ignore late callbacks (data source that failed is not the one we expected)
-    if (!isExpectedDataSource(id, dataSource)) {
-      logMessageAndFailure("ignore_old_datasource @ onFailure", throwable);
-      dataSource.close();
-      return;
-    }
-    mEventTracker.recordEvent(
-        isFinished ? Event.ON_DATASOURCE_FAILURE : Event.ON_DATASOURCE_FAILURE_INT);
-    // fail only if the data source is finished
-    if (isFinished) {
-      logMessageAndFailure("final_failed @ onFailure", throwable);
-      mDataSource = null;
-      mHasFetchFailed = true;
-      if (shouldRetryOnTap()) {
-        mSettableDraweeHierarchy.setRetry(throwable);
-      } else {
-        mSettableDraweeHierarchy.setFailure(throwable);
-      }
-      getControllerListener().onFailure(mId, throwable);
-      // IMPORTANT: do not execute any instance-specific code after this point
-    } else {
-      logMessageAndFailure("intermediate_failed @ onFailure", throwable);
-      getControllerListener().onIntermediateImageFailed(mId, throwable);
-      // IMPORTANT: do not execute any instance-specific code after this point
-    }
-  }
-
-  private void onProgressUpdateInternal(
-      String id,
-      DataSource<T> dataSource,
-      float progress,
-      boolean isFinished) {
-    // ignore late callbacks (data source that failed is not the one we expected)
-    if (!isExpectedDataSource(id, dataSource)) {
-      logMessageAndFailure("ignore_old_datasource @ onProgress", null);
-      dataSource.close();
-      return;
-    }
-    if (!isFinished) {
-      mSettableDraweeHierarchy.setProgress(progress, false);
-    }
-  }
-
-  private boolean isExpectedDataSource(String id, DataSource<T> dataSource) {
-    // There are several situations in which an old data source might return a result that we are no
-    // longer interested in. To verify that the result is indeed expected, we check several things:
-    return id.equals(mId) && dataSource == mDataSource && mIsRequestSubmitted;
-  }
-
-  private void logMessageAndImage(String messageAndMethod, T image) {
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(
-          TAG,
-          "controller %x %s: %s: image: %s %x",
-          System.identityHashCode(this),
-          mId,
-          messageAndMethod,
-          getImageClass(image),
-          getImageHash(image));
-    }
-  }
-
-  private void logMessageAndFailure(String messageAndMethod, Throwable throwable) {
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(
-          TAG,
-          "controller %x %s: %s: failure: %s",
-          System.identityHashCode(this),
-          mId,
-          messageAndMethod,
-          throwable);
-    }
-  }
-
-  @Override
-  public @Nullable Animatable getAnimatable() {
-    return (mDrawable instanceof Animatable) ? (Animatable) mDrawable : null;
-  }
-
-  protected abstract DataSource<T> getDataSource();
-
-  protected abstract Drawable createDrawable(T image);
-
-  protected abstract @Nullable INFO getImageInfo(T image);
-
-  protected String getImageClass(@Nullable T image) {
-    return (image != null) ? image.getClass().getSimpleName() : "<null>";
-  }
-
-  protected int getImageHash(@Nullable T image) {
-    return System.identityHashCode(image);
-  }
-
-  protected abstract void releaseImage(@Nullable T image);
-
-  protected abstract void releaseDrawable(@Nullable Drawable drawable);
-
-  @Override
-  public String toString() {
-    return Objects.toStringHelper(this)
-        .add("isAttached", mIsAttached)
-        .add("isRequestSubmitted", mIsRequestSubmitted)
-        .add("hasFetchFailed", mHasFetchFailed)
-        .add("fetchedImage", getImageHash(mFetchedImage))
-        .add("events", mEventTracker.toString())
-        .toString();
-  }
+        }
+    }
+
+    private void onFailureInternal(
+            String id,
+            DataSource<T> dataSource,
+            Throwable throwable,
+            boolean isFinished) {
+        // ignore late callbacks (data source that failed is not the one we expected)
+        if (!isExpectedDataSource(id, dataSource)) {
+            logMessageAndFailure("ignore_old_datasource @ onFailure", throwable);
+            dataSource.close();
+            return;
+        }
+        mEventTracker.recordEvent(
+                isFinished ? Event.ON_DATASOURCE_FAILURE : Event.ON_DATASOURCE_FAILURE_INT);
+        // fail only if the data source is finished
+        if (isFinished) {
+            logMessageAndFailure("final_failed @ onFailure", throwable);
+            mDataSource = null;
+            mHasFetchFailed = true;
+            if (shouldRetryOnTap()) {
+                mSettableDraweeHierarchy.setRetry(throwable);
+            } else {
+                mSettableDraweeHierarchy.setFailure(throwable);
+            }
+            getControllerListener().onFailure(mId, throwable);
+            // IMPORTANT: do not execute any instance-specific code after this point
+        } else {
+            logMessageAndFailure("intermediate_failed @ onFailure", throwable);
+            getControllerListener().onIntermediateImageFailed(mId, throwable);
+            // IMPORTANT: do not execute any instance-specific code after this point
+        }
+    }
+
+    private void onProgressUpdateInternal(
+            String id,
+            DataSource<T> dataSource,
+            float progress,
+            boolean isFinished) {
+        // ignore late callbacks (data source that failed is not the one we expected)
+        if (!isExpectedDataSource(id, dataSource)) {
+            logMessageAndFailure("ignore_old_datasource @ onProgress", null);
+            dataSource.close();
+            return;
+        }
+        if (!isFinished) {
+            mSettableDraweeHierarchy.setProgress(progress, false);
+        }
+    }
+
+    private boolean isExpectedDataSource(String id, DataSource<T> dataSource) {
+        // There are several situations in which an old data source might return a result that we are no
+        // longer interested in. To verify that the result is indeed expected, we check several things:
+        return id.equals(mId) && dataSource == mDataSource && mIsRequestSubmitted;
+    }
+
+    private void logMessageAndImage(String messageAndMethod, T image) {
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(
+                    TAG,
+                    "controller %x %s: %s: image: %s %x",
+                    System.identityHashCode(this),
+                    mId,
+                    messageAndMethod,
+                    getImageClass(image),
+                    getImageHash(image));
+        }
+    }
+
+    private void logMessageAndFailure(String messageAndMethod, Throwable throwable) {
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(
+                    TAG,
+                    "controller %x %s: %s: failure: %s",
+                    System.identityHashCode(this),
+                    mId,
+                    messageAndMethod,
+                    throwable);
+        }
+    }
+
+    @Override
+    public
+    @Nullable
+    Animatable getAnimatable() {
+        return (mDrawable instanceof Animatable) ? (Animatable) mDrawable : null;
+    }
+
+    protected abstract DataSource<T> getDataSource();
+
+    protected abstract Drawable createDrawable(T image);
+
+    protected abstract
+    @Nullable
+    INFO getImageInfo(T image);
+
+    protected String getImageClass(@Nullable T image) {
+        return (image != null) ? image.getClass().getSimpleName() : "<null>";
+    }
+
+    protected int getImageHash(@Nullable T image) {
+        return System.identityHashCode(image);
+    }
+
+    protected abstract void releaseImage(@Nullable T image);
+
+    protected abstract void releaseDrawable(@Nullable Drawable drawable);
+
+    @Override
+    public String toString() {
+        return Objects.toStringHelper(this)
+                .add("isAttached", mIsAttached)
+                .add("isRequestSubmitted", mIsRequestSubmitted)
+                .add("hasFetchFailed", mHasFetchFailed)
+                .add("fetchedImage", getImageHash(mFetchedImage))
+                .add("events", mEventTracker.toString())
+                .toString();
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeControllerBuilder.java b/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeControllerBuilder.java
index 20eabfeea..6419f6903 100644
--- a/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeControllerBuilder.java
+++ b/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeControllerBuilder.java
@@ -34,364 +34,435 @@
 /**
  * Base implementation for Drawee controller builders.
  */
-public abstract class AbstractDraweeControllerBuilder <
-    BUILDER extends AbstractDraweeControllerBuilder<BUILDER, REQUEST, IMAGE, INFO>,
-    REQUEST,
-    IMAGE,
-    INFO>
-    implements SimpleDraweeControllerBuilder {
-
-  private static final ControllerListener<Object> sAutoPlayAnimationsListener =
-      new BaseControllerListener<Object>() {
-        @Override
-        public void onFinalImageSet(String id, @Nullable Object info, @Nullable Animatable anim) {
-          if (anim != null) {
-            anim.start();
-          }
+public abstract class AbstractDraweeControllerBuilder<
+        BUILDER extends AbstractDraweeControllerBuilder<BUILDER, REQUEST, IMAGE, INFO>,
+        REQUEST,
+        IMAGE,
+        INFO>
+        implements SimpleDraweeControllerBuilder {
+
+    private static final ControllerListener<Object> sAutoPlayAnimationsListener =
+            new BaseControllerListener<Object>() {
+                @Override
+                public void onFinalImageSet(String id, @Nullable Object info, @Nullable Animatable anim) {
+                    if (anim != null) {
+                        anim.start();
+                    }
+                }
+            };
+
+    private static final NullPointerException NO_REQUEST_EXCEPTION =
+            new NullPointerException("No image request was specified!");
+
+    // components
+    private final Context mContext;
+    private final Set<ControllerListener> mBoundControllerListeners;
+
+    // builder parameters
+    private
+    @Nullable
+    Object mCallerContext;
+    private
+    @Nullable
+    REQUEST mImageRequest;
+    private
+    @Nullable
+    REQUEST mLowResImageRequest;
+    private
+    @Nullable
+    REQUEST[] mMultiImageRequests;
+    private
+    @Nullable
+    Supplier<DataSource<IMAGE>> mDataSourceSupplier;
+    private
+    @Nullable
+    ControllerListener<? super INFO> mControllerListener;
+    private boolean mTapToRetryEnabled;
+    private boolean mAutoPlayAnimations;
+    // old controller to reuse
+    private
+    @Nullable
+    DraweeController mOldController;
+
+    private static final AtomicLong sIdCounter = new AtomicLong();
+
+    protected AbstractDraweeControllerBuilder(
+            Context context,
+            Set<ControllerListener> boundControllerListeners) {
+        mContext = context;
+        mBoundControllerListeners = boundControllerListeners;
+        init();
+    }
+
+    /**
+     * Initializes this builder.
+     */
+    private void init() {
+        mCallerContext = null;
+        mImageRequest = null;
+        mLowResImageRequest = null;
+        mMultiImageRequests = null;
+        mControllerListener = null;
+        mTapToRetryEnabled = false;
+        mAutoPlayAnimations = false;
+        mOldController = null;
+    }
+
+    /**
+     * Resets this builder to its initial values making it reusable.
+     */
+    public BUILDER reset() {
+        init();
+        return getThis();
+    }
+
+    /**
+     * Sets the caller context.
+     */
+    @Override
+    public BUILDER setCallerContext(Object callerContext) {
+        mCallerContext = callerContext;
+        return getThis();
+    }
+
+    /**
+     * Gets the caller context.
+     */
+    @Nullable
+    public Object getCallerContext() {
+        return mCallerContext;
+    }
+
+    /**
+     * Sets the image request.
+     */
+    public BUILDER setImageRequest(REQUEST imageRequest) {
+        mImageRequest = imageRequest;
+        return getThis();
+    }
+
+    /**
+     * Gets the image request.
+     */
+    @Nullable
+    public REQUEST getImageRequest() {
+        return mImageRequest;
+    }
+
+    /**
+     * Sets the low-res image request.
+     */
+    public BUILDER setLowResImageRequest(REQUEST lowResImageRequest) {
+        mLowResImageRequest = lowResImageRequest;
+        return getThis();
+    }
+
+    /**
+     * Gets the low-res image request.
+     */
+    @Nullable
+    public REQUEST getLowResImageRequest() {
+        return mLowResImageRequest;
+    }
+
+    /**
+     * Sets the array of first-available image requests that will be probed in order.
+     * <p> For performance reasons, the array is not deep-copied, but only stored by reference.
+     * Please don't modify once submitted.
+     */
+    public BUILDER setFirstAvailableImageRequests(REQUEST[] firstAvailableImageRequests) {
+        mMultiImageRequests = firstAvailableImageRequests;
+        return getThis();
+    }
+
+    /**
+     * Gets the array of first-available image requests.
+     * <p> For performance reasons, the array is not deep-copied, but only stored by reference.
+     * Please don't modify.
+     */
+    @Nullable
+    public REQUEST[] getFirstAvailableImageRequests() {
+        return mMultiImageRequests;
+    }
+
+    /**
+     * Sets the data source supplier to be used.
+     * <p>
+     * <p/> Note: This is mutually exclusive with other image request setters.
+     */
+    public void setDataSourceSupplier(@Nullable Supplier<DataSource<IMAGE>> dataSourceSupplier) {
+        mDataSourceSupplier = dataSourceSupplier;
+    }
+
+    /**
+     * Gets the data source supplier if set.
+     * <p>
+     * <p/>Important: this only returns the externally set data source (if any). Subclasses should
+     * use {#code obtainDataSourceSupplier()} to obtain a data source to be passed to the controller.
+     */
+    @Nullable
+    public Supplier<DataSource<IMAGE>> getDataSourceSupplier() {
+        return mDataSourceSupplier;
+    }
+
+    /**
+     * Sets whether tap-to-retry is enabled.
+     */
+    public BUILDER setTapToRetryEnabled(boolean enabled) {
+        mTapToRetryEnabled = enabled;
+        return getThis();
+    }
+
+    /**
+     * Gets whether tap-to-retry is enabled.
+     */
+    public boolean getTapToRetryEnabled() {
+        return mTapToRetryEnabled;
+    }
+
+    /**
+     * Sets whether to auto play animations.
+     */
+    public BUILDER setAutoPlayAnimations(boolean enabled) {
+        mAutoPlayAnimations = enabled;
+        return getThis();
+    }
+
+    /**
+     * Gets whether to auto play animations.
+     */
+    public boolean getAutoPlayAnimations() {
+        return mAutoPlayAnimations;
+    }
+
+    /**
+     * Sets the controller listener.
+     */
+    public BUILDER setControllerListener(ControllerListener<? super INFO> controllerListener) {
+        mControllerListener = controllerListener;
+        return getThis();
+    }
+
+    /**
+     * Gets the controller listener
+     */
+    @Nullable
+    public ControllerListener<? super INFO> getControllerListener() {
+        return mControllerListener;
+    }
+
+    /**
+     * Sets the old controller to be reused if possible.
+     */
+    @Override
+    public BUILDER setOldController(@Nullable DraweeController oldController) {
+        mOldController = oldController;
+        return getThis();
+    }
+
+    /**
+     * Gets the old controller to be reused.
+     */
+    @Nullable
+    public DraweeController getOldController() {
+        return mOldController;
+    }
+
+    /**
+     * Builds the specified controller.
+     */
+    @Override
+    public AbstractDraweeController build() {
+        validate();
+
+        // if only a low-res request is specified, treat it as a final request.
+        if (mImageRequest == null && mMultiImageRequests == null && mLowResImageRequest != null) {
+            mImageRequest = mLowResImageRequest;
+            mLowResImageRequest = null;
         }
-      };
-
-  private static final NullPointerException NO_REQUEST_EXCEPTION =
-      new NullPointerException("No image request was specified!");
-
-  // components
-  private final Context mContext;
-  private final Set<ControllerListener> mBoundControllerListeners;
-
-  // builder parameters
-  private @Nullable Object mCallerContext;
-  private @Nullable REQUEST mImageRequest;
-  private @Nullable REQUEST mLowResImageRequest;
-  private @Nullable REQUEST[] mMultiImageRequests;
-  private @Nullable Supplier<DataSource<IMAGE>> mDataSourceSupplier;
-  private @Nullable ControllerListener<? super INFO> mControllerListener;
-  private boolean mTapToRetryEnabled;
-  private boolean mAutoPlayAnimations;
-  // old controller to reuse
-  private @Nullable DraweeController mOldController;
-
-  private static final AtomicLong sIdCounter = new AtomicLong();
-
-  protected AbstractDraweeControllerBuilder(
-      Context context,
-      Set<ControllerListener> boundControllerListeners) {
-    mContext = context;
-    mBoundControllerListeners = boundControllerListeners;
-    init();
-  }
-
-  /** Initializes this builder. */
-  private void init() {
-    mCallerContext = null;
-    mImageRequest = null;
-    mLowResImageRequest = null;
-    mMultiImageRequests = null;
-    mControllerListener = null;
-    mTapToRetryEnabled = false;
-    mAutoPlayAnimations = false;
-    mOldController = null;
-  }
-
-  /** Resets this builder to its initial values making it reusable. */
-  public BUILDER reset() {
-    init();
-    return getThis();
-  }
-
-  /** Sets the caller context. */
-  @Override
-  public BUILDER setCallerContext(Object callerContext) {
-    mCallerContext = callerContext;
-    return getThis();
-  }
-
-  /** Gets the caller context. */
-  @Nullable
-  public Object getCallerContext() {
-    return mCallerContext;
-  }
-
-  /** Sets the image request. */
-  public BUILDER setImageRequest(REQUEST imageRequest) {
-    mImageRequest = imageRequest;
-    return getThis();
-  }
-
-  /** Gets the image request. */
-  @Nullable
-  public REQUEST getImageRequest() {
-    return mImageRequest;
-  }
-
-  /** Sets the low-res image request. */
-  public BUILDER setLowResImageRequest(REQUEST lowResImageRequest) {
-    mLowResImageRequest = lowResImageRequest;
-    return getThis();
-  }
-
-  /** Gets the low-res image request. */
-  @Nullable
-  public REQUEST getLowResImageRequest() {
-    return mLowResImageRequest;
-  }
-
-  /**
-   * Sets the array of first-available image requests that will be probed in order.
-   * <p> For performance reasons, the array is not deep-copied, but only stored by reference.
-   * Please don't modify once submitted.
-   */
-  public BUILDER setFirstAvailableImageRequests(REQUEST[] firstAvailableImageRequests) {
-    mMultiImageRequests = firstAvailableImageRequests;
-    return getThis();
-  }
-
-  /**
-   * Gets the array of first-available image requests.
-   * <p> For performance reasons, the array is not deep-copied, but only stored by reference.
-   * Please don't modify.
-   */
-  @Nullable
-  public REQUEST[] getFirstAvailableImageRequests() {
-    return mMultiImageRequests;
-  }
-
-  /**
-   *  Sets the data source supplier to be used.
-   *
-   *  <p/> Note: This is mutually exclusive with other image request setters.
-   */
-  public void setDataSourceSupplier(@Nullable Supplier<DataSource<IMAGE>> dataSourceSupplier) {
-    mDataSourceSupplier = dataSourceSupplier;
-  }
-
-  /**
-   * Gets the data source supplier if set.
-   *
-   * <p/>Important: this only returns the externally set data source (if any). Subclasses should
-   * use {#code obtainDataSourceSupplier()} to obtain a data source to be passed to the controller.
-   */
-  @Nullable
-  public Supplier<DataSource<IMAGE>> getDataSourceSupplier() {
-    return mDataSourceSupplier;
-  }
-
-  /** Sets whether tap-to-retry is enabled. */
-  public BUILDER setTapToRetryEnabled(boolean enabled) {
-    mTapToRetryEnabled = enabled;
-    return getThis();
-  }
-
-  /** Gets whether tap-to-retry is enabled. */
-  public boolean getTapToRetryEnabled() {
-    return mTapToRetryEnabled;
-  }
-
-  /** Sets whether to auto play animations. */
-  public BUILDER setAutoPlayAnimations(boolean enabled) {
-    mAutoPlayAnimations = enabled;
-    return getThis();
-  }
-
-  /** Gets whether to auto play animations. */
-  public boolean getAutoPlayAnimations() {
-    return mAutoPlayAnimations;
-  }
-
-  /** Sets the controller listener. */
-  public BUILDER setControllerListener(ControllerListener<? super INFO> controllerListener) {
-    mControllerListener = controllerListener;
-    return getThis();
-  }
-
-  /** Gets the controller listener */
-  @Nullable
-  public ControllerListener<? super INFO> getControllerListener() {
-    return mControllerListener;
-  }
-
-  /** Sets the old controller to be reused if possible. */
-  @Override
-  public BUILDER setOldController(@Nullable DraweeController oldController) {
-    mOldController = oldController;
-    return getThis();
-  }
-
-  /** Gets the old controller to be reused. */
-  @Nullable
-  public DraweeController getOldController() {
-    return mOldController;
-  }
-
-  /** Builds the specified controller. */
-  @Override
-  public AbstractDraweeController build() {
-    validate();
-
-    // if only a low-res request is specified, treat it as a final request.
-    if (mImageRequest == null && mMultiImageRequests == null && mLowResImageRequest != null) {
-      mImageRequest = mLowResImageRequest;
-      mLowResImageRequest = null;
-    }
-
-    return buildController();
-  }
-
-  /** Validates the parameters before building a controller. */
-  protected void validate() {
-    Preconditions.checkState(
-        (mMultiImageRequests == null) || (mImageRequest == null),
-        "Cannot specify both ImageRequest and FirstAvailableImageRequests!");
-    Preconditions.checkState(
-        (mDataSourceSupplier == null) ||
-            (mMultiImageRequests == null && mImageRequest == null && mLowResImageRequest == null),
-        "Cannot specify DataSourceSupplier with other ImageRequests! Use one or the other.");
-  }
-
-  /** Builds a regular controller. */
-  protected AbstractDraweeController buildController() {
-    AbstractDraweeController controller = obtainController();
-    maybeBuildAndSetRetryManager(controller);
-    maybeAttachListeners(controller);
-    return controller;
-  }
-
-  /** Generates unique controller id. */
-  protected static String generateUniqueControllerId() {
-    return String.valueOf(sIdCounter.getAndIncrement());
-  }
-
-  /** Gets the top-level data source supplier to be used by a controller. */
-  protected Supplier<DataSource<IMAGE>> obtainDataSourceSupplier() {
-    if (mDataSourceSupplier != null) {
-      return mDataSourceSupplier;
-    }
-
-    Supplier<DataSource<IMAGE>> supplier = null;
-
-    // final image supplier;
-    if (mImageRequest != null) {
-      supplier = getDataSourceSupplierForRequest(mImageRequest);
-    } else if (mMultiImageRequests != null) {
-      supplier = getFirstAvailableDataSourceSupplier(mMultiImageRequests);
-    }
-
-    // increasing-quality supplier; highest-quality supplier goes first
-    if (supplier != null && mLowResImageRequest != null) {
-      List<Supplier<DataSource<IMAGE>>> suppliers =
-          Lists.newArrayListWithCapacity(2);
-      suppliers.add(supplier);
-      suppliers.add(getDataSourceSupplierForRequest(mLowResImageRequest));
-      supplier = IncreasingQualityDataSourceSupplier.create(suppliers);
-    }
-
-    // no image requests; use null data source supplier
-    if (supplier == null) {
-      supplier = DataSources.getFailedDataSourceSupplier(NO_REQUEST_EXCEPTION);
-    }
-
-    return supplier;
-  }
-
-  protected Supplier<DataSource<IMAGE>> getFirstAvailableDataSourceSupplier(
-      REQUEST[] imageRequests) {
-    List<Supplier<DataSource<IMAGE>>> suppliers =
-        Lists.newArrayListWithCapacity(imageRequests.length * 2);
-    // we first add cache-only suppliers, then the full-fetch ones
-    for (int i = 0; i < imageRequests.length; i++) {
-      suppliers.add(getDataSourceSupplierForRequest(imageRequests[i], /*cacheOnly */ true));
-    }
-    for (int i = 0; i < imageRequests.length; i++) {
-      suppliers.add(getDataSourceSupplierForRequest(imageRequests[i]));
-    }
-    return FirstAvailableDataSourceSupplier.create(suppliers);
-  }
-
-  /** Creates a data source supplier for the given image request. */
-  protected Supplier<DataSource<IMAGE>> getDataSourceSupplierForRequest(REQUEST imageRequest) {
-    return getDataSourceSupplierForRequest(imageRequest, /* bitmapCacheOnly */ false);
-  }
-
-  /** Creates a data source supplier for the given image request. */
-  protected Supplier<DataSource<IMAGE>> getDataSourceSupplierForRequest(
-      final REQUEST imageRequest,
-      final boolean bitmapCacheOnly) {
-    final Object callerContext = getCallerContext();
-    return new Supplier<DataSource<IMAGE>>() {
-      @Override
-      public DataSource<IMAGE> get() {
-        return getDataSourceForRequest(imageRequest, callerContext, bitmapCacheOnly);
-      }
-      @Override
-      public String toString() {
-        return Objects.toStringHelper(this)
-            .add("request", imageRequest.toString())
-            .toString();
-      }
-    };
-  }
-
-  /** Attaches listeners (if specified) to the given controller. */
-  protected void maybeAttachListeners(AbstractDraweeController controller) {
-    if (mBoundControllerListeners != null) {
-      for (ControllerListener<? super INFO> listener : mBoundControllerListeners) {
-        controller.addControllerListener(listener);
-      }
-    }
-    if (mControllerListener != null) {
-      controller.addControllerListener(mControllerListener);
-    }
-    if (mAutoPlayAnimations) {
-      controller.addControllerListener(sAutoPlayAnimationsListener);
-    }
-  }
-
-  /** Installs a retry manager (if specified) to the given controller. */
-  protected void maybeBuildAndSetRetryManager(AbstractDraweeController controller) {
-    if (!mTapToRetryEnabled) {
-      return;
-    }
-    RetryManager retryManager = controller.getRetryManager();
-    if (retryManager == null) {
-      retryManager = new RetryManager();
-      controller.setRetryManager(retryManager);
-    }
-    retryManager.setTapToRetryEnabled(mTapToRetryEnabled);
-    maybeBuildAndSetGestureDetector(controller);
-  }
-
-  /** Installs a gesture detector to the given controller. */
-  protected void maybeBuildAndSetGestureDetector(AbstractDraweeController controller) {
-    GestureDetector gestureDetector = controller.getGestureDetector();
-    if (gestureDetector == null) {
-      gestureDetector = GestureDetector.newInstance(mContext);
-      controller.setGestureDetector(gestureDetector);
-    }
-  }
-
-  /* Gets the context. */
-  protected Context getContext() {
-    return mContext;
-  }
-
-  /** Concrete builder classes should override this method to return a new controller. */
-  protected abstract AbstractDraweeController obtainController();
-
-  /**
-   * Concrete builder classes should override this method to return a data source for the request.
-   *
-   * <p/>IMPORTANT: Do NOT ever call this method directly. This method is only to be called from
-   * a supplier created in {#code getDataSourceSupplierForRequest(REQUEST, boolean)}.
-   *
-   * <p/>IMPORTANT: Make sure that you do NOT use any non-final field from this method, as the field
-   * may change if the instance of this builder gets reused. If any such field is required, override
-   * {#code getDataSourceSupplierForRequest(REQUEST, boolean)}, and store the field in a final
-   * variable (same as it is done for callerContext).
-   */
-  protected abstract DataSource<IMAGE> getDataSourceForRequest(
-      final REQUEST imageRequest,
-      final Object callerContext,
-      final boolean bitmapCacheOnly);
-
-  /** Concrete builder classes should override this method to return {#code this}. */
-  protected abstract BUILDER getThis();
+
+        return buildController();
+    }
+
+    /**
+     * Validates the parameters before building a controller.
+     */
+    protected void validate() {
+        Preconditions.checkState(
+                (mMultiImageRequests == null) || (mImageRequest == null),
+                "Cannot specify both ImageRequest and FirstAvailableImageRequests!");
+        Preconditions.checkState(
+                (mDataSourceSupplier == null) ||
+                        (mMultiImageRequests == null && mImageRequest == null && mLowResImageRequest == null),
+                "Cannot specify DataSourceSupplier with other ImageRequests! Use one or the other.");
+    }
+
+    /**
+     * Builds a regular controller.
+     */
+    protected AbstractDraweeController buildController() {
+        AbstractDraweeController controller = obtainController();
+        maybeBuildAndSetRetryManager(controller);
+        maybeAttachListeners(controller);
+        return controller;
+    }
+
+    /**
+     * Generates unique controller id.
+     */
+    protected static String generateUniqueControllerId() {
+        return String.valueOf(sIdCounter.getAndIncrement());
+    }
+
+    /**
+     * Gets the top-level data source supplier to be used by a controller.
+     */
+    protected Supplier<DataSource<IMAGE>> obtainDataSourceSupplier() {
+        if (mDataSourceSupplier != null) {
+            return mDataSourceSupplier;
+        }
+
+        Supplier<DataSource<IMAGE>> supplier = null;
+
+        // final image supplier;
+        if (mImageRequest != null) {
+            supplier = getDataSourceSupplierForRequest(mImageRequest);
+        } else if (mMultiImageRequests != null) {
+            supplier = getFirstAvailableDataSourceSupplier(mMultiImageRequests);
+        }
+
+        // increasing-quality supplier; highest-quality supplier goes first
+        if (supplier != null && mLowResImageRequest != null) {
+            List<Supplier<DataSource<IMAGE>>> suppliers =
+                    Lists.newArrayListWithCapacity(2);
+            suppliers.add(supplier);
+            suppliers.add(getDataSourceSupplierForRequest(mLowResImageRequest));
+            supplier = IncreasingQualityDataSourceSupplier.create(suppliers);
+        }
+
+        // no image requests; use null data source supplier
+        if (supplier == null) {
+            supplier = DataSources.getFailedDataSourceSupplier(NO_REQUEST_EXCEPTION);
+        }
+
+        return supplier;
+    }
+
+    protected Supplier<DataSource<IMAGE>> getFirstAvailableDataSourceSupplier(
+            REQUEST[] imageRequests) {
+        List<Supplier<DataSource<IMAGE>>> suppliers =
+                Lists.newArrayListWithCapacity(imageRequests.length * 2);
+        // we first add cache-only suppliers, then the full-fetch ones
+        for (int i = 0; i < imageRequests.length; i++) {
+            suppliers.add(getDataSourceSupplierForRequest(imageRequests[i], /*cacheOnly */ true));
+        }
+        for (int i = 0; i < imageRequests.length; i++) {
+            suppliers.add(getDataSourceSupplierForRequest(imageRequests[i]));
+        }
+        return FirstAvailableDataSourceSupplier.create(suppliers);
+    }
+
+    /**
+     * Creates a data source supplier for the given image request.
+     */
+    protected Supplier<DataSource<IMAGE>> getDataSourceSupplierForRequest(REQUEST imageRequest) {
+        return getDataSourceSupplierForRequest(imageRequest, /* bitmapCacheOnly */ false);
+    }
+
+    /**
+     * Creates a data source supplier for the given image request.
+     */
+    protected Supplier<DataSource<IMAGE>> getDataSourceSupplierForRequest(
+            final REQUEST imageRequest,
+            final boolean bitmapCacheOnly) {
+        final Object callerContext = getCallerContext();
+        return new Supplier<DataSource<IMAGE>>() {
+            @Override
+            public DataSource<IMAGE> get() {
+                return getDataSourceForRequest(imageRequest, callerContext, bitmapCacheOnly);
+            }
+
+            @Override
+            public String toString() {
+                return Objects.toStringHelper(this)
+                        .add("request", imageRequest.toString())
+                        .toString();
+            }
+        };
+    }
+
+    /**
+     * Attaches listeners (if specified) to the given controller.
+     */
+    protected void maybeAttachListeners(AbstractDraweeController controller) {
+        if (mBoundControllerListeners != null) {
+            for (ControllerListener<? super INFO> listener : mBoundControllerListeners) {
+                controller.addControllerListener(listener);
+            }
+        }
+        if (mControllerListener != null) {
+            controller.addControllerListener(mControllerListener);
+        }
+        if (mAutoPlayAnimations) {
+            controller.addControllerListener(sAutoPlayAnimationsListener);
+        }
+    }
+
+    /**
+     * Installs a retry manager (if specified) to the given controller.
+     */
+    protected void maybeBuildAndSetRetryManager(AbstractDraweeController controller) {
+        if (!mTapToRetryEnabled) {
+            return;
+        }
+        RetryManager retryManager = controller.getRetryManager();
+        if (retryManager == null) {
+            retryManager = new RetryManager();
+            controller.setRetryManager(retryManager);
+        }
+        retryManager.setTapToRetryEnabled(mTapToRetryEnabled);
+        maybeBuildAndSetGestureDetector(controller);
+    }
+
+    /**
+     * Installs a gesture detector to the given controller.
+     */
+    protected void maybeBuildAndSetGestureDetector(AbstractDraweeController controller) {
+        GestureDetector gestureDetector = controller.getGestureDetector();
+        if (gestureDetector == null) {
+            gestureDetector = GestureDetector.newInstance(mContext);
+            controller.setGestureDetector(gestureDetector);
+        }
+    }
+
+    /* Gets the context. */
+    protected Context getContext() {
+        return mContext;
+    }
+
+    /**
+     * Concrete builder classes should override this method to return a new controller.
+     */
+    protected abstract AbstractDraweeController obtainController();
+
+    /**
+     * Concrete builder classes should override this method to return a data source for the request.
+     * <p>
+     * <p/>IMPORTANT: Do NOT ever call this method directly. This method is only to be called from
+     * a supplier created in {#code getDataSourceSupplierForRequest(REQUEST, boolean)}.
+     * <p>
+     * <p/>IMPORTANT: Make sure that you do NOT use any non-final field from this method, as the field
+     * may change if the instance of this builder gets reused. If any such field is required, override
+     * {#code getDataSourceSupplierForRequest(REQUEST, boolean)}, and store the field in a final
+     * variable (same as it is done for callerContext).
+     */
+    protected abstract DataSource<IMAGE> getDataSourceForRequest(
+            final REQUEST imageRequest,
+            final Object callerContext,
+            final boolean bitmapCacheOnly);
+
+    /**
+     * Concrete builder classes should override this method to return {#code this}.
+     */
+    protected abstract BUILDER getThis();
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/controller/BaseControllerListener.java b/drawee/src/main/java/com/facebook/drawee/controller/BaseControllerListener.java
index 1ba5421e9..5b9998751 100644
--- a/drawee/src/main/java/com/facebook/drawee/controller/BaseControllerListener.java
+++ b/drawee/src/main/java/com/facebook/drawee/controller/BaseControllerListener.java
@@ -18,39 +18,39 @@
  */
 public class BaseControllerListener<INFO> implements ControllerListener<INFO> {
 
-  private static final ControllerListener<Object> NO_OP_LISTENER =
-      new BaseControllerListener<Object>();
-
-  public static <INFO> ControllerListener<INFO> getNoOpListener() {
-    // Listener only receives <INFO>, it never produces one.
-    // That means if it can accept Object, it can very well accept <INFO>.
-    return (ControllerListener<INFO>) NO_OP_LISTENER;
-  }
-
-  @Override
-  public void onSubmit(String id, Object callerContext) {
-  }
-
-  @Override
-  public void onFinalImageSet(
-      String id,
-      @Nullable INFO imageInfo,
-      @Nullable Animatable animatable) {
-  }
-
-  @Override
-  public void onIntermediateImageSet(String id, @Nullable INFO imageInfo) {
-  }
-
-  @Override
-  public void onIntermediateImageFailed(String id, Throwable throwable) {
-  }
-
-  @Override
-  public void onFailure(String id, Throwable throwable) {
-  }
-
-  @Override
-  public void onRelease(String id) {
-  }
+    private static final ControllerListener<Object> NO_OP_LISTENER =
+            new BaseControllerListener<Object>();
+
+    public static <INFO> ControllerListener<INFO> getNoOpListener() {
+        // Listener only receives <INFO>, it never produces one.
+        // That means if it can accept Object, it can very well accept <INFO>.
+        return (ControllerListener<INFO>) NO_OP_LISTENER;
+    }
+
+    @Override
+    public void onSubmit(String id, Object callerContext) {
+    }
+
+    @Override
+    public void onFinalImageSet(
+            String id,
+            @Nullable INFO imageInfo,
+            @Nullable Animatable animatable) {
+    }
+
+    @Override
+    public void onIntermediateImageSet(String id, @Nullable INFO imageInfo) {
+    }
+
+    @Override
+    public void onIntermediateImageFailed(String id, Throwable throwable) {
+    }
+
+    @Override
+    public void onFailure(String id, Throwable throwable) {
+    }
+
+    @Override
+    public void onRelease(String id) {
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/controller/ControllerListener.java b/drawee/src/main/java/com/facebook/drawee/controller/ControllerListener.java
index 35e198889..2655ff95a 100644
--- a/drawee/src/main/java/com/facebook/drawee/controller/ControllerListener.java
+++ b/drawee/src/main/java/com/facebook/drawee/controller/ControllerListener.java
@@ -15,7 +15,7 @@
 
 /**
  * Interface for {@link AbstractDraweeController} listener.
- *
+ * <p>
  * <p> Controller id is passed to each of the listener methods which is useful for debugging and
  * instrumentation purposes where those events can then be associated with a sequence. Subscriber
  * is free to completely ignore this id, as late callbacks and other such correctness issues are
@@ -25,47 +25,53 @@
  */
 public interface ControllerListener<INFO> {
 
-  /**
-   * Called before the image request is submitted.
-   * <p> IMPORTANT: It is not safe to reuse the controller from within this callback!
-   * @param id controller id
-   * @param callerContext caller context
-   */
-  public void onSubmit(String id, Object callerContext);
+    /**
+     * Called before the image request is submitted.
+     * <p> IMPORTANT: It is not safe to reuse the controller from within this callback!
+     *
+     * @param id            controller id
+     * @param callerContext caller context
+     */
+    public void onSubmit(String id, Object callerContext);
 
-  /**
-   * Called after the final image has been set.
-   * @param id controller id
-   * @param imageInfo image info
-   * @param animatable
-   */
-  public void onFinalImageSet(String id, @Nullable INFO imageInfo, @Nullable Animatable animatable);
+    /**
+     * Called after the final image has been set.
+     *
+     * @param id         controller id
+     * @param imageInfo  image info
+     * @param animatable
+     */
+    public void onFinalImageSet(String id, @Nullable INFO imageInfo, @Nullable Animatable animatable);
 
-  /**
-   * Called after any intermediate image has been set.
-   * @param id controller id
-   * @param imageInfo image info
-   */
-  public void onIntermediateImageSet(String id, @Nullable INFO imageInfo);
+    /**
+     * Called after any intermediate image has been set.
+     *
+     * @param id        controller id
+     * @param imageInfo image info
+     */
+    public void onIntermediateImageSet(String id, @Nullable INFO imageInfo);
 
-  /**
-   * Called after the fetch of the intermediate image failed.
-   * @param id controller id
-   * @param throwable failure cause
-   */
-  public void onIntermediateImageFailed(String id, Throwable throwable);
+    /**
+     * Called after the fetch of the intermediate image failed.
+     *
+     * @param id        controller id
+     * @param throwable failure cause
+     */
+    public void onIntermediateImageFailed(String id, Throwable throwable);
 
-  /**
-   * Called after the fetch of the final image failed.
-   * @param id controller id
-   * @param throwable failure cause
-   */
-  public void onFailure(String id, Throwable throwable);
+    /**
+     * Called after the fetch of the final image failed.
+     *
+     * @param id        controller id
+     * @param throwable failure cause
+     */
+    public void onFailure(String id, Throwable throwable);
 
-  /**
-   * Called after the controller released the fetched image.
-   * <p> IMPORTANT: It is not safe to reuse the controller from within this callback!
-   * @param id controller id
-   */
-  public void onRelease(String id);
+    /**
+     * Called after the controller released the fetched image.
+     * <p> IMPORTANT: It is not safe to reuse the controller from within this callback!
+     *
+     * @param id controller id
+     */
+    public void onRelease(String id);
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/controller/ForwardingControllerListener.java b/drawee/src/main/java/com/facebook/drawee/controller/ForwardingControllerListener.java
index 89b288914..21d11d0e3 100644
--- a/drawee/src/main/java/com/facebook/drawee/controller/ForwardingControllerListener.java
+++ b/drawee/src/main/java/com/facebook/drawee/controller/ForwardingControllerListener.java
@@ -24,134 +24,134 @@
  */
 @ThreadSafe
 public class ForwardingControllerListener<INFO> implements ControllerListener<INFO> {
-  private static final String TAG = "ForwardingControllerListener";
-
-  private final List<ControllerListener<? super INFO>> mListeners
-      = Lists.newArrayListWithCapacity(2);
-
-  public ForwardingControllerListener() {
-  }
-
-  public static <INFO> ForwardingControllerListener<INFO> create() {
-    return new ForwardingControllerListener<INFO>();
-  }
-
-  public static <INFO> ForwardingControllerListener<INFO> of(
-      ControllerListener<? super INFO> listener) {
-    ForwardingControllerListener<INFO> forwarder = create();
-    forwarder.addListener(listener);
-    return forwarder;
-  }
-
-  public static <INFO> ForwardingControllerListener<INFO> of(
-      ControllerListener<? super INFO> listener1,
-      ControllerListener<? super INFO> listener2) {
-    ForwardingControllerListener<INFO> forwarder = create();
-    forwarder.addListener(listener1);
-    forwarder.addListener(listener2);
-    return forwarder;
-  }
-
-  public synchronized void addListener(ControllerListener<? super INFO> listener) {
-    mListeners.add(listener);
-  }
-
-  public synchronized void removeListener(ControllerListener<? super INFO> listener) {
-    mListeners.remove(listener);
-  }
-
-  public synchronized void clearListeners() {
-    mListeners.clear();
-  }
-
-  private synchronized void onException(String message, Throwable t) {
-    Log.e(TAG, message, t);
-  }
-
-  @Override
-  public synchronized void onSubmit(String id, Object callerContext) {
-    final int numberOfListeners = mListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      ControllerListener<? super INFO> listener = mListeners.get(i);
-      try {
-        listener.onSubmit(id, callerContext);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onSubmit", exception);
-      }
+    private static final String TAG = "ForwardingControllerListener";
+
+    private final List<ControllerListener<? super INFO>> mListeners
+            = Lists.newArrayListWithCapacity(2);
+
+    public ForwardingControllerListener() {
+    }
+
+    public static <INFO> ForwardingControllerListener<INFO> create() {
+        return new ForwardingControllerListener<INFO>();
+    }
+
+    public static <INFO> ForwardingControllerListener<INFO> of(
+            ControllerListener<? super INFO> listener) {
+        ForwardingControllerListener<INFO> forwarder = create();
+        forwarder.addListener(listener);
+        return forwarder;
     }
-  }
-
-  @Override
-  public synchronized void onFinalImageSet(
-      String id,
-      @Nullable INFO imageInfo,
-      @Nullable Animatable animatable) {
-    final int numberOfListeners = mListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      ControllerListener<? super INFO> listener = mListeners.get(i);
-      try {
-        listener.onFinalImageSet(id, imageInfo, animatable);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onFinalImageSet", exception);
-      }
+
+    public static <INFO> ForwardingControllerListener<INFO> of(
+            ControllerListener<? super INFO> listener1,
+            ControllerListener<? super INFO> listener2) {
+        ForwardingControllerListener<INFO> forwarder = create();
+        forwarder.addListener(listener1);
+        forwarder.addListener(listener2);
+        return forwarder;
+    }
+
+    public synchronized void addListener(ControllerListener<? super INFO> listener) {
+        mListeners.add(listener);
     }
-  }
-
-  @Override
-  public void onIntermediateImageSet(String id, @Nullable INFO imageInfo) {
-    final int numberOfListeners = mListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      ControllerListener<? super INFO> listener = mListeners.get(i);
-      try {
-        listener.onIntermediateImageSet(id, imageInfo);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onIntermediateImageSet", exception);
-      }
+
+    public synchronized void removeListener(ControllerListener<? super INFO> listener) {
+        mListeners.remove(listener);
     }
-  }
-
-  @Override
-  public void onIntermediateImageFailed(String id, Throwable throwable) {
-    final int numberOfListeners = mListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      ControllerListener<? super INFO> listener = mListeners.get(i);
-      try {
-        listener.onIntermediateImageFailed(id, throwable);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onIntermediateImageFailed", exception);
-      }
+
+    public synchronized void clearListeners() {
+        mListeners.clear();
     }
-  }
-
-  @Override
-  public synchronized void onFailure(String id, Throwable throwable) {
-    final int numberOfListeners = mListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      ControllerListener<? super INFO> listener = mListeners.get(i);
-      try {
-        listener.onFailure(id, throwable);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onFailure", exception);
-      }
+
+    private synchronized void onException(String message, Throwable t) {
+        Log.e(TAG, message, t);
     }
-  }
-
-  @Override
-  public synchronized void onRelease(String id) {
-    final int numberOfListeners = mListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      ControllerListener<? super INFO> listener = mListeners.get(i);
-      try {
-        listener.onRelease(id);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onRelease", exception);
-      }
+
+    @Override
+    public synchronized void onSubmit(String id, Object callerContext) {
+        final int numberOfListeners = mListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            ControllerListener<? super INFO> listener = mListeners.get(i);
+            try {
+                listener.onSubmit(id, callerContext);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onSubmit", exception);
+            }
+        }
+    }
+
+    @Override
+    public synchronized void onFinalImageSet(
+            String id,
+            @Nullable INFO imageInfo,
+            @Nullable Animatable animatable) {
+        final int numberOfListeners = mListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            ControllerListener<? super INFO> listener = mListeners.get(i);
+            try {
+                listener.onFinalImageSet(id, imageInfo, animatable);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onFinalImageSet", exception);
+            }
+        }
+    }
+
+    @Override
+    public void onIntermediateImageSet(String id, @Nullable INFO imageInfo) {
+        final int numberOfListeners = mListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            ControllerListener<? super INFO> listener = mListeners.get(i);
+            try {
+                listener.onIntermediateImageSet(id, imageInfo);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onIntermediateImageSet", exception);
+            }
+        }
+    }
+
+    @Override
+    public void onIntermediateImageFailed(String id, Throwable throwable) {
+        final int numberOfListeners = mListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            ControllerListener<? super INFO> listener = mListeners.get(i);
+            try {
+                listener.onIntermediateImageFailed(id, throwable);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onIntermediateImageFailed", exception);
+            }
+        }
+    }
+
+    @Override
+    public synchronized void onFailure(String id, Throwable throwable) {
+        final int numberOfListeners = mListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            ControllerListener<? super INFO> listener = mListeners.get(i);
+            try {
+                listener.onFailure(id, throwable);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onFailure", exception);
+            }
+        }
+    }
+
+    @Override
+    public synchronized void onRelease(String id) {
+        final int numberOfListeners = mListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            ControllerListener<? super INFO> listener = mListeners.get(i);
+            try {
+                listener.onRelease(id);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onRelease", exception);
+            }
+        }
     }
-  }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/ArrayDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/ArrayDrawable.java
index a8048cfb3..c94458aff 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/ArrayDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/ArrayDrawable.java
@@ -22,268 +22,273 @@
 /**
  * A Drawable that contains an array of other Drawables (layers). These are drawn in array order,
  * so the element with the largest index will be drawn on top.
- *
+ * <p>
  * <p>Similar to android's LayerDrawable but it doesn't support adding/removing layers dynamically.
  */
 public class ArrayDrawable extends Drawable
-    implements Drawable.Callback, TransformCallback, TransformAwareDrawable {
+        implements Drawable.Callback, TransformCallback, TransformAwareDrawable {
 
-  private TransformCallback mTransformCallback;
+    private TransformCallback mTransformCallback;
 
-  private final DrawableProperties mDrawableProperties = new DrawableProperties();
+    private final DrawableProperties mDrawableProperties = new DrawableProperties();
 
-  // layers
-  private final Drawable[] mLayers;
+    // layers
+    private final Drawable[] mLayers;
 
-  // temp rect to avoid allocations
-  private final Rect mTmpRect = new Rect();
+    // temp rect to avoid allocations
+    private final Rect mTmpRect = new Rect();
 
-  // Whether the drawable is stateful or not
-  private boolean mIsStateful = false;
-  private boolean mIsStatefulCalculated = false;
+    // Whether the drawable is stateful or not
+    private boolean mIsStateful = false;
+    private boolean mIsStatefulCalculated = false;
 
-  private boolean mIsMutated = false;
+    private boolean mIsMutated = false;
 
-  /**
-   * Constructs a new layer drawable.
-   * @param layers the layers that this drawable displays
-   */
-  public ArrayDrawable(Drawable[] layers) {
-    Preconditions.checkNotNull(layers);
-    mLayers = layers;
-    for (int i = 0; i < mLayers.length; i++) {
-      DrawableUtils.setCallbacks(mLayers[i], this, this);
+    /**
+     * Constructs a new layer drawable.
+     *
+     * @param layers the layers that this drawable displays
+     */
+    public ArrayDrawable(Drawable[] layers) {
+        Preconditions.checkNotNull(layers);
+        mLayers = layers;
+        for (int i = 0; i < mLayers.length; i++) {
+            DrawableUtils.setCallbacks(mLayers[i], this, this);
+        }
     }
-  }
-
-  /**
-   * Gets the number of layers.
-   * @return number of layers
-   */
-  public int getNumberOfLayers() {
-    return mLayers.length;
-  }
-
-  /**
-   * Gets the drawable at the specified index.
-   * @param index index of drawable to get
-   * @return drawable at the specified index
-   */
-  public Drawable getDrawable(int index) {
-    return mLayers[index];
-  }
-
-  /** Sets a new drawable at the specified index. */
-  public void setDrawable(int index, Drawable drawable) {
-    Preconditions.checkArgument(index >= 0);
-    Preconditions.checkArgument(index < mLayers.length);
-    if (drawable != mLayers[index]) {
-      if (mIsMutated) {
-        drawable = drawable.mutate();
-      }
-      DrawableUtils.setCallbacks(mLayers[index], null, null);
-      DrawableUtils.setCallbacks(drawable, null, null);
-      DrawableUtils.setDrawableProperties(drawable, mDrawableProperties);
-      DrawableUtils.copyProperties(drawable, mLayers[index]);
-      DrawableUtils.setCallbacks(drawable, this, this);
-      mIsStatefulCalculated = false;
-      mLayers[index] = drawable;
-      invalidateSelf();
+
+    /**
+     * Gets the number of layers.
+     *
+     * @return number of layers
+     */
+    public int getNumberOfLayers() {
+        return mLayers.length;
     }
-  }
 
+    /**
+     * Gets the drawable at the specified index.
+     *
+     * @param index index of drawable to get
+     * @return drawable at the specified index
+     */
+    public Drawable getDrawable(int index) {
+        return mLayers[index];
+    }
 
-  @Override
-  public int getIntrinsicWidth() {
-    int width = 0;
-    for (int i = 0; i < mLayers.length; i++) {
-      width = Math.max(width, mLayers[i].getIntrinsicWidth());
+    /**
+     * Sets a new drawable at the specified index.
+     */
+    public void setDrawable(int index, Drawable drawable) {
+        Preconditions.checkArgument(index >= 0);
+        Preconditions.checkArgument(index < mLayers.length);
+        if (drawable != mLayers[index]) {
+            if (mIsMutated) {
+                drawable = drawable.mutate();
+            }
+            DrawableUtils.setCallbacks(mLayers[index], null, null);
+            DrawableUtils.setCallbacks(drawable, null, null);
+            DrawableUtils.setDrawableProperties(drawable, mDrawableProperties);
+            DrawableUtils.copyProperties(drawable, mLayers[index]);
+            DrawableUtils.setCallbacks(drawable, this, this);
+            mIsStatefulCalculated = false;
+            mLayers[index] = drawable;
+            invalidateSelf();
+        }
     }
-    return width;
-  }
-
-  @Override
-  public int getIntrinsicHeight() {
-    int height = 0;
-    for (int i = 0; i < mLayers.length; i++) {
-      height = Math.max(height, mLayers[i].getIntrinsicHeight());
+
+
+    @Override
+    public int getIntrinsicWidth() {
+        int width = 0;
+        for (int i = 0; i < mLayers.length; i++) {
+            width = Math.max(width, mLayers[i].getIntrinsicWidth());
+        }
+        return width;
     }
-    return height;
-  }
 
-  @Override
-  protected void onBoundsChange(Rect bounds) {
-    for (int i = 0; i < mLayers.length; i++) {
-      mLayers[i].setBounds(bounds);
+    @Override
+    public int getIntrinsicHeight() {
+        int height = 0;
+        for (int i = 0; i < mLayers.length; i++) {
+            height = Math.max(height, mLayers[i].getIntrinsicHeight());
+        }
+        return height;
     }
-  }
-
-  @Override
-  public boolean isStateful() {
-    if (!mIsStatefulCalculated) {
-      mIsStateful = false;
-      for (int i = 0; i < mLayers.length; i++) {
-        mIsStateful |= mLayers[i].isStateful();
-      }
-      mIsStatefulCalculated = true;
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        for (int i = 0; i < mLayers.length; i++) {
+            mLayers[i].setBounds(bounds);
+        }
     }
-    return mIsStateful;
-  }
-
-  @Override
-  protected boolean onStateChange(int[] state) {
-    boolean stateChanged = false;
-    for (int i = 0; i < mLayers.length; i++) {
-      if (mLayers[i].setState(state)) {
-        stateChanged = true;
-      }
+
+    @Override
+    public boolean isStateful() {
+        if (!mIsStatefulCalculated) {
+            mIsStateful = false;
+            for (int i = 0; i < mLayers.length; i++) {
+                mIsStateful |= mLayers[i].isStateful();
+            }
+            mIsStatefulCalculated = true;
+        }
+        return mIsStateful;
     }
-    return stateChanged;
-  }
-
-  @Override
-  protected boolean onLevelChange(int level) {
-    boolean levelChanged = false;
-    for (int i = 0; i < mLayers.length; i++) {
-      if (mLayers[i].setLevel(level)) {
-        levelChanged = true;
-      }
+
+    @Override
+    protected boolean onStateChange(int[] state) {
+        boolean stateChanged = false;
+        for (int i = 0; i < mLayers.length; i++) {
+            if (mLayers[i].setState(state)) {
+                stateChanged = true;
+            }
+        }
+        return stateChanged;
     }
-    return levelChanged;
-  }
 
-  @Override
-  public void draw(Canvas canvas) {
-    for (int i = 0; i < mLayers.length; i++) {
-      mLayers[i].draw(canvas);
+    @Override
+    protected boolean onLevelChange(int level) {
+        boolean levelChanged = false;
+        for (int i = 0; i < mLayers.length; i++) {
+            if (mLayers[i].setLevel(level)) {
+                levelChanged = true;
+            }
+        }
+        return levelChanged;
     }
-  }
-
-  @Override
-  public boolean getPadding(Rect padding) {
-    padding.left = 0;
-    padding.top = 0;
-    padding.right = 0;
-    padding.bottom = 0;
-    final Rect rect = mTmpRect;
-    for (int i = 0; i < mLayers.length; i++) {
-      mLayers[i].getPadding(rect);
-      padding.left = Math.max(padding.left, rect.left);
-      padding.top = Math.max(padding.top, rect.top);
-      padding.right = Math.max(padding.right, rect.right);
-      padding.bottom = Math.max(padding.bottom, rect.bottom);
+
+    @Override
+    public void draw(Canvas canvas) {
+        for (int i = 0; i < mLayers.length; i++) {
+            mLayers[i].draw(canvas);
+        }
     }
-    return true;
-  }
 
-  @Override
-  public Drawable mutate() {
-    for (int i = 0; i < mLayers.length; i++) {
-      mLayers[i].mutate();
+    @Override
+    public boolean getPadding(Rect padding) {
+        padding.left = 0;
+        padding.top = 0;
+        padding.right = 0;
+        padding.bottom = 0;
+        final Rect rect = mTmpRect;
+        for (int i = 0; i < mLayers.length; i++) {
+            mLayers[i].getPadding(rect);
+            padding.left = Math.max(padding.left, rect.left);
+            padding.top = Math.max(padding.top, rect.top);
+            padding.right = Math.max(padding.right, rect.right);
+            padding.bottom = Math.max(padding.bottom, rect.bottom);
+        }
+        return true;
     }
-    mIsMutated = true;
-    return this;
-  }
-
-  @Override
-  public int getOpacity() {
-    if (mLayers.length == 0) {
-      return PixelFormat.TRANSPARENT;
+
+    @Override
+    public Drawable mutate() {
+        for (int i = 0; i < mLayers.length; i++) {
+            mLayers[i].mutate();
+        }
+        mIsMutated = true;
+        return this;
     }
-    int opacity = mLayers[0].getOpacity();
-    for (int i = 1; i < mLayers.length; i++) {
-      opacity = Drawable.resolveOpacity(opacity, mLayers[i].getOpacity());
+
+    @Override
+    public int getOpacity() {
+        if (mLayers.length == 0) {
+            return PixelFormat.TRANSPARENT;
+        }
+        int opacity = mLayers[0].getOpacity();
+        for (int i = 1; i < mLayers.length; i++) {
+            opacity = Drawable.resolveOpacity(opacity, mLayers[i].getOpacity());
+        }
+        return opacity;
     }
-    return opacity;
-  }
-
-  @Override
-  public void setAlpha(int alpha) {
-    mDrawableProperties.setAlpha(alpha);
-    for (int i = 0; i < mLayers.length; i++) {
-      mLayers[i].setAlpha(alpha);
+
+    @Override
+    public void setAlpha(int alpha) {
+        mDrawableProperties.setAlpha(alpha);
+        for (int i = 0; i < mLayers.length; i++) {
+            mLayers[i].setAlpha(alpha);
+        }
     }
-  }
 
-  @Override
-  public void setColorFilter(ColorFilter colorFilter) {
-    mDrawableProperties.setColorFilter(colorFilter);
-    for (int i = 0; i < mLayers.length; i++) {
-      mLayers[i].setColorFilter(colorFilter);
+    @Override
+    public void setColorFilter(ColorFilter colorFilter) {
+        mDrawableProperties.setColorFilter(colorFilter);
+        for (int i = 0; i < mLayers.length; i++) {
+            mLayers[i].setColorFilter(colorFilter);
+        }
     }
-  }
 
-  @Override
-  public void setDither(boolean dither) {
-    mDrawableProperties.setDither(dither);
-    for (int i = 0; i < mLayers.length; i++) {
-      mLayers[i].setDither(dither);
+    @Override
+    public void setDither(boolean dither) {
+        mDrawableProperties.setDither(dither);
+        for (int i = 0; i < mLayers.length; i++) {
+            mLayers[i].setDither(dither);
+        }
     }
-  }
 
-  @Override
-  public void setFilterBitmap(boolean filterBitmap) {
-    mDrawableProperties.setFilterBitmap(filterBitmap);
-    for (int i = 0; i < mLayers.length; i++) {
-      mLayers[i].setFilterBitmap(filterBitmap);
+    @Override
+    public void setFilterBitmap(boolean filterBitmap) {
+        mDrawableProperties.setFilterBitmap(filterBitmap);
+        for (int i = 0; i < mLayers.length; i++) {
+            mLayers[i].setFilterBitmap(filterBitmap);
+        }
     }
-  }
 
-  @Override
-  public boolean setVisible(boolean visible, boolean restart) {
-    boolean changed = super.setVisible(visible, restart);
-    for (int i = 0; i < mLayers.length; i++) {
-      mLayers[i].setVisible(visible, restart);
+    @Override
+    public boolean setVisible(boolean visible, boolean restart) {
+        boolean changed = super.setVisible(visible, restart);
+        for (int i = 0; i < mLayers.length; i++) {
+            mLayers[i].setVisible(visible, restart);
+        }
+        return changed;
     }
-    return changed;
-  }
-
-  /**
-   * Drawable.Callback methods
-   */
-
-  @Override
-  public void invalidateDrawable(Drawable who) {
-    invalidateSelf();
-  }
-
-  @Override
-  public void scheduleDrawable(Drawable who, Runnable what, long when) {
-    scheduleSelf(what, when);
-  }
-
-  @Override
-  public void unscheduleDrawable(Drawable who, Runnable what) {
-    unscheduleSelf(what);
-  }
-
-  /**
-   * TransformationCallbackSetter method
-   */
-  @Override
-  public void setTransformCallback(TransformCallback transformCallback) {
-    mTransformCallback = transformCallback;
-  }
-
-  /**
-   * TransformationCallback methods
-   */
-
-  @Override
-  public void getTransform(Matrix transform) {
-    if (mTransformCallback != null) {
-      mTransformCallback.getTransform(transform);
-    } else {
-      transform.reset();
+
+    /**
+     * Drawable.Callback methods
+     */
+
+    @Override
+    public void invalidateDrawable(Drawable who) {
+        invalidateSelf();
+    }
+
+    @Override
+    public void scheduleDrawable(Drawable who, Runnable what, long when) {
+        scheduleSelf(what, when);
+    }
+
+    @Override
+    public void unscheduleDrawable(Drawable who, Runnable what) {
+        unscheduleSelf(what);
     }
-  }
-
-  @Override
-  public void getRootBounds(RectF bounds) {
-    if (mTransformCallback != null) {
-      mTransformCallback.getRootBounds(bounds);
-    } else {
-      bounds.set(getBounds());
+
+    /**
+     * TransformationCallbackSetter method
+     */
+    @Override
+    public void setTransformCallback(TransformCallback transformCallback) {
+        mTransformCallback = transformCallback;
+    }
+
+    /**
+     * TransformationCallback methods
+     */
+
+    @Override
+    public void getTransform(Matrix transform) {
+        if (mTransformCallback != null) {
+            mTransformCallback.getTransform(transform);
+        } else {
+            transform.reset();
+        }
+    }
+
+    @Override
+    public void getRootBounds(RectF bounds) {
+        if (mTransformCallback != null) {
+            mTransformCallback.getRootBounds(bounds);
+        } else {
+            bounds.set(getBounds());
+        }
     }
-  }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/AutoRotateDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/AutoRotateDrawable.java
index da56b78c7..7af9a3153 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/AutoRotateDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/AutoRotateDrawable.java
@@ -21,107 +21,107 @@
  * Drawable that automatically rotates underlying drawable.
  */
 public class AutoRotateDrawable extends ForwardingDrawable implements Runnable {
-  private static final int DEGREES_IN_FULL_ROTATION = 360;
-  private static final int FRAME_INTERVAL_MS = 20;
-
-  // Specified duration in milliseconds for one complete rotation.
-  private int mInterval;
-  // Specified rotation direction
-  private boolean mClockwise;
-
-  // Current angle by which the drawable is rotated.
-  @VisibleForTesting
-  float mRotationAngle = 0;
-
-  // Whether we have our next frame scheduled for update
-  private boolean mIsScheduled = false;
-
-  /**
-   * Creates a new AutoRotateDrawable with given underlying drawable, interval and a clockwise
-   * rotation.
-   *
-   * @param drawable underlying drawable to apply the rotation to
-   * @param interval duration in milliseconds of one complete rotation
-   */
-  public AutoRotateDrawable(Drawable drawable, int interval) {
-    this(drawable, interval, true);
-  }
-
-  /**
-   * Creates a new AutoRotateDrawable with given underlying drawable and interval.
-   *
-   * @param drawable underlying drawable to apply the rotation to
-   * @param interval duration in milliseconds of one complete rotation
-   * @param clockwise defines whether the rotation is clockwise or not
-   */
-  public AutoRotateDrawable(Drawable drawable, int interval, boolean clockwise) {
-    super(Preconditions.checkNotNull(drawable));
-    mInterval = interval;
-    mClockwise = clockwise;
-  }
-
-  /**
-   * Resets to the initial state.
-   */
-  public void reset() {
-    mRotationAngle = 0;
-    mIsScheduled = false;
-    unscheduleSelf(this);
-    invalidateSelf();
-  }
-
-  /**
-   * Define whether the rotation is clockwise or not.
-   * By default is the rotation clockwise.
-   */
-  public void setClockwise(boolean clockwise) {
-    mClockwise = clockwise;
-  }
-
-  @Override
-  public void draw(Canvas canvas) {
-    int saveCount = canvas.save();
-
-    Rect bounds = getBounds();
-    int width = bounds.right - bounds.left;
-    int height = bounds.bottom - bounds.top;
-
-    float angle = mRotationAngle;
-    if (!mClockwise) {
-      angle = DEGREES_IN_FULL_ROTATION - mRotationAngle;
+    private static final int DEGREES_IN_FULL_ROTATION = 360;
+    private static final int FRAME_INTERVAL_MS = 20;
+
+    // Specified duration in milliseconds for one complete rotation.
+    private int mInterval;
+    // Specified rotation direction
+    private boolean mClockwise;
+
+    // Current angle by which the drawable is rotated.
+    @VisibleForTesting
+    float mRotationAngle = 0;
+
+    // Whether we have our next frame scheduled for update
+    private boolean mIsScheduled = false;
+
+    /**
+     * Creates a new AutoRotateDrawable with given underlying drawable, interval and a clockwise
+     * rotation.
+     *
+     * @param drawable underlying drawable to apply the rotation to
+     * @param interval duration in milliseconds of one complete rotation
+     */
+    public AutoRotateDrawable(Drawable drawable, int interval) {
+        this(drawable, interval, true);
     }
-    canvas.rotate(angle, bounds.left + width / 2, bounds.top + height / 2);
-    super.draw(canvas);
-    canvas.restoreToCount(saveCount);
-
-    scheduleNextFrame();
-  }
-
-  @Override
-  public void run() {
-    mIsScheduled = false;
-    mRotationAngle += getIncrement();
-    invalidateSelf();
-  }
-
-  /**
-   * Schedule the next frame for drawing.
-   *
-   * Ideally, we'd like to call this from the callback (i.e. {@code
-   * run()}), but if we do there's no place where we can call
-   * scheduleNextFrame() for the first time. As a tradeoff, we call
-   * this from draw(), which means scheduleNextFrame() could
-   * technically be called multiple times for the same frame, so we
-   * must handle that gracefully.
-   */
-  private void scheduleNextFrame() {
-    if (!mIsScheduled) {
-      mIsScheduled = true;
-      scheduleSelf(this, SystemClock.uptimeMillis() + FRAME_INTERVAL_MS);
+
+    /**
+     * Creates a new AutoRotateDrawable with given underlying drawable and interval.
+     *
+     * @param drawable  underlying drawable to apply the rotation to
+     * @param interval  duration in milliseconds of one complete rotation
+     * @param clockwise defines whether the rotation is clockwise or not
+     */
+    public AutoRotateDrawable(Drawable drawable, int interval, boolean clockwise) {
+        super(Preconditions.checkNotNull(drawable));
+        mInterval = interval;
+        mClockwise = clockwise;
+    }
+
+    /**
+     * Resets to the initial state.
+     */
+    public void reset() {
+        mRotationAngle = 0;
+        mIsScheduled = false;
+        unscheduleSelf(this);
+        invalidateSelf();
+    }
+
+    /**
+     * Define whether the rotation is clockwise or not.
+     * By default is the rotation clockwise.
+     */
+    public void setClockwise(boolean clockwise) {
+        mClockwise = clockwise;
     }
-  }
 
-  private int getIncrement() {
-    return (int) (((float)FRAME_INTERVAL_MS) / mInterval * DEGREES_IN_FULL_ROTATION);
-  }
+    @Override
+    public void draw(Canvas canvas) {
+        int saveCount = canvas.save();
+
+        Rect bounds = getBounds();
+        int width = bounds.right - bounds.left;
+        int height = bounds.bottom - bounds.top;
+
+        float angle = mRotationAngle;
+        if (!mClockwise) {
+            angle = DEGREES_IN_FULL_ROTATION - mRotationAngle;
+        }
+        canvas.rotate(angle, bounds.left + width / 2, bounds.top + height / 2);
+        super.draw(canvas);
+        canvas.restoreToCount(saveCount);
+
+        scheduleNextFrame();
+    }
+
+    @Override
+    public void run() {
+        mIsScheduled = false;
+        mRotationAngle += getIncrement();
+        invalidateSelf();
+    }
+
+    /**
+     * Schedule the next frame for drawing.
+     * <p>
+     * Ideally, we'd like to call this from the callback (i.e. {@code
+     * run()}), but if we do there's no place where we can call
+     * scheduleNextFrame() for the first time. As a tradeoff, we call
+     * this from draw(), which means scheduleNextFrame() could
+     * technically be called multiple times for the same frame, so we
+     * must handle that gracefully.
+     */
+    private void scheduleNextFrame() {
+        if (!mIsScheduled) {
+            mIsScheduled = true;
+            scheduleSelf(this, SystemClock.uptimeMillis() + FRAME_INTERVAL_MS);
+        }
+    }
+
+    private int getIncrement() {
+        return (int) (((float) FRAME_INTERVAL_MS) / mInterval * DEGREES_IN_FULL_ROTATION);
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/DrawableProperties.java b/drawee/src/main/java/com/facebook/drawee/drawable/DrawableProperties.java
index a07d3315e..8eedb129e 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/DrawableProperties.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/DrawableProperties.java
@@ -13,40 +13,40 @@
 
 public class DrawableProperties {
 
-  private int mAlpha = 255;
-  private ColorFilter mColorFilter = null;
-  private boolean mDither = true;
-  private boolean mFilterBitmap = true;
-
-  public int getAlpha() {
-    return mAlpha;
-  }
-
-  public void setAlpha(int alpha) {
-    mAlpha = alpha;
-  }
-
-  public ColorFilter getColorFilter() {
-    return mColorFilter;
-  }
-
-  public void setColorFilter(ColorFilter colorFilter) {
-    mColorFilter = colorFilter;
-  }
-
-  public boolean isDither() {
-    return mDither;
-  }
-
-  public void setDither(boolean dither) {
-    mDither = dither;
-  }
-
-  public boolean isFilterBitmap() {
-    return mFilterBitmap;
-  }
-
-  public void setFilterBitmap(boolean filterBitmap) {
-    mFilterBitmap = filterBitmap;
-  }
+    private int mAlpha = 255;
+    private ColorFilter mColorFilter = null;
+    private boolean mDither = true;
+    private boolean mFilterBitmap = true;
+
+    public int getAlpha() {
+        return mAlpha;
+    }
+
+    public void setAlpha(int alpha) {
+        mAlpha = alpha;
+    }
+
+    public ColorFilter getColorFilter() {
+        return mColorFilter;
+    }
+
+    public void setColorFilter(ColorFilter colorFilter) {
+        mColorFilter = colorFilter;
+    }
+
+    public boolean isDither() {
+        return mDither;
+    }
+
+    public void setDither(boolean dither) {
+        mDither = dither;
+    }
+
+    public boolean isFilterBitmap() {
+        return mFilterBitmap;
+    }
+
+    public void setFilterBitmap(boolean filterBitmap) {
+        mFilterBitmap = filterBitmap;
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/DrawableUtils.java b/drawee/src/main/java/com/facebook/drawee/drawable/DrawableUtils.java
index 1d61033fd..affdf4308 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/DrawableUtils.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/DrawableUtils.java
@@ -19,89 +19,94 @@
  */
 public class DrawableUtils {
 
-  /**
-   * Copies various properties from one drawable to the other.
-   * @param to drawable to copy properties to
-   * @param from drawable to copy properties from
-   */
-  public static void copyProperties(Drawable to, Drawable from) {
-    if (from == null || to == null || to == from) {
-      return;
-    }
-
-    to.setBounds(from.getBounds());
-    to.setChangingConfigurations(from.getChangingConfigurations());
-    to.setLevel(from.getLevel());
-    to.setVisible(from.isVisible(), /* restart */ false);
-    to.setState(from.getState());
-  }
+    /**
+     * Copies various properties from one drawable to the other.
+     *
+     * @param to   drawable to copy properties to
+     * @param from drawable to copy properties from
+     */
+    public static void copyProperties(Drawable to, Drawable from) {
+        if (from == null || to == null || to == from) {
+            return;
+        }
 
-  /**
-   * Sets various paint properties on the drawable
-   * @param drawable Drawable on which to set the properties
-   * @param properties wrapper around property values to set on the drawable
-   */
-  public static void setDrawableProperties(Drawable drawable, DrawableProperties properties) {
-    if (drawable == null || properties == null) {
-      return;
+        to.setBounds(from.getBounds());
+        to.setChangingConfigurations(from.getChangingConfigurations());
+        to.setLevel(from.getLevel());
+        to.setVisible(from.isVisible(), /* restart */ false);
+        to.setState(from.getState());
     }
 
-    drawable.setAlpha(properties.getAlpha());
-    drawable.setColorFilter(properties.getColorFilter());
-    drawable.setDither(properties.isDither());
-    drawable.setFilterBitmap(properties.isFilterBitmap());
-  }
+    /**
+     * Sets various paint properties on the drawable
+     *
+     * @param drawable   Drawable on which to set the properties
+     * @param properties wrapper around property values to set on the drawable
+     */
+    public static void setDrawableProperties(Drawable drawable, DrawableProperties properties) {
+        if (drawable == null || properties == null) {
+            return;
+        }
 
-  /**
-   * Sets callback to the drawable.
-   * @param drawable drawable to set callbacks to
-   * @param callback standard Android Drawable.Callback
-   * @param transformCallback TransformCallback used by TransformAwareDrawables
-   */
-  public static void setCallbacks(
-      Drawable drawable,
-      @Nullable Drawable.Callback callback,
-      @Nullable TransformCallback transformCallback) {
-    if (drawable != null) {
-      drawable.setCallback(callback);
-      if (drawable instanceof TransformAwareDrawable) {
-        ((TransformAwareDrawable) drawable).setTransformCallback(transformCallback);
-      }
+        drawable.setAlpha(properties.getAlpha());
+        drawable.setColorFilter(properties.getColorFilter());
+        drawable.setDither(properties.isDither());
+        drawable.setFilterBitmap(properties.isFilterBitmap());
     }
-  }
 
-  /**
-   * Multiplies the color with the given alpha.
-   * @param color color to be multiplied
-   * @param alpha value between 0 and 255
-   * @return multiplied color
-   */
-  public static int multiplyColorAlpha(int color, int alpha) {
-    if (alpha == 255) {
-      return color;
+    /**
+     * Sets callback to the drawable.
+     *
+     * @param drawable          drawable to set callbacks to
+     * @param callback          standard Android Drawable.Callback
+     * @param transformCallback TransformCallback used by TransformAwareDrawables
+     */
+    public static void setCallbacks(
+            Drawable drawable,
+            @Nullable Drawable.Callback callback,
+            @Nullable TransformCallback transformCallback) {
+        if (drawable != null) {
+            drawable.setCallback(callback);
+            if (drawable instanceof TransformAwareDrawable) {
+                ((TransformAwareDrawable) drawable).setTransformCallback(transformCallback);
+            }
+        }
     }
-    if (alpha == 0) {
-      return color & 0x00FFFFFF;
+
+    /**
+     * Multiplies the color with the given alpha.
+     *
+     * @param color color to be multiplied
+     * @param alpha value between 0 and 255
+     * @return multiplied color
+     */
+    public static int multiplyColorAlpha(int color, int alpha) {
+        if (alpha == 255) {
+            return color;
+        }
+        if (alpha == 0) {
+            return color & 0x00FFFFFF;
+        }
+        alpha = alpha + (alpha >> 7); // make it 0..256
+        int colorAlpha = color >>> 24;
+        int multipliedAlpha = colorAlpha * alpha >> 8;
+        return (multipliedAlpha << 24) | (color & 0x00FFFFFF);
     }
-    alpha = alpha + (alpha >> 7); // make it 0..256
-    int colorAlpha = color >>> 24;
-    int multipliedAlpha = colorAlpha * alpha >> 8;
-    return (multipliedAlpha << 24) | (color & 0x00FFFFFF);
-  }
 
-  /**
-   * Gets the opacity from a color. Inspired by Android ColorDrawable.
-   * @param color
-   * @return opacity expressed by one of PixelFormat constants
-   */
-  public static int getOpacityFromColor(int color) {
-    int colorAlpha = color >>> 24;
-    if (colorAlpha == 255) {
-      return PixelFormat.OPAQUE;
-    } else if (colorAlpha == 0) {
-      return PixelFormat.TRANSPARENT;
-    } else {
-      return PixelFormat.TRANSLUCENT;
+    /**
+     * Gets the opacity from a color. Inspired by Android ColorDrawable.
+     *
+     * @param color
+     * @return opacity expressed by one of PixelFormat constants
+     */
+    public static int getOpacityFromColor(int color) {
+        int colorAlpha = color >>> 24;
+        if (colorAlpha == 255) {
+            return PixelFormat.OPAQUE;
+        } else if (colorAlpha == 0) {
+            return PixelFormat.TRANSPARENT;
+        } else {
+            return PixelFormat.TRANSLUCENT;
+        }
     }
-  }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/FadeDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/FadeDrawable.java
index 4073a5906..1a6630c6f 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/FadeDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/FadeDrawable.java
@@ -20,7 +20,7 @@
 
 /**
  * A drawable that fades to the specific layer.
- *
+ * <p>
  * <p> Arbitrary number of layers is supported. 5 Different fade methods are supported.
  * Once the transition starts we will animate layers in or out based on used fade method.
  * fadeInLayer fades in specified layer to full opacity.
@@ -29,317 +29,333 @@
  * fadeToLayer fades in specified layer to full opacity, fades out all other layers to zero opacity.
  * fadeUpToLayer fades in all layers up to specified layer to full opacity and
  * fades out all other layers to zero opacity.
- *
  */
 public class FadeDrawable extends ArrayDrawable {
 
-  /**
-   * A transition is about to start.
-   */
-  @VisibleForTesting
-  public static final int TRANSITION_STARTING = 0;
-
-  /**
-   * The transition has started and the animation is in progress.
-   */
-  @VisibleForTesting
-  public static final int TRANSITION_RUNNING = 1;
-
-  /**
-   * No transition will be applied.
-   */
-  @VisibleForTesting
-  public static final int TRANSITION_NONE = 2;
-
-  /**
-   * Layers.
-   */
-  private final Drawable[] mLayers;
-
-  /**
-   * The current state.
-   */
-  @VisibleForTesting int mTransitionState;
-  @VisibleForTesting int mDurationMs;
-  @VisibleForTesting long mStartTimeMs;
-  @VisibleForTesting int[] mStartAlphas;
-  @VisibleForTesting int[] mAlphas;
-  @VisibleForTesting int mAlpha;
-
-  /**
-   * Determines whether to fade-out a layer to zero opacity (false) or to fade-in to
-   * the full opacity (true)
-   */
-  @VisibleForTesting boolean[] mIsLayerOn;
-
-  /**
-   * When in batch mode, drawable won't invalidate self until batch mode finishes.
-   */
-  @VisibleForTesting int mPreventInvalidateCount;
-
-  /**
-   * Creates a new fade drawable.
-   * The first layer is displayed with full opacity whereas all other layers are invisible.
-   * @param layers layers to fade between
-   */
-  public FadeDrawable(Drawable[] layers) {
-    super(layers);
-    Preconditions.checkState(layers.length >= 1, "At least one layer required!");
-    mLayers = layers;
-    mStartAlphas = new int[layers.length];
-    mAlphas = new int[layers.length];
-    mAlpha = 255;
-    mIsLayerOn = new boolean[layers.length];
-    mPreventInvalidateCount = 0;
-    resetInternal();
-  }
-
-  @Override
-  public void invalidateSelf() {
-    if (mPreventInvalidateCount == 0) {
-      super.invalidateSelf();
+    /**
+     * A transition is about to start.
+     */
+    @VisibleForTesting
+    public static final int TRANSITION_STARTING = 0;
+
+    /**
+     * The transition has started and the animation is in progress.
+     */
+    @VisibleForTesting
+    public static final int TRANSITION_RUNNING = 1;
+
+    /**
+     * No transition will be applied.
+     */
+    @VisibleForTesting
+    public static final int TRANSITION_NONE = 2;
+
+    /**
+     * Layers.
+     */
+    private final Drawable[] mLayers;
+
+    /**
+     * The current state.
+     */
+    @VisibleForTesting
+    int mTransitionState;
+    @VisibleForTesting
+    int mDurationMs;
+    @VisibleForTesting
+    long mStartTimeMs;
+    @VisibleForTesting
+    int[] mStartAlphas;
+    @VisibleForTesting
+    int[] mAlphas;
+    @VisibleForTesting
+    int mAlpha;
+
+    /**
+     * Determines whether to fade-out a layer to zero opacity (false) or to fade-in to
+     * the full opacity (true)
+     */
+    @VisibleForTesting
+    boolean[] mIsLayerOn;
+
+    /**
+     * When in batch mode, drawable won't invalidate self until batch mode finishes.
+     */
+    @VisibleForTesting
+    int mPreventInvalidateCount;
+
+    /**
+     * Creates a new fade drawable.
+     * The first layer is displayed with full opacity whereas all other layers are invisible.
+     *
+     * @param layers layers to fade between
+     */
+    public FadeDrawable(Drawable[] layers) {
+        super(layers);
+        Preconditions.checkState(layers.length >= 1, "At least one layer required!");
+        mLayers = layers;
+        mStartAlphas = new int[layers.length];
+        mAlphas = new int[layers.length];
+        mAlpha = 255;
+        mIsLayerOn = new boolean[layers.length];
+        mPreventInvalidateCount = 0;
+        resetInternal();
+    }
+
+    @Override
+    public void invalidateSelf() {
+        if (mPreventInvalidateCount == 0) {
+            super.invalidateSelf();
+        }
+    }
+
+    /**
+     * Begins the batch mode so that it doesn't invalidate self on every operation.
+     */
+    public void beginBatchMode() {
+        mPreventInvalidateCount++;
+    }
+
+    /**
+     * Ends the batch mode and invalidates.
+     */
+    public void endBatchMode() {
+        mPreventInvalidateCount--;
+        invalidateSelf();
+    }
+
+    /**
+     * Sets the duration of the current transition in milliseconds.
+     */
+    public void setTransitionDuration(int durationMs) {
+        mDurationMs = durationMs;
+        // re-initialize transition if it's running
+        if (mTransitionState == TRANSITION_RUNNING) {
+            mTransitionState = TRANSITION_STARTING;
+        }
     }
-  }
-
-  /**
-   * Begins the batch mode so that it doesn't invalidate self on every operation.
-   */
-  public void beginBatchMode() {
-    mPreventInvalidateCount++;
-  }
-
-  /**
-   * Ends the batch mode and invalidates.
-   */
-  public void endBatchMode() {
-    mPreventInvalidateCount--;
-    invalidateSelf();
-  }
-
-  /**
-   * Sets the duration of the current transition in milliseconds.
-   */
-  public void setTransitionDuration(int durationMs) {
-    mDurationMs = durationMs;
-    // re-initialize transition if it's running
-    if (mTransitionState == TRANSITION_RUNNING) {
-      mTransitionState = TRANSITION_STARTING;
+
+    /**
+     * Gets the transition duration.
+     *
+     * @return transition duration in milliseconds.
+     */
+    public int getTransitionDuration() {
+        return mDurationMs;
     }
-  }
-
-  /**
-   * Gets the transition duration.
-   * @return transition duration in milliseconds.
-   */
-  public int getTransitionDuration() {
-    return mDurationMs;
-  }
-
-  /**
-   * Resets internal state to the initial state.
-   */
-  private void resetInternal() {
-    mTransitionState = TRANSITION_NONE;
-    Arrays.fill(mStartAlphas, 0);
-    mStartAlphas[0] = 255;
-    Arrays.fill(mAlphas, 0);
-    mAlphas[0] = 255;
-    Arrays.fill(mIsLayerOn, false);
-    mIsLayerOn[0] = true;
-  }
-
-  /**
-   * Resets to the initial state.
-   */
-  public void reset() {
-    resetInternal();
-    invalidateSelf();
-  }
-
-  /**
-   * Starts fading in the specified layer.
-   * @param index the index of the layer to fade in.
-   */
-  public void fadeInLayer(int index) {
-    mTransitionState = TRANSITION_STARTING;
-    mIsLayerOn[index] = true;
-    invalidateSelf();
-  }
-
-  /**
-   * Starts fading out the specified layer.
-   * @param index the index of the layer to fade out.
-   */
-  public void fadeOutLayer(int index) {
-    mTransitionState = TRANSITION_STARTING;
-    mIsLayerOn[index] = false;
-    invalidateSelf();
-  }
-
-  /**
-   * Starts fading in all layers.
-   */
-  public void fadeInAllLayers() {
-    mTransitionState = TRANSITION_STARTING;
-    Arrays.fill(mIsLayerOn, true);
-    invalidateSelf();
-  }
-
-  /**
-   * Starts fading out all layers.
-   */
-  public void fadeOutAllLayers() {
-    mTransitionState = TRANSITION_STARTING;
-    Arrays.fill(mIsLayerOn, false);
-    invalidateSelf();
-  }
-
-  /**
-   * Starts fading to the specified layer.
-   * @param index the index of the layer to fade to
-   */
-  public void fadeToLayer(int index) {
-    mTransitionState = TRANSITION_STARTING;
-    Arrays.fill(mIsLayerOn, false);
-    mIsLayerOn[index] = true;
-    invalidateSelf();
-  }
-
-  /**
-   * Starts fading up to the specified layer.
-   * <p>
-   * Layers up to the specified layer inclusive will fade in, other layers will fade out.
-   * @param index the index of the layer to fade up to.
-   */
-  public void fadeUpToLayer(int index) {
-    mTransitionState = TRANSITION_STARTING;
-    Arrays.fill(mIsLayerOn, 0, index + 1, true);
-    Arrays.fill(mIsLayerOn, index + 1, mLayers.length, false);
-    invalidateSelf();
-  }
-
-  /**
-   * Finishes transition immediately.
-   */
-  public void finishTransitionImmediately() {
-    mTransitionState = TRANSITION_NONE;
-    for (int i = 0; i < mLayers.length; i++) {
-      mAlphas[i] = mIsLayerOn[i] ? 255 : 0;
+
+    /**
+     * Resets internal state to the initial state.
+     */
+    private void resetInternal() {
+        mTransitionState = TRANSITION_NONE;
+        Arrays.fill(mStartAlphas, 0);
+        mStartAlphas[0] = 255;
+        Arrays.fill(mAlphas, 0);
+        mAlphas[0] = 255;
+        Arrays.fill(mIsLayerOn, false);
+        mIsLayerOn[0] = true;
     }
-    invalidateSelf();
-  }
-
-  /**
-   * Updates the current alphas based on the ratio of the elapsed time and duration.
-   * @param ratio
-   * @return whether the all layers have reached their target opacity
-   */
-  private boolean updateAlphas(float ratio) {
-    boolean done = true;
-    for (int i = 0; i < mLayers.length; i++) {
-      int dir = mIsLayerOn[i] ? +1 : -1;
-      // determines alpha value and clamps it to [0, 255]
-      mAlphas[i] = (int) (mStartAlphas[i] + dir * 255 * ratio);
-      if (mAlphas[i] < 0) {
-        mAlphas[i] = 0;
-      }
-      if (mAlphas[i] > 255) {
-        mAlphas[i] = 255;
-      }
-      // determines whether the layer has reached its target opacity
-      if (mIsLayerOn[i] && mAlphas[i] < 255) {
-        done = false;
-      }
-      if (!mIsLayerOn[i] && mAlphas[i] > 0) {
-        done = false;
-      }
+
+    /**
+     * Resets to the initial state.
+     */
+    public void reset() {
+        resetInternal();
+        invalidateSelf();
     }
-    return done;
-  }
-
-  @Override
-  public void draw(Canvas canvas) {
-    boolean done = true;
-    float ratio;
-
-    switch (mTransitionState) {
-      case TRANSITION_STARTING:
-        // initialize start alphas and start time
-        System.arraycopy(mAlphas, 0, mStartAlphas, 0, mLayers.length);
-        mStartTimeMs = getCurrentTimeMs();
-        // if the duration is 0, update alphas to the target opacities immediately
-        ratio = (mDurationMs == 0) ? 1.0f : 0.0f;
-        // if all the layers have reached their target opacity, transition is done
-        done = updateAlphas(ratio);
-        mTransitionState = done ? TRANSITION_NONE : TRANSITION_RUNNING;
-        break;
-
-      case TRANSITION_RUNNING:
-        Preconditions.checkState(mDurationMs > 0);
-        // determine ratio based on the elapsed time
-        ratio = (float) (getCurrentTimeMs() - mStartTimeMs) / mDurationMs;
-        // if all the layers have reached their target opacity, transition is done
-        done = updateAlphas(ratio);
-        mTransitionState = done ? TRANSITION_NONE : TRANSITION_RUNNING;
-        break;
-
-      case TRANSITION_NONE:
-        // there is no transition in progress and mAlphas should be left as is.
-        done = true;
-        break;
+
+    /**
+     * Starts fading in the specified layer.
+     *
+     * @param index the index of the layer to fade in.
+     */
+    public void fadeInLayer(int index) {
+        mTransitionState = TRANSITION_STARTING;
+        mIsLayerOn[index] = true;
+        invalidateSelf();
+    }
+
+    /**
+     * Starts fading out the specified layer.
+     *
+     * @param index the index of the layer to fade out.
+     */
+    public void fadeOutLayer(int index) {
+        mTransitionState = TRANSITION_STARTING;
+        mIsLayerOn[index] = false;
+        invalidateSelf();
+    }
+
+    /**
+     * Starts fading in all layers.
+     */
+    public void fadeInAllLayers() {
+        mTransitionState = TRANSITION_STARTING;
+        Arrays.fill(mIsLayerOn, true);
+        invalidateSelf();
     }
 
-    for (int i = 0; i < mLayers.length; i++) {
-      drawDrawableWithAlpha(canvas, mLayers[i], mAlphas[i] * mAlpha / 255);
+    /**
+     * Starts fading out all layers.
+     */
+    public void fadeOutAllLayers() {
+        mTransitionState = TRANSITION_STARTING;
+        Arrays.fill(mIsLayerOn, false);
+        invalidateSelf();
     }
 
-    if (!done) {
-      invalidateSelf();
+    /**
+     * Starts fading to the specified layer.
+     *
+     * @param index the index of the layer to fade to
+     */
+    public void fadeToLayer(int index) {
+        mTransitionState = TRANSITION_STARTING;
+        Arrays.fill(mIsLayerOn, false);
+        mIsLayerOn[index] = true;
+        invalidateSelf();
     }
-  }
-
-  private void drawDrawableWithAlpha(Canvas canvas, Drawable drawable, int alpha) {
-    if (alpha > 0) {
-      mPreventInvalidateCount++;
-      drawable.mutate().setAlpha(alpha);
-      mPreventInvalidateCount--;
-      drawable.draw(canvas);
+
+    /**
+     * Starts fading up to the specified layer.
+     * <p>
+     * Layers up to the specified layer inclusive will fade in, other layers will fade out.
+     *
+     * @param index the index of the layer to fade up to.
+     */
+    public void fadeUpToLayer(int index) {
+        mTransitionState = TRANSITION_STARTING;
+        Arrays.fill(mIsLayerOn, 0, index + 1, true);
+        Arrays.fill(mIsLayerOn, index + 1, mLayers.length, false);
+        invalidateSelf();
+    }
+
+    /**
+     * Finishes transition immediately.
+     */
+    public void finishTransitionImmediately() {
+        mTransitionState = TRANSITION_NONE;
+        for (int i = 0; i < mLayers.length; i++) {
+            mAlphas[i] = mIsLayerOn[i] ? 255 : 0;
+        }
+        invalidateSelf();
+    }
+
+    /**
+     * Updates the current alphas based on the ratio of the elapsed time and duration.
+     *
+     * @param ratio
+     * @return whether the all layers have reached their target opacity
+     */
+    private boolean updateAlphas(float ratio) {
+        boolean done = true;
+        for (int i = 0; i < mLayers.length; i++) {
+            int dir = mIsLayerOn[i] ? +1 : -1;
+            // determines alpha value and clamps it to [0, 255]
+            mAlphas[i] = (int) (mStartAlphas[i] + dir * 255 * ratio);
+            if (mAlphas[i] < 0) {
+                mAlphas[i] = 0;
+            }
+            if (mAlphas[i] > 255) {
+                mAlphas[i] = 255;
+            }
+            // determines whether the layer has reached its target opacity
+            if (mIsLayerOn[i] && mAlphas[i] < 255) {
+                done = false;
+            }
+            if (!mIsLayerOn[i] && mAlphas[i] > 0) {
+                done = false;
+            }
+        }
+        return done;
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        boolean done = true;
+        float ratio;
+
+        switch (mTransitionState) {
+            case TRANSITION_STARTING:
+                // initialize start alphas and start time
+                System.arraycopy(mAlphas, 0, mStartAlphas, 0, mLayers.length);
+                mStartTimeMs = getCurrentTimeMs();
+                // if the duration is 0, update alphas to the target opacities immediately
+                ratio = (mDurationMs == 0) ? 1.0f : 0.0f;
+                // if all the layers have reached their target opacity, transition is done
+                done = updateAlphas(ratio);
+                mTransitionState = done ? TRANSITION_NONE : TRANSITION_RUNNING;
+                break;
+
+            case TRANSITION_RUNNING:
+                Preconditions.checkState(mDurationMs > 0);
+                // determine ratio based on the elapsed time
+                ratio = (float) (getCurrentTimeMs() - mStartTimeMs) / mDurationMs;
+                // if all the layers have reached their target opacity, transition is done
+                done = updateAlphas(ratio);
+                mTransitionState = done ? TRANSITION_NONE : TRANSITION_RUNNING;
+                break;
+
+            case TRANSITION_NONE:
+                // there is no transition in progress and mAlphas should be left as is.
+                done = true;
+                break;
+        }
+
+        for (int i = 0; i < mLayers.length; i++) {
+            drawDrawableWithAlpha(canvas, mLayers[i], mAlphas[i] * mAlpha / 255);
+        }
+
+        if (!done) {
+            invalidateSelf();
+        }
+    }
+
+    private void drawDrawableWithAlpha(Canvas canvas, Drawable drawable, int alpha) {
+        if (alpha > 0) {
+            mPreventInvalidateCount++;
+            drawable.mutate().setAlpha(alpha);
+            mPreventInvalidateCount--;
+            drawable.draw(canvas);
+        }
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        if (mAlpha != alpha) {
+            mAlpha = alpha;
+            invalidateSelf();
+        }
+    }
+
+    public int getAlpha() {
+        return mAlpha;
+    }
+
+    /**
+     * Returns current time. Absolute reference is not important as only time deltas are used.
+     * Extracting this to a separate method allows better testing.
+     *
+     * @return current time in milliseconds
+     */
+    protected long getCurrentTimeMs() {
+        return SystemClock.uptimeMillis();
+    }
+
+    /**
+     * Gets the transition state (STARTING, RUNNING, NONE).
+     * Useful for testing purposes.
+     *
+     * @return transition state
+     */
+    @VisibleForTesting
+    public int getTransitionState() {
+        return mTransitionState;
     }
-  }
 
-  @Override
-  public void setAlpha(int alpha) {
-    if (mAlpha != alpha) {
-      mAlpha = alpha;
-      invalidateSelf();
+    public boolean isLayerOn(int index) {
+        return mIsLayerOn[index];
     }
-  }
-
-  public int getAlpha() {
-    return mAlpha;
-  }
-
-  /**
-   * Returns current time. Absolute reference is not important as only time deltas are used.
-   * Extracting this to a separate method allows better testing.
-   * @return current time in milliseconds
-   */
-  protected long getCurrentTimeMs() {
-    return SystemClock.uptimeMillis();
-  }
-
-  /**
-   * Gets the transition state (STARTING, RUNNING, NONE).
-   * Useful for testing purposes.
-   * @return transition state
-   */
-  @VisibleForTesting
-  public int getTransitionState() {
-    return mTransitionState;
-  }
-
-  public boolean isLayerOn(int index) {
-    return mIsLayerOn[index];
-  }
 
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/ForwardingDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/ForwardingDrawable.java
index c00285e8f..9e2ced8d5 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/ForwardingDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/ForwardingDrawable.java
@@ -26,208 +26,214 @@
  * and the others don't allow changing the member drawables.
  */
 public abstract class ForwardingDrawable extends Drawable
-    implements Drawable.Callback, TransformCallback, TransformAwareDrawable {
-
-  /** The current drawable to be drawn by this drawable when drawing is needed */
-  private Drawable mCurrentDelegate;
-
-  private final DrawableProperties mDrawableProperties = new DrawableProperties();
-
-  protected TransformCallback mTransformCallback;
-
-  /**
-   * Matrix used to store temporary transform. Drawables should be accessed on UI thread only, and
-   * this matrix is used only as a temporary variable so it's safe to be static.
-   */
-  private static final Matrix sTempTransform = new Matrix();
-
-  /**
-   * Constructs a new forwarding drawable.
-   * @param drawable drawable that this forwarding drawable will forward to
-   */
-  public ForwardingDrawable(Drawable drawable) {
-    mCurrentDelegate = drawable;
-    DrawableUtils.setCallbacks(mCurrentDelegate, this, this);
-  }
-
-  /**
-   * Sets a new drawable to be the delegate, and returns the old one (or null).
-   *
-   * <p>This method will cause the drawable to be invalidated.
-   * @param newDelegate
-   * @return the previous delegate
-   */
-  public Drawable setCurrent(Drawable newDelegate) {
-    Drawable previousDelegate = setCurrentWithoutInvalidate(newDelegate);
-    invalidateSelf();
-    return previousDelegate;
-  }
-
-  /**
-   * As {@code setCurrent}, but without invalidating a drawable. Subclasses are responsible to call
-   * {@code invalidateSelf} on their own.
-   * @param newDelegate
-   * @return the previous delegate
-   */
-  protected Drawable setCurrentWithoutInvalidate(Drawable newDelegate) {
-    Drawable previousDelegate = mCurrentDelegate;
-    DrawableUtils.setCallbacks(previousDelegate, null, null);
-    DrawableUtils.setCallbacks(newDelegate, null, null);
-    DrawableUtils.setDrawableProperties(newDelegate, mDrawableProperties);
-    DrawableUtils.copyProperties(newDelegate, previousDelegate);
-    DrawableUtils.setCallbacks(newDelegate, this, this);
-    mCurrentDelegate = newDelegate;
-    return previousDelegate;
-  }
-
-  @Override
-  public int getOpacity() {
-    return mCurrentDelegate.getOpacity();
-  }
-
-  @Override
-  public void setAlpha(int alpha) {
-    mDrawableProperties.setAlpha(alpha);
-    mCurrentDelegate.setAlpha(alpha);
-  }
-
-  @Override
-  public void setColorFilter(ColorFilter colorFilter) {
-    mDrawableProperties.setColorFilter(colorFilter);
-    mCurrentDelegate.setColorFilter(colorFilter);
-  }
-
-  @Override
-  public void setDither(boolean dither) {
-    mDrawableProperties.setDither(dither);
-    mCurrentDelegate.setDither(dither);
-  }
-
-  @Override
-  public void setFilterBitmap(boolean filterBitmap) {
-    mDrawableProperties.setFilterBitmap(filterBitmap);
-    mCurrentDelegate.setFilterBitmap(filterBitmap);
-  }
-
-  @Override
-  public boolean setVisible(boolean visible, boolean restart) {
-    return mCurrentDelegate.setVisible(visible, restart);
-  }
-
-  @Override
-  protected void onBoundsChange(Rect bounds) {
-    mCurrentDelegate.setBounds(bounds);
-  }
-
-  @Override
-  public boolean isStateful() {
-    return mCurrentDelegate.isStateful();
-  }
-
-  @Override
-  protected boolean onStateChange(int[] state) {
-    return mCurrentDelegate.setState(state);
-  }
-
-  @Override
-  protected boolean onLevelChange(int level) {
-    return mCurrentDelegate.setLevel(level);
-  }
-
-  @Override
-  public void draw(Canvas canvas) {
-    mCurrentDelegate.draw(canvas);
-  }
-
-  @Override
-  public int getIntrinsicWidth() {
-    return mCurrentDelegate.getIntrinsicWidth();
-  }
-
-  @Override
-  public int getIntrinsicHeight() {
-    return mCurrentDelegate.getIntrinsicHeight();
-  }
-
-  @Override
-  public boolean getPadding(Rect padding) {
-    return mCurrentDelegate.getPadding(padding);
-  }
-
-  @Override
-  public Drawable mutate() {
-    mCurrentDelegate.mutate();
-    return this;
-  }
-
-  @Override
-  public Drawable getCurrent() {
-    return mCurrentDelegate;
-  }
-
-  /**
-   * Drawable.Callback methods
-   */
-
-  @Override
-  public void invalidateDrawable(Drawable who) {
-    invalidateSelf();
-  }
-
-  @Override
-  public void scheduleDrawable(Drawable who, Runnable what, long when) {
-    scheduleSelf(what, when);
-  }
-
-  @Override
-  public void unscheduleDrawable(Drawable who, Runnable what) {
-    unscheduleSelf(what);
-  }
-
-  /**
-   * TransformationCallbackSetter method
-   */
-  @Override
-  public void setTransformCallback(TransformCallback transformCallback) {
-    mTransformCallback = transformCallback;
-  }
-
-  /**
-   * TransformationCallback methods
-   */
-
-  protected void getParentTransform(Matrix transform) {
-    if (mTransformCallback != null) {
-      mTransformCallback.getTransform(transform);
-    } else {
-      transform.reset();
-    }
-  }
-
-  @Override
-  public void getTransform(Matrix transform) {
-    getParentTransform(transform);
-  }
-
-  @Override
-  public void getRootBounds(RectF bounds) {
-    if (mTransformCallback != null) {
-      mTransformCallback.getRootBounds(bounds);
-    } else {
-      bounds.set(getBounds());
-    }
-  }
-
-  /**
-   * Gets the transformed bounds of this drawable.
-   * Note: bounds are not cropped (otherwise they would likely be the same as drawable's bounds).
-   * @param outBounds rect to fill with bounds
-   */
-  public void getTransformedBounds(RectF outBounds) {
-    getParentTransform(sTempTransform);
-    // IMPORTANT: {@code getBounds} should be called after {@code getParentTransform},
-    // because the parent may have to change our bounds.
-    outBounds.set(getBounds());
-    sTempTransform.mapRect(outBounds);
-  }
+        implements Drawable.Callback, TransformCallback, TransformAwareDrawable {
+
+    /**
+     * The current drawable to be drawn by this drawable when drawing is needed
+     */
+    private Drawable mCurrentDelegate;
+
+    private final DrawableProperties mDrawableProperties = new DrawableProperties();
+
+    protected TransformCallback mTransformCallback;
+
+    /**
+     * Matrix used to store temporary transform. Drawables should be accessed on UI thread only, and
+     * this matrix is used only as a temporary variable so it's safe to be static.
+     */
+    private static final Matrix sTempTransform = new Matrix();
+
+    /**
+     * Constructs a new forwarding drawable.
+     *
+     * @param drawable drawable that this forwarding drawable will forward to
+     */
+    public ForwardingDrawable(Drawable drawable) {
+        mCurrentDelegate = drawable;
+        DrawableUtils.setCallbacks(mCurrentDelegate, this, this);
+    }
+
+    /**
+     * Sets a new drawable to be the delegate, and returns the old one (or null).
+     * <p>
+     * <p>This method will cause the drawable to be invalidated.
+     *
+     * @param newDelegate
+     * @return the previous delegate
+     */
+    public Drawable setCurrent(Drawable newDelegate) {
+        Drawable previousDelegate = setCurrentWithoutInvalidate(newDelegate);
+        invalidateSelf();
+        return previousDelegate;
+    }
+
+    /**
+     * As {@code setCurrent}, but without invalidating a drawable. Subclasses are responsible to call
+     * {@code invalidateSelf} on their own.
+     *
+     * @param newDelegate
+     * @return the previous delegate
+     */
+    protected Drawable setCurrentWithoutInvalidate(Drawable newDelegate) {
+        Drawable previousDelegate = mCurrentDelegate;
+        DrawableUtils.setCallbacks(previousDelegate, null, null);
+        DrawableUtils.setCallbacks(newDelegate, null, null);
+        DrawableUtils.setDrawableProperties(newDelegate, mDrawableProperties);
+        DrawableUtils.copyProperties(newDelegate, previousDelegate);
+        DrawableUtils.setCallbacks(newDelegate, this, this);
+        mCurrentDelegate = newDelegate;
+        return previousDelegate;
+    }
+
+    @Override
+    public int getOpacity() {
+        return mCurrentDelegate.getOpacity();
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        mDrawableProperties.setAlpha(alpha);
+        mCurrentDelegate.setAlpha(alpha);
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter colorFilter) {
+        mDrawableProperties.setColorFilter(colorFilter);
+        mCurrentDelegate.setColorFilter(colorFilter);
+    }
+
+    @Override
+    public void setDither(boolean dither) {
+        mDrawableProperties.setDither(dither);
+        mCurrentDelegate.setDither(dither);
+    }
+
+    @Override
+    public void setFilterBitmap(boolean filterBitmap) {
+        mDrawableProperties.setFilterBitmap(filterBitmap);
+        mCurrentDelegate.setFilterBitmap(filterBitmap);
+    }
+
+    @Override
+    public boolean setVisible(boolean visible, boolean restart) {
+        return mCurrentDelegate.setVisible(visible, restart);
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        mCurrentDelegate.setBounds(bounds);
+    }
+
+    @Override
+    public boolean isStateful() {
+        return mCurrentDelegate.isStateful();
+    }
+
+    @Override
+    protected boolean onStateChange(int[] state) {
+        return mCurrentDelegate.setState(state);
+    }
+
+    @Override
+    protected boolean onLevelChange(int level) {
+        return mCurrentDelegate.setLevel(level);
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        mCurrentDelegate.draw(canvas);
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return mCurrentDelegate.getIntrinsicWidth();
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return mCurrentDelegate.getIntrinsicHeight();
+    }
+
+    @Override
+    public boolean getPadding(Rect padding) {
+        return mCurrentDelegate.getPadding(padding);
+    }
+
+    @Override
+    public Drawable mutate() {
+        mCurrentDelegate.mutate();
+        return this;
+    }
+
+    @Override
+    public Drawable getCurrent() {
+        return mCurrentDelegate;
+    }
+
+    /**
+     * Drawable.Callback methods
+     */
+
+    @Override
+    public void invalidateDrawable(Drawable who) {
+        invalidateSelf();
+    }
+
+    @Override
+    public void scheduleDrawable(Drawable who, Runnable what, long when) {
+        scheduleSelf(what, when);
+    }
+
+    @Override
+    public void unscheduleDrawable(Drawable who, Runnable what) {
+        unscheduleSelf(what);
+    }
+
+    /**
+     * TransformationCallbackSetter method
+     */
+    @Override
+    public void setTransformCallback(TransformCallback transformCallback) {
+        mTransformCallback = transformCallback;
+    }
+
+    /**
+     * TransformationCallback methods
+     */
+
+    protected void getParentTransform(Matrix transform) {
+        if (mTransformCallback != null) {
+            mTransformCallback.getTransform(transform);
+        } else {
+            transform.reset();
+        }
+    }
+
+    @Override
+    public void getTransform(Matrix transform) {
+        getParentTransform(transform);
+    }
+
+    @Override
+    public void getRootBounds(RectF bounds) {
+        if (mTransformCallback != null) {
+            mTransformCallback.getRootBounds(bounds);
+        } else {
+            bounds.set(getBounds());
+        }
+    }
+
+    /**
+     * Gets the transformed bounds of this drawable.
+     * Note: bounds are not cropped (otherwise they would likely be the same as drawable's bounds).
+     *
+     * @param outBounds rect to fill with bounds
+     */
+    public void getTransformedBounds(RectF outBounds) {
+        getParentTransform(sTempTransform);
+        // IMPORTANT: {@code getBounds} should be called after {@code getParentTransform},
+        // because the parent may have to change our bounds.
+        outBounds.set(getBounds());
+        sTempTransform.mapRect(outBounds);
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/MatrixDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/MatrixDrawable.java
index fa148ed29..4c0657f55 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/MatrixDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/MatrixDrawable.java
@@ -21,104 +21,108 @@
  */
 public class MatrixDrawable extends ForwardingDrawable {
 
-  // Specified matrix.
-  private Matrix mMatrix;
-
-  // Matrix that is actually being used for drawing. In case underlying drawable doesn't have
-  // intrinsic dimensions, this will be null (i.e. no matrix will be applied).
-  private Matrix mDrawMatrix;
-
-  // Last known dimensions of the underlying drawable. Used to avoid computing bounds every time
-  // if underlying size hasn't changed.
-  private int mUnderlyingWidth = 0;
-  private int mUnderlyingHeight = 0;
-
-  /**
-   * Creates a new MatrixDrawable with given underlying drawable and matrix.
-   * @param drawable underlying drawable to apply the matrix to
-   * @param matrix matrix to be applied to the drawable
-   */
-  public MatrixDrawable(Drawable drawable, Matrix matrix) {
-    super(Preconditions.checkNotNull(drawable));
-    mMatrix = matrix;
-  }
-
-  /**
-   * Gets the current matrix.
-   * @return matrix
-   */
-  public Matrix getMatrix() {
-    return mMatrix;
-  }
-
-  /**
-   * Sets the matrix.
-   * @param matrix matrix to set
-   */
-  public void setMatrix(Matrix matrix) {
-    mMatrix = matrix;
-    configureBounds();
-    invalidateSelf();
-  }
-
-  @Override
-  public void draw(Canvas canvas) {
-    configureBoundsIfUnderlyingChanged();
-    if (mDrawMatrix != null) {
-      int saveCount = canvas.save();
-      canvas.clipRect(getBounds());
-      canvas.concat(mDrawMatrix);
-      super.draw(canvas);
-      canvas.restoreToCount(saveCount);
-    } else {
-      // mDrawMatrix == null means our bounds match and we can take fast path
-      super.draw(canvas);
+    // Specified matrix.
+    private Matrix mMatrix;
+
+    // Matrix that is actually being used for drawing. In case underlying drawable doesn't have
+    // intrinsic dimensions, this will be null (i.e. no matrix will be applied).
+    private Matrix mDrawMatrix;
+
+    // Last known dimensions of the underlying drawable. Used to avoid computing bounds every time
+    // if underlying size hasn't changed.
+    private int mUnderlyingWidth = 0;
+    private int mUnderlyingHeight = 0;
+
+    /**
+     * Creates a new MatrixDrawable with given underlying drawable and matrix.
+     *
+     * @param drawable underlying drawable to apply the matrix to
+     * @param matrix   matrix to be applied to the drawable
+     */
+    public MatrixDrawable(Drawable drawable, Matrix matrix) {
+        super(Preconditions.checkNotNull(drawable));
+        mMatrix = matrix;
     }
-  }
-
-  @Override
-  protected void onBoundsChange(Rect bounds) {
-    super.onBoundsChange(bounds);
-    configureBounds();
-  }
-
-  private void configureBoundsIfUnderlyingChanged() {
-    if (mUnderlyingWidth != getCurrent().getIntrinsicWidth() ||
-        mUnderlyingHeight != getCurrent().getIntrinsicHeight()) {
-      configureBounds();
+
+    /**
+     * Gets the current matrix.
+     *
+     * @return matrix
+     */
+    public Matrix getMatrix() {
+        return mMatrix;
+    }
+
+    /**
+     * Sets the matrix.
+     *
+     * @param matrix matrix to set
+     */
+    public void setMatrix(Matrix matrix) {
+        mMatrix = matrix;
+        configureBounds();
+        invalidateSelf();
     }
-  }
-
-  /**
-   * Determines bounds for the underlying drawable and a matrix that should be applied on it.
-   */
-  private void configureBounds() {
-    Drawable underlyingDrawable = getCurrent();
-    Rect bounds = getBounds();
-    int underlyingWidth = mUnderlyingWidth = underlyingDrawable.getIntrinsicWidth();
-    int underlyingHeight = mUnderlyingHeight = underlyingDrawable.getIntrinsicHeight();
-
-    // In case underlying drawable doesn't have intrinsic dimensions, we cannot set its bounds to
-    // -1 so we use our bounds and discard specified matrix. In normal case we use drawable's
-    // intrinsic dimensions for its bounds and apply specified matrix to it.
-    if (underlyingWidth <= 0 || underlyingHeight <= 0) {
-      underlyingDrawable.setBounds(bounds);
-      mDrawMatrix = null;
-    } else {
-      underlyingDrawable.setBounds(0, 0, underlyingWidth, underlyingHeight);
-      mDrawMatrix = mMatrix;
+
+    @Override
+    public void draw(Canvas canvas) {
+        configureBoundsIfUnderlyingChanged();
+        if (mDrawMatrix != null) {
+            int saveCount = canvas.save();
+            canvas.clipRect(getBounds());
+            canvas.concat(mDrawMatrix);
+            super.draw(canvas);
+            canvas.restoreToCount(saveCount);
+        } else {
+            // mDrawMatrix == null means our bounds match and we can take fast path
+            super.draw(canvas);
+        }
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        configureBounds();
     }
-  }
-
-  /**
-   * TransformationCallback method
-   * @param transform
-   */
-  @Override
-  public void getTransform(Matrix transform) {
-    super.getTransform(transform);
-    if (mDrawMatrix != null) {
-      transform.preConcat(mDrawMatrix);
+
+    private void configureBoundsIfUnderlyingChanged() {
+        if (mUnderlyingWidth != getCurrent().getIntrinsicWidth() ||
+                mUnderlyingHeight != getCurrent().getIntrinsicHeight()) {
+            configureBounds();
+        }
+    }
+
+    /**
+     * Determines bounds for the underlying drawable and a matrix that should be applied on it.
+     */
+    private void configureBounds() {
+        Drawable underlyingDrawable = getCurrent();
+        Rect bounds = getBounds();
+        int underlyingWidth = mUnderlyingWidth = underlyingDrawable.getIntrinsicWidth();
+        int underlyingHeight = mUnderlyingHeight = underlyingDrawable.getIntrinsicHeight();
+
+        // In case underlying drawable doesn't have intrinsic dimensions, we cannot set its bounds to
+        // -1 so we use our bounds and discard specified matrix. In normal case we use drawable's
+        // intrinsic dimensions for its bounds and apply specified matrix to it.
+        if (underlyingWidth <= 0 || underlyingHeight <= 0) {
+            underlyingDrawable.setBounds(bounds);
+            mDrawMatrix = null;
+        } else {
+            underlyingDrawable.setBounds(0, 0, underlyingWidth, underlyingHeight);
+            mDrawMatrix = mMatrix;
+        }
+    }
+
+    /**
+     * TransformationCallback method
+     *
+     * @param transform
+     */
+    @Override
+    public void getTransform(Matrix transform) {
+        super.getTransform(transform);
+        if (mDrawMatrix != null) {
+            transform.preConcat(mDrawMatrix);
+        }
     }
-  }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/ProgressBarDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/ProgressBarDrawable.java
index 1cb5ae66c..f27960f15 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/ProgressBarDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/ProgressBarDrawable.java
@@ -16,119 +16,139 @@
 import android.graphics.drawable.Drawable;
 
 /**
-* Drawable that displays a progress bar based on the level.
-*/
+ * Drawable that displays a progress bar based on the level.
+ */
 public class ProgressBarDrawable extends Drawable {
 
-  private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private int mBackgroundColor = 0x80000000;
-  private int mColor = 0x800080FF;
-  private int mPadding = 10;
-  private int mBarWidth = 20;
-  private int mLevel = 0;
-  private boolean mHideWhenZero = false;
-
-  /** Sets the progress bar color. */
-  public void setColor(int color) {
-    if (mColor != color) {
-      mColor = color;
-      invalidateSelf();
-    }
-  }
-
-  /** Gets the progress bar color. */
-  public int getColor() {
-    return mColor;
-  }
-
-  /** Sets the progress bar background color. */
-  public void setBackgroundColor(int backgroundColor) {
-    if (mBackgroundColor != backgroundColor) {
-      mBackgroundColor = backgroundColor;
-      invalidateSelf();
-    }
-  }
-
-  /** Gets the progress bar background color. */
-  public int getBackgroundColor() {
-    return mBackgroundColor;
-  }
-
-  /** Sets the progress bar padding. */
-  public void setPadding(int padding) {
-    if (mPadding != padding) {
-      mPadding = padding;
-      invalidateSelf();
-    }
-  }
-
-  /** Gets the progress bar padding. */
-  @Override
-  public boolean getPadding(Rect padding) {
-    padding.set(mPadding, mPadding, mPadding, mPadding);
-    return mPadding != 0;
-  }
-
-  /** Sets the progress bar width. */
-  public void setBarWidth(int barWidth) {
-    if (mBarWidth != barWidth) {
-      mBarWidth = barWidth;
-      invalidateSelf();
-    }
-  }
-
-  /** Gets the progress bar width. */
-  public int getBarWidth() {
-    return mBarWidth;
-  }
-
-  /** Sets whether the progress bar should be hidden when the progress is 0. */
-  public void setHideWhenZero(boolean hideWhenZero) {
-    mHideWhenZero = hideWhenZero;
-  }
-
-  /** Gets whether the progress bar should be hidden when the progress is 0. */
-  public boolean getHideWhenZero() {
-    return mHideWhenZero;
-  }
-
-  @Override
-  protected boolean onLevelChange(int level) {
-    mLevel = level;
-    invalidateSelf();
-    return true;
-  }
-
-  @Override
-  public void setAlpha(int alpha) {
-    mPaint.setAlpha(alpha);
-  }
-
-  @Override
-  public void setColorFilter(ColorFilter cf) {
-    mPaint.setColorFilter(cf);
-  }
-
-  @Override
-  public int getOpacity() {
-    return DrawableUtils.getOpacityFromColor(mPaint.getColor());
-  }
-
-  @Override
-  public void draw(Canvas canvas) {
-    if (mHideWhenZero && mLevel == 0) {
-      return;
-    }
-    drawBar(canvas, 10000, mBackgroundColor);
-    drawBar(canvas, mLevel, mColor);
-  }
-
-  private void drawBar(Canvas canvas, int level, int color) {
-    Rect bounds = getBounds();
-    int length = (bounds.width() - 2 * mPadding) * level / 10000;
-    int xpos = bounds.left + mPadding;
-    int ypos = bounds.bottom - mPadding - mBarWidth;
-    mPaint.setColor(color);
-    canvas.drawRect(xpos, ypos, xpos + length, ypos + mBarWidth, mPaint);
-  }
+    private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    private int mBackgroundColor = 0x80000000;
+    private int mColor = 0x800080FF;
+    private int mPadding = 10;
+    private int mBarWidth = 20;
+    private int mLevel = 0;
+    private boolean mHideWhenZero = false;
+
+    /**
+     * Sets the progress bar color.
+     */
+    public void setColor(int color) {
+        if (mColor != color) {
+            mColor = color;
+            invalidateSelf();
+        }
+    }
+
+    /**
+     * Gets the progress bar color.
+     */
+    public int getColor() {
+        return mColor;
+    }
+
+    /**
+     * Sets the progress bar background color.
+     */
+    public void setBackgroundColor(int backgroundColor) {
+        if (mBackgroundColor != backgroundColor) {
+            mBackgroundColor = backgroundColor;
+            invalidateSelf();
+        }
+    }
+
+    /**
+     * Gets the progress bar background color.
+     */
+    public int getBackgroundColor() {
+        return mBackgroundColor;
+    }
+
+    /**
+     * Sets the progress bar padding.
+     */
+    public void setPadding(int padding) {
+        if (mPadding != padding) {
+            mPadding = padding;
+            invalidateSelf();
+        }
+    }
+
+    /**
+     * Gets the progress bar padding.
+     */
+    @Override
+    public boolean getPadding(Rect padding) {
+        padding.set(mPadding, mPadding, mPadding, mPadding);
+        return mPadding != 0;
+    }
+
+    /**
+     * Sets the progress bar width.
+     */
+    public void setBarWidth(int barWidth) {
+        if (mBarWidth != barWidth) {
+            mBarWidth = barWidth;
+            invalidateSelf();
+        }
+    }
+
+    /**
+     * Gets the progress bar width.
+     */
+    public int getBarWidth() {
+        return mBarWidth;
+    }
+
+    /**
+     * Sets whether the progress bar should be hidden when the progress is 0.
+     */
+    public void setHideWhenZero(boolean hideWhenZero) {
+        mHideWhenZero = hideWhenZero;
+    }
+
+    /**
+     * Gets whether the progress bar should be hidden when the progress is 0.
+     */
+    public boolean getHideWhenZero() {
+        return mHideWhenZero;
+    }
+
+    @Override
+    protected boolean onLevelChange(int level) {
+        mLevel = level;
+        invalidateSelf();
+        return true;
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        mPaint.setAlpha(alpha);
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        mPaint.setColorFilter(cf);
+    }
+
+    @Override
+    public int getOpacity() {
+        return DrawableUtils.getOpacityFromColor(mPaint.getColor());
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        if (mHideWhenZero && mLevel == 0) {
+            return;
+        }
+        drawBar(canvas, 10000, mBackgroundColor);
+        drawBar(canvas, mLevel, mColor);
+    }
+
+    private void drawBar(Canvas canvas, int level, int color) {
+        Rect bounds = getBounds();
+        int length = (bounds.width() - 2 * mPadding) * level / 10000;
+        int xpos = bounds.left + mPadding;
+        int ypos = bounds.bottom - mPadding - mBarWidth;
+        mPaint.setColor(color);
+        canvas.drawRect(xpos, ypos, xpos + length, ypos + mBarWidth, mPaint);
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java
index 1186e0b27..0cf594db7 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java
@@ -31,191 +31,206 @@
 import com.facebook.common.internal.VisibleForTesting;
 
 /**
-* A drawable that can have rounded corners.
-*/
+ * A drawable that can have rounded corners.
+ */
 public class RoundedBitmapDrawable extends BitmapDrawable
-    implements TransformAwareDrawable {
-  @VisibleForTesting boolean mIsCircle = false;
-  @VisibleForTesting float[] mCornerRadii = new float[8];
-  @VisibleForTesting RectF mRootBounds = new RectF();
-  @VisibleForTesting final RectF mLastRootBounds = new RectF();
-  @VisibleForTesting final Matrix mTransform = new Matrix();
-  @VisibleForTesting final Matrix mInverseTransform = new Matrix();
-  @VisibleForTesting final Matrix mLastTransform = new Matrix();
-  @VisibleForTesting float mBorderWidth = 0;
-  @VisibleForTesting int mBorderColor = Color.TRANSPARENT;
-
-  private final Path mPath = new Path();
-  private boolean mIsPathDirty = true;
-  private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private final Paint mBorderPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private boolean mIsShaderTransformDirty = true;
-  private WeakReference<Bitmap> mLastBitmap;
-
-  private @Nullable TransformCallback mTransformCallback;
-
-  public RoundedBitmapDrawable(Resources res, Bitmap bitmap) {
-    super(res, bitmap);
-    mBorderPaint.setStyle(Paint.Style.STROKE);
-  }
-
-  /**
-   * Creates a new RoundedBitmapDrawable from the given BitmapDrawable.
-   * @param res resources to use for this drawable
-   * @param bitmapDrawable bitmap drawable containing the bitmap to be used for this drawable
-   * @return the RoundedBitmapDrawable that is created
-   */
-  public static RoundedBitmapDrawable fromBitmapDrawable(
-      Resources res,
-      BitmapDrawable bitmapDrawable) {
-    return new RoundedBitmapDrawable(res, bitmapDrawable.getBitmap());
-  }
-
-  /**
-   * Sets whether to round as circle.
-   *
-   * @param isCircle whether or not to round as circle
-   */
-  public void setCircle(boolean isCircle) {
-    mIsCircle = isCircle;
-    mIsPathDirty = true;
-    invalidateSelf();
-  }
-
-  /**
-   * Specify radius for the corners of the rectangle. If this is > 0, then the
-   * drawable is drawn in a round-rectangle, rather than a rectangle.
-   * @param radius the radius for the corners of the rectangle
-   */
-  public void setCornerRadius(float radius) {
-    Preconditions.checkState(radius >= 0);
-    Arrays.fill(mCornerRadii, radius);
-    mIsPathDirty = true;
-    invalidateSelf();
-  }
-
-  /**
-   * Specify radii for each of the 4 corners. For each corner, the array
-   * contains 2 values, [X_radius, Y_radius]. The corners are ordered
-   * top-left, top-right, bottom-right, bottom-left
-   * @param radii the x and y radii of the corners
-   */
-  public void setCornerRadii(float[] radii) {
-    if (radii == null) {
-      Arrays.fill(mCornerRadii, 0);
-    } else {
-      Preconditions.checkArgument(radii.length == 8, "radii should have exactly 8 values");
-      System.arraycopy(radii, 0, mCornerRadii, 0, 8);
+        implements TransformAwareDrawable {
+    @VisibleForTesting
+    boolean mIsCircle = false;
+    @VisibleForTesting
+    float[] mCornerRadii = new float[8];
+    @VisibleForTesting
+    RectF mRootBounds = new RectF();
+    @VisibleForTesting
+    final RectF mLastRootBounds = new RectF();
+    @VisibleForTesting
+    final Matrix mTransform = new Matrix();
+    @VisibleForTesting
+    final Matrix mInverseTransform = new Matrix();
+    @VisibleForTesting
+    final Matrix mLastTransform = new Matrix();
+    @VisibleForTesting
+    float mBorderWidth = 0;
+    @VisibleForTesting
+    int mBorderColor = Color.TRANSPARENT;
+
+    private final Path mPath = new Path();
+    private boolean mIsPathDirty = true;
+    private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    private final Paint mBorderPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    private boolean mIsShaderTransformDirty = true;
+    private WeakReference<Bitmap> mLastBitmap;
+
+    private
+    @Nullable
+    TransformCallback mTransformCallback;
+
+    public RoundedBitmapDrawable(Resources res, Bitmap bitmap) {
+        super(res, bitmap);
+        mBorderPaint.setStyle(Paint.Style.STROKE);
+    }
+
+    /**
+     * Creates a new RoundedBitmapDrawable from the given BitmapDrawable.
+     *
+     * @param res            resources to use for this drawable
+     * @param bitmapDrawable bitmap drawable containing the bitmap to be used for this drawable
+     * @return the RoundedBitmapDrawable that is created
+     */
+    public static RoundedBitmapDrawable fromBitmapDrawable(
+            Resources res,
+            BitmapDrawable bitmapDrawable) {
+        return new RoundedBitmapDrawable(res, bitmapDrawable.getBitmap());
+    }
+
+    /**
+     * Sets whether to round as circle.
+     *
+     * @param isCircle whether or not to round as circle
+     */
+    public void setCircle(boolean isCircle) {
+        mIsCircle = isCircle;
+        mIsPathDirty = true;
+        invalidateSelf();
+    }
+
+    /**
+     * Specify radius for the corners of the rectangle. If this is > 0, then the
+     * drawable is drawn in a round-rectangle, rather than a rectangle.
+     *
+     * @param radius the radius for the corners of the rectangle
+     */
+    public void setCornerRadius(float radius) {
+        Preconditions.checkState(radius >= 0);
+        Arrays.fill(mCornerRadii, radius);
+        mIsPathDirty = true;
+        invalidateSelf();
     }
-    mIsPathDirty = true;
-    invalidateSelf();
-  }
-
-  /**
-   * Sets the border
-   * @param color of the border
-   * @param width of the border
-   */
-  public void setBorder(int color, float width) {
-    if (mBorderColor != color || mBorderWidth != width) {
-      mBorderColor = color;
-      mBorderWidth = width;
-      mIsPathDirty = true;
-      invalidateSelf();
+
+    /**
+     * Specify radii for each of the 4 corners. For each corner, the array
+     * contains 2 values, [X_radius, Y_radius]. The corners are ordered
+     * top-left, top-right, bottom-right, bottom-left
+     *
+     * @param radii the x and y radii of the corners
+     */
+    public void setCornerRadii(float[] radii) {
+        if (radii == null) {
+            Arrays.fill(mCornerRadii, 0);
+        } else {
+            Preconditions.checkArgument(radii.length == 8, "radii should have exactly 8 values");
+            System.arraycopy(radii, 0, mCornerRadii, 0, 8);
+        }
+        mIsPathDirty = true;
+        invalidateSelf();
     }
-  }
-
-  /**
-   * TransformAwareDrawable method
-   */
-  @Override
-  public void setTransformCallback(@Nullable TransformCallback transformCallback) {
-    mTransformCallback = transformCallback;
-  }
-
-  @Override
-  public void setAlpha(int alpha) {
-    if (alpha != mPaint.getAlpha()) {
-      mPaint.setAlpha(alpha);
-      invalidateSelf();
+
+    /**
+     * Sets the border
+     *
+     * @param color of the border
+     * @param width of the border
+     */
+    public void setBorder(int color, float width) {
+        if (mBorderColor != color || mBorderWidth != width) {
+            mBorderColor = color;
+            mBorderWidth = width;
+            mIsPathDirty = true;
+            invalidateSelf();
+        }
     }
-  }
-
-  @Override
-  public void setColorFilter(ColorFilter colorFilter) {
-    mPaint.setColorFilter(colorFilter);
-    invalidateSelf();
-  }
-
-  @Override
-  public void draw(Canvas canvas) {
-    updateTransform();
-    updatePath();
-    updatePaint();
-    int saveCount = canvas.save();
-    canvas.concat(mInverseTransform);
-    canvas.drawPath(mPath, mPaint);
-    if (mBorderWidth != 0) {
-      mBorderPaint.setStrokeWidth(mBorderWidth);
-      mBorderPaint.setColor(DrawableUtils.multiplyColorAlpha(mBorderColor, mPaint.getAlpha()));
-      canvas.drawPath(mPath, mBorderPaint);
+
+    /**
+     * TransformAwareDrawable method
+     */
+    @Override
+    public void setTransformCallback(@Nullable TransformCallback transformCallback) {
+        mTransformCallback = transformCallback;
     }
-    canvas.restoreToCount(saveCount);
-  }
-
-  private void updateTransform() {
-    if (mTransformCallback != null) {
-      mTransformCallback.getTransform(mTransform);
-      mTransformCallback.getRootBounds(mRootBounds);
-    } else {
-      mTransform.reset();
-      mRootBounds.set(getBounds());
+
+    @Override
+    public void setAlpha(int alpha) {
+        if (alpha != mPaint.getAlpha()) {
+            mPaint.setAlpha(alpha);
+            invalidateSelf();
+        }
     }
 
-    if (!mTransform.equals(mLastTransform)) {
-      mIsShaderTransformDirty = true;
-      if (!mTransform.invert(mInverseTransform)) {
-        mInverseTransform.reset();
-        mTransform.reset();
-      }
-      mLastTransform.set(mTransform);
+    @Override
+    public void setColorFilter(ColorFilter colorFilter) {
+        mPaint.setColorFilter(colorFilter);
+        invalidateSelf();
     }
 
-    if (!mRootBounds.equals(mLastRootBounds)) {
-      mIsPathDirty = true;
-      mLastRootBounds.set(mRootBounds);
+    @Override
+    public void draw(Canvas canvas) {
+        updateTransform();
+        updatePath();
+        updatePaint();
+        int saveCount = canvas.save();
+        canvas.concat(mInverseTransform);
+        canvas.drawPath(mPath, mPaint);
+        if (mBorderWidth != 0) {
+            mBorderPaint.setStrokeWidth(mBorderWidth);
+            mBorderPaint.setColor(DrawableUtils.multiplyColorAlpha(mBorderColor, mPaint.getAlpha()));
+            canvas.drawPath(mPath, mBorderPaint);
+        }
+        canvas.restoreToCount(saveCount);
     }
-  }
-
-  private void updatePath() {
-    if (mIsPathDirty) {
-      mPath.reset();
-      mRootBounds.inset(mBorderWidth/2, mBorderWidth/2);
-      if (mIsCircle) {
-        mPath.addCircle(
-            mRootBounds.centerX(),
-            mRootBounds.centerY(),
-            Math.min(mRootBounds.width(), mRootBounds.height())/2,
-            Path.Direction.CW);
-      } else {
-        mPath.addRoundRect(mRootBounds, mCornerRadii, Path.Direction.CW);
-      }
-      mRootBounds.inset(-(mBorderWidth/2), -(mBorderWidth/2));
-      mPath.setFillType(Path.FillType.WINDING);
-      mIsPathDirty = false;
+
+    private void updateTransform() {
+        if (mTransformCallback != null) {
+            mTransformCallback.getTransform(mTransform);
+            mTransformCallback.getRootBounds(mRootBounds);
+        } else {
+            mTransform.reset();
+            mRootBounds.set(getBounds());
+        }
+
+        if (!mTransform.equals(mLastTransform)) {
+            mIsShaderTransformDirty = true;
+            if (!mTransform.invert(mInverseTransform)) {
+                mInverseTransform.reset();
+                mTransform.reset();
+            }
+            mLastTransform.set(mTransform);
+        }
+
+        if (!mRootBounds.equals(mLastRootBounds)) {
+            mIsPathDirty = true;
+            mLastRootBounds.set(mRootBounds);
+        }
     }
-  }
-
-  private void updatePaint() {
-    Bitmap bitmap = getBitmap();
-    if (mLastBitmap == null || mLastBitmap.get() != bitmap) {
-      mLastBitmap = new WeakReference<Bitmap>(bitmap);
-      mPaint.setShader(new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP));
-      mIsShaderTransformDirty = true;
+
+    private void updatePath() {
+        if (mIsPathDirty) {
+            mPath.reset();
+            mRootBounds.inset(mBorderWidth / 2, mBorderWidth / 2);
+            if (mIsCircle) {
+                mPath.addCircle(
+                        mRootBounds.centerX(),
+                        mRootBounds.centerY(),
+                        Math.min(mRootBounds.width(), mRootBounds.height()) / 2,
+                        Path.Direction.CW);
+            } else {
+                mPath.addRoundRect(mRootBounds, mCornerRadii, Path.Direction.CW);
+            }
+            mRootBounds.inset(-(mBorderWidth / 2), -(mBorderWidth / 2));
+            mPath.setFillType(Path.FillType.WINDING);
+            mIsPathDirty = false;
+        }
     }
-    if (mIsShaderTransformDirty) {
-      mPaint.getShader().setLocalMatrix(mTransform);
-      mIsShaderTransformDirty = false;
+
+    private void updatePaint() {
+        Bitmap bitmap = getBitmap();
+        if (mLastBitmap == null || mLastBitmap.get() != bitmap) {
+            mLastBitmap = new WeakReference<Bitmap>(bitmap);
+            mPaint.setShader(new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP));
+            mIsShaderTransformDirty = true;
+        }
+        if (mIsShaderTransformDirty) {
+            mPaint.getShader().setLocalMatrix(mTransform);
+            mIsShaderTransformDirty = false;
+        }
     }
-  }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedColorDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedColorDrawable.java
index d7833ce4e..d3d022426 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedColorDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedColorDrawable.java
@@ -25,207 +25,217 @@
 import com.facebook.common.internal.VisibleForTesting;
 
 public class RoundedColorDrawable extends Drawable {
-  @VisibleForTesting final float[] mRadii = new float[8];
-  @VisibleForTesting final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  @VisibleForTesting boolean mIsCircle = false;
-  @VisibleForTesting float mBorderWidth = 0;
-  @VisibleForTesting int mBorderColor = Color.TRANSPARENT;
-  @VisibleForTesting final Path mPath = new Path();
-  private int mColor = Color.TRANSPARENT;
-  private final RectF mTempRect = new RectF();
-  private int mAlpha = 255;
-
-  /**
-   * Creates a RoundedColorDrawable.
-   *
-   * @param color of the drawable
-   */
-  public RoundedColorDrawable(int color) {
-    setColor(color);
-  }
-
-  /**
-   * Creates a new instance of RoundedColorDrawable from the given ColorDrawable.
-   * @param colorDrawable color drawable to extract the color from
-   * @return a new RoundedColorDrawable
-   */
-  public static RoundedColorDrawable fromColorDrawable(ColorDrawable colorDrawable) {
-    return new RoundedColorDrawable(colorDrawable.getColor());
-  }
-
-  /**
-   * Creates a new instance of RoundedColorDrawable.
-   *
-   * @param radii Each corner receive two radius values [X, Y]. The corners are ordered
-   *   top-left, top-right, bottom-right, bottom-left.
-   * @param color of the drawable
-   */
-  public RoundedColorDrawable(float[] radii, int color) {
-    this(color);
-    setRadii(radii);
-  }
-
-  /**
-   * Creates a new instance of RoundedColorDrawable.
-   *
-   * @param radius of the corners in pixels
-   * @param color of the drawable
-   */
-  public RoundedColorDrawable(float radius, int color) {
-    this(color);
-    setRadius(radius);
-  }
-
-  @Override
-  protected void onBoundsChange(Rect bounds) {
-    super.onBoundsChange(bounds);
-    updatePath();
-  }
-
-  @Override
-  public void draw(Canvas canvas) {
-    mPaint.setColor(DrawableUtils.multiplyColorAlpha(mColor, mAlpha));
-    mPaint.setStyle(Paint.Style.FILL);
-    canvas.drawPath(mPath, mPaint);
-    if (mBorderWidth != 0) {
-      mPaint.setColor(DrawableUtils.multiplyColorAlpha(mBorderColor, mAlpha));
-      mPaint.setStyle(Paint.Style.STROKE);
-      mPaint.setStrokeWidth(mBorderWidth);
-      canvas.drawPath(mPath, mPaint);
-    }
-  }
-
-  /**
-   * Sets whether to round as circle.
-   *
-   * @param isCircle whether or not to round as circle
-   */
-  public void setCircle(boolean isCircle) {
-    mIsCircle = isCircle;
-    updatePath();
-    invalidateSelf();
-  }
-
-  /**
-   * Sets the rounding radii.
-   *
-   * @param radii Each corner receive two radius values [X, Y]. The corners are ordered
-   * top-left, top-right, bottom-right, bottom-left
-   */
-  public void setRadii(float[] radii) {
-    if (radii == null) {
-      Arrays.fill(mRadii, 0);
-    } else {
-      Preconditions.checkArgument(radii.length == 8, "radii should have exactly 8 values");
-      System.arraycopy(radii, 0, mRadii, 0, 8);
-    }
-    updatePath();
-    invalidateSelf();
-  }
-
-  /**
-   * Sets the rounding radius.
-   *
-   * @param radius
-   */
-  public void setRadius(float radius) {
-    Preconditions.checkArgument(radius >= 0, "radius should be non negative");
-    Arrays.fill(mRadii, radius);
-    updatePath();
-    invalidateSelf();
-  }
-
-  /**
-   * Sets the color.
-   * @param color
-   */
-  public void setColor(int color) {
-    if (mColor != color) {
-      mColor = color;
-      invalidateSelf();
-    }
-  }
-
-  /**
-   * Gets the color.
-   * @return color
-   */
-  public int getColor() {
-    return mColor;
-  }
-
-  /**
-   * Sets the border
-   * @param color of the border
-   * @param width of the border
-   */
-  public void setBorder(int color, float width) {
-    if (mBorderColor != color) {
-      mBorderColor = color;
-      invalidateSelf();
-    }
-
-    if (mBorderWidth != width) {
-      mBorderWidth = width;
-      updatePath();
-      invalidateSelf();
-    }
-  }
-
-  /**
-   * Sets the drawable's alpha value.
-   *
-   * @param alpha The alpha value to set, between 0 and 255.
-   */
-  @Override
-  public void setAlpha(int alpha) {
-    if (alpha != mAlpha) {
-      mAlpha = alpha;
-      invalidateSelf();
-    }
-  }
-
-  /**
-   * Returns the drawable's alpha value.
-   *
-   * @return A value between 0 and 255.
-   */
-  @Override
-  public int getAlpha() {
-    return mAlpha;
-  }
-
-  /**
-   * Setting a color filter on a ColorDrawable has no effect. This has been inspired by Android
-   * ColorDrawable.
-   *
-   * @param colorFilter Ignore.
-   */
-  @Override
-  public void setColorFilter(ColorFilter colorFilter) {
-  }
-
-  /**
-   * Returns the opacity of the final color which would be used for drawing. This has been
-   * inspired by Android ColorDrawable.
-   *
-   * @return the opacity
-   */
-  @Override
-  public int getOpacity() {
-    return DrawableUtils.getOpacityFromColor(DrawableUtils.multiplyColorAlpha(mColor, mAlpha));
-  }
-
-  private void updatePath() {
-    mPath.reset();
-    mTempRect.set(getBounds());
-    mTempRect.inset(mBorderWidth/2, mBorderWidth/2);
-    if (mIsCircle) {
-      float radius = Math.min(mTempRect.width(), mTempRect.height()) / 2;
-      mPath.addCircle(mTempRect.centerX(), mTempRect.centerY(), radius, Path.Direction.CW);
-    } else {
-      mPath.addRoundRect(mTempRect, mRadii, Path.Direction.CW);
-    }
-    mTempRect.inset(-mBorderWidth/2, -mBorderWidth/2);
-  }
+    @VisibleForTesting
+    final float[] mRadii = new float[8];
+    @VisibleForTesting
+    final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    @VisibleForTesting
+    boolean mIsCircle = false;
+    @VisibleForTesting
+    float mBorderWidth = 0;
+    @VisibleForTesting
+    int mBorderColor = Color.TRANSPARENT;
+    @VisibleForTesting
+    final Path mPath = new Path();
+    private int mColor = Color.TRANSPARENT;
+    private final RectF mTempRect = new RectF();
+    private int mAlpha = 255;
+
+    /**
+     * Creates a RoundedColorDrawable.
+     *
+     * @param color of the drawable
+     */
+    public RoundedColorDrawable(int color) {
+        setColor(color);
+    }
+
+    /**
+     * Creates a new instance of RoundedColorDrawable from the given ColorDrawable.
+     *
+     * @param colorDrawable color drawable to extract the color from
+     * @return a new RoundedColorDrawable
+     */
+    public static RoundedColorDrawable fromColorDrawable(ColorDrawable colorDrawable) {
+        return new RoundedColorDrawable(colorDrawable.getColor());
+    }
+
+    /**
+     * Creates a new instance of RoundedColorDrawable.
+     *
+     * @param radii Each corner receive two radius values [X, Y]. The corners are ordered
+     *              top-left, top-right, bottom-right, bottom-left.
+     * @param color of the drawable
+     */
+    public RoundedColorDrawable(float[] radii, int color) {
+        this(color);
+        setRadii(radii);
+    }
+
+    /**
+     * Creates a new instance of RoundedColorDrawable.
+     *
+     * @param radius of the corners in pixels
+     * @param color  of the drawable
+     */
+    public RoundedColorDrawable(float radius, int color) {
+        this(color);
+        setRadius(radius);
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        updatePath();
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        mPaint.setColor(DrawableUtils.multiplyColorAlpha(mColor, mAlpha));
+        mPaint.setStyle(Paint.Style.FILL);
+        canvas.drawPath(mPath, mPaint);
+        if (mBorderWidth != 0) {
+            mPaint.setColor(DrawableUtils.multiplyColorAlpha(mBorderColor, mAlpha));
+            mPaint.setStyle(Paint.Style.STROKE);
+            mPaint.setStrokeWidth(mBorderWidth);
+            canvas.drawPath(mPath, mPaint);
+        }
+    }
+
+    /**
+     * Sets whether to round as circle.
+     *
+     * @param isCircle whether or not to round as circle
+     */
+    public void setCircle(boolean isCircle) {
+        mIsCircle = isCircle;
+        updatePath();
+        invalidateSelf();
+    }
+
+    /**
+     * Sets the rounding radii.
+     *
+     * @param radii Each corner receive two radius values [X, Y]. The corners are ordered
+     *              top-left, top-right, bottom-right, bottom-left
+     */
+    public void setRadii(float[] radii) {
+        if (radii == null) {
+            Arrays.fill(mRadii, 0);
+        } else {
+            Preconditions.checkArgument(radii.length == 8, "radii should have exactly 8 values");
+            System.arraycopy(radii, 0, mRadii, 0, 8);
+        }
+        updatePath();
+        invalidateSelf();
+    }
+
+    /**
+     * Sets the rounding radius.
+     *
+     * @param radius
+     */
+    public void setRadius(float radius) {
+        Preconditions.checkArgument(radius >= 0, "radius should be non negative");
+        Arrays.fill(mRadii, radius);
+        updatePath();
+        invalidateSelf();
+    }
+
+    /**
+     * Sets the color.
+     *
+     * @param color
+     */
+    public void setColor(int color) {
+        if (mColor != color) {
+            mColor = color;
+            invalidateSelf();
+        }
+    }
+
+    /**
+     * Gets the color.
+     *
+     * @return color
+     */
+    public int getColor() {
+        return mColor;
+    }
+
+    /**
+     * Sets the border
+     *
+     * @param color of the border
+     * @param width of the border
+     */
+    public void setBorder(int color, float width) {
+        if (mBorderColor != color) {
+            mBorderColor = color;
+            invalidateSelf();
+        }
+
+        if (mBorderWidth != width) {
+            mBorderWidth = width;
+            updatePath();
+            invalidateSelf();
+        }
+    }
+
+    /**
+     * Sets the drawable's alpha value.
+     *
+     * @param alpha The alpha value to set, between 0 and 255.
+     */
+    @Override
+    public void setAlpha(int alpha) {
+        if (alpha != mAlpha) {
+            mAlpha = alpha;
+            invalidateSelf();
+        }
+    }
+
+    /**
+     * Returns the drawable's alpha value.
+     *
+     * @return A value between 0 and 255.
+     */
+    @Override
+    public int getAlpha() {
+        return mAlpha;
+    }
+
+    /**
+     * Setting a color filter on a ColorDrawable has no effect. This has been inspired by Android
+     * ColorDrawable.
+     *
+     * @param colorFilter Ignore.
+     */
+    @Override
+    public void setColorFilter(ColorFilter colorFilter) {
+    }
+
+    /**
+     * Returns the opacity of the final color which would be used for drawing. This has been
+     * inspired by Android ColorDrawable.
+     *
+     * @return the opacity
+     */
+    @Override
+    public int getOpacity() {
+        return DrawableUtils.getOpacityFromColor(DrawableUtils.multiplyColorAlpha(mColor, mAlpha));
+    }
+
+    private void updatePath() {
+        mPath.reset();
+        mTempRect.set(getBounds());
+        mTempRect.inset(mBorderWidth / 2, mBorderWidth / 2);
+        if (mIsCircle) {
+            float radius = Math.min(mTempRect.width(), mTempRect.height()) / 2;
+            mPath.addCircle(mTempRect.centerX(), mTempRect.centerY(), radius, Path.Direction.CW);
+        } else {
+            mPath.addRoundRect(mTempRect, mRadii, Path.Direction.CW);
+        }
+        mTempRect.inset(-mBorderWidth / 2, -mBorderWidth / 2);
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedCornersDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedCornersDrawable.java
index f33ae6a1e..9aa16ca76 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedCornersDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedCornersDrawable.java
@@ -27,186 +27,194 @@
  */
 public class RoundedCornersDrawable extends ForwardingDrawable {
 
-  public enum Type {
+    public enum Type {
+        /**
+         * Draws rounded corners on top of the underlying drawable by overlaying a solid color which
+         * is specified by {@code setOverlayColor}. This option should only be used when the
+         * background beneath the underlying drawable is static and of the same solid color.
+         */
+        OVERLAY_COLOR,
+
+        /**
+         * Clips the drawable to be rounded. This option is not supported right now but is expected to
+         * be made available in the future.
+         */
+        CLIPPING
+    }
+
+    @VisibleForTesting
+    Type mType = Type.OVERLAY_COLOR;
+    @VisibleForTesting
+    final float[] mRadii = new float[8];
+    @VisibleForTesting
+    final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    @VisibleForTesting
+    boolean mIsCircle = false;
+    @VisibleForTesting
+    float mBorderWidth = 0;
+    @VisibleForTesting
+    int mBorderColor = Color.TRANSPARENT;
+    @VisibleForTesting
+    int mOverlayColor = Color.TRANSPARENT;
+    private final Path mPath = new Path();
+    private final RectF mTempRectangle = new RectF();
+
     /**
-     * Draws rounded corners on top of the underlying drawable by overlaying a solid color which
-     * is specified by {@code setOverlayColor}. This option should only be used when the
-     * background beneath the underlying drawable is static and of the same solid color.
+     * Creates a new RoundedCornersDrawable with given underlying drawable.
+     *
+     * @param drawable underlying drawable
      */
-    OVERLAY_COLOR,
+    public RoundedCornersDrawable(Drawable drawable) {
+        super(Preconditions.checkNotNull(drawable));
+    }
 
     /**
-     * Clips the drawable to be rounded. This option is not supported right now but is expected to
-     * be made available in the future.
+     * Sets the type of rounding process
+     *
+     * @param type type of rounding process
      */
-    CLIPPING
-  }
-
-  @VisibleForTesting Type mType = Type.OVERLAY_COLOR;
-  @VisibleForTesting final float[] mRadii = new float[8];
-  @VisibleForTesting final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  @VisibleForTesting boolean mIsCircle = false;
-  @VisibleForTesting float mBorderWidth = 0;
-  @VisibleForTesting int mBorderColor = Color.TRANSPARENT;
-  @VisibleForTesting int mOverlayColor = Color.TRANSPARENT;
-  private final Path mPath = new Path();
-  private final RectF mTempRectangle = new RectF();
-
-  /**
-   * Creates a new RoundedCornersDrawable with given underlying drawable.
-   *
-   * @param drawable underlying drawable
-   */
-  public RoundedCornersDrawable(Drawable drawable) {
-    super(Preconditions.checkNotNull(drawable));
-  }
-
-  /**
-   * Sets the type of rounding process
-   *
-   * @param type type of rounding process
-   */
-  public void setType(Type type) {
-    mType = type;
-    invalidateSelf();
-  }
-
-  /**
-   * Sets whether to round as circle.
-   *
-   * @param isCircle whether or not to round as circle
-   */
-  public void setCircle(boolean isCircle) {
-    mIsCircle = isCircle;
-    updatePath();
-    invalidateSelf();
-  }
-
-  /**
-   * Sets radius to be used for rounding
-   *
-   * @param radius corner radius in pixels
-   */
-  public void setRadius(float radius) {
-    Arrays.fill(mRadii, radius);
-    updatePath();
-    invalidateSelf();
-  }
-
-  /**
-   * Sets radii values to be used for rounding.
-   * Each corner receive two radius values [X, Y]. The corners are ordered
-   * top-left, top-right, bottom-right, bottom-left
-   *
-   * @param radii Array of 8 values, 4 pairs of [X,Y] radii
-   */
-  public void setRadii(float[] radii) {
-    if (radii == null) {
-      Arrays.fill(mRadii, 0);
-    } else {
-      Preconditions.checkArgument(radii.length == 8, "radii should have exactly 8 values");
-      System.arraycopy(radii, 0, mRadii, 0, 8);
+    public void setType(Type type) {
+        mType = type;
+        invalidateSelf();
     }
-    updatePath();
-    invalidateSelf();
-  }
-
-  /**
-   * Sets the overlay color.
-   *
-   * @param overlayColor the color to filled outside the rounded corners
-   */
-  public void setOverlayColor(int overlayColor) {
-    mOverlayColor = overlayColor;
-    invalidateSelf();
-  }
-
-  /**
-   * Sets the border
-   * @param color of the border
-   * @param width of the border
-   */
-  public void setBorder(int color, float width) {
-    mBorderColor = color;
-    mBorderWidth = width;
-    updatePath();
-    invalidateSelf();
-  }
-
-  @Override
-  protected void onBoundsChange(Rect bounds) {
-    super.onBoundsChange(bounds);
-    updatePath();
-  }
-
-  private void updatePath() {
-    mPath.reset();
-    mTempRectangle.set(getBounds());
-    mTempRectangle.inset(mBorderWidth/2, mBorderWidth/2);
-    if (mIsCircle) {
-      mPath.addCircle(
-          mTempRectangle.centerX(),
-          mTempRectangle.centerY(),
-          Math.min(mTempRectangle.width(), mTempRectangle.height())/2,
-          Path.Direction.CW);
-    } else {
-      mPath.addRoundRect(mTempRectangle, mRadii, Path.Direction.CW);
+
+    /**
+     * Sets whether to round as circle.
+     *
+     * @param isCircle whether or not to round as circle
+     */
+    public void setCircle(boolean isCircle) {
+        mIsCircle = isCircle;
+        updatePath();
+        invalidateSelf();
     }
-    mTempRectangle.inset(-mBorderWidth/2, -mBorderWidth/2);
-  }
-
-  @Override
-  public void draw(Canvas canvas) {
-    Rect bounds = getBounds();
-    switch (mType) {
-      case CLIPPING:
-        // clip, note: doesn't support anti-aliasing
-        int saveCount = canvas.save();
-        mPath.setFillType(Path.FillType.EVEN_ODD);
-        canvas.clipPath(mPath);
-        super.draw(canvas);
-        canvas.restoreToCount(saveCount);
-        break;
-      case OVERLAY_COLOR:
-        super.draw(canvas);
-        mPaint.setColor(mOverlayColor);
-        mPaint.setStyle(Paint.Style.FILL);
-        mPath.setFillType(Path.FillType.INVERSE_EVEN_ODD);
-        canvas.drawPath(mPath, mPaint);
 
+    /**
+     * Sets radius to be used for rounding
+     *
+     * @param radius corner radius in pixels
+     */
+    public void setRadius(float radius) {
+        Arrays.fill(mRadii, radius);
+        updatePath();
+        invalidateSelf();
+    }
+
+    /**
+     * Sets radii values to be used for rounding.
+     * Each corner receive two radius values [X, Y]. The corners are ordered
+     * top-left, top-right, bottom-right, bottom-left
+     *
+     * @param radii Array of 8 values, 4 pairs of [X,Y] radii
+     */
+    public void setRadii(float[] radii) {
+        if (radii == null) {
+            Arrays.fill(mRadii, 0);
+        } else {
+            Preconditions.checkArgument(radii.length == 8, "radii should have exactly 8 values");
+            System.arraycopy(radii, 0, mRadii, 0, 8);
+        }
+        updatePath();
+        invalidateSelf();
+    }
+
+    /**
+     * Sets the overlay color.
+     *
+     * @param overlayColor the color to filled outside the rounded corners
+     */
+    public void setOverlayColor(int overlayColor) {
+        mOverlayColor = overlayColor;
+        invalidateSelf();
+    }
+
+    /**
+     * Sets the border
+     *
+     * @param color of the border
+     * @param width of the border
+     */
+    public void setBorder(int color, float width) {
+        mBorderColor = color;
+        mBorderWidth = width;
+        updatePath();
+        invalidateSelf();
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        updatePath();
+    }
+
+    private void updatePath() {
+        mPath.reset();
+        mTempRectangle.set(getBounds());
+        mTempRectangle.inset(mBorderWidth / 2, mBorderWidth / 2);
         if (mIsCircle) {
-          // INVERSE_EVEN_ODD will only draw inverse circle within its bounding box, so we need to
-          // fill the rest manually if the bounds are not square.
-          float paddingH = (bounds.width() - bounds.height() + mBorderWidth) / 2f;
-          float paddingV = (bounds.height() - bounds.width() + mBorderWidth) / 2f;
-          if (paddingH > 0) {
-            canvas.drawRect(bounds.left, bounds.top, bounds.left + paddingH, bounds.bottom, mPaint);
-            canvas.drawRect(
-                bounds.right - paddingH,
-                bounds.top,
-                bounds.right,
-                bounds.bottom,
-                mPaint);
-          }
-          if (paddingV > 0) {
-            canvas.drawRect(bounds.left, bounds.top, bounds.right, bounds.top + paddingV, mPaint);
-            canvas.drawRect(
-                bounds.left,
-                bounds.bottom - paddingV,
-                bounds.right,
-                bounds.bottom,
-                mPaint);
-          }
+            mPath.addCircle(
+                    mTempRectangle.centerX(),
+                    mTempRectangle.centerY(),
+                    Math.min(mTempRectangle.width(), mTempRectangle.height()) / 2,
+                    Path.Direction.CW);
+        } else {
+            mPath.addRoundRect(mTempRectangle, mRadii, Path.Direction.CW);
         }
-        break;
+        mTempRectangle.inset(-mBorderWidth / 2, -mBorderWidth / 2);
     }
 
-    if (mBorderColor != Color.TRANSPARENT) {
-      mPaint.setStyle(Paint.Style.STROKE);
-      mPaint.setColor(mBorderColor);
-      mPaint.setStrokeWidth(mBorderWidth);
-      mPath.setFillType(Path.FillType.EVEN_ODD);
-      canvas.drawPath(mPath, mPaint);
+    @Override
+    public void draw(Canvas canvas) {
+        Rect bounds = getBounds();
+        switch (mType) {
+            case CLIPPING:
+                // clip, note: doesn't support anti-aliasing
+                int saveCount = canvas.save();
+                mPath.setFillType(Path.FillType.EVEN_ODD);
+                canvas.clipPath(mPath);
+                super.draw(canvas);
+                canvas.restoreToCount(saveCount);
+                break;
+            case OVERLAY_COLOR:
+                super.draw(canvas);
+                mPaint.setColor(mOverlayColor);
+                mPaint.setStyle(Paint.Style.FILL);
+                mPath.setFillType(Path.FillType.INVERSE_EVEN_ODD);
+                canvas.drawPath(mPath, mPaint);
+
+                if (mIsCircle) {
+                    // INVERSE_EVEN_ODD will only draw inverse circle within its bounding box, so we need to
+                    // fill the rest manually if the bounds are not square.
+                    float paddingH = (bounds.width() - bounds.height() + mBorderWidth) / 2f;
+                    float paddingV = (bounds.height() - bounds.width() + mBorderWidth) / 2f;
+                    if (paddingH > 0) {
+                        canvas.drawRect(bounds.left, bounds.top, bounds.left + paddingH, bounds.bottom, mPaint);
+                        canvas.drawRect(
+                                bounds.right - paddingH,
+                                bounds.top,
+                                bounds.right,
+                                bounds.bottom,
+                                mPaint);
+                    }
+                    if (paddingV > 0) {
+                        canvas.drawRect(bounds.left, bounds.top, bounds.right, bounds.top + paddingV, mPaint);
+                        canvas.drawRect(
+                                bounds.left,
+                                bounds.bottom - paddingV,
+                                bounds.right,
+                                bounds.bottom,
+                                mPaint);
+                    }
+                }
+                break;
+        }
+
+        if (mBorderColor != Color.TRANSPARENT) {
+            mPaint.setStyle(Paint.Style.STROKE);
+            mPaint.setColor(mBorderColor);
+            mPaint.setStrokeWidth(mBorderWidth);
+            mPath.setFillType(Path.FillType.EVEN_ODD);
+            canvas.drawPath(mPath, mPaint);
+        }
     }
-  }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java
index 5b6fc90c4..7129586c0 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java
@@ -25,161 +25,173 @@
  */
 public class ScaleTypeDrawable extends ForwardingDrawable {
 
-  // Specified scale type.
-  @VisibleForTesting ScalingUtils.ScaleType mScaleType;
-
-  // Specified focus point to use with FOCUS_CROP.
-  @VisibleForTesting PointF mFocusPoint = null;
-
-  // Last known dimensions of the underlying drawable. Used to avoid computing bounds every time
-  // if underlying size hasn't changed.
-  @VisibleForTesting int mUnderlyingWidth = 0;
-  @VisibleForTesting int mUnderlyingHeight = 0;
-
-  // Matrix that is actually being used for drawing.
-  @VisibleForTesting Matrix mDrawMatrix;
-
-  // Temporary objects preallocated in advance to save future allocations.
-  private Matrix mTempMatrix = new Matrix();
-
-  /**
-   * Creates a new ScaleType drawable with given underlying drawable and scale type.
-   * @param drawable underlying drawable to apply scale type on
-   * @param scaleType scale type to be applied
-   */
-  public ScaleTypeDrawable(Drawable drawable, ScalingUtils.ScaleType scaleType) {
-    super(Preconditions.checkNotNull(drawable));
-    mScaleType = scaleType;
-  }
-
-  /**
-   * Gets the current scale type.
-   * @return scale type
-   */
-  public ScalingUtils.ScaleType getScaleType() {
-    return mScaleType;
-  }
-
-  /**
-   * Sets the scale type.
-   * @param scaleType scale type to set
-   */
-  public void setScaleType(ScalingUtils.ScaleType scaleType) {
-    mScaleType = scaleType;
-    configureBounds();
-    invalidateSelf();
-  }
-
-  /**
-   * Gets the focus point.
-   * @return focus point of the image
-   */
-  public PointF getFocusPoint() {
-    return mFocusPoint;
-  }
-
-  /**
-   * Sets the focus point.
-   * If ScaleType.FOCUS_CROP is used, focus point will attempted to be centered within a view.
-   * Each coordinate is a real number in [0,1] range, in the coordinate system where top-left
-   * corner of the image corresponds to (0, 0) and the bottom-right corner corresponds to (1, 1).
-   * @param focusPoint focus point of the image
-   */
-  public void setFocusPoint(PointF focusPoint) {
-    if (mFocusPoint == null) {
-      mFocusPoint = new PointF();
+    // Specified scale type.
+    @VisibleForTesting
+    ScalingUtils.ScaleType mScaleType;
+
+    // Specified focus point to use with FOCUS_CROP.
+    @VisibleForTesting
+    PointF mFocusPoint = null;
+
+    // Last known dimensions of the underlying drawable. Used to avoid computing bounds every time
+    // if underlying size hasn't changed.
+    @VisibleForTesting
+    int mUnderlyingWidth = 0;
+    @VisibleForTesting
+    int mUnderlyingHeight = 0;
+
+    // Matrix that is actually being used for drawing.
+    @VisibleForTesting
+    Matrix mDrawMatrix;
+
+    // Temporary objects preallocated in advance to save future allocations.
+    private Matrix mTempMatrix = new Matrix();
+
+    /**
+     * Creates a new ScaleType drawable with given underlying drawable and scale type.
+     *
+     * @param drawable  underlying drawable to apply scale type on
+     * @param scaleType scale type to be applied
+     */
+    public ScaleTypeDrawable(Drawable drawable, ScalingUtils.ScaleType scaleType) {
+        super(Preconditions.checkNotNull(drawable));
+        mScaleType = scaleType;
     }
-    mFocusPoint.set(focusPoint);
-    configureBounds();
-    invalidateSelf();
-  }
-
-  @Override
-  public void draw(Canvas canvas) {
-    configureBoundsIfUnderlyingChanged();
-    if (mDrawMatrix != null) {
-      int saveCount = canvas.save();
-      canvas.clipRect(getBounds());
-      canvas.concat(mDrawMatrix);
-      super.draw(canvas);
-      canvas.restoreToCount(saveCount);
-    } else {
-      // mDrawMatrix == null means our bounds match and we can take fast path
-      super.draw(canvas);
+
+    /**
+     * Gets the current scale type.
+     *
+     * @return scale type
+     */
+    public ScalingUtils.ScaleType getScaleType() {
+        return mScaleType;
+    }
+
+    /**
+     * Sets the scale type.
+     *
+     * @param scaleType scale type to set
+     */
+    public void setScaleType(ScalingUtils.ScaleType scaleType) {
+        mScaleType = scaleType;
+        configureBounds();
+        invalidateSelf();
     }
-  }
 
-  @Override
-  protected void onBoundsChange(Rect bounds) {
-    configureBounds();
-  }
+    /**
+     * Gets the focus point.
+     *
+     * @return focus point of the image
+     */
+    public PointF getFocusPoint() {
+        return mFocusPoint;
+    }
 
-  private void configureBoundsIfUnderlyingChanged() {
-    if (mUnderlyingWidth != getCurrent().getIntrinsicWidth() ||
-        mUnderlyingHeight != getCurrent().getIntrinsicHeight()) {
-      configureBounds();
+    /**
+     * Sets the focus point.
+     * If ScaleType.FOCUS_CROP is used, focus point will attempted to be centered within a view.
+     * Each coordinate is a real number in [0,1] range, in the coordinate system where top-left
+     * corner of the image corresponds to (0, 0) and the bottom-right corner corresponds to (1, 1).
+     *
+     * @param focusPoint focus point of the image
+     */
+    public void setFocusPoint(PointF focusPoint) {
+        if (mFocusPoint == null) {
+            mFocusPoint = new PointF();
+        }
+        mFocusPoint.set(focusPoint);
+        configureBounds();
+        invalidateSelf();
     }
-  }
-
-  /**
-   * Determines bounds for the underlying drawable and a matrix that should be applied on it.
-   * Adopted from android.widget.ImageView
-   */
-  @VisibleForTesting void configureBounds() {
-    Drawable underlyingDrawable = getCurrent();
-    Rect bounds = getBounds();
-    int viewWidth = bounds.width();
-    int viewHeight = bounds.height();
-    int underlyingWidth = mUnderlyingWidth = underlyingDrawable.getIntrinsicWidth();
-    int underlyingHeight = mUnderlyingHeight = underlyingDrawable.getIntrinsicHeight();
-
-    // If the drawable has no intrinsic size, we just fill our entire view.
-    if (underlyingWidth <= 0 || underlyingHeight <= 0) {
-      underlyingDrawable.setBounds(bounds);
-      mDrawMatrix = null;
-      return;
+
+    @Override
+    public void draw(Canvas canvas) {
+        configureBoundsIfUnderlyingChanged();
+        if (mDrawMatrix != null) {
+            int saveCount = canvas.save();
+            canvas.clipRect(getBounds());
+            canvas.concat(mDrawMatrix);
+            super.draw(canvas);
+            canvas.restoreToCount(saveCount);
+        } else {
+            // mDrawMatrix == null means our bounds match and we can take fast path
+            super.draw(canvas);
+        }
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        configureBounds();
     }
 
-    // If the drawable fits exactly, no transform needed.
-    if (underlyingWidth == viewWidth && underlyingHeight == viewHeight) {
-      underlyingDrawable.setBounds(bounds);
-      mDrawMatrix = null;
-      return;
+    private void configureBoundsIfUnderlyingChanged() {
+        if (mUnderlyingWidth != getCurrent().getIntrinsicWidth() ||
+                mUnderlyingHeight != getCurrent().getIntrinsicHeight()) {
+            configureBounds();
+        }
     }
 
-    // If we're told to scale to fit, we just fill our entire view.
-    // (ScalingUtils.getTransform would do, but this is faster)
-    if (mScaleType == ScalingUtils.ScaleType.FIT_XY) {
-      underlyingDrawable.setBounds(bounds);
-      mDrawMatrix = null;
-      return;
+    /**
+     * Determines bounds for the underlying drawable and a matrix that should be applied on it.
+     * Adopted from android.widget.ImageView
+     */
+    @VisibleForTesting
+    void configureBounds() {
+        Drawable underlyingDrawable = getCurrent();
+        Rect bounds = getBounds();
+        int viewWidth = bounds.width();
+        int viewHeight = bounds.height();
+        int underlyingWidth = mUnderlyingWidth = underlyingDrawable.getIntrinsicWidth();
+        int underlyingHeight = mUnderlyingHeight = underlyingDrawable.getIntrinsicHeight();
+
+        // If the drawable has no intrinsic size, we just fill our entire view.
+        if (underlyingWidth <= 0 || underlyingHeight <= 0) {
+            underlyingDrawable.setBounds(bounds);
+            mDrawMatrix = null;
+            return;
+        }
+
+        // If the drawable fits exactly, no transform needed.
+        if (underlyingWidth == viewWidth && underlyingHeight == viewHeight) {
+            underlyingDrawable.setBounds(bounds);
+            mDrawMatrix = null;
+            return;
+        }
+
+        // If we're told to scale to fit, we just fill our entire view.
+        // (ScalingUtils.getTransform would do, but this is faster)
+        if (mScaleType == ScalingUtils.ScaleType.FIT_XY) {
+            underlyingDrawable.setBounds(bounds);
+            mDrawMatrix = null;
+            return;
+        }
+
+        // We need to do the scaling ourselves, so have the underlying drawable use its preferred size.
+        underlyingDrawable.setBounds(0, 0, underlyingWidth, underlyingHeight);
+        ScalingUtils.getTransform(
+                mTempMatrix,
+                bounds,
+                underlyingWidth,
+                underlyingHeight,
+                (mFocusPoint != null) ? mFocusPoint.x : 0.5f,
+                (mFocusPoint != null) ? mFocusPoint.y : 0.5f,
+                mScaleType);
+        mDrawMatrix = mTempMatrix;
     }
 
-    // We need to do the scaling ourselves, so have the underlying drawable use its preferred size.
-    underlyingDrawable.setBounds(0, 0, underlyingWidth, underlyingHeight);
-    ScalingUtils.getTransform(
-        mTempMatrix,
-        bounds,
-        underlyingWidth,
-        underlyingHeight,
-        (mFocusPoint != null) ? mFocusPoint.x : 0.5f,
-        (mFocusPoint != null) ? mFocusPoint.y : 0.5f,
-        mScaleType);
-    mDrawMatrix = mTempMatrix;
-  }
-
-  /**
-   * TransformationCallback method
-   * @param transform
-   */
-  @Override
-  public void getTransform(Matrix transform) {
-    getParentTransform(transform);
-    // IMPORTANT: {@code configureBounds} should be called after {@code getParentTransform},
-    // because the parent may have to change our bounds.
-    configureBoundsIfUnderlyingChanged();
-    if (mDrawMatrix != null) {
-      transform.preConcat(mDrawMatrix);
+    /**
+     * TransformationCallback method
+     *
+     * @param transform
+     */
+    @Override
+    public void getTransform(Matrix transform) {
+        getParentTransform(transform);
+        // IMPORTANT: {@code configureBounds} should be called after {@code getParentTransform},
+        // because the parent may have to change our bounds.
+        configureBoundsIfUnderlyingChanged();
+        if (mDrawMatrix != null) {
+            transform.preConcat(mDrawMatrix);
+        }
     }
-  }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java b/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java
index aa750c9d7..295fa337a 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java
@@ -17,220 +17,221 @@
  */
 public class ScalingUtils {
 
-  /**
-   * Options for scaling the child bounds to the parent bounds.
-   * <p>
-   * Similar to {@link android.widget.ImageView.ScaleType}, but ScaleType.MATRIX is not supported.
-   * To use matrix scaling, use a {@link MatrixDrawable}. An additional scale type (FOCUS_CROP) is
-   * provided.
-   */
-  public enum ScaleType {
-
-    /**
-     * Scales width and height independently, so that the child matches the parent exactly.
-     * This may change the aspect ratio of the child.
-     */
-    FIT_XY,
-
-    /**
-     * Scales the child so that it fits entirely inside the parent. At least one dimension (width or
-     * height) will fit exactly. Aspect ratio is preserved.
-     * Child is aligned to the top-left corner of the parent.
-     */
-    FIT_START,
-
-    /**
-     * Scales the child so that it fits entirely inside the parent. At least one dimension (width or
-     * height) will fit exactly. Aspect ratio is preserved.
-     * Child is centered within the parent's bounds.
-     */
-    FIT_CENTER,
-
-    /**
-     * Scales the child so that it fits entirely inside the parent. At least one dimension (width or
-     * height) will fit exactly. Aspect ratio is preserved.
-     * Child is aligned to the bottom-right corner of the parent.
-     */
-    FIT_END,
-
-    /**
-     * Performs no scaling.
-     * Child is centered within parent's bounds.
-     */
-    CENTER,
-
-    /**
-     * Scales the child so that it fits entirely inside the parent. Unlike FIT_CENTER, if the child
-     * is smaller, no up-scaling will be performed. Aspect ratio is preserved.
-     * Child is centered within parent's bounds.
-     */
-    CENTER_INSIDE,
-
-    /**
-     * Scales the child so that both dimensions will be greater than or equal to the corresponding
-     * dimension of the parent. At least one dimension (width or height) will fit exactly.
-     * Child is centered within parent's bounds.
-     */
-    CENTER_CROP,
-
     /**
-     * Scales the child so that both dimensions will be greater than or equal to the corresponding
-     * dimension of the parent. At least one dimension (width or height) will fit exactly.
-     * The child's focus point will be centered within the parent's bounds as much as possible
-     * without leaving empty space.
-     * It is guaranteed that the focus point will be visible and centered as much as possible.
-     * If the focus point is set to (0.5f, 0.5f), result will be equivalent to CENTER_CROP.
+     * Options for scaling the child bounds to the parent bounds.
+     * <p>
+     * Similar to {@link android.widget.ImageView.ScaleType}, but ScaleType.MATRIX is not supported.
+     * To use matrix scaling, use a {@link MatrixDrawable}. An additional scale type (FOCUS_CROP) is
+     * provided.
      */
-    FOCUS_CROP;
+    public enum ScaleType {
+
+        /**
+         * Scales width and height independently, so that the child matches the parent exactly.
+         * This may change the aspect ratio of the child.
+         */
+        FIT_XY,
+
+        /**
+         * Scales the child so that it fits entirely inside the parent. At least one dimension (width or
+         * height) will fit exactly. Aspect ratio is preserved.
+         * Child is aligned to the top-left corner of the parent.
+         */
+        FIT_START,
+
+        /**
+         * Scales the child so that it fits entirely inside the parent. At least one dimension (width or
+         * height) will fit exactly. Aspect ratio is preserved.
+         * Child is centered within the parent's bounds.
+         */
+        FIT_CENTER,
+
+        /**
+         * Scales the child so that it fits entirely inside the parent. At least one dimension (width or
+         * height) will fit exactly. Aspect ratio is preserved.
+         * Child is aligned to the bottom-right corner of the parent.
+         */
+        FIT_END,
+
+        /**
+         * Performs no scaling.
+         * Child is centered within parent's bounds.
+         */
+        CENTER,
+
+        /**
+         * Scales the child so that it fits entirely inside the parent. Unlike FIT_CENTER, if the child
+         * is smaller, no up-scaling will be performed. Aspect ratio is preserved.
+         * Child is centered within parent's bounds.
+         */
+        CENTER_INSIDE,
+
+        /**
+         * Scales the child so that both dimensions will be greater than or equal to the corresponding
+         * dimension of the parent. At least one dimension (width or height) will fit exactly.
+         * Child is centered within parent's bounds.
+         */
+        CENTER_CROP,
+
+        /**
+         * Scales the child so that both dimensions will be greater than or equal to the corresponding
+         * dimension of the parent. At least one dimension (width or height) will fit exactly.
+         * The child's focus point will be centered within the parent's bounds as much as possible
+         * without leaving empty space.
+         * It is guaranteed that the focus point will be visible and centered as much as possible.
+         * If the focus point is set to (0.5f, 0.5f), result will be equivalent to CENTER_CROP.
+         */
+        FOCUS_CROP;
+
+        /**
+         * Gets the scale type out of string.
+         * <p>
+         * <p> Used by GenericDraweeView styleable in
+         * android_res/com/facebook/custom/res/values/attrs.xml
+         *
+         * @param value string value to parse
+         * @return scale type if recognized
+         * @throws IllegalArgumentException if scale type is not recognized
+         */
+        public static ScaleType fromString(String value) {
+            if (value.equals("none")) {
+                return null;
+            } else if (value.equals("fitXY")) {
+                return ScaleType.FIT_XY;
+            } else if (value.equals("fitStart")) {
+                return ScaleType.FIT_START;
+            } else if (value.equals("fitCenter")) {
+                return FIT_CENTER;
+            } else if (value.equals("fitEnd")) {
+                return FIT_END;
+            } else if (value.equals("center")) {
+                return CENTER;
+            } else if (value.equals("centerInside")) {
+                return CENTER_INSIDE;
+            } else if (value.equals("centerCrop")) {
+                return CENTER_CROP;
+            } else if (value.equals("focusCrop")) {
+                return FOCUS_CROP;
+            } else {
+                throw new IllegalArgumentException(
+                        "Unrecognized scale type: " + value +
+                                "; use a value defined in the ScalingUtils.fromString method");
+            }
+        }
+    }
 
     /**
-     * Gets the scale type out of string.
-     *
-     * <p> Used by GenericDraweeView styleable in
-     * android_res/com/facebook/custom/res/values/attrs.xml
+     * Gets transformation based on the scale type.
      *
-     * @param value string value to parse
-     * @return scale type if recognized
-     * @throws IllegalArgumentException if scale type is not recognized
+     * @param transform    out matrix to store result
+     * @param parentBounds parent bounds
+     * @param childWidth   child width
+     * @param childHeight  child height
+     * @param focusX       focus point x coordinate, relative [0...1]
+     * @param focusY       focus point y coordinate, relative [0...1]
+     * @param scaleType    scale type to be used
+     * @return reference to the out matrix
      */
-    public static ScaleType fromString(String value) {
-      if (value.equals("none")) {
-        return null;
-      } else if (value.equals("fitXY")) {
-        return ScaleType.FIT_XY;
-      } else if (value.equals("fitStart")) {
-        return ScaleType.FIT_START;
-      } else if (value.equals("fitCenter")) {
-        return FIT_CENTER;
-      } else if (value.equals("fitEnd")) {
-        return FIT_END;
-      } else if (value.equals("center")) {
-        return CENTER;
-      } else if (value.equals("centerInside")) {
-        return CENTER_INSIDE;
-      } else if (value.equals("centerCrop")) {
-        return CENTER_CROP;
-      } else if (value.equals("focusCrop")) {
-        return FOCUS_CROP;
-      } else {
-        throw new IllegalArgumentException(
-            "Unrecognized scale type: " + value +
-                "; use a value defined in the ScalingUtils.fromString method");
-      }
-    }
-  }
-
-  /**
-   * Gets transformation based on the scale type.
-   * @param transform out matrix to store result
-   * @param parentBounds parent bounds
-   * @param childWidth child width
-   * @param childHeight child height
-   * @param focusX focus point x coordinate, relative [0...1]
-   * @param focusY focus point y coordinate, relative [0...1]
-   * @param scaleType scale type to be used
-   * @return reference to the out matrix
-   */
-  public static Matrix getTransform(
-      final Matrix transform,
-      final Rect parentBounds,
-      final int childWidth,
-      final int childHeight,
-      final float focusX,
-      final float focusY,
-      final ScaleType scaleType) {
-
-    final int parentWidth = parentBounds.width();
-    final int parentHeight = parentBounds.height();
-
-    final float scaleX = (float) parentWidth / (float) childWidth;
-    final float scaleY = (float) parentHeight / (float) childHeight;
-
-    float scale = 1.0f;
-    float dx = 0;
-    float dy = 0;
-
-
-    switch (scaleType) {
-      case FIT_XY:
-        dx = parentBounds.left;
-        dy = parentBounds.top;
-        transform.setScale(scaleX, scaleY);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case FIT_START:
-        scale = Math.min(scaleX, scaleY);
-        dx = parentBounds.left;
-        dy = parentBounds.top;
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case FIT_CENTER:
-        scale = Math.min(scaleX, scaleY);
-        dx = parentBounds.left + (parentWidth - childWidth * scale) * 0.5f;
-        dy = parentBounds.top + (parentHeight - childHeight * scale) * 0.5f;
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case FIT_END:
-        scale = Math.min(scaleX, scaleY);
-        dx = parentBounds.left + (parentWidth - childWidth * scale);
-        dy = parentBounds.top + (parentHeight - childHeight * scale);
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case CENTER:
-        dx = parentBounds.left + (parentWidth - childWidth) * 0.5f;
-        dy = parentBounds.top + (parentHeight - childHeight) * 0.5f;
-        transform.setTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case CENTER_INSIDE:
-        scale = Math.min(Math.min(scaleX, scaleY), 1.0f);
-        dx = parentBounds.left + (parentWidth - childWidth * scale) * 0.5f;
-        dy = parentBounds.top + (parentHeight - childHeight * scale) * 0.5f;
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case CENTER_CROP:
-        if (scaleY > scaleX) {
-          scale = scaleY;
-          dx = parentBounds.left + (parentWidth - childWidth * scale) * 0.5f;
-          dy = parentBounds.top;
-        } else {
-          scale = scaleX;
-          dx = parentBounds.left;
-          dy = parentBounds.top + (parentHeight - childHeight * scale) * 0.5f;
-        }
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
-
-      case FOCUS_CROP:
-        if (scaleY > scaleX) {
-          scale = scaleY;
-          dx = parentWidth * 0.5f - childWidth * scale * focusX;
-          dx = parentBounds.left + Math.max(Math.min(dx, 0), parentWidth - childWidth * scale);
-          dy = parentBounds.top;
-        } else {
-          scale = scaleX;
-          dx = parentBounds.left;
-          dy = parentHeight * 0.5f - childHeight * scale * focusY;
-          dy = parentBounds.top + Math.max(Math.min(dy, 0), parentHeight - childHeight * scale);
+    public static Matrix getTransform(
+            final Matrix transform,
+            final Rect parentBounds,
+            final int childWidth,
+            final int childHeight,
+            final float focusX,
+            final float focusY,
+            final ScaleType scaleType) {
+
+        final int parentWidth = parentBounds.width();
+        final int parentHeight = parentBounds.height();
+
+        final float scaleX = (float) parentWidth / (float) childWidth;
+        final float scaleY = (float) parentHeight / (float) childHeight;
+
+        float scale = 1.0f;
+        float dx = 0;
+        float dy = 0;
+
+
+        switch (scaleType) {
+            case FIT_XY:
+                dx = parentBounds.left;
+                dy = parentBounds.top;
+                transform.setScale(scaleX, scaleY);
+                transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+                break;
+
+            case FIT_START:
+                scale = Math.min(scaleX, scaleY);
+                dx = parentBounds.left;
+                dy = parentBounds.top;
+                transform.setScale(scale, scale);
+                transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+                break;
+
+            case FIT_CENTER:
+                scale = Math.min(scaleX, scaleY);
+                dx = parentBounds.left + (parentWidth - childWidth * scale) * 0.5f;
+                dy = parentBounds.top + (parentHeight - childHeight * scale) * 0.5f;
+                transform.setScale(scale, scale);
+                transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+                break;
+
+            case FIT_END:
+                scale = Math.min(scaleX, scaleY);
+                dx = parentBounds.left + (parentWidth - childWidth * scale);
+                dy = parentBounds.top + (parentHeight - childHeight * scale);
+                transform.setScale(scale, scale);
+                transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+                break;
+
+            case CENTER:
+                dx = parentBounds.left + (parentWidth - childWidth) * 0.5f;
+                dy = parentBounds.top + (parentHeight - childHeight) * 0.5f;
+                transform.setTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+                break;
+
+            case CENTER_INSIDE:
+                scale = Math.min(Math.min(scaleX, scaleY), 1.0f);
+                dx = parentBounds.left + (parentWidth - childWidth * scale) * 0.5f;
+                dy = parentBounds.top + (parentHeight - childHeight * scale) * 0.5f;
+                transform.setScale(scale, scale);
+                transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+                break;
+
+            case CENTER_CROP:
+                if (scaleY > scaleX) {
+                    scale = scaleY;
+                    dx = parentBounds.left + (parentWidth - childWidth * scale) * 0.5f;
+                    dy = parentBounds.top;
+                } else {
+                    scale = scaleX;
+                    dx = parentBounds.left;
+                    dy = parentBounds.top + (parentHeight - childHeight * scale) * 0.5f;
+                }
+                transform.setScale(scale, scale);
+                transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+                break;
+
+            case FOCUS_CROP:
+                if (scaleY > scaleX) {
+                    scale = scaleY;
+                    dx = parentWidth * 0.5f - childWidth * scale * focusX;
+                    dx = parentBounds.left + Math.max(Math.min(dx, 0), parentWidth - childWidth * scale);
+                    dy = parentBounds.top;
+                } else {
+                    scale = scaleX;
+                    dx = parentBounds.left;
+                    dy = parentHeight * 0.5f - childHeight * scale * focusY;
+                    dy = parentBounds.top + Math.max(Math.min(dy, 0), parentHeight - childHeight * scale);
+                }
+                transform.setScale(scale, scale);
+                transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
+                break;
+
+            default:
+                throw new UnsupportedOperationException("Unsupported scale type: " + scaleType);
         }
-        transform.setScale(scale, scale);
-        transform.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
-        break;
 
-      default:
-        throw new UnsupportedOperationException("Unsupported scale type: " + scaleType);
+        return transform;
     }
-
-    return transform;
-  }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/SettableDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/SettableDrawable.java
index 6417f9436..ace3a667f 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/SettableDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/SettableDrawable.java
@@ -18,29 +18,32 @@
  */
 public class SettableDrawable extends ForwardingDrawable {
 
-  /**
-   * Creates a new settable drawable.
-   * @param drawable underlying drawable
-   */
-  public SettableDrawable(Drawable drawable) {
-    super(Preconditions.checkNotNull(drawable));
-  }
-
-  /**
-   * Sets the new drawable. It is allowed to set drawable multiple times.
-   * @param newDrawable a new drawable to set
-   */
-  public void setDrawable(Drawable newDrawable) {
-    Preconditions.checkNotNull(newDrawable);
-    setCurrent(newDrawable);
-  }
-
-  /**
-   * Gets the current drawable.
-   * @return the current drawable
-   */
-  public Drawable getDrawable() {
-    return getCurrent();
-  }
+    /**
+     * Creates a new settable drawable.
+     *
+     * @param drawable underlying drawable
+     */
+    public SettableDrawable(Drawable drawable) {
+        super(Preconditions.checkNotNull(drawable));
+    }
+
+    /**
+     * Sets the new drawable. It is allowed to set drawable multiple times.
+     *
+     * @param newDrawable a new drawable to set
+     */
+    public void setDrawable(Drawable newDrawable) {
+        Preconditions.checkNotNull(newDrawable);
+        setCurrent(newDrawable);
+    }
+
+    /**
+     * Gets the current drawable.
+     *
+     * @return the current drawable
+     */
+    public Drawable getDrawable() {
+        return getCurrent();
+    }
 
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/TransformAwareDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/TransformAwareDrawable.java
index 4a08f1e4e..37e608e3a 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/TransformAwareDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/TransformAwareDrawable.java
@@ -14,10 +14,10 @@
  */
 public interface TransformAwareDrawable {
 
-  /**
-   * Sets a transform callback.
-   *
-   * @param transformCallback the transform callback to be set
-   */
-  public void setTransformCallback(TransformCallback transformCallback);
+    /**
+     * Sets a transform callback.
+     *
+     * @param transformCallback the transform callback to be set
+     */
+    public void setTransformCallback(TransformCallback transformCallback);
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/TransformCallback.java b/drawee/src/main/java/com/facebook/drawee/drawable/TransformCallback.java
index 5bb0c48ee..baae1aec8 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/TransformCallback.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/TransformCallback.java
@@ -18,17 +18,17 @@
  */
 public interface TransformCallback {
 
-  /**
-   * Called when the drawable needs to get all matrices applied to it.
-   *
-   * @param transform Matrix that is applied to the drawable by the parent drawables.
-   */
-  public void getTransform(Matrix transform);
+    /**
+     * Called when the drawable needs to get all matrices applied to it.
+     *
+     * @param transform Matrix that is applied to the drawable by the parent drawables.
+     */
+    public void getTransform(Matrix transform);
 
-  /**
-   * Called when the drawable needs to get its root bounds.
-   *
-   * @param bounds The root bounds of the drawable.
-   */
-  public void getRootBounds(RectF bounds);
+    /**
+     * Called when the drawable needs to get its root bounds.
+     *
+     * @param bounds The root bounds of the drawable.
+     */
+    public void getRootBounds(RectF bounds);
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/VisibilityAwareDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/VisibilityAwareDrawable.java
index f0ae57cea..167cea2aa 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/VisibilityAwareDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/VisibilityAwareDrawable.java
@@ -14,10 +14,10 @@
  */
 public interface VisibilityAwareDrawable {
 
-  /**
-   * Sets a visibility callback.
-   *
-   * @param visibilityCallback the visibility callback to be set
-   */
-  public void setVisibilityCallback(VisibilityCallback visibilityCallback);
+    /**
+     * Sets a visibility callback.
+     *
+     * @param visibilityCallback the visibility callback to be set
+     */
+    public void setVisibilityCallback(VisibilityCallback visibilityCallback);
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/VisibilityCallback.java b/drawee/src/main/java/com/facebook/drawee/drawable/VisibilityCallback.java
index 90c009823..b9550e3e2 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/VisibilityCallback.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/VisibilityCallback.java
@@ -14,15 +14,15 @@
  */
 public interface VisibilityCallback {
 
-  /**
-   * Called when the drawable's visibility changes.
-   *
-   * @param visible whether or not the drawable is visible
-   */
-  public void onVisibilityChange(boolean visible);
+    /**
+     * Called when the drawable's visibility changes.
+     *
+     * @param visible whether or not the drawable is visible
+     */
+    public void onVisibilityChange(boolean visible);
 
-  /**
-   * Called when the drawable gets drawn.
-   */
-  public void onDraw();
+    /**
+     * Called when the drawable gets drawn.
+     */
+    public void onDraw();
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchy.java b/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchy.java
index 3523402e7..cfc739f52 100644
--- a/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchy.java
+++ b/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchy.java
@@ -46,10 +46,10 @@
  * If provided, progressbar will be displayed until fully loaded.
  * Each image can be displayed with a different scale type (or no scaling at all).
  * Fading between the layers is supported.
- *
+ * <p>
  * <p>
  * Example hierarchy with placeholder, retry, failure and one actual image:
- *  <pre>
+ * <pre>
  *     o FadeDrawable (top level drawable)
  *     |
  *     +--o ScaleTypeDrawable
@@ -70,7 +70,7 @@
  *        |
  *        +--o Drawable (failure image)
  *  </pre>
- *
+ * <p>
  * <p>
  * Note:
  * - ScaleType and Matrix transformations will be added only if specified. If both are unspecified,
@@ -88,566 +88,577 @@
  */
 public class GenericDraweeHierarchy implements SettableDraweeHierarchy {
 
-  private static class RootFadeDrawable extends FadeDrawable implements VisibilityAwareDrawable {
-    @Nullable
-    private VisibilityCallback mVisibilityCallback;
+    private static class RootFadeDrawable extends FadeDrawable implements VisibilityAwareDrawable {
+        @Nullable
+        private VisibilityCallback mVisibilityCallback;
+
+        public RootFadeDrawable(Drawable[] layers) {
+            super(layers);
+        }
+
+        @Override
+        public int getIntrinsicWidth() {
+            return -1;
+        }
+
+        @Override
+        public int getIntrinsicHeight() {
+            return -1;
+        }
+
+        @Override
+        public void setVisibilityCallback(@Nullable VisibilityCallback visibilityCallback) {
+            mVisibilityCallback = visibilityCallback;
+        }
+
+        @Override
+        public boolean setVisible(boolean visible, boolean restart) {
+            if (mVisibilityCallback != null) {
+                mVisibilityCallback.onVisibilityChange(visible);
+            }
+            return super.setVisible(visible, restart);
+        }
+
+        @Override
+        public void draw(Canvas canvas) {
+            if (mVisibilityCallback != null) {
+                mVisibilityCallback.onDraw();
+            }
+            super.draw(canvas);
+        }
+    }
+
+    private Drawable mEmptyPlaceholderDrawable;
+    private final Drawable mEmptyActualImageDrawable = new ColorDrawable(Color.TRANSPARENT);
+    private final Drawable mEmptyControllerOverlayDrawable = new ColorDrawable(Color.TRANSPARENT);
+
+    private final Resources mResources;
+
+    private final Drawable mTopLevelDrawable;
+    private final FadeDrawable mFadeDrawable;
+    private final SettableDrawable mActualImageSettableDrawable;
+
+    private final int mPlaceholderImageIndex;
+    private final int mProgressBarImageIndex;
+    private final int mActualImageIndex;
+    private final int mRetryImageIndex;
+    private final int mFailureImageIndex;
+    private final int mControllerOverlayIndex;
+
+    private RoundingParams mRoundingParams;
+
+    GenericDraweeHierarchy(GenericDraweeHierarchyBuilder builder) {
+        mResources = builder.getResources();
+        mRoundingParams = builder.getRoundingParams();
+
+        int numLayers = 0;
+
+        // backgrounds
+        int numBackgrounds = (builder.getBackgrounds() != null) ? builder.getBackgrounds().size() : 0;
+        int backgroundsIndex = numLayers;
+        numLayers += numBackgrounds;
+
+        // placeholder image branch
+        Drawable placeholderImageBranch = builder.getPlaceholderImage();
+        if (placeholderImageBranch == null) {
+            placeholderImageBranch = getEmptyPlaceholderDrawable();
+        }
+        placeholderImageBranch = maybeApplyRounding(
+                mRoundingParams,
+                mResources,
+                placeholderImageBranch);
+        placeholderImageBranch = maybeWrapWithScaleType(
+                placeholderImageBranch,
+                builder.getPlaceholderImageScaleType());
+        mPlaceholderImageIndex = numLayers++;
+
+        // actual image branch
+        Drawable actualImageBranch = null;
+        mActualImageSettableDrawable = new SettableDrawable(mEmptyActualImageDrawable);
+        actualImageBranch = mActualImageSettableDrawable;
+        actualImageBranch = maybeWrapWithScaleType(
+                actualImageBranch,
+                builder.getActualImageScaleType(),
+                builder.getActualImageFocusPoint());
+        actualImageBranch = maybeWrapWithMatrix(
+                actualImageBranch,
+                builder.getActualImageMatrix());
+        actualImageBranch.setColorFilter(builder.getActualImageColorFilter());
+        mActualImageIndex = numLayers++;
+
+        // progressBar image branch
+        Drawable progressBarImageBranch = builder.getProgressBarImage();
+        if (progressBarImageBranch != null) {
+            progressBarImageBranch = maybeWrapWithScaleType(
+                    progressBarImageBranch,
+                    builder.getProgressBarImageScaleType());
+            mProgressBarImageIndex = numLayers++;
+        } else {
+            mProgressBarImageIndex = -1;
+        }
+
+        // retry image branch
+        Drawable retryImageBranch = builder.getRetryImage();
+        if (retryImageBranch != null) {
+            retryImageBranch = maybeWrapWithScaleType(
+                    retryImageBranch,
+                    builder.getRetryImageScaleType());
+            mRetryImageIndex = numLayers++;
+        } else {
+            mRetryImageIndex = -1;
+        }
+
+        // failure image branch
+        Drawable failureImageBranch = builder.getFailureImage();
+        if (failureImageBranch != null) {
+            failureImageBranch = maybeWrapWithScaleType(
+                    failureImageBranch,
+                    builder.getFailureImageScaleType());
+            mFailureImageIndex = numLayers++;
+        } else {
+            mFailureImageIndex = -1;
+        }
+
+        // overlays
+        int overlaysIndex = numLayers;
+        int numOverlays =
+                ((builder.getOverlays() != null) ? builder.getOverlays().size() : 0) +
+                        ((builder.getPressedStateOverlay() != null) ? 1 : 0);
+        numLayers += numOverlays;
+
+        // controller overlay
+        mControllerOverlayIndex = numLayers++;
+
+        // array of layers
+        Drawable[] layers = new Drawable[numLayers];
+        if (numBackgrounds > 0) {
+            int index = 0;
+            for (Drawable background : builder.getBackgrounds()) {
+                layers[backgroundsIndex + index++] =
+                        maybeApplyRounding(mRoundingParams, mResources, background);
+            }
+        }
+        if (mPlaceholderImageIndex >= 0) {
+            layers[mPlaceholderImageIndex] = placeholderImageBranch;
+        }
+        if (mActualImageIndex >= 0) {
+            layers[mActualImageIndex] = actualImageBranch;
+        }
+        if (mProgressBarImageIndex >= 0) {
+            layers[mProgressBarImageIndex] = progressBarImageBranch;
+        }
+        if (mRetryImageIndex >= 0) {
+            layers[mRetryImageIndex] = retryImageBranch;
+        }
+        if (mFailureImageIndex >= 0) {
+            layers[mFailureImageIndex] = failureImageBranch;
+        }
+        if (numOverlays > 0) {
+            int index = 0;
+            if (builder.getOverlays() != null) {
+                for (Drawable overlay : builder.getOverlays()) {
+                    layers[overlaysIndex + index++] = overlay;
+                }
+            }
+            if (builder.getPressedStateOverlay() != null) {
+                layers[overlaysIndex + index++] = builder.getPressedStateOverlay();
+            }
+        }
+        if (mControllerOverlayIndex >= 0) {
+            layers[mControllerOverlayIndex] = mEmptyControllerOverlayDrawable;
+        }
+
+        Drawable root;
+
+        // fade drawable composed of branches
+        mFadeDrawable = new RootFadeDrawable(layers);
+        mFadeDrawable.setTransitionDuration(builder.getFadeDuration());
+        root = mFadeDrawable;
+
+        // rounded corners drawable (optional)
+        root = maybeWrapWithRoundedCorners(mRoundingParams, root);
+
+        // top-level drawable
+        mTopLevelDrawable = root;
+        mTopLevelDrawable.mutate();
+
+        resetFade();
+    }
+
+    private static Drawable maybeWrapWithScaleType(
+            Drawable drawable,
+            @Nullable ScaleType scaleType) {
+        return maybeWrapWithScaleType(drawable, scaleType, null);
+    }
+
+    private static Drawable maybeWrapWithScaleType(
+            Drawable drawable,
+            @Nullable ScaleType scaleType,
+            @Nullable PointF focusPoint) {
+        Preconditions.checkNotNull(drawable);
+        if (scaleType == null) {
+            return drawable;
+        }
+        ScaleTypeDrawable scaleTypeDrawable = new ScaleTypeDrawable(drawable, scaleType);
+        if (focusPoint != null) {
+            scaleTypeDrawable.setFocusPoint(focusPoint);
+        }
+        return scaleTypeDrawable;
+    }
+
+    private static Drawable maybeWrapWithMatrix(
+            Drawable drawable,
+            @Nullable Matrix matrix) {
+        Preconditions.checkNotNull(drawable);
+        if (matrix == null) {
+            return drawable;
+        }
+        return new MatrixDrawable(drawable, matrix);
+    }
+
+    private static Drawable maybeWrapWithRoundedCorners(
+            @Nullable RoundingParams roundingParams,
+            Drawable drawable) {
+        if (roundingParams != null &&
+                roundingParams.getRoundingMethod() == RoundingParams.RoundingMethod.OVERLAY_COLOR) {
+            RoundedCornersDrawable roundedCornersDrawable = new RoundedCornersDrawable(drawable);
+            roundedCornersDrawable.setCircle(roundingParams.getRoundAsCircle());
+            roundedCornersDrawable.setRadii(roundingParams.getCornersRadii());
+            roundedCornersDrawable.setOverlayColor(roundingParams.getOverlayColor());
+            roundedCornersDrawable.setBorder(
+                    roundingParams.getBorderColor(),
+                    roundingParams.getBorderWidth());
+            return roundedCornersDrawable;
+        } else {
+            return drawable;
+        }
+    }
 
-    public RootFadeDrawable(Drawable[] layers) {
-      super(layers);
+    private static Drawable maybeApplyRounding(
+            @Nullable RoundingParams roundingParams,
+            Resources resources,
+            Drawable drawable) {
+        if (roundingParams != null &&
+                roundingParams.getRoundingMethod() == RoundingParams.RoundingMethod.BITMAP_ONLY) {
+            if (drawable instanceof BitmapDrawable) {
+                RoundedBitmapDrawable roundedBitmapDrawable =
+                        RoundedBitmapDrawable.fromBitmapDrawable(resources, (BitmapDrawable) drawable);
+                roundedBitmapDrawable.setCircle(roundingParams.getRoundAsCircle());
+                roundedBitmapDrawable.setCornerRadii(roundingParams.getCornersRadii());
+                roundedBitmapDrawable.setBorder(
+                        roundingParams.getBorderColor(),
+                        roundingParams.getBorderWidth());
+                return roundedBitmapDrawable;
+            }
+            if (drawable instanceof ColorDrawable &&
+                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+                RoundedColorDrawable roundedColorDrawable =
+                        RoundedColorDrawable.fromColorDrawable((ColorDrawable) drawable);
+                roundedColorDrawable.setCircle(roundingParams.getRoundAsCircle());
+                roundedColorDrawable.setRadii(roundingParams.getCornersRadii());
+                roundedColorDrawable.setBorder(
+                        roundingParams.getBorderColor(),
+                        roundingParams.getBorderWidth());
+                return roundedColorDrawable;
+            }
+        }
+        return drawable;
+    }
+
+    private void resetActualImages() {
+        if (mActualImageSettableDrawable != null) {
+            mActualImageSettableDrawable.setDrawable(mEmptyActualImageDrawable);
+        }
+    }
+
+    private void resetFade() {
+        if (mFadeDrawable != null) {
+            mFadeDrawable.beginBatchMode();
+            // turn on all layers (backgrounds, branches, overlays)
+            mFadeDrawable.fadeInAllLayers();
+            // turn off branches (leaving backgrounds and overlays on)
+            fadeOutBranches();
+            // turn on placeholder
+            fadeInLayer(mPlaceholderImageIndex);
+            mFadeDrawable.finishTransitionImmediately();
+            mFadeDrawable.endBatchMode();
+        }
+    }
+
+    private void fadeOutBranches() {
+        fadeOutLayer(mPlaceholderImageIndex);
+        fadeOutLayer(mActualImageIndex);
+        fadeOutLayer(mProgressBarImageIndex);
+        fadeOutLayer(mRetryImageIndex);
+        fadeOutLayer(mFailureImageIndex);
+    }
+
+    private void fadeInLayer(int index) {
+        if (index >= 0) {
+            mFadeDrawable.fadeInLayer(index);
+        }
+    }
+
+    private void fadeOutLayer(int index) {
+        if (index >= 0) {
+            mFadeDrawable.fadeOutLayer(index);
+        }
+    }
+
+    private void setProgress(float progress) {
+        if (mProgressBarImageIndex < 0) {
+            return;
+        }
+        Drawable progressBarDrawable = getLayerChildDrawable(mProgressBarImageIndex);
+        // display progressbar when not fully loaded, hide otherwise
+        if (progress >= 0.999f) {
+            if (progressBarDrawable instanceof Animatable) {
+                ((Animatable) progressBarDrawable).stop();
+            }
+            fadeOutLayer(mProgressBarImageIndex);
+        } else {
+            if (progressBarDrawable instanceof Animatable) {
+                ((Animatable) progressBarDrawable).start();
+            }
+            fadeInLayer(mProgressBarImageIndex);
+        }
+        // set drawable level, scaled to [0, 10000] per drawable specification
+        progressBarDrawable.setLevel(Math.round(progress * 10000));
+    }
+
+    // SettableDraweeHierarchy interface
+
+    @Override
+    public Drawable getTopLevelDrawable() {
+        return mTopLevelDrawable;
     }
 
     @Override
-    public int getIntrinsicWidth() {
-      return -1;
+    public void reset() {
+        resetActualImages();
+        resetFade();
     }
 
     @Override
-    public int getIntrinsicHeight() {
-      return -1;
+    public void setImage(Drawable drawable, float progress, boolean immediate) {
+        drawable = maybeApplyRounding(mRoundingParams, mResources, drawable);
+        drawable.mutate();
+        mActualImageSettableDrawable.setDrawable(drawable);
+        mFadeDrawable.beginBatchMode();
+        fadeOutBranches();
+        fadeInLayer(mActualImageIndex);
+        setProgress(progress);
+        if (immediate) {
+            mFadeDrawable.finishTransitionImmediately();
+        }
+        mFadeDrawable.endBatchMode();
     }
 
     @Override
-    public void setVisibilityCallback(@Nullable VisibilityCallback visibilityCallback) {
-      mVisibilityCallback = visibilityCallback;
+    public void setProgress(float progress, boolean immediate) {
+        mFadeDrawable.beginBatchMode();
+        setProgress(progress);
+        if (immediate) {
+            mFadeDrawable.finishTransitionImmediately();
+        }
+        mFadeDrawable.endBatchMode();
+    }
+
+    @Override
+    public void setFailure(Throwable throwable) {
+        mFadeDrawable.beginBatchMode();
+        fadeOutBranches();
+        if (mFailureImageIndex >= 0) {
+            fadeInLayer(mFailureImageIndex);
+        } else {
+            fadeInLayer(mPlaceholderImageIndex);
+        }
+        mFadeDrawable.endBatchMode();
     }
 
     @Override
-    public boolean setVisible(boolean visible, boolean restart) {
-      if (mVisibilityCallback != null) {
-        mVisibilityCallback.onVisibilityChange(visible);
-      }
-      return super.setVisible(visible, restart);
+    public void setRetry(Throwable throwable) {
+        mFadeDrawable.beginBatchMode();
+        fadeOutBranches();
+        if (mRetryImageIndex >= 0) {
+            fadeInLayer(mRetryImageIndex);
+        } else {
+            fadeInLayer(mPlaceholderImageIndex);
+        }
+        mFadeDrawable.endBatchMode();
     }
 
     @Override
-    public void draw(Canvas canvas) {
-      if (mVisibilityCallback != null) {
-        mVisibilityCallback.onDraw();
-      }
-      super.draw(canvas);
-    }
-  }
-
-  private Drawable mEmptyPlaceholderDrawable;
-  private final Drawable mEmptyActualImageDrawable = new ColorDrawable(Color.TRANSPARENT);
-  private final Drawable mEmptyControllerOverlayDrawable = new ColorDrawable(Color.TRANSPARENT);
-
-  private final Resources mResources;
-
-  private final Drawable mTopLevelDrawable;
-  private final FadeDrawable mFadeDrawable;
-  private final SettableDrawable mActualImageSettableDrawable;
-
-  private final int mPlaceholderImageIndex;
-  private final int mProgressBarImageIndex;
-  private final int mActualImageIndex;
-  private final int mRetryImageIndex;
-  private final int mFailureImageIndex;
-  private final int mControllerOverlayIndex;
-
-  private RoundingParams mRoundingParams;
-
-  GenericDraweeHierarchy(GenericDraweeHierarchyBuilder builder) {
-    mResources = builder.getResources();
-    mRoundingParams = builder.getRoundingParams();
-
-    int numLayers = 0;
-
-    // backgrounds
-    int numBackgrounds = (builder.getBackgrounds() != null) ? builder.getBackgrounds().size() : 0;
-    int backgroundsIndex = numLayers;
-    numLayers += numBackgrounds;
-
-    // placeholder image branch
-    Drawable placeholderImageBranch = builder.getPlaceholderImage();
-    if (placeholderImageBranch == null) {
-      placeholderImageBranch = getEmptyPlaceholderDrawable();
-    }
-    placeholderImageBranch = maybeApplyRounding(
-        mRoundingParams,
-        mResources,
-        placeholderImageBranch);
-    placeholderImageBranch = maybeWrapWithScaleType(
-        placeholderImageBranch,
-        builder.getPlaceholderImageScaleType());
-    mPlaceholderImageIndex = numLayers++;
-
-    // actual image branch
-    Drawable actualImageBranch = null;
-    mActualImageSettableDrawable = new SettableDrawable(mEmptyActualImageDrawable);
-    actualImageBranch = mActualImageSettableDrawable;
-    actualImageBranch = maybeWrapWithScaleType(
-        actualImageBranch,
-        builder.getActualImageScaleType(),
-        builder.getActualImageFocusPoint());
-    actualImageBranch = maybeWrapWithMatrix(
-        actualImageBranch,
-        builder.getActualImageMatrix());
-    actualImageBranch.setColorFilter(builder.getActualImageColorFilter());
-    mActualImageIndex = numLayers++;
-
-    // progressBar image branch
-    Drawable progressBarImageBranch = builder.getProgressBarImage();
-    if (progressBarImageBranch != null) {
-      progressBarImageBranch = maybeWrapWithScaleType(
-          progressBarImageBranch,
-          builder.getProgressBarImageScaleType());
-      mProgressBarImageIndex = numLayers++;
-    } else {
-      mProgressBarImageIndex = -1;
-    }
-
-    // retry image branch
-    Drawable retryImageBranch = builder.getRetryImage();
-    if (retryImageBranch != null) {
-      retryImageBranch = maybeWrapWithScaleType(
-          retryImageBranch,
-          builder.getRetryImageScaleType());
-      mRetryImageIndex = numLayers++;
-    } else {
-      mRetryImageIndex = -1;
-    }
-
-    // failure image branch
-    Drawable failureImageBranch = builder.getFailureImage();
-    if (failureImageBranch != null) {
-      failureImageBranch = maybeWrapWithScaleType(
-          failureImageBranch,
-          builder.getFailureImageScaleType());
-      mFailureImageIndex = numLayers++;
-    } else {
-      mFailureImageIndex = -1;
-    }
-
-    // overlays
-    int overlaysIndex = numLayers;
-    int numOverlays =
-        ((builder.getOverlays() != null) ? builder.getOverlays().size() : 0) +
-            ((builder.getPressedStateOverlay() != null) ? 1 : 0);
-    numLayers += numOverlays;
-
-    // controller overlay
-    mControllerOverlayIndex = numLayers++;
-
-    // array of layers
-    Drawable[] layers = new Drawable[numLayers];
-    if (numBackgrounds > 0) {
-      int index = 0;
-      for (Drawable background : builder.getBackgrounds()) {
-        layers[backgroundsIndex + index++] =
-            maybeApplyRounding(mRoundingParams, mResources, background);
-      }
-    }
-    if (mPlaceholderImageIndex >= 0) {
-      layers[mPlaceholderImageIndex] = placeholderImageBranch;
-    }
-    if (mActualImageIndex >= 0) {
-      layers[mActualImageIndex] = actualImageBranch;
-    }
-    if (mProgressBarImageIndex >= 0) {
-      layers[mProgressBarImageIndex] = progressBarImageBranch;
-    }
-    if (mRetryImageIndex >= 0) {
-      layers[mRetryImageIndex] = retryImageBranch;
-    }
-    if (mFailureImageIndex >= 0) {
-      layers[mFailureImageIndex] = failureImageBranch;
-    }
-    if (numOverlays > 0) {
-      int index = 0;
-      if (builder.getOverlays() != null) {
-        for (Drawable overlay : builder.getOverlays()) {
-          layers[overlaysIndex + index++] = overlay;
-        }
-      }
-      if (builder.getPressedStateOverlay() != null) {
-        layers[overlaysIndex + index++] = builder.getPressedStateOverlay();
-      }
-    }
-    if (mControllerOverlayIndex >= 0) {
-      layers[mControllerOverlayIndex] = mEmptyControllerOverlayDrawable;
-    }
-
-    Drawable root;
-
-    // fade drawable composed of branches
-    mFadeDrawable = new RootFadeDrawable(layers);
-    mFadeDrawable.setTransitionDuration(builder.getFadeDuration());
-    root = mFadeDrawable;
-
-    // rounded corners drawable (optional)
-    root = maybeWrapWithRoundedCorners(mRoundingParams, root);
-
-    // top-level drawable
-    mTopLevelDrawable = root;
-    mTopLevelDrawable.mutate();
-
-    resetFade();
-  }
-
-  private static Drawable maybeWrapWithScaleType(
-      Drawable drawable,
-      @Nullable ScaleType scaleType) {
-    return maybeWrapWithScaleType(drawable, scaleType, null);
-  }
-
-  private static Drawable maybeWrapWithScaleType(
-      Drawable drawable,
-      @Nullable ScaleType scaleType,
-      @Nullable PointF focusPoint) {
-    Preconditions.checkNotNull(drawable);
-    if (scaleType == null) {
-      return drawable;
-    }
-    ScaleTypeDrawable scaleTypeDrawable = new ScaleTypeDrawable(drawable, scaleType);
-    if (focusPoint != null) {
-      scaleTypeDrawable.setFocusPoint(focusPoint);
-    }
-    return scaleTypeDrawable;
-  }
-
-  private static Drawable maybeWrapWithMatrix(
-      Drawable drawable,
-      @Nullable Matrix matrix) {
-    Preconditions.checkNotNull(drawable);
-    if (matrix == null) {
-      return drawable;
-    }
-    return new MatrixDrawable(drawable, matrix);
-  }
-
-  private static Drawable maybeWrapWithRoundedCorners(
-      @Nullable RoundingParams roundingParams,
-      Drawable drawable) {
-    if (roundingParams != null &&
-        roundingParams.getRoundingMethod() == RoundingParams.RoundingMethod.OVERLAY_COLOR) {
-      RoundedCornersDrawable roundedCornersDrawable = new RoundedCornersDrawable(drawable);
-      roundedCornersDrawable.setCircle(roundingParams.getRoundAsCircle());
-      roundedCornersDrawable.setRadii(roundingParams.getCornersRadii());
-      roundedCornersDrawable.setOverlayColor(roundingParams.getOverlayColor());
-      roundedCornersDrawable.setBorder(
-          roundingParams.getBorderColor(),
-          roundingParams.getBorderWidth());
-      return roundedCornersDrawable;
-    } else {
-      return drawable;
-    }
-  }
-
-  private static Drawable maybeApplyRounding(
-      @Nullable RoundingParams roundingParams,
-      Resources resources,
-      Drawable drawable) {
-    if (roundingParams != null &&
-        roundingParams.getRoundingMethod() == RoundingParams.RoundingMethod.BITMAP_ONLY) {
-      if (drawable instanceof BitmapDrawable) {
-        RoundedBitmapDrawable roundedBitmapDrawable =
-            RoundedBitmapDrawable.fromBitmapDrawable(resources, (BitmapDrawable) drawable);
-        roundedBitmapDrawable.setCircle(roundingParams.getRoundAsCircle());
-        roundedBitmapDrawable.setCornerRadii(roundingParams.getCornersRadii());
-        roundedBitmapDrawable.setBorder(
-            roundingParams.getBorderColor(),
-            roundingParams.getBorderWidth());
-        return roundedBitmapDrawable;
-      }
-      if (drawable instanceof ColorDrawable &&
-          Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-        RoundedColorDrawable roundedColorDrawable =
-            RoundedColorDrawable.fromColorDrawable((ColorDrawable) drawable);
-        roundedColorDrawable.setCircle(roundingParams.getRoundAsCircle());
-        roundedColorDrawable.setRadii(roundingParams.getCornersRadii());
-        roundedColorDrawable.setBorder(
-            roundingParams.getBorderColor(),
-            roundingParams.getBorderWidth());
-        return roundedColorDrawable;
-      }
-    }
-    return drawable;
-  }
-
-  private void resetActualImages() {
-    if (mActualImageSettableDrawable != null) {
-      mActualImageSettableDrawable.setDrawable(mEmptyActualImageDrawable);
-    }
-  }
-
-  private void resetFade() {
-    if (mFadeDrawable != null) {
-      mFadeDrawable.beginBatchMode();
-      // turn on all layers (backgrounds, branches, overlays)
-      mFadeDrawable.fadeInAllLayers();
-      // turn off branches (leaving backgrounds and overlays on)
-      fadeOutBranches();
-      // turn on placeholder
-      fadeInLayer(mPlaceholderImageIndex);
-      mFadeDrawable.finishTransitionImmediately();
-      mFadeDrawable.endBatchMode();
-    }
-  }
-
-  private void fadeOutBranches() {
-    fadeOutLayer(mPlaceholderImageIndex);
-    fadeOutLayer(mActualImageIndex);
-    fadeOutLayer(mProgressBarImageIndex);
-    fadeOutLayer(mRetryImageIndex);
-    fadeOutLayer(mFailureImageIndex);
-  }
-
-  private void fadeInLayer(int index) {
-    if (index >= 0) {
-      mFadeDrawable.fadeInLayer(index);
-    }
-  }
-
-  private void fadeOutLayer(int index) {
-    if (index >= 0) {
-      mFadeDrawable.fadeOutLayer(index);
-    }
-  }
-
-  private void setProgress(float progress) {
-    if (mProgressBarImageIndex < 0) {
-      return;
-    }
-    Drawable progressBarDrawable = getLayerChildDrawable(mProgressBarImageIndex);
-    // display progressbar when not fully loaded, hide otherwise
-    if (progress >= 0.999f) {
-      if (progressBarDrawable instanceof Animatable) {
-        ((Animatable) progressBarDrawable).stop();
-      }
-      fadeOutLayer(mProgressBarImageIndex);
-    } else {
-      if (progressBarDrawable instanceof Animatable) {
-        ((Animatable) progressBarDrawable).start();
-      }
-      fadeInLayer(mProgressBarImageIndex);
-    }
-    // set drawable level, scaled to [0, 10000] per drawable specification
-    progressBarDrawable.setLevel(Math.round(progress * 10000));
-  }
-
-  // SettableDraweeHierarchy interface
-
-  @Override
-  public Drawable getTopLevelDrawable() {
-    return mTopLevelDrawable;
-  }
-
-  @Override
-  public void reset() {
-    resetActualImages();
-    resetFade();
-  }
-
-  @Override
-  public void setImage(Drawable drawable, float progress, boolean immediate) {
-    drawable = maybeApplyRounding(mRoundingParams, mResources, drawable);
-    drawable.mutate();
-    mActualImageSettableDrawable.setDrawable(drawable);
-    mFadeDrawable.beginBatchMode();
-    fadeOutBranches();
-    fadeInLayer(mActualImageIndex);
-    setProgress(progress);
-    if (immediate) {
-      mFadeDrawable.finishTransitionImmediately();
-    }
-    mFadeDrawable.endBatchMode();
-  }
-
-  @Override
-  public void setProgress(float progress, boolean immediate) {
-    mFadeDrawable.beginBatchMode();
-    setProgress(progress);
-    if (immediate) {
-      mFadeDrawable.finishTransitionImmediately();
-    }
-    mFadeDrawable.endBatchMode();
-  }
-
-  @Override
-  public void setFailure(Throwable throwable) {
-    mFadeDrawable.beginBatchMode();
-    fadeOutBranches();
-    if (mFailureImageIndex >= 0) {
-      fadeInLayer(mFailureImageIndex);
-    } else {
-      fadeInLayer(mPlaceholderImageIndex);
-    }
-    mFadeDrawable.endBatchMode();
-  }
-
-  @Override
-  public void setRetry(Throwable throwable) {
-    mFadeDrawable.beginBatchMode();
-    fadeOutBranches();
-    if (mRetryImageIndex >= 0) {
-      fadeInLayer(mRetryImageIndex);
-    } else {
-      fadeInLayer(mPlaceholderImageIndex);
-    }
-    mFadeDrawable.endBatchMode();
-  }
-
-  @Override
-  public void setControllerOverlay(@Nullable Drawable drawable) {
-    if (drawable == null) {
-      drawable = mEmptyControllerOverlayDrawable;
-    }
-    mFadeDrawable.setDrawable(mControllerOverlayIndex, drawable);
-  }
-
-  // Helper methods for accessing layers
-
-  /**
-   * Gets the drawable at the specified index while skipping MatrixDrawable and ScaleTypeDrawable.
-   *
-   * <p> If <code>returnParent</code> is set, parent drawable will be returned instead. If
-   * MatrixDrawable or ScaleTypeDrawable is found at that index, it will be returned as a parent.
-   * Otherwise, the FadeDrawable will be returned as a parent.
-   */
-  private Drawable getLayerDrawable(int index, boolean returnParent) {
-    Drawable parent = mFadeDrawable;
-    Drawable child = mFadeDrawable.getDrawable(index);
-    if (child instanceof MatrixDrawable) {
-      parent = child;
-      child = parent.getCurrent();
-    }
-    if (child instanceof ScaleTypeDrawable) {
-      parent = child;
-      child = parent.getCurrent();
-    }
-    return returnParent ? parent : child;
-  }
-
-  /**
-   * Returns the ScaleTypeDrawable at the specified index, or null if not found.
-   */
-  private @Nullable ScaleTypeDrawable findLayerScaleTypeDrawable(int index) {
-    Drawable drawable = mFadeDrawable.getDrawable(index);
-    if (drawable instanceof MatrixDrawable) {
-      drawable = drawable.getCurrent();
-    }
-    if (drawable instanceof ScaleTypeDrawable) {
-      return (ScaleTypeDrawable) drawable;
-    } else {
-      return null;
-    }
-  }
-
-  /**
-   * Sets a child drawable at the specified index.
-   *
-   * <p> Note: This uses {@link #getLayerDrawable} to find the parent drawable. Given drawable is
-   * then set as its child.
-   */
-  private void setLayerChildDrawable(int index, Drawable drawable) {
-    Drawable parent = getLayerDrawable(index, true /* returnParent */);
-    if (parent == mFadeDrawable) {
-      mFadeDrawable.setDrawable(index, drawable);
-    } else {
-      ((ForwardingDrawable) parent).setCurrent(drawable);
-    }
-  }
-
-  /**
-   * Gets the child drawable at the specified index.
-   */
-  private Drawable getLayerChildDrawable(int index) {
-    return getLayerDrawable(index, false /* returnParent */);
-  }
-
-  private Drawable getEmptyPlaceholderDrawable() {
-    if (mEmptyPlaceholderDrawable == null) {
-      mEmptyPlaceholderDrawable = new ColorDrawable(Color.TRANSPARENT);
-    }
-    return mEmptyPlaceholderDrawable;
-  }
-
-  // Mutability
-
-  /** Sets the actual image focus point. */
-  public void setActualImageFocusPoint(PointF focusPoint) {
-    Preconditions.checkNotNull(focusPoint);
-    ScaleTypeDrawable scaleTypeDrawable = findLayerScaleTypeDrawable(mActualImageIndex);
-    if (scaleTypeDrawable == null) {
-      throw new UnsupportedOperationException("ScaleTypeDrawable not found!");
-    }
-    scaleTypeDrawable.setFocusPoint(focusPoint);
-  }
-
-  /** Sets the actual image scale type. */
-  public void setActualImageScaleType(ScaleType scaleType) {
-    Preconditions.checkNotNull(scaleType);
-    ScaleTypeDrawable scaleTypeDrawable = findLayerScaleTypeDrawable(mActualImageIndex);
-    if (scaleTypeDrawable == null) {
-      throw new UnsupportedOperationException("ScaleTypeDrawable not found!");
-    }
-    scaleTypeDrawable.setScaleType(scaleType);
-  }
-
-  /** Sets the color filter to be applied on the actual image. */
-  public void setActualImageColorFilter(ColorFilter colorfilter) {
-    mFadeDrawable.getDrawable(mActualImageIndex).setColorFilter(colorfilter);
-  }
-
-  /**
-   * Gets the post-scaling bounds of the actual image.
-   *
-   * <p> Note: the returned bounds are not cropped.
-   * @param outBounds rect to fill with bounds
-   */
-  public void getActualImageBounds(RectF outBounds) {
-    mActualImageSettableDrawable.getTransformedBounds(outBounds);
-  }
-
-  /**
-   * Sets a new placeholder drawable.
-   *
-   * <p>The placeholder scale type will not be changed.
-   */
-  public void setPlaceholderImage(Drawable drawable) {
-    if (drawable == null) {
-      drawable = getEmptyPlaceholderDrawable();
-    }
-    drawable = maybeApplyRounding(mRoundingParams, mResources, drawable);
-    setLayerChildDrawable(mPlaceholderImageIndex, drawable);
-  }
-
-  /**
-   * Sets a new placeholder drawable using the supplied resource ID.
-   *
-   * <p>The placeholder scale type will not be changed.
-   * @param resourceId an identifier of an Android drawable or color resource.
-   */
-  public void setPlaceholderImage(int resourceId) {
-    setPlaceholderImage(mResources.getDrawable(resourceId));
-  }
-
-  /**
-   * Sets the rounding params.
-   */
-  public void setRoundingParams(RoundingParams roundingParams) {
-    Preconditions.checkState(
-        mRoundingParams != null && roundingParams != null &&
-            roundingParams.getRoundingMethod() == mRoundingParams.getRoundingMethod(),
-        "Rounding method cannot be changed and it has to be set during construction time.");
-    mRoundingParams = roundingParams;
-    if (roundingParams.getRoundingMethod() == RoundingParams.RoundingMethod.OVERLAY_COLOR) {
-      RoundedCornersDrawable roundedCornersDrawable = (RoundedCornersDrawable) mTopLevelDrawable;
-      roundedCornersDrawable.setCircle(roundingParams.getRoundAsCircle());
-      roundedCornersDrawable.setRadii(roundingParams.getCornersRadii());
-      roundedCornersDrawable.setOverlayColor(roundingParams.getOverlayColor());
-      roundedCornersDrawable.setBorder(
-          roundingParams.getBorderColor(),
-          roundingParams.getBorderWidth());
-    }
-  }
-
-  /**
-   * Gets the rounding params.
-   * @return rounding params
-   */
-  public RoundingParams getRoundingParams() {
-    return mRoundingParams;
-  }
+    public void setControllerOverlay(@Nullable Drawable drawable) {
+        if (drawable == null) {
+            drawable = mEmptyControllerOverlayDrawable;
+        }
+        mFadeDrawable.setDrawable(mControllerOverlayIndex, drawable);
+    }
+
+    // Helper methods for accessing layers
+
+    /**
+     * Gets the drawable at the specified index while skipping MatrixDrawable and ScaleTypeDrawable.
+     * <p>
+     * <p> If <code>returnParent</code> is set, parent drawable will be returned instead. If
+     * MatrixDrawable or ScaleTypeDrawable is found at that index, it will be returned as a parent.
+     * Otherwise, the FadeDrawable will be returned as a parent.
+     */
+    private Drawable getLayerDrawable(int index, boolean returnParent) {
+        Drawable parent = mFadeDrawable;
+        Drawable child = mFadeDrawable.getDrawable(index);
+        if (child instanceof MatrixDrawable) {
+            parent = child;
+            child = parent.getCurrent();
+        }
+        if (child instanceof ScaleTypeDrawable) {
+            parent = child;
+            child = parent.getCurrent();
+        }
+        return returnParent ? parent : child;
+    }
+
+    /**
+     * Returns the ScaleTypeDrawable at the specified index, or null if not found.
+     */
+    private
+    @Nullable
+    ScaleTypeDrawable findLayerScaleTypeDrawable(int index) {
+        Drawable drawable = mFadeDrawable.getDrawable(index);
+        if (drawable instanceof MatrixDrawable) {
+            drawable = drawable.getCurrent();
+        }
+        if (drawable instanceof ScaleTypeDrawable) {
+            return (ScaleTypeDrawable) drawable;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Sets a child drawable at the specified index.
+     * <p>
+     * <p> Note: This uses {@link #getLayerDrawable} to find the parent drawable. Given drawable is
+     * then set as its child.
+     */
+    private void setLayerChildDrawable(int index, Drawable drawable) {
+        Drawable parent = getLayerDrawable(index, true /* returnParent */);
+        if (parent == mFadeDrawable) {
+            mFadeDrawable.setDrawable(index, drawable);
+        } else {
+            ((ForwardingDrawable) parent).setCurrent(drawable);
+        }
+    }
+
+    /**
+     * Gets the child drawable at the specified index.
+     */
+    private Drawable getLayerChildDrawable(int index) {
+        return getLayerDrawable(index, false /* returnParent */);
+    }
+
+    private Drawable getEmptyPlaceholderDrawable() {
+        if (mEmptyPlaceholderDrawable == null) {
+            mEmptyPlaceholderDrawable = new ColorDrawable(Color.TRANSPARENT);
+        }
+        return mEmptyPlaceholderDrawable;
+    }
+
+    // Mutability
+
+    /**
+     * Sets the actual image focus point.
+     */
+    public void setActualImageFocusPoint(PointF focusPoint) {
+        Preconditions.checkNotNull(focusPoint);
+        ScaleTypeDrawable scaleTypeDrawable = findLayerScaleTypeDrawable(mActualImageIndex);
+        if (scaleTypeDrawable == null) {
+            throw new UnsupportedOperationException("ScaleTypeDrawable not found!");
+        }
+        scaleTypeDrawable.setFocusPoint(focusPoint);
+    }
+
+    /**
+     * Sets the actual image scale type.
+     */
+    public void setActualImageScaleType(ScaleType scaleType) {
+        Preconditions.checkNotNull(scaleType);
+        ScaleTypeDrawable scaleTypeDrawable = findLayerScaleTypeDrawable(mActualImageIndex);
+        if (scaleTypeDrawable == null) {
+            throw new UnsupportedOperationException("ScaleTypeDrawable not found!");
+        }
+        scaleTypeDrawable.setScaleType(scaleType);
+    }
+
+    /**
+     * Sets the color filter to be applied on the actual image.
+     */
+    public void setActualImageColorFilter(ColorFilter colorfilter) {
+        mFadeDrawable.getDrawable(mActualImageIndex).setColorFilter(colorfilter);
+    }
+
+    /**
+     * Gets the post-scaling bounds of the actual image.
+     * <p>
+     * <p> Note: the returned bounds are not cropped.
+     *
+     * @param outBounds rect to fill with bounds
+     */
+    public void getActualImageBounds(RectF outBounds) {
+        mActualImageSettableDrawable.getTransformedBounds(outBounds);
+    }
+
+    /**
+     * Sets a new placeholder drawable.
+     * <p>
+     * <p>The placeholder scale type will not be changed.
+     */
+    public void setPlaceholderImage(Drawable drawable) {
+        if (drawable == null) {
+            drawable = getEmptyPlaceholderDrawable();
+        }
+        drawable = maybeApplyRounding(mRoundingParams, mResources, drawable);
+        setLayerChildDrawable(mPlaceholderImageIndex, drawable);
+    }
+
+    /**
+     * Sets a new placeholder drawable using the supplied resource ID.
+     * <p>
+     * <p>The placeholder scale type will not be changed.
+     *
+     * @param resourceId an identifier of an Android drawable or color resource.
+     */
+    public void setPlaceholderImage(int resourceId) {
+        setPlaceholderImage(mResources.getDrawable(resourceId));
+    }
+
+    /**
+     * Sets the rounding params.
+     */
+    public void setRoundingParams(RoundingParams roundingParams) {
+        Preconditions.checkState(
+                mRoundingParams != null && roundingParams != null &&
+                        roundingParams.getRoundingMethod() == mRoundingParams.getRoundingMethod(),
+                "Rounding method cannot be changed and it has to be set during construction time.");
+        mRoundingParams = roundingParams;
+        if (roundingParams.getRoundingMethod() == RoundingParams.RoundingMethod.OVERLAY_COLOR) {
+            RoundedCornersDrawable roundedCornersDrawable = (RoundedCornersDrawable) mTopLevelDrawable;
+            roundedCornersDrawable.setCircle(roundingParams.getRoundAsCircle());
+            roundedCornersDrawable.setRadii(roundingParams.getCornersRadii());
+            roundedCornersDrawable.setOverlayColor(roundingParams.getOverlayColor());
+            roundedCornersDrawable.setBorder(
+                    roundingParams.getBorderColor(),
+                    roundingParams.getBorderWidth());
+        }
+    }
+
+    /**
+     * Gets the rounding params.
+     *
+     * @return rounding params
+     */
+    public RoundingParams getRoundingParams() {
+        return mRoundingParams;
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilder.java b/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilder.java
index fc884d68d..6a191ed88 100644
--- a/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilder.java
+++ b/drawee/src/main/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilder.java
@@ -27,407 +27,430 @@
 
 /**
  * Class to construct a {@link GenericDraweeHierarchy}.
- *
+ * <p>
  * <p/> This class does not do deep copies of most of the input parameters. There should be one
  * instance of the hierarchy per DraweeView, so that each hierarchy has a unique set of drawables.
  */
 public class GenericDraweeHierarchyBuilder {
 
-  public static final int DEFAULT_FADE_DURATION = 300;
-  public static final ScaleType DEFAULT_SCALE_TYPE = ScaleType.CENTER_INSIDE;
-  public static final ScaleType DEFAULT_ACTUAL_IMAGE_SCALE_TYPE = ScaleType.CENTER_CROP;
+    public static final int DEFAULT_FADE_DURATION = 300;
+    public static final ScaleType DEFAULT_SCALE_TYPE = ScaleType.CENTER_INSIDE;
+    public static final ScaleType DEFAULT_ACTUAL_IMAGE_SCALE_TYPE = ScaleType.CENTER_CROP;
+
+    private Resources mResources;
+
+    private int mFadeDuration;
+
+    private Drawable mPlaceholderImage;
+    private
+    @Nullable
+    ScaleType mPlaceholderImageScaleType;
+
+    private Drawable mRetryImage;
+    private ScaleType mRetryImageScaleType;
+
+    private Drawable mFailureImage;
+    private ScaleType mFailureImageScaleType;
+
+    private Drawable mProgressBarImage;
+    private ScaleType mProgressBarImageScaleType;
+
+    private ScaleType mActualImageScaleType;
+    private Matrix mActualImageMatrix;
+    private PointF mActualImageFocusPoint;
+    private ColorFilter mActualImageColorFilter;
+
+    private List<Drawable> mBackgrounds;
+    private List<Drawable> mOverlays;
+    private Drawable mPressedStateOverlay;
+
+    private RoundingParams mRoundingParams;
+
+    public GenericDraweeHierarchyBuilder(Resources resources) {
+        mResources = resources;
+        init();
+    }
+
+    public static GenericDraweeHierarchyBuilder newInstance(Resources resources) {
+        return new GenericDraweeHierarchyBuilder(resources);
+    }
+
+    /**
+     * Initializes this builder to its defaults.
+     */
+    private void init() {
+        mFadeDuration = DEFAULT_FADE_DURATION;
+
+        mPlaceholderImage = null;
+        mPlaceholderImageScaleType = null;
+
+        mRetryImage = null;
+        mRetryImageScaleType = null;
+
+        mFailureImage = null;
+        mFailureImageScaleType = null;
+
+        mProgressBarImage = null;
+        mProgressBarImageScaleType = null;
+
+        mActualImageScaleType = DEFAULT_ACTUAL_IMAGE_SCALE_TYPE;
+        mActualImageMatrix = null;
+        mActualImageFocusPoint = null;
+
+        mBackgrounds = null;
+        mOverlays = null;
+        mPressedStateOverlay = null;
+
+        mRoundingParams = null;
+
+        mActualImageColorFilter = null;
+    }
+
+    /**
+     * Resets this builder to its initial values making it reusable.
+     *
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder reset() {
+        init();
+        return this;
+    }
+
+    /**
+     * Gets resources.
+     *
+     * @return
+     */
+    public Resources getResources() {
+        return mResources;
+    }
+
+    /**
+     * Sets the duration of the fade animation.
+     * If not set, default value of 300ms will be used.
+     *
+     * @param fadeDuration duration in milliseconds
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setFadeDuration(int fadeDuration) {
+        mFadeDuration = fadeDuration;
+        return this;
+    }
+
+    public int getFadeDuration() {
+        return mFadeDuration;
+    }
+
+    /**
+     * Sets the placeholder image, with default scale type CENTER_INSIDE. If no placeholder is set,
+     * a transparent ColorDrawable will be used.
+     *
+     * @param placeholderDrawable drawable to be used as placeholder image
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setPlaceholderImage(Drawable placeholderDrawable) {
+        return setPlaceholderImage(placeholderDrawable, DEFAULT_SCALE_TYPE);
+    }
+
+    /**
+     * Sets the placeholder image and scale type. If no placeholder is set, a transparent
+     * ColorDrawable will be used.
+     *
+     * @param placeholderDrawable       drawable to be used as placeholder image
+     * @param placeholderImageScaleType scale type for the placeholder image
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setPlaceholderImage(
+            Drawable placeholderDrawable,
+            @Nullable ScaleType placeholderImageScaleType) {
+        mPlaceholderImage = placeholderDrawable;
+        mPlaceholderImageScaleType = placeholderImageScaleType;
+        return this;
+    }
+
+    public Drawable getPlaceholderImage() {
+        return mPlaceholderImage;
+    }
+
+    public
+    @Nullable
+    ScaleType getPlaceholderImageScaleType() {
+        return mPlaceholderImageScaleType;
+    }
+
+    /**
+     * Sets the retry image, with default scale type CENTER_INSIDE.
+     *
+     * @param retryDrawable drawable to be used as retry image
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setRetryImage(Drawable retryDrawable) {
+        return setRetryImage(retryDrawable, DEFAULT_SCALE_TYPE);
+    }
+
+    /**
+     * Sets the retry image and scale type.
+     *
+     * @param retryDrawable       drawable to be used as retry image
+     * @param retryImageScaleType scale type for the retry image
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setRetryImage(
+            Drawable retryDrawable,
+            ScaleType retryImageScaleType) {
+        mRetryImage = retryDrawable;
+        mRetryImageScaleType = retryImageScaleType;
+        return this;
+    }
+
+    public Drawable getRetryImage() {
+        return mRetryImage;
+    }
+
+    public ScaleType getRetryImageScaleType() {
+        return mRetryImageScaleType;
+    }
+
+    /**
+     * Sets the failure image, with default scale type CENTER_INSIDE.
+     *
+     * @param failureDrawable drawable to be used as failure image
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setFailureImage(Drawable failureDrawable) {
+        return setFailureImage(failureDrawable, DEFAULT_SCALE_TYPE);
+    }
+
+    /**
+     * Sets the failure image, and scale type.
+     *
+     * @param failureDrawable       drawable to be used as failure image
+     * @param failureImageScaleType scale type for the failure image
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setFailureImage(
+            Drawable failureDrawable,
+            ScaleType failureImageScaleType) {
+        mFailureImage = failureDrawable;
+        mFailureImageScaleType = failureImageScaleType;
+        return this;
+    }
+
+    public Drawable getFailureImage() {
+        return mFailureImage;
+    }
+
+    public ScaleType getFailureImageScaleType() {
+        return mFailureImageScaleType;
+    }
+
+    /**
+     * Sets the progressBar image, with default scale type CENTER_INSIDE.
+     *
+     * @param progressBarImage drawable to be used as progressBar image
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setProgressBarImage(Drawable progressBarImage) {
+        return setProgressBarImage(progressBarImage, DEFAULT_SCALE_TYPE);
+    }
+
+    /**
+     * Sets the progressBar image, and scale type.
+     *
+     * @param progressBarImage          drawable to be used as progressBar image
+     * @param progressBarImageScaleType scale type for the progressBar image
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setProgressBarImage(
+            Drawable progressBarImage,
+            ScaleType progressBarImageScaleType) {
+        mProgressBarImage = progressBarImage;
+        mProgressBarImageScaleType = progressBarImageScaleType;
+        return this;
+    }
+
+    public Drawable getProgressBarImage() {
+        return mProgressBarImage;
+    }
+
+    public ScaleType getProgressBarImageScaleType() {
+        return mProgressBarImageScaleType;
+    }
 
-  private Resources mResources;
+    /**
+     * Sets the scale type, and removes the transformation matrix, for the actual image. If scale
+     * type is not set, and nor is a transformation matrix, then the actual image will be drawn
+     * with scale type CENTER_CROP.
+     *
+     * @param actualImageScaleType scale type for the actual image
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setActualImageScaleType(ScaleType actualImageScaleType) {
+        mActualImageScaleType = actualImageScaleType;
+        mActualImageMatrix = null;
+        return this;
+    }
+
+    public ScaleType getActualImageScaleType() {
+        return mActualImageScaleType;
+    }
+
+    /**
+     * Sets the transformation matrix, and removes the scale type, for the actual image. If matrix
+     * is not set, then the image will be drawn without a matrix being applied to it.
+     *
+     * @param actualImageMatrix matrix for the actual image
+     * @return modified instance of this builder
+     * @deprecated this is likely not something you want
+     */
+    @Deprecated
+    public GenericDraweeHierarchyBuilder setActualImageMatrix(Matrix actualImageMatrix) {
+        mActualImageMatrix = actualImageMatrix;
+        mActualImageScaleType = null;
+        return this;
+    }
+
+    public Matrix getActualImageMatrix() {
+        return mActualImageMatrix;
+    }
+
+    /**
+     * Sets the focus point for the actual image.
+     * If scale type FOCUS_CROP is used, focus point will attempted to be centered within a view.
+     * Each coordinate is a real number in [0,1] range, in the coordinate system where top-left
+     * corner of the image corresponds to (0, 0) and the bottom-right corner corresponds to (1, 1).
+     *
+     * @param focusPoint focus point of the image
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setActualImageFocusPoint(PointF focusPoint) {
+        mActualImageFocusPoint = focusPoint;
+        return this;
+    }
+
+    public PointF getActualImageFocusPoint() {
+        return mActualImageFocusPoint;
+    }
+
+    /**
+     * Sets the color filter.
+     *
+     * @param colorFilter color filter to be set
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setActualImageColorFilter(ColorFilter colorFilter) {
+        mActualImageColorFilter = colorFilter;
+        return this;
+    }
 
-  private int mFadeDuration;
-
-  private Drawable mPlaceholderImage;
-  private @Nullable ScaleType mPlaceholderImageScaleType;
-
-  private Drawable mRetryImage;
-  private ScaleType mRetryImageScaleType;
-
-  private Drawable mFailureImage;
-  private ScaleType mFailureImageScaleType;
-
-  private Drawable mProgressBarImage;
-  private ScaleType mProgressBarImageScaleType;
-
-  private ScaleType mActualImageScaleType;
-  private Matrix mActualImageMatrix;
-  private PointF mActualImageFocusPoint;
-  private ColorFilter mActualImageColorFilter;
-
-  private List<Drawable> mBackgrounds;
-  private List<Drawable> mOverlays;
-  private Drawable mPressedStateOverlay;
-
-  private RoundingParams mRoundingParams;
-
-  public GenericDraweeHierarchyBuilder(Resources resources) {
-    mResources = resources;
-    init();
-  }
-
-  public static GenericDraweeHierarchyBuilder newInstance(Resources resources) {
-    return new GenericDraweeHierarchyBuilder(resources);
-  }
-
-  /**
-   * Initializes this builder to its defaults.
-   */
-  private void init() {
-    mFadeDuration = DEFAULT_FADE_DURATION;
-
-    mPlaceholderImage = null;
-    mPlaceholderImageScaleType = null;
-
-    mRetryImage = null;
-    mRetryImageScaleType = null;
-
-    mFailureImage = null;
-    mFailureImageScaleType = null;
-
-    mProgressBarImage = null;
-    mProgressBarImageScaleType = null;
-
-    mActualImageScaleType = DEFAULT_ACTUAL_IMAGE_SCALE_TYPE;
-    mActualImageMatrix = null;
-    mActualImageFocusPoint = null;
-
-    mBackgrounds = null;
-    mOverlays = null;
-    mPressedStateOverlay = null;
-
-    mRoundingParams = null;
-
-    mActualImageColorFilter = null;
-  }
-
-  /**
-   * Resets this builder to its initial values making it reusable.
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder reset() {
-    init();
-    return this;
-  }
-
-  /**
-   * Gets resources.
-   * @return
-   */
-  public Resources getResources() {
-    return mResources;
-  }
-
-  /**
-   * Sets the duration of the fade animation.
-   * If not set, default value of 300ms will be used.
-   * @param fadeDuration duration in milliseconds
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setFadeDuration(int fadeDuration) {
-    mFadeDuration = fadeDuration;
-    return this;
-  }
-
-  public int getFadeDuration() {
-    return mFadeDuration;
-  }
-
-  /**
-   * Sets the placeholder image, with default scale type CENTER_INSIDE. If no placeholder is set,
-   * a transparent ColorDrawable will be used.
-   * @param placeholderDrawable drawable to be used as placeholder image
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setPlaceholderImage(Drawable placeholderDrawable) {
-    return setPlaceholderImage(placeholderDrawable, DEFAULT_SCALE_TYPE);
-  }
-
-  /**
-   * Sets the placeholder image and scale type. If no placeholder is set, a transparent
-   * ColorDrawable will be used.
-   * @param placeholderDrawable drawable to be used as placeholder image
-   * @param placeholderImageScaleType scale type for the placeholder image
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setPlaceholderImage(
-      Drawable placeholderDrawable,
-      @Nullable ScaleType placeholderImageScaleType) {
-    mPlaceholderImage = placeholderDrawable;
-    mPlaceholderImageScaleType = placeholderImageScaleType;
-    return this;
-  }
-
-  public Drawable getPlaceholderImage() {
-    return mPlaceholderImage;
-  }
-
-  public @Nullable ScaleType getPlaceholderImageScaleType() {
-    return mPlaceholderImageScaleType;
-  }
-
-  /**
-   * Sets the retry image, with default scale type CENTER_INSIDE.
-   * @param retryDrawable drawable to be used as retry image
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setRetryImage(Drawable retryDrawable) {
-    return setRetryImage(retryDrawable, DEFAULT_SCALE_TYPE);
-  }
-
-  /**
-   * Sets the retry image and scale type.
-   * @param retryDrawable drawable to be used as retry image
-   * @param retryImageScaleType scale type for the retry image
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setRetryImage(
-      Drawable retryDrawable,
-      ScaleType retryImageScaleType) {
-    mRetryImage = retryDrawable;
-    mRetryImageScaleType = retryImageScaleType;
-    return this;
-  }
-
-  public Drawable getRetryImage() {
-    return mRetryImage;
-  }
-
-  public ScaleType getRetryImageScaleType() {
-    return mRetryImageScaleType;
-  }
-
-  /**
-   * Sets the failure image, with default scale type CENTER_INSIDE.
-   * @param failureDrawable drawable to be used as failure image
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setFailureImage(Drawable failureDrawable) {
-    return setFailureImage(failureDrawable, DEFAULT_SCALE_TYPE);
-  }
-
-  /**
-   * Sets the failure image, and scale type.
-   * @param failureDrawable drawable to be used as failure image
-   * @param failureImageScaleType scale type for the failure image
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setFailureImage(
-      Drawable failureDrawable,
-      ScaleType failureImageScaleType) {
-    mFailureImage = failureDrawable;
-    mFailureImageScaleType = failureImageScaleType;
-    return this;
-  }
-
-  public Drawable getFailureImage() {
-    return mFailureImage;
-  }
-
-  public ScaleType getFailureImageScaleType() {
-    return mFailureImageScaleType;
-  }
-
-  /**
-   * Sets the progressBar image, with default scale type CENTER_INSIDE.
-   * @param progressBarImage drawable to be used as progressBar image
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setProgressBarImage(Drawable progressBarImage) {
-    return setProgressBarImage(progressBarImage, DEFAULT_SCALE_TYPE);
-  }
-
-  /**
-   * Sets the progressBar image, and scale type.
-   * @param progressBarImage drawable to be used as progressBar image
-   * @param progressBarImageScaleType scale type for the progressBar image
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setProgressBarImage(
-      Drawable progressBarImage,
-      ScaleType progressBarImageScaleType) {
-    mProgressBarImage = progressBarImage;
-    mProgressBarImageScaleType = progressBarImageScaleType;
-    return this;
-  }
-
-  public Drawable getProgressBarImage() {
-    return mProgressBarImage;
-  }
-
-  public ScaleType getProgressBarImageScaleType() {
-    return mProgressBarImageScaleType;
-  }
-
-  /**
-   * Sets the scale type, and removes the transformation matrix, for the actual image. If scale
-   * type is not set, and nor is a transformation matrix, then the actual image will be drawn
-   * with scale type CENTER_CROP.
-   * @param actualImageScaleType scale type for the actual image
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setActualImageScaleType(ScaleType actualImageScaleType) {
-    mActualImageScaleType = actualImageScaleType;
-    mActualImageMatrix = null;
-    return this;
-  }
-
-  public ScaleType getActualImageScaleType() {
-    return mActualImageScaleType;
-  }
-
-  /**
-   * Sets the transformation matrix, and removes the scale type, for the actual image. If matrix
-   * is not set, then the image will be drawn without a matrix being applied to it.
-   * @param actualImageMatrix matrix for the actual image
-   * @return modified instance of this builder
-   * @deprecated this is likely not something you want
-   */
-  @Deprecated
-  public GenericDraweeHierarchyBuilder setActualImageMatrix(Matrix actualImageMatrix) {
-    mActualImageMatrix = actualImageMatrix;
-    mActualImageScaleType = null;
-    return this;
-  }
-
-  public Matrix getActualImageMatrix() {
-    return mActualImageMatrix;
-  }
-
-  /**
-   * Sets the focus point for the actual image.
-   * If scale type FOCUS_CROP is used, focus point will attempted to be centered within a view.
-   * Each coordinate is a real number in [0,1] range, in the coordinate system where top-left
-   * corner of the image corresponds to (0, 0) and the bottom-right corner corresponds to (1, 1).
-   * @param focusPoint focus point of the image
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setActualImageFocusPoint(PointF focusPoint) {
-    mActualImageFocusPoint = focusPoint;
-    return this;
-  }
-
-  public PointF getActualImageFocusPoint() {
-    return mActualImageFocusPoint;
-  }
-
-  /**
-   * Sets the color filter.
-   *
-   * @param colorFilter color filter to be set
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setActualImageColorFilter(ColorFilter colorFilter) {
-    mActualImageColorFilter = colorFilter;
-    return this;
-  }
-
-  public ColorFilter getActualImageColorFilter() {
-    return mActualImageColorFilter;
-  }
-
-  /**
-   * Sets the backgrounds.
-   * Backgrounds are drawn in list order before the rest of the hierarchy and overlays. The
-   * first background will be drawn at the bottom.
-   * @param backgrounds background drawables
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setBackgrounds(List<Drawable> backgrounds) {
-    mBackgrounds = backgrounds;
-    return this;
-  }
-
-  /**
-   * Sets a single background.
-   * @param background background drawable
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setBackground(Drawable background) {
-    mBackgrounds = Lists.newArrayList(background);
-    return this;
-  }
-
-  public List<Drawable> getBackgrounds() {
-    return mBackgrounds;
-  }
-
-  /**
-   * Sets the overlays.
-   * Overlays are drawn in list order after the backgrounds and the rest of the hierarchy. The
-   * last overlay will be drawn at the top.
-   * @param overlays overlay drawables
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setOverlays(List<Drawable> overlays) {
-    mOverlays = overlays;
-    return this;
-  }
-
-  /**
-   * Sets a single overlay.
-   * @param overlay overlay drawable
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setOverlay(Drawable overlay) {
-    mOverlays = Lists.newArrayList(overlay);
-    return this;
-  }
-
-  public List<Drawable> getOverlays() {
-    return mOverlays;
-  }
-
-  /**
-   * Sets Overlay for pressed state
-   * @param drawable for pressed state
-   * @return
-   */
-  public GenericDraweeHierarchyBuilder setPressedStateOverlay(Drawable drawable) {
-    StateListDrawable stateListDrawable = new StateListDrawable();
-    stateListDrawable.addState(new int[]{android.R.attr.state_pressed}, drawable);
-    mPressedStateOverlay = stateListDrawable;
-    return this;
-  }
-
-  public Drawable getPressedStateOverlay() {
-    return mPressedStateOverlay;
-  }
-
-  /**
-   * Sets rounding params.
-   *
-   * @param roundingParams rounding params to be set
-   * @return modified instance of this builder
-   */
-  public GenericDraweeHierarchyBuilder setRoundingParams(RoundingParams roundingParams) {
-    mRoundingParams = roundingParams;
-    return this;
-  }
-
-  public RoundingParams getRoundingParams() {
-    return mRoundingParams;
-  }
-
-  private void validate() {
-    if (mOverlays != null) {
-      for (Drawable overlay : mOverlays) {
-        Preconditions.checkNotNull(overlay);
-      }
-    }
-
-    if (mBackgrounds != null) {
-      for (Drawable background : mBackgrounds) {
-        Preconditions.checkNotNull(background);
-      }
-    }
-  }
-
-  public GenericDraweeHierarchy build() {
-    validate();
-    return new GenericDraweeHierarchy(this);
-  }
+    public ColorFilter getActualImageColorFilter() {
+        return mActualImageColorFilter;
+    }
+
+    /**
+     * Sets the backgrounds.
+     * Backgrounds are drawn in list order before the rest of the hierarchy and overlays. The
+     * first background will be drawn at the bottom.
+     *
+     * @param backgrounds background drawables
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setBackgrounds(List<Drawable> backgrounds) {
+        mBackgrounds = backgrounds;
+        return this;
+    }
+
+    /**
+     * Sets a single background.
+     *
+     * @param background background drawable
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setBackground(Drawable background) {
+        mBackgrounds = Lists.newArrayList(background);
+        return this;
+    }
+
+    public List<Drawable> getBackgrounds() {
+        return mBackgrounds;
+    }
+
+    /**
+     * Sets the overlays.
+     * Overlays are drawn in list order after the backgrounds and the rest of the hierarchy. The
+     * last overlay will be drawn at the top.
+     *
+     * @param overlays overlay drawables
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setOverlays(List<Drawable> overlays) {
+        mOverlays = overlays;
+        return this;
+    }
+
+    /**
+     * Sets a single overlay.
+     *
+     * @param overlay overlay drawable
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setOverlay(Drawable overlay) {
+        mOverlays = Lists.newArrayList(overlay);
+        return this;
+    }
+
+    public List<Drawable> getOverlays() {
+        return mOverlays;
+    }
+
+    /**
+     * Sets Overlay for pressed state
+     *
+     * @param drawable for pressed state
+     * @return
+     */
+    public GenericDraweeHierarchyBuilder setPressedStateOverlay(Drawable drawable) {
+        StateListDrawable stateListDrawable = new StateListDrawable();
+        stateListDrawable.addState(new int[]{android.R.attr.state_pressed}, drawable);
+        mPressedStateOverlay = stateListDrawable;
+        return this;
+    }
+
+    public Drawable getPressedStateOverlay() {
+        return mPressedStateOverlay;
+    }
+
+    /**
+     * Sets rounding params.
+     *
+     * @param roundingParams rounding params to be set
+     * @return modified instance of this builder
+     */
+    public GenericDraweeHierarchyBuilder setRoundingParams(RoundingParams roundingParams) {
+        mRoundingParams = roundingParams;
+        return this;
+    }
+
+    public RoundingParams getRoundingParams() {
+        return mRoundingParams;
+    }
+
+    private void validate() {
+        if (mOverlays != null) {
+            for (Drawable overlay : mOverlays) {
+                Preconditions.checkNotNull(overlay);
+            }
+        }
+
+        if (mBackgrounds != null) {
+            for (Drawable background : mBackgrounds) {
+                Preconditions.checkNotNull(background);
+            }
+        }
+    }
+
+    public GenericDraweeHierarchy build() {
+        validate();
+        return new GenericDraweeHierarchy(this);
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/generic/RoundingParams.java b/drawee/src/main/java/com/facebook/drawee/generic/RoundingParams.java
index d2b44b1c3..21a169af7 100644
--- a/drawee/src/main/java/com/facebook/drawee/generic/RoundingParams.java
+++ b/drawee/src/main/java/com/facebook/drawee/generic/RoundingParams.java
@@ -20,186 +20,205 @@
  */
 public class RoundingParams {
 
-  public enum RoundingMethod {
-    /**
-     * Draws rounded corners on top of the underlying drawable by overlaying a solid color which
-     * is specified by {@code setOverlayColor}. This option should only be used when the
-     * background beneath the underlying drawable is static and of the same solid color.
-     */
-    OVERLAY_COLOR,
-
-    /**
-     * Uses BitmapShader to draw bitmap with rounded corners. Works only with BitmapDrawables and
-     * ColorDrawables.
-     * IMPORTANT: Only the actual image and the placeholder image will get rounded. Other images
-     * (such as retry, failure, progress bar, backgrounds, overlays, etc.) won't get rounded.
-     */
-    BITMAP_ONLY
-  }
-
-  private RoundingMethod mRoundingMethod = RoundingMethod.BITMAP_ONLY;
-  private boolean mRoundAsCircle = false;
-  private float[] mCornersRadii = null;
-  private int mOverlayColor = 0;
-  private float mBorderWidth = 0;
-  private int mBorderColor = Color.TRANSPARENT;
-
-  /**
-   *  Sets whether to round as circle.
-   *
-   * @param roundAsCircle whether or not to round as circle
-   * @return modified instance
-   */
-  public RoundingParams setRoundAsCircle(boolean roundAsCircle) {
-    mRoundAsCircle = roundAsCircle;
-    return this;
-  }
-
-  /** Gets whether to round as circle */
-  public boolean getRoundAsCircle() {
-    return mRoundAsCircle;
-  }
-
-  /**
-   * Sets the rounded corners radius.
-   *
-   * @param radius corner radius in pixels
-   * @return  modified instance
-   */
-  public RoundingParams setCornersRadius(float radius) {
-    Arrays.fill(getOrCreateRoundedCornersRadii(), radius);
-    return this;
-  }
-
-  /**
-   * Sets the rounded corners radii.
-   *
-   * @param topLeft top-left corner radius in pixels
-   * @param topRight top-right corner radius in pixels
-   * @param bottomRight bottom-right corner radius in pixels
-   * @param bottomLeft bottom-left corner radius in pixels
-   * @return modified instance
-   */
-  public RoundingParams setCornersRadii(
-      float topLeft,
-      float topRight,
-      float bottomRight,
-      float bottomLeft) {
-    float[] radii = getOrCreateRoundedCornersRadii();
-    radii[0] = radii[1] = topLeft;
-    radii[2] = radii[3] = topRight;
-    radii[4] = radii[5] = bottomRight;
-    radii[6] = radii[7] = bottomLeft;
-    return this;
-  }
-
-  /**
-   * Sets the rounded corners radii.
-   *
-   * @param radii float array of 8 radii in pixels. Each corner receives two radius values [X, Y].
-   *     The corners are ordered top-left, top-right, bottom-right, bottom-left.
-   * @return modified instance
-   */
-  public RoundingParams setCornersRadii(float[] radii) {
-    Preconditions.checkNotNull(radii);
-    Preconditions.checkArgument(radii.length == 8, "radii should have exactly 8 values");
-    System.arraycopy(radii, 0, getOrCreateRoundedCornersRadii(), 0, 8);
-    return this;
-  }
-
-  /**
-   * Gets the rounded corners radii.
-   *
-   * <p> For performance reasons the internal array is returned directly. Do not modify it directly,
-   * but use one of the exposed corner radii setters instead.
-   */
-  public float[] getCornersRadii() {
-    return mCornersRadii;
-  }
-
-  /**
-   * Sets the rounding method.
-   *
-   * @param roundingMethod method of rounding
-   * @return modified instance
-   */
-  public RoundingParams setRoundingMethod(RoundingMethod roundingMethod) {
-    mRoundingMethod = roundingMethod;
-    return this;
-  }
-
-  /** Gets the rounding method. */
-  public RoundingMethod getRoundingMethod() {
-    return mRoundingMethod;
-  }
-
-  /**
-   * Sets the overlay color and changes the method to {@code RoundingMethod.COLOR_OVERLAY}.
-   *
-   * @param overlayColor overlay color
-   */
-  public RoundingParams setOverlayColor(int overlayColor) {
-    mOverlayColor = overlayColor;
-    mRoundingMethod = RoundingMethod.OVERLAY_COLOR;
-    return this;
-  }
-
-  /** Gets the overlay color. */
-  public int getOverlayColor() {
-    return mOverlayColor;
-  }
-
-  private float[] getOrCreateRoundedCornersRadii() {
-    if (mCornersRadii == null) {
-      mCornersRadii = new float[8];
-    }
-    return mCornersRadii;
-  }
-
-  /** Factory method that creates new RoundingParams with RoundAsCircle specified. */
-  public static RoundingParams asCircle() {
-    return (new RoundingParams()).setRoundAsCircle(true);
-  }
-
-  /** Factory method that creates new RoundingParams with the specified corners radius. */
-  public static RoundingParams fromCornersRadius(float radius) {
-    return (new RoundingParams()).setCornersRadius(radius);
-  }
-
-  /** Factory method that creates new RoundingParams with the specified corners radii. */
-  public static RoundingParams fromCornersRadii(
-      float topLeft,
-      float topRight,
-      float bottomRight,
-      float bottomLeft) {
-    return (new RoundingParams())
-        .setCornersRadii(topLeft, topRight, bottomRight, bottomLeft);
-  }
-
-  /** Factory method that creates new RoundingParams with the specified corners radii. */
-  public static RoundingParams fromCornersRadii(float[] radii) {
-    return (new RoundingParams()).setCornersRadii(radii);
-  }
-
-  /**
-   * Sets the border around the rounded drawable
-   * @param color of the border
-   * @param width of the width
-   */
-  public RoundingParams setBorder(int color, float width) {
-    Preconditions.checkArgument(width >= 0, "the border width cannot be < 0");
-    mBorderWidth = width;
-    mBorderColor = color;
-    return this;
-  }
-
-  /** Gets the border width */
-  public float getBorderWidth() {
-    return mBorderWidth;
-  }
-
-  /** Gets the border color */
-  public int getBorderColor() {
-    return mBorderColor;
-  }
+    public enum RoundingMethod {
+        /**
+         * Draws rounded corners on top of the underlying drawable by overlaying a solid color which
+         * is specified by {@code setOverlayColor}. This option should only be used when the
+         * background beneath the underlying drawable is static and of the same solid color.
+         */
+        OVERLAY_COLOR,
+
+        /**
+         * Uses BitmapShader to draw bitmap with rounded corners. Works only with BitmapDrawables and
+         * ColorDrawables.
+         * IMPORTANT: Only the actual image and the placeholder image will get rounded. Other images
+         * (such as retry, failure, progress bar, backgrounds, overlays, etc.) won't get rounded.
+         */
+        BITMAP_ONLY
+    }
+
+    private RoundingMethod mRoundingMethod = RoundingMethod.BITMAP_ONLY;
+    private boolean mRoundAsCircle = false;
+    private float[] mCornersRadii = null;
+    private int mOverlayColor = 0;
+    private float mBorderWidth = 0;
+    private int mBorderColor = Color.TRANSPARENT;
+
+    /**
+     * Sets whether to round as circle.
+     *
+     * @param roundAsCircle whether or not to round as circle
+     * @return modified instance
+     */
+    public RoundingParams setRoundAsCircle(boolean roundAsCircle) {
+        mRoundAsCircle = roundAsCircle;
+        return this;
+    }
+
+    /**
+     * Gets whether to round as circle
+     */
+    public boolean getRoundAsCircle() {
+        return mRoundAsCircle;
+    }
+
+    /**
+     * Sets the rounded corners radius.
+     *
+     * @param radius corner radius in pixels
+     * @return modified instance
+     */
+    public RoundingParams setCornersRadius(float radius) {
+        Arrays.fill(getOrCreateRoundedCornersRadii(), radius);
+        return this;
+    }
+
+    /**
+     * Sets the rounded corners radii.
+     *
+     * @param topLeft     top-left corner radius in pixels
+     * @param topRight    top-right corner radius in pixels
+     * @param bottomRight bottom-right corner radius in pixels
+     * @param bottomLeft  bottom-left corner radius in pixels
+     * @return modified instance
+     */
+    public RoundingParams setCornersRadii(
+            float topLeft,
+            float topRight,
+            float bottomRight,
+            float bottomLeft) {
+        float[] radii = getOrCreateRoundedCornersRadii();
+        radii[0] = radii[1] = topLeft;
+        radii[2] = radii[3] = topRight;
+        radii[4] = radii[5] = bottomRight;
+        radii[6] = radii[7] = bottomLeft;
+        return this;
+    }
+
+    /**
+     * Sets the rounded corners radii.
+     *
+     * @param radii float array of 8 radii in pixels. Each corner receives two radius values [X, Y].
+     *              The corners are ordered top-left, top-right, bottom-right, bottom-left.
+     * @return modified instance
+     */
+    public RoundingParams setCornersRadii(float[] radii) {
+        Preconditions.checkNotNull(radii);
+        Preconditions.checkArgument(radii.length == 8, "radii should have exactly 8 values");
+        System.arraycopy(radii, 0, getOrCreateRoundedCornersRadii(), 0, 8);
+        return this;
+    }
+
+    /**
+     * Gets the rounded corners radii.
+     * <p>
+     * <p> For performance reasons the internal array is returned directly. Do not modify it directly,
+     * but use one of the exposed corner radii setters instead.
+     */
+    public float[] getCornersRadii() {
+        return mCornersRadii;
+    }
+
+    /**
+     * Sets the rounding method.
+     *
+     * @param roundingMethod method of rounding
+     * @return modified instance
+     */
+    public RoundingParams setRoundingMethod(RoundingMethod roundingMethod) {
+        mRoundingMethod = roundingMethod;
+        return this;
+    }
+
+    /**
+     * Gets the rounding method.
+     */
+    public RoundingMethod getRoundingMethod() {
+        return mRoundingMethod;
+    }
+
+    /**
+     * Sets the overlay color and changes the method to {@code RoundingMethod.COLOR_OVERLAY}.
+     *
+     * @param overlayColor overlay color
+     */
+    public RoundingParams setOverlayColor(int overlayColor) {
+        mOverlayColor = overlayColor;
+        mRoundingMethod = RoundingMethod.OVERLAY_COLOR;
+        return this;
+    }
+
+    /**
+     * Gets the overlay color.
+     */
+    public int getOverlayColor() {
+        return mOverlayColor;
+    }
+
+    private float[] getOrCreateRoundedCornersRadii() {
+        if (mCornersRadii == null) {
+            mCornersRadii = new float[8];
+        }
+        return mCornersRadii;
+    }
+
+    /**
+     * Factory method that creates new RoundingParams with RoundAsCircle specified.
+     */
+    public static RoundingParams asCircle() {
+        return (new RoundingParams()).setRoundAsCircle(true);
+    }
+
+    /**
+     * Factory method that creates new RoundingParams with the specified corners radius.
+     */
+    public static RoundingParams fromCornersRadius(float radius) {
+        return (new RoundingParams()).setCornersRadius(radius);
+    }
+
+    /**
+     * Factory method that creates new RoundingParams with the specified corners radii.
+     */
+    public static RoundingParams fromCornersRadii(
+            float topLeft,
+            float topRight,
+            float bottomRight,
+            float bottomLeft) {
+        return (new RoundingParams())
+                .setCornersRadii(topLeft, topRight, bottomRight, bottomLeft);
+    }
+
+    /**
+     * Factory method that creates new RoundingParams with the specified corners radii.
+     */
+    public static RoundingParams fromCornersRadii(float[] radii) {
+        return (new RoundingParams()).setCornersRadii(radii);
+    }
+
+    /**
+     * Sets the border around the rounded drawable
+     *
+     * @param color of the border
+     * @param width of the width
+     */
+    public RoundingParams setBorder(int color, float width) {
+        Preconditions.checkArgument(width >= 0, "the border width cannot be < 0");
+        mBorderWidth = width;
+        mBorderColor = color;
+        return this;
+    }
+
+    /**
+     * Gets the border width
+     */
+    public float getBorderWidth() {
+        return mBorderWidth;
+    }
+
+    /**
+     * Gets the border color
+     */
+    public int getBorderColor() {
+        return mBorderColor;
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/gestures/GestureDetector.java b/drawee/src/main/java/com/facebook/drawee/gestures/GestureDetector.java
index ed001fb6c..5110a636f 100644
--- a/drawee/src/main/java/com/facebook/drawee/gestures/GestureDetector.java
+++ b/drawee/src/main/java/com/facebook/drawee/gestures/GestureDetector.java
@@ -28,95 +28,114 @@
  */
 public class GestureDetector {
 
-  /** Interface for the click listener. */
-  public interface ClickListener {
-    public boolean onClick();
-  }
+    /**
+     * Interface for the click listener.
+     */
+    public interface ClickListener {
+        public boolean onClick();
+    }
 
-  @VisibleForTesting ClickListener mClickListener;
+    @VisibleForTesting
+    ClickListener mClickListener;
 
-  @VisibleForTesting final float mSingleTapSlopPx;
-  @VisibleForTesting boolean mIsCapturingGesture;
-  @VisibleForTesting boolean mIsClickCandidate;
-  @VisibleForTesting long mActionDownTime;
-  @VisibleForTesting float mActionDownX;
-  @VisibleForTesting float mActionDownY;
+    @VisibleForTesting
+    final float mSingleTapSlopPx;
+    @VisibleForTesting
+    boolean mIsCapturingGesture;
+    @VisibleForTesting
+    boolean mIsClickCandidate;
+    @VisibleForTesting
+    long mActionDownTime;
+    @VisibleForTesting
+    float mActionDownX;
+    @VisibleForTesting
+    float mActionDownY;
 
-  public GestureDetector(Context context) {
-    final ViewConfiguration viewConfiguration = ViewConfiguration.get(context);
-    mSingleTapSlopPx = viewConfiguration.getScaledTouchSlop();
-    init();
-  }
+    public GestureDetector(Context context) {
+        final ViewConfiguration viewConfiguration = ViewConfiguration.get(context);
+        mSingleTapSlopPx = viewConfiguration.getScaledTouchSlop();
+        init();
+    }
 
-  /** Creates a new instance of this gesture detector. */
-  public static GestureDetector newInstance(Context context) {
-    return new GestureDetector(context);
-  }
+    /**
+     * Creates a new instance of this gesture detector.
+     */
+    public static GestureDetector newInstance(Context context) {
+        return new GestureDetector(context);
+    }
 
-  /** Initializes this component to its initial state. */
-  public void init() {
-    mClickListener = null;
-    reset();
-  }
+    /**
+     * Initializes this component to its initial state.
+     */
+    public void init() {
+        mClickListener = null;
+        reset();
+    }
 
-  /**
-   * Resets component.
-   * <p> This will drop any gesture recognition that might currently be in progress.
-   */
-  public void reset() {
-    mIsCapturingGesture = false;
-    mIsClickCandidate = false;
-  }
+    /**
+     * Resets component.
+     * <p> This will drop any gesture recognition that might currently be in progress.
+     */
+    public void reset() {
+        mIsCapturingGesture = false;
+        mIsClickCandidate = false;
+    }
 
-  /** Sets the click listener. */
-  public void setClickListener(ClickListener clickListener) {
-    mClickListener = clickListener;
-  }
+    /**
+     * Sets the click listener.
+     */
+    public void setClickListener(ClickListener clickListener) {
+        mClickListener = clickListener;
+    }
 
-  /** Returns whether the gesture capturing is in progress. */
-  public boolean isCapturingGesture() {
-    return mIsCapturingGesture;
-  }
+    /**
+     * Returns whether the gesture capturing is in progress.
+     */
+    public boolean isCapturingGesture() {
+        return mIsCapturingGesture;
+    }
 
-  /** Handles the touch event */
-  public boolean onTouchEvent(MotionEvent event) {
-    switch (event.getAction()) {
-      case MotionEvent.ACTION_DOWN:
-        mIsCapturingGesture = true;
-        mIsClickCandidate = true;
-        mActionDownTime = event.getEventTime();
-        mActionDownX = event.getX();
-        mActionDownY = event.getY();
-        break;
-      case MotionEvent.ACTION_MOVE:
-        if (Math.abs(event.getX() - mActionDownX) > mSingleTapSlopPx ||
-            Math.abs(event.getY() - mActionDownY) > mSingleTapSlopPx) {
-          mIsClickCandidate = false;
+    /**
+     * Handles the touch event
+     */
+    public boolean onTouchEvent(MotionEvent event) {
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+                mIsCapturingGesture = true;
+                mIsClickCandidate = true;
+                mActionDownTime = event.getEventTime();
+                mActionDownX = event.getX();
+                mActionDownY = event.getY();
+                break;
+            case MotionEvent.ACTION_MOVE:
+                if (Math.abs(event.getX() - mActionDownX) > mSingleTapSlopPx ||
+                        Math.abs(event.getY() - mActionDownY) > mSingleTapSlopPx) {
+                    mIsClickCandidate = false;
+                }
+                break;
+            case MotionEvent.ACTION_CANCEL:
+                mIsCapturingGesture = false;
+                mIsClickCandidate = false;
+                break;
+            case MotionEvent.ACTION_UP:
+                mIsCapturingGesture = false;
+                if (Math.abs(event.getX() - mActionDownX) > mSingleTapSlopPx ||
+                        Math.abs(event.getY() - mActionDownY) > mSingleTapSlopPx) {
+                    mIsClickCandidate = false;
+                }
+                if (mIsClickCandidate) {
+                    if (event.getEventTime() - mActionDownTime <= ViewConfiguration.getLongPressTimeout()) {
+                        if (mClickListener != null) {
+                            mClickListener.onClick();
+                        }
+                    } else {
+                        // long click, not handled
+                    }
+                }
+                mIsClickCandidate = false;
+                break;
         }
-        break;
-      case MotionEvent.ACTION_CANCEL:
-        mIsCapturingGesture = false;
-        mIsClickCandidate = false;
-        break;
-      case MotionEvent.ACTION_UP:
-        mIsCapturingGesture = false;
-        if (Math.abs(event.getX() - mActionDownX) > mSingleTapSlopPx ||
-            Math.abs(event.getY() - mActionDownY) > mSingleTapSlopPx) {
-          mIsClickCandidate = false;
-        }
-        if (mIsClickCandidate) {
-          if (event.getEventTime() - mActionDownTime <= ViewConfiguration.getLongPressTimeout()) {
-            if (mClickListener != null) {
-              mClickListener.onClick();
-            }
-          } else {
-            // long click, not handled
-          }
-        }
-        mIsClickCandidate = false;
-        break;
+        return true;
     }
-    return true;
-  }
 
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeController.java b/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeController.java
index fe35f5015..c7d123ce5 100644
--- a/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeController.java
+++ b/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeController.java
@@ -21,35 +21,41 @@
  */
 public interface DraweeController {
 
-  /** Gets the hierarchy. */
-  @Nullable
-  public DraweeHierarchy getHierarchy();
-
-  /** Sets a new hierarchy. */
-  void setHierarchy(@Nullable DraweeHierarchy hierarchy);
-
-  /**
-   * Called when the view containing the hierarchy is attached to a window
-   * (either temporarily or permanently).
-   */
-  public void onAttach();
-
-  /**
-   * Called when the view containing the hierarchy is detached from a window
-   * (either temporarily or permanently).
-   */
-  public void onDetach();
-
-  /**
-   * Called when the view containing the hierarchy receives a touch event.
-   * @return true if the event was handled by the controller, false otherwise
-   */
-  public boolean onTouchEvent(MotionEvent event);
-
-  /**
-   * For an animated image, returns an Animatable that lets clients control the animation.
-   * @return animatable, or null if the image is not animated or not loaded yet
-   */
-  public Animatable getAnimatable();
+    /**
+     * Gets the hierarchy.
+     */
+    @Nullable
+    public DraweeHierarchy getHierarchy();
+
+    /**
+     * Sets a new hierarchy.
+     */
+    void setHierarchy(@Nullable DraweeHierarchy hierarchy);
+
+    /**
+     * Called when the view containing the hierarchy is attached to a window
+     * (either temporarily or permanently).
+     */
+    public void onAttach();
+
+    /**
+     * Called when the view containing the hierarchy is detached from a window
+     * (either temporarily or permanently).
+     */
+    public void onDetach();
+
+    /**
+     * Called when the view containing the hierarchy receives a touch event.
+     *
+     * @return true if the event was handled by the controller, false otherwise
+     */
+    public boolean onTouchEvent(MotionEvent event);
+
+    /**
+     * For an animated image, returns an Animatable that lets clients control the animation.
+     *
+     * @return animatable, or null if the image is not animated or not loaded yet
+     */
+    public Animatable getAnimatable();
 
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeHierarchy.java b/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeHierarchy.java
index cab796da7..da9611792 100644
--- a/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeHierarchy.java
+++ b/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeHierarchy.java
@@ -18,24 +18,24 @@
  * <p> Hierarchy details are hidden for the outside world. All that's visible is the top level
  * drawable, which can be put into a view.
  * <p> Example hierarchy:
- *
- *   o FadeDrawable (top level drawable)
- *   |
- *   +--o ScaleTypeDrawable
- *   |  |
- *   |  +--o BitmapDrawable
- *   |
- *   +--o ScaleTypeDrawable
- *      |
- *      +--o BitmapDrawable
- *
+ * <p>
+ * o FadeDrawable (top level drawable)
+ * |
+ * +--o ScaleTypeDrawable
+ * |  |
+ * |  +--o BitmapDrawable
+ * |
+ * +--o ScaleTypeDrawable
+ * |
+ * +--o BitmapDrawable
  */
 public interface DraweeHierarchy {
 
-  /**
-   * Returns the top level drawable in the corresponding hierarchy. Hierarchy should always have
-   * the same instance of its top level drawable.
-   * @return top level drawable
-   */
-  public Drawable getTopLevelDrawable();
+    /**
+     * Returns the top level drawable in the corresponding hierarchy. Hierarchy should always have
+     * the same instance of its top level drawable.
+     *
+     * @return top level drawable
+     */
+    public Drawable getTopLevelDrawable();
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/interfaces/SettableDraweeHierarchy.java b/drawee/src/main/java/com/facebook/drawee/interfaces/SettableDraweeHierarchy.java
index 6491edd0e..228543098 100644
--- a/drawee/src/main/java/com/facebook/drawee/interfaces/SettableDraweeHierarchy.java
+++ b/drawee/src/main/java/com/facebook/drawee/interfaces/SettableDraweeHierarchy.java
@@ -15,79 +15,83 @@
  * Interface that represents a settable Drawee hierarchy. Hierarchy should display a placeholder
  * image until the actual image is set. In case of a failure, hierarchy can choose to display
  * a failure image.
- *
+ * <p>
  * <p>IMPORTANT: methods of this interface are to be used by controllers ONLY!
- *
+ * <p>
  * <p>
  * Example hierarchy:
- *
- *   o FadeDrawable (top level drawable)
- *   |
- *   +--o ScaleTypeDrawable
- *   |  |
- *   |  +--o ColorDrawable (placeholder image)
- *   |
- *   +--o ScaleTypeDrawable
- *   |  |
- *   |  +--o BitmapDrawable (failure image)
- *   |
- *   +--o ScaleTypeDrawable
- *      |
- *      +--o SettableDrawable
- *         |
- *         +--o BitmapDrawable (actual image)
- *
- *   SettableDraweeHierarchy in the given example has a FadeDrawable as its top level drawable.
- *   Top level drawable can be immediately put into view. Once the actual image is ready, it will
- *   be set to the hierarchy's SettableDrawable and fade animation between the placeholder and the
- *   actual image will be initiated. In case of failure, hierarchy will switch to failure image.
- *   All image branches are wrapped with ScaleType drawable which allows separate scale type to be
- *   applied on each.
- *
+ * <p>
+ * o FadeDrawable (top level drawable)
+ * |
+ * +--o ScaleTypeDrawable
+ * |  |
+ * |  +--o ColorDrawable (placeholder image)
+ * |
+ * +--o ScaleTypeDrawable
+ * |  |
+ * |  +--o BitmapDrawable (failure image)
+ * |
+ * +--o ScaleTypeDrawable
+ * |
+ * +--o SettableDrawable
+ * |
+ * +--o BitmapDrawable (actual image)
+ * <p>
+ * SettableDraweeHierarchy in the given example has a FadeDrawable as its top level drawable.
+ * Top level drawable can be immediately put into view. Once the actual image is ready, it will
+ * be set to the hierarchy's SettableDrawable and fade animation between the placeholder and the
+ * actual image will be initiated. In case of failure, hierarchy will switch to failure image.
+ * All image branches are wrapped with ScaleType drawable which allows separate scale type to be
+ * applied on each.
  */
 public interface SettableDraweeHierarchy extends DraweeHierarchy {
 
-  /**
-   * Called by controller when the hierarchy should be reset to its initial state. Any image
-   * previously set by {@code setImage} should be detached and not used anymore.
-   */
-  public void reset();
+    /**
+     * Called by controller when the hierarchy should be reset to its initial state. Any image
+     * previously set by {@code setImage} should be detached and not used anymore.
+     */
+    public void reset();
 
-  /**
-   * Called by controller when the future that provides the actual image completes successfully.
-   * Hierarchy should display the actual image.
-   * @param drawable drawable to be set as the temporary image
-   * @param progress number in range [0, 1] that indicates progress
-   * @param immediate if true, image will be shown immediately (without fade effect)
-   */
-  public void setImage(Drawable drawable, float progress, boolean immediate);
+    /**
+     * Called by controller when the future that provides the actual image completes successfully.
+     * Hierarchy should display the actual image.
+     *
+     * @param drawable  drawable to be set as the temporary image
+     * @param progress  number in range [0, 1] that indicates progress
+     * @param immediate if true, image will be shown immediately (without fade effect)
+     */
+    public void setImage(Drawable drawable, float progress, boolean immediate);
 
-  /**
-   * Called by controller to update the progress.
-   * Hierarchy can choose to hide the progressbar when progress is set to its final value of 1.
-   * @param progress number in range [0, 1] that indicates progress
-   * @param immediate if true, progressbar will be shown/hidden immediately (without fade effect)
-   */
-  public void setProgress(float progress, boolean immediate);
+    /**
+     * Called by controller to update the progress.
+     * Hierarchy can choose to hide the progressbar when progress is set to its final value of 1.
+     *
+     * @param progress  number in range [0, 1] that indicates progress
+     * @param immediate if true, progressbar will be shown/hidden immediately (without fade effect)
+     */
+    public void setProgress(float progress, boolean immediate);
 
-  /**
-   * Called by controller when the future that provides the actual image completes with failure.
-   * Hierarchy can choose to display between different images based on cause of failure.
-   * @param throwable cause of failure
-   */
-  public void setFailure(Throwable throwable);
+    /**
+     * Called by controller when the future that provides the actual image completes with failure.
+     * Hierarchy can choose to display between different images based on cause of failure.
+     *
+     * @param throwable cause of failure
+     */
+    public void setFailure(Throwable throwable);
 
-  /**
-   * Called by controller when the future that provides the actual image completes with failure,
-   * but the controller is prepared to kick off a retry when the user clicks on the image.
-   * Hierarchy can choose to display a retry image.
-   * @param throwable cause of failure
-   */
-  public void setRetry(Throwable throwable);
+    /**
+     * Called by controller when the future that provides the actual image completes with failure,
+     * but the controller is prepared to kick off a retry when the user clicks on the image.
+     * Hierarchy can choose to display a retry image.
+     *
+     * @param throwable cause of failure
+     */
+    public void setRetry(Throwable throwable);
 
-  /**
-   * Called by controller if it needs to display some controller overlay.
-   * @param drawable drawable to be displayed as controller overlay
-   */
-  public void setControllerOverlay(Drawable drawable);
+    /**
+     * Called by controller if it needs to display some controller overlay.
+     *
+     * @param drawable drawable to be displayed as controller overlay
+     */
+    public void setControllerOverlay(Drawable drawable);
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/interfaces/SimpleDraweeControllerBuilder.java b/drawee/src/main/java/com/facebook/drawee/interfaces/SimpleDraweeControllerBuilder.java
index 61af1227b..9d81d6173 100644
--- a/drawee/src/main/java/com/facebook/drawee/interfaces/SimpleDraweeControllerBuilder.java
+++ b/drawee/src/main/java/com/facebook/drawee/interfaces/SimpleDraweeControllerBuilder.java
@@ -18,15 +18,23 @@
  */
 public interface SimpleDraweeControllerBuilder {
 
-  /** Sets the caller context. */
-  public SimpleDraweeControllerBuilder setCallerContext(Object callerContext);
-
-  /** Sets the uri. */
-  public SimpleDraweeControllerBuilder setUri(Uri uri);
-
-  /** Sets the old controller to be reused if possible. */
-  public SimpleDraweeControllerBuilder setOldController(@Nullable DraweeController oldController);
-
-  /** Builds the specified controller. */
-  public DraweeController build();
+    /**
+     * Sets the caller context.
+     */
+    public SimpleDraweeControllerBuilder setCallerContext(Object callerContext);
+
+    /**
+     * Sets the uri.
+     */
+    public SimpleDraweeControllerBuilder setUri(Uri uri);
+
+    /**
+     * Sets the old controller to be reused if possible.
+     */
+    public SimpleDraweeControllerBuilder setOldController(@Nullable DraweeController oldController);
+
+    /**
+     * Builds the specified controller.
+     */
+    public DraweeController build();
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/view/AspectRatioMeasure.java b/drawee/src/main/java/com/facebook/drawee/view/AspectRatioMeasure.java
index e145c60c0..88f996e5f 100644
--- a/drawee/src/main/java/com/facebook/drawee/view/AspectRatioMeasure.java
+++ b/drawee/src/main/java/com/facebook/drawee/view/AspectRatioMeasure.java
@@ -17,60 +17,60 @@
  */
 public class AspectRatioMeasure {
 
-  /**
-   * Holder for width and height measure specs.
-   */
-  public static class Spec {
-    public int width;
-    public int height;
-  }
-
-  /**
-   * Updates the given measure spec with respect to the aspect ratio.
-   *
-   * <p>Note: Measure spec is not changed if the aspect ratio is not greater than zero.
-   *
-   * <p>Measure spec of the layout dimension (width or height) specified as "0dp" is updated
-   * to match the measure spec of the other dimension adjusted by the aspect ratio. Exactly one
-   * layout dimension should be specified as "0dp".
-   *
-   * <p>Padding is taken into account so that the aspect ratio refers to the content without
-   * padding: {@code aspectRatio == (viewWidth - widthPadding) / (viewHeight - heightPadding)}
-   *
-   * <p>Updated measure spec respects the parent's constraints. I.e. measure spec is not changed
-   * if the parent has specified mode {@code EXACTLY}, and it doesn't exceed measure size if parent
-   * has specified mode {@code AT_MOST}.
-   *
-   * @param spec in/out measure spec to be updated
-   * @param aspectRatio desired aspect ratio
-   * @param layoutParams view's layout params
-   * @param widthPadding view's left + right padding
-   * @param heightPadding view's top + bottom padding
-   */
-  public static void updateMeasureSpec(
-      Spec spec,
-      float aspectRatio,
-      ViewGroup.LayoutParams layoutParams,
-      int widthPadding,
-      int heightPadding) {
-    if (aspectRatio <= 0) {
-      return;
+    /**
+     * Holder for width and height measure specs.
+     */
+    public static class Spec {
+        public int width;
+        public int height;
     }
-    if (shouldAdjust(layoutParams.height)) {
-      int widthSpecSize = View.MeasureSpec.getSize(spec.width);
-      int desiredHeight = (int) ((widthSpecSize - widthPadding) / aspectRatio + heightPadding);
-      int resolvedHeight = View.resolveSize(desiredHeight, spec.height);
-      spec.height = View.MeasureSpec.makeMeasureSpec(resolvedHeight, View.MeasureSpec.EXACTLY);
-    } else if (shouldAdjust(layoutParams.width)) {
-      int heightSpecSize = View.MeasureSpec.getSize(spec.height);
-      int desiredWidth = (int) ((heightSpecSize - heightPadding) * aspectRatio + widthPadding);
-      int resolvedWidth = View.resolveSize(desiredWidth, spec.width);
-      spec.width = View.MeasureSpec.makeMeasureSpec(resolvedWidth, View.MeasureSpec.EXACTLY);
+
+    /**
+     * Updates the given measure spec with respect to the aspect ratio.
+     * <p>
+     * <p>Note: Measure spec is not changed if the aspect ratio is not greater than zero.
+     * <p>
+     * <p>Measure spec of the layout dimension (width or height) specified as "0dp" is updated
+     * to match the measure spec of the other dimension adjusted by the aspect ratio. Exactly one
+     * layout dimension should be specified as "0dp".
+     * <p>
+     * <p>Padding is taken into account so that the aspect ratio refers to the content without
+     * padding: {@code aspectRatio == (viewWidth - widthPadding) / (viewHeight - heightPadding)}
+     * <p>
+     * <p>Updated measure spec respects the parent's constraints. I.e. measure spec is not changed
+     * if the parent has specified mode {@code EXACTLY}, and it doesn't exceed measure size if parent
+     * has specified mode {@code AT_MOST}.
+     *
+     * @param spec          in/out measure spec to be updated
+     * @param aspectRatio   desired aspect ratio
+     * @param layoutParams  view's layout params
+     * @param widthPadding  view's left + right padding
+     * @param heightPadding view's top + bottom padding
+     */
+    public static void updateMeasureSpec(
+            Spec spec,
+            float aspectRatio,
+            ViewGroup.LayoutParams layoutParams,
+            int widthPadding,
+            int heightPadding) {
+        if (aspectRatio <= 0) {
+            return;
+        }
+        if (shouldAdjust(layoutParams.height)) {
+            int widthSpecSize = View.MeasureSpec.getSize(spec.width);
+            int desiredHeight = (int) ((widthSpecSize - widthPadding) / aspectRatio + heightPadding);
+            int resolvedHeight = View.resolveSize(desiredHeight, spec.height);
+            spec.height = View.MeasureSpec.makeMeasureSpec(resolvedHeight, View.MeasureSpec.EXACTLY);
+        } else if (shouldAdjust(layoutParams.width)) {
+            int heightSpecSize = View.MeasureSpec.getSize(spec.height);
+            int desiredWidth = (int) ((heightSpecSize - heightPadding) * aspectRatio + widthPadding);
+            int resolvedWidth = View.resolveSize(desiredWidth, spec.width);
+            spec.width = View.MeasureSpec.makeMeasureSpec(resolvedWidth, View.MeasureSpec.EXACTLY);
+        }
     }
-  }
 
-  private static boolean shouldAdjust(int layoutDimension) {
-    // Note: wrap_content is supported for backwards compatibility, but should not be used.
-    return layoutDimension == 0 || layoutDimension == ViewGroup.LayoutParams.WRAP_CONTENT;
-  }
+    private static boolean shouldAdjust(int layoutDimension) {
+        // Note: wrap_content is supported for backwards compatibility, but should not be used.
+        return layoutDimension == 0 || layoutDimension == ViewGroup.LayoutParams.WRAP_CONTENT;
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/view/DraweeHolder.java b/drawee/src/main/java/com/facebook/drawee/view/DraweeHolder.java
index a944b0a46..9f72ab282 100644
--- a/drawee/src/main/java/com/facebook/drawee/view/DraweeHolder.java
+++ b/drawee/src/main/java/com/facebook/drawee/view/DraweeHolder.java
@@ -33,16 +33,16 @@
 
 /**
  * A holder class for Drawee controller and hierarchy.
- *
+ * <p>
  * <p>Drawee users, should, as a rule, use {@link DraweeView} or its subclasses. There are
  * situations where custom views are required, however, and this class is for those circumstances.
- *
+ * <p>
  * <p>Each {@link DraweeHierarchy} object should be contained in a single instance of this
  * class.
- *
+ * <p>
  * <p>Users of this class must call {@link Drawable#setBounds} on the top-level drawable
  * of the DraweeHierarchy. Otherwise the drawable will not be drawn.
- *
+ * <p>
  * <p>The containing view must also call {@link #onDetach()} from its
  * {@link View#onStartTemporaryDetach()} and {@link View#onDetachedFromWindow()} methods. It must
  * call {@link #onAttach} from its {@link View#onFinishTemporaryDetach()} and
@@ -50,260 +50,263 @@
  */
 public class DraweeHolder<DH extends DraweeHierarchy> implements VisibilityCallback {
 
-  private boolean mIsControllerAttached = false;
-  private boolean mIsHolderAttached = false;
-  private boolean mIsVisible = true;
-  private boolean mIsActivityStarted = true;
-  private DH mHierarchy;
-  private DraweeController mController = null;
-  private final ActivityListener mActivityListener;
-  private final DraweeEventTracker mEventTracker = new DraweeEventTracker();
-
-  /**
-   * Creates a new instance of DraweeHolder that detaches / attaches controller whenever context
-   * notifies it about activity's onStop and onStart callbacks.
-   *
-   * <p>It is strongly recommended to pass a {@link ListenableActivity} as context. The holder will
-   * then also be able to respond to onStop and onStart events from that activity, making sure the
-   * image does not waste memory when the activity is stopped.
-   */
-  public static <DH extends DraweeHierarchy> DraweeHolder<DH> create(
-      @Nullable DH hierarchy,
-      Context context) {
-    DraweeHolder<DH> holder = new DraweeHolder<DH>(hierarchy);
-    holder.registerWithContext(context);
-    return holder;
-  }
+    private boolean mIsControllerAttached = false;
+    private boolean mIsHolderAttached = false;
+    private boolean mIsVisible = true;
+    private boolean mIsActivityStarted = true;
+    private DH mHierarchy;
+    private DraweeController mController = null;
+    private final ActivityListener mActivityListener;
+    private final DraweeEventTracker mEventTracker = new DraweeEventTracker();
 
-  /**
-   * If the given context is an instance of FbListenableActivity, then listener for its onStop and
-   * onStart methods is registered that changes visibility of the holder.
-   */
-  public void registerWithContext(Context context) {
-    // TODO(T6181423): this is not working reliably and we cannot afford photos-not-loading issues.
-    //ActivityListenerManager.register(mActivityListener, context);
-  }
-
-  /**
-   * Creates a new instance of DraweeHolder.
-   * @param hierarchy
-   */
-  public DraweeHolder(@Nullable DH hierarchy) {
-    if (hierarchy != null) {
-      setHierarchy(hierarchy);
+    /**
+     * Creates a new instance of DraweeHolder that detaches / attaches controller whenever context
+     * notifies it about activity's onStop and onStart callbacks.
+     * <p>
+     * <p>It is strongly recommended to pass a {@link ListenableActivity} as context. The holder will
+     * then also be able to respond to onStop and onStart events from that activity, making sure the
+     * image does not waste memory when the activity is stopped.
+     */
+    public static <DH extends DraweeHierarchy> DraweeHolder<DH> create(
+            @Nullable DH hierarchy,
+            Context context) {
+        DraweeHolder<DH> holder = new DraweeHolder<DH>(hierarchy);
+        holder.registerWithContext(context);
+        return holder;
     }
-    mActivityListener = new BaseActivityListener() {
-      @Override
-      public void onStart(Activity activity) {
-        setActivityStarted(true);
-      }
-
-      @Override
-      public void onStop(Activity activity) {
-        setActivityStarted(false);
-      }
-    };
-  }
 
-  /**
-   * Gets the controller ready to display the image.
-   *
-   * <p>The containing view must call this method from both {@link View#onFinishTemporaryDetach()}
-   * and {@link View#onAttachedToWindow()}.
-   */
-  public void onAttach() {
-    mEventTracker.recordEvent(Event.ON_HOLDER_ATTACH);
-    mIsHolderAttached = true;
-    attachOrDetachController();
-  }
+    /**
+     * If the given context is an instance of FbListenableActivity, then listener for its onStop and
+     * onStart methods is registered that changes visibility of the holder.
+     */
+    public void registerWithContext(Context context) {
+        // TODO(T6181423): this is not working reliably and we cannot afford photos-not-loading issues.
+        //ActivityListenerManager.register(mActivityListener, context);
+    }
 
-  /**
-   * Releases resources used to display the image.
-   *
-   * <p>The containing view must call this method from both {@link View#onStartTemporaryDetach()}
-   * and {@link View#onDetachedFromWindow()}.
-   */
-  public void onDetach() {
-    mEventTracker.recordEvent(Event.ON_HOLDER_DETACH);
-    mIsHolderAttached = false;
-    attachOrDetachController();
-  }
+    /**
+     * Creates a new instance of DraweeHolder.
+     *
+     * @param hierarchy
+     */
+    public DraweeHolder(@Nullable DH hierarchy) {
+        if (hierarchy != null) {
+            setHierarchy(hierarchy);
+        }
+        mActivityListener = new BaseActivityListener() {
+            @Override
+            public void onStart(Activity activity) {
+                setActivityStarted(true);
+            }
 
-  /**
-   * Forwards the touch event to the controller.
-   * @param event touch event to handle
-   * @return whether the event was handled or not
-   */
-  public boolean onTouchEvent(MotionEvent event) {
-    if (mController == null) {
-      return false;
+            @Override
+            public void onStop(Activity activity) {
+                setActivityStarted(false);
+            }
+        };
     }
-    return mController.onTouchEvent(event);
-  }
 
-  /**
-   * Callback used to notify about top-level-drawable's visibility changes.
-   */
-  @Override
-  public void onVisibilityChange(boolean isVisible) {
-    if (mIsVisible == isVisible) {
-      return;
+    /**
+     * Gets the controller ready to display the image.
+     * <p>
+     * <p>The containing view must call this method from both {@link View#onFinishTemporaryDetach()}
+     * and {@link View#onAttachedToWindow()}.
+     */
+    public void onAttach() {
+        mEventTracker.recordEvent(Event.ON_HOLDER_ATTACH);
+        mIsHolderAttached = true;
+        attachOrDetachController();
     }
-    mEventTracker.recordEvent(isVisible ? Event.ON_DRAWABLE_SHOW : Event.ON_DRAWABLE_HIDE);
-    mIsVisible = isVisible;
-    attachOrDetachController();
-  }
 
-  /**
-   * Callback used to notify about top-level-drawable being drawn.
-   */
-  @Override
-  public void onDraw() {
-    // draw is only expected if the controller is attached
-    if (mIsControllerAttached) {
-      return;
+    /**
+     * Releases resources used to display the image.
+     * <p>
+     * <p>The containing view must call this method from both {@link View#onStartTemporaryDetach()}
+     * and {@link View#onDetachedFromWindow()}.
+     */
+    public void onDetach() {
+        mEventTracker.recordEvent(Event.ON_HOLDER_DETACH);
+        mIsHolderAttached = false;
+        attachOrDetachController();
     }
-    // something went wrong here; controller is not attached, yet the hierarchy has to be drawn
-    // log error and attach the controller
-    FLog.wtf(
-        DraweeEventTracker.class,
-        "%x: Draw requested for a non-attached controller %x. %s",
-        System.identityHashCode(this),
-        System.identityHashCode(mController),
-        toString());
-    mIsHolderAttached = true;
-    mIsVisible = true;
-    mIsActivityStarted = true;
-    attachOrDetachController();
-  }
 
-  /**
-   * Sets the visibility callback to the current top-level-drawable.
-   */
-  private void setVisibilityCallback(@Nullable VisibilityCallback visibilityCallback) {
-    Drawable drawable = getTopLevelDrawable();
-    if (drawable instanceof VisibilityAwareDrawable) {
-      ((VisibilityAwareDrawable) drawable).setVisibilityCallback(visibilityCallback);
+    /**
+     * Forwards the touch event to the controller.
+     *
+     * @param event touch event to handle
+     * @return whether the event was handled or not
+     */
+    public boolean onTouchEvent(MotionEvent event) {
+        if (mController == null) {
+            return false;
+        }
+        return mController.onTouchEvent(event);
     }
-  }
-
-  /**
-   * Notifies the holder of activity's visibility change
-   */
-  private void setActivityStarted(boolean isStarted) {
-    mEventTracker.recordEvent(isStarted ? Event.ON_ACTIVITY_START : Event.ON_ACTIVITY_STOP);
-    mIsActivityStarted = isStarted;
-    attachOrDetachController();
-  }
 
-  /**
-   * Sets a new controller.
-   */
-  public void setController(@Nullable DraweeController draweeController) {
-    boolean wasAttached = mIsControllerAttached;
-    if (wasAttached) {
-      detachController();
+    /**
+     * Callback used to notify about top-level-drawable's visibility changes.
+     */
+    @Override
+    public void onVisibilityChange(boolean isVisible) {
+        if (mIsVisible == isVisible) {
+            return;
+        }
+        mEventTracker.recordEvent(isVisible ? Event.ON_DRAWABLE_SHOW : Event.ON_DRAWABLE_HIDE);
+        mIsVisible = isVisible;
+        attachOrDetachController();
     }
 
-    // Clear the old controller
-    if (mController != null) {
-      mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);
-      mController.setHierarchy(null);
+    /**
+     * Callback used to notify about top-level-drawable being drawn.
+     */
+    @Override
+    public void onDraw() {
+        // draw is only expected if the controller is attached
+        if (mIsControllerAttached) {
+            return;
+        }
+        // something went wrong here; controller is not attached, yet the hierarchy has to be drawn
+        // log error and attach the controller
+        FLog.wtf(
+                DraweeEventTracker.class,
+                "%x: Draw requested for a non-attached controller %x. %s",
+                System.identityHashCode(this),
+                System.identityHashCode(mController),
+                toString());
+        mIsHolderAttached = true;
+        mIsVisible = true;
+        mIsActivityStarted = true;
+        attachOrDetachController();
     }
-    mController = draweeController;
-    if (mController != null) {
-      mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);
-      mController.setHierarchy(mHierarchy);
-    } else {
-      mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);
+
+    /**
+     * Sets the visibility callback to the current top-level-drawable.
+     */
+    private void setVisibilityCallback(@Nullable VisibilityCallback visibilityCallback) {
+        Drawable drawable = getTopLevelDrawable();
+        if (drawable instanceof VisibilityAwareDrawable) {
+            ((VisibilityAwareDrawable) drawable).setVisibilityCallback(visibilityCallback);
+        }
     }
 
-    if (wasAttached) {
-      attachController();
+    /**
+     * Notifies the holder of activity's visibility change
+     */
+    private void setActivityStarted(boolean isStarted) {
+        mEventTracker.recordEvent(isStarted ? Event.ON_ACTIVITY_START : Event.ON_ACTIVITY_STOP);
+        mIsActivityStarted = isStarted;
+        attachOrDetachController();
     }
-  }
 
-  /**
-   * Gets the controller if set, null otherwise.
-   */
-  @Nullable public DraweeController getController() {
-    return mController;
-  }
+    /**
+     * Sets a new controller.
+     */
+    public void setController(@Nullable DraweeController draweeController) {
+        boolean wasAttached = mIsControllerAttached;
+        if (wasAttached) {
+            detachController();
+        }
+
+        // Clear the old controller
+        if (mController != null) {
+            mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);
+            mController.setHierarchy(null);
+        }
+        mController = draweeController;
+        if (mController != null) {
+            mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);
+            mController.setHierarchy(mHierarchy);
+        } else {
+            mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);
+        }
 
-  /**
-   * Sets the drawee hierarchy.
-   */
-  public void setHierarchy(DH hierarchy) {
-    mEventTracker.recordEvent(Event.ON_SET_HIERARCHY);
-    setVisibilityCallback(null);
-    mHierarchy = Preconditions.checkNotNull(hierarchy);
-    onVisibilityChange(mHierarchy.getTopLevelDrawable().isVisible());
-    setVisibilityCallback(this);
-    if (mController != null) {
-      mController.setHierarchy(hierarchy);
+        if (wasAttached) {
+            attachController();
+        }
     }
-  }
 
-  /**
-   * Gets the drawee hierarchy if set, throws NPE otherwise.
-   */
-  public DH getHierarchy() {
-    return Preconditions.checkNotNull(mHierarchy);
-  }
+    /**
+     * Gets the controller if set, null otherwise.
+     */
+    @Nullable
+    public DraweeController getController() {
+        return mController;
+    }
 
-  /**
-   * Returns whether the hierarchy is set or not.
-   */
-  public boolean hasHierarchy() {
-    return mHierarchy != null;
-  }
+    /**
+     * Sets the drawee hierarchy.
+     */
+    public void setHierarchy(DH hierarchy) {
+        mEventTracker.recordEvent(Event.ON_SET_HIERARCHY);
+        setVisibilityCallback(null);
+        mHierarchy = Preconditions.checkNotNull(hierarchy);
+        onVisibilityChange(mHierarchy.getTopLevelDrawable().isVisible());
+        setVisibilityCallback(this);
+        if (mController != null) {
+            mController.setHierarchy(hierarchy);
+        }
+    }
 
-  /**
-   * Gets the top-level drawable if hierarchy is set, null otherwise.
-   */
-  public Drawable getTopLevelDrawable() {
-    return mHierarchy == null ? null : mHierarchy.getTopLevelDrawable();
-  }
+    /**
+     * Gets the drawee hierarchy if set, throws NPE otherwise.
+     */
+    public DH getHierarchy() {
+        return Preconditions.checkNotNull(mHierarchy);
+    }
 
-  private void attachController() {
-    if (mIsControllerAttached) {
-      return;
+    /**
+     * Returns whether the hierarchy is set or not.
+     */
+    public boolean hasHierarchy() {
+        return mHierarchy != null;
     }
-    mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);
-    mIsControllerAttached = true;
-    if (mController != null &&
-        mController.getHierarchy() != null) {
-      mController.onAttach();
+
+    /**
+     * Gets the top-level drawable if hierarchy is set, null otherwise.
+     */
+    public Drawable getTopLevelDrawable() {
+        return mHierarchy == null ? null : mHierarchy.getTopLevelDrawable();
     }
-  }
 
-  private void detachController() {
-    if (!mIsControllerAttached) {
-      return;
+    private void attachController() {
+        if (mIsControllerAttached) {
+            return;
+        }
+        mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);
+        mIsControllerAttached = true;
+        if (mController != null &&
+                mController.getHierarchy() != null) {
+            mController.onAttach();
+        }
     }
-    mEventTracker.recordEvent(Event.ON_DETACH_CONTROLLER);
-    mIsControllerAttached = false;
-    if (mController != null) {
-      mController.onDetach();
+
+    private void detachController() {
+        if (!mIsControllerAttached) {
+            return;
+        }
+        mEventTracker.recordEvent(Event.ON_DETACH_CONTROLLER);
+        mIsControllerAttached = false;
+        if (mController != null) {
+            mController.onDetach();
+        }
     }
-  }
 
-  private void attachOrDetachController() {
-    if (mIsHolderAttached && mIsVisible && mIsActivityStarted) {
-      attachController();
-    } else {
-      detachController();
+    private void attachOrDetachController() {
+        if (mIsHolderAttached && mIsVisible && mIsActivityStarted) {
+            attachController();
+        } else {
+            detachController();
+        }
     }
-  }
 
-  @Override
-  public String toString() {
-    return Objects.toStringHelper(this)
-        .add("controllerAttached", mIsControllerAttached)
-        .add("holderAttached", mIsHolderAttached)
-        .add("drawableVisible", mIsVisible)
-        .add("activityStarted", mIsActivityStarted)
-        .add("events", mEventTracker.toString())
-        .toString();
-  }
+    @Override
+    public String toString() {
+        return Objects.toStringHelper(this)
+                .add("controllerAttached", mIsControllerAttached)
+                .add("holderAttached", mIsHolderAttached)
+                .add("drawableVisible", mIsVisible)
+                .add("activityStarted", mIsActivityStarted)
+                .add("events", mEventTracker.toString())
+                .toString();
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/view/DraweeView.java b/drawee/src/main/java/com/facebook/drawee/view/DraweeView.java
index 920076690..cc2f6585b 100644
--- a/drawee/src/main/java/com/facebook/drawee/view/DraweeView.java
+++ b/drawee/src/main/java/com/facebook/drawee/view/DraweeView.java
@@ -25,13 +25,13 @@
 
 /**
  * View that displays a {@link DraweeHierarchy}.
- *
+ * <p>
  * <p> Hierarchy should be set prior to using this view. See {@code setHierarchy}. Because creating
  * a hierarchy is an expensive operation, it is recommended this be done once per view, typically
  * near creation time.
- *
+ * <p>
  * <p> In order to display an image, controller has to be set. See {@code setController}.
-
+ * <p>
  * <p> Although ImageView is subclassed instead of subclassing View directly, this class does not
  * support ImageView's setImageXxx, setScaleType and similar methods. Extending ImageView is a short
  * term solution in order to inherit some of its implementation (padding calculations, etc.).
@@ -40,144 +40,164 @@
  */
 public class DraweeView<DH extends DraweeHierarchy> extends ImageView {
 
-  private DraweeHolder<DH> mDraweeHolder;
-
-  public DraweeView(Context context) {
-    super(context);
-    init(context);
-  }
-
-  public DraweeView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-    init(context);
-  }
-
-  public DraweeView(Context context, AttributeSet attrs, int defStyle) {
-    super(context, attrs, defStyle);
-    init(context);
-  }
-
-  private void init(Context context) {
-    mDraweeHolder = DraweeHolder.create(null, context);
-  }
-
-  /** Sets the hierarchy. */
-  public void setHierarchy(DH hierarchy) {
-    mDraweeHolder.setHierarchy(hierarchy);
-    super.setImageDrawable(mDraweeHolder.getTopLevelDrawable());
-  }
-
-  /** Gets the hierarchy if set, throws NPE otherwise. */
-  public DH getHierarchy() {
-    return mDraweeHolder.getHierarchy();
-  }
-
-  /** Returns whether the hierarchy is set or not. */
-  public boolean hasHierarchy() {
-    return mDraweeHolder.hasHierarchy();
-  }
-
-  /** Gets the top-level drawable if hierarchy is set, null otherwise. */
-  @Nullable public Drawable getTopLevelDrawable() {
-    return mDraweeHolder.getTopLevelDrawable();
-  }
-
-  /** Sets the controller. */
-  public void setController(@Nullable DraweeController draweeController) {
-    mDraweeHolder.setController(draweeController);
-    super.setImageDrawable(mDraweeHolder.getTopLevelDrawable());
-  }
-
-  /** Gets the controller if set, null otherwise. */
-  @Nullable public DraweeController getController() {
-    return mDraweeHolder.getController();
-  }
-
-  /** Returns whether the controller is set or not.  */
-  public boolean hasController() {
-    return mDraweeHolder.getController() != null;
-  }
-
-  @Override
-  protected void onAttachedToWindow() {
-    super.onAttachedToWindow();
-    mDraweeHolder.onAttach();
-  }
-
-  @Override
-  protected void onDetachedFromWindow() {
-    super.onDetachedFromWindow();
-    mDraweeHolder.onDetach();
-  }
-
-  @Override
-  public void onStartTemporaryDetach() {
-    super.onStartTemporaryDetach();
-    mDraweeHolder.onDetach();
-  }
-
-  @Override
-  public void onFinishTemporaryDetach() {
-    super.onFinishTemporaryDetach();
-    mDraweeHolder.onAttach();
-  }
-
-  @Override
-  public boolean onTouchEvent(MotionEvent event) {
-    if (mDraweeHolder.onTouchEvent(event)) {
-      return true;
-    }
-    return super.onTouchEvent(event);
-  }
-
-  /**
-   * Use this method only when using this class as an ordinary ImageView.
-   * @deprecated Use {@link #setController(DraweeController)} instead.
-   */
-  @Override
-  @Deprecated
-  public void setImageDrawable(Drawable drawable) {
-    mDraweeHolder.setController(null);
-    super.setImageDrawable(drawable);
-  }
-
-  /**
-   * Use this method only when using this class as an ordinary ImageView.
-   * @deprecated Use {@link #setController(DraweeController)} instead.
-   */
-  @Override
-  @Deprecated
-  public void setImageBitmap(Bitmap bm) {
-    mDraweeHolder.setController(null);
-    super.setImageBitmap(bm);
-  }
-
-  /**
-   * Use this method only when using this class as an ordinary ImageView.
-   * @deprecated Use {@link #setController(DraweeController)} instead.
-   */
-  @Override
-  @Deprecated
-  public void setImageResource(int resId) {
-    mDraweeHolder.setController(null);
-    super.setImageResource(resId);
-  }
-
-  /**
-   * Use this method only when using this class as an ordinary ImageView.
-   * @deprecated Use {@link #setController(DraweeController)} instead.
-   */
-  @Override
-  @Deprecated
-  public void setImageURI(Uri uri) {
-    mDraweeHolder.setController(null);
-    super.setImageURI(uri);
-  }
-
-  @Override
-  public String toString() {
-    return Objects.toStringHelper(this)
-        .add("holder", mDraweeHolder.toString())
-        .toString();
-  }
+    private DraweeHolder<DH> mDraweeHolder;
+
+    public DraweeView(Context context) {
+        super(context);
+        init(context);
+    }
+
+    public DraweeView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context);
+    }
+
+    public DraweeView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init(context);
+    }
+
+    private void init(Context context) {
+        mDraweeHolder = DraweeHolder.create(null, context);
+    }
+
+    /**
+     * Sets the hierarchy.
+     */
+    public void setHierarchy(DH hierarchy) {
+        mDraweeHolder.setHierarchy(hierarchy);
+        super.setImageDrawable(mDraweeHolder.getTopLevelDrawable());
+    }
+
+    /**
+     * Gets the hierarchy if set, throws NPE otherwise.
+     */
+    public DH getHierarchy() {
+        return mDraweeHolder.getHierarchy();
+    }
+
+    /**
+     * Returns whether the hierarchy is set or not.
+     */
+    public boolean hasHierarchy() {
+        return mDraweeHolder.hasHierarchy();
+    }
+
+    /**
+     * Gets the top-level drawable if hierarchy is set, null otherwise.
+     */
+    @Nullable
+    public Drawable getTopLevelDrawable() {
+        return mDraweeHolder.getTopLevelDrawable();
+    }
+
+    /**
+     * Sets the controller.
+     */
+    public void setController(@Nullable DraweeController draweeController) {
+        mDraweeHolder.setController(draweeController);
+        super.setImageDrawable(mDraweeHolder.getTopLevelDrawable());
+    }
+
+    /**
+     * Gets the controller if set, null otherwise.
+     */
+    @Nullable
+    public DraweeController getController() {
+        return mDraweeHolder.getController();
+    }
+
+    /**
+     * Returns whether the controller is set or not.
+     */
+    public boolean hasController() {
+        return mDraweeHolder.getController() != null;
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        mDraweeHolder.onAttach();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        mDraweeHolder.onDetach();
+    }
+
+    @Override
+    public void onStartTemporaryDetach() {
+        super.onStartTemporaryDetach();
+        mDraweeHolder.onDetach();
+    }
+
+    @Override
+    public void onFinishTemporaryDetach() {
+        super.onFinishTemporaryDetach();
+        mDraweeHolder.onAttach();
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (mDraweeHolder.onTouchEvent(event)) {
+            return true;
+        }
+        return super.onTouchEvent(event);
+    }
+
+    /**
+     * Use this method only when using this class as an ordinary ImageView.
+     *
+     * @deprecated Use {@link #setController(DraweeController)} instead.
+     */
+    @Override
+    @Deprecated
+    public void setImageDrawable(Drawable drawable) {
+        mDraweeHolder.setController(null);
+        super.setImageDrawable(drawable);
+    }
+
+    /**
+     * Use this method only when using this class as an ordinary ImageView.
+     *
+     * @deprecated Use {@link #setController(DraweeController)} instead.
+     */
+    @Override
+    @Deprecated
+    public void setImageBitmap(Bitmap bm) {
+        mDraweeHolder.setController(null);
+        super.setImageBitmap(bm);
+    }
+
+    /**
+     * Use this method only when using this class as an ordinary ImageView.
+     *
+     * @deprecated Use {@link #setController(DraweeController)} instead.
+     */
+    @Override
+    @Deprecated
+    public void setImageResource(int resId) {
+        mDraweeHolder.setController(null);
+        super.setImageResource(resId);
+    }
+
+    /**
+     * Use this method only when using this class as an ordinary ImageView.
+     *
+     * @deprecated Use {@link #setController(DraweeController)} instead.
+     */
+    @Override
+    @Deprecated
+    public void setImageURI(Uri uri) {
+        mDraweeHolder.setController(null);
+        super.setImageURI(uri);
+    }
+
+    @Override
+    public String toString() {
+        return Objects.toStringHelper(this)
+                .add("holder", mDraweeHolder.toString())
+                .toString();
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/view/GenericDraweeView.java b/drawee/src/main/java/com/facebook/drawee/view/GenericDraweeView.java
index 37ef62393..941b77e05 100644
--- a/drawee/src/main/java/com/facebook/drawee/view/GenericDraweeView.java
+++ b/drawee/src/main/java/com/facebook/drawee/view/GenericDraweeView.java
@@ -26,8 +26,9 @@
 
 /**
  * DraweeView that creates GenericDraweeHierarchy based on XML attributes.
- *
+ * <p>
  * Fading animation parameters:
+ *
  * @attr ref com.facebook.R.styleable#GenericDraweeView_fadeDuration
  * Images & scale types parameters:
  * @attr ref com.facebook.R.styleable#GenericDraweeView_viewAspectRatio
@@ -57,272 +58,271 @@
  */
 public class GenericDraweeView extends DraweeView<GenericDraweeHierarchy> {
 
-  private float mAspectRatio = 0;
-  private final AspectRatioMeasure.Spec mMeasureSpec = new AspectRatioMeasure.Spec();
+    private float mAspectRatio = 0;
+    private final AspectRatioMeasure.Spec mMeasureSpec = new AspectRatioMeasure.Spec();
 
-  public GenericDraweeView(Context context, GenericDraweeHierarchy hierarchy) {
-    super(context);
-    setHierarchy(hierarchy);
-  }
+    public GenericDraweeView(Context context, GenericDraweeHierarchy hierarchy) {
+        super(context);
+        setHierarchy(hierarchy);
+    }
 
-  public GenericDraweeView(Context context) {
-    super(context);
-    inflateHierarchy(context, null);
-  }
+    public GenericDraweeView(Context context) {
+        super(context);
+        inflateHierarchy(context, null);
+    }
 
-  public GenericDraweeView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-    inflateHierarchy(context, attrs);
-  }
+    public GenericDraweeView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        inflateHierarchy(context, attrs);
+    }
 
-  public GenericDraweeView(Context context, AttributeSet attrs, int defStyle) {
-    super(context, attrs, defStyle);
-    inflateHierarchy(context, attrs);
-  }
+    public GenericDraweeView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        inflateHierarchy(context, attrs);
+    }
 
-  private void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {
-    Resources resources = context.getResources();
+    private void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {
+        Resources resources = context.getResources();
 
-    // fading animation defaults
-    int fadeDuration = GenericDraweeHierarchyBuilder.DEFAULT_FADE_DURATION;
-    // images & scale types defaults
-    int placeholderId = 0;
-    ScalingUtils.ScaleType placeholderScaleType
-        = GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
-    int retryImageId = 0;
-    ScalingUtils.ScaleType retryImageScaleType =
-        GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
-    int failureImageId = 0;
-    ScalingUtils.ScaleType failureImageScaleType =
-        GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
-    int progressBarId = 0;
-    ScalingUtils.ScaleType progressBarScaleType =
-        GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
-    ScalingUtils.ScaleType actualImageScaleType =
-        GenericDraweeHierarchyBuilder.DEFAULT_ACTUAL_IMAGE_SCALE_TYPE;
-    int backgroundId = 0;
-    int overlayId = 0;
-    int pressedStateOverlayId = 0;
-    // rounding defaults
-    boolean roundAsCircle = false;
-    int roundedCornerRadius = 0;
-    boolean roundTopLeft = true;
-    boolean roundTopRight = true;
-    boolean roundBottomRight = true;
-    boolean roundBottomLeft = true;
-    int roundWithOverlayColor = 0;
-    int roundingBorderWidth = 0;
-    int roundingBorderColor = 0;
-    int progressBarAutoRotateInterval = 0;
+        // fading animation defaults
+        int fadeDuration = GenericDraweeHierarchyBuilder.DEFAULT_FADE_DURATION;
+        // images & scale types defaults
+        int placeholderId = 0;
+        ScalingUtils.ScaleType placeholderScaleType
+                = GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
+        int retryImageId = 0;
+        ScalingUtils.ScaleType retryImageScaleType =
+                GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
+        int failureImageId = 0;
+        ScalingUtils.ScaleType failureImageScaleType =
+                GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
+        int progressBarId = 0;
+        ScalingUtils.ScaleType progressBarScaleType =
+                GenericDraweeHierarchyBuilder.DEFAULT_SCALE_TYPE;
+        ScalingUtils.ScaleType actualImageScaleType =
+                GenericDraweeHierarchyBuilder.DEFAULT_ACTUAL_IMAGE_SCALE_TYPE;
+        int backgroundId = 0;
+        int overlayId = 0;
+        int pressedStateOverlayId = 0;
+        // rounding defaults
+        boolean roundAsCircle = false;
+        int roundedCornerRadius = 0;
+        boolean roundTopLeft = true;
+        boolean roundTopRight = true;
+        boolean roundBottomRight = true;
+        boolean roundBottomLeft = true;
+        int roundWithOverlayColor = 0;
+        int roundingBorderWidth = 0;
+        int roundingBorderColor = 0;
+        int progressBarAutoRotateInterval = 0;
 
 
-    if (attrs != null) {
-      TypedArray gdhAttrs = context.obtainStyledAttributes(
-          attrs,
-          R.styleable.GenericDraweeView);
-      try {
-        // fade duration
-        fadeDuration = gdhAttrs.getInt(
-            R.styleable.GenericDraweeView_fadeDuration,
-            fadeDuration);
+        if (attrs != null) {
+            TypedArray gdhAttrs = context.obtainStyledAttributes(
+                    attrs,
+                    R.styleable.GenericDraweeView);
+            try {
+                // fade duration
+                fadeDuration = gdhAttrs.getInt(
+                        R.styleable.GenericDraweeView_fadeDuration,
+                        fadeDuration);
 
-        // aspect ratio
-        mAspectRatio = gdhAttrs.getFloat(
-            R.styleable.GenericDraweeView_viewAspectRatio,
-            mAspectRatio);
+                // aspect ratio
+                mAspectRatio = gdhAttrs.getFloat(
+                        R.styleable.GenericDraweeView_viewAspectRatio,
+                        mAspectRatio);
 
-        // placeholder image
-        placeholderId = gdhAttrs.getResourceId(
-            R.styleable.GenericDraweeView_placeholderImage,
-            placeholderId);
-        // placeholder image scale type
-        placeholderScaleType = getScaleTypeFromXml(
-            gdhAttrs,
-            R.styleable.GenericDraweeView_placeholderImageScaleType,
-            placeholderScaleType);
+                // placeholder image
+                placeholderId = gdhAttrs.getResourceId(
+                        R.styleable.GenericDraweeView_placeholderImage,
+                        placeholderId);
+                // placeholder image scale type
+                placeholderScaleType = getScaleTypeFromXml(
+                        gdhAttrs,
+                        R.styleable.GenericDraweeView_placeholderImageScaleType,
+                        placeholderScaleType);
 
-        // retry image
-        retryImageId = gdhAttrs.getResourceId(
-            R.styleable.GenericDraweeView_retryImage,
-            retryImageId);
-        // retry image scale type
-        retryImageScaleType = getScaleTypeFromXml(
-            gdhAttrs,
-            R.styleable.GenericDraweeView_retryImageScaleType,
-            retryImageScaleType);
+                // retry image
+                retryImageId = gdhAttrs.getResourceId(
+                        R.styleable.GenericDraweeView_retryImage,
+                        retryImageId);
+                // retry image scale type
+                retryImageScaleType = getScaleTypeFromXml(
+                        gdhAttrs,
+                        R.styleable.GenericDraweeView_retryImageScaleType,
+                        retryImageScaleType);
 
-        // failure image
-        failureImageId = gdhAttrs.getResourceId(
-            R.styleable.GenericDraweeView_failureImage,
-            failureImageId);
-        // failure image scale type
-        failureImageScaleType = getScaleTypeFromXml(
-            gdhAttrs,
-            R.styleable.GenericDraweeView_failureImageScaleType,
-            failureImageScaleType);
+                // failure image
+                failureImageId = gdhAttrs.getResourceId(
+                        R.styleable.GenericDraweeView_failureImage,
+                        failureImageId);
+                // failure image scale type
+                failureImageScaleType = getScaleTypeFromXml(
+                        gdhAttrs,
+                        R.styleable.GenericDraweeView_failureImageScaleType,
+                        failureImageScaleType);
 
-        // progress bar image
-        progressBarId = gdhAttrs.getResourceId(
-            R.styleable.GenericDraweeView_progressBarImage,
-            progressBarId);
-        // progress bar image scale type
-        progressBarScaleType = getScaleTypeFromXml(
-            gdhAttrs,
-            R.styleable.GenericDraweeView_progressBarImageScaleType,
-            progressBarScaleType);
-        // progress bar auto rotate interval
-        progressBarAutoRotateInterval = gdhAttrs.getInteger(
-            R.styleable.GenericDraweeView_progressBarAutoRotateInterval,
-            0);
+                // progress bar image
+                progressBarId = gdhAttrs.getResourceId(
+                        R.styleable.GenericDraweeView_progressBarImage,
+                        progressBarId);
+                // progress bar image scale type
+                progressBarScaleType = getScaleTypeFromXml(
+                        gdhAttrs,
+                        R.styleable.GenericDraweeView_progressBarImageScaleType,
+                        progressBarScaleType);
+                // progress bar auto rotate interval
+                progressBarAutoRotateInterval = gdhAttrs.getInteger(
+                        R.styleable.GenericDraweeView_progressBarAutoRotateInterval,
+                        0);
 
-        // actual image scale type
-        actualImageScaleType = getScaleTypeFromXml(
-            gdhAttrs,
-            R.styleable.GenericDraweeView_actualImageScaleType,
-            actualImageScaleType);
+                // actual image scale type
+                actualImageScaleType = getScaleTypeFromXml(
+                        gdhAttrs,
+                        R.styleable.GenericDraweeView_actualImageScaleType,
+                        actualImageScaleType);
 
-        // background
-        backgroundId = gdhAttrs.getResourceId(
-            R.styleable.GenericDraweeView_backgroundImage,
-            backgroundId);
+                // background
+                backgroundId = gdhAttrs.getResourceId(
+                        R.styleable.GenericDraweeView_backgroundImage,
+                        backgroundId);
 
-        // overlay
-        overlayId = gdhAttrs.getResourceId(
-            R.styleable.GenericDraweeView_overlayImage,
-            overlayId);
+                // overlay
+                overlayId = gdhAttrs.getResourceId(
+                        R.styleable.GenericDraweeView_overlayImage,
+                        overlayId);
 
-        // pressedState overlay
-        pressedStateOverlayId = gdhAttrs.getResourceId(
-            R.styleable.GenericDraweeView_pressedStateOverlayImage,
-            pressedStateOverlayId);
+                // pressedState overlay
+                pressedStateOverlayId = gdhAttrs.getResourceId(
+                        R.styleable.GenericDraweeView_pressedStateOverlayImage,
+                        pressedStateOverlayId);
 
-        // rounding parameters
-        roundAsCircle = gdhAttrs.getBoolean(
-            R.styleable.GenericDraweeView_roundAsCircle,
-            roundAsCircle);
-        roundedCornerRadius = gdhAttrs.getDimensionPixelSize(
-            R.styleable.GenericDraweeView_roundedCornerRadius,
-            roundedCornerRadius);
-        roundTopLeft = gdhAttrs.getBoolean(
-            R.styleable.GenericDraweeView_roundTopLeft,
-            roundTopLeft);
-        roundTopRight = gdhAttrs.getBoolean(
-            R.styleable.GenericDraweeView_roundTopRight,
-            roundTopRight);
-        roundBottomRight = gdhAttrs.getBoolean(
-            R.styleable.GenericDraweeView_roundBottomRight,
-            roundBottomRight);
-        roundBottomLeft = gdhAttrs.getBoolean(
-            R.styleable.GenericDraweeView_roundBottomLeft,
-            roundBottomLeft);
-        roundWithOverlayColor = gdhAttrs.getColor(
-            R.styleable.GenericDraweeView_roundWithOverlayColor,
-            roundWithOverlayColor);
-        roundingBorderWidth = gdhAttrs.getDimensionPixelSize(
-            R.styleable.GenericDraweeView_roundingBorderWidth,
-            roundingBorderWidth);
-        roundingBorderColor = gdhAttrs.getColor(
-            R.styleable.GenericDraweeView_roundingBorderColor,
-            roundingBorderColor);
-      }
-      finally {
-        gdhAttrs.recycle();
-      }
-    }
+                // rounding parameters
+                roundAsCircle = gdhAttrs.getBoolean(
+                        R.styleable.GenericDraweeView_roundAsCircle,
+                        roundAsCircle);
+                roundedCornerRadius = gdhAttrs.getDimensionPixelSize(
+                        R.styleable.GenericDraweeView_roundedCornerRadius,
+                        roundedCornerRadius);
+                roundTopLeft = gdhAttrs.getBoolean(
+                        R.styleable.GenericDraweeView_roundTopLeft,
+                        roundTopLeft);
+                roundTopRight = gdhAttrs.getBoolean(
+                        R.styleable.GenericDraweeView_roundTopRight,
+                        roundTopRight);
+                roundBottomRight = gdhAttrs.getBoolean(
+                        R.styleable.GenericDraweeView_roundBottomRight,
+                        roundBottomRight);
+                roundBottomLeft = gdhAttrs.getBoolean(
+                        R.styleable.GenericDraweeView_roundBottomLeft,
+                        roundBottomLeft);
+                roundWithOverlayColor = gdhAttrs.getColor(
+                        R.styleable.GenericDraweeView_roundWithOverlayColor,
+                        roundWithOverlayColor);
+                roundingBorderWidth = gdhAttrs.getDimensionPixelSize(
+                        R.styleable.GenericDraweeView_roundingBorderWidth,
+                        roundingBorderWidth);
+                roundingBorderColor = gdhAttrs.getColor(
+                        R.styleable.GenericDraweeView_roundingBorderColor,
+                        roundingBorderColor);
+            } finally {
+                gdhAttrs.recycle();
+            }
+        }
 
-    GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(resources);
-    // set fade duration
-    builder.setFadeDuration(fadeDuration);
-    // set images & scale types
-    if (placeholderId > 0) {
-      builder.setPlaceholderImage(resources.getDrawable(placeholderId), placeholderScaleType);
-    }
-    if (retryImageId > 0) {
-      builder.setRetryImage(resources.getDrawable(retryImageId), retryImageScaleType);
-    }
-    if (failureImageId > 0) {
-      builder.setFailureImage(resources.getDrawable(failureImageId), failureImageScaleType);
-    }
-    if (progressBarId > 0) {
-      Drawable progressBarDrawable = resources.getDrawable(progressBarId);
-      if (progressBarAutoRotateInterval > 0) {
-        progressBarDrawable =
-            new AutoRotateDrawable(progressBarDrawable, progressBarAutoRotateInterval);
-      }
-      builder.setProgressBarImage(progressBarDrawable, progressBarScaleType);
-    }
-    if (backgroundId > 0) {
-      builder.setBackground(resources.getDrawable(backgroundId));
-    }
-    if (overlayId > 0) {
-      builder.setOverlay(resources.getDrawable(overlayId));
-    }
-    if (pressedStateOverlayId > 0) {
-      builder.setPressedStateOverlay(getResources().getDrawable(pressedStateOverlayId));
-    }
+        GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(resources);
+        // set fade duration
+        builder.setFadeDuration(fadeDuration);
+        // set images & scale types
+        if (placeholderId > 0) {
+            builder.setPlaceholderImage(resources.getDrawable(placeholderId), placeholderScaleType);
+        }
+        if (retryImageId > 0) {
+            builder.setRetryImage(resources.getDrawable(retryImageId), retryImageScaleType);
+        }
+        if (failureImageId > 0) {
+            builder.setFailureImage(resources.getDrawable(failureImageId), failureImageScaleType);
+        }
+        if (progressBarId > 0) {
+            Drawable progressBarDrawable = resources.getDrawable(progressBarId);
+            if (progressBarAutoRotateInterval > 0) {
+                progressBarDrawable =
+                        new AutoRotateDrawable(progressBarDrawable, progressBarAutoRotateInterval);
+            }
+            builder.setProgressBarImage(progressBarDrawable, progressBarScaleType);
+        }
+        if (backgroundId > 0) {
+            builder.setBackground(resources.getDrawable(backgroundId));
+        }
+        if (overlayId > 0) {
+            builder.setOverlay(resources.getDrawable(overlayId));
+        }
+        if (pressedStateOverlayId > 0) {
+            builder.setPressedStateOverlay(getResources().getDrawable(pressedStateOverlayId));
+        }
 
-    builder.setActualImageScaleType(actualImageScaleType);
-    // set rounding parameters
-    if (roundAsCircle || roundedCornerRadius > 0) {
-      RoundingParams roundingParams = new RoundingParams();
-      roundingParams.setRoundAsCircle(roundAsCircle);
-      if (roundedCornerRadius > 0) {
-        roundingParams.setCornersRadii(
-            roundTopLeft ? roundedCornerRadius : 0,
-            roundTopRight ? roundedCornerRadius : 0,
-            roundBottomRight ? roundedCornerRadius : 0,
-            roundBottomLeft ? roundedCornerRadius : 0);
-      }
-      if (roundWithOverlayColor != 0) {
-        roundingParams.setOverlayColor(roundWithOverlayColor);
-      }
-      if (roundingBorderColor != 0 && roundingBorderWidth > 0) {
-        roundingParams.setBorder(roundingBorderColor, roundingBorderWidth);
-      }
-      builder.setRoundingParams(roundingParams);
+        builder.setActualImageScaleType(actualImageScaleType);
+        // set rounding parameters
+        if (roundAsCircle || roundedCornerRadius > 0) {
+            RoundingParams roundingParams = new RoundingParams();
+            roundingParams.setRoundAsCircle(roundAsCircle);
+            if (roundedCornerRadius > 0) {
+                roundingParams.setCornersRadii(
+                        roundTopLeft ? roundedCornerRadius : 0,
+                        roundTopRight ? roundedCornerRadius : 0,
+                        roundBottomRight ? roundedCornerRadius : 0,
+                        roundBottomLeft ? roundedCornerRadius : 0);
+            }
+            if (roundWithOverlayColor != 0) {
+                roundingParams.setOverlayColor(roundWithOverlayColor);
+            }
+            if (roundingBorderColor != 0 && roundingBorderWidth > 0) {
+                roundingParams.setBorder(roundingBorderColor, roundingBorderWidth);
+            }
+            builder.setRoundingParams(roundingParams);
+        }
+        setHierarchy(builder.build());
     }
-    setHierarchy(builder.build());
-  }
 
-  /**
-   * Returns the scale type indicated in XML, or null if the special 'none' value was found.
-   */
-  private static ScalingUtils.ScaleType getScaleTypeFromXml(
-      TypedArray attrs,
-      int attrId,
-      ScalingUtils.ScaleType defaultScaleType) {
-    String xmlType = attrs.getString(attrId);
-    return (xmlType != null) ? ScalingUtils.ScaleType.fromString(xmlType) : defaultScaleType;
-  }
+    /**
+     * Returns the scale type indicated in XML, or null if the special 'none' value was found.
+     */
+    private static ScalingUtils.ScaleType getScaleTypeFromXml(
+            TypedArray attrs,
+            int attrId,
+            ScalingUtils.ScaleType defaultScaleType) {
+        String xmlType = attrs.getString(attrId);
+        return (xmlType != null) ? ScalingUtils.ScaleType.fromString(xmlType) : defaultScaleType;
+    }
 
- /**
-  * Sets the desired aspect ratio (w/h).
-  */
-  public void setAspectRatio(float aspectRatio) {
-    if (aspectRatio == mAspectRatio) {
-      return;
+    /**
+     * Sets the desired aspect ratio (w/h).
+     */
+    public void setAspectRatio(float aspectRatio) {
+        if (aspectRatio == mAspectRatio) {
+            return;
+        }
+        mAspectRatio = aspectRatio;
+        requestLayout();
     }
-    mAspectRatio = aspectRatio;
-    requestLayout();
-  }
 
-  /**
-   * Gets the desired aspect ratio (w/h).
-   */
-  public float getAspectRatio() {
-    return mAspectRatio;
-  }
+    /**
+     * Gets the desired aspect ratio (w/h).
+     */
+    public float getAspectRatio() {
+        return mAspectRatio;
+    }
 
-  @Override
-  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-    mMeasureSpec.width = widthMeasureSpec;
-    mMeasureSpec.height = heightMeasureSpec;
-    AspectRatioMeasure.updateMeasureSpec(
-        mMeasureSpec,
-        mAspectRatio,
-        getLayoutParams(),
-        getPaddingLeft() + getPaddingRight(),
-        getPaddingTop() + getPaddingBottom());
-    super.onMeasure(mMeasureSpec.width, mMeasureSpec.height);
-  }
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        mMeasureSpec.width = widthMeasureSpec;
+        mMeasureSpec.height = heightMeasureSpec;
+        AspectRatioMeasure.updateMeasureSpec(
+                mMeasureSpec,
+                mAspectRatio,
+                getLayoutParams(),
+                getPaddingLeft() + getPaddingRight(),
+                getPaddingTop() + getPaddingBottom());
+        super.onMeasure(mMeasureSpec.width, mMeasureSpec.height);
+    }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/view/MultiDraweeHolder.java b/drawee/src/main/java/com/facebook/drawee/view/MultiDraweeHolder.java
index 26b469203..79455cedd 100644
--- a/drawee/src/main/java/com/facebook/drawee/view/MultiDraweeHolder.java
+++ b/drawee/src/main/java/com/facebook/drawee/view/MultiDraweeHolder.java
@@ -23,12 +23,12 @@
 
 /**
  * Contains multiple Drawee holders.
- *
+ * <p>
  * <p>Intended for use in custom views that are showing more than one hierarchy.
- *
+ * <p>
  * Users of this class must< call {@link Drawable#setBounds} on the top-level drawable
  * of each DraweeHierarchy in this holder. Otherwise the drawables will not be drawn.
-
+ * <p>
  * <p>The containing view must also call {@link #onDetach()} from its
  * {@link View#onStartTemporaryDetach()} and {@link View#onDetachedFromWindow()} methods. It must
  * call {@link #onAttach} from its  {@link View#onFinishTemporaryDetach()} and
@@ -36,105 +36,111 @@
  */
 public class MultiDraweeHolder<DH extends DraweeHierarchy> {
 
-  @VisibleForTesting boolean mIsAttached = false;
-  @VisibleForTesting ArrayList<DraweeHolder<DH>> mHolders = Lists.newArrayList();
-
-  /**
-   * Gets the controller ready to display the images.
-   *
-   * <p>The containing view must call this method from both {@link View#onFinishTemporaryDetach()}
-   * and {@link View#onAttachedToWindow()}.
-   */
-  public void onAttach() {
-    if (mIsAttached) {
-      return;
+    @VisibleForTesting
+    boolean mIsAttached = false;
+    @VisibleForTesting
+    ArrayList<DraweeHolder<DH>> mHolders = Lists.newArrayList();
+
+    /**
+     * Gets the controller ready to display the images.
+     * <p>
+     * <p>The containing view must call this method from both {@link View#onFinishTemporaryDetach()}
+     * and {@link View#onAttachedToWindow()}.
+     */
+    public void onAttach() {
+        if (mIsAttached) {
+            return;
+        }
+        mIsAttached = true;
+        for (int i = 0; i < mHolders.size(); ++i) {
+            mHolders.get(i).onAttach();
+        }
     }
-    mIsAttached = true;
-    for (int i = 0; i < mHolders.size(); ++i) {
-      mHolders.get(i).onAttach();
+
+    /**
+     * Releases resources used to display the image.
+     * <p>
+     * <p>The containing view must call this method from both {@link View#onStartTemporaryDetach()}
+     * and {@link View#onDetachedFromWindow()}.
+     */
+    public void onDetach() {
+        if (!mIsAttached) {
+            return;
+        }
+        mIsAttached = false;
+        for (int i = 0; i < mHolders.size(); ++i) {
+            mHolders.get(i).onDetach();
+        }
+    }
+
+    public boolean onTouchEvent(MotionEvent event) {
+        for (int i = 0; i < mHolders.size(); ++i) {
+            if (mHolders.get(i).onTouchEvent(event)) {
+                return true;
+            }
+        }
+        return false;
     }
-  }
-
-  /**
-   * Releases resources used to display the image.
-   *
-   * <p>The containing view must call this method from both {@link View#onStartTemporaryDetach()}
-   * and {@link View#onDetachedFromWindow()}.
-   */
-  public void onDetach() {
-    if (!mIsAttached) {
-      return;
+
+    public void clear() {
+        if (mIsAttached) {
+            for (int i = 0; i < mHolders.size(); ++i) {
+                mHolders.get(i).onDetach();
+            }
+        }
+        mHolders.clear();
     }
-    mIsAttached = false;
-    for (int i = 0; i < mHolders.size(); ++i) {
-      mHolders.get(i).onDetach();
+
+    public void add(DraweeHolder<DH> holder) {
+        add(mHolders.size(), holder);
     }
-  }
 
-  public boolean onTouchEvent(MotionEvent event) {
-    for (int i = 0; i < mHolders.size(); ++i) {
-      if (mHolders.get(i).onTouchEvent(event)) {
-        return true;
-      }
+    public void add(int index, DraweeHolder<DH> holder) {
+        Preconditions.checkNotNull(holder);
+        Preconditions.checkElementIndex(index, mHolders.size() + 1);
+        mHolders.add(index, holder);
+        if (mIsAttached) {
+            holder.onAttach();
+        }
     }
-    return false;
-  }
-
-  public void clear() {
-    if (mIsAttached) {
-      for (int i = 0; i < mHolders.size(); ++i) {
-        mHolders.get(i).onDetach();
-      }
+
+    public void remove(int index) {
+        DraweeHolder<DH> holder = mHolders.get(index);
+        if (mIsAttached) {
+            holder.onDetach();
+        }
+        mHolders.remove(index);
     }
-    mHolders.clear();
-  }
-
-  public void add(DraweeHolder<DH> holder) {
-    add(mHolders.size(), holder);
-  }
-
-  public void add(int index, DraweeHolder<DH> holder) {
-    Preconditions.checkNotNull(holder);
-    Preconditions.checkElementIndex(index, mHolders.size() + 1);
-    mHolders.add(index, holder);
-    if (mIsAttached) {
-      holder.onAttach();
+
+    public DraweeHolder<DH> get(int index) {
+        return mHolders.get(index);
     }
-  }
 
-  public void remove(int index) {
-    DraweeHolder<DH> holder = mHolders.get(index);
-    if (mIsAttached) {
-      holder.onDetach();
+    public int size() {
+        return mHolders.size();
     }
-    mHolders.remove(index);
-  }
-
-  public DraweeHolder<DH> get(int index) {
-    return mHolders.get(index);
-  }
-
-  public int size() {
-    return mHolders.size();
-  }
-
-  /** Convenience method to draw all the top-level drawables in this holder. */
-  public void draw(Canvas canvas) {
-    for (int i = 0; i < mHolders.size(); ++i) {
-      Drawable drawable = get(i).getTopLevelDrawable();
-      if (drawable != null) {
-        drawable.draw(canvas);
-      }
+
+    /**
+     * Convenience method to draw all the top-level drawables in this holder.
+     */
+    public void draw(Canvas canvas) {
+        for (int i = 0; i < mHolders.size(); ++i) {
+            Drawable drawable = get(i).getTopLevelDrawable();
+            if (drawable != null) {
+                drawable.draw(canvas);
+            }
+        }
     }
-  }
-
-  /** Returns true if the argument is a top-level Drawable in this holder. */
-  public boolean verifyDrawable(Drawable who) {
-    for (int i = 0; i < mHolders.size(); ++i) {
-      if (who == get(i).getTopLevelDrawable()) {
-        return true;
-      }
+
+    /**
+     * Returns true if the argument is a top-level Drawable in this holder.
+     */
+    public boolean verifyDrawable(Drawable who) {
+        for (int i = 0; i < mHolders.size(); ++i) {
+            if (who == get(i).getTopLevelDrawable()) {
+                return true;
+            }
+        }
+        return false;
     }
-    return false;
-  }
 }
diff --git a/drawee/src/main/java/com/facebook/drawee/view/SimpleDraweeView.java b/drawee/src/main/java/com/facebook/drawee/view/SimpleDraweeView.java
index 66d7b2400..59c4af0c5 100644
--- a/drawee/src/main/java/com/facebook/drawee/view/SimpleDraweeView.java
+++ b/drawee/src/main/java/com/facebook/drawee/view/SimpleDraweeView.java
@@ -23,84 +23,88 @@
 
 /**
  * This view takes a uri as input and internally builds and sets a controller.
- *
+ * <p>
  * <p>This class must be statically initialized in order to be used. If you are using the Fresco
  * image pipeline, use {@link com.facebook.drawee.backends.pipeline.Fresco#initialize} to do this.
  */
 public class SimpleDraweeView extends GenericDraweeView {
 
-  private static Supplier<? extends SimpleDraweeControllerBuilder> sDraweeControllerBuilderSupplier;
+    private static Supplier<? extends SimpleDraweeControllerBuilder> sDraweeControllerBuilderSupplier;
 
-  /** Initializes {@link SimpleDraweeView} with supplier of Drawee controller builders. */
-  public static void initialize(
-      Supplier<? extends SimpleDraweeControllerBuilder> draweeControllerBuilderSupplier) {
-    sDraweeControllerBuilderSupplier = draweeControllerBuilderSupplier;
-  }
+    /**
+     * Initializes {@link SimpleDraweeView} with supplier of Drawee controller builders.
+     */
+    public static void initialize(
+            Supplier<? extends SimpleDraweeControllerBuilder> draweeControllerBuilderSupplier) {
+        sDraweeControllerBuilderSupplier = draweeControllerBuilderSupplier;
+    }
 
-  /** Shuts {@link SimpleDraweeView} down. */
-  public static void shutDown() {
-    sDraweeControllerBuilderSupplier = null;
-  }
+    /**
+     * Shuts {@link SimpleDraweeView} down.
+     */
+    public static void shutDown() {
+        sDraweeControllerBuilderSupplier = null;
+    }
 
-  private SimpleDraweeControllerBuilder mSimpleDraweeControllerBuilder;
+    private SimpleDraweeControllerBuilder mSimpleDraweeControllerBuilder;
 
-  public SimpleDraweeView(Context context, GenericDraweeHierarchy hierarchy) {
-    super(context, hierarchy);
-    init();
-  }
+    public SimpleDraweeView(Context context, GenericDraweeHierarchy hierarchy) {
+        super(context, hierarchy);
+        init();
+    }
 
-  public SimpleDraweeView(Context context) {
-    super(context);
-    init();
-  }
+    public SimpleDraweeView(Context context) {
+        super(context);
+        init();
+    }
 
-  public SimpleDraweeView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-    init();
-  }
+    public SimpleDraweeView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
 
-  public SimpleDraweeView(Context context, AttributeSet attrs, int defStyle) {
-    super(context, attrs, defStyle);
-    init();
-  }
+    public SimpleDraweeView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init();
+    }
+
+    private void init() {
+        if (isInEditMode()) {
+            return;
+        }
+        Preconditions.checkNotNull(
+                sDraweeControllerBuilderSupplier,
+                "SimpleDraweeView was not initialized!");
+        mSimpleDraweeControllerBuilder = sDraweeControllerBuilderSupplier.get();
+    }
+
+    protected SimpleDraweeControllerBuilder getControllerBuilder() {
+        return mSimpleDraweeControllerBuilder;
+    }
+
+    /**
+     * Displays an image given by the uri.
+     *
+     * @param uri uri of the image
+     * @undeprecate
+     */
+    @Override
+    public void setImageURI(Uri uri) {
+        setImageURI(uri, null);
+    }
 
-  private void init() {
-    if (isInEditMode()) {
-      return;
+    /**
+     * Displays an image given by the uri.
+     *
+     * @param uri           uri of the image
+     * @param callerContext caller context
+     */
+    public void setImageURI(Uri uri, @Nullable Object callerContext) {
+        DraweeController controller = mSimpleDraweeControllerBuilder
+                .setCallerContext(callerContext)
+                .setUri(uri)
+                .setOldController(getController())
+                .build();
+        setController(controller);
     }
-    Preconditions.checkNotNull(
-        sDraweeControllerBuilderSupplier,
-        "SimpleDraweeView was not initialized!");
-    mSimpleDraweeControllerBuilder = sDraweeControllerBuilderSupplier.get();
-  }
-
-  protected SimpleDraweeControllerBuilder getControllerBuilder() {
-    return mSimpleDraweeControllerBuilder;
-  }
-
-  /**
-   * Displays an image given by the uri.
-   *
-   * @param uri uri of the image
-   * @undeprecate
-   */
-  @Override
-  public void setImageURI(Uri uri) {
-    setImageURI(uri, null);
-  }
-
-  /**
-   * Displays an image given by the uri.
-   *
-   * @param uri uri of the image
-   * @param callerContext caller context
-   */
-  public void setImageURI(Uri uri, @Nullable Object callerContext) {
-    DraweeController controller = mSimpleDraweeControllerBuilder
-        .setCallerContext(callerContext)
-        .setUri(uri)
-        .setOldController(getController())
-        .build();
-    setController(controller);
-  }
 }
diff --git a/drawee/src/main/res/values/attrs.xml b/drawee/src/main/res/values/attrs.xml
index da90fc366..6c893fbd0 100644
--- a/drawee/src/main/res/values/attrs.xml
+++ b/drawee/src/main/res/values/attrs.xml
@@ -1,73 +1,73 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-  <declare-styleable name="GenericDraweeView">
+    <declare-styleable name="GenericDraweeView">
 
-    <!-- Fade duration in milliseconds. -->
-    <attr name="fadeDuration" format="integer"/>
+        <!-- Fade duration in milliseconds. -->
+        <attr name="fadeDuration" format="integer" />
 
-    <!-- Images -
-    Scale types must match values in ScaleType.fromString (ScalingUtils.java).
-    For drawables that should not be scaled, such as those with the android:tileMode
-    attribute set, use the value 'none'. -->
+        <!-- Images -
+        Scale types must match values in ScaleType.fromString (ScalingUtils.java).
+        For drawables that should not be scaled, such as those with the android:tileMode
+        attribute set, use the value 'none'. -->
 
-    <!-- Aspect ratio (width / height) of the view, not necessarily of the images. -->
-    <attr name="viewAspectRatio" format="float"/>
+        <!-- Aspect ratio (width / height) of the view, not necessarily of the images. -->
+        <attr name="viewAspectRatio" format="float" />
 
-    <!-- A drawable or color to be be used as a placeholder. -->
-    <attr name="placeholderImage" format="reference"/>
-    <!-- Scale type of the placeholder image. Ignored if placeholderImage is not specified. -->
-    <attr name="placeholderImageScaleType" format="string"/>
+        <!-- A drawable or color to be be used as a placeholder. -->
+        <attr name="placeholderImage" format="reference" />
+        <!-- Scale type of the placeholder image. Ignored if placeholderImage is not specified. -->
+        <attr name="placeholderImageScaleType" format="string" />
 
-    <!-- A drawable to be be used as a retry image. -->
-    <attr name="retryImage" format="reference"/>
-    <!-- Scale type of the retry image. Ignored if retryImage is not specified. -->
-    <attr name="retryImageScaleType" format="string"/>
+        <!-- A drawable to be be used as a retry image. -->
+        <attr name="retryImage" format="reference" />
+        <!-- Scale type of the retry image. Ignored if retryImage is not specified. -->
+        <attr name="retryImageScaleType" format="string" />
 
-    <!-- A drawable to be be used as a failure image. -->
-    <attr name="failureImage" format="reference"/>
-    <!-- Scale type of the failure image. Ignored if failureImage is not specified. -->
-    <attr name="failureImageScaleType" format="string"/>
+        <!-- A drawable to be be used as a failure image. -->
+        <attr name="failureImage" format="reference" />
+        <!-- Scale type of the failure image. Ignored if failureImage is not specified. -->
+        <attr name="failureImageScaleType" format="string" />
 
-    <!-- A drawable to be be used as a progress bar. -->
-    <attr name="progressBarImage" format="reference"/>
-    <!-- Scale type of the progress bar. Ignored if progressBarImage is not specified. -->
-    <attr name="progressBarImageScaleType" format="string"/>
-    <!-- Progress bar Auto Rotate interval in milliseconds -->
-    <attr name="progressBarAutoRotateInterval" format="integer"/>
+        <!-- A drawable to be be used as a progress bar. -->
+        <attr name="progressBarImage" format="reference" />
+        <!-- Scale type of the progress bar. Ignored if progressBarImage is not specified. -->
+        <attr name="progressBarImageScaleType" format="string" />
+        <!-- Progress bar Auto Rotate interval in milliseconds -->
+        <attr name="progressBarAutoRotateInterval" format="integer" />
 
-    <!-- Scale type of the actual image. -->
-    <attr name="actualImageScaleType" format="string"/>
+        <!-- Scale type of the actual image. -->
+        <attr name="actualImageScaleType" format="string" />
 
-    <!-- A drawable or color to be used as a background. -->
-    <attr name="backgroundImage" format="reference"/>
+        <!-- A drawable or color to be used as a background. -->
+        <attr name="backgroundImage" format="reference" />
 
-    <!-- A drawable or color to be used as an overlay. -->
-    <attr name="overlayImage" format="reference"/>
+        <!-- A drawable or color to be used as an overlay. -->
+        <attr name="overlayImage" format="reference" />
 
-    <!-- A drawable or color to be used as a pressed-state-overlay -->
-    <attr name="pressedStateOverlayImage" format="reference"/>
+        <!-- A drawable or color to be used as a pressed-state-overlay -->
+        <attr name="pressedStateOverlayImage" format="reference" />
 
-    <!-- Rounding params -
-    Declares attributes for rounding shape, mode and border. -->
+        <!-- Rounding params -
+        Declares attributes for rounding shape, mode and border. -->
 
-    <!-- Round as circle. -->
-    <attr name="roundAsCircle" format="boolean"/>
-    <!-- Rounded corner radius. Ignored if roundAsCircle is used. -->
-    <attr name="roundedCornerRadius" format="dimension"/>
-    <!-- Round the top-left corner. Ignored if roundAsCircle is used. -->
-    <attr name="roundTopLeft" format="boolean"/>
-    <!-- Round the top-right corner. Ignored if roundAsCircle is used. -->
-    <attr name="roundTopRight" format="boolean"/>
-    <!-- Round the bottom-right corner. Ignored if roundAsCircle is used. -->
-    <attr name="roundBottomRight" format="boolean"/>
-    <!-- Round the bottom-left corner. Ignored if roundAsCircle is used. -->
-    <attr name="roundBottomLeft" format="boolean"/>
-    <!-- Round by overlying color. -->
-    <attr name="roundWithOverlayColor" format="color"/>
-    <!-- Rounding border width-->
-    <attr name="roundingBorderWidth" format="dimension"/>
-    <!-- Rounding border color -->
-    <attr name="roundingBorderColor" format="color"/>
+        <!-- Round as circle. -->
+        <attr name="roundAsCircle" format="boolean" />
+        <!-- Rounded corner radius. Ignored if roundAsCircle is used. -->
+        <attr name="roundedCornerRadius" format="dimension" />
+        <!-- Round the top-left corner. Ignored if roundAsCircle is used. -->
+        <attr name="roundTopLeft" format="boolean" />
+        <!-- Round the top-right corner. Ignored if roundAsCircle is used. -->
+        <attr name="roundTopRight" format="boolean" />
+        <!-- Round the bottom-right corner. Ignored if roundAsCircle is used. -->
+        <attr name="roundBottomRight" format="boolean" />
+        <!-- Round the bottom-left corner. Ignored if roundAsCircle is used. -->
+        <attr name="roundBottomLeft" format="boolean" />
+        <!-- Round by overlying color. -->
+        <attr name="roundWithOverlayColor" format="color" />
+        <!-- Rounding border width-->
+        <attr name="roundingBorderWidth" format="dimension" />
+        <!-- Rounding border color -->
+        <attr name="roundingBorderColor" format="color" />
 
-  </declare-styleable>
+    </declare-styleable>
 </resources>
diff --git a/drawee/src/test/java/com/facebook/drawee/controller/AbstractDraweeControllerTest.java b/drawee/src/test/java/com/facebook/drawee/controller/AbstractDraweeControllerTest.java
index 307235b26..a24f91b99 100644
--- a/drawee/src/test/java/com/facebook/drawee/controller/AbstractDraweeControllerTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/controller/AbstractDraweeControllerTest.java
@@ -38,683 +38,692 @@
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
-/** * Tests for AbstractDraweeController */
+/**
+ * Tests for AbstractDraweeController
+ */
 @RunWith(WithTestDefaultsRunner.class)
 public class AbstractDraweeControllerTest {
 
-  public static class FakeImageInfo {
-  }
+    public static class FakeImageInfo {
+    }
+
+    public static class FakeImage {
+        private final Drawable mDrawable;
+        private final FakeImageInfo mImageInfo;
+        private boolean mIsOpened;
+        private boolean mIsClosed;
+
+        protected FakeImage(Drawable drawable, FakeImageInfo imageInfo) {
+            mDrawable = drawable;
+            mImageInfo = imageInfo;
+            mIsOpened = false;
+            mIsClosed = false;
+        }
+
+        public Drawable getDrawable() {
+            return mDrawable;
+        }
+
+        public
+        @Nullable
+        FakeImageInfo getImageInfo() {
+            return mImageInfo;
+        }
+
+        public void open() {
+            mIsOpened = true;
+        }
+
+        public boolean isOpened() {
+            return mIsOpened;
+        }
+
+        public void close() {
+            mIsClosed = true;
+        }
+
+        public boolean isClosed() {
+            return mIsClosed;
+        }
+
+        public static FakeImage create(Drawable drawable) {
+            return new FakeImage(drawable, null);
+        }
+
+        public static FakeImage create(Drawable drawable, FakeImageInfo imageInfo) {
+            return new FakeImage(drawable, imageInfo);
+        }
+    }
 
-  public static class FakeImage {
-    private final Drawable mDrawable;
-    private final FakeImageInfo mImageInfo;
-    private boolean mIsOpened;
-    private boolean mIsClosed;
+    public static class FakeDraweeController
+            extends AbstractDraweeController<FakeImage, FakeImageInfo> {
+
+        private Supplier<DataSource<FakeImage>> mDataSourceSupplier;
+        public boolean mIsAttached = false;
+
+        public FakeDraweeController(
+                DeferredReleaser deferredReleaser,
+                Executor uiThreadExecutor,
+                Supplier<DataSource<FakeImage>> dataSourceSupplier,
+                String id,
+                Object callerContext) {
+            super(deferredReleaser, uiThreadExecutor, id, callerContext);
+            mDataSourceSupplier = dataSourceSupplier;
+        }
+
+        @Override
+        public void onAttach() {
+            mIsAttached = true;
+            super.onAttach();
+        }
+
+        @Override
+        public void onDetach() {
+            mIsAttached = false;
+            super.onDetach();
+        }
+
+        public boolean isAttached() {
+            return mIsAttached;
+        }
+
+        @Override
+        protected DataSource<FakeImage> getDataSource() {
+            return mDataSourceSupplier.get();
+        }
+
+        @Override
+        protected Drawable createDrawable(FakeImage image) {
+            return image.getDrawable();
+        }
+
+        @Override
+        protected
+        @Nullable
+        FakeImageInfo getImageInfo(FakeImage image) {
+            return image.getImageInfo();
+        }
+
+        @Override
+        protected void releaseImage(@Nullable FakeImage image) {
+            if (image != null) {
+                image.close();
+            }
+        }
+
+        @Override
+        protected void releaseDrawable(@Nullable Drawable drawable) {
+        }
+    }
 
-    protected FakeImage(Drawable drawable, FakeImageInfo imageInfo) {
-      mDrawable = drawable;
-      mImageInfo = imageInfo;
-      mIsOpened = false;
-      mIsClosed = false;
+    private DeferredReleaser mDeferredReleaser;
+    private Object mCallerContext;
+    private Supplier<DataSource<FakeImage>> mDataSourceSupplier;
+    private SettableDraweeHierarchy mDraweeHierarchy;
+
+    private Executor mUiThreadExecutor;
+    private FakeDraweeController mController;
+
+    @Before
+    public void setUp() {
+        mDeferredReleaser = mock(DeferredReleaser.class);
+        mCallerContext = mock(Object.class);
+        mDataSourceSupplier = mock(Supplier.class);
+        mDraweeHierarchy = mock(SettableDraweeHierarchy.class);
+        mUiThreadExecutor = CallerThreadExecutor.getInstance();
+        mController = new FakeDraweeController(
+                mDeferredReleaser,
+                mUiThreadExecutor,
+                mDataSourceSupplier,
+                "id",
+                mCallerContext);
+        doAnswer(
+                new Answer<Object>() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        ((DeferredReleaser.Releasable) invocation.getArguments()[0]).release();
+                        return null;
+                    }
+                }).when(mDeferredReleaser).scheduleDeferredRelease(any(DeferredReleaser.Releasable.class));
+        when(mDataSourceSupplier.get()).thenReturn(SettableDataSource.<FakeImage>create());
     }
 
-    public Drawable getDrawable() {
-      return mDrawable;
+    @Test
+    public void testOnAttach() {
+        mController.setHierarchy(mDraweeHierarchy);
+        mController.onAttach();
+        verify(mDeferredReleaser, atLeastOnce()).cancelDeferredRelease(eq(mController));
+        verify(mDataSourceSupplier).get();
     }
 
-    public @Nullable
-    FakeImageInfo getImageInfo() {
-      return mImageInfo;
+    @Test
+    public void testOnAttach_ThrowsWithoutHierarchy() {
+        try {
+            mController.setHierarchy(null);
+            mController.onAttach();
+            fail("onAttach should fail if no drawee hierarchy is set!");
+        } catch (NullPointerException npe) {
+            // expected
+        }
     }
 
-    public void open() {
-      mIsOpened = true;
+    @Test
+    public void testOnDetach() {
+        mController.setHierarchy(mDraweeHierarchy);
+        mController.onAttach();
+        mController.onDetach();
+        assertSame(mDraweeHierarchy, mController.getHierarchy());
+        verify(mDeferredReleaser).scheduleDeferredRelease(mController);
     }
 
-    public boolean isOpened() {
-      return mIsOpened;
+    @Test
+    public void testSettingControllerOverlay() {
+        Drawable controllerOverlay1 = mock(Drawable.class);
+        Drawable controllerOverlay2 = mock(Drawable.class);
+        SettableDraweeHierarchy draweeHierarchy1 = mock(SettableDraweeHierarchy.class);
+        SettableDraweeHierarchy draweeHierarchy2 = mock(SettableDraweeHierarchy.class);
+        InOrder inOrder = inOrder(draweeHierarchy1, draweeHierarchy2);
+
+        // initial state
+        assertNull(mController.getHierarchy());
+
+        // set controller overlay before hierarchy
+        mController.setControllerOverlay(controllerOverlay1);
+
+        // set drawee hierarchy
+        mController.setHierarchy(draweeHierarchy1);
+        assertSame(draweeHierarchy1, mController.getHierarchy());
+        inOrder.verify(draweeHierarchy1, times(1)).setControllerOverlay(controllerOverlay1);
+        inOrder.verify(draweeHierarchy1, times(0)).reset();
+
+        // change drawee hierarchy
+        mController.setHierarchy(draweeHierarchy2);
+        assertSame(draweeHierarchy2, mController.getHierarchy());
+        inOrder.verify(draweeHierarchy1, times(1)).setControllerOverlay(null);
+        inOrder.verify(draweeHierarchy1, times(0)).reset();
+        inOrder.verify(draweeHierarchy2, times(1)).setControllerOverlay(controllerOverlay1);
+        inOrder.verify(draweeHierarchy2, times(0)).reset();
+
+        // clear drawee hierarchy
+        mController.setHierarchy(null);
+        assertSame(null, mController.getHierarchy());
+        inOrder.verify(draweeHierarchy1, times(0)).setControllerOverlay(any(Drawable.class));
+        inOrder.verify(draweeHierarchy1, times(0)).reset();
+        inOrder.verify(draweeHierarchy2, times(1)).setControllerOverlay(null);
+        inOrder.verify(draweeHierarchy2, times(0)).reset();
+
+        // set drawee hierarchy
+        mController.setHierarchy(draweeHierarchy1);
+        assertSame(draweeHierarchy1, mController.getHierarchy());
+        inOrder.verify(draweeHierarchy1, times(1)).setControllerOverlay(controllerOverlay1);
+        inOrder.verify(draweeHierarchy1, times(0)).reset();
+        inOrder.verify(draweeHierarchy2, times(0)).setControllerOverlay(any(Drawable.class));
+        inOrder.verify(draweeHierarchy2, times(0)).reset();
+
+        // change controller overlay
+        mController.setControllerOverlay(controllerOverlay2);
+        inOrder.verify(draweeHierarchy1, times(1)).setControllerOverlay(controllerOverlay2);
+        inOrder.verify(draweeHierarchy1, times(0)).reset();
+        inOrder.verify(draweeHierarchy2, times(0)).setControllerOverlay(any(Drawable.class));
+        inOrder.verify(draweeHierarchy2, times(0)).reset();
+
+        // clear controller overlay
+        mController.setControllerOverlay(null);
+        inOrder.verify(draweeHierarchy1, times(1)).setControllerOverlay(null);
+        inOrder.verify(draweeHierarchy1, times(0)).reset();
+        inOrder.verify(draweeHierarchy2, times(0)).setControllerOverlay(any(Drawable.class));
+        inOrder.verify(draweeHierarchy2, times(0)).reset();
     }
 
-    public void close() {
-      mIsClosed = true;
+    @Test
+    public void testListeners() {
+        ControllerListener<FakeImageInfo> listener1 = mock(ControllerListener.class);
+        ControllerListener<Object> listener2 = mock(ControllerListener.class);
+        InOrder inOrder = inOrder(listener1, listener2);
+
+        mController.getControllerListener().onRelease("id");
+        inOrder.verify(listener1, never()).onRelease(anyString());
+        inOrder.verify(listener2, never()).onRelease(anyString());
+
+        mController.addControllerListener(listener1);
+        mController.getControllerListener().onRelease("id");
+        inOrder.verify(listener1, times(1)).onRelease("id");
+        inOrder.verify(listener2, never()).onRelease(anyString());
+
+        mController.addControllerListener(listener2);
+        mController.getControllerListener().onRelease("id");
+        inOrder.verify(listener1, times(1)).onRelease("id");
+        inOrder.verify(listener2, times(1)).onRelease("id");
+
+        mController.removeControllerListener(listener1);
+        mController.getControllerListener().onRelease("id");
+        inOrder.verify(listener1, never()).onRelease(anyString());
+        inOrder.verify(listener2, times(1)).onRelease("id");
+
+        mController.removeControllerListener(listener2);
+        mController.getControllerListener().onRelease("id");
+        inOrder.verify(listener1, never()).onRelease(anyString());
+        inOrder.verify(listener2, never()).onRelease(anyString());
     }
 
-    public boolean isClosed() {
-      return mIsClosed;
+    @Test
+    public void testListenerReentrancy_AfterIntermediateSet() {
+        testListenerReentrancy(INTERMEDIATE_FAILURE);
     }
 
-    public static FakeImage create(Drawable drawable) {
-      return new FakeImage(drawable, null);
+    @Test
+    public void testListenerReentrancy_AfterIntermediateFailed() {
+        testListenerReentrancy(INTERMEDIATE_GOOD);
     }
 
-    public static FakeImage create(Drawable drawable, FakeImageInfo imageInfo) {
-      return new FakeImage(drawable, imageInfo);
+    @Test
+    public void testListenerReentrancy_AfterFinalSet() {
+        testListenerReentrancy(SUCCESS);
     }
-  }
 
-  public static class FakeDraweeController
-      extends AbstractDraweeController<FakeImage, FakeImageInfo> {
+    @Test
+    public void testListenerReentrancy_AfterFailure() {
+        testListenerReentrancy(FAILURE);
+    }
 
-    private Supplier<DataSource<FakeImage>> mDataSourceSupplier;
-    public boolean mIsAttached = false;
-
-    public FakeDraweeController(
-        DeferredReleaser deferredReleaser,
-        Executor uiThreadExecutor,
-        Supplier<DataSource<FakeImage>> dataSourceSupplier,
-        String id,
-        Object callerContext) {
-      super(deferredReleaser, uiThreadExecutor, id, callerContext);
-      mDataSourceSupplier = dataSourceSupplier;
-    }
-
-    @Override
-    public void onAttach() {
-      mIsAttached = true;
-      super.onAttach();
-    }
-
-    @Override
-    public void onDetach() {
-      mIsAttached = false;
-      super.onDetach();
-    }
-
-    public boolean isAttached() {
-      return mIsAttached;
-    }
-
-    @Override
-    protected DataSource<FakeImage> getDataSource() {
-      return mDataSourceSupplier.get();
-    }
-
-    @Override
-    protected Drawable createDrawable(FakeImage image) {
-      return image.getDrawable();
-    }
-
-    @Override
-    protected
-    @Nullable
-    FakeImageInfo getImageInfo(FakeImage image) {
-      return image.getImageInfo();
-    }
-
-    @Override
-    protected void releaseImage(@Nullable FakeImage image) {
-      if (image != null) {
-        image.close();
-      }
-    }
-
-    @Override
-    protected void releaseDrawable(@Nullable Drawable drawable) {
-    }
-  }
-
-  private DeferredReleaser mDeferredReleaser;
-  private Object mCallerContext;
-  private Supplier<DataSource<FakeImage>> mDataSourceSupplier;
-  private SettableDraweeHierarchy mDraweeHierarchy;
-
-  private Executor mUiThreadExecutor;
-  private FakeDraweeController mController;
-
-  @Before
-  public void setUp() {
-    mDeferredReleaser = mock(DeferredReleaser.class);
-    mCallerContext = mock(Object.class);
-    mDataSourceSupplier = mock(Supplier.class);
-    mDraweeHierarchy = mock(SettableDraweeHierarchy.class);
-    mUiThreadExecutor = CallerThreadExecutor.getInstance();
-    mController = new FakeDraweeController(
-        mDeferredReleaser,
-        mUiThreadExecutor,
-        mDataSourceSupplier,
-        "id",
-        mCallerContext);
-    doAnswer(
-        new Answer<Object>() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            ((DeferredReleaser.Releasable) invocation.getArguments()[0]).release();
-            return null;
-          }
-        }).when(mDeferredReleaser).scheduleDeferredRelease(any(DeferredReleaser.Releasable.class));
-    when(mDataSourceSupplier.get()).thenReturn(SettableDataSource.<FakeImage>create());
-  }
-
-  @Test
-  public void testOnAttach() {
-    mController.setHierarchy(mDraweeHierarchy);
-    mController.onAttach();
-    verify(mDeferredReleaser, atLeastOnce()).cancelDeferredRelease(eq(mController));
-    verify(mDataSourceSupplier).get();
-  }
-
-  @Test
-  public void testOnAttach_ThrowsWithoutHierarchy() {
-    try {
-      mController.setHierarchy(null);
-      mController.onAttach();
-      fail("onAttach should fail if no drawee hierarchy is set!");
-    } catch (NullPointerException npe) {
-      // expected
-    }
-  }
-
-  @Test
-  public void testOnDetach() {
-    mController.setHierarchy(mDraweeHierarchy);
-    mController.onAttach();
-    mController.onDetach();
-    assertSame(mDraweeHierarchy, mController.getHierarchy());
-    verify(mDeferredReleaser).scheduleDeferredRelease(mController);
-  }
-
-  @Test
-  public void testSettingControllerOverlay() {
-    Drawable controllerOverlay1 = mock(Drawable.class);
-    Drawable controllerOverlay2 = mock(Drawable.class);
-    SettableDraweeHierarchy draweeHierarchy1 = mock(SettableDraweeHierarchy.class);
-    SettableDraweeHierarchy draweeHierarchy2 = mock(SettableDraweeHierarchy.class);
-    InOrder inOrder = inOrder(draweeHierarchy1, draweeHierarchy2);
-
-    // initial state
-    assertNull(mController.getHierarchy());
-
-    // set controller overlay before hierarchy
-    mController.setControllerOverlay(controllerOverlay1);
-
-    // set drawee hierarchy
-    mController.setHierarchy(draweeHierarchy1);
-    assertSame(draweeHierarchy1, mController.getHierarchy());
-    inOrder.verify(draweeHierarchy1, times(1)).setControllerOverlay(controllerOverlay1);
-    inOrder.verify(draweeHierarchy1, times(0)).reset();
-
-    // change drawee hierarchy
-    mController.setHierarchy(draweeHierarchy2);
-    assertSame(draweeHierarchy2, mController.getHierarchy());
-    inOrder.verify(draweeHierarchy1, times(1)).setControllerOverlay(null);
-    inOrder.verify(draweeHierarchy1, times(0)).reset();
-    inOrder.verify(draweeHierarchy2, times(1)).setControllerOverlay(controllerOverlay1);
-    inOrder.verify(draweeHierarchy2, times(0)).reset();
-
-    // clear drawee hierarchy
-    mController.setHierarchy(null);
-    assertSame(null, mController.getHierarchy());
-    inOrder.verify(draweeHierarchy1, times(0)).setControllerOverlay(any(Drawable.class));
-    inOrder.verify(draweeHierarchy1, times(0)).reset();
-    inOrder.verify(draweeHierarchy2, times(1)).setControllerOverlay(null);
-    inOrder.verify(draweeHierarchy2, times(0)).reset();
-
-    // set drawee hierarchy
-    mController.setHierarchy(draweeHierarchy1);
-    assertSame(draweeHierarchy1, mController.getHierarchy());
-    inOrder.verify(draweeHierarchy1, times(1)).setControllerOverlay(controllerOverlay1);
-    inOrder.verify(draweeHierarchy1, times(0)).reset();
-    inOrder.verify(draweeHierarchy2, times(0)).setControllerOverlay(any(Drawable.class));
-    inOrder.verify(draweeHierarchy2, times(0)).reset();
-
-    // change controller overlay
-    mController.setControllerOverlay(controllerOverlay2);
-    inOrder.verify(draweeHierarchy1, times(1)).setControllerOverlay(controllerOverlay2);
-    inOrder.verify(draweeHierarchy1, times(0)).reset();
-    inOrder.verify(draweeHierarchy2, times(0)).setControllerOverlay(any(Drawable.class));
-    inOrder.verify(draweeHierarchy2, times(0)).reset();
-
-    // clear controller overlay
-    mController.setControllerOverlay(null);
-    inOrder.verify(draweeHierarchy1, times(1)).setControllerOverlay(null);
-    inOrder.verify(draweeHierarchy1, times(0)).reset();
-    inOrder.verify(draweeHierarchy2, times(0)).setControllerOverlay(any(Drawable.class));
-    inOrder.verify(draweeHierarchy2, times(0)).reset();
-  }
-
-  @Test
-  public void testListeners() {
-    ControllerListener<FakeImageInfo> listener1 = mock(ControllerListener.class);
-    ControllerListener<Object> listener2 = mock(ControllerListener.class);
-    InOrder inOrder = inOrder(listener1, listener2);
-
-    mController.getControllerListener().onRelease("id");
-    inOrder.verify(listener1, never()).onRelease(anyString());
-    inOrder.verify(listener2, never()).onRelease(anyString());
-
-    mController.addControllerListener(listener1);
-    mController.getControllerListener().onRelease("id");
-    inOrder.verify(listener1, times(1)).onRelease("id");
-    inOrder.verify(listener2, never()).onRelease(anyString());
-
-    mController.addControllerListener(listener2);
-    mController.getControllerListener().onRelease("id");
-    inOrder.verify(listener1, times(1)).onRelease("id");
-    inOrder.verify(listener2, times(1)).onRelease("id");
-
-    mController.removeControllerListener(listener1);
-    mController.getControllerListener().onRelease("id");
-    inOrder.verify(listener1, never()).onRelease(anyString());
-    inOrder.verify(listener2, times(1)).onRelease("id");
-
-    mController.removeControllerListener(listener2);
-    mController.getControllerListener().onRelease("id");
-    inOrder.verify(listener1, never()).onRelease(anyString());
-    inOrder.verify(listener2, never()).onRelease(anyString());
-  }
-
-  @Test
-  public void testListenerReentrancy_AfterIntermediateSet() {
-    testListenerReentrancy(INTERMEDIATE_FAILURE);
-  }
-
-  @Test
-  public void testListenerReentrancy_AfterIntermediateFailed() {
-    testListenerReentrancy(INTERMEDIATE_GOOD);
-  }
-
-  @Test
-  public void testListenerReentrancy_AfterFinalSet() {
-    testListenerReentrancy(SUCCESS);
-  }
-
-  @Test
-  public void testListenerReentrancy_AfterFailure() {
-    testListenerReentrancy(FAILURE);
-  }
-
-  private void testListenerReentrancy(int outcome) {
-    final SettableDataSource<FakeImage> dataSource0 = SettableDataSource.create();
-    final SettableDataSource<FakeImage> dataSource = SettableDataSource.create();
-    when(mDataSourceSupplier.get()).thenReturn(dataSource0);
-    FakeImage image0 = FakeImage.create(mock(Drawable.class), mock(FakeImageInfo.class));
-    finish(dataSource0, image0, outcome);
-
-    ControllerListener listener = new BaseControllerListener<FakeImageInfo>() {
-      @Override
-      public void onIntermediateImageSet(String id, @Nullable FakeImageInfo imageInfo) {
-        initializeAndAttachController("id_AfterIntermediateSet", dataSource);
-      }
-      @Override
-      public void onIntermediateImageFailed(String id, Throwable throwable) {
-        initializeAndAttachController("id_AfterIntermediateFailed", dataSource);
-      }
-      @Override
-      public void onFinalImageSet(
-          String id,
-          @Nullable FakeImageInfo imageInfo,
-          @Nullable Animatable animatable) {
-        initializeAndAttachController("id_AfterFinalSet", dataSource);
-      }
-      @Override
-      public void onFailure(String id, Throwable throwable) {
-        initializeAndAttachController("id_AfterFailure", dataSource);
-      }
-    };
-
-    mController.addControllerListener(listener);
-    mController.setHierarchy(mDraweeHierarchy);
-    mController.onAttach();
-
-    switch (outcome) {
-      case INTERMEDIATE_GOOD:
-        verifyDhInteraction(SET_IMAGE_P50, image0.getDrawable(), true);
-        Assert.assertEquals("id_AfterIntermediateSet", mController.getId());
-        break;
-      case INTERMEDIATE_FAILURE:
-        verifyDhInteraction(IGNORE, image0.getDrawable(), true);
-        Assert.assertEquals("id_AfterIntermediateFailed", mController.getId());
-        break;
-      case SUCCESS:
-        verifyDhInteraction(SET_IMAGE_P100, image0.getDrawable(), true);
-        Assert.assertEquals("id_AfterFinalSet", mController.getId());
-        break;
-      case FAILURE:
-        verifyDhInteraction(SET_FAILURE, image0.getDrawable(), true);
-        Assert.assertEquals("id_AfterFailure", mController.getId());
-        break;
-    }
-    verify(mDraweeHierarchy).reset();
-
-    FakeImage image = FakeImage.create(mock(Drawable.class), mock(FakeImageInfo.class));
-    finish(dataSource, image, SUCCESS);
-    verifyDhInteraction(SET_IMAGE_P100, image.getDrawable(), false);
-  }
-
-  private void initializeAndAttachController(String id, DataSource<FakeImage> dataSource) {
-    try {
-      when(mDataSourceSupplier.get()).thenReturn(dataSource);
-      mController.initialize(id, mCallerContext);
-      mController.setHierarchy(mDraweeHierarchy);
-      mController.onAttach();
-    } catch (Throwable throwable) {
-      System.err.println(
-          "Exception thrown in listener: " + Throwables.getStackTraceAsString(throwable));
-    }
-  }
-
-  @Test
-  public void testLoading1_DelayedSuccess() {
-    testLoading(false, SUCCESS, SET_IMAGE_P100);
-  }
-
-  @Test
-  public void testLoading1_DelayedFailure() {
-    testLoading(false, FAILURE, SET_FAILURE);
-  }
-
-  @Test
-  public void testLoading1_ImmediateSuccess() {
-    testLoading(true, SUCCESS, SET_IMAGE_P100);
-  }
-
-  @Test
-  public void testLoading1_ImmediateFailure() {
-    testLoading(true, FAILURE, SET_FAILURE);
-  }
-
-  @Test
-  public void testLoadingS_S() {
-    testStreamedLoading(
-        new int[]{SUCCESS},
-        new int[]{SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_F() {
-    testStreamedLoading(
-        new int[]{FAILURE},
-        new int[]{SET_FAILURE});
-  }
-
-  @Test
-  public void testLoadingS_LS() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_LOW, SUCCESS},
-        new int[]{SET_IMAGE_P20, SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_GS() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_GOOD, SUCCESS},
-        new int[]{SET_IMAGE_P50, SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_FS() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_FAILURE, SUCCESS},
-        new int[]{IGNORE, SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_LF() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_LOW, FAILURE},
-        new int[]{SET_IMAGE_P20, SET_FAILURE});
-  }
-
-  @Test
-  public void testLoadingS_GF() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_GOOD, FAILURE},
-        new int[]{SET_IMAGE_P50, SET_FAILURE});
-  }
-
-  @Test
-  public void testLoadingS_FF() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_FAILURE, FAILURE},
-        new int[]{IGNORE, SET_FAILURE});
-  }
-
-  @Test
-  public void testLoadingS_LLS() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_LOW, INTERMEDIATE_LOW, SUCCESS},
-        new int[]{SET_IMAGE_P20, SET_IMAGE_P20, SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_FLS() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_FAILURE, INTERMEDIATE_LOW, SUCCESS},
-        new int[]{IGNORE, SET_IMAGE_P20, SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_LGS() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_LOW, INTERMEDIATE_GOOD, SUCCESS},
-        new int[]{SET_IMAGE_P20, SET_IMAGE_P50, SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_GGS() {
-    testStreamedLoading(
-        0,
-        new int[]{INTERMEDIATE_GOOD, INTERMEDIATE_GOOD, SUCCESS},
-        new int[]{SET_IMAGE_P50, SET_IMAGE_P50, SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_FGS() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_FAILURE, INTERMEDIATE_GOOD, SUCCESS},
-        new int[]{IGNORE, SET_IMAGE_P50, SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_LFS() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_LOW, INTERMEDIATE_FAILURE, SUCCESS},
-        new int[]{SET_IMAGE_P20, IGNORE, SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_GFS() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_GOOD, INTERMEDIATE_FAILURE, SUCCESS},
-        new int[]{SET_IMAGE_P50, IGNORE, SET_IMAGE_P100});
-  }
-
-  @Test
-  public void testLoadingS_FFS() {
-    testStreamedLoading(
-        new int[]{INTERMEDIATE_FAILURE, INTERMEDIATE_FAILURE, SUCCESS},
-        new int[]{IGNORE, IGNORE, SET_IMAGE_P100});
-  }
-
-  /**
-   * Tests a single loading scenario.
-   * @param isImmediate whether the result is immediate or not
-   * @param outcome outcomes of the submitted request
-   * @param dhInteraction expected interaction with drawee hierarchy after the request finishes
-   */
-  private void testLoading(boolean isImmediate, int outcome, int dhInteraction) {
-    FakeDraweeController controller = new FakeDraweeController(
-        mDeferredReleaser,
-        mUiThreadExecutor,
-        mDataSourceSupplier,
-        "id2",
-        mCallerContext);
-
-    // create image and the corresponding data source
-    FakeImage image = FakeImage.create(mock(Drawable.class), mock(FakeImageInfo.class));
-    SettableDataSource<FakeImage> dataSource = SettableDataSource.create();
-    when(mDataSourceSupplier.get()).thenReturn(dataSource);
-
-    // finish immediate
-    if (isImmediate) {
-      finish(dataSource, image, outcome);
-    }
-
-    // attach
-    controller.setHierarchy(mDraweeHierarchy);
-    controller.onAttach();
-
-    // finish delayed
-    if (!isImmediate) {
-      finish(dataSource, image, outcome);
-    }
-
-    // verify
-    verify(mDataSourceSupplier).get();
-    verifyDhInteraction(dhInteraction, image.getDrawable(), isImmediate);
-    assertTrue(dataSource.isClosed());
-
-    // detach
-    controller.onDetach();
-
-    // verify that all open images has been closed
-    assertTrue(image.isOpened() == image.isClosed());
-
-    verifyNoMoreInteractions(mDataSourceSupplier);
-  }
-
-  /**
-   * Tests a suite of loading scenarios with streaming.
-   * @param outcomes outcomes of submitted requests
-   * @param dhInteraction expected interaction with drawee hierarchy after each request finishes
-   */
-  private void testStreamedLoading(int[] outcomes, int[] dhInteraction) {
-    for (int numImmediate = 0; numImmediate <= 1; numImmediate++) {
-      reset(mDataSourceSupplier, mDraweeHierarchy);
-      System.out.println("numImmediate: " + numImmediate);
-      testStreamedLoading(numImmediate, outcomes, dhInteraction);
-    }
-  }
-
-  /**
-   * Tests a single loading scenario with streaming.
-   * @param numImmediate number of immediate results
-   * @param outcomes outcomes of submitted requests
-   * @param dhInteraction expected interaction with drawee hierarchy after each request finishes
-   */
-  private void testStreamedLoading(int numImmediate, int[] outcomes, int[] dhInteraction) {
-    FakeDraweeController controller = new FakeDraweeController(
-        mDeferredReleaser,
-        mUiThreadExecutor,
-        mDataSourceSupplier,
-        "id_streamed",
-        mCallerContext);
-
-    int n = outcomes.length;
-
-    // create data source and images
-    SettableDataSource<FakeImage> dataSource = SettableDataSource.create();
-    when(mDataSourceSupplier.get()).thenReturn(dataSource);
-    List<FakeImage> images = Lists.newArrayList();
-    for (int i = 0; i < n; i++) {
-      images.add(FakeImage.create(mock(Drawable.class), mock(FakeImageInfo.class)));
-    }
-
-    // finish immediate
-    for (int i = 0; i < numImmediate; i++) {
-      finish(dataSource, images.get(i), outcomes[i]);
-    }
-
-    // attach
-    controller.setHierarchy(mDraweeHierarchy);
-    controller.onAttach();
-    verify(mDraweeHierarchy).setProgress(0, true);
-
-    // finish delayed
-    for (int i = numImmediate; i < n; i++) {
-      finish(dataSource, images.get(i), outcomes[i]);
-    }
-
-    // verify
-    verify(mDataSourceSupplier).get();
-    for (int i = 0; i < n; i++) {
-      verifyDhInteraction(dhInteraction[i], images.get(i).getDrawable(), 0 < numImmediate);
-    }
-    assertTrue(dataSource.isClosed());
-
-    // detach
-    controller.onDetach();
-
-    // verify that all open images has been closed
-    for (int i = 0; i < n; i++) {
-      assertTrue(images.get(i).isOpened() == images.get(i).isClosed());
-    }
-
-    verifyNoMoreInteractions(mDataSourceSupplier);
-  }
-
-  private void finish(SettableDataSource<FakeImage> dataSource, FakeImage image, int outcome) {
-    switch (outcome) {
-      case FAILURE:
-        dataSource.setFailure(new RuntimeException());
-        break;
-      case SUCCESS:
-        image.open();
-        dataSource.setResult(image);
-        break;
-      case INTERMEDIATE_FAILURE:
-        dataSource.setResult(createFaultyImage(), false);
-        break;
-      case INTERMEDIATE_LOW:
-        image.open();
-        dataSource.setProgress(0.2f);
-        dataSource.setResult(image, false);
-        break;
-      case INTERMEDIATE_GOOD:
-        image.open();
-        dataSource.setProgress(0.5f);
-        dataSource.setResult(image, false);
-        break;
-      default:
-        throw new UnsupportedOperationException("Unsupported outcome: " + outcome);
-    }
-  }
-
-  private void verifyDhInteraction(int dhInteraction, Drawable drawable, boolean wasImmediate) {
-    switch (dhInteraction) {
-      case IGNORE:
-        verify(mDraweeHierarchy, never()).setImage(eq(drawable), anyFloat(), anyBoolean());
-        break;
-      case SET_IMAGE_P20:
-        verify(mDraweeHierarchy).setImage(eq(drawable), eq(0.2f), eq(wasImmediate));
-        break;
-      case SET_IMAGE_P50:
-        verify(mDraweeHierarchy).setImage(eq(drawable), eq(0.5f), eq(wasImmediate));
-        break;
-      case SET_IMAGE_P100:
-        verify(mDraweeHierarchy).setImage(eq(drawable), eq(1.0f), eq(wasImmediate));
-        break;
-      case SET_FAILURE:
-        verify(mDraweeHierarchy).setFailure(any(Throwable.class));
-        break;
-      case SET_RETRY:
-        verify(mDraweeHierarchy).setRetry(any(Throwable.class));
-        break;
-      default:
-        fail();
-        break;
-    }
-  }
-
-  private static final int FAILURE = 0;
-  private static final int SUCCESS = 1;
-  private static final int INTERMEDIATE_FAILURE = 2;
-  private static final int INTERMEDIATE_LOW = 3;
-  private static final int INTERMEDIATE_GOOD = 4;
-
-  private static final int IGNORE = 1000;
-  private static final int SET_FAILURE = 1001;
-  private static final int SET_RETRY = 1002;
-  private static final int SET_IMAGE_P20 = 1003;
-  private static final int SET_IMAGE_P50 = 1004;
-  private static final int SET_IMAGE_P100 = 1005;
-
-  private static FakeImage createFaultyImage() {
-    return new FakeImage(null, null) {
-      @Override
-      public Drawable getDrawable() {
-        throw new RuntimeException("Faulty intermediate image");
-      }
-    };
-  }
+    private void testListenerReentrancy(int outcome) {
+        final SettableDataSource<FakeImage> dataSource0 = SettableDataSource.create();
+        final SettableDataSource<FakeImage> dataSource = SettableDataSource.create();
+        when(mDataSourceSupplier.get()).thenReturn(dataSource0);
+        FakeImage image0 = FakeImage.create(mock(Drawable.class), mock(FakeImageInfo.class));
+        finish(dataSource0, image0, outcome);
+
+        ControllerListener listener = new BaseControllerListener<FakeImageInfo>() {
+            @Override
+            public void onIntermediateImageSet(String id, @Nullable FakeImageInfo imageInfo) {
+                initializeAndAttachController("id_AfterIntermediateSet", dataSource);
+            }
+
+            @Override
+            public void onIntermediateImageFailed(String id, Throwable throwable) {
+                initializeAndAttachController("id_AfterIntermediateFailed", dataSource);
+            }
+
+            @Override
+            public void onFinalImageSet(
+                    String id,
+                    @Nullable FakeImageInfo imageInfo,
+                    @Nullable Animatable animatable) {
+                initializeAndAttachController("id_AfterFinalSet", dataSource);
+            }
+
+            @Override
+            public void onFailure(String id, Throwable throwable) {
+                initializeAndAttachController("id_AfterFailure", dataSource);
+            }
+        };
+
+        mController.addControllerListener(listener);
+        mController.setHierarchy(mDraweeHierarchy);
+        mController.onAttach();
+
+        switch (outcome) {
+            case INTERMEDIATE_GOOD:
+                verifyDhInteraction(SET_IMAGE_P50, image0.getDrawable(), true);
+                Assert.assertEquals("id_AfterIntermediateSet", mController.getId());
+                break;
+            case INTERMEDIATE_FAILURE:
+                verifyDhInteraction(IGNORE, image0.getDrawable(), true);
+                Assert.assertEquals("id_AfterIntermediateFailed", mController.getId());
+                break;
+            case SUCCESS:
+                verifyDhInteraction(SET_IMAGE_P100, image0.getDrawable(), true);
+                Assert.assertEquals("id_AfterFinalSet", mController.getId());
+                break;
+            case FAILURE:
+                verifyDhInteraction(SET_FAILURE, image0.getDrawable(), true);
+                Assert.assertEquals("id_AfterFailure", mController.getId());
+                break;
+        }
+        verify(mDraweeHierarchy).reset();
+
+        FakeImage image = FakeImage.create(mock(Drawable.class), mock(FakeImageInfo.class));
+        finish(dataSource, image, SUCCESS);
+        verifyDhInteraction(SET_IMAGE_P100, image.getDrawable(), false);
+    }
+
+    private void initializeAndAttachController(String id, DataSource<FakeImage> dataSource) {
+        try {
+            when(mDataSourceSupplier.get()).thenReturn(dataSource);
+            mController.initialize(id, mCallerContext);
+            mController.setHierarchy(mDraweeHierarchy);
+            mController.onAttach();
+        } catch (Throwable throwable) {
+            System.err.println(
+                    "Exception thrown in listener: " + Throwables.getStackTraceAsString(throwable));
+        }
+    }
+
+    @Test
+    public void testLoading1_DelayedSuccess() {
+        testLoading(false, SUCCESS, SET_IMAGE_P100);
+    }
+
+    @Test
+    public void testLoading1_DelayedFailure() {
+        testLoading(false, FAILURE, SET_FAILURE);
+    }
+
+    @Test
+    public void testLoading1_ImmediateSuccess() {
+        testLoading(true, SUCCESS, SET_IMAGE_P100);
+    }
+
+    @Test
+    public void testLoading1_ImmediateFailure() {
+        testLoading(true, FAILURE, SET_FAILURE);
+    }
+
+    @Test
+    public void testLoadingS_S() {
+        testStreamedLoading(
+                new int[]{SUCCESS},
+                new int[]{SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_F() {
+        testStreamedLoading(
+                new int[]{FAILURE},
+                new int[]{SET_FAILURE});
+    }
+
+    @Test
+    public void testLoadingS_LS() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_LOW, SUCCESS},
+                new int[]{SET_IMAGE_P20, SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_GS() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_GOOD, SUCCESS},
+                new int[]{SET_IMAGE_P50, SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_FS() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_FAILURE, SUCCESS},
+                new int[]{IGNORE, SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_LF() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_LOW, FAILURE},
+                new int[]{SET_IMAGE_P20, SET_FAILURE});
+    }
+
+    @Test
+    public void testLoadingS_GF() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_GOOD, FAILURE},
+                new int[]{SET_IMAGE_P50, SET_FAILURE});
+    }
+
+    @Test
+    public void testLoadingS_FF() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_FAILURE, FAILURE},
+                new int[]{IGNORE, SET_FAILURE});
+    }
+
+    @Test
+    public void testLoadingS_LLS() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_LOW, INTERMEDIATE_LOW, SUCCESS},
+                new int[]{SET_IMAGE_P20, SET_IMAGE_P20, SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_FLS() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_FAILURE, INTERMEDIATE_LOW, SUCCESS},
+                new int[]{IGNORE, SET_IMAGE_P20, SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_LGS() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_LOW, INTERMEDIATE_GOOD, SUCCESS},
+                new int[]{SET_IMAGE_P20, SET_IMAGE_P50, SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_GGS() {
+        testStreamedLoading(
+                0,
+                new int[]{INTERMEDIATE_GOOD, INTERMEDIATE_GOOD, SUCCESS},
+                new int[]{SET_IMAGE_P50, SET_IMAGE_P50, SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_FGS() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_FAILURE, INTERMEDIATE_GOOD, SUCCESS},
+                new int[]{IGNORE, SET_IMAGE_P50, SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_LFS() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_LOW, INTERMEDIATE_FAILURE, SUCCESS},
+                new int[]{SET_IMAGE_P20, IGNORE, SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_GFS() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_GOOD, INTERMEDIATE_FAILURE, SUCCESS},
+                new int[]{SET_IMAGE_P50, IGNORE, SET_IMAGE_P100});
+    }
+
+    @Test
+    public void testLoadingS_FFS() {
+        testStreamedLoading(
+                new int[]{INTERMEDIATE_FAILURE, INTERMEDIATE_FAILURE, SUCCESS},
+                new int[]{IGNORE, IGNORE, SET_IMAGE_P100});
+    }
+
+    /**
+     * Tests a single loading scenario.
+     *
+     * @param isImmediate   whether the result is immediate or not
+     * @param outcome       outcomes of the submitted request
+     * @param dhInteraction expected interaction with drawee hierarchy after the request finishes
+     */
+    private void testLoading(boolean isImmediate, int outcome, int dhInteraction) {
+        FakeDraweeController controller = new FakeDraweeController(
+                mDeferredReleaser,
+                mUiThreadExecutor,
+                mDataSourceSupplier,
+                "id2",
+                mCallerContext);
+
+        // create image and the corresponding data source
+        FakeImage image = FakeImage.create(mock(Drawable.class), mock(FakeImageInfo.class));
+        SettableDataSource<FakeImage> dataSource = SettableDataSource.create();
+        when(mDataSourceSupplier.get()).thenReturn(dataSource);
+
+        // finish immediate
+        if (isImmediate) {
+            finish(dataSource, image, outcome);
+        }
+
+        // attach
+        controller.setHierarchy(mDraweeHierarchy);
+        controller.onAttach();
+
+        // finish delayed
+        if (!isImmediate) {
+            finish(dataSource, image, outcome);
+        }
+
+        // verify
+        verify(mDataSourceSupplier).get();
+        verifyDhInteraction(dhInteraction, image.getDrawable(), isImmediate);
+        assertTrue(dataSource.isClosed());
+
+        // detach
+        controller.onDetach();
+
+        // verify that all open images has been closed
+        assertTrue(image.isOpened() == image.isClosed());
+
+        verifyNoMoreInteractions(mDataSourceSupplier);
+    }
+
+    /**
+     * Tests a suite of loading scenarios with streaming.
+     *
+     * @param outcomes      outcomes of submitted requests
+     * @param dhInteraction expected interaction with drawee hierarchy after each request finishes
+     */
+    private void testStreamedLoading(int[] outcomes, int[] dhInteraction) {
+        for (int numImmediate = 0; numImmediate <= 1; numImmediate++) {
+            reset(mDataSourceSupplier, mDraweeHierarchy);
+            System.out.println("numImmediate: " + numImmediate);
+            testStreamedLoading(numImmediate, outcomes, dhInteraction);
+        }
+    }
+
+    /**
+     * Tests a single loading scenario with streaming.
+     *
+     * @param numImmediate  number of immediate results
+     * @param outcomes      outcomes of submitted requests
+     * @param dhInteraction expected interaction with drawee hierarchy after each request finishes
+     */
+    private void testStreamedLoading(int numImmediate, int[] outcomes, int[] dhInteraction) {
+        FakeDraweeController controller = new FakeDraweeController(
+                mDeferredReleaser,
+                mUiThreadExecutor,
+                mDataSourceSupplier,
+                "id_streamed",
+                mCallerContext);
+
+        int n = outcomes.length;
+
+        // create data source and images
+        SettableDataSource<FakeImage> dataSource = SettableDataSource.create();
+        when(mDataSourceSupplier.get()).thenReturn(dataSource);
+        List<FakeImage> images = Lists.newArrayList();
+        for (int i = 0; i < n; i++) {
+            images.add(FakeImage.create(mock(Drawable.class), mock(FakeImageInfo.class)));
+        }
+
+        // finish immediate
+        for (int i = 0; i < numImmediate; i++) {
+            finish(dataSource, images.get(i), outcomes[i]);
+        }
+
+        // attach
+        controller.setHierarchy(mDraweeHierarchy);
+        controller.onAttach();
+        verify(mDraweeHierarchy).setProgress(0, true);
+
+        // finish delayed
+        for (int i = numImmediate; i < n; i++) {
+            finish(dataSource, images.get(i), outcomes[i]);
+        }
+
+        // verify
+        verify(mDataSourceSupplier).get();
+        for (int i = 0; i < n; i++) {
+            verifyDhInteraction(dhInteraction[i], images.get(i).getDrawable(), 0 < numImmediate);
+        }
+        assertTrue(dataSource.isClosed());
+
+        // detach
+        controller.onDetach();
+
+        // verify that all open images has been closed
+        for (int i = 0; i < n; i++) {
+            assertTrue(images.get(i).isOpened() == images.get(i).isClosed());
+        }
+
+        verifyNoMoreInteractions(mDataSourceSupplier);
+    }
+
+    private void finish(SettableDataSource<FakeImage> dataSource, FakeImage image, int outcome) {
+        switch (outcome) {
+            case FAILURE:
+                dataSource.setFailure(new RuntimeException());
+                break;
+            case SUCCESS:
+                image.open();
+                dataSource.setResult(image);
+                break;
+            case INTERMEDIATE_FAILURE:
+                dataSource.setResult(createFaultyImage(), false);
+                break;
+            case INTERMEDIATE_LOW:
+                image.open();
+                dataSource.setProgress(0.2f);
+                dataSource.setResult(image, false);
+                break;
+            case INTERMEDIATE_GOOD:
+                image.open();
+                dataSource.setProgress(0.5f);
+                dataSource.setResult(image, false);
+                break;
+            default:
+                throw new UnsupportedOperationException("Unsupported outcome: " + outcome);
+        }
+    }
+
+    private void verifyDhInteraction(int dhInteraction, Drawable drawable, boolean wasImmediate) {
+        switch (dhInteraction) {
+            case IGNORE:
+                verify(mDraweeHierarchy, never()).setImage(eq(drawable), anyFloat(), anyBoolean());
+                break;
+            case SET_IMAGE_P20:
+                verify(mDraweeHierarchy).setImage(eq(drawable), eq(0.2f), eq(wasImmediate));
+                break;
+            case SET_IMAGE_P50:
+                verify(mDraweeHierarchy).setImage(eq(drawable), eq(0.5f), eq(wasImmediate));
+                break;
+            case SET_IMAGE_P100:
+                verify(mDraweeHierarchy).setImage(eq(drawable), eq(1.0f), eq(wasImmediate));
+                break;
+            case SET_FAILURE:
+                verify(mDraweeHierarchy).setFailure(any(Throwable.class));
+                break;
+            case SET_RETRY:
+                verify(mDraweeHierarchy).setRetry(any(Throwable.class));
+                break;
+            default:
+                fail();
+                break;
+        }
+    }
+
+    private static final int FAILURE = 0;
+    private static final int SUCCESS = 1;
+    private static final int INTERMEDIATE_FAILURE = 2;
+    private static final int INTERMEDIATE_LOW = 3;
+    private static final int INTERMEDIATE_GOOD = 4;
+
+    private static final int IGNORE = 1000;
+    private static final int SET_FAILURE = 1001;
+    private static final int SET_RETRY = 1002;
+    private static final int SET_IMAGE_P20 = 1003;
+    private static final int SET_IMAGE_P50 = 1004;
+    private static final int SET_IMAGE_P100 = 1005;
+
+    private static FakeImage createFaultyImage() {
+        return new FakeImage(null, null) {
+            @Override
+            public Drawable getDrawable() {
+                throw new RuntimeException("Faulty intermediate image");
+            }
+        };
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/AndroidGraphicsTestUtils.java b/drawee/src/test/java/com/facebook/drawee/drawable/AndroidGraphicsTestUtils.java
index d6717a70b..b2a09b9ac 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/AndroidGraphicsTestUtils.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/AndroidGraphicsTestUtils.java
@@ -19,25 +19,25 @@
  */
 public class AndroidGraphicsTestUtils {
 
-  public static void assertEquals(Matrix expectedMatrix, Matrix actualMatrix) {
-    if (expectedMatrix == null) {
-      Assert.assertNull(actualMatrix);
-      return;
+    public static void assertEquals(Matrix expectedMatrix, Matrix actualMatrix) {
+        if (expectedMatrix == null) {
+            Assert.assertNull(actualMatrix);
+            return;
+        }
+        Assert.assertNotNull(actualMatrix);
+        String expected = expectedMatrix.toString();
+        String actual = actualMatrix.toString();
+        if (!actual.equals(expected)) {
+            Assert.fail(String.format("\nexpected %s \nbut was %s", expected, actual));
+        }
     }
-    Assert.assertNotNull(actualMatrix);
-    String expected = expectedMatrix.toString();
-    String actual = actualMatrix.toString();
-    if (!actual.equals(expected)) {
-      Assert.fail(String.format("\nexpected %s \nbut was %s", expected, actual));
-    }
-  }
 
-  public static void assertEquals(PointF expected, PointF actual, float delta) {
-    if (expected == null) {
-      Assert.assertNull(actual);
-      return;
+    public static void assertEquals(PointF expected, PointF actual, float delta) {
+        if (expected == null) {
+            Assert.assertNull(actual);
+            return;
+        }
+        Assert.assertEquals(expected.x, actual.x, delta);
+        Assert.assertEquals(expected.y, actual.y, delta);
     }
-    Assert.assertEquals(expected.x, actual.x, delta);
-    Assert.assertEquals(expected.y, actual.y, delta);
-  }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/ArrayDrawableTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/ArrayDrawableTest.java
index 374d0d035..c646f1b70 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/ArrayDrawableTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/ArrayDrawableTest.java
@@ -33,143 +33,143 @@
 
 @RunWith(WithTestDefaultsRunner.class)
 public class ArrayDrawableTest {
-  private Drawable mUnderlyingDrawable0;
-  private Drawable mUnderlyingDrawable1;
-  private Drawable mUnderlyingDrawable2;
-  private ArrayDrawable mArrayDrawable;
-
-  @Before
-  public void setUp() {
-    mUnderlyingDrawable0 = mock(Drawable.class);
-    mUnderlyingDrawable1 = mock(Drawable.class);
-    mUnderlyingDrawable2 = mock(Drawable.class);
-    when(mUnderlyingDrawable0.mutate()).thenReturn(mUnderlyingDrawable0);
-    when(mUnderlyingDrawable1.mutate()).thenReturn(mUnderlyingDrawable1);
-    when(mUnderlyingDrawable2.mutate()).thenReturn(mUnderlyingDrawable2);
-    mArrayDrawable = new ArrayDrawable(new Drawable[] {
-        mUnderlyingDrawable0,
-        mUnderlyingDrawable1,
-        mUnderlyingDrawable2
-    });
-  }
-
-  @Test
-  public void testIntrinsicDimensions() {
-    when(mUnderlyingDrawable0.getIntrinsicWidth()).thenReturn(100);
-    when(mUnderlyingDrawable1.getIntrinsicWidth()).thenReturn(200);
-    when(mUnderlyingDrawable2.getIntrinsicWidth()).thenReturn(150);
-    when(mUnderlyingDrawable0.getIntrinsicHeight()).thenReturn(500);
-    when(mUnderlyingDrawable1.getIntrinsicHeight()).thenReturn(300);
-    when(mUnderlyingDrawable2.getIntrinsicHeight()).thenReturn(400);
-    Assert.assertEquals(200, mArrayDrawable.getIntrinsicWidth());
-    Assert.assertEquals(500, mArrayDrawable.getIntrinsicHeight());
-  }
-
-  @Test
-  public void testGetDrawable() {
-    Assert.assertEquals(mUnderlyingDrawable0, mArrayDrawable.getDrawable(0));
-    Assert.assertEquals(mUnderlyingDrawable1, mArrayDrawable.getDrawable(1));
-    Assert.assertEquals(mUnderlyingDrawable2, mArrayDrawable.getDrawable(2));
-  }
-
-  @Test
-  public void testDraw() {
-    Canvas mockCanvas = mock(Canvas.class);
-    mArrayDrawable.draw(mockCanvas);
-    verify(mUnderlyingDrawable0).draw(mockCanvas);
-    verify(mUnderlyingDrawable1).draw(mockCanvas);
-    verify(mUnderlyingDrawable2).draw(mockCanvas);
-  }
-
-  @Test
-  public void testOnBoundsChange() {
-    Rect rectMock = mock(Rect.class);
-    mArrayDrawable.onBoundsChange(rectMock);
-    verify(mUnderlyingDrawable0).setBounds(rectMock);
-    verify(mUnderlyingDrawable1).setBounds(rectMock);
-    verify(mUnderlyingDrawable2).setBounds(rectMock);
-  }
-
-  @Test
-  public void testSetAlpha() {
-    mArrayDrawable.setAlpha(11);
-    verify(mUnderlyingDrawable0).setAlpha(11);
-    verify(mUnderlyingDrawable1).setAlpha(11);
-    verify(mUnderlyingDrawable2).setAlpha(11);
-  }
-
-  @Test
-  public void testSetColorFilter() {
-    ColorFilter colorFilter = mock(ColorFilter.class);
-    mArrayDrawable.setColorFilter(colorFilter);
-    verify(mUnderlyingDrawable0).setColorFilter(colorFilter);
-    verify(mUnderlyingDrawable1).setColorFilter(colorFilter);
-    verify(mUnderlyingDrawable2).setColorFilter(colorFilter);
-  }
-
-  @Test
-  public void testSetDither() {
-    testSetDither(true);
-    testSetDither(false);
-  }
-
-  private void testSetDither(boolean dither) {
-    reset(mUnderlyingDrawable0, mUnderlyingDrawable1, mUnderlyingDrawable2);
-    mArrayDrawable.setDither(dither);
-    verify(mUnderlyingDrawable0).setDither(dither);
-    verify(mUnderlyingDrawable1).setDither(dither);
-    verify(mUnderlyingDrawable2).setDither(dither);
-  }
-
-  @Test
-  public void testSetFilterBitmap() {
-    testSetFilterBitmap(true);
-    testSetFilterBitmap(false);
-  }
-
-  private void testSetFilterBitmap(boolean filterBitmap) {
-    mArrayDrawable.setFilterBitmap(filterBitmap);
-    verify(mUnderlyingDrawable0).setFilterBitmap(filterBitmap);
-    verify(mUnderlyingDrawable1).setFilterBitmap(filterBitmap);
-    verify(mUnderlyingDrawable2).setFilterBitmap(filterBitmap);
-  }
-
-  @Test
-  public void testSetVisible() {
-    testSetVisible(true, true);
-    testSetVisible(true, false);
-    testSetVisible(false, true);
-    testSetVisible(false, false);
-  }
-
-  private void testSetVisible(boolean visible, boolean restart) {
-    mArrayDrawable.setVisible(visible, restart);
-    verify(mUnderlyingDrawable0).setVisible(visible, restart);
-    verify(mUnderlyingDrawable1).setVisible(visible, restart);
-    verify(mUnderlyingDrawable2).setVisible(visible, restart);
-  }
-
-  @Test
-  public void testSetDrawableNonMutated() {
-    Drawable newDrawable = mock(Drawable.class);
-    mArrayDrawable.setDrawable(1, newDrawable);
-    assertSame(newDrawable, mArrayDrawable.getDrawable(1));
-    verify(mUnderlyingDrawable1).setCallback(isNull(Drawable.Callback.class));
-    verify(newDrawable).setCallback(eq(mArrayDrawable));
-    verify(newDrawable, never()).mutate();
-  }
-
-  @Test
-  public void testSetDrawableMutated() {
-    BitmapDrawable newDrawable = mock(BitmapDrawable.class);
-    when(newDrawable.mutate()).thenReturn(newDrawable);
-    Rect rect = new Rect(1, 2, 3, 4);
-    when(mUnderlyingDrawable1.getBounds()).thenReturn(rect);
-    mArrayDrawable = (ArrayDrawable) mArrayDrawable.mutate();
-    mArrayDrawable.setDrawable(1, newDrawable);
-    verify(newDrawable).setBounds(eq(rect));
-    verify(mUnderlyingDrawable1).setCallback(isNull(Drawable.Callback.class));
-    verify(newDrawable).setCallback(eq(mArrayDrawable));
-    verify(newDrawable).mutate();
-  }
+    private Drawable mUnderlyingDrawable0;
+    private Drawable mUnderlyingDrawable1;
+    private Drawable mUnderlyingDrawable2;
+    private ArrayDrawable mArrayDrawable;
+
+    @Before
+    public void setUp() {
+        mUnderlyingDrawable0 = mock(Drawable.class);
+        mUnderlyingDrawable1 = mock(Drawable.class);
+        mUnderlyingDrawable2 = mock(Drawable.class);
+        when(mUnderlyingDrawable0.mutate()).thenReturn(mUnderlyingDrawable0);
+        when(mUnderlyingDrawable1.mutate()).thenReturn(mUnderlyingDrawable1);
+        when(mUnderlyingDrawable2.mutate()).thenReturn(mUnderlyingDrawable2);
+        mArrayDrawable = new ArrayDrawable(new Drawable[]{
+                mUnderlyingDrawable0,
+                mUnderlyingDrawable1,
+                mUnderlyingDrawable2
+        });
+    }
+
+    @Test
+    public void testIntrinsicDimensions() {
+        when(mUnderlyingDrawable0.getIntrinsicWidth()).thenReturn(100);
+        when(mUnderlyingDrawable1.getIntrinsicWidth()).thenReturn(200);
+        when(mUnderlyingDrawable2.getIntrinsicWidth()).thenReturn(150);
+        when(mUnderlyingDrawable0.getIntrinsicHeight()).thenReturn(500);
+        when(mUnderlyingDrawable1.getIntrinsicHeight()).thenReturn(300);
+        when(mUnderlyingDrawable2.getIntrinsicHeight()).thenReturn(400);
+        Assert.assertEquals(200, mArrayDrawable.getIntrinsicWidth());
+        Assert.assertEquals(500, mArrayDrawable.getIntrinsicHeight());
+    }
+
+    @Test
+    public void testGetDrawable() {
+        Assert.assertEquals(mUnderlyingDrawable0, mArrayDrawable.getDrawable(0));
+        Assert.assertEquals(mUnderlyingDrawable1, mArrayDrawable.getDrawable(1));
+        Assert.assertEquals(mUnderlyingDrawable2, mArrayDrawable.getDrawable(2));
+    }
+
+    @Test
+    public void testDraw() {
+        Canvas mockCanvas = mock(Canvas.class);
+        mArrayDrawable.draw(mockCanvas);
+        verify(mUnderlyingDrawable0).draw(mockCanvas);
+        verify(mUnderlyingDrawable1).draw(mockCanvas);
+        verify(mUnderlyingDrawable2).draw(mockCanvas);
+    }
+
+    @Test
+    public void testOnBoundsChange() {
+        Rect rectMock = mock(Rect.class);
+        mArrayDrawable.onBoundsChange(rectMock);
+        verify(mUnderlyingDrawable0).setBounds(rectMock);
+        verify(mUnderlyingDrawable1).setBounds(rectMock);
+        verify(mUnderlyingDrawable2).setBounds(rectMock);
+    }
+
+    @Test
+    public void testSetAlpha() {
+        mArrayDrawable.setAlpha(11);
+        verify(mUnderlyingDrawable0).setAlpha(11);
+        verify(mUnderlyingDrawable1).setAlpha(11);
+        verify(mUnderlyingDrawable2).setAlpha(11);
+    }
+
+    @Test
+    public void testSetColorFilter() {
+        ColorFilter colorFilter = mock(ColorFilter.class);
+        mArrayDrawable.setColorFilter(colorFilter);
+        verify(mUnderlyingDrawable0).setColorFilter(colorFilter);
+        verify(mUnderlyingDrawable1).setColorFilter(colorFilter);
+        verify(mUnderlyingDrawable2).setColorFilter(colorFilter);
+    }
+
+    @Test
+    public void testSetDither() {
+        testSetDither(true);
+        testSetDither(false);
+    }
+
+    private void testSetDither(boolean dither) {
+        reset(mUnderlyingDrawable0, mUnderlyingDrawable1, mUnderlyingDrawable2);
+        mArrayDrawable.setDither(dither);
+        verify(mUnderlyingDrawable0).setDither(dither);
+        verify(mUnderlyingDrawable1).setDither(dither);
+        verify(mUnderlyingDrawable2).setDither(dither);
+    }
+
+    @Test
+    public void testSetFilterBitmap() {
+        testSetFilterBitmap(true);
+        testSetFilterBitmap(false);
+    }
+
+    private void testSetFilterBitmap(boolean filterBitmap) {
+        mArrayDrawable.setFilterBitmap(filterBitmap);
+        verify(mUnderlyingDrawable0).setFilterBitmap(filterBitmap);
+        verify(mUnderlyingDrawable1).setFilterBitmap(filterBitmap);
+        verify(mUnderlyingDrawable2).setFilterBitmap(filterBitmap);
+    }
+
+    @Test
+    public void testSetVisible() {
+        testSetVisible(true, true);
+        testSetVisible(true, false);
+        testSetVisible(false, true);
+        testSetVisible(false, false);
+    }
+
+    private void testSetVisible(boolean visible, boolean restart) {
+        mArrayDrawable.setVisible(visible, restart);
+        verify(mUnderlyingDrawable0).setVisible(visible, restart);
+        verify(mUnderlyingDrawable1).setVisible(visible, restart);
+        verify(mUnderlyingDrawable2).setVisible(visible, restart);
+    }
+
+    @Test
+    public void testSetDrawableNonMutated() {
+        Drawable newDrawable = mock(Drawable.class);
+        mArrayDrawable.setDrawable(1, newDrawable);
+        assertSame(newDrawable, mArrayDrawable.getDrawable(1));
+        verify(mUnderlyingDrawable1).setCallback(isNull(Drawable.Callback.class));
+        verify(newDrawable).setCallback(eq(mArrayDrawable));
+        verify(newDrawable, never()).mutate();
+    }
+
+    @Test
+    public void testSetDrawableMutated() {
+        BitmapDrawable newDrawable = mock(BitmapDrawable.class);
+        when(newDrawable.mutate()).thenReturn(newDrawable);
+        Rect rect = new Rect(1, 2, 3, 4);
+        when(mUnderlyingDrawable1.getBounds()).thenReturn(rect);
+        mArrayDrawable = (ArrayDrawable) mArrayDrawable.mutate();
+        mArrayDrawable.setDrawable(1, newDrawable);
+        verify(newDrawable).setBounds(eq(rect));
+        verify(mUnderlyingDrawable1).setCallback(isNull(Drawable.Callback.class));
+        verify(newDrawable).setCallback(eq(mArrayDrawable));
+        verify(newDrawable).mutate();
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/DrawableTestUtils.java b/drawee/src/test/java/com/facebook/drawee/drawable/DrawableTestUtils.java
index b4549388b..dcd44c7cb 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/DrawableTestUtils.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/DrawableTestUtils.java
@@ -30,140 +30,146 @@
 
 public class DrawableTestUtils {
 
-  public static abstract class FakeDrawable extends Drawable implements VisibilityAwareDrawable {
-    @Override
-    public void setVisibilityCallback(VisibilityCallback visibilityCallback) {}
-  }
+    public static abstract class FakeDrawable extends Drawable implements VisibilityAwareDrawable {
+        @Override
+        public void setVisibilityCallback(VisibilityCallback visibilityCallback) {
+        }
+    }
 
-  /**
-   * Creates a mock Drawable with some methods stubbed.
-   * @return mock Drawable
-   */
-  public static Drawable mockDrawable() {
-    FakeDrawable drawable = mock(FakeDrawable.class);
-    when(drawable.mutate()).thenReturn(drawable);
-    stubGetAndSetBounds(drawable);
-    stubGetAndSetCallback(drawable);
-    stubSetVisibilityCallback(drawable);
-    stubSetAlpha(drawable);
-    return drawable;
-  }
+    /**
+     * Creates a mock Drawable with some methods stubbed.
+     *
+     * @return mock Drawable
+     */
+    public static Drawable mockDrawable() {
+        FakeDrawable drawable = mock(FakeDrawable.class);
+        when(drawable.mutate()).thenReturn(drawable);
+        stubGetAndSetBounds(drawable);
+        stubGetAndSetCallback(drawable);
+        stubSetVisibilityCallback(drawable);
+        stubSetAlpha(drawable);
+        return drawable;
+    }
 
-  /**
-   * Stubs setBounds and getBounds methods.
-   * @param drawable drawable to stub methods of
-   */
-  public static void stubGetAndSetBounds(Drawable drawable) {
-    final Rect rect = new Rect();
-    when(drawable.getBounds()).thenReturn(rect);
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            rect.set(
-                (Integer) invocation.getArguments()[0],
-                (Integer) invocation.getArguments()[1],
-                (Integer) invocation.getArguments()[2],
-                (Integer) invocation.getArguments()[3]);
-            return null;
-          }
-        }).when(drawable).setBounds(anyInt(), anyInt(), anyInt(), anyInt());
-  }
+    /**
+     * Stubs setBounds and getBounds methods.
+     *
+     * @param drawable drawable to stub methods of
+     */
+    public static void stubGetAndSetBounds(Drawable drawable) {
+        final Rect rect = new Rect();
+        when(drawable.getBounds()).thenReturn(rect);
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        rect.set(
+                                (Integer) invocation.getArguments()[0],
+                                (Integer) invocation.getArguments()[1],
+                                (Integer) invocation.getArguments()[2],
+                                (Integer) invocation.getArguments()[3]);
+                        return null;
+                    }
+                }).when(drawable).setBounds(anyInt(), anyInt(), anyInt(), anyInt());
+    }
 
-  /**
-   * Stubs setCallback and getCallback methods.
-   * @param drawable drawable to stub methods of
-   */
-  @TargetApi(11)
-  public static void stubGetAndSetCallback(final Drawable drawable) {
-    final AtomicReference<Drawable.Callback> callback =
-        new AtomicReference<Drawable.Callback>();
-    when(drawable.getCallback()).thenReturn(callback.get());
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            callback.set((Drawable.Callback) invocation.getArguments()[0]);
-            return null;
-          }
-        }).when(drawable).setCallback(any(Drawable.Callback.class));
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            if (callback.get() != null) {
-              callback.get().invalidateDrawable(drawable);
-            }
-            return null;
-          }
-        }).when(drawable).invalidateSelf();
-  }
+    /**
+     * Stubs setCallback and getCallback methods.
+     *
+     * @param drawable drawable to stub methods of
+     */
+    @TargetApi(11)
+    public static void stubGetAndSetCallback(final Drawable drawable) {
+        final AtomicReference<Drawable.Callback> callback =
+                new AtomicReference<Drawable.Callback>();
+        when(drawable.getCallback()).thenReturn(callback.get());
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        callback.set((Drawable.Callback) invocation.getArguments()[0]);
+                        return null;
+                    }
+                }).when(drawable).setCallback(any(Drawable.Callback.class));
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        if (callback.get() != null) {
+                            callback.get().invalidateDrawable(drawable);
+                        }
+                        return null;
+                    }
+                }).when(drawable).invalidateSelf();
+    }
 
-  /**
-   * Stubs setVisibilityCallback methods.
-   * @param drawable drawable to stub methods of
-   */
-  public static void stubSetVisibilityCallback(final Drawable drawable) {
-    final AtomicBoolean isVisible = new AtomicBoolean(true);
-    final AtomicReference<VisibilityCallback> callback =
-        new AtomicReference<VisibilityCallback>();
-    if (!(drawable instanceof VisibilityAwareDrawable)) {
-      return;
+    /**
+     * Stubs setVisibilityCallback methods.
+     *
+     * @param drawable drawable to stub methods of
+     */
+    public static void stubSetVisibilityCallback(final Drawable drawable) {
+        final AtomicBoolean isVisible = new AtomicBoolean(true);
+        final AtomicReference<VisibilityCallback> callback =
+                new AtomicReference<VisibilityCallback>();
+        if (!(drawable instanceof VisibilityAwareDrawable)) {
+            return;
+        }
+        VisibilityAwareDrawable visibilityAwareDrawable = (VisibilityAwareDrawable) drawable;
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        callback.set((VisibilityCallback) invocation.getArguments()[0]);
+                        return null;
+                    }
+                }).when(visibilityAwareDrawable).setVisibilityCallback(any(VisibilityCallback.class));
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        if (callback.get() != null) {
+                            isVisible.set((Boolean) invocation.getArguments()[0]);
+                            callback.get().onVisibilityChange(isVisible.get());
+                        }
+                        return null;
+                    }
+                }).when(drawable).setVisible(anyBoolean(), anyBoolean());
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        return isVisible.get();
+                    }
+                }).when(drawable).isVisible();
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        if (callback.get() != null) {
+                            callback.get().onDraw();
+                        }
+                        return null;
+                    }
+                }).when(drawable).draw(any(Canvas.class));
     }
-    VisibilityAwareDrawable visibilityAwareDrawable = (VisibilityAwareDrawable) drawable;
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            callback.set((VisibilityCallback) invocation.getArguments()[0]);
-            return null;
-          }
-        }).when(visibilityAwareDrawable).setVisibilityCallback(any(VisibilityCallback.class));
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            if (callback.get() != null) {
-              isVisible.set((Boolean) invocation.getArguments()[0]);
-              callback.get().onVisibilityChange(isVisible.get());
-            }
-            return null;
-          }
-        }).when(drawable).setVisible(anyBoolean(), anyBoolean());
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            return isVisible.get();
-          }
-        }).when(drawable).isVisible();
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            if (callback.get() != null) {
-              callback.get().onDraw();
-            }
-            return null;
-          }
-        }).when(drawable).draw(any(Canvas.class));
-  }
 
-  /**
-   * Stubs setAlpha method.
-   * @param drawable to stub method of
-   */
-  public static void stubSetAlpha(final Drawable drawable) {
-    final AtomicInteger atomicInteger = new AtomicInteger(255);
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            Integer alpha = (Integer) invocation.getArguments()[0];
-            drawable.invalidateSelf();
-            atomicInteger.set(alpha);
-            return null;
-          }
-        }).when(drawable).setAlpha(anyInt());
-  }
+    /**
+     * Stubs setAlpha method.
+     *
+     * @param drawable to stub method of
+     */
+    public static void stubSetAlpha(final Drawable drawable) {
+        final AtomicInteger atomicInteger = new AtomicInteger(255);
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        Integer alpha = (Integer) invocation.getArguments()[0];
+                        drawable.invalidateSelf();
+                        atomicInteger.set(alpha);
+                        return null;
+                    }
+                }).when(drawable).setAlpha(anyInt());
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/DrawableUtilsTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/DrawableUtilsTest.java
index 56f1442e7..e1d1527d7 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/DrawableUtilsTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/DrawableUtilsTest.java
@@ -29,123 +29,123 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class DrawableUtilsTest {
 
-  private final Rect mBounds = mock(Rect.class);
-  private final int mChangingConfigurations = 0x12345678;
-  private final int mLevel = 3;
-  private final boolean mIsVisible = true;
-  private final int[] mState = new int[5];
-
-  private final Drawable.Callback mCallback = mock(Drawable.Callback.class);
-  private final TransformCallback mTransformCallback = mock(TransformCallback.class);
-
-  @Before
-  public void setup() {
-  }
-
-  private void testCopyProperties(Drawable drawableFrom, Drawable drawableTo) {
-    when(drawableFrom.getBounds()).thenReturn(mBounds);
-    when(drawableFrom.getChangingConfigurations()).thenReturn(mChangingConfigurations);
-    when(drawableFrom.getLevel()).thenReturn(mLevel);
-    when(drawableFrom.isVisible()).thenReturn(mIsVisible);
-    when(drawableFrom.getState()).thenReturn(mState);
-    DrawableUtils.copyProperties(drawableTo, drawableFrom);
-    verify(drawableTo).setBounds(mBounds);
-    verify(drawableTo).setChangingConfigurations(mChangingConfigurations);
-    verify(drawableTo).setLevel(mLevel);
-    verify(drawableTo).setVisible(mIsVisible, false);
-    verify(drawableTo).setState(mState);
-  }
-
-  @Test
-  public void testCopyProperties() {
-    testCopyProperties(mock(Drawable.class), mock(Drawable.class));
-  }
-
-  @Test
-  public void testSetDrawableProperties() {
-    DrawableProperties properties = mock(DrawableProperties.class);
-    ColorFilter colorFilter = mock(ColorFilter.class);
-    when(properties.getAlpha()).thenReturn(42);
-    when(properties.getColorFilter()).thenReturn(colorFilter);
-    when(properties.isDither()).thenReturn(true);
-    when(properties.isFilterBitmap()).thenReturn(true);
-    Drawable drawableTo = mock(Drawable.class);
-    DrawableUtils.setDrawableProperties(drawableTo, properties);
-    verify(drawableTo).setAlpha(42);
-    verify(drawableTo).setColorFilter(colorFilter);
-    verify(drawableTo).setDither(true);
-    verify(drawableTo).setFilterBitmap(true);
-  }
-
-  @Test
-  public void testCopyProperties_Null() {
-    Drawable drawableFrom = mock(Drawable.class);
-    Drawable drawableTo = mock(Drawable.class);
-    DrawableUtils.copyProperties(null, drawableFrom);
-    DrawableUtils.copyProperties(drawableTo, null);
-    verifyNoMoreInteractions(drawableTo, drawableFrom);
-  }
-
-  @Test
-  public void testCopyProperties_Same() {
-    Drawable drawable = mock(Drawable.class);
-    DrawableUtils.copyProperties(drawable, drawable);
-    verifyNoMoreInteractions(drawable);
-  }
-
-  @Test
-  public void testSetCallbacks() {
-    Drawable drawable = mock(Drawable.class);
-    DrawableUtils.setCallbacks(drawable, mCallback, mTransformCallback);
-    verify(drawable).setCallback(mCallback);
-  }
-
-  @Test
-  public void testSetCallbacks_TransformAwareDrawable() {
-    ForwardingDrawable transformAwareDrawable = mock(ForwardingDrawable.class);
-    DrawableUtils.setCallbacks(transformAwareDrawable, mCallback, mTransformCallback);
-    verify(transformAwareDrawable).setCallback(mCallback);
-    verify(transformAwareDrawable).setTransformCallback(mTransformCallback);
-  }
-
-  @Test
-  public void testSetCallbacks_NullCallback() {
-    Drawable drawable = mock(Drawable.class);
-    DrawableUtils.setCallbacks(drawable, null, null);
-    verify(drawable).setCallback(null);
-  }
-
-  @Test
-  public void testSetCallbacks_TransformAwareDrawable_NullCallback() {
-    ForwardingDrawable transformAwareDrawable = mock(ForwardingDrawable.class);
-    DrawableUtils.setCallbacks(transformAwareDrawable, null, null);
-    verify(transformAwareDrawable).setCallback(null);
-    verify(transformAwareDrawable).setTransformCallback(null);
-  }
-
-  @Test
-  public void testSetCallbacks_NullDrawable() {
-    DrawableUtils.setCallbacks(null, mCallback, mTransformCallback);
-  }
-
-  @Test
-  public void testMultiplyColorAlpha() {
-    assertEquals(0x00123456, DrawableUtils.multiplyColorAlpha(0xC0123456, 0));
-    assertEquals(0x07123456, DrawableUtils.multiplyColorAlpha(0xC0123456, 10));
-    assertEquals(0x96123456, DrawableUtils.multiplyColorAlpha(0xC0123456, 200));
-    assertEquals(0xC0123456, DrawableUtils.multiplyColorAlpha(0xC0123456, 255));
-  }
-
-  @Test
-  public void testGetOpacityFromColor() {
-    assertEquals(PixelFormat.TRANSPARENT, DrawableUtils.getOpacityFromColor(0x00000000));
-    assertEquals(PixelFormat.TRANSPARENT, DrawableUtils.getOpacityFromColor(0x00123456));
-    assertEquals(PixelFormat.TRANSPARENT, DrawableUtils.getOpacityFromColor(0x00FFFFFF));
-    assertEquals(PixelFormat.TRANSLUCENT, DrawableUtils.getOpacityFromColor(0xC0000000));
-    assertEquals(PixelFormat.TRANSLUCENT, DrawableUtils.getOpacityFromColor(0xC0123456));
-    assertEquals(PixelFormat.TRANSLUCENT, DrawableUtils.getOpacityFromColor(0xC0FFFFFF));
-    assertEquals(PixelFormat.OPAQUE, DrawableUtils.getOpacityFromColor(0xFF000000));
-    assertEquals(PixelFormat.OPAQUE, DrawableUtils.getOpacityFromColor(0xFF123456));
-    assertEquals(PixelFormat.OPAQUE, DrawableUtils.getOpacityFromColor(0xFFFFFFFF));
-  }
+    private final Rect mBounds = mock(Rect.class);
+    private final int mChangingConfigurations = 0x12345678;
+    private final int mLevel = 3;
+    private final boolean mIsVisible = true;
+    private final int[] mState = new int[5];
+
+    private final Drawable.Callback mCallback = mock(Drawable.Callback.class);
+    private final TransformCallback mTransformCallback = mock(TransformCallback.class);
+
+    @Before
+    public void setup() {
+    }
+
+    private void testCopyProperties(Drawable drawableFrom, Drawable drawableTo) {
+        when(drawableFrom.getBounds()).thenReturn(mBounds);
+        when(drawableFrom.getChangingConfigurations()).thenReturn(mChangingConfigurations);
+        when(drawableFrom.getLevel()).thenReturn(mLevel);
+        when(drawableFrom.isVisible()).thenReturn(mIsVisible);
+        when(drawableFrom.getState()).thenReturn(mState);
+        DrawableUtils.copyProperties(drawableTo, drawableFrom);
+        verify(drawableTo).setBounds(mBounds);
+        verify(drawableTo).setChangingConfigurations(mChangingConfigurations);
+        verify(drawableTo).setLevel(mLevel);
+        verify(drawableTo).setVisible(mIsVisible, false);
+        verify(drawableTo).setState(mState);
+    }
+
+    @Test
+    public void testCopyProperties() {
+        testCopyProperties(mock(Drawable.class), mock(Drawable.class));
+    }
+
+    @Test
+    public void testSetDrawableProperties() {
+        DrawableProperties properties = mock(DrawableProperties.class);
+        ColorFilter colorFilter = mock(ColorFilter.class);
+        when(properties.getAlpha()).thenReturn(42);
+        when(properties.getColorFilter()).thenReturn(colorFilter);
+        when(properties.isDither()).thenReturn(true);
+        when(properties.isFilterBitmap()).thenReturn(true);
+        Drawable drawableTo = mock(Drawable.class);
+        DrawableUtils.setDrawableProperties(drawableTo, properties);
+        verify(drawableTo).setAlpha(42);
+        verify(drawableTo).setColorFilter(colorFilter);
+        verify(drawableTo).setDither(true);
+        verify(drawableTo).setFilterBitmap(true);
+    }
+
+    @Test
+    public void testCopyProperties_Null() {
+        Drawable drawableFrom = mock(Drawable.class);
+        Drawable drawableTo = mock(Drawable.class);
+        DrawableUtils.copyProperties(null, drawableFrom);
+        DrawableUtils.copyProperties(drawableTo, null);
+        verifyNoMoreInteractions(drawableTo, drawableFrom);
+    }
+
+    @Test
+    public void testCopyProperties_Same() {
+        Drawable drawable = mock(Drawable.class);
+        DrawableUtils.copyProperties(drawable, drawable);
+        verifyNoMoreInteractions(drawable);
+    }
+
+    @Test
+    public void testSetCallbacks() {
+        Drawable drawable = mock(Drawable.class);
+        DrawableUtils.setCallbacks(drawable, mCallback, mTransformCallback);
+        verify(drawable).setCallback(mCallback);
+    }
+
+    @Test
+    public void testSetCallbacks_TransformAwareDrawable() {
+        ForwardingDrawable transformAwareDrawable = mock(ForwardingDrawable.class);
+        DrawableUtils.setCallbacks(transformAwareDrawable, mCallback, mTransformCallback);
+        verify(transformAwareDrawable).setCallback(mCallback);
+        verify(transformAwareDrawable).setTransformCallback(mTransformCallback);
+    }
+
+    @Test
+    public void testSetCallbacks_NullCallback() {
+        Drawable drawable = mock(Drawable.class);
+        DrawableUtils.setCallbacks(drawable, null, null);
+        verify(drawable).setCallback(null);
+    }
+
+    @Test
+    public void testSetCallbacks_TransformAwareDrawable_NullCallback() {
+        ForwardingDrawable transformAwareDrawable = mock(ForwardingDrawable.class);
+        DrawableUtils.setCallbacks(transformAwareDrawable, null, null);
+        verify(transformAwareDrawable).setCallback(null);
+        verify(transformAwareDrawable).setTransformCallback(null);
+    }
+
+    @Test
+    public void testSetCallbacks_NullDrawable() {
+        DrawableUtils.setCallbacks(null, mCallback, mTransformCallback);
+    }
+
+    @Test
+    public void testMultiplyColorAlpha() {
+        assertEquals(0x00123456, DrawableUtils.multiplyColorAlpha(0xC0123456, 0));
+        assertEquals(0x07123456, DrawableUtils.multiplyColorAlpha(0xC0123456, 10));
+        assertEquals(0x96123456, DrawableUtils.multiplyColorAlpha(0xC0123456, 200));
+        assertEquals(0xC0123456, DrawableUtils.multiplyColorAlpha(0xC0123456, 255));
+    }
+
+    @Test
+    public void testGetOpacityFromColor() {
+        assertEquals(PixelFormat.TRANSPARENT, DrawableUtils.getOpacityFromColor(0x00000000));
+        assertEquals(PixelFormat.TRANSPARENT, DrawableUtils.getOpacityFromColor(0x00123456));
+        assertEquals(PixelFormat.TRANSPARENT, DrawableUtils.getOpacityFromColor(0x00FFFFFF));
+        assertEquals(PixelFormat.TRANSLUCENT, DrawableUtils.getOpacityFromColor(0xC0000000));
+        assertEquals(PixelFormat.TRANSLUCENT, DrawableUtils.getOpacityFromColor(0xC0123456));
+        assertEquals(PixelFormat.TRANSLUCENT, DrawableUtils.getOpacityFromColor(0xC0FFFFFF));
+        assertEquals(PixelFormat.OPAQUE, DrawableUtils.getOpacityFromColor(0xFF000000));
+        assertEquals(PixelFormat.OPAQUE, DrawableUtils.getOpacityFromColor(0xFF123456));
+        assertEquals(PixelFormat.OPAQUE, DrawableUtils.getOpacityFromColor(0xFFFFFFFF));
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/FadeDrawableTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/FadeDrawableTest.java
index 2e08b44d1..b52db8b97 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/FadeDrawableTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/FadeDrawableTest.java
@@ -25,390 +25,393 @@
 
 @RunWith(WithTestDefaultsRunner.class)
 public class FadeDrawableTest {
-  private Drawable[] mLayers = new Drawable[] {
-      DrawableTestUtils.mockDrawable(),
-      DrawableTestUtils.mockDrawable(),
-      DrawableTestUtils.mockDrawable(),
-  };
-
-  private FakeClock mFakeClock;
-  private FadeDrawable mFadeDrawable;
-  private Canvas mCanvas = mock(Canvas.class);
-  private Drawable.Callback mCallback = mock(Drawable.Callback.class);
-
-  @Before
-  public void setUp() {
-    mFakeClock = new FakeClock();
-    mFadeDrawable = new FakeFadeDrawable(mFakeClock, mLayers);
-    mFadeDrawable.setCallback(mCallback);
-  }
-
-  private void resetInteractions() {
-    reset(mCallback, mLayers[0], mLayers[1], mLayers[2]);
-    when(mLayers[0].mutate()).thenReturn(mLayers[0]);
-    when(mLayers[1].mutate()).thenReturn(mLayers[1]);
-    when(mLayers[2].mutate()).thenReturn(mLayers[2]);
-  }
-
-  @Test
-  public void testIntrinsicDimensions() {
-    when(mLayers[0].getIntrinsicWidth()).thenReturn(100);
-    when(mLayers[1].getIntrinsicWidth()).thenReturn(200);
-    when(mLayers[2].getIntrinsicWidth()).thenReturn(150);
-    when(mLayers[0].getIntrinsicHeight()).thenReturn(400);
-    when(mLayers[1].getIntrinsicHeight()).thenReturn(350);
-    when(mLayers[2].getIntrinsicHeight()).thenReturn(300);
-    Assert.assertEquals(200, mFadeDrawable.getIntrinsicWidth());
-    Assert.assertEquals(400, mFadeDrawable.getIntrinsicHeight());
-  }
-
-  @Test
-  public void testInitialState() {
-    // initially only the fist layer is displayed and there is no transition
-    Assert.assertEquals(FadeDrawable.TRANSITION_NONE, mFadeDrawable.mTransitionState);
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-  }
-
-  @Test
-  public void testFadeToLayer() {
-    // start fade
-    mFadeDrawable.setTransitionDuration(100);
-    mFadeDrawable.fadeToLayer(1);
-    Assert.assertEquals(100, mFadeDrawable.mDurationMs);
-    Assert.assertEquals(FadeDrawable.TRANSITION_STARTING, mFadeDrawable.mTransitionState);
-    verify(mCallback).invalidateDrawable(mFadeDrawable);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-    // alphas will change only when the next draw happens
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-  }
-
-  @Test
-  public void testFadeUpToLayer() {
-    // start fade
-    mFadeDrawable.setTransitionDuration(100);
-    mFadeDrawable.fadeUpToLayer(1);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-    Assert.assertEquals(100, mFadeDrawable.mDurationMs);
-    Assert.assertEquals(FadeDrawable.TRANSITION_STARTING, mFadeDrawable.mTransitionState);
-    verify(mCallback).invalidateDrawable(mFadeDrawable);
-    // alphas will change only when the next draw happens
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-  }
-
-  @Test
-  public void testFadeInLayer() {
-    //start fade in
-    mFadeDrawable.setTransitionDuration(100);
-    mFadeDrawable.fadeInLayer(2);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[2]);
-    Assert.assertEquals(100, mFadeDrawable.mDurationMs);
-    Assert.assertEquals(FadeDrawable.TRANSITION_STARTING, mFadeDrawable.mTransitionState);
-    verify(mCallback).invalidateDrawable(mFadeDrawable);
-    // alphas will change only when the next draw happens
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-  }
-
-  @Test
-  public void testFadeOutLayer() {
-    //start fade out
-    mFadeDrawable.setTransitionDuration(100);
-    mFadeDrawable.fadeOutLayer(0);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-    Assert.assertEquals(100, mFadeDrawable.mDurationMs);
-    Assert.assertEquals(FadeDrawable.TRANSITION_STARTING, mFadeDrawable.mTransitionState);
-    verify(mCallback).invalidateDrawable(mFadeDrawable);
-    // alphas will change only when the next draw happens
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-  }
-
-  @Test
-  public void testFadeOutAllLayers() {
-    //start fade out
-    mFadeDrawable.setTransitionDuration(100);
-    mFadeDrawable.mIsLayerOn[1] = true;
-    mFadeDrawable.mIsLayerOn[2] = true;
-    mFadeDrawable.fadeOutAllLayers();
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-    Assert.assertEquals(100, mFadeDrawable.mDurationMs);
-    Assert.assertEquals(FadeDrawable.TRANSITION_STARTING, mFadeDrawable.mTransitionState);
-    verify(mCallback).invalidateDrawable(mFadeDrawable);
-    // alphas will change only when the next draw happens
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-  }
-
-  @Test
-  public void testImmediateTransition() {
-    testImmediateTransition(true);
-    testImmediateTransition(false);
-  }
-  private void testImmediateTransition(boolean fadeUpToLayer) {
-    resetInteractions();
-    if (fadeUpToLayer) {
-      mFadeDrawable.fadeUpToLayer(1);
-    } else {
-      mFadeDrawable.fadeToLayer(1);
+    private Drawable[] mLayers = new Drawable[]{
+            DrawableTestUtils.mockDrawable(),
+            DrawableTestUtils.mockDrawable(),
+            DrawableTestUtils.mockDrawable(),
+    };
+
+    private FakeClock mFakeClock;
+    private FadeDrawable mFadeDrawable;
+    private Canvas mCanvas = mock(Canvas.class);
+    private Drawable.Callback mCallback = mock(Drawable.Callback.class);
+
+    @Before
+    public void setUp() {
+        mFakeClock = new FakeClock();
+        mFadeDrawable = new FakeFadeDrawable(mFakeClock, mLayers);
+        mFadeDrawable.setCallback(mCallback);
     }
-    Assert.assertEquals(fadeUpToLayer, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-    verify(mCallback).invalidateDrawable(mFadeDrawable);
-
-    mFadeDrawable.finishTransitionImmediately();
-    verify(mCallback, times(2)).invalidateDrawable(mFadeDrawable);
-    Assert.assertEquals(fadeUpToLayer ? 255 : 0, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-    Assert.assertEquals(FadeDrawable.TRANSITION_NONE, mFadeDrawable.mTransitionState);
-  }
-
-  @Test
-  public void testZeroTransition() {
-    testZeroTransition(true);
-    testZeroTransition(false);
-  }
-  private void testZeroTransition(boolean fadeUpToLayer) {
-    resetInteractions();
-    mFadeDrawable.setTransitionDuration(0);
-    if (fadeUpToLayer) {
-      mFadeDrawable.fadeUpToLayer(1);
-    } else {
-      mFadeDrawable.fadeToLayer(1);
+
+    private void resetInteractions() {
+        reset(mCallback, mLayers[0], mLayers[1], mLayers[2]);
+        when(mLayers[0].mutate()).thenReturn(mLayers[0]);
+        when(mLayers[1].mutate()).thenReturn(mLayers[1]);
+        when(mLayers[2].mutate()).thenReturn(mLayers[2]);
+    }
+
+    @Test
+    public void testIntrinsicDimensions() {
+        when(mLayers[0].getIntrinsicWidth()).thenReturn(100);
+        when(mLayers[1].getIntrinsicWidth()).thenReturn(200);
+        when(mLayers[2].getIntrinsicWidth()).thenReturn(150);
+        when(mLayers[0].getIntrinsicHeight()).thenReturn(400);
+        when(mLayers[1].getIntrinsicHeight()).thenReturn(350);
+        when(mLayers[2].getIntrinsicHeight()).thenReturn(300);
+        Assert.assertEquals(200, mFadeDrawable.getIntrinsicWidth());
+        Assert.assertEquals(400, mFadeDrawable.getIntrinsicHeight());
+    }
+
+    @Test
+    public void testInitialState() {
+        // initially only the fist layer is displayed and there is no transition
+        Assert.assertEquals(FadeDrawable.TRANSITION_NONE, mFadeDrawable.mTransitionState);
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
+    }
+
+    @Test
+    public void testFadeToLayer() {
+        // start fade
+        mFadeDrawable.setTransitionDuration(100);
+        mFadeDrawable.fadeToLayer(1);
+        Assert.assertEquals(100, mFadeDrawable.mDurationMs);
+        Assert.assertEquals(FadeDrawable.TRANSITION_STARTING, mFadeDrawable.mTransitionState);
+        verify(mCallback).invalidateDrawable(mFadeDrawable);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
+        // alphas will change only when the next draw happens
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+    }
+
+    @Test
+    public void testFadeUpToLayer() {
+        // start fade
+        mFadeDrawable.setTransitionDuration(100);
+        mFadeDrawable.fadeUpToLayer(1);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
+        Assert.assertEquals(100, mFadeDrawable.mDurationMs);
+        Assert.assertEquals(FadeDrawable.TRANSITION_STARTING, mFadeDrawable.mTransitionState);
+        verify(mCallback).invalidateDrawable(mFadeDrawable);
+        // alphas will change only when the next draw happens
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+    }
+
+    @Test
+    public void testFadeInLayer() {
+        //start fade in
+        mFadeDrawable.setTransitionDuration(100);
+        mFadeDrawable.fadeInLayer(2);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[2]);
+        Assert.assertEquals(100, mFadeDrawable.mDurationMs);
+        Assert.assertEquals(FadeDrawable.TRANSITION_STARTING, mFadeDrawable.mTransitionState);
+        verify(mCallback).invalidateDrawable(mFadeDrawable);
+        // alphas will change only when the next draw happens
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+    }
+
+    @Test
+    public void testFadeOutLayer() {
+        //start fade out
+        mFadeDrawable.setTransitionDuration(100);
+        mFadeDrawable.fadeOutLayer(0);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
+        Assert.assertEquals(100, mFadeDrawable.mDurationMs);
+        Assert.assertEquals(FadeDrawable.TRANSITION_STARTING, mFadeDrawable.mTransitionState);
+        verify(mCallback).invalidateDrawable(mFadeDrawable);
+        // alphas will change only when the next draw happens
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+    }
+
+    @Test
+    public void testFadeOutAllLayers() {
+        //start fade out
+        mFadeDrawable.setTransitionDuration(100);
+        mFadeDrawable.mIsLayerOn[1] = true;
+        mFadeDrawable.mIsLayerOn[2] = true;
+        mFadeDrawable.fadeOutAllLayers();
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
+        Assert.assertEquals(100, mFadeDrawable.mDurationMs);
+        Assert.assertEquals(FadeDrawable.TRANSITION_STARTING, mFadeDrawable.mTransitionState);
+        verify(mCallback).invalidateDrawable(mFadeDrawable);
+        // alphas will change only when the next draw happens
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+    }
+
+    @Test
+    public void testImmediateTransition() {
+        testImmediateTransition(true);
+        testImmediateTransition(false);
     }
-    Assert.assertEquals(fadeUpToLayer, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-    verify(mCallback).invalidateDrawable(mFadeDrawable);
-
-    mFadeDrawable.draw(mCanvas);
-    Assert.assertEquals(fadeUpToLayer ? 255 : 0, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-    Assert.assertEquals(FadeDrawable.TRANSITION_NONE, mFadeDrawable.mTransitionState);
-    if (fadeUpToLayer) {
-      verify(mLayers[0]).draw(mCanvas);
+
+    private void testImmediateTransition(boolean fadeUpToLayer) {
+        resetInteractions();
+        if (fadeUpToLayer) {
+            mFadeDrawable.fadeUpToLayer(1);
+        } else {
+            mFadeDrawable.fadeToLayer(1);
+        }
+        Assert.assertEquals(fadeUpToLayer, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
+        verify(mCallback).invalidateDrawable(mFadeDrawable);
+
+        mFadeDrawable.finishTransitionImmediately();
+        verify(mCallback, times(2)).invalidateDrawable(mFadeDrawable);
+        Assert.assertEquals(fadeUpToLayer ? 255 : 0, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+        Assert.assertEquals(FadeDrawable.TRANSITION_NONE, mFadeDrawable.mTransitionState);
     }
-    verify(mLayers[1]).draw(mCanvas);
-  }
-
-  @Test
-  public void testTransition() {
-    testTransition(true);
-    testTransition(false);
-  }
-  private void testTransition(boolean fadeUpToLayer) {
-    // duration is set to 85 ms
-    // 85 = 5 * 17; 5 frames of 17ms
-    // 255 / 5 = 51; each frame alpha should increase by 51
-
-    // reset drawable
-    mFadeDrawable.reset();
-
-    // start animation
-    resetInteractions();
-    mFadeDrawable.setTransitionDuration(85);
-    if (fadeUpToLayer) {
-      mFadeDrawable.fadeUpToLayer(1);
-    } else {
-      mFadeDrawable.fadeToLayer(1);
+
+    @Test
+    public void testZeroTransition() {
+        testZeroTransition(true);
+        testZeroTransition(false);
     }
-    Assert.assertEquals(fadeUpToLayer, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-    verify(mCallback).invalidateDrawable(mFadeDrawable);
-    verifyNoMoreInteractions(mCallback, mLayers[0], mLayers[1], mLayers[2]);
-
-    // first frame
-    resetInteractions();
-    mFadeDrawable.draw(mCanvas);
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-    Assert.assertEquals(FadeDrawable.TRANSITION_RUNNING, mFadeDrawable.mTransitionState);
-    verify(mLayers[0]).mutate();
-    verify(mLayers[0]).setAlpha(255);
-    verify(mLayers[0]).draw(mCanvas);
-    verify(mCallback).invalidateDrawable(mFadeDrawable);
-    verifyNoMoreInteractions(mCallback, mLayers[0], mLayers[1], mLayers[2]);
-
-    // intermediate frames
-    for (int i = 1; i < 5; i++) {
-      resetInteractions();
-      mFakeClock.incrementBy(17);
-      mFadeDrawable.draw(mCanvas);
-      Assert.assertEquals(fadeUpToLayer ? 255 : 255 - 51 * i, mFadeDrawable.mAlphas[0]);
-      Assert.assertEquals(51 * i, mFadeDrawable.mAlphas[1]);
-      Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-      Assert.assertEquals(FadeDrawable.TRANSITION_RUNNING, mFadeDrawable.mTransitionState);
-      if (fadeUpToLayer) {
+
+    private void testZeroTransition(boolean fadeUpToLayer) {
+        resetInteractions();
+        mFadeDrawable.setTransitionDuration(0);
+        if (fadeUpToLayer) {
+            mFadeDrawable.fadeUpToLayer(1);
+        } else {
+            mFadeDrawable.fadeToLayer(1);
+        }
+        Assert.assertEquals(fadeUpToLayer, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
+        verify(mCallback).invalidateDrawable(mFadeDrawable);
+
+        mFadeDrawable.draw(mCanvas);
+        Assert.assertEquals(fadeUpToLayer ? 255 : 0, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+        Assert.assertEquals(FadeDrawable.TRANSITION_NONE, mFadeDrawable.mTransitionState);
+        if (fadeUpToLayer) {
+            verify(mLayers[0]).draw(mCanvas);
+        }
+        verify(mLayers[1]).draw(mCanvas);
+    }
+
+    @Test
+    public void testTransition() {
+        testTransition(true);
+        testTransition(false);
+    }
+
+    private void testTransition(boolean fadeUpToLayer) {
+        // duration is set to 85 ms
+        // 85 = 5 * 17; 5 frames of 17ms
+        // 255 / 5 = 51; each frame alpha should increase by 51
+
+        // reset drawable
+        mFadeDrawable.reset();
+
+        // start animation
+        resetInteractions();
+        mFadeDrawable.setTransitionDuration(85);
+        if (fadeUpToLayer) {
+            mFadeDrawable.fadeUpToLayer(1);
+        } else {
+            mFadeDrawable.fadeToLayer(1);
+        }
+        Assert.assertEquals(fadeUpToLayer, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
+        verify(mCallback).invalidateDrawable(mFadeDrawable);
+        verifyNoMoreInteractions(mCallback, mLayers[0], mLayers[1], mLayers[2]);
+
+        // first frame
+        resetInteractions();
+        mFadeDrawable.draw(mCanvas);
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+        Assert.assertEquals(FadeDrawable.TRANSITION_RUNNING, mFadeDrawable.mTransitionState);
         verify(mLayers[0]).mutate();
         verify(mLayers[0]).setAlpha(255);
         verify(mLayers[0]).draw(mCanvas);
-      } else {
-        verify(mLayers[0]).mutate();
-        verify(mLayers[0]).setAlpha(255 - 51 * i);
-        verify(mLayers[0]).draw(mCanvas);
-      }
-      verify(mLayers[1]).mutate();
-      verify(mLayers[1]).setAlpha(51 * i);
-      verify(mLayers[1]).draw(mCanvas);
-      verify(mCallback).invalidateDrawable(mFadeDrawable);
-      verifyNoMoreInteractions(mCallback, mLayers[0], mLayers[1], mLayers[2]);
+        verify(mCallback).invalidateDrawable(mFadeDrawable);
+        verifyNoMoreInteractions(mCallback, mLayers[0], mLayers[1], mLayers[2]);
+
+        // intermediate frames
+        for (int i = 1; i < 5; i++) {
+            resetInteractions();
+            mFakeClock.incrementBy(17);
+            mFadeDrawable.draw(mCanvas);
+            Assert.assertEquals(fadeUpToLayer ? 255 : 255 - 51 * i, mFadeDrawable.mAlphas[0]);
+            Assert.assertEquals(51 * i, mFadeDrawable.mAlphas[1]);
+            Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+            Assert.assertEquals(FadeDrawable.TRANSITION_RUNNING, mFadeDrawable.mTransitionState);
+            if (fadeUpToLayer) {
+                verify(mLayers[0]).mutate();
+                verify(mLayers[0]).setAlpha(255);
+                verify(mLayers[0]).draw(mCanvas);
+            } else {
+                verify(mLayers[0]).mutate();
+                verify(mLayers[0]).setAlpha(255 - 51 * i);
+                verify(mLayers[0]).draw(mCanvas);
+            }
+            verify(mLayers[1]).mutate();
+            verify(mLayers[1]).setAlpha(51 * i);
+            verify(mLayers[1]).draw(mCanvas);
+            verify(mCallback).invalidateDrawable(mFadeDrawable);
+            verifyNoMoreInteractions(mCallback, mLayers[0], mLayers[1], mLayers[2]);
+        }
+
+        // last frame
+        resetInteractions();
+        mFakeClock.incrementBy(17);
+        mFadeDrawable.draw(mCanvas);
+        Assert.assertEquals(fadeUpToLayer ? 255 : 0, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+        Assert.assertEquals(FadeDrawable.TRANSITION_NONE, mFadeDrawable.mTransitionState);
+        if (fadeUpToLayer) {
+            verify(mLayers[0]).mutate();
+            verify(mLayers[0]).setAlpha(255);
+            verify(mLayers[0]).draw(mCanvas);
+        }
+        verify(mLayers[1]).mutate();
+        verify(mLayers[1]).setAlpha(255);
+        verify(mLayers[1]).draw(mCanvas);
+        verifyNoMoreInteractions(mCallback, mLayers[0], mLayers[1], mLayers[2]);
     }
 
-    // last frame
-    resetInteractions();
-    mFakeClock.incrementBy(17);
-    mFadeDrawable.draw(mCanvas);
-    Assert.assertEquals(fadeUpToLayer ? 255 : 0, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-    Assert.assertEquals(FadeDrawable.TRANSITION_NONE, mFadeDrawable.mTransitionState);
-    if (fadeUpToLayer) {
-      verify(mLayers[0]).mutate();
-      verify(mLayers[0]).setAlpha(255);
-      verify(mLayers[0]).draw(mCanvas);
+    @Test
+    public void testSetAlpha() {
+        InOrder inOrder = inOrder(mLayers[0], mLayers[1], mLayers[2], mCallback);
+        // reset drawable
+        mFadeDrawable.reset();
+        inOrder.verify(mCallback).invalidateDrawable(mFadeDrawable);
+        // start animation
+        mFadeDrawable.setTransitionDuration(85);
+        mFadeDrawable.fadeUpToLayer(1);
+        inOrder.verify(mCallback).invalidateDrawable(mFadeDrawable);
+        // first frame
+        mFadeDrawable.draw(mCanvas);
+        inOrder.verify(mCallback, atLeastOnce()).invalidateDrawable(mFadeDrawable);
+        // setAlpha
+        mFadeDrawable.setAlpha(128);
+        Assert.assertEquals(128, mFadeDrawable.getAlpha());
+        inOrder.verify(mCallback).invalidateDrawable(mFadeDrawable);
+        // next frame
+        mFakeClock.incrementBy(17);
+        mFadeDrawable.draw(mCanvas);
+        Assert.assertEquals(128, mFadeDrawable.getAlpha());
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(51, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+        Assert.assertEquals(FadeDrawable.TRANSITION_RUNNING, mFadeDrawable.mTransitionState);
+        inOrder.verify(mLayers[0]).mutate();
+        inOrder.verify(mLayers[0]).setAlpha(128);
+        inOrder.verify(mLayers[0]).draw(mCanvas);
+        inOrder.verify(mLayers[1]).mutate();
+        inOrder.verify(mLayers[1]).setAlpha(25);
+        inOrder.verify(mLayers[1]).draw(mCanvas);
+        inOrder.verify(mCallback, atLeastOnce()).invalidateDrawable(mFadeDrawable);
+        inOrder.verifyNoMoreInteractions();
+
+        // make sure the fade has finished, and verify that after that we don't invalidate
+        mFakeClock.incrementBy(1000);
+        mFadeDrawable.draw(mCanvas);
+        inOrder.verify(mCallback, never()).invalidateDrawable(mFadeDrawable);
     }
-    verify(mLayers[1]).mutate();
-    verify(mLayers[1]).setAlpha(255);
-    verify(mLayers[1]).draw(mCanvas);
-    verifyNoMoreInteractions(mCallback, mLayers[0], mLayers[1], mLayers[2]);
-  }
-
-  @Test
-  public void testSetAlpha() {
-    InOrder inOrder = inOrder(mLayers[0], mLayers[1], mLayers[2], mCallback);
-    // reset drawable
-    mFadeDrawable.reset();
-    inOrder.verify(mCallback).invalidateDrawable(mFadeDrawable);
-    // start animation
-    mFadeDrawable.setTransitionDuration(85);
-    mFadeDrawable.fadeUpToLayer(1);
-    inOrder.verify(mCallback).invalidateDrawable(mFadeDrawable);
-    // first frame
-    mFadeDrawable.draw(mCanvas);
-    inOrder.verify(mCallback, atLeastOnce()).invalidateDrawable(mFadeDrawable);
-    // setAlpha
-    mFadeDrawable.setAlpha(128);
-    Assert.assertEquals(128, mFadeDrawable.getAlpha());
-    inOrder.verify(mCallback).invalidateDrawable(mFadeDrawable);
-    // next frame
-    mFakeClock.incrementBy(17);
-    mFadeDrawable.draw(mCanvas);
-    Assert.assertEquals(128, mFadeDrawable.getAlpha());
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(51, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-    Assert.assertEquals(FadeDrawable.TRANSITION_RUNNING, mFadeDrawable.mTransitionState);
-    inOrder.verify(mLayers[0]).mutate();
-    inOrder.verify(mLayers[0]).setAlpha(128);
-    inOrder.verify(mLayers[0]).draw(mCanvas);
-    inOrder.verify(mLayers[1]).mutate();
-    inOrder.verify(mLayers[1]).setAlpha(25);
-    inOrder.verify(mLayers[1]).draw(mCanvas);
-    inOrder.verify(mCallback, atLeastOnce()).invalidateDrawable(mFadeDrawable);
-    inOrder.verifyNoMoreInteractions();
-
-    // make sure the fade has finished, and verify that after that we don't invalidate
-    mFakeClock.incrementBy(1000);
-    mFadeDrawable.draw(mCanvas);
-    inOrder.verify(mCallback, never()).invalidateDrawable(mFadeDrawable);
-  }
-
-  @Test
-  public void testReset() {
-    // go to some non-initial state
-    mFadeDrawable.fadeToLayer(2);
-    mFadeDrawable.finishTransitionImmediately();
-    resetInteractions();
-
-    mFadeDrawable.reset();
-    Assert.assertEquals(FadeDrawable.TRANSITION_NONE, mFadeDrawable.mTransitionState);
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-    verify(mCallback).invalidateDrawable(mFadeDrawable);
-  }
-
-  @Test
-  public void testBatchMode() {
-    mFadeDrawable.beginBatchMode();
-    mFadeDrawable.reset();
-    mFadeDrawable.fadeInLayer(1);
-    mFadeDrawable.fadeOutLayer(0);
-    mFadeDrawable.fadeOutAllLayers();
-    mFadeDrawable.fadeToLayer(2);
-    mFadeDrawable.fadeUpToLayer(1);
-    mFadeDrawable.finishTransitionImmediately();
-    mFadeDrawable.endBatchMode();
-    verify(mCallback, times(1)).invalidateDrawable(mFadeDrawable);
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-  }
-
-  @Test
-  public void testNoBatchMode() {
-    mFadeDrawable.reset();
-    mFadeDrawable.fadeInLayer(1);
-    mFadeDrawable.fadeOutLayer(0);
-    mFadeDrawable.fadeOutAllLayers();
-    mFadeDrawable.fadeToLayer(2);
-    mFadeDrawable.fadeUpToLayer(1);
-    mFadeDrawable.finishTransitionImmediately();
-    verify(mCallback, times(7)).invalidateDrawable(mFadeDrawable);
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
-    Assert.assertEquals(255, mFadeDrawable.mAlphas[1]);
-    Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
-    Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
-    Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
-  }
-
-  private class FakeFadeDrawable extends FadeDrawable {
-
-    private final FakeClock mFakeClock;
-
-    public FakeFadeDrawable(FakeClock fakeClock, Drawable[] layers) {
-      super(layers);
-      mFakeClock = fakeClock;
+
+    @Test
+    public void testReset() {
+        // go to some non-initial state
+        mFadeDrawable.fadeToLayer(2);
+        mFadeDrawable.finishTransitionImmediately();
+        resetInteractions();
+
+        mFadeDrawable.reset();
+        Assert.assertEquals(FadeDrawable.TRANSITION_NONE, mFadeDrawable.mTransitionState);
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
+        verify(mCallback).invalidateDrawable(mFadeDrawable);
+    }
+
+    @Test
+    public void testBatchMode() {
+        mFadeDrawable.beginBatchMode();
+        mFadeDrawable.reset();
+        mFadeDrawable.fadeInLayer(1);
+        mFadeDrawable.fadeOutLayer(0);
+        mFadeDrawable.fadeOutAllLayers();
+        mFadeDrawable.fadeToLayer(2);
+        mFadeDrawable.fadeUpToLayer(1);
+        mFadeDrawable.finishTransitionImmediately();
+        mFadeDrawable.endBatchMode();
+        verify(mCallback, times(1)).invalidateDrawable(mFadeDrawable);
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
     }
 
-    @Override
-    protected long getCurrentTimeMs() {
-      return mFakeClock.now();
+    @Test
+    public void testNoBatchMode() {
+        mFadeDrawable.reset();
+        mFadeDrawable.fadeInLayer(1);
+        mFadeDrawable.fadeOutLayer(0);
+        mFadeDrawable.fadeOutAllLayers();
+        mFadeDrawable.fadeToLayer(2);
+        mFadeDrawable.fadeUpToLayer(1);
+        mFadeDrawable.finishTransitionImmediately();
+        verify(mCallback, times(7)).invalidateDrawable(mFadeDrawable);
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[0]);
+        Assert.assertEquals(255, mFadeDrawable.mAlphas[1]);
+        Assert.assertEquals(0, mFadeDrawable.mAlphas[2]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[0]);
+        Assert.assertEquals(true, mFadeDrawable.mIsLayerOn[1]);
+        Assert.assertEquals(false, mFadeDrawable.mIsLayerOn[2]);
     }
 
-  }
+    private class FakeFadeDrawable extends FadeDrawable {
+
+        private final FakeClock mFakeClock;
+
+        public FakeFadeDrawable(FakeClock fakeClock, Drawable[] layers) {
+            super(layers);
+            mFakeClock = fakeClock;
+        }
+
+        @Override
+        protected long getCurrentTimeMs() {
+            return mFakeClock.now();
+        }
+
+    }
 
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/ForwardingDrawableTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/ForwardingDrawableTest.java
index e93471861..09c92b6c6 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/ForwardingDrawableTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/ForwardingDrawableTest.java
@@ -28,73 +28,73 @@
  */
 @RunWith(WithTestDefaultsRunner.class)
 public class ForwardingDrawableTest {
-  private Drawable mInnerDrawable;
-  private FakeForwardingDrawable mDrawable;
-
-  @Before
-  public void setup() {
-    mInnerDrawable = mock(Drawable.class);
-    mDrawable = new FakeForwardingDrawable(mInnerDrawable);
-    // ForwardingDrawable will call mInnerDrawable.setCallback
-    reset(mInnerDrawable);
-  }
-
-  @Test
-  public void testIntrinsicDimensions() {
-    when(mInnerDrawable.getIntrinsicWidth()).thenReturn(100);
-    when(mInnerDrawable.getIntrinsicHeight()).thenReturn(200);
-    Drawable drawable1 = new FakeForwardingDrawable(mInnerDrawable);
-    Assert.assertEquals(100, drawable1.getIntrinsicWidth());
-    Assert.assertEquals(200, drawable1.getIntrinsicHeight());
-  }
-
-  @Test
-  public void testGetCurrent() {
-    Assert.assertEquals(mInnerDrawable, mDrawable.getCurrent());
-  }
-
-  @Test
-  public void testSettersAndGetters() {
-    ColorFilter colorFilterMock = mock(ColorFilter.class);
-    Rect rectMock = mock(Rect.class);
-    int alpha = 77;
-    boolean dither = true;
-    boolean filterBitmap = false;
-    boolean visible = false;
-    boolean restart = false;
-
-    //when(mInnerDrawable.setVisible(visible, restart)).thenReturn(true);
-    when(mInnerDrawable.getOpacity()).thenReturn(11);
-    Assert.assertEquals(11, mDrawable.getOpacity());
-
-    mDrawable.getPadding(rectMock);
-    mDrawable.setAlpha(alpha);
-    mDrawable.setDither(dither);
-    mDrawable.setFilterBitmap(filterBitmap);
-    mDrawable.setColorFilter(colorFilterMock);
-    mDrawable.onBoundsChange(rectMock);
-    mDrawable.setVisible(visible, restart);
-
-    verify(mInnerDrawable).getPadding(rectMock);
-    verify(mInnerDrawable).setAlpha(alpha);
-    verify(mInnerDrawable).setDither(dither);
-    verify(mInnerDrawable).setFilterBitmap(filterBitmap);
-    verify(mInnerDrawable).setColorFilter(colorFilterMock);
-    verify(mInnerDrawable).setBounds(rectMock);
-    verify(mInnerDrawable).setVisible(visible, restart);
-  }
-
-  @Test
-  public void testDraw() {
-    Canvas mockCanvas = mock(Canvas.class);
-    mDrawable.draw(mockCanvas);
-    verify(mInnerDrawable).draw(mockCanvas);
-  }
-
-  static class FakeForwardingDrawable extends ForwardingDrawable {
-    public FakeForwardingDrawable(Drawable drawable) {
-      super(drawable);
+    private Drawable mInnerDrawable;
+    private FakeForwardingDrawable mDrawable;
+
+    @Before
+    public void setup() {
+        mInnerDrawable = mock(Drawable.class);
+        mDrawable = new FakeForwardingDrawable(mInnerDrawable);
+        // ForwardingDrawable will call mInnerDrawable.setCallback
+        reset(mInnerDrawable);
+    }
+
+    @Test
+    public void testIntrinsicDimensions() {
+        when(mInnerDrawable.getIntrinsicWidth()).thenReturn(100);
+        when(mInnerDrawable.getIntrinsicHeight()).thenReturn(200);
+        Drawable drawable1 = new FakeForwardingDrawable(mInnerDrawable);
+        Assert.assertEquals(100, drawable1.getIntrinsicWidth());
+        Assert.assertEquals(200, drawable1.getIntrinsicHeight());
+    }
+
+    @Test
+    public void testGetCurrent() {
+        Assert.assertEquals(mInnerDrawable, mDrawable.getCurrent());
+    }
+
+    @Test
+    public void testSettersAndGetters() {
+        ColorFilter colorFilterMock = mock(ColorFilter.class);
+        Rect rectMock = mock(Rect.class);
+        int alpha = 77;
+        boolean dither = true;
+        boolean filterBitmap = false;
+        boolean visible = false;
+        boolean restart = false;
+
+        //when(mInnerDrawable.setVisible(visible, restart)).thenReturn(true);
+        when(mInnerDrawable.getOpacity()).thenReturn(11);
+        Assert.assertEquals(11, mDrawable.getOpacity());
+
+        mDrawable.getPadding(rectMock);
+        mDrawable.setAlpha(alpha);
+        mDrawable.setDither(dither);
+        mDrawable.setFilterBitmap(filterBitmap);
+        mDrawable.setColorFilter(colorFilterMock);
+        mDrawable.onBoundsChange(rectMock);
+        mDrawable.setVisible(visible, restart);
+
+        verify(mInnerDrawable).getPadding(rectMock);
+        verify(mInnerDrawable).setAlpha(alpha);
+        verify(mInnerDrawable).setDither(dither);
+        verify(mInnerDrawable).setFilterBitmap(filterBitmap);
+        verify(mInnerDrawable).setColorFilter(colorFilterMock);
+        verify(mInnerDrawable).setBounds(rectMock);
+        verify(mInnerDrawable).setVisible(visible, restart);
+    }
+
+    @Test
+    public void testDraw() {
+        Canvas mockCanvas = mock(Canvas.class);
+        mDrawable.draw(mockCanvas);
+        verify(mInnerDrawable).draw(mockCanvas);
+    }
+
+    static class FakeForwardingDrawable extends ForwardingDrawable {
+        public FakeForwardingDrawable(Drawable drawable) {
+            super(drawable);
+        }
     }
-  }
 
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/MatrixDrawableTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/MatrixDrawableTest.java
index 39b4d9d7d..89a5ad71c 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/MatrixDrawableTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/MatrixDrawableTest.java
@@ -24,37 +24,37 @@
 
 @RunWith(WithTestDefaultsRunner.class)
 public class MatrixDrawableTest {
-  private Drawable mUnderlyingDrawable;
-  private Matrix mMatrix1;
-  private Matrix mMatrix2;
-
-  private MatrixDrawable mMatrixDrawable;
-
-  @Before
-  public void setUp() {
-    mUnderlyingDrawable = mock(Drawable.class);
-    mMatrix1 = mock(Matrix.class);
-    mMatrix2 = mock(Matrix.class);
-    mMatrixDrawable = new MatrixDrawable(mUnderlyingDrawable, mMatrix1);
-  }
-
-  @Test
-  public void testIntrinsicDimensions() {
-    when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(100);
-    when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(200);
-    Assert.assertEquals(100, mMatrixDrawable.getIntrinsicWidth());
-    Assert.assertEquals(200, mMatrixDrawable.getIntrinsicHeight());
-  }
-
-  @Test
-  public void testSetMatrix() throws Exception {
-    // initial state
-    Assert.assertEquals(mUnderlyingDrawable, mMatrixDrawable.getCurrent());
-    Assert.assertEquals(mMatrixDrawable.getMatrix(), mMatrix1);
-
-    mMatrixDrawable.setMatrix(mMatrix2);
-    Assert.assertEquals(mUnderlyingDrawable, mMatrixDrawable.getCurrent());
-    Assert.assertEquals(mMatrixDrawable.getMatrix(), mMatrix2);
-  }
+    private Drawable mUnderlyingDrawable;
+    private Matrix mMatrix1;
+    private Matrix mMatrix2;
+
+    private MatrixDrawable mMatrixDrawable;
+
+    @Before
+    public void setUp() {
+        mUnderlyingDrawable = mock(Drawable.class);
+        mMatrix1 = mock(Matrix.class);
+        mMatrix2 = mock(Matrix.class);
+        mMatrixDrawable = new MatrixDrawable(mUnderlyingDrawable, mMatrix1);
+    }
+
+    @Test
+    public void testIntrinsicDimensions() {
+        when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(100);
+        when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(200);
+        Assert.assertEquals(100, mMatrixDrawable.getIntrinsicWidth());
+        Assert.assertEquals(200, mMatrixDrawable.getIntrinsicHeight());
+    }
+
+    @Test
+    public void testSetMatrix() throws Exception {
+        // initial state
+        Assert.assertEquals(mUnderlyingDrawable, mMatrixDrawable.getCurrent());
+        Assert.assertEquals(mMatrixDrawable.getMatrix(), mMatrix1);
+
+        mMatrixDrawable.setMatrix(mMatrix2);
+        Assert.assertEquals(mUnderlyingDrawable, mMatrixDrawable.getCurrent());
+        Assert.assertEquals(mMatrixDrawable.getMatrix(), mMatrix2);
+    }
 
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/RoundedBitmapDrawableTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/RoundedBitmapDrawableTest.java
index 1c5677bbe..931fb40f0 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/RoundedBitmapDrawableTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/RoundedBitmapDrawableTest.java
@@ -27,57 +27,57 @@
 
 @RunWith(WithTestDefaultsRunner.class)
 public class RoundedBitmapDrawableTest {
-  private Resources mResources;
-  private Bitmap mBitmap;
-  private DisplayMetrics mDisplayMetrics;
+    private Resources mResources;
+    private Bitmap mBitmap;
+    private DisplayMetrics mDisplayMetrics;
 
-  RoundedBitmapDrawable mRoundedBitmapDrawable;
-  private final Drawable.Callback mCallback = mock(Drawable.Callback.class);
+    RoundedBitmapDrawable mRoundedBitmapDrawable;
+    private final Drawable.Callback mCallback = mock(Drawable.Callback.class);
 
-  @Before
-  public void setUp() {
-    mResources = mock(Resources.class);
-    mBitmap = mock(Bitmap.class);
-    mDisplayMetrics = mock(DisplayMetrics.class);
-    when(mResources.getDisplayMetrics()).thenReturn(mDisplayMetrics);
-    mRoundedBitmapDrawable = new RoundedBitmapDrawable(mResources, mBitmap);
-    mRoundedBitmapDrawable.setCallback(mCallback);
-  }
+    @Before
+    public void setUp() {
+        mResources = mock(Resources.class);
+        mBitmap = mock(Bitmap.class);
+        mDisplayMetrics = mock(DisplayMetrics.class);
+        when(mResources.getDisplayMetrics()).thenReturn(mDisplayMetrics);
+        mRoundedBitmapDrawable = new RoundedBitmapDrawable(mResources, mBitmap);
+        mRoundedBitmapDrawable.setCallback(mCallback);
+    }
 
-  @Test
-  public void testDefaults() {
-    assertArrayEquals(new float[]{0, 0, 0, 0, 0, 0, 0, 0}, mRoundedBitmapDrawable.mCornerRadii, 0);
-    AndroidGraphicsTestUtils.assertEquals(new Matrix(), mRoundedBitmapDrawable.mInverseTransform);
-  }
+    @Test
+    public void testDefaults() {
+        assertArrayEquals(new float[]{0, 0, 0, 0, 0, 0, 0, 0}, mRoundedBitmapDrawable.mCornerRadii, 0);
+        AndroidGraphicsTestUtils.assertEquals(new Matrix(), mRoundedBitmapDrawable.mInverseTransform);
+    }
 
-  @Test
-  public void testSetCircle() {
-    mRoundedBitmapDrawable.setCircle(true);
-    verify(mCallback).invalidateDrawable(mRoundedBitmapDrawable);
-    assertTrue(mRoundedBitmapDrawable.mIsCircle);
-  }
+    @Test
+    public void testSetCircle() {
+        mRoundedBitmapDrawable.setCircle(true);
+        verify(mCallback).invalidateDrawable(mRoundedBitmapDrawable);
+        assertTrue(mRoundedBitmapDrawable.mIsCircle);
+    }
 
-  @Test
-  public void testSetRadii() {
-    mRoundedBitmapDrawable.setCornerRadii(new float[]{1, 2, 3, 4, 5, 6, 7, 8});
-    verify(mCallback).invalidateDrawable(mRoundedBitmapDrawable);
-    assertArrayEquals(new float[]{1, 2, 3, 4, 5, 6, 7, 8}, mRoundedBitmapDrawable.mCornerRadii, 0);
-  }
+    @Test
+    public void testSetRadii() {
+        mRoundedBitmapDrawable.setCornerRadii(new float[]{1, 2, 3, 4, 5, 6, 7, 8});
+        verify(mCallback).invalidateDrawable(mRoundedBitmapDrawable);
+        assertArrayEquals(new float[]{1, 2, 3, 4, 5, 6, 7, 8}, mRoundedBitmapDrawable.mCornerRadii, 0);
+    }
 
-  @Test
-  public void testSetRadius() {
-    mRoundedBitmapDrawable.setCornerRadius(9);
-    verify(mCallback).invalidateDrawable(mRoundedBitmapDrawable);
-    assertArrayEquals(new float[]{9, 9, 9, 9, 9, 9, 9, 9}, mRoundedBitmapDrawable.mCornerRadii, 0);
-  }
+    @Test
+    public void testSetRadius() {
+        mRoundedBitmapDrawable.setCornerRadius(9);
+        verify(mCallback).invalidateDrawable(mRoundedBitmapDrawable);
+        assertArrayEquals(new float[]{9, 9, 9, 9, 9, 9, 9, 9}, mRoundedBitmapDrawable.mCornerRadii, 0);
+    }
 
-  @Test
-  public void testSetBorder() {
-    int color = 0x12345678;
-    float width = 5;
-    mRoundedBitmapDrawable.setBorder(color, width);
-    verify(mCallback).invalidateDrawable(mRoundedBitmapDrawable);
-    assertEquals(color, mRoundedBitmapDrawable.mBorderColor);
-    assertEquals(width, mRoundedBitmapDrawable.mBorderWidth, 0);
-  }
+    @Test
+    public void testSetBorder() {
+        int color = 0x12345678;
+        float width = 5;
+        mRoundedBitmapDrawable.setBorder(color, width);
+        verify(mCallback).invalidateDrawable(mRoundedBitmapDrawable);
+        assertEquals(color, mRoundedBitmapDrawable.mBorderColor);
+        assertEquals(width, mRoundedBitmapDrawable.mBorderWidth, 0);
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/RoundedColorDrawableTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/RoundedColorDrawableTest.java
index c40e19205..5659f3d5d 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/RoundedColorDrawableTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/RoundedColorDrawableTest.java
@@ -30,136 +30,136 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class RoundedColorDrawableTest {
 
-  private Canvas mCanvas;
-  private Drawable.Callback mCallback;
-
-  private RoundedColorDrawable mRoundedColorDrawable;
-
-  @Before
-  public void setup() {
-    mCanvas = mock(Canvas.class);
-    mCallback = mock(Drawable.Callback.class);
-    mRoundedColorDrawable = new RoundedColorDrawable(Color.GREEN);
-    mRoundedColorDrawable.setCallback(mCallback);
-  }
-
-  @Test
-  public void testInitialSetup() {
-    assertEquals(Color.GREEN, mRoundedColorDrawable.getColor());
-    assertFalse(mRoundedColorDrawable.mIsCircle);
-    assertArrayEquals(new float[] {0, 0, 0, 0, 0, 0, 0, 0}, mRoundedColorDrawable.mRadii, 0f);
-  }
-
-  @Test
-  public void testSetCircle() {
-    mRoundedColorDrawable.setCircle(true);
-    verify(mCallback).invalidateDrawable(mRoundedColorDrawable);
-    assertTrue(mRoundedColorDrawable.mIsCircle);
-  }
-
-  @Test
-  public void testSetRadii() {
-    float[] radii = {8f, 8f, 8f, 8f, 8f, 8f, 8f, 8f};
-    float[] expectedRadii = {8f, 8f, 8f, 8f, 8f, 8f, 8f, 8f};
-    mRoundedColorDrawable.setRadii(radii);
-    verify(mCallback).invalidateDrawable(mRoundedColorDrawable);
-    assertArrayEquals(expectedRadii, mRoundedColorDrawable.mRadii, 0f);
-  }
-
-  @Test
-  public void testSetRadius() {
-    float radius = 8f;
-    float[] expectedRadii = {8f, 8f, 8f, 8f, 8f, 8f, 8f, 8f};
-    mRoundedColorDrawable.setRadius(radius);
-    verify(mCallback).invalidateDrawable(mRoundedColorDrawable);
-    assertArrayEquals(expectedRadii, mRoundedColorDrawable.mRadii, 0f);
-  }
-
-  @Test
-  public void testSetColor() {
-    int color = 0xC0223456;
-    mRoundedColorDrawable.setColor(color);
-    verify(mCallback).invalidateDrawable(mRoundedColorDrawable);
-    assertEquals(color, mRoundedColorDrawable.getColor());
-  }
-
-  @Test
-  public void testSetAlpha() {
-    int alpha = 10;
-    mRoundedColorDrawable.setAlpha(alpha);
-    verify(mCallback).invalidateDrawable(mRoundedColorDrawable);
-    assertEquals(alpha, mRoundedColorDrawable.getAlpha());
-  }
-
-  @Test
-  public void testSetBorder() {
-    int color = 0xC0223456;
-    float width = 5;
-    mRoundedColorDrawable.setBorder(color, width);
-    verify(mCallback, times(2)).invalidateDrawable(mRoundedColorDrawable);
-    assertEquals(color, mRoundedColorDrawable.mBorderColor);
-    assertEquals(width, mRoundedColorDrawable.mBorderWidth, 0);
-  }
-
-  @Test
-  public void testDrawWithoutBorder() {
-    int internalColor = 0xC0223456;
-    int alpha = 10;
-    int expectedInternalPaintColor = 0x07223456;
-
-    mRoundedColorDrawable.setAlpha(alpha);
-    mRoundedColorDrawable.setColor(internalColor);
-    mRoundedColorDrawable.draw(mCanvas);
-
-    ArgumentCaptor<Paint> argumentCaptor = ArgumentCaptor.forClass(Paint.class);
-    verify(mCanvas).drawPath(any(Path.class), argumentCaptor.capture());
-
-    Paint internalPaint = argumentCaptor.getValue();
-    assertEquals(expectedInternalPaintColor, internalPaint.getColor());
-    assertEquals(Paint.Style.FILL, internalPaint.getStyle());
-  }
-
-  @Test
-  public void testDrawWithBorder() {
-    int internalColor = 0xC0223456;
-    int alpha = 10;
-    int borderColor = 0xC0123456;
-    int expectedBorderPaintColor = 0x07123456;
-    float borderWidth = 5;
-
-    mRoundedColorDrawable.setAlpha(alpha);
-    mRoundedColorDrawable.setColor(internalColor);
-    mRoundedColorDrawable.setBorder(borderColor, borderWidth);
-    mRoundedColorDrawable.draw(mCanvas);
-
-    ArgumentCaptor<Paint> argumentCaptor = ArgumentCaptor.forClass(Paint.class);
-    verify(mCanvas, times(2)).drawPath(any(Path.class), argumentCaptor.capture());
-    assertEquals(2, argumentCaptor.getAllValues().size());
-
-    Paint borderPaint = argumentCaptor.getAllValues().get(1);
-    assertEquals(expectedBorderPaintColor, borderPaint.getColor());
-    assertEquals(Paint.Style.STROKE, borderPaint.getStyle());
-    assertEquals(borderWidth, borderPaint.getStrokeWidth(), 0);
-  }
-
-  @Test
-  public void testGetOpacity() {
-    mRoundedColorDrawable.setColor(0x8FFFFFFF);
-    mRoundedColorDrawable.setAlpha(255);
-    assertEquals(PixelFormat.TRANSLUCENT, mRoundedColorDrawable.getOpacity());
-
-    mRoundedColorDrawable.setColor(0x00000000);
-    mRoundedColorDrawable.setAlpha(255);
-    assertEquals(PixelFormat.TRANSPARENT, mRoundedColorDrawable.getOpacity());
-
-    mRoundedColorDrawable.setColor(0xFFFFFFFF);
-    mRoundedColorDrawable.setAlpha(255);
-    assertEquals(PixelFormat.OPAQUE, mRoundedColorDrawable.getOpacity());
-
-    mRoundedColorDrawable.setAlpha(100);
-    assertEquals(PixelFormat.TRANSLUCENT, mRoundedColorDrawable.getOpacity());
-
-    mRoundedColorDrawable.setAlpha(0);
-    assertEquals(PixelFormat.TRANSPARENT, mRoundedColorDrawable.getOpacity());
-  }
+    private Canvas mCanvas;
+    private Drawable.Callback mCallback;
+
+    private RoundedColorDrawable mRoundedColorDrawable;
+
+    @Before
+    public void setup() {
+        mCanvas = mock(Canvas.class);
+        mCallback = mock(Drawable.Callback.class);
+        mRoundedColorDrawable = new RoundedColorDrawable(Color.GREEN);
+        mRoundedColorDrawable.setCallback(mCallback);
+    }
+
+    @Test
+    public void testInitialSetup() {
+        assertEquals(Color.GREEN, mRoundedColorDrawable.getColor());
+        assertFalse(mRoundedColorDrawable.mIsCircle);
+        assertArrayEquals(new float[]{0, 0, 0, 0, 0, 0, 0, 0}, mRoundedColorDrawable.mRadii, 0f);
+    }
+
+    @Test
+    public void testSetCircle() {
+        mRoundedColorDrawable.setCircle(true);
+        verify(mCallback).invalidateDrawable(mRoundedColorDrawable);
+        assertTrue(mRoundedColorDrawable.mIsCircle);
+    }
+
+    @Test
+    public void testSetRadii() {
+        float[] radii = {8f, 8f, 8f, 8f, 8f, 8f, 8f, 8f};
+        float[] expectedRadii = {8f, 8f, 8f, 8f, 8f, 8f, 8f, 8f};
+        mRoundedColorDrawable.setRadii(radii);
+        verify(mCallback).invalidateDrawable(mRoundedColorDrawable);
+        assertArrayEquals(expectedRadii, mRoundedColorDrawable.mRadii, 0f);
+    }
+
+    @Test
+    public void testSetRadius() {
+        float radius = 8f;
+        float[] expectedRadii = {8f, 8f, 8f, 8f, 8f, 8f, 8f, 8f};
+        mRoundedColorDrawable.setRadius(radius);
+        verify(mCallback).invalidateDrawable(mRoundedColorDrawable);
+        assertArrayEquals(expectedRadii, mRoundedColorDrawable.mRadii, 0f);
+    }
+
+    @Test
+    public void testSetColor() {
+        int color = 0xC0223456;
+        mRoundedColorDrawable.setColor(color);
+        verify(mCallback).invalidateDrawable(mRoundedColorDrawable);
+        assertEquals(color, mRoundedColorDrawable.getColor());
+    }
+
+    @Test
+    public void testSetAlpha() {
+        int alpha = 10;
+        mRoundedColorDrawable.setAlpha(alpha);
+        verify(mCallback).invalidateDrawable(mRoundedColorDrawable);
+        assertEquals(alpha, mRoundedColorDrawable.getAlpha());
+    }
+
+    @Test
+    public void testSetBorder() {
+        int color = 0xC0223456;
+        float width = 5;
+        mRoundedColorDrawable.setBorder(color, width);
+        verify(mCallback, times(2)).invalidateDrawable(mRoundedColorDrawable);
+        assertEquals(color, mRoundedColorDrawable.mBorderColor);
+        assertEquals(width, mRoundedColorDrawable.mBorderWidth, 0);
+    }
+
+    @Test
+    public void testDrawWithoutBorder() {
+        int internalColor = 0xC0223456;
+        int alpha = 10;
+        int expectedInternalPaintColor = 0x07223456;
+
+        mRoundedColorDrawable.setAlpha(alpha);
+        mRoundedColorDrawable.setColor(internalColor);
+        mRoundedColorDrawable.draw(mCanvas);
+
+        ArgumentCaptor<Paint> argumentCaptor = ArgumentCaptor.forClass(Paint.class);
+        verify(mCanvas).drawPath(any(Path.class), argumentCaptor.capture());
+
+        Paint internalPaint = argumentCaptor.getValue();
+        assertEquals(expectedInternalPaintColor, internalPaint.getColor());
+        assertEquals(Paint.Style.FILL, internalPaint.getStyle());
+    }
+
+    @Test
+    public void testDrawWithBorder() {
+        int internalColor = 0xC0223456;
+        int alpha = 10;
+        int borderColor = 0xC0123456;
+        int expectedBorderPaintColor = 0x07123456;
+        float borderWidth = 5;
+
+        mRoundedColorDrawable.setAlpha(alpha);
+        mRoundedColorDrawable.setColor(internalColor);
+        mRoundedColorDrawable.setBorder(borderColor, borderWidth);
+        mRoundedColorDrawable.draw(mCanvas);
+
+        ArgumentCaptor<Paint> argumentCaptor = ArgumentCaptor.forClass(Paint.class);
+        verify(mCanvas, times(2)).drawPath(any(Path.class), argumentCaptor.capture());
+        assertEquals(2, argumentCaptor.getAllValues().size());
+
+        Paint borderPaint = argumentCaptor.getAllValues().get(1);
+        assertEquals(expectedBorderPaintColor, borderPaint.getColor());
+        assertEquals(Paint.Style.STROKE, borderPaint.getStyle());
+        assertEquals(borderWidth, borderPaint.getStrokeWidth(), 0);
+    }
+
+    @Test
+    public void testGetOpacity() {
+        mRoundedColorDrawable.setColor(0x8FFFFFFF);
+        mRoundedColorDrawable.setAlpha(255);
+        assertEquals(PixelFormat.TRANSLUCENT, mRoundedColorDrawable.getOpacity());
+
+        mRoundedColorDrawable.setColor(0x00000000);
+        mRoundedColorDrawable.setAlpha(255);
+        assertEquals(PixelFormat.TRANSPARENT, mRoundedColorDrawable.getOpacity());
+
+        mRoundedColorDrawable.setColor(0xFFFFFFFF);
+        mRoundedColorDrawable.setAlpha(255);
+        assertEquals(PixelFormat.OPAQUE, mRoundedColorDrawable.getOpacity());
+
+        mRoundedColorDrawable.setAlpha(100);
+        assertEquals(PixelFormat.TRANSLUCENT, mRoundedColorDrawable.getOpacity());
+
+        mRoundedColorDrawable.setAlpha(0);
+        assertEquals(PixelFormat.TRANSPARENT, mRoundedColorDrawable.getOpacity());
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/RoundedCornersDrawableTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/RoundedCornersDrawableTest.java
index e084c6ac6..8689c002a 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/RoundedCornersDrawableTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/RoundedCornersDrawableTest.java
@@ -24,70 +24,70 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class RoundedCornersDrawableTest {
 
-  private Drawable mUnderlyingDrawable;
-  private RoundedCornersDrawable mRoundedCornersDrawable;
-  private Drawable.Callback mCallback;
+    private Drawable mUnderlyingDrawable;
+    private RoundedCornersDrawable mRoundedCornersDrawable;
+    private Drawable.Callback mCallback;
 
-  @Before
-  public void setup() {
-    mUnderlyingDrawable = mock(Drawable.class);
-    mCallback = mock(Drawable.Callback.class);
-    mRoundedCornersDrawable = new RoundedCornersDrawable(mUnderlyingDrawable);
-    mRoundedCornersDrawable.setCallback(mCallback);
-  }
+    @Before
+    public void setup() {
+        mUnderlyingDrawable = mock(Drawable.class);
+        mCallback = mock(Drawable.Callback.class);
+        mRoundedCornersDrawable = new RoundedCornersDrawable(mUnderlyingDrawable);
+        mRoundedCornersDrawable.setCallback(mCallback);
+    }
 
-  @Test
-  public void testInitialSetup() {
-    assertEquals(RoundedCornersDrawable.Type.OVERLAY_COLOR, mRoundedCornersDrawable.mType);
-    assertFalse(mRoundedCornersDrawable.mIsCircle);
-    assertArrayEquals(new float[]{0, 0, 0, 0, 0, 0, 0, 0}, mRoundedCornersDrawable.mRadii, 0);
-    assertEquals(0, mRoundedCornersDrawable.mPaint.getColor());
-  }
+    @Test
+    public void testInitialSetup() {
+        assertEquals(RoundedCornersDrawable.Type.OVERLAY_COLOR, mRoundedCornersDrawable.mType);
+        assertFalse(mRoundedCornersDrawable.mIsCircle);
+        assertArrayEquals(new float[]{0, 0, 0, 0, 0, 0, 0, 0}, mRoundedCornersDrawable.mRadii, 0);
+        assertEquals(0, mRoundedCornersDrawable.mPaint.getColor());
+    }
 
-  @Test
-  public void testSetType() {
-    RoundedCornersDrawable.Type type = RoundedCornersDrawable.Type.CLIPPING;
-    mRoundedCornersDrawable.setType(type);
-    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
-    assertEquals(type, mRoundedCornersDrawable.mType);
-  }
+    @Test
+    public void testSetType() {
+        RoundedCornersDrawable.Type type = RoundedCornersDrawable.Type.CLIPPING;
+        mRoundedCornersDrawable.setType(type);
+        verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
+        assertEquals(type, mRoundedCornersDrawable.mType);
+    }
 
-  @Test
-  public void testSetCircle() {
-    mRoundedCornersDrawable.setCircle(true);
-    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
-    assertTrue(mRoundedCornersDrawable.mIsCircle);
-  }
+    @Test
+    public void testSetCircle() {
+        mRoundedCornersDrawable.setCircle(true);
+        verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
+        assertTrue(mRoundedCornersDrawable.mIsCircle);
+    }
 
-  @Test
-  public void testSetRadii() {
-    mRoundedCornersDrawable.setRadii(new float[] {1, 2, 3, 4, 5, 6, 7, 8});
-    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
-    assertArrayEquals(new float[] {1, 2, 3, 4, 5, 6, 7, 8}, mRoundedCornersDrawable.mRadii, 0);
-  }
+    @Test
+    public void testSetRadii() {
+        mRoundedCornersDrawable.setRadii(new float[]{1, 2, 3, 4, 5, 6, 7, 8});
+        verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
+        assertArrayEquals(new float[]{1, 2, 3, 4, 5, 6, 7, 8}, mRoundedCornersDrawable.mRadii, 0);
+    }
 
-  @Test
-  public void testSetRadius() {
-    mRoundedCornersDrawable.setRadius(9);
-    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
-    assertArrayEquals(new float[]{9, 9, 9, 9, 9, 9, 9, 9}, mRoundedCornersDrawable.mRadii, 0);
-  }
+    @Test
+    public void testSetRadius() {
+        mRoundedCornersDrawable.setRadius(9);
+        verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
+        assertArrayEquals(new float[]{9, 9, 9, 9, 9, 9, 9, 9}, mRoundedCornersDrawable.mRadii, 0);
+    }
 
-  @Test
-  public void testSetOverlayColor() {
-    int overlayColor = 0xC0123456;
-    mRoundedCornersDrawable.setOverlayColor(overlayColor);
-    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
-    assertEquals(overlayColor, mRoundedCornersDrawable.mOverlayColor);
-  }
+    @Test
+    public void testSetOverlayColor() {
+        int overlayColor = 0xC0123456;
+        mRoundedCornersDrawable.setOverlayColor(overlayColor);
+        verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
+        assertEquals(overlayColor, mRoundedCornersDrawable.mOverlayColor);
+    }
 
-  @Test
-  public void testSetBorder() {
-    float borderWidth = 0.7f;
-    int borderColor = Color.CYAN;
-    mRoundedCornersDrawable.setBorder(borderColor, borderWidth);
-    verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
-    assertEquals(borderColor, mRoundedCornersDrawable.mBorderColor);
-    assertEquals(borderWidth, mRoundedCornersDrawable.mBorderWidth, 0);
-  }
+    @Test
+    public void testSetBorder() {
+        float borderWidth = 0.7f;
+        int borderColor = Color.CYAN;
+        mRoundedCornersDrawable.setBorder(borderColor, borderWidth);
+        verify(mCallback).invalidateDrawable(mRoundedCornersDrawable);
+        assertEquals(borderColor, mRoundedCornersDrawable.mBorderColor);
+        assertEquals(borderWidth, mRoundedCornersDrawable.mBorderWidth, 0);
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/ScaleTypeDrawableTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/ScaleTypeDrawableTest.java
index 5edf5831a..ecbfbc369 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/ScaleTypeDrawableTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/ScaleTypeDrawableTest.java
@@ -28,261 +28,261 @@
 
 @RunWith(WithTestDefaultsRunner.class)
 public class ScaleTypeDrawableTest {
-  private Drawable mUnderlyingDrawable = mock(Drawable.class);
-  private PointF mFocusPoint = new PointF(0.1f, 0.4f);
-  private Drawable.Callback mCallback = mock(Drawable.Callback.class);
-  private Rect mViewBounds = new Rect(10, 10, 410, 310);
-  private ScaleTypeDrawable mScaleTypeDrawable;
+    private Drawable mUnderlyingDrawable = mock(Drawable.class);
+    private PointF mFocusPoint = new PointF(0.1f, 0.4f);
+    private Drawable.Callback mCallback = mock(Drawable.Callback.class);
+    private Rect mViewBounds = new Rect(10, 10, 410, 310);
+    private ScaleTypeDrawable mScaleTypeDrawable;
 
-  @Before
-  public void setUp() {
-    mScaleTypeDrawable = new ScaleTypeDrawable(mUnderlyingDrawable, ScaleType.CENTER);
-    mScaleTypeDrawable.setCallback(mCallback);
-  }
+    @Before
+    public void setUp() {
+        mScaleTypeDrawable = new ScaleTypeDrawable(mUnderlyingDrawable, ScaleType.CENTER);
+        mScaleTypeDrawable.setCallback(mCallback);
+    }
 
-  @Test
-  public void testIntrinsicDimensions() {
-    when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(100);
-    when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(200);
-    Assert.assertEquals(100, mScaleTypeDrawable.getIntrinsicWidth());
-    Assert.assertEquals(200, mScaleTypeDrawable.getIntrinsicHeight());
-  }
+    @Test
+    public void testIntrinsicDimensions() {
+        when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(100);
+        when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(200);
+        Assert.assertEquals(100, mScaleTypeDrawable.getIntrinsicWidth());
+        Assert.assertEquals(200, mScaleTypeDrawable.getIntrinsicHeight());
+    }
 
-  @Test
-  public void testBasics() {
-    // initial state
-    Assert.assertEquals(mUnderlyingDrawable, mScaleTypeDrawable.getCurrent());
-    Assert.assertEquals(ScaleType.CENTER, mScaleTypeDrawable.getScaleType());
-    Assert.assertEquals(null, mScaleTypeDrawable.getFocusPoint());
+    @Test
+    public void testBasics() {
+        // initial state
+        Assert.assertEquals(mUnderlyingDrawable, mScaleTypeDrawable.getCurrent());
+        Assert.assertEquals(ScaleType.CENTER, mScaleTypeDrawable.getScaleType());
+        Assert.assertEquals(null, mScaleTypeDrawable.getFocusPoint());
 
-    mScaleTypeDrawable.setScaleType(ScaleType.FIT_XY);
-    Assert.assertEquals(ScaleType.FIT_XY, mScaleTypeDrawable.getScaleType());
+        mScaleTypeDrawable.setScaleType(ScaleType.FIT_XY);
+        Assert.assertEquals(ScaleType.FIT_XY, mScaleTypeDrawable.getScaleType());
 
-    mScaleTypeDrawable.setScaleType(ScaleType.FOCUS_CROP);
-    Assert.assertEquals(ScaleType.FOCUS_CROP, mScaleTypeDrawable.getScaleType());
+        mScaleTypeDrawable.setScaleType(ScaleType.FOCUS_CROP);
+        Assert.assertEquals(ScaleType.FOCUS_CROP, mScaleTypeDrawable.getScaleType());
 
-    mScaleTypeDrawable.setFocusPoint(mFocusPoint);
-    AndroidGraphicsTestUtils.assertEquals(mFocusPoint, mScaleTypeDrawable.getFocusPoint(), 0f);
-  }
+        mScaleTypeDrawable.setFocusPoint(mFocusPoint);
+        AndroidGraphicsTestUtils.assertEquals(mFocusPoint, mScaleTypeDrawable.getFocusPoint(), 0f);
+    }
 
-  @Test
-  public void testConfigureBounds_NoIntrinsicDimensions() {
-    for (ScaleType scaleType : ScaleType.values()) {
-      System.out.println("testConfigureBounds_NoIntrinsicDimensions: " + scaleType);
-      testConfigureBounds_NoIntrinsicDimensions(scaleType, mViewBounds);
+    @Test
+    public void testConfigureBounds_NoIntrinsicDimensions() {
+        for (ScaleType scaleType : ScaleType.values()) {
+            System.out.println("testConfigureBounds_NoIntrinsicDimensions: " + scaleType);
+            testConfigureBounds_NoIntrinsicDimensions(scaleType, mViewBounds);
+        }
     }
-  }
 
-  private void testConfigureBounds_NoIntrinsicDimensions(ScaleType scaleType, Rect viewBounds) {
-    mScaleTypeDrawable.setScaleType(scaleType);
-    mScaleTypeDrawable.setBounds(viewBounds);
-    reset(mUnderlyingDrawable);
-    when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(-1);
-    when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(-1);
-    mScaleTypeDrawable.configureBounds();
-    verify(mUnderlyingDrawable).getIntrinsicWidth();
-    verify(mUnderlyingDrawable).getIntrinsicHeight();
-    verify(mUnderlyingDrawable).setBounds(viewBounds);
-    Assert.assertEquals(null, mScaleTypeDrawable.mDrawMatrix);
-    verifyNoMoreInteractions(mUnderlyingDrawable);
-  }
+    private void testConfigureBounds_NoIntrinsicDimensions(ScaleType scaleType, Rect viewBounds) {
+        mScaleTypeDrawable.setScaleType(scaleType);
+        mScaleTypeDrawable.setBounds(viewBounds);
+        reset(mUnderlyingDrawable);
+        when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(-1);
+        when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(-1);
+        mScaleTypeDrawable.configureBounds();
+        verify(mUnderlyingDrawable).getIntrinsicWidth();
+        verify(mUnderlyingDrawable).getIntrinsicHeight();
+        verify(mUnderlyingDrawable).setBounds(viewBounds);
+        Assert.assertEquals(null, mScaleTypeDrawable.mDrawMatrix);
+        verifyNoMoreInteractions(mUnderlyingDrawable);
+    }
 
-  @Test
-  public void testConfigureBounds_SameAsView() {
-    for (ScaleType scaleType : ScaleType.values()) {
-      System.out.println("testConfigureBounds_SameAsView: " + scaleType);
-      testConfigureBounds_SameAsView(scaleType, mViewBounds);
+    @Test
+    public void testConfigureBounds_SameAsView() {
+        for (ScaleType scaleType : ScaleType.values()) {
+            System.out.println("testConfigureBounds_SameAsView: " + scaleType);
+            testConfigureBounds_SameAsView(scaleType, mViewBounds);
+        }
     }
-  }
 
-  private void testConfigureBounds_SameAsView(ScaleType scaleType, Rect viewBounds) {
-    mScaleTypeDrawable.setScaleType(scaleType);
-    mScaleTypeDrawable.setBounds(viewBounds);
-    reset(mUnderlyingDrawable);
-    when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(viewBounds.width());
-    when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(viewBounds.height());
-    mScaleTypeDrawable.configureBounds();
-    verify(mUnderlyingDrawable).getIntrinsicWidth();
-    verify(mUnderlyingDrawable).getIntrinsicHeight();
-    verify(mUnderlyingDrawable).setBounds(viewBounds);
-    Assert.assertEquals(null, mScaleTypeDrawable.mDrawMatrix);
-    verifyNoMoreInteractions(mUnderlyingDrawable);
-  }
+    private void testConfigureBounds_SameAsView(ScaleType scaleType, Rect viewBounds) {
+        mScaleTypeDrawable.setScaleType(scaleType);
+        mScaleTypeDrawable.setBounds(viewBounds);
+        reset(mUnderlyingDrawable);
+        when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(viewBounds.width());
+        when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(viewBounds.height());
+        mScaleTypeDrawable.configureBounds();
+        verify(mUnderlyingDrawable).getIntrinsicWidth();
+        verify(mUnderlyingDrawable).getIntrinsicHeight();
+        verify(mUnderlyingDrawable).setBounds(viewBounds);
+        Assert.assertEquals(null, mScaleTypeDrawable.mDrawMatrix);
+        verifyNoMoreInteractions(mUnderlyingDrawable);
+    }
 
-  @Test
-  public void testConfigureBounds_FIT_XY() {
-    mScaleTypeDrawable.setScaleType(ScaleType.FIT_XY);
-    mScaleTypeDrawable.setBounds(mViewBounds);
-    reset(mUnderlyingDrawable);
-    when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(40);
-    when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(30);
-    mScaleTypeDrawable.configureBounds();
-    verify(mUnderlyingDrawable).getIntrinsicWidth();
-    verify(mUnderlyingDrawable).getIntrinsicHeight();
-    verify(mUnderlyingDrawable).setBounds(mViewBounds);
-    Assert.assertEquals(null, mScaleTypeDrawable.mDrawMatrix);
-    verifyNoMoreInteractions(mUnderlyingDrawable);
-  }
+    @Test
+    public void testConfigureBounds_FIT_XY() {
+        mScaleTypeDrawable.setScaleType(ScaleType.FIT_XY);
+        mScaleTypeDrawable.setBounds(mViewBounds);
+        reset(mUnderlyingDrawable);
+        when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(40);
+        when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(30);
+        mScaleTypeDrawable.configureBounds();
+        verify(mUnderlyingDrawable).getIntrinsicWidth();
+        verify(mUnderlyingDrawable).getIntrinsicHeight();
+        verify(mUnderlyingDrawable).setBounds(mViewBounds);
+        Assert.assertEquals(null, mScaleTypeDrawable.mDrawMatrix);
+        verifyNoMoreInteractions(mUnderlyingDrawable);
+    }
 
-  /**
-   * Underlying drawable's aspect ratio is bigger than view's, so it has to be slided horizontally
-   * after scaling.
-   */
-  @Test
-  public void testConfigureBounds_CENTER_CROP_H() {
-    Rect bounds = new Rect(10, 10, 410, 310);
-    int width = 400;
-    int height = 200;
-    Matrix expectedMatrix = new Matrix();
-    expectedMatrix.setScale(1.5f, 1.5f);
-    expectedMatrix.postTranslate(-89, 10);
-    testConfigureBounds(bounds, width, height, ScaleType.CENTER_CROP, null, expectedMatrix);
-  }
+    /**
+     * Underlying drawable's aspect ratio is bigger than view's, so it has to be slided horizontally
+     * after scaling.
+     */
+    @Test
+    public void testConfigureBounds_CENTER_CROP_H() {
+        Rect bounds = new Rect(10, 10, 410, 310);
+        int width = 400;
+        int height = 200;
+        Matrix expectedMatrix = new Matrix();
+        expectedMatrix.setScale(1.5f, 1.5f);
+        expectedMatrix.postTranslate(-89, 10);
+        testConfigureBounds(bounds, width, height, ScaleType.CENTER_CROP, null, expectedMatrix);
+    }
 
-  /**
-   * Underlying drawable's aspect ratio is smaller than view's, so it has to be slided vertically
-   * after scaling.
-   */
-  @Test
-  public void testConfigureBounds_CENTER_CROP_V() {
-    Rect bounds = new Rect(10, 10, 410, 310);
-    int width = 200;
-    int height = 300;
-    Matrix expectedMatrix = new Matrix();
-    expectedMatrix.setScale(2.0f, 2.0f);
-    expectedMatrix.postTranslate(10, -139);
-    testConfigureBounds(bounds, width, height, ScaleType.CENTER_CROP, null, expectedMatrix);
-  }
+    /**
+     * Underlying drawable's aspect ratio is smaller than view's, so it has to be slided vertically
+     * after scaling.
+     */
+    @Test
+    public void testConfigureBounds_CENTER_CROP_V() {
+        Rect bounds = new Rect(10, 10, 410, 310);
+        int width = 200;
+        int height = 300;
+        Matrix expectedMatrix = new Matrix();
+        expectedMatrix.setScale(2.0f, 2.0f);
+        expectedMatrix.postTranslate(10, -139);
+        testConfigureBounds(bounds, width, height, ScaleType.CENTER_CROP, null, expectedMatrix);
+    }
 
-  /**
-   * Underlying drawable's aspect ratio is bigger than view's, so it has to be slided horizontally
-   * after scaling. Focus point is too much left, so it cannot be completely centered. Left-most
-   * part of the image is displayed.
-   */
-  @Test
-  public void testConfigureBounds_FOCUS_CROP_HL() {
-    Rect bounds = new Rect(10, 10, 410, 310);
-    int width = 400;
-    int height = 200;
-    PointF focusPoint = new PointF(0.1f, 0.5f);
-    Matrix expectedMatrix = new Matrix();
-    expectedMatrix.setScale(1.5f, 1.5f);
-    expectedMatrix.postTranslate(10, 10);
-    testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
-  }
+    /**
+     * Underlying drawable's aspect ratio is bigger than view's, so it has to be slided horizontally
+     * after scaling. Focus point is too much left, so it cannot be completely centered. Left-most
+     * part of the image is displayed.
+     */
+    @Test
+    public void testConfigureBounds_FOCUS_CROP_HL() {
+        Rect bounds = new Rect(10, 10, 410, 310);
+        int width = 400;
+        int height = 200;
+        PointF focusPoint = new PointF(0.1f, 0.5f);
+        Matrix expectedMatrix = new Matrix();
+        expectedMatrix.setScale(1.5f, 1.5f);
+        expectedMatrix.postTranslate(10, 10);
+        testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
+    }
 
-  /**
-   * Underlying drawable's aspect ratio is bigger than view's, so it has to be slided horizontally
-   * after scaling. Focus point is at 40% and it can be completely centered.
-   */
-  @Test
-  public void testConfigureBounds_FOCUS_CROP_HC() {
-    Rect bounds = new Rect(10, 10, 410, 310);
-    int width = 400;
-    int height = 200;
-    PointF focusPoint = new PointF(0.40f, 0.5f);
-    Matrix expectedMatrix = new Matrix();
-    expectedMatrix.setScale(1.5f, 1.5f);
-    expectedMatrix.postTranslate(-29, 10);
-    testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
-  }
+    /**
+     * Underlying drawable's aspect ratio is bigger than view's, so it has to be slided horizontally
+     * after scaling. Focus point is at 40% and it can be completely centered.
+     */
+    @Test
+    public void testConfigureBounds_FOCUS_CROP_HC() {
+        Rect bounds = new Rect(10, 10, 410, 310);
+        int width = 400;
+        int height = 200;
+        PointF focusPoint = new PointF(0.40f, 0.5f);
+        Matrix expectedMatrix = new Matrix();
+        expectedMatrix.setScale(1.5f, 1.5f);
+        expectedMatrix.postTranslate(-29, 10);
+        testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
+    }
 
-  /**
-   * Underlying drawable's aspect ratio is bigger than view's, so it has to be slided horizontally
-   * after scaling. Focus point is too much right, so it cannot be completely centered. Right-most
-   * part of the image is displayed.
-   */
-  @Test
-  public void testConfigureBounds_FOCUS_CROP_HR() {
-    Rect bounds = new Rect(10, 10, 410, 310);
-    int width = 400;
-    int height = 200;
-    PointF focusPoint = new PointF(0.9f, 0.5f);
-    Matrix expectedMatrix = new Matrix();
-    expectedMatrix.setScale(1.5f, 1.5f);
-    expectedMatrix.postTranslate(-189, 10);
-    testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
-  }
+    /**
+     * Underlying drawable's aspect ratio is bigger than view's, so it has to be slided horizontally
+     * after scaling. Focus point is too much right, so it cannot be completely centered. Right-most
+     * part of the image is displayed.
+     */
+    @Test
+    public void testConfigureBounds_FOCUS_CROP_HR() {
+        Rect bounds = new Rect(10, 10, 410, 310);
+        int width = 400;
+        int height = 200;
+        PointF focusPoint = new PointF(0.9f, 0.5f);
+        Matrix expectedMatrix = new Matrix();
+        expectedMatrix.setScale(1.5f, 1.5f);
+        expectedMatrix.postTranslate(-189, 10);
+        testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
+    }
 
-  /**
-   * Underlying drawable's aspect ratio is smaller than view's, so it has to be slided vertically
-   * after scaling. Focus point is too much top, so it cannot be completely centered. Top-most
-   * part of the image is displayed.
-   */
-  @Test
-  public void testConfigureBounds_FOCUS_CROP_VT() {
-    Rect bounds = new Rect(10, 10, 410, 310);
-    int width = 200;
-    int height = 300;
-    PointF focusPoint = new PointF(0.5f, 0.1f);
-    Matrix expectedMatrix = new Matrix();
-    expectedMatrix.setScale(2.0f, 2.0f);
-    expectedMatrix.postTranslate(10, 10);
-    testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
-  }
+    /**
+     * Underlying drawable's aspect ratio is smaller than view's, so it has to be slided vertically
+     * after scaling. Focus point is too much top, so it cannot be completely centered. Top-most
+     * part of the image is displayed.
+     */
+    @Test
+    public void testConfigureBounds_FOCUS_CROP_VT() {
+        Rect bounds = new Rect(10, 10, 410, 310);
+        int width = 200;
+        int height = 300;
+        PointF focusPoint = new PointF(0.5f, 0.1f);
+        Matrix expectedMatrix = new Matrix();
+        expectedMatrix.setScale(2.0f, 2.0f);
+        expectedMatrix.postTranslate(10, 10);
+        testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
+    }
 
-  /**
-   * Underlying drawable's aspect ratio is smaller than view's, so it has to be slided vertically
-   * after scaling. Focus point is at 40% and it can be completely centered.
-   */
-  @Test
-  public void testConfigureBounds_FOCUS_CROP_VC() {
-    Rect bounds = new Rect(10, 10, 410, 310);
-    int width = 200;
-    int height = 300;
-    PointF focusPoint = new PointF(0.5f, 0.4f);
-    Matrix expectedMatrix = new Matrix();
-    expectedMatrix.setScale(2.0f, 2.0f);
-    expectedMatrix.postTranslate(10, -79);
-    testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
-    // expected bounds of the actual image after the scaling has been performed (without cropping)
-    testActualImageBounds(new RectF(10f, -79f, 410f, 521f));
-  }
+    /**
+     * Underlying drawable's aspect ratio is smaller than view's, so it has to be slided vertically
+     * after scaling. Focus point is at 40% and it can be completely centered.
+     */
+    @Test
+    public void testConfigureBounds_FOCUS_CROP_VC() {
+        Rect bounds = new Rect(10, 10, 410, 310);
+        int width = 200;
+        int height = 300;
+        PointF focusPoint = new PointF(0.5f, 0.4f);
+        Matrix expectedMatrix = new Matrix();
+        expectedMatrix.setScale(2.0f, 2.0f);
+        expectedMatrix.postTranslate(10, -79);
+        testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
+        // expected bounds of the actual image after the scaling has been performed (without cropping)
+        testActualImageBounds(new RectF(10f, -79f, 410f, 521f));
+    }
 
-  /**
-   * Underlying drawable's aspect ratio is smaller than view's, so it has to be slided vertically
-   * after scaling. Focus point is too much bottom, so it cannot be completely centered. Bottom-most
-   * part of the image is displayed.
-   */
-  @Test
-  public void testConfigureBounds_FOCUS_CROP_VB() {
-    Rect bounds = new Rect(10, 10, 410, 310);
-    int width = 200;
-    int height = 300;
-    PointF focusPoint = new PointF(0.5f, 0.9f);
-    Matrix expectedMatrix = new Matrix();
-    expectedMatrix.setScale(2.0f, 2.0f);
-    expectedMatrix.postTranslate(10, -289);
-    testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
-  }
+    /**
+     * Underlying drawable's aspect ratio is smaller than view's, so it has to be slided vertically
+     * after scaling. Focus point is too much bottom, so it cannot be completely centered. Bottom-most
+     * part of the image is displayed.
+     */
+    @Test
+    public void testConfigureBounds_FOCUS_CROP_VB() {
+        Rect bounds = new Rect(10, 10, 410, 310);
+        int width = 200;
+        int height = 300;
+        PointF focusPoint = new PointF(0.5f, 0.9f);
+        Matrix expectedMatrix = new Matrix();
+        expectedMatrix.setScale(2.0f, 2.0f);
+        expectedMatrix.postTranslate(10, -289);
+        testConfigureBounds(bounds, width, height, ScaleType.FOCUS_CROP, focusPoint, expectedMatrix);
+    }
 
-  private void testConfigureBounds(
-      Rect viewBounds,
-      int underlyingWidth,
-      int underlyingHeight,
-      ScaleType scaleType,
-      PointF focusPoint,
-      Matrix expectedMatrix) {
-    mScaleTypeDrawable.setScaleType(scaleType);
-    if (focusPoint != null) {
-      mScaleTypeDrawable.setFocusPoint(focusPoint);
+    private void testConfigureBounds(
+            Rect viewBounds,
+            int underlyingWidth,
+            int underlyingHeight,
+            ScaleType scaleType,
+            PointF focusPoint,
+            Matrix expectedMatrix) {
+        mScaleTypeDrawable.setScaleType(scaleType);
+        if (focusPoint != null) {
+            mScaleTypeDrawable.setFocusPoint(focusPoint);
+        }
+        mScaleTypeDrawable.setBounds(viewBounds);
+        reset(mUnderlyingDrawable);
+        when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(underlyingWidth);
+        when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(underlyingHeight);
+        mScaleTypeDrawable.configureBounds();
+        verify(mUnderlyingDrawable).getIntrinsicWidth();
+        verify(mUnderlyingDrawable).getIntrinsicHeight();
+        verify(mUnderlyingDrawable).setBounds(0, 0, underlyingWidth, underlyingHeight);
+        AndroidGraphicsTestUtils.assertEquals(expectedMatrix, mScaleTypeDrawable.mDrawMatrix);
+        verifyNoMoreInteractions(mUnderlyingDrawable);
     }
-    mScaleTypeDrawable.setBounds(viewBounds);
-    reset(mUnderlyingDrawable);
-    when(mUnderlyingDrawable.getIntrinsicWidth()).thenReturn(underlyingWidth);
-    when(mUnderlyingDrawable.getIntrinsicHeight()).thenReturn(underlyingHeight);
-    mScaleTypeDrawable.configureBounds();
-    verify(mUnderlyingDrawable).getIntrinsicWidth();
-    verify(mUnderlyingDrawable).getIntrinsicHeight();
-    verify(mUnderlyingDrawable).setBounds(0, 0, underlyingWidth, underlyingHeight);
-    AndroidGraphicsTestUtils.assertEquals(expectedMatrix, mScaleTypeDrawable.mDrawMatrix);
-    verifyNoMoreInteractions(mUnderlyingDrawable);
-  }
 
-  private void testActualImageBounds(RectF expectedActualImageBounds) {
-    // TODO(5469563): enable this once we have a decent implementation of ShadowMatrix
-    //RectF actualImageBounds = new RectF();
-    //mScaleTypeDrawable.getTransformedBounds(actualImageBounds);
-    //Assert.assertEquals(expectedActualImageBounds, actualImageBounds);
-  }
+    private void testActualImageBounds(RectF expectedActualImageBounds) {
+        // TODO(5469563): enable this once we have a decent implementation of ShadowMatrix
+        //RectF actualImageBounds = new RectF();
+        //mScaleTypeDrawable.getTransformedBounds(actualImageBounds);
+        //Assert.assertEquals(expectedActualImageBounds, actualImageBounds);
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/ScalingUtilsTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/ScalingUtilsTest.java
index 169fc7260..a6e80b554 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/ScalingUtilsTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/ScalingUtilsTest.java
@@ -26,218 +26,218 @@
  */
 @RunWith(WithTestDefaultsRunner.class)
 public class ScalingUtilsTest {
-  private final Matrix mExpectedMatrix = new Matrix();
-  private final Matrix mActualMatrix = new Matrix();
-  private final Rect mParentBounds = new Rect(10, 15, 410, 315);
-
-  @Before
-  public void setUp() {
-  }
-
-  @Test
-  public void testFitXY() {
-    test(1.60f, 2.00f, 10, 15, 250, 150, ScaleType.FIT_XY);
-    test(0.50f, 1.50f, 10, 15, 800, 200, ScaleType.FIT_XY);
-    test(0.50f, 0.75f, 10, 15, 800, 400, ScaleType.FIT_XY);
-    test(2.00f, 2.00f, 10, 15, 200, 150, ScaleType.FIT_XY);
-    test(1.00f, 1.00f, 10, 15, 400, 300, ScaleType.FIT_XY);
-    test(0.50f, 0.50f, 10, 15, 800, 600, ScaleType.FIT_XY);
-    test(2.00f, 1.50f, 10, 15, 200, 200, ScaleType.FIT_XY);
-    test(2.00f, 0.75f, 10, 15, 200, 400, ScaleType.FIT_XY);
-    test(0.80f, 0.75f, 10, 15, 500, 400, ScaleType.FIT_XY);
-  }
-
-  @Test
-  public void testFitStart() {
-    test(1.60f, 1.60f, 10, 15, 250, 150, ScaleType.FIT_START);
-    test(0.50f, 0.50f, 10, 15, 800, 200, ScaleType.FIT_START);
-    test(0.50f, 0.50f, 10, 15, 800, 400, ScaleType.FIT_START);
-    test(2.00f, 2.00f, 10, 15, 200, 150, ScaleType.FIT_START);
-    test(1.00f, 1.00f, 10, 15, 400, 300, ScaleType.FIT_START);
-    test(0.50f, 0.50f, 10, 15, 800, 600, ScaleType.FIT_START);
-    test(1.50f, 1.50f, 10, 15, 200, 200, ScaleType.FIT_START);
-    test(0.75f, 0.75f, 10, 15, 200, 400, ScaleType.FIT_START);
-    test(0.75f, 0.75f, 10, 15, 500, 400, ScaleType.FIT_START);
-  }
-
-  @Test
-  public void testFitCenter() {
-    test(1.60f, 1.60f,  10,  45, 250, 150, ScaleType.FIT_CENTER);
-    test(0.50f, 0.50f,  10, 115, 800, 200, ScaleType.FIT_CENTER);
-    test(0.50f, 0.50f,  10,  65, 800, 400, ScaleType.FIT_CENTER);
-    test(2.00f, 2.00f,  10,  15, 200, 150, ScaleType.FIT_CENTER);
-    test(1.00f, 1.00f,  10,  15, 400, 300, ScaleType.FIT_CENTER);
-    test(0.50f, 0.50f,  10,  15, 800, 600, ScaleType.FIT_CENTER);
-    test(1.50f, 1.50f,  60,  15, 200, 200, ScaleType.FIT_CENTER);
-    test(0.75f, 0.75f, 135,  15, 200, 400, ScaleType.FIT_CENTER);
-    test(0.75f, 0.75f,  23,  15, 500, 400, ScaleType.FIT_CENTER);
-  }
-
-  @Test
-  public void testFitEnd() {
-    test(1.60f, 1.60f,  10,  75, 250, 150, ScaleType.FIT_END);
-    test(0.50f, 0.50f,  10, 215, 800, 200, ScaleType.FIT_END);
-    test(0.50f, 0.50f,  10, 115, 800, 400, ScaleType.FIT_END);
-    test(2.00f, 2.00f,  10,  15, 200, 150, ScaleType.FIT_END);
-    test(1.00f, 1.00f,  10,  15, 400, 300, ScaleType.FIT_END);
-    test(0.50f, 0.50f,  10,  15, 800, 600, ScaleType.FIT_END);
-    test(1.50f, 1.50f, 110,  15, 200, 200, ScaleType.FIT_END);
-    test(0.75f, 0.75f, 260,  15, 200, 400, ScaleType.FIT_END);
-    test(0.75f, 0.75f,  35,  15, 500, 400, ScaleType.FIT_END);
-  }
-
-  @Test
-  public void testCenter() {
-    test(1.00f, 1.00f,   85,   90, 250, 150, ScaleType.CENTER);
-    test(1.00f, 1.00f, -189,   65, 800, 200, ScaleType.CENTER);
-    test(1.00f, 1.00f, -189,  -34, 800, 400, ScaleType.CENTER);
-    test(1.00f, 1.00f,  110,   90, 200, 150, ScaleType.CENTER);
-    test(1.00f, 1.00f,   10,   15, 400, 300, ScaleType.CENTER);
-    test(1.00f, 1.00f, -189, -134, 800, 600, ScaleType.CENTER);
-    test(1.00f, 1.00f,  110,   65, 200, 200, ScaleType.CENTER);
-    test(1.00f, 1.00f,  110,  -34, 200, 400, ScaleType.CENTER);
-    test(1.00f, 1.00f,  -39,  -34, 500, 400, ScaleType.CENTER);
-  }
-
-  @Test
-  public void testCenterInside() {
-    test(1.00f, 1.00f,  85,  90, 250, 150, ScaleType.CENTER_INSIDE);
-    test(0.50f, 0.50f,  10, 115, 800, 200, ScaleType.CENTER_INSIDE);
-    test(0.50f, 0.50f,  10,  65, 800, 400, ScaleType.CENTER_INSIDE);
-    test(1.00f, 1.00f, 110,  90, 200, 150, ScaleType.CENTER_INSIDE);
-    test(1.00f, 1.00f,  10,  15, 400, 300, ScaleType.CENTER_INSIDE);
-    test(0.50f, 0.50f,  10,  15, 800, 600, ScaleType.CENTER_INSIDE);
-    test(1.00f, 1.00f, 110,  65, 200, 200, ScaleType.CENTER_INSIDE);
-    test(0.75f, 0.75f, 135,  15, 200, 400, ScaleType.CENTER_INSIDE);
-    test(0.75f, 0.75f,  23,  15, 500, 400, ScaleType.CENTER_INSIDE);
-  }
-
-  @Test
-  public void testCenterCrop() {
-    test(2.00f, 2.00f,  -39,   15, 250, 150, ScaleType.CENTER_CROP);
-    test(1.50f, 1.50f, -389,   15, 800, 200, ScaleType.CENTER_CROP);
-    test(0.75f, 0.75f,  -89,   15, 800, 400, ScaleType.CENTER_CROP);
-    test(2.00f, 2.00f,   10,   15, 200, 150, ScaleType.CENTER_CROP);
-    test(1.00f, 1.00f,   10,   15, 400, 300, ScaleType.CENTER_CROP);
-    test(0.50f, 0.50f,   10,   15, 800, 600, ScaleType.CENTER_CROP);
-    test(2.00f, 2.00f,   10,  -34, 200, 200, ScaleType.CENTER_CROP);
-    test(2.00f, 2.00f,   10, -234, 200, 400, ScaleType.CENTER_CROP);
-    test(0.80f, 0.80f,   10,    5, 500, 400, ScaleType.CENTER_CROP);
-  }
-
-  @Test
-  public void testFocusCrop_DefaultFocus() {
-    test(2.00f, 2.00f,  -39,   15, 250, 150, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
-    test(1.50f, 1.50f, -389,   15, 800, 200, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
-    test(0.75f, 0.75f,  -89,   15, 800, 400, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f,   10,   15, 200, 150, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
-    test(1.00f, 1.00f,   10,   15, 400, 300, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
-    test(0.50f, 0.50f,   10,   15, 800, 600, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f,   10,  -34, 200, 200, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f,   10, -234, 200, 400, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
-    test(0.80f, 0.80f,   10,    5, 500, 400, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
-  }
-
-  @Test
-  public void testFocusCrop_FocusCentered() {
-    test(2.00f, 2.00f,  -14,   15, 250, 150, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
-    test(1.50f, 1.50f, -329,   15, 800, 200, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
-    test(0.75f, 0.75f,  -59,   15, 800, 400, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f,   10,   15, 200, 150, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
-    test(1.00f, 1.00f,   10,   15, 400, 300, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
-    test(0.50f, 0.50f,   10,   15, 800, 600, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f,   10,  -54, 200, 200, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f,   10, -274, 200, 400, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
-    test(0.80f, 0.80f,   10,    2, 500, 400, 0.45f, 0.51f, ScaleType.FOCUS_CROP);
-  }
-
-  @Test
-  public void testFocusCrop_FocusTopLeft() {
-    test(2.00f, 2.00f, 10, 15, 250, 150, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
-    test(1.50f, 1.50f, 10, 15, 800, 200, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
-    test(0.75f, 0.75f, 10, 15, 800, 400, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f, 10, 15, 200, 150, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
-    test(1.00f, 1.00f, 10, 15, 400, 300, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
-    test(0.50f, 0.50f, 10, 15, 800, 600, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f, 10, 15, 200, 200, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f, 10, 15, 200, 400, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
-    test(0.80f, 0.80f, 10, 15, 500, 400, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
-  }
-
-  @Test
-  public void testFocusCrop_FocusBottomRight() {
-    test(2.00f, 2.00f,  -89,   15, 250, 150, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
-    test(1.50f, 1.50f, -789,   15, 800, 200, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
-    test(0.75f, 0.75f, -189,   15, 800, 400, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f,   10,   15, 200, 150, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
-    test(1.00f, 1.00f,   10,   15, 400, 300, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
-    test(0.50f, 0.50f,   10,   15, 800, 600, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f,   10,  -84, 200, 200, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
-    test(2.00f, 2.00f,   10, -484, 200, 400, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
-    test(0.80f, 0.80f,   10,   -4, 500, 400, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
-  }
-
-  private void test(
-      // expected
-      float scaleX,
-      float scaleY,
-      float translateX,
-      float translateY,
-      // params
-      int childWidth,
-      int childHeight,
-      ScaleType scaleType) {
-    test(scaleX, scaleY, translateX, translateY, childWidth, childHeight, 0.5f, 0.5f, scaleType);
-  }
-
-  private void test(
-      // expected
-      float scaleX,
-      float scaleY,
-      float translateX,
-      float translateY,
-      // params
-      int childWidth,
-      int childHeight,
-      float focusX,
-      float focusY,
-      ScaleType scaleType) {
-
-    mExpectedMatrix.reset();
-    if (scaleType == ScaleType.CENTER) {
-      Assert.assertEquals(1.0f, scaleX, 0);
-      Assert.assertEquals(1.0f, scaleY, 0);
-      mExpectedMatrix.setTranslate(translateX, translateY);
-    } else {
-      createTransform(
-          mExpectedMatrix,
-          scaleX,
-          scaleY,
-          translateX,
-          translateY);
+    private final Matrix mExpectedMatrix = new Matrix();
+    private final Matrix mActualMatrix = new Matrix();
+    private final Rect mParentBounds = new Rect(10, 15, 410, 315);
+
+    @Before
+    public void setUp() {
+    }
+
+    @Test
+    public void testFitXY() {
+        test(1.60f, 2.00f, 10, 15, 250, 150, ScaleType.FIT_XY);
+        test(0.50f, 1.50f, 10, 15, 800, 200, ScaleType.FIT_XY);
+        test(0.50f, 0.75f, 10, 15, 800, 400, ScaleType.FIT_XY);
+        test(2.00f, 2.00f, 10, 15, 200, 150, ScaleType.FIT_XY);
+        test(1.00f, 1.00f, 10, 15, 400, 300, ScaleType.FIT_XY);
+        test(0.50f, 0.50f, 10, 15, 800, 600, ScaleType.FIT_XY);
+        test(2.00f, 1.50f, 10, 15, 200, 200, ScaleType.FIT_XY);
+        test(2.00f, 0.75f, 10, 15, 200, 400, ScaleType.FIT_XY);
+        test(0.80f, 0.75f, 10, 15, 500, 400, ScaleType.FIT_XY);
+    }
+
+    @Test
+    public void testFitStart() {
+        test(1.60f, 1.60f, 10, 15, 250, 150, ScaleType.FIT_START);
+        test(0.50f, 0.50f, 10, 15, 800, 200, ScaleType.FIT_START);
+        test(0.50f, 0.50f, 10, 15, 800, 400, ScaleType.FIT_START);
+        test(2.00f, 2.00f, 10, 15, 200, 150, ScaleType.FIT_START);
+        test(1.00f, 1.00f, 10, 15, 400, 300, ScaleType.FIT_START);
+        test(0.50f, 0.50f, 10, 15, 800, 600, ScaleType.FIT_START);
+        test(1.50f, 1.50f, 10, 15, 200, 200, ScaleType.FIT_START);
+        test(0.75f, 0.75f, 10, 15, 200, 400, ScaleType.FIT_START);
+        test(0.75f, 0.75f, 10, 15, 500, 400, ScaleType.FIT_START);
+    }
+
+    @Test
+    public void testFitCenter() {
+        test(1.60f, 1.60f, 10, 45, 250, 150, ScaleType.FIT_CENTER);
+        test(0.50f, 0.50f, 10, 115, 800, 200, ScaleType.FIT_CENTER);
+        test(0.50f, 0.50f, 10, 65, 800, 400, ScaleType.FIT_CENTER);
+        test(2.00f, 2.00f, 10, 15, 200, 150, ScaleType.FIT_CENTER);
+        test(1.00f, 1.00f, 10, 15, 400, 300, ScaleType.FIT_CENTER);
+        test(0.50f, 0.50f, 10, 15, 800, 600, ScaleType.FIT_CENTER);
+        test(1.50f, 1.50f, 60, 15, 200, 200, ScaleType.FIT_CENTER);
+        test(0.75f, 0.75f, 135, 15, 200, 400, ScaleType.FIT_CENTER);
+        test(0.75f, 0.75f, 23, 15, 500, 400, ScaleType.FIT_CENTER);
+    }
+
+    @Test
+    public void testFitEnd() {
+        test(1.60f, 1.60f, 10, 75, 250, 150, ScaleType.FIT_END);
+        test(0.50f, 0.50f, 10, 215, 800, 200, ScaleType.FIT_END);
+        test(0.50f, 0.50f, 10, 115, 800, 400, ScaleType.FIT_END);
+        test(2.00f, 2.00f, 10, 15, 200, 150, ScaleType.FIT_END);
+        test(1.00f, 1.00f, 10, 15, 400, 300, ScaleType.FIT_END);
+        test(0.50f, 0.50f, 10, 15, 800, 600, ScaleType.FIT_END);
+        test(1.50f, 1.50f, 110, 15, 200, 200, ScaleType.FIT_END);
+        test(0.75f, 0.75f, 260, 15, 200, 400, ScaleType.FIT_END);
+        test(0.75f, 0.75f, 35, 15, 500, 400, ScaleType.FIT_END);
+    }
+
+    @Test
+    public void testCenter() {
+        test(1.00f, 1.00f, 85, 90, 250, 150, ScaleType.CENTER);
+        test(1.00f, 1.00f, -189, 65, 800, 200, ScaleType.CENTER);
+        test(1.00f, 1.00f, -189, -34, 800, 400, ScaleType.CENTER);
+        test(1.00f, 1.00f, 110, 90, 200, 150, ScaleType.CENTER);
+        test(1.00f, 1.00f, 10, 15, 400, 300, ScaleType.CENTER);
+        test(1.00f, 1.00f, -189, -134, 800, 600, ScaleType.CENTER);
+        test(1.00f, 1.00f, 110, 65, 200, 200, ScaleType.CENTER);
+        test(1.00f, 1.00f, 110, -34, 200, 400, ScaleType.CENTER);
+        test(1.00f, 1.00f, -39, -34, 500, 400, ScaleType.CENTER);
+    }
+
+    @Test
+    public void testCenterInside() {
+        test(1.00f, 1.00f, 85, 90, 250, 150, ScaleType.CENTER_INSIDE);
+        test(0.50f, 0.50f, 10, 115, 800, 200, ScaleType.CENTER_INSIDE);
+        test(0.50f, 0.50f, 10, 65, 800, 400, ScaleType.CENTER_INSIDE);
+        test(1.00f, 1.00f, 110, 90, 200, 150, ScaleType.CENTER_INSIDE);
+        test(1.00f, 1.00f, 10, 15, 400, 300, ScaleType.CENTER_INSIDE);
+        test(0.50f, 0.50f, 10, 15, 800, 600, ScaleType.CENTER_INSIDE);
+        test(1.00f, 1.00f, 110, 65, 200, 200, ScaleType.CENTER_INSIDE);
+        test(0.75f, 0.75f, 135, 15, 200, 400, ScaleType.CENTER_INSIDE);
+        test(0.75f, 0.75f, 23, 15, 500, 400, ScaleType.CENTER_INSIDE);
+    }
+
+    @Test
+    public void testCenterCrop() {
+        test(2.00f, 2.00f, -39, 15, 250, 150, ScaleType.CENTER_CROP);
+        test(1.50f, 1.50f, -389, 15, 800, 200, ScaleType.CENTER_CROP);
+        test(0.75f, 0.75f, -89, 15, 800, 400, ScaleType.CENTER_CROP);
+        test(2.00f, 2.00f, 10, 15, 200, 150, ScaleType.CENTER_CROP);
+        test(1.00f, 1.00f, 10, 15, 400, 300, ScaleType.CENTER_CROP);
+        test(0.50f, 0.50f, 10, 15, 800, 600, ScaleType.CENTER_CROP);
+        test(2.00f, 2.00f, 10, -34, 200, 200, ScaleType.CENTER_CROP);
+        test(2.00f, 2.00f, 10, -234, 200, 400, ScaleType.CENTER_CROP);
+        test(0.80f, 0.80f, 10, 5, 500, 400, ScaleType.CENTER_CROP);
+    }
+
+    @Test
+    public void testFocusCrop_DefaultFocus() {
+        test(2.00f, 2.00f, -39, 15, 250, 150, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
+        test(1.50f, 1.50f, -389, 15, 800, 200, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
+        test(0.75f, 0.75f, -89, 15, 800, 400, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, 15, 200, 150, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
+        test(1.00f, 1.00f, 10, 15, 400, 300, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
+        test(0.50f, 0.50f, 10, 15, 800, 600, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, -34, 200, 200, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, -234, 200, 400, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
+        test(0.80f, 0.80f, 10, 5, 500, 400, 0.50f, 0.50f, ScaleType.FOCUS_CROP);
+    }
+
+    @Test
+    public void testFocusCrop_FocusCentered() {
+        test(2.00f, 2.00f, -14, 15, 250, 150, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
+        test(1.50f, 1.50f, -329, 15, 800, 200, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
+        test(0.75f, 0.75f, -59, 15, 800, 400, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, 15, 200, 150, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
+        test(1.00f, 1.00f, 10, 15, 400, 300, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
+        test(0.50f, 0.50f, 10, 15, 800, 600, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, -54, 200, 200, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, -274, 200, 400, 0.45f, 0.55f, ScaleType.FOCUS_CROP);
+        test(0.80f, 0.80f, 10, 2, 500, 400, 0.45f, 0.51f, ScaleType.FOCUS_CROP);
+    }
+
+    @Test
+    public void testFocusCrop_FocusTopLeft() {
+        test(2.00f, 2.00f, 10, 15, 250, 150, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
+        test(1.50f, 1.50f, 10, 15, 800, 200, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
+        test(0.75f, 0.75f, 10, 15, 800, 400, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, 15, 200, 150, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
+        test(1.00f, 1.00f, 10, 15, 400, 300, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
+        test(0.50f, 0.50f, 10, 15, 800, 600, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, 15, 200, 200, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, 15, 200, 400, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
+        test(0.80f, 0.80f, 10, 15, 500, 400, 0.00f, 0.00f, ScaleType.FOCUS_CROP);
     }
 
-    mActualMatrix.reset();
-    ScalingUtils.getTransform(
-        mActualMatrix,
-        mParentBounds,
-        childWidth,
-        childHeight,
-        focusX,
-        focusY,
-        scaleType);
-
-    AndroidGraphicsTestUtils.assertEquals(mExpectedMatrix, mActualMatrix);
-  }
-
-  private static Matrix createTransform(
-      Matrix transform,
-      float scaleX,
-      float scaleY,
-      float translateX,
-      float translateY) {
-    transform.setScale(scaleX, scaleY);
-    transform.postTranslate(translateX, translateY);
-    return transform;
-  }
+    @Test
+    public void testFocusCrop_FocusBottomRight() {
+        test(2.00f, 2.00f, -89, 15, 250, 150, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
+        test(1.50f, 1.50f, -789, 15, 800, 200, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
+        test(0.75f, 0.75f, -189, 15, 800, 400, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, 15, 200, 150, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
+        test(1.00f, 1.00f, 10, 15, 400, 300, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
+        test(0.50f, 0.50f, 10, 15, 800, 600, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, -84, 200, 200, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
+        test(2.00f, 2.00f, 10, -484, 200, 400, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
+        test(0.80f, 0.80f, 10, -4, 500, 400, 1.00f, 1.00f, ScaleType.FOCUS_CROP);
+    }
+
+    private void test(
+            // expected
+            float scaleX,
+            float scaleY,
+            float translateX,
+            float translateY,
+            // params
+            int childWidth,
+            int childHeight,
+            ScaleType scaleType) {
+        test(scaleX, scaleY, translateX, translateY, childWidth, childHeight, 0.5f, 0.5f, scaleType);
+    }
+
+    private void test(
+            // expected
+            float scaleX,
+            float scaleY,
+            float translateX,
+            float translateY,
+            // params
+            int childWidth,
+            int childHeight,
+            float focusX,
+            float focusY,
+            ScaleType scaleType) {
+
+        mExpectedMatrix.reset();
+        if (scaleType == ScaleType.CENTER) {
+            Assert.assertEquals(1.0f, scaleX, 0);
+            Assert.assertEquals(1.0f, scaleY, 0);
+            mExpectedMatrix.setTranslate(translateX, translateY);
+        } else {
+            createTransform(
+                    mExpectedMatrix,
+                    scaleX,
+                    scaleY,
+                    translateX,
+                    translateY);
+        }
+
+        mActualMatrix.reset();
+        ScalingUtils.getTransform(
+                mActualMatrix,
+                mParentBounds,
+                childWidth,
+                childHeight,
+                focusX,
+                focusY,
+                scaleType);
+
+        AndroidGraphicsTestUtils.assertEquals(mExpectedMatrix, mActualMatrix);
+    }
+
+    private static Matrix createTransform(
+            Matrix transform,
+            float scaleX,
+            float scaleY,
+            float translateX,
+            float translateY) {
+        transform.setScale(scaleX, scaleY);
+        transform.postTranslate(translateX, translateY);
+        return transform;
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/drawable/SettableDrawableTest.java b/drawee/src/test/java/com/facebook/drawee/drawable/SettableDrawableTest.java
index 4e3de4904..a2e1f3f54 100644
--- a/drawee/src/test/java/com/facebook/drawee/drawable/SettableDrawableTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/drawable/SettableDrawableTest.java
@@ -22,54 +22,54 @@
 
 @RunWith(WithTestDefaultsRunner.class)
 public class SettableDrawableTest {
-  private Drawable mUnderlyingDrawable0;
-  private Drawable mUnderlyingDrawable1;
-  private Drawable mUnderlyingDrawable2;
-  private Drawable mUnderlyingDrawable3;
-  private SettableDrawable mSettableDrawable;
+    private Drawable mUnderlyingDrawable0;
+    private Drawable mUnderlyingDrawable1;
+    private Drawable mUnderlyingDrawable2;
+    private Drawable mUnderlyingDrawable3;
+    private SettableDrawable mSettableDrawable;
 
-  @Before
-  public void setUp() {
-    mUnderlyingDrawable0 = mock(Drawable.class);
-    mUnderlyingDrawable1 = mock(Drawable.class);
-    mUnderlyingDrawable2 = mock(Drawable.class);
-    mUnderlyingDrawable3 = mock(Drawable.class);
-    mSettableDrawable = new SettableDrawable(mUnderlyingDrawable0);
-  }
+    @Before
+    public void setUp() {
+        mUnderlyingDrawable0 = mock(Drawable.class);
+        mUnderlyingDrawable1 = mock(Drawable.class);
+        mUnderlyingDrawable2 = mock(Drawable.class);
+        mUnderlyingDrawable3 = mock(Drawable.class);
+        mSettableDrawable = new SettableDrawable(mUnderlyingDrawable0);
+    }
 
-  @Test
-  public void testIntrinsicDimensions() {
-    when(mUnderlyingDrawable0.getIntrinsicWidth()).thenReturn(100);
-    when(mUnderlyingDrawable0.getIntrinsicHeight()).thenReturn(200);
-    when(mUnderlyingDrawable1.getIntrinsicWidth()).thenReturn(300);
-    when(mUnderlyingDrawable1.getIntrinsicHeight()).thenReturn(400);
-    Assert.assertEquals(100, mSettableDrawable.getIntrinsicWidth());
-    Assert.assertEquals(200, mSettableDrawable.getIntrinsicHeight());
-    mSettableDrawable.setDrawable(mUnderlyingDrawable1);
-    Assert.assertEquals(300, mSettableDrawable.getIntrinsicWidth());
-    Assert.assertEquals(400, mSettableDrawable.getIntrinsicHeight());
-  }
+    @Test
+    public void testIntrinsicDimensions() {
+        when(mUnderlyingDrawable0.getIntrinsicWidth()).thenReturn(100);
+        when(mUnderlyingDrawable0.getIntrinsicHeight()).thenReturn(200);
+        when(mUnderlyingDrawable1.getIntrinsicWidth()).thenReturn(300);
+        when(mUnderlyingDrawable1.getIntrinsicHeight()).thenReturn(400);
+        Assert.assertEquals(100, mSettableDrawable.getIntrinsicWidth());
+        Assert.assertEquals(200, mSettableDrawable.getIntrinsicHeight());
+        mSettableDrawable.setDrawable(mUnderlyingDrawable1);
+        Assert.assertEquals(300, mSettableDrawable.getIntrinsicWidth());
+        Assert.assertEquals(400, mSettableDrawable.getIntrinsicHeight());
+    }
 
-  @Test
-  public void testGetCurrent() {
-    // initial drawable is mUnderlyingDrawable0
-    Assert.assertEquals(mUnderlyingDrawable0, mSettableDrawable.getCurrent());
-    mSettableDrawable.setDrawable(mUnderlyingDrawable1);
-    Assert.assertEquals(mUnderlyingDrawable1, mSettableDrawable.getCurrent());
-    mSettableDrawable.setDrawable(mUnderlyingDrawable2);
-    Assert.assertEquals(mUnderlyingDrawable2, mSettableDrawable.getCurrent());
-    mSettableDrawable.setDrawable(mUnderlyingDrawable3);
-    Assert.assertEquals(mUnderlyingDrawable3, mSettableDrawable.getCurrent());
-  }
+    @Test
+    public void testGetCurrent() {
+        // initial drawable is mUnderlyingDrawable0
+        Assert.assertEquals(mUnderlyingDrawable0, mSettableDrawable.getCurrent());
+        mSettableDrawable.setDrawable(mUnderlyingDrawable1);
+        Assert.assertEquals(mUnderlyingDrawable1, mSettableDrawable.getCurrent());
+        mSettableDrawable.setDrawable(mUnderlyingDrawable2);
+        Assert.assertEquals(mUnderlyingDrawable2, mSettableDrawable.getCurrent());
+        mSettableDrawable.setDrawable(mUnderlyingDrawable3);
+        Assert.assertEquals(mUnderlyingDrawable3, mSettableDrawable.getCurrent());
+    }
 
-  @Test
-  public void testSetCurrent() {
-    Drawable.Callback callback = mock(Drawable.Callback.class);
-    mSettableDrawable.setCallback(callback);
-    mSettableDrawable.setDrawable(mUnderlyingDrawable1);
-    verify(mUnderlyingDrawable0).setCallback(null);
-    verify(mUnderlyingDrawable1).setCallback(isNotNull(Drawable.Callback.class));
-    verify(callback).invalidateDrawable(mSettableDrawable);
-  }
+    @Test
+    public void testSetCurrent() {
+        Drawable.Callback callback = mock(Drawable.Callback.class);
+        mSettableDrawable.setCallback(callback);
+        mSettableDrawable.setDrawable(mUnderlyingDrawable1);
+        verify(mUnderlyingDrawable0).setCallback(null);
+        verify(mUnderlyingDrawable1).setCallback(isNotNull(Drawable.Callback.class));
+        verify(callback).invalidateDrawable(mSettableDrawable);
+    }
 
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilderTest.java b/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilderTest.java
index 0fc10ca70..25bb8054f 100644
--- a/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilderTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyBuilderTest.java
@@ -29,118 +29,118 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class GenericDraweeHierarchyBuilderTest {
 
-  private final Drawable mBackgroundDrawable1 = mock(BitmapDrawable.class);
-  private final Drawable mBackgroundDrawable2 = mock(BitmapDrawable.class);
-  private final Drawable mOverlayDrawable1 = mock(BitmapDrawable.class);
-  private final Drawable mOverlayDrawable2 = mock(BitmapDrawable.class);
-  private final BitmapDrawable mPlaceholderDrawable1 = mock(BitmapDrawable.class);
-  private final BitmapDrawable mFailureDrawable1 = mock(BitmapDrawable.class);
-  private final BitmapDrawable mRetryDrawable1 = mock(BitmapDrawable.class);
-  private final BitmapDrawable mPlaceholderDrawable2 = mock(BitmapDrawable.class);
-  private final BitmapDrawable mFailureDrawable2 = mock(BitmapDrawable.class);
-  private final BitmapDrawable mRetryDrawable2 = mock(BitmapDrawable.class);
-  private final BitmapDrawable mProgressBarDrawable1 = mock(BitmapDrawable.class);
-  private final BitmapDrawable mProgressBarDrawable2 = mock(BitmapDrawable.class);
-  private final BitmapDrawable mPressedStateDrawable = mock(BitmapDrawable.class);
-  private final Matrix mActualImageMatrix = mock(Matrix.class);
-  private final PointF mFocusPoint = mock(PointF.class);
-  private final RoundingParams mRoundingParams = mock(RoundingParams.class);
-
-  private void testInitialState(GenericDraweeHierarchyBuilder builder) {
-    assertEquals(300, builder.getFadeDuration());
-    assertEquals(null, builder.getPlaceholderImage());
-    assertEquals(null, builder.getPlaceholderImageScaleType());
-    assertEquals(null, builder.getRetryImage());
-    assertEquals(null, builder.getRetryImageScaleType());
-    assertEquals(null, builder.getFailureImage());
-    assertEquals(null, builder.getFailureImageScaleType());
-    assertEquals(null, builder.getProgressBarImage());
-    assertEquals(null, builder.getProgressBarImageScaleType());
-    assertEquals(ScalingUtils.ScaleType.CENTER_CROP, builder.getActualImageScaleType());
-    assertEquals(null, builder.getActualImageMatrix());
-    assertEquals(null, builder.getActualImageFocusPoint());
-    assertEquals(null, builder.getBackgrounds());
-    assertEquals(null, builder.getOverlays());
-    assertEquals(null, builder.getRoundingParams());
-  }
-
-  @Test
-  public void testBuilder() throws Exception {
-    GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(null);
-
-    // test defaults
-    testInitialState(builder);
-
-    // test fade duration
-    builder.setFadeDuration(100);
-    assertEquals(100, builder.getFadeDuration());
-
-    // test image setters with default scale type
-    builder.setPlaceholderImage(mPlaceholderDrawable1);
-    builder.setRetryImage(mRetryDrawable1);
-    builder.setFailureImage(mFailureDrawable1);
-    builder.setProgressBarImage(mProgressBarDrawable1);
-    assertEquals(mPlaceholderDrawable1, builder.getPlaceholderImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getPlaceholderImageScaleType());
-    assertEquals(mRetryDrawable1, builder.getRetryImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getRetryImageScaleType());
-    assertEquals(mFailureDrawable1, builder.getFailureImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getFailureImageScaleType());
-    assertEquals(mProgressBarDrawable1, builder.getProgressBarImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getProgressBarImageScaleType());
-
-    // test image setters with explicit scale type
-    builder.setPlaceholderImage(mPlaceholderDrawable2, ScalingUtils.ScaleType.CENTER);
-    builder.setRetryImage(mRetryDrawable2, ScalingUtils.ScaleType.FIT_CENTER);
-    builder.setFailureImage(mFailureDrawable2, ScalingUtils.ScaleType.FIT_END);
-    builder.setProgressBarImage(mProgressBarDrawable2, ScalingUtils.ScaleType.CENTER_CROP);
-    assertEquals(mPlaceholderDrawable2, builder.getPlaceholderImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER, builder.getPlaceholderImageScaleType());
-    assertEquals(mRetryDrawable2, builder.getRetryImage());
-    assertEquals(ScalingUtils.ScaleType.FIT_CENTER, builder.getRetryImageScaleType());
-    assertEquals(mFailureDrawable2, builder.getFailureImage());
-    assertEquals(ScalingUtils.ScaleType.FIT_END, builder.getFailureImageScaleType());
-    assertEquals(mProgressBarDrawable2, builder.getProgressBarImage());
-    assertEquals(ScalingUtils.ScaleType.CENTER_CROP, builder.getProgressBarImageScaleType());
-
-    // test actual image matrix
-    builder.setActualImageMatrix(mActualImageMatrix);
-    assertSame(mActualImageMatrix, builder.getActualImageMatrix());
-    assertSame(null, builder.getActualImageScaleType());
-
-    // test actual image scale type
-    builder.setActualImageScaleType(ScalingUtils.ScaleType.FIT_START);
-    assertEquals(ScalingUtils.ScaleType.FIT_START, builder.getActualImageScaleType());
-
-    // test actual image focus point
-    builder.setActualImageFocusPoint(mFocusPoint);
-    AndroidGraphicsTestUtils.assertEquals(mFocusPoint, builder.getActualImageFocusPoint(), 0f);
-    builder.setActualImageScaleType(ScalingUtils.ScaleType.FOCUS_CROP);
-    assertSame(ScalingUtils.ScaleType.FOCUS_CROP, builder.getActualImageScaleType());
-    assertSame(null, builder.getActualImageMatrix());
-
-    // test backgrounds & overlays
-    builder.setBackgrounds(Lists.newArrayList(mBackgroundDrawable1, mBackgroundDrawable2));
-    builder.setOverlays(Lists.newArrayList(mOverlayDrawable1, mOverlayDrawable2));
-    assertArrayEquals(
-        builder.getBackgrounds().toArray(),
-        new Drawable[]{mBackgroundDrawable1, mBackgroundDrawable2});
-    assertArrayEquals(
-        builder.getOverlays().toArray(),
-        new Drawable[]{mOverlayDrawable1, mOverlayDrawable2});
-    builder.setBackground(mBackgroundDrawable2);
-    builder.setOverlay(mOverlayDrawable2);
-    builder.setPressedStateOverlay(mPressedStateDrawable);
-    assertArrayEquals(builder.getBackgrounds().toArray(), new Drawable[]{mBackgroundDrawable2});
-    assertArrayEquals(builder.getOverlays().toArray(), new Drawable[] {mOverlayDrawable2});
-    assertEquals(builder.getPressedStateOverlay().getClass(), StateListDrawable.class);
-
-    // test rounding params
-    builder.setRoundingParams(mRoundingParams);
-    assertEquals(mRoundingParams, builder.getRoundingParams());
-
-    // test reset
-    builder.reset();
-    testInitialState(builder);
-  }
+    private final Drawable mBackgroundDrawable1 = mock(BitmapDrawable.class);
+    private final Drawable mBackgroundDrawable2 = mock(BitmapDrawable.class);
+    private final Drawable mOverlayDrawable1 = mock(BitmapDrawable.class);
+    private final Drawable mOverlayDrawable2 = mock(BitmapDrawable.class);
+    private final BitmapDrawable mPlaceholderDrawable1 = mock(BitmapDrawable.class);
+    private final BitmapDrawable mFailureDrawable1 = mock(BitmapDrawable.class);
+    private final BitmapDrawable mRetryDrawable1 = mock(BitmapDrawable.class);
+    private final BitmapDrawable mPlaceholderDrawable2 = mock(BitmapDrawable.class);
+    private final BitmapDrawable mFailureDrawable2 = mock(BitmapDrawable.class);
+    private final BitmapDrawable mRetryDrawable2 = mock(BitmapDrawable.class);
+    private final BitmapDrawable mProgressBarDrawable1 = mock(BitmapDrawable.class);
+    private final BitmapDrawable mProgressBarDrawable2 = mock(BitmapDrawable.class);
+    private final BitmapDrawable mPressedStateDrawable = mock(BitmapDrawable.class);
+    private final Matrix mActualImageMatrix = mock(Matrix.class);
+    private final PointF mFocusPoint = mock(PointF.class);
+    private final RoundingParams mRoundingParams = mock(RoundingParams.class);
+
+    private void testInitialState(GenericDraweeHierarchyBuilder builder) {
+        assertEquals(300, builder.getFadeDuration());
+        assertEquals(null, builder.getPlaceholderImage());
+        assertEquals(null, builder.getPlaceholderImageScaleType());
+        assertEquals(null, builder.getRetryImage());
+        assertEquals(null, builder.getRetryImageScaleType());
+        assertEquals(null, builder.getFailureImage());
+        assertEquals(null, builder.getFailureImageScaleType());
+        assertEquals(null, builder.getProgressBarImage());
+        assertEquals(null, builder.getProgressBarImageScaleType());
+        assertEquals(ScalingUtils.ScaleType.CENTER_CROP, builder.getActualImageScaleType());
+        assertEquals(null, builder.getActualImageMatrix());
+        assertEquals(null, builder.getActualImageFocusPoint());
+        assertEquals(null, builder.getBackgrounds());
+        assertEquals(null, builder.getOverlays());
+        assertEquals(null, builder.getRoundingParams());
+    }
+
+    @Test
+    public void testBuilder() throws Exception {
+        GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(null);
+
+        // test defaults
+        testInitialState(builder);
+
+        // test fade duration
+        builder.setFadeDuration(100);
+        assertEquals(100, builder.getFadeDuration());
+
+        // test image setters with default scale type
+        builder.setPlaceholderImage(mPlaceholderDrawable1);
+        builder.setRetryImage(mRetryDrawable1);
+        builder.setFailureImage(mFailureDrawable1);
+        builder.setProgressBarImage(mProgressBarDrawable1);
+        assertEquals(mPlaceholderDrawable1, builder.getPlaceholderImage());
+        assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getPlaceholderImageScaleType());
+        assertEquals(mRetryDrawable1, builder.getRetryImage());
+        assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getRetryImageScaleType());
+        assertEquals(mFailureDrawable1, builder.getFailureImage());
+        assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getFailureImageScaleType());
+        assertEquals(mProgressBarDrawable1, builder.getProgressBarImage());
+        assertEquals(ScalingUtils.ScaleType.CENTER_INSIDE, builder.getProgressBarImageScaleType());
+
+        // test image setters with explicit scale type
+        builder.setPlaceholderImage(mPlaceholderDrawable2, ScalingUtils.ScaleType.CENTER);
+        builder.setRetryImage(mRetryDrawable2, ScalingUtils.ScaleType.FIT_CENTER);
+        builder.setFailureImage(mFailureDrawable2, ScalingUtils.ScaleType.FIT_END);
+        builder.setProgressBarImage(mProgressBarDrawable2, ScalingUtils.ScaleType.CENTER_CROP);
+        assertEquals(mPlaceholderDrawable2, builder.getPlaceholderImage());
+        assertEquals(ScalingUtils.ScaleType.CENTER, builder.getPlaceholderImageScaleType());
+        assertEquals(mRetryDrawable2, builder.getRetryImage());
+        assertEquals(ScalingUtils.ScaleType.FIT_CENTER, builder.getRetryImageScaleType());
+        assertEquals(mFailureDrawable2, builder.getFailureImage());
+        assertEquals(ScalingUtils.ScaleType.FIT_END, builder.getFailureImageScaleType());
+        assertEquals(mProgressBarDrawable2, builder.getProgressBarImage());
+        assertEquals(ScalingUtils.ScaleType.CENTER_CROP, builder.getProgressBarImageScaleType());
+
+        // test actual image matrix
+        builder.setActualImageMatrix(mActualImageMatrix);
+        assertSame(mActualImageMatrix, builder.getActualImageMatrix());
+        assertSame(null, builder.getActualImageScaleType());
+
+        // test actual image scale type
+        builder.setActualImageScaleType(ScalingUtils.ScaleType.FIT_START);
+        assertEquals(ScalingUtils.ScaleType.FIT_START, builder.getActualImageScaleType());
+
+        // test actual image focus point
+        builder.setActualImageFocusPoint(mFocusPoint);
+        AndroidGraphicsTestUtils.assertEquals(mFocusPoint, builder.getActualImageFocusPoint(), 0f);
+        builder.setActualImageScaleType(ScalingUtils.ScaleType.FOCUS_CROP);
+        assertSame(ScalingUtils.ScaleType.FOCUS_CROP, builder.getActualImageScaleType());
+        assertSame(null, builder.getActualImageMatrix());
+
+        // test backgrounds & overlays
+        builder.setBackgrounds(Lists.newArrayList(mBackgroundDrawable1, mBackgroundDrawable2));
+        builder.setOverlays(Lists.newArrayList(mOverlayDrawable1, mOverlayDrawable2));
+        assertArrayEquals(
+                builder.getBackgrounds().toArray(),
+                new Drawable[]{mBackgroundDrawable1, mBackgroundDrawable2});
+        assertArrayEquals(
+                builder.getOverlays().toArray(),
+                new Drawable[]{mOverlayDrawable1, mOverlayDrawable2});
+        builder.setBackground(mBackgroundDrawable2);
+        builder.setOverlay(mOverlayDrawable2);
+        builder.setPressedStateOverlay(mPressedStateDrawable);
+        assertArrayEquals(builder.getBackgrounds().toArray(), new Drawable[]{mBackgroundDrawable2});
+        assertArrayEquals(builder.getOverlays().toArray(), new Drawable[]{mOverlayDrawable2});
+        assertEquals(builder.getPressedStateOverlay().getClass(), StateListDrawable.class);
+
+        // test rounding params
+        builder.setRoundingParams(mRoundingParams);
+        assertEquals(mRoundingParams, builder.getRoundingParams());
+
+        // test reset
+        builder.reset();
+        testInitialState(builder);
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyTest.java b/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyTest.java
index 2be404bef..036dd30eb 100644
--- a/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/generic/GenericDraweeHierarchyTest.java
@@ -42,1060 +42,1060 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class GenericDraweeHierarchyTest {
 
-  private final BitmapDrawable mPlaceholderImage = mock(BitmapDrawable.class);
-  private final BitmapDrawable mFailureImage = mock(BitmapDrawable.class);
-  private final BitmapDrawable mRetryImage = mock(BitmapDrawable.class);
-  private final BitmapDrawable mProgressBarImage = mock(BitmapDrawable.class);
-  private final BitmapDrawable mActualImage1 = mock(BitmapDrawable.class);
-  private final BitmapDrawable mActualImage2 = mock(BitmapDrawable.class);
-  private final Matrix mActualImageMatrix = mock(Matrix.class);
-  private final PointF mFocusPoint = new PointF(0.1f, 0.4f);
-  private final Drawable mBackground1 = mock(BitmapDrawable.class);
-  private final Drawable mBackground2 = mock(BitmapDrawable.class);
-  private final Drawable mOverlay1 = mock(BitmapDrawable.class);
-  private final Drawable mOverlay2 = mock(BitmapDrawable.class);
-
-  private GenericDraweeHierarchyBuilder mBuilder;
-
-  @Before
-  public void setUp() {
-    when(mPlaceholderImage.getBounds()).thenReturn(new Rect());
-    when(mPlaceholderImage.getPaint()).thenReturn(new Paint());
-    when(mFailureImage.getBounds()).thenReturn(new Rect());
-    when(mFailureImage.getPaint()).thenReturn(new Paint());
-    when(mRetryImage.getBounds()).thenReturn(new Rect());
-    when(mRetryImage.getPaint()).thenReturn(new Paint());
-    when(mProgressBarImage.getBounds()).thenReturn(new Rect());
-    when(mProgressBarImage.getPaint()).thenReturn(new Paint());
-    when(mActualImage1.getBounds()).thenReturn(new Rect());
-    when(mActualImage1.getPaint()).thenReturn(new Paint());
-    when(mActualImage2.getBounds()).thenReturn(new Rect());
-    when(mActualImage2.getPaint()).thenReturn(new Paint());
-
-    mBuilder = new GenericDraweeHierarchyBuilder(null);
-  }
-
-  @Test
-  public void testHierarchy_WithScaleType() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, ScaleType.CENTER)
-        .setRetryImage(mRetryImage, ScaleType.FIT_CENTER)
-        .setFailureImage(mFailureImage, ScaleType.CENTER_INSIDE)
-        .setProgressBarImage(mProgressBarImage, ScaleType.CENTER_CROP)
-        .setActualImageScaleType(ScaleType.FOCUS_CROP)
-        .setActualImageFocusPoint(mFocusPoint)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(0).getClass());
-    ScaleTypeDrawable placeholderBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(0);
-    assertEquals(ScaleType.CENTER, placeholderBranch.getScaleType());
-    assertEquals(mPlaceholderImage, placeholderBranch.getCurrent());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
-    assertEquals(ScaleType.FOCUS_CROP, actualImageBranch.getScaleType());
-    assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
-    AndroidGraphicsTestUtils.assertEquals(mFocusPoint, actualImageBranch.getFocusPoint(), 0f);
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
-    ScaleTypeDrawable progressBarImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(2);
-    assertEquals(ScaleType.CENTER_CROP, progressBarImageBranch.getScaleType());
-    assertEquals(mProgressBarImage, progressBarImageBranch.getCurrent());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(3).getClass());
-    ScaleTypeDrawable retryImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(3);
-    assertEquals(ScaleType.FIT_CENTER, retryImageBranch.getScaleType());
-    assertEquals(mRetryImage, retryImageBranch.getCurrent());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(4).getClass());
-    ScaleTypeDrawable failureImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(4);
-    assertEquals(ScaleType.CENTER_INSIDE, failureImageBranch.getScaleType());
-    assertEquals(mFailureImage, failureImageBranch.getCurrent());
-  }
-
-  @Test
-  public void testHierarchy_WithMatrix() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setRetryImage(mRetryImage, null)
-        .setFailureImage(mFailureImage, null)
-        .setProgressBarImage(mProgressBarImage, null)
-        .setActualImageMatrix(mActualImageMatrix)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(0));
-
-    assertEquals(MatrixDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    MatrixDrawable actualImageBranch = (MatrixDrawable) fadeDrawable.getDrawable(1);
-    assertEquals(mActualImageMatrix, actualImageBranch.getMatrix());
-    assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
-
-    assertEquals(mProgressBarImage, fadeDrawable.getDrawable(2));
-
-    assertEquals(mRetryImage, fadeDrawable.getDrawable(3));
-
-    assertEquals(mFailureImage, fadeDrawable.getDrawable(4));
-  }
-
-  @Test
-  public void testHierarchy_NoScaleTypeNorMatrix() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setRetryImage(mRetryImage, null)
-        .setFailureImage(mFailureImage, null)
-        .setProgressBarImage(mProgressBarImage, null)
-        .setActualImageScaleType(null)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(0));
-    assertEquals(SettableDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    assertEquals(mProgressBarImage, fadeDrawable.getDrawable(2));
-    assertEquals(mRetryImage, fadeDrawable.getDrawable(3));
-    assertEquals(mFailureImage, fadeDrawable.getDrawable(4));
-  }
-
-  @Test
-  public void testHierarchy_NoPlaceholderImage() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    // transparent color drawable will be used as placeholder
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(0).getClass());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
-    assertEquals(ScaleType.CENTER_CROP, actualImageBranch.getScaleType());
-    assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
-  }
-
-  @Test
-  public void testHierarchy_WithPlaceholderImage() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, ScaleType.CENTER)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(0).getClass());
-    ScaleTypeDrawable placeholderBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(0);
-    assertEquals(ScaleType.CENTER, placeholderBranch.getScaleType());
-    assertEquals(mPlaceholderImage, placeholderBranch.getCurrent());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
-    assertEquals(ScaleType.CENTER_CROP, actualImageBranch.getScaleType());
-    assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
-  }
-
-  @Test
-  public void testHierarchy_WithFailureImage() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setFailureImage(mFailureImage, ScaleType.CENTER)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    // transparent color drawable is used as placeholder when not specified otherwise
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(0).getClass());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
-    assertEquals(ScaleType.CENTER_CROP, actualImageBranch.getScaleType());
-    assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
-    ScaleTypeDrawable failureImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(2);
-    assertEquals(ScaleType.CENTER, failureImageBranch.getScaleType());
-    assertEquals(mFailureImage, failureImageBranch.getCurrent());
-  }
-
-  @Test
-  public void testHierarchy_WithRetryImage() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setRetryImage(mRetryImage, ScaleType.CENTER)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    // transparent color drawable is used as placeholder when not specified otherwise
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(0).getClass());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
-    assertEquals(ScaleType.CENTER_CROP, actualImageBranch.getScaleType());
-    assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
-    ScaleTypeDrawable retryImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(2);
-    assertEquals(ScaleType.CENTER, retryImageBranch.getScaleType());
-    assertEquals(mRetryImage, retryImageBranch.getCurrent());
-  }
-
-  @Test
-  public void testHierarchy_WithProgressBarImage() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setProgressBarImage(mProgressBarImage, ScaleType.CENTER)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    // transparent color drawable is used as placeholder when not specified otherwise
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(0).getClass());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
-    assertEquals(ScaleType.CENTER_CROP, actualImageBranch.getScaleType());
-    assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
-    ScaleTypeDrawable progressBarImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(2);
-    assertEquals(ScaleType.CENTER, progressBarImageBranch.getScaleType());
-    assertEquals(mProgressBarImage, progressBarImageBranch.getCurrent());
-  }
-
-  @Test
-  public void testHierarchy_WithAllBranches() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, ScaleType.CENTER)
-        .setRetryImage(mRetryImage, ScaleType.FIT_CENTER)
-        .setFailureImage(mFailureImage, ScaleType.FIT_CENTER)
-        .setProgressBarImage(mProgressBarImage, ScaleType.CENTER)
-        .setActualImageScaleType(ScaleType.CENTER_CROP)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(6, fadeDrawable.getNumberOfLayers());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(0).getClass());
-    ScaleTypeDrawable placeholderBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(0);
-    assertEquals(ScaleType.CENTER, placeholderBranch.getScaleType());
-    assertEquals(mPlaceholderImage, placeholderBranch.getCurrent());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    ScaleTypeDrawable imageBranch1 = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
-    assertEquals(ScaleType.CENTER_CROP, imageBranch1.getScaleType());
-    assertEquals(SettableDrawable.class, imageBranch1.getCurrent().getClass());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
-    ScaleTypeDrawable progressBarImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(2);
-    assertEquals(ScaleType.CENTER, progressBarImageBranch.getScaleType());
-    assertEquals(mProgressBarImage, progressBarImageBranch.getCurrent());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(3).getClass());
-    ScaleTypeDrawable retryImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(3);
-    assertEquals(ScaleType.FIT_CENTER, retryImageBranch.getScaleType());
-    assertEquals(mRetryImage, retryImageBranch.getCurrent());
-
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(4).getClass());
-    ScaleTypeDrawable failureImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(4);
-    assertEquals(ScaleType.FIT_CENTER, failureImageBranch.getScaleType());
-    assertEquals(mFailureImage, failureImageBranch.getCurrent());
-
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(5).getClass()); // controller overlay
-  }
-
-  @Test
-  public void testHierarchy_WithBackgrounds() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setBackgrounds(Lists.newArrayList(mBackground1, mBackground2))
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(5, fadeDrawable.getNumberOfLayers());
-    assertEquals(mBackground1, fadeDrawable.getDrawable(0));
-    assertEquals(mBackground2, fadeDrawable.getDrawable(1));
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(2));
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(3).getClass());
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(4).getClass()); // controller overlay
-  }
-
-  @Test
-  public void testHierarchy_WithSingleBackground() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setBackground(mBackground1)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(4, fadeDrawable.getNumberOfLayers());
-    assertEquals(mBackground1, fadeDrawable.getDrawable(0));
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(1));
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(3).getClass()); // controller overlay
-  }
-
-  @Test
-  public void testHierarchy_WithOverlays() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setOverlays(Lists.newArrayList(mOverlay1, mOverlay2))
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(5, fadeDrawable.getNumberOfLayers());
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(0));
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    assertEquals(mOverlay1, fadeDrawable.getDrawable(2));
-    assertEquals(mOverlay2, fadeDrawable.getDrawable(3));
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(4).getClass()); // controller overlay
-  }
-
-  @Test
-  public void testHierarchy_WithSingleOverlay() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setOverlay(mOverlay1)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(4, fadeDrawable.getNumberOfLayers());
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(0));
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
-    assertEquals(mOverlay1, fadeDrawable.getDrawable(2));
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(3).getClass()); // controller overlay
-  }
-
-  @Test
-  public void testHierarchy_WithBackgroundsAndOverlays() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setBackgrounds(Lists.newArrayList(mBackground1, mBackground2))
-        .setOverlays(Lists.newArrayList(mOverlay1, mOverlay2))
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(7, fadeDrawable.getNumberOfLayers());
-    assertEquals(mBackground1, fadeDrawable.getDrawable(0));
-    assertEquals(mBackground2, fadeDrawable.getDrawable(1));
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(2));
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(3).getClass());
-    assertEquals(mOverlay1, fadeDrawable.getDrawable(4));
-    assertEquals(mOverlay2, fadeDrawable.getDrawable(5));
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(6).getClass()); // controller overlay
-  }
-
-  @Test
-  public void testHierarchy_WithSingleBackgroundAndOverlay() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setBackground(mBackground2)
-        .setOverlay(mOverlay2)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(5, fadeDrawable.getNumberOfLayers());
-    assertEquals(mBackground2, fadeDrawable.getDrawable(0));
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(1));
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
-    assertEquals(mOverlay2, fadeDrawable.getDrawable(3));
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(4).getClass()); // controller overlay
-  }
-
-  @Test
-  public void testHierarchy_WithPressedStateOverlaySetFirst() throws Exception {
-    //Setting PressedStateOverlay before Overlays and Backgroud
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setPressedStateOverlay(mOverlay1)
-        .setBackground(mBackground2)
-        .setOverlay(mOverlay2)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(6, fadeDrawable.getNumberOfLayers());
-    assertEquals(mBackground2, fadeDrawable.getDrawable(0));
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(1));
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
-    assertEquals(mOverlay2, fadeDrawable.getDrawable(3));
-    assertEquals(StateListDrawable.class, fadeDrawable.getDrawable(4).getClass());
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(5).getClass()); // controller overlay
-  }
-
-  @Test
-  public void testHierarchy_WithPressedStateOverlaySetLast() throws Exception {
-    //Setting PressedStateOverlay after Overlays and Backgroud
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setBackground(mBackground2)
-        .setOverlay(mOverlay2)
-        .setPressedStateOverlay(mOverlay1)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(6, fadeDrawable.getNumberOfLayers());
-    assertEquals(mBackground2, fadeDrawable.getDrawable(0));
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(1));
-    assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
-    assertEquals(mOverlay2, fadeDrawable.getDrawable(3));
-    assertEquals(StateListDrawable.class, fadeDrawable.getDrawable(4).getClass());
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(5).getClass()); // controller overlay
-  }
-
-  @Test
-  public void testHierarchy_WithRoundedCornersDrawable() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setActualImageScaleType(null)
-        .setRoundingParams(RoundingParams.fromCornersRadius(10).setOverlayColor(0xFFFFFFFF))
-        .setFadeDuration(250)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertEquals(RoundedCornersDrawable.class, dh.getTopLevelDrawable().getClass());
-  }
-
-  @Test
-  public void testHierarchy_WithRoundedCornersDrawableAsCircle() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setActualImageScaleType(null)
-        .setRoundingParams(RoundingParams.asCircle().setOverlayColor(0xFFFFFFFF))
-        .setFadeDuration(100)
-        .build();
-
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
-    assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
-
-    assertEquals(RoundedCornersDrawable.class, dh.getTopLevelDrawable().getClass());
-  }
-
-  @Test
-  public void testControlling_WithPlaceholderOnly() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setActualImageScaleType(null)
-        .setFadeDuration(250)
-        .build();
-
-    // image indexes in DH tree
-    final int placeholderImageIndex = 0;
-    final int actualImageIndex = 1;
-
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(placeholderImageIndex));
-    assertEquals(
-        SettableDrawable.class,
-        fadeDrawable.getDrawable(actualImageIndex).getClass());
-
-    SettableDrawable actualImageSettableDrawable =
-        (SettableDrawable) fadeDrawable.getDrawable(actualImageIndex);
-
-    // initial state -> final image (non-immediate)
-    // initial state
-    assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set final image (non-immediate)
-    dh.setImage(mActualImage1, 1f, false);
-    assertEquals(mActualImage1, actualImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
-    assertEquals(250, fadeDrawable.getTransitionDuration());
-
-    // initial state -> final image (immediate)
-    // reset hierarchy to initial state
-    dh.reset();
-    assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set final image (immediate)
-    dh.setImage(mActualImage2, 1f, true);
-    assertEquals(mActualImage2, actualImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-
-    // initial state -> retry
-    // reset hierarchy to initial state
-    dh.reset();
-    assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set retry
-    dh.setRetry(new RuntimeException());
-    assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
-    assertEquals(250, fadeDrawable.getTransitionDuration());
-
-    // initial state -> failure
-    // reset hierarchy to initial state
-    dh.reset();
-    assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set failure
-    dh.setFailure(new RuntimeException());
-    assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
-    assertEquals(250, fadeDrawable.getTransitionDuration());
-  }
-
-  @Test
-  public void testControlling_WithAllLayers() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setBackgrounds(Lists.newArrayList(mBackground1, mBackground2))
-        .setOverlays(Lists.newArrayList(mOverlay1, mOverlay2))
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setRetryImage(mRetryImage, null)
-        .setFailureImage(mFailureImage, null)
-        .setProgressBarImage(mProgressBarImage, null)
-        .setActualImageScaleType(null)
-        .setFadeDuration(250)
-        .build();
-
-    // image indexes in DH tree
-    final int backgroundsIndex = 0;
-    final int numBackgrounds = 2;
-    final int placeholderImageIndex = numBackgrounds + 0;
-    final int actualImageIndex = numBackgrounds + 1;
-    final int progressBarImageIndex = numBackgrounds + 2;
-    final int retryImageIndex = numBackgrounds + 3;
-    final int failureImageIndex = numBackgrounds + 4;
-    final int numBranches = 5;
-    final int overlaysIndex = numBackgrounds + numBranches;
-    final int numOverlays = 2;
-
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(placeholderImageIndex));
-    assertEquals(mProgressBarImage, fadeDrawable.getDrawable(progressBarImageIndex));
-    assertEquals(mRetryImage, fadeDrawable.getDrawable(retryImageIndex));
-    assertEquals(mFailureImage, fadeDrawable.getDrawable(failureImageIndex));
-    assertEquals(
-        SettableDrawable.class,
-        fadeDrawable.getDrawable(actualImageIndex).getClass());
-
-    SettableDrawable finalImageSettableDrawable =
-        (SettableDrawable) fadeDrawable.getDrawable(actualImageIndex);
-
-    // initial state -> final image (immediate)
-    // initial state, show progress bar
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    dh.setProgress(0f, true);
-    assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set final image (immediate)
-    dh.setImage(mActualImage2, 1f, true);
-    assertEquals(mActualImage2, finalImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-
-    // initial state -> final image (non-immediate)
-    // reset hierarchy to initial state, show progress bar
-    dh.reset();
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    dh.setProgress(0f, true);
-    assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set final image (non-immediate)
-    dh.setImage(mActualImage2, 1f, false);
-    assertEquals(mActualImage2, finalImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
-    assertEquals(250, fadeDrawable.getTransitionDuration());
-
-    // initial state -> temporary image (immediate) -> final image (non-immediate)
-    // reset hierarchy to initial state, show progress bar
-    dh.reset();
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    dh.setProgress(0f, true);
-    assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set temporary image (immediate)
-    dh.setImage(mActualImage1, 0.5f, true);
-    assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set final image (non-immediate)
-    dh.setImage(mActualImage2, 1f, false);
-    assertEquals(mActualImage2, finalImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
-    assertEquals(250, fadeDrawable.getTransitionDuration());
-
-    // initial state -> temporary image (non-immediate) -> final image (non-immediate)
-    // reset hierarchy to initial state, show progress bar
-    dh.reset();
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    dh.setProgress(0f, true);
-    assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set temporary image (non-immediate)
-    dh.setImage(mActualImage1, 0.5f, false);
-    assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
-    assertEquals(250, fadeDrawable.getTransitionDuration());
-    // set final image (non-immediate)
-    dh.setImage(mActualImage2, 1f, false);
-    assertEquals(mActualImage2, finalImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
-    assertEquals(250, fadeDrawable.getTransitionDuration());
-
-    // initial state -> temporary image (immediate) -> retry
-    // reset hierarchy to initial state, show progress bar
-    dh.reset();
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    dh.setProgress(0f, true);
-    assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set temporary image (immediate)
-    dh.setImage(mActualImage1, 0.5f, true);
-    assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set retry
-    dh.setRetry(new RuntimeException());
-    assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
-    assertEquals(250, fadeDrawable.getTransitionDuration());
-
-    // initial state -> temporary image (immediate) -> failure
-    // reset hierarchy to initial state, show progress bar
-    dh.reset();
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    dh.setProgress(0f, true);
-    assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set temporary image (immediate)
-    dh.setImage(mActualImage1, 0.5f, true);
-    assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-    // set failure
-    dh.setFailure(new RuntimeException());
-    assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
-    assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
-    assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
-    assertEquals(true, fadeDrawable.isLayerOn(failureImageIndex));
-    assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
-    assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
-    assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
-    assertEquals(250, fadeDrawable.getTransitionDuration());
-  }
-
-  @Test
-  public void testControlling_WithCornerRadii() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setActualImageScaleType(null)
-        .setRoundingParams(RoundingParams.fromCornersRadius(10))
-        .setFadeDuration(250)
-        .build();
-
-    // image indexes in DH tree
-    final int imageIndex = 1;
-
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-    SettableDrawable settableDrawable = (SettableDrawable) fadeDrawable.getDrawable(imageIndex);
-
-    // set temporary image
-    dh.setImage(mActualImage1, 0.5f, true);
-    assertNotSame(mActualImage1, settableDrawable.getCurrent());
-    assertEquals(RoundedBitmapDrawable.class, settableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(imageIndex));
-    assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
-
-    // set final image
-    dh.setImage(mActualImage2, 1f, false);
-    assertNotSame(mActualImage2, settableDrawable.getCurrent());
-    assertEquals(RoundedBitmapDrawable.class, settableDrawable.getCurrent().getClass());
-    assertEquals(true, fadeDrawable.isLayerOn(imageIndex));
-    assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
-    assertEquals(250, fadeDrawable.getTransitionDuration());
-  }
-
-  @Test
-  public void testControlling_WithControllerOverlay() {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, null)
-        .setActualImageScaleType(null)
-        .setFadeDuration(250)
-        .build();
-
-    Drawable controllerOverlay = DrawableTestUtils.mockDrawable();
-
-    // image indexes in DH tree
-    final int placeholderImageIndex = 0;
-    final int actualImageIndex = 1;
-    final int controllerOverlayIndex = 2;
-
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-
-    // initial state
-    assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(placeholderImageIndex));
-    assertEquals(SettableDrawable.class, fadeDrawable.getDrawable(actualImageIndex).getClass());
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(controllerOverlayIndex).getClass());
-
-    // set controller overlay
-    dh.setControllerOverlay(controllerOverlay);
-    assertEquals(controllerOverlay, fadeDrawable.getDrawable(controllerOverlayIndex));
-
-    // clear controller overlay
-    dh.setControllerOverlay(null);
-    assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(controllerOverlayIndex).getClass());
-  }
-
-  private void assertLayersOn(FadeDrawable fadeDrawable, int firstLayerIndex, int numberOfLayers) {
-    for (int i = 0; i < numberOfLayers; i++) {
-      assertEquals(true, fadeDrawable.isLayerOn(firstLayerIndex + i));
+    private final BitmapDrawable mPlaceholderImage = mock(BitmapDrawable.class);
+    private final BitmapDrawable mFailureImage = mock(BitmapDrawable.class);
+    private final BitmapDrawable mRetryImage = mock(BitmapDrawable.class);
+    private final BitmapDrawable mProgressBarImage = mock(BitmapDrawable.class);
+    private final BitmapDrawable mActualImage1 = mock(BitmapDrawable.class);
+    private final BitmapDrawable mActualImage2 = mock(BitmapDrawable.class);
+    private final Matrix mActualImageMatrix = mock(Matrix.class);
+    private final PointF mFocusPoint = new PointF(0.1f, 0.4f);
+    private final Drawable mBackground1 = mock(BitmapDrawable.class);
+    private final Drawable mBackground2 = mock(BitmapDrawable.class);
+    private final Drawable mOverlay1 = mock(BitmapDrawable.class);
+    private final Drawable mOverlay2 = mock(BitmapDrawable.class);
+
+    private GenericDraweeHierarchyBuilder mBuilder;
+
+    @Before
+    public void setUp() {
+        when(mPlaceholderImage.getBounds()).thenReturn(new Rect());
+        when(mPlaceholderImage.getPaint()).thenReturn(new Paint());
+        when(mFailureImage.getBounds()).thenReturn(new Rect());
+        when(mFailureImage.getPaint()).thenReturn(new Paint());
+        when(mRetryImage.getBounds()).thenReturn(new Rect());
+        when(mRetryImage.getPaint()).thenReturn(new Paint());
+        when(mProgressBarImage.getBounds()).thenReturn(new Rect());
+        when(mProgressBarImage.getPaint()).thenReturn(new Paint());
+        when(mActualImage1.getBounds()).thenReturn(new Rect());
+        when(mActualImage1.getPaint()).thenReturn(new Paint());
+        when(mActualImage2.getBounds()).thenReturn(new Rect());
+        when(mActualImage2.getPaint()).thenReturn(new Paint());
+
+        mBuilder = new GenericDraweeHierarchyBuilder(null);
+    }
+
+    @Test
+    public void testHierarchy_WithScaleType() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, ScaleType.CENTER)
+                .setRetryImage(mRetryImage, ScaleType.FIT_CENTER)
+                .setFailureImage(mFailureImage, ScaleType.CENTER_INSIDE)
+                .setProgressBarImage(mProgressBarImage, ScaleType.CENTER_CROP)
+                .setActualImageScaleType(ScaleType.FOCUS_CROP)
+                .setActualImageFocusPoint(mFocusPoint)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(0).getClass());
+        ScaleTypeDrawable placeholderBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(0);
+        assertEquals(ScaleType.CENTER, placeholderBranch.getScaleType());
+        assertEquals(mPlaceholderImage, placeholderBranch.getCurrent());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
+        assertEquals(ScaleType.FOCUS_CROP, actualImageBranch.getScaleType());
+        assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
+        AndroidGraphicsTestUtils.assertEquals(mFocusPoint, actualImageBranch.getFocusPoint(), 0f);
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
+        ScaleTypeDrawable progressBarImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(2);
+        assertEquals(ScaleType.CENTER_CROP, progressBarImageBranch.getScaleType());
+        assertEquals(mProgressBarImage, progressBarImageBranch.getCurrent());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(3).getClass());
+        ScaleTypeDrawable retryImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(3);
+        assertEquals(ScaleType.FIT_CENTER, retryImageBranch.getScaleType());
+        assertEquals(mRetryImage, retryImageBranch.getCurrent());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(4).getClass());
+        ScaleTypeDrawable failureImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(4);
+        assertEquals(ScaleType.CENTER_INSIDE, failureImageBranch.getScaleType());
+        assertEquals(mFailureImage, failureImageBranch.getCurrent());
+    }
+
+    @Test
+    public void testHierarchy_WithMatrix() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setRetryImage(mRetryImage, null)
+                .setFailureImage(mFailureImage, null)
+                .setProgressBarImage(mProgressBarImage, null)
+                .setActualImageMatrix(mActualImageMatrix)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(0));
+
+        assertEquals(MatrixDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        MatrixDrawable actualImageBranch = (MatrixDrawable) fadeDrawable.getDrawable(1);
+        assertEquals(mActualImageMatrix, actualImageBranch.getMatrix());
+        assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
+
+        assertEquals(mProgressBarImage, fadeDrawable.getDrawable(2));
+
+        assertEquals(mRetryImage, fadeDrawable.getDrawable(3));
+
+        assertEquals(mFailureImage, fadeDrawable.getDrawable(4));
+    }
+
+    @Test
+    public void testHierarchy_NoScaleTypeNorMatrix() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setRetryImage(mRetryImage, null)
+                .setFailureImage(mFailureImage, null)
+                .setProgressBarImage(mProgressBarImage, null)
+                .setActualImageScaleType(null)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(0));
+        assertEquals(SettableDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        assertEquals(mProgressBarImage, fadeDrawable.getDrawable(2));
+        assertEquals(mRetryImage, fadeDrawable.getDrawable(3));
+        assertEquals(mFailureImage, fadeDrawable.getDrawable(4));
+    }
+
+    @Test
+    public void testHierarchy_NoPlaceholderImage() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        // transparent color drawable will be used as placeholder
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(0).getClass());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
+        assertEquals(ScaleType.CENTER_CROP, actualImageBranch.getScaleType());
+        assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
+    }
+
+    @Test
+    public void testHierarchy_WithPlaceholderImage() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, ScaleType.CENTER)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(0).getClass());
+        ScaleTypeDrawable placeholderBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(0);
+        assertEquals(ScaleType.CENTER, placeholderBranch.getScaleType());
+        assertEquals(mPlaceholderImage, placeholderBranch.getCurrent());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
+        assertEquals(ScaleType.CENTER_CROP, actualImageBranch.getScaleType());
+        assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
+    }
+
+    @Test
+    public void testHierarchy_WithFailureImage() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setFailureImage(mFailureImage, ScaleType.CENTER)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        // transparent color drawable is used as placeholder when not specified otherwise
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(0).getClass());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
+        assertEquals(ScaleType.CENTER_CROP, actualImageBranch.getScaleType());
+        assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
+        ScaleTypeDrawable failureImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(2);
+        assertEquals(ScaleType.CENTER, failureImageBranch.getScaleType());
+        assertEquals(mFailureImage, failureImageBranch.getCurrent());
+    }
+
+    @Test
+    public void testHierarchy_WithRetryImage() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setRetryImage(mRetryImage, ScaleType.CENTER)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        // transparent color drawable is used as placeholder when not specified otherwise
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(0).getClass());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
+        assertEquals(ScaleType.CENTER_CROP, actualImageBranch.getScaleType());
+        assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
+        ScaleTypeDrawable retryImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(2);
+        assertEquals(ScaleType.CENTER, retryImageBranch.getScaleType());
+        assertEquals(mRetryImage, retryImageBranch.getCurrent());
+    }
+
+    @Test
+    public void testHierarchy_WithProgressBarImage() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setProgressBarImage(mProgressBarImage, ScaleType.CENTER)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        // transparent color drawable is used as placeholder when not specified otherwise
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(0).getClass());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        ScaleTypeDrawable actualImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
+        assertEquals(ScaleType.CENTER_CROP, actualImageBranch.getScaleType());
+        assertEquals(SettableDrawable.class, actualImageBranch.getCurrent().getClass());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
+        ScaleTypeDrawable progressBarImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(2);
+        assertEquals(ScaleType.CENTER, progressBarImageBranch.getScaleType());
+        assertEquals(mProgressBarImage, progressBarImageBranch.getCurrent());
+    }
+
+    @Test
+    public void testHierarchy_WithAllBranches() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, ScaleType.CENTER)
+                .setRetryImage(mRetryImage, ScaleType.FIT_CENTER)
+                .setFailureImage(mFailureImage, ScaleType.FIT_CENTER)
+                .setProgressBarImage(mProgressBarImage, ScaleType.CENTER)
+                .setActualImageScaleType(ScaleType.CENTER_CROP)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(6, fadeDrawable.getNumberOfLayers());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(0).getClass());
+        ScaleTypeDrawable placeholderBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(0);
+        assertEquals(ScaleType.CENTER, placeholderBranch.getScaleType());
+        assertEquals(mPlaceholderImage, placeholderBranch.getCurrent());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        ScaleTypeDrawable imageBranch1 = (ScaleTypeDrawable) fadeDrawable.getDrawable(1);
+        assertEquals(ScaleType.CENTER_CROP, imageBranch1.getScaleType());
+        assertEquals(SettableDrawable.class, imageBranch1.getCurrent().getClass());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
+        ScaleTypeDrawable progressBarImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(2);
+        assertEquals(ScaleType.CENTER, progressBarImageBranch.getScaleType());
+        assertEquals(mProgressBarImage, progressBarImageBranch.getCurrent());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(3).getClass());
+        ScaleTypeDrawable retryImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(3);
+        assertEquals(ScaleType.FIT_CENTER, retryImageBranch.getScaleType());
+        assertEquals(mRetryImage, retryImageBranch.getCurrent());
+
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(4).getClass());
+        ScaleTypeDrawable failureImageBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(4);
+        assertEquals(ScaleType.FIT_CENTER, failureImageBranch.getScaleType());
+        assertEquals(mFailureImage, failureImageBranch.getCurrent());
+
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(5).getClass()); // controller overlay
+    }
+
+    @Test
+    public void testHierarchy_WithBackgrounds() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setBackgrounds(Lists.newArrayList(mBackground1, mBackground2))
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(5, fadeDrawable.getNumberOfLayers());
+        assertEquals(mBackground1, fadeDrawable.getDrawable(0));
+        assertEquals(mBackground2, fadeDrawable.getDrawable(1));
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(2));
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(3).getClass());
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(4).getClass()); // controller overlay
+    }
+
+    @Test
+    public void testHierarchy_WithSingleBackground() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setBackground(mBackground1)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(4, fadeDrawable.getNumberOfLayers());
+        assertEquals(mBackground1, fadeDrawable.getDrawable(0));
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(1));
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(3).getClass()); // controller overlay
+    }
+
+    @Test
+    public void testHierarchy_WithOverlays() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setOverlays(Lists.newArrayList(mOverlay1, mOverlay2))
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(5, fadeDrawable.getNumberOfLayers());
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(0));
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        assertEquals(mOverlay1, fadeDrawable.getDrawable(2));
+        assertEquals(mOverlay2, fadeDrawable.getDrawable(3));
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(4).getClass()); // controller overlay
+    }
+
+    @Test
+    public void testHierarchy_WithSingleOverlay() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setOverlay(mOverlay1)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(4, fadeDrawable.getNumberOfLayers());
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(0));
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(1).getClass());
+        assertEquals(mOverlay1, fadeDrawable.getDrawable(2));
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(3).getClass()); // controller overlay
+    }
+
+    @Test
+    public void testHierarchy_WithBackgroundsAndOverlays() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setBackgrounds(Lists.newArrayList(mBackground1, mBackground2))
+                .setOverlays(Lists.newArrayList(mOverlay1, mOverlay2))
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(7, fadeDrawable.getNumberOfLayers());
+        assertEquals(mBackground1, fadeDrawable.getDrawable(0));
+        assertEquals(mBackground2, fadeDrawable.getDrawable(1));
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(2));
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(3).getClass());
+        assertEquals(mOverlay1, fadeDrawable.getDrawable(4));
+        assertEquals(mOverlay2, fadeDrawable.getDrawable(5));
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(6).getClass()); // controller overlay
+    }
+
+    @Test
+    public void testHierarchy_WithSingleBackgroundAndOverlay() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setBackground(mBackground2)
+                .setOverlay(mOverlay2)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(5, fadeDrawable.getNumberOfLayers());
+        assertEquals(mBackground2, fadeDrawable.getDrawable(0));
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(1));
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
+        assertEquals(mOverlay2, fadeDrawable.getDrawable(3));
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(4).getClass()); // controller overlay
+    }
+
+    @Test
+    public void testHierarchy_WithPressedStateOverlaySetFirst() throws Exception {
+        //Setting PressedStateOverlay before Overlays and Backgroud
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setPressedStateOverlay(mOverlay1)
+                .setBackground(mBackground2)
+                .setOverlay(mOverlay2)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(6, fadeDrawable.getNumberOfLayers());
+        assertEquals(mBackground2, fadeDrawable.getDrawable(0));
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(1));
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
+        assertEquals(mOverlay2, fadeDrawable.getDrawable(3));
+        assertEquals(StateListDrawable.class, fadeDrawable.getDrawable(4).getClass());
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(5).getClass()); // controller overlay
+    }
+
+    @Test
+    public void testHierarchy_WithPressedStateOverlaySetLast() throws Exception {
+        //Setting PressedStateOverlay after Overlays and Backgroud
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setBackground(mBackground2)
+                .setOverlay(mOverlay2)
+                .setPressedStateOverlay(mOverlay1)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertAssignableFrom(FadeDrawable.class, dh.getTopLevelDrawable().getClass());
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(6, fadeDrawable.getNumberOfLayers());
+        assertEquals(mBackground2, fadeDrawable.getDrawable(0));
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(1));
+        assertEquals(ScaleTypeDrawable.class, fadeDrawable.getDrawable(2).getClass());
+        assertEquals(mOverlay2, fadeDrawable.getDrawable(3));
+        assertEquals(StateListDrawable.class, fadeDrawable.getDrawable(4).getClass());
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(5).getClass()); // controller overlay
+    }
+
+    @Test
+    public void testHierarchy_WithRoundedCornersDrawable() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setActualImageScaleType(null)
+                .setRoundingParams(RoundingParams.fromCornersRadius(10).setOverlayColor(0xFFFFFFFF))
+                .setFadeDuration(250)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertEquals(RoundedCornersDrawable.class, dh.getTopLevelDrawable().getClass());
+    }
+
+    @Test
+    public void testHierarchy_WithRoundedCornersDrawableAsCircle() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setActualImageScaleType(null)
+                .setRoundingParams(RoundingParams.asCircle().setOverlayColor(0xFFFFFFFF))
+                .setFadeDuration(100)
+                .build();
+
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicWidth());
+        assertEquals(-1, dh.getTopLevelDrawable().getIntrinsicHeight());
+
+        assertEquals(RoundedCornersDrawable.class, dh.getTopLevelDrawable().getClass());
+    }
+
+    @Test
+    public void testControlling_WithPlaceholderOnly() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setActualImageScaleType(null)
+                .setFadeDuration(250)
+                .build();
+
+        // image indexes in DH tree
+        final int placeholderImageIndex = 0;
+        final int actualImageIndex = 1;
+
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(placeholderImageIndex));
+        assertEquals(
+                SettableDrawable.class,
+                fadeDrawable.getDrawable(actualImageIndex).getClass());
+
+        SettableDrawable actualImageSettableDrawable =
+                (SettableDrawable) fadeDrawable.getDrawable(actualImageIndex);
+
+        // initial state -> final image (non-immediate)
+        // initial state
+        assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set final image (non-immediate)
+        dh.setImage(mActualImage1, 1f, false);
+        assertEquals(mActualImage1, actualImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
+        assertEquals(250, fadeDrawable.getTransitionDuration());
+
+        // initial state -> final image (immediate)
+        // reset hierarchy to initial state
+        dh.reset();
+        assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set final image (immediate)
+        dh.setImage(mActualImage2, 1f, true);
+        assertEquals(mActualImage2, actualImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+
+        // initial state -> retry
+        // reset hierarchy to initial state
+        dh.reset();
+        assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set retry
+        dh.setRetry(new RuntimeException());
+        assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
+        assertEquals(250, fadeDrawable.getTransitionDuration());
+
+        // initial state -> failure
+        // reset hierarchy to initial state
+        dh.reset();
+        assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set failure
+        dh.setFailure(new RuntimeException());
+        assertEquals(ColorDrawable.class, actualImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
+        assertEquals(250, fadeDrawable.getTransitionDuration());
+    }
+
+    @Test
+    public void testControlling_WithAllLayers() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setBackgrounds(Lists.newArrayList(mBackground1, mBackground2))
+                .setOverlays(Lists.newArrayList(mOverlay1, mOverlay2))
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setRetryImage(mRetryImage, null)
+                .setFailureImage(mFailureImage, null)
+                .setProgressBarImage(mProgressBarImage, null)
+                .setActualImageScaleType(null)
+                .setFadeDuration(250)
+                .build();
+
+        // image indexes in DH tree
+        final int backgroundsIndex = 0;
+        final int numBackgrounds = 2;
+        final int placeholderImageIndex = numBackgrounds + 0;
+        final int actualImageIndex = numBackgrounds + 1;
+        final int progressBarImageIndex = numBackgrounds + 2;
+        final int retryImageIndex = numBackgrounds + 3;
+        final int failureImageIndex = numBackgrounds + 4;
+        final int numBranches = 5;
+        final int overlaysIndex = numBackgrounds + numBranches;
+        final int numOverlays = 2;
+
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(placeholderImageIndex));
+        assertEquals(mProgressBarImage, fadeDrawable.getDrawable(progressBarImageIndex));
+        assertEquals(mRetryImage, fadeDrawable.getDrawable(retryImageIndex));
+        assertEquals(mFailureImage, fadeDrawable.getDrawable(failureImageIndex));
+        assertEquals(
+                SettableDrawable.class,
+                fadeDrawable.getDrawable(actualImageIndex).getClass());
+
+        SettableDrawable finalImageSettableDrawable =
+                (SettableDrawable) fadeDrawable.getDrawable(actualImageIndex);
+
+        // initial state -> final image (immediate)
+        // initial state, show progress bar
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        dh.setProgress(0f, true);
+        assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set final image (immediate)
+        dh.setImage(mActualImage2, 1f, true);
+        assertEquals(mActualImage2, finalImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+
+        // initial state -> final image (non-immediate)
+        // reset hierarchy to initial state, show progress bar
+        dh.reset();
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        dh.setProgress(0f, true);
+        assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set final image (non-immediate)
+        dh.setImage(mActualImage2, 1f, false);
+        assertEquals(mActualImage2, finalImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
+        assertEquals(250, fadeDrawable.getTransitionDuration());
+
+        // initial state -> temporary image (immediate) -> final image (non-immediate)
+        // reset hierarchy to initial state, show progress bar
+        dh.reset();
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        dh.setProgress(0f, true);
+        assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set temporary image (immediate)
+        dh.setImage(mActualImage1, 0.5f, true);
+        assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set final image (non-immediate)
+        dh.setImage(mActualImage2, 1f, false);
+        assertEquals(mActualImage2, finalImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
+        assertEquals(250, fadeDrawable.getTransitionDuration());
+
+        // initial state -> temporary image (non-immediate) -> final image (non-immediate)
+        // reset hierarchy to initial state, show progress bar
+        dh.reset();
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        dh.setProgress(0f, true);
+        assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set temporary image (non-immediate)
+        dh.setImage(mActualImage1, 0.5f, false);
+        assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
+        assertEquals(250, fadeDrawable.getTransitionDuration());
+        // set final image (non-immediate)
+        dh.setImage(mActualImage2, 1f, false);
+        assertEquals(mActualImage2, finalImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
+        assertEquals(250, fadeDrawable.getTransitionDuration());
+
+        // initial state -> temporary image (immediate) -> retry
+        // reset hierarchy to initial state, show progress bar
+        dh.reset();
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        dh.setProgress(0f, true);
+        assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set temporary image (immediate)
+        dh.setImage(mActualImage1, 0.5f, true);
+        assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set retry
+        dh.setRetry(new RuntimeException());
+        assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
+        assertEquals(250, fadeDrawable.getTransitionDuration());
+
+        // initial state -> temporary image (immediate) -> failure
+        // reset hierarchy to initial state, show progress bar
+        dh.reset();
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        dh.setProgress(0f, true);
+        assertEquals(ColorDrawable.class, finalImageSettableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set temporary image (immediate)
+        dh.setImage(mActualImage1, 0.5f, true);
+        assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+        // set failure
+        dh.setFailure(new RuntimeException());
+        assertEquals(mActualImage1, finalImageSettableDrawable.getCurrent());
+        assertEquals(false, fadeDrawable.isLayerOn(placeholderImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(actualImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(progressBarImageIndex));
+        assertEquals(false, fadeDrawable.isLayerOn(retryImageIndex));
+        assertEquals(true, fadeDrawable.isLayerOn(failureImageIndex));
+        assertLayersOn(fadeDrawable, backgroundsIndex, numBackgrounds);
+        assertLayersOn(fadeDrawable, overlaysIndex, numOverlays);
+        assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
+        assertEquals(250, fadeDrawable.getTransitionDuration());
+    }
+
+    @Test
+    public void testControlling_WithCornerRadii() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setActualImageScaleType(null)
+                .setRoundingParams(RoundingParams.fromCornersRadius(10))
+                .setFadeDuration(250)
+                .build();
+
+        // image indexes in DH tree
+        final int imageIndex = 1;
+
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+        SettableDrawable settableDrawable = (SettableDrawable) fadeDrawable.getDrawable(imageIndex);
+
+        // set temporary image
+        dh.setImage(mActualImage1, 0.5f, true);
+        assertNotSame(mActualImage1, settableDrawable.getCurrent());
+        assertEquals(RoundedBitmapDrawable.class, settableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(imageIndex));
+        assertEquals(FadeDrawable.TRANSITION_NONE, fadeDrawable.getTransitionState());
+
+        // set final image
+        dh.setImage(mActualImage2, 1f, false);
+        assertNotSame(mActualImage2, settableDrawable.getCurrent());
+        assertEquals(RoundedBitmapDrawable.class, settableDrawable.getCurrent().getClass());
+        assertEquals(true, fadeDrawable.isLayerOn(imageIndex));
+        assertEquals(FadeDrawable.TRANSITION_STARTING, fadeDrawable.getTransitionState());
+        assertEquals(250, fadeDrawable.getTransitionDuration());
+    }
+
+    @Test
+    public void testControlling_WithControllerOverlay() {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, null)
+                .setActualImageScaleType(null)
+                .setFadeDuration(250)
+                .build();
+
+        Drawable controllerOverlay = DrawableTestUtils.mockDrawable();
+
+        // image indexes in DH tree
+        final int placeholderImageIndex = 0;
+        final int actualImageIndex = 1;
+        final int controllerOverlayIndex = 2;
+
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+
+        // initial state
+        assertEquals(mPlaceholderImage, fadeDrawable.getDrawable(placeholderImageIndex));
+        assertEquals(SettableDrawable.class, fadeDrawable.getDrawable(actualImageIndex).getClass());
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(controllerOverlayIndex).getClass());
+
+        // set controller overlay
+        dh.setControllerOverlay(controllerOverlay);
+        assertEquals(controllerOverlay, fadeDrawable.getDrawable(controllerOverlayIndex));
+
+        // clear controller overlay
+        dh.setControllerOverlay(null);
+        assertEquals(ColorDrawable.class, fadeDrawable.getDrawable(controllerOverlayIndex).getClass());
+    }
+
+    private void assertLayersOn(FadeDrawable fadeDrawable, int firstLayerIndex, int numberOfLayers) {
+        for (int i = 0; i < numberOfLayers; i++) {
+            assertEquals(true, fadeDrawable.isLayerOn(firstLayerIndex + i));
+        }
+    }
+
+    @Test
+    @TargetApi(11)
+    public void testSetPlaceholderImage() throws Exception {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage, ScaleType.FIT_XY)
+                .build();
+
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+        ScaleTypeDrawable placeholderBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(0);
+        assertEquals(mPlaceholderImage, placeholderBranch.getCurrent());
+
+        dh.setPlaceholderImage(null);
+        assertTrue(placeholderBranch.getCurrent() instanceof ColorDrawable);
+        assertEquals(Color.TRANSPARENT, ((ColorDrawable) placeholderBranch.getCurrent()).getColor());
+
+        Drawable newPlaceholder = mock(Drawable.class);
+        dh.setPlaceholderImage(newPlaceholder);
+        assertSame(placeholderBranch, fadeDrawable.getDrawable(0));
+        assertSame(newPlaceholder, placeholderBranch.getCurrent());
+        assertEquals(ScaleType.FIT_XY, placeholderBranch.getScaleType());
+    }
+
+    @Test
+    public void testSetActualImageFocusPoint() {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage)
+                .setProgressBarImage(mProgressBarImage)
+                .setActualImageScaleType(ScaleType.FOCUS_CROP)
+                .build();
+
+        // image indexes in DH tree
+        final int imageIndex = 1;
+
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+        ScaleTypeDrawable scaleTypeDrawable = (ScaleTypeDrawable) fadeDrawable.getDrawable(imageIndex);
+        assertNull(scaleTypeDrawable.getFocusPoint());
+
+        PointF focus1 = new PointF(0.3f, 0.4f);
+        dh.setActualImageFocusPoint(focus1);
+        AndroidGraphicsTestUtils.assertEquals(focus1, scaleTypeDrawable.getFocusPoint(), 0f);
+
+        PointF focus2 = new PointF(0.6f, 0.7f);
+        dh.setActualImageFocusPoint(focus2);
+        AndroidGraphicsTestUtils.assertEquals(focus2, scaleTypeDrawable.getFocusPoint(), 0f);
+    }
+
+    @Test
+    public void testSetActualImageScaleType() {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage)
+                .build();
+
+        // image indexes in DH tree
+        final int imageIndex = 1;
+
+        FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
+        ScaleTypeDrawable scaleTypeDrawable = (ScaleTypeDrawable) fadeDrawable.getDrawable(imageIndex);
+
+        ScaleType scaleType1 = ScaleType.FOCUS_CROP;
+        dh.setActualImageScaleType(scaleType1);
+        assertEquals(scaleType1, scaleTypeDrawable.getScaleType());
+
+        ScaleType scaleType2 = ScaleType.CENTER;
+        dh.setActualImageScaleType(scaleType2);
+        assertEquals(scaleType2, scaleTypeDrawable.getScaleType());
+    }
+
+    @Test
+    public void testSetRoundingParams_OverlayColor() {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage)
+                .setRoundingParams(RoundingParams.asCircle().setOverlayColor(0xC0123456))
+                .build();
+
+        assertEquals(RoundedCornersDrawable.class, dh.getTopLevelDrawable().getClass());
+
+        assertTrue(dh.getRoundingParams().getRoundAsCircle());
+        assertEquals(
+                RoundingParams.RoundingMethod.OVERLAY_COLOR,
+                dh.getRoundingParams().getRoundingMethod());
+        assertEquals(0xC0123456, dh.getRoundingParams().getOverlayColor());
+
+        dh.setRoundingParams(RoundingParams.fromCornersRadius(9).setOverlayColor(0xFFFFFFFF));
+
+        assertFalse(dh.getRoundingParams().getRoundAsCircle());
+        assertEquals(
+                RoundingParams.RoundingMethod.OVERLAY_COLOR,
+                dh.getRoundingParams().getRoundingMethod());
+        float[] expectedRadii = new float[]{9, 9, 9, 9, 9, 9, 9, 9};
+        assertArrayEquals(expectedRadii, dh.getRoundingParams().getCornersRadii(), 0);
+        assertEquals(0xFFFFFFFF, dh.getRoundingParams().getOverlayColor());
+    }
+
+    @Test
+    public void testSetRoundingParams_Border() {
+        int borderColor = Color.CYAN;
+        float borderWidth = 0.4f;
+
+        RoundingParams roundingParams = RoundingParams
+                .asCircle()
+                .setOverlayColor(Color.GRAY)
+                .setBorder(borderColor, borderWidth);
+
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage)
+                .setRoundingParams(roundingParams)
+                .build();
+
+        assertEquals(RoundedCornersDrawable.class, dh.getTopLevelDrawable().getClass());
+
+        assertTrue(dh.getRoundingParams().getRoundAsCircle());
+        assertEquals(borderColor, dh.getRoundingParams().getBorderColor());
+        assertEquals(borderWidth, dh.getRoundingParams().getBorderWidth(), 0);
+        assertEquals(Color.GRAY, dh.getRoundingParams().getOverlayColor());
+
+        int borderColor2 = Color.RED;
+        float borderWidth2 = 0.3f;
+        roundingParams = RoundingParams
+                .fromCornersRadius(9)
+                .setOverlayColor(Color.RED)
+                .setBorder(borderColor2, borderWidth2);
+
+        dh.setRoundingParams(roundingParams);
+
+        assertFalse(dh.getRoundingParams().getRoundAsCircle());
+
+        float[] expectedRadii = new float[]{9, 9, 9, 9, 9, 9, 9, 9};
+        assertArrayEquals(expectedRadii, dh.getRoundingParams().getCornersRadii(), 0);
+        assertEquals(borderColor2, dh.getRoundingParams().getBorderColor());
+        assertEquals(borderWidth2, dh.getRoundingParams().getBorderWidth(), 0);
+        assertEquals(Color.RED, dh.getRoundingParams().getOverlayColor());
+    }
+
+    @Test
+    public void testSetRoundingParams_BitmapOnly() {
+        GenericDraweeHierarchy dh = mBuilder
+                .setPlaceholderImage(mPlaceholderImage)
+                .setRoundingParams(RoundingParams.asCircle())
+                .build();
+
+        assertTrue(dh.getRoundingParams().getRoundAsCircle());
+        assertEquals(
+                RoundingParams.RoundingMethod.BITMAP_ONLY,
+                dh.getRoundingParams().getRoundingMethod());
+
+        dh.setRoundingParams(RoundingParams.fromCornersRadius(9));
+
+        assertFalse(dh.getRoundingParams().getRoundAsCircle());
+        assertEquals(
+                RoundingParams.RoundingMethod.BITMAP_ONLY,
+                dh.getRoundingParams().getRoundingMethod());
+        float[] expectedRadii = new float[]{9, 9, 9, 9, 9, 9, 9, 9};
+        assertArrayEquals(expectedRadii, dh.getRoundingParams().getCornersRadii(), 0);
+    }
+
+    private <T, F> void assertAssignableFrom(Class<T> to, Class<F> from) {
+        assertTrue(to + " is not assignable from " + from, to.isAssignableFrom(from));
     }
-  }
-
-  @Test
-  @TargetApi(11)
-  public void testSetPlaceholderImage() throws Exception {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage, ScaleType.FIT_XY)
-        .build();
-
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-    ScaleTypeDrawable placeholderBranch = (ScaleTypeDrawable) fadeDrawable.getDrawable(0);
-    assertEquals(mPlaceholderImage, placeholderBranch.getCurrent());
-
-    dh.setPlaceholderImage(null);
-    assertTrue(placeholderBranch.getCurrent() instanceof ColorDrawable);
-    assertEquals(Color.TRANSPARENT, ((ColorDrawable) placeholderBranch.getCurrent()).getColor());
-
-    Drawable newPlaceholder = mock(Drawable.class);
-    dh.setPlaceholderImage(newPlaceholder);
-    assertSame(placeholderBranch, fadeDrawable.getDrawable(0));
-    assertSame(newPlaceholder, placeholderBranch.getCurrent());
-    assertEquals(ScaleType.FIT_XY, placeholderBranch.getScaleType());
-  }
-
-  @Test
-  public void testSetActualImageFocusPoint() {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage)
-        .setProgressBarImage(mProgressBarImage)
-        .setActualImageScaleType(ScaleType.FOCUS_CROP)
-        .build();
-
-    // image indexes in DH tree
-    final int imageIndex = 1;
-
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-    ScaleTypeDrawable scaleTypeDrawable = (ScaleTypeDrawable) fadeDrawable.getDrawable(imageIndex);
-    assertNull(scaleTypeDrawable.getFocusPoint());
-
-    PointF focus1 = new PointF(0.3f, 0.4f);
-    dh.setActualImageFocusPoint(focus1);
-    AndroidGraphicsTestUtils.assertEquals(focus1, scaleTypeDrawable.getFocusPoint(), 0f);
-
-    PointF focus2 = new PointF(0.6f, 0.7f);
-    dh.setActualImageFocusPoint(focus2);
-    AndroidGraphicsTestUtils.assertEquals(focus2, scaleTypeDrawable.getFocusPoint(), 0f);
-  }
-
-  @Test
-  public void testSetActualImageScaleType() {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage)
-        .build();
-
-    // image indexes in DH tree
-    final int imageIndex = 1;
-
-    FadeDrawable fadeDrawable = (FadeDrawable) dh.getTopLevelDrawable();
-    ScaleTypeDrawable scaleTypeDrawable = (ScaleTypeDrawable) fadeDrawable.getDrawable(imageIndex);
-
-    ScaleType scaleType1 = ScaleType.FOCUS_CROP;
-    dh.setActualImageScaleType(scaleType1);
-    assertEquals(scaleType1, scaleTypeDrawable.getScaleType());
-
-    ScaleType scaleType2 = ScaleType.CENTER;
-    dh.setActualImageScaleType(scaleType2);
-    assertEquals(scaleType2, scaleTypeDrawable.getScaleType());
-  }
-
-  @Test
-  public void testSetRoundingParams_OverlayColor() {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage)
-        .setRoundingParams(RoundingParams.asCircle().setOverlayColor(0xC0123456))
-        .build();
-
-    assertEquals(RoundedCornersDrawable.class, dh.getTopLevelDrawable().getClass());
-
-    assertTrue(dh.getRoundingParams().getRoundAsCircle());
-    assertEquals(
-        RoundingParams.RoundingMethod.OVERLAY_COLOR,
-        dh.getRoundingParams().getRoundingMethod());
-    assertEquals(0xC0123456, dh.getRoundingParams().getOverlayColor());
-
-    dh.setRoundingParams(RoundingParams.fromCornersRadius(9).setOverlayColor(0xFFFFFFFF));
-
-    assertFalse(dh.getRoundingParams().getRoundAsCircle());
-    assertEquals(
-        RoundingParams.RoundingMethod.OVERLAY_COLOR,
-        dh.getRoundingParams().getRoundingMethod());
-    float[] expectedRadii = new float[] {9, 9, 9, 9, 9, 9, 9, 9};
-    assertArrayEquals(expectedRadii, dh.getRoundingParams().getCornersRadii(), 0);
-    assertEquals(0xFFFFFFFF, dh.getRoundingParams().getOverlayColor());
-  }
-
-  @Test
-  public void testSetRoundingParams_Border() {
-    int borderColor = Color.CYAN;
-    float borderWidth = 0.4f;
-
-    RoundingParams roundingParams = RoundingParams
-        .asCircle()
-        .setOverlayColor(Color.GRAY)
-        .setBorder(borderColor, borderWidth);
-
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage)
-        .setRoundingParams(roundingParams)
-        .build();
-
-    assertEquals(RoundedCornersDrawable.class, dh.getTopLevelDrawable().getClass());
-
-    assertTrue(dh.getRoundingParams().getRoundAsCircle());
-    assertEquals(borderColor, dh.getRoundingParams().getBorderColor());
-    assertEquals(borderWidth, dh.getRoundingParams().getBorderWidth(), 0);
-    assertEquals(Color.GRAY, dh.getRoundingParams().getOverlayColor());
-
-    int borderColor2 = Color.RED;
-    float borderWidth2 = 0.3f;
-    roundingParams = RoundingParams
-        .fromCornersRadius(9)
-        .setOverlayColor(Color.RED)
-        .setBorder(borderColor2, borderWidth2);
-
-    dh.setRoundingParams(roundingParams);
-
-    assertFalse(dh.getRoundingParams().getRoundAsCircle());
-
-    float[] expectedRadii = new float[] {9, 9, 9, 9, 9, 9, 9, 9};
-    assertArrayEquals(expectedRadii, dh.getRoundingParams().getCornersRadii(), 0);
-    assertEquals(borderColor2, dh.getRoundingParams().getBorderColor());
-    assertEquals(borderWidth2, dh.getRoundingParams().getBorderWidth(), 0);
-    assertEquals(Color.RED, dh.getRoundingParams().getOverlayColor());
-  }
-
-  @Test
-  public void testSetRoundingParams_BitmapOnly() {
-    GenericDraweeHierarchy dh = mBuilder
-        .setPlaceholderImage(mPlaceholderImage)
-        .setRoundingParams(RoundingParams.asCircle())
-        .build();
-
-    assertTrue(dh.getRoundingParams().getRoundAsCircle());
-    assertEquals(
-        RoundingParams.RoundingMethod.BITMAP_ONLY,
-        dh.getRoundingParams().getRoundingMethod());
-
-    dh.setRoundingParams(RoundingParams.fromCornersRadius(9));
-
-    assertFalse(dh.getRoundingParams().getRoundAsCircle());
-    assertEquals(
-        RoundingParams.RoundingMethod.BITMAP_ONLY,
-        dh.getRoundingParams().getRoundingMethod());
-    float[] expectedRadii = new float[] {9, 9, 9, 9, 9, 9, 9, 9};
-    assertArrayEquals(expectedRadii, dh.getRoundingParams().getCornersRadii(), 0);
-  }
-
-  private <T, F> void assertAssignableFrom(Class<T> to, Class<F> from) {
-    assertTrue(to + " is not assignable from " + from, to.isAssignableFrom(from));
-  }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/generic/RoundingParamsTest.java b/drawee/src/test/java/com/facebook/drawee/generic/RoundingParamsTest.java
index 61e7646a9..5a526b612 100644
--- a/drawee/src/test/java/com/facebook/drawee/generic/RoundingParamsTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/generic/RoundingParamsTest.java
@@ -22,81 +22,81 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class RoundingParamsTest {
 
-  private RoundingParams mRoundingParams;
-
-  @Before
-  public void setUp() {
-    mRoundingParams = new RoundingParams();
-  }
-
-  @Test
-  public void testDefaults() {
-    assertEquals(RoundingParams.RoundingMethod.BITMAP_ONLY, mRoundingParams.getRoundingMethod());
-    assertFalse(mRoundingParams.getRoundAsCircle());
-    assertNull(mRoundingParams.getCornersRadii());
-    assertEquals(0, mRoundingParams.getOverlayColor());
-  }
-
-  @Test
-  public void testSetCircle() {
-    assertSame(mRoundingParams, mRoundingParams.setRoundAsCircle(true));
-    assertTrue(mRoundingParams.getRoundAsCircle());
-    assertSame(mRoundingParams, mRoundingParams.setRoundAsCircle(false));
-    assertFalse(mRoundingParams.getRoundAsCircle());
-  }
-
-  @Test
-  public void testSetRadii() {
-    mRoundingParams.setCornersRadius(9);
-    assertArrayEquals(new float[]{9, 9, 9, 9, 9, 9, 9, 9}, mRoundingParams.getCornersRadii(), 0f);
-
-    mRoundingParams.setCornersRadii(8, 7, 2, 1);
-    assertArrayEquals(new float[]{8, 8, 7, 7, 2, 2, 1, 1}, mRoundingParams.getCornersRadii(), 0f);
-
-    mRoundingParams.setCornersRadii(new float[]{1, 2, 3, 4, 5, 6, 7, 8});
-    assertArrayEquals(new float[]{1, 2, 3, 4, 5, 6, 7, 8}, mRoundingParams.getCornersRadii(), 0f);
-  }
-
-  @Test
-  public void testSetRoundingMethod() {
-    mRoundingParams.setRoundingMethod(RoundingParams.RoundingMethod.OVERLAY_COLOR);
-    assertEquals(RoundingParams.RoundingMethod.OVERLAY_COLOR, mRoundingParams.getRoundingMethod());
-    mRoundingParams.setRoundingMethod(RoundingParams.RoundingMethod.BITMAP_ONLY);
-    assertEquals(RoundingParams.RoundingMethod.BITMAP_ONLY, mRoundingParams.getRoundingMethod());
-  }
-
-  @Test
-  public void testSetOverlayColor() {
-    mRoundingParams.setOverlayColor(0xC0123456);
-    assertEquals(0xC0123456, mRoundingParams.getOverlayColor());
-    assertEquals(RoundingParams.RoundingMethod.OVERLAY_COLOR, mRoundingParams.getRoundingMethod());
-  }
-
-  @Test
-  public void testSetBorder() {
-    int borderColor = Color.RED;
-    float borderWidth = 0.8f;
-
-    mRoundingParams.setBorder(borderColor, borderWidth);
-    assertEquals(borderColor, mRoundingParams.getBorderColor());
-    assertEquals(borderWidth, mRoundingParams.getBorderWidth(), 0);
-  }
-
-  @Test
-  public void testFactoryMethods() {
-    RoundingParams params1 = RoundingParams.asCircle();
-    assertTrue(params1.getRoundAsCircle());
-
-    RoundingParams params2 = RoundingParams.fromCornersRadius(9);
-    assertFalse(params2.getRoundAsCircle());
-    assertArrayEquals(new float[]{9, 9, 9, 9, 9, 9, 9, 9}, params2.getCornersRadii(), 0f);
-
-    RoundingParams params3 = RoundingParams.fromCornersRadii(8, 7, 2, 1);
-    assertFalse(params3.getRoundAsCircle());
-    assertArrayEquals(new float[]{8, 8, 7, 7, 2, 2, 1, 1}, params3.getCornersRadii(), 0f);
-
-    RoundingParams params4 = RoundingParams.fromCornersRadii(new float[]{1, 2, 3, 4, 5, 6, 7, 8});
-    assertFalse(params4.getRoundAsCircle());
-    assertArrayEquals(new float[]{1, 2, 3, 4, 5, 6, 7, 8}, params4.getCornersRadii(), 0f);
-  }
+    private RoundingParams mRoundingParams;
+
+    @Before
+    public void setUp() {
+        mRoundingParams = new RoundingParams();
+    }
+
+    @Test
+    public void testDefaults() {
+        assertEquals(RoundingParams.RoundingMethod.BITMAP_ONLY, mRoundingParams.getRoundingMethod());
+        assertFalse(mRoundingParams.getRoundAsCircle());
+        assertNull(mRoundingParams.getCornersRadii());
+        assertEquals(0, mRoundingParams.getOverlayColor());
+    }
+
+    @Test
+    public void testSetCircle() {
+        assertSame(mRoundingParams, mRoundingParams.setRoundAsCircle(true));
+        assertTrue(mRoundingParams.getRoundAsCircle());
+        assertSame(mRoundingParams, mRoundingParams.setRoundAsCircle(false));
+        assertFalse(mRoundingParams.getRoundAsCircle());
+    }
+
+    @Test
+    public void testSetRadii() {
+        mRoundingParams.setCornersRadius(9);
+        assertArrayEquals(new float[]{9, 9, 9, 9, 9, 9, 9, 9}, mRoundingParams.getCornersRadii(), 0f);
+
+        mRoundingParams.setCornersRadii(8, 7, 2, 1);
+        assertArrayEquals(new float[]{8, 8, 7, 7, 2, 2, 1, 1}, mRoundingParams.getCornersRadii(), 0f);
+
+        mRoundingParams.setCornersRadii(new float[]{1, 2, 3, 4, 5, 6, 7, 8});
+        assertArrayEquals(new float[]{1, 2, 3, 4, 5, 6, 7, 8}, mRoundingParams.getCornersRadii(), 0f);
+    }
+
+    @Test
+    public void testSetRoundingMethod() {
+        mRoundingParams.setRoundingMethod(RoundingParams.RoundingMethod.OVERLAY_COLOR);
+        assertEquals(RoundingParams.RoundingMethod.OVERLAY_COLOR, mRoundingParams.getRoundingMethod());
+        mRoundingParams.setRoundingMethod(RoundingParams.RoundingMethod.BITMAP_ONLY);
+        assertEquals(RoundingParams.RoundingMethod.BITMAP_ONLY, mRoundingParams.getRoundingMethod());
+    }
+
+    @Test
+    public void testSetOverlayColor() {
+        mRoundingParams.setOverlayColor(0xC0123456);
+        assertEquals(0xC0123456, mRoundingParams.getOverlayColor());
+        assertEquals(RoundingParams.RoundingMethod.OVERLAY_COLOR, mRoundingParams.getRoundingMethod());
+    }
+
+    @Test
+    public void testSetBorder() {
+        int borderColor = Color.RED;
+        float borderWidth = 0.8f;
+
+        mRoundingParams.setBorder(borderColor, borderWidth);
+        assertEquals(borderColor, mRoundingParams.getBorderColor());
+        assertEquals(borderWidth, mRoundingParams.getBorderWidth(), 0);
+    }
+
+    @Test
+    public void testFactoryMethods() {
+        RoundingParams params1 = RoundingParams.asCircle();
+        assertTrue(params1.getRoundAsCircle());
+
+        RoundingParams params2 = RoundingParams.fromCornersRadius(9);
+        assertFalse(params2.getRoundAsCircle());
+        assertArrayEquals(new float[]{9, 9, 9, 9, 9, 9, 9, 9}, params2.getCornersRadii(), 0f);
+
+        RoundingParams params3 = RoundingParams.fromCornersRadii(8, 7, 2, 1);
+        assertFalse(params3.getRoundAsCircle());
+        assertArrayEquals(new float[]{8, 8, 7, 7, 2, 2, 1, 1}, params3.getCornersRadii(), 0f);
+
+        RoundingParams params4 = RoundingParams.fromCornersRadii(new float[]{1, 2, 3, 4, 5, 6, 7, 8});
+        assertFalse(params4.getRoundAsCircle());
+        assertArrayEquals(new float[]{1, 2, 3, 4, 5, 6, 7, 8}, params4.getCornersRadii(), 0f);
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/gestures/GestureDetectorTest.java b/drawee/src/test/java/com/facebook/drawee/gestures/GestureDetectorTest.java
index e88a250f5..5685c004c 100644
--- a/drawee/src/test/java/com/facebook/drawee/gestures/GestureDetectorTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/gestures/GestureDetectorTest.java
@@ -28,197 +28,197 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class GestureDetectorTest {
 
-  private GestureDetector.ClickListener mClickListener;
-  private ViewConfiguration mViewConfiguration;
-  private long mScaledTouchSlop;
-  private long mLongPressTimeout;
-  private GestureDetector mGestureDetector;
-
-  @Before
-  public void setup() {
-    mClickListener = mock(GestureDetector.ClickListener.class);
-    mViewConfiguration = ViewConfiguration.get(Robolectric.application);
-    mScaledTouchSlop = mViewConfiguration.getScaledTouchSlop();
-    mLongPressTimeout = mViewConfiguration.getLongPressTimeout();
-    mGestureDetector = new GestureDetector(Robolectric.application);
-    mGestureDetector.setClickListener(mClickListener);
-  }
-
-  @Test
-  public void testInitialstate() {
-    assertEquals(mScaledTouchSlop, mGestureDetector.mSingleTapSlopPx, 0f);
-    assertEquals(false, mGestureDetector.mIsCapturingGesture);
-    assertEquals(false, mGestureDetector.mIsClickCandidate);
-  }
-
-  @Test
-  public void testSetClickListener() {
-    GestureDetector.ClickListener clickListener = mock(GestureDetector.ClickListener.class);
-    mGestureDetector.setClickListener(clickListener);
-    assertSame(clickListener, mGestureDetector.mClickListener);
-    mGestureDetector.setClickListener(null);
-    assertSame(null, mGestureDetector.mClickListener);
-  }
-
-  @Test
-  public void testOnClick_NoListener() {
-    MotionEvent event1 = obtain(1000, 1000, ACTION_DOWN, 100.f, 100.f, 0);
-    MotionEvent event2 = obtain(1000, 1001, ACTION_UP, 100.f, 100.f, 0);
-
-    mGestureDetector.setClickListener(mClickListener);
-    mGestureDetector.onTouchEvent(event1);
-    mGestureDetector.onTouchEvent(event2);
-    verify(mClickListener).onClick();
-
-    mGestureDetector.setClickListener(null);
-    mGestureDetector.onTouchEvent(event1);
-    mGestureDetector.onTouchEvent(event2);
-    verifyNoMoreInteractions(mClickListener);
-
-    event1.recycle();
-    event2.recycle();
-  }
-
-  @Test
-  public void testOnClick_Valid() {
-    float s = mScaledTouchSlop;
-    long T0 = 1000;
-    long T1 = T0;
-    MotionEvent event1 = obtain(T0, T1, ACTION_DOWN, 100.f, 100.f, 0);
-    mGestureDetector.onTouchEvent(event1);
-    assertEquals(true, mGestureDetector.mIsCapturingGesture);
-    assertEquals(true, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-
-    long T2 = T0 + mLongPressTimeout * 1 / 3;
-    MotionEvent event2 = obtain(T0, T2, ACTION_MOVE, 100.f + s * 0.3f, 100.f - s * 0.3f, 0);
-    mGestureDetector.onTouchEvent(event2);
-    assertEquals(true, mGestureDetector.mIsCapturingGesture);
-    assertEquals(true, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-
-    long T3 = T0 + mLongPressTimeout * 2 / 3;
-    MotionEvent event3 = obtain(T0, T3, ACTION_MOVE, 100.f + s * 0.6f, 100.f - s * 0.6f, 0);
-    mGestureDetector.onTouchEvent(event3);
-    assertEquals(true, mGestureDetector.mIsCapturingGesture);
-    assertEquals(true, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-
-    long T4 = T0 + mLongPressTimeout;
-    MotionEvent event4 = obtain(T0, T4, ACTION_UP, 100.f + s, 100.f - s, 0);
-    mGestureDetector.onTouchEvent(event4);
-    assertEquals(false, mGestureDetector.mIsCapturingGesture);
-    assertEquals(false, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-    verify(mClickListener).onClick();
-
-    event1.recycle();
-    event2.recycle();
-    event3.recycle();
-    event4.recycle();
-  }
-
-  @Test
-  public void testOnClick_ToFar() {
-    float s = mScaledTouchSlop;
-    long T0 = 1000;
-    long T1 = T0;
-    MotionEvent event1 = obtain(T0, T1, ACTION_DOWN, 100.f, 100.f, 0);
-    mGestureDetector.onTouchEvent(event1);
-    assertEquals(true, mGestureDetector.mIsCapturingGesture);
-    assertEquals(true, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-
-    long T2 = T0 + mLongPressTimeout * 1 / 3;
-    MotionEvent event2 = obtain(T0, T2, ACTION_MOVE, 100.f + s * 0.5f, 100.f - s * 0.5f, 0);
-    mGestureDetector.onTouchEvent(event2);
-    assertEquals(true, mGestureDetector.mIsCapturingGesture);
-    assertEquals(true, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-
-    // maximum allowed distance is `s` px, but here we went `s * 1.1` px away from down point
-    long T3 = T0 + mLongPressTimeout * 2 / 3;
-    MotionEvent event3 = obtain(T0, T3, ACTION_MOVE, 100.f + s * 1.1f, 100.f - s * 0.5f, 0);
-    mGestureDetector.onTouchEvent(event3);
-    assertEquals(true, mGestureDetector.mIsCapturingGesture);
-    assertEquals(false, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-
-    long T4 = T0 + mLongPressTimeout;
-    MotionEvent event4 = obtain(T0, T4, ACTION_UP, 100.f + s, 100.f - s, 0);
-    mGestureDetector.onTouchEvent(event4);
-    assertEquals(false, mGestureDetector.mIsCapturingGesture);
-    assertEquals(false, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-    verifyNoMoreInteractions(mClickListener);
-
-    event1.recycle();
-    event2.recycle();
-    event3.recycle();
-    event4.recycle();
-  }
-
-  @Test
-  public void testOnClick_ToLong() {
-    float s = mScaledTouchSlop;
-    long T0 = 1000;
-    long T1 = T0;
-    MotionEvent event1 = obtain(T0, T1, ACTION_DOWN, 100.f, 100.f, 0);
-    mGestureDetector.onTouchEvent(event1);
-    assertEquals(true, mGestureDetector.mIsCapturingGesture);
-    assertEquals(true, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-
-    long T2 = T0 + mLongPressTimeout * 1 / 3;
-    MotionEvent event2 = obtain(T0, T2, ACTION_MOVE, 100.f + s * 0.3f, 100.f - s * 0.3f, 0);
-    mGestureDetector.onTouchEvent(event2);
-    assertEquals(true, mGestureDetector.mIsCapturingGesture);
-    assertEquals(true, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-
-    long T3 = T0 + mLongPressTimeout * 2 / 3;
-    MotionEvent event3 = obtain(T0, T3, ACTION_MOVE, 100.f + s * 0.6f, 100.f - s * 0.6f, 0);
-    mGestureDetector.onTouchEvent(event3);
-    assertEquals(true, mGestureDetector.mIsCapturingGesture);
-    assertEquals(true, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-
-    // maximum allowed duration is mLongPressTimeout ms, but here we released 1 ms after that
-    long T4 = T0 + mLongPressTimeout + 1;
-    MotionEvent event4 = obtain(T0, T4, ACTION_UP, 100.f + s, 100.f - s, 0);
-    mGestureDetector.onTouchEvent(event4);
-    assertEquals(false, mGestureDetector.mIsCapturingGesture);
-    assertEquals(false, mGestureDetector.mIsClickCandidate);
-    assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
-    assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
-    assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
-    verifyNoMoreInteractions(mClickListener);
-
-    event1.recycle();
-    event2.recycle();
-    event3.recycle();
-    event4.recycle();
-  }
+    private GestureDetector.ClickListener mClickListener;
+    private ViewConfiguration mViewConfiguration;
+    private long mScaledTouchSlop;
+    private long mLongPressTimeout;
+    private GestureDetector mGestureDetector;
+
+    @Before
+    public void setup() {
+        mClickListener = mock(GestureDetector.ClickListener.class);
+        mViewConfiguration = ViewConfiguration.get(Robolectric.application);
+        mScaledTouchSlop = mViewConfiguration.getScaledTouchSlop();
+        mLongPressTimeout = mViewConfiguration.getLongPressTimeout();
+        mGestureDetector = new GestureDetector(Robolectric.application);
+        mGestureDetector.setClickListener(mClickListener);
+    }
+
+    @Test
+    public void testInitialstate() {
+        assertEquals(mScaledTouchSlop, mGestureDetector.mSingleTapSlopPx, 0f);
+        assertEquals(false, mGestureDetector.mIsCapturingGesture);
+        assertEquals(false, mGestureDetector.mIsClickCandidate);
+    }
+
+    @Test
+    public void testSetClickListener() {
+        GestureDetector.ClickListener clickListener = mock(GestureDetector.ClickListener.class);
+        mGestureDetector.setClickListener(clickListener);
+        assertSame(clickListener, mGestureDetector.mClickListener);
+        mGestureDetector.setClickListener(null);
+        assertSame(null, mGestureDetector.mClickListener);
+    }
+
+    @Test
+    public void testOnClick_NoListener() {
+        MotionEvent event1 = obtain(1000, 1000, ACTION_DOWN, 100.f, 100.f, 0);
+        MotionEvent event2 = obtain(1000, 1001, ACTION_UP, 100.f, 100.f, 0);
+
+        mGestureDetector.setClickListener(mClickListener);
+        mGestureDetector.onTouchEvent(event1);
+        mGestureDetector.onTouchEvent(event2);
+        verify(mClickListener).onClick();
+
+        mGestureDetector.setClickListener(null);
+        mGestureDetector.onTouchEvent(event1);
+        mGestureDetector.onTouchEvent(event2);
+        verifyNoMoreInteractions(mClickListener);
+
+        event1.recycle();
+        event2.recycle();
+    }
+
+    @Test
+    public void testOnClick_Valid() {
+        float s = mScaledTouchSlop;
+        long T0 = 1000;
+        long T1 = T0;
+        MotionEvent event1 = obtain(T0, T1, ACTION_DOWN, 100.f, 100.f, 0);
+        mGestureDetector.onTouchEvent(event1);
+        assertEquals(true, mGestureDetector.mIsCapturingGesture);
+        assertEquals(true, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+
+        long T2 = T0 + mLongPressTimeout * 1 / 3;
+        MotionEvent event2 = obtain(T0, T2, ACTION_MOVE, 100.f + s * 0.3f, 100.f - s * 0.3f, 0);
+        mGestureDetector.onTouchEvent(event2);
+        assertEquals(true, mGestureDetector.mIsCapturingGesture);
+        assertEquals(true, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+
+        long T3 = T0 + mLongPressTimeout * 2 / 3;
+        MotionEvent event3 = obtain(T0, T3, ACTION_MOVE, 100.f + s * 0.6f, 100.f - s * 0.6f, 0);
+        mGestureDetector.onTouchEvent(event3);
+        assertEquals(true, mGestureDetector.mIsCapturingGesture);
+        assertEquals(true, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+
+        long T4 = T0 + mLongPressTimeout;
+        MotionEvent event4 = obtain(T0, T4, ACTION_UP, 100.f + s, 100.f - s, 0);
+        mGestureDetector.onTouchEvent(event4);
+        assertEquals(false, mGestureDetector.mIsCapturingGesture);
+        assertEquals(false, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+        verify(mClickListener).onClick();
+
+        event1.recycle();
+        event2.recycle();
+        event3.recycle();
+        event4.recycle();
+    }
+
+    @Test
+    public void testOnClick_ToFar() {
+        float s = mScaledTouchSlop;
+        long T0 = 1000;
+        long T1 = T0;
+        MotionEvent event1 = obtain(T0, T1, ACTION_DOWN, 100.f, 100.f, 0);
+        mGestureDetector.onTouchEvent(event1);
+        assertEquals(true, mGestureDetector.mIsCapturingGesture);
+        assertEquals(true, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+
+        long T2 = T0 + mLongPressTimeout * 1 / 3;
+        MotionEvent event2 = obtain(T0, T2, ACTION_MOVE, 100.f + s * 0.5f, 100.f - s * 0.5f, 0);
+        mGestureDetector.onTouchEvent(event2);
+        assertEquals(true, mGestureDetector.mIsCapturingGesture);
+        assertEquals(true, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+
+        // maximum allowed distance is `s` px, but here we went `s * 1.1` px away from down point
+        long T3 = T0 + mLongPressTimeout * 2 / 3;
+        MotionEvent event3 = obtain(T0, T3, ACTION_MOVE, 100.f + s * 1.1f, 100.f - s * 0.5f, 0);
+        mGestureDetector.onTouchEvent(event3);
+        assertEquals(true, mGestureDetector.mIsCapturingGesture);
+        assertEquals(false, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+
+        long T4 = T0 + mLongPressTimeout;
+        MotionEvent event4 = obtain(T0, T4, ACTION_UP, 100.f + s, 100.f - s, 0);
+        mGestureDetector.onTouchEvent(event4);
+        assertEquals(false, mGestureDetector.mIsCapturingGesture);
+        assertEquals(false, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+        verifyNoMoreInteractions(mClickListener);
+
+        event1.recycle();
+        event2.recycle();
+        event3.recycle();
+        event4.recycle();
+    }
+
+    @Test
+    public void testOnClick_ToLong() {
+        float s = mScaledTouchSlop;
+        long T0 = 1000;
+        long T1 = T0;
+        MotionEvent event1 = obtain(T0, T1, ACTION_DOWN, 100.f, 100.f, 0);
+        mGestureDetector.onTouchEvent(event1);
+        assertEquals(true, mGestureDetector.mIsCapturingGesture);
+        assertEquals(true, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+
+        long T2 = T0 + mLongPressTimeout * 1 / 3;
+        MotionEvent event2 = obtain(T0, T2, ACTION_MOVE, 100.f + s * 0.3f, 100.f - s * 0.3f, 0);
+        mGestureDetector.onTouchEvent(event2);
+        assertEquals(true, mGestureDetector.mIsCapturingGesture);
+        assertEquals(true, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+
+        long T3 = T0 + mLongPressTimeout * 2 / 3;
+        MotionEvent event3 = obtain(T0, T3, ACTION_MOVE, 100.f + s * 0.6f, 100.f - s * 0.6f, 0);
+        mGestureDetector.onTouchEvent(event3);
+        assertEquals(true, mGestureDetector.mIsCapturingGesture);
+        assertEquals(true, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+
+        // maximum allowed duration is mLongPressTimeout ms, but here we released 1 ms after that
+        long T4 = T0 + mLongPressTimeout + 1;
+        MotionEvent event4 = obtain(T0, T4, ACTION_UP, 100.f + s, 100.f - s, 0);
+        mGestureDetector.onTouchEvent(event4);
+        assertEquals(false, mGestureDetector.mIsCapturingGesture);
+        assertEquals(false, mGestureDetector.mIsClickCandidate);
+        assertEquals(event1.getEventTime(), mGestureDetector.mActionDownTime);
+        assertEquals(event1.getX(), mGestureDetector.mActionDownX, 0f);
+        assertEquals(event1.getY(), mGestureDetector.mActionDownY, 0f);
+        verifyNoMoreInteractions(mClickListener);
+
+        event1.recycle();
+        event2.recycle();
+        event3.recycle();
+        event4.recycle();
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/gestures/MotionEventTestUtils.java b/drawee/src/test/java/com/facebook/drawee/gestures/MotionEventTestUtils.java
index b28be4040..e59b0b0be 100644
--- a/drawee/src/test/java/com/facebook/drawee/gestures/MotionEventTestUtils.java
+++ b/drawee/src/test/java/com/facebook/drawee/gestures/MotionEventTestUtils.java
@@ -11,41 +11,41 @@
 import android.view.MotionEvent;
 
 public class MotionEventTestUtils {
-  public static MotionEvent.PointerCoords createCoords(float x, float y) {
-    MotionEvent.PointerCoords pointerCoords = new MotionEvent.PointerCoords();
-    pointerCoords.x = x;
-    pointerCoords.y = y;
-    return pointerCoords;
-  }
+    public static MotionEvent.PointerCoords createCoords(float x, float y) {
+        MotionEvent.PointerCoords pointerCoords = new MotionEvent.PointerCoords();
+        pointerCoords.x = x;
+        pointerCoords.y = y;
+        return pointerCoords;
+    }
 
-  public static MotionEvent obtainMotionEvent(
-      long downTime,
-      long eventTime,
-      int action,
-      int id1,
-      float x1,
-      float y1) {
-    int[] ids = new int[] {id1};
-    MotionEvent.PointerCoords[] coords = new MotionEvent.PointerCoords[] {createCoords(x1, y1)};
-    return MotionEvent
-        .obtain(downTime, eventTime, action, 1, ids, coords, 0, 1.0f, 1.0f, 0, 0, 0, 0);
-  }
+    public static MotionEvent obtainMotionEvent(
+            long downTime,
+            long eventTime,
+            int action,
+            int id1,
+            float x1,
+            float y1) {
+        int[] ids = new int[]{id1};
+        MotionEvent.PointerCoords[] coords = new MotionEvent.PointerCoords[]{createCoords(x1, y1)};
+        return MotionEvent
+                .obtain(downTime, eventTime, action, 1, ids, coords, 0, 1.0f, 1.0f, 0, 0, 0, 0);
+    }
 
-  public static MotionEvent obtainMotionEvent(
-      long downTime,
-      long eventTime,
-      int action,
-      int id1,
-      float x1,
-      float y1,
-      int id2,
-      float x2,
-      float y2) {
-    int[] ids = new int[] {id1, id2};
-    MotionEvent.PointerCoords[] coords = new MotionEvent.PointerCoords[] {
-        createCoords(x1, y1),
-        createCoords(x2, y2)};
-    return MotionEvent
-        .obtain(downTime, eventTime, action, 2, ids, coords, 0, 1.0f, 1.0f, 0, 0, 0, 0);
-  }
+    public static MotionEvent obtainMotionEvent(
+            long downTime,
+            long eventTime,
+            int action,
+            int id1,
+            float x1,
+            float y1,
+            int id2,
+            float x2,
+            float y2) {
+        int[] ids = new int[]{id1, id2};
+        MotionEvent.PointerCoords[] coords = new MotionEvent.PointerCoords[]{
+                createCoords(x1, y1),
+                createCoords(x2, y2)};
+        return MotionEvent
+                .obtain(downTime, eventTime, action, 2, ids, coords, 0, 1.0f, 1.0f, 0, 0, 0, 0);
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/testing/DraweeMocks.java b/drawee/src/test/java/com/facebook/drawee/testing/DraweeMocks.java
index 296232347..fc17752bf 100644
--- a/drawee/src/test/java/com/facebook/drawee/testing/DraweeMocks.java
+++ b/drawee/src/test/java/com/facebook/drawee/testing/DraweeMocks.java
@@ -33,133 +33,141 @@
  */
 public class DraweeMocks {
 
-  /**
-   * Creates a mock DraweeController with some methods stubbed.
-   * @return mock DraweeController
-   */
-  public static DraweeController mockController() {
-    DraweeController controller = mock(AbstractDraweeController.class);
-    stubGetAndSetHierarchy(controller);
-    return controller;
-  }
-
-  /**
-   * Stubs setHierarchy and getHierarchy methods.
-   * @param controller controller to stub methods of
-   */
-  public static void stubGetAndSetHierarchy(DraweeController controller) {
-    final DraweeHierarchy[] dhHolder = new DraweeHierarchy[1];
-    doAnswer(
-        new Answer<Object>() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            return dhHolder[0];
-          }
-        }).when(controller).getHierarchy();
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            return dhHolder[0] = (DraweeHierarchy) invocation.getArguments()[0];
-          }
-        }).when(controller).setHierarchy(any(DraweeHierarchy.class));
-  }
+    /**
+     * Creates a mock DraweeController with some methods stubbed.
+     *
+     * @return mock DraweeController
+     */
+    public static DraweeController mockController() {
+        DraweeController controller = mock(AbstractDraweeController.class);
+        stubGetAndSetHierarchy(controller);
+        return controller;
+    }
 
-  /**
-   * Stubs addControllerListener
-   * @param controller
-   * @return forwarding listener
-   */
-  public static ControllerListener stubControllerListener(
-      final DraweeController controller) {
-    final ForwardingControllerListener forwardingListener = new ForwardingControllerListener();
-    if (!(controller instanceof AbstractDraweeController)) {
-      return null;
+    /**
+     * Stubs setHierarchy and getHierarchy methods.
+     *
+     * @param controller controller to stub methods of
+     */
+    public static void stubGetAndSetHierarchy(DraweeController controller) {
+        final DraweeHierarchy[] dhHolder = new DraweeHierarchy[1];
+        doAnswer(
+                new Answer<Object>() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        return dhHolder[0];
+                    }
+                }).when(controller).getHierarchy();
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        return dhHolder[0] = (DraweeHierarchy) invocation.getArguments()[0];
+                    }
+                }).when(controller).setHierarchy(any(DraweeHierarchy.class));
     }
-    AbstractDraweeController abstractController = (AbstractDraweeController) controller;
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            forwardingListener.addListener((ControllerListener) invocation.getArguments()[0]);
+
+    /**
+     * Stubs addControllerListener
+     *
+     * @param controller
+     * @return forwarding listener
+     */
+    public static ControllerListener stubControllerListener(
+            final DraweeController controller) {
+        final ForwardingControllerListener forwardingListener = new ForwardingControllerListener();
+        if (!(controller instanceof AbstractDraweeController)) {
             return null;
-          }
-        }).when(abstractController).addControllerListener(any(ControllerListener.class));
-    return forwardingListener;
-  }
+        }
+        AbstractDraweeController abstractController = (AbstractDraweeController) controller;
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        forwardingListener.addListener((ControllerListener) invocation.getArguments()[0]);
+                        return null;
+                    }
+                }).when(abstractController).addControllerListener(any(ControllerListener.class));
+        return forwardingListener;
+    }
 
-  /**
-   * Creates a mock GenericDraweeHierarchy with some methods stubbed.
-   * @param topLevelDrawable drawable to return on {@code getTopLevelDrawable()}
-   * @return mock GenericDraweeHierarchy
-   */
-  public static GenericDraweeHierarchy mockDraweeHierarchyOf(Drawable topLevelDrawable) {
-    GenericDraweeHierarchy gdh = mock(GenericDraweeHierarchy.class);
-    when(gdh.getTopLevelDrawable()).thenReturn(topLevelDrawable);
-    return gdh;
-  }
+    /**
+     * Creates a mock GenericDraweeHierarchy with some methods stubbed.
+     *
+     * @param topLevelDrawable drawable to return on {@code getTopLevelDrawable()}
+     * @return mock GenericDraweeHierarchy
+     */
+    public static GenericDraweeHierarchy mockDraweeHierarchyOf(Drawable topLevelDrawable) {
+        GenericDraweeHierarchy gdh = mock(GenericDraweeHierarchy.class);
+        when(gdh.getTopLevelDrawable()).thenReturn(topLevelDrawable);
+        return gdh;
+    }
 
-  /**
-   * Creates a mock GenericDraweeHierarchy with some methods stubbed.
-   * @return mock GenericDraweeHierarchy
-   */
-  public static GenericDraweeHierarchy mockDraweeHierarchy() {
-    return mockDraweeHierarchyOf(DrawableTestUtils.mockDrawable());
-  }
+    /**
+     * Creates a mock GenericDraweeHierarchy with some methods stubbed.
+     *
+     * @return mock GenericDraweeHierarchy
+     */
+    public static GenericDraweeHierarchy mockDraweeHierarchy() {
+        return mockDraweeHierarchyOf(DrawableTestUtils.mockDrawable());
+    }
 
-  /**
-   * Creates a mock GenericDraweeHierarchyBuilder that builds a new DH instance each time.
-   * @return mock GenericDraweeHierarchyBuilder
-   */
-  public static GenericDraweeHierarchyBuilder mockGenericDraweeHierarchyBuilder() {
-    GenericDraweeHierarchyBuilder builder =
-        mock(GenericDraweeHierarchyBuilder.class, CALLS_REAL_METHODS);
-    doAnswer(
-        new Answer<Object>() {
-          @Override
-          public DraweeHierarchy answer(InvocationOnMock invocation) throws Throwable {
-            return mockDraweeHierarchy();
-          }
-        }).when(builder).build();
-    return builder;
-  }
+    /**
+     * Creates a mock GenericDraweeHierarchyBuilder that builds a new DH instance each time.
+     *
+     * @return mock GenericDraweeHierarchyBuilder
+     */
+    public static GenericDraweeHierarchyBuilder mockGenericDraweeHierarchyBuilder() {
+        GenericDraweeHierarchyBuilder builder =
+                mock(GenericDraweeHierarchyBuilder.class, CALLS_REAL_METHODS);
+        doAnswer(
+                new Answer<Object>() {
+                    @Override
+                    public DraweeHierarchy answer(InvocationOnMock invocation) throws Throwable {
+                        return mockDraweeHierarchy();
+                    }
+                }).when(builder).build();
+        return builder;
+    }
 
-  /**
-   * Creates a mock GenericDraweeHierarchyBuilder with stubbed build.
-   * @param drawableHierarchies drawable hierarchies to return on {@code build()}
-   * @return mock GenericDraweeHierarchyBuilder
-   */
-  public static GenericDraweeHierarchyBuilder mockBuilderOf(
-      GenericDraweeHierarchy... drawableHierarchies) {
-    GenericDraweeHierarchyBuilder builder =
-        mock(GenericDraweeHierarchyBuilder.class, CALLS_REAL_METHODS);
-    final Supplier<GenericDraweeHierarchy> gdhProvider = supplierOf(drawableHierarchies);
-    doAnswer(
-        new Answer() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            return gdhProvider.get();
-          }
-        }).when(builder).build();
-    return builder;
-  }
+    /**
+     * Creates a mock GenericDraweeHierarchyBuilder with stubbed build.
+     *
+     * @param drawableHierarchies drawable hierarchies to return on {@code build()}
+     * @return mock GenericDraweeHierarchyBuilder
+     */
+    public static GenericDraweeHierarchyBuilder mockBuilderOf(
+            GenericDraweeHierarchy... drawableHierarchies) {
+        GenericDraweeHierarchyBuilder builder =
+                mock(GenericDraweeHierarchyBuilder.class, CALLS_REAL_METHODS);
+        final Supplier<GenericDraweeHierarchy> gdhProvider = supplierOf(drawableHierarchies);
+        doAnswer(
+                new Answer() {
+                    @Override
+                    public Object answer(InvocationOnMock invocation) throws Throwable {
+                        return gdhProvider.get();
+                    }
+                }).when(builder).build();
+        return builder;
+    }
 
-  /**
-   * Creates a supplier of T.
-   * @param values values to return on {@code get()}
-   * @return supplier of T
-   */
-  public static <T> Supplier<T> supplierOf(final T... values) {
-    final AtomicInteger index = new AtomicInteger(0);
-    return new Supplier<T>() {
-      @Override
-      public T get() {
-        if (index.get() < values.length) {
-          return values[index.getAndIncrement()];
-        } else {
-          return values[values.length - 1];
-        }
-      }
-    };
-  }
+    /**
+     * Creates a supplier of T.
+     *
+     * @param values values to return on {@code get()}
+     * @return supplier of T
+     */
+    public static <T> Supplier<T> supplierOf(final T... values) {
+        final AtomicInteger index = new AtomicInteger(0);
+        return new Supplier<T>() {
+            @Override
+            public T get() {
+                if (index.get() < values.length) {
+                    return values[index.getAndIncrement()];
+                } else {
+                    return values[values.length - 1];
+                }
+            }
+        };
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/testing/DraweeMocksTest.java b/drawee/src/test/java/com/facebook/drawee/testing/DraweeMocksTest.java
index ea4969d05..e5a298e42 100644
--- a/drawee/src/test/java/com/facebook/drawee/testing/DraweeMocksTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/testing/DraweeMocksTest.java
@@ -31,72 +31,72 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class DraweeMocksTest {
 
-  @Before
-  public void setUp() {
-  }
+    @Before
+    public void setUp() {
+    }
 
-  @Test
-  public void testMockProviderOf() {
-    Object obj = mock(Object.class);
-    Supplier<Object> provider =
-        DraweeMocks.supplierOf(obj);
-    assertEquals(obj, provider.get());
-    assertEquals(obj, provider.get());
-    assertEquals(obj, provider.get());
-    assertEquals(obj, provider.get());
-    assertEquals(obj, provider.get());
+    @Test
+    public void testMockProviderOf() {
+        Object obj = mock(Object.class);
+        Supplier<Object> provider =
+                DraweeMocks.supplierOf(obj);
+        assertEquals(obj, provider.get());
+        assertEquals(obj, provider.get());
+        assertEquals(obj, provider.get());
+        assertEquals(obj, provider.get());
+        assertEquals(obj, provider.get());
 
-    Object obj1 = mock(Object.class);
-    Object obj2 = mock(Object.class);
-    Object obj3 = mock(Object.class);
-    Supplier<Object> multiProvider =
-        DraweeMocks.supplierOf(obj1, obj2, obj3);
-    assertEquals(obj1, multiProvider.get());
-    assertEquals(obj2, multiProvider.get());
-    assertEquals(obj3, multiProvider.get());
-    assertEquals(obj3, multiProvider.get());
-    assertEquals(obj3, multiProvider.get());
-  }
+        Object obj1 = mock(Object.class);
+        Object obj2 = mock(Object.class);
+        Object obj3 = mock(Object.class);
+        Supplier<Object> multiProvider =
+                DraweeMocks.supplierOf(obj1, obj2, obj3);
+        assertEquals(obj1, multiProvider.get());
+        assertEquals(obj2, multiProvider.get());
+        assertEquals(obj3, multiProvider.get());
+        assertEquals(obj3, multiProvider.get());
+        assertEquals(obj3, multiProvider.get());
+    }
 
-  @Test
-  public void testMockBuilderOfDrawableHierarchies() {
-    GenericDraweeHierarchy gdh = DraweeMocks.mockDraweeHierarchy();
-    GenericDraweeHierarchyBuilder builder =
-        DraweeMocks.mockBuilderOf(gdh);
-    assertEquals(gdh, builder.build());
-    assertEquals(gdh, builder.build());
-    assertEquals(gdh, builder.build());
-    assertEquals(gdh, builder.build());
-    assertEquals(gdh, builder.build());
+    @Test
+    public void testMockBuilderOfDrawableHierarchies() {
+        GenericDraweeHierarchy gdh = DraweeMocks.mockDraweeHierarchy();
+        GenericDraweeHierarchyBuilder builder =
+                DraweeMocks.mockBuilderOf(gdh);
+        assertEquals(gdh, builder.build());
+        assertEquals(gdh, builder.build());
+        assertEquals(gdh, builder.build());
+        assertEquals(gdh, builder.build());
+        assertEquals(gdh, builder.build());
 
-    GenericDraweeHierarchy gdh1 = DraweeMocks.mockDraweeHierarchy();
-    GenericDraweeHierarchy gdh2 = DraweeMocks.mockDraweeHierarchy();
-    GenericDraweeHierarchy gdh3 = DraweeMocks.mockDraweeHierarchy();
-    GenericDraweeHierarchyBuilder multiBuilder =
-        DraweeMocks.mockBuilderOf(gdh1, gdh2, gdh3);
-    assertEquals(gdh1, multiBuilder.build());
-    assertEquals(gdh2, multiBuilder.build());
-    assertEquals(gdh3, multiBuilder.build());
-    assertEquals(gdh3, multiBuilder.build());
-    assertEquals(gdh3, multiBuilder.build());
-  }
+        GenericDraweeHierarchy gdh1 = DraweeMocks.mockDraweeHierarchy();
+        GenericDraweeHierarchy gdh2 = DraweeMocks.mockDraweeHierarchy();
+        GenericDraweeHierarchy gdh3 = DraweeMocks.mockDraweeHierarchy();
+        GenericDraweeHierarchyBuilder multiBuilder =
+                DraweeMocks.mockBuilderOf(gdh1, gdh2, gdh3);
+        assertEquals(gdh1, multiBuilder.build());
+        assertEquals(gdh2, multiBuilder.build());
+        assertEquals(gdh3, multiBuilder.build());
+        assertEquals(gdh3, multiBuilder.build());
+        assertEquals(gdh3, multiBuilder.build());
+    }
 
-  @Test
-  public void testMockDrawable_VisibilityCallback() {
-    boolean reset = true;
-    Drawable drawable = DrawableTestUtils.mockDrawable();
-    assertTrue(drawable instanceof VisibilityAwareDrawable);
+    @Test
+    public void testMockDrawable_VisibilityCallback() {
+        boolean reset = true;
+        Drawable drawable = DrawableTestUtils.mockDrawable();
+        assertTrue(drawable instanceof VisibilityAwareDrawable);
 
-    VisibilityAwareDrawable visibilityAwareDrawable = (VisibilityAwareDrawable) drawable;
-    VisibilityCallback visibilityCallback = mock(VisibilityCallback.class);
-    visibilityAwareDrawable.setVisibilityCallback(visibilityCallback);
+        VisibilityAwareDrawable visibilityAwareDrawable = (VisibilityAwareDrawable) drawable;
+        VisibilityCallback visibilityCallback = mock(VisibilityCallback.class);
+        visibilityAwareDrawable.setVisibilityCallback(visibilityCallback);
 
-    InOrder inOrder = inOrder(visibilityCallback);
-    drawable.setVisible(false, reset);
-    inOrder.verify(visibilityCallback).onVisibilityChange(false);
-    drawable.setVisible(true, reset);
-    inOrder.verify(visibilityCallback).onVisibilityChange(true);
-    drawable.setVisible(false, reset);
-    inOrder.verify(visibilityCallback).onVisibilityChange(false);
-  }
+        InOrder inOrder = inOrder(visibilityCallback);
+        drawable.setVisible(false, reset);
+        inOrder.verify(visibilityCallback).onVisibilityChange(false);
+        drawable.setVisible(true, reset);
+        inOrder.verify(visibilityCallback).onVisibilityChange(true);
+        drawable.setVisible(false, reset);
+        inOrder.verify(visibilityCallback).onVisibilityChange(false);
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/view/AspectRatioMeasureTest.java b/drawee/src/test/java/com/facebook/drawee/view/AspectRatioMeasureTest.java
index 6367e2da9..2d3294cdc 100644
--- a/drawee/src/test/java/com/facebook/drawee/view/AspectRatioMeasureTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/view/AspectRatioMeasureTest.java
@@ -25,101 +25,101 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class AspectRatioMeasureTest {
 
-  AspectRatioMeasure.Spec mSpec = new AspectRatioMeasure.Spec();
-
-  @Before
-  public void setUp() {
-  }
-
-  @Test
-  public void testAspectRatio() {
-    // width
-    mSpec.width = makeMeasureSpec(410, UNSPECIFIED);
-    mSpec.height = makeMeasureSpec(310, EXACTLY);
-    LayoutParams layoutParams1 = new LayoutParams(WRAP_CONTENT, MATCH_PARENT);
-    AspectRatioMeasure.updateMeasureSpec(mSpec, 1.5f, layoutParams1, 10, 10);
-    assertEquals(makeMeasureSpec(460, EXACTLY), mSpec.width);
-    assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
-
-    // height
-    mSpec.width = makeMeasureSpec(410, EXACTLY);
-    mSpec.height = makeMeasureSpec(310, UNSPECIFIED);
-    LayoutParams layoutParams2 = new LayoutParams(MATCH_PARENT, WRAP_CONTENT);
-    AspectRatioMeasure.updateMeasureSpec(mSpec, 2f, layoutParams2, 10, 10);
-    assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
-    assertEquals(makeMeasureSpec(210, EXACTLY), mSpec.height);
-  }
-
-  @Test
-  public void testNoAspectRatio() {
-    // width
-    mSpec.width = makeMeasureSpec(410, UNSPECIFIED);
-    mSpec.height = makeMeasureSpec(310, EXACTLY);
-    LayoutParams layoutParams1 = new LayoutParams(WRAP_CONTENT, MATCH_PARENT);
-    AspectRatioMeasure.updateMeasureSpec(mSpec, 0, layoutParams1, 10, 10);
-    assertEquals(makeMeasureSpec(410, UNSPECIFIED), mSpec.width);
-    assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
-
-    // height
-    mSpec.width = makeMeasureSpec(410, EXACTLY);
-    mSpec.height = makeMeasureSpec(310, UNSPECIFIED);
-    LayoutParams layoutParams2 = new LayoutParams(MATCH_PARENT, WRAP_CONTENT);
-    AspectRatioMeasure.updateMeasureSpec(mSpec, 0, layoutParams2, 10, 10);
-    assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
-    assertEquals(makeMeasureSpec(310, UNSPECIFIED), mSpec.height);
-  }
-
-  @Test
-  public void testAtMost() {
-    // width exceeded
-    mSpec.width = makeMeasureSpec(410, AT_MOST);
-    mSpec.height = makeMeasureSpec(310, EXACTLY);
-    LayoutParams layoutParams1 = new LayoutParams(WRAP_CONTENT, MATCH_PARENT);
-    AspectRatioMeasure.updateMeasureSpec(mSpec, 1.5f, layoutParams1, 10, 10);
-    assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
-    assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
-
-    // width within limits
-    mSpec.width = makeMeasureSpec(510, AT_MOST);
-    mSpec.height = makeMeasureSpec(310, EXACTLY);
-    LayoutParams layoutParams2 = new LayoutParams(WRAP_CONTENT, MATCH_PARENT);
-    AspectRatioMeasure.updateMeasureSpec(mSpec, 1.5f, layoutParams2, 10, 10);
-    assertEquals(makeMeasureSpec(460, EXACTLY), mSpec.width);
-    assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
-
-    // height exceeded
-    mSpec.width = makeMeasureSpec(410, EXACTLY);
-    mSpec.height = makeMeasureSpec(110, AT_MOST);
-    LayoutParams layoutParams3 = new LayoutParams(MATCH_PARENT, WRAP_CONTENT);
-    AspectRatioMeasure.updateMeasureSpec(mSpec, 2f, layoutParams3, 10, 10);
-    assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
-    assertEquals(makeMeasureSpec(110, EXACTLY), mSpec.height);
-
-    // height within limits
-    mSpec.width = makeMeasureSpec(410, EXACTLY);
-    mSpec.height = makeMeasureSpec(310, AT_MOST);
-    LayoutParams layoutParams4 = new LayoutParams(MATCH_PARENT, WRAP_CONTENT);
-    AspectRatioMeasure.updateMeasureSpec(mSpec, 2f, layoutParams4, 10, 10);
-    assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
-    assertEquals(makeMeasureSpec(210, EXACTLY), mSpec.height);
-  }
-
-  @Test
-  public void testExactly() {
-    // width
-    mSpec.width = makeMeasureSpec(410, EXACTLY);
-    mSpec.height = makeMeasureSpec(310, EXACTLY);
-    LayoutParams layoutParams1 = new LayoutParams(WRAP_CONTENT, MATCH_PARENT);
-    AspectRatioMeasure.updateMeasureSpec(mSpec, 1.5f, layoutParams1, 10, 10);
-    assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
-    assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
-
-    // height
-    mSpec.width = makeMeasureSpec(410, EXACTLY);
-    mSpec.height = makeMeasureSpec(310, EXACTLY);
-    LayoutParams layoutParams2 = new LayoutParams(MATCH_PARENT, WRAP_CONTENT);
-    AspectRatioMeasure.updateMeasureSpec(mSpec, 2f, layoutParams2, 10, 10);
-    assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
-    assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
-  }
+    AspectRatioMeasure.Spec mSpec = new AspectRatioMeasure.Spec();
+
+    @Before
+    public void setUp() {
+    }
+
+    @Test
+    public void testAspectRatio() {
+        // width
+        mSpec.width = makeMeasureSpec(410, UNSPECIFIED);
+        mSpec.height = makeMeasureSpec(310, EXACTLY);
+        LayoutParams layoutParams1 = new LayoutParams(WRAP_CONTENT, MATCH_PARENT);
+        AspectRatioMeasure.updateMeasureSpec(mSpec, 1.5f, layoutParams1, 10, 10);
+        assertEquals(makeMeasureSpec(460, EXACTLY), mSpec.width);
+        assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
+
+        // height
+        mSpec.width = makeMeasureSpec(410, EXACTLY);
+        mSpec.height = makeMeasureSpec(310, UNSPECIFIED);
+        LayoutParams layoutParams2 = new LayoutParams(MATCH_PARENT, WRAP_CONTENT);
+        AspectRatioMeasure.updateMeasureSpec(mSpec, 2f, layoutParams2, 10, 10);
+        assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
+        assertEquals(makeMeasureSpec(210, EXACTLY), mSpec.height);
+    }
+
+    @Test
+    public void testNoAspectRatio() {
+        // width
+        mSpec.width = makeMeasureSpec(410, UNSPECIFIED);
+        mSpec.height = makeMeasureSpec(310, EXACTLY);
+        LayoutParams layoutParams1 = new LayoutParams(WRAP_CONTENT, MATCH_PARENT);
+        AspectRatioMeasure.updateMeasureSpec(mSpec, 0, layoutParams1, 10, 10);
+        assertEquals(makeMeasureSpec(410, UNSPECIFIED), mSpec.width);
+        assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
+
+        // height
+        mSpec.width = makeMeasureSpec(410, EXACTLY);
+        mSpec.height = makeMeasureSpec(310, UNSPECIFIED);
+        LayoutParams layoutParams2 = new LayoutParams(MATCH_PARENT, WRAP_CONTENT);
+        AspectRatioMeasure.updateMeasureSpec(mSpec, 0, layoutParams2, 10, 10);
+        assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
+        assertEquals(makeMeasureSpec(310, UNSPECIFIED), mSpec.height);
+    }
+
+    @Test
+    public void testAtMost() {
+        // width exceeded
+        mSpec.width = makeMeasureSpec(410, AT_MOST);
+        mSpec.height = makeMeasureSpec(310, EXACTLY);
+        LayoutParams layoutParams1 = new LayoutParams(WRAP_CONTENT, MATCH_PARENT);
+        AspectRatioMeasure.updateMeasureSpec(mSpec, 1.5f, layoutParams1, 10, 10);
+        assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
+        assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
+
+        // width within limits
+        mSpec.width = makeMeasureSpec(510, AT_MOST);
+        mSpec.height = makeMeasureSpec(310, EXACTLY);
+        LayoutParams layoutParams2 = new LayoutParams(WRAP_CONTENT, MATCH_PARENT);
+        AspectRatioMeasure.updateMeasureSpec(mSpec, 1.5f, layoutParams2, 10, 10);
+        assertEquals(makeMeasureSpec(460, EXACTLY), mSpec.width);
+        assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
+
+        // height exceeded
+        mSpec.width = makeMeasureSpec(410, EXACTLY);
+        mSpec.height = makeMeasureSpec(110, AT_MOST);
+        LayoutParams layoutParams3 = new LayoutParams(MATCH_PARENT, WRAP_CONTENT);
+        AspectRatioMeasure.updateMeasureSpec(mSpec, 2f, layoutParams3, 10, 10);
+        assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
+        assertEquals(makeMeasureSpec(110, EXACTLY), mSpec.height);
+
+        // height within limits
+        mSpec.width = makeMeasureSpec(410, EXACTLY);
+        mSpec.height = makeMeasureSpec(310, AT_MOST);
+        LayoutParams layoutParams4 = new LayoutParams(MATCH_PARENT, WRAP_CONTENT);
+        AspectRatioMeasure.updateMeasureSpec(mSpec, 2f, layoutParams4, 10, 10);
+        assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
+        assertEquals(makeMeasureSpec(210, EXACTLY), mSpec.height);
+    }
+
+    @Test
+    public void testExactly() {
+        // width
+        mSpec.width = makeMeasureSpec(410, EXACTLY);
+        mSpec.height = makeMeasureSpec(310, EXACTLY);
+        LayoutParams layoutParams1 = new LayoutParams(WRAP_CONTENT, MATCH_PARENT);
+        AspectRatioMeasure.updateMeasureSpec(mSpec, 1.5f, layoutParams1, 10, 10);
+        assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
+        assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
+
+        // height
+        mSpec.width = makeMeasureSpec(410, EXACTLY);
+        mSpec.height = makeMeasureSpec(310, EXACTLY);
+        LayoutParams layoutParams2 = new LayoutParams(MATCH_PARENT, WRAP_CONTENT);
+        AspectRatioMeasure.updateMeasureSpec(mSpec, 2f, layoutParams2, 10, 10);
+        assertEquals(makeMeasureSpec(410, EXACTLY), mSpec.width);
+        assertEquals(makeMeasureSpec(310, EXACTLY), mSpec.height);
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/view/DraweeHolderTest.java b/drawee/src/test/java/com/facebook/drawee/view/DraweeHolderTest.java
index 292b132bf..4ea453b8f 100644
--- a/drawee/src/test/java/com/facebook/drawee/view/DraweeHolderTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/view/DraweeHolderTest.java
@@ -32,142 +32,143 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class DraweeHolderTest {
 
-  private DraweeHolder mDraweeHolder;
-
-  private Drawable mTopLevelDrawable;
-  private DraweeHierarchy mDraweeHierarchy;
-  private DraweeController mController;
-
-  private InOrder mInOrderVerifier;
-
-  @Before
-  public void setUp() {
-    mTopLevelDrawable = DrawableTestUtils.mockDrawable();
-    mDraweeHierarchy = DraweeMocks.mockDraweeHierarchyOf(mTopLevelDrawable);
-    mController = DraweeMocks.mockController();
-    mDraweeHolder = new DraweeHolder(mDraweeHierarchy);
-    mInOrderVerifier = inOrder(mController);
-  }
-
-  @Test
-  public void testOverrideControllerHierarchy() {
-    DraweeHierarchy otherHierarchy = mock(DraweeHierarchy.class);
-    mController.setHierarchy(otherHierarchy);
-    assertSame(otherHierarchy, mController.getHierarchy());
-    mDraweeHolder.setController(mController);
-    assertSame(mController, mDraweeHolder.getController());
-    assertSame(mDraweeHierarchy, mDraweeHolder.getHierarchy());
-    assertSame(mDraweeHierarchy, mController.getHierarchy());
-  }
-
-  @Test
-  public void testSetControllerWithoutHierarchy() {
-    mDraweeHolder.setController(mController);
-    assertSame(mController, mDraweeHolder.getController());
-    assertSame(mDraweeHierarchy, mDraweeHolder.getHierarchy());
-    assertSame(mDraweeHierarchy, mController.getHierarchy());
-  }
-
-  @Test
-  public void testClearControllerKeepsHierarchy() {
-    mDraweeHolder.setController(mController);
-    mDraweeHolder.setController(null);
-    assertSame(mDraweeHierarchy, mDraweeHolder.getHierarchy());
-    assertNull(mDraweeHolder.getController());
-    assertNull(mController.getHierarchy());
-  }
-
-  @Test
-  public void testNewControllerKeepsHierarchy() {
-    mDraweeHolder.setController(mController);
-    assertSame(mDraweeHierarchy, mDraweeHolder.getHierarchy());
-    DraweeController another = DraweeMocks.mockController();
-    mDraweeHolder.setController(another);
-    assertSame(mDraweeHierarchy, mDraweeHolder.getHierarchy());
-    assertSame(another, mDraweeHolder.getController());
-    assertNull(mController.getHierarchy());
-    assertSame(mDraweeHierarchy, another.getHierarchy());
-  }
-
-  @Test
-  public void testLifecycle() {
-    mDraweeHolder.setController(mController);
-    mDraweeHolder.onAttach();
-    mDraweeHolder.onDetach();
-    verify(mController).onAttach();
-    verify(mController).onDetach();
-  }
-
-  @Test
-  public void testSetControllerWhenAlreadyAttached() {
-    mDraweeHolder.onAttach();
-    mDraweeHolder.setController(mController);
-    mDraweeHolder.onDetach();
-    verify(mController).onAttach();
-    verify(mController).onDetach();
-  }
-
-  @Test
-  public void testSetNullController() {
-    mDraweeHolder.setController(null);
-    mDraweeHolder.onAttach();
-    mDraweeHolder.onDetach();
-    mDraweeHolder.onAttach();
-  }
-
-  /** There are 8 possible state transitions with two variables
-   * 1. (visible, unattached)   -> (visible, attached)
-   * 2. (visible, attached)     -> (invisible, attached)
-   * 3. (invisible, attached)   -> (invisible, unattached)
-   * 4. (invisible, unattached) -> (visible, unattached)
-   * 5. (visible, unattached)   -> (invisible, unattached)
-   * 6. (invisible, unattached) -> (invisible, attached)
-   * 7. (invisible, attached)   -> (visible, attached)
-   * 8. (visible, attached)     -> (visible, unattached)
-   */
-  @Test
-  public void testVisibilityStateTransitions() {
-    boolean restart = true;
-
-    // Initial state (mIsVisible, !mIsHolderAttached)
-    mDraweeHolder.setController(mController);
-    verifyControllerLifecycleCalls(0, 0);
-
-    /** 1 */
-    mDraweeHolder.onAttach();
-    verifyControllerLifecycleCalls(1, 0);
-
-    /** 2 */
-    mTopLevelDrawable.setVisible(false, restart);
-    verifyControllerLifecycleCalls(0, 1);
-
-    /** 3 */
-    mDraweeHolder.onDetach();
-    verifyControllerLifecycleCalls(0, 0);
-
-    /** 4 */
-    mTopLevelDrawable.setVisible(true, restart);
-    verifyControllerLifecycleCalls(0, 0);
-
-    /** 5 */
-    mTopLevelDrawable.setVisible(false, restart);
-    verifyControllerLifecycleCalls(0, 0);
-
-    /** 6 */
-    mDraweeHolder.onAttach();
-    verifyControllerLifecycleCalls(0, 0);
-
-    /** 7 */
-    mTopLevelDrawable.setVisible(true, restart);
-    verifyControllerLifecycleCalls(1, 0);
-
-    /** 8 */
-    mDraweeHolder.onDetach();
-    verifyControllerLifecycleCalls(0, 1);
-  }
-
-  private void verifyControllerLifecycleCalls(int numOnAttach, int numOnDetach) {
-    mInOrderVerifier.verify(mController, times(numOnAttach)).onAttach();
-    mInOrderVerifier.verify(mController, times(numOnDetach)).onDetach();
-  }
+    private DraweeHolder mDraweeHolder;
+
+    private Drawable mTopLevelDrawable;
+    private DraweeHierarchy mDraweeHierarchy;
+    private DraweeController mController;
+
+    private InOrder mInOrderVerifier;
+
+    @Before
+    public void setUp() {
+        mTopLevelDrawable = DrawableTestUtils.mockDrawable();
+        mDraweeHierarchy = DraweeMocks.mockDraweeHierarchyOf(mTopLevelDrawable);
+        mController = DraweeMocks.mockController();
+        mDraweeHolder = new DraweeHolder(mDraweeHierarchy);
+        mInOrderVerifier = inOrder(mController);
+    }
+
+    @Test
+    public void testOverrideControllerHierarchy() {
+        DraweeHierarchy otherHierarchy = mock(DraweeHierarchy.class);
+        mController.setHierarchy(otherHierarchy);
+        assertSame(otherHierarchy, mController.getHierarchy());
+        mDraweeHolder.setController(mController);
+        assertSame(mController, mDraweeHolder.getController());
+        assertSame(mDraweeHierarchy, mDraweeHolder.getHierarchy());
+        assertSame(mDraweeHierarchy, mController.getHierarchy());
+    }
+
+    @Test
+    public void testSetControllerWithoutHierarchy() {
+        mDraweeHolder.setController(mController);
+        assertSame(mController, mDraweeHolder.getController());
+        assertSame(mDraweeHierarchy, mDraweeHolder.getHierarchy());
+        assertSame(mDraweeHierarchy, mController.getHierarchy());
+    }
+
+    @Test
+    public void testClearControllerKeepsHierarchy() {
+        mDraweeHolder.setController(mController);
+        mDraweeHolder.setController(null);
+        assertSame(mDraweeHierarchy, mDraweeHolder.getHierarchy());
+        assertNull(mDraweeHolder.getController());
+        assertNull(mController.getHierarchy());
+    }
+
+    @Test
+    public void testNewControllerKeepsHierarchy() {
+        mDraweeHolder.setController(mController);
+        assertSame(mDraweeHierarchy, mDraweeHolder.getHierarchy());
+        DraweeController another = DraweeMocks.mockController();
+        mDraweeHolder.setController(another);
+        assertSame(mDraweeHierarchy, mDraweeHolder.getHierarchy());
+        assertSame(another, mDraweeHolder.getController());
+        assertNull(mController.getHierarchy());
+        assertSame(mDraweeHierarchy, another.getHierarchy());
+    }
+
+    @Test
+    public void testLifecycle() {
+        mDraweeHolder.setController(mController);
+        mDraweeHolder.onAttach();
+        mDraweeHolder.onDetach();
+        verify(mController).onAttach();
+        verify(mController).onDetach();
+    }
+
+    @Test
+    public void testSetControllerWhenAlreadyAttached() {
+        mDraweeHolder.onAttach();
+        mDraweeHolder.setController(mController);
+        mDraweeHolder.onDetach();
+        verify(mController).onAttach();
+        verify(mController).onDetach();
+    }
+
+    @Test
+    public void testSetNullController() {
+        mDraweeHolder.setController(null);
+        mDraweeHolder.onAttach();
+        mDraweeHolder.onDetach();
+        mDraweeHolder.onAttach();
+    }
+
+    /**
+     * There are 8 possible state transitions with two variables
+     * 1. (visible, unattached)   -> (visible, attached)
+     * 2. (visible, attached)     -> (invisible, attached)
+     * 3. (invisible, attached)   -> (invisible, unattached)
+     * 4. (invisible, unattached) -> (visible, unattached)
+     * 5. (visible, unattached)   -> (invisible, unattached)
+     * 6. (invisible, unattached) -> (invisible, attached)
+     * 7. (invisible, attached)   -> (visible, attached)
+     * 8. (visible, attached)     -> (visible, unattached)
+     */
+    @Test
+    public void testVisibilityStateTransitions() {
+        boolean restart = true;
+
+        // Initial state (mIsVisible, !mIsHolderAttached)
+        mDraweeHolder.setController(mController);
+        verifyControllerLifecycleCalls(0, 0);
+
+        /** 1 */
+        mDraweeHolder.onAttach();
+        verifyControllerLifecycleCalls(1, 0);
+
+        /** 2 */
+        mTopLevelDrawable.setVisible(false, restart);
+        verifyControllerLifecycleCalls(0, 1);
+
+        /** 3 */
+        mDraweeHolder.onDetach();
+        verifyControllerLifecycleCalls(0, 0);
+
+        /** 4 */
+        mTopLevelDrawable.setVisible(true, restart);
+        verifyControllerLifecycleCalls(0, 0);
+
+        /** 5 */
+        mTopLevelDrawable.setVisible(false, restart);
+        verifyControllerLifecycleCalls(0, 0);
+
+        /** 6 */
+        mDraweeHolder.onAttach();
+        verifyControllerLifecycleCalls(0, 0);
+
+        /** 7 */
+        mTopLevelDrawable.setVisible(true, restart);
+        verifyControllerLifecycleCalls(1, 0);
+
+        /** 8 */
+        mDraweeHolder.onDetach();
+        verifyControllerLifecycleCalls(0, 1);
+    }
+
+    private void verifyControllerLifecycleCalls(int numOnAttach, int numOnDetach) {
+        mInOrderVerifier.verify(mController, times(numOnAttach)).onAttach();
+        mInOrderVerifier.verify(mController, times(numOnDetach)).onDetach();
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/view/DraweeViewTest.java b/drawee/src/test/java/com/facebook/drawee/view/DraweeViewTest.java
index 3350a9ac0..46a732074 100644
--- a/drawee/src/test/java/com/facebook/drawee/view/DraweeViewTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/view/DraweeViewTest.java
@@ -27,137 +27,139 @@
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
-/** Unit test for {@link DraweeView}. */
+/**
+ * Unit test for {@link DraweeView}.
+ */
 @RunWith(WithTestDefaultsRunner.class)
 public class DraweeViewTest {
 
-  private DraweeView<DraweeHierarchy> mDraweeView;
-
-  private Drawable mDrawable;
-  private Drawable mTopLevelDrawable;
-  private DraweeHierarchy mDraweeHierarchy;
-  private DraweeController mController;
-
-  @Before
-  public void setUp() {
-    Activity activity = Robolectric.buildActivity(Activity.class).create().get();
-    mDrawable = DrawableTestUtils.mockDrawable();
-    mTopLevelDrawable = DrawableTestUtils.mockDrawable();
-    mDraweeHierarchy = DraweeMocks.mockDraweeHierarchyOf(mTopLevelDrawable);
-    mController = DraweeMocks.mockController();
-    mDraweeView = new DraweeView<DraweeHierarchy>(activity);
-  }
-
-  @Test
-  public void testSetHierarchy() {
-    mDraweeView.setHierarchy(mDraweeHierarchy);
-    assertSame(mDraweeHierarchy, mDraweeView.getHierarchy());
-    assertSame(mTopLevelDrawable, mDraweeView.getDrawable());
-
-    DraweeHierarchy hierarchy2 = DraweeMocks.mockDraweeHierarchy();
-    mDraweeView.setHierarchy(hierarchy2);
-    assertSame(hierarchy2, mDraweeView.getHierarchy());
-    assertSame(hierarchy2.getTopLevelDrawable(), mDraweeView.getDrawable());
-  }
-
-  @Test
-  public void testSetController() {
-    mDraweeView.setHierarchy(mDraweeHierarchy);
-    mDraweeView.setController(mController);
-    assertSame(mController, mDraweeView.getController());
-    assertSame(mTopLevelDrawable, mDraweeView.getDrawable());
-    verify(mController).setHierarchy(mDraweeHierarchy);
-  }
-
-  @Test
-  public void testClearControllerKeepsHierarchy() {
-    mDraweeView.setHierarchy(mDraweeHierarchy);
-    mDraweeView.setController(mController);
-    mDraweeView.setController(null);
-    assertNull(mDraweeView.getController());
-    assertSame(mTopLevelDrawable, mDraweeView.getDrawable());
-    verify(mController).setHierarchy(null);
-  }
-
-  @Test
-  public void testNewControllerKeepsHierarchy() {
-    mDraweeView.setHierarchy(mDraweeHierarchy);
-    mDraweeView.setController(mController);
-    DraweeController controller2 = DraweeMocks.mockController();
-    mDraweeView.setController(controller2);
-    assertSame(controller2, mDraweeView.getController());
-    assertSame(mTopLevelDrawable, mDraweeView.getDrawable());
-    verify(mController).setHierarchy(null);
-    verify(controller2).setHierarchy(mDraweeHierarchy);
-  }
-
-  @Test
-  public void testSetDrawable() {
-    mDraweeView.setImageDrawable(mDrawable);
-    assertSame(mDrawable, mDraweeView.getDrawable());
-    assertNull(mDraweeView.getController());
-  }
-
-  @Test
-  public void testSetDrawableAfterController() {
-    mDraweeView.setHierarchy(mDraweeHierarchy);
-    mDraweeView.onAttachedToWindow();
-    mDraweeView.setController(mController);
-    mDraweeView.setImageDrawable(mDrawable);
-    assertNull(mDraweeView.getController());
-    assertSame(mDrawable, mDraweeView.getDrawable());
-  }
-
-  @Test
-  public void testSetControllerAfterDrawable() {
-    mDraweeView.setHierarchy(mDraweeHierarchy);
-    mDraweeView.onAttachedToWindow();
-    mDraweeView.setImageDrawable(mDrawable);
-    mDraweeView.setController(mController);
-    assertSame(mController, mDraweeView.getController());
-    assertSame(mTopLevelDrawable, mDraweeView.getDrawable());
-  }
-
-  @Test
-  public void testLifecycle_Controller() {
-    InOrder inOrder = inOrder(mController);
-    mDraweeView.setHierarchy(mDraweeHierarchy);
-    mDraweeView.setController(mController);
-    inOrder.verify(mController).setHierarchy(mDraweeHierarchy);
-    mDraweeView.onAttachedToWindow();
-    inOrder.verify(mController).onAttach();
-    mDraweeView.onStartTemporaryDetach();
-    inOrder.verify(mController).onDetach();
-    mDraweeView.onFinishTemporaryDetach();
-    inOrder.verify(mController).onAttach();
-    mDraweeView.onDetachedFromWindow();
-    inOrder.verify(mController).onDetach();
-  }
-
-  @Test
-  public void testLifecycle_ControllerSetWhileAttached() {
-    InOrder inOrder = inOrder(mController);
-    mDraweeView.setHierarchy(mDraweeHierarchy);
-    mDraweeView.onAttachedToWindow();
-    mDraweeView.setController(mController);
-    inOrder.verify(mController).setHierarchy(mDraweeHierarchy);
-    inOrder.verify(mController).onAttach();
-    mDraweeView.onDetachedFromWindow();
-    inOrder.verify(mController).onDetach();
-  }
-
-  @Test
-  public void testLifecycle_NullController() {
-    mDraweeView.setHierarchy(mDraweeHierarchy);
-    mDraweeView.setController(null);
-    mDraweeView.onStartTemporaryDetach();
-    mDraweeView.onFinishTemporaryDetach();
-  }
-
-  @Test
-  public void testLifecycle_Drawable() {
-    mDraweeView.setImageDrawable(mDrawable);
-    mDraweeView.onStartTemporaryDetach();
-    mDraweeView.onFinishTemporaryDetach();
-  }
+    private DraweeView<DraweeHierarchy> mDraweeView;
+
+    private Drawable mDrawable;
+    private Drawable mTopLevelDrawable;
+    private DraweeHierarchy mDraweeHierarchy;
+    private DraweeController mController;
+
+    @Before
+    public void setUp() {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        mDrawable = DrawableTestUtils.mockDrawable();
+        mTopLevelDrawable = DrawableTestUtils.mockDrawable();
+        mDraweeHierarchy = DraweeMocks.mockDraweeHierarchyOf(mTopLevelDrawable);
+        mController = DraweeMocks.mockController();
+        mDraweeView = new DraweeView<DraweeHierarchy>(activity);
+    }
+
+    @Test
+    public void testSetHierarchy() {
+        mDraweeView.setHierarchy(mDraweeHierarchy);
+        assertSame(mDraweeHierarchy, mDraweeView.getHierarchy());
+        assertSame(mTopLevelDrawable, mDraweeView.getDrawable());
+
+        DraweeHierarchy hierarchy2 = DraweeMocks.mockDraweeHierarchy();
+        mDraweeView.setHierarchy(hierarchy2);
+        assertSame(hierarchy2, mDraweeView.getHierarchy());
+        assertSame(hierarchy2.getTopLevelDrawable(), mDraweeView.getDrawable());
+    }
+
+    @Test
+    public void testSetController() {
+        mDraweeView.setHierarchy(mDraweeHierarchy);
+        mDraweeView.setController(mController);
+        assertSame(mController, mDraweeView.getController());
+        assertSame(mTopLevelDrawable, mDraweeView.getDrawable());
+        verify(mController).setHierarchy(mDraweeHierarchy);
+    }
+
+    @Test
+    public void testClearControllerKeepsHierarchy() {
+        mDraweeView.setHierarchy(mDraweeHierarchy);
+        mDraweeView.setController(mController);
+        mDraweeView.setController(null);
+        assertNull(mDraweeView.getController());
+        assertSame(mTopLevelDrawable, mDraweeView.getDrawable());
+        verify(mController).setHierarchy(null);
+    }
+
+    @Test
+    public void testNewControllerKeepsHierarchy() {
+        mDraweeView.setHierarchy(mDraweeHierarchy);
+        mDraweeView.setController(mController);
+        DraweeController controller2 = DraweeMocks.mockController();
+        mDraweeView.setController(controller2);
+        assertSame(controller2, mDraweeView.getController());
+        assertSame(mTopLevelDrawable, mDraweeView.getDrawable());
+        verify(mController).setHierarchy(null);
+        verify(controller2).setHierarchy(mDraweeHierarchy);
+    }
+
+    @Test
+    public void testSetDrawable() {
+        mDraweeView.setImageDrawable(mDrawable);
+        assertSame(mDrawable, mDraweeView.getDrawable());
+        assertNull(mDraweeView.getController());
+    }
+
+    @Test
+    public void testSetDrawableAfterController() {
+        mDraweeView.setHierarchy(mDraweeHierarchy);
+        mDraweeView.onAttachedToWindow();
+        mDraweeView.setController(mController);
+        mDraweeView.setImageDrawable(mDrawable);
+        assertNull(mDraweeView.getController());
+        assertSame(mDrawable, mDraweeView.getDrawable());
+    }
+
+    @Test
+    public void testSetControllerAfterDrawable() {
+        mDraweeView.setHierarchy(mDraweeHierarchy);
+        mDraweeView.onAttachedToWindow();
+        mDraweeView.setImageDrawable(mDrawable);
+        mDraweeView.setController(mController);
+        assertSame(mController, mDraweeView.getController());
+        assertSame(mTopLevelDrawable, mDraweeView.getDrawable());
+    }
+
+    @Test
+    public void testLifecycle_Controller() {
+        InOrder inOrder = inOrder(mController);
+        mDraweeView.setHierarchy(mDraweeHierarchy);
+        mDraweeView.setController(mController);
+        inOrder.verify(mController).setHierarchy(mDraweeHierarchy);
+        mDraweeView.onAttachedToWindow();
+        inOrder.verify(mController).onAttach();
+        mDraweeView.onStartTemporaryDetach();
+        inOrder.verify(mController).onDetach();
+        mDraweeView.onFinishTemporaryDetach();
+        inOrder.verify(mController).onAttach();
+        mDraweeView.onDetachedFromWindow();
+        inOrder.verify(mController).onDetach();
+    }
+
+    @Test
+    public void testLifecycle_ControllerSetWhileAttached() {
+        InOrder inOrder = inOrder(mController);
+        mDraweeView.setHierarchy(mDraweeHierarchy);
+        mDraweeView.onAttachedToWindow();
+        mDraweeView.setController(mController);
+        inOrder.verify(mController).setHierarchy(mDraweeHierarchy);
+        inOrder.verify(mController).onAttach();
+        mDraweeView.onDetachedFromWindow();
+        inOrder.verify(mController).onDetach();
+    }
+
+    @Test
+    public void testLifecycle_NullController() {
+        mDraweeView.setHierarchy(mDraweeHierarchy);
+        mDraweeView.setController(null);
+        mDraweeView.onStartTemporaryDetach();
+        mDraweeView.onFinishTemporaryDetach();
+    }
+
+    @Test
+    public void testLifecycle_Drawable() {
+        mDraweeView.setImageDrawable(mDrawable);
+        mDraweeView.onStartTemporaryDetach();
+        mDraweeView.onFinishTemporaryDetach();
+    }
 }
diff --git a/drawee/src/test/java/com/facebook/drawee/view/MultiDraweeHolderTest.java b/drawee/src/test/java/com/facebook/drawee/view/MultiDraweeHolderTest.java
index 5f85480ac..74641f78f 100644
--- a/drawee/src/test/java/com/facebook/drawee/view/MultiDraweeHolderTest.java
+++ b/drawee/src/test/java/com/facebook/drawee/view/MultiDraweeHolderTest.java
@@ -28,200 +28,200 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class MultiDraweeHolderTest {
 
-  MultiDraweeHolder mMultiHolder;
-  DraweeHolder mHolder1;
-  DraweeHolder mHolder2;
-  DraweeHolder mHolder3;
-
-  @Before
-  public void setUp() {
-    mMultiHolder = new MultiDraweeHolder();
-    mHolder1 = mock(DraweeHolder.class);
-    mHolder2 = mock(DraweeHolder.class);
-    mHolder3 = mock(DraweeHolder.class);
-
-    mMultiHolder.add(mHolder1);
-    mMultiHolder.add(mHolder2);
-    mMultiHolder.add(mHolder3);
-  }
-
-  @Test
-  public void testAttaching() {
-    mMultiHolder.onAttach();
-    verify(mHolder1).onAttach();
-    verify(mHolder2).onAttach();
-    verify(mHolder3).onAttach();
-    mMultiHolder.onDetach();
-    verify(mHolder1).onDetach();
-    verify(mHolder2).onDetach();
-    verify(mHolder3).onDetach();
-  }
-
-  @Test
-  public void testTouchEvent_Handled() {
-    MotionEvent event = mock(MotionEvent.class);
-    when(mHolder1.onTouchEvent(event)).thenReturn(false);
-    when(mHolder2.onTouchEvent(event)).thenReturn(true);
-    when(mHolder3.onTouchEvent(event)).thenReturn(true);
-    boolean ret = mMultiHolder.onTouchEvent(event);
-    assertEquals(true, ret);
-    verify(mHolder1).onTouchEvent(event);
-    verify(mHolder2).onTouchEvent(event);
-    verify(mHolder3, never()).onTouchEvent(event);
-  }
-
-  @Test
-  public void testTouchEvent_NotHandled() {
-    MotionEvent event = mock(MotionEvent.class);
-    when(mHolder1.onTouchEvent(event)).thenReturn(false);
-    when(mHolder2.onTouchEvent(event)).thenReturn(false);
-    when(mHolder3.onTouchEvent(event)).thenReturn(false);
-    boolean ret = mMultiHolder.onTouchEvent(event);
-    assertEquals(false, ret);
-    verify(mHolder1).onTouchEvent(event);
-    verify(mHolder2).onTouchEvent(event);
-    verify(mHolder3).onTouchEvent(event);
-  }
-
-  @Test
-  public void testClear_Detached() {
-    assertEquals(3, mMultiHolder.mHolders.size());
-    mMultiHolder.clear();
-    assertTrue(mMultiHolder.mHolders.isEmpty());
-  }
-
-  @Test
-  public void testClear_Attached() {
-    mMultiHolder.onAttach();
-    reset(mHolder1, mHolder2, mHolder3);
-
-    assertEquals(3, mMultiHolder.mHolders.size());
-    mMultiHolder.clear();
-    assertTrue(mMultiHolder.mHolders.isEmpty());
-
-    verify(mHolder1).onDetach();
-    verify(mHolder2).onDetach();
-    verify(mHolder2).onDetach();
-  }
-
-  @Test
-  public void testAdd_Detached() {
-    mMultiHolder.clear();
-    reset(mHolder1, mHolder2, mHolder3);
-
-    assertEquals(0, mMultiHolder.mHolders.size());
-    mMultiHolder.add(mHolder1);
-    assertEquals(1, mMultiHolder.mHolders.size());
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    mMultiHolder.add(1, mHolder3);
-    assertEquals(2, mMultiHolder.mHolders.size());
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    assertEquals(mHolder3, mMultiHolder.mHolders.get(1));
-    mMultiHolder.add(1, mHolder2);
-    assertEquals(3, mMultiHolder.mHolders.size());
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    assertEquals(mHolder2, mMultiHolder.mHolders.get(1));
-    assertEquals(mHolder3, mMultiHolder.mHolders.get(2));
-
-    verify(mHolder1, never()).onAttach();
-    verify(mHolder2, never()).onAttach();
-    verify(mHolder3, never()).onAttach();
-  }
-
-  @Test
-  public void testAdd_Attached() {
-    mMultiHolder.clear();
-    mMultiHolder.onAttach();
-    reset(mHolder1, mHolder2, mHolder3);
-
-    assertEquals(0, mMultiHolder.mHolders.size());
-    mMultiHolder.add(mHolder1);
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    mMultiHolder.add(1, mHolder3);
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    assertEquals(mHolder3, mMultiHolder.mHolders.get(1));
-    mMultiHolder.add(1, mHolder2);
-    assertEquals(3, mMultiHolder.mHolders.size());
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    assertEquals(mHolder2, mMultiHolder.mHolders.get(1));
-    assertEquals(mHolder3, mMultiHolder.mHolders.get(2));
-
-    verify(mHolder1).onAttach();
-    verify(mHolder2).onAttach();
-    verify(mHolder3).onAttach();
-  }
-
-  @Test
-  public void testRemove_Detached() {
-    assertEquals(3, mMultiHolder.mHolders.size());
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    assertEquals(mHolder2, mMultiHolder.mHolders.get(1));
-    assertEquals(mHolder3, mMultiHolder.mHolders.get(2));
-    mMultiHolder.remove(1);
-    assertEquals(2, mMultiHolder.mHolders.size());
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    assertEquals(mHolder3, mMultiHolder.mHolders.get(1));
-    mMultiHolder.remove(1);
-    assertEquals(1, mMultiHolder.mHolders.size());
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    mMultiHolder.remove(0);
-    assertEquals(0, mMultiHolder.mHolders.size());
-  }
-
-  @Test
-  public void testRemove_attached() {
-    mMultiHolder.onAttach();
-    reset(mHolder1, mHolder2, mHolder3);
-
-    assertEquals(3, mMultiHolder.mHolders.size());
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    assertEquals(mHolder2, mMultiHolder.mHolders.get(1));
-    assertEquals(mHolder3, mMultiHolder.mHolders.get(2));
-    mMultiHolder.remove(1);
-    assertEquals(2, mMultiHolder.mHolders.size());
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    assertEquals(mHolder3, mMultiHolder.mHolders.get(1));
-    mMultiHolder.remove(1);
-    assertEquals(1, mMultiHolder.mHolders.size());
-    assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
-    mMultiHolder.remove(0);
-    assertEquals(0, mMultiHolder.mHolders.size());
-
-    verify(mHolder1).onDetach();
-    verify(mHolder2).onDetach();
-    verify(mHolder3).onDetach();
-  }
-
-  @Test
-  public void testGet() {
-    assertEquals(mHolder1, mMultiHolder.get(0));
-    assertEquals(mHolder2, mMultiHolder.get(1));
-    assertEquals(mHolder3, mMultiHolder.get(2));
-  }
-
-  @Test
-  public void testDraw() {
-    Canvas canvas = mock(Canvas.class);
-    Drawable drawable1 = mock(Drawable.class);
-    Drawable drawable2 = mock(Drawable.class);
-    Drawable drawable3 = mock(Drawable.class);
-    when(mHolder1.getTopLevelDrawable()).thenReturn(drawable1);
-    when(mHolder2.getTopLevelDrawable()).thenReturn(drawable2);
-    when(mHolder3.getTopLevelDrawable()).thenReturn(drawable3);
-
-    mMultiHolder.draw(canvas);
-
-    verify(drawable1).draw(canvas);
-    verify(drawable2).draw(canvas);
-    verify(drawable3).draw(canvas);
-  }
-
-  @Test
-  public void testVerifyDrawable() {
-    Drawable drawable1 = mock(Drawable.class);
-    Drawable drawable2 = mock(Drawable.class);
-    when(mHolder1.getTopLevelDrawable()).thenReturn(drawable1);
-    assertTrue(mMultiHolder.verifyDrawable(drawable1));
-    assertFalse(mMultiHolder.verifyDrawable(drawable2));
-  }
+    MultiDraweeHolder mMultiHolder;
+    DraweeHolder mHolder1;
+    DraweeHolder mHolder2;
+    DraweeHolder mHolder3;
+
+    @Before
+    public void setUp() {
+        mMultiHolder = new MultiDraweeHolder();
+        mHolder1 = mock(DraweeHolder.class);
+        mHolder2 = mock(DraweeHolder.class);
+        mHolder3 = mock(DraweeHolder.class);
+
+        mMultiHolder.add(mHolder1);
+        mMultiHolder.add(mHolder2);
+        mMultiHolder.add(mHolder3);
+    }
+
+    @Test
+    public void testAttaching() {
+        mMultiHolder.onAttach();
+        verify(mHolder1).onAttach();
+        verify(mHolder2).onAttach();
+        verify(mHolder3).onAttach();
+        mMultiHolder.onDetach();
+        verify(mHolder1).onDetach();
+        verify(mHolder2).onDetach();
+        verify(mHolder3).onDetach();
+    }
+
+    @Test
+    public void testTouchEvent_Handled() {
+        MotionEvent event = mock(MotionEvent.class);
+        when(mHolder1.onTouchEvent(event)).thenReturn(false);
+        when(mHolder2.onTouchEvent(event)).thenReturn(true);
+        when(mHolder3.onTouchEvent(event)).thenReturn(true);
+        boolean ret = mMultiHolder.onTouchEvent(event);
+        assertEquals(true, ret);
+        verify(mHolder1).onTouchEvent(event);
+        verify(mHolder2).onTouchEvent(event);
+        verify(mHolder3, never()).onTouchEvent(event);
+    }
+
+    @Test
+    public void testTouchEvent_NotHandled() {
+        MotionEvent event = mock(MotionEvent.class);
+        when(mHolder1.onTouchEvent(event)).thenReturn(false);
+        when(mHolder2.onTouchEvent(event)).thenReturn(false);
+        when(mHolder3.onTouchEvent(event)).thenReturn(false);
+        boolean ret = mMultiHolder.onTouchEvent(event);
+        assertEquals(false, ret);
+        verify(mHolder1).onTouchEvent(event);
+        verify(mHolder2).onTouchEvent(event);
+        verify(mHolder3).onTouchEvent(event);
+    }
+
+    @Test
+    public void testClear_Detached() {
+        assertEquals(3, mMultiHolder.mHolders.size());
+        mMultiHolder.clear();
+        assertTrue(mMultiHolder.mHolders.isEmpty());
+    }
+
+    @Test
+    public void testClear_Attached() {
+        mMultiHolder.onAttach();
+        reset(mHolder1, mHolder2, mHolder3);
+
+        assertEquals(3, mMultiHolder.mHolders.size());
+        mMultiHolder.clear();
+        assertTrue(mMultiHolder.mHolders.isEmpty());
+
+        verify(mHolder1).onDetach();
+        verify(mHolder2).onDetach();
+        verify(mHolder2).onDetach();
+    }
+
+    @Test
+    public void testAdd_Detached() {
+        mMultiHolder.clear();
+        reset(mHolder1, mHolder2, mHolder3);
+
+        assertEquals(0, mMultiHolder.mHolders.size());
+        mMultiHolder.add(mHolder1);
+        assertEquals(1, mMultiHolder.mHolders.size());
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        mMultiHolder.add(1, mHolder3);
+        assertEquals(2, mMultiHolder.mHolders.size());
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        assertEquals(mHolder3, mMultiHolder.mHolders.get(1));
+        mMultiHolder.add(1, mHolder2);
+        assertEquals(3, mMultiHolder.mHolders.size());
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        assertEquals(mHolder2, mMultiHolder.mHolders.get(1));
+        assertEquals(mHolder3, mMultiHolder.mHolders.get(2));
+
+        verify(mHolder1, never()).onAttach();
+        verify(mHolder2, never()).onAttach();
+        verify(mHolder3, never()).onAttach();
+    }
+
+    @Test
+    public void testAdd_Attached() {
+        mMultiHolder.clear();
+        mMultiHolder.onAttach();
+        reset(mHolder1, mHolder2, mHolder3);
+
+        assertEquals(0, mMultiHolder.mHolders.size());
+        mMultiHolder.add(mHolder1);
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        mMultiHolder.add(1, mHolder3);
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        assertEquals(mHolder3, mMultiHolder.mHolders.get(1));
+        mMultiHolder.add(1, mHolder2);
+        assertEquals(3, mMultiHolder.mHolders.size());
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        assertEquals(mHolder2, mMultiHolder.mHolders.get(1));
+        assertEquals(mHolder3, mMultiHolder.mHolders.get(2));
+
+        verify(mHolder1).onAttach();
+        verify(mHolder2).onAttach();
+        verify(mHolder3).onAttach();
+    }
+
+    @Test
+    public void testRemove_Detached() {
+        assertEquals(3, mMultiHolder.mHolders.size());
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        assertEquals(mHolder2, mMultiHolder.mHolders.get(1));
+        assertEquals(mHolder3, mMultiHolder.mHolders.get(2));
+        mMultiHolder.remove(1);
+        assertEquals(2, mMultiHolder.mHolders.size());
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        assertEquals(mHolder3, mMultiHolder.mHolders.get(1));
+        mMultiHolder.remove(1);
+        assertEquals(1, mMultiHolder.mHolders.size());
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        mMultiHolder.remove(0);
+        assertEquals(0, mMultiHolder.mHolders.size());
+    }
+
+    @Test
+    public void testRemove_attached() {
+        mMultiHolder.onAttach();
+        reset(mHolder1, mHolder2, mHolder3);
+
+        assertEquals(3, mMultiHolder.mHolders.size());
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        assertEquals(mHolder2, mMultiHolder.mHolders.get(1));
+        assertEquals(mHolder3, mMultiHolder.mHolders.get(2));
+        mMultiHolder.remove(1);
+        assertEquals(2, mMultiHolder.mHolders.size());
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        assertEquals(mHolder3, mMultiHolder.mHolders.get(1));
+        mMultiHolder.remove(1);
+        assertEquals(1, mMultiHolder.mHolders.size());
+        assertEquals(mHolder1, mMultiHolder.mHolders.get(0));
+        mMultiHolder.remove(0);
+        assertEquals(0, mMultiHolder.mHolders.size());
+
+        verify(mHolder1).onDetach();
+        verify(mHolder2).onDetach();
+        verify(mHolder3).onDetach();
+    }
+
+    @Test
+    public void testGet() {
+        assertEquals(mHolder1, mMultiHolder.get(0));
+        assertEquals(mHolder2, mMultiHolder.get(1));
+        assertEquals(mHolder3, mMultiHolder.get(2));
+    }
+
+    @Test
+    public void testDraw() {
+        Canvas canvas = mock(Canvas.class);
+        Drawable drawable1 = mock(Drawable.class);
+        Drawable drawable2 = mock(Drawable.class);
+        Drawable drawable3 = mock(Drawable.class);
+        when(mHolder1.getTopLevelDrawable()).thenReturn(drawable1);
+        when(mHolder2.getTopLevelDrawable()).thenReturn(drawable2);
+        when(mHolder3.getTopLevelDrawable()).thenReturn(drawable3);
+
+        mMultiHolder.draw(canvas);
+
+        verify(drawable1).draw(canvas);
+        verify(drawable2).draw(canvas);
+        verify(drawable3).draw(canvas);
+    }
+
+    @Test
+    public void testVerifyDrawable() {
+        Drawable drawable1 = mock(Drawable.class);
+        Drawable drawable2 = mock(Drawable.class);
+        when(mHolder1.getTopLevelDrawable()).thenReturn(drawable1);
+        assertTrue(mMultiHolder.verifyDrawable(drawable1));
+        assertFalse(mMultiHolder.verifyDrawable(drawable2));
+    }
 }
diff --git a/fbcore/AndroidManifest.xml b/fbcore/AndroidManifest.xml
index 0847879d3..0fd87cfe1 100644
--- a/fbcore/AndroidManifest.xml
+++ b/fbcore/AndroidManifest.xml
@@ -1,11 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook"
-    >
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook">
 
-  <uses-sdk
-      android:minSdkVersion="9"
-      android:targetSdkVersion="21"
-      />
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
 </manifest>
diff --git a/fbcore/build.gradle b/fbcore/build.gradle
index d972a583c..8a479254c 100644
--- a/fbcore/build.gradle
+++ b/fbcore/build.gradle
@@ -25,7 +25,6 @@ apply from: rootProject.file('release.gradle')
 
 def generatedTestSources = "$buildDir/generated-src/test"
 
-
 // Gradle and Buck need different versions of the test runner.
 // For gradle, WithTestDefaultsRunner just is a direct sub-class of RobolectricTestRunner.
 task generateTestSources {
@@ -35,14 +34,14 @@ task generateTestSources {
         def generated = new File(generatedTestSources, "WithTestDefaultsRunner.java")
         generated.text =
                 "package com.facebook.testing.robolectric.v2;\n" +
-                "import org.robolectric.RobolectricTestRunner;\n" +
-                "import org.junit.runners.model.InitializationError;\n" +
-                "public class WithTestDefaultsRunner extends RobolectricTestRunner {\n" +
-                "  public WithTestDefaultsRunner(final Class<?> testClass) " +
+                        "import org.robolectric.RobolectricTestRunner;\n" +
+                        "import org.junit.runners.model.InitializationError;\n" +
+                        "public class WithTestDefaultsRunner extends RobolectricTestRunner {\n" +
+                        "  public WithTestDefaultsRunner(final Class<?> testClass) " +
                         "throws InitializationError {" +
-                "    super(testClass);" +
-                "  }" +
-                "}"
+                        "    super(testClass);" +
+                        "  }" +
+                        "}"
     }
 }
 
@@ -53,12 +52,12 @@ android {
     compileSdkVersion 21
 
     packagingOptions {
-      exclude 'LICENSE'
-      exclude 'LICENSE.txt'
-      exclude 'META-INF/LICENSE'
-      exclude 'META-INF/LICENSE.txt'
-      exclude 'META-INF/NOTICE'
-      exclude 'META-INF/NOTICE.txt'
+        exclude 'LICENSE'
+        exclude 'LICENSE.txt'
+        exclude 'META-INF/LICENSE'
+        exclude 'META-INF/LICENSE.txt'
+        exclude 'META-INF/NOTICE'
+        exclude 'META-INF/NOTICE.txt'
     }
 }
 
diff --git a/fbcore/src/main/AndroidManifest.xml b/fbcore/src/main/AndroidManifest.xml
index 397f6ad20..fa5be79eb 100644
--- a/fbcore/src/main/AndroidManifest.xml
+++ b/fbcore/src/main/AndroidManifest.xml
@@ -1,11 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook.fbcore"
-    >
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.fbcore">
 
-  <uses-sdk
-      android:minSdkVersion="9"
-      android:targetSdkVersion="21"
-      />
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
 </manifest>
diff --git a/fbcore/src/main/java/com/facebook/common/activitylistener/ActivityListener.java b/fbcore/src/main/java/com/facebook/common/activitylistener/ActivityListener.java
index 0a30683cf..a57cc08ad 100644
--- a/fbcore/src/main/java/com/facebook/common/activitylistener/ActivityListener.java
+++ b/fbcore/src/main/java/com/facebook/common/activitylistener/ActivityListener.java
@@ -19,46 +19,46 @@
  */
 public interface ActivityListener {
 
-  /**
-   * Called by the Activity base class after the Activity's <code>onActivityCreate</code>
-   * method has run.
-   *
-   * @param activity the activity
-   */
-  void onActivityCreate(Activity activity);
+    /**
+     * Called by the Activity base class after the Activity's <code>onActivityCreate</code>
+     * method has run.
+     *
+     * @param activity the activity
+     */
+    void onActivityCreate(Activity activity);
 
-  /**
-   * Called by the Activity base class from the {@link Activity#onStart} method.
-   *
-   * @param activity the activity
-   */
-  void onStart(Activity activity);
+    /**
+     * Called by the Activity base class from the {@link Activity#onStart} method.
+     *
+     * @param activity the activity
+     */
+    void onStart(Activity activity);
 
-  /**
-   * Called by the Activity base class from the {@link Activity#onResume} method.
-   *
-   * @param activity the activity
-   */
-  void onResume(Activity activity);
+    /**
+     * Called by the Activity base class from the {@link Activity#onResume} method.
+     *
+     * @param activity the activity
+     */
+    void onResume(Activity activity);
 
-  /**
-   * Called by the Activity base class from the {@link Activity#onPause} method.
-   *
-   * @param activity the activity
-   */
-  void onPause(Activity activity);
+    /**
+     * Called by the Activity base class from the {@link Activity#onPause} method.
+     *
+     * @param activity the activity
+     */
+    void onPause(Activity activity);
 
-  /**
-   * Called by the Activity base class from the {@link Activity#onStop} method.
-   *
-   * @param activity the activity
-   */
-  void onStop(Activity activity);
+    /**
+     * Called by the Activity base class from the {@link Activity#onStop} method.
+     *
+     * @param activity the activity
+     */
+    void onStop(Activity activity);
 
-  /**
-   * Called by the Activity base class from the {@link Activity#onDestroy} method.
-   *
-   * @param activity the activity
-   */
-  void onDestroy(Activity activity);
+    /**
+     * Called by the Activity base class from the {@link Activity#onDestroy} method.
+     *
+     * @param activity the activity
+     */
+    void onDestroy(Activity activity);
 }
diff --git a/fbcore/src/main/java/com/facebook/common/activitylistener/ActivityListenerManager.java b/fbcore/src/main/java/com/facebook/common/activitylistener/ActivityListenerManager.java
index b3be1cdc6..c2b177714 100644
--- a/fbcore/src/main/java/com/facebook/common/activitylistener/ActivityListenerManager.java
+++ b/fbcore/src/main/java/com/facebook/common/activitylistener/ActivityListenerManager.java
@@ -19,92 +19,92 @@
 
 /**
  * Registers ActivityListener with ActivityListener.
- *
+ * <p>
  * <p> A WeakReference is used to wrap an ActivityVisibilityListener. When it is nullified
  * ActivityListener is automatically removed from the listened ListenableActivity.
  */
 public class ActivityListenerManager {
 
-  /**
-   * If given context is an instance of ListenableActivity then creates new instance of
-   * WeakReferenceActivityListenerAdapter and adds it to activity's listeners
-   */
-  public static void register(
-      ActivityListener activityListener,
-      Context context) {
-    if (!(context instanceof ListenableActivity) && context instanceof ContextWrapper) {
-      context = ((ContextWrapper) context).getBaseContext();
-    }
-    if (context instanceof ListenableActivity) {
-      ListenableActivity listenableActivity = (ListenableActivity) context;
-      Listener listener = new Listener(activityListener);
-      listenableActivity.addActivityListener(listener);
+    /**
+     * If given context is an instance of ListenableActivity then creates new instance of
+     * WeakReferenceActivityListenerAdapter and adds it to activity's listeners
+     */
+    public static void register(
+            ActivityListener activityListener,
+            Context context) {
+        if (!(context instanceof ListenableActivity) && context instanceof ContextWrapper) {
+            context = ((ContextWrapper) context).getBaseContext();
+        }
+        if (context instanceof ListenableActivity) {
+            ListenableActivity listenableActivity = (ListenableActivity) context;
+            Listener listener = new Listener(activityListener);
+            listenableActivity.addActivityListener(listener);
+        }
     }
-  }
 
-  private static class Listener extends BaseActivityListener {
-    private final WeakReference<ActivityListener> mActivityListenerRef;
+    private static class Listener extends BaseActivityListener {
+        private final WeakReference<ActivityListener> mActivityListenerRef;
 
-    public Listener(ActivityListener activityListener) {
-      mActivityListenerRef = new WeakReference<ActivityListener>(activityListener);
-    }
+        public Listener(ActivityListener activityListener) {
+            mActivityListenerRef = new WeakReference<ActivityListener>(activityListener);
+        }
 
-    @Override
-    public void onActivityCreate(Activity activity) {
-      ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
-      if (activityVisibilityListener != null) {
-        activityVisibilityListener.onActivityCreate(activity);
-      }
-    }
+        @Override
+        public void onActivityCreate(Activity activity) {
+            ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
+            if (activityVisibilityListener != null) {
+                activityVisibilityListener.onActivityCreate(activity);
+            }
+        }
 
-    @Override
-    public void onDestroy(Activity activity) {
-      ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
-      if (activityVisibilityListener != null) {
-        activityVisibilityListener.onDestroy(activity);
-      }
-    }
+        @Override
+        public void onDestroy(Activity activity) {
+            ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
+            if (activityVisibilityListener != null) {
+                activityVisibilityListener.onDestroy(activity);
+            }
+        }
 
-    @Override
-    public void onStart(Activity activity) {
-      ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
-      if (activityVisibilityListener != null) {
-        activityVisibilityListener.onStart(activity);
-      }
-    }
+        @Override
+        public void onStart(Activity activity) {
+            ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
+            if (activityVisibilityListener != null) {
+                activityVisibilityListener.onStart(activity);
+            }
+        }
 
-    @Override
-    public void onStop(Activity activity) {
-      ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
-      if (activityVisibilityListener != null) {
-        activityVisibilityListener.onStop(activity);
-      }
-    }
+        @Override
+        public void onStop(Activity activity) {
+            ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
+            if (activityVisibilityListener != null) {
+                activityVisibilityListener.onStop(activity);
+            }
+        }
 
-    @Override
-    public void onResume(Activity activity) {
-      ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
-      if (activityVisibilityListener != null) {
-        activityVisibilityListener.onResume(activity);
-      }
-    }
+        @Override
+        public void onResume(Activity activity) {
+            ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
+            if (activityVisibilityListener != null) {
+                activityVisibilityListener.onResume(activity);
+            }
+        }
 
-    @Override
-    public void onPause(Activity activity) {
-      ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
-      if (activityVisibilityListener != null) {
-        activityVisibilityListener.onPause(activity);
-      }
-    }
+        @Override
+        public void onPause(Activity activity) {
+            ActivityListener activityVisibilityListener = getListenerOrCleanUp(activity);
+            if (activityVisibilityListener != null) {
+                activityVisibilityListener.onPause(activity);
+            }
+        }
 
-    private ActivityListener getListenerOrCleanUp(Activity activity) {
-      ActivityListener activityVisibilityListener = mActivityListenerRef.get();
-      if (activityVisibilityListener == null) {
-        Preconditions.checkArgument(activity instanceof ListenableActivity);
-        ListenableActivity listenableActivity = (ListenableActivity) activity;
-        listenableActivity.removeActivityListener(this);
-      }
-      return activityVisibilityListener;
+        private ActivityListener getListenerOrCleanUp(Activity activity) {
+            ActivityListener activityVisibilityListener = mActivityListenerRef.get();
+            if (activityVisibilityListener == null) {
+                Preconditions.checkArgument(activity instanceof ListenableActivity);
+                ListenableActivity listenableActivity = (ListenableActivity) activity;
+                listenableActivity.removeActivityListener(this);
+            }
+            return activityVisibilityListener;
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/activitylistener/BaseActivityListener.java b/fbcore/src/main/java/com/facebook/common/activitylistener/BaseActivityListener.java
index 2949fb22f..cbaed5392 100644
--- a/fbcore/src/main/java/com/facebook/common/activitylistener/BaseActivityListener.java
+++ b/fbcore/src/main/java/com/facebook/common/activitylistener/BaseActivityListener.java
@@ -13,27 +13,27 @@
 
 public class BaseActivityListener implements ActivityListener {
 
-  @Override
-  public void onActivityCreate(Activity activity) {
-  }
+    @Override
+    public void onActivityCreate(Activity activity) {
+    }
 
-  @Override
-  public void onStop(Activity activity) {
-  }
+    @Override
+    public void onStop(Activity activity) {
+    }
 
-  @Override
-  public void onStart(Activity activity) {
-  }
+    @Override
+    public void onStart(Activity activity) {
+    }
 
-  @Override
-  public void onDestroy(Activity activity) {
-  }
+    @Override
+    public void onDestroy(Activity activity) {
+    }
 
-  @Override
-  public void onPause(Activity activity) {
-  }
+    @Override
+    public void onPause(Activity activity) {
+    }
 
-  @Override
-  public void onResume(Activity activity) {
-  }
+    @Override
+    public void onResume(Activity activity) {
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/activitylistener/ListenableActivity.java b/fbcore/src/main/java/com/facebook/common/activitylistener/ListenableActivity.java
index ecd498f4d..83928dd0d 100644
--- a/fbcore/src/main/java/com/facebook/common/activitylistener/ListenableActivity.java
+++ b/fbcore/src/main/java/com/facebook/common/activitylistener/ListenableActivity.java
@@ -14,17 +14,17 @@
  */
 public interface ListenableActivity {
 
-  /**
-   * Adds ActivityListener to the activity
-   *
-   * @param listener
-   */
-  public void addActivityListener(ActivityListener listener);
+    /**
+     * Adds ActivityListener to the activity
+     *
+     * @param listener
+     */
+    public void addActivityListener(ActivityListener listener);
 
-  /**
-   * Removes ActivityListener from the activity
-   *
-   * @param listener
-   */
-  public void removeActivityListener(ActivityListener listener);
+    /**
+     * Removes ActivityListener from the activity
+     *
+     * @param listener
+     */
+    public void removeActivityListener(ActivityListener listener);
 }
diff --git a/fbcore/src/main/java/com/facebook/common/disk/DiskTrimmable.java b/fbcore/src/main/java/com/facebook/common/disk/DiskTrimmable.java
index 2d0fef7a6..71255635f 100644
--- a/fbcore/src/main/java/com/facebook/common/disk/DiskTrimmable.java
+++ b/fbcore/src/main/java/com/facebook/common/disk/DiskTrimmable.java
@@ -13,13 +13,13 @@
  * Any class that uses a lot of disk space and should implement this interface.
  */
 public interface DiskTrimmable {
-  /**
-   * Called when there is very little disk space left.
-   */
-  public void trimToMinimum();
+    /**
+     * Called when there is very little disk space left.
+     */
+    public void trimToMinimum();
 
-  /**
-   * Called when there is almost no disk space left and the app is likely to crash soon
-   */
-  public void trimToNothing();
+    /**
+     * Called when there is almost no disk space left and the app is likely to crash soon
+     */
+    public void trimToNothing();
 }
diff --git a/fbcore/src/main/java/com/facebook/common/disk/DiskTrimmableRegistry.java b/fbcore/src/main/java/com/facebook/common/disk/DiskTrimmableRegistry.java
index 18b81b2e7..c0bb46c0e 100644
--- a/fbcore/src/main/java/com/facebook/common/disk/DiskTrimmableRegistry.java
+++ b/fbcore/src/main/java/com/facebook/common/disk/DiskTrimmableRegistry.java
@@ -11,18 +11,22 @@
 
 /**
  * A class which keeps a list of other classes to be notified of system disk events.
- *
+ * <p>
  * <p>If a class uses a lot of disk space and needs these notices from the system, it should
  * implement the {@link DiskTrimmable} interface.
- *
+ * <p>
  * <p>Implementations of this class should notify all the trimmables that have registered with it
  * when they need to trim their disk usage.
  */
 public interface DiskTrimmableRegistry {
 
-  /** Register an object. */
-  void registerDiskTrimmable(DiskTrimmable trimmable);
+    /**
+     * Register an object.
+     */
+    void registerDiskTrimmable(DiskTrimmable trimmable);
 
-  /** Unregister an object. */
-  void unregisterDiskTrimmable(DiskTrimmable trimmable);
+    /**
+     * Unregister an object.
+     */
+    void unregisterDiskTrimmable(DiskTrimmable trimmable);
 }
diff --git a/fbcore/src/main/java/com/facebook/common/disk/NoOpDiskTrimmableRegistry.java b/fbcore/src/main/java/com/facebook/common/disk/NoOpDiskTrimmableRegistry.java
index f4b24d5e5..b5cbee361 100644
--- a/fbcore/src/main/java/com/facebook/common/disk/NoOpDiskTrimmableRegistry.java
+++ b/fbcore/src/main/java/com/facebook/common/disk/NoOpDiskTrimmableRegistry.java
@@ -13,23 +13,23 @@
  * Implementation of {@link DiskTrimmableRegistry} that does not do anything.
  */
 public class NoOpDiskTrimmableRegistry implements DiskTrimmableRegistry {
-  private static NoOpDiskTrimmableRegistry sInstance = null;
+    private static NoOpDiskTrimmableRegistry sInstance = null;
 
-  private NoOpDiskTrimmableRegistry() {
-  }
+    private NoOpDiskTrimmableRegistry() {
+    }
 
-  public static synchronized NoOpDiskTrimmableRegistry getInstance() {
-    if (sInstance == null) {
-      sInstance = new NoOpDiskTrimmableRegistry();
+    public static synchronized NoOpDiskTrimmableRegistry getInstance() {
+        if (sInstance == null) {
+            sInstance = new NoOpDiskTrimmableRegistry();
+        }
+        return sInstance;
     }
-    return sInstance;
-  }
 
-  @Override
-  public void registerDiskTrimmable(DiskTrimmable trimmable) {
-  }
+    @Override
+    public void registerDiskTrimmable(DiskTrimmable trimmable) {
+    }
 
-  @Override
-  public void unregisterDiskTrimmable(DiskTrimmable trimmable) {
-  }
+    @Override
+    public void unregisterDiskTrimmable(DiskTrimmable trimmable) {
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/executors/CallerThreadExecutor.java b/fbcore/src/main/java/com/facebook/common/executors/CallerThreadExecutor.java
index e2c5a3f67..9c87e6d9a 100644
--- a/fbcore/src/main/java/com/facebook/common/executors/CallerThreadExecutor.java
+++ b/fbcore/src/main/java/com/facebook/common/executors/CallerThreadExecutor.java
@@ -16,62 +16,62 @@
 
 /**
  * An executor service that runs each task in the thread that invokes {@code execute/submit}.
- *
+ * <p>
  * <p> This applies both to individually submitted tasks and to collections of tasks submitted via
  * {@code invokeAll} or {@code invokeAny}. In the latter case, tasks will run serially on the
  * calling thread. Tasks are run to completion before a {@code Future} is returned to the caller.
- *
+ * <p>
  * <p> The implementation deviates from the {@code ExecutorService} specification with regards to
  * the {@code shutdownNow} and {@code awaitTermination} methods.
  * 1. A call to {@code shutdown} or {@code shutdownNow} is a no-op. A call to {@code isTerminated}
- *    always returns false.
+ * always returns false.
  * 2. A call to {@code awaitTermination} always returns true immediately. True is returned in order
- *    to avoid potential infinite loop in the clients.
+ * to avoid potential infinite loop in the clients.
  * 3. "best-effort" with regards to canceling running tasks is implemented as "no-effort".
- *    No interrupts or other attempts are made to stop threads executing tasks.
+ * No interrupts or other attempts are made to stop threads executing tasks.
  * 4. The returned list will always be empty, as any submitted task is considered to have started
- *    execution. This applies also to tasks given to {@code invokeAll} or {@code invokeAny} which
- *    are pending serial execution, including the tasks that have not yet started execution.
+ * execution. This applies also to tasks given to {@code invokeAll} or {@code invokeAny} which
+ * are pending serial execution, including the tasks that have not yet started execution.
  */
 public class CallerThreadExecutor extends AbstractExecutorService {
 
-  private static final CallerThreadExecutor sInstance = new CallerThreadExecutor();
+    private static final CallerThreadExecutor sInstance = new CallerThreadExecutor();
 
-  public static CallerThreadExecutor getInstance() {
-    return sInstance;
-  }
+    public static CallerThreadExecutor getInstance() {
+        return sInstance;
+    }
 
-  private CallerThreadExecutor() {
-  }
+    private CallerThreadExecutor() {
+    }
 
-  @Override
-  public void execute(Runnable command) {
-    command.run();
-  }
+    @Override
+    public void execute(Runnable command) {
+        command.run();
+    }
 
-  @Override
-  public boolean isShutdown() {
-    return false;
-  }
+    @Override
+    public boolean isShutdown() {
+        return false;
+    }
 
-  @Override
-  public void shutdown() {
-    // no-op
-  }
+    @Override
+    public void shutdown() {
+        // no-op
+    }
 
-  @Override
-  public List<Runnable> shutdownNow() {
-    shutdown();
-    return Collections.emptyList();
-  }
+    @Override
+    public List<Runnable> shutdownNow() {
+        shutdown();
+        return Collections.emptyList();
+    }
 
-  @Override
-  public boolean isTerminated() {
-    return false;
-  }
+    @Override
+    public boolean isTerminated() {
+        return false;
+    }
 
-  @Override
-  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-    return true;
-  }
+    @Override
+    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
+        return true;
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/executors/ConstrainedExecutorService.java b/fbcore/src/main/java/com/facebook/common/executors/ConstrainedExecutorService.java
index eab938170..35dbb9e61 100644
--- a/fbcore/src/main/java/com/facebook/common/executors/ConstrainedExecutorService.java
+++ b/fbcore/src/main/java/com/facebook/common/executors/ConstrainedExecutorService.java
@@ -27,168 +27,172 @@
  */
 public class ConstrainedExecutorService extends AbstractExecutorService {
 
-  private static final Class<?> TAG = ConstrainedExecutorService.class;
-
-  private final String mName;
-  private final Executor mExecutor;
-  private volatile int mMaxConcurrency;
-  private final BlockingQueue<Runnable> mWorkQueue;
-
-  private final Worker mTaskRunner;
-  private final AtomicInteger mPendingWorkers;
-  private final AtomicInteger mMaxQueueSize;
-
-  /**
-   * Creates a new {@code ConstrainedExecutorService}.
-   * @param name Friendly name to identify the executor in logging and reporting.
-   * @param maxConcurrency Maximum number of tasks to execute in parallel on the delegate executor.
-   * @param executor Delegate executor for actually running tasks.
-   * @param workQueue Queue to hold {@link Runnable}s for eventual execution.
-   */
-  public ConstrainedExecutorService(
-      String name,
-      int maxConcurrency,
-      Executor executor,
-      BlockingQueue<Runnable> workQueue) {
-    if (maxConcurrency <= 0) {
-      throw new IllegalArgumentException("max concurrency must be > 0");
-    }
-    mName = name;
-    mExecutor = executor;
-    mMaxConcurrency = maxConcurrency;
-    mWorkQueue = workQueue;
-    mTaskRunner = new Worker();
-    mPendingWorkers = new AtomicInteger(0);
-    mMaxQueueSize = new AtomicInteger(0);
-  }
-
-  /**
-   * Factory method to create a new {@code ConstrainedExecutorService} with an unbounded
-   * {@link LinkedBlockingQueue} queue.
-   * @param name Friendly name to identify the executor in logging and reporting.
-   * @param maxConcurrency Maximum number of tasks to execute in parallel on the delegate executor.
-   * @param queueSize Number of items that can be queued before new submissions are rejected.
-   * @param executor Delegate executor for actually running tasks.
-   * @return new {@code ConstrainedExecutorService} instance.
-   */
-  public static ConstrainedExecutorService newConstrainedExecutor(
-      String name,
-      int maxConcurrency,
-      int queueSize,
-      Executor executor) {
-    return new ConstrainedExecutorService(
-        name,
-        maxConcurrency,
-        executor,
-        new LinkedBlockingQueue<Runnable>(queueSize));
-  }
-
-  /**
-   * Determine whether or not the queue is idle.
-   * @return true if there is no work being executed and the work queue is empty, false otherwise.
-   */
-  public boolean isIdle() {
-    return mWorkQueue.isEmpty() && (mPendingWorkers.get() == 0);
-  }
-
-  /**
-   * Submit a task to be executed in the future.
-   * @param runnable The task to be executed.
-   */
-  @Override
-  public void execute(Runnable runnable) {
-    if (runnable == null) {
-      throw new NullPointerException("runnable parameter is null");
+    private static final Class<?> TAG = ConstrainedExecutorService.class;
+
+    private final String mName;
+    private final Executor mExecutor;
+    private volatile int mMaxConcurrency;
+    private final BlockingQueue<Runnable> mWorkQueue;
+
+    private final Worker mTaskRunner;
+    private final AtomicInteger mPendingWorkers;
+    private final AtomicInteger mMaxQueueSize;
+
+    /**
+     * Creates a new {@code ConstrainedExecutorService}.
+     *
+     * @param name           Friendly name to identify the executor in logging and reporting.
+     * @param maxConcurrency Maximum number of tasks to execute in parallel on the delegate executor.
+     * @param executor       Delegate executor for actually running tasks.
+     * @param workQueue      Queue to hold {@link Runnable}s for eventual execution.
+     */
+    public ConstrainedExecutorService(
+            String name,
+            int maxConcurrency,
+            Executor executor,
+            BlockingQueue<Runnable> workQueue) {
+        if (maxConcurrency <= 0) {
+            throw new IllegalArgumentException("max concurrency must be > 0");
+        }
+        mName = name;
+        mExecutor = executor;
+        mMaxConcurrency = maxConcurrency;
+        mWorkQueue = workQueue;
+        mTaskRunner = new Worker();
+        mPendingWorkers = new AtomicInteger(0);
+        mMaxQueueSize = new AtomicInteger(0);
     }
 
-    if (!mWorkQueue.offer(runnable)) {
-      throw new RejectedExecutionException(
-          mName + " queue is full, size=" + mWorkQueue.size());
+    /**
+     * Factory method to create a new {@code ConstrainedExecutorService} with an unbounded
+     * {@link LinkedBlockingQueue} queue.
+     *
+     * @param name           Friendly name to identify the executor in logging and reporting.
+     * @param maxConcurrency Maximum number of tasks to execute in parallel on the delegate executor.
+     * @param queueSize      Number of items that can be queued before new submissions are rejected.
+     * @param executor       Delegate executor for actually running tasks.
+     * @return new {@code ConstrainedExecutorService} instance.
+     */
+    public static ConstrainedExecutorService newConstrainedExecutor(
+            String name,
+            int maxConcurrency,
+            int queueSize,
+            Executor executor) {
+        return new ConstrainedExecutorService(
+                name,
+                maxConcurrency,
+                executor,
+                new LinkedBlockingQueue<Runnable>(queueSize));
     }
 
-    final int queueSize = mWorkQueue.size();
-    final int maxSize = mMaxQueueSize.get();
-    if ((queueSize > maxSize) && mMaxQueueSize.compareAndSet(maxSize, queueSize)) {
-      FLog.v(TAG, "%s: max pending work in queue = %d", mName, queueSize);
-    } // else, there was a race and another thread updated and logged the max queue size
-
-    startWorkerIfNeeded();
-  }
-
-  /**
-   * Submits the single {@code Worker} instance {@code mTaskRunner} to the underlying executor an
-   * additional time if there are fewer than {@code mMaxConcurrency} pending submissions. Does
-   * nothing if the maximum number of workers is already pending.
-   */
-  private void startWorkerIfNeeded() {
-    // Perform a compare-and-swap retry loop for synchronization to make sure we don't start more
-    // workers than desired.
-    int currentCount = mPendingWorkers.get();
-    while (currentCount < mMaxConcurrency) {
-      int updatedCount = currentCount + 1;
-      if (mPendingWorkers.compareAndSet(currentCount, updatedCount)) {
-        // Start a new worker.
-        FLog.v(TAG, "%s: starting worker %d of %d", mName, updatedCount, mMaxConcurrency);
-        mExecutor.execute(mTaskRunner);
-        break;
-      }
-      // else: compareAndSet failed due to race; snapshot the new count and try again
-      FLog.v(TAG, "%s: race in startWorkerIfNeeded; retrying", mName);
-      currentCount = mPendingWorkers.get();
+    /**
+     * Determine whether or not the queue is idle.
+     *
+     * @return true if there is no work being executed and the work queue is empty, false otherwise.
+     */
+    public boolean isIdle() {
+        return mWorkQueue.isEmpty() && (mPendingWorkers.get() == 0);
     }
-  }
-
-  @Override
-  public void shutdown() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public List<Runnable> shutdownNow() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean isShutdown() {
-    return false;
-  }
-
-  @Override
-  public boolean isTerminated() {
-    return false;
-  }
-
-  @Override
-  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-    throw new UnsupportedOperationException();
-  }
-
-  /**
-   * Private worker class that removes one task from the work queue and runs it. This class
-   * maintains no state of its own, so a single instance may be submitted to an executor
-   * multiple times.
-   */
-  private class Worker implements Runnable {
 
+    /**
+     * Submit a task to be executed in the future.
+     *
+     * @param runnable The task to be executed.
+     */
     @Override
-    public void run() {
-      try {
-        Runnable runnable = mWorkQueue.poll();
-        if (runnable != null) {
-          runnable.run();
-        } else {
-          // It is possible that a new worker was started before a previously started worker
-          // de-queued its work item.
-          FLog.v(TAG, "%s: Worker has nothing to run", mName);
+    public void execute(Runnable runnable) {
+        if (runnable == null) {
+            throw new NullPointerException("runnable parameter is null");
+        }
+
+        if (!mWorkQueue.offer(runnable)) {
+            throw new RejectedExecutionException(
+                    mName + " queue is full, size=" + mWorkQueue.size());
         }
-      } finally {
-        int workers = mPendingWorkers.decrementAndGet();
-        if (!mWorkQueue.isEmpty()) {
-          startWorkerIfNeeded();
-        } else {
-          FLog.v(TAG, "%s: worker finished; %d workers left", mName, workers);
+
+        final int queueSize = mWorkQueue.size();
+        final int maxSize = mMaxQueueSize.get();
+        if ((queueSize > maxSize) && mMaxQueueSize.compareAndSet(maxSize, queueSize)) {
+            FLog.v(TAG, "%s: max pending work in queue = %d", mName, queueSize);
+        } // else, there was a race and another thread updated and logged the max queue size
+
+        startWorkerIfNeeded();
+    }
+
+    /**
+     * Submits the single {@code Worker} instance {@code mTaskRunner} to the underlying executor an
+     * additional time if there are fewer than {@code mMaxConcurrency} pending submissions. Does
+     * nothing if the maximum number of workers is already pending.
+     */
+    private void startWorkerIfNeeded() {
+        // Perform a compare-and-swap retry loop for synchronization to make sure we don't start more
+        // workers than desired.
+        int currentCount = mPendingWorkers.get();
+        while (currentCount < mMaxConcurrency) {
+            int updatedCount = currentCount + 1;
+            if (mPendingWorkers.compareAndSet(currentCount, updatedCount)) {
+                // Start a new worker.
+                FLog.v(TAG, "%s: starting worker %d of %d", mName, updatedCount, mMaxConcurrency);
+                mExecutor.execute(mTaskRunner);
+                break;
+            }
+            // else: compareAndSet failed due to race; snapshot the new count and try again
+            FLog.v(TAG, "%s: race in startWorkerIfNeeded; retrying", mName);
+            currentCount = mPendingWorkers.get();
+        }
+    }
+
+    @Override
+    public void shutdown() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public List<Runnable> shutdownNow() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isShutdown() {
+        return false;
+    }
+
+    @Override
+    public boolean isTerminated() {
+        return false;
+    }
+
+    @Override
+    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Private worker class that removes one task from the work queue and runs it. This class
+     * maintains no state of its own, so a single instance may be submitted to an executor
+     * multiple times.
+     */
+    private class Worker implements Runnable {
+
+        @Override
+        public void run() {
+            try {
+                Runnable runnable = mWorkQueue.poll();
+                if (runnable != null) {
+                    runnable.run();
+                } else {
+                    // It is possible that a new worker was started before a previously started worker
+                    // de-queued its work item.
+                    FLog.v(TAG, "%s: Worker has nothing to run", mName);
+                }
+            } finally {
+                int workers = mPendingWorkers.decrementAndGet();
+                if (!mWorkQueue.isEmpty()) {
+                    startWorkerIfNeeded();
+                } else {
+                    FLog.v(TAG, "%s: worker finished; %d workers left", mName, workers);
+                }
+            }
         }
-      }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/executors/DefaultSerialExecutorService.java b/fbcore/src/main/java/com/facebook/common/executors/DefaultSerialExecutorService.java
index 73b0f1f0a..b8d7b3db3 100644
--- a/fbcore/src/main/java/com/facebook/common/executors/DefaultSerialExecutorService.java
+++ b/fbcore/src/main/java/com/facebook/common/executors/DefaultSerialExecutorService.java
@@ -16,21 +16,22 @@
  * Default implementation of {@link SerialExecutorService} that wraps an existing {@link Executor}.
  */
 public class DefaultSerialExecutorService extends ConstrainedExecutorService
-    implements SerialExecutorService {
+        implements SerialExecutorService {
 
-  public DefaultSerialExecutorService(Executor executor) {
-    // SerialExecutorService is just a ConstrainedExecutorService with a concurrency limit
-    // of one and an unbounded work queue.
-    super("SerialExecutor", 1, executor, new LinkedBlockingQueue<Runnable>());
-  }
+    public DefaultSerialExecutorService(Executor executor) {
+        // SerialExecutorService is just a ConstrainedExecutorService with a concurrency limit
+        // of one and an unbounded work queue.
+        super("SerialExecutor", 1, executor, new LinkedBlockingQueue<Runnable>());
+    }
 
-  /**
-   * Synchronized override of {@link ConstrainedExecutorService#execute(Runnable)} to
-   * ensure that view of memory is consistent between different threads executing tasks serially.
-   * @param runnable The task to be executed.
-   */
-  @Override
-  public synchronized void execute(Runnable runnable) {
-    super.execute(runnable);
-  }
+    /**
+     * Synchronized override of {@link ConstrainedExecutorService#execute(Runnable)} to
+     * ensure that view of memory is consistent between different threads executing tasks serially.
+     *
+     * @param runnable The task to be executed.
+     */
+    @Override
+    public synchronized void execute(Runnable runnable) {
+        super.execute(runnable);
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/executors/HandlerExecutorService.java b/fbcore/src/main/java/com/facebook/common/executors/HandlerExecutorService.java
index cdf978de9..e6f97d8ec 100644
--- a/fbcore/src/main/java/com/facebook/common/executors/HandlerExecutorService.java
+++ b/fbcore/src/main/java/com/facebook/common/executors/HandlerExecutorService.java
@@ -17,13 +17,13 @@
  */
 public interface HandlerExecutorService extends ScheduledExecutorService {
 
-  /**
-   * Quit the handler
-   */
-  void quit();
+    /**
+     * Quit the handler
+     */
+    void quit();
 
-  /**
-   * Check if we are currently in the handler thread of this HandlerExecutorService.
-   */
-  boolean isHandlerThread();
+    /**
+     * Check if we are currently in the handler thread of this HandlerExecutorService.
+     */
+    boolean isHandlerThread();
 }
diff --git a/fbcore/src/main/java/com/facebook/common/executors/HandlerExecutorServiceImpl.java b/fbcore/src/main/java/com/facebook/common/executors/HandlerExecutorServiceImpl.java
index e82547801..fe544302a 100644
--- a/fbcore/src/main/java/com/facebook/common/executors/HandlerExecutorServiceImpl.java
+++ b/fbcore/src/main/java/com/facebook/common/executors/HandlerExecutorServiceImpl.java
@@ -23,108 +23,108 @@
  * A {@link HandlerExecutorService} implementation.
  */
 public class HandlerExecutorServiceImpl extends AbstractExecutorService
-    implements HandlerExecutorService {
-
-  private final Handler mHandler;
-
-  public HandlerExecutorServiceImpl(Handler handler) {
-    mHandler = handler;
-  }
-
-  @Override
-  public void shutdown() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public List<Runnable> shutdownNow() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean isShutdown() {
-    return false;
-  }
-
-  @Override
-  public boolean isTerminated() {
-    return false;
-  }
-
-  @Override
-  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void execute(Runnable command) {
-    mHandler.post(command);
-  }
-
-  @Override
-  protected <T> ScheduledFutureImpl<T> newTaskFor(Runnable runnable, T value) {
-    return new ScheduledFutureImpl<T>(mHandler, runnable, value);
-  }
-
-  @Override
-  protected <T> ScheduledFutureImpl<T> newTaskFor(Callable<T> callable) {
-    return new ScheduledFutureImpl<T>(mHandler, callable);
-  }
-
-  @Override
-  public ScheduledFuture<?> submit(Runnable task) {
-    return submit(task, (Void) null);
-  }
-
-  @Override
-  public <T> ScheduledFuture<T> submit(Runnable task, @Nullable T result) {
-    if (task == null) throw new NullPointerException();
-    ScheduledFutureImpl<T> future = newTaskFor(task, result);
-    execute(future);
-    return future;
-  }
-
-  @Override
-  public <T> ScheduledFuture<T> submit(Callable<T> task) {
-    if (task == null) throw new NullPointerException();
-    ScheduledFutureImpl<T> future = newTaskFor(task);
-    execute(future);
-    return future;
-  }
-
-  @Override
-  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
-    ScheduledFutureImpl<?> future = newTaskFor(command, null);
-    mHandler.postDelayed(future, unit.toMillis(delay));
-    return future;
-  }
-
-  @Override
-  public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
-    ScheduledFutureImpl<V> future = newTaskFor(callable);
-    mHandler.postDelayed(future, unit.toMillis(delay));
-    return future;
-  }
-
-  @Override
-  public ScheduledFuture<?> scheduleAtFixedRate(
-      Runnable command, long initialDelay, long period, TimeUnit unit) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public ScheduledFuture<?> scheduleWithFixedDelay(
-      Runnable command, long initialDelay, long delay, TimeUnit unit) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void quit() {
-    mHandler.getLooper().quit();
-  }
-
-  @Override
-  public boolean isHandlerThread() {
-    return Thread.currentThread() == mHandler.getLooper().getThread();
-  }
+        implements HandlerExecutorService {
+
+    private final Handler mHandler;
+
+    public HandlerExecutorServiceImpl(Handler handler) {
+        mHandler = handler;
+    }
+
+    @Override
+    public void shutdown() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public List<Runnable> shutdownNow() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isShutdown() {
+        return false;
+    }
+
+    @Override
+    public boolean isTerminated() {
+        return false;
+    }
+
+    @Override
+    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void execute(Runnable command) {
+        mHandler.post(command);
+    }
+
+    @Override
+    protected <T> ScheduledFutureImpl<T> newTaskFor(Runnable runnable, T value) {
+        return new ScheduledFutureImpl<T>(mHandler, runnable, value);
+    }
+
+    @Override
+    protected <T> ScheduledFutureImpl<T> newTaskFor(Callable<T> callable) {
+        return new ScheduledFutureImpl<T>(mHandler, callable);
+    }
+
+    @Override
+    public ScheduledFuture<?> submit(Runnable task) {
+        return submit(task, (Void) null);
+    }
+
+    @Override
+    public <T> ScheduledFuture<T> submit(Runnable task, @Nullable T result) {
+        if (task == null) throw new NullPointerException();
+        ScheduledFutureImpl<T> future = newTaskFor(task, result);
+        execute(future);
+        return future;
+    }
+
+    @Override
+    public <T> ScheduledFuture<T> submit(Callable<T> task) {
+        if (task == null) throw new NullPointerException();
+        ScheduledFutureImpl<T> future = newTaskFor(task);
+        execute(future);
+        return future;
+    }
+
+    @Override
+    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
+        ScheduledFutureImpl<?> future = newTaskFor(command, null);
+        mHandler.postDelayed(future, unit.toMillis(delay));
+        return future;
+    }
+
+    @Override
+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
+        ScheduledFutureImpl<V> future = newTaskFor(callable);
+        mHandler.postDelayed(future, unit.toMillis(delay));
+        return future;
+    }
+
+    @Override
+    public ScheduledFuture<?> scheduleAtFixedRate(
+            Runnable command, long initialDelay, long period, TimeUnit unit) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ScheduledFuture<?> scheduleWithFixedDelay(
+            Runnable command, long initialDelay, long delay, TimeUnit unit) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void quit() {
+        mHandler.getLooper().quit();
+    }
+
+    @Override
+    public boolean isHandlerThread() {
+        return Thread.currentThread() == mHandler.getLooper().getThread();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/executors/ScheduledFutureImpl.java b/fbcore/src/main/java/com/facebook/common/executors/ScheduledFutureImpl.java
index 85598e45b..5d1a6ab80 100644
--- a/fbcore/src/main/java/com/facebook/common/executors/ScheduledFutureImpl.java
+++ b/fbcore/src/main/java/com/facebook/common/executors/ScheduledFutureImpl.java
@@ -27,57 +27,57 @@
  */
 public class ScheduledFutureImpl<V> implements RunnableFuture<V>, ScheduledFuture<V> {
 
-  private final Handler mHandler;
-  private final FutureTask<V> mListenableFuture;
-
-  public ScheduledFutureImpl(Handler handler, Callable<V> callable) {
-    mHandler = handler;
-    mListenableFuture = new FutureTask<V>(callable);
-  }
-
-  public ScheduledFutureImpl(Handler handler, Runnable runnable, @Nullable V result) {
-    mHandler = handler;
-    mListenableFuture = new FutureTask<V>(runnable, result);
-  }
-
-  @Override
-  public long getDelay(TimeUnit unit) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public int compareTo(Delayed other) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void run() {
-    mListenableFuture.run();
-  }
-
-  @Override
-  public boolean cancel(boolean mayInterruptIfRunning) {
-    return mListenableFuture.cancel(mayInterruptIfRunning);
-  }
-
-  @Override
-  public boolean isCancelled() {
-    return mListenableFuture.isCancelled();
-  }
-
-  @Override
-  public boolean isDone() {
-    return mListenableFuture.isDone();
-  }
-
-  @Override
-  public V get() throws InterruptedException, ExecutionException {
-    return mListenableFuture.get();
-  }
-
-  @Override
-  public V get(long timeout, TimeUnit unit)
-      throws InterruptedException, ExecutionException, TimeoutException {
-    return mListenableFuture.get(timeout, unit);
-  }
+    private final Handler mHandler;
+    private final FutureTask<V> mListenableFuture;
+
+    public ScheduledFutureImpl(Handler handler, Callable<V> callable) {
+        mHandler = handler;
+        mListenableFuture = new FutureTask<V>(callable);
+    }
+
+    public ScheduledFutureImpl(Handler handler, Runnable runnable, @Nullable V result) {
+        mHandler = handler;
+        mListenableFuture = new FutureTask<V>(runnable, result);
+    }
+
+    @Override
+    public long getDelay(TimeUnit unit) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int compareTo(Delayed other) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void run() {
+        mListenableFuture.run();
+    }
+
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        return mListenableFuture.cancel(mayInterruptIfRunning);
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return mListenableFuture.isCancelled();
+    }
+
+    @Override
+    public boolean isDone() {
+        return mListenableFuture.isDone();
+    }
+
+    @Override
+    public V get() throws InterruptedException, ExecutionException {
+        return mListenableFuture.get();
+    }
+
+    @Override
+    public V get(long timeout, TimeUnit unit)
+            throws InterruptedException, ExecutionException, TimeoutException {
+        return mListenableFuture.get(timeout, unit);
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/executors/SerialDelegatingExecutor.java b/fbcore/src/main/java/com/facebook/common/executors/SerialDelegatingExecutor.java
index 4c7f7ea6a..ef45ae879 100644
--- a/fbcore/src/main/java/com/facebook/common/executors/SerialDelegatingExecutor.java
+++ b/fbcore/src/main/java/com/facebook/common/executors/SerialDelegatingExecutor.java
@@ -23,68 +23,68 @@
  */
 public class SerialDelegatingExecutor implements Executor {
 
-  private final Executor mDelegate;
-  @VisibleForTesting
-  final Runnable mRunnable;
+    private final Executor mDelegate;
+    @VisibleForTesting
+    final Runnable mRunnable;
 
-  /**
-   * True if and only if runnable has been passed to mDelegate for execution, but the execution
-   * itself has not completed yet.
-   */
-  @GuardedBy("this")
-  @VisibleForTesting
-  boolean mExecutionInProgress;
-  @GuardedBy("this")
-  final private Queue<Runnable> mCommands;
+    /**
+     * True if and only if runnable has been passed to mDelegate for execution, but the execution
+     * itself has not completed yet.
+     */
+    @GuardedBy("this")
+    @VisibleForTesting
+    boolean mExecutionInProgress;
+    @GuardedBy("this")
+    final private Queue<Runnable> mCommands;
 
-  public SerialDelegatingExecutor(Executor delegate) {
-    mDelegate = Preconditions.checkNotNull(delegate);
-    mExecutionInProgress = false;
-    mCommands = new LinkedList<Runnable>();
-    mRunnable = new Runnable() {
-      @Override
-      public void run() {
-        executeSingleCommand();
-      }
-    };
-  }
+    public SerialDelegatingExecutor(Executor delegate) {
+        mDelegate = Preconditions.checkNotNull(delegate);
+        mExecutionInProgress = false;
+        mCommands = new LinkedList<Runnable>();
+        mRunnable = new Runnable() {
+            @Override
+            public void run() {
+                executeSingleCommand();
+            }
+        };
+    }
 
-  /**
-   * Submits another command for execution
-   */
-  @Override
-  public void execute(Runnable command) {
-    synchronized (this) {
-      mCommands.add(command);
+    /**
+     * Submits another command for execution
+     */
+    @Override
+    public void execute(Runnable command) {
+        synchronized (this) {
+            mCommands.add(command);
+        }
+        maybeSubmitRunnable();
     }
-    maybeSubmitRunnable();
-  }
 
-  private void maybeSubmitRunnable() {
-    synchronized (this) {
-      if (mExecutionInProgress || mCommands.isEmpty()) {
-        return;
-      }
-      mExecutionInProgress = true;
+    private void maybeSubmitRunnable() {
+        synchronized (this) {
+            if (mExecutionInProgress || mCommands.isEmpty()) {
+                return;
+            }
+            mExecutionInProgress = true;
+        }
+        mDelegate.execute(mRunnable);
     }
-    mDelegate.execute(mRunnable);
-  }
 
-  private void executeSingleCommand() {
-    Runnable command;
-    try {
-      removeNextCommand().run();
-    } finally {
-      clearExecutionInProgress();
-      maybeSubmitRunnable();
+    private void executeSingleCommand() {
+        Runnable command;
+        try {
+            removeNextCommand().run();
+        } finally {
+            clearExecutionInProgress();
+            maybeSubmitRunnable();
+        }
     }
-  }
 
-  private synchronized Runnable removeNextCommand() {
-    return mCommands.remove();
-  }
+    private synchronized Runnable removeNextCommand() {
+        return mCommands.remove();
+    }
 
-  private synchronized void clearExecutionInProgress() {
-    mExecutionInProgress = false;
-  }
+    private synchronized void clearExecutionInProgress() {
+        mExecutionInProgress = false;
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/executors/StatefulRunnable.java b/fbcore/src/main/java/com/facebook/common/executors/StatefulRunnable.java
index 38df528fd..eb70f33fe 100644
--- a/fbcore/src/main/java/com/facebook/common/executors/StatefulRunnable.java
+++ b/fbcore/src/main/java/com/facebook/common/executors/StatefulRunnable.java
@@ -13,78 +13,85 @@
 
 /**
  * Abstraction for computation.
- *
+ * <p>
  * <p> Computation expressed as StatefulRunnable can be cancelled, but only if it has not
  * started yet.
- *
+ * <p>
  * <p> For better decoupling of the code computing the result and the code that handles it, 4
  * separate methods are provided: getResult, onSuccess, onFailure and onCancellation.
- *
+ * <p>
  * <p> This runnable can be run only once. Subsequent calls to run method won't have any effect.
  */
 abstract public class StatefulRunnable<T> implements Runnable {
-  protected static final int STATE_CREATED = 0;
-  protected static final int STATE_STARTED = 1;
-  protected static final int STATE_CANCELLED = 2;
-  protected static final int STATE_FINISHED = 3;
-  protected static final int STATE_FAILED = 4;
+    protected static final int STATE_CREATED = 0;
+    protected static final int STATE_STARTED = 1;
+    protected static final int STATE_CANCELLED = 2;
+    protected static final int STATE_FINISHED = 3;
+    protected static final int STATE_FAILED = 4;
 
-  protected final AtomicInteger mState;
+    protected final AtomicInteger mState;
 
-  public StatefulRunnable() {
-    mState = new AtomicInteger(STATE_CREATED);
-  }
-
-  @Override
-  public final void run() {
-    if (!mState.compareAndSet(STATE_CREATED, STATE_STARTED)) {
-      return;
-    }
-    T result;
-    try {
-      result = getResult();
-    } catch (Exception e) {
-      mState.set(STATE_FAILED);
-      onFailure(e);
-      return;
+    public StatefulRunnable() {
+        mState = new AtomicInteger(STATE_CREATED);
     }
 
-    mState.set(STATE_FINISHED);
-    try {
-      onSuccess(result);
-    } finally {
-      disposeResult(result);
+    @Override
+    public final void run() {
+        if (!mState.compareAndSet(STATE_CREATED, STATE_STARTED)) {
+            return;
+        }
+        T result;
+        try {
+            result = getResult();
+        } catch (Exception e) {
+            mState.set(STATE_FAILED);
+            onFailure(e);
+            return;
+        }
+
+        mState.set(STATE_FINISHED);
+        try {
+            onSuccess(result);
+        } finally {
+            disposeResult(result);
+        }
     }
-  }
 
-  public void cancel() {
-    if (mState.compareAndSet(STATE_CREATED, STATE_CANCELLED)) {
-      onCancellation();
+    public void cancel() {
+        if (mState.compareAndSet(STATE_CREATED, STATE_CANCELLED)) {
+            onCancellation();
+        }
     }
-  }
 
-  /**
-   * Called after computing result successfully.
-   * @param result
-   */
-  protected void onSuccess(T result) {}
+    /**
+     * Called after computing result successfully.
+     *
+     * @param result
+     */
+    protected void onSuccess(T result) {
+    }
 
-  /**
-   * Called if exception occurred during computation.
-   * @param e
-   */
-  protected void onFailure(Exception e) {}
+    /**
+     * Called if exception occurred during computation.
+     *
+     * @param e
+     */
+    protected void onFailure(Exception e) {
+    }
 
-  /**
-   * Called when the runnable is cancelled.
-   */
-  protected void onCancellation() {}
+    /**
+     * Called when the runnable is cancelled.
+     */
+    protected void onCancellation() {
+    }
 
-  /**
-   * Called after onSuccess callback completes in order to dispose the result.
-   * @param result
-   */
-  protected void disposeResult(T result) {}
+    /**
+     * Called after onSuccess callback completes in order to dispose the result.
+     *
+     * @param result
+     */
+    protected void disposeResult(T result) {
+    }
 
-  abstract protected T getResult() throws Exception;
+    abstract protected T getResult() throws Exception;
 }
diff --git a/fbcore/src/main/java/com/facebook/common/executors/UiThreadExecutorService.java b/fbcore/src/main/java/com/facebook/common/executors/UiThreadExecutorService.java
index d490d0dbd..4c2bb5f87 100644
--- a/fbcore/src/main/java/com/facebook/common/executors/UiThreadExecutorService.java
+++ b/fbcore/src/main/java/com/facebook/common/executors/UiThreadExecutorService.java
@@ -19,16 +19,16 @@
  */
 public class UiThreadExecutorService extends HandlerExecutorServiceImpl {
 
-  private static UiThreadExecutorService sInstance = null;
+    private static UiThreadExecutorService sInstance = null;
 
-  private UiThreadExecutorService() {
-    super(new Handler(Looper.getMainLooper()));
-  }
+    private UiThreadExecutorService() {
+        super(new Handler(Looper.getMainLooper()));
+    }
 
-  public static UiThreadExecutorService getInstance() {
-    if (sInstance == null) {
-      sInstance = new UiThreadExecutorService();
+    public static UiThreadExecutorService getInstance() {
+        if (sInstance == null) {
+            sInstance = new UiThreadExecutorService();
+        }
+        return sInstance;
     }
-    return sInstance;
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/executors/UiThreadImmediateExecutorService.java b/fbcore/src/main/java/com/facebook/common/executors/UiThreadImmediateExecutorService.java
index b137308ed..01bcbc38d 100644
--- a/fbcore/src/main/java/com/facebook/common/executors/UiThreadImmediateExecutorService.java
+++ b/fbcore/src/main/java/com/facebook/common/executors/UiThreadImmediateExecutorService.java
@@ -16,30 +16,30 @@
 
 /**
  * An {@link ExecutorService} that is backed by the application's main looper.
- *
+ * <p>
  * <p/> If the execute is called from the thread of the application's main looper,
  * it will be executed synchronously.
  */
 public class UiThreadImmediateExecutorService extends HandlerExecutorServiceImpl {
-  private static UiThreadImmediateExecutorService sInstance = null;
+    private static UiThreadImmediateExecutorService sInstance = null;
 
-  private UiThreadImmediateExecutorService() {
-    super(new Handler(Looper.getMainLooper()));
-  }
+    private UiThreadImmediateExecutorService() {
+        super(new Handler(Looper.getMainLooper()));
+    }
 
-  public static UiThreadImmediateExecutorService getInstance() {
-    if (sInstance == null) {
-      sInstance = new UiThreadImmediateExecutorService();
+    public static UiThreadImmediateExecutorService getInstance() {
+        if (sInstance == null) {
+            sInstance = new UiThreadImmediateExecutorService();
+        }
+        return sInstance;
     }
-    return sInstance;
-  }
 
-  @Override
-  public void execute(Runnable command) {
-    if (isHandlerThread()) {
-      command.run();
-    } else {
-      super.execute(command);
+    @Override
+    public void execute(Runnable command) {
+        if (isHandlerThread()) {
+            command.run();
+        } else {
+            super.execute(command);
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/file/FileTree.java b/fbcore/src/main/java/com/facebook/common/file/FileTree.java
index ee1fbe144..3ac57d507 100644
--- a/fbcore/src/main/java/com/facebook/common/file/FileTree.java
+++ b/fbcore/src/main/java/com/facebook/common/file/FileTree.java
@@ -19,57 +19,59 @@
  */
 public class FileTree {
 
-  /**
-   * Iterates over the file tree of a directory. It receives a visitor and will call its methods
-   * for each file in the directory.
-   * preVisitDirectory (directory)
-   * visitFile (file)
-   * - recursively the same for every subdirectory
-   * postVisitDirectory (directory)
-   * @param directory the directory to iterate
-   * @param visitor the visitor that will be invoked for each directory/file in the tree
-   */
-  public static void walkFileTree(File directory, FileTreeVisitor visitor) {
-    visitor.preVisitDirectory(directory);
-    File[] files = directory.listFiles();
-    if (files != null) {
-      for (File file: files) {
-        if (file.isDirectory()) {
-          walkFileTree(file, visitor);
-        } else {
-          visitor.visitFile(file);
+    /**
+     * Iterates over the file tree of a directory. It receives a visitor and will call its methods
+     * for each file in the directory.
+     * preVisitDirectory (directory)
+     * visitFile (file)
+     * - recursively the same for every subdirectory
+     * postVisitDirectory (directory)
+     *
+     * @param directory the directory to iterate
+     * @param visitor   the visitor that will be invoked for each directory/file in the tree
+     */
+    public static void walkFileTree(File directory, FileTreeVisitor visitor) {
+        visitor.preVisitDirectory(directory);
+        File[] files = directory.listFiles();
+        if (files != null) {
+            for (File file : files) {
+                if (file.isDirectory()) {
+                    walkFileTree(file, visitor);
+                } else {
+                    visitor.visitFile(file);
+                }
+            }
         }
-      }
+        visitor.postVisitDirectory(directory);
     }
-    visitor.postVisitDirectory(directory);
-  }
 
-  /**
-   * Deletes all files and subdirectories in directory (doesn't delete the directory
-   * passed as parameter).
-   */
-  public static boolean deleteContents(File directory) {
-    File[] files = directory.listFiles();
-    boolean success = true;
-    if (files != null) {
-      for (File file : files) {
-        success &= deleteRecursively(file);
-      }
+    /**
+     * Deletes all files and subdirectories in directory (doesn't delete the directory
+     * passed as parameter).
+     */
+    public static boolean deleteContents(File directory) {
+        File[] files = directory.listFiles();
+        boolean success = true;
+        if (files != null) {
+            for (File file : files) {
+                success &= deleteRecursively(file);
+            }
+        }
+        return success;
     }
-    return success;
-  }
 
-  /**
-   * Deletes the file and if it's a directory deletes also any content in it
-   * @param file a file or directory
-   * @return true if the file/directory could be deleted
-   */
-  public static boolean deleteRecursively(File file) {
-    if (file.isDirectory()) {
-      deleteContents(file);
+    /**
+     * Deletes the file and if it's a directory deletes also any content in it
+     *
+     * @param file a file or directory
+     * @return true if the file/directory could be deleted
+     */
+    public static boolean deleteRecursively(File file) {
+        if (file.isDirectory()) {
+            deleteContents(file);
+        }
+        // if I can delete directory then I know everything was deleted
+        return file.delete();
     }
-    // if I can delete directory then I know everything was deleted
-    return file.delete();
-  }
 
 }
diff --git a/fbcore/src/main/java/com/facebook/common/file/FileTreeVisitor.java b/fbcore/src/main/java/com/facebook/common/file/FileTreeVisitor.java
index 4a7ada9cd..67a6dded4 100644
--- a/fbcore/src/main/java/com/facebook/common/file/FileTreeVisitor.java
+++ b/fbcore/src/main/java/com/facebook/common/file/FileTreeVisitor.java
@@ -19,18 +19,18 @@
  */
 public interface FileTreeVisitor {
 
-  /**
-   * Called before iterating over a directory (including the root directory of the iteration)
-   */
-  void preVisitDirectory(File directory);
+    /**
+     * Called before iterating over a directory (including the root directory of the iteration)
+     */
+    void preVisitDirectory(File directory);
 
-  /**
-   * Called for each file contained in a directory (after preVisitDirectory)
-   */
-  void visitFile(File file);
+    /**
+     * Called for each file contained in a directory (after preVisitDirectory)
+     */
+    void visitFile(File file);
 
-  /**
-   * Called after iterating over a directory (including the root directory of the iteration)
-   */
-  void postVisitDirectory(File directory);
+    /**
+     * Called after iterating over a directory (including the root directory of the iteration)
+     */
+    void postVisitDirectory(File directory);
 }
diff --git a/fbcore/src/main/java/com/facebook/common/file/FileUtils.java b/fbcore/src/main/java/com/facebook/common/file/FileUtils.java
index 7bf44c1a1..de9d73329 100644
--- a/fbcore/src/main/java/com/facebook/common/file/FileUtils.java
+++ b/fbcore/src/main/java/com/facebook/common/file/FileUtils.java
@@ -20,108 +20,110 @@
  */
 public class FileUtils {
 
-  /**
-   * Creates the specified directory, along with all parent paths if necessary
-   * @param directory directory to be created
-   * @throws CreateDirectoryException
-   */
-  public static void mkdirs(File directory) throws CreateDirectoryException {
-    if (directory.exists()) {
-      // file exists and *is* a directory
-      if (directory.isDirectory()) {
-        return;
-      }
-
-      // file exists, but is not a directory - delete it
-      if (!directory.delete()) {
-        throw new CreateDirectoryException(
-            directory.getAbsolutePath(),
-            new FileDeleteException(directory.getAbsolutePath()));
-      }
+    /**
+     * Creates the specified directory, along with all parent paths if necessary
+     *
+     * @param directory directory to be created
+     * @throws CreateDirectoryException
+     */
+    public static void mkdirs(File directory) throws CreateDirectoryException {
+        if (directory.exists()) {
+            // file exists and *is* a directory
+            if (directory.isDirectory()) {
+                return;
+            }
+
+            // file exists, but is not a directory - delete it
+            if (!directory.delete()) {
+                throw new CreateDirectoryException(
+                        directory.getAbsolutePath(),
+                        new FileDeleteException(directory.getAbsolutePath()));
+            }
+        }
+
+        // doesn't exist. Create one
+        if (!directory.mkdirs() && !directory.isDirectory()) {
+            throw new CreateDirectoryException(directory.getAbsolutePath());
+        }
     }
 
-    // doesn't exist. Create one
-    if (!directory.mkdirs() && !directory.isDirectory()) {
-      throw new CreateDirectoryException(directory.getAbsolutePath());
-    }
-  }
-
-  /**
-   * Renames the source file to the target file. If the target file exists, then we attempt to
-   * delete it. If the delete or the rename operation fails, then we raise an exception
-   * @param source the source file
-   * @param target the new 'name' for the source file
-   * @throws IOException
-   */
-  public static void rename(File source, File target) throws RenameException {
-    Preconditions.checkNotNull(source);
-    Preconditions.checkNotNull(target);
-
-    // delete the target first - but ignore the result
-    target.delete();
-
-    if (source.renameTo(target)) {
-      return;
+    /**
+     * Renames the source file to the target file. If the target file exists, then we attempt to
+     * delete it. If the delete or the rename operation fails, then we raise an exception
+     *
+     * @param source the source file
+     * @param target the new 'name' for the source file
+     * @throws IOException
+     */
+    public static void rename(File source, File target) throws RenameException {
+        Preconditions.checkNotNull(source);
+        Preconditions.checkNotNull(target);
+
+        // delete the target first - but ignore the result
+        target.delete();
+
+        if (source.renameTo(target)) {
+            return;
+        }
+
+        Throwable innerException = null;
+        if (target.exists()) {
+            innerException = new FileDeleteException(target.getAbsolutePath());
+        } else if (!source.getParentFile().exists()) {
+            innerException = new ParentDirNotFoundException(source.getAbsolutePath());
+        } else if (!source.exists()) {
+            innerException = new FileNotFoundException(source.getAbsolutePath());
+        }
+
+        throw new RenameException(
+                "Unknown error renaming " + source.getAbsolutePath() + " to " + target.getAbsolutePath(),
+                innerException);
     }
 
-    Throwable innerException = null;
-    if (target.exists()) {
-      innerException = new FileDeleteException(target.getAbsolutePath());
-    } else if (!source.getParentFile().exists()) {
-      innerException = new ParentDirNotFoundException(source.getAbsolutePath());
-    } else if (!source.exists()) {
-      innerException = new FileNotFoundException(source.getAbsolutePath());
+    /**
+     * Represents an exception during directory creation
+     */
+    public static class CreateDirectoryException extends IOException {
+        public CreateDirectoryException(String message) {
+            super(message);
+        }
+
+        public CreateDirectoryException(String message, Throwable innerException) {
+            super(message);
+            initCause(innerException);
+        }
     }
 
-    throw new RenameException(
-        "Unknown error renaming " + source.getAbsolutePath() + " to " + target.getAbsolutePath(),
-        innerException);
-  }
-
-  /**
-   * Represents an exception during directory creation
-   */
-  public static class CreateDirectoryException extends IOException {
-    public CreateDirectoryException(String message) {
-      super(message);
+    /**
+     * A specialization of FileNotFoundException when the parent-dir doesn't exist
+     */
+    public static class ParentDirNotFoundException extends FileNotFoundException {
+        public ParentDirNotFoundException(String message) {
+            super(message);
+        }
     }
 
-    public CreateDirectoryException(String message, Throwable innerException) {
-      super(message);
-      initCause(innerException);
-    }
-  }
-
-  /**
-   * A specialization of FileNotFoundException when the parent-dir doesn't exist
-   */
-  public static class ParentDirNotFoundException extends FileNotFoundException {
-    public ParentDirNotFoundException(String message) {
-      super(message);
-    }
-  }
-
-  /**
-   * Represents an exception when the target file/directory cannot be deleted
-   */
-  public static class FileDeleteException extends IOException {
-    public FileDeleteException(String message) {
-      super(message);
-    }
-  }
-
-  /**
-   * Represents an unknown rename exception
-   */
-  public static class RenameException extends IOException {
-    public RenameException(String message) {
-      super(message);
+    /**
+     * Represents an exception when the target file/directory cannot be deleted
+     */
+    public static class FileDeleteException extends IOException {
+        public FileDeleteException(String message) {
+            super(message);
+        }
     }
 
-    public RenameException(String message, Throwable innerException) {
-      super(message);
-      initCause(innerException);
+    /**
+     * Represents an unknown rename exception
+     */
+    public static class RenameException extends IOException {
+        public RenameException(String message) {
+            super(message);
+        }
+
+        public RenameException(String message, Throwable innerException) {
+            super(message);
+            initCause(innerException);
 
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/AndroidPredicates.java b/fbcore/src/main/java/com/facebook/common/internal/AndroidPredicates.java
index 637cce385..5d79a1dcd 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/AndroidPredicates.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/AndroidPredicates.java
@@ -16,23 +16,24 @@
  */
 public class AndroidPredicates {
 
-  private AndroidPredicates() {}
+    private AndroidPredicates() {
+    }
 
-  public static <T> Predicate<T> True() {
-    return new Predicate<T>() {
-      @Override
-      public boolean apply(T t) {
-        return true;
-      }
-    };
-  }
+    public static <T> Predicate<T> True() {
+        return new Predicate<T>() {
+            @Override
+            public boolean apply(T t) {
+                return true;
+            }
+        };
+    }
 
-  public static <T> Predicate<T> False() {
-    return new Predicate<T>() {
-      @Override
-      public boolean apply(T t) {
-        return false;
-      }
-    };
-  }
+    public static <T> Predicate<T> False() {
+        return new Predicate<T>() {
+            @Override
+            public boolean apply(T t) {
+                return false;
+            }
+        };
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/ByteStreams.java b/fbcore/src/main/java/com/facebook/common/internal/ByteStreams.java
index af1c33884..8a4f7a834 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/ByteStreams.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/ByteStreams.java
@@ -35,169 +35,169 @@
  */
 public final class ByteStreams {
 
-  private static final int BUF_SIZE = 0x1000; // 4K
-
-  private ByteStreams() {
-  }
-
-  /**
-   * Copies all bytes from the input stream to the output stream. Does not close or flush either
-   * stream.
-   *
-   * @param from the input stream to read from
-   * @param to the output stream to write to
-   * @return the number of bytes copied
-   * @throws IOException if an I/O error occurs
-   */
-  public static long copy(InputStream from, OutputStream to)
-      throws IOException {
-    checkNotNull(from);
-    checkNotNull(to);
-    byte[] buf = new byte[BUF_SIZE];
-    long total = 0;
-    while (true) {
-      int r = from.read(buf);
-      if (r == -1) {
-        break;
-      }
-      to.write(buf, 0, r);
-      total += r;
+    private static final int BUF_SIZE = 0x1000; // 4K
+
+    private ByteStreams() {
     }
-    return total;
-  }
-
-  /**
-   * Reads some bytes from an input stream and stores them into the buffer array
-   * {@code b}. This method blocks until {@code len} bytes of input data have
-   * been read into the array, or end of file is detected. The number of bytes
-   * read is returned, possibly zero. Does not close the stream.
-   *
-   * <p>A caller can detect EOF if the number of bytes read is less than
-   * {@code len}. All subsequent calls on the same stream will return zero.
-   *
-   * <p>If {@code b} is null, a {@code NullPointerException} is thrown. If
-   * {@code off} is negative, or {@code len} is negative, or {@code off+len} is
-   * greater than the length of the array {@code b}, then an
-   * {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then
-   * no bytes are read. Otherwise, the first byte read is stored into element
-   * {@code b[off]}, the next one into {@code b[off+1]}, and so on. The number
-   * of bytes read is, at most, equal to {@code len}.
-   *
-   * @param in the input stream to read from
-   * @param b the buffer into which the data is read
-   * @param off an int specifying the offset into the data
-   * @param len an int specifying the number of bytes to read
-   * @return the number of bytes read
-   * @throws IOException if an I/O error occurs
-   */
-  public static int read(InputStream in, byte[] b, int off, int len)
-      throws IOException {
-    checkNotNull(in);
-    checkNotNull(b);
-    if (len < 0) {
-      throw new IndexOutOfBoundsException("len is negative");
+
+    /**
+     * Copies all bytes from the input stream to the output stream. Does not close or flush either
+     * stream.
+     *
+     * @param from the input stream to read from
+     * @param to   the output stream to write to
+     * @return the number of bytes copied
+     * @throws IOException if an I/O error occurs
+     */
+    public static long copy(InputStream from, OutputStream to)
+            throws IOException {
+        checkNotNull(from);
+        checkNotNull(to);
+        byte[] buf = new byte[BUF_SIZE];
+        long total = 0;
+        while (true) {
+            int r = from.read(buf);
+            if (r == -1) {
+                break;
+            }
+            to.write(buf, 0, r);
+            total += r;
+        }
+        return total;
     }
-    int total = 0;
-    while (total < len) {
-      int result = in.read(b, off + total, len - total);
-      if (result == -1) {
-        break;
-      }
-      total += result;
+
+    /**
+     * Reads some bytes from an input stream and stores them into the buffer array
+     * {@code b}. This method blocks until {@code len} bytes of input data have
+     * been read into the array, or end of file is detected. The number of bytes
+     * read is returned, possibly zero. Does not close the stream.
+     * <p>
+     * <p>A caller can detect EOF if the number of bytes read is less than
+     * {@code len}. All subsequent calls on the same stream will return zero.
+     * <p>
+     * <p>If {@code b} is null, a {@code NullPointerException} is thrown. If
+     * {@code off} is negative, or {@code len} is negative, or {@code off+len} is
+     * greater than the length of the array {@code b}, then an
+     * {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then
+     * no bytes are read. Otherwise, the first byte read is stored into element
+     * {@code b[off]}, the next one into {@code b[off+1]}, and so on. The number
+     * of bytes read is, at most, equal to {@code len}.
+     *
+     * @param in  the input stream to read from
+     * @param b   the buffer into which the data is read
+     * @param off an int specifying the offset into the data
+     * @param len an int specifying the number of bytes to read
+     * @return the number of bytes read
+     * @throws IOException if an I/O error occurs
+     */
+    public static int read(InputStream in, byte[] b, int off, int len)
+            throws IOException {
+        checkNotNull(in);
+        checkNotNull(b);
+        if (len < 0) {
+            throw new IndexOutOfBoundsException("len is negative");
+        }
+        int total = 0;
+        while (total < len) {
+            int result = in.read(b, off + total, len - total);
+            if (result == -1) {
+                break;
+            }
+            total += result;
+        }
+        return total;
     }
-    return total;
-  }
-
-  /**
-   * Reads all bytes from an input stream into a byte array.
-   * Does not close the stream.
-   *
-   * @param in the input stream to read from
-   * @return a byte array containing all the bytes from the stream
-   * @throws IOException if an I/O error occurs
-   */
-  public static byte[] toByteArray(InputStream in) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    copy(in, out);
-    return out.toByteArray();
-  }
-
-  /**
-   * Reads all bytes from an input stream into a byte array. The given
-   * expected size is used to create an initial byte array, but if the actual
-   * number of bytes read from the stream differs, the correct result will be
-   * returned anyway.
-   */
-  public static byte[] toByteArray(
-      InputStream in,
-      int expectedSize) throws IOException {
-    byte[] bytes = new byte[expectedSize];
-    int remaining = expectedSize;
-
-    while (remaining > 0) {
-      int off = expectedSize - remaining;
-      int read = in.read(bytes, off, remaining);
-      if (read == -1) {
-        // end of stream before reading expectedSize bytes
-        // just return the bytes read so far
-        return Arrays.copyOf(bytes, off);
-      }
-      remaining -= read;
+
+    /**
+     * Reads all bytes from an input stream into a byte array.
+     * Does not close the stream.
+     *
+     * @param in the input stream to read from
+     * @return a byte array containing all the bytes from the stream
+     * @throws IOException if an I/O error occurs
+     */
+    public static byte[] toByteArray(InputStream in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        copy(in, out);
+        return out.toByteArray();
     }
 
-    // bytes is now full
-    int b = in.read();
-    if (b == -1) {
-      return bytes;
+    /**
+     * Reads all bytes from an input stream into a byte array. The given
+     * expected size is used to create an initial byte array, but if the actual
+     * number of bytes read from the stream differs, the correct result will be
+     * returned anyway.
+     */
+    public static byte[] toByteArray(
+            InputStream in,
+            int expectedSize) throws IOException {
+        byte[] bytes = new byte[expectedSize];
+        int remaining = expectedSize;
+
+        while (remaining > 0) {
+            int off = expectedSize - remaining;
+            int read = in.read(bytes, off, remaining);
+            if (read == -1) {
+                // end of stream before reading expectedSize bytes
+                // just return the bytes read so far
+                return Arrays.copyOf(bytes, off);
+            }
+            remaining -= read;
+        }
+
+        // bytes is now full
+        int b = in.read();
+        if (b == -1) {
+            return bytes;
+        }
+
+        // the stream was longer, so read the rest normally
+        FastByteArrayOutputStream out = new FastByteArrayOutputStream();
+        out.write(b); // write the byte we read when testing for end of stream
+        copy(in, out);
+
+        byte[] result = new byte[bytes.length + out.size()];
+        System.arraycopy(bytes, 0, result, 0, bytes.length);
+        out.writeTo(result, bytes.length);
+        return result;
     }
 
-    // the stream was longer, so read the rest normally
-    FastByteArrayOutputStream out = new FastByteArrayOutputStream();
-    out.write(b); // write the byte we read when testing for end of stream
-    copy(in, out);
 
-    byte[] result = new byte[bytes.length + out.size()];
-    System.arraycopy(bytes, 0, result, 0, bytes.length);
-    out.writeTo(result, bytes.length);
-    return result;
-  }
+    /**
+     * BAOS that provides limited access to its internal byte array.
+     */
+    private static final class FastByteArrayOutputStream
+            extends ByteArrayOutputStream {
+        /**
+         * Writes the contents of the internal buffer to the given array starting
+         * at the given offset. Assumes the array has space to hold count bytes.
+         */
+        void writeTo(byte[] b, int off) {
+            System.arraycopy(buf, 0, b, off, count);
+        }
+    }
 
 
-  /**
-   * BAOS that provides limited access to its internal byte array.
-   */
-  private static final class FastByteArrayOutputStream
-      extends ByteArrayOutputStream {
     /**
-     * Writes the contents of the internal buffer to the given array starting
-     * at the given offset. Assumes the array has space to hold count bytes.
+     * Attempts to read {@code len} bytes from the stream into the given array
+     * starting at {@code off}, with the same behavior as
+     * {@link DataInput#readFully(byte[], int, int)}. Does not close the
+     * stream.
+     *
+     * @param in  the input stream to read from.
+     * @param b   the buffer into which the data is read.
+     * @param off an int specifying the offset into the data.
+     * @param len an int specifying the number of bytes to read.
+     * @throws EOFException if this stream reaches the end before reading all
+     *                      the bytes.
+     * @throws IOException  if an I/O error occurs.
      */
-    void writeTo(byte[] b, int off) {
-      System.arraycopy(buf, 0, b, off, count);
-    }
-  }
-
-
-  /**
-   * Attempts to read {@code len} bytes from the stream into the given array
-   * starting at {@code off}, with the same behavior as
-   * {@link DataInput#readFully(byte[], int, int)}. Does not close the
-   * stream.
-   *
-   * @param in the input stream to read from.
-   * @param b the buffer into which the data is read.
-   * @param off an int specifying the offset into the data.
-   * @param len an int specifying the number of bytes to read.
-   * @throws EOFException if this stream reaches the end before reading all
-   *     the bytes.
-   * @throws IOException if an I/O error occurs.
-   */
-  public static void readFully(
-      InputStream in, byte[] b, int off, int len) throws IOException {
-    int read = read(in, b, off, len);
-    if (read != len) {
-      throw new EOFException("reached end of stream after reading "
-          + read + " bytes; " + len + " bytes expected");
+    public static void readFully(
+            InputStream in, byte[] b, int off, int len) throws IOException {
+        int read = read(in, b, off, len);
+        if (read != len) {
+            throw new EOFException("reached end of stream after reading "
+                    + read + " bytes; " + len + " bytes expected");
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Closeables.java b/fbcore/src/main/java/com/facebook/common/internal/Closeables.java
index 460532bfb..d4ace4340 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Closeables.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Closeables.java
@@ -32,97 +32,99 @@
  * @since 1.0
  */
 public final class Closeables {
-  @VisibleForTesting static final Logger logger
-      = Logger.getLogger(Closeables.class.getName());
+    @VisibleForTesting
+    static final Logger logger
+            = Logger.getLogger(Closeables.class.getName());
 
-  private Closeables() {}
-
-  /**
-   * Closes a {@link Closeable}, with control over whether an {@code IOException} may be thrown.
-   * This is primarily useful in a finally block, where a thrown exception needs to be logged but
-   * not propagated (otherwise the original exception will be lost).
-   *
-   * <p>If {@code swallowIOException} is true then we never throw {@code IOException} but merely log
-   * it.
-   *
-   * <p>Example: <pre>   {@code
-   *
-   *   public void useStreamNicely() throws IOException {
-   *     SomeStream stream = new SomeStream("foo");
-   *     boolean threw = true;
-   *     try {
-   *       // ... code which does something with the stream ...
-   *       threw = false;
-   *     } finally {
-   *       // If an exception occurs, rethrow it only if threw==false:
-   *       Closeables.close(stream, threw);
-   *     }
-   *   }}</pre>
-   *
-   * @param closeable the {@code Closeable} object to be closed, or null, in which case this method
-   *     does nothing
-   * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code close}
-   *     methods
-   * @throws IOException if {@code swallowIOException} is false and {@code close} throws an
-   *     {@code IOException}.
-   */
-  public static void close(@Nullable Closeable closeable,
-      boolean swallowIOException) throws IOException {
-    if (closeable == null) {
-      return;
+    private Closeables() {
     }
-    try {
-      closeable.close();
-    } catch (IOException e) {
-      if (swallowIOException) {
-        logger.log(Level.WARNING,
-            "IOException thrown while closing Closeable.", e);
-      } else {
-        throw e;
-      }
+
+    /**
+     * Closes a {@link Closeable}, with control over whether an {@code IOException} may be thrown.
+     * This is primarily useful in a finally block, where a thrown exception needs to be logged but
+     * not propagated (otherwise the original exception will be lost).
+     * <p>
+     * <p>If {@code swallowIOException} is true then we never throw {@code IOException} but merely log
+     * it.
+     * <p>
+     * <p>Example: <pre>   {@code
+     * <p>
+     *   public void useStreamNicely() throws IOException {
+     *     SomeStream stream = new SomeStream("foo");
+     *     boolean threw = true;
+     *     try {
+     *       // ... code which does something with the stream ...
+     *       threw = false;
+     *     } finally {
+     *       // If an exception occurs, rethrow it only if threw==false:
+     *       Closeables.close(stream, threw);
+     *     }
+     *   }}</pre>
+     *
+     * @param closeable          the {@code Closeable} object to be closed, or null, in which case this method
+     *                           does nothing
+     * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code close}
+     *                           methods
+     * @throws IOException if {@code swallowIOException} is false and {@code close} throws an
+     *                     {@code IOException}.
+     */
+    public static void close(@Nullable Closeable closeable,
+                             boolean swallowIOException) throws IOException {
+        if (closeable == null) {
+            return;
+        }
+        try {
+            closeable.close();
+        } catch (IOException e) {
+            if (swallowIOException) {
+                logger.log(Level.WARNING,
+                        "IOException thrown while closing Closeable.", e);
+            } else {
+                throw e;
+            }
+        }
     }
-  }
 
-  /**
-   * Closes the given {@link InputStream}, logging any {@code IOException} that's thrown rather
-   * than propagating it.
-   *
-   * <p>While it's not safe in the general case to ignore exceptions that are thrown when closing
-   * an I/O resource, it should generally be safe in the case of a resource that's being used only
-   * for reading, such as an {@code InputStream}. Unlike with writable resources, there's no
-   * chance that a failure that occurs when closing the stream indicates a meaningful problem such
-   * as a failure to flush all bytes to the underlying resource.
-   *
-   * @param inputStream the input stream to be closed, or {@code null} in which case this method
-   *     does nothing
-   * @since 17.0
-   */
-  public static void closeQuietly(@Nullable InputStream inputStream) {
-    try {
-      close(inputStream, true);
-    } catch (IOException impossible) {
-      throw new AssertionError(impossible);
+    /**
+     * Closes the given {@link InputStream}, logging any {@code IOException} that's thrown rather
+     * than propagating it.
+     * <p>
+     * <p>While it's not safe in the general case to ignore exceptions that are thrown when closing
+     * an I/O resource, it should generally be safe in the case of a resource that's being used only
+     * for reading, such as an {@code InputStream}. Unlike with writable resources, there's no
+     * chance that a failure that occurs when closing the stream indicates a meaningful problem such
+     * as a failure to flush all bytes to the underlying resource.
+     *
+     * @param inputStream the input stream to be closed, or {@code null} in which case this method
+     *                    does nothing
+     * @since 17.0
+     */
+    public static void closeQuietly(@Nullable InputStream inputStream) {
+        try {
+            close(inputStream, true);
+        } catch (IOException impossible) {
+            throw new AssertionError(impossible);
+        }
     }
-  }
 
-  /**
-   * Closes the given {@link Reader}, logging any {@code IOException} that's thrown rather than
-   * propagating it.
-   *
-   * <p>While it's not safe in the general case to ignore exceptions that are thrown when closing
-   * an I/O resource, it should generally be safe in the case of a resource that's being used only
-   * for reading, such as a {@code Reader}. Unlike with writable resources, there's no chance that
-   * a failure that occurs when closing the reader indicates a meaningful problem such as a failure
-   * to flush all bytes to the underlying resource.
-   *
-   * @param reader the reader to be closed, or {@code null} in which case this method does nothing
-   * @since 17.0
-   */
-  public static void closeQuietly(@Nullable Reader reader) {
-    try {
-      close(reader, true);
-    } catch (IOException impossible) {
-      throw new AssertionError(impossible);
+    /**
+     * Closes the given {@link Reader}, logging any {@code IOException} that's thrown rather than
+     * propagating it.
+     * <p>
+     * <p>While it's not safe in the general case to ignore exceptions that are thrown when closing
+     * an I/O resource, it should generally be safe in the case of a resource that's being used only
+     * for reading, such as a {@code Reader}. Unlike with writable resources, there's no chance that
+     * a failure that occurs when closing the reader indicates a meaningful problem such as a failure
+     * to flush all bytes to the underlying resource.
+     *
+     * @param reader the reader to be closed, or {@code null} in which case this method does nothing
+     * @since 17.0
+     */
+    public static void closeQuietly(@Nullable Reader reader) {
+        try {
+            close(reader, true);
+        } catch (IOException impossible) {
+            throw new AssertionError(impossible);
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/CountingOutputStream.java b/fbcore/src/main/java/com/facebook/common/internal/CountingOutputStream.java
index 6a7b1e7c0..ca5681303 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/CountingOutputStream.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/CountingOutputStream.java
@@ -28,43 +28,43 @@
  */
 public class CountingOutputStream extends FilterOutputStream {
 
-  private long mCount;
+    private long mCount;
 
-  /**
-   * Constructs a new {@code FilterOutputStream} with {@code out} as its
-   * target stream.
-   *
-   * @param out the target stream that this stream writes to.
-   */
-  public CountingOutputStream(OutputStream out) {
-    super(out);
-    mCount = 0;
-  }
+    /**
+     * Constructs a new {@code FilterOutputStream} with {@code out} as its
+     * target stream.
+     *
+     * @param out the target stream that this stream writes to.
+     */
+    public CountingOutputStream(OutputStream out) {
+        super(out);
+        mCount = 0;
+    }
 
-  /**
-   * Returns the number of bytes written.
-   */
-  public long getCount() {
-    return mCount;
-  }
+    /**
+     * Returns the number of bytes written.
+     */
+    public long getCount() {
+        return mCount;
+    }
 
-  @Override
-  public void write(byte[] b, int off, int len) throws IOException {
-    out.write(b, off, len);
-    mCount += len;
-  }
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+        out.write(b, off, len);
+        mCount += len;
+    }
 
-  @Override
-  public void write(int b) throws IOException {
-    out.write(b);
-    mCount++;
-  }
+    @Override
+    public void write(int b) throws IOException {
+        out.write(b);
+        mCount++;
+    }
 
-  // Overriding close() because FilterOutputStream's close() method pre-JDK8 has bad behavior:
-  // it silently ignores any exception thrown by flush(). Instead, just close the delegate stream.
-  // It should flush itself if necessary.
-  @Override
-  public void close() throws IOException {
-    out.close();
-  }
+    // Overriding close() because FilterOutputStream's close() method pre-JDK8 has bad behavior:
+    // it silently ignores any exception thrown by flush(). Instead, just close the delegate stream.
+    // It should flush itself if necessary.
+    @Override
+    public void close() throws IOException {
+        out.close();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/DoNotStrip.java b/fbcore/src/main/java/com/facebook/common/internal/DoNotStrip.java
index 9b5138890..71f907fa6 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/DoNotStrip.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/DoNotStrip.java
@@ -17,10 +17,10 @@
 
 /**
  * Add this annotation to a class, method, or field to instruct Proguard to not strip it out.
- *
+ * <p>
  * This is useful for methods called via reflection that could appear as unused to Proguard.
  */
-@Target({ ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
+@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})
 @Retention(CLASS)
 public @interface DoNotStrip {
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Files.java b/fbcore/src/main/java/com/facebook/common/internal/Files.java
index 70b25bd3c..745e5606b 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Files.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Files.java
@@ -23,7 +23,7 @@
 
 /**
  * Provides utility methods for working with files.
- *
+ * <p>
  * <p>All method parameters must be non-null unless documented otherwise.
  *
  * @author Chris Nokleberg
@@ -31,45 +31,47 @@
  * @since 1.0
  */
 public class Files {
-  private Files() {}
+    private Files() {
+    }
+
+    /**
+     * Reads a file of the given expected size from the given input stream, if
+     * it will fit into a byte array. This method handles the case where the file
+     * size changes between when the size is read and when the contents are read
+     * from the stream.
+     */
+    static byte[] readFile(
+            InputStream in, long expectedSize) throws IOException {
+        if (expectedSize > Integer.MAX_VALUE) {
+            throw new OutOfMemoryError("file is too large to fit in a byte array: "
+                    + expectedSize + " bytes");
+        }
 
-  /**
-   * Reads a file of the given expected size from the given input stream, if
-   * it will fit into a byte array. This method handles the case where the file
-   * size changes between when the size is read and when the contents are read
-   * from the stream.
-   */
-  static byte[] readFile(
-      InputStream in, long expectedSize) throws IOException {
-    if (expectedSize > Integer.MAX_VALUE) {
-      throw new OutOfMemoryError("file is too large to fit in a byte array: "
-          + expectedSize + " bytes");
+        // some special files may return size 0 but have content, so read
+        // the file normally in that case
+        return expectedSize == 0
+                ? ByteStreams.toByteArray(in)
+                : ByteStreams.toByteArray(in, (int) expectedSize);
     }
 
-    // some special files may return size 0 but have content, so read
-    // the file normally in that case
-    return expectedSize == 0
-        ? ByteStreams.toByteArray(in)
-        : ByteStreams.toByteArray(in, (int) expectedSize);
-  }
-  /**
-   * Reads all bytes from a file into a byte array.
-   *
-   * @param file the file to read from
-   * @return a byte array containing all the bytes from file
-   * @throws IllegalArgumentException if the file is bigger than the largest
-   *     possible byte array (2^31 - 1)
-   * @throws IOException if an I/O error occurs
-   */
-  public static byte[] toByteArray(File file) throws IOException {
-    FileInputStream in = null;
-    try {
-      in = new FileInputStream(file);
-      return readFile(in, in.getChannel().size());
-    } finally {
-      if (in != null) {
-        in.close();
-      }
+    /**
+     * Reads all bytes from a file into a byte array.
+     *
+     * @param file the file to read from
+     * @return a byte array containing all the bytes from file
+     * @throws IllegalArgumentException if the file is bigger than the largest
+     *                                  possible byte array (2^31 - 1)
+     * @throws IOException              if an I/O error occurs
+     */
+    public static byte[] toByteArray(File file) throws IOException {
+        FileInputStream in = null;
+        try {
+            in = new FileInputStream(file);
+            return readFile(in, in.getChannel().size());
+        } finally {
+            if (in != null) {
+                in.close();
+            }
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/ImmutableMap.java b/fbcore/src/main/java/com/facebook/common/internal/ImmutableMap.java
index 8fc4fe444..3e44b9578 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/ImmutableMap.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/ImmutableMap.java
@@ -15,59 +15,60 @@
 
 /**
  * Utility class to create immutable maps.
- *
+ * <p>
  * <p>We do not replicate Guava's ImmutableMap class here. This class merely returns standard
  * {@link HashMap}s wrapped so that they throw UnsupportedOperationExceptions on any write method.
  */
 public class ImmutableMap {
-  private ImmutableMap() {}
+    private ImmutableMap() {
+    }
 
-  public static <K, V> Map<K, V> of() {
-    return Collections.unmodifiableMap(Maps.<K, V>newHashMap());
-  }
+    public static <K, V> Map<K, V> of() {
+        return Collections.unmodifiableMap(Maps.<K, V>newHashMap());
+    }
 
-  public static <K, V> Map<K, V> of(K k1, V v1) {
-    Map<K, V> map = Maps.newHashMap();
-    map.put(k1, v1);
-    return Collections.unmodifiableMap(map);
-  }
+    public static <K, V> Map<K, V> of(K k1, V v1) {
+        Map<K, V> map = Maps.newHashMap();
+        map.put(k1, v1);
+        return Collections.unmodifiableMap(map);
+    }
 
-  public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2) {
-    Map<K, V> map = Maps.newHashMap();
-    map.put(k1, v1);
-    map.put(k2, v2);
-    return Collections.unmodifiableMap(map);
-  }
+    public static <K, V> Map<K, V> of(K k1, V v1, K k2, V v2) {
+        Map<K, V> map = Maps.newHashMap();
+        map.put(k1, v1);
+        map.put(k2, v2);
+        return Collections.unmodifiableMap(map);
+    }
 
-  public static <K, V> Map<K, V> of(
-      K k1, V v1, K k2, V v2, K k3, V v3) {
-    Map<K, V> map = Maps.newHashMap();
-    map.put(k1, v1);
-    map.put(k2, v2);
-    map.put(k3, v3);
-    return Collections.unmodifiableMap(map);
-  }
+    public static <K, V> Map<K, V> of(
+            K k1, V v1, K k2, V v2, K k3, V v3) {
+        Map<K, V> map = Maps.newHashMap();
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        return Collections.unmodifiableMap(map);
+    }
 
-  public static <K, V> Map<K, V> of(
-      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
-    Map<K, V> map = Maps.newHashMap();
-    map.put(k1, v1);
-    map.put(k2, v2);
-    map.put(k3, v3);
-    map.put(k4, v4);
-    return Collections.unmodifiableMap(map);
-  }
+    public static <K, V> Map<K, V> of(
+            K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
+        Map<K, V> map = Maps.newHashMap();
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        return Collections.unmodifiableMap(map);
+    }
 
-  public static <K, V> Map<K, V> of(
-      K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
-    Map<K, V> map = Maps.newHashMap();
-    map.put(k1, v1);
-    map.put(k2, v2);
-    map.put(k3, v3);
-    map.put(k4, v4);
-    map.put(k5, v5);
-    return Collections.unmodifiableMap(map);
-  }
+    public static <K, V> Map<K, V> of(
+            K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
+        Map<K, V> map = Maps.newHashMap();
+        map.put(k1, v1);
+        map.put(k2, v2);
+        map.put(k3, v3);
+        map.put(k4, v4);
+        map.put(k5, v5);
+        return Collections.unmodifiableMap(map);
+    }
 
-  // looking for of() with > 5 entries? Use the put method instead
+    // looking for of() with > 5 entries? Use the put method instead
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Ints.java b/fbcore/src/main/java/com/facebook/common/internal/Ints.java
index fa5cbdb3b..5e0e75ce9 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Ints.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Ints.java
@@ -26,25 +26,26 @@
  * @since 1.0
  */
 public class Ints {
-  private Ints() {}
+    private Ints() {
+    }
 
-  /**
-   * Returns the greatest value present in {@code array}.
-   *
-   * @param array a <i>nonempty</i> array of {@code int} values
-   * @return the value present in {@code array} that is greater than or equal to
-   *     every other value in the array
-   * @throws IllegalArgumentException if {@code array} is empty
-   */
-  public static int max(int... array) {
-    Preconditions.checkArgument(array.length > 0);
-    int max = array[0];
-    for (int i = 1; i < array.length; i++) {
-      if (array[i] > max) {
-        max = array[i];
-      }
+    /**
+     * Returns the greatest value present in {@code array}.
+     *
+     * @param array a <i>nonempty</i> array of {@code int} values
+     * @return the value present in {@code array} that is greater than or equal to
+     * every other value in the array
+     * @throws IllegalArgumentException if {@code array} is empty
+     */
+    public static int max(int... array) {
+        Preconditions.checkArgument(array.length > 0);
+        int max = array[0];
+        for (int i = 1; i < array.length; i++) {
+            if (array[i] > max) {
+                max = array[i];
+            }
+        }
+        return max;
     }
-    return max;
-  }
 
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Lists.java b/fbcore/src/main/java/com/facebook/common/internal/Lists.java
index 8a4bc52b4..f6b980145 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Lists.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Lists.java
@@ -29,7 +29,7 @@
 /**
  * Static utility methods pertaining to {@link List} instances. Also see this
  * class's counterparts {@link Sets}, {@link Maps} and {@link Queues}.
- *
+ * <p>
  * <p>See the Guava User Guide article on <a href=
  * "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Lists">
  * {@code Lists}</a>.
@@ -40,133 +40,135 @@
  * @since 2.0 (imported from Google Collections Library)
  */
 public final class Lists {
-  private Lists() {}
+    private Lists() {
+    }
 
-  // ArrayList
+    // ArrayList
 
-  /**
-   * Creates a <i>mutable</i>, empty {@code ArrayList} instance.
-   *
-   * <p><b>Note:</b> if mutability is not required, use {@link
-   * ImmutableList#of()} instead.
-   *
-   * @return a new, empty {@code ArrayList}
-   */
-  public static <E> ArrayList<E> newArrayList() {
-    return new ArrayList<E>();
-  }
+    /**
+     * Creates a <i>mutable</i>, empty {@code ArrayList} instance.
+     * <p>
+     * <p><b>Note:</b> if mutability is not required, use {@link
+     * ImmutableList#of()} instead.
+     *
+     * @return a new, empty {@code ArrayList}
+     */
+    public static <E> ArrayList<E> newArrayList() {
+        return new ArrayList<E>();
+    }
 
-  /**
-   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given
-   * elements.
-   *
-   * <p><b>Note:</b> if mutability is not required and the elements are
-   * non-null, use an overload of {@link ImmutableList#of()} (for varargs) or
-   * {@link ImmutableList#copyOf(Object[])} (for an array) instead.
-   *
-   * @param elements the elements that the list should contain, in order
-   * @return a new {@code ArrayList} containing those elements
-   */
-  public static <E> ArrayList<E> newArrayList(E... elements) {
-    checkNotNull(elements); // for GWT
-    // Avoid integer overflow when a large array is passed in
-    int capacity = computeArrayListCapacity(elements.length);
-    ArrayList<E> list = new ArrayList<E>(capacity);
-    Collections.addAll(list, elements);
-    return list;
-  }
+    /**
+     * Creates a <i>mutable</i> {@code ArrayList} instance containing the given
+     * elements.
+     * <p>
+     * <p><b>Note:</b> if mutability is not required and the elements are
+     * non-null, use an overload of {@link ImmutableList#of()} (for varargs) or
+     * {@link ImmutableList#copyOf(Object[])} (for an array) instead.
+     *
+     * @param elements the elements that the list should contain, in order
+     * @return a new {@code ArrayList} containing those elements
+     */
+    public static <E> ArrayList<E> newArrayList(E... elements) {
+        checkNotNull(elements); // for GWT
+        // Avoid integer overflow when a large array is passed in
+        int capacity = computeArrayListCapacity(elements.length);
+        ArrayList<E> list = new ArrayList<E>(capacity);
+        Collections.addAll(list, elements);
+        return list;
+    }
 
-  @VisibleForTesting static int computeArrayListCapacity(int arraySize) {
-    Preconditions.checkArgument(arraySize >= 0);
-    long desiredSize = 5L + arraySize + (arraySize / 10);
+    @VisibleForTesting
+    static int computeArrayListCapacity(int arraySize) {
+        Preconditions.checkArgument(arraySize >= 0);
+        long desiredSize = 5L + arraySize + (arraySize / 10);
 
-    if (desiredSize > Integer.MAX_VALUE) {
-      return Integer.MAX_VALUE;
+        if (desiredSize > Integer.MAX_VALUE) {
+            return Integer.MAX_VALUE;
+        }
+        if (desiredSize < Integer.MIN_VALUE) {
+            return Integer.MIN_VALUE;
+        }
+        return (int) desiredSize;
     }
-    if (desiredSize < Integer.MIN_VALUE) {
-      return Integer.MIN_VALUE;
-    }
-    return (int) desiredSize;
-  }
 
-  /**
-   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given
-   * elements.
-   *
-   * <p><b>Note:</b> if mutability is not required and the elements are
-   * non-null, use {@link ImmutableList#copyOf(Iterator)} instead.
-   *
-   * @param elements the elements that the list should contain, in order
-   * @return a new {@code ArrayList} containing those elements
-   */
-  public static <E> ArrayList<E> newArrayList(Iterable<? extends E> elements) {
-    checkNotNull(elements);
-    // Let ArrayList's sizing logic work, if possible
-    return (elements instanceof Collection)
-        ? new ArrayList<E>((Collection<E>) elements)
-        : newArrayList(elements.iterator());
-  }
+    /**
+     * Creates a <i>mutable</i> {@code ArrayList} instance containing the given
+     * elements.
+     * <p>
+     * <p><b>Note:</b> if mutability is not required and the elements are
+     * non-null, use {@link ImmutableList#copyOf(Iterator)} instead.
+     *
+     * @param elements the elements that the list should contain, in order
+     * @return a new {@code ArrayList} containing those elements
+     */
+    public static <E> ArrayList<E> newArrayList(Iterable<? extends E> elements) {
+        checkNotNull(elements);
+        // Let ArrayList's sizing logic work, if possible
+        return (elements instanceof Collection)
+                ? new ArrayList<E>((Collection<E>) elements)
+                : newArrayList(elements.iterator());
+    }
 
-  /**
-   * Creates a <i>mutable</i> {@code ArrayList} instance containing the given
-   * elements.
-   *
-   * <p><b>Note:</b> if mutability is not required and the elements are
-   * non-null, use {@link ImmutableList#copyOf(Iterator)} instead.
-   *
-   * @param elements the elements that the list should contain, in order
-   * @return a new {@code ArrayList} containing those elements
-   */
-  public static <E> ArrayList<E> newArrayList(Iterator<? extends E> elements) {
-    checkNotNull(elements);
-    ArrayList<E> list = newArrayList();
-    while (elements.hasNext()) {
-      list.add(elements.next());
+    /**
+     * Creates a <i>mutable</i> {@code ArrayList} instance containing the given
+     * elements.
+     * <p>
+     * <p><b>Note:</b> if mutability is not required and the elements are
+     * non-null, use {@link ImmutableList#copyOf(Iterator)} instead.
+     *
+     * @param elements the elements that the list should contain, in order
+     * @return a new {@code ArrayList} containing those elements
+     */
+    public static <E> ArrayList<E> newArrayList(Iterator<? extends E> elements) {
+        checkNotNull(elements);
+        ArrayList<E> list = newArrayList();
+        while (elements.hasNext()) {
+            list.add(elements.next());
+        }
+        return list;
     }
-    return list;
-  }
 
-  /**
-   * Creates an {@code ArrayList} instance backed by an array of the
-   * <i>exact</i> size specified; equivalent to
-   * {@link ArrayList#ArrayList(int)}.
-   *
-   * <p><b>Note:</b> if you know the exact size your list will be, consider
-   * using a fixed-size list ({@link Arrays#asList(Object[])}) or an {@link
-   * ImmutableList} instead of a growable {@link ArrayList}.
-   *
-   * <p><b>Note:</b> If you have only an <i>estimate</i> of the eventual size of
-   * the list, consider padding this estimate by a suitable amount, or simply
-   * use {@link #newArrayListWithExpectedSize(int)} instead.
-   *
-   * @param initialArraySize the exact size of the initial backing array for
-   *     the returned array list ({@code ArrayList} documentation calls this
-   *     value the "capacity")
-   * @return a new, empty {@code ArrayList} which is guaranteed not to resize
-   *     itself unless its size reaches {@code initialArraySize + 1}
-   * @throws IllegalArgumentException if {@code initialArraySize} is negative
-   */
-  public static <E> ArrayList<E> newArrayListWithCapacity(int initialArraySize) {
-    return new ArrayList<E>(initialArraySize);
-  }
+    /**
+     * Creates an {@code ArrayList} instance backed by an array of the
+     * <i>exact</i> size specified; equivalent to
+     * {@link ArrayList#ArrayList(int)}.
+     * <p>
+     * <p><b>Note:</b> if you know the exact size your list will be, consider
+     * using a fixed-size list ({@link Arrays#asList(Object[])}) or an {@link
+     * ImmutableList} instead of a growable {@link ArrayList}.
+     * <p>
+     * <p><b>Note:</b> If you have only an <i>estimate</i> of the eventual size of
+     * the list, consider padding this estimate by a suitable amount, or simply
+     * use {@link #newArrayListWithExpectedSize(int)} instead.
+     *
+     * @param initialArraySize the exact size of the initial backing array for
+     *                         the returned array list ({@code ArrayList} documentation calls this
+     *                         value the "capacity")
+     * @return a new, empty {@code ArrayList} which is guaranteed not to resize
+     * itself unless its size reaches {@code initialArraySize + 1}
+     * @throws IllegalArgumentException if {@code initialArraySize} is negative
+     */
+    public static <E> ArrayList<E> newArrayListWithCapacity(int initialArraySize) {
+        return new ArrayList<E>(initialArraySize);
+    }
 
-  /**
-   * Creates an {@code ArrayList} instance sized appropriately to hold an
-   * <i>estimated</i> number of elements without resizing. A small amount of
-   * padding is added in case the estimate is low.
-   *
-   * <p><b>Note:</b> If you know the <i>exact</i> number of elements the list
-   * will hold, or prefer to calculate your own amount of padding, refer to
-   * {@link #newArrayListWithCapacity(int)}.
-   *
-   * @param estimatedSize an estimate of the eventual {@link List#size()} of
-   *     the new list
-   * @return a new, empty {@code ArrayList}, sized appropriately to hold the
-   *     estimated number of elements
-   * @throws IllegalArgumentException if {@code estimatedSize} is negative
-   */
-  public static <E> ArrayList<E> newArrayListWithExpectedSize(
-      int estimatedSize) {
-    return new ArrayList<E>(computeArrayListCapacity(estimatedSize));
-  }
+    /**
+     * Creates an {@code ArrayList} instance sized appropriately to hold an
+     * <i>estimated</i> number of elements without resizing. A small amount of
+     * padding is added in case the estimate is low.
+     * <p>
+     * <p><b>Note:</b> If you know the <i>exact</i> number of elements the list
+     * will hold, or prefer to calculate your own amount of padding, refer to
+     * {@link #newArrayListWithCapacity(int)}.
+     *
+     * @param estimatedSize an estimate of the eventual {@link List#size()} of
+     *                      the new list
+     * @return a new, empty {@code ArrayList}, sized appropriately to hold the
+     * estimated number of elements
+     * @throws IllegalArgumentException if {@code estimatedSize} is negative
+     */
+    public static <E> ArrayList<E> newArrayListWithExpectedSize(
+            int estimatedSize) {
+        return new ArrayList<E>(computeArrayListCapacity(estimatedSize));
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Maps.java b/fbcore/src/main/java/com/facebook/common/internal/Maps.java
index c90bfc5dc..278be6a3a 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Maps.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Maps.java
@@ -30,23 +30,24 @@
  * @since 2.0 (imported from Google Collections Library)
  */
 public final class Maps {
-  private Maps() {}
+    private Maps() {
+    }
 
-  /**
-   * Creates a <i>mutable</i>, empty {@code HashMap} instance.
-   *
-   * @return a new, empty {@code HashMap}
-   */
-  public static <K, V> HashMap<K, V> newHashMap() {
-    return new HashMap<K, V>();
-  }
+    /**
+     * Creates a <i>mutable</i>, empty {@code HashMap} instance.
+     *
+     * @return a new, empty {@code HashMap}
+     */
+    public static <K, V> HashMap<K, V> newHashMap() {
+        return new HashMap<K, V>();
+    }
 
-  /**
-   * Creates an {@code IdentityHashMap} instance.
-   *
-   * @return a new, empty {@code IdentityHashMap}
-   */
-  public static <K, V> IdentityHashMap<K, V> newIdentityHashMap() {
-    return new IdentityHashMap<K, V>();
-  }
+    /**
+     * Creates an {@code IdentityHashMap} instance.
+     *
+     * @return a new, empty {@code IdentityHashMap}
+     */
+    public static <K, V> IdentityHashMap<K, V> newIdentityHashMap() {
+        return new IdentityHashMap<K, V>();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Objects.java b/fbcore/src/main/java/com/facebook/common/internal/Objects.java
index 8f83f4fc4..95ea1fe75 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Objects.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Objects.java
@@ -25,7 +25,7 @@
 
 /**
  * Helper functions that can operate on any {@code Object}.
- *
+ * <p>
  * <p>See the Guava User Guide on <a
  * href="http://code.google.com/p/guava-libraries/wiki/CommonObjectUtilitiesExplained">writing
  * {@code Object} methods with {@code Objects}</a>.
@@ -34,396 +34,398 @@
  * @since 2.0 (imported from Google Collections Library)
  */
 public final class Objects {
-  private Objects() {}
-
-  /**
-   * Determines whether two possibly-null objects are equal. Returns:
-   *
-   * <ul>
-   * <li>{@code true} if {@code a} and {@code b} are both null.
-   * <li>{@code true} if {@code a} and {@code b} are both non-null and they are
-   *     equal according to {@link Object#equals(Object)}.
-   * <li>{@code false} in all other situations.
-   * </ul>
-   *
-   * <p>This assumes that any non-null objects passed to this function conform
-   * to the {@code equals()} contract.
-   */
-  @CheckReturnValue
-  public static boolean equal(@Nullable Object a, @Nullable Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  /**
-   * Generates a hash code for multiple values. The hash code is generated by
-   * calling {@link Arrays#hashCode(Object[])}. Note that array arguments to
-   * this method, with the exception of a single Object array, do not get any
-   * special handling; their hash codes are based on identity and not contents.
-   *
-   * <p>This is useful for implementing {@link Object#hashCode()}. For example,
-   * in an object that has three properties, {@code x}, {@code y}, and
-   * {@code z}, one could write:
-   * <pre>   {@code
-   *   public int hashCode() {
-   *     return Objects.hashCode(getX(), getY(), getZ());
-   *   }}</pre>
-   *
-   * <p><b>Warning</b>: When a single object is supplied, the returned hash code
-   * does not equal the hash code of that object.
-   */
-  public static int hashCode(@Nullable Object... objects) {
-    return Arrays.hashCode(objects);
-  }
-
-  /**
-   * Creates an instance of {@link ToStringHelper}.
-   *
-   * <p>This is helpful for implementing {@link Object#toString()}.
-   * Specification by example: <pre>   {@code
-   *   // Returns "ClassName{}"
-   *   Objects.toStringHelper(this)
-   *       .toString();
-   *
-   *   // Returns "ClassName{x=1}"
-   *   Objects.toStringHelper(this)
-   *       .add("x", 1)
-   *       .toString();
-   *
-   *   // Returns "MyObject{x=1}"
-   *   Objects.toStringHelper("MyObject")
-   *       .add("x", 1)
-   *       .toString();
-   *
-   *   // Returns "ClassName{x=1, y=foo}"
-   *   Objects.toStringHelper(this)
-   *       .add("x", 1)
-   *       .add("y", "foo")
-   *       .toString();
-   *
-   *   // Returns "ClassName{x=1}"
-   *   Objects.toStringHelper(this)
-   *       .omitNullValues()
-   *       .add("x", 1)
-   *       .add("y", null)
-   *       .toString();
-   *   }}</pre>
-   *
-   * <p>Note that in GWT, class names are often obfuscated.
-   *
-   * @param self the object to generate the string for (typically {@code this}),
-   *        used only for its class name
-   * @since 2.0
-   */
-  public static ToStringHelper toStringHelper(Object self) {
-    return new ToStringHelper(simpleName(self.getClass()));
-  }
-
-  /**
-   * Creates an instance of {@link ToStringHelper} in the same manner as
-   * {@link Objects#toStringHelper(Object)}, but using the name of {@code clazz}
-   * instead of using an instance's {@link Object#getClass()}.
-   *
-   * <p>Note that in GWT, class names are often obfuscated.
-   *
-   * @param clazz the {@link Class} of the instance
-   * @since 7.0 (source-compatible since 2.0)
-   */
-  public static ToStringHelper toStringHelper(Class<?> clazz) {
-    return new ToStringHelper(simpleName(clazz));
-  }
-
-  /**
-   * Creates an instance of {@link ToStringHelper} in the same manner as
-   * {@link Objects#toStringHelper(Object)}, but using {@code className} instead
-   * of using an instance's {@link Object#getClass()}.
-   *
-   * @param className the name of the instance type
-   * @since 7.0 (source-compatible since 2.0)
-   */
-  public static ToStringHelper toStringHelper(String className) {
-    return new ToStringHelper(className);
-  }
-
-  /**
-   * {@link Class#getSimpleName()} is not GWT compatible yet, so we
-   * provide our own implementation.
-   */
-  private static String simpleName(Class<?> clazz) {
-    String name = clazz.getName();
-
-    // the nth anonymous class has a class name ending in "Outer$n"
-    // and local inner classes have names ending in "Outer.$1Inner"
-    name = name.replaceAll("\\$[0-9]+", "\\$");
-
-    // we want the name of the inner class all by its lonesome
-    int start = name.lastIndexOf('$');
-
-    // if this isn't an inner class, just find the start of the
-    // top level class name.
-    if (start == -1) {
-      start = name.lastIndexOf('.');
-    }
-    return name.substring(start + 1);
-  }
-
-  /**
-   * Returns the first of two given parameters that is not {@code null}, if
-   * either is, or otherwise throws a {@link NullPointerException}.
-   *
-   * <p><b>Note:</b> if {@code first} is represented as an {@link Optional},
-   * this can be accomplished with
-   * {@linkplain Optional#or(Object) first.or(second)}.
-   * That approach also allows for lazy evaluation of the fallback instance,
-   * using {@linkplain Optional#or(Supplier) first.or(Supplier)}.
-   *
-   * @return {@code first} if {@code first} is not {@code null}, or
-   *     {@code second} if {@code first} is {@code null} and {@code second} is
-   *     not {@code null}
-   * @throws NullPointerException if both {@code first} and {@code second} were
-   *     {@code null}
-   * @since 3.0
-   */
-  public static <T> T firstNonNull(@Nullable T first, @Nullable T second) {
-    return first != null ? first : checkNotNull(second);
-  }
-
-  /**
-   * Support class for {@link Objects#toStringHelper}.
-   *
-   * @author Jason Lee
-   * @since 2.0
-   */
-  public static final class ToStringHelper {
-    private final String className;
-    private ValueHolder holderHead = new ValueHolder();
-    private ValueHolder holderTail = holderHead;
-    private boolean omitNullValues = false;
-
-    /**
-     * Use {@link Objects#toStringHelper(Object)} to create an instance.
-     */
-    private ToStringHelper(String className) {
-      this.className = checkNotNull(className);
+    private Objects() {
     }
 
     /**
-     * Configures the {@link ToStringHelper} so {@link #toString()} will ignore
-     * properties with null value. The order of calling this method, relative
-     * to the {@code add()}/{@code addValue()} methods, is not significant.
-     *
-     * @since 12.0
+     * Determines whether two possibly-null objects are equal. Returns:
+     * <p>
+     * <ul>
+     * <li>{@code true} if {@code a} and {@code b} are both null.
+     * <li>{@code true} if {@code a} and {@code b} are both non-null and they are
+     * equal according to {@link Object#equals(Object)}.
+     * <li>{@code false} in all other situations.
+     * </ul>
+     * <p>
+     * <p>This assumes that any non-null objects passed to this function conform
+     * to the {@code equals()} contract.
      */
-    public ToStringHelper omitNullValues() {
-      omitNullValues = true;
-      return this;
+    @CheckReturnValue
+    public static boolean equal(@Nullable Object a, @Nullable Object b) {
+        return a == b || (a != null && a.equals(b));
     }
 
     /**
-     * Adds a name/value pair to the formatted output in {@code name=value}
-     * format. If {@code value} is {@code null}, the string {@code "null"}
-     * is used, unless {@link #omitNullValues()} is called, in which case this
-     * name/value pair will not be added.
+     * Generates a hash code for multiple values. The hash code is generated by
+     * calling {@link Arrays#hashCode(Object[])}. Note that array arguments to
+     * this method, with the exception of a single Object array, do not get any
+     * special handling; their hash codes are based on identity and not contents.
+     * <p>
+     * <p>This is useful for implementing {@link Object#hashCode()}. For example,
+     * in an object that has three properties, {@code x}, {@code y}, and
+     * {@code z}, one could write:
+     * <pre>   {@code
+     *   public int hashCode() {
+     *     return Objects.hashCode(getX(), getY(), getZ());
+     *   }}</pre>
+     * <p>
+     * <p><b>Warning</b>: When a single object is supplied, the returned hash code
+     * does not equal the hash code of that object.
      */
-    public ToStringHelper add(String name, @Nullable Object value) {
-      return addHolder(name, value);
+    public static int hashCode(@Nullable Object... objects) {
+        return Arrays.hashCode(objects);
     }
 
     /**
-     * Adds a name/value pair to the formatted output in {@code name=value}
-     * format.
+     * Creates an instance of {@link ToStringHelper}.
+     * <p>
+     * <p>This is helpful for implementing {@link Object#toString()}.
+     * Specification by example: <pre>   {@code
+     *   // Returns "ClassName{}"
+     *   Objects.toStringHelper(this)
+     *       .toString();
+     * <p>
+     *   // Returns "ClassName{x=1}"
+     *   Objects.toStringHelper(this)
+     *       .add("x", 1)
+     *       .toString();
+     * <p>
+     *   // Returns "MyObject{x=1}"
+     *   Objects.toStringHelper("MyObject")
+     *       .add("x", 1)
+     *       .toString();
+     * <p>
+     *   // Returns "ClassName{x=1, y=foo}"
+     *   Objects.toStringHelper(this)
+     *       .add("x", 1)
+     *       .add("y", "foo")
+     *       .toString();
+     * <p>
+     *   // Returns "ClassName{x=1}"
+     *   Objects.toStringHelper(this)
+     *       .omitNullValues()
+     *       .add("x", 1)
+     *       .add("y", null)
+     *       .toString();
+     *   }}</pre>
+     * <p>
+     * <p>Note that in GWT, class names are often obfuscated.
      *
-     * @since 11.0 (source-compatible since 2.0)
+     * @param self the object to generate the string for (typically {@code this}),
+     *             used only for its class name
+     * @since 2.0
      */
-    public ToStringHelper add(String name, boolean value) {
-      return addHolder(name, String.valueOf(value));
+    public static ToStringHelper toStringHelper(Object self) {
+        return new ToStringHelper(simpleName(self.getClass()));
     }
 
     /**
-     * Adds a name/value pair to the formatted output in {@code name=value}
-     * format.
+     * Creates an instance of {@link ToStringHelper} in the same manner as
+     * {@link Objects#toStringHelper(Object)}, but using the name of {@code clazz}
+     * instead of using an instance's {@link Object#getClass()}.
+     * <p>
+     * <p>Note that in GWT, class names are often obfuscated.
      *
-     * @since 11.0 (source-compatible since 2.0)
+     * @param clazz the {@link Class} of the instance
+     * @since 7.0 (source-compatible since 2.0)
      */
-    public ToStringHelper add(String name, char value) {
-      return addHolder(name, String.valueOf(value));
+    public static ToStringHelper toStringHelper(Class<?> clazz) {
+        return new ToStringHelper(simpleName(clazz));
     }
 
     /**
-     * Adds a name/value pair to the formatted output in {@code name=value}
-     * format.
+     * Creates an instance of {@link ToStringHelper} in the same manner as
+     * {@link Objects#toStringHelper(Object)}, but using {@code className} instead
+     * of using an instance's {@link Object#getClass()}.
      *
-     * @since 11.0 (source-compatible since 2.0)
+     * @param className the name of the instance type
+     * @since 7.0 (source-compatible since 2.0)
      */
-    public ToStringHelper add(String name, double value) {
-      return addHolder(name, String.valueOf(value));
+    public static ToStringHelper toStringHelper(String className) {
+        return new ToStringHelper(className);
     }
 
     /**
-     * Adds a name/value pair to the formatted output in {@code name=value}
-     * format.
-     *
-     * @since 11.0 (source-compatible since 2.0)
+     * {@link Class#getSimpleName()} is not GWT compatible yet, so we
+     * provide our own implementation.
      */
-    public ToStringHelper add(String name, float value) {
-      return addHolder(name, String.valueOf(value));
-    }
+    private static String simpleName(Class<?> clazz) {
+        String name = clazz.getName();
 
-    /**
-     * Adds a name/value pair to the formatted output in {@code name=value}
-     * format.
-     *
-     * @since 11.0 (source-compatible since 2.0)
-     */
-    public ToStringHelper add(String name, int value) {
-      return addHolder(name, String.valueOf(value));
-    }
+        // the nth anonymous class has a class name ending in "Outer$n"
+        // and local inner classes have names ending in "Outer.$1Inner"
+        name = name.replaceAll("\\$[0-9]+", "\\$");
 
-    /**
-     * Adds a name/value pair to the formatted output in {@code name=value}
-     * format.
-     *
-     * @since 11.0 (source-compatible since 2.0)
-     */
-    public ToStringHelper add(String name, long value) {
-      return addHolder(name, String.valueOf(value));
-    }
+        // we want the name of the inner class all by its lonesome
+        int start = name.lastIndexOf('$');
 
-    /**
-     * Adds an unnamed value to the formatted output.
-     *
-     * <p>It is strongly encouraged to use {@link #add(String, Object)} instead
-     * and give value a readable name.
-     */
-    public ToStringHelper addValue(@Nullable Object value) {
-      return addHolder(value);
+        // if this isn't an inner class, just find the start of the
+        // top level class name.
+        if (start == -1) {
+            start = name.lastIndexOf('.');
+        }
+        return name.substring(start + 1);
     }
 
     /**
-     * Adds an unnamed value to the formatted output.
-     *
-     * <p>It is strongly encouraged to use {@link #add(String, boolean)} instead
-     * and give value a readable name.
+     * Returns the first of two given parameters that is not {@code null}, if
+     * either is, or otherwise throws a {@link NullPointerException}.
+     * <p>
+     * <p><b>Note:</b> if {@code first} is represented as an {@link Optional},
+     * this can be accomplished with
+     * {@linkplain Optional#or(Object) first.or(second)}.
+     * That approach also allows for lazy evaluation of the fallback instance,
+     * using {@linkplain Optional#or(Supplier) first.or(Supplier)}.
      *
-     * @since 11.0 (source-compatible since 2.0)
+     * @return {@code first} if {@code first} is not {@code null}, or
+     * {@code second} if {@code first} is {@code null} and {@code second} is
+     * not {@code null}
+     * @throws NullPointerException if both {@code first} and {@code second} were
+     *                              {@code null}
+     * @since 3.0
      */
-    public ToStringHelper addValue(boolean value) {
-      return addHolder(String.valueOf(value));
+    public static <T> T firstNonNull(@Nullable T first, @Nullable T second) {
+        return first != null ? first : checkNotNull(second);
     }
 
     /**
-     * Adds an unnamed value to the formatted output.
+     * Support class for {@link Objects#toStringHelper}.
      *
-     * <p>It is strongly encouraged to use {@link #add(String, char)} instead
-     * and give value a readable name.
-     *
-     * @since 11.0 (source-compatible since 2.0)
+     * @author Jason Lee
+     * @since 2.0
      */
-    public ToStringHelper addValue(char value) {
-      return addHolder(String.valueOf(value));
-    }
+    public static final class ToStringHelper {
+        private final String className;
+        private ValueHolder holderHead = new ValueHolder();
+        private ValueHolder holderTail = holderHead;
+        private boolean omitNullValues = false;
+
+        /**
+         * Use {@link Objects#toStringHelper(Object)} to create an instance.
+         */
+        private ToStringHelper(String className) {
+            this.className = checkNotNull(className);
+        }
 
-    /**
-     * Adds an unnamed value to the formatted output.
-     *
-     * <p>It is strongly encouraged to use {@link #add(String, double)} instead
-     * and give value a readable name.
-     *
-     * @since 11.0 (source-compatible since 2.0)
-     */
-    public ToStringHelper addValue(double value) {
-      return addHolder(String.valueOf(value));
-    }
+        /**
+         * Configures the {@link ToStringHelper} so {@link #toString()} will ignore
+         * properties with null value. The order of calling this method, relative
+         * to the {@code add()}/{@code addValue()} methods, is not significant.
+         *
+         * @since 12.0
+         */
+        public ToStringHelper omitNullValues() {
+            omitNullValues = true;
+            return this;
+        }
 
-    /**
-     * Adds an unnamed value to the formatted output.
-     *
-     * <p>It is strongly encouraged to use {@link #add(String, float)} instead
-     * and give value a readable name.
-     *
-     * @since 11.0 (source-compatible since 2.0)
-     */
-    public ToStringHelper addValue(float value) {
-      return addHolder(String.valueOf(value));
-    }
+        /**
+         * Adds a name/value pair to the formatted output in {@code name=value}
+         * format. If {@code value} is {@code null}, the string {@code "null"}
+         * is used, unless {@link #omitNullValues()} is called, in which case this
+         * name/value pair will not be added.
+         */
+        public ToStringHelper add(String name, @Nullable Object value) {
+            return addHolder(name, value);
+        }
 
-    /**
-     * Adds an unnamed value to the formatted output.
-     *
-     * <p>It is strongly encouraged to use {@link #add(String, int)} instead
-     * and give value a readable name.
-     *
-     * @since 11.0 (source-compatible since 2.0)
-     */
-    public ToStringHelper addValue(int value) {
-      return addHolder(String.valueOf(value));
-    }
+        /**
+         * Adds a name/value pair to the formatted output in {@code name=value}
+         * format.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper add(String name, boolean value) {
+            return addHolder(name, String.valueOf(value));
+        }
 
-    /**
-     * Adds an unnamed value to the formatted output.
-     *
-     * <p>It is strongly encouraged to use {@link #add(String, long)} instead
-     * and give value a readable name.
-     *
-     * @since 11.0 (source-compatible since 2.0)
-     */
-    public ToStringHelper addValue(long value) {
-      return addHolder(String.valueOf(value));
-    }
+        /**
+         * Adds a name/value pair to the formatted output in {@code name=value}
+         * format.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper add(String name, char value) {
+            return addHolder(name, String.valueOf(value));
+        }
 
-    /**
-     * Returns a string in the format specified by {@link
-     * Objects#toStringHelper(Object)}.
-     *
-     * <p>After calling this method, you can keep adding more properties to later
-     * call toString() again and get a more complete representation of the
-     * same object; but properties cannot be removed, so this only allows
-     * limited reuse of the helper instance. The helper allows duplication of
-     * properties (multiple name/value pairs with the same name can be added).
-     */
-    @Override public String toString() {
-      // create a copy to keep it consistent in case value changes
-      boolean omitNullValuesSnapshot = omitNullValues;
-      String nextSeparator = "";
-      StringBuilder builder = new StringBuilder(32).append(className)
-          .append('{');
-      for (ValueHolder valueHolder = holderHead.next; valueHolder != null;
-          valueHolder = valueHolder.next) {
-        if (!omitNullValuesSnapshot || valueHolder.value != null) {
-          builder.append(nextSeparator);
-          nextSeparator = ", ";
-
-          if (valueHolder.name != null) {
-            builder.append(valueHolder.name).append('=');
-          }
-          builder.append(valueHolder.value);
+        /**
+         * Adds a name/value pair to the formatted output in {@code name=value}
+         * format.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper add(String name, double value) {
+            return addHolder(name, String.valueOf(value));
         }
-      }
-      return builder.append('}').toString();
-    }
 
-    private ValueHolder addHolder() {
-      ValueHolder valueHolder = new ValueHolder();
-      holderTail = holderTail.next = valueHolder;
-      return valueHolder;
-    }
+        /**
+         * Adds a name/value pair to the formatted output in {@code name=value}
+         * format.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper add(String name, float value) {
+            return addHolder(name, String.valueOf(value));
+        }
 
-    private ToStringHelper addHolder(@Nullable Object value) {
-      ValueHolder valueHolder = addHolder();
-      valueHolder.value = value;
-      return this;
-    }
+        /**
+         * Adds a name/value pair to the formatted output in {@code name=value}
+         * format.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper add(String name, int value) {
+            return addHolder(name, String.valueOf(value));
+        }
 
-    private ToStringHelper addHolder(String name, @Nullable Object value) {
-      ValueHolder valueHolder = addHolder();
-      valueHolder.value = value;
-      valueHolder.name = checkNotNull(name);
-      return this;
-    }
+        /**
+         * Adds a name/value pair to the formatted output in {@code name=value}
+         * format.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper add(String name, long value) {
+            return addHolder(name, String.valueOf(value));
+        }
+
+        /**
+         * Adds an unnamed value to the formatted output.
+         * <p>
+         * <p>It is strongly encouraged to use {@link #add(String, Object)} instead
+         * and give value a readable name.
+         */
+        public ToStringHelper addValue(@Nullable Object value) {
+            return addHolder(value);
+        }
+
+        /**
+         * Adds an unnamed value to the formatted output.
+         * <p>
+         * <p>It is strongly encouraged to use {@link #add(String, boolean)} instead
+         * and give value a readable name.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper addValue(boolean value) {
+            return addHolder(String.valueOf(value));
+        }
+
+        /**
+         * Adds an unnamed value to the formatted output.
+         * <p>
+         * <p>It is strongly encouraged to use {@link #add(String, char)} instead
+         * and give value a readable name.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper addValue(char value) {
+            return addHolder(String.valueOf(value));
+        }
+
+        /**
+         * Adds an unnamed value to the formatted output.
+         * <p>
+         * <p>It is strongly encouraged to use {@link #add(String, double)} instead
+         * and give value a readable name.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper addValue(double value) {
+            return addHolder(String.valueOf(value));
+        }
+
+        /**
+         * Adds an unnamed value to the formatted output.
+         * <p>
+         * <p>It is strongly encouraged to use {@link #add(String, float)} instead
+         * and give value a readable name.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper addValue(float value) {
+            return addHolder(String.valueOf(value));
+        }
+
+        /**
+         * Adds an unnamed value to the formatted output.
+         * <p>
+         * <p>It is strongly encouraged to use {@link #add(String, int)} instead
+         * and give value a readable name.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper addValue(int value) {
+            return addHolder(String.valueOf(value));
+        }
+
+        /**
+         * Adds an unnamed value to the formatted output.
+         * <p>
+         * <p>It is strongly encouraged to use {@link #add(String, long)} instead
+         * and give value a readable name.
+         *
+         * @since 11.0 (source-compatible since 2.0)
+         */
+        public ToStringHelper addValue(long value) {
+            return addHolder(String.valueOf(value));
+        }
+
+        /**
+         * Returns a string in the format specified by {@link
+         * Objects#toStringHelper(Object)}.
+         * <p>
+         * <p>After calling this method, you can keep adding more properties to later
+         * call toString() again and get a more complete representation of the
+         * same object; but properties cannot be removed, so this only allows
+         * limited reuse of the helper instance. The helper allows duplication of
+         * properties (multiple name/value pairs with the same name can be added).
+         */
+        @Override
+        public String toString() {
+            // create a copy to keep it consistent in case value changes
+            boolean omitNullValuesSnapshot = omitNullValues;
+            String nextSeparator = "";
+            StringBuilder builder = new StringBuilder(32).append(className)
+                    .append('{');
+            for (ValueHolder valueHolder = holderHead.next; valueHolder != null;
+                 valueHolder = valueHolder.next) {
+                if (!omitNullValuesSnapshot || valueHolder.value != null) {
+                    builder.append(nextSeparator);
+                    nextSeparator = ", ";
+
+                    if (valueHolder.name != null) {
+                        builder.append(valueHolder.name).append('=');
+                    }
+                    builder.append(valueHolder.value);
+                }
+            }
+            return builder.append('}').toString();
+        }
+
+        private ValueHolder addHolder() {
+            ValueHolder valueHolder = new ValueHolder();
+            holderTail = holderTail.next = valueHolder;
+            return valueHolder;
+        }
 
-    private static final class ValueHolder {
-      String name;
-      Object value;
-      ValueHolder next;
+        private ToStringHelper addHolder(@Nullable Object value) {
+            ValueHolder valueHolder = addHolder();
+            valueHolder.value = value;
+            return this;
+        }
+
+        private ToStringHelper addHolder(String name, @Nullable Object value) {
+            ValueHolder valueHolder = addHolder();
+            valueHolder.value = value;
+            valueHolder.name = checkNotNull(name);
+            return this;
+        }
+
+        private static final class ValueHolder {
+            String name;
+            Object value;
+            ValueHolder next;
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Preconditions.java b/fbcore/src/main/java/com/facebook/common/internal/Preconditions.java
index d825ce8b5..a8ff482c6 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Preconditions.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Preconditions.java
@@ -24,7 +24,7 @@
  * {@code null}) is passed instead, the {@code Preconditions} method throws an unchecked exception,
  * which helps the calling method communicate to <i>its</i> caller that <i>that</i> caller has made
  * a mistake. Example: <pre>   {@code
- *
+ * <p>
  *   /**
  *    * Returns the positive square root of the given value.
  *    *
@@ -34,16 +34,16 @@
  *     Preconditions.checkArgument(value >= 0.0, "negative value: %s", value);
  *     // calculate the square root
  *   }
- *
+ * <p>
  *   void exampleBadCaller() {
  *     double d = sqrt(-1.0);
  *   }}</pre>
- *
+ * <p>
  * In this example, {@code checkArgument} throws an {@code IllegalArgumentException} to indicate
  * that {@code exampleBadCaller} made an error in <i>its</i> call to {@code sqrt}.
- *
+ * <p>
  * <h3>Warning about performance</h3>
- *
+ * <p>
  * <p>The goal of this class is to improve readability of code, but in some circumstances this may
  * come at a significant performance cost. Remember that parameter values for message construction
  * must all be computed eagerly, and autoboxing and varargs array creation may happen as well, even
@@ -55,38 +55,38 @@
  *   if (value < 0.0) {
  *     throw new IllegalArgumentException("negative value: " + value);
  *   }}</pre>
- *
+ * <p>
  * <h3>Other types of preconditions</h3>
- *
+ * <p>
  * <p>Not every type of precondition failure is supported by these methods. Continue to throw
  * standard JDK exceptions such as {@link java.util.NoSuchElementException} or {@link
  * UnsupportedOperationException} in the situations they are intended for.
- *
+ * <p>
  * <h3>Non-preconditions</h3>
- *
+ * <p>
  * <p>It is of course possible to use the methods of this class to check for invalid conditions
  * which are <i>not the caller's fault</i>. Doing so is <b>not recommended</b> because it is
  * misleading to future readers of the code and of stack traces. See
  * <a href="http://code.google.com/p/guava-libraries/wiki/ConditionalFailuresExplained">Conditional
  * failures explained</a> in the Guava User Guide for more advice.
- *
+ * <p>
  * <h3>{@code java.util.Objects.requireNonNull()}</h3>
- *
+ * <p>
  * <p>Projects which use {@code com.google.common} should generally avoid the use of {@link
  * java.util.Objects#requireNonNull(Object)}. Instead, use whichever of {@link
  * #checkNotNull(Object)} or {@link Verify#verifyNotNull(Object)} is appropriate to the situation.
  * (The same goes for the message-accepting overloads.)
- *
+ * <p>
  * <h3>Only {@code %s} is supported</h3>
- *
+ * <p>
  * <p>In {@code Preconditions} error message template strings, only the {@code "%s"} specifier is
  * supported, not the full range of {@link java.util.Formatter} specifiers. However, note that if
  * the number of arguments does not match the number of occurrences of {@code "%s"} in the format
  * string, {@code Preconditions} will still behave as expected, and will still include all argument
  * values in the error message; the message will simply not be formatted exactly as intended.
- *
+ * <p>
  * <h3>More information</h3>
- *
+ * <p>
  * <p>See the Guava User Guide on
  * <a href="http://code.google.com/p/guava-libraries/wiki/PreconditionsExplained">using {@code
  * Preconditions}</a>.
@@ -95,162 +95,163 @@
  * @since 2.0 (imported from Google Collections Library)
  */
 public final class Preconditions {
-  private Preconditions() {}
+    private Preconditions() {
+    }
 
-  /**
-   * Ensures the truth of an expression involving one or more parameters to the calling method.
-   *
-   * @param expression a boolean expression
-   * @throws IllegalArgumentException if {@code expression} is false
-   */
-  public static void checkArgument(boolean expression) {
-    if (!expression) {
-      throw new IllegalArgumentException();
+    /**
+     * Ensures the truth of an expression involving one or more parameters to the calling method.
+     *
+     * @param expression a boolean expression
+     * @throws IllegalArgumentException if {@code expression} is false
+     */
+    public static void checkArgument(boolean expression) {
+        if (!expression) {
+            throw new IllegalArgumentException();
+        }
     }
-  }
 
-  /**
-   * Ensures the truth of an expression involving one or more parameters to the calling method.
-   *
-   * @param expression a boolean expression
-   * @param errorMessage the exception message to use if the check fails; will be converted to a
-   *     string using {@link String#valueOf(Object)}
-   * @throws IllegalArgumentException if {@code expression} is false
-   */
-  public static void checkArgument(boolean expression, @Nullable Object errorMessage) {
-    if (!expression) {
-      throw new IllegalArgumentException(String.valueOf(errorMessage));
+    /**
+     * Ensures the truth of an expression involving one or more parameters to the calling method.
+     *
+     * @param expression   a boolean expression
+     * @param errorMessage the exception message to use if the check fails; will be converted to a
+     *                     string using {@link String#valueOf(Object)}
+     * @throws IllegalArgumentException if {@code expression} is false
+     */
+    public static void checkArgument(boolean expression, @Nullable Object errorMessage) {
+        if (!expression) {
+            throw new IllegalArgumentException(String.valueOf(errorMessage));
+        }
     }
-  }
 
-  /**
-   * Ensures the truth of an expression involving one or more parameters to the calling method.
-   *
-   * @param expression a boolean expression
-   * @param errorMessageTemplate a template for the exception message should the check fail. The
-   *     message is formed by replacing each {@code %s} placeholder in the template with an
-   *     argument. These are matched by position - the first {@code %s} gets {@code
-   *     errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message
-   *     in square braces. Unmatched placeholders will be left as-is.
-   * @param errorMessageArgs the arguments to be substituted into the message template. Arguments
-   *     are converted to strings using {@link String#valueOf(Object)}.
-   * @throws IllegalArgumentException if {@code expression} is false
-   * @throws NullPointerException if the check fails and either {@code errorMessageTemplate} or
-   *     {@code errorMessageArgs} is null (don't let this happen)
-   */
-  public static void checkArgument(boolean expression,
-      @Nullable String errorMessageTemplate,
-      @Nullable Object... errorMessageArgs) {
-    if (!expression) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, errorMessageArgs));
+    /**
+     * Ensures the truth of an expression involving one or more parameters to the calling method.
+     *
+     * @param expression           a boolean expression
+     * @param errorMessageTemplate a template for the exception message should the check fail. The
+     *                             message is formed by replacing each {@code %s} placeholder in the template with an
+     *                             argument. These are matched by position - the first {@code %s} gets {@code
+     *                             errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message
+     *                             in square braces. Unmatched placeholders will be left as-is.
+     * @param errorMessageArgs     the arguments to be substituted into the message template. Arguments
+     *                             are converted to strings using {@link String#valueOf(Object)}.
+     * @throws IllegalArgumentException if {@code expression} is false
+     * @throws NullPointerException     if the check fails and either {@code errorMessageTemplate} or
+     *                                  {@code errorMessageArgs} is null (don't let this happen)
+     */
+    public static void checkArgument(boolean expression,
+                                     @Nullable String errorMessageTemplate,
+                                     @Nullable Object... errorMessageArgs) {
+        if (!expression) {
+            throw new IllegalArgumentException(format(errorMessageTemplate, errorMessageArgs));
+        }
     }
-  }
 
-  /**
-   * Ensures the truth of an expression involving the state of the calling instance, but not
-   * involving any parameters to the calling method.
-   *
-   * @param expression a boolean expression
-   * @throws IllegalStateException if {@code expression} is false
-   */
-  public static void checkState(boolean expression) {
-    if (!expression) {
-      throw new IllegalStateException();
+    /**
+     * Ensures the truth of an expression involving the state of the calling instance, but not
+     * involving any parameters to the calling method.
+     *
+     * @param expression a boolean expression
+     * @throws IllegalStateException if {@code expression} is false
+     */
+    public static void checkState(boolean expression) {
+        if (!expression) {
+            throw new IllegalStateException();
+        }
     }
-  }
 
-  /**
-   * Ensures the truth of an expression involving the state of the calling instance, but not
-   * involving any parameters to the calling method.
-   *
-   * @param expression a boolean expression
-   * @param errorMessage the exception message to use if the check fails; will be converted to a
-   *     string using {@link String#valueOf(Object)}
-   * @throws IllegalStateException if {@code expression} is false
-   */
-  public static void checkState(boolean expression, @Nullable Object errorMessage) {
-    if (!expression) {
-      throw new IllegalStateException(String.valueOf(errorMessage));
+    /**
+     * Ensures the truth of an expression involving the state of the calling instance, but not
+     * involving any parameters to the calling method.
+     *
+     * @param expression   a boolean expression
+     * @param errorMessage the exception message to use if the check fails; will be converted to a
+     *                     string using {@link String#valueOf(Object)}
+     * @throws IllegalStateException if {@code expression} is false
+     */
+    public static void checkState(boolean expression, @Nullable Object errorMessage) {
+        if (!expression) {
+            throw new IllegalStateException(String.valueOf(errorMessage));
+        }
     }
-  }
 
-  /**
-   * Ensures the truth of an expression involving the state of the calling instance, but not
-   * involving any parameters to the calling method.
-   *
-   * @param expression a boolean expression
-   * @param errorMessageTemplate a template for the exception message should the check fail. The
-   *     message is formed by replacing each {@code %s} placeholder in the template with an
-   *     argument. These are matched by position - the first {@code %s} gets {@code
-   *     errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message
-   *     in square braces. Unmatched placeholders will be left as-is.
-   * @param errorMessageArgs the arguments to be substituted into the message template. Arguments
-   *     are converted to strings using {@link String#valueOf(Object)}.
-   * @throws IllegalStateException if {@code expression} is false
-   * @throws NullPointerException if the check fails and either {@code errorMessageTemplate} or
-   *     {@code errorMessageArgs} is null (don't let this happen)
-   */
-  public static void checkState(boolean expression,
-      @Nullable String errorMessageTemplate,
-      @Nullable Object... errorMessageArgs) {
-    if (!expression) {
-      throw new IllegalStateException(format(errorMessageTemplate, errorMessageArgs));
+    /**
+     * Ensures the truth of an expression involving the state of the calling instance, but not
+     * involving any parameters to the calling method.
+     *
+     * @param expression           a boolean expression
+     * @param errorMessageTemplate a template for the exception message should the check fail. The
+     *                             message is formed by replacing each {@code %s} placeholder in the template with an
+     *                             argument. These are matched by position - the first {@code %s} gets {@code
+     *                             errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message
+     *                             in square braces. Unmatched placeholders will be left as-is.
+     * @param errorMessageArgs     the arguments to be substituted into the message template. Arguments
+     *                             are converted to strings using {@link String#valueOf(Object)}.
+     * @throws IllegalStateException if {@code expression} is false
+     * @throws NullPointerException  if the check fails and either {@code errorMessageTemplate} or
+     *                               {@code errorMessageArgs} is null (don't let this happen)
+     */
+    public static void checkState(boolean expression,
+                                  @Nullable String errorMessageTemplate,
+                                  @Nullable Object... errorMessageArgs) {
+        if (!expression) {
+            throw new IllegalStateException(format(errorMessageTemplate, errorMessageArgs));
+        }
     }
-  }
 
-  /**
-   * Ensures that an object reference passed as a parameter to the calling method is not null.
-   *
-   * @param reference an object reference
-   * @return the non-null reference that was validated
-   * @throws NullPointerException if {@code reference} is null
-   */
-  public static <T> T checkNotNull(T reference) {
-    if (reference == null) {
-      throw new NullPointerException();
+    /**
+     * Ensures that an object reference passed as a parameter to the calling method is not null.
+     *
+     * @param reference an object reference
+     * @return the non-null reference that was validated
+     * @throws NullPointerException if {@code reference} is null
+     */
+    public static <T> T checkNotNull(T reference) {
+        if (reference == null) {
+            throw new NullPointerException();
+        }
+        return reference;
     }
-    return reference;
-  }
 
-  /**
-   * Ensures that an object reference passed as a parameter to the calling method is not null.
-   *
-   * @param reference an object reference
-   * @param errorMessage the exception message to use if the check fails; will be converted to a
-   *     string using {@link String#valueOf(Object)}
-   * @return the non-null reference that was validated
-   * @throws NullPointerException if {@code reference} is null
-   */
-  public static <T> T checkNotNull(T reference, @Nullable Object errorMessage) {
-    if (reference == null) {
-      throw new NullPointerException(String.valueOf(errorMessage));
+    /**
+     * Ensures that an object reference passed as a parameter to the calling method is not null.
+     *
+     * @param reference    an object reference
+     * @param errorMessage the exception message to use if the check fails; will be converted to a
+     *                     string using {@link String#valueOf(Object)}
+     * @return the non-null reference that was validated
+     * @throws NullPointerException if {@code reference} is null
+     */
+    public static <T> T checkNotNull(T reference, @Nullable Object errorMessage) {
+        if (reference == null) {
+            throw new NullPointerException(String.valueOf(errorMessage));
+        }
+        return reference;
     }
-    return reference;
-  }
 
-  /**
-   * Ensures that an object reference passed as a parameter to the calling method is not null.
-   *
-   * @param reference an object reference
-   * @param errorMessageTemplate a template for the exception message should the check fail. The
-   *     message is formed by replacing each {@code %s} placeholder in the template with an
-   *     argument. These are matched by position - the first {@code %s} gets {@code
-   *     errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message
-   *     in square braces. Unmatched placeholders will be left as-is.
-   * @param errorMessageArgs the arguments to be substituted into the message template. Arguments
-   *     are converted to strings using {@link String#valueOf(Object)}.
-   * @return the non-null reference that was validated
-   * @throws NullPointerException if {@code reference} is null
-   */
-  public static <T> T checkNotNull(T reference,
-      @Nullable String errorMessageTemplate,
-      @Nullable Object... errorMessageArgs) {
-    if (reference == null) {
-      // If either of these parameters is null, the right thing happens anyway
-      throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));
+    /**
+     * Ensures that an object reference passed as a parameter to the calling method is not null.
+     *
+     * @param reference            an object reference
+     * @param errorMessageTemplate a template for the exception message should the check fail. The
+     *                             message is formed by replacing each {@code %s} placeholder in the template with an
+     *                             argument. These are matched by position - the first {@code %s} gets {@code
+     *                             errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message
+     *                             in square braces. Unmatched placeholders will be left as-is.
+     * @param errorMessageArgs     the arguments to be substituted into the message template. Arguments
+     *                             are converted to strings using {@link String#valueOf(Object)}.
+     * @return the non-null reference that was validated
+     * @throws NullPointerException if {@code reference} is null
+     */
+    public static <T> T checkNotNull(T reference,
+                                     @Nullable String errorMessageTemplate,
+                                     @Nullable Object... errorMessageArgs) {
+        if (reference == null) {
+            // If either of these parameters is null, the right thing happens anyway
+            throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));
+        }
+        return reference;
     }
-    return reference;
-  }
 
   /*
    * All recent hotspots (as of 2009) *really* like to have the natural code
@@ -278,163 +279,163 @@ public static void checkState(boolean expression,
    * is fine with that.
    */
 
-  /**
-   * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
-   * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.
-   *
-   * @param index a user-supplied index identifying an element of an array, list or string
-   * @param size the size of that array, list or string
-   * @return the value of {@code index}
-   * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
-   * @throws IllegalArgumentException if {@code size} is negative
-   */
-  public static int checkElementIndex(int index, int size) {
-    return checkElementIndex(index, size, "index");
-  }
-
-  /**
-   * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
-   * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.
-   *
-   * @param index a user-supplied index identifying an element of an array, list or string
-   * @param size the size of that array, list or string
-   * @param desc the text to use to describe this index in an error message
-   * @return the value of {@code index}
-   * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
-   * @throws IllegalArgumentException if {@code size} is negative
-   */
-  public static int checkElementIndex(
-      int index, int size, @Nullable String desc) {
-    // Carefully optimized for execution by hotspot (explanatory comment above)
-    if (index < 0 || index >= size) {
-      throw new IndexOutOfBoundsException(badElementIndex(index, size, desc));
+    /**
+     * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
+     * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.
+     *
+     * @param index a user-supplied index identifying an element of an array, list or string
+     * @param size  the size of that array, list or string
+     * @return the value of {@code index}
+     * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
+     * @throws IllegalArgumentException  if {@code size} is negative
+     */
+    public static int checkElementIndex(int index, int size) {
+        return checkElementIndex(index, size, "index");
     }
-    return index;
-  }
 
-  private static String badElementIndex(int index, int size, @Nullable String desc) {
-    if (index < 0) {
-      return format("%s (%s) must not be negative", desc, index);
-    } else if (size < 0) {
-      throw new IllegalArgumentException("negative size: " + size);
-    } else { // index >= size
-      return format("%s (%s) must be less than size (%s)", desc, index, size);
+    /**
+     * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
+     * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.
+     *
+     * @param index a user-supplied index identifying an element of an array, list or string
+     * @param size  the size of that array, list or string
+     * @param desc  the text to use to describe this index in an error message
+     * @return the value of {@code index}
+     * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
+     * @throws IllegalArgumentException  if {@code size} is negative
+     */
+    public static int checkElementIndex(
+            int index, int size, @Nullable String desc) {
+        // Carefully optimized for execution by hotspot (explanatory comment above)
+        if (index < 0 || index >= size) {
+            throw new IndexOutOfBoundsException(badElementIndex(index, size, desc));
+        }
+        return index;
     }
-  }
 
-  /**
-   * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
-   * size {@code size}. A position index may range from zero to {@code size}, inclusive.
-   *
-   * @param index a user-supplied index identifying a position in an array, list or string
-   * @param size the size of that array, list or string
-   * @return the value of {@code index}
-   * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
-   * @throws IllegalArgumentException if {@code size} is negative
-   */
-  public static int checkPositionIndex(int index, int size) {
-    return checkPositionIndex(index, size, "index");
-  }
+    private static String badElementIndex(int index, int size, @Nullable String desc) {
+        if (index < 0) {
+            return format("%s (%s) must not be negative", desc, index);
+        } else if (size < 0) {
+            throw new IllegalArgumentException("negative size: " + size);
+        } else { // index >= size
+            return format("%s (%s) must be less than size (%s)", desc, index, size);
+        }
+    }
 
-  /**
-   * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
-   * size {@code size}. A position index may range from zero to {@code size}, inclusive.
-   *
-   * @param index a user-supplied index identifying a position in an array, list or string
-   * @param size the size of that array, list or string
-   * @param desc the text to use to describe this index in an error message
-   * @return the value of {@code index}
-   * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
-   * @throws IllegalArgumentException if {@code size} is negative
-   */
-  public static int checkPositionIndex(int index, int size, @Nullable String desc) {
-    // Carefully optimized for execution by hotspot (explanatory comment above)
-    if (index < 0 || index > size) {
-      throw new IndexOutOfBoundsException(badPositionIndex(index, size, desc));
+    /**
+     * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
+     * size {@code size}. A position index may range from zero to {@code size}, inclusive.
+     *
+     * @param index a user-supplied index identifying a position in an array, list or string
+     * @param size  the size of that array, list or string
+     * @return the value of {@code index}
+     * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
+     * @throws IllegalArgumentException  if {@code size} is negative
+     */
+    public static int checkPositionIndex(int index, int size) {
+        return checkPositionIndex(index, size, "index");
     }
-    return index;
-  }
 
-  private static String badPositionIndex(int index, int size, @Nullable String desc) {
-    if (index < 0) {
-      return format("%s (%s) must not be negative", desc, index);
-    } else if (size < 0) {
-      throw new IllegalArgumentException("negative size: " + size);
-    } else { // index > size
-      return format("%s (%s) must not be greater than size (%s)", desc, index, size);
+    /**
+     * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
+     * size {@code size}. A position index may range from zero to {@code size}, inclusive.
+     *
+     * @param index a user-supplied index identifying a position in an array, list or string
+     * @param size  the size of that array, list or string
+     * @param desc  the text to use to describe this index in an error message
+     * @return the value of {@code index}
+     * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
+     * @throws IllegalArgumentException  if {@code size} is negative
+     */
+    public static int checkPositionIndex(int index, int size, @Nullable String desc) {
+        // Carefully optimized for execution by hotspot (explanatory comment above)
+        if (index < 0 || index > size) {
+            throw new IndexOutOfBoundsException(badPositionIndex(index, size, desc));
+        }
+        return index;
     }
-  }
 
-  /**
-   * Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list
-   * or string of size {@code size}, and are in order. A position index may range from zero to
-   * {@code size}, inclusive.
-   *
-   * @param start a user-supplied index identifying a starting position in an array, list or string
-   * @param end a user-supplied index identifying a ending position in an array, list or string
-   * @param size the size of that array, list or string
-   * @throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},
-   *     or if {@code end} is less than {@code start}
-   * @throws IllegalArgumentException if {@code size} is negative
-   */
-  public static void checkPositionIndexes(int start, int end, int size) {
-    // Carefully optimized for execution by hotspot (explanatory comment above)
-    if (start < 0 || end < start || end > size) {
-      throw new IndexOutOfBoundsException(badPositionIndexes(start, end, size));
+    private static String badPositionIndex(int index, int size, @Nullable String desc) {
+        if (index < 0) {
+            return format("%s (%s) must not be negative", desc, index);
+        } else if (size < 0) {
+            throw new IllegalArgumentException("negative size: " + size);
+        } else { // index > size
+            return format("%s (%s) must not be greater than size (%s)", desc, index, size);
+        }
     }
-  }
 
-  private static String badPositionIndexes(int start, int end, int size) {
-    if (start < 0 || start > size) {
-      return badPositionIndex(start, size, "start index");
+    /**
+     * Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list
+     * or string of size {@code size}, and are in order. A position index may range from zero to
+     * {@code size}, inclusive.
+     *
+     * @param start a user-supplied index identifying a starting position in an array, list or string
+     * @param end   a user-supplied index identifying a ending position in an array, list or string
+     * @param size  the size of that array, list or string
+     * @throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},
+     *                                   or if {@code end} is less than {@code start}
+     * @throws IllegalArgumentException  if {@code size} is negative
+     */
+    public static void checkPositionIndexes(int start, int end, int size) {
+        // Carefully optimized for execution by hotspot (explanatory comment above)
+        if (start < 0 || end < start || end > size) {
+            throw new IndexOutOfBoundsException(badPositionIndexes(start, end, size));
+        }
     }
-    if (end < 0 || end > size) {
-      return badPositionIndex(end, size, "end index");
+
+    private static String badPositionIndexes(int start, int end, int size) {
+        if (start < 0 || start > size) {
+            return badPositionIndex(start, size, "start index");
+        }
+        if (end < 0 || end > size) {
+            return badPositionIndex(end, size, "end index");
+        }
+        // end < start
+        return format("end index (%s) must not be less than start index (%s)", end, start);
     }
-    // end < start
-    return format("end index (%s) must not be less than start index (%s)", end, start);
-  }
 
-  /**
-   * Substitutes each {@code %s} in {@code template} with an argument. These are matched by
-   * position: the first {@code %s} gets {@code args[0]}, etc.  If there are more arguments than
-   * placeholders, the unmatched arguments will be appended to the end of the formatted message in
-   * square braces.
-   *
-   * @param template a non-null string containing 0 or more {@code %s} placeholders.
-   * @param args the arguments to be substituted into the message template. Arguments are converted
-   *     to strings using {@link String#valueOf(Object)}. Arguments can be null.
-   */
-  // Note that this is somewhat-improperly used from Verify.java as well.
-  static String format(@Nullable String template, @Nullable Object... args) {
-    template = String.valueOf(template); // null -> "null"
+    /**
+     * Substitutes each {@code %s} in {@code template} with an argument. These are matched by
+     * position: the first {@code %s} gets {@code args[0]}, etc.  If there are more arguments than
+     * placeholders, the unmatched arguments will be appended to the end of the formatted message in
+     * square braces.
+     *
+     * @param template a non-null string containing 0 or more {@code %s} placeholders.
+     * @param args     the arguments to be substituted into the message template. Arguments are converted
+     *                 to strings using {@link String#valueOf(Object)}. Arguments can be null.
+     */
+    // Note that this is somewhat-improperly used from Verify.java as well.
+    static String format(@Nullable String template, @Nullable Object... args) {
+        template = String.valueOf(template); // null -> "null"
 
-    // start substituting the arguments into the '%s' placeholders
-    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);
-    int templateStart = 0;
-    int i = 0;
-    while (i < args.length) {
-      int placeholderStart = template.indexOf("%s", templateStart);
-      if (placeholderStart == -1) {
-        break;
-      }
-      builder.append(template.substring(templateStart, placeholderStart));
-      builder.append(args[i++]);
-      templateStart = placeholderStart + 2;
-    }
-    builder.append(template.substring(templateStart));
+        // start substituting the arguments into the '%s' placeholders
+        StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);
+        int templateStart = 0;
+        int i = 0;
+        while (i < args.length) {
+            int placeholderStart = template.indexOf("%s", templateStart);
+            if (placeholderStart == -1) {
+                break;
+            }
+            builder.append(template.substring(templateStart, placeholderStart));
+            builder.append(args[i++]);
+            templateStart = placeholderStart + 2;
+        }
+        builder.append(template.substring(templateStart));
 
-    // if we run out of placeholders, append the extra args in square braces
-    if (i < args.length) {
-      builder.append(" [");
-      builder.append(args[i++]);
-      while (i < args.length) {
-        builder.append(", ");
-        builder.append(args[i++]);
-      }
-      builder.append(']');
-    }
+        // if we run out of placeholders, append the extra args in square braces
+        if (i < args.length) {
+            builder.append(" [");
+            builder.append(args[i++]);
+            while (i < args.length) {
+                builder.append(", ");
+                builder.append(args[i++]);
+            }
+            builder.append(']');
+        }
 
-    return builder.toString();
-  }
+        return builder.toString();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Sets.java b/fbcore/src/main/java/com/facebook/common/internal/Sets.java
index 7145f56ac..4e14aa3f2 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Sets.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Sets.java
@@ -29,142 +29,143 @@
  * Static utility methods pertaining to {@link Set} instances.
  */
 public final class Sets {
-  private Sets() {}
+    private Sets() {
+    }
 
-  /**
-   * Creates a <i>mutable</i>, empty {@code HashSet} instance.
-   *
-   * @return a new, empty {@code HashSet}
-   */
-  public static <E> HashSet<E> newHashSet() {
-    return new HashSet<E>();
-  }
+    /**
+     * Creates a <i>mutable</i>, empty {@code HashSet} instance.
+     *
+     * @return a new, empty {@code HashSet}
+     */
+    public static <E> HashSet<E> newHashSet() {
+        return new HashSet<E>();
+    }
 
-  /**
-   * Creates a <i>mutable</i> {@code HashSet} instance containing the given
-   * elements in unspecified order.
-   *
-   * @param elements the elements that the set should contain
-   * @return a new {@code HashSet} containing those elements (minus duplicates)
-   */
-  public static <E> HashSet<E> newHashSet(E... elements) {
-    HashSet<E> set = newHashSetWithCapacity(elements.length);
-    Collections.addAll(set, elements);
-    return set;
-  }
+    /**
+     * Creates a <i>mutable</i> {@code HashSet} instance containing the given
+     * elements in unspecified order.
+     *
+     * @param elements the elements that the set should contain
+     * @return a new {@code HashSet} containing those elements (minus duplicates)
+     */
+    public static <E> HashSet<E> newHashSet(E... elements) {
+        HashSet<E> set = newHashSetWithCapacity(elements.length);
+        Collections.addAll(set, elements);
+        return set;
+    }
 
-  /**
-   * Creates a {@code HashSet} instance, with a high enough "initial capacity"
-   * that it <i>should</i> hold {@code expectedSize} elements without growth.
-   * This behavior cannot be broadly guaranteed, but it is observed to be true
-   * for OpenJDK 1.6. It also can't be guaranteed that the method isn't
-   * inadvertently <i>oversizing</i> the returned set.
-   *
-   * @param capacity the number of elements you expect to add to the
-   *        returned set
-   * @return a new, empty {@code HashSet} with enough capacity to hold {@code
-   *         expectedSize} elements without resizing
-   * @throws IllegalArgumentException if {@code expectedSize} is negative
-   */
-  public static <E> HashSet<E> newHashSetWithCapacity(int capacity) {
-    return new HashSet<E>(capacity);
-  }
+    /**
+     * Creates a {@code HashSet} instance, with a high enough "initial capacity"
+     * that it <i>should</i> hold {@code expectedSize} elements without growth.
+     * This behavior cannot be broadly guaranteed, but it is observed to be true
+     * for OpenJDK 1.6. It also can't be guaranteed that the method isn't
+     * inadvertently <i>oversizing</i> the returned set.
+     *
+     * @param capacity the number of elements you expect to add to the
+     *                 returned set
+     * @return a new, empty {@code HashSet} with enough capacity to hold {@code
+     * expectedSize} elements without resizing
+     * @throws IllegalArgumentException if {@code expectedSize} is negative
+     */
+    public static <E> HashSet<E> newHashSetWithCapacity(int capacity) {
+        return new HashSet<E>(capacity);
+    }
 
-  /**
-   * Creates a <i>mutable</i> {@code HashSet} instance containing the given
-   * elements in unspecified order.
-   *
-   * @param elements the elements that the set should contain
-   * @return a new {@code HashSet} containing those elements (minus duplicates)
-   */
-  public static <E> HashSet<E> newHashSet(Iterable<? extends E> elements) {
-    return (elements instanceof Collection)
-        ? new HashSet<E>((Collection<E>) elements)
-        : newHashSet(elements.iterator());
-  }
+    /**
+     * Creates a <i>mutable</i> {@code HashSet} instance containing the given
+     * elements in unspecified order.
+     *
+     * @param elements the elements that the set should contain
+     * @return a new {@code HashSet} containing those elements (minus duplicates)
+     */
+    public static <E> HashSet<E> newHashSet(Iterable<? extends E> elements) {
+        return (elements instanceof Collection)
+                ? new HashSet<E>((Collection<E>) elements)
+                : newHashSet(elements.iterator());
+    }
 
-  /**
-   * Creates a <i>mutable</i> {@code HashSet} instance containing the given
-   * elements in unspecified order.
-   *
-   * @param elements the elements that the set should contain
-   * @return a new {@code HashSet} containing those elements (minus duplicates)
-   */
-  public static <E> HashSet<E> newHashSet(Iterator<? extends E> elements) {
-    HashSet<E> set = newHashSet();
-    while (elements.hasNext()) {
-      set.add(elements.next());
+    /**
+     * Creates a <i>mutable</i> {@code HashSet} instance containing the given
+     * elements in unspecified order.
+     *
+     * @param elements the elements that the set should contain
+     * @return a new {@code HashSet} containing those elements (minus duplicates)
+     */
+    public static <E> HashSet<E> newHashSet(Iterator<? extends E> elements) {
+        HashSet<E> set = newHashSet();
+        while (elements.hasNext()) {
+            set.add(elements.next());
+        }
+        return set;
     }
-    return set;
-  }
 
-  /**
-   * Creates an empty {@code Set} that uses identity to determine equality. It
-   * compares object references, instead of calling {@code equals}, to
-   * determine whether a provided object matches an element in the set. For
-   * example, {@code contains} returns {@code false} when passed an object that
-   * equals a set member, but isn't the same instance. This behavior is similar
-   * to the way {@code IdentityHashMap} handles key lookups.
-   */
-  public static <E> Set<E> newIdentityHashSet() {
-    return Sets.newSetFromMap(Maps.<E, Boolean>newIdentityHashMap());
-  }
+    /**
+     * Creates an empty {@code Set} that uses identity to determine equality. It
+     * compares object references, instead of calling {@code equals}, to
+     * determine whether a provided object matches an element in the set. For
+     * example, {@code contains} returns {@code false} when passed an object that
+     * equals a set member, but isn't the same instance. This behavior is similar
+     * to the way {@code IdentityHashMap} handles key lookups.
+     */
+    public static <E> Set<E> newIdentityHashSet() {
+        return Sets.newSetFromMap(Maps.<E, Boolean>newIdentityHashMap());
+    }
 
-  /**
-   * Returns a set backed by the specified map. The resulting set displays
-   * the same ordering, concurrency, and performance characteristics as the
-   * backing map. In essence, this factory method provides a {@link Set}
-   * implementation corresponding to any {@link Map} implementation. There is no
-   * need to use this method on a {@link Map} implementation that already has a
-   * corresponding {@link Set} implementation (such as {@link java.util.HashMap}
-   * or {@link java.util.TreeMap}).
-   *
-   * <p>Each method invocation on the set returned by this method results in
-   * exactly one method invocation on the backing map or its {@code keySet}
-   * view, with one exception. The {@code addAll} method is implemented as a
-   * sequence of {@code put} invocations on the backing map.
-   *
-   * <p>The specified map must be empty at the time this method is invoked,
-   * and should not be accessed directly after this method returns. These
-   * conditions are ensured if the map is created empty, passed directly
-   * to this method, and no reference to the map is retained, as illustrated
-   * in the following code fragment: <pre>  {@code
-   *
-   *   Set<Object> identityHashSet = Sets.newSetFromMap(
-   *       new IdentityHashMap<Object, Boolean>());}</pre>
-   *
-   * <p>This method has the same behavior as the JDK 6 method
-   * {@code Collections.newSetFromMap()}. The returned set is serializable if
-   * the backing map is.
-   *
-   * @param map the backing map
-   * @return the set backed by the map
-   * @throws IllegalArgumentException if {@code map} is not empty
-   */
-  public static <E> Set<E> newSetFromMap(Map<E, Boolean> map) {
-    return Collections.newSetFromMap(map);
-  }
+    /**
+     * Returns a set backed by the specified map. The resulting set displays
+     * the same ordering, concurrency, and performance characteristics as the
+     * backing map. In essence, this factory method provides a {@link Set}
+     * implementation corresponding to any {@link Map} implementation. There is no
+     * need to use this method on a {@link Map} implementation that already has a
+     * corresponding {@link Set} implementation (such as {@link java.util.HashMap}
+     * or {@link java.util.TreeMap}).
+     * <p>
+     * <p>Each method invocation on the set returned by this method results in
+     * exactly one method invocation on the backing map or its {@code keySet}
+     * view, with one exception. The {@code addAll} method is implemented as a
+     * sequence of {@code put} invocations on the backing map.
+     * <p>
+     * <p>The specified map must be empty at the time this method is invoked,
+     * and should not be accessed directly after this method returns. These
+     * conditions are ensured if the map is created empty, passed directly
+     * to this method, and no reference to the map is retained, as illustrated
+     * in the following code fragment: <pre>  {@code
+     * <p>
+     *   Set<Object> identityHashSet = Sets.newSetFromMap(
+     *       new IdentityHashMap<Object, Boolean>());}</pre>
+     * <p>
+     * <p>This method has the same behavior as the JDK 6 method
+     * {@code Collections.newSetFromMap()}. The returned set is serializable if
+     * the backing map is.
+     *
+     * @param map the backing map
+     * @return the set backed by the map
+     * @throws IllegalArgumentException if {@code map} is not empty
+     */
+    public static <E> Set<E> newSetFromMap(Map<E, Boolean> map) {
+        return Collections.newSetFromMap(map);
+    }
 
-  /**
-   * Creates an empty {@code CopyOnWriteArraySet} instance.
-   *
-   * <p><b>Note:</b> if you need an immutable empty {@link Set}, use
-   * {@link Collections#emptySet} instead.
-   *
-   * @return a new, empty {@code CopyOnWriteArraySet}
-   * @since 12.0
-   */
-  public static <E> CopyOnWriteArraySet<E> newCopyOnWriteArraySet() {
-    return new CopyOnWriteArraySet<E>();
-  }
+    /**
+     * Creates an empty {@code CopyOnWriteArraySet} instance.
+     * <p>
+     * <p><b>Note:</b> if you need an immutable empty {@link Set}, use
+     * {@link Collections#emptySet} instead.
+     *
+     * @return a new, empty {@code CopyOnWriteArraySet}
+     * @since 12.0
+     */
+    public static <E> CopyOnWriteArraySet<E> newCopyOnWriteArraySet() {
+        return new CopyOnWriteArraySet<E>();
+    }
 
 
-  /**
-   * Creates a <i>mutable</i>, empty {@code LinkedHashSet} instance.
-   *
-   * @return a new, empty {@code LinkedHashSet}
-   */
-  public static <E> LinkedHashSet<E> newLinkedHashSet() {
-    return new LinkedHashSet<E>();
-  }
+    /**
+     * Creates a <i>mutable</i>, empty {@code LinkedHashSet} instance.
+     *
+     * @return a new, empty {@code LinkedHashSet}
+     */
+    public static <E> LinkedHashSet<E> newLinkedHashSet() {
+        return new LinkedHashSet<E>();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Supplier.java b/fbcore/src/main/java/com/facebook/common/internal/Supplier.java
index b7560a63c..dbfd1bf5a 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Supplier.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Supplier.java
@@ -25,11 +25,11 @@
  * @since 2.0 (imported from Google Collections Library)
  */
 public interface Supplier<T> {
-  /**
-   * Retrieves an instance of the appropriate type. The returned object may or
-   * may not be a new instance, depending on the implementation.
-   *
-   * @return an instance of the appropriate type
-   */
-  T get();
+    /**
+     * Retrieves an instance of the appropriate type. The returned object may or
+     * may not be a new instance, depending on the implementation.
+     *
+     * @return an instance of the appropriate type
+     */
+    T get();
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Suppliers.java b/fbcore/src/main/java/com/facebook/common/internal/Suppliers.java
index f4cefe51d..b7164b1cb 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Suppliers.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Suppliers.java
@@ -13,17 +13,17 @@
  * Wrapper for creating a Supplier.
  */
 public class Suppliers {
-  /**
-   * Returns a Supplier which always returns {@code instance}.
-   *
-   * @param instance the instance that should always be provided.
-   */
-  public static <T> Supplier<T> of(final T instance) {
-    return new Supplier<T>() {
-      @Override
-      public T get() {
-        return instance;
-      }
-    };
-  }
+    /**
+     * Returns a Supplier which always returns {@code instance}.
+     *
+     * @param instance the instance that should always be provided.
+     */
+    public static <T> Supplier<T> of(final T instance) {
+        return new Supplier<T>() {
+            @Override
+            public T get() {
+                return instance;
+            }
+        };
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/internal/Throwables.java b/fbcore/src/main/java/com/facebook/common/internal/Throwables.java
index 7b33b8efb..d39ea8476 100644
--- a/fbcore/src/main/java/com/facebook/common/internal/Throwables.java
+++ b/fbcore/src/main/java/com/facebook/common/internal/Throwables.java
@@ -26,7 +26,7 @@
 
 /**
  * Static utility methods pertaining to instances of {@link Throwable}.
- *
+ * <p>
  * <p>See the Guava User Guide entry on <a href=
  * "http://code.google.com/p/guava-libraries/wiki/ThrowablesExplained">
  * Throwables</a>.
@@ -36,180 +36,181 @@
  * @since 1.0
  */
 public final class Throwables {
-  private Throwables() {}
+    private Throwables() {
+    }
 
-  /**
-   * Propagates {@code throwable} exactly as-is, if and only if it is an
-   * instance of {@code declaredType}.  Example usage:
-   * <pre>
-   *   try {
-   *     someMethodThatCouldThrowAnything();
-   *   } catch (IKnowWhatToDoWithThisException e) {
-   *     handle(e);
-   *   } catch (Throwable t) {
-   *     Throwables.propagateIfInstanceOf(t, IOException.class);
-   *     Throwables.propagateIfInstanceOf(t, SQLException.class);
-   *     throw Throwables.propagate(t);
-   *   }
-   * </pre>
-   */
-  public static <X extends Throwable> void propagateIfInstanceOf(
-      @Nullable Throwable throwable, Class<X> declaredType) throws X {
-    // Check for null is needed to avoid frequent JNI calls to isInstance().
-    if (throwable != null && declaredType.isInstance(throwable)) {
-      throw declaredType.cast(throwable);
+    /**
+     * Propagates {@code throwable} exactly as-is, if and only if it is an
+     * instance of {@code declaredType}.  Example usage:
+     * <pre>
+     *   try {
+     *     someMethodThatCouldThrowAnything();
+     *   } catch (IKnowWhatToDoWithThisException e) {
+     *     handle(e);
+     *   } catch (Throwable t) {
+     *     Throwables.propagateIfInstanceOf(t, IOException.class);
+     *     Throwables.propagateIfInstanceOf(t, SQLException.class);
+     *     throw Throwables.propagate(t);
+     *   }
+     * </pre>
+     */
+    public static <X extends Throwable> void propagateIfInstanceOf(
+            @Nullable Throwable throwable, Class<X> declaredType) throws X {
+        // Check for null is needed to avoid frequent JNI calls to isInstance().
+        if (throwable != null && declaredType.isInstance(throwable)) {
+            throw declaredType.cast(throwable);
+        }
     }
-  }
 
-  /**
-   * Propagates {@code throwable} exactly as-is, if and only if it is an
-   * instance of {@link RuntimeException} or {@link Error}.  Example usage:
-   * <pre>
-   *   try {
-   *     someMethodThatCouldThrowAnything();
-   *   } catch (IKnowWhatToDoWithThisException e) {
-   *     handle(e);
-   *   } catch (Throwable t) {
-   *     Throwables.propagateIfPossible(t);
-   *     throw new RuntimeException("unexpected", t);
-   *   }
-   * </pre>
-   */
-  public static void propagateIfPossible(@Nullable Throwable throwable) {
-    propagateIfInstanceOf(throwable, Error.class);
-    propagateIfInstanceOf(throwable, RuntimeException.class);
-  }
+    /**
+     * Propagates {@code throwable} exactly as-is, if and only if it is an
+     * instance of {@link RuntimeException} or {@link Error}.  Example usage:
+     * <pre>
+     *   try {
+     *     someMethodThatCouldThrowAnything();
+     *   } catch (IKnowWhatToDoWithThisException e) {
+     *     handle(e);
+     *   } catch (Throwable t) {
+     *     Throwables.propagateIfPossible(t);
+     *     throw new RuntimeException("unexpected", t);
+     *   }
+     * </pre>
+     */
+    public static void propagateIfPossible(@Nullable Throwable throwable) {
+        propagateIfInstanceOf(throwable, Error.class);
+        propagateIfInstanceOf(throwable, RuntimeException.class);
+    }
 
-  /**
-   * Propagates {@code throwable} exactly as-is, if and only if it is an
-   * instance of {@link RuntimeException}, {@link Error}, or
-   * {@code declaredType}. Example usage:
-   * <pre>
-   *   try {
-   *     someMethodThatCouldThrowAnything();
-   *   } catch (IKnowWhatToDoWithThisException e) {
-   *     handle(e);
-   *   } catch (Throwable t) {
-   *     Throwables.propagateIfPossible(t, OtherException.class);
-   *     throw new RuntimeException("unexpected", t);
-   *   }
-   * </pre>
-   *
-   * @param throwable the Throwable to possibly propagate
-   * @param declaredType the single checked exception type declared by the
-   *     calling method
-   */
-  public static <X extends Throwable> void propagateIfPossible(
-      @Nullable Throwable throwable, Class<X> declaredType) throws X {
-    propagateIfInstanceOf(throwable, declaredType);
-    propagateIfPossible(throwable);
-  }
+    /**
+     * Propagates {@code throwable} exactly as-is, if and only if it is an
+     * instance of {@link RuntimeException}, {@link Error}, or
+     * {@code declaredType}. Example usage:
+     * <pre>
+     *   try {
+     *     someMethodThatCouldThrowAnything();
+     *   } catch (IKnowWhatToDoWithThisException e) {
+     *     handle(e);
+     *   } catch (Throwable t) {
+     *     Throwables.propagateIfPossible(t, OtherException.class);
+     *     throw new RuntimeException("unexpected", t);
+     *   }
+     * </pre>
+     *
+     * @param throwable    the Throwable to possibly propagate
+     * @param declaredType the single checked exception type declared by the
+     *                     calling method
+     */
+    public static <X extends Throwable> void propagateIfPossible(
+            @Nullable Throwable throwable, Class<X> declaredType) throws X {
+        propagateIfInstanceOf(throwable, declaredType);
+        propagateIfPossible(throwable);
+    }
 
-  /**
-   * Propagates {@code throwable} exactly as-is, if and only if it is an
-   * instance of {@link RuntimeException}, {@link Error}, {@code declaredType1},
-   * or {@code declaredType2}.  In the unlikely case that you have three or more
-   * declared checked exception types, you can handle them all by invoking these
-   * methods repeatedly. See usage example in {@link
-   * #propagateIfPossible(Throwable, Class)}.
-   *
-   * @param throwable the Throwable to possibly propagate
-   * @param declaredType1 any checked exception type declared by the calling
-   *     method
-   * @param declaredType2 any other checked exception type declared by the
-   *     calling method
-   */
-  public static <X1 extends Throwable, X2 extends Throwable>
-  void propagateIfPossible(@Nullable Throwable throwable,
-      Class<X1> declaredType1, Class<X2> declaredType2) throws X1, X2 {
-    Preconditions.checkNotNull(declaredType2);
-    propagateIfInstanceOf(throwable, declaredType1);
-    propagateIfPossible(throwable, declaredType2);
-  }
+    /**
+     * Propagates {@code throwable} exactly as-is, if and only if it is an
+     * instance of {@link RuntimeException}, {@link Error}, {@code declaredType1},
+     * or {@code declaredType2}.  In the unlikely case that you have three or more
+     * declared checked exception types, you can handle them all by invoking these
+     * methods repeatedly. See usage example in {@link
+     * #propagateIfPossible(Throwable, Class)}.
+     *
+     * @param throwable     the Throwable to possibly propagate
+     * @param declaredType1 any checked exception type declared by the calling
+     *                      method
+     * @param declaredType2 any other checked exception type declared by the
+     *                      calling method
+     */
+    public static <X1 extends Throwable, X2 extends Throwable>
+    void propagateIfPossible(@Nullable Throwable throwable,
+                             Class<X1> declaredType1, Class<X2> declaredType2) throws X1, X2 {
+        Preconditions.checkNotNull(declaredType2);
+        propagateIfInstanceOf(throwable, declaredType1);
+        propagateIfPossible(throwable, declaredType2);
+    }
 
-  /**
-   * Propagates {@code throwable} as-is if it is an instance of
-   * {@link RuntimeException} or {@link Error}, or else as a last resort, wraps
-   * it in a {@code RuntimeException} then propagates.
-   * <p>
-   * This method always throws an exception. The {@code RuntimeException} return
-   * type is only for client code to make Java type system happy in case a
-   * return value is required by the enclosing method. Example usage:
-   * <pre>
-   *   T doSomething() {
-   *     try {
-   *       return someMethodThatCouldThrowAnything();
-   *     } catch (IKnowWhatToDoWithThisException e) {
-   *       return handle(e);
-   *     } catch (Throwable t) {
-   *       throw Throwables.propagate(t);
-   *     }
-   *   }
-   * </pre>
-   *
-   * @param throwable the Throwable to propagate
-   * @return nothing will ever be returned; this return type is only for your
-   *     convenience, as illustrated in the example above
-   */
-  public static RuntimeException propagate(Throwable throwable) {
-    propagateIfPossible(Preconditions.checkNotNull(throwable));
-    throw new RuntimeException(throwable);
-  }
+    /**
+     * Propagates {@code throwable} as-is if it is an instance of
+     * {@link RuntimeException} or {@link Error}, or else as a last resort, wraps
+     * it in a {@code RuntimeException} then propagates.
+     * <p>
+     * This method always throws an exception. The {@code RuntimeException} return
+     * type is only for client code to make Java type system happy in case a
+     * return value is required by the enclosing method. Example usage:
+     * <pre>
+     *   T doSomething() {
+     *     try {
+     *       return someMethodThatCouldThrowAnything();
+     *     } catch (IKnowWhatToDoWithThisException e) {
+     *       return handle(e);
+     *     } catch (Throwable t) {
+     *       throw Throwables.propagate(t);
+     *     }
+     *   }
+     * </pre>
+     *
+     * @param throwable the Throwable to propagate
+     * @return nothing will ever be returned; this return type is only for your
+     * convenience, as illustrated in the example above
+     */
+    public static RuntimeException propagate(Throwable throwable) {
+        propagateIfPossible(Preconditions.checkNotNull(throwable));
+        throw new RuntimeException(throwable);
+    }
 
-  /**
-   * Returns the innermost cause of {@code throwable}. The first throwable in a
-   * chain provides context from when the error or exception was initially
-   * detected. Example usage:
-   * <pre>
-   *   assertEquals("Unable to assign a customer id",
-   *       Throwables.getRootCause(e).getMessage());
-   * </pre>
-   */
-  public static Throwable getRootCause(Throwable throwable) {
-    Throwable cause;
-    while ((cause = throwable.getCause()) != null) {
-      throwable = cause;
+    /**
+     * Returns the innermost cause of {@code throwable}. The first throwable in a
+     * chain provides context from when the error or exception was initially
+     * detected. Example usage:
+     * <pre>
+     *   assertEquals("Unable to assign a customer id",
+     *       Throwables.getRootCause(e).getMessage());
+     * </pre>
+     */
+    public static Throwable getRootCause(Throwable throwable) {
+        Throwable cause;
+        while ((cause = throwable.getCause()) != null) {
+            throwable = cause;
+        }
+        return throwable;
     }
-    return throwable;
-  }
 
-  /**
-   * Gets a {@code Throwable} cause chain as a list.  The first entry in the
-   * list will be {@code throwable} followed by its cause hierarchy.  Note
-   * that this is a snapshot of the cause chain and will not reflect
-   * any subsequent changes to the cause chain.
-   *
-   * <p>Here's an example of how it can be used to find specific types
-   * of exceptions in the cause chain:
-   *
-   * <pre>
-   * Iterables.filter(Throwables.getCausalChain(e), IOException.class));
-   * </pre>
-   *
-   * @param throwable the non-null {@code Throwable} to extract causes from
-   * @return an unmodifiable list containing the cause chain starting with
-   *     {@code throwable}
-   */
-  public static List<Throwable> getCausalChain(Throwable throwable) {
-    Preconditions.checkNotNull(throwable);
-    List<Throwable> causes = new ArrayList<Throwable>(4);
-    while (throwable != null) {
-      causes.add(throwable);
-      throwable = throwable.getCause();
+    /**
+     * Gets a {@code Throwable} cause chain as a list.  The first entry in the
+     * list will be {@code throwable} followed by its cause hierarchy.  Note
+     * that this is a snapshot of the cause chain and will not reflect
+     * any subsequent changes to the cause chain.
+     * <p>
+     * <p>Here's an example of how it can be used to find specific types
+     * of exceptions in the cause chain:
+     * <p>
+     * <pre>
+     * Iterables.filter(Throwables.getCausalChain(e), IOException.class));
+     * </pre>
+     *
+     * @param throwable the non-null {@code Throwable} to extract causes from
+     * @return an unmodifiable list containing the cause chain starting with
+     * {@code throwable}
+     */
+    public static List<Throwable> getCausalChain(Throwable throwable) {
+        Preconditions.checkNotNull(throwable);
+        List<Throwable> causes = new ArrayList<Throwable>(4);
+        while (throwable != null) {
+            causes.add(throwable);
+            throwable = throwable.getCause();
+        }
+        return Collections.unmodifiableList(causes);
     }
-    return Collections.unmodifiableList(causes);
-  }
 
-  /**
-   * Returns a string containing the result of
-   * {@link Throwable#toString() toString()}, followed by the full, recursive
-   * stack trace of {@code throwable}. Note that you probably should not be
-   * parsing the resulting string; if you need programmatic access to the stack
-   * frames, you can call {@link Throwable#getStackTrace()}.
-   */
-  public static String getStackTraceAsString(Throwable throwable) {
-    StringWriter stringWriter = new StringWriter();
-    throwable.printStackTrace(new PrintWriter(stringWriter));
-    return stringWriter.toString();
-  }
+    /**
+     * Returns a string containing the result of
+     * {@link Throwable#toString() toString()}, followed by the full, recursive
+     * stack trace of {@code throwable}. Note that you probably should not be
+     * parsing the resulting string; if you need programmatic access to the stack
+     * frames, you can call {@link Throwable#getStackTrace()}.
+     */
+    public static String getStackTraceAsString(Throwable throwable) {
+        StringWriter stringWriter = new StringWriter();
+        throwable.printStackTrace(new PrintWriter(stringWriter));
+        return stringWriter.toString();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/logging/FLog.java b/fbcore/src/main/java/com/facebook/common/logging/FLog.java
index 3634bee30..96c8f27de 100644
--- a/fbcore/src/main/java/com/facebook/common/logging/FLog.java
+++ b/fbcore/src/main/java/com/facebook/common/logging/FLog.java
@@ -16,484 +16,484 @@
  */
 public class FLog {
 
-  public static final int VERBOSE = Log.VERBOSE;
+    public static final int VERBOSE = Log.VERBOSE;
 
-  public static final int DEBUG = Log.DEBUG;
+    public static final int DEBUG = Log.DEBUG;
 
-  public static final int INFO = Log.INFO;
+    public static final int INFO = Log.INFO;
 
-  public static final int WARN = Log.WARN;
+    public static final int WARN = Log.WARN;
 
-  public static final int ERROR = Log.ERROR;
+    public static final int ERROR = Log.ERROR;
 
-  public static final int ASSERT = Log.ASSERT;
+    public static final int ASSERT = Log.ASSERT;
 
-  private static LoggingDelegate sHandler = FLogDefaultLoggingDelegate.getInstance();
+    private static LoggingDelegate sHandler = FLogDefaultLoggingDelegate.getInstance();
 
-  /**
-   * Sets the logging delegate that overrides the default delegate.
-   *
-   * @param delegate the delegate to use
-   */
-  public static void setLoggingDelegate(LoggingDelegate delegate) {
-    if (delegate == null) {
-      throw new IllegalArgumentException();
+    /**
+     * Sets the logging delegate that overrides the default delegate.
+     *
+     * @param delegate the delegate to use
+     */
+    public static void setLoggingDelegate(LoggingDelegate delegate) {
+        if (delegate == null) {
+            throw new IllegalArgumentException();
+        }
+        sHandler = delegate;
     }
-    sHandler = delegate;
-  }
 
-  public static boolean isLoggable(int level) {
-    return sHandler.isLoggable(level);
-  }
+    public static boolean isLoggable(int level) {
+        return sHandler.isLoggable(level);
+    }
 
-  public static void setMinimumLoggingLevel(int level) {
-    sHandler.setMinimumLoggingLevel(level);
-  }
+    public static void setMinimumLoggingLevel(int level) {
+        sHandler.setMinimumLoggingLevel(level);
+    }
 
-  public static int getMinimumLoggingLevel() {
-    return sHandler.getMinimumLoggingLevel();
-  }
+    public static int getMinimumLoggingLevel() {
+        return sHandler.getMinimumLoggingLevel();
+    }
 
-  public static void v(String tag, String msg) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(tag, msg);
+    public static void v(String tag, String msg) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(tag, msg);
+        }
     }
-  }
 
-  public static void v(String tag, String msg, Object arg1) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(tag, formatString(msg, arg1));
+    public static void v(String tag, String msg, Object arg1) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(tag, formatString(msg, arg1));
+        }
     }
-  }
 
-  public static void v(String tag, String msg, Object arg1, Object arg2) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(tag, formatString(msg, arg1, arg2));
+    public static void v(String tag, String msg, Object arg1, Object arg2) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(tag, formatString(msg, arg1, arg2));
+        }
     }
-  }
 
-  public static void v(String tag, String msg, Object arg1, Object arg2, Object arg3) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(tag, formatString(msg, arg1, arg2, arg3));
+    public static void v(String tag, String msg, Object arg1, Object arg2, Object arg3) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(tag, formatString(msg, arg1, arg2, arg3));
+        }
     }
-  }
 
-  public static void v(String tag, String msg, Object arg1, Object arg2, Object arg3, Object arg4) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(tag, formatString(msg, arg1, arg2, arg3, arg4));
+    public static void v(String tag, String msg, Object arg1, Object arg2, Object arg3, Object arg4) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(tag, formatString(msg, arg1, arg2, arg3, arg4));
+        }
     }
-  }
 
-  public static void v(Class<?> cls, String msg) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(getTag(cls), msg);
+    public static void v(Class<?> cls, String msg) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(getTag(cls), msg);
+        }
     }
-  }
 
-  public static void v(Class<?> cls, String msg, Object arg1) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(getTag(cls), formatString(msg, arg1));
+    public static void v(Class<?> cls, String msg, Object arg1) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(getTag(cls), formatString(msg, arg1));
+        }
     }
-  }
 
-  public static void v(Class<?> cls, String msg, Object arg1, Object arg2) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(getTag(cls), formatString(msg, arg1, arg2));
+    public static void v(Class<?> cls, String msg, Object arg1, Object arg2) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(getTag(cls), formatString(msg, arg1, arg2));
+        }
     }
-  }
 
-  public static void v(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3) {
-    if (isLoggable(VERBOSE)) {
-      v(cls, formatString(msg, arg1, arg2, arg3));
+    public static void v(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3) {
+        if (isLoggable(VERBOSE)) {
+            v(cls, formatString(msg, arg1, arg2, arg3));
+        }
     }
-  }
 
-  public static void v(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3,
-      Object arg4) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(getTag(cls), formatString(msg, arg1, arg2, arg3, arg4));
+    public static void v(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3,
+                         Object arg4) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(getTag(cls), formatString(msg, arg1, arg2, arg3, arg4));
+        }
     }
-  }
 
-  public static void v(String tag, String msg, Object... args) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(tag, formatString(msg, args));
+    public static void v(String tag, String msg, Object... args) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(tag, formatString(msg, args));
+        }
     }
-  }
 
-  public static void v(String tag, Throwable tr, String msg, Object... args) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(tag, formatString(msg, args), tr);
+    public static void v(String tag, Throwable tr, String msg, Object... args) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(tag, formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void v(Class<?> cls, String msg, Object... args) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(getTag(cls), formatString(msg, args));
+    public static void v(Class<?> cls, String msg, Object... args) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(getTag(cls), formatString(msg, args));
+        }
     }
-  }
 
-  public static void v(Class<?> cls, Throwable tr, String msg, Object... args) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(getTag(cls), formatString(msg, args), tr);
+    public static void v(Class<?> cls, Throwable tr, String msg, Object... args) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(getTag(cls), formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void v(String tag, String msg, Throwable tr) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(tag, msg, tr);
+    public static void v(String tag, String msg, Throwable tr) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(tag, msg, tr);
+        }
     }
-  }
 
-  public static void v(Class<?> cls, String msg, Throwable tr) {
-    if (sHandler.isLoggable(VERBOSE)) {
-      sHandler.v(getTag(cls), msg, tr);
+    public static void v(Class<?> cls, String msg, Throwable tr) {
+        if (sHandler.isLoggable(VERBOSE)) {
+            sHandler.v(getTag(cls), msg, tr);
+        }
     }
-  }
 
-  public static void d(String tag, String msg) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(tag, msg);
+    public static void d(String tag, String msg) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(tag, msg);
+        }
     }
-  }
 
-  public static void d(String tag, String msg, Object arg1) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(tag, formatString(msg, arg1));
+    public static void d(String tag, String msg, Object arg1) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(tag, formatString(msg, arg1));
+        }
     }
-  }
 
-  public static void d(String tag, String msg, Object arg1, Object arg2) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(tag, formatString(msg, arg1, arg2));
+    public static void d(String tag, String msg, Object arg1, Object arg2) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(tag, formatString(msg, arg1, arg2));
+        }
     }
-  }
 
-  public static void d(String tag, String msg, Object arg1, Object arg2, Object arg3) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(tag, formatString(msg, arg1, arg2, arg3));
+    public static void d(String tag, String msg, Object arg1, Object arg2, Object arg3) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(tag, formatString(msg, arg1, arg2, arg3));
+        }
     }
-  }
 
-  public static void d(String tag, String msg, Object arg1, Object arg2, Object arg3, Object arg4) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(tag, formatString(msg, arg1, arg2, arg3, arg4));
+    public static void d(String tag, String msg, Object arg1, Object arg2, Object arg3, Object arg4) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(tag, formatString(msg, arg1, arg2, arg3, arg4));
+        }
     }
-  }
 
-  public static void d(Class<?> cls, String msg) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(getTag(cls), msg);
+    public static void d(Class<?> cls, String msg) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(getTag(cls), msg);
+        }
     }
-  }
 
-  public static void d(Class<?> cls, String msg, Object arg1) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(getTag(cls), formatString(msg, arg1));
+    public static void d(Class<?> cls, String msg, Object arg1) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(getTag(cls), formatString(msg, arg1));
+        }
     }
-  }
 
-  public static void d(Class<?> cls, String msg, Object arg1, Object arg2) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(getTag(cls), formatString(msg, arg1, arg2));
+    public static void d(Class<?> cls, String msg, Object arg1, Object arg2) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(getTag(cls), formatString(msg, arg1, arg2));
+        }
     }
-  }
 
-  public static void d(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(getTag(cls), formatString(msg, arg1, arg2, arg3));
+    public static void d(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(getTag(cls), formatString(msg, arg1, arg2, arg3));
+        }
     }
-  }
 
-  public static void d(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3,
-      Object arg4) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(getTag(cls), formatString(msg, arg1, arg2, arg3, arg4));
+    public static void d(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3,
+                         Object arg4) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(getTag(cls), formatString(msg, arg1, arg2, arg3, arg4));
+        }
     }
-  }
 
-  public static void d(String tag, String msg, Object... args) {
-    if (sHandler.isLoggable(DEBUG)) {
-      d(tag, formatString(msg, args));
+    public static void d(String tag, String msg, Object... args) {
+        if (sHandler.isLoggable(DEBUG)) {
+            d(tag, formatString(msg, args));
+        }
     }
-  }
 
-  public static void d(String tag, Throwable tr, String msg, Object... args) {
-    if (sHandler.isLoggable(DEBUG)) {
-      d(tag, formatString(msg, args), tr);
+    public static void d(String tag, Throwable tr, String msg, Object... args) {
+        if (sHandler.isLoggable(DEBUG)) {
+            d(tag, formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void d(Class<?> cls, String msg, Object... args) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(getTag(cls), formatString(msg, args));
+    public static void d(Class<?> cls, String msg, Object... args) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(getTag(cls), formatString(msg, args));
+        }
     }
-  }
 
-  public static void d(Class<?> cls, Throwable tr, String msg, Object... args) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(getTag(cls), formatString(msg, args), tr);
+    public static void d(Class<?> cls, Throwable tr, String msg, Object... args) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(getTag(cls), formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void d(String tag, String msg, Throwable tr) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(tag, msg, tr);
+    public static void d(String tag, String msg, Throwable tr) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(tag, msg, tr);
+        }
     }
-  }
 
-  public static void d(Class<?> cls, String msg, Throwable tr) {
-    if (sHandler.isLoggable(DEBUG)) {
-      sHandler.d(getTag(cls), msg, tr);
+    public static void d(Class<?> cls, String msg, Throwable tr) {
+        if (sHandler.isLoggable(DEBUG)) {
+            sHandler.d(getTag(cls), msg, tr);
+        }
     }
-  }
 
-  public static void i(String tag, String msg) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(tag, msg);
+    public static void i(String tag, String msg) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(tag, msg);
+        }
     }
-  }
 
-  public static void i(String tag, String msg, Object arg1) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(tag, formatString(msg, arg1));
+    public static void i(String tag, String msg, Object arg1) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(tag, formatString(msg, arg1));
+        }
     }
-  }
 
-  public static void i(String tag, String msg, Object arg1, Object arg2) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(tag, formatString(msg, arg1, arg2));
+    public static void i(String tag, String msg, Object arg1, Object arg2) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(tag, formatString(msg, arg1, arg2));
+        }
     }
-  }
 
-  public static void i(String tag, String msg, Object arg1, Object arg2, Object arg3) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(tag, formatString(msg, arg1, arg2, arg3));
+    public static void i(String tag, String msg, Object arg1, Object arg2, Object arg3) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(tag, formatString(msg, arg1, arg2, arg3));
+        }
     }
-  }
 
-  public static void i(String tag, String msg, Object arg1, Object arg2, Object arg3, Object arg4) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(tag, formatString(msg, arg1, arg2, arg3, arg4));
+    public static void i(String tag, String msg, Object arg1, Object arg2, Object arg3, Object arg4) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(tag, formatString(msg, arg1, arg2, arg3, arg4));
+        }
     }
-  }
 
-  public static void i(Class<?> cls, String msg) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(getTag(cls), msg);
+    public static void i(Class<?> cls, String msg) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(getTag(cls), msg);
+        }
     }
-  }
 
-  public static void i(Class<?> cls, String msg, Object arg1) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(getTag(cls), formatString(msg, arg1));
+    public static void i(Class<?> cls, String msg, Object arg1) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(getTag(cls), formatString(msg, arg1));
+        }
     }
-  }
 
-  public static void i(Class<?> cls, String msg, Object arg1, Object arg2) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(getTag(cls), formatString(msg, arg1, arg2));
+    public static void i(Class<?> cls, String msg, Object arg1, Object arg2) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(getTag(cls), formatString(msg, arg1, arg2));
+        }
     }
-  }
 
-  public static void i(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(getTag(cls), formatString(msg, arg1, arg2, arg3));
+    public static void i(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(getTag(cls), formatString(msg, arg1, arg2, arg3));
+        }
     }
-  }
 
-  public static void i(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3,
-      Object arg4) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(getTag(cls), formatString(msg, arg1, arg2, arg3, arg4));
+    public static void i(Class<?> cls, String msg, Object arg1, Object arg2, Object arg3,
+                         Object arg4) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(getTag(cls), formatString(msg, arg1, arg2, arg3, arg4));
+        }
     }
-  }
 
-  public static void i(String tag, String msg, Object... args) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(tag, formatString(msg, args));
+    public static void i(String tag, String msg, Object... args) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(tag, formatString(msg, args));
+        }
     }
-  }
 
-  public static void i(String tag, Throwable tr, String msg, Object... args) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(tag, formatString(msg, args), tr);
+    public static void i(String tag, Throwable tr, String msg, Object... args) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(tag, formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void i(Class<?> cls, String msg, Object... args) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(getTag(cls), formatString(msg, args));
+    public static void i(Class<?> cls, String msg, Object... args) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(getTag(cls), formatString(msg, args));
+        }
     }
-  }
 
-  public static void i(Class <?> cls, Throwable tr, String msg, Object... args) {
-    if (isLoggable(INFO)) {
-      sHandler.i(getTag(cls), formatString(msg, args), tr);
+    public static void i(Class<?> cls, Throwable tr, String msg, Object... args) {
+        if (isLoggable(INFO)) {
+            sHandler.i(getTag(cls), formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void i(String tag, String msg, Throwable tr) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(tag, msg, tr);
+    public static void i(String tag, String msg, Throwable tr) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(tag, msg, tr);
+        }
     }
-  }
 
-  public static void i(Class<?> cls, String msg, Throwable tr) {
-    if (sHandler.isLoggable(INFO)) {
-      sHandler.i(getTag(cls), msg, tr);
+    public static void i(Class<?> cls, String msg, Throwable tr) {
+        if (sHandler.isLoggable(INFO)) {
+            sHandler.i(getTag(cls), msg, tr);
+        }
     }
-  }
 
-  public static void w(String tag, String msg) {
-    if (sHandler.isLoggable(WARN)) {
-      sHandler.w(tag, msg);
+    public static void w(String tag, String msg) {
+        if (sHandler.isLoggable(WARN)) {
+            sHandler.w(tag, msg);
+        }
     }
-  }
 
-  public static void w(Class <?> cls, String msg) {
-    if (sHandler.isLoggable(WARN)) {
-      sHandler.w(getTag(cls), msg);
+    public static void w(Class<?> cls, String msg) {
+        if (sHandler.isLoggable(WARN)) {
+            sHandler.w(getTag(cls), msg);
+        }
     }
-  }
 
-  public static void w(String tag, String msg, Object... args) {
-    if (sHandler.isLoggable(WARN)) {
-      sHandler.w(tag, formatString(msg, args));
+    public static void w(String tag, String msg, Object... args) {
+        if (sHandler.isLoggable(WARN)) {
+            sHandler.w(tag, formatString(msg, args));
+        }
     }
-  }
 
-  public static void w(String tag, Throwable tr, String msg, Object... args) {
-    if (sHandler.isLoggable(WARN)) {
-      sHandler.w(tag, formatString(msg, args), tr);
+    public static void w(String tag, Throwable tr, String msg, Object... args) {
+        if (sHandler.isLoggable(WARN)) {
+            sHandler.w(tag, formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void w(Class<?> cls, String msg, Object... args) {
-    if (sHandler.isLoggable(WARN)) {
-      sHandler.w(getTag(cls), formatString(msg, args));
+    public static void w(Class<?> cls, String msg, Object... args) {
+        if (sHandler.isLoggable(WARN)) {
+            sHandler.w(getTag(cls), formatString(msg, args));
+        }
     }
-  }
 
-  public static void w(Class<?> cls, Throwable tr, String msg, Object... args) {
-    if (isLoggable(WARN)) {
-      w(cls, formatString(msg, args), tr);
+    public static void w(Class<?> cls, Throwable tr, String msg, Object... args) {
+        if (isLoggable(WARN)) {
+            w(cls, formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void w(String tag, String msg, Throwable tr) {
-    if (sHandler.isLoggable(WARN)) {
-      sHandler.w(tag, msg, tr);
+    public static void w(String tag, String msg, Throwable tr) {
+        if (sHandler.isLoggable(WARN)) {
+            sHandler.w(tag, msg, tr);
+        }
     }
-  }
 
-  public static void w(Class <?> cls, String msg, Throwable tr) {
-    if (sHandler.isLoggable(WARN)) {
-      sHandler.w(getTag(cls), msg, tr);
+    public static void w(Class<?> cls, String msg, Throwable tr) {
+        if (sHandler.isLoggable(WARN)) {
+            sHandler.w(getTag(cls), msg, tr);
+        }
     }
-  }
 
-  public static void e(String tag, String msg) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.e(tag, msg);
+    public static void e(String tag, String msg) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.e(tag, msg);
+        }
     }
-  }
 
-  public static void e(Class <?> cls, String msg) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.e(getTag(cls), msg);
+    public static void e(Class<?> cls, String msg) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.e(getTag(cls), msg);
+        }
     }
-  }
 
-  public static void e(String tag, String msg, Object... args) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.e(tag, formatString(msg, args));
+    public static void e(String tag, String msg, Object... args) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.e(tag, formatString(msg, args));
+        }
     }
-  }
 
-  public static void e(String tag, Throwable tr, String msg, Object... args) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.e(tag, formatString(msg, args), tr);
+    public static void e(String tag, Throwable tr, String msg, Object... args) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.e(tag, formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void e(Class<?> cls, String msg, Object... args) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.e(getTag(cls), formatString(msg, args));
+    public static void e(Class<?> cls, String msg, Object... args) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.e(getTag(cls), formatString(msg, args));
+        }
     }
-  }
 
-  public static void e(Class<?> cls, Throwable tr, String msg, Object... args) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.e(getTag(cls), formatString(msg, args), tr);
+    public static void e(Class<?> cls, Throwable tr, String msg, Object... args) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.e(getTag(cls), formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void e(String tag, String msg, Throwable tr) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.e(tag, msg, tr);
+    public static void e(String tag, String msg, Throwable tr) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.e(tag, msg, tr);
+        }
     }
-  }
 
-  public static void e(Class <?> cls, String msg, Throwable tr) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.e(getTag(cls), msg, tr);
+    public static void e(Class<?> cls, String msg, Throwable tr) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.e(getTag(cls), msg, tr);
+        }
     }
-  }
 
-  public static void wtf(String tag, String msg) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.e(tag, msg);
+    public static void wtf(String tag, String msg) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.e(tag, msg);
+        }
     }
-  }
 
-  public static void wtf(Class <?> cls, String msg) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.e(getTag(cls), msg);
+    public static void wtf(Class<?> cls, String msg) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.e(getTag(cls), msg);
+        }
     }
-  }
 
-  public static void wtf(String tag, String msg, Object... args) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.wtf(tag, formatString(msg, args));
+    public static void wtf(String tag, String msg, Object... args) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.wtf(tag, formatString(msg, args));
+        }
     }
-  }
 
-  public static void wtf(String tag, Throwable tr, String msg, Object... args) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.wtf(tag, formatString(msg, args), tr);
+    public static void wtf(String tag, Throwable tr, String msg, Object... args) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.wtf(tag, formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void wtf(Class <?> cls, String msg, Object... args) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.wtf(getTag(cls), formatString(msg, args));
+    public static void wtf(Class<?> cls, String msg, Object... args) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.wtf(getTag(cls), formatString(msg, args));
+        }
     }
-  }
 
-  public static void wtf(Class <?> cls, Throwable tr, String msg, Object... args) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.wtf(getTag(cls), formatString(msg, args), tr);
+    public static void wtf(Class<?> cls, Throwable tr, String msg, Object... args) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.wtf(getTag(cls), formatString(msg, args), tr);
+        }
     }
-  }
 
-  public static void wtf(String tag, String msg, Throwable tr) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.wtf(tag, msg, tr);
+    public static void wtf(String tag, String msg, Throwable tr) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.wtf(tag, msg, tr);
+        }
     }
-  }
 
-  public static void wtf(Class <?> cls, String msg, Throwable tr) {
-    if (sHandler.isLoggable(ERROR)) {
-      sHandler.wtf(getTag(cls), msg, tr);
+    public static void wtf(Class<?> cls, String msg, Throwable tr) {
+        if (sHandler.isLoggable(ERROR)) {
+            sHandler.wtf(getTag(cls), msg, tr);
+        }
     }
-  }
 
-  private static String formatString(String str, Object... args) {
-    return String.format(null, str, args);
-  }
+    private static String formatString(String str, Object... args) {
+        return String.format(null, str, args);
+    }
 
-  private static String getTag(Class<?> clazz) {
-    return clazz.getSimpleName();
-  }
+    private static String getTag(Class<?> clazz) {
+        return clazz.getSimpleName();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/logging/FLogDefaultLoggingDelegate.java b/fbcore/src/main/java/com/facebook/common/logging/FLogDefaultLoggingDelegate.java
index c3cfa55d7..a7440f2b4 100644
--- a/fbcore/src/main/java/com/facebook/common/logging/FLogDefaultLoggingDelegate.java
+++ b/fbcore/src/main/java/com/facebook/common/logging/FLogDefaultLoggingDelegate.java
@@ -19,159 +19,159 @@
  */
 public class FLogDefaultLoggingDelegate implements LoggingDelegate {
 
-  public static final FLogDefaultLoggingDelegate sInstance = new FLogDefaultLoggingDelegate();
-
-  private String mApplicationTag = "unknown";
-  private int mMinimumLoggingLevel = Log.WARN;
-
-  public static FLogDefaultLoggingDelegate getInstance() {
-    return sInstance;
-  }
-
-  private FLogDefaultLoggingDelegate() {
-  }
-
-  /**
-   * Sets an application tag that is used for checking if a log line is loggable and also
-   * to prefix to all log lines.
-   *
-   * @param tag the tag
-   */
-  public void setApplicationTag(String tag) {
-    mApplicationTag = tag;
-  }
-
-
-  @Override
-  public void setMinimumLoggingLevel(int level) {
-    mMinimumLoggingLevel = level;
-  }
-
-  @Override
-  public int getMinimumLoggingLevel() {
-    return mMinimumLoggingLevel;
-  }
-
-  @Override
-  public boolean isLoggable(int level) {
-    return mMinimumLoggingLevel <= level;
-  }
-
-  @Override
-  public boolean isLoggable(String tag, int level) {
-    try {
-      return mMinimumLoggingLevel <= level && Log.isLoggable(tag, level);
-    } catch (IllegalArgumentException e) {
-      // isLoggable yields an IllegalArgumentException if tag.length() > 23.  we could
-      // hard-code this constant in here, but if the SDK changes the length, we're in for a
-      // real treat.  thus, we catch the exception.
-      //
-      // We're making an educated guess as to a reasonably policy for when the exception
-      // happens, which is to log.
-      return true;
-    }
-  }
-
-  @Override
-  public void v(String tag, String msg) {
-    println(Log.VERBOSE, tag, msg);
-  }
-
-  @Override
-  public void v(String tag, String msg, Throwable tr) {
-    println(Log.VERBOSE, tag, msg, tr);
-  }
-
-  @Override
-  public void d(String tag, String msg) {
-    println(Log.DEBUG, tag, msg);
-  }
-
-  @Override
-  public void d(String tag, String msg, Throwable tr) {
-    println(Log.DEBUG, tag, msg, tr);
-  }
-
-  @Override
-  public void i(String tag, String msg) {
-    println(Log.INFO, tag, msg);
-  }
-
-  @Override
-  public void i(String tag, String msg, Throwable tr) {
-    println(Log.INFO, tag, msg, tr);
-  }
-
-  @Override
-  public void w(String tag, String msg) {
-    println(Log.WARN, tag, msg);
-  }
-
-  @Override
-  public void w(String tag, String msg, Throwable tr) {
-    println(Log.WARN, tag, msg, tr);
-  }
-
-  @Override
-  public void e(String tag, String msg) {
-    println(Log.ERROR, tag, msg);
-  }
-
-  @Override
-  public void e(String tag, String msg, Throwable tr) {
-    println(Log.ERROR, tag, msg, tr);
-  }
-
-  /**
-   * <p> Note: this gets forwarded to {@code android.util.Log.e} as {@code android.util.Log.wtf}
-   * might crash the app.
-   */
-  @Override
-  public void wtf(String tag, String msg) {
-    println(Log.ERROR, tag, msg);
-  }
-
-  /**
-   * <p> Note: this gets forwarded to {@code android.util.Log.e} as {@code android.util.Log.wtf}
-   * might crash the app.
-   */
-  @Override
-  public void wtf(String tag, String msg, Throwable tr) {
-    println(Log.ERROR, tag, msg, tr);
-  }
-
-  @Override
-  public void log(int priority, String tag, String msg) {
-    println(priority, tag, msg);
-  }
-
-  private void println(int priority, String tag, String msg) {
-    Log.println(priority, prefixTag(tag), msg);
-  }
-
-  private void println(int priority, String tag, String msg, Throwable tr) {
-    Log.println(priority, prefixTag(tag), getMsg(msg, tr));
-  }
-
-  private String prefixTag(String tag) {
-    if (mApplicationTag != null) {
-      return mApplicationTag + ":" + tag;
-    } else {
-      return tag;
-    }
-  }
-
-  private static String getMsg(String msg, Throwable tr) {
-    return msg + '\n' + getStackTraceString(tr);
-  }
-
-  private static String getStackTraceString(Throwable tr) {
-    if (tr == null) {
-      return "";
-    }
-    StringWriter sw = new StringWriter();
-    PrintWriter pw = new PrintWriter(sw);
-    tr.printStackTrace(pw);
-    return sw.toString();
-  }
+    public static final FLogDefaultLoggingDelegate sInstance = new FLogDefaultLoggingDelegate();
+
+    private String mApplicationTag = "unknown";
+    private int mMinimumLoggingLevel = Log.WARN;
+
+    public static FLogDefaultLoggingDelegate getInstance() {
+        return sInstance;
+    }
+
+    private FLogDefaultLoggingDelegate() {
+    }
+
+    /**
+     * Sets an application tag that is used for checking if a log line is loggable and also
+     * to prefix to all log lines.
+     *
+     * @param tag the tag
+     */
+    public void setApplicationTag(String tag) {
+        mApplicationTag = tag;
+    }
+
+
+    @Override
+    public void setMinimumLoggingLevel(int level) {
+        mMinimumLoggingLevel = level;
+    }
+
+    @Override
+    public int getMinimumLoggingLevel() {
+        return mMinimumLoggingLevel;
+    }
+
+    @Override
+    public boolean isLoggable(int level) {
+        return mMinimumLoggingLevel <= level;
+    }
+
+    @Override
+    public boolean isLoggable(String tag, int level) {
+        try {
+            return mMinimumLoggingLevel <= level && Log.isLoggable(tag, level);
+        } catch (IllegalArgumentException e) {
+            // isLoggable yields an IllegalArgumentException if tag.length() > 23.  we could
+            // hard-code this constant in here, but if the SDK changes the length, we're in for a
+            // real treat.  thus, we catch the exception.
+            //
+            // We're making an educated guess as to a reasonably policy for when the exception
+            // happens, which is to log.
+            return true;
+        }
+    }
+
+    @Override
+    public void v(String tag, String msg) {
+        println(Log.VERBOSE, tag, msg);
+    }
+
+    @Override
+    public void v(String tag, String msg, Throwable tr) {
+        println(Log.VERBOSE, tag, msg, tr);
+    }
+
+    @Override
+    public void d(String tag, String msg) {
+        println(Log.DEBUG, tag, msg);
+    }
+
+    @Override
+    public void d(String tag, String msg, Throwable tr) {
+        println(Log.DEBUG, tag, msg, tr);
+    }
+
+    @Override
+    public void i(String tag, String msg) {
+        println(Log.INFO, tag, msg);
+    }
+
+    @Override
+    public void i(String tag, String msg, Throwable tr) {
+        println(Log.INFO, tag, msg, tr);
+    }
+
+    @Override
+    public void w(String tag, String msg) {
+        println(Log.WARN, tag, msg);
+    }
+
+    @Override
+    public void w(String tag, String msg, Throwable tr) {
+        println(Log.WARN, tag, msg, tr);
+    }
+
+    @Override
+    public void e(String tag, String msg) {
+        println(Log.ERROR, tag, msg);
+    }
+
+    @Override
+    public void e(String tag, String msg, Throwable tr) {
+        println(Log.ERROR, tag, msg, tr);
+    }
+
+    /**
+     * <p> Note: this gets forwarded to {@code android.util.Log.e} as {@code android.util.Log.wtf}
+     * might crash the app.
+     */
+    @Override
+    public void wtf(String tag, String msg) {
+        println(Log.ERROR, tag, msg);
+    }
+
+    /**
+     * <p> Note: this gets forwarded to {@code android.util.Log.e} as {@code android.util.Log.wtf}
+     * might crash the app.
+     */
+    @Override
+    public void wtf(String tag, String msg, Throwable tr) {
+        println(Log.ERROR, tag, msg, tr);
+    }
+
+    @Override
+    public void log(int priority, String tag, String msg) {
+        println(priority, tag, msg);
+    }
+
+    private void println(int priority, String tag, String msg) {
+        Log.println(priority, prefixTag(tag), msg);
+    }
+
+    private void println(int priority, String tag, String msg, Throwable tr) {
+        Log.println(priority, prefixTag(tag), getMsg(msg, tr));
+    }
+
+    private String prefixTag(String tag) {
+        if (mApplicationTag != null) {
+            return mApplicationTag + ":" + tag;
+        } else {
+            return tag;
+        }
+    }
+
+    private static String getMsg(String msg, Throwable tr) {
+        return msg + '\n' + getStackTraceString(tr);
+    }
+
+    private static String getStackTraceString(Throwable tr) {
+        if (tr == null) {
+            return "";
+        }
+        StringWriter sw = new StringWriter();
+        PrintWriter pw = new PrintWriter(sw);
+        tr.printStackTrace(pw);
+        return sw.toString();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/logging/LoggingDelegate.java b/fbcore/src/main/java/com/facebook/common/logging/LoggingDelegate.java
index 08b6f79c9..75f738536 100644
--- a/fbcore/src/main/java/com/facebook/common/logging/LoggingDelegate.java
+++ b/fbcore/src/main/java/com/facebook/common/logging/LoggingDelegate.java
@@ -14,160 +14,160 @@
  */
 public interface LoggingDelegate {
 
-  /**
-   * Sets a minimum log-level under which the logger will not log regardless of other checks.
-   *
-   * @param level the minimum level to set
-   */
-  void setMinimumLoggingLevel(int level);
-
-  /**
-   * Gets a minimum log-level under which the logger will not log regardless of other checks.
-   *
-   * @return the minimum level
-   */
-  int getMinimumLoggingLevel();
-
-  /**
-   * Gets whether the specified level is loggable.
-   *
-   * @param level the level to check
-   * @return the level
-   */
-  boolean isLoggable(int level);
-
-  /**
-   * Gets whether the specified level and tag is loggable. How the delegate handles checking the
-   * tag is up to the delegate.
-   *
-   * @param tag the lag to check
-   * @param level the level
-   * @return whether it's loggable
-   */
-  boolean isLoggable(String tag, int level);
-
-  /**
-   * Send a {@link android.util.Log#VERBOSE} log message.
-   *
-   * @param tag Used to identify the source of a log message.  It usually identifies
-   *            the class or activity where the log call occurs.
-   * @param msg The message you would like logged.
-   */
-  void v(String tag, String msg);
-
-  /**
-   * Send a {@link android.util.Log#VERBOSE} log message and log the exception.
-   *
-   * @param tag Used to identify the source of a log message.  It usually identifies
-   *            the class or activity where the log call occurs.
-   * @param msg The message you would like logged.
-   * @param tr  An exception to log
-   */
-  void v(String tag, String msg, Throwable tr);
-
-  /**
-   * Send a {@link android.util.Log#DEBUG} log message.
-   *
-   * @param tag Used to identify the source of a log message.  It usually identifies
-   *            the class or activity where the log call occurs.
-   * @param msg The message you would like logged.
-   */
-  void d(String tag, String msg);
-
-  /**
-   * Send a {@link android.util.Log#DEBUG} log message and log the exception.
-   *
-   * @param tag Used to identify the source of a log message.  It usually identifies
-   *            the class or activity where the log call occurs.
-   * @param msg The message you would like logged.
-   * @param tr  An exception to log
-   */
-  void d(String tag, String msg, Throwable tr);
-
-  /**
-   * Send an {@link android.util.Log#INFO} log message.
-   *
-   * @param tag Used to identify the source of a log message.  It usually identifies
-   *            the class or activity where the log call occurs.
-   * @param msg The message you would like logged.
-   */
-  void i(String tag, String msg);
-
-  /**
-   * Send a {@link android.util.Log#INFO} log message and log the exception.
-   *
-   * @param tag Used to identify the source of a log message.  It usually identifies
-   *            the class or activity where the log call occurs.
-   * @param msg The message you would like logged.
-   * @param tr  An exception to log
-   */
-  void i(String tag, String msg, Throwable tr);
-
-  /**
-   * Send a {@link android.util.Log#WARN} log message.
-   *
-   * @param tag Used to identify the source of a log message.  It usually identifies
-   *            the class or activity where the log call occurs.
-   * @param msg The message you would like logged.
-   */
-  void w(String tag, String msg);
-
-  /**
-   * Send a {@link android.util.Log#WARN} log message and log the exception.
-   *
-   * @param tag Used to identify the source of a log message.  It usually identifies
-   *            the class or activity where the log call occurs.
-   * @param msg The message you would like logged.
-   * @param tr  An exception to log
-   */
-  void w(String tag, String msg, Throwable tr);
-
-  /**
-   * Send an {@link android.util.Log#ERROR} log message.
-   *
-   * @param tag Used to identify the source of a log message.  It usually identifies
-   *            the class or activity where the log call occurs.
-   * @param msg The message you would like logged.
-   */
-  void e(String tag, String msg);
-
-  /**
-   * Send a {@link android.util.Log#ERROR} log message and log the exception.
-   *
-   * @param tag Used to identify the source of a log message.  It usually identifies
-   *            the class or activity where the log call occurs.
-   * @param msg The message you would like logged.
-   * @param tr  An exception to log
-   */
-  void e(String tag, String msg, Throwable tr);
-
-  /**
-   * Send an {@link android.util.Log#ERROR} log message.
-   * Send wtf soft error report (sampled).
-   * Note: This is not equivalent of {@link android.util.Log#wtf}.
-   *
-   * @param tag Used to identify the source of a log message.
-   * @param msg The message you would like logged.
-   */
-  void wtf(String tag, String msg);
-
-  /**
-   * Send an {@link android.util.Log#ERROR} log message.
-   * Send wtf soft error report (sampled).
-   * Note: This is not equivalent of {@link android.util.Log#wtf}.
-   *
-   * @param tag Used to identify the source of a log message.
-   * @param msg The message you would like logged.
-   * @param tr  An exception to log.  May be null.
-   */
-  void wtf(String tag, String msg, Throwable tr);
-
-  /**
-   * Logs a message.
-   *
-   * @param priority the priority of the message
-   * @param tag Used to identify the source of a log message.
-   * @param msg The message you would like logged.
-   */
-  void log(int priority, String tag, String msg);
+    /**
+     * Sets a minimum log-level under which the logger will not log regardless of other checks.
+     *
+     * @param level the minimum level to set
+     */
+    void setMinimumLoggingLevel(int level);
+
+    /**
+     * Gets a minimum log-level under which the logger will not log regardless of other checks.
+     *
+     * @return the minimum level
+     */
+    int getMinimumLoggingLevel();
+
+    /**
+     * Gets whether the specified level is loggable.
+     *
+     * @param level the level to check
+     * @return the level
+     */
+    boolean isLoggable(int level);
+
+    /**
+     * Gets whether the specified level and tag is loggable. How the delegate handles checking the
+     * tag is up to the delegate.
+     *
+     * @param tag   the lag to check
+     * @param level the level
+     * @return whether it's loggable
+     */
+    boolean isLoggable(String tag, int level);
+
+    /**
+     * Send a {@link android.util.Log#VERBOSE} log message.
+     *
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *            the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     */
+    void v(String tag, String msg);
+
+    /**
+     * Send a {@link android.util.Log#VERBOSE} log message and log the exception.
+     *
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *            the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @param tr  An exception to log
+     */
+    void v(String tag, String msg, Throwable tr);
+
+    /**
+     * Send a {@link android.util.Log#DEBUG} log message.
+     *
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *            the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     */
+    void d(String tag, String msg);
+
+    /**
+     * Send a {@link android.util.Log#DEBUG} log message and log the exception.
+     *
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *            the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @param tr  An exception to log
+     */
+    void d(String tag, String msg, Throwable tr);
+
+    /**
+     * Send an {@link android.util.Log#INFO} log message.
+     *
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *            the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     */
+    void i(String tag, String msg);
+
+    /**
+     * Send a {@link android.util.Log#INFO} log message and log the exception.
+     *
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *            the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @param tr  An exception to log
+     */
+    void i(String tag, String msg, Throwable tr);
+
+    /**
+     * Send a {@link android.util.Log#WARN} log message.
+     *
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *            the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     */
+    void w(String tag, String msg);
+
+    /**
+     * Send a {@link android.util.Log#WARN} log message and log the exception.
+     *
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *            the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @param tr  An exception to log
+     */
+    void w(String tag, String msg, Throwable tr);
+
+    /**
+     * Send an {@link android.util.Log#ERROR} log message.
+     *
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *            the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     */
+    void e(String tag, String msg);
+
+    /**
+     * Send a {@link android.util.Log#ERROR} log message and log the exception.
+     *
+     * @param tag Used to identify the source of a log message.  It usually identifies
+     *            the class or activity where the log call occurs.
+     * @param msg The message you would like logged.
+     * @param tr  An exception to log
+     */
+    void e(String tag, String msg, Throwable tr);
+
+    /**
+     * Send an {@link android.util.Log#ERROR} log message.
+     * Send wtf soft error report (sampled).
+     * Note: This is not equivalent of {@link android.util.Log#wtf}.
+     *
+     * @param tag Used to identify the source of a log message.
+     * @param msg The message you would like logged.
+     */
+    void wtf(String tag, String msg);
+
+    /**
+     * Send an {@link android.util.Log#ERROR} log message.
+     * Send wtf soft error report (sampled).
+     * Note: This is not equivalent of {@link android.util.Log#wtf}.
+     *
+     * @param tag Used to identify the source of a log message.
+     * @param msg The message you would like logged.
+     * @param tr  An exception to log.  May be null.
+     */
+    void wtf(String tag, String msg, Throwable tr);
+
+    /**
+     * Logs a message.
+     *
+     * @param priority the priority of the message
+     * @param tag      Used to identify the source of a log message.
+     * @param msg      The message you would like logged.
+     */
+    void log(int priority, String tag, String msg);
 }
diff --git a/fbcore/src/main/java/com/facebook/common/media/MediaUtils.java b/fbcore/src/main/java/com/facebook/common/media/MediaUtils.java
index 01a0873ae..b0ec9c3d4 100644
--- a/fbcore/src/main/java/com/facebook/common/media/MediaUtils.java
+++ b/fbcore/src/main/java/com/facebook/common/media/MediaUtils.java
@@ -22,48 +22,52 @@
  * Utility class.
  */
 public class MediaUtils {
-  // Additional mime types that we know to be a particular media type but which may not be
-  // supported natively on the device.
-  public static final Map<String, String> ADDITIONAL_ALLOWED_MIME_TYPES =
-      ImmutableMap.of("mkv", "video/x-matroska");
+    // Additional mime types that we know to be a particular media type but which may not be
+    // supported natively on the device.
+    public static final Map<String, String> ADDITIONAL_ALLOWED_MIME_TYPES =
+            ImmutableMap.of("mkv", "video/x-matroska");
 
-  public static boolean isPhoto(@Nullable String mimeType) {
-    return mimeType != null && mimeType.startsWith("image/");
-  }
-
-  public static boolean isVideo(@Nullable String mimeType) {
-    return mimeType != null && mimeType.startsWith("video/");
-  }
+    public static boolean isPhoto(@Nullable String mimeType) {
+        return mimeType != null && mimeType.startsWith("image/");
+    }
 
-  public @Nullable static String extractMime(String path) {
-    String extension = extractExtension(path);
-    if (extension == null) {
-      return null;
+    public static boolean isVideo(@Nullable String mimeType) {
+        return mimeType != null && mimeType.startsWith("video/");
     }
-    extension = extension.toLowerCase(Locale.US);
-    String mimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
 
-    // If we did not find a mime type for the extension specified, check our additional
-    // extension/mime-type mappings.
-    if (mimeType == null) {
-      mimeType = ADDITIONAL_ALLOWED_MIME_TYPES.get(extension);
+    public
+    @Nullable
+    static String extractMime(String path) {
+        String extension = extractExtension(path);
+        if (extension == null) {
+            return null;
+        }
+        extension = extension.toLowerCase(Locale.US);
+        String mimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
+
+        // If we did not find a mime type for the extension specified, check our additional
+        // extension/mime-type mappings.
+        if (mimeType == null) {
+            mimeType = ADDITIONAL_ALLOWED_MIME_TYPES.get(extension);
+        }
+        return mimeType;
     }
-    return mimeType;
-  }
 
-  private @Nullable static String extractExtension(String path) {
-    int pos = path.lastIndexOf('.');
-    if (pos < 0 || pos == path.length() - 1) {
-      return null;
+    private
+    @Nullable
+    static String extractExtension(String path) {
+        int pos = path.lastIndexOf('.');
+        if (pos < 0 || pos == path.length() - 1) {
+            return null;
+        }
+        return path.substring(pos + 1);
     }
-    return path.substring(pos + 1);
-  }
 
-  /**
-   * @return true if the mime type is one of our whitelisted mimetypes that we support beyond
-   *         what the native platform supports.
-   */
-  public static boolean isNonNativeSupportedMimeType(String mimeType) {
-    return ADDITIONAL_ALLOWED_MIME_TYPES.containsValue(mimeType);
-  }
+    /**
+     * @return true if the mime type is one of our whitelisted mimetypes that we support beyond
+     * what the native platform supports.
+     */
+    public static boolean isNonNativeSupportedMimeType(String mimeType) {
+        return ADDITIONAL_ALLOWED_MIME_TYPES.containsValue(mimeType);
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimType.java b/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimType.java
index 89b70faa5..3eea3b3f1 100644
--- a/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimType.java
+++ b/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimType.java
@@ -11,33 +11,43 @@
 
 /**
  * Types of memory trim.
- *
+ * <p>
  * <p>Each type of trim will provide a suggested trim ratio.
- *
+ * <p>
  * <p>A {@link MemoryTrimmableRegistry} implementation sends out memory trim events with this type.
  */
 public enum MemoryTrimType {
 
-  /** The application is approaching the device-specific Java heap limit. */
-  OnCloseToDalvikHeapLimit(0.5),
-
-  /** The system as a whole is running out of memory, and this application is in the foreground. */
-  OnSystemLowMemoryWhileAppInForeground(0.5),
-
-  /** The system as a whole is running out of memory, and this application is in the background. */
-  OnSystemLowMemoryWhileAppInBackground(1),
-
-  /** This app is moving into the background, usually because the user navigated to another app. */
-  OnAppBackgrounded(1);
-
-  private double mSuggestedTrimRatio;
-
-  private MemoryTrimType(double suggestedTrimRatio) {
-    mSuggestedTrimRatio = suggestedTrimRatio;
-  }
-
-  /** Get the recommended percentage by which to trim the cache on receiving this event. */
-  public double getSuggestedTrimRatio () {
-    return mSuggestedTrimRatio;
-  }
+    /**
+     * The application is approaching the device-specific Java heap limit.
+     */
+    OnCloseToDalvikHeapLimit(0.5),
+
+    /**
+     * The system as a whole is running out of memory, and this application is in the foreground.
+     */
+    OnSystemLowMemoryWhileAppInForeground(0.5),
+
+    /**
+     * The system as a whole is running out of memory, and this application is in the background.
+     */
+    OnSystemLowMemoryWhileAppInBackground(1),
+
+    /**
+     * This app is moving into the background, usually because the user navigated to another app.
+     */
+    OnAppBackgrounded(1);
+
+    private double mSuggestedTrimRatio;
+
+    private MemoryTrimType(double suggestedTrimRatio) {
+        mSuggestedTrimRatio = suggestedTrimRatio;
+    }
+
+    /**
+     * Get the recommended percentage by which to trim the cache on receiving this event.
+     */
+    public double getSuggestedTrimRatio() {
+        return mSuggestedTrimRatio;
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimmable.java b/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimmable.java
index 8172d0cbe..b6a9c798e 100644
--- a/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimmable.java
+++ b/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimmable.java
@@ -16,8 +16,8 @@
 
 public interface MemoryTrimmable {
 
-  /**
-   * Trim memory.
-   */
-  public void trim(MemoryTrimType trimType);
+    /**
+     * Trim memory.
+     */
+    public void trim(MemoryTrimType trimType);
 }
diff --git a/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimmableRegistry.java b/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimmableRegistry.java
index 64a560985..29fd6b005 100644
--- a/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimmableRegistry.java
+++ b/fbcore/src/main/java/com/facebook/common/memory/MemoryTrimmableRegistry.java
@@ -11,18 +11,22 @@
 
 /**
  * A class which keeps a list of other classes to be notified of system memory events.
- *
+ * <p>
  * <p>If a class uses a lot of memory and needs these notices from the system, it should implement
  * the {@link MemoryTrimmable} interface.
- *
+ * <p>
  * <p>Implementations of this class should notify all the trimmables that have registered with it
  * when they need to trim their memory usage.
  */
 public interface MemoryTrimmableRegistry {
 
-  /** Register an object. */
-  void registerMemoryTrimmable(MemoryTrimmable trimmable);
+    /**
+     * Register an object.
+     */
+    void registerMemoryTrimmable(MemoryTrimmable trimmable);
 
-  /** Unregister an object. */
-  void unregisterMemoryTrimmable(MemoryTrimmable trimmable);
+    /**
+     * Unregister an object.
+     */
+    void unregisterMemoryTrimmable(MemoryTrimmable trimmable);
 }
diff --git a/fbcore/src/main/java/com/facebook/common/memory/NoOpMemoryTrimmableRegistry.java b/fbcore/src/main/java/com/facebook/common/memory/NoOpMemoryTrimmableRegistry.java
index 09059cc72..55d633271 100644
--- a/fbcore/src/main/java/com/facebook/common/memory/NoOpMemoryTrimmableRegistry.java
+++ b/fbcore/src/main/java/com/facebook/common/memory/NoOpMemoryTrimmableRegistry.java
@@ -13,23 +13,27 @@
  * Implementation of {@link MemoryTrimmableRegistry} that does not do anything.
  */
 public class NoOpMemoryTrimmableRegistry implements MemoryTrimmableRegistry {
-  private static NoOpMemoryTrimmableRegistry sInstance = null;
+    private static NoOpMemoryTrimmableRegistry sInstance = null;
 
-  private NoOpMemoryTrimmableRegistry() {
-  }
+    private NoOpMemoryTrimmableRegistry() {
+    }
 
-  public static synchronized NoOpMemoryTrimmableRegistry getInstance() {
-    if (sInstance == null) {
-      sInstance = new NoOpMemoryTrimmableRegistry();
+    public static synchronized NoOpMemoryTrimmableRegistry getInstance() {
+        if (sInstance == null) {
+            sInstance = new NoOpMemoryTrimmableRegistry();
+        }
+        return sInstance;
     }
-    return sInstance;
-  }
 
-  /** Register an object. */
-  public void registerMemoryTrimmable(MemoryTrimmable trimmable) {
-  }
+    /**
+     * Register an object.
+     */
+    public void registerMemoryTrimmable(MemoryTrimmable trimmable) {
+    }
 
-  /** Unregister an object. */
-  public void unregisterMemoryTrimmable(MemoryTrimmable trimmable) {
-  }
+    /**
+     * Unregister an object.
+     */
+    public void unregisterMemoryTrimmable(MemoryTrimmable trimmable) {
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPool.java b/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPool.java
index b3a3fd823..8b2436ce2 100644
--- a/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPool.java
+++ b/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPool.java
@@ -18,213 +18,223 @@
  * Generic object pool implementation for arbitrary types.  Provides an interface for performing
  * actions when allocating from / releasing to the pool, as well as a simple compaction strategy
  * based upon the last time we needed the pool to be as large as it is.
+ *
  * @param <T> type of the object to pool
  */
 public class ObjectPool<T> {
 
-  private static final Class<?> TAG = ObjectPool.class;
-
-  private final Class<T> mClazz;
-  // minimum and maximum size for the pool
-  private final int mMinSize;
-  private final int mMaxSize;
+    private static final Class<?> TAG = ObjectPool.class;
 
-  // increment size the pool size is increased by when there is not enough space
-  private final int mIncrementSize;
-  private final Allocator<T> mAllocator;
+    private final Class<T> mClazz;
+    // minimum and maximum size for the pool
+    private final int mMinSize;
+    private final int mMaxSize;
 
-  private final MonotonicClock mClock;
+    // increment size the pool size is increased by when there is not enough space
+    private final int mIncrementSize;
+    private final Allocator<T> mAllocator;
 
-  // amount of time in ms since the last 'low capacity' event before we reduce the size of the pool
-  private final long mCompactionDelayMs;
+    private final MonotonicClock mClock;
 
-  // The last time we had low supply (denoted as less than 2x the increment size in spare capacity)
-  private long mLastLowSupplyTimeMs;
+    // amount of time in ms since the last 'low capacity' event before we reduce the size of the pool
+    private final long mCompactionDelayMs;
 
-  private T[] mPool;
-  private int mSize;
+    // The last time we had low supply (denoted as less than 2x the increment size in spare capacity)
+    private long mLastLowSupplyTimeMs;
 
-  /**
-   * Generic allocator interface for the pool.  Encapsulates the per-object logic needed to
-   * instantiate, destroy, and do operations when an object is allocated from / returned to the pool
-   * The call sequence for a given object will look like:
-   * obj1 = Allocator.create()
-   * [
-   *   Allocator.onAllocate(obj1)
-   *   Allocator.onRelease(obj1)
-   * ] (zero or more times)
-   * Allocator.onDestroy(obj1) // if the object is freed from the pool
-   * @param <T>
-   */
-  public interface Allocator<T> {
+    private T[] mPool;
+    private int mSize;
 
     /**
-     * Create and return a new instance of T
-     * @return new instance of T suitable for pooling
+     * Generic allocator interface for the pool.  Encapsulates the per-object logic needed to
+     * instantiate, destroy, and do operations when an object is allocated from / returned to the pool
+     * The call sequence for a given object will look like:
+     * obj1 = Allocator.create()
+     * [
+     * Allocator.onAllocate(obj1)
+     * Allocator.onRelease(obj1)
+     * ] (zero or more times)
+     * Allocator.onDestroy(obj1) // if the object is freed from the pool
+     *
+     * @param <T>
      */
-    public T create();
+    public interface Allocator<T> {
+
+        /**
+         * Create and return a new instance of T
+         *
+         * @return new instance of T suitable for pooling
+         */
+        public T create();
+
+        /**
+         * Handler for when an instance of T is allocated from the pool
+         *
+         * @param obj instance of T that is being allocated
+         */
+        public void onAllocate(T obj);
+
+        /**
+         * Handler for when an instance of T is returned to the pool
+         *
+         * @param obj instance of T that is being returned
+         */
+        public void onRelease(T obj);
 
-    /**
-     * Handler for when an instance of T is allocated from the pool
-     * @param obj instance of T that is being allocated
-     */
-    public void onAllocate(T obj);
+    }
 
     /**
-     * Handler for when an instance of T is returned to the pool
-     * @param obj instance of T that is being returned
+     * Basic implementation of an Allocator.  Uses new to create the object instance
+     *
+     * @param <T>
      */
-    public void onRelease(T obj);
+    public static class BasicAllocator<T> implements Allocator<T> {
+
+        Class<T> mClazz;
+
+        public BasicAllocator(Class<T> clazz) {
+            mClazz = clazz;
+        }
+
+        @Override
+        public T create() {
+            try {
+                return mClazz.newInstance();
+            } catch (InstantiationException e) {
+                FLog.e(TAG, "Couldn't instantiate object", e);
+            } catch (IllegalAccessException e) {
+                FLog.e(TAG, "Couldn't instantiate object", e);
+            }
+            return null;
+        }
+
+        @Override
+        public void onAllocate(T obj) {
+        }
+
+        @Override
+        public void onRelease(T obj) {
+        }
+    }
 
-  }
+    @SuppressWarnings("unchecked")
+    public ObjectPool(Class<T> clazz, int minSize, int maxSize, int incrementSize,
+                      long compactionDelay, Allocator<T> alloc, MonotonicClock clock) {
+        mClazz = clazz;
+        mMinSize = Math.max(minSize, 0);
+        mMaxSize = Math.max(mMinSize, maxSize);
+        mIncrementSize = Math.max(incrementSize, 1);
+        mCompactionDelayMs = compactionDelay;
+        mAllocator = alloc;
+        mClock = clock;
+        mPool = (T[]) Array.newInstance(mClazz, mMinSize);
+    }
 
-  /**
-   * Basic implementation of an Allocator.  Uses new to create the object instance
-   * @param <T>
-   */
-  public static class BasicAllocator<T> implements Allocator<T> {
+    /**
+     * Return a free instance of T for use.  Tries to return an already allocated instance, or creates
+     * a new one if none exist
+     *
+     * @return an instance of T for use
+     */
+    public synchronized T allocate() {
+        T obj;
+        if (mSize > 0) {
+            --mSize;
+            obj = mPool[mSize];
+            mPool[mSize] = null;
+        } else {
+            obj = mAllocator.create();
+        }
+        mAllocator.onAllocate(obj);
+        return obj;
+    }
 
-    Class<T> mClazz;
+    /**
+     * Return a previously allocated object back to the pool
+     *
+     * @param obj object to return to the pool
+     */
+    public synchronized void release(T obj) {
+        // Check usage at the beginning of release since it represents the low point
+        checkUsage();
+
+        mAllocator.onRelease(obj);
+        if (mSize < mMaxSize) {
+            if (mSize + 1 > mPool.length) {
+                resizePool(Math.min(mMaxSize, mPool.length + mIncrementSize));
+            }
+            mPool[mSize++] = obj;
+        }
+    }
 
-    public BasicAllocator(Class<T> clazz) {
-      mClazz = clazz;
+    /**
+     * Checks whether the compaction policies set for this pool have been satisfied
+     */
+    public synchronized void checkUsage() {
+        final long now = mClock.now();
+
+        // this check prevents compaction from occurring by setting the last timestamp
+        // to right now when the size is less than 2x the increment size (default
+        // ObjectPoolBuilder.DEFAULT_INCREMENT_SIZE).
+        if (mSize < 2 * mIncrementSize) {
+            mLastLowSupplyTimeMs = now;
+        }
+
+        if (now - mLastLowSupplyTimeMs > mCompactionDelayMs) {
+            FLog.d(TAG, "ObjectPool.checkUsage is compacting the pool.");
+            compactUsage();
+        }
     }
 
-    @Override
-    public T create() {
-      try {
-        return mClazz.newInstance();
-      } catch (InstantiationException e) {
-        FLog.e(TAG, "Couldn't instantiate object", e);
-      } catch (IllegalAccessException e) {
-        FLog.e(TAG, "Couldn't instantiate object", e);
-      }
-      return null;
+    /**
+     * Forcibly compacts the pool by the set increment size, regardless of the compaction policy.
+     */
+    public synchronized void compactUsage() {
+        int newSize = Math.max(mPool.length - mIncrementSize, mMinSize);
+        if (newSize != mPool.length) {
+            resizePool(newSize);
+        }
     }
 
-    @Override
-    public void onAllocate(T obj) {
+    /**
+     * Get the number of free objects currently in the pool.
+     *
+     * @return the number of free objects
+     */
+    public int getPooledObjectCount() {
+        return mSize;
     }
 
-    @Override
-    public void onRelease(T obj) {
+    public int getMinimumSize() {
+        return mMinSize;
     }
-  }
-
-  @SuppressWarnings("unchecked")
-  public ObjectPool(Class<T> clazz, int minSize, int maxSize, int incrementSize,
-      long compactionDelay, Allocator<T> alloc, MonotonicClock clock) {
-    mClazz = clazz;
-    mMinSize = Math.max(minSize, 0);
-    mMaxSize = Math.max(mMinSize, maxSize);
-    mIncrementSize = Math.max(incrementSize, 1);
-    mCompactionDelayMs = compactionDelay;
-    mAllocator = alloc;
-    mClock = clock;
-    mPool = (T[]) Array.newInstance(mClazz, mMinSize);
-  }
-
-  /**
-   * Return a free instance of T for use.  Tries to return an already allocated instance, or creates
-   * a new one if none exist
-   * @return an instance of T for use
-   */
-  public synchronized T allocate() {
-    T obj;
-    if (mSize > 0) {
-      --mSize;
-      obj = mPool[mSize];
-      mPool[mSize] = null;
-    } else {
-      obj = mAllocator.create();
+
+    public int getMaximumSize() {
+        return mMaxSize;
     }
-    mAllocator.onAllocate(obj);
-    return obj;
-  }
-
-  /**
-   * Return a previously allocated object back to the pool
-   * @param obj object to return to the pool
-   */
-  public synchronized void release(T obj) {
-    // Check usage at the beginning of release since it represents the low point
-    checkUsage();
-
-    mAllocator.onRelease(obj);
-    if (mSize < mMaxSize) {
-      if (mSize + 1 > mPool.length) {
-        resizePool(Math.min(mMaxSize, mPool.length + mIncrementSize));
-      }
-      mPool[mSize++] = obj;
+
+    public int getIncrementSize() {
+        return mIncrementSize;
     }
-  }
-
-  /**
-   * Checks whether the compaction policies set for this pool have been satisfied
-   */
-  public synchronized void checkUsage() {
-    final long now = mClock.now();
-
-    // this check prevents compaction from occurring by setting the last timestamp
-    // to right now when the size is less than 2x the increment size (default
-    // ObjectPoolBuilder.DEFAULT_INCREMENT_SIZE).
-    if (mSize < 2*mIncrementSize) {
-      mLastLowSupplyTimeMs = now;
+
+    public long getCompactionDelayMs() {
+        return mCompactionDelayMs;
     }
 
-    if (now - mLastLowSupplyTimeMs > mCompactionDelayMs) {
-      FLog.d(TAG, "ObjectPool.checkUsage is compacting the pool.");
-      compactUsage();
+    /**
+     * Get the total size of the array backing the pool.  This will always be >= getPooledObjectCount
+     *
+     * @return the pool size
+     */
+    public int getPoolSize() {
+        return mPool.length;
     }
-  }
-
-  /**
-   * Forcibly compacts the pool by the set increment size, regardless of the compaction policy.
-   */
-  public synchronized void compactUsage() {
-    int newSize = Math.max(mPool.length - mIncrementSize, mMinSize);
-    if (newSize != mPool.length) {
-      resizePool(newSize);
+
+    @SuppressWarnings("unchecked")
+    private void resizePool(int newSize) {
+        T[] newArr = (T[]) Array.newInstance(mClazz, newSize);
+        System.arraycopy(mPool, 0, newArr, 0, Math.min(mPool.length, newSize));
+        mPool = newArr;
+        mSize = Math.min(mSize, newSize);
     }
-  }
-
-  /**
-   * Get the number of free objects currently in the pool.
-   * @return the number of free objects
-   */
-  public int getPooledObjectCount() {
-    return mSize;
-  }
-
-  public int getMinimumSize() {
-    return mMinSize;
-  }
-
-  public int getMaximumSize() {
-    return mMaxSize;
-  }
-
-  public int getIncrementSize() {
-    return mIncrementSize;
-  }
-
-  public long getCompactionDelayMs() {
-    return mCompactionDelayMs;
-  }
-
-  /**
-   * Get the total size of the array backing the pool.  This will always be >= getPooledObjectCount
-   * @return the pool size
-   */
-  public int getPoolSize() {
-    return mPool.length;
-  }
-
-  @SuppressWarnings("unchecked")
-  private void resizePool(int newSize) {
-    T[] newArr = (T[]) Array.newInstance(mClazz, newSize);
-    System.arraycopy(mPool, 0, newArr, 0, Math.min(mPool.length, newSize));
-    mPool = newArr;
-    mSize = Math.min(mSize, newSize);
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPoolBuilder.java b/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPoolBuilder.java
index bd2303641..458978e61 100644
--- a/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPoolBuilder.java
+++ b/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPoolBuilder.java
@@ -15,105 +15,106 @@
 
 /**
  * Builder interface for constructing a new pool
+ *
  * @param <T>
  */
 public class ObjectPoolBuilder<T> {
-  private Class<T> mClazz;
-  private int mMinSize = DEFAULT_MIN_SIZE;
-  private int mMaxSize = DEFAULT_MAX_SIZE;
-  private int mIncrementSize = DEFAULT_INCREMENT_SIZE;
-  private long mCompactionDelayMs = DEFAULT_COMPACTION_DELAY_MS;
-  private ObjectPool.Allocator<T> mAllocator;
-  private MonotonicClock mClock;
-  private final ObjectPoolManager mManager;
-
-  public static final int DEFAULT_MIN_SIZE = 16;
-  public static final int DEFAULT_MAX_SIZE = 1024;
-  public static final int DEFAULT_INCREMENT_SIZE = 16;
-  public static final long DEFAULT_COMPACTION_DELAY_MS = 60 * 1000;
-
-  // Generic constructor which does not attach to any specific manager
-  public ObjectPoolBuilder(Class<T> clazz, MonotonicClock clock) {
-    this(null, clazz, clock);
-  }
-
-  // Constructor which will attach the built pool to the specified pool manager
+    private Class<T> mClazz;
+    private int mMinSize = DEFAULT_MIN_SIZE;
+    private int mMaxSize = DEFAULT_MAX_SIZE;
+    private int mIncrementSize = DEFAULT_INCREMENT_SIZE;
+    private long mCompactionDelayMs = DEFAULT_COMPACTION_DELAY_MS;
+    private ObjectPool.Allocator<T> mAllocator;
+    private MonotonicClock mClock;
+    private final ObjectPoolManager mManager;
+
+    public static final int DEFAULT_MIN_SIZE = 16;
+    public static final int DEFAULT_MAX_SIZE = 1024;
+    public static final int DEFAULT_INCREMENT_SIZE = 16;
+    public static final long DEFAULT_COMPACTION_DELAY_MS = 60 * 1000;
+
+    // Generic constructor which does not attach to any specific manager
+    public ObjectPoolBuilder(Class<T> clazz, MonotonicClock clock) {
+        this(null, clazz, clock);
+    }
+
+    // Constructor which will attach the built pool to the specified pool manager
   /* package */ ObjectPoolBuilder(
-      @Nullable ObjectPoolManager manager,
-      Class<T> clazz,
-      MonotonicClock clock) {
-    mManager = manager;
-    mClazz = clazz;
-    mClock = clock;
-  }
-
-  public ObjectPoolBuilder<T> setMinimumSize(int size) {
-    mMinSize = size;
-    return this;
-  }
-
-  public int getMinimumSize() {
-    return mMinSize;
-  }
-
-  public ObjectPoolBuilder<T> setMaximumSize(int size) {
-    mMaxSize = size;
-    return this;
-  }
-
-  public int getMaximumSize() {
-    return mMaxSize;
-  }
-
-  public ObjectPoolBuilder<T> setIncrementSize(int size) {
-    mIncrementSize = size;
-    return this;
-  }
-
-  public int getIncrementSize() {
-    return mIncrementSize;
-  }
-
-  public ObjectPoolBuilder<T> setCompactionDelay(long delayMs) {
-    mCompactionDelayMs = delayMs;
-    return this;
-  }
-
-  public long getCompactionDelay() {
-    return mCompactionDelayMs;
-  }
-
-  public ObjectPoolBuilder<T> setAllocator(ObjectPool.Allocator<T> alloc) {
-    mAllocator = alloc;
-    return this;
-  }
-
-  public ObjectPool.Allocator<T> getAllocator() {
-    return mAllocator;
-  }
-
-  public ObjectPoolBuilder<T> setClock(MonotonicClock clock) {
-    mClock = clock;
-    return this;
-  }
-
-  public MonotonicClock getClock() {
-    return mClock;
-  }
-
-  public ObjectPool<T> build() {
-    if (mClock == null) {
-      throw new IllegalArgumentException("Must add a clock to the object pool builder");
+            @Nullable ObjectPoolManager manager,
+            Class<T> clazz,
+            MonotonicClock clock) {
+        mManager = manager;
+        mClazz = clazz;
+        mClock = clock;
+    }
+
+    public ObjectPoolBuilder<T> setMinimumSize(int size) {
+        mMinSize = size;
+        return this;
+    }
+
+    public int getMinimumSize() {
+        return mMinSize;
     }
-    ObjectPool.Allocator<T> alloc = mAllocator;
-    if (alloc == null) {
-      alloc = new ObjectPool.BasicAllocator<T>(mClazz);
+
+    public ObjectPoolBuilder<T> setMaximumSize(int size) {
+        mMaxSize = size;
+        return this;
+    }
+
+    public int getMaximumSize() {
+        return mMaxSize;
+    }
+
+    public ObjectPoolBuilder<T> setIncrementSize(int size) {
+        mIncrementSize = size;
+        return this;
+    }
+
+    public int getIncrementSize() {
+        return mIncrementSize;
     }
-    ObjectPool<T> pool = new ObjectPool<T>(mClazz, mMinSize, mMaxSize, mIncrementSize,
-        mCompactionDelayMs, alloc, mClock);
-    if (mManager != null) {
-      mManager.addPool(mClazz, pool);
+
+    public ObjectPoolBuilder<T> setCompactionDelay(long delayMs) {
+        mCompactionDelayMs = delayMs;
+        return this;
+    }
+
+    public long getCompactionDelay() {
+        return mCompactionDelayMs;
+    }
+
+    public ObjectPoolBuilder<T> setAllocator(ObjectPool.Allocator<T> alloc) {
+        mAllocator = alloc;
+        return this;
+    }
+
+    public ObjectPool.Allocator<T> getAllocator() {
+        return mAllocator;
+    }
+
+    public ObjectPoolBuilder<T> setClock(MonotonicClock clock) {
+        mClock = clock;
+        return this;
+    }
+
+    public MonotonicClock getClock() {
+        return mClock;
+    }
+
+    public ObjectPool<T> build() {
+        if (mClock == null) {
+            throw new IllegalArgumentException("Must add a clock to the object pool builder");
+        }
+        ObjectPool.Allocator<T> alloc = mAllocator;
+        if (alloc == null) {
+            alloc = new ObjectPool.BasicAllocator<T>(mClazz);
+        }
+        ObjectPool<T> pool = new ObjectPool<T>(mClazz, mMinSize, mMaxSize, mIncrementSize,
+                mCompactionDelayMs, alloc, mClock);
+        if (mManager != null) {
+            mManager.addPool(mClazz, pool);
+        }
+        return pool;
     }
-    return pool;
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPoolManager.java b/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPoolManager.java
index aac4633da..6d79a3d7a 100644
--- a/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPoolManager.java
+++ b/fbcore/src/main/java/com/facebook/common/objectpool/ObjectPoolManager.java
@@ -18,65 +18,69 @@
  */
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class ObjectPoolManager {
-  private final HashMap<Class, ObjectPool> mObjectPools;
-  private final MonotonicClock mClock;
+    private final HashMap<Class, ObjectPool> mObjectPools;
+    private final MonotonicClock mClock;
 
-  public ObjectPoolManager(MonotonicClock clock) {
-    mObjectPools = new HashMap<Class, ObjectPool>();
-    mClock = clock;
-  }
+    public ObjectPoolManager(MonotonicClock clock) {
+        mObjectPools = new HashMap<Class, ObjectPool>();
+        mClock = clock;
+    }
 
-  /**
-   * Create a new pool builder.  Note that the pool is not actually constructed until
-   * ObjectPoolBuilder.build() is called
-   * @param clazz the class object for the type which is going to be stored in the pool
-   * @param <T> type of object to pool
-   * @return a builder object to configure and build the pool
-   */
-  public <T> ObjectPoolBuilder<T> createPoolBuilder(Class<T> clazz) {
-    return new ObjectPoolBuilder<T>(this, clazz, mClock);
-  }
+    /**
+     * Create a new pool builder.  Note that the pool is not actually constructed until
+     * ObjectPoolBuilder.build() is called
+     *
+     * @param clazz the class object for the type which is going to be stored in the pool
+     * @param <T>   type of object to pool
+     * @return a builder object to configure and build the pool
+     */
+    public <T> ObjectPoolBuilder<T> createPoolBuilder(Class<T> clazz) {
+        return new ObjectPoolBuilder<T>(this, clazz, mClock);
+    }
 
-  /* package */ <T> void addPool(Class<T> clazz, ObjectPool<T> pool) {
-    mObjectPools.put(clazz, pool);
-  }
+    /* package */ <T> void addPool(Class<T> clazz, ObjectPool<T> pool) {
+        mObjectPools.put(clazz, pool);
+    }
 
-  /**
-   * Retrieve the ObjectPool created for the specified class type
-   * @param clazz the class object for the type which is pooled
-   * @param <T> type of object which is pooled
-   * @return an object pool for the given type
-   */
-  public <T> ObjectPool<T> getPool(Class<T> clazz) {
-    return (ObjectPool<T>) mObjectPools.get(clazz);
-  }
+    /**
+     * Retrieve the ObjectPool created for the specified class type
+     *
+     * @param clazz the class object for the type which is pooled
+     * @param <T>   type of object which is pooled
+     * @return an object pool for the given type
+     */
+    public <T> ObjectPool<T> getPool(Class<T> clazz) {
+        return (ObjectPool<T>) mObjectPools.get(clazz);
+    }
 
-  /**
-   * Convenience method which retrieves the pool and requests an allocation from the pool, returning
-   * the allocated object
-   * @param clazz the class object for the type which is pooled
-   * @param <T> type of object which is pooled
-   * @return an instance of the type from the pooler, if it exists
-   */
-  public <T> T allocate(Class<T> clazz) {
-    ObjectPool<T> pool = getPool(clazz);
-    if (pool != null) {
-      return pool.allocate();
-    } else {
-      return null;
+    /**
+     * Convenience method which retrieves the pool and requests an allocation from the pool, returning
+     * the allocated object
+     *
+     * @param clazz the class object for the type which is pooled
+     * @param <T>   type of object which is pooled
+     * @return an instance of the type from the pooler, if it exists
+     */
+    public <T> T allocate(Class<T> clazz) {
+        ObjectPool<T> pool = getPool(clazz);
+        if (pool != null) {
+            return pool.allocate();
+        } else {
+            return null;
+        }
     }
-  }
 
-  /**
-   * Convenience method to release an object back to the corresponding pool
-   * @param clazz the class object for the type which is pooled
-   * @param obj an instance of the type to return to the pooler
-   * @param <T> type of the object which is pooled
-   */
-  public <T> void release(Class<T> clazz, T obj) {
-    ObjectPool<T> pool = getPool(clazz);
-    if (pool != null) {
-      pool.release(obj);
+    /**
+     * Convenience method to release an object back to the corresponding pool
+     *
+     * @param clazz the class object for the type which is pooled
+     * @param obj   an instance of the type to return to the pooler
+     * @param <T>   type of the object which is pooled
+     */
+    public <T> void release(Class<T> clazz, T obj) {
+        ObjectPool<T> pool = getPool(clazz);
+        if (pool != null) {
+            pool.release(obj);
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/references/CloseableReference.java b/fbcore/src/main/java/com/facebook/common/references/CloseableReference.java
index fd206623d..75bdcee69 100644
--- a/fbcore/src/main/java/com/facebook/common/references/CloseableReference.java
+++ b/fbcore/src/main/java/com/facebook/common/references/CloseableReference.java
@@ -26,13 +26,13 @@
 
 /**
  * A smart pointer-like class for Java.
- *
+ * <p>
  * <p>This class allows reference-counting semantics in a Java-friendlier way. A single object
  * can have any number of CloseableReferences pointing to it. When all of these have been closed,
  * the object either has its {@link Closeable#close} method called, if it implements
  * {@link Closeable}, or its designated {@link ResourceReleaser#release},
  * if it does not.
- *
+ * <p>
  * <p>Callers can construct a CloseableReference wrapping a {@link Closeable} with:
  * <pre>
  * Closeable foo;
@@ -57,7 +57,7 @@
  * copy.close();
  * c.close();
  * </pre>
- *
+ * <p>
  * <p>As with any Closeable, try-finally semantics may be needed to ensure that close is called.
  * <p>Do not rely upon the finalizer; the purpose of this class is for expensive resources to
  * be released without waiting for the garbage collector. The finalizer will log an error if
@@ -65,217 +65,223 @@
  */
 public final class CloseableReference<T> implements Cloneable, Closeable {
 
-  private static Class<CloseableReference> TAG = CloseableReference.class;
-
-  private static final ResourceReleaser<Closeable> DEFAULT_CLOSEABLE_RELEASER =
-      new ResourceReleaser<Closeable>() {
-        @Override
-        public void release(Closeable value) {
-          try {
-            Closeables.close(value, true);
-          } catch (IOException ioe) {
-            // This will not happen, Closeable.close swallows and logs IOExceptions
-          }
-        }
-      };
+    private static Class<CloseableReference> TAG = CloseableReference.class;
 
+    private static final ResourceReleaser<Closeable> DEFAULT_CLOSEABLE_RELEASER =
+            new ResourceReleaser<Closeable>() {
+                @Override
+                public void release(Closeable value) {
+                    try {
+                        Closeables.close(value, true);
+                    } catch (IOException ioe) {
+                        // This will not happen, Closeable.close swallows and logs IOExceptions
+                    }
+                }
+            };
 
-  @GuardedBy("this")
-  private boolean mIsClosed = false;
 
-  private final SharedReference<T> mSharedReference;
+    @GuardedBy("this")
+    private boolean mIsClosed = false;
 
-  /**
-   * The caller should guarantee that reference count of sharedReference is not decreased to zero,
-   * so that the reference is valid during execution of this method.
-   */
-  private CloseableReference(SharedReference<T> sharedReference) {
-    mSharedReference = Preconditions.checkNotNull(sharedReference);
-    sharedReference.addReference();
-  }
+    private final SharedReference<T> mSharedReference;
 
-  private CloseableReference(T t, ResourceReleaser<T> resourceReleaser) {
-    // Ref-count pre-set to 1
-    mSharedReference = new SharedReference<T>(t, resourceReleaser);
-  }
+    /**
+     * The caller should guarantee that reference count of sharedReference is not decreased to zero,
+     * so that the reference is valid during execution of this method.
+     */
+    private CloseableReference(SharedReference<T> sharedReference) {
+        mSharedReference = Preconditions.checkNotNull(sharedReference);
+        sharedReference.addReference();
+    }
 
-  /**
-   * Constructs a CloseableReference.
-   *
-   * <p>Returns null if the parameter is null.
-   */
-  public static @Nullable <T extends Closeable> CloseableReference<T> of(@Nullable T t) {
-    if (t == null) {
-      return null;
-    } else {
-      return new CloseableReference<T>(t, (ResourceReleaser<T>) DEFAULT_CLOSEABLE_RELEASER);
+    private CloseableReference(T t, ResourceReleaser<T> resourceReleaser) {
+        // Ref-count pre-set to 1
+        mSharedReference = new SharedReference<T>(t, resourceReleaser);
     }
-  }
 
-  /**
-   * Constructs a CloseableReference (wrapping a SharedReference) of T with provided
-   * ResourceReleaser<T>. If t is null, this will just return null.
-   */
-  public static @Nullable <T> CloseableReference<T> of(
-      @Nullable T t,
-      ResourceReleaser<T> resourceReleaser) {
-    if (t == null) {
-      return null;
-    } else {
-      return new CloseableReference<T>(t, resourceReleaser);
+    /**
+     * Constructs a CloseableReference.
+     * <p>
+     * <p>Returns null if the parameter is null.
+     */
+    public static
+    @Nullable
+    <T extends Closeable> CloseableReference<T> of(@Nullable T t) {
+        if (t == null) {
+            return null;
+        } else {
+            return new CloseableReference<T>(t, (ResourceReleaser<T>) DEFAULT_CLOSEABLE_RELEASER);
+        }
     }
-  }
 
-  /**
-   * Closes this CloseableReference.
-   *
-   * <p>Decrements the reference count of the underlying object. If it is zero, the object
-   * will be released.
-   *
-   * <p>This method is idempotent. Calling it multiple times on the same instance has no effect.
-   */
-  @Override
-  public void close() {
-    synchronized (this) {
-      if (mIsClosed) {
-        return;
-      }
-      mIsClosed = true;
+    /**
+     * Constructs a CloseableReference (wrapping a SharedReference) of T with provided
+     * ResourceReleaser<T>. If t is null, this will just return null.
+     */
+    public static
+    @Nullable
+    <T> CloseableReference<T> of(
+            @Nullable T t,
+            ResourceReleaser<T> resourceReleaser) {
+        if (t == null) {
+            return null;
+        } else {
+            return new CloseableReference<T>(t, resourceReleaser);
+        }
     }
 
-    mSharedReference.deleteReference();
-  }
+    /**
+     * Closes this CloseableReference.
+     * <p>
+     * <p>Decrements the reference count of the underlying object. If it is zero, the object
+     * will be released.
+     * <p>
+     * <p>This method is idempotent. Calling it multiple times on the same instance has no effect.
+     */
+    @Override
+    public void close() {
+        synchronized (this) {
+            if (mIsClosed) {
+                return;
+            }
+            mIsClosed = true;
+        }
 
-  /**
-   * Returns the underlying Closeable if this reference is not closed yet.
-   * Otherwise IllegalStateException is thrown.
-   */
-  public synchronized T get() {
-    Preconditions.checkState(!mIsClosed);
-    return mSharedReference.get();
-  }
+        mSharedReference.deleteReference();
+    }
 
-  /**
-   * Returns a new CloseableReference to the same underlying SharedReference. The SharedReference
-   * ref-count is incremented.
-   */
-  @Override
-  public synchronized CloseableReference<T> clone() {
-    Preconditions.checkState(isValid());
-    return new CloseableReference<T>(mSharedReference);
-  }
+    /**
+     * Returns the underlying Closeable if this reference is not closed yet.
+     * Otherwise IllegalStateException is thrown.
+     */
+    public synchronized T get() {
+        Preconditions.checkState(!mIsClosed);
+        return mSharedReference.get();
+    }
 
-  public synchronized CloseableReference<T> cloneOrNull() {
-    return isValid() ? new CloseableReference<T>(mSharedReference) : null;
-  }
+    /**
+     * Returns a new CloseableReference to the same underlying SharedReference. The SharedReference
+     * ref-count is incremented.
+     */
+    @Override
+    public synchronized CloseableReference<T> clone() {
+        Preconditions.checkState(isValid());
+        return new CloseableReference<T>(mSharedReference);
+    }
 
-  /**
-   * Checks if this closable-reference is valid i.e. is not closed.
-   * @return true if the closeable reference is valid
-   */
-  public synchronized boolean isValid() {
-    return !mIsClosed;
-  }
+    public synchronized CloseableReference<T> cloneOrNull() {
+        return isValid() ? new CloseableReference<T>(mSharedReference) : null;
+    }
 
-  @Override
-  protected void finalize() throws Throwable {
-    try {
-      // We put synchronized here so that lint doesn't warn about accessing mIsClosed, which is
-      // guarded by this. Lint isn't aware of finalize semantics.
-      synchronized (this) {
-        if (mIsClosed) {
-          return;
-        }
-      }
+    /**
+     * Checks if this closable-reference is valid i.e. is not closed.
+     *
+     * @return true if the closeable reference is valid
+     */
+    public synchronized boolean isValid() {
+        return !mIsClosed;
+    }
 
-      FLog.w(TAG, "Finalized without closing: %x %x (type = %s)",
-          System.identityHashCode(this),
-          System.identityHashCode(mSharedReference),
-          mSharedReference.get().getClass().getSimpleName());
+    @Override
+    protected void finalize() throws Throwable {
+        try {
+            // We put synchronized here so that lint doesn't warn about accessing mIsClosed, which is
+            // guarded by this. Lint isn't aware of finalize semantics.
+            synchronized (this) {
+                if (mIsClosed) {
+                    return;
+                }
+            }
 
-      close();
-    } finally {
-      super.finalize();
-    }
-  }
+            FLog.w(TAG, "Finalized without closing: %x %x (type = %s)",
+                    System.identityHashCode(this),
+                    System.identityHashCode(mSharedReference),
+                    mSharedReference.get().getClass().getSimpleName());
 
-  /**
-   * A test-only method to get the underlying references.
-   *
-   * <p><b>DO NOT USE in application code.</b>
-   */
-  @VisibleForTesting
-  public synchronized SharedReference<T> getUnderlyingReferenceTestOnly() {
-    return mSharedReference;
-  }
+            close();
+        } finally {
+            super.finalize();
+        }
+    }
 
-  /**
-   * Method used for tracking Closeables pointed by CloseableReference.
-   * Use only for debugging and logging.
-   */
-  public synchronized int getValueHash() {
-    return isValid() ? System.identityHashCode(mSharedReference.get()) : 0;
-  }
+    /**
+     * A test-only method to get the underlying references.
+     * <p>
+     * <p><b>DO NOT USE in application code.</b>
+     */
+    @VisibleForTesting
+    public synchronized SharedReference<T> getUnderlyingReferenceTestOnly() {
+        return mSharedReference;
+    }
 
-  /**
-   * Checks if the closable-reference is valid i.e. is not null, and is not closed.
-   * @return true if the closeable reference is valid
-   */
-  public static boolean isValid(@Nullable CloseableReference<?> ref) {
-    return ref != null && ref.isValid();
-  }
+    /**
+     * Method used for tracking Closeables pointed by CloseableReference.
+     * Use only for debugging and logging.
+     */
+    public synchronized int getValueHash() {
+        return isValid() ? System.identityHashCode(mSharedReference.get()) : 0;
+    }
 
-  /**
-   * Returns the cloned reference if valid, null otherwise.
-   *
-   * @param ref the reference to clone
-   */
-  @Nullable
-  public static <T> CloseableReference<T> cloneOrNull(@Nullable CloseableReference<T> ref) {
-    return (ref != null) ? ref.cloneOrNull() : null;
-  }
+    /**
+     * Checks if the closable-reference is valid i.e. is not null, and is not closed.
+     *
+     * @return true if the closeable reference is valid
+     */
+    public static boolean isValid(@Nullable CloseableReference<?> ref) {
+        return ref != null && ref.isValid();
+    }
 
-  /**
-   * Clones a collection of references and returns a list. Returns null if the list is null. If
-   * the list is non-null, clones each reference. If a reference cannot be cloned due to already
-   * being closed, the list will contain a null value in its place.
-   *
-   * @param refs the references to clone
-   * @return the list of cloned references or null
-   */
-  public static <T> List<CloseableReference<T>> cloneOrNull(
-      Collection<CloseableReference<T>> refs) {
-    if (refs == null) {
-      return null;
+    /**
+     * Returns the cloned reference if valid, null otherwise.
+     *
+     * @param ref the reference to clone
+     */
+    @Nullable
+    public static <T> CloseableReference<T> cloneOrNull(@Nullable CloseableReference<T> ref) {
+        return (ref != null) ? ref.cloneOrNull() : null;
     }
-    List<CloseableReference<T>> ret = new ArrayList<>(refs.size());
-    for (CloseableReference<T> ref : refs) {
-      ret.add(CloseableReference.cloneOrNull(ref));
+
+    /**
+     * Clones a collection of references and returns a list. Returns null if the list is null. If
+     * the list is non-null, clones each reference. If a reference cannot be cloned due to already
+     * being closed, the list will contain a null value in its place.
+     *
+     * @param refs the references to clone
+     * @return the list of cloned references or null
+     */
+    public static <T> List<CloseableReference<T>> cloneOrNull(
+            Collection<CloseableReference<T>> refs) {
+        if (refs == null) {
+            return null;
+        }
+        List<CloseableReference<T>> ret = new ArrayList<>(refs.size());
+        for (CloseableReference<T> ref : refs) {
+            ret.add(CloseableReference.cloneOrNull(ref));
+        }
+        return ret;
     }
-    return ret;
-  }
 
-  /**
-   * Closes the reference handling null.
-   *
-   * @param ref the reference to close
-   */
-  public static void closeSafely(@Nullable CloseableReference<?> ref) {
-    if (ref != null) {
-      ref.close();
+    /**
+     * Closes the reference handling null.
+     *
+     * @param ref the reference to close
+     */
+    public static void closeSafely(@Nullable CloseableReference<?> ref) {
+        if (ref != null) {
+            ref.close();
+        }
     }
-  }
 
-  /**
-   * Closes the references in the iterable handling null.
-   *
-   * @param references the reference to close
-   */
-  public static void closeSafely(@Nullable Iterable<? extends CloseableReference<?>> references) {
-    if (references != null) {
-      for (CloseableReference<?> ref : references) {
-        closeSafely(ref);
-      }
+    /**
+     * Closes the references in the iterable handling null.
+     *
+     * @param references the reference to close
+     */
+    public static void closeSafely(@Nullable Iterable<? extends CloseableReference<?>> references) {
+        if (references != null) {
+            for (CloseableReference<?> ref : references) {
+                closeSafely(ref);
+            }
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/references/OOMSoftReference.java b/fbcore/src/main/java/com/facebook/common/references/OOMSoftReference.java
index 94ded3aec..bcaadadba 100644
--- a/fbcore/src/main/java/com/facebook/common/references/OOMSoftReference.java
+++ b/fbcore/src/main/java/com/facebook/common/references/OOMSoftReference.java
@@ -18,17 +18,17 @@
  * To eliminate the possibility of some of our objects causing an OutOfMemoryError when they are
  * not used, we reference them via SoftReferences.
  * What is a SoftReference?
- *    <a href="http://developer.android.com/reference/java/lang/ref/SoftReference.html"></a>
- *    <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/ref/SoftReference.html"></a>
+ * <a href="http://developer.android.com/reference/java/lang/ref/SoftReference.html"></a>
+ * <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/ref/SoftReference.html"></a>
  * A Soft Reference is a reference that is cleared when its referent is not strongly reachable and
  * there is memory pressure. SoftReferences as implemented by Dalvik blindly treat every second
  * SoftReference as a WeakReference every time a garbage collection happens, - i.e. clear it unless
  * there is something else referring to it:
- *  <a href="https://fburl.com/dalviksoftref">dalvik</a>
- *  <a href="https://fburl.com/artsoftref">art</a>
+ * <a href="https://fburl.com/dalviksoftref">dalvik</a>
+ * <a href="https://fburl.com/artsoftref">art</a>
  * It will however clear every SoftReference if we don't have enough memory to satisfy an
  * allocation after a garbage collection.
- *
+ * <p>
  * This means that as long as one of the soft references stays alive, they all stay alive. If we
  * have two SoftReferences next to each other on the heap, both pointing to the same object, then
  * we are guaranteed that neither will be cleared until we otherwise would have thrown an
@@ -38,39 +38,39 @@
  */
 public class OOMSoftReference<T> {
 
-  SoftReference<T> softRef1;
-  SoftReference<T> softRef2;
-  SoftReference<T> softRef3;
-
-  public OOMSoftReference() {
-    softRef1 = null;
-    softRef2 = null;
-    softRef3 = null;
-  }
-
-  public void set(@Nonnull T hardReference) {
-    softRef1 = new SoftReference<T>(hardReference);
-    softRef2 = new SoftReference<T>(hardReference);
-    softRef3 = new SoftReference<T>(hardReference);
-  }
+    SoftReference<T> softRef1;
+    SoftReference<T> softRef2;
+    SoftReference<T> softRef3;
 
-  @Nullable
-  public T get() {
-    return (softRef1 == null ? null : softRef1.get());
-  }
+    public OOMSoftReference() {
+        softRef1 = null;
+        softRef2 = null;
+        softRef3 = null;
+    }
 
-  public void clear() {
-    if (softRef1 != null) {
-      softRef1.clear();
-      softRef1 = null;
+    public void set(@Nonnull T hardReference) {
+        softRef1 = new SoftReference<T>(hardReference);
+        softRef2 = new SoftReference<T>(hardReference);
+        softRef3 = new SoftReference<T>(hardReference);
     }
-    if (softRef2 != null) {
-      softRef2.clear();
-      softRef2 = null;
+
+    @Nullable
+    public T get() {
+        return (softRef1 == null ? null : softRef1.get());
     }
-    if (softRef3 != null) {
-      softRef3.clear();
-      softRef3 = null;
+
+    public void clear() {
+        if (softRef1 != null) {
+            softRef1.clear();
+            softRef1 = null;
+        }
+        if (softRef2 != null) {
+            softRef2.clear();
+            softRef2 = null;
+        }
+        if (softRef3 != null) {
+            softRef3.clear();
+            softRef3 = null;
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/references/ResourceReleaser.java b/fbcore/src/main/java/com/facebook/common/references/ResourceReleaser.java
index 30db6c5ac..be41c91e9 100644
--- a/fbcore/src/main/java/com/facebook/common/references/ResourceReleaser.java
+++ b/fbcore/src/main/java/com/facebook/common/references/ResourceReleaser.java
@@ -10,23 +10,25 @@
 
 /**
  * Interface that abstracts the action of releasing a resource.
- *
+ * <p>
  * <p>There are multiple components that own resources that are shared by others, like pools and
  * caches. This interface should be implemented by classes that want to perform some action
  * when a particular resource is no longer needed.
+ *
  * @param <T> type of resource managed by this ResourceReleaser
  */
 public interface ResourceReleaser<T> {
 
-  /**
-   * <p>Release the given value.
-   *
-   * <p>After calling this method, the caller is no longer responsible for
-   * managing lifetime of the value.
-   * <p>This method is not permitted to throw an exception and is always required to succeed.
-   * It is often called from contexts like catch blocks or finally blocks to cleanup resources.
-   * Throwing an exception could result in swallowing the original exception.</p>
-   * @param value
-   */
-  void release(T value);
+    /**
+     * <p>Release the given value.
+     * <p>
+     * <p>After calling this method, the caller is no longer responsible for
+     * managing lifetime of the value.
+     * <p>This method is not permitted to throw an exception and is always required to succeed.
+     * It is often called from contexts like catch blocks or finally blocks to cleanup resources.
+     * Throwing an exception could result in swallowing the original exception.</p>
+     *
+     * @param value
+     */
+    void release(T value);
 }
diff --git a/fbcore/src/main/java/com/facebook/common/references/SharedReference.java b/fbcore/src/main/java/com/facebook/common/references/SharedReference.java
index 56626b5c8..6c65399ba 100644
--- a/fbcore/src/main/java/com/facebook/common/references/SharedReference.java
+++ b/fbcore/src/main/java/com/facebook/common/references/SharedReference.java
@@ -32,224 +32,229 @@
  * <p>
  * The somewhat clunky rules are
  * 1. If a function returns a SharedReference, it must guarantee that the reference count
- *    is at least 1. In the case where a SharedReference is being constructed and returned,
- *    the SharedReference constructor will already set the ref count to 1.
+ * is at least 1. In the case where a SharedReference is being constructed and returned,
+ * the SharedReference constructor will already set the ref count to 1.
  * 2. If a function calls another function with a shared-reference parameter,
- *    2.1 The caller must ensure that the reference is valid for the duration of the
- *        invocation.
- *    2.2 The callee *is not* responsible for the cleanup of the reference.
- *    2.3 If the callee wants to keep the reference around even after the call returns (for
- *        example, stashing it away in a map), then it should "clone" the reference by invoking
- *        {@link #addReference()}
+ * 2.1 The caller must ensure that the reference is valid for the duration of the
+ * invocation.
+ * 2.2 The callee *is not* responsible for the cleanup of the reference.
+ * 2.3 If the callee wants to keep the reference around even after the call returns (for
+ * example, stashing it away in a map), then it should "clone" the reference by invoking
+ * {@link #addReference()}
  * <p>
- *   Example #1 (function with a shared reference parameter):
- *   void foo(SharedReference r, ...) {
- *     // first assert that the reference is valid
- *     Preconditions.checkArgument(SharedReference.isValid(r));
- *     ...
- *     // do something with the contents of r
- *     ...
- *     // do not increment/decrement the ref count
- *   }
+ * Example #1 (function with a shared reference parameter):
+ * void foo(SharedReference r, ...) {
+ * // first assert that the reference is valid
+ * Preconditions.checkArgument(SharedReference.isValid(r));
+ * ...
+ * // do something with the contents of r
+ * ...
+ * // do not increment/decrement the ref count
+ * }
  * <p>
- *   Example #2 (function with a shared reference parameter that keeps around the shared ref)
- *     void foo(SharedReference r, ...) {
- *       // first assert that the reference is valid
- *       Preconditions.checkArgument(SharedReference.isValid(r));
- *       ...
- *       // increment ref count
- *       r.addReference();
- *       // stash away the reference
- *       ...
- *       return;
- *     }
+ * Example #2 (function with a shared reference parameter that keeps around the shared ref)
+ * void foo(SharedReference r, ...) {
+ * // first assert that the reference is valid
+ * Preconditions.checkArgument(SharedReference.isValid(r));
+ * ...
+ * // increment ref count
+ * r.addReference();
+ * // stash away the reference
+ * ...
+ * return;
+ * }
  * <p>
- *   Example #3 (function with a shared reference parameter that passes along the reference to
- *   another function)
- *     void foo(SharedReference r, ...) {
- *       // first assert that the reference is valid
- *       Preconditions.checkArgument(SharedReference.isValid(r));
- *       ...
- *       bar(r, ...); // call to other function
- *       ...
- *     }
+ * Example #3 (function with a shared reference parameter that passes along the reference to
+ * another function)
+ * void foo(SharedReference r, ...) {
+ * // first assert that the reference is valid
+ * Preconditions.checkArgument(SharedReference.isValid(r));
+ * ...
+ * bar(r, ...); // call to other function
+ * ...
+ * }
  * <p>
- *   Example #4 (function that returns a shared reference)
- *     SharedReference foo(...) {
- *       // do something
- *       ...
- *       // create a new shared reference (refcount automatically at 1)
- *       SharedReference r = new SharedReference(x);
- *       // return this shared reference
- *       return r;
- *     }
+ * Example #4 (function that returns a shared reference)
+ * SharedReference foo(...) {
+ * // do something
+ * ...
+ * // create a new shared reference (refcount automatically at 1)
+ * SharedReference r = new SharedReference(x);
+ * // return this shared reference
+ * return r;
+ * }
  * <p>
- *   Example #5 (function with a shared reference parameter that returns the shared reference)
- *     void foo(SharedReference r, ...) {
- *       // first assert that the reference is valid
- *       Preconditions.checkArgument(SharedReference.isValid(r));
- *       ...
- *       // increment ref count before returning
- *       r.addReference();
- *       return r;
- *     }
+ * Example #5 (function with a shared reference parameter that returns the shared reference)
+ * void foo(SharedReference r, ...) {
+ * // first assert that the reference is valid
+ * Preconditions.checkArgument(SharedReference.isValid(r));
+ * ...
+ * // increment ref count before returning
+ * r.addReference();
+ * return r;
+ * }
  */
 @VisibleForTesting
 public class SharedReference<T> {
 
-  // Keeps references to all live objects so finalization of those Objects always happens after
-  // SharedReference first disposes of it. Note, this does not prevent CloseableReference's from
-  // being finalized when the reference is no longer reachable.
-  @GuardedBy("itself")
-  private static final Map<Object, Integer> sLiveObjects = Maps.newIdentityHashMap();
-
-  @GuardedBy("this")
-  private T mValue;
-  @GuardedBy("this")
-  private int mRefCount;
-
-  private final ResourceReleaser<T> mResourceReleaser;
-
-  /**
-   * Construct a new shared-reference that will 'own' the supplied {@code value}.
-   * The reference count will be set to 1. When the reference count decreases to zero
-   * {@code resourceReleaser} will be used to release the {@code value}
-   * @param value non-null value to manage
-   * @param resourceReleaser non-null ResourceReleaser for the value
-   */
-  public SharedReference(T value, ResourceReleaser<T> resourceReleaser) {
-    mValue = Preconditions.checkNotNull(value);
-    mResourceReleaser = Preconditions.checkNotNull(resourceReleaser);
-    mRefCount = 1;
-    addLiveReference(value);
-  }
-
-  /**
-   * Increases the reference count of a live object in the static map. Adds it if it's not
-   * being held.
-   *
-   * @param value the value to add.
-   */
-  private static void addLiveReference(Object value) {
-    synchronized (sLiveObjects) {
-      Integer count = sLiveObjects.get(value);
-      if (count == null) {
-        sLiveObjects.put(value, 1);
-      } else {
-        sLiveObjects.put(value, count + 1);
-      }
+    // Keeps references to all live objects so finalization of those Objects always happens after
+    // SharedReference first disposes of it. Note, this does not prevent CloseableReference's from
+    // being finalized when the reference is no longer reachable.
+    @GuardedBy("itself")
+    private static final Map<Object, Integer> sLiveObjects = Maps.newIdentityHashMap();
+
+    @GuardedBy("this")
+    private T mValue;
+    @GuardedBy("this")
+    private int mRefCount;
+
+    private final ResourceReleaser<T> mResourceReleaser;
+
+    /**
+     * Construct a new shared-reference that will 'own' the supplied {@code value}.
+     * The reference count will be set to 1. When the reference count decreases to zero
+     * {@code resourceReleaser} will be used to release the {@code value}
+     *
+     * @param value            non-null value to manage
+     * @param resourceReleaser non-null ResourceReleaser for the value
+     */
+    public SharedReference(T value, ResourceReleaser<T> resourceReleaser) {
+        mValue = Preconditions.checkNotNull(value);
+        mResourceReleaser = Preconditions.checkNotNull(resourceReleaser);
+        mRefCount = 1;
+        addLiveReference(value);
+    }
+
+    /**
+     * Increases the reference count of a live object in the static map. Adds it if it's not
+     * being held.
+     *
+     * @param value the value to add.
+     */
+    private static void addLiveReference(Object value) {
+        synchronized (sLiveObjects) {
+            Integer count = sLiveObjects.get(value);
+            if (count == null) {
+                sLiveObjects.put(value, 1);
+            } else {
+                sLiveObjects.put(value, count + 1);
+            }
+        }
+    }
+
+    /**
+     * Decreases the reference count of live object from the static map. Removes it if it's reference
+     * count has become 0.
+     *
+     * @param value the value to remove.
+     */
+    private static void removeLiveReference(Object value) {
+        synchronized (sLiveObjects) {
+            Integer count = sLiveObjects.get(value);
+            if (count == null) {
+                // Uh oh.
+                FLog.wtf(
+                        "SharedReference",
+                        "No entry in sLiveObjects for value of type %s",
+                        value.getClass());
+            } else if (count == 1) {
+                sLiveObjects.remove(value);
+            } else {
+                sLiveObjects.put(value, count - 1);
+            }
+        }
+    }
+
+    /**
+     * Get the current referenced value. Null if there's no value.
+     *
+     * @return the referenced value
+     */
+    public synchronized T get() {
+        return mValue;
+    }
+
+    /**
+     * Checks if this shared-reference is valid i.e. its reference count is greater than zero.
+     *
+     * @return true if shared reference is valid
+     */
+    public synchronized boolean isValid() {
+        return mRefCount > 0;
     }
-  }
-
-  /**
-   * Decreases the reference count of live object from the static map. Removes it if it's reference
-   * count has become 0.
-   *
-   * @param value the value to remove.
-   */
-  private static void removeLiveReference(Object value) {
-    synchronized (sLiveObjects) {
-      Integer count = sLiveObjects.get(value);
-      if (count == null) {
-        // Uh oh.
-        FLog.wtf(
-            "SharedReference",
-            "No entry in sLiveObjects for value of type %s",
-            value.getClass());
-      } else if (count == 1) {
-        sLiveObjects.remove(value);
-      } else {
-        sLiveObjects.put(value, count - 1);
-      }
+
+    /**
+     * Checks if the shared-reference is valid i.e. its reference count is greater than zero
+     *
+     * @return true if the shared reference is valid
+     */
+    public static boolean isValid(SharedReference<?> ref) {
+        return ref != null && ref.isValid();
+    }
+
+    /**
+     * Bump up the reference count for the shared reference
+     * Note: The reference must be valid (aka not null) at this point
+     */
+    public synchronized void addReference() {
+        ensureValid();
+        mRefCount++;
     }
-  }
-
-  /**
-   * Get the current referenced value. Null if there's no value.
-   * @return the referenced value
-   */
-  public synchronized T get() {
-    return mValue;
-  }
-
-  /**
-   * Checks if this shared-reference is valid i.e. its reference count is greater than zero.
-   * @return true if shared reference is valid
-   */
-  public synchronized boolean isValid() {
-    return mRefCount > 0;
-  }
-
-  /**
-   * Checks if the shared-reference is valid i.e. its reference count is greater than zero
-   * @return true if the shared reference is valid
-   */
-  public static boolean isValid(SharedReference<?> ref) {
-    return ref != null && ref.isValid();
-  }
-
-  /**
-   * Bump up the reference count for the shared reference
-   * Note: The reference must be valid (aka not null) at this point
-   */
-  public synchronized void addReference() {
-    ensureValid();
-    mRefCount++;
-  }
-
-  /**
-   * Decrement the reference count for the shared reference. If the reference count drops to zero,
-   * then dispose of the referenced value
-   */
-  public void deleteReference() {
-    if (decreaseRefCount() == 0) {
-      T deleted;
-      synchronized (this) {
-        deleted = mValue;
-        mValue = null;
-      }
-      mResourceReleaser.release(deleted);
-      removeLiveReference(deleted);
+
+    /**
+     * Decrement the reference count for the shared reference. If the reference count drops to zero,
+     * then dispose of the referenced value
+     */
+    public void deleteReference() {
+        if (decreaseRefCount() == 0) {
+            T deleted;
+            synchronized (this) {
+                deleted = mValue;
+                mValue = null;
+            }
+            mResourceReleaser.release(deleted);
+            removeLiveReference(deleted);
+        }
     }
-  }
-
-  /**
-   * Decrements reference count for the shared reference. Returns value of mRefCount after
-   * decrementing
-   */
-  private synchronized int decreaseRefCount() {
-    ensureValid();
-    Preconditions.checkArgument(mRefCount > 0);
-
-    mRefCount--;
-    return mRefCount;
-  }
-
-  /**
-   * Assert that there is a valid referenced value. Throw a NullReferenceException otherwise
-   * @throws NullReferenceException, if the reference is invalid (i.e.) the underlying value is null
-   */
-  private void ensureValid() {
-    if (!isValid(this)) {
-      throw new NullReferenceException();
+
+    /**
+     * Decrements reference count for the shared reference. Returns value of mRefCount after
+     * decrementing
+     */
+    private synchronized int decreaseRefCount() {
+        ensureValid();
+        Preconditions.checkArgument(mRefCount > 0);
+
+        mRefCount--;
+        return mRefCount;
     }
-  }
-
-  /**
-   * A test-only method to get the ref count
-   * DO NOT USE in regular code
-   */
-  public synchronized int getRefCountTestOnly() {
-    return mRefCount;
-  }
-
-  /**
-   * The moral equivalent of NullPointerException for SharedReference. Indicates that the
-   * referenced object is null
-   */
-  public static class NullReferenceException extends RuntimeException {
-    public NullReferenceException() {
-      super("Null shared reference");
+
+    /**
+     * Assert that there is a valid referenced value. Throw a NullReferenceException otherwise
+     *
+     * @throws NullReferenceException, if the reference is invalid (i.e.) the underlying value is null
+     */
+    private void ensureValid() {
+        if (!isValid(this)) {
+            throw new NullReferenceException();
+        }
+    }
+
+    /**
+     * A test-only method to get the ref count
+     * DO NOT USE in regular code
+     */
+    public synchronized int getRefCountTestOnly() {
+        return mRefCount;
+    }
+
+    /**
+     * The moral equivalent of NullPointerException for SharedReference. Indicates that the
+     * referenced object is null
+     */
+    public static class NullReferenceException extends RuntimeException {
+        public NullReferenceException() {
+            super("Null shared reference");
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/soloader/SoLoaderShim.java b/fbcore/src/main/java/com/facebook/common/soloader/SoLoaderShim.java
index 58eeda2e4..8a69498b2 100644
--- a/fbcore/src/main/java/com/facebook/common/soloader/SoLoaderShim.java
+++ b/fbcore/src/main/java/com/facebook/common/soloader/SoLoaderShim.java
@@ -16,52 +16,52 @@
  */
 public class SoLoaderShim {
 
-  /**
-   * Handler that can be overridden by the application.
-   */
-  public interface Handler {
+    /**
+     * Handler that can be overridden by the application.
+     */
+    public interface Handler {
 
-    void loadLibrary(String libraryName);
-  }
+        void loadLibrary(String libraryName);
+    }
 
-  /**
-   * Default handler for loading libraries.
-   */
-  public static class DefaultHandler implements Handler {
+    /**
+     * Default handler for loading libraries.
+     */
+    public static class DefaultHandler implements Handler {
 
-    @Override
-    public void loadLibrary(String libraryName) {
-      System.loadLibrary(libraryName);
+        @Override
+        public void loadLibrary(String libraryName) {
+            System.loadLibrary(libraryName);
+        }
     }
-  }
 
-  private static volatile Handler sHandler = new DefaultHandler();
+    private static volatile Handler sHandler = new DefaultHandler();
 
-  /**
-   * Sets the handler.
-   *
-   * @param handler the new handler
-   */
-  public static void setHandler(Handler handler) {
-    Preconditions.checkNotNull(handler);
-    sHandler = handler;
-  }
+    /**
+     * Sets the handler.
+     *
+     * @param handler the new handler
+     */
+    public static void setHandler(Handler handler) {
+        Preconditions.checkNotNull(handler);
+        sHandler = handler;
+    }
 
-  /**
-   * See {@link Runtime#loadLibrary}.
-   *
-   * @param libraryName the library to load
-   */
-  public static void loadLibrary(String libraryName) {
-    sHandler.loadLibrary(libraryName);
-  }
+    /**
+     * See {@link Runtime#loadLibrary}.
+     *
+     * @param libraryName the library to load
+     */
+    public static void loadLibrary(String libraryName) {
+        sHandler.loadLibrary(libraryName);
+    }
 
-  public static void setInTestMode() {
-    setHandler(
-        new Handler() {
-          @Override
-          public void loadLibrary(String libraryName) {
-          }
-        });
-  }
+    public static void setInTestMode() {
+        setHandler(
+                new Handler() {
+                    @Override
+                    public void loadLibrary(String libraryName) {
+                    }
+                });
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/statfs/StatFsHelper.java b/fbcore/src/main/java/com/facebook/common/statfs/StatFsHelper.java
index 579542fb8..473d43412 100644
--- a/fbcore/src/main/java/com/facebook/common/statfs/StatFsHelper.java
+++ b/fbcore/src/main/java/com/facebook/common/statfs/StatFsHelper.java
@@ -28,202 +28,205 @@
  * Helper class that periodically checks the amount of free space available.
  * <p>To keep the overhead low, it caches the free space information, and
  * only updates that info after two minutes.
- *
+ * <p>
  * <p>It is a singleton, and is thread-safe.
- *
+ * <p>
  * <p>Initialization is delayed until first use, so the first call to any method may incur some
  * additional cost.
  */
 @ThreadSafe
 public class StatFsHelper {
 
-  public enum StorageType {
-    INTERNAL,
-    EXTERNAL
-  };
+    public enum StorageType {
+        INTERNAL,
+        EXTERNAL
+    }
+
+    ;
 
-  private static StatFsHelper sStatsFsHelper;
+    private static StatFsHelper sStatsFsHelper;
 
-  // Time interval for updating disk information
-  private static final long RESTAT_INTERVAL_MS = TimeUnit.MINUTES.toMillis(2);
+    // Time interval for updating disk information
+    private static final long RESTAT_INTERVAL_MS = TimeUnit.MINUTES.toMillis(2);
 
-  private volatile StatFs mInternalStatFs = null;
-  private volatile File mInternalPath;
+    private volatile StatFs mInternalStatFs = null;
+    private volatile File mInternalPath;
 
-  private volatile StatFs mExternalStatFs = null;
-  private volatile File mExternalPath;
+    private volatile StatFs mExternalStatFs = null;
+    private volatile File mExternalPath;
 
-  @GuardedBy("lock")
-  private long mLastRestatTime;
+    @GuardedBy("lock")
+    private long mLastRestatTime;
 
-  private final Lock lock;
-  private volatile boolean mInitialized = false;
+    private final Lock lock;
+    private volatile boolean mInitialized = false;
 
-  public synchronized static StatFsHelper getInstance() {
-    if (sStatsFsHelper == null) {
-      sStatsFsHelper = new StatFsHelper();
+    public synchronized static StatFsHelper getInstance() {
+        if (sStatsFsHelper == null) {
+            sStatsFsHelper = new StatFsHelper();
+        }
+        return sStatsFsHelper;
     }
-    return sStatsFsHelper;
-  }
-
-  /**
-   * Constructor.
-   *
-   * <p>Initialization is delayed until first use, so we must call {@link #ensureInitialized()}
-   * when implementing member methods.
-   */
-  protected StatFsHelper() {
-    lock = new ReentrantLock();
-  }
-
-  /**
-   * Initialization code that can sometimes take a long time.
-   */
-  private void ensureInitialized() {
-    if (!mInitialized) {
-     lock.lock();
-      try {
+
+    /**
+     * Constructor.
+     * <p>
+     * <p>Initialization is delayed until first use, so we must call {@link #ensureInitialized()}
+     * when implementing member methods.
+     */
+    protected StatFsHelper() {
+        lock = new ReentrantLock();
+    }
+
+    /**
+     * Initialization code that can sometimes take a long time.
+     */
+    private void ensureInitialized() {
         if (!mInitialized) {
-          mInternalPath = Environment.getDataDirectory();
-          mExternalPath = Environment.getExternalStorageDirectory();
-          updateStats();
-          mInitialized = true;
+            lock.lock();
+            try {
+                if (!mInitialized) {
+                    mInternalPath = Environment.getDataDirectory();
+                    mExternalPath = Environment.getExternalStorageDirectory();
+                    updateStats();
+                    mInitialized = true;
+                }
+            } finally {
+                lock.unlock();
+            }
         }
-      } finally {
-        lock.unlock();
-      }
-    }
-  }
-
-  /**
-   * Check if free space available in the filesystem is greater than the given threshold.
-   * Note that the free space stats are cached and updated in intervals of RESTAT_INTERVAL_MS.
-   * If the amount of free space has crossed over the threshold since the last update, it will
-   * return incorrect results till the space stats are updated again.
-   *
-   * @param storageType StorageType (internal or external) to test
-   * @param freeSpaceThreshold compare the available free space to this size
-   * @return whether free space is lower than the input freeSpaceThreshold,
-   * returns true if disk information is not available
-   */
-  public boolean testLowDiskSpace(StorageType storageType, long freeSpaceThreshold) {
-    ensureInitialized();
-
-    long availableStorageSpace = getAvailableStorageSpace(storageType);
-    if (availableStorageSpace > 0) {
-      return availableStorageSpace < freeSpaceThreshold;
     }
-    return true;
-  }
-
-  /**
-   * Gets the information about the available storage space
-   * either internal or external depends on the give input
-   * @param storageType Internal or external storage type
-   * @return available space in bytes, 0 if no information is available
-   */
-  public long getAvailableStorageSpace(StorageType storageType) {
-    ensureInitialized();
-
-    maybeUpdateStats();
-
-    StatFs statFS = storageType == StorageType.INTERNAL ? mInternalStatFs : mExternalStatFs;
-    if (statFS != null) {
-      long blockSize = statFS.getBlockSize();
-      long availableBlocks = statFS.getAvailableBlocks();
-      return blockSize * availableBlocks;
+
+    /**
+     * Check if free space available in the filesystem is greater than the given threshold.
+     * Note that the free space stats are cached and updated in intervals of RESTAT_INTERVAL_MS.
+     * If the amount of free space has crossed over the threshold since the last update, it will
+     * return incorrect results till the space stats are updated again.
+     *
+     * @param storageType        StorageType (internal or external) to test
+     * @param freeSpaceThreshold compare the available free space to this size
+     * @return whether free space is lower than the input freeSpaceThreshold,
+     * returns true if disk information is not available
+     */
+    public boolean testLowDiskSpace(StorageType storageType, long freeSpaceThreshold) {
+        ensureInitialized();
+
+        long availableStorageSpace = getAvailableStorageSpace(storageType);
+        if (availableStorageSpace > 0) {
+            return availableStorageSpace < freeSpaceThreshold;
+        }
+        return true;
     }
-    return 0;
-  }
-
-  /**
-   * Thread-safe call to update disk stats. Update occurs if the thread is able to acquire
-   * the lock (i.e., no other thread is updating it at the same time), and it has been
-   * at least RESTAT_INTERVAL_MS since the last update.
-   * Assumes that initialization has been completed before this method is called.
-   */
-  private void maybeUpdateStats() {
-    // Update the free space if able to get the lock,
-    // with a frequency of once in RESTAT_INTERVAL_MS
-    if (lock.tryLock()) {
-      try {
-        if ((SystemClock.elapsedRealtime() - mLastRestatTime) > RESTAT_INTERVAL_MS) {
-          updateStats();
+
+    /**
+     * Gets the information about the available storage space
+     * either internal or external depends on the give input
+     *
+     * @param storageType Internal or external storage type
+     * @return available space in bytes, 0 if no information is available
+     */
+    public long getAvailableStorageSpace(StorageType storageType) {
+        ensureInitialized();
+
+        maybeUpdateStats();
+
+        StatFs statFS = storageType == StorageType.INTERNAL ? mInternalStatFs : mExternalStatFs;
+        if (statFS != null) {
+            long blockSize = statFS.getBlockSize();
+            long availableBlocks = statFS.getAvailableBlocks();
+            return blockSize * availableBlocks;
         }
-      } finally {
-        lock.unlock();
-      }
+        return 0;
     }
-  }
-
-  /**
-   * Thread-safe call to reset the disk stats.
-   * If we know that the free space has changed recently (for example, if we have
-   * deleted files), use this method to reset the internal state and
-   * start tracking disk stats afresh, resetting the internal timer for updating stats.
-   */
-  public void resetStats() {
-    // Update the free space if able to get the lock
-    if (lock.tryLock()) {
-      try {
-          ensureInitialized();
-
-          updateStats();
-      } finally {
-        lock.unlock();
-      }
+
+    /**
+     * Thread-safe call to update disk stats. Update occurs if the thread is able to acquire
+     * the lock (i.e., no other thread is updating it at the same time), and it has been
+     * at least RESTAT_INTERVAL_MS since the last update.
+     * Assumes that initialization has been completed before this method is called.
+     */
+    private void maybeUpdateStats() {
+        // Update the free space if able to get the lock,
+        // with a frequency of once in RESTAT_INTERVAL_MS
+        if (lock.tryLock()) {
+            try {
+                if ((SystemClock.elapsedRealtime() - mLastRestatTime) > RESTAT_INTERVAL_MS) {
+                    updateStats();
+                }
+            } finally {
+                lock.unlock();
+            }
+        }
     }
-  }
-
-  /**
-   * (Re)calculate the stats.
-   * It is the callers responsibility to ensure thread-safety.
-   * Assumes that it is called after initialization (or at the end of it).
-   */
-  @GuardedBy("lock")
-  private void updateStats() {
-    mInternalStatFs = updateStatsHelper(mInternalStatFs, mInternalPath);
-    mExternalStatFs = updateStatsHelper(mExternalStatFs, mExternalPath);
-    mLastRestatTime = SystemClock.elapsedRealtime();
-  }
-
-  /**
-   * Update stats for a single directory and return the StatFs object for that directory. If the
-   * directory does not exist or the StatFs restat() or constructor fails (throws), a null StatFs
-   * object is returned.
-   */
-  private StatFs updateStatsHelper(@Nullable StatFs statfs, @Nullable File dir) {
-    if(dir == null || !dir.exists()) {
-      // The path does not exist, do not track stats for it.
-      return null;
+
+    /**
+     * Thread-safe call to reset the disk stats.
+     * If we know that the free space has changed recently (for example, if we have
+     * deleted files), use this method to reset the internal state and
+     * start tracking disk stats afresh, resetting the internal timer for updating stats.
+     */
+    public void resetStats() {
+        // Update the free space if able to get the lock
+        if (lock.tryLock()) {
+            try {
+                ensureInitialized();
+
+                updateStats();
+            } finally {
+                lock.unlock();
+            }
+        }
     }
 
-    try {
-      if (statfs == null) {
-        // Create a new StatFs object for this path.
-        statfs = createStatFs(dir.getAbsolutePath());
-      } else {
-        // Call restat and keep the existing StatFs object.
-        statfs.restat(dir.getAbsolutePath());
-      }
-    } catch (IllegalArgumentException ex) {
-      // Invalidate the StatFs object for this directory. The native StatFs implementation throws
-      // IllegalArgumentException in the case that the statfs() system call fails and it invalidates
-      // its internal data structures so subsequent calls against the StatFs object will fail or
-      // throw (so we should make no more calls on the object). The most likely reason for this call
-      // to fail is because the provided path no longer exists. The next call to updateStats() will
-      // a new statfs object if the path exists. This will handle the case that a path is unmounted
-      // and later remounted (but it has to have been mounted when this object was initialized).
-      statfs = null;
-    } catch (Throwable ex) {
-      // Any other exception types are not expected and should be propagated as runtime errors.
-      throw Throwables.propagate(ex);
+    /**
+     * (Re)calculate the stats.
+     * It is the callers responsibility to ensure thread-safety.
+     * Assumes that it is called after initialization (or at the end of it).
+     */
+    @GuardedBy("lock")
+    private void updateStats() {
+        mInternalStatFs = updateStatsHelper(mInternalStatFs, mInternalPath);
+        mExternalStatFs = updateStatsHelper(mExternalStatFs, mExternalPath);
+        mLastRestatTime = SystemClock.elapsedRealtime();
     }
 
-    return statfs;
-  }
+    /**
+     * Update stats for a single directory and return the StatFs object for that directory. If the
+     * directory does not exist or the StatFs restat() or constructor fails (throws), a null StatFs
+     * object is returned.
+     */
+    private StatFs updateStatsHelper(@Nullable StatFs statfs, @Nullable File dir) {
+        if (dir == null || !dir.exists()) {
+            // The path does not exist, do not track stats for it.
+            return null;
+        }
 
-  protected static StatFs createStatFs(String path) {
-    return new StatFs(path);
-  }
+        try {
+            if (statfs == null) {
+                // Create a new StatFs object for this path.
+                statfs = createStatFs(dir.getAbsolutePath());
+            } else {
+                // Call restat and keep the existing StatFs object.
+                statfs.restat(dir.getAbsolutePath());
+            }
+        } catch (IllegalArgumentException ex) {
+            // Invalidate the StatFs object for this directory. The native StatFs implementation throws
+            // IllegalArgumentException in the case that the statfs() system call fails and it invalidates
+            // its internal data structures so subsequent calls against the StatFs object will fail or
+            // throw (so we should make no more calls on the object). The most likely reason for this call
+            // to fail is because the provided path no longer exists. The next call to updateStats() will
+            // a new statfs object if the path exists. This will handle the case that a path is unmounted
+            // and later remounted (but it has to have been mounted when this object was initialized).
+            statfs = null;
+        } catch (Throwable ex) {
+            // Any other exception types are not expected and should be propagated as runtime errors.
+            throw Throwables.propagate(ex);
+        }
+
+        return statfs;
+    }
+
+    protected static StatFs createStatFs(String path) {
+        return new StatFs(path);
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/streams/LimitedInputStream.java b/fbcore/src/main/java/com/facebook/common/streams/LimitedInputStream.java
index d5b88b8e6..c236ccec8 100644
--- a/fbcore/src/main/java/com/facebook/common/streams/LimitedInputStream.java
+++ b/fbcore/src/main/java/com/facebook/common/streams/LimitedInputStream.java
@@ -17,82 +17,82 @@
  * Reads the wrapped InputStream only until a specified number of bytes, the 'limit' is reached.
  */
 public class LimitedInputStream extends FilterInputStream {
-  private int mBytesToRead;
-  private int mBytesToReadWhenMarked;
-
-  public LimitedInputStream(InputStream inputStream, int limit) {
-    super(inputStream);
-    if (inputStream == null) {
-      throw new NullPointerException();
-    }
-    if (limit < 0) {
-      throw new IllegalArgumentException("limit must be >= 0");
-    }
-    mBytesToRead = limit;
-    mBytesToReadWhenMarked = -1;
-  }
-
-  @Override
-  public int read() throws IOException {
-    if (mBytesToRead == 0) {
-      return -1;
+    private int mBytesToRead;
+    private int mBytesToReadWhenMarked;
+
+    public LimitedInputStream(InputStream inputStream, int limit) {
+        super(inputStream);
+        if (inputStream == null) {
+            throw new NullPointerException();
+        }
+        if (limit < 0) {
+            throw new IllegalArgumentException("limit must be >= 0");
+        }
+        mBytesToRead = limit;
+        mBytesToReadWhenMarked = -1;
     }
 
-    final int readByte = in.read();
-    if (readByte != -1) {
-      mBytesToRead--;
-    }
+    @Override
+    public int read() throws IOException {
+        if (mBytesToRead == 0) {
+            return -1;
+        }
 
-    return readByte;
-  }
+        final int readByte = in.read();
+        if (readByte != -1) {
+            mBytesToRead--;
+        }
 
-  @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
-    if (mBytesToRead == 0) {
-      return -1;
+        return readByte;
     }
 
-    final int maxBytesToRead = Math.min(byteCount, mBytesToRead);
-    final int bytesRead = in.read(buffer, byteOffset, maxBytesToRead);
-    if (bytesRead > 0) {
-      mBytesToRead -= bytesRead;
+    @Override
+    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+        if (mBytesToRead == 0) {
+            return -1;
+        }
+
+        final int maxBytesToRead = Math.min(byteCount, mBytesToRead);
+        final int bytesRead = in.read(buffer, byteOffset, maxBytesToRead);
+        if (bytesRead > 0) {
+            mBytesToRead -= bytesRead;
+        }
+
+        return bytesRead;
     }
 
-    return bytesRead;
-  }
-
-  @Override
-  public long skip(long byteCount) throws IOException {
-    final long maxBytesToSkip = Math.min(byteCount, mBytesToRead);
-    final long bytesSkipped = in.skip(maxBytesToSkip);
-    mBytesToRead -= bytesSkipped;
-    return bytesSkipped;
-  }
-
-  @Override
-  public int available() throws IOException {
-    return Math.min(in.available(), mBytesToRead);
-  }
-
-  @Override
-  public void mark(int readLimit) {
-    if (in.markSupported()) {
-      in.mark(readLimit);
-      mBytesToReadWhenMarked = mBytesToRead;
+    @Override
+    public long skip(long byteCount) throws IOException {
+        final long maxBytesToSkip = Math.min(byteCount, mBytesToRead);
+        final long bytesSkipped = in.skip(maxBytesToSkip);
+        mBytesToRead -= bytesSkipped;
+        return bytesSkipped;
     }
-  }
 
-  @Override
-  public void reset() throws IOException {
-    if (!in.markSupported()) {
-      throw new IOException("mark is not supported");
+    @Override
+    public int available() throws IOException {
+        return Math.min(in.available(), mBytesToRead);
     }
 
-    if (mBytesToReadWhenMarked == -1) {
-      throw new IOException("mark not set");
+    @Override
+    public void mark(int readLimit) {
+        if (in.markSupported()) {
+            in.mark(readLimit);
+            mBytesToReadWhenMarked = mBytesToRead;
+        }
     }
 
-    in.reset();
-    mBytesToRead = mBytesToReadWhenMarked;
-  }
+    @Override
+    public void reset() throws IOException {
+        if (!in.markSupported()) {
+            throw new IOException("mark is not supported");
+        }
+
+        if (mBytesToReadWhenMarked == -1) {
+            throw new IOException("mark not set");
+        }
+
+        in.reset();
+        mBytesToRead = mBytesToReadWhenMarked;
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/streams/TailAppendingInputStream.java b/fbcore/src/main/java/com/facebook/common/streams/TailAppendingInputStream.java
index d428a7c54..1e1b64d0a 100644
--- a/fbcore/src/main/java/com/facebook/common/streams/TailAppendingInputStream.java
+++ b/fbcore/src/main/java/com/facebook/common/streams/TailAppendingInputStream.java
@@ -18,80 +18,80 @@
  * InputStream that returns all bytes from another stream, then appends the specified 'tail' bytes.
  */
 public class TailAppendingInputStream extends FilterInputStream {
-  private final byte[] mTail;
-  private int mTailOffset;
-  private int mMarkedTailOffset;
+    private final byte[] mTail;
+    private int mTailOffset;
+    private int mMarkedTailOffset;
 
-  public TailAppendingInputStream(InputStream inputStream, byte[] tail) {
-    super(inputStream);
-    if (inputStream == null) {
-      throw new NullPointerException();
+    public TailAppendingInputStream(InputStream inputStream, byte[] tail) {
+        super(inputStream);
+        if (inputStream == null) {
+            throw new NullPointerException();
+        }
+        if (tail == null) {
+            throw new NullPointerException();
+        }
+        mTail = tail;
     }
-    if (tail == null) {
-      throw new NullPointerException();
-    }
-    mTail = tail;
-  }
 
-  @Override
-  public int read() throws IOException {
-    final int readResult = in.read();
-    if (readResult != -1) {
-      return readResult;
+    @Override
+    public int read() throws IOException {
+        final int readResult = in.read();
+        if (readResult != -1) {
+            return readResult;
+        }
+        return readNextTailByte();
     }
-    return readNextTailByte();
-  }
-
-  @Override
-  public int read(byte[] buffer) throws IOException {
-    return read(buffer, 0, buffer.length);
-  }
 
-  @Override
-  public int read(byte[] buffer, int offset, int count) throws IOException {
-    final int readResult = in.read(buffer, offset, count);
-    if (readResult != -1) {
-      return readResult;
+    @Override
+    public int read(byte[] buffer) throws IOException {
+        return read(buffer, 0, buffer.length);
     }
 
-    if (count == 0) {
-      return 0;
-    }
+    @Override
+    public int read(byte[] buffer, int offset, int count) throws IOException {
+        final int readResult = in.read(buffer, offset, count);
+        if (readResult != -1) {
+            return readResult;
+        }
+
+        if (count == 0) {
+            return 0;
+        }
 
-    int bytesRead = 0;
-    while (bytesRead < count) {
-      final int nextByte = readNextTailByte();
-      if (nextByte == -1) {
-        break;
-      }
-      buffer[offset + bytesRead] = (byte) nextByte;
-      bytesRead++;
+        int bytesRead = 0;
+        while (bytesRead < count) {
+            final int nextByte = readNextTailByte();
+            if (nextByte == -1) {
+                break;
+            }
+            buffer[offset + bytesRead] = (byte) nextByte;
+            bytesRead++;
+        }
+        return bytesRead > 0 ? bytesRead : -1;
     }
-    return bytesRead > 0 ? bytesRead : -1;
-  }
 
-  @Override
-  public void reset() throws IOException {
-    if (in.markSupported()) {
-      in.reset();
-      mTailOffset = mMarkedTailOffset;
-    } else {
-      throw new IOException("mark is not supported");
+    @Override
+    public void reset() throws IOException {
+        if (in.markSupported()) {
+            in.reset();
+            mTailOffset = mMarkedTailOffset;
+        } else {
+            throw new IOException("mark is not supported");
+        }
     }
-  }
 
-  @Override
-  public void mark(int readLimit) {
-    if (in.markSupported()) {
-      super.mark(readLimit);
-      mMarkedTailOffset = mTailOffset;
+    @Override
+    public void mark(int readLimit) {
+        if (in.markSupported()) {
+            super.mark(readLimit);
+            mMarkedTailOffset = mTailOffset;
+        }
     }
-  }
 
-  private int readNextTailByte() {
-    if (mTailOffset >= mTail.length) {
-      return -1;
+    private int readNextTailByte() {
+        if (mTailOffset >= mTail.length) {
+            return -1;
+        }
+        return ((int) mTail[mTailOffset++]) & 0xFF;
     }
-    return ((int) mTail[mTailOffset++]) & 0xFF;
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/time/Clock.java b/fbcore/src/main/java/com/facebook/common/time/Clock.java
index e43a5d4db..1e7a3d6ef 100644
--- a/fbcore/src/main/java/com/facebook/common/time/Clock.java
+++ b/fbcore/src/main/java/com/facebook/common/time/Clock.java
@@ -14,15 +14,15 @@
  */
 public interface Clock {
 
-  /**
-   * The maximum time.
-   */
-  public static final long MAX_TIME = Long.MAX_VALUE;
+    /**
+     * The maximum time.
+     */
+    public static final long MAX_TIME = Long.MAX_VALUE;
 
-  /**
-   * Gets the current time in milliseconds.
-   *
-   * @return the current time in milliseconds.
-   */
-  long now();
+    /**
+     * Gets the current time in milliseconds.
+     *
+     * @return the current time in milliseconds.
+     */
+    long now();
 }
diff --git a/fbcore/src/main/java/com/facebook/common/time/CurrentThreadTimeClock.java b/fbcore/src/main/java/com/facebook/common/time/CurrentThreadTimeClock.java
index 228ec0c23..c01c9dc0c 100644
--- a/fbcore/src/main/java/com/facebook/common/time/CurrentThreadTimeClock.java
+++ b/fbcore/src/main/java/com/facebook/common/time/CurrentThreadTimeClock.java
@@ -15,10 +15,11 @@
  */
 public class CurrentThreadTimeClock implements Clock {
 
-  public CurrentThreadTimeClock() {}
+    public CurrentThreadTimeClock() {
+    }
 
-  @Override
-  public long now() {
-    return android.os.SystemClock.currentThreadTimeMillis();
-  }
+    @Override
+    public long now() {
+        return android.os.SystemClock.currentThreadTimeMillis();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/time/MonotonicClock.java b/fbcore/src/main/java/com/facebook/common/time/MonotonicClock.java
index 6325b891f..c999c82b0 100644
--- a/fbcore/src/main/java/com/facebook/common/time/MonotonicClock.java
+++ b/fbcore/src/main/java/com/facebook/common/time/MonotonicClock.java
@@ -16,15 +16,15 @@
  */
 public interface MonotonicClock {
 
-  /**
-   * Produce a timestamp.  Values returned from this method may only be compared to other values
-   * returned from this clock in this process.  They have no meaning outside of this process
-   * and should not be written to disk.
-   *
-   * The difference between two timestamps is an interval, in milliseconds.
-   *
-   * @return A timestamp for the current time, in ms.
-   */
-  @DoNotStrip
-  long now();
+    /**
+     * Produce a timestamp.  Values returned from this method may only be compared to other values
+     * returned from this clock in this process.  They have no meaning outside of this process
+     * and should not be written to disk.
+     * <p>
+     * The difference between two timestamps is an interval, in milliseconds.
+     *
+     * @return A timestamp for the current time, in ms.
+     */
+    @DoNotStrip
+    long now();
 }
diff --git a/fbcore/src/main/java/com/facebook/common/time/RealtimeSinceBootClock.java b/fbcore/src/main/java/com/facebook/common/time/RealtimeSinceBootClock.java
index 5df689733..e73979aab 100644
--- a/fbcore/src/main/java/com/facebook/common/time/RealtimeSinceBootClock.java
+++ b/fbcore/src/main/java/com/facebook/common/time/RealtimeSinceBootClock.java
@@ -15,22 +15,23 @@
  * This happens regardless system time changes, time zone changes, daylight saving changes etc.
  */
 public class RealtimeSinceBootClock implements MonotonicClock {
-  private static final RealtimeSinceBootClock INSTANCE = new RealtimeSinceBootClock();
+    private static final RealtimeSinceBootClock INSTANCE = new RealtimeSinceBootClock();
 
-  private RealtimeSinceBootClock() {
-  }
+    private RealtimeSinceBootClock() {
+    }
 
-  /**
-   * Returns a singleton instance of this clock.
-   * @return singleton instance
-   */
-  public static RealtimeSinceBootClock get() {
-    return INSTANCE;
-  }
+    /**
+     * Returns a singleton instance of this clock.
+     *
+     * @return singleton instance
+     */
+    public static RealtimeSinceBootClock get() {
+        return INSTANCE;
+    }
 
-  @Override
-  public long now() {
-    // Guaranteed to be monotonic according to documentation.
-    return android.os.SystemClock.elapsedRealtime();
-  }
+    @Override
+    public long now() {
+        // Guaranteed to be monotonic according to documentation.
+        return android.os.SystemClock.elapsedRealtime();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/time/SystemClock.java b/fbcore/src/main/java/com/facebook/common/time/SystemClock.java
index d116a5b4e..f88cace29 100644
--- a/fbcore/src/main/java/com/facebook/common/time/SystemClock.java
+++ b/fbcore/src/main/java/com/facebook/common/time/SystemClock.java
@@ -14,17 +14,17 @@
  */
 public class SystemClock implements Clock {
 
-  private static final SystemClock INSTANCE = new SystemClock();
+    private static final SystemClock INSTANCE = new SystemClock();
 
-  private SystemClock() {
-  }
+    private SystemClock() {
+    }
 
-  public static SystemClock get() {
-    return INSTANCE;
-  }
+    public static SystemClock get() {
+        return INSTANCE;
+    }
 
-  @Override
-  public long now() {
-    return System.currentTimeMillis();
-  }
+    @Override
+    public long now() {
+        return System.currentTimeMillis();
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/time/TimeConstants.java b/fbcore/src/main/java/com/facebook/common/time/TimeConstants.java
index df07779e4..8a2b81112 100644
--- a/fbcore/src/main/java/com/facebook/common/time/TimeConstants.java
+++ b/fbcore/src/main/java/com/facebook/common/time/TimeConstants.java
@@ -13,28 +13,28 @@
  * Useful time constants.
  */
 public class TimeConstants {
-  public static final long NS_PER_MS = 1000000;
-  public static final long NS_PER_US = 1000;
-  public static final long US_PER_MS = 1000;
-  public static final long NS_PER_SECOND = 1000 * 1000 * 1000;
-  public static final long US_PER_SECOND = 1000 * 1000;
-  public static final long MS_PER_SECOND = 1000;
-  public static final long SECONDS_PER_MINUTE = 60;
-  public static final long MINUTES_PER_HOUR = 60;
-  public static final long HOURS_PER_DAY = 24;
-  public static final long DAYS_PER_WEEK = 7;
-  public static final long DAYS_PER_MONTH = 30;
-  public static final long DAYS_PER_YEAR = 365;
+    public static final long NS_PER_MS = 1000000;
+    public static final long NS_PER_US = 1000;
+    public static final long US_PER_MS = 1000;
+    public static final long NS_PER_SECOND = 1000 * 1000 * 1000;
+    public static final long US_PER_SECOND = 1000 * 1000;
+    public static final long MS_PER_SECOND = 1000;
+    public static final long SECONDS_PER_MINUTE = 60;
+    public static final long MINUTES_PER_HOUR = 60;
+    public static final long HOURS_PER_DAY = 24;
+    public static final long DAYS_PER_WEEK = 7;
+    public static final long DAYS_PER_MONTH = 30;
+    public static final long DAYS_PER_YEAR = 365;
 
-  public static final long MS_PER_MINUTE = MS_PER_SECOND * SECONDS_PER_MINUTE;
-  public static final long MS_PER_HOUR = MS_PER_MINUTE * MINUTES_PER_HOUR;
-  public static final long MS_PER_DAY = MS_PER_HOUR * HOURS_PER_DAY;
-  public static final long MS_PER_WEEK = MS_PER_DAY * DAYS_PER_WEEK;
-  public static final long MS_PER_YEAR = MS_PER_DAY * DAYS_PER_YEAR;
+    public static final long MS_PER_MINUTE = MS_PER_SECOND * SECONDS_PER_MINUTE;
+    public static final long MS_PER_HOUR = MS_PER_MINUTE * MINUTES_PER_HOUR;
+    public static final long MS_PER_DAY = MS_PER_HOUR * HOURS_PER_DAY;
+    public static final long MS_PER_WEEK = MS_PER_DAY * DAYS_PER_WEEK;
+    public static final long MS_PER_YEAR = MS_PER_DAY * DAYS_PER_YEAR;
 
-  public static final long SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
-  public static final long SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;
-  public static final long SECONDS_PER_WEEK = SECONDS_PER_DAY * DAYS_PER_WEEK;
-  public static final long SECONDS_PER_MONTH = SECONDS_PER_DAY * DAYS_PER_MONTH;
-  public static final long SECONDS_PER_YEAR = SECONDS_PER_DAY * DAYS_PER_YEAR;
+    public static final long SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
+    public static final long SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;
+    public static final long SECONDS_PER_WEEK = SECONDS_PER_DAY * DAYS_PER_WEEK;
+    public static final long SECONDS_PER_MONTH = SECONDS_PER_DAY * DAYS_PER_MONTH;
+    public static final long SECONDS_PER_YEAR = SECONDS_PER_DAY * DAYS_PER_YEAR;
 }
diff --git a/fbcore/src/main/java/com/facebook/common/time/TimeConversions.java b/fbcore/src/main/java/com/facebook/common/time/TimeConversions.java
index bac81b3f5..80729c6fc 100644
--- a/fbcore/src/main/java/com/facebook/common/time/TimeConversions.java
+++ b/fbcore/src/main/java/com/facebook/common/time/TimeConversions.java
@@ -14,32 +14,32 @@
  */
 public class TimeConversions {
 
-  /**
-   * Convert time in millisecond to hours rounding down.
-   */
-  public static long millisecondsToHours(long timeMs) {
-    return timeMs / TimeConstants.MS_PER_HOUR;
-  }
+    /**
+     * Convert time in millisecond to hours rounding down.
+     */
+    public static long millisecondsToHours(long timeMs) {
+        return timeMs / TimeConstants.MS_PER_HOUR;
+    }
 
-  /**
-   * Convert time in milliseconds to minutes rounding down.
-   */
-  public static long millisecondsToMinutes(long timeMs) {
-    return timeMs / TimeConstants.MS_PER_MINUTE;
-  }
+    /**
+     * Convert time in milliseconds to minutes rounding down.
+     */
+    public static long millisecondsToMinutes(long timeMs) {
+        return timeMs / TimeConstants.MS_PER_MINUTE;
+    }
 
-  public static long millisecondsToDays(long timeMs) {
-    return timeMs / TimeConstants.MS_PER_DAY;
-  }
+    public static long millisecondsToDays(long timeMs) {
+        return timeMs / TimeConstants.MS_PER_DAY;
+    }
 
-  public static long millisecondsToYears(long timeMs) {
-    return timeMs / TimeConstants.MS_PER_YEAR;
-  }
+    public static long millisecondsToYears(long timeMs) {
+        return timeMs / TimeConstants.MS_PER_YEAR;
+    }
 
-  /**
-   * Convert time in milliseconds to seconds rounding down.
-   */
-  public static long millisecondsToSeconds(long timeMs) {
-    return timeMs / TimeConstants.MS_PER_SECOND;
-  }
+    /**
+     * Convert time in milliseconds to seconds rounding down.
+     */
+    public static long millisecondsToSeconds(long timeMs) {
+        return timeMs / TimeConstants.MS_PER_SECOND;
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/time/TimeSpan.java b/fbcore/src/main/java/com/facebook/common/time/TimeSpan.java
index 832de2706..99b9a0970 100644
--- a/fbcore/src/main/java/com/facebook/common/time/TimeSpan.java
+++ b/fbcore/src/main/java/com/facebook/common/time/TimeSpan.java
@@ -16,207 +16,208 @@
  */
 public class TimeSpan {
 
-  /**
-   * @param nanos Duration, in nanoseconds
-   * @return The time span representing the given duration
-   */
-  public static TimeSpan fromNanos(long nanos) {
-    return new TimeSpan(nanos, TimeUnit.NANOSECONDS);
-  }
-
-  /**
-   * @param micros Duration, in microseconds
-   * @return The time span representing the given duration
-   */
-  public static TimeSpan fromMicros(long micros) {
-    return new TimeSpan(micros, TimeUnit.MICROSECONDS);
-  }
-
-  /**
-   * @param millis Duration, in milliseconds
-   * @return The time span representing the given duration
-   */
-  public static TimeSpan fromMillis(long millis) {
-    return new TimeSpan(millis, TimeUnit.MILLISECONDS);
-  }
-
-  /**
-   * @param seconds Duration, in seconds
-   * @return The time span representing the given duration
-   */
-  public static TimeSpan fromSeconds(long seconds) {
-    return new TimeSpan(seconds, TimeUnit.SECONDS);
-  }
-
-  /**
-   * @param minutes Duration, in minutes
-   * @return The time span representing the given duration
-   */
-  public static TimeSpan fromMinutes(long minutes) {
-    return new TimeSpan(minutes, TimeUnit.MINUTES);
-  }
-
-  /**
-   * @param hours Duration, in hours
-   * @return The time span representing the given duration
-   */
-  public static TimeSpan fromHours(long hours) {
-    return new TimeSpan(hours, TimeUnit.HOURS);
-  }
-
-  /**
-   * @param days Duration, in days
-   * @return The time span representing the given duration
-   */
-  public static TimeSpan fromDays(long days) {
-    return new TimeSpan(days, TimeUnit.DAYS);
-  }
-
-  /**
-   * Actual time span, normalized to nanoseconds (shortest time supported by
-   * {@link java.util.concurrent.TimeUnit})
-   */
-  private final long mDurationNanos;
-
-  /**
-   * Constructs an object representing the given time span
-   * @param duration Duration, in the given units
-   * @param timeUnit Unit duration is given
-   */
-  public TimeSpan(long duration, TimeUnit timeUnit) {
-    mDurationNanos = timeUnit.toNanos(duration);
-  }
-
-  /**
-   * @return Duration in nanoseconds
-   */
-  public long toNanos() {
-    return mDurationNanos;
-  }
-
-  /**
-   * @return Duration in microseconds
-   */
-  public long toMicros() {
-    return TimeUnit.NANOSECONDS.toMicros(mDurationNanos);
-  }
-
-  /**
-   * @return Duration in milliseconds
-   */
-  public long toMillis() {
-    return TimeUnit.NANOSECONDS.toMillis(mDurationNanos);
-  }
-
-  /**
-   * @return Duration in seconds
-   */
-  public long toSeconds() {
-    return TimeUnit.NANOSECONDS.toSeconds(mDurationNanos);
-  }
-
-  /**
-   * @return Duration in minutes
-   */
-  public long toMinutes() {
-    return TimeUnit.NANOSECONDS.toMinutes(mDurationNanos);
-  }
-
-  /**
-   * @return Duration in hours
-   */
-  public long toHours() {
-    return TimeUnit.NANOSECONDS.toHours(mDurationNanos);
-  }
-
-  /**
-   * @return Duration in days
-   */
-  public long toDays() {
-    return TimeUnit.NANOSECONDS.toDays(mDurationNanos);
-  }
-
-  /**
-   * Get duration as the given time unit
-   *
-   * @param timeUnit Time unit to get the duration in
-   * @return Duration in requested time unit
-   */
-  public long as(TimeUnit timeUnit) {
-    return timeUnit.convert(mDurationNanos, TimeUnit.NANOSECONDS);
-  }
-
-  @Override
-  public String toString() {
-    long days = toDays();
-    long hours = toHours() % 24;
-    long minutes = toMinutes() % 60;
-    long seconds = toSeconds() % 60;
-    long millis = toMillis() % 1000;
-    long micros = toMicros() % 1000;
-    long nanos = toNanos() % 1000;
-
-    String sep = "";
-    StringBuilder sb = new StringBuilder("TimeSpan{");
-    if (days > 0) {
-      sb.append(days).append(" ");
-      pluralize(sb, "Day", days);
-      sep = ", ";
-    }
-    if (hours > 0) {
-      sb.append(sep).append(hours).append(" ");
-      pluralize(sb, "Hour", hours);
-      sep = ", ";
-    }
-    if (minutes > 0) {
-      sb.append(sep).append(minutes).append(" ");
-      pluralize(sb, "Minute", minutes);
-      sep = ", ";
-    }
-    if (seconds > 0) {
-      sb.append(sep).append(seconds).append(" ");
-      pluralize(sb, "Second", seconds);
-      sep = ", ";
-    }
-    if (millis > 0) {
-      sb.append(sep).append(millis).append(" ");
-      pluralize(sb, "Milli", millis);
-      sep = ", ";
-    }
-    if (micros > 0) {
-      sb.append(sep).append(micros).append(" ");
-      pluralize(sb, "Micro", micros);
-      sep = ", ";
-    }
-    if (nanos > 0) {
-      sb.append(sep).append(nanos).append(" ");
-      pluralize(sb, "Nano", nanos);
-    }
-    sb.append("}");
-    return sb.toString();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    TimeSpan timeSpan = (TimeSpan) o;
-
-    if (mDurationNanos != timeSpan.mDurationNanos) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    return (int)(mDurationNanos ^ (mDurationNanos >>> 32));
-  }
-
-  private static final void pluralize(StringBuilder sb, String singular, long num) {
-    sb.append(singular);
-    if (num > 1) {
-      sb.append("s");
-    }
-  }
+    /**
+     * @param nanos Duration, in nanoseconds
+     * @return The time span representing the given duration
+     */
+    public static TimeSpan fromNanos(long nanos) {
+        return new TimeSpan(nanos, TimeUnit.NANOSECONDS);
+    }
+
+    /**
+     * @param micros Duration, in microseconds
+     * @return The time span representing the given duration
+     */
+    public static TimeSpan fromMicros(long micros) {
+        return new TimeSpan(micros, TimeUnit.MICROSECONDS);
+    }
+
+    /**
+     * @param millis Duration, in milliseconds
+     * @return The time span representing the given duration
+     */
+    public static TimeSpan fromMillis(long millis) {
+        return new TimeSpan(millis, TimeUnit.MILLISECONDS);
+    }
+
+    /**
+     * @param seconds Duration, in seconds
+     * @return The time span representing the given duration
+     */
+    public static TimeSpan fromSeconds(long seconds) {
+        return new TimeSpan(seconds, TimeUnit.SECONDS);
+    }
+
+    /**
+     * @param minutes Duration, in minutes
+     * @return The time span representing the given duration
+     */
+    public static TimeSpan fromMinutes(long minutes) {
+        return new TimeSpan(minutes, TimeUnit.MINUTES);
+    }
+
+    /**
+     * @param hours Duration, in hours
+     * @return The time span representing the given duration
+     */
+    public static TimeSpan fromHours(long hours) {
+        return new TimeSpan(hours, TimeUnit.HOURS);
+    }
+
+    /**
+     * @param days Duration, in days
+     * @return The time span representing the given duration
+     */
+    public static TimeSpan fromDays(long days) {
+        return new TimeSpan(days, TimeUnit.DAYS);
+    }
+
+    /**
+     * Actual time span, normalized to nanoseconds (shortest time supported by
+     * {@link java.util.concurrent.TimeUnit})
+     */
+    private final long mDurationNanos;
+
+    /**
+     * Constructs an object representing the given time span
+     *
+     * @param duration Duration, in the given units
+     * @param timeUnit Unit duration is given
+     */
+    public TimeSpan(long duration, TimeUnit timeUnit) {
+        mDurationNanos = timeUnit.toNanos(duration);
+    }
+
+    /**
+     * @return Duration in nanoseconds
+     */
+    public long toNanos() {
+        return mDurationNanos;
+    }
+
+    /**
+     * @return Duration in microseconds
+     */
+    public long toMicros() {
+        return TimeUnit.NANOSECONDS.toMicros(mDurationNanos);
+    }
+
+    /**
+     * @return Duration in milliseconds
+     */
+    public long toMillis() {
+        return TimeUnit.NANOSECONDS.toMillis(mDurationNanos);
+    }
+
+    /**
+     * @return Duration in seconds
+     */
+    public long toSeconds() {
+        return TimeUnit.NANOSECONDS.toSeconds(mDurationNanos);
+    }
+
+    /**
+     * @return Duration in minutes
+     */
+    public long toMinutes() {
+        return TimeUnit.NANOSECONDS.toMinutes(mDurationNanos);
+    }
+
+    /**
+     * @return Duration in hours
+     */
+    public long toHours() {
+        return TimeUnit.NANOSECONDS.toHours(mDurationNanos);
+    }
+
+    /**
+     * @return Duration in days
+     */
+    public long toDays() {
+        return TimeUnit.NANOSECONDS.toDays(mDurationNanos);
+    }
+
+    /**
+     * Get duration as the given time unit
+     *
+     * @param timeUnit Time unit to get the duration in
+     * @return Duration in requested time unit
+     */
+    public long as(TimeUnit timeUnit) {
+        return timeUnit.convert(mDurationNanos, TimeUnit.NANOSECONDS);
+    }
+
+    @Override
+    public String toString() {
+        long days = toDays();
+        long hours = toHours() % 24;
+        long minutes = toMinutes() % 60;
+        long seconds = toSeconds() % 60;
+        long millis = toMillis() % 1000;
+        long micros = toMicros() % 1000;
+        long nanos = toNanos() % 1000;
+
+        String sep = "";
+        StringBuilder sb = new StringBuilder("TimeSpan{");
+        if (days > 0) {
+            sb.append(days).append(" ");
+            pluralize(sb, "Day", days);
+            sep = ", ";
+        }
+        if (hours > 0) {
+            sb.append(sep).append(hours).append(" ");
+            pluralize(sb, "Hour", hours);
+            sep = ", ";
+        }
+        if (minutes > 0) {
+            sb.append(sep).append(minutes).append(" ");
+            pluralize(sb, "Minute", minutes);
+            sep = ", ";
+        }
+        if (seconds > 0) {
+            sb.append(sep).append(seconds).append(" ");
+            pluralize(sb, "Second", seconds);
+            sep = ", ";
+        }
+        if (millis > 0) {
+            sb.append(sep).append(millis).append(" ");
+            pluralize(sb, "Milli", millis);
+            sep = ", ";
+        }
+        if (micros > 0) {
+            sb.append(sep).append(micros).append(" ");
+            pluralize(sb, "Micro", micros);
+            sep = ", ";
+        }
+        if (nanos > 0) {
+            sb.append(sep).append(nanos).append(" ");
+            pluralize(sb, "Nano", nanos);
+        }
+        sb.append("}");
+        return sb.toString();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        TimeSpan timeSpan = (TimeSpan) o;
+
+        if (mDurationNanos != timeSpan.mDurationNanos) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        return (int) (mDurationNanos ^ (mDurationNanos >>> 32));
+    }
+
+    private static final void pluralize(StringBuilder sb, String singular, long num) {
+        sb.append(singular);
+        if (num > 1) {
+            sb.append("s");
+        }
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/time/TimeUtil.java b/fbcore/src/main/java/com/facebook/common/time/TimeUtil.java
index 6d0ba464f..22758237c 100644
--- a/fbcore/src/main/java/com/facebook/common/time/TimeUtil.java
+++ b/fbcore/src/main/java/com/facebook/common/time/TimeUtil.java
@@ -18,86 +18,90 @@
  */
 public class TimeUtil {
 
-  private static final long[] TIME_UNITS = {MS_PER_DAY, MS_PER_HOUR, MS_PER_MINUTE, MS_PER_SECOND};
-  private static final String[] TIME_UNITS_ABBR = {"d", "h", "m", "s", "ms"};
+    private static final long[] TIME_UNITS = {MS_PER_DAY, MS_PER_HOUR, MS_PER_MINUTE, MS_PER_SECOND};
+    private static final String[] TIME_UNITS_ABBR = {"d", "h", "m", "s", "ms"};
 
-  /**
-   * The API deals with seconds since the PST epoch, while pretty much everything else deals
-   * with milliseconds since the UTC epoch.
-   * @param utcTime time in milliseconds since the epoch in UTC time
-   * @return time in seconds since the epoch in PST time zone
-   */
-  public static long utcToApiTime(long utcTime) {
-    long apiTimeMs = utcTime + TimeZone.getTimeZone("PST").getRawOffset();
-    return apiTimeMs / MS_PER_SECOND;
-  }
+    /**
+     * The API deals with seconds since the PST epoch, while pretty much everything else deals
+     * with milliseconds since the UTC epoch.
+     *
+     * @param utcTime time in milliseconds since the epoch in UTC time
+     * @return time in seconds since the epoch in PST time zone
+     */
+    public static long utcToApiTime(long utcTime) {
+        long apiTimeMs = utcTime + TimeZone.getTimeZone("PST").getRawOffset();
+        return apiTimeMs / MS_PER_SECOND;
+    }
 
-  /**
-   * The API deals with seconds since the PST epoch, while pretty much everything else deals
-   * with milliseconds since the UTC epoch.
-   * @param apiTime time in seconds since the epoch in PST time zone
-   * @return time in milliseconds since the epoch in UTC time
-   */
-  public static long apiToUtcTime(long apiTime) {
-    long apiTimeMs = apiTime * MS_PER_SECOND;
-    return apiTimeMs - TimeZone.getTimeZone("PST").getRawOffset();
-  }
+    /**
+     * The API deals with seconds since the PST epoch, while pretty much everything else deals
+     * with milliseconds since the UTC epoch.
+     *
+     * @param apiTime time in seconds since the epoch in PST time zone
+     * @return time in milliseconds since the epoch in UTC time
+     */
+    public static long apiToUtcTime(long apiTime) {
+        long apiTimeMs = apiTime * MS_PER_SECOND;
+        return apiTimeMs - TimeZone.getTimeZone("PST").getRawOffset();
+    }
 
-  /**
-   * Converts minutes to milliseconds.
-   * It is implemented because current min API is 8,
-   * but TimeUnit.MINUTES.toMillis was added to API 9.
-   *
-   * @param minutes value to be converted to milliseconds
-   * @return milliseconds converted from given minutes
-   */
-  public static long minutesToMilliseconds(int minutes) {
-    return minutes * MS_PER_MINUTE;
-  }
+    /**
+     * Converts minutes to milliseconds.
+     * It is implemented because current min API is 8,
+     * but TimeUnit.MINUTES.toMillis was added to API 9.
+     *
+     * @param minutes value to be converted to milliseconds
+     * @return milliseconds converted from given minutes
+     */
+    public static long minutesToMilliseconds(int minutes) {
+        return minutes * MS_PER_MINUTE;
+    }
 
-  /**
-   * Converts given time stamp to human readable string based on liveshare_picker_fragmentnow
-   * @param whenMillis time stamp to be converted based on now
-   * @param nowMillis current time stamp
-   * @return human readable string indicating given time based on now
-   */
-  public static String whenFromNow(long whenMillis, long nowMillis) {
-    if (whenMillis == nowMillis) {
-      return "now";
+    /**
+     * Converts given time stamp to human readable string based on liveshare_picker_fragmentnow
+     *
+     * @param whenMillis time stamp to be converted based on now
+     * @param nowMillis  current time stamp
+     * @return human readable string indicating given time based on now
+     */
+    public static String whenFromNow(long whenMillis, long nowMillis) {
+        if (whenMillis == nowMillis) {
+            return "now";
+        }
+        StringBuilder sb = new StringBuilder();
+        String lastWord = (whenMillis > nowMillis) ? "later" : "ago";
+        long diff = Math.abs(whenMillis - nowMillis);
+        sb.append(toHumanReadableTime(diff)).append(' ').append(lastWord);
+        return sb.toString();
     }
-    StringBuilder sb = new StringBuilder();
-    String lastWord = (whenMillis > nowMillis) ? "later" : "ago";
-    long diff = Math.abs(whenMillis - nowMillis);
-    sb.append(toHumanReadableTime(diff)).append(' ').append(lastWord);
-    return sb.toString();
-  }
 
-  /**
-   * Converts given time stamp to human readable string
-   * @param milliseconds time stamp to be converted
-   * @return human readable time
-   */
-  public static String toHumanReadableTime(long milliseconds) {
-    StringBuilder sb = new StringBuilder();
-    int len = TIME_UNITS.length;
-    int i = 0;
-    for ( ; i < len; i++) {
-      long quotient = milliseconds / TIME_UNITS[i];
-      if (quotient > 0) {
+    /**
+     * Converts given time stamp to human readable string
+     *
+     * @param milliseconds time stamp to be converted
+     * @return human readable time
+     */
+    public static String toHumanReadableTime(long milliseconds) {
+        StringBuilder sb = new StringBuilder();
+        int len = TIME_UNITS.length;
+        int i = 0;
+        for (; i < len; i++) {
+            long quotient = milliseconds / TIME_UNITS[i];
+            if (quotient > 0) {
+                if (sb.length() > 0) {
+                    sb.append(' ');
+                }
+                sb.append(quotient).append(TIME_UNITS_ABBR[i]);
+                milliseconds = milliseconds % TIME_UNITS[i];
+            }
+        }
         if (sb.length() > 0) {
-          sb.append(' ');
+            if (milliseconds > 0) {
+                sb.append(' ').append(milliseconds).append(TIME_UNITS_ABBR[i]);
+            }
+        } else {
+            sb.append(milliseconds).append(TIME_UNITS_ABBR[i]);
         }
-        sb.append(quotient).append(TIME_UNITS_ABBR[i]);
-        milliseconds = milliseconds % TIME_UNITS[i];
-      }
-    }
-    if (sb.length() > 0) {
-      if (milliseconds > 0) {
-        sb.append(' ').append(milliseconds).append(TIME_UNITS_ABBR[i]);
-      }
-    } else {
-      sb.append(milliseconds).append(TIME_UNITS_ABBR[i]);
+        return sb.toString();
     }
-    return sb.toString();
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/util/ByteConstants.java b/fbcore/src/main/java/com/facebook/common/util/ByteConstants.java
index 528334dc6..15c87eb2f 100644
--- a/fbcore/src/main/java/com/facebook/common/util/ByteConstants.java
+++ b/fbcore/src/main/java/com/facebook/common/util/ByteConstants.java
@@ -10,9 +10,9 @@
 package com.facebook.common.util;
 
 public class ByteConstants {
-  public static final int KB = 1024;
-  public static final int MB = 1024 * KB;
+    public static final int KB = 1024;
+    public static final int MB = 1024 * KB;
 
-  private ByteConstants() {
-  }
+    private ByteConstants() {
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/util/HashCodeUtil.java b/fbcore/src/main/java/com/facebook/common/util/HashCodeUtil.java
index 36f8e7829..e1f5e540c 100644
--- a/fbcore/src/main/java/com/facebook/common/util/HashCodeUtil.java
+++ b/fbcore/src/main/java/com/facebook/common/util/HashCodeUtil.java
@@ -18,145 +18,145 @@
  */
 public class HashCodeUtil {
 
-  /**
-   * Hash code is computed as value of polynomial whose coefficients are determined by hash codes
-   * of objects passed as parameter to one of hashCode functions. More precisely:
-   * hashCode(o1, o2, ..., on) = P[o1, o2, ..., on](X) =
-   * X^n + o1.hashCode() * X ^ (n - 1) + o2.hashCode() * X ^ (n - 2) + ... + on.hashCode() * X ^ 0
-   *
-   * <p> Constant X determines point at which polynomial is evaluated.
-   */
-  private static final int X = 31;
-
-  public static int hashCode(
-      @Nullable Object o1) {
-    return hashCode(
-        o1 == null ? 0 : o1.hashCode());
-  }
-
-  public static int hashCode(
-      @Nullable Object o1,
-      @Nullable Object o2) {
-    return hashCode(
-        o1 == null ? 0 : o1.hashCode(),
-        o2 == null ? 0 : o2.hashCode());
-  }
-
-  public static int hashCode(
-      @Nullable Object o1,
-      @Nullable Object o2,
-      @Nullable Object o3) {
-    return hashCode(
-        o1 == null ? 0 : o1.hashCode(),
-        o2 == null ? 0 : o2.hashCode(),
-        o3 == null ? 0 : o3.hashCode());
-  }
-
-  public static int hashCode(
-      @Nullable Object o1,
-      @Nullable Object o2,
-      @Nullable Object o3,
-      @Nullable Object o4) {
-    return hashCode(
-        o1 == null ? 0 : o1.hashCode(),
-        o2 == null ? 0 : o2.hashCode(),
-        o3 == null ? 0 : o3.hashCode(),
-        o4 == null ? 0 : o4.hashCode());
-  }
-
-  public static int hashCode(
-      @Nullable Object o1,
-      @Nullable Object o2,
-      @Nullable Object o3,
-      @Nullable Object o4,
-      @Nullable Object o5) {
-    return hashCode(
-        o1 == null ? 0 : o1.hashCode(),
-        o2 == null ? 0 : o2.hashCode(),
-        o3 == null ? 0 : o3.hashCode(),
-        o4 == null ? 0 : o4.hashCode(),
-        o5 == null ? 0 : o5.hashCode());
-  }
-
-  public static int hashCode(
-      @Nullable Object o1,
-      @Nullable Object o2,
-      @Nullable Object o3,
-      @Nullable Object o4,
-      @Nullable Object o5,
-      @Nullable Object o6) {
-    return hashCode(
-        o1 == null ? 0 : o1.hashCode(),
-        o2 == null ? 0 : o2.hashCode(),
-        o3 == null ? 0 : o3.hashCode(),
-        o4 == null ? 0 : o4.hashCode(),
-        o5 == null ? 0 : o5.hashCode(),
-        o6 == null ? 0 : o6.hashCode());
-  }
-
-  public static int hashCode(
-      int i1) {
-    int acc = X + i1;
-    return acc;
-  }
-
-  public static int hashCode(
-      int i1,
-      int i2) {
-    int acc = X + i1;
-    acc = X * acc + i2;
-    return acc;
-  }
-
-  public static int hashCode(
-      int i1,
-      int i2,
-      int i3) {
-    int acc = X + i1;
-    acc = X * acc + i2;
-    acc = X * acc + i3;
-    return acc;
-  }
-
-  public static int hashCode(
-      int i1,
-      int i2,
-      int i3,
-      int i4) {
-    int acc = X + i1;
-    acc = X * acc + i2;
-    acc = X * acc + i3;
-    acc = X * acc + i4;
-    return acc;
-  }
-
-  public static int hashCode(
-      int i1,
-      int i2,
-      int i3,
-      int i4,
-      int i5) {
-    int acc = X + i1;
-    acc = X * acc + i2;
-    acc = X * acc + i3;
-    acc = X * acc + i4;
-    acc = X * acc + i5;
-    return acc;
-  }
-
-  public static int hashCode(
-      int i1,
-      int i2,
-      int i3,
-      int i4,
-      int i5,
-      int i6) {
-    int acc = X + i1;
-    acc = X * acc + i2;
-    acc = X * acc + i3;
-    acc = X * acc + i4;
-    acc = X * acc + i5;
-    acc = X * acc + i6;
-    return acc;
-  }
+    /**
+     * Hash code is computed as value of polynomial whose coefficients are determined by hash codes
+     * of objects passed as parameter to one of hashCode functions. More precisely:
+     * hashCode(o1, o2, ..., on) = P[o1, o2, ..., on](X) =
+     * X^n + o1.hashCode() * X ^ (n - 1) + o2.hashCode() * X ^ (n - 2) + ... + on.hashCode() * X ^ 0
+     * <p>
+     * <p> Constant X determines point at which polynomial is evaluated.
+     */
+    private static final int X = 31;
+
+    public static int hashCode(
+            @Nullable Object o1) {
+        return hashCode(
+                o1 == null ? 0 : o1.hashCode());
+    }
+
+    public static int hashCode(
+            @Nullable Object o1,
+            @Nullable Object o2) {
+        return hashCode(
+                o1 == null ? 0 : o1.hashCode(),
+                o2 == null ? 0 : o2.hashCode());
+    }
+
+    public static int hashCode(
+            @Nullable Object o1,
+            @Nullable Object o2,
+            @Nullable Object o3) {
+        return hashCode(
+                o1 == null ? 0 : o1.hashCode(),
+                o2 == null ? 0 : o2.hashCode(),
+                o3 == null ? 0 : o3.hashCode());
+    }
+
+    public static int hashCode(
+            @Nullable Object o1,
+            @Nullable Object o2,
+            @Nullable Object o3,
+            @Nullable Object o4) {
+        return hashCode(
+                o1 == null ? 0 : o1.hashCode(),
+                o2 == null ? 0 : o2.hashCode(),
+                o3 == null ? 0 : o3.hashCode(),
+                o4 == null ? 0 : o4.hashCode());
+    }
+
+    public static int hashCode(
+            @Nullable Object o1,
+            @Nullable Object o2,
+            @Nullable Object o3,
+            @Nullable Object o4,
+            @Nullable Object o5) {
+        return hashCode(
+                o1 == null ? 0 : o1.hashCode(),
+                o2 == null ? 0 : o2.hashCode(),
+                o3 == null ? 0 : o3.hashCode(),
+                o4 == null ? 0 : o4.hashCode(),
+                o5 == null ? 0 : o5.hashCode());
+    }
+
+    public static int hashCode(
+            @Nullable Object o1,
+            @Nullable Object o2,
+            @Nullable Object o3,
+            @Nullable Object o4,
+            @Nullable Object o5,
+            @Nullable Object o6) {
+        return hashCode(
+                o1 == null ? 0 : o1.hashCode(),
+                o2 == null ? 0 : o2.hashCode(),
+                o3 == null ? 0 : o3.hashCode(),
+                o4 == null ? 0 : o4.hashCode(),
+                o5 == null ? 0 : o5.hashCode(),
+                o6 == null ? 0 : o6.hashCode());
+    }
+
+    public static int hashCode(
+            int i1) {
+        int acc = X + i1;
+        return acc;
+    }
+
+    public static int hashCode(
+            int i1,
+            int i2) {
+        int acc = X + i1;
+        acc = X * acc + i2;
+        return acc;
+    }
+
+    public static int hashCode(
+            int i1,
+            int i2,
+            int i3) {
+        int acc = X + i1;
+        acc = X * acc + i2;
+        acc = X * acc + i3;
+        return acc;
+    }
+
+    public static int hashCode(
+            int i1,
+            int i2,
+            int i3,
+            int i4) {
+        int acc = X + i1;
+        acc = X * acc + i2;
+        acc = X * acc + i3;
+        acc = X * acc + i4;
+        return acc;
+    }
+
+    public static int hashCode(
+            int i1,
+            int i2,
+            int i3,
+            int i4,
+            int i5) {
+        int acc = X + i1;
+        acc = X * acc + i2;
+        acc = X * acc + i3;
+        acc = X * acc + i4;
+        acc = X * acc + i5;
+        return acc;
+    }
+
+    public static int hashCode(
+            int i1,
+            int i2,
+            int i3,
+            int i4,
+            int i5,
+            int i6) {
+        int acc = X + i1;
+        acc = X * acc + i2;
+        acc = X * acc + i3;
+        acc = X * acc + i4;
+        acc = X * acc + i5;
+        acc = X * acc + i6;
+        return acc;
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/util/Hex.java b/fbcore/src/main/java/com/facebook/common/util/Hex.java
index 50aeb7eed..4d19e70a8 100644
--- a/fbcore/src/main/java/com/facebook/common/util/Hex.java
+++ b/fbcore/src/main/java/com/facebook/common/util/Hex.java
@@ -15,125 +15,125 @@
 
 /**
  * Basic hex operations: from byte array to string and vice versa.
- * <p/>
+ * <p>
  * TODO: move to the framework and consider implementing as native code.
  */
 public class Hex {
 
-  private static final char[] HEX_DIGITS = new char[]{
-      '0', '1', '2', '3', '4', '5', '6', '7',
-      '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
-  };
+    private static final char[] HEX_DIGITS = new char[]{
+            '0', '1', '2', '3', '4', '5', '6', '7',
+            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
+    };
 
-  private static final char[] FIRST_CHAR = new char[256];
-  private static final char[] SECOND_CHAR = new char[256];
+    private static final char[] FIRST_CHAR = new char[256];
+    private static final char[] SECOND_CHAR = new char[256];
 
-  static {
-    for (int i = 0; i < 256; i++) {
-      FIRST_CHAR[i] = HEX_DIGITS[(i >> 4) & 0xF];
-      SECOND_CHAR[i] = HEX_DIGITS[i & 0xF];
+    static {
+        for (int i = 0; i < 256; i++) {
+            FIRST_CHAR[i] = HEX_DIGITS[(i >> 4) & 0xF];
+            SECOND_CHAR[i] = HEX_DIGITS[i & 0xF];
+        }
     }
-  }
 
-  private static final byte[] DIGITS = new byte['f' + 1];
-
-  static {
-    for (int i = 0; i <= 'F'; i++) {
-      DIGITS[i] = -1;
-    }
-    for (byte i = 0; i < 10; i++) {
-      DIGITS['0' + i] = i;
-    }
-    for (byte i = 0; i < 6; i++) {
-      DIGITS['A' + i] = (byte) (10 + i);
-      DIGITS['a' + i] = (byte) (10 + i);
-    }
-  }
-
-  /**
-   * Convert an int [0-255] to a hexadecimal string representation.
-   *
-   * @param value int value.
-   */
-  public static String byte2Hex(int value) {
-    if (value > 255 || value < 0) {
-      throw new IllegalArgumentException("The int converting to hex should be in range 0~255");
-    }
-    return String.valueOf(FIRST_CHAR[value]) + String.valueOf(SECOND_CHAR[value]);
-  }
-
-  /**
-   * Quickly converts a byte array to a hexadecimal string representation.
-   *
-   * @param array byte array, possibly zero-terminated.
-   */
-  public static String encodeHex(byte[] array, boolean zeroTerminated) {
-    char[] cArray = new char[array.length * 2];
-
-    int j = 0;
-    for (int i = 0; i < array.length; i++) {
-      int index = array[i] & 0xFF;
-      if (index == 0 && zeroTerminated) {
-        break;
-      }
-
-      cArray[j++] = FIRST_CHAR[index];
-      cArray[j++] = SECOND_CHAR[index];
+    private static final byte[] DIGITS = new byte['f' + 1];
+
+    static {
+        for (int i = 0; i <= 'F'; i++) {
+            DIGITS[i] = -1;
+        }
+        for (byte i = 0; i < 10; i++) {
+            DIGITS['0' + i] = i;
+        }
+        for (byte i = 0; i < 6; i++) {
+            DIGITS['A' + i] = (byte) (10 + i);
+            DIGITS['a' + i] = (byte) (10 + i);
+        }
     }
 
-    return new String(cArray, 0, j);
-  }
-
-  /**
-   * Quickly converts a hexadecimal string to a byte array.
-   */
-  public static byte[] decodeHex(String hexString) {
-    int length = hexString.length();
-
-    if ((length & 0x01) != 0) {
-      throw new IllegalArgumentException("Odd number of characters.");
+    /**
+     * Convert an int [0-255] to a hexadecimal string representation.
+     *
+     * @param value int value.
+     */
+    public static String byte2Hex(int value) {
+        if (value > 255 || value < 0) {
+            throw new IllegalArgumentException("The int converting to hex should be in range 0~255");
+        }
+        return String.valueOf(FIRST_CHAR[value]) + String.valueOf(SECOND_CHAR[value]);
     }
 
-    boolean badHex = false;
-    byte[] out = new byte[length >> 1];
-    for (int i = 0, j = 0; j < length; i++) {
-      int c1 = hexString.charAt(j++);
-      if (c1 > 'f') {
-        badHex = true;
-        break;
-      }
-
-      final byte d1 = DIGITS[c1];
-      if (d1 == -1) {
-        badHex = true;
-        break;
-      }
-
-      int c2 = hexString.charAt(j++);
-      if (c2 > 'f') {
-        badHex = true;
-        break;
-      }
-
-      final byte d2 = DIGITS[c2];
-      if (d2 == -1) {
-        badHex = true;
-        break;
-      }
-
-      out[i] = (byte) (d1 << 4 | d2);
+    /**
+     * Quickly converts a byte array to a hexadecimal string representation.
+     *
+     * @param array byte array, possibly zero-terminated.
+     */
+    public static String encodeHex(byte[] array, boolean zeroTerminated) {
+        char[] cArray = new char[array.length * 2];
+
+        int j = 0;
+        for (int i = 0; i < array.length; i++) {
+            int index = array[i] & 0xFF;
+            if (index == 0 && zeroTerminated) {
+                break;
+            }
+
+            cArray[j++] = FIRST_CHAR[index];
+            cArray[j++] = SECOND_CHAR[index];
+        }
+
+        return new String(cArray, 0, j);
     }
 
-    if (badHex) {
-      throw new IllegalArgumentException("Invalid hexadecimal digit: " + hexString);
+    /**
+     * Quickly converts a hexadecimal string to a byte array.
+     */
+    public static byte[] decodeHex(String hexString) {
+        int length = hexString.length();
+
+        if ((length & 0x01) != 0) {
+            throw new IllegalArgumentException("Odd number of characters.");
+        }
+
+        boolean badHex = false;
+        byte[] out = new byte[length >> 1];
+        for (int i = 0, j = 0; j < length; i++) {
+            int c1 = hexString.charAt(j++);
+            if (c1 > 'f') {
+                badHex = true;
+                break;
+            }
+
+            final byte d1 = DIGITS[c1];
+            if (d1 == -1) {
+                badHex = true;
+                break;
+            }
+
+            int c2 = hexString.charAt(j++);
+            if (c2 > 'f') {
+                badHex = true;
+                break;
+            }
+
+            final byte d2 = DIGITS[c2];
+            if (d2 == -1) {
+                badHex = true;
+                break;
+            }
+
+            out[i] = (byte) (d1 << 4 | d2);
+        }
+
+        if (badHex) {
+            throw new IllegalArgumentException("Invalid hexadecimal digit: " + hexString);
+        }
+
+        return out;
     }
 
-    return out;
-  }
-
-  public static byte[] hexStringToByteArray(String s) {
-    String noSpaceString = s.replaceAll(" ", "");
-    byte[] data = decodeHex(noSpaceString);
-    return data;
-  }
+    public static byte[] hexStringToByteArray(String s) {
+        String noSpaceString = s.replaceAll(" ", "");
+        byte[] data = decodeHex(noSpaceString);
+        return data;
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/util/SecureHashUtil.java b/fbcore/src/main/java/com/facebook/common/util/SecureHashUtil.java
index 82fc8bfa9..19f5a56fd 100644
--- a/fbcore/src/main/java/com/facebook/common/util/SecureHashUtil.java
+++ b/fbcore/src/main/java/com/facebook/common/util/SecureHashUtil.java
@@ -20,73 +20,73 @@
  */
 public class SecureHashUtil {
 
-  public static String makeSHA1Hash(String text) {
-    try {
-      return makeSHA1Hash(text.getBytes("utf-8"));
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(e);
+    public static String makeSHA1Hash(String text) {
+        try {
+            return makeSHA1Hash(text.getBytes("utf-8"));
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(e);
+        }
     }
-  }
 
-  public static String makeSHA1Hash(byte[] bytes) {
-    try {
-      MessageDigest md = MessageDigest.getInstance("SHA-1");
-      md.update(bytes, 0, bytes.length);
-      byte[] sha1hash = md.digest();
-      return convertToHex(sha1hash);
-    } catch (NoSuchAlgorithmException e) {
-      throw new RuntimeException(e);
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(e);
+    public static String makeSHA1Hash(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA-1");
+            md.update(bytes, 0, bytes.length);
+            byte[] sha1hash = md.digest();
+            return convertToHex(sha1hash);
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(e);
+        }
     }
-  }
 
-  public static String makeSHA1HashBase64(byte[] bytes) {
-    try {
-      MessageDigest md = MessageDigest.getInstance("SHA-1");
-      md.update(bytes, 0, bytes.length);
-      byte[] sha1hash = md.digest();
-      return Base64.encodeToString(sha1hash, Base64.URL_SAFE | Base64.NO_PADDING | Base64.NO_WRAP);
-    } catch (NoSuchAlgorithmException e) {
-      throw new RuntimeException(e);
+    public static String makeSHA1HashBase64(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA-1");
+            md.update(bytes, 0, bytes.length);
+            byte[] sha1hash = md.digest();
+            return Base64.encodeToString(sha1hash, Base64.URL_SAFE | Base64.NO_PADDING | Base64.NO_WRAP);
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        }
     }
-  }
 
-  public static String makeMD5Hash(String text) {
-    try {
-      return makeMD5Hash(text.getBytes("utf-8"));
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(e);
+    public static String makeMD5Hash(String text) {
+        try {
+            return makeMD5Hash(text.getBytes("utf-8"));
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(e);
+        }
     }
-  }
 
-  public static String makeMD5Hash(byte[] bytes) {
-    try {
-      MessageDigest md = MessageDigest.getInstance("MD5");
-      md.update(bytes, 0, bytes.length);
-      byte[] sha1hash = md.digest();
-      return convertToHex(sha1hash);
-    } catch (NoSuchAlgorithmException e) {
-      throw new RuntimeException(e);
-    } catch (UnsupportedEncodingException e) {
-      throw new RuntimeException(e);
+    public static String makeMD5Hash(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("MD5");
+            md.update(bytes, 0, bytes.length);
+            byte[] sha1hash = md.digest();
+            return convertToHex(sha1hash);
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(e);
+        }
     }
-  }
 
-  static final byte[] HEX_CHAR_TABLE = {
-      (byte) '0', (byte) '1', (byte) '2', (byte) '3',
-      (byte) '4', (byte) '5', (byte) '6', (byte) '7',
-      (byte) '8', (byte) '9', (byte) 'a', (byte) 'b',
-      (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f'
-  };
+    static final byte[] HEX_CHAR_TABLE = {
+            (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+            (byte) '4', (byte) '5', (byte) '6', (byte) '7',
+            (byte) '8', (byte) '9', (byte) 'a', (byte) 'b',
+            (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f'
+    };
 
-  private static String convertToHex(byte[] raw) throws UnsupportedEncodingException {
-    StringBuilder sb = new StringBuilder(raw.length);
-    for (byte b : raw) {
-      int v = b & 0xFF;
-      sb.append((char) HEX_CHAR_TABLE[v >>> 4]);
-      sb.append((char) HEX_CHAR_TABLE[v & 0xF]);
+    private static String convertToHex(byte[] raw) throws UnsupportedEncodingException {
+        StringBuilder sb = new StringBuilder(raw.length);
+        for (byte b : raw) {
+            int v = b & 0xFF;
+            sb.append((char) HEX_CHAR_TABLE[v >>> 4]);
+            sb.append((char) HEX_CHAR_TABLE[v & 0xF]);
+        }
+        return sb.toString();
     }
-    return sb.toString();
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/util/StreamUtil.java b/fbcore/src/main/java/com/facebook/common/util/StreamUtil.java
index 9d6f93a19..8c2f7d0db 100644
--- a/fbcore/src/main/java/com/facebook/common/util/StreamUtil.java
+++ b/fbcore/src/main/java/com/facebook/common/util/StreamUtil.java
@@ -21,65 +21,66 @@
  */
 public class StreamUtil {
 
-  /**
-   * Efficiently fetch bytes from InputStream is by delegating to
-   * getBytesFromStream(is, is.available())
-   */
-  public static byte[] getBytesFromStream(final InputStream is) throws IOException {
-    return getBytesFromStream(is, is.available());
-  }
+    /**
+     * Efficiently fetch bytes from InputStream is by delegating to
+     * getBytesFromStream(is, is.available())
+     */
+    public static byte[] getBytesFromStream(final InputStream is) throws IOException {
+        return getBytesFromStream(is, is.available());
+    }
 
-  /**
-   * Efficiently fetch the bytes from the InputStream, provided that caller can guess
-   * exact numbers of bytes that can be read from inputStream. Avoids one extra byte[] allocation
-   * that ByteStreams.toByteArray() performs.
-   * @param hint - size of inputStream's content in bytes
-   */
-  public static byte[] getBytesFromStream(InputStream inputStream, int hint) throws IOException {
-    // Subclass ByteArrayOutputStream to avoid an extra byte[] allocation and copy
-    ByteArrayOutputStream byteOutput = new ByteArrayOutputStream(hint) {
-      @Override
-      public byte[] toByteArray() {
-        // Can only use the raw buffer directly if the size is equal to the array we have.
-        // Otherwise we have no choice but to copy.
-        if (count == buf.length) {
-          return buf;
-        } else {
-          return super.toByteArray();
-        }
-      }
-    };
-    ByteStreams.copy(inputStream, byteOutput);
-    return byteOutput.toByteArray();
-  }
+    /**
+     * Efficiently fetch the bytes from the InputStream, provided that caller can guess
+     * exact numbers of bytes that can be read from inputStream. Avoids one extra byte[] allocation
+     * that ByteStreams.toByteArray() performs.
+     *
+     * @param hint - size of inputStream's content in bytes
+     */
+    public static byte[] getBytesFromStream(InputStream inputStream, int hint) throws IOException {
+        // Subclass ByteArrayOutputStream to avoid an extra byte[] allocation and copy
+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream(hint) {
+            @Override
+            public byte[] toByteArray() {
+                // Can only use the raw buffer directly if the size is equal to the array we have.
+                // Otherwise we have no choice but to copy.
+                if (count == buf.length) {
+                    return buf;
+                } else {
+                    return super.toByteArray();
+                }
+            }
+        };
+        ByteStreams.copy(inputStream, byteOutput);
+        return byteOutput.toByteArray();
+    }
 
-  /**
-   * Skips exactly bytesCount bytes in inputStream unless end of stream is reached first.
-   *
-   * @param inputStream input stream to skip bytes from
-   * @param bytesCount number of bytes to skip
-   * @return number of skipped bytes
-   * @throws IOException
-   */
-  public static long skip(final InputStream inputStream, final long bytesCount) throws IOException {
-    Preconditions.checkNotNull(inputStream);
-    Preconditions.checkArgument(bytesCount >= 0);
+    /**
+     * Skips exactly bytesCount bytes in inputStream unless end of stream is reached first.
+     *
+     * @param inputStream input stream to skip bytes from
+     * @param bytesCount  number of bytes to skip
+     * @return number of skipped bytes
+     * @throws IOException
+     */
+    public static long skip(final InputStream inputStream, final long bytesCount) throws IOException {
+        Preconditions.checkNotNull(inputStream);
+        Preconditions.checkArgument(bytesCount >= 0);
 
-    long toSkip = bytesCount;
-    while (toSkip > 0) {
-      final long skipped = inputStream.skip(toSkip);
-      if (skipped > 0) {
-        toSkip -= skipped;
-        continue;
-      }
+        long toSkip = bytesCount;
+        while (toSkip > 0) {
+            final long skipped = inputStream.skip(toSkip);
+            if (skipped > 0) {
+                toSkip -= skipped;
+                continue;
+            }
 
-      if (inputStream.read() != -1) {
-        toSkip--;
-        continue;
-      }
-      return bytesCount - toSkip;
-    }
+            if (inputStream.read() != -1) {
+                toSkip--;
+                continue;
+            }
+            return bytesCount - toSkip;
+        }
 
-    return bytesCount;
-  }
+        return bytesCount;
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/util/TriState.java b/fbcore/src/main/java/com/facebook/common/util/TriState.java
index cf56a3154..99d2f9771 100644
--- a/fbcore/src/main/java/com/facebook/common/util/TriState.java
+++ b/fbcore/src/main/java/com/facebook/common/util/TriState.java
@@ -13,118 +13,119 @@
  * Generic tri-state enum for boolean values that can also be unset.
  */
 public enum TriState {
-  YES,
-  NO,
-  UNSET,
-  ;
+    YES,
+    NO,
+    UNSET,;
 
-  /** @return whether this value is set; that is, whether it is YES or NO. */
-  public boolean isSet() {
-    return this != UNSET;
-  }
+    /**
+     * @return whether this value is set; that is, whether it is YES or NO.
+     */
+    public boolean isSet() {
+        return this != UNSET;
+    }
 
-  /**
-   * Returns the value of the {@link TriState} enum that corresponds to the specified
-   * {@code boolean}.
-   * <p>
-   * This method deliberately declares {@code boolean} as its param type rather than {@link Boolean}
-   * because:
-   * <ol>
-   *   <li>Declaring {@link Boolean} would likely result in a bunch of unnecessary autoboxing.
-   *   <li>Anyone who finds himself using a {@link Boolean} instead of a {@code boolean} for its
-   *       nullability should replace the {@link Boolean} with a {@link TriState}, anyway.
-   * </ol>
-   */
-  public static TriState valueOf(boolean bool) {
-    return bool ? YES : NO;
-  }
+    /**
+     * Returns the value of the {@link TriState} enum that corresponds to the specified
+     * {@code boolean}.
+     * <p>
+     * This method deliberately declares {@code boolean} as its param type rather than {@link Boolean}
+     * because:
+     * <ol>
+     * <li>Declaring {@link Boolean} would likely result in a bunch of unnecessary autoboxing.
+     * <li>Anyone who finds himself using a {@link Boolean} instead of a {@code boolean} for its
+     * nullability should replace the {@link Boolean} with a {@link TriState}, anyway.
+     * </ol>
+     */
+    public static TriState valueOf(boolean bool) {
+        return bool ? YES : NO;
+    }
 
-  public static TriState valueOf(Boolean bool) {
-    return bool != null ? valueOf(bool.booleanValue()) : TriState.UNSET;
-  }
+    public static TriState valueOf(Boolean bool) {
+        return bool != null ? valueOf(bool.booleanValue()) : TriState.UNSET;
+    }
 
-  /**
-   * Returns the {@code boolean} value that corresponds to this {@link TriState}, if appropriate.
-   *
-   * @return {@code true} if {@code this} is {@link TriState#YES} or
-   *     {@code false} if {@code this} is {@link TriState#NO}
-   * @throws IllegalStateException if {@code this} is {@link TriState#UNSET}.
-   */
-  public boolean asBoolean() {
-    switch (this) {
-      case YES:
-        return true;
-      case NO:
-        return false;
-      case UNSET:
-        throw new IllegalStateException("No boolean equivalent for UNSET");
-      default:
-        throw new IllegalStateException("Unrecognized TriState value: " + this);
+    /**
+     * Returns the {@code boolean} value that corresponds to this {@link TriState}, if appropriate.
+     *
+     * @return {@code true} if {@code this} is {@link TriState#YES} or
+     * {@code false} if {@code this} is {@link TriState#NO}
+     * @throws IllegalStateException if {@code this} is {@link TriState#UNSET}.
+     */
+    public boolean asBoolean() {
+        switch (this) {
+            case YES:
+                return true;
+            case NO:
+                return false;
+            case UNSET:
+                throw new IllegalStateException("No boolean equivalent for UNSET");
+            default:
+                throw new IllegalStateException("Unrecognized TriState value: " + this);
+        }
     }
-  }
 
-  /**
-   * Returns the {@code boolean} value that corresponds to this {@link TriState}, if appropriate.
-   *
-   * @param defaultValue default value to use if not set
-   * @return {@code true} if {@code this} is {@link TriState#YES} or
-   *     {@code false} if {@code this} is {@link TriState#NO} or {@code defaultValue} if
-   *     {@code this} is {@link TriState#UNSET}.
-   */
-  public boolean asBoolean(boolean defaultValue) {
-    switch (this) {
-      case YES:
-        return true;
-      case NO:
-        return false;
-      case UNSET:
-        return defaultValue;
-      default:
-        throw new IllegalStateException("Unrecognized TriState value: " + this);
+    /**
+     * Returns the {@code boolean} value that corresponds to this {@link TriState}, if appropriate.
+     *
+     * @param defaultValue default value to use if not set
+     * @return {@code true} if {@code this} is {@link TriState#YES} or
+     * {@code false} if {@code this} is {@link TriState#NO} or {@code defaultValue} if
+     * {@code this} is {@link TriState#UNSET}.
+     */
+    public boolean asBoolean(boolean defaultValue) {
+        switch (this) {
+            case YES:
+                return true;
+            case NO:
+                return false;
+            case UNSET:
+                return defaultValue;
+            default:
+                throw new IllegalStateException("Unrecognized TriState value: " + this);
+        }
     }
-  }
 
-  /**
-   * Returns the {@code Boolean} value that corresponds to this {@link TriState}, if appropriate.
-   *
-   * @return {@link Boolean#TRUE} if {@code this} is {@link TriState#YES} or
-   *     {@link Boolean#FALSE} if {@code this} is {@link TriState#NO} or {@code null} if
-   *     {@code this} is {@link TriState#UNSET}.
-   */
-  public Boolean asBooleanObject() {
-    switch (this) {
-      case YES:
-        return Boolean.TRUE;
-      case NO:
-        return Boolean.FALSE;
-      case UNSET:
-        return null;
-      default:
-        throw new IllegalStateException("Unrecognized TriState value: " + this);
+    /**
+     * Returns the {@code Boolean} value that corresponds to this {@link TriState}, if appropriate.
+     *
+     * @return {@link Boolean#TRUE} if {@code this} is {@link TriState#YES} or
+     * {@link Boolean#FALSE} if {@code this} is {@link TriState#NO} or {@code null} if
+     * {@code this} is {@link TriState#UNSET}.
+     */
+    public Boolean asBooleanObject() {
+        switch (this) {
+            case YES:
+                return Boolean.TRUE;
+            case NO:
+                return Boolean.FALSE;
+            case UNSET:
+                return null;
+            default:
+                throw new IllegalStateException("Unrecognized TriState value: " + this);
+        }
     }
-  }
 
-  public int getDbValue() {
-    switch (this) {
-      case YES:
-        return 1;
-      case NO:
-        return 2;
-      case UNSET:
-      default:
-        return 3;
+    public int getDbValue() {
+        switch (this) {
+            case YES:
+                return 1;
+            case NO:
+                return 2;
+            case UNSET:
+            default:
+                return 3;
+        }
     }
-  }
 
-  public static TriState fromDbValue(int value) {
-    switch (value) {
-      case 1:
-        return YES;
-      case 2:
-        return NO;
-      case 3:
-      default:
-        return UNSET;
+    public static TriState fromDbValue(int value) {
+        switch (value) {
+            case 1:
+                return YES;
+            case 2:
+                return NO;
+            case 3:
+            default:
+                return UNSET;
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/common/util/UriUtil.java b/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
index 0cdeb59aa..ea57fe2b6 100644
--- a/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
+++ b/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
@@ -15,104 +15,104 @@
 
 public class UriUtil {
 
-  /**
-   * http scheme for URIs
-   */
-  public static final String HTTP_SCHEME = "http";
-  public static final String HTTPS_SCHEME = "https";
-
-  /**
-   * File scheme for URIs
-   */
-  public static final String LOCAL_FILE_SCHEME = "file";
-
-  /**
-   * Content URI scheme for URIs
-   */
-  public static final String LOCAL_CONTENT_SCHEME = "content";
-
-  /**
-   * Asset scheme for URIs
-   */
-  public static final String LOCAL_ASSET_SCHEME = "asset";
-
-  /**
-   * Resource scheme for URIs
-   */
-  public static final String LOCAL_RESOURCE_SCHEME = "res";
-
-  /**
-   * /**
-   * Check if uri represents network resource
-   *
-   * @param uri uri to check
-   * @return true if uri's scheme is equal to "http" or "https"
-   */
-  public static boolean isNetworkUri(@Nullable Uri uri) {
-    final String scheme = getSchemeOrNull(uri);
-    return HTTPS_SCHEME.equals(scheme) || HTTP_SCHEME.equals(scheme);
-  }
-
-  /**
-   * Check if uri represents local file
-   *
-   * @param uri uri to check
-   * @return true if uri's scheme is equal to "file"
-   */
-  public static boolean isLocalFileUri(@Nullable Uri uri) {
-    final String scheme = getSchemeOrNull(uri);
-    return LOCAL_FILE_SCHEME.equals(scheme);
-  }
-
-  /**
-   * Check if uri represents local content
-   *
-   * @param uri uri to check
-   * @return true if uri's scheme is equal to "content"
-   */
-  public static boolean isLocalContentUri(@Nullable Uri uri) {
-    final String scheme = getSchemeOrNull(uri);
-    return LOCAL_CONTENT_SCHEME.equals(scheme);
-  }
-
-  /**
-   * Check if uri represents local asset
-   *
-   * @param uri uri to check
-   * @return true if uri's scheme is equal to "asset"
-   */
-  public static boolean isLocalAssetUri(@Nullable Uri uri) {
-    final String scheme = getSchemeOrNull(uri);
-    return LOCAL_ASSET_SCHEME.equals(scheme);
-  }
-
-  /**
-   * Check if uri represents local resource
-   *
-   * @param uri uri to check
-   * @return true if uri's scheme is equal to {@link #LOCAL_RESOURCE_SCHEME}
-   */
-  public static boolean isLocalResourceUri(@Nullable Uri uri) {
-    final String scheme = getSchemeOrNull(uri);
-    return LOCAL_RESOURCE_SCHEME.equals(scheme);
-  }
-
-  /**
-   * @param uri uri to extract scheme from, possibly null
-   * @return null if uri is null, result of uri.getScheme() otherwise
-   */
-  @Nullable
-  public static String getSchemeOrNull(@Nullable Uri uri) {
-    return uri == null ? null : uri.getScheme();
-  }
-
-  /**
-   * A wrapper around {@link Uri#parse} that returns null if the input is null.
-   *
-   * @param uriAsString the uri as a string
-   * @return the parsed Uri or null if the input was null
-   */
-  public static Uri parseUriOrNull(@Nullable String uriAsString) {
-    return uriAsString != null ? Uri.parse(uriAsString) : null;
-  }
+    /**
+     * http scheme for URIs
+     */
+    public static final String HTTP_SCHEME = "http";
+    public static final String HTTPS_SCHEME = "https";
+
+    /**
+     * File scheme for URIs
+     */
+    public static final String LOCAL_FILE_SCHEME = "file";
+
+    /**
+     * Content URI scheme for URIs
+     */
+    public static final String LOCAL_CONTENT_SCHEME = "content";
+
+    /**
+     * Asset scheme for URIs
+     */
+    public static final String LOCAL_ASSET_SCHEME = "asset";
+
+    /**
+     * Resource scheme for URIs
+     */
+    public static final String LOCAL_RESOURCE_SCHEME = "res";
+
+    /**
+     * /**
+     * Check if uri represents network resource
+     *
+     * @param uri uri to check
+     * @return true if uri's scheme is equal to "http" or "https"
+     */
+    public static boolean isNetworkUri(@Nullable Uri uri) {
+        final String scheme = getSchemeOrNull(uri);
+        return HTTPS_SCHEME.equals(scheme) || HTTP_SCHEME.equals(scheme);
+    }
+
+    /**
+     * Check if uri represents local file
+     *
+     * @param uri uri to check
+     * @return true if uri's scheme is equal to "file"
+     */
+    public static boolean isLocalFileUri(@Nullable Uri uri) {
+        final String scheme = getSchemeOrNull(uri);
+        return LOCAL_FILE_SCHEME.equals(scheme);
+    }
+
+    /**
+     * Check if uri represents local content
+     *
+     * @param uri uri to check
+     * @return true if uri's scheme is equal to "content"
+     */
+    public static boolean isLocalContentUri(@Nullable Uri uri) {
+        final String scheme = getSchemeOrNull(uri);
+        return LOCAL_CONTENT_SCHEME.equals(scheme);
+    }
+
+    /**
+     * Check if uri represents local asset
+     *
+     * @param uri uri to check
+     * @return true if uri's scheme is equal to "asset"
+     */
+    public static boolean isLocalAssetUri(@Nullable Uri uri) {
+        final String scheme = getSchemeOrNull(uri);
+        return LOCAL_ASSET_SCHEME.equals(scheme);
+    }
+
+    /**
+     * Check if uri represents local resource
+     *
+     * @param uri uri to check
+     * @return true if uri's scheme is equal to {@link #LOCAL_RESOURCE_SCHEME}
+     */
+    public static boolean isLocalResourceUri(@Nullable Uri uri) {
+        final String scheme = getSchemeOrNull(uri);
+        return LOCAL_RESOURCE_SCHEME.equals(scheme);
+    }
+
+    /**
+     * @param uri uri to extract scheme from, possibly null
+     * @return null if uri is null, result of uri.getScheme() otherwise
+     */
+    @Nullable
+    public static String getSchemeOrNull(@Nullable Uri uri) {
+        return uri == null ? null : uri.getScheme();
+    }
+
+    /**
+     * A wrapper around {@link Uri#parse} that returns null if the input is null.
+     *
+     * @param uriAsString the uri as a string
+     * @return the parsed Uri or null if the input was null
+     */
+    public static Uri parseUriOrNull(@Nullable String uriAsString) {
+        return uriAsString != null ? Uri.parse(uriAsString) : null;
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/datasource/AbstractDataSource.java b/fbcore/src/main/java/com/facebook/datasource/AbstractDataSource.java
index 4c1d065d0..35909b73b 100644
--- a/fbcore/src/main/java/com/facebook/datasource/AbstractDataSource.java
+++ b/fbcore/src/main/java/com/facebook/datasource/AbstractDataSource.java
@@ -21,307 +21,309 @@
 
 /**
  * An abstract implementation of {@link DataSource} interface.
- *
+ * <p>
  * <p> It is highly recommended that other data sources extend this class as it takes care of the
  * state, as well as of notifying listeners when the state changes.
- *
+ * <p>
  * <p> Subclasses should override {@link #closeResult(T result)} if results need clean up
  *
  * @param <T>
  */
 public abstract class AbstractDataSource<T> implements DataSource<T> {
-  /**
-   * Describes state of data source
-   */
-  private enum DataSourceStatus {
-    // data source has not finished yet
-    IN_PROGRESS,
-
-    // data source has finished with success
-    SUCCESS,
-
-    // data source has finished with failure
-    FAILURE,
-  }
-
-  @GuardedBy("this")
-  private DataSourceStatus mDataSourceStatus;
-  @GuardedBy("this")
-  private boolean mIsClosed;
-  @GuardedBy("this")
-  private @Nullable T mResult = null;
-  @GuardedBy("this")
-  private Throwable mFailureThrowable = null;
-  @GuardedBy("this")
-  private float mProgress = 0;
-  private final ConcurrentLinkedQueue<Pair<DataSubscriber<T>, Executor>> mSubscribers;
-
-  protected AbstractDataSource() {
-    mIsClosed = false;
-    mDataSourceStatus = DataSourceStatus.IN_PROGRESS;
-    mSubscribers = new ConcurrentLinkedQueue<Pair<DataSubscriber<T>, Executor>>();
-  }
-
-  @Override
-  public synchronized boolean isClosed() {
-    return mIsClosed;
-  }
-
-  @Override
-  public synchronized boolean isFinished() {
-    return mDataSourceStatus != DataSourceStatus.IN_PROGRESS;
-  }
-
-  @Override
-  public synchronized boolean hasResult() {
-    return mResult != null;
-  }
-
-  @Override
-  @Nullable
-  public synchronized T getResult() {
-    return mResult;
-  }
-
-  @Override
-  public synchronized boolean hasFailed() {
-    return mDataSourceStatus == DataSourceStatus.FAILURE;
-  }
-
-  @Override
-  @Nullable
-  public synchronized Throwable getFailureCause() {
-    return mFailureThrowable;
-  }
-
-  @Override
-  public synchronized float getProgress() {
-    return mProgress;
-  }
-
-  @Override
-  public boolean close() {
-    T resultToClose;
-    synchronized (this) {
-      if (mIsClosed) {
-        return false;
-      }
-      mIsClosed = true;
-      resultToClose = mResult;
-      mResult = null;
+    /**
+     * Describes state of data source
+     */
+    private enum DataSourceStatus {
+        // data source has not finished yet
+        IN_PROGRESS,
+
+        // data source has finished with success
+        SUCCESS,
+
+        // data source has finished with failure
+        FAILURE,
+    }
+
+    @GuardedBy("this")
+    private DataSourceStatus mDataSourceStatus;
+    @GuardedBy("this")
+    private boolean mIsClosed;
+    @GuardedBy("this")
+    private
+    @Nullable
+    T mResult = null;
+    @GuardedBy("this")
+    private Throwable mFailureThrowable = null;
+    @GuardedBy("this")
+    private float mProgress = 0;
+    private final ConcurrentLinkedQueue<Pair<DataSubscriber<T>, Executor>> mSubscribers;
+
+    protected AbstractDataSource() {
+        mIsClosed = false;
+        mDataSourceStatus = DataSourceStatus.IN_PROGRESS;
+        mSubscribers = new ConcurrentLinkedQueue<Pair<DataSubscriber<T>, Executor>>();
     }
-    if (resultToClose != null) {
-      closeResult(resultToClose);
+
+    @Override
+    public synchronized boolean isClosed() {
+        return mIsClosed;
+    }
+
+    @Override
+    public synchronized boolean isFinished() {
+        return mDataSourceStatus != DataSourceStatus.IN_PROGRESS;
     }
-    if (!isFinished()) {
-      notifyDataSubscribers();
+
+    @Override
+    public synchronized boolean hasResult() {
+        return mResult != null;
     }
-    synchronized (this) {
-      mSubscribers.clear();
+
+    @Override
+    @Nullable
+    public synchronized T getResult() {
+        return mResult;
     }
-    return true;
-  }
-
-  /**
-   * Subclasses should override this method to close the result that is not needed anymore.
-   *
-   * <p> This method is called in two cases:
-   * 1. to clear the result when data source gets closed
-   * 2. to clear the previous result when a new result is set
-   */
-  protected void closeResult(@Nullable T result) {
-    // default implementation does nothing
-  }
-
-  @Override
-  public void subscribe(final DataSubscriber<T> dataSubscriber, final Executor executor) {
-    Preconditions.checkNotNull(dataSubscriber);
-    Preconditions.checkNotNull(executor);
-    boolean shouldNotify;
-
-    synchronized(this) {
-      if (mIsClosed) {
-        return;
-      }
-
-      if (mDataSourceStatus == DataSourceStatus.IN_PROGRESS) {
-        mSubscribers.add(Pair.create(dataSubscriber, executor));
-      }
-
-      shouldNotify = hasResult() || isFinished() || wasCancelled();
+
+    @Override
+    public synchronized boolean hasFailed() {
+        return mDataSourceStatus == DataSourceStatus.FAILURE;
     }
 
-    if (shouldNotify) {
-      notifyDataSubscriber(dataSubscriber, executor, hasFailed(), wasCancelled());
+    @Override
+    @Nullable
+    public synchronized Throwable getFailureCause() {
+        return mFailureThrowable;
     }
-  }
 
-  private void notifyDataSubscribers() {
-    final boolean isFailure = hasFailed();
-    final boolean isCancellation = wasCancelled();
-    for (Pair<DataSubscriber<T>, Executor> pair : mSubscribers) {
-      notifyDataSubscriber(pair.first, pair.second, isFailure, isCancellation);
+    @Override
+    public synchronized float getProgress() {
+        return mProgress;
     }
-  }
-
-  private void notifyDataSubscriber(
-      final DataSubscriber<T> dataSubscriber,
-      final Executor executor,
-      final boolean isFailure,
-      final boolean isCancellation) {
-    executor.execute(
-        new Runnable() {
-          @Override
-          public void run() {
-            if (isFailure) {
-              dataSubscriber.onFailure(AbstractDataSource.this);
-            } else if (isCancellation) {
-              dataSubscriber.onCancellation(AbstractDataSource.this);
-            } else {
-              dataSubscriber.onNewResult(AbstractDataSource.this);
+
+    @Override
+    public boolean close() {
+        T resultToClose;
+        synchronized (this) {
+            if (mIsClosed) {
+                return false;
             }
-          }
-        });
-  }
-
-  private synchronized boolean wasCancelled() {
-    return isClosed() && !isFinished();
-  }
-
-  /**
-   * Subclasses should invoke this method to set the result to {@code value}.
-   *
-   * <p> This method will return {@code true} if the value was successfully set, or
-   * {@code false} if the data source has already been set, failed or closed.
-   *
-   * <p> If the value was successfully set and {@code isLast} is {@code true}, state of the
-   * data source will be set to {@link AbstractDataSource.DataSourceStatus#SUCCESS}.
-   *
-   * <p> {@link #closeResult} will be called for the previous result if the new value was
-   * successfully set, OR for the new result otherwise.
-   *
-   * <p> This will also notify the subscribers if the value was successfully set.
-   *
-   * <p> Do NOT call this method from a synchronized block as it invokes external code of the
-   * subscribers.
-   *
-   * @param value the value that was the result of the task.
-   * @param isLast whether or not the value is last.
-   * @return true if the value was successfully set.
-   */
-  protected boolean setResult(@Nullable T value, boolean isLast) {
-    boolean result = setResultInternal(value, isLast);
-    if (result) {
-      notifyDataSubscribers();
+            mIsClosed = true;
+            resultToClose = mResult;
+            mResult = null;
+        }
+        if (resultToClose != null) {
+            closeResult(resultToClose);
+        }
+        if (!isFinished()) {
+            notifyDataSubscribers();
+        }
+        synchronized (this) {
+            mSubscribers.clear();
+        }
+        return true;
     }
-    return result;
-  }
-
-  /**
-   * Subclasses should invoke this method to set the failure.
-   *
-   * <p> This method will return {@code true} if the failure was successfully set, or
-   * {@code false} if the data source has already been set, failed or closed.
-   *
-   * <p> If the failure was successfully set, state of the data source will be set to
-   * {@link AbstractDataSource.DataSourceStatus#FAILURE}.
-   *
-   * <p> This will also notify the subscribers if the failure was successfully set.
-   *
-   * <p> Do NOT call this method from a synchronized block as it invokes external code of the
-   * subscribers.
-   *
-   * @param throwable the failure cause to be set.
-   * @return true if the failure was successfully set.
-   */
-  protected boolean setFailure(Throwable throwable) {
-    boolean result = setFailureInternal(throwable);
-    if (result) {
-      notifyDataSubscribers();
+
+    /**
+     * Subclasses should override this method to close the result that is not needed anymore.
+     * <p>
+     * <p> This method is called in two cases:
+     * 1. to clear the result when data source gets closed
+     * 2. to clear the previous result when a new result is set
+     */
+    protected void closeResult(@Nullable T result) {
+        // default implementation does nothing
     }
-    return result;
-  }
-
-  /**
-   * Subclasses should invoke this method to set the progress.
-   *
-   * <p> This method will return {@code true} if the progress was successfully set, or
-   * {@code false} if the data source has already been set, failed or closed.
-   *
-   * <p> This will also notify the subscribers if the progress was successfully set.
-   *
-   * <p> Do NOT call this method from a synchronized block as it invokes external code of the
-   * subscribers.
-   *
-   * @param progress the progress in range [0, 1] to be set.
-   * @return true if the progress was successfully set.
-   */
-  protected boolean setProgress(float progress) {
-    boolean result = setProgressInternal(progress);
-    if (result) {
-      notifyProgressUpdate();
+
+    @Override
+    public void subscribe(final DataSubscriber<T> dataSubscriber, final Executor executor) {
+        Preconditions.checkNotNull(dataSubscriber);
+        Preconditions.checkNotNull(executor);
+        boolean shouldNotify;
+
+        synchronized (this) {
+            if (mIsClosed) {
+                return;
+            }
+
+            if (mDataSourceStatus == DataSourceStatus.IN_PROGRESS) {
+                mSubscribers.add(Pair.create(dataSubscriber, executor));
+            }
+
+            shouldNotify = hasResult() || isFinished() || wasCancelled();
+        }
+
+        if (shouldNotify) {
+            notifyDataSubscriber(dataSubscriber, executor, hasFailed(), wasCancelled());
+        }
     }
-    return result;
-  }
 
-  private boolean setResultInternal(@Nullable T value, boolean isLast) {
-    T resultToClose = null;
-    try {
-      synchronized (this) {
-        if (mIsClosed || mDataSourceStatus != DataSourceStatus.IN_PROGRESS) {
-          resultToClose = value;
-          return false;
-        } else {
-          if (isLast) {
-            mDataSourceStatus = DataSourceStatus.SUCCESS;
-            mProgress = 1;
-          }
-          if (mResult != value) {
-            resultToClose = mResult;
-            mResult = value;
-          }
-          return true;
+    private void notifyDataSubscribers() {
+        final boolean isFailure = hasFailed();
+        final boolean isCancellation = wasCancelled();
+        for (Pair<DataSubscriber<T>, Executor> pair : mSubscribers) {
+            notifyDataSubscriber(pair.first, pair.second, isFailure, isCancellation);
+        }
+    }
+
+    private void notifyDataSubscriber(
+            final DataSubscriber<T> dataSubscriber,
+            final Executor executor,
+            final boolean isFailure,
+            final boolean isCancellation) {
+        executor.execute(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        if (isFailure) {
+                            dataSubscriber.onFailure(AbstractDataSource.this);
+                        } else if (isCancellation) {
+                            dataSubscriber.onCancellation(AbstractDataSource.this);
+                        } else {
+                            dataSubscriber.onNewResult(AbstractDataSource.this);
+                        }
+                    }
+                });
+    }
+
+    private synchronized boolean wasCancelled() {
+        return isClosed() && !isFinished();
+    }
+
+    /**
+     * Subclasses should invoke this method to set the result to {@code value}.
+     * <p>
+     * <p> This method will return {@code true} if the value was successfully set, or
+     * {@code false} if the data source has already been set, failed or closed.
+     * <p>
+     * <p> If the value was successfully set and {@code isLast} is {@code true}, state of the
+     * data source will be set to {@link AbstractDataSource.DataSourceStatus#SUCCESS}.
+     * <p>
+     * <p> {@link #closeResult} will be called for the previous result if the new value was
+     * successfully set, OR for the new result otherwise.
+     * <p>
+     * <p> This will also notify the subscribers if the value was successfully set.
+     * <p>
+     * <p> Do NOT call this method from a synchronized block as it invokes external code of the
+     * subscribers.
+     *
+     * @param value  the value that was the result of the task.
+     * @param isLast whether or not the value is last.
+     * @return true if the value was successfully set.
+     */
+    protected boolean setResult(@Nullable T value, boolean isLast) {
+        boolean result = setResultInternal(value, isLast);
+        if (result) {
+            notifyDataSubscribers();
         }
-      }
-    } finally {
-      if (resultToClose != null) {
-        closeResult(resultToClose);
-      }
+        return result;
     }
-  }
-
-  private synchronized boolean setFailureInternal(Throwable throwable) {
-    if (mIsClosed || mDataSourceStatus != DataSourceStatus.IN_PROGRESS) {
-      return false;
-    } else {
-      mDataSourceStatus = DataSourceStatus.FAILURE;
-      mFailureThrowable = throwable;
-      return true;
+
+    /**
+     * Subclasses should invoke this method to set the failure.
+     * <p>
+     * <p> This method will return {@code true} if the failure was successfully set, or
+     * {@code false} if the data source has already been set, failed or closed.
+     * <p>
+     * <p> If the failure was successfully set, state of the data source will be set to
+     * {@link AbstractDataSource.DataSourceStatus#FAILURE}.
+     * <p>
+     * <p> This will also notify the subscribers if the failure was successfully set.
+     * <p>
+     * <p> Do NOT call this method from a synchronized block as it invokes external code of the
+     * subscribers.
+     *
+     * @param throwable the failure cause to be set.
+     * @return true if the failure was successfully set.
+     */
+    protected boolean setFailure(Throwable throwable) {
+        boolean result = setFailureInternal(throwable);
+        if (result) {
+            notifyDataSubscribers();
+        }
+        return result;
     }
-  }
-
-  private synchronized boolean setProgressInternal(float progress) {
-    if (mIsClosed || mDataSourceStatus != DataSourceStatus.IN_PROGRESS) {
-      return false;
-    } else if (progress < mProgress) {
-      return false;
-    } else {
-      mProgress = progress;
-      return true;
+
+    /**
+     * Subclasses should invoke this method to set the progress.
+     * <p>
+     * <p> This method will return {@code true} if the progress was successfully set, or
+     * {@code false} if the data source has already been set, failed or closed.
+     * <p>
+     * <p> This will also notify the subscribers if the progress was successfully set.
+     * <p>
+     * <p> Do NOT call this method from a synchronized block as it invokes external code of the
+     * subscribers.
+     *
+     * @param progress the progress in range [0, 1] to be set.
+     * @return true if the progress was successfully set.
+     */
+    protected boolean setProgress(float progress) {
+        boolean result = setProgressInternal(progress);
+        if (result) {
+            notifyProgressUpdate();
+        }
+        return result;
     }
-  }
-
-  protected void notifyProgressUpdate() {
-    for (Pair<DataSubscriber<T>, Executor> pair : mSubscribers) {
-      final DataSubscriber<T> subscriber = pair.first;
-      Executor executor = pair.second;
-      executor.execute(
-          new Runnable() {
-            @Override
-            public void run() {
-              subscriber.onProgressUpdate(AbstractDataSource.this);
+
+    private boolean setResultInternal(@Nullable T value, boolean isLast) {
+        T resultToClose = null;
+        try {
+            synchronized (this) {
+                if (mIsClosed || mDataSourceStatus != DataSourceStatus.IN_PROGRESS) {
+                    resultToClose = value;
+                    return false;
+                } else {
+                    if (isLast) {
+                        mDataSourceStatus = DataSourceStatus.SUCCESS;
+                        mProgress = 1;
+                    }
+                    if (mResult != value) {
+                        resultToClose = mResult;
+                        mResult = value;
+                    }
+                    return true;
+                }
+            }
+        } finally {
+            if (resultToClose != null) {
+                closeResult(resultToClose);
             }
-          });
+        }
+    }
+
+    private synchronized boolean setFailureInternal(Throwable throwable) {
+        if (mIsClosed || mDataSourceStatus != DataSourceStatus.IN_PROGRESS) {
+            return false;
+        } else {
+            mDataSourceStatus = DataSourceStatus.FAILURE;
+            mFailureThrowable = throwable;
+            return true;
+        }
+    }
+
+    private synchronized boolean setProgressInternal(float progress) {
+        if (mIsClosed || mDataSourceStatus != DataSourceStatus.IN_PROGRESS) {
+            return false;
+        } else if (progress < mProgress) {
+            return false;
+        } else {
+            mProgress = progress;
+            return true;
+        }
+    }
+
+    protected void notifyProgressUpdate() {
+        for (Pair<DataSubscriber<T>, Executor> pair : mSubscribers) {
+            final DataSubscriber<T> subscriber = pair.first;
+            Executor executor = pair.second;
+            executor.execute(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            subscriber.onProgressUpdate(AbstractDataSource.this);
+                        }
+                    });
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/datasource/BaseDataSubscriber.java b/fbcore/src/main/java/com/facebook/datasource/BaseDataSubscriber.java
index 8f4da40f3..f545e9a76 100644
--- a/fbcore/src/main/java/com/facebook/datasource/BaseDataSubscriber.java
+++ b/fbcore/src/main/java/com/facebook/datasource/BaseDataSubscriber.java
@@ -37,35 +37,35 @@
  */
 public abstract class BaseDataSubscriber<T> implements DataSubscriber<T> {
 
-  @Override
-  public void onNewResult(DataSource<T> dataSource) {
-    try {
-      onNewResultImpl(dataSource);
-    } finally {
-      if (dataSource.isFinished()) {
-        dataSource.close();
-      }
+    @Override
+    public void onNewResult(DataSource<T> dataSource) {
+        try {
+            onNewResultImpl(dataSource);
+        } finally {
+            if (dataSource.isFinished()) {
+                dataSource.close();
+            }
+        }
     }
-  }
 
-  @Override
-  public void onFailure(DataSource<T> dataSource) {
-    try {
-      onFailureImpl(dataSource);
-    } finally {
-      dataSource.close();
+    @Override
+    public void onFailure(DataSource<T> dataSource) {
+        try {
+            onFailureImpl(dataSource);
+        } finally {
+            dataSource.close();
+        }
     }
-  }
 
-  @Override
-  public void onCancellation(DataSource<T> dataSource) {
-  }
+    @Override
+    public void onCancellation(DataSource<T> dataSource) {
+    }
 
-  @Override
-  public void onProgressUpdate(DataSource<T> dataSource) {
-  }
+    @Override
+    public void onProgressUpdate(DataSource<T> dataSource) {
+    }
 
-  protected abstract void onNewResultImpl(DataSource<T> dataSource);
+    protected abstract void onNewResultImpl(DataSource<T> dataSource);
 
-  protected abstract void onFailureImpl(DataSource<T> dataSource);
+    protected abstract void onFailureImpl(DataSource<T> dataSource);
 }
diff --git a/fbcore/src/main/java/com/facebook/datasource/DataSource.java b/fbcore/src/main/java/com/facebook/datasource/DataSource.java
index 165849b31..1d9db31d5 100644
--- a/fbcore/src/main/java/com/facebook/datasource/DataSource.java
+++ b/fbcore/src/main/java/com/facebook/datasource/DataSource.java
@@ -15,77 +15,82 @@
 
 /**
  * An alternative to Java Futures for the image pipeline.
- *
+ * <p>
  * <p>Unlike Futures, DataSource can issue a series of results, rather than just one. A prime
  * example is decoding progressive images, which have a series of intermediate results before the
  * final one.
- *
+ * <p>
  * <p>DataSources MUST be closed (close() is called on the DataSource) else resources may leak.
  *
- *@param <T> the type of the result
+ * @param <T> the type of the result
  */
 public interface DataSource<T> {
 
-  /**
-   * @return true if the data source is closed, false otherwise
-   */
-  public boolean isClosed();
+    /**
+     * @return true if the data source is closed, false otherwise
+     */
+    public boolean isClosed();
 
-  /**
-   * The most recent result of the asynchronous computation.
-   *
-   * <p>The caller gains ownership of the object and is responsible for releasing it.
-   * Note that subsequent calls to getResult might give different results. Later results should be
-   * considered to be of higher quality.
-   *
-   * <p>This method will return null in the following cases:
-   * <ul>
-   * <li>when the DataSource does not have a result ({@code hasResult} returns false).
-   * <li>when the last result produced was null.
-   * </ul>
-   * @return current best result
-   */
-  @Nullable T getResult();
+    /**
+     * The most recent result of the asynchronous computation.
+     * <p>
+     * <p>The caller gains ownership of the object and is responsible for releasing it.
+     * Note that subsequent calls to getResult might give different results. Later results should be
+     * considered to be of higher quality.
+     * <p>
+     * <p>This method will return null in the following cases:
+     * <ul>
+     * <li>when the DataSource does not have a result ({@code hasResult} returns false).
+     * <li>when the last result produced was null.
+     * </ul>
+     *
+     * @return current best result
+     */
+    @Nullable
+    T getResult();
 
-  /**
-   * @return true if any result (possibly of lower quality) is available right now, false otherwise
-   */
-  boolean hasResult();
+    /**
+     * @return true if any result (possibly of lower quality) is available right now, false otherwise
+     */
+    boolean hasResult();
 
-  /**
-   * @return true if request is finished, false otherwise
-   */
-  boolean isFinished();
+    /**
+     * @return true if request is finished, false otherwise
+     */
+    boolean isFinished();
 
-  /**
-   * @return true if request finished due to error
-   */
-  boolean hasFailed();
+    /**
+     * @return true if request finished due to error
+     */
+    boolean hasFailed();
 
-  /**
-   * @return failure cause if the source has failed, else null
-   */
-  @Nullable Throwable getFailureCause();
+    /**
+     * @return failure cause if the source has failed, else null
+     */
+    @Nullable
+    Throwable getFailureCause();
 
-  /**
-   * @return progress in range [0, 1]
-   */
-  float getProgress();
+    /**
+     * @return progress in range [0, 1]
+     */
+    float getProgress();
 
-  /**
-   * Cancels the ongoing request and releases all associated resources.
-   *
-   * <p>Subsequent calls to {@link #getResult} will return null.
-   * @return true if the data source is closed for the first time
-   */
-  boolean close();
+    /**
+     * Cancels the ongoing request and releases all associated resources.
+     * <p>
+     * <p>Subsequent calls to {@link #getResult} will return null.
+     *
+     * @return true if the data source is closed for the first time
+     */
+    boolean close();
 
-  /**
-   * Subscribe for notifications whenever the state of the DataSource changes.
-   *
-   * <p>All changes will be observed on the provided executor.
-   * @param dataSubscriber
-   * @param executor
-   */
-  void subscribe(DataSubscriber<T> dataSubscriber, Executor executor);
+    /**
+     * Subscribe for notifications whenever the state of the DataSource changes.
+     * <p>
+     * <p>All changes will be observed on the provided executor.
+     *
+     * @param dataSubscriber
+     * @param executor
+     */
+    void subscribe(DataSubscriber<T> dataSubscriber, Executor executor);
 }
diff --git a/fbcore/src/main/java/com/facebook/datasource/DataSources.java b/fbcore/src/main/java/com/facebook/datasource/DataSources.java
index dcc84ddbc..3247e95f3 100644
--- a/fbcore/src/main/java/com/facebook/datasource/DataSources.java
+++ b/fbcore/src/main/java/com/facebook/datasource/DataSources.java
@@ -17,21 +17,21 @@
  */
 public class DataSources {
 
-  private DataSources() {
-  }
+    private DataSources() {
+    }
 
-  public static <T> DataSource<T> immediateFailedDataSource(Throwable failure) {
-    SettableDataSource<T> settableDataSource = SettableDataSource.create();
-    settableDataSource.setFailure(failure);
-    return settableDataSource;
-  }
+    public static <T> DataSource<T> immediateFailedDataSource(Throwable failure) {
+        SettableDataSource<T> settableDataSource = SettableDataSource.create();
+        settableDataSource.setFailure(failure);
+        return settableDataSource;
+    }
 
-  public static <T> Supplier<DataSource<T>> getFailedDataSourceSupplier(final Throwable failure) {
-    return new Supplier<DataSource<T>>() {
-      @Override
-      public DataSource<T> get() {
-        return DataSources.immediateFailedDataSource(failure);
-      }
-    };
-  }
+    public static <T> Supplier<DataSource<T>> getFailedDataSourceSupplier(final Throwable failure) {
+        return new Supplier<DataSource<T>>() {
+            @Override
+            public DataSource<T> get() {
+                return DataSources.immediateFailedDataSource(failure);
+            }
+        };
+    }
 }
diff --git a/fbcore/src/main/java/com/facebook/datasource/DataSubscriber.java b/fbcore/src/main/java/com/facebook/datasource/DataSubscriber.java
index 1deda8bed..2efe4fc11 100644
--- a/fbcore/src/main/java/com/facebook/datasource/DataSubscriber.java
+++ b/fbcore/src/main/java/com/facebook/datasource/DataSubscriber.java
@@ -11,47 +11,48 @@
 
 /**
  * Subscribes to DataSource<T>.
+ *
  * @param <T>
  */
 public interface DataSubscriber<T> {
 
-  /**
-   * Called whenever a new value is ready to be retrieved from the DataSource.
-   *
-   * <p>To retrieve the new value, call {@code dataSource.getResult()}.
-   *
-   * <p>To determine if the new value is the last, use {@code dataSource.isFinished()}.
-   *
-   * @param dataSource
-   */
-  void onNewResult(DataSource<T> dataSource);
+    /**
+     * Called whenever a new value is ready to be retrieved from the DataSource.
+     * <p>
+     * <p>To retrieve the new value, call {@code dataSource.getResult()}.
+     * <p>
+     * <p>To determine if the new value is the last, use {@code dataSource.isFinished()}.
+     *
+     * @param dataSource
+     */
+    void onNewResult(DataSource<T> dataSource);
 
-  /**
-   * Called whenever an error occurs inside of the pipeline.
-   *
-   * <p>No further results will be produced after this method is called.
-   *
-   * <p>The throwable resulting from the failure can be obtained using
-   * {@code dataSource.getFailureCause}.
-   *
-   * @param dataSource
-   */
-  void onFailure(DataSource<T> dataSource);
+    /**
+     * Called whenever an error occurs inside of the pipeline.
+     * <p>
+     * <p>No further results will be produced after this method is called.
+     * <p>
+     * <p>The throwable resulting from the failure can be obtained using
+     * {@code dataSource.getFailureCause}.
+     *
+     * @param dataSource
+     */
+    void onFailure(DataSource<T> dataSource);
 
-  /**
-   * Called whenever the request is cancelled (a request being cancelled means that is was closed
-   * before it finished).
-   *
-   * <p>No further results will be produced after this method is called.
-   *
-   * @param dataSource
-   */
-  void onCancellation(DataSource<T> dataSource);
+    /**
+     * Called whenever the request is cancelled (a request being cancelled means that is was closed
+     * before it finished).
+     * <p>
+     * <p>No further results will be produced after this method is called.
+     *
+     * @param dataSource
+     */
+    void onCancellation(DataSource<T> dataSource);
 
-  /**
-   * Called when the progress updates.
-   *
-   * @param dataSource
-   */
-  void onProgressUpdate(DataSource<T> dataSource);
+    /**
+     * Called when the progress updates.
+     *
+     * @param dataSource
+     */
+    void onProgressUpdate(DataSource<T> dataSource);
 }
diff --git a/fbcore/src/main/java/com/facebook/datasource/FirstAvailableDataSourceSupplier.java b/fbcore/src/main/java/com/facebook/datasource/FirstAvailableDataSourceSupplier.java
index cbcbbfa81..f8863c039 100644
--- a/fbcore/src/main/java/com/facebook/datasource/FirstAvailableDataSourceSupplier.java
+++ b/fbcore/src/main/java/com/facebook/datasource/FirstAvailableDataSourceSupplier.java
@@ -22,214 +22,214 @@
 /**
  * {@link DataSource} supplier that provides a data source which will forward results of the first
  * available data source.
- *
+ * <p>
  * <p>Data sources are obtained in order. Only if the current data source fails, or if it finishes
  * without result, the next one will be tried.
  */
 @ThreadSafe
 public class FirstAvailableDataSourceSupplier<T> implements Supplier<DataSource<T>> {
 
-  private final List<Supplier<DataSource<T>>> mDataSourceSuppliers;
-
-  private FirstAvailableDataSourceSupplier(List<Supplier<DataSource<T>>> dataSourceSuppliers) {
-    Preconditions.checkArgument(!dataSourceSuppliers.isEmpty(), "List of suppliers is empty!");
-    mDataSourceSuppliers = dataSourceSuppliers;
-  }
-
-  public static <T> FirstAvailableDataSourceSupplier<T> create(
-      List<Supplier<DataSource<T>>> dataSourceSuppliers) {
-    return new FirstAvailableDataSourceSupplier<T>(dataSourceSuppliers);
-  }
-
-  @Override
-  public DataSource<T> get() {
-    return new FirstAvailableDataSource();
-  }
-
-  @Override
-  public int hashCode() {
-    return mDataSourceSuppliers.hashCode();
-  }
+    private final List<Supplier<DataSource<T>>> mDataSourceSuppliers;
 
-  @Override
-  public boolean equals(Object other) {
-    if (other == this) {
-      return true;
+    private FirstAvailableDataSourceSupplier(List<Supplier<DataSource<T>>> dataSourceSuppliers) {
+        Preconditions.checkArgument(!dataSourceSuppliers.isEmpty(), "List of suppliers is empty!");
+        mDataSourceSuppliers = dataSourceSuppliers;
     }
-    if (!(other instanceof FirstAvailableDataSourceSupplier)) {
-      return false;
-    }
-    FirstAvailableDataSourceSupplier that = (FirstAvailableDataSourceSupplier) other;
-    return Objects.equal(this.mDataSourceSuppliers, that.mDataSourceSuppliers);
-  }
-
-  @Override
-  public String toString() {
-    return Objects.toStringHelper(this)
-        .add("list", mDataSourceSuppliers)
-        .toString();
-  }
-
-  @ThreadSafe
-  private class FirstAvailableDataSource extends AbstractDataSource<T> {
-
-    private int mIndex = 0;
-    private DataSource<T> mCurrentDataSource = null;
-    private DataSource<T> mDataSourceWithResult = null;
-
-    public FirstAvailableDataSource() {
-      if (!startNextDataSource()) {
-        setFailure(new RuntimeException("No data source supplier or supplier returned null."));
-      }
+
+    public static <T> FirstAvailableDataSourceSupplier<T> create(
+            List<Supplier<DataSource<T>>> dataSourceSuppliers) {
+        return new FirstAvailableDataSourceSupplier<T>(dataSourceSuppliers);
     }
 
     @Override
-    @Nullable
-    public synchronized T getResult() {
-      DataSource<T> dataSourceWithResult = getDataSourceWithResult();
-      return (dataSourceWithResult != null) ? dataSourceWithResult.getResult() : null;
+    public DataSource<T> get() {
+        return new FirstAvailableDataSource();
     }
 
     @Override
-    public synchronized boolean hasResult() {
-      DataSource<T> dataSourceWithResult = getDataSourceWithResult();
-      return (dataSourceWithResult != null) && dataSourceWithResult.hasResult();
+    public int hashCode() {
+        return mDataSourceSuppliers.hashCode();
     }
 
     @Override
-    public boolean close() {
-      DataSource<T> currentDataSource;
-      DataSource<T> dataSourceWithResult;
-      synchronized (FirstAvailableDataSource.this) {
-        // it's fine to call {@code super.close()} within a synchronized block because we don't
-        // implement {@link #closeResult()}, but perform result closing ourselves.
-        if (!super.close()) {
-          return false;
-        }
-        currentDataSource = mCurrentDataSource;
-        mCurrentDataSource = null;
-        dataSourceWithResult = mDataSourceWithResult;
-        mDataSourceWithResult = null;
-      }
-      closeSafely(dataSourceWithResult);
-      closeSafely(currentDataSource);
-      return true;
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof FirstAvailableDataSourceSupplier)) {
+            return false;
+        }
+        FirstAvailableDataSourceSupplier that = (FirstAvailableDataSourceSupplier) other;
+        return Objects.equal(this.mDataSourceSuppliers, that.mDataSourceSuppliers);
     }
 
-    private boolean startNextDataSource() {
-      Supplier<DataSource<T>> dataSourceSupplier = getNextSupplier();
-      DataSource<T> dataSource = (dataSourceSupplier != null) ? dataSourceSupplier.get() : null;
-      if (setCurrentDataSource(dataSource) && dataSource != null) {
-        dataSource.subscribe(new InternalDataSubscriber(), CallerThreadExecutor.getInstance());
-        return true;
-      } else {
-        closeSafely(dataSource);
-        return false;
-      }
+    @Override
+    public String toString() {
+        return Objects.toStringHelper(this)
+                .add("list", mDataSourceSuppliers)
+                .toString();
     }
 
-    @Nullable
-    private synchronized Supplier<DataSource<T>> getNextSupplier() {
-      if (!isClosed() && mIndex < mDataSourceSuppliers.size()) {
-        return mDataSourceSuppliers.get(mIndex++);
-      }
-      return null;
-    }
+    @ThreadSafe
+    private class FirstAvailableDataSource extends AbstractDataSource<T> {
 
-    private synchronized boolean setCurrentDataSource(DataSource<T> dataSource) {
-      if (isClosed()) {
-        return false;
-      }
-      mCurrentDataSource = dataSource;
-      return true;
-    }
+        private int mIndex = 0;
+        private DataSource<T> mCurrentDataSource = null;
+        private DataSource<T> mDataSourceWithResult = null;
 
-    private synchronized boolean clearCurrentDataSource(DataSource<T> dataSource) {
-      if (isClosed() || dataSource != mCurrentDataSource) {
-        return false;
-      }
-      mCurrentDataSource = null;
-      return true;
-    }
+        public FirstAvailableDataSource() {
+            if (!startNextDataSource()) {
+                setFailure(new RuntimeException("No data source supplier or supplier returned null."));
+            }
+        }
 
-    @Nullable
-    private synchronized DataSource<T> getDataSourceWithResult() {
-      return mDataSourceWithResult;
-    }
+        @Override
+        @Nullable
+        public synchronized T getResult() {
+            DataSource<T> dataSourceWithResult = getDataSourceWithResult();
+            return (dataSourceWithResult != null) ? dataSourceWithResult.getResult() : null;
+        }
 
-    private void maybeSetDataSourceWithResult(
-        DataSource<T> dataSource,
-        boolean isFinished) {
-      DataSource<T> oldDataSource = null;
-      synchronized (FirstAvailableDataSource.this) {
-        if (dataSource != mCurrentDataSource || dataSource == mDataSourceWithResult) {
-          return;
-        }
-        // If we didn't have any result so far, we got one now, so we'll set
-        // {@code mDataSourceWithResult} to point to the current data source.
-        // If we did have a result which came from another data source,
-        // we'll only set {@code mDataSourceWithResult} to point to the current
-        // data source if it has finished (i.e. the new result is final).
-        if (mDataSourceWithResult == null || isFinished) {
-          oldDataSource = mDataSourceWithResult;
-          mDataSourceWithResult = dataSource;
-        }
-      }
-      closeSafely(oldDataSource);
-    }
+        @Override
+        public synchronized boolean hasResult() {
+            DataSource<T> dataSourceWithResult = getDataSourceWithResult();
+            return (dataSourceWithResult != null) && dataSourceWithResult.hasResult();
+        }
 
-    private void onDataSourceFailed(DataSource<T> dataSource) {
-      if (!clearCurrentDataSource(dataSource)) {
-        return;
-      }
-      if (dataSource != getDataSourceWithResult()) {
-        closeSafely(dataSource);
-      }
-      if (!startNextDataSource()) {
-        setFailure(dataSource.getFailureCause());
-      }
-    }
+        @Override
+        public boolean close() {
+            DataSource<T> currentDataSource;
+            DataSource<T> dataSourceWithResult;
+            synchronized (FirstAvailableDataSource.this) {
+                // it's fine to call {@code super.close()} within a synchronized block because we don't
+                // implement {@link #closeResult()}, but perform result closing ourselves.
+                if (!super.close()) {
+                    return false;
+                }
+                currentDataSource = mCurrentDataSource;
+                mCurrentDataSource = null;
+                dataSourceWithResult = mDataSourceWithResult;
+                mDataSourceWithResult = null;
+            }
+            closeSafely(dataSourceWithResult);
+            closeSafely(currentDataSource);
+            return true;
+        }
 
-    private void onDataSourceNewResult(DataSource<T> dataSource) {
-      maybeSetDataSourceWithResult(dataSource, dataSource.isFinished());
-      // If the data source with the new result is our {@code mDataSourceWithResult},
-      // we have to notify our subscribers about the new result.
-      if (dataSource == getDataSourceWithResult()) {
-        setResult(null, dataSource.isFinished());
-      }
-    }
+        private boolean startNextDataSource() {
+            Supplier<DataSource<T>> dataSourceSupplier = getNextSupplier();
+            DataSource<T> dataSource = (dataSourceSupplier != null) ? dataSourceSupplier.get() : null;
+            if (setCurrentDataSource(dataSource) && dataSource != null) {
+                dataSource.subscribe(new InternalDataSubscriber(), CallerThreadExecutor.getInstance());
+                return true;
+            } else {
+                closeSafely(dataSource);
+                return false;
+            }
+        }
 
-    private void closeSafely(DataSource<T> dataSource) {
-      if (dataSource != null) {
-        dataSource.close();
-      }
-    }
+        @Nullable
+        private synchronized Supplier<DataSource<T>> getNextSupplier() {
+            if (!isClosed() && mIndex < mDataSourceSuppliers.size()) {
+                return mDataSourceSuppliers.get(mIndex++);
+            }
+            return null;
+        }
 
-    private class InternalDataSubscriber implements DataSubscriber<T> {
+        private synchronized boolean setCurrentDataSource(DataSource<T> dataSource) {
+            if (isClosed()) {
+                return false;
+            }
+            mCurrentDataSource = dataSource;
+            return true;
+        }
 
-      @Override
-      public void onFailure(DataSource<T> dataSource) {
-        FirstAvailableDataSource.this.onDataSourceFailed(dataSource);
-      }
+        private synchronized boolean clearCurrentDataSource(DataSource<T> dataSource) {
+            if (isClosed() || dataSource != mCurrentDataSource) {
+                return false;
+            }
+            mCurrentDataSource = null;
+            return true;
+        }
 
-      @Override
-      public void onCancellation(DataSource<T> dataSource) {
-      }
+        @Nullable
+        private synchronized DataSource<T> getDataSourceWithResult() {
+            return mDataSourceWithResult;
+        }
+
+        private void maybeSetDataSourceWithResult(
+                DataSource<T> dataSource,
+                boolean isFinished) {
+            DataSource<T> oldDataSource = null;
+            synchronized (FirstAvailableDataSource.this) {
+                if (dataSource != mCurrentDataSource || dataSource == mDataSourceWithResult) {
+                    return;
+                }
+                // If we didn't have any result so far, we got one now, so we'll set
+                // {@code mDataSourceWithResult} to point to the current data source.
+                // If we did have a result which came from another data source,
+                // we'll only set {@code mDataSourceWithResult} to point to the current
+                // data source if it has finished (i.e. the new result is final).
+                if (mDataSourceWithResult == null || isFinished) {
+                    oldDataSource = mDataSourceWithResult;
+                    mDataSourceWithResult = dataSource;
+                }
+            }
+            closeSafely(oldDataSource);
+        }
+
+        private void onDataSourceFailed(DataSource<T> dataSource) {
+            if (!clearCurrentDataSource(dataSource)) {
+                return;
+            }
+            if (dataSource != getDataSourceWithResult()) {
+                closeSafely(dataSource);
+            }
+            if (!startNextDataSource()) {
+                setFailure(dataSource.getFailureCause());
+            }
+        }
+
+        private void onDataSourceNewResult(DataSource<T> dataSource) {
+            maybeSetDataSourceWithResult(dataSource, dataSource.isFinished());
+            // If the data source with the new result is our {@code mDataSourceWithResult},
+            // we have to notify our subscribers about the new result.
+            if (dataSource == getDataSourceWithResult()) {
+                setResult(null, dataSource.isFinished());
+            }
+        }
 
-      @Override
-      public void onNewResult(DataSource<T> dataSource) {
-        if (dataSource.hasResult()) {
-          FirstAvailableDataSource.this.onDataSourceNewResult(dataSource);
-        } else if (dataSource.isFinished()) {
-          FirstAvailableDataSource.this.onDataSourceFailed(dataSource);
+        private void closeSafely(DataSource<T> dataSource) {
+            if (dataSource != null) {
+                dataSource.close();
+            }
         }
-      }
 
-      @Override
-      public void onProgressUpdate(DataSource<T> dataSource) {
-        float oldProgress = FirstAvailableDataSource.this.getProgress();
-        FirstAvailableDataSource.this.setProgress(Math.max(oldProgress, dataSource.getProgress()));
-      }
+        private class InternalDataSubscriber implements DataSubscriber<T> {
+
+            @Override
+            public void onFailure(DataSource<T> dataSource) {
+                FirstAvailableDataSource.this.onDataSourceFailed(dataSource);
+            }
+
+            @Override
+            public void onCancellation(DataSource<T> dataSource) {
+            }
+
+            @Override
+            public void onNewResult(DataSource<T> dataSource) {
+                if (dataSource.hasResult()) {
+                    FirstAvailableDataSource.this.onDataSourceNewResult(dataSource);
+                } else if (dataSource.isFinished()) {
+                    FirstAvailableDataSource.this.onDataSourceFailed(dataSource);
+                }
+            }
+
+            @Override
+            public void onProgressUpdate(DataSource<T> dataSource) {
+                float oldProgress = FirstAvailableDataSource.this.getProgress();
+                FirstAvailableDataSource.this.setProgress(Math.max(oldProgress, dataSource.getProgress()));
+            }
+        }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/datasource/IncreasingQualityDataSourceSupplier.java b/fbcore/src/main/java/com/facebook/datasource/IncreasingQualityDataSourceSupplier.java
index acbb41b10..071a6985f 100644
--- a/fbcore/src/main/java/com/facebook/datasource/IncreasingQualityDataSourceSupplier.java
+++ b/fbcore/src/main/java/com/facebook/datasource/IncreasingQualityDataSourceSupplier.java
@@ -25,231 +25,234 @@
 /**
  * {@link DataSource} supplier that provides a data source which forwards results of the underlying
  * data sources with the increasing quality.
- *
+ * <p>
  * <p>Data sources are obtained in order. The first data source in array is considered to be of the
  * highest quality. The first data source to provide an result gets forwarded until one of the
  * higher quality data sources provides its final image at which point that data source gets
  * forwarded (and so on). That being said, only the first data source to provide an result is
  * streamed.
- *
+ * <p>
  * <p>Outcome (success/failure) of the data source provided by this supplier is determined by the
  * outcome of the highest quality data source (the first data source in the array).
  */
 @ThreadSafe
 public class IncreasingQualityDataSourceSupplier<T> implements Supplier<DataSource<T>> {
 
-  private final List<Supplier<DataSource<T>>> mDataSourceSuppliers;
-
-  private IncreasingQualityDataSourceSupplier(List<Supplier<DataSource<T>>> dataSourceSuppliers) {
-    Preconditions.checkArgument(!dataSourceSuppliers.isEmpty(), "List of suppliers is empty!");
-    mDataSourceSuppliers = dataSourceSuppliers;
-  }
-
-  /**
-   * Creates a new data source supplier with increasing-quality strategy.
-   * <p>Note: for performance reasons the list doesn't get cloned, so the caller of this method
-   * should not modify the list once passed in here.
-   * @param dataSourceSuppliers list of underlying suppliers
-   */
-  public static <T> IncreasingQualityDataSourceSupplier<T> create(
-      List<Supplier<DataSource<T>>> dataSourceSuppliers) {
-    return new IncreasingQualityDataSourceSupplier<T>(dataSourceSuppliers);
-  }
-
-  @Override
-  public DataSource<T> get() {
-    return new IncreasingQualityDataSource();
-  }
-
-  @Override
-  public int hashCode() {
-    return mDataSourceSuppliers.hashCode();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-    if (other == this) {
-      return true;
-    }
-    if (!(other instanceof IncreasingQualityDataSourceSupplier)) {
-      return false;
-    }
-    IncreasingQualityDataSourceSupplier that = (IncreasingQualityDataSourceSupplier) other;
-    return Objects.equal(this.mDataSourceSuppliers, that.mDataSourceSuppliers);
-  }
-
-  @Override
-  public String toString() {
-    return Objects.toStringHelper(this)
-        .add("list", mDataSourceSuppliers)
-        .toString();
-  }
-
-  @ThreadSafe
-  private class IncreasingQualityDataSource extends AbstractDataSource<T> {
-
-    @GuardedBy("IncreasingQualityDataSource.this")
-    private @Nullable ArrayList<DataSource<T>> mDataSources;
-    @GuardedBy("IncreasingQualityDataSource.this")
-    private int mIndexOfDataSourceWithResult;
-
-    public IncreasingQualityDataSource() {
-      final int n = mDataSourceSuppliers.size();
-      mIndexOfDataSourceWithResult = n;
-      mDataSources = Lists.newArrayListWithCapacity(n);
-      for (int i = 0; i < n; i++) {
-        DataSource<T> dataSource = mDataSourceSuppliers.get(i).get();
-        mDataSources.add(dataSource);
-        dataSource.subscribe(new InternalDataSubscriber(i), CallerThreadExecutor.getInstance());
-        // there's no point in creating data sources of lower quality
-        // if the data source of a higher quality has some result already
-        if (dataSource.hasResult()) {
-          break;
-        }
-      }
-    }
+    private final List<Supplier<DataSource<T>>> mDataSourceSuppliers;
 
-    @Nullable
-    private synchronized DataSource<T> getDataSource(int i) {
-      return (mDataSources != null && i < mDataSources.size()) ? mDataSources.get(i) : null;
+    private IncreasingQualityDataSourceSupplier(List<Supplier<DataSource<T>>> dataSourceSuppliers) {
+        Preconditions.checkArgument(!dataSourceSuppliers.isEmpty(), "List of suppliers is empty!");
+        mDataSourceSuppliers = dataSourceSuppliers;
     }
 
-    @Nullable
-    private synchronized DataSource<T> getAndClearDataSource(int i) {
-      return (mDataSources != null && i < mDataSources.size()) ? mDataSources.set(i, null) : null;
-    }
-
-    @Nullable
-    private synchronized DataSource<T> getDataSourceWithResult() {
-      return getDataSource(mIndexOfDataSourceWithResult);
+    /**
+     * Creates a new data source supplier with increasing-quality strategy.
+     * <p>Note: for performance reasons the list doesn't get cloned, so the caller of this method
+     * should not modify the list once passed in here.
+     *
+     * @param dataSourceSuppliers list of underlying suppliers
+     */
+    public static <T> IncreasingQualityDataSourceSupplier<T> create(
+            List<Supplier<DataSource<T>>> dataSourceSuppliers) {
+        return new IncreasingQualityDataSourceSupplier<T>(dataSourceSuppliers);
     }
 
     @Override
-    @Nullable
-    public synchronized T getResult() {
-      DataSource<T> dataSourceWithResult = getDataSourceWithResult();
-      return (dataSourceWithResult != null) ? dataSourceWithResult.getResult() : null;
+    public DataSource<T> get() {
+        return new IncreasingQualityDataSource();
     }
 
     @Override
-    public synchronized boolean hasResult() {
-      DataSource<T> dataSourceWithResult = getDataSourceWithResult();
-      return (dataSourceWithResult != null) && dataSourceWithResult.hasResult();
+    public int hashCode() {
+        return mDataSourceSuppliers.hashCode();
     }
 
     @Override
-    public boolean close() {
-      ArrayList<DataSource<T>> dataSources;
-      synchronized (IncreasingQualityDataSource.this) {
-        // it's fine to call {@code super.close()} within a synchronized block because we don't
-        // implement {@link #closeResult()}, but perform result closing ourselves.
-        if (!super.close()) {
-          return false;
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
         }
-        dataSources = mDataSources;
-        mDataSources = null;
-      }
-      if (dataSources != null) {
-        for (int i = 0; i < dataSources.size(); i++) {
-          closeSafely(dataSources.get(i));
+        if (!(other instanceof IncreasingQualityDataSourceSupplier)) {
+            return false;
         }
-      }
-      return true;
+        IncreasingQualityDataSourceSupplier that = (IncreasingQualityDataSourceSupplier) other;
+        return Objects.equal(this.mDataSourceSuppliers, that.mDataSourceSuppliers);
     }
 
-    private void onDataSourceNewResult(int index, DataSource<T> dataSource) {
-      maybeSetIndexOfDataSourceWithResult(index, dataSource, dataSource.isFinished());
-      // If the data source with the new result is our {@code mIndexOfDataSourceWithResult},
-      // we have to notify our subscribers about the new result.
-      if (dataSource == getDataSourceWithResult()) {
-        setResult(null, (index == 0) && dataSource.isFinished());
-      }
+    @Override
+    public String toString() {
+        return Objects.toStringHelper(this)
+                .add("list", mDataSourceSuppliers)
+                .toString();
     }
 
-    private void onDataSourceFailed(int index, DataSource<T> dataSource) {
-      closeSafely(tryGetAndClearDataSource(index, dataSource));
-      if (index == 0) {
-        setFailure(dataSource.getFailureCause());
-      }
-    }
+    @ThreadSafe
+    private class IncreasingQualityDataSource extends AbstractDataSource<T> {
+
+        @GuardedBy("IncreasingQualityDataSource.this")
+        private
+        @Nullable
+        ArrayList<DataSource<T>> mDataSources;
+        @GuardedBy("IncreasingQualityDataSource.this")
+        private int mIndexOfDataSourceWithResult;
+
+        public IncreasingQualityDataSource() {
+            final int n = mDataSourceSuppliers.size();
+            mIndexOfDataSourceWithResult = n;
+            mDataSources = Lists.newArrayListWithCapacity(n);
+            for (int i = 0; i < n; i++) {
+                DataSource<T> dataSource = mDataSourceSuppliers.get(i).get();
+                mDataSources.add(dataSource);
+                dataSource.subscribe(new InternalDataSubscriber(i), CallerThreadExecutor.getInstance());
+                // there's no point in creating data sources of lower quality
+                // if the data source of a higher quality has some result already
+                if (dataSource.hasResult()) {
+                    break;
+                }
+            }
+        }
 
-    private void maybeSetIndexOfDataSourceWithResult(
-        int index,
-        DataSource<T> dataSource,
-        boolean isFinished) {
-      int oldIndexOfDataSourceWithResult;
-      int newIndexOfDataSourceWithResult;
-      synchronized (IncreasingQualityDataSource.this) {
-        oldIndexOfDataSourceWithResult = mIndexOfDataSourceWithResult;
-        newIndexOfDataSourceWithResult = mIndexOfDataSourceWithResult;
-        if (dataSource != getDataSource(index) || index == mIndexOfDataSourceWithResult) {
-          return;
+        @Nullable
+        private synchronized DataSource<T> getDataSource(int i) {
+            return (mDataSources != null && i < mDataSources.size()) ? mDataSources.get(i) : null;
         }
-        // If we didn't have any result so far, we got one now, so we'll set
-        // {@code mIndexOfDataSourceWithResult} to point to the data source with result.
-        // If we did have a result which came from another data source,
-        // we'll only set {@code mIndexOfDataSourceWithResult} to point to the current data source
-        // if it has finished (i.e. the new result is final), and is of higher quality.
-        if (getDataSourceWithResult() == null ||
-            (isFinished && index < mIndexOfDataSourceWithResult)) {
-          newIndexOfDataSourceWithResult = index;
-          mIndexOfDataSourceWithResult = index;
+
+        @Nullable
+        private synchronized DataSource<T> getAndClearDataSource(int i) {
+            return (mDataSources != null && i < mDataSources.size()) ? mDataSources.set(i, null) : null;
         }
-      }
-      // close data sources of lower quality than the one with the result
-      for (int i = oldIndexOfDataSourceWithResult; i > newIndexOfDataSourceWithResult; i--) {
-        closeSafely(getAndClearDataSource(i));
-      }
-    }
 
-    @Nullable
-    private synchronized DataSource<T> tryGetAndClearDataSource(int i, DataSource<T> dataSource) {
-      if (dataSource == getDataSourceWithResult()) {
-        return null;
-      }
-      if (dataSource == getDataSource(i)) {
-        return getAndClearDataSource(i);
-      }
-      return dataSource;
-    }
+        @Nullable
+        private synchronized DataSource<T> getDataSourceWithResult() {
+            return getDataSource(mIndexOfDataSourceWithResult);
+        }
 
-    private void closeSafely(DataSource<T> dataSource) {
-      if (dataSource != null) {
-        dataSource.close();
-      }
-    }
+        @Override
+        @Nullable
+        public synchronized T getResult() {
+            DataSource<T> dataSourceWithResult = getDataSourceWithResult();
+            return (dataSourceWithResult != null) ? dataSourceWithResult.getResult() : null;
+        }
+
+        @Override
+        public synchronized boolean hasResult() {
+            DataSource<T> dataSourceWithResult = getDataSourceWithResult();
+            return (dataSourceWithResult != null) && dataSourceWithResult.hasResult();
+        }
 
-    private class InternalDataSubscriber implements DataSubscriber<T> {
-      private int mIndex;
+        @Override
+        public boolean close() {
+            ArrayList<DataSource<T>> dataSources;
+            synchronized (IncreasingQualityDataSource.this) {
+                // it's fine to call {@code super.close()} within a synchronized block because we don't
+                // implement {@link #closeResult()}, but perform result closing ourselves.
+                if (!super.close()) {
+                    return false;
+                }
+                dataSources = mDataSources;
+                mDataSources = null;
+            }
+            if (dataSources != null) {
+                for (int i = 0; i < dataSources.size(); i++) {
+                    closeSafely(dataSources.get(i));
+                }
+            }
+            return true;
+        }
+
+        private void onDataSourceNewResult(int index, DataSource<T> dataSource) {
+            maybeSetIndexOfDataSourceWithResult(index, dataSource, dataSource.isFinished());
+            // If the data source with the new result is our {@code mIndexOfDataSourceWithResult},
+            // we have to notify our subscribers about the new result.
+            if (dataSource == getDataSourceWithResult()) {
+                setResult(null, (index == 0) && dataSource.isFinished());
+            }
+        }
 
-      public InternalDataSubscriber(int index) {
-        mIndex = index;
-      }
+        private void onDataSourceFailed(int index, DataSource<T> dataSource) {
+            closeSafely(tryGetAndClearDataSource(index, dataSource));
+            if (index == 0) {
+                setFailure(dataSource.getFailureCause());
+            }
+        }
 
-      @Override
-      public void onNewResult(DataSource<T> dataSource) {
-        if (dataSource.hasResult()) {
-          IncreasingQualityDataSource.this.onDataSourceNewResult(mIndex, dataSource);
-        } else if (dataSource.isFinished()) {
-          IncreasingQualityDataSource.this.onDataSourceFailed(mIndex, dataSource);
+        private void maybeSetIndexOfDataSourceWithResult(
+                int index,
+                DataSource<T> dataSource,
+                boolean isFinished) {
+            int oldIndexOfDataSourceWithResult;
+            int newIndexOfDataSourceWithResult;
+            synchronized (IncreasingQualityDataSource.this) {
+                oldIndexOfDataSourceWithResult = mIndexOfDataSourceWithResult;
+                newIndexOfDataSourceWithResult = mIndexOfDataSourceWithResult;
+                if (dataSource != getDataSource(index) || index == mIndexOfDataSourceWithResult) {
+                    return;
+                }
+                // If we didn't have any result so far, we got one now, so we'll set
+                // {@code mIndexOfDataSourceWithResult} to point to the data source with result.
+                // If we did have a result which came from another data source,
+                // we'll only set {@code mIndexOfDataSourceWithResult} to point to the current data source
+                // if it has finished (i.e. the new result is final), and is of higher quality.
+                if (getDataSourceWithResult() == null ||
+                        (isFinished && index < mIndexOfDataSourceWithResult)) {
+                    newIndexOfDataSourceWithResult = index;
+                    mIndexOfDataSourceWithResult = index;
+                }
+            }
+            // close data sources of lower quality than the one with the result
+            for (int i = oldIndexOfDataSourceWithResult; i > newIndexOfDataSourceWithResult; i--) {
+                closeSafely(getAndClearDataSource(i));
+            }
         }
-      }
 
-      @Override
-      public void onFailure(DataSource<T> dataSource) {
-        IncreasingQualityDataSource.this.onDataSourceFailed(mIndex, dataSource);
-      }
+        @Nullable
+        private synchronized DataSource<T> tryGetAndClearDataSource(int i, DataSource<T> dataSource) {
+            if (dataSource == getDataSourceWithResult()) {
+                return null;
+            }
+            if (dataSource == getDataSource(i)) {
+                return getAndClearDataSource(i);
+            }
+            return dataSource;
+        }
 
-      @Override
-      public void onCancellation(DataSource<T> dataSource) {
-      }
+        private void closeSafely(DataSource<T> dataSource) {
+            if (dataSource != null) {
+                dataSource.close();
+            }
+        }
 
-      @Override
-      public void onProgressUpdate(DataSource<T> dataSource) {
-        if (mIndex == 0) {
-          IncreasingQualityDataSource.this.setProgress(dataSource.getProgress());
+        private class InternalDataSubscriber implements DataSubscriber<T> {
+            private int mIndex;
+
+            public InternalDataSubscriber(int index) {
+                mIndex = index;
+            }
+
+            @Override
+            public void onNewResult(DataSource<T> dataSource) {
+                if (dataSource.hasResult()) {
+                    IncreasingQualityDataSource.this.onDataSourceNewResult(mIndex, dataSource);
+                } else if (dataSource.isFinished()) {
+                    IncreasingQualityDataSource.this.onDataSourceFailed(mIndex, dataSource);
+                }
+            }
+
+            @Override
+            public void onFailure(DataSource<T> dataSource) {
+                IncreasingQualityDataSource.this.onDataSourceFailed(mIndex, dataSource);
+            }
+
+            @Override
+            public void onCancellation(DataSource<T> dataSource) {
+            }
+
+            @Override
+            public void onProgressUpdate(DataSource<T> dataSource) {
+                if (mIndex == 0) {
+                    IncreasingQualityDataSource.this.setProgress(dataSource.getProgress());
+                }
+            }
         }
-      }
     }
-  }
 }
diff --git a/fbcore/src/main/java/com/facebook/datasource/SettableDataSource.java b/fbcore/src/main/java/com/facebook/datasource/SettableDataSource.java
index addf0cc74..d87388245 100644
--- a/fbcore/src/main/java/com/facebook/datasource/SettableDataSource.java
+++ b/fbcore/src/main/java/com/facebook/datasource/SettableDataSource.java
@@ -16,71 +16,71 @@
  */
 public class SettableDataSource<T> extends AbstractDataSource<T> {
 
-  private SettableDataSource() {
-  }
+    private SettableDataSource() {
+    }
 
-  /**
-   * Creates a new {@link SettableDataSource}.
-   */
-  public static <T> SettableDataSource<T> create() {
-    return new SettableDataSource<T>();
-  }
+    /**
+     * Creates a new {@link SettableDataSource}.
+     */
+    public static <T> SettableDataSource<T> create() {
+        return new SettableDataSource<T>();
+    }
 
-  /**
-   * Sets the result to {@code value}.
-   *
-   * <p> This method will return {@code true} if the value was successfully set, or
-   * {@code false} if the data source has already been set, failed or closed.
-   *
-   * <p> If the value was successfully set and {@code isLast} is {@code true}, state of the
-   * data source will be set to {@link AbstractDataSource.DataSourceStatus#SUCCESS}.
-   *
-   * <p> This will also notify the subscribers if the value was successfully set.
-   *
-   * @param value the value to be set
-   * @param isLast whether or not the value is last.
-   * @return true if the value was successfully set.
-   */
-  @Override
-  public boolean setResult(T value, boolean isLast) {
-    return super.setResult(Preconditions.checkNotNull(value), isLast);
-  }
+    /**
+     * Sets the result to {@code value}.
+     * <p>
+     * <p> This method will return {@code true} if the value was successfully set, or
+     * {@code false} if the data source has already been set, failed or closed.
+     * <p>
+     * <p> If the value was successfully set and {@code isLast} is {@code true}, state of the
+     * data source will be set to {@link AbstractDataSource.DataSourceStatus#SUCCESS}.
+     * <p>
+     * <p> This will also notify the subscribers if the value was successfully set.
+     *
+     * @param value  the value to be set
+     * @param isLast whether or not the value is last.
+     * @return true if the value was successfully set.
+     */
+    @Override
+    public boolean setResult(T value, boolean isLast) {
+        return super.setResult(Preconditions.checkNotNull(value), isLast);
+    }
 
-  /**
-   * Sets the value as the last result.
-   * <p> See {@link #setResult(T value, boolean isLast)}.
-   */
-  public boolean setResult(T value) {
-    return super.setResult(Preconditions.checkNotNull(value), /* isLast */ true);
-  }
+    /**
+     * Sets the value as the last result.
+     * <p> See {@link #setResult(T value, boolean isLast)}.
+     */
+    public boolean setResult(T value) {
+        return super.setResult(Preconditions.checkNotNull(value), /* isLast */ true);
+    }
 
-  /**
-   * Sets the failure.
-   *
-   * <p> This method will return {@code true} if the failure was successfully set, or
-   * {@code false} if the data source has already been set, failed or closed.
-   *
-   * <p> If the failure was successfully set, state of the data source will be set to
-   * {@link AbstractDataSource.DataSourceStatus#FAILURE}.
-   *
-   * <p> This will also notify the subscribers if the failure was successfully set.
-   *
-   * @param throwable the failure cause to be set.
-   * @return true if the failure was successfully set.
-   */
-  @Override
-  public boolean setFailure(Throwable throwable) {
-    return super.setFailure(Preconditions.checkNotNull(throwable));
-  }
+    /**
+     * Sets the failure.
+     * <p>
+     * <p> This method will return {@code true} if the failure was successfully set, or
+     * {@code false} if the data source has already been set, failed or closed.
+     * <p>
+     * <p> If the failure was successfully set, state of the data source will be set to
+     * {@link AbstractDataSource.DataSourceStatus#FAILURE}.
+     * <p>
+     * <p> This will also notify the subscribers if the failure was successfully set.
+     *
+     * @param throwable the failure cause to be set.
+     * @return true if the failure was successfully set.
+     */
+    @Override
+    public boolean setFailure(Throwable throwable) {
+        return super.setFailure(Preconditions.checkNotNull(throwable));
+    }
 
-  /**
-   * Sets the progress.
-   *
-   * @param progress the progress in range [0, 1] to be set.
-   * @return true if the progress was successfully set.
-   */
-  @Override
-  public boolean setProgress(float progress) {
-    return super.setProgress(progress);
-  }
+    /**
+     * Sets the progress.
+     *
+     * @param progress the progress in range [0, 1] to be set.
+     * @return true if the progress was successfully set.
+     */
+    @Override
+    public boolean setProgress(float progress) {
+        return super.setProgress(progress);
+    }
 }
diff --git a/fbcore/src/main/java/pom.xml b/fbcore/src/main/java/pom.xml
index 6d029b468..20af068ac 100644
--- a/fbcore/src/main/java/pom.xml
+++ b/fbcore/src/main/java/pom.xml
@@ -1,43 +1,43 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-  <parent>
-    <groupId>com.facebook.fbcore</groupId>
-    <artifactId>parent</artifactId>
-    <version>0.0.1-SNAPSHOT</version>
-  </parent>
+    <parent>
+        <groupId>com.facebook.fbcore</groupId>
+        <artifactId>parent</artifactId>
+        <version>0.0.1-SNAPSHOT</version>
+    </parent>
 
-  <artifactId>fbcore</artifactId>
-  <name>FB Core</name>
+    <artifactId>fbcore</artifactId>
+    <name>FB Core</name>
 
-  <dependencies>
-  </dependencies>
+    <dependencies></dependencies>
 
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>templating-maven-plugin</artifactId>
-        <version>1.0-alpha-3</version>
-        <executions>
-          <execution>
-            <goals>
-              <goal>filter-sources</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <configuration>
-          <!--<excludePackageNames></excludePackageNames>-->
-          <links>
-          </links>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>templating-maven-plugin</artifactId>
+                <version>1.0-alpha-3</version>
+                <executions>
+                    <execution>
+                        <goals>
+                            <goal>filter-sources</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-javadoc-plugin</artifactId>
+                <configuration>
+                    <!--<excludePackageNames></excludePackageNames>-->
+                    <links></links>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
 </project>
diff --git a/fbcore/src/test/java/com/facebook/common/executors/HandlerExecutorServiceImplTest.java b/fbcore/src/test/java/com/facebook/common/executors/HandlerExecutorServiceImplTest.java
index 1f9820c21..083f6944e 100644
--- a/fbcore/src/test/java/com/facebook/common/executors/HandlerExecutorServiceImplTest.java
+++ b/fbcore/src/test/java/com/facebook/common/executors/HandlerExecutorServiceImplTest.java
@@ -27,37 +27,37 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class HandlerExecutorServiceImplTest {
 
-  private AtomicInteger mCounter = new AtomicInteger();
+    private AtomicInteger mCounter = new AtomicInteger();
 
-  private HandlerExecutorServiceImpl mExecutorService;
+    private HandlerExecutorServiceImpl mExecutorService;
 
-  Runnable mIncrementCounterRunnable = new Runnable() {
-    @Override
-    public void run() {
-      mCounter.incrementAndGet();
+    Runnable mIncrementCounterRunnable = new Runnable() {
+        @Override
+        public void run() {
+            mCounter.incrementAndGet();
+        }
+    };
+
+    @Before
+    public void setup() {
+        Handler handler = new Handler();
+        mExecutorService = new HandlerExecutorServiceImpl(handler);
+    }
+
+    @Test
+    public void testSimpleExecute() {
+        ShadowLooper.pauseMainLooper();
+        mExecutorService.execute(mIncrementCounterRunnable);
+        Assert.assertEquals(0, mCounter.get());
+        ShadowLooper.unPauseMainLooper();
+        Assert.assertEquals(1, mCounter.get());
+    }
+
+    @Test
+    public void testDelay() {
+        mExecutorService.schedule(mIncrementCounterRunnable, 30, TimeUnit.SECONDS);
+        Assert.assertEquals(0, mCounter.get());
+        Robolectric.shadowOf(ShadowLooper.getMainLooper()).getScheduler().advanceBy(30 * 1000);
+        Assert.assertEquals(1, mCounter.get());
     }
-  };
-
-  @Before
-  public void setup() {
-    Handler handler = new Handler();
-    mExecutorService = new HandlerExecutorServiceImpl(handler);
-  }
-
-  @Test
-  public void testSimpleExecute() {
-    ShadowLooper.pauseMainLooper();
-    mExecutorService.execute(mIncrementCounterRunnable);
-    Assert.assertEquals(0, mCounter.get());
-    ShadowLooper.unPauseMainLooper();
-    Assert.assertEquals(1, mCounter.get());
-  }
-
-  @Test
-  public void testDelay() {
-    mExecutorService.schedule(mIncrementCounterRunnable, 30, TimeUnit.SECONDS);
-    Assert.assertEquals(0, mCounter.get());
-    Robolectric.shadowOf(ShadowLooper.getMainLooper()).getScheduler().advanceBy(30 * 1000);
-    Assert.assertEquals(1, mCounter.get());
-  }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/executors/SerialDelegatingExecutorTest.java b/fbcore/src/test/java/com/facebook/common/executors/SerialDelegatingExecutorTest.java
index 0a50384f2..5c4584266 100644
--- a/fbcore/src/test/java/com/facebook/common/executors/SerialDelegatingExecutorTest.java
+++ b/fbcore/src/test/java/com/facebook/common/executors/SerialDelegatingExecutorTest.java
@@ -16,66 +16,66 @@
 import static org.mockito.Mockito.*;
 
 public class SerialDelegatingExecutorTest {
-  private SerialDelegatingExecutor mSerialDelegatingExecutor;
-  private Executor mExecutor;
-  private Runnable mRunnable;
-
-  @Before
-  public void setUp() {
-    mExecutor = mock(Executor.class);
-    mSerialDelegatingExecutor = new SerialDelegatingExecutor(mExecutor);
-    mRunnable = mock(Runnable.class);
-  }
-
-  @Test
-  public void testSubmitsTask() {
-    mSerialDelegatingExecutor.execute(mRunnable);
-
-    verify(mExecutor).execute(mSerialDelegatingExecutor.mRunnable);
-  }
-
-  @Test
-  public void testExecutesTask() {
-    mSerialDelegatingExecutor.execute(mRunnable);
-    mSerialDelegatingExecutor.mRunnable.run();
-
-    verify(mRunnable).run();
-  }
-
-  @Test
-  public void testDoesNotSubmitMultipleRunnables() {
-    mSerialDelegatingExecutor.execute(mRunnable);
-    mSerialDelegatingExecutor.execute(mRunnable);
-
-    verify(mExecutor).execute(mSerialDelegatingExecutor.mRunnable);
-  }
-
-  @Test
-  public void testDoesSubmitNextRunnable() {
-    mSerialDelegatingExecutor.execute(mRunnable);
-    mSerialDelegatingExecutor.execute(mRunnable);
-    mSerialDelegatingExecutor.mRunnable.run();
-
-    verify(mExecutor, times(2)).execute(mSerialDelegatingExecutor.mRunnable);
-  }
-
-  @Test
-  public void testExecutesMultipleTasks() {
-    mSerialDelegatingExecutor.execute(mRunnable);
-    mSerialDelegatingExecutor.execute(mRunnable);
-    mSerialDelegatingExecutor.mRunnable.run();
-    mSerialDelegatingExecutor.mRunnable.run();
-
-    verify(mRunnable, times(2)).run();
-  }
-
-  @Test
-  public void testDoesNotSubmitRunnableTooManyTimes() {
-    mSerialDelegatingExecutor.execute(mRunnable);
-    mSerialDelegatingExecutor.execute(mRunnable);
-    mSerialDelegatingExecutor.mRunnable.run();
-    mSerialDelegatingExecutor.mRunnable.run();
-
-    verify(mExecutor, times(2)).execute(mSerialDelegatingExecutor.mRunnable);
-  }
+    private SerialDelegatingExecutor mSerialDelegatingExecutor;
+    private Executor mExecutor;
+    private Runnable mRunnable;
+
+    @Before
+    public void setUp() {
+        mExecutor = mock(Executor.class);
+        mSerialDelegatingExecutor = new SerialDelegatingExecutor(mExecutor);
+        mRunnable = mock(Runnable.class);
+    }
+
+    @Test
+    public void testSubmitsTask() {
+        mSerialDelegatingExecutor.execute(mRunnable);
+
+        verify(mExecutor).execute(mSerialDelegatingExecutor.mRunnable);
+    }
+
+    @Test
+    public void testExecutesTask() {
+        mSerialDelegatingExecutor.execute(mRunnable);
+        mSerialDelegatingExecutor.mRunnable.run();
+
+        verify(mRunnable).run();
+    }
+
+    @Test
+    public void testDoesNotSubmitMultipleRunnables() {
+        mSerialDelegatingExecutor.execute(mRunnable);
+        mSerialDelegatingExecutor.execute(mRunnable);
+
+        verify(mExecutor).execute(mSerialDelegatingExecutor.mRunnable);
+    }
+
+    @Test
+    public void testDoesSubmitNextRunnable() {
+        mSerialDelegatingExecutor.execute(mRunnable);
+        mSerialDelegatingExecutor.execute(mRunnable);
+        mSerialDelegatingExecutor.mRunnable.run();
+
+        verify(mExecutor, times(2)).execute(mSerialDelegatingExecutor.mRunnable);
+    }
+
+    @Test
+    public void testExecutesMultipleTasks() {
+        mSerialDelegatingExecutor.execute(mRunnable);
+        mSerialDelegatingExecutor.execute(mRunnable);
+        mSerialDelegatingExecutor.mRunnable.run();
+        mSerialDelegatingExecutor.mRunnable.run();
+
+        verify(mRunnable, times(2)).run();
+    }
+
+    @Test
+    public void testDoesNotSubmitRunnableTooManyTimes() {
+        mSerialDelegatingExecutor.execute(mRunnable);
+        mSerialDelegatingExecutor.execute(mRunnable);
+        mSerialDelegatingExecutor.mRunnable.run();
+        mSerialDelegatingExecutor.mRunnable.run();
+
+        verify(mExecutor, times(2)).execute(mSerialDelegatingExecutor.mRunnable);
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/executors/StatefulRunnableTest.java b/fbcore/src/test/java/com/facebook/common/executors/StatefulRunnableTest.java
index 984e00041..d077c20ba 100644
--- a/fbcore/src/test/java/com/facebook/common/executors/StatefulRunnableTest.java
+++ b/fbcore/src/test/java/com/facebook/common/executors/StatefulRunnableTest.java
@@ -26,90 +26,90 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class StatefulRunnableTest {
 
-  private StatefulRunnable mStatefulRunnable;
-  private Object mResult;
-  private ConcurrentModificationException mException;
-
-  @Before
-  public void setUp() throws Exception {
-    mResult = new Object();
-    mException = new ConcurrentModificationException();
-    mStatefulRunnable = mock(StatefulRunnable.class, CALLS_REAL_METHODS);
-
-    // setup state - no constructor has been run
-    Field mStateField = StatefulRunnable.class.getDeclaredField("mState");
-    mStateField.setAccessible(true);
-    mStateField.set(mStatefulRunnable, new AtomicInteger(StatefulRunnable.STATE_CREATED));
-    mStateField.setAccessible(false);
-  }
-
-  @Test
-  public void testSuccess() throws Exception {
-    runSuccess();
-    InOrder inOrder = inOrder(mStatefulRunnable);
-    inOrder.verify(mStatefulRunnable).onSuccess(mResult);
-    inOrder.verify(mStatefulRunnable).disposeResult(mResult);
-  }
-
-  @Test
-  public void testClosesResultWhenOnSuccessThrows() throws Exception {
-    doThrow(mException).when(mStatefulRunnable).onSuccess(mResult);
-    try {
-      runSuccess();
-      fail();
-    } catch (ConcurrentModificationException cme) {
-      // expected
+    private StatefulRunnable mStatefulRunnable;
+    private Object mResult;
+    private ConcurrentModificationException mException;
+
+    @Before
+    public void setUp() throws Exception {
+        mResult = new Object();
+        mException = new ConcurrentModificationException();
+        mStatefulRunnable = mock(StatefulRunnable.class, CALLS_REAL_METHODS);
+
+        // setup state - no constructor has been run
+        Field mStateField = StatefulRunnable.class.getDeclaredField("mState");
+        mStateField.setAccessible(true);
+        mStateField.set(mStatefulRunnable, new AtomicInteger(StatefulRunnable.STATE_CREATED));
+        mStateField.setAccessible(false);
+    }
+
+    @Test
+    public void testSuccess() throws Exception {
+        runSuccess();
+        InOrder inOrder = inOrder(mStatefulRunnable);
+        inOrder.verify(mStatefulRunnable).onSuccess(mResult);
+        inOrder.verify(mStatefulRunnable).disposeResult(mResult);
+    }
+
+    @Test
+    public void testClosesResultWhenOnSuccessThrows() throws Exception {
+        doThrow(mException).when(mStatefulRunnable).onSuccess(mResult);
+        try {
+            runSuccess();
+            fail();
+        } catch (ConcurrentModificationException cme) {
+            // expected
+        }
+        verify(mStatefulRunnable).disposeResult(mResult);
+    }
+
+    @Test
+    public void testFailure() throws Exception {
+        runFailure();
+        verify(mStatefulRunnable).onFailure(mException);
+    }
+
+    @Test
+    public void testDoesNotRunAgainAfterStarted() throws Exception {
+        mStatefulRunnable.mState.set(StatefulRunnable.STATE_STARTED);
+        runSuccess();
+        verify(mStatefulRunnable, never()).getResult();
+    }
+
+    @Test
+    public void testCancellation() {
+        mStatefulRunnable.cancel();
+        verify(mStatefulRunnable).onCancellation();
+    }
+
+    @Test
+    public void testDoesNotRunAfterCancellation() throws Exception {
+        mStatefulRunnable.cancel();
+        runSuccess();
+        verify(mStatefulRunnable, never()).getResult();
+    }
+
+    @Test
+    public void testDoesNotCancelTwice() {
+        mStatefulRunnable.cancel();
+        mStatefulRunnable.cancel();
+        verify(mStatefulRunnable).onCancellation();
+    }
+
+    @Test
+    public void testDoesNotCancelAfterStarted() {
+        mStatefulRunnable.mState.set(StatefulRunnable.STATE_STARTED);
+        mStatefulRunnable.cancel();
+        verify(mStatefulRunnable, never()).onCancellation();
+    }
+
+    private void runSuccess() throws Exception {
+        doReturn(mResult).when(mStatefulRunnable).getResult();
+        mStatefulRunnable.run();
+    }
+
+    private void runFailure() throws Exception {
+        doThrow(mException).when(mStatefulRunnable).getResult();
+        mStatefulRunnable.run();
     }
-    verify(mStatefulRunnable).disposeResult(mResult);
-  }
-
-  @Test
-  public void testFailure() throws Exception {
-    runFailure();
-    verify(mStatefulRunnable).onFailure(mException);
-  }
-
-  @Test
-  public void testDoesNotRunAgainAfterStarted() throws Exception {
-    mStatefulRunnable.mState.set(StatefulRunnable.STATE_STARTED);
-    runSuccess();
-    verify(mStatefulRunnable, never()).getResult();
-  }
-
-  @Test
-  public void testCancellation() {
-    mStatefulRunnable.cancel();
-    verify(mStatefulRunnable).onCancellation();
-  }
-
-  @Test
-  public void testDoesNotRunAfterCancellation() throws Exception {
-    mStatefulRunnable.cancel();
-    runSuccess();
-    verify(mStatefulRunnable, never()).getResult();
-  }
-
-  @Test
-  public void testDoesNotCancelTwice() {
-    mStatefulRunnable.cancel();
-    mStatefulRunnable.cancel();
-    verify(mStatefulRunnable).onCancellation();
-  }
-
-  @Test
-  public void testDoesNotCancelAfterStarted() {
-    mStatefulRunnable.mState.set(StatefulRunnable.STATE_STARTED);
-    mStatefulRunnable.cancel();
-    verify(mStatefulRunnable, never()).onCancellation();
-  }
-
-  private void runSuccess() throws Exception {
-    doReturn(mResult).when(mStatefulRunnable).getResult();
-    mStatefulRunnable.run();
-  }
-
-  private void runFailure() throws Exception {
-    doThrow(mException).when(mStatefulRunnable).getResult();
-    mStatefulRunnable.run();
-  }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/file/FileUtilsTest.java b/fbcore/src/test/java/com/facebook/common/file/FileUtilsTest.java
index a27d83f5c..f7d6ae41d 100644
--- a/fbcore/src/test/java/com/facebook/common/file/FileUtilsTest.java
+++ b/fbcore/src/test/java/com/facebook/common/file/FileUtilsTest.java
@@ -22,74 +22,74 @@
  */
 public class FileUtilsTest {
 
-  @Test
-  public void testMkDirsNoWorkRequired() {
-    File directory = mock(File.class);
-    when(directory.exists()).thenReturn(true);
-    when(directory.isDirectory()).thenReturn(true);
-    try {
-      FileUtils.mkdirs(directory);
-    } catch (FileUtils.CreateDirectoryException cde) {
-      assertTrue(false);
+    @Test
+    public void testMkDirsNoWorkRequired() {
+        File directory = mock(File.class);
+        when(directory.exists()).thenReturn(true);
+        when(directory.isDirectory()).thenReturn(true);
+        try {
+            FileUtils.mkdirs(directory);
+        } catch (FileUtils.CreateDirectoryException cde) {
+            assertTrue(false);
+        }
     }
-  }
 
-  @Test
-  public void testMkDirsSuccessfulCreate() {
-    File directory = mock(File.class);
-    when(directory.exists()).thenReturn(false);
-    when(directory.mkdirs()).thenReturn(true);
-    when(directory.isDirectory()).thenReturn(true);
-    try {
-      FileUtils.mkdirs(directory);
-    } catch (FileUtils.CreateDirectoryException cde) {
-      assertTrue(false);
+    @Test
+    public void testMkDirsSuccessfulCreate() {
+        File directory = mock(File.class);
+        when(directory.exists()).thenReturn(false);
+        when(directory.mkdirs()).thenReturn(true);
+        when(directory.isDirectory()).thenReturn(true);
+        try {
+            FileUtils.mkdirs(directory);
+        } catch (FileUtils.CreateDirectoryException cde) {
+            assertTrue(false);
+        }
     }
-  }
 
-  @Test
-  public void testMkDirsCantDeleteExisting() {
-    File directory = mock(File.class);
-    when(directory.exists()).thenReturn(true);
-    when(directory.isDirectory()).thenReturn(false);
-    when(directory.delete()).thenReturn(false);
-    try {
-      FileUtils.mkdirs(directory);
-      assertTrue(false);
-    } catch (FileUtils.CreateDirectoryException cde) {
-      assertTrue(cde.getCause() instanceof FileUtils.FileDeleteException);
+    @Test
+    public void testMkDirsCantDeleteExisting() {
+        File directory = mock(File.class);
+        when(directory.exists()).thenReturn(true);
+        when(directory.isDirectory()).thenReturn(false);
+        when(directory.delete()).thenReturn(false);
+        try {
+            FileUtils.mkdirs(directory);
+            assertTrue(false);
+        } catch (FileUtils.CreateDirectoryException cde) {
+            assertTrue(cde.getCause() instanceof FileUtils.FileDeleteException);
+        }
     }
-  }
 
-  @Test
-  public void testRenameSuccessful() {
-    File sourceFile = mock(File.class);
-    File targetFile = mock(File.class);
+    @Test
+    public void testRenameSuccessful() {
+        File sourceFile = mock(File.class);
+        File targetFile = mock(File.class);
 
-    when(sourceFile.renameTo(targetFile)).thenReturn(true);
+        when(sourceFile.renameTo(targetFile)).thenReturn(true);
 
-    try {
-      FileUtils.rename(sourceFile, targetFile);
-    } catch (FileUtils.RenameException re) {
-      assertTrue(false);
+        try {
+            FileUtils.rename(sourceFile, targetFile);
+        } catch (FileUtils.RenameException re) {
+            assertTrue(false);
+        }
     }
-  }
 
-  @Test
-  public void testParentDirNotFoundExceptionIsThrown() {
-    File parentFile = mock(File.class);
-    File sourceFile = mock(File.class);
-    File targetFile = mock(File.class);
+    @Test
+    public void testParentDirNotFoundExceptionIsThrown() {
+        File parentFile = mock(File.class);
+        File sourceFile = mock(File.class);
+        File targetFile = mock(File.class);
 
-    when(sourceFile.getParentFile()).thenReturn(parentFile);
-    when(sourceFile.getAbsolutePath()).thenReturn("<source>");
-    when(targetFile.getAbsolutePath()).thenReturn("<destination>");
+        when(sourceFile.getParentFile()).thenReturn(parentFile);
+        when(sourceFile.getAbsolutePath()).thenReturn("<source>");
+        when(targetFile.getAbsolutePath()).thenReturn("<destination>");
 
-    try {
-      FileUtils.rename(sourceFile, targetFile);
-      assertTrue(false);
-    } catch (FileUtils.RenameException re) {
-      assertTrue(re.getCause() instanceof FileUtils.ParentDirNotFoundException);
+        try {
+            FileUtils.rename(sourceFile, targetFile);
+            assertTrue(false);
+        } catch (FileUtils.RenameException re) {
+            assertTrue(re.getCause() instanceof FileUtils.ParentDirNotFoundException);
+        }
     }
-  }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/media/MediaUtilsTest.java b/fbcore/src/test/java/com/facebook/common/media/MediaUtilsTest.java
index de2c13cee..10b344494 100644
--- a/fbcore/src/test/java/com/facebook/common/media/MediaUtilsTest.java
+++ b/fbcore/src/test/java/com/facebook/common/media/MediaUtilsTest.java
@@ -23,70 +23,70 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class MediaUtilsTest {
 
-  @Test
-  public void testIsPhotoMimeTypeNull() {
-    assertThat(MediaUtils.isPhoto(null)).isFalse();
-  }
-
-  @Test
-  public void testIsPhotoMimeTypeImage() {
-    assertThat(MediaUtils.isPhoto("image/jpg")).isTrue();
-  }
-
-  @Test
-  public void testIsPhotoMimeTypeVideo() {
-    assertThat(MediaUtils.isPhoto("video/mp4")).isFalse();
-  }
-
-  @Test
-  public void testIsVideoMimeTypeNull() {
-    assertThat(MediaUtils.isVideo(null)).isFalse();
-  }
-
-  @Test
-  public void testIsVideoMimeTypeImage() {
-    assertThat(MediaUtils.isVideo("image/jpg")).isFalse();
-  }
-
-  @Test
-  public void testIsVideoMimeTypeVideo() {
-    assertThat(MediaUtils.isVideo("video/mp4")).isTrue();
-  }
-
-  @Test
-  public void testExtractMimeNoFileExtension() {
-    String path = "file/with/no/extension";
-    assertThat(MediaUtils.extractMime(path)).isNull();
-  }
-
-  @Test
-  public void testExtractMimeNativelySupportedFileExtension() {
-    ShadowMimeTypeMap mimeTypeMap = Robolectric.shadowOf(MimeTypeMap.getSingleton());
-    mimeTypeMap.addExtensionMimeTypMapping("jpg", "image/jpg");
-
-    String path = "file/with/natively/supported/extension.jpg";
-    assertThat(MediaUtils.extractMime(path)).isEqualTo("image/jpg");
-  }
-
-  @Test
-  public void testExtractMimeNonNativelySupportedFileExtension() {
-    String path = "file/with/non/natively/supported/extension.mkv";
-    assertThat(MediaUtils.extractMime(path)).isEqualTo("video/x-matroska");
-  }
-
-  @Test
-  public void testExtractMimeUnsupportedFileExtension() {
-    String path = "file/with/unsupported/extension.zip";
-    assertThat(MediaUtils.extractMime(path)).isNull();
-  }
-
-  @Test
-   public void testIsNonNativeSupportedMimeTypeNative() {
-    assertThat(MediaUtils.isNonNativeSupportedMimeType("image/jpg")).isFalse();
-  }
-
-  @Test
-  public void testIsNonNativeSupportedMimeTypeNonNative() {
-    assertThat(MediaUtils.isNonNativeSupportedMimeType("video/x-matroska")).isTrue();
-  }
+    @Test
+    public void testIsPhotoMimeTypeNull() {
+        assertThat(MediaUtils.isPhoto(null)).isFalse();
+    }
+
+    @Test
+    public void testIsPhotoMimeTypeImage() {
+        assertThat(MediaUtils.isPhoto("image/jpg")).isTrue();
+    }
+
+    @Test
+    public void testIsPhotoMimeTypeVideo() {
+        assertThat(MediaUtils.isPhoto("video/mp4")).isFalse();
+    }
+
+    @Test
+    public void testIsVideoMimeTypeNull() {
+        assertThat(MediaUtils.isVideo(null)).isFalse();
+    }
+
+    @Test
+    public void testIsVideoMimeTypeImage() {
+        assertThat(MediaUtils.isVideo("image/jpg")).isFalse();
+    }
+
+    @Test
+    public void testIsVideoMimeTypeVideo() {
+        assertThat(MediaUtils.isVideo("video/mp4")).isTrue();
+    }
+
+    @Test
+    public void testExtractMimeNoFileExtension() {
+        String path = "file/with/no/extension";
+        assertThat(MediaUtils.extractMime(path)).isNull();
+    }
+
+    @Test
+    public void testExtractMimeNativelySupportedFileExtension() {
+        ShadowMimeTypeMap mimeTypeMap = Robolectric.shadowOf(MimeTypeMap.getSingleton());
+        mimeTypeMap.addExtensionMimeTypMapping("jpg", "image/jpg");
+
+        String path = "file/with/natively/supported/extension.jpg";
+        assertThat(MediaUtils.extractMime(path)).isEqualTo("image/jpg");
+    }
+
+    @Test
+    public void testExtractMimeNonNativelySupportedFileExtension() {
+        String path = "file/with/non/natively/supported/extension.mkv";
+        assertThat(MediaUtils.extractMime(path)).isEqualTo("video/x-matroska");
+    }
+
+    @Test
+    public void testExtractMimeUnsupportedFileExtension() {
+        String path = "file/with/unsupported/extension.zip";
+        assertThat(MediaUtils.extractMime(path)).isNull();
+    }
+
+    @Test
+    public void testIsNonNativeSupportedMimeTypeNative() {
+        assertThat(MediaUtils.isNonNativeSupportedMimeType("image/jpg")).isFalse();
+    }
+
+    @Test
+    public void testIsNonNativeSupportedMimeTypeNonNative() {
+        assertThat(MediaUtils.isNonNativeSupportedMimeType("video/x-matroska")).isTrue();
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/objectpool/ObjectPoolTest.java b/fbcore/src/test/java/com/facebook/common/objectpool/ObjectPoolTest.java
index ee1b52886..9b62ba487 100644
--- a/fbcore/src/test/java/com/facebook/common/objectpool/ObjectPoolTest.java
+++ b/fbcore/src/test/java/com/facebook/common/objectpool/ObjectPoolTest.java
@@ -27,160 +27,160 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class ObjectPoolTest {
 
-  private FakeClock fakeClock;
-
-  @Before
-  public void setUp() throws Exception {
-    this.fakeClock = new FakeClock();
-  }
-
-  @Test
-  public void testPoolConstruction() {
-    ObjectPoolManager manager = new ObjectPoolManager(fakeClock);
-    TestAllocator alloc = new TestAllocator();
-    ObjectPool<String> pool = manager.createPoolBuilder(String.class)
-        .setMinimumSize(101)
-        .setMaximumSize(303)
-        .setIncrementSize(18)
-        .setCompactionDelay(805)
-        .setAllocator(alloc)
-        .build();
-
-    assertEquals(101, pool.getMinimumSize());
-    assertEquals(303, pool.getMaximumSize());
-    assertEquals(805, pool.getCompactionDelayMs());
-    assertEquals(18, pool.getIncrementSize());
-
-    // make sure the allocator we specified is actually the one attached to the pool
-    String s = pool.allocate();
-    assertEquals(1, alloc.allocateCallCount);
-    pool.release(s);
-    assertEquals(1, alloc.releaseCallCount);
-  }
-
-  @Test
-  public void testPool() {
-    ObjectPoolManager manager = new ObjectPoolManager(fakeClock);
-    TestAllocator alloc = new TestAllocator();
-    ObjectPool<String> pool = manager.createPoolBuilder(String.class)
-        .setMinimumSize(16)
-        .setMaximumSize(100)
-        .setIncrementSize(16)
-        .setCompactionDelay(100)
-        .setAllocator(alloc)
-        .build();
-
-    // The new pool we got should be the same pool we get from the manager afterwards
-    assertEquals(pool, manager.getPool(String.class));
-
-    String s = pool.allocate();
-    // Only check that create must be called at least this many times, to account for the pool
-    // possibly eagerly creating objects to fill the pool
-    assertTrue(alloc.createCallCount >= 1);
-    // Our allocator should be notified whenever there is an allocation
-    assertEquals(1, alloc.allocateCallCount);
-    assertTrue(s != null);
-    // Allocating one object should not have changed the backing size of the array
-    assertEquals(pool.getMinimumSize(), pool.getPoolSize());
-    int poolSize = pool.getPooledObjectCount();
-    pool.release(s);
-    // ... or a release
-    assertEquals(1, alloc.releaseCallCount);
-    // The object should have returned to the pool
-    assertEquals(poolSize + 1, pool.getPooledObjectCount());
-    // Our minimum size was enough that we should not have had to increase the pool size
-    assertEquals(pool.getMinimumSize(), pool.getPoolSize());
-    int prevCallCount = alloc.createCallCount;
-    s = pool.allocate();
-    // Reallocating from the pool should call our allocation function again even though it should
-    // be serviced from the pool
-    assertEquals(prevCallCount, alloc.createCallCount);
-    assertEquals(2, alloc.allocateCallCount);
-
-
-    alloc.resetCallCounts();
-    Vector<String> store = new Vector<String>();
-    for (int i = 0; i < pool.getMinimumSize() + 1; ++i) {
-      store.add(pool.allocate());
-    }
-    // We shouldn't have increased the pool size during allocation
-    assertEquals(pool.getMinimumSize(), pool.getPoolSize());
-    for (String str : store) {
-      pool.release(str);
-    }
-    store.clear();
-
-    // ... but we should have upon releasing
-    assertEquals(pool.getMinimumSize() + pool.getIncrementSize(), pool.getPoolSize());
-
-    alloc.resetCallCounts();
-    for (int i = 0; i < pool.getIncrementSize() * 2 + 1; ++i) {
-      store.add(pool.allocate());
-    }
-    for (String str : store) {
-      pool.release(str);
-    }
-    store.clear();
-    pool.checkUsage();
-    // We should not have resized our pool yet because the clock has not advanced
-    assertEquals(pool.getMinimumSize() + pool.getIncrementSize() * 2, pool.getPoolSize());
-
-    fakeClock.incrementBy(pool.getCompactionDelayMs() + 1);
-    pool.checkUsage();
-    // We should have lopped off incrementSize number of elements in our pool
-    assertEquals(pool.getMinimumSize() + pool.getIncrementSize(), pool.getPoolSize());
-
-    // If we force a compaction, then it must shrink
-    pool.compactUsage();
-    assertEquals(pool.getMinimumSize(), pool.getPoolSize());
-
-    for (int i = 0; i < 2 * pool.getMaximumSize(); ++i) {
-      store.add(pool.allocate());
-    }
-    for (String str : store) {
-      pool.release(str);
-    }
-    store.clear();
-    // Regardless of how many objects we allocate, we should only have up to the maximum
-    assertEquals(pool.getMaximumSize(), pool.getPoolSize());
-  }
-
-  public class TestAllocator extends ObjectPool.BasicAllocator<String> {
-    public int createCallCount;
-    public int allocateCallCount;
-    public int releaseCallCount;
-
-    public TestAllocator() {
-      super(String.class);
-      resetCallCounts();
-    }
+    private FakeClock fakeClock;
 
-    public void resetCallCounts() {
-      createCallCount = 0;
-      allocateCallCount = 0;
-      releaseCallCount = 0;
+    @Before
+    public void setUp() throws Exception {
+        this.fakeClock = new FakeClock();
     }
 
-    @Override
-    public String create() {
-      ++createCallCount;
-      String s = super.create();
-      assertNotNull(s);
-      return s;
+    @Test
+    public void testPoolConstruction() {
+        ObjectPoolManager manager = new ObjectPoolManager(fakeClock);
+        TestAllocator alloc = new TestAllocator();
+        ObjectPool<String> pool = manager.createPoolBuilder(String.class)
+                .setMinimumSize(101)
+                .setMaximumSize(303)
+                .setIncrementSize(18)
+                .setCompactionDelay(805)
+                .setAllocator(alloc)
+                .build();
+
+        assertEquals(101, pool.getMinimumSize());
+        assertEquals(303, pool.getMaximumSize());
+        assertEquals(805, pool.getCompactionDelayMs());
+        assertEquals(18, pool.getIncrementSize());
+
+        // make sure the allocator we specified is actually the one attached to the pool
+        String s = pool.allocate();
+        assertEquals(1, alloc.allocateCallCount);
+        pool.release(s);
+        assertEquals(1, alloc.releaseCallCount);
     }
 
-    @Override
-    public void onAllocate(String obj) {
-      ++allocateCallCount;
-      assertNotNull(obj);
-      super.onAllocate(obj);
+    @Test
+    public void testPool() {
+        ObjectPoolManager manager = new ObjectPoolManager(fakeClock);
+        TestAllocator alloc = new TestAllocator();
+        ObjectPool<String> pool = manager.createPoolBuilder(String.class)
+                .setMinimumSize(16)
+                .setMaximumSize(100)
+                .setIncrementSize(16)
+                .setCompactionDelay(100)
+                .setAllocator(alloc)
+                .build();
+
+        // The new pool we got should be the same pool we get from the manager afterwards
+        assertEquals(pool, manager.getPool(String.class));
+
+        String s = pool.allocate();
+        // Only check that create must be called at least this many times, to account for the pool
+        // possibly eagerly creating objects to fill the pool
+        assertTrue(alloc.createCallCount >= 1);
+        // Our allocator should be notified whenever there is an allocation
+        assertEquals(1, alloc.allocateCallCount);
+        assertTrue(s != null);
+        // Allocating one object should not have changed the backing size of the array
+        assertEquals(pool.getMinimumSize(), pool.getPoolSize());
+        int poolSize = pool.getPooledObjectCount();
+        pool.release(s);
+        // ... or a release
+        assertEquals(1, alloc.releaseCallCount);
+        // The object should have returned to the pool
+        assertEquals(poolSize + 1, pool.getPooledObjectCount());
+        // Our minimum size was enough that we should not have had to increase the pool size
+        assertEquals(pool.getMinimumSize(), pool.getPoolSize());
+        int prevCallCount = alloc.createCallCount;
+        s = pool.allocate();
+        // Reallocating from the pool should call our allocation function again even though it should
+        // be serviced from the pool
+        assertEquals(prevCallCount, alloc.createCallCount);
+        assertEquals(2, alloc.allocateCallCount);
+
+
+        alloc.resetCallCounts();
+        Vector<String> store = new Vector<String>();
+        for (int i = 0; i < pool.getMinimumSize() + 1; ++i) {
+            store.add(pool.allocate());
+        }
+        // We shouldn't have increased the pool size during allocation
+        assertEquals(pool.getMinimumSize(), pool.getPoolSize());
+        for (String str : store) {
+            pool.release(str);
+        }
+        store.clear();
+
+        // ... but we should have upon releasing
+        assertEquals(pool.getMinimumSize() + pool.getIncrementSize(), pool.getPoolSize());
+
+        alloc.resetCallCounts();
+        for (int i = 0; i < pool.getIncrementSize() * 2 + 1; ++i) {
+            store.add(pool.allocate());
+        }
+        for (String str : store) {
+            pool.release(str);
+        }
+        store.clear();
+        pool.checkUsage();
+        // We should not have resized our pool yet because the clock has not advanced
+        assertEquals(pool.getMinimumSize() + pool.getIncrementSize() * 2, pool.getPoolSize());
+
+        fakeClock.incrementBy(pool.getCompactionDelayMs() + 1);
+        pool.checkUsage();
+        // We should have lopped off incrementSize number of elements in our pool
+        assertEquals(pool.getMinimumSize() + pool.getIncrementSize(), pool.getPoolSize());
+
+        // If we force a compaction, then it must shrink
+        pool.compactUsage();
+        assertEquals(pool.getMinimumSize(), pool.getPoolSize());
+
+        for (int i = 0; i < 2 * pool.getMaximumSize(); ++i) {
+            store.add(pool.allocate());
+        }
+        for (String str : store) {
+            pool.release(str);
+        }
+        store.clear();
+        // Regardless of how many objects we allocate, we should only have up to the maximum
+        assertEquals(pool.getMaximumSize(), pool.getPoolSize());
     }
 
-    @Override
-    public void onRelease(String obj) {
-      ++releaseCallCount;
-      assertNotNull(obj);
-      super.onRelease(obj);
+    public class TestAllocator extends ObjectPool.BasicAllocator<String> {
+        public int createCallCount;
+        public int allocateCallCount;
+        public int releaseCallCount;
+
+        public TestAllocator() {
+            super(String.class);
+            resetCallCounts();
+        }
+
+        public void resetCallCounts() {
+            createCallCount = 0;
+            allocateCallCount = 0;
+            releaseCallCount = 0;
+        }
+
+        @Override
+        public String create() {
+            ++createCallCount;
+            String s = super.create();
+            assertNotNull(s);
+            return s;
+        }
+
+        @Override
+        public void onAllocate(String obj) {
+            ++allocateCallCount;
+            assertNotNull(obj);
+            super.onAllocate(obj);
+        }
+
+        @Override
+        public void onRelease(String obj) {
+            ++releaseCallCount;
+            assertNotNull(obj);
+            super.onRelease(obj);
+        }
     }
-  }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/references/CloseableReferenceTest.java b/fbcore/src/test/java/com/facebook/common/references/CloseableReferenceTest.java
index c8f75b944..8b27fb673 100644
--- a/fbcore/src/test/java/com/facebook/common/references/CloseableReferenceTest.java
+++ b/fbcore/src/test/java/com/facebook/common/references/CloseableReferenceTest.java
@@ -26,45 +26,45 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class CloseableReferenceTest {
 
-  private Closeable mMockCloseable;
-  private CloseableReference<Closeable> mCloseableReference;
+    private Closeable mMockCloseable;
+    private CloseableReference<Closeable> mCloseableReference;
 
-  @Before
-  public void setup() {
-    mMockCloseable = Mockito.mock(Closeable.class);
-    mCloseableReference = CloseableReference.of(mMockCloseable);
-  }
+    @Before
+    public void setup() {
+        mMockCloseable = Mockito.mock(Closeable.class);
+        mCloseableReference = CloseableReference.of(mMockCloseable);
+    }
 
-  @Test
-  public void testCreation() {
-    Assert.assertEquals(1,
-        mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-  }
+    @Test
+    public void testCreation() {
+        Assert.assertEquals(1,
+                mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+    }
 
-  @Test
-  public void testClone() {
-    CloseableReference<Closeable> copy = mCloseableReference.clone();
-    Assert.assertEquals(2,
-        mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-    Assert.assertSame(mCloseableReference.getUnderlyingReferenceTestOnly(),
-        copy.getUnderlyingReferenceTestOnly());
-  }
+    @Test
+    public void testClone() {
+        CloseableReference<Closeable> copy = mCloseableReference.clone();
+        Assert.assertEquals(2,
+                mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+        Assert.assertSame(mCloseableReference.getUnderlyingReferenceTestOnly(),
+                copy.getUnderlyingReferenceTestOnly());
+    }
 
-  @Test
-  public void testCloseReference() {
-    CloseableReference<Closeable> copy = mCloseableReference.clone();
-    Assert.assertEquals(2,
-        mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-    copy.close();
-    Assert.assertEquals(1,
-        mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-  }
+    @Test
+    public void testCloseReference() {
+        CloseableReference<Closeable> copy = mCloseableReference.clone();
+        Assert.assertEquals(2,
+                mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+        copy.close();
+        Assert.assertEquals(1,
+                mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+    }
 
-  @Test
-  public void testCloseWhenRefcount0() throws IOException {
-    mCloseableReference.close();
-    Assert.assertEquals(0,
-        mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-    Mockito.verify(mMockCloseable).close();
-  }
+    @Test
+    public void testCloseWhenRefcount0() throws IOException {
+        mCloseableReference.close();
+        Assert.assertEquals(0,
+                mCloseableReference.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+        Mockito.verify(mMockCloseable).close();
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/references/SharedReferenceTest.java b/fbcore/src/test/java/com/facebook/common/references/SharedReferenceTest.java
index b9eec3fb5..b228cbdea 100644
--- a/fbcore/src/test/java/com/facebook/common/references/SharedReferenceTest.java
+++ b/fbcore/src/test/java/com/facebook/common/references/SharedReferenceTest.java
@@ -16,6 +16,7 @@
 import com.facebook.testing.robolectric.v2.WithTestDefaultsRunner;
 
 import junit.framework.Assert;
+
 import org.robolectric.RobolectricTestRunner;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,118 +28,118 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class SharedReferenceTest {
 
-  /**
-   * Tests out the basic operations (isn't everything a basic operation?)
-   */
-  @Test
-  public void testBasic() {
-
-    // ref count = 1 after creation
-    SharedReference<Thing> tRef = new SharedReference<Thing>(new Thing("abc"), THING_RELEASER);
-    Assert.assertTrue(SharedReference.isValid(tRef));
-    Assert.assertEquals(1, tRef.getRefCountTestOnly());
-    Thing t = tRef.get();
-    Assert.assertEquals("abc", t.get());
-
-    // adding a reference increases the ref count
-    tRef.addReference();
-    Assert.assertTrue(SharedReference.isValid(tRef));
-    Assert.assertEquals(2, tRef.getRefCountTestOnly());
-    Assert.assertEquals(t, tRef.get());
-    Assert.assertEquals("abc", t.get());
-
-    // deleting a reference drops the reference count
-    tRef.deleteReference();
-    Assert.assertTrue(SharedReference.isValid(tRef));
-    Assert.assertEquals(1, tRef.getRefCountTestOnly());
-    Assert.assertEquals(t, tRef.get());
-    Assert.assertEquals("abc", t.get());
-
-    // when the last reference is gone, the underlying object is disposed
-    tRef.deleteReference();
-    Assert.assertFalse(SharedReference.isValid(tRef));
-    Assert.assertEquals(0, tRef.getRefCountTestOnly());
-
-    // adding a reference now should fail
-    try {
-      tRef.addReference();
-      Assert.fail();
-    } catch (SharedReference.NullReferenceException e) {
-      // do nothing
+    /**
+     * Tests out the basic operations (isn't everything a basic operation?)
+     */
+    @Test
+    public void testBasic() {
+
+        // ref count = 1 after creation
+        SharedReference<Thing> tRef = new SharedReference<Thing>(new Thing("abc"), THING_RELEASER);
+        Assert.assertTrue(SharedReference.isValid(tRef));
+        Assert.assertEquals(1, tRef.getRefCountTestOnly());
+        Thing t = tRef.get();
+        Assert.assertEquals("abc", t.get());
+
+        // adding a reference increases the ref count
+        tRef.addReference();
+        Assert.assertTrue(SharedReference.isValid(tRef));
+        Assert.assertEquals(2, tRef.getRefCountTestOnly());
+        Assert.assertEquals(t, tRef.get());
+        Assert.assertEquals("abc", t.get());
+
+        // deleting a reference drops the reference count
+        tRef.deleteReference();
+        Assert.assertTrue(SharedReference.isValid(tRef));
+        Assert.assertEquals(1, tRef.getRefCountTestOnly());
+        Assert.assertEquals(t, tRef.get());
+        Assert.assertEquals("abc", t.get());
+
+        // when the last reference is gone, the underlying object is disposed
+        tRef.deleteReference();
+        Assert.assertFalse(SharedReference.isValid(tRef));
+        Assert.assertEquals(0, tRef.getRefCountTestOnly());
+
+        // adding a reference now should fail
+        try {
+            tRef.addReference();
+            Assert.fail();
+        } catch (SharedReference.NullReferenceException e) {
+            // do nothing
+        }
+
+        // so should deleting a reference
+        try {
+            tRef.deleteReference();
+            Assert.fail();
+        } catch (SharedReference.NullReferenceException e) {
+            // do nothing
+        }
+
+        // null shared references are not 'valid'
+        Assert.assertFalse(SharedReference.isValid(null));
+
+        // test out exceptions during a close
+        SharedReference<Thing> t2Ref = new SharedReference<Thing>(new Thing2("abc"), THING_RELEASER);
+        // this should not throw
+        t2Ref.deleteReference();
     }
 
-    // so should deleting a reference
-    try {
-      tRef.deleteReference();
-      Assert.fail();
-    } catch (SharedReference.NullReferenceException e) {
-      // do nothing
+    @Test
+    public void testNewSharedReference() {
+        final Thing thing = new Thing("abc");
+        Assert.assertSame(thing, new SharedReference(thing, THING_RELEASER).get());
     }
 
-    // null shared references are not 'valid'
-    Assert.assertFalse(SharedReference.isValid(null));
-
-    // test out exceptions during a close
-    SharedReference<Thing> t2Ref = new SharedReference<Thing>(new Thing2("abc"), THING_RELEASER);
-    // this should not throw
-    t2Ref.deleteReference();
-  }
-
-  @Test
-  public void testNewSharedReference() {
-    final Thing thing = new Thing("abc");
-    Assert.assertSame(thing, new SharedReference(thing, THING_RELEASER).get());
-  }
-
-  @Test
-  public void testCustomReleaser() {
-    final Thing thing = new Thing("abc");
-    final ResourceReleaser releaser = Mockito.mock(ResourceReleaser.class);
-    final SharedReference<Thing> tRef = new SharedReference<Thing>(thing, releaser);
-    tRef.deleteReference();
-    Mockito.verify(releaser, Mockito.times(1)).release(thing);
-  }
-
-  public static class Thing implements Closeable {
-    private String mValue;
-
-    public Thing(String value) {
-      mValue = value;
+    @Test
+    public void testCustomReleaser() {
+        final Thing thing = new Thing("abc");
+        final ResourceReleaser releaser = Mockito.mock(ResourceReleaser.class);
+        final SharedReference<Thing> tRef = new SharedReference<Thing>(thing, releaser);
+        tRef.deleteReference();
+        Mockito.verify(releaser, Mockito.times(1)).release(thing);
     }
 
-    public String get() {
-      return mValue;
-    }
+    public static class Thing implements Closeable {
+        private String mValue;
 
-    public void close() throws IOException {
-      mValue = null;
-    }
-  }
+        public Thing(String value) {
+            mValue = value;
+        }
 
-  /**
-   * A subclass of Thing that throws an exception on close
-   */
-  public static class Thing2 extends Thing {
-    private String mValue;
+        public String get() {
+            return mValue;
+        }
 
-    public Thing2(String value) {
-      super(value);
+        public void close() throws IOException {
+            mValue = null;
+        }
     }
 
-    public void close() throws IOException {
-      throw new IOException("");
-    }
-  }
-
-  public final ResourceReleaser<Thing> THING_RELEASER = new ResourceReleaser<Thing>() {
-    @Override
-    public void release(Thing value) {
-      try {
-        Closeables.close(value, true);
-      } catch (IOException ioe) {
-        // this should not happen
-        Assert.fail();
-      }
+    /**
+     * A subclass of Thing that throws an exception on close
+     */
+    public static class Thing2 extends Thing {
+        private String mValue;
+
+        public Thing2(String value) {
+            super(value);
+        }
+
+        public void close() throws IOException {
+            throw new IOException("");
+        }
     }
-  };
+
+    public final ResourceReleaser<Thing> THING_RELEASER = new ResourceReleaser<Thing>() {
+        @Override
+        public void release(Thing value) {
+            try {
+                Closeables.close(value, true);
+            } catch (IOException ioe) {
+                // this should not happen
+                Assert.fail();
+            }
+        }
+    };
 }
diff --git a/fbcore/src/test/java/com/facebook/common/statfs/StatFsHelperTest.java b/fbcore/src/test/java/com/facebook/common/statfs/StatFsHelperTest.java
index 7c88bd18f..494f8d4f5 100644
--- a/fbcore/src/test/java/com/facebook/common/statfs/StatFsHelperTest.java
+++ b/fbcore/src/test/java/com/facebook/common/statfs/StatFsHelperTest.java
@@ -40,202 +40,202 @@
 @Ignore("t6344387")
 public class StatFsHelperTest {
 
-  @Rule
-  public PowerMockRule rule = new PowerMockRule();
+    @Rule
+    public PowerMockRule rule = new PowerMockRule();
+
+    private File mMockFileInternal;
+    private File mMockFileExternal;
+    private StatFs mMockStatFsInternal;
+    private StatFs mMockStatFsExternal;
+
+    private static final String INTERNAL_PATH = "/data";
+    private static final String EXTERNAL_PATH = "/mnt/sdcard/data";
+
+    private static final int INTERNAL_BLOCK_SIZE = 512;
+    private static final int EXTERNAL_BLOCK_SIZE = 2048;
+
+    private static final int INTERNAL_BLOCKS_FREE = 16;
+    private static final int EXTERNAL_BLOCKS_FREE = 32;
+
+    @Before
+    public void setUp() {
+        PowerMockito.mockStatic(Environment.class);
+        PowerMockito.mockStatic(StatFsHelper.class);
+        PowerMockito.mockStatic(SystemClock.class);
+        mMockFileInternal = mock(File.class);
+        mMockFileExternal = mock(File.class);
+        mMockStatFsInternal = mock(StatFs.class);
+        mMockStatFsExternal = mock(StatFs.class);
+        PowerMockito.when(SystemClock.elapsedRealtime()).thenReturn(System.currentTimeMillis());
+    }
+
+    private void expectInternalSetup() {
+        PowerMockito.when(Environment.getDataDirectory()).thenReturn(mMockFileInternal);
+        when(mMockFileInternal.getAbsolutePath()).thenReturn(INTERNAL_PATH);
+        when(mMockFileInternal.exists()).thenReturn(true);
+        PowerMockito.when(StatFsHelper.createStatFs(INTERNAL_PATH)).thenReturn(mMockStatFsInternal);
+        when(mMockStatFsInternal.getBlockSize()).thenReturn(INTERNAL_BLOCK_SIZE);
+        when(mMockStatFsInternal.getAvailableBlocks()).thenReturn(INTERNAL_BLOCKS_FREE);
+    }
+
+    private void expectExternalSetup() {
+        PowerMockito.when(Environment.getExternalStorageDirectory()).thenReturn(mMockFileExternal);
+        when(mMockFileExternal.getAbsolutePath()).thenReturn(EXTERNAL_PATH);
+        when(mMockFileExternal.exists()).thenReturn(true);
+        PowerMockito.when(StatFsHelper.createStatFs(EXTERNAL_PATH)).thenReturn(mMockStatFsExternal);
+        when(mMockStatFsExternal.getBlockSize()).thenReturn(EXTERNAL_BLOCK_SIZE);
+        when(mMockStatFsExternal.getAvailableBlocks()).thenReturn(EXTERNAL_BLOCKS_FREE);
+    }
 
-  private File mMockFileInternal;
-  private File mMockFileExternal;
-  private StatFs mMockStatFsInternal;
-  private StatFs mMockStatFsExternal;
-
-  private static final String INTERNAL_PATH = "/data";
-  private static final String EXTERNAL_PATH = "/mnt/sdcard/data";
-
-  private static final int INTERNAL_BLOCK_SIZE = 512;
-  private static final int EXTERNAL_BLOCK_SIZE = 2048;
-
-  private static final int INTERNAL_BLOCKS_FREE = 16;
-  private static final int EXTERNAL_BLOCKS_FREE = 32;
-
-  @Before
-  public void setUp() {
-    PowerMockito.mockStatic(Environment.class);
-    PowerMockito.mockStatic(StatFsHelper.class);
-    PowerMockito.mockStatic(SystemClock.class);
-    mMockFileInternal = mock(File.class);
-    mMockFileExternal = mock(File.class);
-    mMockStatFsInternal = mock(StatFs.class);
-    mMockStatFsExternal = mock(StatFs.class);
-    PowerMockito.when(SystemClock.elapsedRealtime()).thenReturn(System.currentTimeMillis());
-  }
-
-  private void expectInternalSetup() {
-    PowerMockito.when(Environment.getDataDirectory()).thenReturn(mMockFileInternal);
-    when(mMockFileInternal.getAbsolutePath()).thenReturn(INTERNAL_PATH);
-    when(mMockFileInternal.exists()).thenReturn(true);
-    PowerMockito.when(StatFsHelper.createStatFs(INTERNAL_PATH)).thenReturn(mMockStatFsInternal);
-    when(mMockStatFsInternal.getBlockSize()).thenReturn(INTERNAL_BLOCK_SIZE);
-    when(mMockStatFsInternal.getAvailableBlocks()).thenReturn(INTERNAL_BLOCKS_FREE);
-  }
-
-  private void expectExternalSetup() {
-    PowerMockito.when(Environment.getExternalStorageDirectory()).thenReturn(mMockFileExternal);
-    when(mMockFileExternal.getAbsolutePath()).thenReturn(EXTERNAL_PATH);
-    when(mMockFileExternal.exists()).thenReturn(true);
-    PowerMockito.when(StatFsHelper.createStatFs(EXTERNAL_PATH)).thenReturn(mMockStatFsExternal);
-    when(mMockStatFsExternal.getBlockSize()).thenReturn(EXTERNAL_BLOCK_SIZE);
-    when(mMockStatFsExternal.getAvailableBlocks()).thenReturn(EXTERNAL_BLOCKS_FREE);
-  }
-
-  @Test
-  public void testShouldCreateStatFsForInternalAndExternalStorage() {
+    @Test
+    public void testShouldCreateStatFsForInternalAndExternalStorage() {
 
-    expectInternalSetup();
-    expectExternalSetup();
+        expectInternalSetup();
+        expectExternalSetup();
 
-    StatFsHelper statFsHelper = new StatFsHelper();
+        StatFsHelper statFsHelper = new StatFsHelper();
 
-    long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
-    assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
+        long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
+        assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
 
-    freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
-    assertEquals(EXTERNAL_BLOCK_SIZE * EXTERNAL_BLOCKS_FREE, freeBytes);
+        freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
+        assertEquals(EXTERNAL_BLOCK_SIZE * EXTERNAL_BLOCKS_FREE, freeBytes);
 
-    statFsHelper.resetStats();
+        statFsHelper.resetStats();
 
-    verify(mMockStatFsInternal).restat(INTERNAL_PATH);
-    verify(mMockStatFsExternal).restat(EXTERNAL_PATH);
-  }
+        verify(mMockStatFsInternal).restat(INTERNAL_PATH);
+        verify(mMockStatFsExternal).restat(EXTERNAL_PATH);
+    }
 
-  @Test
-  public void testShouldCreateStatFsForInternalStorageOnly() {
+    @Test
+    public void testShouldCreateStatFsForInternalStorageOnly() {
 
-    expectInternalSetup();
-    // Configure external storage to be absent.
-    PowerMockito.when(Environment.getExternalStorageDirectory()).thenReturn(null);
-    StatFsHelper statFsHelper = new StatFsHelper();
+        expectInternalSetup();
+        // Configure external storage to be absent.
+        PowerMockito.when(Environment.getExternalStorageDirectory()).thenReturn(null);
+        StatFsHelper statFsHelper = new StatFsHelper();
 
-    long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
-    assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
+        long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
+        assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
 
-    freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
-    assertEquals(0, freeBytes);
+        freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
+        assertEquals(0, freeBytes);
 
-    statFsHelper.resetStats();
+        statFsHelper.resetStats();
 
-    verify(mMockStatFsInternal).restat(INTERNAL_PATH);
-  }
+        verify(mMockStatFsInternal).restat(INTERNAL_PATH);
+    }
 
-  @Test
-  public void testShouldHandleNoInternalStorage() {
-    // Configure internal storage to be absent.
-    PowerMockito.when(Environment.getDataDirectory()).thenReturn(null);
-    // Configure external storage to be absent.
-    PowerMockito.when(Environment.getExternalStorageDirectory()).thenReturn(null);
+    @Test
+    public void testShouldHandleNoInternalStorage() {
+        // Configure internal storage to be absent.
+        PowerMockito.when(Environment.getDataDirectory()).thenReturn(null);
+        // Configure external storage to be absent.
+        PowerMockito.when(Environment.getExternalStorageDirectory()).thenReturn(null);
 
-    StatFsHelper statFsHelper = new StatFsHelper();
+        StatFsHelper statFsHelper = new StatFsHelper();
 
-    long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
-    assertEquals(0, freeBytes);
+        long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
+        assertEquals(0, freeBytes);
 
-    freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
-    assertEquals(0, freeBytes);
+        freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
+        assertEquals(0, freeBytes);
 
-    statFsHelper.resetStats();
-  }
+        statFsHelper.resetStats();
+    }
 
 
     @Test
-  public void testShouldHandleExceptionOnExternalCacheCreate() {
+    public void testShouldHandleExceptionOnExternalCacheCreate() {
 
-    expectInternalSetup();
+        expectInternalSetup();
 
-    // Configure external storage to be present but to throw an exception while instantiating
-    // a new StatFs object for external storage.
-    when(mMockFileExternal.getAbsolutePath()).thenReturn(EXTERNAL_PATH);
-    when(mMockFileExternal.exists()).thenReturn(true);
-    PowerMockito.when(StatFsHelper.createStatFs(EXTERNAL_PATH))
-        .thenThrow(new IllegalArgumentException());
+        // Configure external storage to be present but to throw an exception while instantiating
+        // a new StatFs object for external storage.
+        when(mMockFileExternal.getAbsolutePath()).thenReturn(EXTERNAL_PATH);
+        when(mMockFileExternal.exists()).thenReturn(true);
+        PowerMockito.when(StatFsHelper.createStatFs(EXTERNAL_PATH))
+                .thenThrow(new IllegalArgumentException());
 
-    StatFsHelper statFsHelper = new StatFsHelper();
+        StatFsHelper statFsHelper = new StatFsHelper();
 
-    long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
-    assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
+        long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
+        assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
 
-    freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
-    assertEquals(0, freeBytes);
-  }
+        freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
+        assertEquals(0, freeBytes);
+    }
 
-  @Test
-  public void testShouldHandleExceptionOnExternalCacheRestat() {
+    @Test
+    public void testShouldHandleExceptionOnExternalCacheRestat() {
 
-    expectInternalSetup();
-    expectExternalSetup();
-    doThrow(new IllegalArgumentException()).when(mMockStatFsExternal).restat(EXTERNAL_PATH);
+        expectInternalSetup();
+        expectExternalSetup();
+        doThrow(new IllegalArgumentException()).when(mMockStatFsExternal).restat(EXTERNAL_PATH);
 
-    StatFsHelper statFsHelper = new StatFsHelper();
-    statFsHelper.resetStats();
+        StatFsHelper statFsHelper = new StatFsHelper();
+        statFsHelper.resetStats();
 
-    long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
-    assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
+        long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
+        assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
 
-    freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
-    assertEquals(0, freeBytes);
+        freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
+        assertEquals(0, freeBytes);
 
-    verify(mMockStatFsInternal).restat(INTERNAL_PATH);
-  }
+        verify(mMockStatFsInternal).restat(INTERNAL_PATH);
+    }
 
-  @Test
-  public void testShouldHandleExternalStorageRemoved() {
+    @Test
+    public void testShouldHandleExternalStorageRemoved() {
 
-    expectInternalSetup();
-    expectExternalSetup();
+        expectInternalSetup();
+        expectExternalSetup();
 
-    // External dir is present on creation and missing on subsequent resetStatus() calls.
-    when(mMockFileExternal.exists()).thenReturn(true).thenReturn(false);
+        // External dir is present on creation and missing on subsequent resetStatus() calls.
+        when(mMockFileExternal.exists()).thenReturn(true).thenReturn(false);
 
-    StatFsHelper statFsHelper = new StatFsHelper();
-    statFsHelper.resetStats();
+        StatFsHelper statFsHelper = new StatFsHelper();
+        statFsHelper.resetStats();
 
-    long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
-    assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
+        long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
+        assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
 
-    freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
-    assertEquals(0, freeBytes);
+        freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
+        assertEquals(0, freeBytes);
 
-    verify(mMockStatFsInternal).restat(INTERNAL_PATH);
-  }
+        verify(mMockStatFsInternal).restat(INTERNAL_PATH);
+    }
 
-  @Test
-  public void testShouldHandleExternalStorageReinserted() {
+    @Test
+    public void testShouldHandleExternalStorageReinserted() {
 
-    expectInternalSetup();
-    expectExternalSetup();
+        expectInternalSetup();
+        expectExternalSetup();
 
-    // External dir is present on creation, missing on first resetStatus() call, and back on
-    // subsequent resetStatus() calls.
-    when(mMockFileExternal.exists()).thenReturn(true).thenReturn(false).thenReturn(true);
+        // External dir is present on creation, missing on first resetStatus() call, and back on
+        // subsequent resetStatus() calls.
+        when(mMockFileExternal.exists()).thenReturn(true).thenReturn(false).thenReturn(true);
 
-    StatFsHelper statFsHelper = new StatFsHelper();
-    statFsHelper.resetStats();
+        StatFsHelper statFsHelper = new StatFsHelper();
+        statFsHelper.resetStats();
 
-    long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
-    assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
+        long freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.INTERNAL);
+        assertEquals(INTERNAL_BLOCK_SIZE * INTERNAL_BLOCKS_FREE, freeBytes);
 
-    freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
-    assertEquals(0, freeBytes);
+        freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
+        assertEquals(0, freeBytes);
 
-    statFsHelper.resetStats();
+        statFsHelper.resetStats();
 
-    freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
-    assertEquals(EXTERNAL_BLOCK_SIZE * EXTERNAL_BLOCKS_FREE, freeBytes);
+        freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
+        assertEquals(EXTERNAL_BLOCK_SIZE * EXTERNAL_BLOCKS_FREE, freeBytes);
 
-    statFsHelper.resetStats();
+        statFsHelper.resetStats();
 
-    freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
-    assertEquals(EXTERNAL_BLOCK_SIZE * EXTERNAL_BLOCKS_FREE, freeBytes);
+        freeBytes = statFsHelper.getAvailableStorageSpace(StatFsHelper.StorageType.EXTERNAL);
+        assertEquals(EXTERNAL_BLOCK_SIZE * EXTERNAL_BLOCKS_FREE, freeBytes);
 
-    verify(mMockStatFsInternal, times(3)).restat(INTERNAL_PATH);
-    verify(mMockStatFsExternal).restat(EXTERNAL_PATH);
-  }
+        verify(mMockStatFsInternal, times(3)).restat(INTERNAL_PATH);
+        verify(mMockStatFsExternal).restat(EXTERNAL_PATH);
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/streams/LimitedInputStreamTest.java b/fbcore/src/test/java/com/facebook/common/streams/LimitedInputStreamTest.java
index 0587e1860..8af9c12b6 100644
--- a/fbcore/src/test/java/com/facebook/common/streams/LimitedInputStreamTest.java
+++ b/fbcore/src/test/java/com/facebook/common/streams/LimitedInputStreamTest.java
@@ -25,144 +25,144 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class LimitedInputStreamTest {
 
-  private static final int RANDOM_SEED = 1023;
-  private static final int BYTES_LENGTH = 1024;
-  private static final int LIMITED_LENGTH = BYTES_LENGTH / 2;
-
-  private byte[] mData;
-  private byte[] mReadBuffer;
-  private byte[] mZeroTail;
-
-  private ByteArrayInputStream mOriginalStream;
-  private LimitedInputStream mLimitedStream;
-
-  @Before
-  public void setUp() {
-    mData = new byte[BYTES_LENGTH];
-    mReadBuffer = new byte[BYTES_LENGTH];
-    final Random random = new Random(RANDOM_SEED);
-    random.nextBytes(mData);
-    mZeroTail = new byte[BYTES_LENGTH - LIMITED_LENGTH];
-    Arrays.fill(mZeroTail, (byte) 0);
-
-    mOriginalStream = new ByteArrayInputStream(mData);
-    mLimitedStream = new LimitedInputStream(mOriginalStream, LIMITED_LENGTH);
-  }
-
-  @Test
-  public void testBasic() throws Exception {
-    assertEquals(LIMITED_LENGTH, mLimitedStream.available());
-    assertTrue(mLimitedStream.markSupported());
-  }
-
-  @Test
-  public void testDoesReadSingleBytes() throws Exception {
-    for (int i = 0; i < LIMITED_LENGTH; ++i) {
-      assertEquals(((int) mData[i]) & 0xFF, mLimitedStream.read());
+    private static final int RANDOM_SEED = 1023;
+    private static final int BYTES_LENGTH = 1024;
+    private static final int LIMITED_LENGTH = BYTES_LENGTH / 2;
+
+    private byte[] mData;
+    private byte[] mReadBuffer;
+    private byte[] mZeroTail;
+
+    private ByteArrayInputStream mOriginalStream;
+    private LimitedInputStream mLimitedStream;
+
+    @Before
+    public void setUp() {
+        mData = new byte[BYTES_LENGTH];
+        mReadBuffer = new byte[BYTES_LENGTH];
+        final Random random = new Random(RANDOM_SEED);
+        random.nextBytes(mData);
+        mZeroTail = new byte[BYTES_LENGTH - LIMITED_LENGTH];
+        Arrays.fill(mZeroTail, (byte) 0);
+
+        mOriginalStream = new ByteArrayInputStream(mData);
+        mLimitedStream = new LimitedInputStream(mOriginalStream, LIMITED_LENGTH);
     }
-  }
 
-  @Test
-  public void testDoesNotReadTooMuch_singleBytes() throws Exception {
-    for (int i = 0; i < BYTES_LENGTH; ++i) {
-      final int lastByte = mLimitedStream.read();
-      assertEquals(i >= LIMITED_LENGTH, lastByte == -1);
+    @Test
+    public void testBasic() throws Exception {
+        assertEquals(LIMITED_LENGTH, mLimitedStream.available());
+        assertTrue(mLimitedStream.markSupported());
+    }
+
+    @Test
+    public void testDoesReadSingleBytes() throws Exception {
+        for (int i = 0; i < LIMITED_LENGTH; ++i) {
+            assertEquals(((int) mData[i]) & 0xFF, mLimitedStream.read());
+        }
+    }
+
+    @Test
+    public void testDoesNotReadTooMuch_singleBytes() throws Exception {
+        for (int i = 0; i < BYTES_LENGTH; ++i) {
+            final int lastByte = mLimitedStream.read();
+            assertEquals(i >= LIMITED_LENGTH, lastByte == -1);
+        }
+        assertEquals(BYTES_LENGTH - LIMITED_LENGTH, mOriginalStream.available());
+    }
+
+    @Test
+    public void testDoesReadMultipleBytes() throws Exception {
+        assertEquals(LIMITED_LENGTH, mLimitedStream.read(mReadBuffer, 0, LIMITED_LENGTH));
+        assertArrayEquals(
+                Arrays.copyOfRange(mData, 0, LIMITED_LENGTH),
+                Arrays.copyOfRange(mReadBuffer, 0, LIMITED_LENGTH));
+        assertArrayEquals(
+                mZeroTail,
+                Arrays.copyOfRange(mReadBuffer, LIMITED_LENGTH, BYTES_LENGTH));
+    }
+
+    @Test
+    public void testDoesNotReadTooMuch_multipleBytes() throws Exception {
+        assertEquals(LIMITED_LENGTH, mLimitedStream.read(mReadBuffer, 0, BYTES_LENGTH));
+        final byte[] readBufferCopy = Arrays.copyOf(mReadBuffer, mReadBuffer.length);
+        assertEquals(-1, mLimitedStream.read(mReadBuffer, 0, BYTES_LENGTH));
+        assertArrayEquals(readBufferCopy, mReadBuffer);
+        assertEquals(BYTES_LENGTH - LIMITED_LENGTH, mOriginalStream.available());
+    }
+
+    @Test
+    public void testSkip() throws Exception {
+        assertEquals(LIMITED_LENGTH / 2, mLimitedStream.skip(LIMITED_LENGTH / 2));
+        assertEquals(LIMITED_LENGTH / 2, mLimitedStream.read(mReadBuffer));
+        assertArrayEquals(
+                Arrays.copyOfRange(mData, LIMITED_LENGTH / 2, LIMITED_LENGTH),
+                Arrays.copyOfRange(mReadBuffer, 0, LIMITED_LENGTH / 2));
+    }
+
+    @Test
+    public void testDoesNotReadTooMuch_skip() throws Exception {
+        assertEquals(LIMITED_LENGTH, mLimitedStream.skip(BYTES_LENGTH));
+        assertEquals(0, mLimitedStream.skip(BYTES_LENGTH));
+        assertEquals(BYTES_LENGTH - LIMITED_LENGTH, mOriginalStream.available());
+    }
+
+    @Test
+    public void testDoesMark() throws Exception {
+        mLimitedStream.mark(BYTES_LENGTH);
+        mLimitedStream.read(mReadBuffer);
+        final byte[] readBufferCopy = Arrays.copyOf(mReadBuffer, mReadBuffer.length);
+        Arrays.fill(mReadBuffer, (byte) 0);
+        mLimitedStream.reset();
+        assertEquals(LIMITED_LENGTH, mLimitedStream.read(mReadBuffer));
+        assertArrayEquals(readBufferCopy, mReadBuffer);
+    }
+
+    @Test
+    public void testResetsMultipleTimes() throws Exception {
+        mLimitedStream.mark(BYTES_LENGTH);
+        mLimitedStream.read(mReadBuffer);
+        final byte[] readBufferCopy = Arrays.copyOf(mReadBuffer, mReadBuffer.length);
+
+        // first reset
+        mLimitedStream.reset();
+        assertEquals(LIMITED_LENGTH, mLimitedStream.read(mReadBuffer));
+
+        // second reset
+        Arrays.fill(mReadBuffer, (byte) 0);
+        mLimitedStream.reset();
+        assertEquals(LIMITED_LENGTH, mLimitedStream.read(mReadBuffer));
+
+        assertArrayEquals(readBufferCopy, mReadBuffer);
+    }
+
+    @Test
+    public void testDoesNotReadTooMuch_reset() throws Exception {
+        mLimitedStream.mark(BYTES_LENGTH);
+        mLimitedStream.read(mReadBuffer);
+        mLimitedStream.reset();
+        mLimitedStream.read(mReadBuffer);
+        assertEquals(BYTES_LENGTH - LIMITED_LENGTH, mOriginalStream.available());
+    }
+
+    @Test(expected = IOException.class)
+    public void testDoesNotRestIfNotMarked() throws Exception {
+        mLimitedStream.read(mReadBuffer);
+        mLimitedStream.reset();
+    }
+
+    @Test
+    public void testMultipleMarks() throws IOException {
+        mLimitedStream.mark(BYTES_LENGTH);
+        assertEquals(LIMITED_LENGTH / 2, mLimitedStream.read(mReadBuffer, 0, LIMITED_LENGTH / 2));
+        mLimitedStream.mark(BYTES_LENGTH);
+        assertEquals(
+                LIMITED_LENGTH / 2,
+                mLimitedStream.read(mReadBuffer, LIMITED_LENGTH / 2, LIMITED_LENGTH / 2));
+        mLimitedStream.reset();
+        assertEquals(LIMITED_LENGTH / 2, mLimitedStream.read(mReadBuffer));
+        assertArrayEquals(
+                Arrays.copyOfRange(mReadBuffer, 0, LIMITED_LENGTH / 2),
+                Arrays.copyOfRange(mReadBuffer, LIMITED_LENGTH / 2, LIMITED_LENGTH));
     }
-    assertEquals(BYTES_LENGTH - LIMITED_LENGTH, mOriginalStream.available());
-  }
-
-  @Test
-  public void testDoesReadMultipleBytes() throws Exception {
-    assertEquals(LIMITED_LENGTH, mLimitedStream.read(mReadBuffer, 0, LIMITED_LENGTH));
-    assertArrayEquals(
-        Arrays.copyOfRange(mData, 0, LIMITED_LENGTH),
-        Arrays.copyOfRange(mReadBuffer, 0, LIMITED_LENGTH));
-    assertArrayEquals(
-        mZeroTail,
-        Arrays.copyOfRange(mReadBuffer, LIMITED_LENGTH, BYTES_LENGTH));
-  }
-
-  @Test
-  public void testDoesNotReadTooMuch_multipleBytes() throws Exception {
-    assertEquals(LIMITED_LENGTH, mLimitedStream.read(mReadBuffer, 0, BYTES_LENGTH));
-    final byte[] readBufferCopy = Arrays.copyOf(mReadBuffer, mReadBuffer.length);
-    assertEquals(-1, mLimitedStream.read(mReadBuffer, 0, BYTES_LENGTH));
-    assertArrayEquals(readBufferCopy, mReadBuffer);
-    assertEquals(BYTES_LENGTH - LIMITED_LENGTH, mOriginalStream.available());
-  }
-
-  @Test
-  public void testSkip() throws Exception {
-    assertEquals(LIMITED_LENGTH / 2, mLimitedStream.skip(LIMITED_LENGTH / 2));
-    assertEquals(LIMITED_LENGTH / 2, mLimitedStream.read(mReadBuffer));
-    assertArrayEquals(
-        Arrays.copyOfRange(mData, LIMITED_LENGTH / 2, LIMITED_LENGTH),
-        Arrays.copyOfRange(mReadBuffer, 0, LIMITED_LENGTH / 2));
-  }
-
-  @Test
-  public void testDoesNotReadTooMuch_skip() throws Exception {
-    assertEquals(LIMITED_LENGTH, mLimitedStream.skip(BYTES_LENGTH));
-    assertEquals(0, mLimitedStream.skip(BYTES_LENGTH));
-    assertEquals(BYTES_LENGTH - LIMITED_LENGTH, mOriginalStream.available());
-  }
-
-  @Test
-  public void testDoesMark() throws Exception {
-    mLimitedStream.mark(BYTES_LENGTH);
-    mLimitedStream.read(mReadBuffer);
-    final byte[] readBufferCopy = Arrays.copyOf(mReadBuffer, mReadBuffer.length);
-    Arrays.fill(mReadBuffer, (byte) 0);
-    mLimitedStream.reset();
-    assertEquals(LIMITED_LENGTH, mLimitedStream.read(mReadBuffer));
-    assertArrayEquals(readBufferCopy, mReadBuffer);
-  }
-
-  @Test
-  public void testResetsMultipleTimes() throws Exception {
-    mLimitedStream.mark(BYTES_LENGTH);
-    mLimitedStream.read(mReadBuffer);
-    final byte[] readBufferCopy = Arrays.copyOf(mReadBuffer, mReadBuffer.length);
-
-    // first reset
-    mLimitedStream.reset();
-    assertEquals(LIMITED_LENGTH, mLimitedStream.read(mReadBuffer));
-
-    // second reset
-    Arrays.fill(mReadBuffer, (byte) 0);
-    mLimitedStream.reset();
-    assertEquals(LIMITED_LENGTH, mLimitedStream.read(mReadBuffer));
-
-    assertArrayEquals(readBufferCopy, mReadBuffer);
-  }
-
-  @Test
-  public void testDoesNotReadTooMuch_reset() throws Exception {
-    mLimitedStream.mark(BYTES_LENGTH);
-    mLimitedStream.read(mReadBuffer);
-    mLimitedStream.reset();
-    mLimitedStream.read(mReadBuffer);
-    assertEquals(BYTES_LENGTH - LIMITED_LENGTH, mOriginalStream.available());
-  }
-
-  @Test(expected = IOException.class)
-  public void testDoesNotRestIfNotMarked() throws Exception {
-    mLimitedStream.read(mReadBuffer);
-    mLimitedStream.reset();
-  }
-
-  @Test
-  public void testMultipleMarks() throws IOException {
-    mLimitedStream.mark(BYTES_LENGTH);
-    assertEquals(LIMITED_LENGTH / 2, mLimitedStream.read(mReadBuffer, 0, LIMITED_LENGTH / 2));
-    mLimitedStream.mark(BYTES_LENGTH);
-    assertEquals(
-        LIMITED_LENGTH / 2,
-        mLimitedStream.read(mReadBuffer, LIMITED_LENGTH / 2, LIMITED_LENGTH / 2));
-    mLimitedStream.reset();
-    assertEquals(LIMITED_LENGTH / 2, mLimitedStream.read(mReadBuffer));
-    assertArrayEquals(
-        Arrays.copyOfRange(mReadBuffer, 0, LIMITED_LENGTH / 2),
-        Arrays.copyOfRange(mReadBuffer, LIMITED_LENGTH / 2, LIMITED_LENGTH));
-  }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/streams/TailAppendingInputStreamTest.java b/fbcore/src/test/java/com/facebook/common/streams/TailAppendingInputStreamTest.java
index ccfd47bfb..697f7a363 100644
--- a/fbcore/src/test/java/com/facebook/common/streams/TailAppendingInputStreamTest.java
+++ b/fbcore/src/test/java/com/facebook/common/streams/TailAppendingInputStreamTest.java
@@ -18,6 +18,7 @@
 import com.facebook.testing.robolectric.v2.WithTestDefaultsRunner;
 
 import com.google.common.io.ByteStreams;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,115 +28,115 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class TailAppendingInputStreamTest {
 
-  private static final int RANDOM_SEED = 1023;
-  private static final int BYTES_LENGTH = 1024;
-  private static final int TAIL_LENGTH = 1024;
-  private static final int OUTPUT_LENGTH = BYTES_LENGTH + TAIL_LENGTH;
-
-  private byte[] mBytes;
-  private byte[] mTail;
-
-  private byte[] mOutputBuffer;
-  private TailAppendingInputStream mTailAppendingInputStream;
-
-  @Before
-  public void setUp() {
-    Random random = new Random();
-    random.setSeed(RANDOM_SEED);
-    mBytes = new byte[BYTES_LENGTH];
-    mTail = new byte[TAIL_LENGTH];
-    mOutputBuffer = new byte[OUTPUT_LENGTH];
-    random.nextBytes(mBytes);
-    random.nextBytes(mTail);
-    InputStream stream = new ByteArrayInputStream(mBytes);
-    mTailAppendingInputStream = new TailAppendingInputStream(stream, mTail);
-  }
-
-  @Test
-  public void testDoesReadSingleBytes() throws Exception {
-    for (byte b : mBytes) {
-      assertEquals(((int) b) & 0xFF, mTailAppendingInputStream.read());
-    }
-    for (byte b : mTail) {
-      assertEquals(((int) b) & 0xFF, mTailAppendingInputStream.read());
+    private static final int RANDOM_SEED = 1023;
+    private static final int BYTES_LENGTH = 1024;
+    private static final int TAIL_LENGTH = 1024;
+    private static final int OUTPUT_LENGTH = BYTES_LENGTH + TAIL_LENGTH;
+
+    private byte[] mBytes;
+    private byte[] mTail;
+
+    private byte[] mOutputBuffer;
+    private TailAppendingInputStream mTailAppendingInputStream;
+
+    @Before
+    public void setUp() {
+        Random random = new Random();
+        random.setSeed(RANDOM_SEED);
+        mBytes = new byte[BYTES_LENGTH];
+        mTail = new byte[TAIL_LENGTH];
+        mOutputBuffer = new byte[OUTPUT_LENGTH];
+        random.nextBytes(mBytes);
+        random.nextBytes(mTail);
+        InputStream stream = new ByteArrayInputStream(mBytes);
+        mTailAppendingInputStream = new TailAppendingInputStream(stream, mTail);
     }
-  }
 
-  @Test
-  public void testDoesNotReadTooMuch_singleBytes() throws Exception {
-    for (int i = 0; i < mBytes.length + mTail.length; ++i) {
-      mTailAppendingInputStream.read();
+    @Test
+    public void testDoesReadSingleBytes() throws Exception {
+        for (byte b : mBytes) {
+            assertEquals(((int) b) & 0xFF, mTailAppendingInputStream.read());
+        }
+        for (byte b : mTail) {
+            assertEquals(((int) b) & 0xFF, mTailAppendingInputStream.read());
+        }
     }
-    assertEquals(-1, mTailAppendingInputStream.read());
-  }
-
-  @Test
-  public void testDoesReadMultipleBytes() throws Exception {
-    ByteStreams.readFully(mTailAppendingInputStream, mOutputBuffer);
-    assertArrayEquals(mBytes, Arrays.copyOfRange(mOutputBuffer, 0, BYTES_LENGTH));
-    assertArrayEquals(mTail, Arrays.copyOfRange(mOutputBuffer, BYTES_LENGTH, OUTPUT_LENGTH));
-  }
-
-  @Test
-  public void testDoesNotReadTooMuch_multipleBytes() throws Exception {
-    byte[] buffer = new byte[OUTPUT_LENGTH + 1];
-    assertEquals(
-        OUTPUT_LENGTH,
-        ByteStreams.read(mTailAppendingInputStream, buffer, 0, OUTPUT_LENGTH + 1));
-    assertEquals(-1, mTailAppendingInputStream.read());
-  }
-
-  @Test
-  public void testUnalignedReads() throws IOException {
-    assertEquals(128, mTailAppendingInputStream.read(mOutputBuffer, 256, 128));
-    assertArrayEquals(
-        Arrays.copyOfRange(mBytes, 0, 128),
-        Arrays.copyOfRange(mOutputBuffer, 256, 384));
-    Arrays.fill(mOutputBuffer, 256, 384, (byte) 0);
-    for (byte b : mOutputBuffer) {
-      assertEquals(0, b);
+
+    @Test
+    public void testDoesNotReadTooMuch_singleBytes() throws Exception {
+        for (int i = 0; i < mBytes.length + mTail.length; ++i) {
+            mTailAppendingInputStream.read();
+        }
+        assertEquals(-1, mTailAppendingInputStream.read());
     }
 
-    assertEquals(BYTES_LENGTH - 128, mTailAppendingInputStream.read(mOutputBuffer));
-    assertArrayEquals(
-        Arrays.copyOfRange(mBytes, 128, BYTES_LENGTH),
-        Arrays.copyOfRange(mOutputBuffer, 0, BYTES_LENGTH - 128));
-    Arrays.fill(mOutputBuffer, 0, BYTES_LENGTH - 128, (byte) 0);
-    for (byte b : mOutputBuffer) {
-      assertEquals(0, b);
+    @Test
+    public void testDoesReadMultipleBytes() throws Exception {
+        ByteStreams.readFully(mTailAppendingInputStream, mOutputBuffer);
+        assertArrayEquals(mBytes, Arrays.copyOfRange(mOutputBuffer, 0, BYTES_LENGTH));
+        assertArrayEquals(mTail, Arrays.copyOfRange(mOutputBuffer, BYTES_LENGTH, OUTPUT_LENGTH));
     }
 
-    assertEquals(128, mTailAppendingInputStream.read(mOutputBuffer, 256, 128));
-    assertArrayEquals(
-        Arrays.copyOfRange(mTail, 0, 128),
-        Arrays.copyOfRange(mOutputBuffer, 256, 384));
-    Arrays.fill(mOutputBuffer, 256, 384, (byte) 0);
-    for (byte b : mOutputBuffer) {
-      assertEquals(0, b);
+    @Test
+    public void testDoesNotReadTooMuch_multipleBytes() throws Exception {
+        byte[] buffer = new byte[OUTPUT_LENGTH + 1];
+        assertEquals(
+                OUTPUT_LENGTH,
+                ByteStreams.read(mTailAppendingInputStream, buffer, 0, OUTPUT_LENGTH + 1));
+        assertEquals(-1, mTailAppendingInputStream.read());
     }
 
-    assertEquals(TAIL_LENGTH - 128, mTailAppendingInputStream.read(mOutputBuffer));
-    assertArrayEquals(
-        Arrays.copyOfRange(mTail, 128, TAIL_LENGTH),
-        Arrays.copyOfRange(mOutputBuffer, 0, TAIL_LENGTH - 128));
-    Arrays.fill(mOutputBuffer, 0, TAIL_LENGTH - 128, (byte) 0);
-    for (byte b : mOutputBuffer) {
-      assertEquals(0, b);
+    @Test
+    public void testUnalignedReads() throws IOException {
+        assertEquals(128, mTailAppendingInputStream.read(mOutputBuffer, 256, 128));
+        assertArrayEquals(
+                Arrays.copyOfRange(mBytes, 0, 128),
+                Arrays.copyOfRange(mOutputBuffer, 256, 384));
+        Arrays.fill(mOutputBuffer, 256, 384, (byte) 0);
+        for (byte b : mOutputBuffer) {
+            assertEquals(0, b);
+        }
+
+        assertEquals(BYTES_LENGTH - 128, mTailAppendingInputStream.read(mOutputBuffer));
+        assertArrayEquals(
+                Arrays.copyOfRange(mBytes, 128, BYTES_LENGTH),
+                Arrays.copyOfRange(mOutputBuffer, 0, BYTES_LENGTH - 128));
+        Arrays.fill(mOutputBuffer, 0, BYTES_LENGTH - 128, (byte) 0);
+        for (byte b : mOutputBuffer) {
+            assertEquals(0, b);
+        }
+
+        assertEquals(128, mTailAppendingInputStream.read(mOutputBuffer, 256, 128));
+        assertArrayEquals(
+                Arrays.copyOfRange(mTail, 0, 128),
+                Arrays.copyOfRange(mOutputBuffer, 256, 384));
+        Arrays.fill(mOutputBuffer, 256, 384, (byte) 0);
+        for (byte b : mOutputBuffer) {
+            assertEquals(0, b);
+        }
+
+        assertEquals(TAIL_LENGTH - 128, mTailAppendingInputStream.read(mOutputBuffer));
+        assertArrayEquals(
+                Arrays.copyOfRange(mTail, 128, TAIL_LENGTH),
+                Arrays.copyOfRange(mOutputBuffer, 0, TAIL_LENGTH - 128));
+        Arrays.fill(mOutputBuffer, 0, TAIL_LENGTH - 128, (byte) 0);
+        for (byte b : mOutputBuffer) {
+            assertEquals(0, b);
+        }
+
+        assertEquals(-1, mTailAppendingInputStream.read());
     }
 
-    assertEquals(-1, mTailAppendingInputStream.read());
-  }
-
-  @Test
-  public void testMark() throws IOException {
-    assertEquals(128, mTailAppendingInputStream.read(mOutputBuffer, 0, 128));
-    mTailAppendingInputStream.mark(BYTES_LENGTH);
-    assertEquals(
-        BYTES_LENGTH,
-        ByteStreams.read(mTailAppendingInputStream, mOutputBuffer, 0, BYTES_LENGTH));
-    mTailAppendingInputStream.reset();
-    for (byte b : Arrays.copyOfRange(mOutputBuffer, 0, BYTES_LENGTH)) {
-      assertEquals(((int) b) & 0xFF, mTailAppendingInputStream.read());
+    @Test
+    public void testMark() throws IOException {
+        assertEquals(128, mTailAppendingInputStream.read(mOutputBuffer, 0, 128));
+        mTailAppendingInputStream.mark(BYTES_LENGTH);
+        assertEquals(
+                BYTES_LENGTH,
+                ByteStreams.read(mTailAppendingInputStream, mOutputBuffer, 0, BYTES_LENGTH));
+        mTailAppendingInputStream.reset();
+        for (byte b : Arrays.copyOfRange(mOutputBuffer, 0, BYTES_LENGTH)) {
+            assertEquals(((int) b) & 0xFF, mTailAppendingInputStream.read());
+        }
     }
-  }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/testing/CoreRobolectricTestRunner.java b/fbcore/src/test/java/com/facebook/common/testing/CoreRobolectricTestRunner.java
index 9f3dd5aa0..fb7763b6f 100644
--- a/fbcore/src/test/java/com/facebook/common/testing/CoreRobolectricTestRunner.java
+++ b/fbcore/src/test/java/com/facebook/common/testing/CoreRobolectricTestRunner.java
@@ -18,15 +18,15 @@
  */
 public class CoreRobolectricTestRunner extends RobolectricTestRunner {
 
-  /**
-   * Creates a runner to run {@code testClass}. Looks in your working directory for your
-   * AndroidManifest.xml file and res directory by default. Use the {@link Config} annotation to
-   * configure.
-   *
-   * @param testClass the test class to be run
-   * @throws InitializationError if junit says so
-   */
-  public CoreRobolectricTestRunner(Class<?> testClass) throws InitializationError {
-    super(testClass);
-  }
+    /**
+     * Creates a runner to run {@code testClass}. Looks in your working directory for your
+     * AndroidManifest.xml file and res directory by default. Use the {@link Config} annotation to
+     * configure.
+     *
+     * @param testClass the test class to be run
+     * @throws InitializationError if junit says so
+     */
+    public CoreRobolectricTestRunner(Class<?> testClass) throws InitializationError {
+        super(testClass);
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/testing/FakeClock.java b/fbcore/src/test/java/com/facebook/common/testing/FakeClock.java
index 02688ab76..af8a3b3b4 100644
--- a/fbcore/src/test/java/com/facebook/common/testing/FakeClock.java
+++ b/fbcore/src/test/java/com/facebook/common/testing/FakeClock.java
@@ -20,82 +20,82 @@
  */
 public class FakeClock implements MonotonicClock {
 
-  public interface OnTickListener {
-    void onTick();
-  }
-
-  private final Map<OnTickListener, OnTickListener> otherClocks =
-      new ConcurrentHashMap<OnTickListener, OnTickListener>();
-  private final Map<OnTickListener, OnTickListener> listeners =
-      new ConcurrentHashMap<OnTickListener, OnTickListener>();
-
-  private long now;
+    public interface OnTickListener {
+        void onTick();
+    }
 
-  public FakeClock() {
-    now = 100000;
-  }
+    private final Map<OnTickListener, OnTickListener> otherClocks =
+            new ConcurrentHashMap<OnTickListener, OnTickListener>();
+    private final Map<OnTickListener, OnTickListener> listeners =
+            new ConcurrentHashMap<OnTickListener, OnTickListener>();
 
-  public FakeClock(long now) {
-    this.now = now;
-  }
+    private long now;
 
-  public void incrementBy(long amountMs) {
-    synchronized (this) {
-      now += amountMs;
+    public FakeClock() {
+        now = 100000;
     }
-    // Update other clocks before dispatching to listeners.  This is not a perfect solution, since
-    // the other clocks might still dispatch events before subsequent clocks are updated.  All
-    // clocks should be forced to update their time before dispatching events so all clocks are
-    // guaranteed in sync, but it's better than the random order of having everything in a single
-    // listeners Map where some events will be dispatched before other clocks are updated depending
-    // on hashing randomness.
-    for (OnTickListener otherClock : otherClocks.keySet()) {
-      otherClock.onTick();
+
+    public FakeClock(long now) {
+        this.now = now;
     }
-    for (OnTickListener listener : listeners.keySet()) {
-      listener.onTick();
+
+    public void incrementBy(long amountMs) {
+        synchronized (this) {
+            now += amountMs;
+        }
+        // Update other clocks before dispatching to listeners.  This is not a perfect solution, since
+        // the other clocks might still dispatch events before subsequent clocks are updated.  All
+        // clocks should be forced to update their time before dispatching events so all clocks are
+        // guaranteed in sync, but it's better than the random order of having everything in a single
+        // listeners Map where some events will be dispatched before other clocks are updated depending
+        // on hashing randomness.
+        for (OnTickListener otherClock : otherClocks.keySet()) {
+            otherClock.onTick();
+        }
+        for (OnTickListener listener : listeners.keySet()) {
+            listener.onTick();
+        }
     }
-  }
 
-  /**
-   * Increments the clock's time gradually in several steps
-   *
-   * The clock will be incremented by tickMs amount repeatedly until it has progress by totalMs
-   * from the given time when this call was made.
-   *
-   * This call is useful for working with animations in tests.
-   *
-   * In the end of this call, the call will progress by exactly totalMs, even if it means the last
-   * tick of the clock is smaller than tickMs
-   *
-   * @param tickMs the amount to tick the clock at each step
-   * @param totalMs the total amount of time to elapse during the call
-   */
-  public void incrementInSteps(long tickMs, long totalMs) {
-    long start = now;
-    long end = start + totalMs;
-    while (now < end) {
-      incrementBy(Math.min(tickMs, end - now));
+    /**
+     * Increments the clock's time gradually in several steps
+     * <p>
+     * The clock will be incremented by tickMs amount repeatedly until it has progress by totalMs
+     * from the given time when this call was made.
+     * <p>
+     * This call is useful for working with animations in tests.
+     * <p>
+     * In the end of this call, the call will progress by exactly totalMs, even if it means the last
+     * tick of the clock is smaller than tickMs
+     *
+     * @param tickMs  the amount to tick the clock at each step
+     * @param totalMs the total amount of time to elapse during the call
+     */
+    public void incrementInSteps(long tickMs, long totalMs) {
+        long start = now;
+        long end = start + totalMs;
+        while (now < end) {
+            incrementBy(Math.min(tickMs, end - now));
+        }
     }
-  }
 
-  @Override
-  public synchronized long now() {
-    return now;
-  }
+    @Override
+    public synchronized long now() {
+        return now;
+    }
 
-  /**
-   * Add a clock that will get called before {@link #listeners}, in order to guarantee call order.
-   */
-  public void addOtherClock(OnTickListener otherClock) {
-    otherClocks.put(otherClock, otherClock);
-  }
+    /**
+     * Add a clock that will get called before {@link #listeners}, in order to guarantee call order.
+     */
+    public void addOtherClock(OnTickListener otherClock) {
+        otherClocks.put(otherClock, otherClock);
+    }
 
-  public void addListener(OnTickListener listener) {
-    listeners.put(listener, listener);
-  }
+    public void addListener(OnTickListener listener) {
+        listeners.put(listener, listener);
+    }
 
-  public void removeListener(OnTickListener listener) {
-    listeners.remove(listener);
-  }
+    public void removeListener(OnTickListener listener) {
+        listeners.remove(listener);
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/time/TimeSpanTest.java b/fbcore/src/test/java/com/facebook/common/time/TimeSpanTest.java
index 81d139a33..080336fae 100644
--- a/fbcore/src/test/java/com/facebook/common/time/TimeSpanTest.java
+++ b/fbcore/src/test/java/com/facebook/common/time/TimeSpanTest.java
@@ -20,101 +20,102 @@
 
 @RunWith(WithTestDefaultsRunner.class)
 public class TimeSpanTest {
-  @Test
-  public void testFromNanos() throws Exception {
-    final long duration = 36;
-    TimeSpan underTest = TimeSpan.fromNanos(duration);
-    assertThat(underTest.as(TimeUnit.NANOSECONDS)).isEqualTo(duration);
-    assertThat(underTest.toNanos()).isEqualTo(duration);
-  }
-
-  @Test
-  public void testFromMicros() throws Exception {
-    final long duration = 37;
-    TimeSpan underTest = TimeSpan.fromMicros(duration);
-    assertThat(underTest.as(TimeUnit.MICROSECONDS)).isEqualTo(duration);
-    assertThat(underTest.toMicros()).isEqualTo(duration);
-  }
-  @Test
-  public void testFromMillis() throws Exception {
-    final long duration = 38;
-    TimeSpan underTest = TimeSpan.fromMillis(duration);
-    assertThat(underTest.as(TimeUnit.MILLISECONDS)).isEqualTo(duration);
-    assertThat(underTest.toMillis()).isEqualTo(duration);
-  }
-
-  @Test
-  public void testFromSeconds() throws Exception {
-    final long duration = 39;
-    TimeSpan underTest = TimeSpan.fromSeconds(duration);
-    assertThat(underTest.as(TimeUnit.SECONDS)).isEqualTo(duration);
-    assertThat(underTest.toSeconds()).isEqualTo(duration);
-  }
-
-  @Test
-  public void testFromMinutes() throws Exception {
-    final long duration = 40;
-    TimeSpan underTest = TimeSpan.fromMinutes(duration);
-    assertThat(underTest.as(TimeUnit.MINUTES)).isEqualTo(duration);
-    assertThat(underTest.toMinutes()).isEqualTo(duration);
-  }
-
-  @Test
-  public void testFromHours() throws Exception {
-    final long duration = 41;
-    TimeSpan underTest = TimeSpan.fromHours(duration);
-    assertThat(underTest.as(TimeUnit.HOURS)).isEqualTo(duration);
-    assertThat(underTest.toHours()).isEqualTo(duration);
-  }
-
-  @Test
-  public void testFromDays() throws Exception {
-    final long duration = 42;
-    TimeSpan underTest = TimeSpan.fromDays(duration);
-    assertThat(underTest.as(TimeUnit.DAYS)).isEqualTo(duration);
-    assertThat(underTest.toDays()).isEqualTo(duration);
-  }
-
-  @Test
-  public void testCtor() throws Exception {
-    final long duration = 555;
-    TimeSpan underTest = new TimeSpan(duration, TimeUnit.HOURS);
-    assertThat(underTest.as(TimeUnit.HOURS)).isEqualTo(duration);
-  }
-
-  @Test
-  public void testConversion() throws Exception {
-    assertThat(TimeSpan.fromMillis(1000).as(TimeUnit.SECONDS)).isEqualTo(1);
-  }
-
-  @Test
-  public void testEquality() throws Exception {
-    assertThat(TimeSpan.fromMillis(1000)).isEqualTo(TimeSpan.fromSeconds(1));
-  }
-
-  @Test
-  public void testToString() throws Exception {
-    assertThat(TimeSpan.fromNanos(1).toString()).isEqualTo("TimeSpan{1 Nano}");
-    assertThat(TimeSpan.fromNanos(2).toString()).isEqualTo("TimeSpan{2 Nanos}");
-
-    assertThat(TimeSpan.fromMicros(1).toString()).isEqualTo("TimeSpan{1 Micro}");
-    assertThat(TimeSpan.fromMicros(2).toString()).isEqualTo("TimeSpan{2 Micros}");
-
-    assertThat(TimeSpan.fromMillis(1).toString()).isEqualTo("TimeSpan{1 Milli}");
-    assertThat(TimeSpan.fromMillis(2).toString()).isEqualTo("TimeSpan{2 Millis}");
-
-    assertThat(TimeSpan.fromSeconds(1).toString()).isEqualTo("TimeSpan{1 Second}");
-    assertThat(TimeSpan.fromSeconds(2).toString()).isEqualTo("TimeSpan{2 Seconds}");
-
-    assertThat(TimeSpan.fromMinutes(1).toString()).isEqualTo("TimeSpan{1 Minute}");
-    assertThat(TimeSpan.fromMinutes(2).toString()).isEqualTo("TimeSpan{2 Minutes}");
-
-    assertThat(TimeSpan.fromHours(1).toString()).isEqualTo("TimeSpan{1 Hour}");
-    assertThat(TimeSpan.fromHours(2).toString()).isEqualTo("TimeSpan{2 Hours}");
-
-    assertThat(TimeSpan.fromDays(1).toString()).isEqualTo("TimeSpan{1 Day}");
-    assertThat(TimeSpan.fromDays(2).toString()).isEqualTo("TimeSpan{2 Days}");
-
-    assertThat(TimeSpan.fromMinutes(90).toString()).isEqualTo("TimeSpan{1 Hour, 30 Minutes}");
-  }
+    @Test
+    public void testFromNanos() throws Exception {
+        final long duration = 36;
+        TimeSpan underTest = TimeSpan.fromNanos(duration);
+        assertThat(underTest.as(TimeUnit.NANOSECONDS)).isEqualTo(duration);
+        assertThat(underTest.toNanos()).isEqualTo(duration);
+    }
+
+    @Test
+    public void testFromMicros() throws Exception {
+        final long duration = 37;
+        TimeSpan underTest = TimeSpan.fromMicros(duration);
+        assertThat(underTest.as(TimeUnit.MICROSECONDS)).isEqualTo(duration);
+        assertThat(underTest.toMicros()).isEqualTo(duration);
+    }
+
+    @Test
+    public void testFromMillis() throws Exception {
+        final long duration = 38;
+        TimeSpan underTest = TimeSpan.fromMillis(duration);
+        assertThat(underTest.as(TimeUnit.MILLISECONDS)).isEqualTo(duration);
+        assertThat(underTest.toMillis()).isEqualTo(duration);
+    }
+
+    @Test
+    public void testFromSeconds() throws Exception {
+        final long duration = 39;
+        TimeSpan underTest = TimeSpan.fromSeconds(duration);
+        assertThat(underTest.as(TimeUnit.SECONDS)).isEqualTo(duration);
+        assertThat(underTest.toSeconds()).isEqualTo(duration);
+    }
+
+    @Test
+    public void testFromMinutes() throws Exception {
+        final long duration = 40;
+        TimeSpan underTest = TimeSpan.fromMinutes(duration);
+        assertThat(underTest.as(TimeUnit.MINUTES)).isEqualTo(duration);
+        assertThat(underTest.toMinutes()).isEqualTo(duration);
+    }
+
+    @Test
+    public void testFromHours() throws Exception {
+        final long duration = 41;
+        TimeSpan underTest = TimeSpan.fromHours(duration);
+        assertThat(underTest.as(TimeUnit.HOURS)).isEqualTo(duration);
+        assertThat(underTest.toHours()).isEqualTo(duration);
+    }
+
+    @Test
+    public void testFromDays() throws Exception {
+        final long duration = 42;
+        TimeSpan underTest = TimeSpan.fromDays(duration);
+        assertThat(underTest.as(TimeUnit.DAYS)).isEqualTo(duration);
+        assertThat(underTest.toDays()).isEqualTo(duration);
+    }
+
+    @Test
+    public void testCtor() throws Exception {
+        final long duration = 555;
+        TimeSpan underTest = new TimeSpan(duration, TimeUnit.HOURS);
+        assertThat(underTest.as(TimeUnit.HOURS)).isEqualTo(duration);
+    }
+
+    @Test
+    public void testConversion() throws Exception {
+        assertThat(TimeSpan.fromMillis(1000).as(TimeUnit.SECONDS)).isEqualTo(1);
+    }
+
+    @Test
+    public void testEquality() throws Exception {
+        assertThat(TimeSpan.fromMillis(1000)).isEqualTo(TimeSpan.fromSeconds(1));
+    }
+
+    @Test
+    public void testToString() throws Exception {
+        assertThat(TimeSpan.fromNanos(1).toString()).isEqualTo("TimeSpan{1 Nano}");
+        assertThat(TimeSpan.fromNanos(2).toString()).isEqualTo("TimeSpan{2 Nanos}");
+
+        assertThat(TimeSpan.fromMicros(1).toString()).isEqualTo("TimeSpan{1 Micro}");
+        assertThat(TimeSpan.fromMicros(2).toString()).isEqualTo("TimeSpan{2 Micros}");
+
+        assertThat(TimeSpan.fromMillis(1).toString()).isEqualTo("TimeSpan{1 Milli}");
+        assertThat(TimeSpan.fromMillis(2).toString()).isEqualTo("TimeSpan{2 Millis}");
+
+        assertThat(TimeSpan.fromSeconds(1).toString()).isEqualTo("TimeSpan{1 Second}");
+        assertThat(TimeSpan.fromSeconds(2).toString()).isEqualTo("TimeSpan{2 Seconds}");
+
+        assertThat(TimeSpan.fromMinutes(1).toString()).isEqualTo("TimeSpan{1 Minute}");
+        assertThat(TimeSpan.fromMinutes(2).toString()).isEqualTo("TimeSpan{2 Minutes}");
+
+        assertThat(TimeSpan.fromHours(1).toString()).isEqualTo("TimeSpan{1 Hour}");
+        assertThat(TimeSpan.fromHours(2).toString()).isEqualTo("TimeSpan{2 Hours}");
+
+        assertThat(TimeSpan.fromDays(1).toString()).isEqualTo("TimeSpan{1 Day}");
+        assertThat(TimeSpan.fromDays(2).toString()).isEqualTo("TimeSpan{2 Days}");
+
+        assertThat(TimeSpan.fromMinutes(90).toString()).isEqualTo("TimeSpan{1 Hour, 30 Minutes}");
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/util/HashCodeUtilTest.java b/fbcore/src/test/java/com/facebook/common/util/HashCodeUtilTest.java
index a3d69285a..667d0b82f 100644
--- a/fbcore/src/test/java/com/facebook/common/util/HashCodeUtilTest.java
+++ b/fbcore/src/test/java/com/facebook/common/util/HashCodeUtilTest.java
@@ -22,46 +22,46 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class HashCodeUtilTest {
 
-  @Test
-  public void testSimple() {
-    testCase(1, 2, 3, 4, 5, 6);
-  }
+    @Test
+    public void testSimple() {
+        testCase(1, 2, 3, 4, 5, 6);
+    }
 
-  @Test
-  public void testRandom() {
-    Random generator = new Random(123);
-    testCase(
-        generator.nextInt(),
-        generator.nextInt(),
-        generator.nextInt(),
-        generator.nextInt(),
-        generator.nextInt(),
-        generator.nextInt());
-  }
+    @Test
+    public void testRandom() {
+        Random generator = new Random(123);
+        testCase(
+                generator.nextInt(),
+                generator.nextInt(),
+                generator.nextInt(),
+                generator.nextInt(),
+                generator.nextInt(),
+                generator.nextInt());
+    }
 
-  @Test
-  public void testNull() {
-    testCase(1, null, 3, 4, 5, 6);
-  }
+    @Test
+    public void testNull() {
+        testCase(1, null, 3, 4, 5, 6);
+    }
 
-  private void testCase(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6) {
-    assertEquals(
-        Objects.hashCode(o1),
-        HashCodeUtil.hashCode(o1));
-    assertEquals(
-        Objects.hashCode(o1, o2),
-        HashCodeUtil.hashCode(o1, o2));
-    assertEquals(
-        Objects.hashCode(o1, o2, o3),
-        HashCodeUtil.hashCode(o1, o2, o3));
-    assertEquals(
-        Objects.hashCode(o1, o2, o3, o4),
-        HashCodeUtil.hashCode(o1, o2, o3, o4));
-    assertEquals(
-        Objects.hashCode(o1, o2, o3, o4, o5),
-        HashCodeUtil.hashCode(o1, o2, o3, o4, o5));
-    assertEquals(
-        Objects.hashCode(o1, o2, o3, o4, o5, o6),
-        HashCodeUtil.hashCode(o1, o2, o3, o4, o5, o6));
-  }
+    private void testCase(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6) {
+        assertEquals(
+                Objects.hashCode(o1),
+                HashCodeUtil.hashCode(o1));
+        assertEquals(
+                Objects.hashCode(o1, o2),
+                HashCodeUtil.hashCode(o1, o2));
+        assertEquals(
+                Objects.hashCode(o1, o2, o3),
+                HashCodeUtil.hashCode(o1, o2, o3));
+        assertEquals(
+                Objects.hashCode(o1, o2, o3, o4),
+                HashCodeUtil.hashCode(o1, o2, o3, o4));
+        assertEquals(
+                Objects.hashCode(o1, o2, o3, o4, o5),
+                HashCodeUtil.hashCode(o1, o2, o3, o4, o5));
+        assertEquals(
+                Objects.hashCode(o1, o2, o3, o4, o5, o6),
+                HashCodeUtil.hashCode(o1, o2, o3, o4, o5, o6));
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/common/util/StreamUtilTest.java b/fbcore/src/test/java/com/facebook/common/util/StreamUtilTest.java
index 9267cd559..c23f9c3b5 100644
--- a/fbcore/src/test/java/com/facebook/common/util/StreamUtilTest.java
+++ b/fbcore/src/test/java/com/facebook/common/util/StreamUtilTest.java
@@ -34,99 +34,99 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class StreamUtilTest {
 
-  /**
-   * Verify that using a ByteArrayInputStream does not allocate a new byte array.
-   */
-  @Test
-  public void testByteArrayInputStream() throws Exception {
-    byte[] bytes = new byte[8];
-    InputStream input = new ByteArrayInputStream(bytes);
-    try {
-      byte[] bytesRead = StreamUtil.getBytesFromStream(input);
-      assertTrue(Arrays.equals(bytes, bytesRead));
-    } finally {
-      Closeables.close(input, true);
+    /**
+     * Verify that using a ByteArrayInputStream does not allocate a new byte array.
+     */
+    @Test
+    public void testByteArrayInputStream() throws Exception {
+        byte[] bytes = new byte[8];
+        InputStream input = new ByteArrayInputStream(bytes);
+        try {
+            byte[] bytesRead = StreamUtil.getBytesFromStream(input);
+            assertTrue(Arrays.equals(bytes, bytesRead));
+        } finally {
+            Closeables.close(input, true);
+        }
     }
-  }
 
-  /**
-   * Verify that using an offset with ByteArrayInputStream still produces correct output.
-   */
-  @Test
-  public void testByteArrayInputStreamWithOffset() throws Exception {
-    byte[] bytes = new byte[] {0, 1, 2, 3, 4};
-    InputStream input = new ByteArrayInputStream(bytes, 1, 4);
-    try {
-      byte[] bytesRead = StreamUtil.getBytesFromStream(input);
-      byte[] expectedBytes = new byte[] {1, 2, 3, 4};
-      assertTrue(Arrays.equals(expectedBytes, bytesRead));
-    } finally {
-      Closeables.close(input, true);
+    /**
+     * Verify that using an offset with ByteArrayInputStream still produces correct output.
+     */
+    @Test
+    public void testByteArrayInputStreamWithOffset() throws Exception {
+        byte[] bytes = new byte[]{0, 1, 2, 3, 4};
+        InputStream input = new ByteArrayInputStream(bytes, 1, 4);
+        try {
+            byte[] bytesRead = StreamUtil.getBytesFromStream(input);
+            byte[] expectedBytes = new byte[]{1, 2, 3, 4};
+            assertTrue(Arrays.equals(expectedBytes, bytesRead));
+        } finally {
+            Closeables.close(input, true);
+        }
     }
-  }
 
-  /**
-   * Verify getting a byte array from a FileInputStream.
-   */
-  @Test
-  public void testFileInputStream() throws Exception {
-    checkFileInputStream(4);
-    checkFileInputStream(64 * 1024 + 5); // Don't end on an even byte boundary
-  }
-
-  @Test
-  public void testSuccessfulSkip() throws Exception {
-    InputStream inputStream = mock(InputStream.class);
-    when(inputStream.skip(anyLong())).thenReturn(2L);
-    assertEquals(10, StreamUtil.skip(inputStream, 10));
-    InOrder order = inOrder(inputStream);
-    order.verify(inputStream).skip(10);
-    order.verify(inputStream).skip(8);
-    order.verify(inputStream).skip(6);
-    order.verify(inputStream).skip(4);
-    order.verify(inputStream).skip(2);
-    verifyNoMoreInteractions(inputStream);
-  }
+    /**
+     * Verify getting a byte array from a FileInputStream.
+     */
+    @Test
+    public void testFileInputStream() throws Exception {
+        checkFileInputStream(4);
+        checkFileInputStream(64 * 1024 + 5); // Don't end on an even byte boundary
+    }
 
-  @Test
-  public void testUnsuccessfulSkip() throws Exception {
-    InputStream inputStream = mock(InputStream.class);
-    when(inputStream.skip(anyLong())).thenReturn(3L, 5L, 0L, 6L, 0L);
-    when(inputStream.read()).thenReturn(3, -1);
-    assertEquals(15, StreamUtil.skip(inputStream, 20));
-    InOrder order = inOrder(inputStream);
-    order.verify(inputStream).skip(20);
-    order.verify(inputStream).skip(17);
-    order.verify(inputStream).skip(12);
-    order.verify(inputStream).read();
-    order.verify(inputStream).skip(11);
-    order.verify(inputStream).skip(5);
-    order.verify(inputStream).read();
-    verifyNoMoreInteractions(inputStream);
-  }
+    @Test
+    public void testSuccessfulSkip() throws Exception {
+        InputStream inputStream = mock(InputStream.class);
+        when(inputStream.skip(anyLong())).thenReturn(2L);
+        assertEquals(10, StreamUtil.skip(inputStream, 10));
+        InOrder order = inOrder(inputStream);
+        order.verify(inputStream).skip(10);
+        order.verify(inputStream).skip(8);
+        order.verify(inputStream).skip(6);
+        order.verify(inputStream).skip(4);
+        order.verify(inputStream).skip(2);
+        verifyNoMoreInteractions(inputStream);
+    }
 
-  private void checkFileInputStream(int size) throws IOException {
-    byte[] bytesToWrite = new byte[size];
-    for (int i=0; i<size; i++) {
-      bytesToWrite[i] = (byte)i; // It's okay to truncate
+    @Test
+    public void testUnsuccessfulSkip() throws Exception {
+        InputStream inputStream = mock(InputStream.class);
+        when(inputStream.skip(anyLong())).thenReturn(3L, 5L, 0L, 6L, 0L);
+        when(inputStream.read()).thenReturn(3, -1);
+        assertEquals(15, StreamUtil.skip(inputStream, 20));
+        InOrder order = inOrder(inputStream);
+        order.verify(inputStream).skip(20);
+        order.verify(inputStream).skip(17);
+        order.verify(inputStream).skip(12);
+        order.verify(inputStream).read();
+        order.verify(inputStream).skip(11);
+        order.verify(inputStream).skip(5);
+        order.verify(inputStream).read();
+        verifyNoMoreInteractions(inputStream);
     }
 
-    File tmpFile = File.createTempFile("streamUtil", "test");
-    InputStream input = null;
-    OutputStream output = null;
-    try {
-      output = new FileOutputStream(tmpFile);
-      output.write(bytesToWrite);
-      output.close();
+    private void checkFileInputStream(int size) throws IOException {
+        byte[] bytesToWrite = new byte[size];
+        for (int i = 0; i < size; i++) {
+            bytesToWrite[i] = (byte) i; // It's okay to truncate
+        }
+
+        File tmpFile = File.createTempFile("streamUtil", "test");
+        InputStream input = null;
+        OutputStream output = null;
+        try {
+            output = new FileOutputStream(tmpFile);
+            output.write(bytesToWrite);
+            output.close();
 
-      input = new FileInputStream(tmpFile);
-      byte[] bytesRead = StreamUtil.getBytesFromStream(input);
-      assertTrue(Arrays.equals(bytesToWrite, bytesRead));
-    } finally {
-      Closeables.close(input, true);
-      Closeables.close(output, false);
-      assertTrue(tmpFile.delete());
+            input = new FileInputStream(tmpFile);
+            byte[] bytesRead = StreamUtil.getBytesFromStream(input);
+            assertTrue(Arrays.equals(bytesToWrite, bytesRead));
+        } finally {
+            Closeables.close(input, true);
+            Closeables.close(output, false);
+            assertTrue(tmpFile.delete());
+        }
     }
-  }
 
 }
diff --git a/fbcore/src/test/java/com/facebook/common/util/TriStateTest.java b/fbcore/src/test/java/com/facebook/common/util/TriStateTest.java
index bc1914d99..2b13405e3 100644
--- a/fbcore/src/test/java/com/facebook/common/util/TriStateTest.java
+++ b/fbcore/src/test/java/com/facebook/common/util/TriStateTest.java
@@ -13,45 +13,47 @@
 
 import static org.junit.Assert.*;
 
-/** Unit test for {@link TriState}. */
+/**
+ * Unit test for {@link TriState}.
+ */
 public class TriStateTest {
 
-  @Test
-  public void testIsSet() {
-    assertTrue(TriState.YES.isSet());
-    assertTrue(TriState.NO.isSet());
-    assertFalse(TriState.UNSET.isSet());
-  }
-
-  @Test
-  public void testValueOf() {
-    assertEquals(TriState.YES, TriState.valueOf(true));
-    assertEquals(TriState.NO, TriState.valueOf(false));
-  }
-
-  @Test
-  public void testAsBooleanValidValues() {
-    assertTrue(TriState.YES.asBoolean());
-    assertFalse(TriState.NO.asBoolean());
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void testAsBooleanInvalidValues() {
-    TriState.UNSET.asBoolean();
-  }
-
-  @Test
-  public void testAsBooleanDefault() {
-    assertTrue(TriState.YES.asBoolean(false));
-    assertFalse(TriState.NO.asBoolean(true));
-    assertTrue(TriState.UNSET.asBoolean(true));
-    assertFalse(TriState.UNSET.asBoolean(false));
-  }
-
-  @Test
-  public void testAsBooleanObject() {
-    assertSame(Boolean.TRUE, TriState.YES.asBooleanObject());
-    assertSame(Boolean.FALSE, TriState.NO.asBooleanObject());
-    assertNull(TriState.UNSET.asBooleanObject());
-  }
+    @Test
+    public void testIsSet() {
+        assertTrue(TriState.YES.isSet());
+        assertTrue(TriState.NO.isSet());
+        assertFalse(TriState.UNSET.isSet());
+    }
+
+    @Test
+    public void testValueOf() {
+        assertEquals(TriState.YES, TriState.valueOf(true));
+        assertEquals(TriState.NO, TriState.valueOf(false));
+    }
+
+    @Test
+    public void testAsBooleanValidValues() {
+        assertTrue(TriState.YES.asBoolean());
+        assertFalse(TriState.NO.asBoolean());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testAsBooleanInvalidValues() {
+        TriState.UNSET.asBoolean();
+    }
+
+    @Test
+    public void testAsBooleanDefault() {
+        assertTrue(TriState.YES.asBoolean(false));
+        assertFalse(TriState.NO.asBoolean(true));
+        assertTrue(TriState.UNSET.asBoolean(true));
+        assertFalse(TriState.UNSET.asBoolean(false));
+    }
+
+    @Test
+    public void testAsBooleanObject() {
+        assertSame(Boolean.TRUE, TriState.YES.asBooleanObject());
+        assertSame(Boolean.FALSE, TriState.NO.asBooleanObject());
+        assertNull(TriState.UNSET.asBooleanObject());
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/datasource/AbstractDataSourceTest.java b/fbcore/src/test/java/com/facebook/datasource/AbstractDataSourceTest.java
index 93f96d514..f103f763b 100644
--- a/fbcore/src/test/java/com/facebook/datasource/AbstractDataSourceTest.java
+++ b/fbcore/src/test/java/com/facebook/datasource/AbstractDataSourceTest.java
@@ -27,298 +27,298 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class AbstractDataSourceTest {
 
-  public interface Value {
-    public void close();
-  }
-
-  private static class FakeAbstractDataSource extends AbstractDataSource<Value> {
-    @Override
-    public boolean setResult(@Nullable Value value, boolean isLast) {
-      return super.setResult(value, isLast);
+    public interface Value {
+        public void close();
     }
 
-    @Override
-    public boolean setFailure(Throwable throwable) {
-      return super.setFailure(throwable);
+    private static class FakeAbstractDataSource extends AbstractDataSource<Value> {
+        @Override
+        public boolean setResult(@Nullable Value value, boolean isLast) {
+            return super.setResult(value, isLast);
+        }
+
+        @Override
+        public boolean setFailure(Throwable throwable) {
+            return super.setFailure(throwable);
+        }
+
+        @Override
+        public boolean setProgress(float progress) {
+            return super.setProgress(progress);
+        }
+
+        @Override
+        public void closeResult(Value result) {
+            result.close();
+        }
     }
 
-    @Override
-    public boolean setProgress(float progress) {
-      return super.setProgress(progress);
+    private Executor mExecutor1;
+    private Executor mExecutor2;
+    private DataSubscriber<Value> mDataSubscriber1;
+    private DataSubscriber<Value> mDataSubscriber2;
+    private FakeAbstractDataSource mDataSource;
+
+    @Before
+    public void setUp() {
+        mExecutor1 = mock(Executor.class);
+        mExecutor2 = mock(Executor.class);
+        mDataSubscriber1 = mock(DataSubscriber.class);
+        mDataSubscriber2 = mock(DataSubscriber.class);
+        mDataSource = new FakeAbstractDataSource();
     }
 
-    @Override
-    public void closeResult(Value result) {
-      result.close();
+    private void verifyExecutor(Executor executor) {
+        ArgumentCaptor<Runnable> captor = ArgumentCaptor.forClass(Runnable.class);
+        verify(executor).execute(captor.capture());
+        Runnable runnable = captor.getValue();
+        assertNotNull(runnable);
+        runnable.run();
     }
-  }
-
-  private Executor mExecutor1;
-  private Executor mExecutor2;
-  private DataSubscriber<Value> mDataSubscriber1;
-  private DataSubscriber<Value> mDataSubscriber2;
-  private FakeAbstractDataSource mDataSource;
-
-  @Before
-  public void setUp() {
-    mExecutor1 = mock(Executor.class);
-    mExecutor2 = mock(Executor.class);
-    mDataSubscriber1 = mock(DataSubscriber.class);
-    mDataSubscriber2 = mock(DataSubscriber.class);
-    mDataSource = new FakeAbstractDataSource();
-  }
-
-  private void verifyExecutor(Executor executor) {
-    ArgumentCaptor<Runnable> captor = ArgumentCaptor.forClass(Runnable.class);
-    verify(executor).execute(captor.capture());
-    Runnable runnable = captor.getValue();
-    assertNotNull(runnable);
-    runnable.run();
-  }
-
-  private void verifySubscribers(int expected) {
-    switch (expected) {
-      case NO_INTERACTIONS:
-        verifyZeroInteractions(mExecutor1, mDataSubscriber1);
-        verifyZeroInteractions(mExecutor2, mDataSubscriber2);
-        break;
-      case ON_NEW_RESULT:
-        verifyExecutor(mExecutor1);
-        verify(mDataSubscriber1).onNewResult(mDataSource);
-        verifyExecutor(mExecutor2);
-        verify(mDataSubscriber2).onNewResult(mDataSource);
-        break;
-      case ON_FAILURE:
-        verifyExecutor(mExecutor1);
-        verify(mDataSubscriber1).onFailure(mDataSource);
-        verifyExecutor(mExecutor2);
-        verify(mDataSubscriber2).onFailure(mDataSource);
-        break;
-      case ON_CANCELLATION:
-        verifyExecutor(mExecutor1);
-        verify(mDataSubscriber1).onCancellation(mDataSource);
-        verifyExecutor(mExecutor2);
-        verify(mDataSubscriber2).onCancellation(mDataSource);
-        break;
+
+    private void verifySubscribers(int expected) {
+        switch (expected) {
+            case NO_INTERACTIONS:
+                verifyZeroInteractions(mExecutor1, mDataSubscriber1);
+                verifyZeroInteractions(mExecutor2, mDataSubscriber2);
+                break;
+            case ON_NEW_RESULT:
+                verifyExecutor(mExecutor1);
+                verify(mDataSubscriber1).onNewResult(mDataSource);
+                verifyExecutor(mExecutor2);
+                verify(mDataSubscriber2).onNewResult(mDataSource);
+                break;
+            case ON_FAILURE:
+                verifyExecutor(mExecutor1);
+                verify(mDataSubscriber1).onFailure(mDataSource);
+                verifyExecutor(mExecutor2);
+                verify(mDataSubscriber2).onFailure(mDataSource);
+                break;
+            case ON_CANCELLATION:
+                verifyExecutor(mExecutor1);
+                verify(mDataSubscriber1).onCancellation(mDataSource);
+                verifyExecutor(mExecutor2);
+                verify(mDataSubscriber2).onCancellation(mDataSource);
+                break;
+        }
+        reset(mExecutor1, mExecutor2, mDataSubscriber1, mDataSubscriber2);
+    }
+
+    private void subscribe() {
+        mDataSource.subscribe(mDataSubscriber1, mExecutor1);
+        mDataSource.subscribe(mDataSubscriber2, mExecutor2);
+    }
+
+    @Test
+    public void testInitialState() {
+        verifyState(mDataSource, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    @Test
+    public void testLifeCycle_LastResult_Close() {
+        subscribe();
+        // last result
+        Value value = mock(Value.class);
+        mDataSource.setResult(value, LAST);
+        verifySubscribers(ON_NEW_RESULT);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
+        // close
+        mDataSource.close();
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    @Test
+    public void testLifeCycle_Failure_Close() {
+        subscribe();
+        // failure
+        Throwable throwable = mock(Throwable.class);
+        mDataSource.setFailure(throwable);
+        verifySubscribers(ON_FAILURE);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+        // close
+        mDataSource.close();
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+    }
+
+    @Test
+    public void testLifeCycle_IntermediateResult_LastResult_Close() {
+        subscribe();
+        // intermediate result
+        Value value1 = mock(Value.class);
+        mDataSource.setResult(value1, INTERMEDIATE);
+        verifySubscribers(ON_NEW_RESULT);
+        verifyState(mDataSource, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, value1, NOT_FAILED, null);
+        // last result
+        Value value = mock(Value.class);
+        mDataSource.setResult(value, LAST);
+        verifySubscribers(ON_NEW_RESULT);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
+        // close
+        mDataSource.close();
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    @Test
+    public void testLifeCycle_IntermediateResult_Failure_Close() {
+        subscribe();
+        // intermediate result
+        Value value1 = mock(Value.class);
+        mDataSource.setResult(value1, INTERMEDIATE);
+        verifySubscribers(ON_NEW_RESULT);
+        verifyState(mDataSource, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, value1, NOT_FAILED, null);
+        // failure
+        Throwable throwable = mock(Throwable.class);
+        mDataSource.setFailure(throwable);
+        verifySubscribers(ON_FAILURE);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value1, FAILED, throwable);
+        // close
+        mDataSource.close();
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+    }
+
+    @Test
+    public void testLifeCycle_AfterSuccess() {
+        subscribe();
+        // success
+        Value value = mock(Value.class);
+        mDataSource.setResult(value, LAST);
+        verifySubscribers(ON_NEW_RESULT);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
+        // try intermediate
+        mDataSource.setResult(mock(Value.class), INTERMEDIATE);
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
+        // try last
+        mDataSource.setResult(mock(Value.class), LAST);
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
+        // try failure
+        mDataSource.setFailure(mock(Throwable.class));
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
+    }
+
+    @Test
+    public void testLifeCycle_AfterFailure() {
+        subscribe();
+        // failure
+        Throwable throwable = mock(Throwable.class);
+        mDataSource.setFailure(throwable);
+        verifySubscribers(ON_FAILURE);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+        // try intermediate
+        mDataSource.setResult(mock(Value.class), INTERMEDIATE);
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+        // try last
+        mDataSource.setResult(mock(Value.class), LAST);
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+        // try failure
+        mDataSource.setFailure(mock(Throwable.class));
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+    }
+
+    @Test
+    public void testLifeCycle_AfterClose() {
+        subscribe();
+        // close
+        mDataSource.close();
+        verifySubscribers(ON_CANCELLATION);
+        verifyState(mDataSource, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+        // try intermediate
+        mDataSource.setResult(mock(Value.class), INTERMEDIATE);
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+        // try last
+        mDataSource.setResult(mock(Value.class), LAST);
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+        // try failure
+        mDataSource.setFailure(mock(Throwable.class));
+        verifySubscribers(NO_INTERACTIONS);
+        verifyState(mDataSource, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    @Test
+    public void testSubscribe_InProgress_WithoutResult() {
+        subscribe();
+        verifySubscribers(NO_INTERACTIONS);
+    }
+
+    @Test
+    public void testSubscribe_InProgress_WithResult() {
+        mDataSource.setResult(mock(Value.class), INTERMEDIATE);
+        subscribe();
+        verifySubscribers(ON_NEW_RESULT);
+    }
+
+    @Test
+    public void testSubscribe_Finished_WithoutResult() {
+        mDataSource.setResult(null, LAST);
+        subscribe();
+        verifySubscribers(ON_NEW_RESULT);
+    }
+
+    @Test
+    public void testSubscribe_Finished_WithResult() {
+        mDataSource.setResult(mock(Value.class), LAST);
+        subscribe();
+        verifySubscribers(ON_NEW_RESULT);
+    }
+
+    @Test
+    public void testSubscribe_Failed_WithoutResult() {
+        mDataSource.setFailure(mock(Throwable.class));
+        subscribe();
+        verifySubscribers(ON_FAILURE);
+    }
+
+    @Test
+    public void testSubscribe_Failed_WithResult() {
+        mDataSource.setResult(mock(Value.class), INTERMEDIATE);
+        mDataSource.setFailure(mock(Throwable.class));
+        subscribe();
+        verifySubscribers(ON_FAILURE);
+    }
+
+    @Test
+    public void testSubscribe_Closed_AfterSuccess() {
+        mDataSource.setResult(mock(Value.class), LAST);
+        mDataSource.close();
+        subscribe();
+        verifySubscribers(NO_INTERACTIONS);
+    }
+
+    @Test
+    public void testSubscribe_Closed_AfterFailure() {
+        mDataSource.setFailure(mock(Throwable.class));
+        mDataSource.close();
+        subscribe();
+        verifySubscribers(NO_INTERACTIONS);
+    }
+
+    @Test
+    public void testCloseResult() {
+        Value value1 = mock(Value.class);
+        mDataSource.setResult(value1, false);
+
+        Value value2 = mock(Value.class);
+        mDataSource.setResult(value2, false);
+        verify(value1).close();
+        verify(value2, never()).close();
+
+        Value value3 = mock(Value.class);
+        mDataSource.setResult(value3, false);
+        verify(value2).close();
+        verify(value3, never()).close();
+
+        mDataSource.close();
+        verify(value3).close();
     }
-    reset(mExecutor1, mExecutor2, mDataSubscriber1, mDataSubscriber2);
-  }
-
-  private void subscribe() {
-    mDataSource.subscribe(mDataSubscriber1, mExecutor1);
-    mDataSource.subscribe(mDataSubscriber2, mExecutor2);
-  }
-
-  @Test
-  public void testInitialState() {
-    verifyState(mDataSource, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  @Test
-  public void testLifeCycle_LastResult_Close() {
-    subscribe();
-    // last result
-    Value value = mock(Value.class);
-    mDataSource.setResult(value, LAST);
-    verifySubscribers(ON_NEW_RESULT);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
-    // close
-    mDataSource.close();
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  @Test
-  public void testLifeCycle_Failure_Close() {
-    subscribe();
-    // failure
-    Throwable throwable = mock(Throwable.class);
-    mDataSource.setFailure(throwable);
-    verifySubscribers(ON_FAILURE);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-    // close
-    mDataSource.close();
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-  }
-
-  @Test
-  public void testLifeCycle_IntermediateResult_LastResult_Close() {
-    subscribe();
-    // intermediate result
-    Value value1 = mock(Value.class);
-    mDataSource.setResult(value1, INTERMEDIATE);
-    verifySubscribers(ON_NEW_RESULT);
-    verifyState(mDataSource, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, value1, NOT_FAILED, null);
-    // last result
-    Value value = mock(Value.class);
-    mDataSource.setResult(value, LAST);
-    verifySubscribers(ON_NEW_RESULT);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
-    // close
-    mDataSource.close();
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  @Test
-  public void testLifeCycle_IntermediateResult_Failure_Close() {
-    subscribe();
-    // intermediate result
-    Value value1 = mock(Value.class);
-    mDataSource.setResult(value1, INTERMEDIATE);
-    verifySubscribers(ON_NEW_RESULT);
-    verifyState(mDataSource, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, value1, NOT_FAILED, null);
-    // failure
-    Throwable throwable = mock(Throwable.class);
-    mDataSource.setFailure(throwable);
-    verifySubscribers(ON_FAILURE);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value1, FAILED, throwable);
-    // close
-    mDataSource.close();
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-  }
-
-  @Test
-  public void testLifeCycle_AfterSuccess() {
-    subscribe();
-    // success
-    Value value = mock(Value.class);
-    mDataSource.setResult(value, LAST);
-    verifySubscribers(ON_NEW_RESULT);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
-    // try intermediate
-    mDataSource.setResult(mock(Value.class), INTERMEDIATE);
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
-    // try last
-    mDataSource.setResult(mock(Value.class), LAST);
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
-    // try failure
-    mDataSource.setFailure(mock(Throwable.class));
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITH_RESULT, value, NOT_FAILED, null);
-  }
-
-  @Test
-  public void testLifeCycle_AfterFailure() {
-    subscribe();
-    // failure
-    Throwable throwable = mock(Throwable.class);
-    mDataSource.setFailure(throwable);
-    verifySubscribers(ON_FAILURE);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-    // try intermediate
-    mDataSource.setResult(mock(Value.class), INTERMEDIATE);
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-    // try last
-    mDataSource.setResult(mock(Value.class), LAST);
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-    // try failure
-    mDataSource.setFailure(mock(Throwable.class));
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-  }
-
-  @Test
-  public void testLifeCycle_AfterClose() {
-    subscribe();
-    // close
-    mDataSource.close();
-    verifySubscribers(ON_CANCELLATION);
-    verifyState(mDataSource, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-    // try intermediate
-    mDataSource.setResult(mock(Value.class), INTERMEDIATE);
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-    // try last
-    mDataSource.setResult(mock(Value.class), LAST);
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-    // try failure
-    mDataSource.setFailure(mock(Throwable.class));
-    verifySubscribers(NO_INTERACTIONS);
-    verifyState(mDataSource, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  @Test
-  public void testSubscribe_InProgress_WithoutResult() {
-    subscribe();
-    verifySubscribers(NO_INTERACTIONS);
-  }
-
-  @Test
-  public void testSubscribe_InProgress_WithResult() {
-    mDataSource.setResult(mock(Value.class), INTERMEDIATE);
-    subscribe();
-    verifySubscribers(ON_NEW_RESULT);
-  }
-
-  @Test
-  public void testSubscribe_Finished_WithoutResult() {
-    mDataSource.setResult(null, LAST);
-    subscribe();
-    verifySubscribers(ON_NEW_RESULT);
-  }
-
-  @Test
-  public void testSubscribe_Finished_WithResult() {
-    mDataSource.setResult(mock(Value.class), LAST);
-    subscribe();
-    verifySubscribers(ON_NEW_RESULT);
-  }
-
-  @Test
-  public void testSubscribe_Failed_WithoutResult() {
-    mDataSource.setFailure(mock(Throwable.class));
-    subscribe();
-    verifySubscribers(ON_FAILURE);
-  }
-
-  @Test
-  public void testSubscribe_Failed_WithResult() {
-    mDataSource.setResult(mock(Value.class), INTERMEDIATE);
-    mDataSource.setFailure(mock(Throwable.class));
-    subscribe();
-    verifySubscribers(ON_FAILURE);
-  }
-
-  @Test
-  public void testSubscribe_Closed_AfterSuccess() {
-    mDataSource.setResult(mock(Value.class), LAST);
-    mDataSource.close();
-    subscribe();
-    verifySubscribers(NO_INTERACTIONS);
-  }
-
-  @Test
-  public void testSubscribe_Closed_AfterFailure() {
-    mDataSource.setFailure(mock(Throwable.class));
-    mDataSource.close();
-    subscribe();
-    verifySubscribers(NO_INTERACTIONS);
-  }
-
-  @Test
-  public void testCloseResult() {
-    Value value1 = mock(Value.class);
-    mDataSource.setResult(value1, false);
-
-    Value value2 = mock(Value.class);
-    mDataSource.setResult(value2, false);
-    verify(value1).close();
-    verify(value2, never()).close();
-
-    Value value3 = mock(Value.class);
-    mDataSource.setResult(value3, false);
-    verify(value2).close();
-    verify(value3, never()).close();
-
-    mDataSource.close();
-    verify(value3).close();
-  }
 }
diff --git a/fbcore/src/test/java/com/facebook/datasource/DataSourceTestUtils.java b/fbcore/src/test/java/com/facebook/datasource/DataSourceTestUtils.java
index f06474d1e..eb4b34101 100644
--- a/fbcore/src/test/java/com/facebook/datasource/DataSourceTestUtils.java
+++ b/fbcore/src/test/java/com/facebook/datasource/DataSourceTestUtils.java
@@ -29,257 +29,261 @@
 
 public class DataSourceTestUtils {
 
-  public static final boolean CLOSED = true;
-  public static final boolean NOT_CLOSED = false;
-  public static final boolean FINISHED = true;
-  public static final boolean NOT_FINISHED = false;
-  public static final boolean WITH_RESULT = true;
-  public static final boolean WITHOUT_RESULT = false;
-  public static final boolean FAILED = true;
-  public static final boolean NOT_FAILED = false;
-  public static final boolean LAST = true;
-  public static final boolean INTERMEDIATE = false;
-  public static final int NO_INTERACTIONS = 0;
-  public static final int ON_NEW_RESULT = 1;
-  public static final int ON_FAILURE = 2;
-  public static final int ON_CANCELLATION = 3;
+    public static final boolean CLOSED = true;
+    public static final boolean NOT_CLOSED = false;
+    public static final boolean FINISHED = true;
+    public static final boolean NOT_FINISHED = false;
+    public static final boolean WITH_RESULT = true;
+    public static final boolean WITHOUT_RESULT = false;
+    public static final boolean FAILED = true;
+    public static final boolean NOT_FAILED = false;
+    public static final boolean LAST = true;
+    public static final boolean INTERMEDIATE = false;
+    public static final int NO_INTERACTIONS = 0;
+    public static final int ON_NEW_RESULT = 1;
+    public static final int ON_FAILURE = 2;
+    public static final int ON_CANCELLATION = 3;
 
-  public static VerificationMode optional() {
-    return atLeast(0);
-  }
-
-  public static void setState(
-      DataSource<Object> dataSource,
-      boolean isClosed,
-      boolean isFinished,
-      boolean hasResult,
-      Object value,
-      boolean hasFailed,
-      Throwable failureCause) {
-    when(dataSource.isClosed()).thenReturn(isClosed);
-    when(dataSource.isFinished()).thenReturn(isFinished);
-    when(dataSource.hasResult()).thenReturn(hasResult);
-    when(dataSource.getResult()).thenReturn(value);
-    when(dataSource.hasFailed()).thenReturn(hasFailed);
-    when(dataSource.getFailureCause()).thenReturn(failureCause);
-  }
+    public static VerificationMode optional() {
+        return atLeast(0);
+    }
 
-  public static <T> void verifyState(
-      DataSource<T> dataSource,
-      boolean isClosed,
-      boolean isFinished,
-      boolean hasResult,
-      T result,
-      boolean hasFailed,
-      Throwable failureCause) {
-    assertEquals("isClosed", isClosed, dataSource.isClosed());
-    assertEquals("isFinished", isFinished, dataSource.isFinished());
-    assertEquals("hasResult", hasResult, dataSource.hasResult());
-    assertSame("getResult", result, dataSource.getResult());
-    assertEquals("hasFailed", hasFailed, dataSource.hasFailed());
-    assertSame("failureCause", failureCause, dataSource.getFailureCause());
-  }
+    public static void setState(
+            DataSource<Object> dataSource,
+            boolean isClosed,
+            boolean isFinished,
+            boolean hasResult,
+            Object value,
+            boolean hasFailed,
+            Throwable failureCause) {
+        when(dataSource.isClosed()).thenReturn(isClosed);
+        when(dataSource.isFinished()).thenReturn(isFinished);
+        when(dataSource.hasResult()).thenReturn(hasResult);
+        when(dataSource.getResult()).thenReturn(value);
+        when(dataSource.hasFailed()).thenReturn(hasFailed);
+        when(dataSource.getFailureCause()).thenReturn(failureCause);
+    }
 
-  public static class AbstractDataSourceSupplier {
+    public static <T> void verifyState(
+            DataSource<T> dataSource,
+            boolean isClosed,
+            boolean isFinished,
+            boolean hasResult,
+            T result,
+            boolean hasFailed,
+            Throwable failureCause) {
+        assertEquals("isClosed", isClosed, dataSource.isClosed());
+        assertEquals("isFinished", isFinished, dataSource.isFinished());
+        assertEquals("hasResult", hasResult, dataSource.hasResult());
+        assertSame("getResult", result, dataSource.getResult());
+        assertEquals("hasFailed", hasFailed, dataSource.hasFailed());
+        assertSame("failureCause", failureCause, dataSource.getFailureCause());
+    }
 
-    protected DataSource<Object> mSrc1;
-    protected DataSource<Object> mSrc2;
-    protected DataSource<Object> mSrc3;
-    protected Supplier<DataSource<Object>> mDataSourceSupplier1;
-    protected Supplier<DataSource<Object>> mDataSourceSupplier2;
-    protected Supplier<DataSource<Object>> mDataSourceSupplier3;
-    protected DataSubscriber<Object> mDataSubscriber;
-    protected Executor mExecutor;
-    protected InOrder mInOrder;
-    protected List<Supplier<DataSource<Object>>> mSuppliers;
-    protected Supplier<DataSource<Object>> mDataSourceSupplier;
+    public static class AbstractDataSourceSupplier {
 
-    public void setUp() {
-      mSrc1 = mock(DataSource.class);
-      mSrc2 = mock(DataSource.class);
-      mSrc3 = mock(DataSource.class);
-      mDataSourceSupplier1 = mock(Supplier.class);
-      mDataSourceSupplier2 = mock(Supplier.class);
-      mDataSourceSupplier3 = mock(Supplier.class);
-      when(mDataSourceSupplier1.get()).thenReturn(mSrc1);
-      when(mDataSourceSupplier2.get()).thenReturn(mSrc2);
-      when(mDataSourceSupplier3.get()).thenReturn(mSrc3);
-      mDataSubscriber = mock(DataSubscriber.class);
-      mExecutor = CallerThreadExecutor.getInstance();
-      mInOrder = inOrder(
-          mSrc1,
-          mSrc2,
-          mSrc3,
-          mDataSourceSupplier1,
-          mDataSourceSupplier2,
-          mDataSourceSupplier3,
-          mDataSubscriber);
-      mSuppliers = Lists.newArrayList(
-          mDataSourceSupplier1,
-          mDataSourceSupplier2,
-          mDataSourceSupplier3);
-    }
+        protected DataSource<Object> mSrc1;
+        protected DataSource<Object> mSrc2;
+        protected DataSource<Object> mSrc3;
+        protected Supplier<DataSource<Object>> mDataSourceSupplier1;
+        protected Supplier<DataSource<Object>> mDataSourceSupplier2;
+        protected Supplier<DataSource<Object>> mDataSourceSupplier3;
+        protected DataSubscriber<Object> mDataSubscriber;
+        protected Executor mExecutor;
+        protected InOrder mInOrder;
+        protected List<Supplier<DataSource<Object>>> mSuppliers;
+        protected Supplier<DataSource<Object>> mDataSourceSupplier;
 
-    protected void verifyNoMoreInteractionsAll() {
-      verifyOptionals(mSrc1);
-      verifyOptionals(mSrc2);
-      verifyOptionals(mSrc3);
-      mInOrder.verifyNoMoreInteractions();
-      verifyNoMoreInteractions(
-          mSrc1,
-          mSrc2,
-          mSrc3,
-          mDataSourceSupplier1,
-          mDataSourceSupplier2,
-          mDataSourceSupplier3,
-          mDataSubscriber);
-    }
+        public void setUp() {
+            mSrc1 = mock(DataSource.class);
+            mSrc2 = mock(DataSource.class);
+            mSrc3 = mock(DataSource.class);
+            mDataSourceSupplier1 = mock(Supplier.class);
+            mDataSourceSupplier2 = mock(Supplier.class);
+            mDataSourceSupplier3 = mock(Supplier.class);
+            when(mDataSourceSupplier1.get()).thenReturn(mSrc1);
+            when(mDataSourceSupplier2.get()).thenReturn(mSrc2);
+            when(mDataSourceSupplier3.get()).thenReturn(mSrc3);
+            mDataSubscriber = mock(DataSubscriber.class);
+            mExecutor = CallerThreadExecutor.getInstance();
+            mInOrder = inOrder(
+                    mSrc1,
+                    mSrc2,
+                    mSrc3,
+                    mDataSourceSupplier1,
+                    mDataSourceSupplier2,
+                    mDataSourceSupplier3,
+                    mDataSubscriber);
+            mSuppliers = Lists.newArrayList(
+                    mDataSourceSupplier1,
+                    mDataSourceSupplier2,
+                    mDataSourceSupplier3);
+        }
 
-    protected void verifyOptionals(DataSource<Object> underlyingDataSource) {
-      mInOrder.verify(underlyingDataSource, optional()).isFinished();
-      mInOrder.verify(underlyingDataSource, optional()).hasResult();
-      mInOrder.verify(underlyingDataSource, optional()).hasFailed();
-      verify(underlyingDataSource, optional()).isFinished();
-      verify(underlyingDataSource, optional()).hasResult();
-      verify(underlyingDataSource, optional()).hasFailed();
-    }
+        protected void verifyNoMoreInteractionsAll() {
+            verifyOptionals(mSrc1);
+            verifyOptionals(mSrc2);
+            verifyOptionals(mSrc3);
+            mInOrder.verifyNoMoreInteractions();
+            verifyNoMoreInteractions(
+                    mSrc1,
+                    mSrc2,
+                    mSrc3,
+                    mDataSourceSupplier1,
+                    mDataSourceSupplier2,
+                    mDataSourceSupplier3,
+                    mDataSubscriber);
+        }
 
-    /**
-     * Verifies that our mDataSourceSupplier got underlying data source and subscribed to it.
-     * Subscriber is returned.
-     */
-    protected DataSubscriber<Object> verifyGetAndSubscribe(
-        Supplier<DataSource<Object>> dataSourceSupplier,
-        DataSource<Object> underlyingDataSource,
-        boolean expectMoreInteractions) {
-      mInOrder.verify(dataSourceSupplier).get();
-      ArgumentCaptor<DataSubscriber> captor = ArgumentCaptor.forClass(DataSubscriber.class);
-      mInOrder.verify(underlyingDataSource).subscribe(captor.capture(), any(Executor.class));
-      if (!expectMoreInteractions) {
-        verifyNoMoreInteractionsAll();
-      }
-      return captor.getValue();
-    }
+        protected void verifyOptionals(DataSource<Object> underlyingDataSource) {
+            mInOrder.verify(underlyingDataSource, optional()).isFinished();
+            mInOrder.verify(underlyingDataSource, optional()).hasResult();
+            mInOrder.verify(underlyingDataSource, optional()).hasFailed();
+            verify(underlyingDataSource, optional()).isFinished();
+            verify(underlyingDataSource, optional()).hasResult();
+            verify(underlyingDataSource, optional()).hasFailed();
+        }
 
-    protected DataSubscriber<Object> verifyGetAndSubscribe(
-        Supplier<DataSource<Object>> dataSourceSupplier,
-        DataSource<Object> underlyingDataSource) {
-      return verifyGetAndSubscribe(dataSourceSupplier, underlyingDataSource, false);
-    }
+        /**
+         * Verifies that our mDataSourceSupplier got underlying data source and subscribed to it.
+         * Subscriber is returned.
+         */
+        protected DataSubscriber<Object> verifyGetAndSubscribe(
+                Supplier<DataSource<Object>> dataSourceSupplier,
+                DataSource<Object> underlyingDataSource,
+                boolean expectMoreInteractions) {
+            mInOrder.verify(dataSourceSupplier).get();
+            ArgumentCaptor<DataSubscriber> captor = ArgumentCaptor.forClass(DataSubscriber.class);
+            mInOrder.verify(underlyingDataSource).subscribe(captor.capture(), any(Executor.class));
+            if (!expectMoreInteractions) {
+                verifyNoMoreInteractionsAll();
+            }
+            return captor.getValue();
+        }
 
-    protected DataSubscriber<Object> verifyGetAndSubscribeM(
-        Supplier<DataSource<Object>> dataSourceSupplier,
-        DataSource<Object> underlyingDataSource) {
-      return verifyGetAndSubscribe(dataSourceSupplier, underlyingDataSource, true);
-    }
+        protected DataSubscriber<Object> verifyGetAndSubscribe(
+                Supplier<DataSource<Object>> dataSourceSupplier,
+                DataSource<Object> underlyingDataSource) {
+            return verifyGetAndSubscribe(dataSourceSupplier, underlyingDataSource, false);
+        }
 
-    /**
-     * Verifies that data source provided by our mDataSourceSupplier notified mDataSubscriber.
-     */
-    protected void verifySubscriber(
-        DataSource<Object> dataSource,
-        DataSource<Object> underlyingDataSource,
-        int expected) {
-      switch (expected) {
-        case NO_INTERACTIONS:
-          verifyNoMoreInteractionsAll();
-          break;
-        case ON_NEW_RESULT:
-          mInOrder.verify(mDataSubscriber).onNewResult(dataSource);
-          verifyNoMoreInteractionsAll();
-          break;
-        case ON_FAILURE:
-          mInOrder.verify(underlyingDataSource).getFailureCause();
-          mInOrder.verify(mDataSubscriber).onFailure(dataSource);
-          verifyNoMoreInteractionsAll();
-          break;
-        case ON_CANCELLATION:
-          verify(mDataSubscriber).onCancellation(dataSource);
-          verifyNoMoreInteractionsAll();
-          break;
-      }
-    }
+        protected DataSubscriber<Object> verifyGetAndSubscribeM(
+                Supplier<DataSource<Object>> dataSourceSupplier,
+                DataSource<Object> underlyingDataSource) {
+            return verifyGetAndSubscribe(dataSourceSupplier, underlyingDataSource, true);
+        }
 
-    /**
-     * Verifies the state of the data source provided by our mDataSourceSupplier.
-     */
-    protected void verifyState(
-        DataSource<Object> dataSource,
-        @Nullable DataSource<Object> dataSourceWithResult,
-        boolean isClosed,
-        boolean isFinished,
-        boolean hasResult,
-        Object result,
-        boolean hasFailed,
-        Throwable failureCause) {
-      DataSourceTestUtils.verifyState(
-          dataSource, isClosed, isFinished, hasResult, result, hasFailed, failureCause);
-      // DataSourceTestUtils.verifyState will call dataSource.getResult() which should forward to
-      // underlyingDataSource.getResult()
-      if (dataSourceWithResult != null) {
-        mInOrder.verify(dataSourceWithResult).getResult();
-      }
-      verifyNoMoreInteractionsAll();
-    }
+        /**
+         * Verifies that data source provided by our mDataSourceSupplier notified mDataSubscriber.
+         */
+        protected void verifySubscriber(
+                DataSource<Object> dataSource,
+                DataSource<Object> underlyingDataSource,
+                int expected) {
+            switch (expected) {
+                case NO_INTERACTIONS:
+                    verifyNoMoreInteractionsAll();
+                    break;
+                case ON_NEW_RESULT:
+                    mInOrder.verify(mDataSubscriber).onNewResult(dataSource);
+                    verifyNoMoreInteractionsAll();
+                    break;
+                case ON_FAILURE:
+                    mInOrder.verify(underlyingDataSource).getFailureCause();
+                    mInOrder.verify(mDataSubscriber).onFailure(dataSource);
+                    verifyNoMoreInteractionsAll();
+                    break;
+                case ON_CANCELLATION:
+                    verify(mDataSubscriber).onCancellation(dataSource);
+                    verifyNoMoreInteractionsAll();
+                    break;
+            }
+        }
 
-    /**
-     * Verifies that the underlying data sources get closed when data source provided by
-     * our mDataSourceSupplier gets closed.
-     */
-    protected void testClose(
-        DataSource<Object> dataSource,
-        DataSource<Object>... underlyingDataSources) {
-      dataSource.close();
-      if (underlyingDataSources != null) {
-        for (DataSource<Object> underlyingDataSource : underlyingDataSources) {
-          mInOrder.verify(underlyingDataSource, atLeastOnce()).close();
+        /**
+         * Verifies the state of the data source provided by our mDataSourceSupplier.
+         */
+        protected void verifyState(
+                DataSource<Object> dataSource,
+                @Nullable DataSource<Object> dataSourceWithResult,
+                boolean isClosed,
+                boolean isFinished,
+                boolean hasResult,
+                Object result,
+                boolean hasFailed,
+                Throwable failureCause) {
+            DataSourceTestUtils.verifyState(
+                    dataSource, isClosed, isFinished, hasResult, result, hasFailed, failureCause);
+            // DataSourceTestUtils.verifyState will call dataSource.getResult() which should forward to
+            // underlyingDataSource.getResult()
+            if (dataSourceWithResult != null) {
+                mInOrder.verify(dataSourceWithResult).getResult();
+            }
+            verifyNoMoreInteractionsAll();
         }
-      }
-    }
 
-    /**
-     * Gets data source from our mDataSourceSupplier and subscribes mDataSubscriber to it.
-     * Obtained data source is returned.
-     */
-    protected DataSource<Object> getAndSubscribe() {
-      DataSource<Object> dataSource = mDataSourceSupplier.get();
-      dataSource.subscribe(mDataSubscriber, mExecutor);
-      return dataSource;
-    }
+        /**
+         * Verifies that the underlying data sources get closed when data source provided by
+         * our mDataSourceSupplier gets closed.
+         */
+        protected void testClose(
+                DataSource<Object> dataSource,
+                DataSource<Object>... underlyingDataSources) {
+            dataSource.close();
+            if (underlyingDataSources != null) {
+                for (DataSource<Object> underlyingDataSource : underlyingDataSources) {
+                    mInOrder.verify(underlyingDataSource, atLeastOnce()).close();
+                }
+            }
+        }
 
-    /** Respond to subscriber with given data source and response. */
-    protected static <T> void respond(
-        DataSubscriber<T> subscriber,
-        DataSource<T> dataSource,
-        int response) {
-      switch (response) {
-        case NO_INTERACTIONS:
-          break;
-        case ON_NEW_RESULT:
-          subscriber.onNewResult(dataSource);
-          break;
-        case ON_FAILURE:
-          subscriber.onFailure(dataSource);
-          break;
-        case ON_CANCELLATION:
-          subscriber.onCancellation(dataSource);
-          break;
-      }
-    }
+        /**
+         * Gets data source from our mDataSourceSupplier and subscribes mDataSubscriber to it.
+         * Obtained data source is returned.
+         */
+        protected DataSource<Object> getAndSubscribe() {
+            DataSource<Object> dataSource = mDataSourceSupplier.get();
+            dataSource.subscribe(mDataSubscriber, mExecutor);
+            return dataSource;
+        }
 
-    /** Schedule response on subscribe. */
-    protected static <T> void respondOnSubscribe(
-        final DataSource<T> dataSource,
-        final int response) {
-      doAnswer(
-          new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-              DataSubscriber<T> subscriber = (DataSubscriber<T>) invocation.getArguments()[0];
-              respond(subscriber, dataSource, response);
-              return subscriber;
+        /**
+         * Respond to subscriber with given data source and response.
+         */
+        protected static <T> void respond(
+                DataSubscriber<T> subscriber,
+                DataSource<T> dataSource,
+                int response) {
+            switch (response) {
+                case NO_INTERACTIONS:
+                    break;
+                case ON_NEW_RESULT:
+                    subscriber.onNewResult(dataSource);
+                    break;
+                case ON_FAILURE:
+                    subscriber.onFailure(dataSource);
+                    break;
+                case ON_CANCELLATION:
+                    subscriber.onCancellation(dataSource);
+                    break;
             }
-          }).when(dataSource).subscribe(any(DataSubscriber.class), any(Executor.class));
+        }
+
+        /**
+         * Schedule response on subscribe.
+         */
+        protected static <T> void respondOnSubscribe(
+                final DataSource<T> dataSource,
+                final int response) {
+            doAnswer(
+                    new Answer() {
+                        @Override
+                        public Object answer(InvocationOnMock invocation) throws Throwable {
+                            DataSubscriber<T> subscriber = (DataSubscriber<T>) invocation.getArguments()[0];
+                            respond(subscriber, dataSource, response);
+                            return subscriber;
+                        }
+                    }).when(dataSource).subscribe(any(DataSubscriber.class), any(Executor.class));
+        }
     }
-  }
 }
diff --git a/fbcore/src/test/java/com/facebook/datasource/DataSourcesTest.java b/fbcore/src/test/java/com/facebook/datasource/DataSourcesTest.java
index bb821f1ba..3b8478b0e 100644
--- a/fbcore/src/test/java/com/facebook/datasource/DataSourcesTest.java
+++ b/fbcore/src/test/java/com/facebook/datasource/DataSourcesTest.java
@@ -20,20 +20,20 @@
 
 @RunWith(WithTestDefaultsRunner.class)
 public class DataSourcesTest {
-  private Exception mException;
+    private Exception mException;
 
-  @Before
-  public void setUp() {
-    mException = mock(Exception.class);
-  }
+    @Before
+    public void setUp() {
+        mException = mock(Exception.class);
+    }
 
-  @Test
-  public void testImmediateFailedDataSource() {
-    DataSource<?> dataSource = DataSources.immediateFailedDataSource(mException);
-    assertTrue(dataSource.isFinished());
-    assertTrue(dataSource.hasFailed());
-    assertEquals(mException, dataSource.getFailureCause());
-    assertFalse(dataSource.hasResult());
-    assertFalse(dataSource.isClosed());
-  }
+    @Test
+    public void testImmediateFailedDataSource() {
+        DataSource<?> dataSource = DataSources.immediateFailedDataSource(mException);
+        assertTrue(dataSource.isFinished());
+        assertTrue(dataSource.hasFailed());
+        assertEquals(mException, dataSource.getFailureCause());
+        assertFalse(dataSource.hasResult());
+        assertFalse(dataSource.isClosed());
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/datasource/FirstAvailableDataSourceSupplierTest.java b/fbcore/src/test/java/com/facebook/datasource/FirstAvailableDataSourceSupplierTest.java
index 56f3e23a7..7981512c2 100644
--- a/fbcore/src/test/java/com/facebook/datasource/FirstAvailableDataSourceSupplierTest.java
+++ b/fbcore/src/test/java/com/facebook/datasource/FirstAvailableDataSourceSupplierTest.java
@@ -24,340 +24,340 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class FirstAvailableDataSourceSupplierTest extends AbstractDataSourceSupplier {
 
-  @Before
-  public void setUp() {
-    super.setUp();
-    mDataSourceSupplier = FirstAvailableDataSourceSupplier.create(mSuppliers);
-  }
-
-  /**
-   * All data sources failed, no intermediate results.
-   */
-  @Test
-  public void testLifecycle_F1_F2_F3_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
-    subscriber1.onFailure(mSrc1);
-    mInOrder.verify(mSrc1).close();
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
-    subscriber2.onFailure(mSrc2);
-    mInOrder.verify(mSrc2).close();
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    Throwable throwable = mock(Throwable.class);
-    setState(mSrc3, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-    subscriber3.onFailure(mSrc3);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc3, ON_FAILURE);
-    verifyState(dataSource, null, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-
-    testClose(dataSource);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-  }
-
-  /**
-   * All data sources failed, second data source produced multiple intermediate results.
-   */
-  @Test
-  public void testLifecycle_F1_I2_I2_F2_F3_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
-    subscriber1.onFailure(mSrc1);
-    mInOrder.verify(mSrc1).close();
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    Object val2a = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-
-    Object val2b = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, FAILED, mock(Throwable.class));
-    subscriber2.onFailure(mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-
-    Throwable throwable = mock(Throwable.class);
-    setState(mSrc3, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-    subscriber3.onFailure(mSrc3);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc3, ON_FAILURE);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, FAILED, throwable);
-
-    testClose(dataSource, mSrc2);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-  }
-
-  /**
-   * All data sources failed, first two data sources produced intermediate results. Only first kept.
-   */
-  @Test
-  public void testLifecycle_I1_F1_I2_F2_F3_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    Object val1 = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, FAILED, mock(Throwable.class));
-    subscriber1.onFailure(mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    // I2 gets ignored because we already have I1
-    Object val2 = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2, FAILED, mock(Throwable.class));
-    subscriber2.onFailure(mSrc2);
-    mInOrder.verify(mSrc2).close();
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    Throwable throwable = mock(Throwable.class);
-    setState(mSrc3, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-    subscriber3.onFailure(mSrc3);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc3, ON_FAILURE);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, FAILED, throwable);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-  }
-
-  /**
-   * First data source failed, second succeeded, no intermediate results.
-   */
-  @Test
-  public void testLifecycle_F1_S2_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
-    subscriber1.onFailure(mSrc1);
-    mInOrder.verify(mSrc1).close();
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    Object val = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc2);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * First data source succeeded, no intermediate results.
-   */
-  @Test
-  public void testLifecycle_S1_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    Object val = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * First data source succeeded, with multiple intermediate results.
-   */
-  @Test
-  public void testLifecycle_I1_I1_S1_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    Object val1 = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    Object val2 = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
-
-    Object val = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * First data source failed with intermediate results, second succeeded with intermediate results.
-   */
-  @Test
-  public void testLifecycle_I1_F1_I2_S2_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    Object val1 = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, FAILED, mock(Throwable.class));
-    subscriber1.onFailure(mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    // I2 gets ignored because we already have I1
-    Object val2 = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    Object val = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    mInOrder.verify(mSrc1).close();
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc2);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * First data source failed with intermediate results, second had intermediate results but closed.
-   */
-  @Test
-  public void testLifecycle_I1_F1_I2_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    Object val1 = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, FAILED, mock(Throwable.class));
-    subscriber1.onFailure(mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    // I2 gets ignored because we already have I1
-    Object val2 = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1, mSrc2);
-    verifySubscriber(dataSource, null, ON_CANCELLATION);
-    verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Early close with no results.
-   */
-  @Test
-  public void testLifecycle_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    testClose(dataSource, mSrc1);
-    verifySubscriber(dataSource, null, ON_CANCELLATION);
-    verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Ignore callbacks after closed.
-   */
-  @Test
-  public void testLifecycle_I1_C_S1() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    Object val1 = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifySubscriber(dataSource, null, ON_CANCELLATION);
-    verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    Object val = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, NO_INTERACTIONS);
-    verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Test data source without result
-   */
-  @Test
-  public void testLifecycle_WithoutResult_NI1_NS1_I2_S2_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
-
-    // I1 gets ignored because there is no result
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, NO_INTERACTIONS);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    // S1 gets ignored because there is no result
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    mInOrder.verify(mSrc1).close();
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    Object val2a = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-
-    Object val2b = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc2);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
+    @Before
+    public void setUp() {
+        super.setUp();
+        mDataSourceSupplier = FirstAvailableDataSourceSupplier.create(mSuppliers);
+    }
+
+    /**
+     * All data sources failed, no intermediate results.
+     */
+    @Test
+    public void testLifecycle_F1_F2_F3_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
+        subscriber1.onFailure(mSrc1);
+        mInOrder.verify(mSrc1).close();
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
+        subscriber2.onFailure(mSrc2);
+        mInOrder.verify(mSrc2).close();
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        Throwable throwable = mock(Throwable.class);
+        setState(mSrc3, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+        subscriber3.onFailure(mSrc3);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc3, ON_FAILURE);
+        verifyState(dataSource, null, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+
+        testClose(dataSource);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+    }
+
+    /**
+     * All data sources failed, second data source produced multiple intermediate results.
+     */
+    @Test
+    public void testLifecycle_F1_I2_I2_F2_F3_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
+        subscriber1.onFailure(mSrc1);
+        mInOrder.verify(mSrc1).close();
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        Object val2a = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+
+        Object val2b = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, FAILED, mock(Throwable.class));
+        subscriber2.onFailure(mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+
+        Throwable throwable = mock(Throwable.class);
+        setState(mSrc3, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+        subscriber3.onFailure(mSrc3);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc3, ON_FAILURE);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, FAILED, throwable);
+
+        testClose(dataSource, mSrc2);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+    }
+
+    /**
+     * All data sources failed, first two data sources produced intermediate results. Only first kept.
+     */
+    @Test
+    public void testLifecycle_I1_F1_I2_F2_F3_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        Object val1 = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, FAILED, mock(Throwable.class));
+        subscriber1.onFailure(mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        // I2 gets ignored because we already have I1
+        Object val2 = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2, FAILED, mock(Throwable.class));
+        subscriber2.onFailure(mSrc2);
+        mInOrder.verify(mSrc2).close();
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        Throwable throwable = mock(Throwable.class);
+        setState(mSrc3, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+        subscriber3.onFailure(mSrc3);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc3, ON_FAILURE);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, FAILED, throwable);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+    }
+
+    /**
+     * First data source failed, second succeeded, no intermediate results.
+     */
+    @Test
+    public void testLifecycle_F1_S2_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
+        subscriber1.onFailure(mSrc1);
+        mInOrder.verify(mSrc1).close();
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        Object val = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc2);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * First data source succeeded, no intermediate results.
+     */
+    @Test
+    public void testLifecycle_S1_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        Object val = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * First data source succeeded, with multiple intermediate results.
+     */
+    @Test
+    public void testLifecycle_I1_I1_S1_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        Object val1 = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        Object val2 = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
+
+        Object val = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * First data source failed with intermediate results, second succeeded with intermediate results.
+     */
+    @Test
+    public void testLifecycle_I1_F1_I2_S2_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        Object val1 = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, FAILED, mock(Throwable.class));
+        subscriber1.onFailure(mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        // I2 gets ignored because we already have I1
+        Object val2 = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        Object val = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        mInOrder.verify(mSrc1).close();
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc2);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * First data source failed with intermediate results, second had intermediate results but closed.
+     */
+    @Test
+    public void testLifecycle_I1_F1_I2_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        Object val1 = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, FAILED, mock(Throwable.class));
+        subscriber1.onFailure(mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        // I2 gets ignored because we already have I1
+        Object val2 = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1, mSrc2);
+        verifySubscriber(dataSource, null, ON_CANCELLATION);
+        verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Early close with no results.
+     */
+    @Test
+    public void testLifecycle_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        testClose(dataSource, mSrc1);
+        verifySubscriber(dataSource, null, ON_CANCELLATION);
+        verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Ignore callbacks after closed.
+     */
+    @Test
+    public void testLifecycle_I1_C_S1() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        Object val1 = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifySubscriber(dataSource, null, ON_CANCELLATION);
+        verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        Object val = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, NO_INTERACTIONS);
+        verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Test data source without result
+     */
+    @Test
+    public void testLifecycle_WithoutResult_NI1_NS1_I2_S2_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribe(mDataSourceSupplier1, mSrc1);
+
+        // I1 gets ignored because there is no result
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, NO_INTERACTIONS);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        // S1 gets ignored because there is no result
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        mInOrder.verify(mSrc1).close();
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribe(mDataSourceSupplier2, mSrc2);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        Object val2a = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+
+        Object val2b = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc2);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
 }
diff --git a/fbcore/src/test/java/com/facebook/datasource/IncreasingQualityDataSourceSupplierTest.java b/fbcore/src/test/java/com/facebook/datasource/IncreasingQualityDataSourceSupplierTest.java
index ea3ad717b..65031b709 100644
--- a/fbcore/src/test/java/com/facebook/datasource/IncreasingQualityDataSourceSupplierTest.java
+++ b/fbcore/src/test/java/com/facebook/datasource/IncreasingQualityDataSourceSupplierTest.java
@@ -24,469 +24,469 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class IncreasingQualityDataSourceSupplierTest extends AbstractDataSourceSupplier {
 
-  @Before
-  public void setUp() {
-    super.setUp();
-    mDataSourceSupplier = IncreasingQualityDataSourceSupplier.create(mSuppliers);
-  }
-
-  /**
-   * All data sources failed, highest-quality failed last, no intermediate results.
-   */
-  @Test
-  public void testLifecycle_F2_F3_F1_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
-    subscriber2.onFailure(mSrc2);
-    mInOrder.verify(mSrc2).close();
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    setState(mSrc3, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
-    subscriber3.onFailure(mSrc3);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc3, NO_INTERACTIONS);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    Throwable throwable = mock(Throwable.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-    subscriber1.onFailure(mSrc1);
-    mInOrder.verify(mSrc1).close();
-    verifySubscriber(dataSource, mSrc1, ON_FAILURE);
-    verifyState(dataSource, null, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-
-    testClose(dataSource);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-  }
-
-  /**
-   * Highest-quality data source failed second, result of the third data source is ignored.
-   */
-  @Test
-  public void testLifecycle_F2_F1_S3_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
-    subscriber2.onFailure(mSrc2);
-    mInOrder.verify(mSrc2).close();
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    Throwable throwable = mock(Throwable.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-    subscriber1.onFailure(mSrc1);
-    mInOrder.verify(mSrc1).close();
-    verifySubscriber(dataSource, mSrc1, ON_FAILURE);
-    verifyState(dataSource, null, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-
-    // gets ignored because DS1 failed
-    setState(mSrc3, NOT_CLOSED, FINISHED, WITH_RESULT, mock(Object.class), NOT_FAILED, null);
-    subscriber3.onFailure(mSrc3);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc3, NO_INTERACTIONS);
-    verifyState(dataSource, null, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-
-    testClose(dataSource);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-  }
-
-  /**
-   * Highest-quality data source failed, result of the third data source is ignored.
-   * Second data source produced intermediate result first, the result is preserved until closed.
-   */
-  @Test
-  public void testLifecycle_I2_F2_F1_S3_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    Object val2 = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
-
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2, FAILED, mock(Throwable.class));
-    subscriber2.onFailure(mSrc2);
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
-
-    Throwable throwable = mock(Throwable.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-    subscriber1.onFailure(mSrc1);
-    mInOrder.verify(mSrc1).close();
-    verifySubscriber(dataSource, mSrc1, ON_FAILURE);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2, FAILED, throwable);
-
-    // gets ignored because DS1 failed
-    // besides, this data source shouldn't have finished as it was supposed to be closed!
-    setState(mSrc3, NOT_CLOSED, FINISHED, WITH_RESULT, mock(Object.class), NOT_FAILED, null);
-    subscriber3.onFailure(mSrc3);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc3, NO_INTERACTIONS);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2, FAILED, throwable);
-
-    testClose(dataSource, mSrc2);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
-  }
-
-  /**
-   * Second data source produced multiple intermediate results first, intermediate result of
-   * highest-quality data source gets ignored afterwards. Second data source fails and first data
-   * source produced another intermediate result, but it gets ignored again. Finally, first data
-   * source produced its final result which is set.
-   */
-  @Test
-  public void testLifecycle_I2_I2_I1_F2_I1_S1_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    Object val2a = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-
-    Object val2b = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-
-    // gets ignored because DS2 was first to produce result
-    Object val1a = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1a, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, NO_INTERACTIONS);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, FAILED, mock(Throwable.class));
-    subscriber2.onFailure(mSrc2);
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-
-    // gets ignored because DS2 was first to produce result
-    Object val1b = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, NO_INTERACTIONS);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-
-    Object val1c = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1c, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    mInOrder.verify(mSrc2).close();
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1c, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Interleaved results.
-   */
-  @Test
-  public void testLifecycle_I3_I2_I3_S2_I1_S1_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    Object val3a = mock(Object.class);
-    setState(mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3a, NOT_FAILED, null);
-    subscriber3.onNewResult(mSrc3);
-    verifySubscriber(dataSource, mSrc3, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3a, NOT_FAILED, null);
-
-    // gets ignored because DS3 was first
-    Object val2a = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3a, NOT_FAILED, null);
-
-    Object val3b = mock(Object.class);
-    setState(mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3b, NOT_FAILED, null);
-    subscriber3.onNewResult(mSrc3);
-    verifySubscriber(dataSource, mSrc3, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3b, NOT_FAILED, null);
-
-    Object val2b = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-
-    // gets ignored because DS2 was first
-    Object val1a = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1a, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, NO_INTERACTIONS);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-
-    Object val1b = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    mInOrder.verify(mSrc2).close();
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Second data source produced its final result, followed by the first data source.
-   */
-  @Test
-  public void testLifecycle_S2_S1_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    Object val2 = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
-
-    Object val1 = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    mInOrder.verify(mSrc2).close();
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Highest-quality data source was first to produce result, other data sources got closed.
-   */
-  @Test
-  public void testLifecycle_I1_S1_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    Object val1a = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1a, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    mInOrder.verify(mSrc3).close();
-    mInOrder.verify(mSrc2).close();
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1a, NOT_FAILED, null);
-
-    Object val1b = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Highest-quality data source was first to produce result, other data sources got closed.
-   */
-  @Test
-  public void testLifecycle_S1_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    Object val1b = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    mInOrder.verify(mSrc3).close();
-    mInOrder.verify(mSrc2).close();
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Early close with intermediate result.
-   */
-  @Test
-  public void testLifecycle_I2_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    Object val2a = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1, mSrc2);
-    verifySubscriber(dataSource, null, ON_CANCELLATION);
-    verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Early close with no results.
-   */
-  @Test
-  public void testLifecycle_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    testClose(dataSource, mSrc1, mSrc2, mSrc3);
-    verifySubscriber(dataSource, null, ON_CANCELLATION);
-    verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Ignore callbacks after closed.
-   */
-  @Test
-  public void testLifecycle_I2_C_S1() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    Object val2a = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1, mSrc2);
-    verifySubscriber(dataSource, null, ON_CANCELLATION);
-    verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    Object val = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Test data source without result
-   */
-  @Test
-  public void testLifecycle_WithoutResult_NI2_NS2_I3_S3_S1_C() {
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-    DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
-
-    // I2 gets ignored because there is no result
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    // S2 gets ignored because there is no result
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    mInOrder.verify(mSrc2).close();
-    verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
-    verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-
-    Object val3a = mock(Object.class);
-    setState(mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3a, NOT_FAILED, null);
-    subscriber3.onNewResult(mSrc3);
-    verifySubscriber(dataSource, mSrc3, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3a, NOT_FAILED, null);
-
-    Object val3b = mock(Object.class);
-    setState(mSrc3, NOT_CLOSED, FINISHED, WITH_RESULT, val3b, NOT_FAILED, null);
-    subscriber3.onNewResult(mSrc3);
-    verifySubscriber(dataSource, mSrc3, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3b, NOT_FAILED, null);
-
-    Object val = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    mInOrder.verify(mSrc3).close();
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Immediate result of low-res data source followed by delayed result of the first data source.
-   */
-  @Test
-  public void testLifecycle_ImmediateLowRes() {
-    Object val2a = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-    respondOnSubscribe(mSrc2, ON_NEW_RESULT);
-
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-    DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
-
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
-
-    Object val2b = mock(Object.class);
-    setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-    subscriber2.onNewResult(mSrc2);
-    verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
-
-    Object val = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-    subscriber1.onNewResult(mSrc1);
-    mInOrder.verify(mSrc2).close();
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
-
-  /**
-   * Immediate finish of the first data source.
-   */
-  @Test
-  public void testLifecycle_ImmediateFinish() {
-    Object val = mock(Object.class);
-    setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-    respondOnSubscribe(mSrc1, ON_NEW_RESULT);
-
-    DataSource<Object> dataSource = getAndSubscribe();
-    DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
-
-    verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
-    verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
-
-    testClose(dataSource, mSrc1);
-    verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
-  }
+    @Before
+    public void setUp() {
+        super.setUp();
+        mDataSourceSupplier = IncreasingQualityDataSourceSupplier.create(mSuppliers);
+    }
+
+    /**
+     * All data sources failed, highest-quality failed last, no intermediate results.
+     */
+    @Test
+    public void testLifecycle_F2_F3_F1_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
+        subscriber2.onFailure(mSrc2);
+        mInOrder.verify(mSrc2).close();
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        setState(mSrc3, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
+        subscriber3.onFailure(mSrc3);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc3, NO_INTERACTIONS);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        Throwable throwable = mock(Throwable.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+        subscriber1.onFailure(mSrc1);
+        mInOrder.verify(mSrc1).close();
+        verifySubscriber(dataSource, mSrc1, ON_FAILURE);
+        verifyState(dataSource, null, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+
+        testClose(dataSource);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+    }
+
+    /**
+     * Highest-quality data source failed second, result of the third data source is ignored.
+     */
+    @Test
+    public void testLifecycle_F2_F1_S3_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, mock(Throwable.class));
+        subscriber2.onFailure(mSrc2);
+        mInOrder.verify(mSrc2).close();
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        Throwable throwable = mock(Throwable.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+        subscriber1.onFailure(mSrc1);
+        mInOrder.verify(mSrc1).close();
+        verifySubscriber(dataSource, mSrc1, ON_FAILURE);
+        verifyState(dataSource, null, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+
+        // gets ignored because DS1 failed
+        setState(mSrc3, NOT_CLOSED, FINISHED, WITH_RESULT, mock(Object.class), NOT_FAILED, null);
+        subscriber3.onFailure(mSrc3);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc3, NO_INTERACTIONS);
+        verifyState(dataSource, null, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+
+        testClose(dataSource);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+    }
+
+    /**
+     * Highest-quality data source failed, result of the third data source is ignored.
+     * Second data source produced intermediate result first, the result is preserved until closed.
+     */
+    @Test
+    public void testLifecycle_I2_F2_F1_S3_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        Object val2 = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
+
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2, FAILED, mock(Throwable.class));
+        subscriber2.onFailure(mSrc2);
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
+
+        Throwable throwable = mock(Throwable.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+        subscriber1.onFailure(mSrc1);
+        mInOrder.verify(mSrc1).close();
+        verifySubscriber(dataSource, mSrc1, ON_FAILURE);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2, FAILED, throwable);
+
+        // gets ignored because DS1 failed
+        // besides, this data source shouldn't have finished as it was supposed to be closed!
+        setState(mSrc3, NOT_CLOSED, FINISHED, WITH_RESULT, mock(Object.class), NOT_FAILED, null);
+        subscriber3.onFailure(mSrc3);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc3, NO_INTERACTIONS);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2, FAILED, throwable);
+
+        testClose(dataSource, mSrc2);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, FAILED, throwable);
+    }
+
+    /**
+     * Second data source produced multiple intermediate results first, intermediate result of
+     * highest-quality data source gets ignored afterwards. Second data source fails and first data
+     * source produced another intermediate result, but it gets ignored again. Finally, first data
+     * source produced its final result which is set.
+     */
+    @Test
+    public void testLifecycle_I2_I2_I1_F2_I1_S1_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        Object val2a = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+
+        Object val2b = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+
+        // gets ignored because DS2 was first to produce result
+        Object val1a = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1a, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, NO_INTERACTIONS);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, FAILED, mock(Throwable.class));
+        subscriber2.onFailure(mSrc2);
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+
+        // gets ignored because DS2 was first to produce result
+        Object val1b = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, NO_INTERACTIONS);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+
+        Object val1c = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1c, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        mInOrder.verify(mSrc2).close();
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1c, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Interleaved results.
+     */
+    @Test
+    public void testLifecycle_I3_I2_I3_S2_I1_S1_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        Object val3a = mock(Object.class);
+        setState(mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3a, NOT_FAILED, null);
+        subscriber3.onNewResult(mSrc3);
+        verifySubscriber(dataSource, mSrc3, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3a, NOT_FAILED, null);
+
+        // gets ignored because DS3 was first
+        Object val2a = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3a, NOT_FAILED, null);
+
+        Object val3b = mock(Object.class);
+        setState(mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3b, NOT_FAILED, null);
+        subscriber3.onNewResult(mSrc3);
+        verifySubscriber(dataSource, mSrc3, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3b, NOT_FAILED, null);
+
+        Object val2b = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+
+        // gets ignored because DS2 was first
+        Object val1a = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1a, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, NO_INTERACTIONS);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+
+        Object val1b = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        mInOrder.verify(mSrc2).close();
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Second data source produced its final result, followed by the first data source.
+     */
+    @Test
+    public void testLifecycle_S2_S1_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        Object val2 = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2, NOT_FAILED, null);
+
+        Object val1 = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        mInOrder.verify(mSrc2).close();
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Highest-quality data source was first to produce result, other data sources got closed.
+     */
+    @Test
+    public void testLifecycle_I1_S1_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        Object val1a = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1a, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        mInOrder.verify(mSrc3).close();
+        mInOrder.verify(mSrc2).close();
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val1a, NOT_FAILED, null);
+
+        Object val1b = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Highest-quality data source was first to produce result, other data sources got closed.
+     */
+    @Test
+    public void testLifecycle_S1_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        Object val1b = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        mInOrder.verify(mSrc3).close();
+        mInOrder.verify(mSrc2).close();
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val1b, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Early close with intermediate result.
+     */
+    @Test
+    public void testLifecycle_I2_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        Object val2a = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1, mSrc2);
+        verifySubscriber(dataSource, null, ON_CANCELLATION);
+        verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Early close with no results.
+     */
+    @Test
+    public void testLifecycle_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        testClose(dataSource, mSrc1, mSrc2, mSrc3);
+        verifySubscriber(dataSource, null, ON_CANCELLATION);
+        verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Ignore callbacks after closed.
+     */
+    @Test
+    public void testLifecycle_I2_C_S1() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        Object val2a = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1, mSrc2);
+        verifySubscriber(dataSource, null, ON_CANCELLATION);
+        verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        Object val = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, null, CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Test data source without result
+     */
+    @Test
+    public void testLifecycle_WithoutResult_NI2_NS2_I3_S3_S1_C() {
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+        DataSubscriber<Object> subscriber3 = verifyGetAndSubscribe(mDataSourceSupplier3, mSrc3);
+
+        // I2 gets ignored because there is no result
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        // S2 gets ignored because there is no result
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        mInOrder.verify(mSrc2).close();
+        verifySubscriber(dataSource, mSrc2, NO_INTERACTIONS);
+        verifyState(dataSource, null, NOT_CLOSED, NOT_FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+
+        Object val3a = mock(Object.class);
+        setState(mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3a, NOT_FAILED, null);
+        subscriber3.onNewResult(mSrc3);
+        verifySubscriber(dataSource, mSrc3, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3a, NOT_FAILED, null);
+
+        Object val3b = mock(Object.class);
+        setState(mSrc3, NOT_CLOSED, FINISHED, WITH_RESULT, val3b, NOT_FAILED, null);
+        subscriber3.onNewResult(mSrc3);
+        verifySubscriber(dataSource, mSrc3, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc3, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val3b, NOT_FAILED, null);
+
+        Object val = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        mInOrder.verify(mSrc3).close();
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Immediate result of low-res data source followed by delayed result of the first data source.
+     */
+    @Test
+    public void testLifecycle_ImmediateLowRes() {
+        Object val2a = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+        respondOnSubscribe(mSrc2, ON_NEW_RESULT);
+
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+        DataSubscriber<Object> subscriber2 = verifyGetAndSubscribeM(mDataSourceSupplier2, mSrc2);
+
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2a, NOT_FAILED, null);
+
+        Object val2b = mock(Object.class);
+        setState(mSrc2, NOT_CLOSED, FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+        subscriber2.onNewResult(mSrc2);
+        verifySubscriber(dataSource, mSrc2, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc2, NOT_CLOSED, NOT_FINISHED, WITH_RESULT, val2b, NOT_FAILED, null);
+
+        Object val = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+        subscriber1.onNewResult(mSrc1);
+        mInOrder.verify(mSrc2).close();
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
+
+    /**
+     * Immediate finish of the first data source.
+     */
+    @Test
+    public void testLifecycle_ImmediateFinish() {
+        Object val = mock(Object.class);
+        setState(mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+        respondOnSubscribe(mSrc1, ON_NEW_RESULT);
+
+        DataSource<Object> dataSource = getAndSubscribe();
+        DataSubscriber<Object> subscriber1 = verifyGetAndSubscribeM(mDataSourceSupplier1, mSrc1);
+
+        verifySubscriber(dataSource, mSrc1, ON_NEW_RESULT);
+        verifyState(dataSource, mSrc1, NOT_CLOSED, FINISHED, WITH_RESULT, val, NOT_FAILED, null);
+
+        testClose(dataSource, mSrc1);
+        verifyState(dataSource, null, CLOSED, FINISHED, WITHOUT_RESULT, null, NOT_FAILED, null);
+    }
 }
diff --git a/fbcore/src/test/java/org/mockito/configuration/MockitoConfiguration.java b/fbcore/src/test/java/org/mockito/configuration/MockitoConfiguration.java
index 20f4aa035..f4ddd8b01 100644
--- a/fbcore/src/test/java/org/mockito/configuration/MockitoConfiguration.java
+++ b/fbcore/src/test/java/org/mockito/configuration/MockitoConfiguration.java
@@ -11,16 +11,16 @@
 
 /**
  * Disables the Mockito cache to prevent Mockito & Robolectric bugs.
- *
+ * <p>
  * Mockito loads this with reflection, so this class might appear unused.
  */
 @SuppressWarnings("unused")
 public class MockitoConfiguration extends DefaultMockitoConfiguration {
 
-  /* (non-Javadoc)
-   * @see org.mockito.configuration.IMockitoConfiguration#enableClassCache()
-   */
-  public boolean enableClassCache() {
-    return false;
-  }
+    /* (non-Javadoc)
+     * @see org.mockito.configuration.IMockitoConfiguration#enableClassCache()
+     */
+    public boolean enableClassCache() {
+        return false;
+    }
 }
diff --git a/imagepipeline-backends/imagepipeline-okhttp/build.gradle b/imagepipeline-backends/imagepipeline-okhttp/build.gradle
index f2dd5ccfe..ec4331743 100644
--- a/imagepipeline-backends/imagepipeline-okhttp/build.gradle
+++ b/imagepipeline-backends/imagepipeline-okhttp/build.gradle
@@ -4,10 +4,10 @@ project.group = GROUP
 version = VERSION_NAME
 
 dependencies {
-  compile "com.squareup.okhttp:okhttp:${OKHTTP_VERSION}"
+    compile "com.squareup.okhttp:okhttp:${OKHTTP_VERSION}"
 
-  compile project(':fbcore')
-  compile project(':imagepipeline')
+    compile project(':fbcore')
+    compile project(':imagepipeline')
 }
 apply from: rootProject.file('release.gradle')
 
diff --git a/imagepipeline-backends/imagepipeline-okhttp/src/main/AndroidManifest.xml b/imagepipeline-backends/imagepipeline-okhttp/src/main/AndroidManifest.xml
index deac9927e..34a97baa8 100644
--- a/imagepipeline-backends/imagepipeline-okhttp/src/main/AndroidManifest.xml
+++ b/imagepipeline-backends/imagepipeline-okhttp/src/main/AndroidManifest.xml
@@ -1,11 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook.imagepipeline.backends.okhttp"
-    >
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.imagepipeline.backends.okhttp">
 
-  <uses-sdk
-      android:minSdkVersion="9"
-      android:targetSdkVersion="21"
-      />
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
 </manifest>
diff --git a/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpImagePipelineConfigFactory.java b/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpImagePipelineConfigFactory.java
index 262b10c3e..eea54fc5c 100644
--- a/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpImagePipelineConfigFactory.java
+++ b/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpImagePipelineConfigFactory.java
@@ -20,8 +20,8 @@
  */
 public class OkHttpImagePipelineConfigFactory {
 
-  public static ImagePipelineConfig.Builder newBuilder(Context context, OkHttpClient okHttpClient) {
-    return ImagePipelineConfig.newBuilder(context)
-        .setNetworkFetcher(new OkHttpNetworkFetcher(okHttpClient));
-  }
+    public static ImagePipelineConfig.Builder newBuilder(Context context, OkHttpClient okHttpClient) {
+        return ImagePipelineConfig.newBuilder(context)
+                .setNetworkFetcher(new OkHttpNetworkFetcher(okHttpClient));
+    }
 }
diff --git a/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpNetworkFetcher.java b/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpNetworkFetcher.java
index 7eb9c6707..26d9f920b 100644
--- a/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpNetworkFetcher.java
+++ b/imagepipeline-backends/imagepipeline-okhttp/src/main/java/com/facebook/imagepipeline/backends/okhttp/OkHttpNetworkFetcher.java
@@ -35,94 +35,95 @@
  */
 public class OkHttpNetworkFetcher extends BaseNetworkFetcher<FetchState> {
 
-  private static final String TAG = "OkHttpNetworkFetchProducer";
+    private static final String TAG = "OkHttpNetworkFetchProducer";
 
-  private final OkHttpClient mOkHttpClient;
+    private final OkHttpClient mOkHttpClient;
 
-  private Executor mCancellationExecutor;
+    private Executor mCancellationExecutor;
 
-  /**
-   * @param okHttpClient client to use
-   */
-  public OkHttpNetworkFetcher(OkHttpClient okHttpClient) {
-    mOkHttpClient = okHttpClient;
-    mCancellationExecutor = okHttpClient.getDispatcher().getExecutorService();
-  }
+    /**
+     * @param okHttpClient client to use
+     */
+    public OkHttpNetworkFetcher(OkHttpClient okHttpClient) {
+        mOkHttpClient = okHttpClient;
+        mCancellationExecutor = okHttpClient.getDispatcher().getExecutorService();
+    }
 
-  @Override
-  public FetchState createFetchState(
-      Consumer<CloseableReference<PooledByteBuffer>> consumer,
-      ProducerContext context) {
-    return new FetchState(consumer, context);
-  }
+    @Override
+    public FetchState createFetchState(
+            Consumer<CloseableReference<PooledByteBuffer>> consumer,
+            ProducerContext context) {
+        return new FetchState(consumer, context);
+    }
 
-  @Override
-  public void fetch(final FetchState requestState, final Callback callback) {
-    final Uri uri = requestState.getUri();
-    final Request request = new Request.Builder()
-        .cacheControl(new CacheControl.Builder().noStore().build())
-        .url(uri.toString())
-        .get()
-        .build();
-    final Call call = mOkHttpClient.newCall(request);
+    @Override
+    public void fetch(final FetchState requestState, final Callback callback) {
+        final Uri uri = requestState.getUri();
+        final Request request = new Request.Builder()
+                .cacheControl(new CacheControl.Builder().noStore().build())
+                .url(uri.toString())
+                .get()
+                .build();
+        final Call call = mOkHttpClient.newCall(request);
 
-    requestState.getContext().addCallbacks(
-        new BaseProducerContextCallbacks() {
-          @Override
-          public void onCancellationRequested() {
-            if (Looper.myLooper() != Looper.getMainLooper()) {
-              call.cancel();
-            } else {
-              mCancellationExecutor.execute(new Runnable() {
-                @Override public void run() {
-                  call.cancel();
-                }
-              });
-            }
-          }
-        });
+        requestState.getContext().addCallbacks(
+                new BaseProducerContextCallbacks() {
+                    @Override
+                    public void onCancellationRequested() {
+                        if (Looper.myLooper() != Looper.getMainLooper()) {
+                            call.cancel();
+                        } else {
+                            mCancellationExecutor.execute(new Runnable() {
+                                @Override
+                                public void run() {
+                                    call.cancel();
+                                }
+                            });
+                        }
+                    }
+                });
 
-    call.enqueue(
-        new com.squareup.okhttp.Callback() {
-          @Override
-          public void onResponse(Response response) {
-            final ResponseBody body = response.body();
-            try {
-              long contentLength = body.contentLength();
-              if (contentLength < 0) {
-                contentLength = 0;
-              }
-              callback.onResponse(body.byteStream(), (int) contentLength);
-            } catch (IOException ioe) {
-              handleException(call, ioe, callback);
-            } finally {
-              try {
-                body.close();
-              } catch (IOException ioe) {
-                FLog.w(TAG, "Exception when closing response body", ioe);
-              }
-            }
-          }
+        call.enqueue(
+                new com.squareup.okhttp.Callback() {
+                    @Override
+                    public void onResponse(Response response) {
+                        final ResponseBody body = response.body();
+                        try {
+                            long contentLength = body.contentLength();
+                            if (contentLength < 0) {
+                                contentLength = 0;
+                            }
+                            callback.onResponse(body.byteStream(), (int) contentLength);
+                        } catch (IOException ioe) {
+                            handleException(call, ioe, callback);
+                        } finally {
+                            try {
+                                body.close();
+                            } catch (IOException ioe) {
+                                FLog.w(TAG, "Exception when closing response body", ioe);
+                            }
+                        }
+                    }
 
-          @Override
-          public void onFailure(final Request request, final IOException e) {
-            handleException(call, e, callback);
-          }
-        });
-  }
+                    @Override
+                    public void onFailure(final Request request, final IOException e) {
+                        handleException(call, e, callback);
+                    }
+                });
+    }
 
-  /**
-   * Handles IOExceptions.
-   *
-   * <p> OkHttp notifies callers of cancellations via an IOException. If IOException is caught
-   * after request cancellation, then the exception is interpreted as successful cancellation
-   * and onCancellation is called. Otherwise onFailure is called.
-   */
-  private void handleException(final Call call, final IOException ioe, final Callback callback) {
-    if (call.isCanceled()) {
-      callback.onCancellation();
-    } else {
-      callback.onFailure(ioe);
+    /**
+     * Handles IOExceptions.
+     * <p>
+     * <p> OkHttp notifies callers of cancellations via an IOException. If IOException is caught
+     * after request cancellation, then the exception is interpreted as successful cancellation
+     * and onCancellation is called. Otherwise onFailure is called.
+     */
+    private void handleException(final Call call, final IOException ioe, final Callback callback) {
+        if (call.isCanceled()) {
+            callback.onCancellation();
+        } else {
+            callback.onFailure(ioe);
+        }
     }
-  }
 }
diff --git a/imagepipeline/build.gradle b/imagepipeline/build.gradle
index 60f3af9ac..2aff55553 100644
--- a/imagepipeline/build.gradle
+++ b/imagepipeline/build.gradle
@@ -31,7 +31,6 @@ apply from: rootProject.file('release.gradle')
 
 def generatedTestSources = "$buildDir/generated-src/test"
 
-
 // Gradle and Buck need different versions of the test runner.
 // For gradle, WithTestDefaultsRunner just is a direct sub-class of RobolectricTestRunner.
 task generateTestSources {
@@ -41,14 +40,14 @@ task generateTestSources {
         def generated = new File(generatedTestSources, "WithTestDefaultsRunner.java")
         generated.text =
                 "package com.facebook.testing.robolectric.v2;\n" +
-                "import org.robolectric.RobolectricTestRunner;\n" +
-                "import org.junit.runners.model.InitializationError;\n" +
-                "public class WithTestDefaultsRunner extends RobolectricTestRunner {\n" +
-                "  public WithTestDefaultsRunner(final Class<?> testClass) " +
+                        "import org.robolectric.RobolectricTestRunner;\n" +
+                        "import org.junit.runners.model.InitializationError;\n" +
+                        "public class WithTestDefaultsRunner extends RobolectricTestRunner {\n" +
+                        "  public WithTestDefaultsRunner(final Class<?> testClass) " +
                         "throws InitializationError {" +
-                "    super(testClass);" +
-                "  }" +
-                "}"
+                        "    super(testClass);" +
+                        "  }" +
+                        "}"
     }
 }
 
@@ -125,7 +124,7 @@ task copyGiflib(dependsOn: unpackGiflib, type: Copy) {
 task copyLibjpeg(dependsOn: unpackLibjpeg, type: Copy) {
     from "${unpackLibjpeg.destinationDir}/libjpeg-turbo-1.3.1"
     from 'src/main/jni/third-party/libjpeg-turbo-1.3.x'
-    include('**/*.c', '**/*.h','**/*.S', '**/*.asm', '**/*.inc', '*.mk')
+    include('**/*.c', '**/*.h', '**/*.S', '**/*.asm', '**/*.inc', '*.mk')
     into "${mergeDir}/libjpeg-turbo-1.3.x"
 }
 
@@ -181,23 +180,23 @@ def makeNdkTasks(String name, Object[] deps) {
         inputs.file("src/main/jni/$name")
         outputs.dir("$buildDir/$name")
         commandLine getNdkBuildFullPath(),
-            'NDK_PROJECT_PATH=null',
-            'NDK_APPLICATION_MK=../Application.mk',
-            'NDK_OUT=' + temporaryDir,
-            "NDK_LIBS_OUT=$buildDir/$name",
-            '-C', file("src/main/jni/$name").absolutePath,
-            '--jobs', '8'
+                'NDK_PROJECT_PATH=null',
+                'NDK_APPLICATION_MK=../Application.mk',
+                'NDK_OUT=' + temporaryDir,
+                "NDK_LIBS_OUT=$buildDir/$name",
+                '-C', file("src/main/jni/$name").absolutePath,
+                '--jobs', '8'
     }
 
     task "ndk_clean_$name"(type: Exec) {
         ignoreExitValue true
         commandLine getNdkBuildFullPath(),
-            'NDK_PROJECT_PATH=null',
-            'NDK_APPLICATION_MK=../Application.mk',
-            'NDK_OUT=' + temporaryDir,
-            "NDK_LIBS_OUT=$buildDir/$name",
-            '-C', file("src/main/jni/$name").absolutePath,
-            'clean'
+                'NDK_PROJECT_PATH=null',
+                'NDK_APPLICATION_MK=../Application.mk',
+                'NDK_OUT=' + temporaryDir,
+                "NDK_LIBS_OUT=$buildDir/$name",
+                '-C', file("src/main/jni/$name").absolutePath,
+                'clean'
     }
 
     tasks.withType(JavaCompile) {
@@ -209,11 +208,11 @@ def makeNdkTasks(String name, Object[] deps) {
 
 android {
     def ndkLibs = [
-        ['bitmaps', []],
-        ['gifimage', [copyGiflib]],
-        ['imagepipeline', [copyLibjpeg, copyLibpng, copyLibwebp]],
-        ['memchunk', []],
-        ['webpimage', [copyLibwebp]]]
+            ['bitmaps', []],
+            ['gifimage', [copyGiflib]],
+            ['imagepipeline', [copyLibjpeg, copyLibpng, copyLibwebp]],
+            ['memchunk', []],
+            ['webpimage', [copyLibwebp]]]
 
     buildToolsVersion "21.1.2"
     compileSdkVersion 21
diff --git a/imagepipeline/src/main/AndroidManifest.xml b/imagepipeline/src/main/AndroidManifest.xml
index 65e3e75e0..23a103eff 100644
--- a/imagepipeline/src/main/AndroidManifest.xml
+++ b/imagepipeline/src/main/AndroidManifest.xml
@@ -1,11 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook.imagepipeline"
-    >
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.facebook.imagepipeline">
 
-  <uses-sdk
-      android:minSdkVersion="9"
-      android:targetSdkVersion="21"
-      />
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
 </manifest>
diff --git a/imagepipeline/src/main/java/com/facebook/binaryresource/BinaryResource.java b/imagepipeline/src/main/java/com/facebook/binaryresource/BinaryResource.java
index 028a7d1f7..2bad6f30f 100644
--- a/imagepipeline/src/main/java/com/facebook/binaryresource/BinaryResource.java
+++ b/imagepipeline/src/main/java/com/facebook/binaryresource/BinaryResource.java
@@ -23,37 +23,37 @@
  */
 public interface BinaryResource {
 
-  /**
-   * Opens a new {@link InputStream} for reading from this source. This method should return a new,
-   * independent stream each time it is called.
-   *
-   * <p>The caller is responsible for ensuring that the returned stream is closed.
-   *
-   * @throws IOException if an I/O error occurs in the process of opening the stream
-   */
-  InputStream openStream() throws IOException;
+    /**
+     * Opens a new {@link InputStream} for reading from this source. This method should return a new,
+     * independent stream each time it is called.
+     * <p>
+     * <p>The caller is responsible for ensuring that the returned stream is closed.
+     *
+     * @throws IOException if an I/O error occurs in the process of opening the stream
+     */
+    InputStream openStream() throws IOException;
 
-  /**
-   * Reads the full contents of this byte source as a byte array.
-   *
-   * @throws IOException if an I/O error occurs in the process of reading from this source
-   */
-   byte[] read() throws IOException;
+    /**
+     * Reads the full contents of this byte source as a byte array.
+     *
+     * @throws IOException if an I/O error occurs in the process of reading from this source
+     */
+    byte[] read() throws IOException;
 
-  /**
-   * Returns the size of this source in bytes. This may be a heavyweight
-   * operation that will open a stream, read (or {@link InputStream#skip(long) skip}, if possible)
-   * to the end of the stream and return the total number of bytes that were read.
-   *
-   * <p>For some sources, such as a file, this method may use a more efficient implementation. Note
-   * that in such cases, it is <i>possible</i> that this method will return a different number of
-   * bytes than would be returned by reading all of the bytes (for example, some special files may
-   * return a size of 0 despite actually having content when read).
-   *
-   * <p>In either case, if this is a mutable source such as a file, the size it returns may not be
-   * the same number of bytes a subsequent read would return.
-   *
-   * @throws IOException if an I/O error occurs in the process of reading the size of this source
-   */
-  long size();
+    /**
+     * Returns the size of this source in bytes. This may be a heavyweight
+     * operation that will open a stream, read (or {@link InputStream#skip(long) skip}, if possible)
+     * to the end of the stream and return the total number of bytes that were read.
+     * <p>
+     * <p>For some sources, such as a file, this method may use a more efficient implementation. Note
+     * that in such cases, it is <i>possible</i> that this method will return a different number of
+     * bytes than would be returned by reading all of the bytes (for example, some special files may
+     * return a size of 0 despite actually having content when read).
+     * <p>
+     * <p>In either case, if this is a mutable source such as a file, the size it returns may not be
+     * the same number of bytes a subsequent read would return.
+     *
+     * @throws IOException if an I/O error occurs in the process of reading the size of this source
+     */
+    long size();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/binaryresource/ByteArrayBinaryResource.java b/imagepipeline/src/main/java/com/facebook/binaryresource/ByteArrayBinaryResource.java
index 351f36427..c562b6990 100644
--- a/imagepipeline/src/main/java/com/facebook/binaryresource/ByteArrayBinaryResource.java
+++ b/imagepipeline/src/main/java/com/facebook/binaryresource/ByteArrayBinaryResource.java
@@ -19,28 +19,29 @@
  * A trivial implementation of BinaryResource that wraps a byte array
  */
 public class ByteArrayBinaryResource implements BinaryResource {
-  private final byte[] mBytes;
-
-  public ByteArrayBinaryResource(byte[] bytes) {
-    mBytes = Preconditions.checkNotNull(bytes);
-  }
-
-  @Override
-  public long size() {
-    return mBytes.length;
-  }
-
-  @Override
-  public InputStream openStream() throws IOException {
-    return new ByteArrayInputStream(mBytes);
-  }
-
-  /**
-   * Get the underlying byte array
-   * @return the underlying byte array of this resource
-   */
-  @Override
-  public byte[] read() {
-    return mBytes;
-  }
+    private final byte[] mBytes;
+
+    public ByteArrayBinaryResource(byte[] bytes) {
+        mBytes = Preconditions.checkNotNull(bytes);
+    }
+
+    @Override
+    public long size() {
+        return mBytes.length;
+    }
+
+    @Override
+    public InputStream openStream() throws IOException {
+        return new ByteArrayInputStream(mBytes);
+    }
+
+    /**
+     * Get the underlying byte array
+     *
+     * @return the underlying byte array of this resource
+     */
+    @Override
+    public byte[] read() {
+        return mBytes;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/binaryresource/FileBinaryResource.java b/imagepipeline/src/main/java/com/facebook/binaryresource/FileBinaryResource.java
index 513384131..ddf3a8f39 100644
--- a/imagepipeline/src/main/java/com/facebook/binaryresource/FileBinaryResource.java
+++ b/imagepipeline/src/main/java/com/facebook/binaryresource/FileBinaryResource.java
@@ -21,50 +21,50 @@
  * Implementation of BinaryResource based on a real file. @see BinaryResource for more details.
  */
 public class FileBinaryResource implements BinaryResource {
-  private final File mFile;
+    private final File mFile;
 
-  private FileBinaryResource(File file) {
-    mFile = Preconditions.checkNotNull(file);
-  }
+    private FileBinaryResource(File file) {
+        mFile = Preconditions.checkNotNull(file);
+    }
 
-  public File getFile() {
-    return mFile;
-  }
+    public File getFile() {
+        return mFile;
+    }
 
-  @Override
-  public InputStream openStream() throws IOException {
-    return new FileInputStream(mFile);
-  }
+    @Override
+    public InputStream openStream() throws IOException {
+        return new FileInputStream(mFile);
+    }
 
-  @Override
-  public long size() {
-    return mFile.length(); // 0L if file doesn't exist
-  }
+    @Override
+    public long size() {
+        return mFile.length(); // 0L if file doesn't exist
+    }
 
-  @Override
-  public byte[] read() throws IOException {
-    return Files.toByteArray(mFile);
-  }
+    @Override
+    public byte[] read() throws IOException {
+        return Files.toByteArray(mFile);
+    }
 
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null || !(obj instanceof FileBinaryResource)) {
-      return false;
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == null || !(obj instanceof FileBinaryResource)) {
+            return false;
+        }
+        FileBinaryResource that = (FileBinaryResource) obj;
+        return mFile.equals(that.mFile);
     }
-    FileBinaryResource that = (FileBinaryResource)obj;
-    return mFile.equals(that.mFile);
-  }
 
-  @Override
-  public int hashCode() {
-    return mFile.hashCode();
-  }
+    @Override
+    public int hashCode() {
+        return mFile.hashCode();
+    }
 
-  /*
-   * Factory method to create a wrapping BinaryResource without explicitly taking care of null.
-   * If the supplied file is null, instead of BinaryResource, null is returned.
-   */
-  public static FileBinaryResource createOrNull(File file) {
-    return (file != null) ? new FileBinaryResource(file) : null;
-  }
+    /*
+     * Factory method to create a wrapping BinaryResource without explicitly taking care of null.
+     * If the supplied file is null, instead of BinaryResource, null is returned.
+     */
+    public static FileBinaryResource createOrNull(File file) {
+        return (file != null) ? new FileBinaryResource(file) : null;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/common/CacheErrorLogger.java b/imagepipeline/src/main/java/com/facebook/cache/common/CacheErrorLogger.java
index 0f1295310..f536354cf 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/common/CacheErrorLogger.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/common/CacheErrorLogger.java
@@ -16,42 +16,43 @@
  */
 public interface CacheErrorLogger {
 
-  /**
-   * A categorizaton of different cache and storage related errors.
-   */
-  public enum CacheErrorCategory {
-    READ_DECODE,
-    READ_FILE,
-    READ_FILE_NOT_FOUND,
-    READ_INVALID_ENTRY,
-
-    WRITE_ENCODE,
-    WRITE_CREATE_TEMPFILE,
-    WRITE_UPDATE_FILE_NOT_FOUND,
-    WRITE_RENAME_FILE_TEMPFILE_NOT_FOUND,
-    WRITE_RENAME_FILE_TEMPFILE_PARENT_NOT_FOUND,
-    WRITE_RENAME_FILE_OTHER,
-    WRITE_CREATE_DIR,
-    WRITE_CALLBACK_ERROR,
-    WRITE_INVALID_ENTRY,
-
-    DELETE_FILE,
-
-    EVICTION,
-    GENERIC_IO,
-    OTHER
-  }
-
-  /**
-   * Log an error of the specified category.
-   * @param category Error category
-   * @param clazz Class reporting the error
-   * @param message An optional error message
-   * @param throwable An optional exception
-   */
-  public void logError(
-      CacheErrorCategory category,
-      Class<?> clazz,
-      String message,
-      @Nullable Throwable throwable);
+    /**
+     * A categorizaton of different cache and storage related errors.
+     */
+    public enum CacheErrorCategory {
+        READ_DECODE,
+        READ_FILE,
+        READ_FILE_NOT_FOUND,
+        READ_INVALID_ENTRY,
+
+        WRITE_ENCODE,
+        WRITE_CREATE_TEMPFILE,
+        WRITE_UPDATE_FILE_NOT_FOUND,
+        WRITE_RENAME_FILE_TEMPFILE_NOT_FOUND,
+        WRITE_RENAME_FILE_TEMPFILE_PARENT_NOT_FOUND,
+        WRITE_RENAME_FILE_OTHER,
+        WRITE_CREATE_DIR,
+        WRITE_CALLBACK_ERROR,
+        WRITE_INVALID_ENTRY,
+
+        DELETE_FILE,
+
+        EVICTION,
+        GENERIC_IO,
+        OTHER
+    }
+
+    /**
+     * Log an error of the specified category.
+     *
+     * @param category  Error category
+     * @param clazz     Class reporting the error
+     * @param message   An optional error message
+     * @param throwable An optional exception
+     */
+    public void logError(
+            CacheErrorCategory category,
+            Class<?> clazz,
+            String message,
+            @Nullable Throwable throwable);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/common/CacheEventListener.java b/imagepipeline/src/main/java/com/facebook/cache/common/CacheEventListener.java
index 49bef4b34..d07856aad 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/common/CacheEventListener.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/common/CacheEventListener.java
@@ -14,22 +14,22 @@
  */
 public interface CacheEventListener {
 
-  void onHit();
+    void onHit();
 
-  void onMiss();
+    void onMiss();
 
-  void onWriteAttempt();
+    void onWriteAttempt();
 
-  void onReadException();
+    void onReadException();
 
-  void onWriteException();
+    void onWriteException();
 
-  void onEviction(EvictionReason evictionReason, int itemCount, long itemSize);
+    void onEviction(EvictionReason evictionReason, int itemCount, long itemSize);
 
-  enum EvictionReason {
-    CACHE_FULL,
-    CONTENT_STALE,
-    USER_FORCED,
-    CACHE_MANAGER_TRIMMED
-  }
+    enum EvictionReason {
+        CACHE_FULL,
+        CONTENT_STALE,
+        USER_FORCED,
+        CACHE_MANAGER_TRIMMED
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/common/CacheKey.java b/imagepipeline/src/main/java/com/facebook/cache/common/CacheKey.java
index 5398d511d..c5c05cc01 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/common/CacheKey.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/common/CacheKey.java
@@ -11,17 +11,23 @@
 
 /**
  * Strongly typed cache key to be used instead of {@link Object}.
- *
+ * <p>
  * <p> {@link #toString}, {@link #equals} and {@link #hashCode} methods must be implemented.
  */
 public interface CacheKey {
 
-  /** This is useful for instrumentation and debugging purposes. */
-  public String toString();
+    /**
+     * This is useful for instrumentation and debugging purposes.
+     */
+    public String toString();
 
-  /** This method must be implemented, otherwise the cache keys will be be compared by reference. */
-  public boolean equals(Object o);
+    /**
+     * This method must be implemented, otherwise the cache keys will be be compared by reference.
+     */
+    public boolean equals(Object o);
 
-  /** This method must be implemented with accordance to the {@link #equals} method. */
-  public int hashCode();
+    /**
+     * This method must be implemented with accordance to the {@link #equals} method.
+     */
+    public int hashCode();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/common/NoOpCacheErrorLogger.java b/imagepipeline/src/main/java/com/facebook/cache/common/NoOpCacheErrorLogger.java
index e9349c104..21bc4c62d 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/common/NoOpCacheErrorLogger.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/common/NoOpCacheErrorLogger.java
@@ -15,30 +15,31 @@
  * An implementation of {@link CacheErrorLogger} that doesn't do anything.
  */
 public class NoOpCacheErrorLogger implements CacheErrorLogger {
-  private static NoOpCacheErrorLogger sInstance = null;
+    private static NoOpCacheErrorLogger sInstance = null;
 
-  private NoOpCacheErrorLogger() {
-  }
+    private NoOpCacheErrorLogger() {
+    }
 
-  public static synchronized NoOpCacheErrorLogger getInstance() {
-    if (sInstance == null) {
-      sInstance = new NoOpCacheErrorLogger();
+    public static synchronized NoOpCacheErrorLogger getInstance() {
+        if (sInstance == null) {
+            sInstance = new NoOpCacheErrorLogger();
+        }
+        return sInstance;
     }
-    return sInstance;
-  }
 
-  /**
-   * Log an error of the specified category.
-   * @param category Error category
-   * @param clazz Class reporting the error
-   * @param message An optional error message
-   * @param throwable An optional exception
-   */
-  @Override
-  public void logError(
-      CacheErrorCategory category,
-      Class<?> clazz,
-      String message,
-      @Nullable Throwable throwable) {
-  }
+    /**
+     * Log an error of the specified category.
+     *
+     * @param category  Error category
+     * @param clazz     Class reporting the error
+     * @param message   An optional error message
+     * @param throwable An optional exception
+     */
+    @Override
+    public void logError(
+            CacheErrorCategory category,
+            Class<?> clazz,
+            String message,
+            @Nullable Throwable throwable) {
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/common/NoOpCacheEventListener.java b/imagepipeline/src/main/java/com/facebook/cache/common/NoOpCacheEventListener.java
index 51d9c7281..344a135b7 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/common/NoOpCacheEventListener.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/common/NoOpCacheEventListener.java
@@ -13,40 +13,40 @@
  * Implementation of {@link CacheEventListener} that doesn't do anything.
  */
 public class NoOpCacheEventListener implements CacheEventListener {
-  private static NoOpCacheEventListener sInstance = null;
+    private static NoOpCacheEventListener sInstance = null;
 
-  private NoOpCacheEventListener() {
-  }
+    private NoOpCacheEventListener() {
+    }
 
-  public static synchronized NoOpCacheEventListener getInstance() {
-    if (sInstance == null) {
-      sInstance = new NoOpCacheEventListener();
+    public static synchronized NoOpCacheEventListener getInstance() {
+        if (sInstance == null) {
+            sInstance = new NoOpCacheEventListener();
+        }
+        return sInstance;
     }
-    return sInstance;
-  }
 
-  @Override
-  public void onHit() {
+    @Override
+    public void onHit() {
 
-  }
+    }
 
-  @Override
-  public void onMiss() {
-  }
+    @Override
+    public void onMiss() {
+    }
 
-  @Override
-  public void onWriteAttempt() {
-  }
+    @Override
+    public void onWriteAttempt() {
+    }
 
-  @Override
-  public void onReadException() {
-  }
+    @Override
+    public void onReadException() {
+    }
 
-  @Override
-  public void onWriteException() {
-  }
+    @Override
+    public void onWriteException() {
+    }
 
-  @Override
-  public void onEviction(EvictionReason evictionReason, int itemCount, long itemSize) {
-  }
+    @Override
+    public void onEviction(EvictionReason evictionReason, int itemCount, long itemSize) {
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/common/SimpleCacheKey.java b/imagepipeline/src/main/java/com/facebook/cache/common/SimpleCacheKey.java
index 40fcadb63..8e50bc174 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/common/SimpleCacheKey.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/common/SimpleCacheKey.java
@@ -13,36 +13,36 @@
 
 /**
  * {@link CacheKey} implementation that is a simple wrapper around a {@link String} object.
- *
+ * <p>
  * <p>Users of CacheKey should construct it by providing a unique string that unambiguously
  * identifies the cached resource.
  */
 public class SimpleCacheKey implements CacheKey {
-  final String mKey;
-
-  public SimpleCacheKey(final String key) {
-    mKey = Preconditions.checkNotNull(key);
-  }
+    final String mKey;
 
-  @Override
-  public String toString() {
-    return mKey;
-  }
+    public SimpleCacheKey(final String key) {
+        mKey = Preconditions.checkNotNull(key);
+    }
 
-  @Override
-  public boolean equals(Object o) {
-    if (o == this) {
-      return true;
+    @Override
+    public String toString() {
+        return mKey;
     }
-    if (o instanceof SimpleCacheKey) {
-      final SimpleCacheKey otherKey = (SimpleCacheKey) o;
-      return mKey.equals(otherKey.mKey);
+
+    @Override
+    public boolean equals(Object o) {
+        if (o == this) {
+            return true;
+        }
+        if (o instanceof SimpleCacheKey) {
+            final SimpleCacheKey otherKey = (SimpleCacheKey) o;
+            return mKey.equals(otherKey.mKey);
+        }
+        return false;
     }
-    return false;
-  }
 
-  @Override
-  public int hashCode() {
-    return mKey.hashCode();
-  }
+    @Override
+    public int hashCode() {
+        return mKey.hashCode();
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/common/WriterCallback.java b/imagepipeline/src/main/java/com/facebook/cache/common/WriterCallback.java
index 5d673b273..b0fd839ed 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/common/WriterCallback.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/common/WriterCallback.java
@@ -13,8 +13,8 @@
 import java.io.OutputStream;
 
 /**
-* Callback that writes to an {@link OutputStream}.
-*/
+ * Callback that writes to an {@link OutputStream}.
+ */
 public interface WriterCallback {
-  void write(OutputStream os) throws IOException;
+    void write(OutputStream os) throws IOException;
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/common/WriterCallbacks.java b/imagepipeline/src/main/java/com/facebook/cache/common/WriterCallbacks.java
index 7edc3b74f..2af00be5a 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/common/WriterCallbacks.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/common/WriterCallbacks.java
@@ -20,36 +20,38 @@
  */
 public class WriterCallbacks {
 
-  /**
-   * Creates a writer callback that copies all the content read from an {@link InputStream} into
-   * the target stream.
-   *
-   * <p>This writer can be used only once.
-   * @param is the source
-   * @return the writer callback
-   */
-  public static WriterCallback from(final InputStream is) {
-   return new WriterCallback() {
-     @Override
-     public void write(OutputStream os) throws IOException {
-       ByteStreams.copy(is, os);
-     }
-   };
-  }
+    /**
+     * Creates a writer callback that copies all the content read from an {@link InputStream} into
+     * the target stream.
+     * <p>
+     * <p>This writer can be used only once.
+     *
+     * @param is the source
+     * @return the writer callback
+     */
+    public static WriterCallback from(final InputStream is) {
+        return new WriterCallback() {
+            @Override
+            public void write(OutputStream os) throws IOException {
+                ByteStreams.copy(is, os);
+            }
+        };
+    }
 
-  /**
-   * Creates a writer callback that writes some byte array to the target stream.
-   *
-   * <p>This writer can be used many times.
-   * @param data the bytes to write
-   * @return the writer callback
-   */
-  public static WriterCallback from(final byte[] data) {
-    return new WriterCallback() {
-      @Override
-      public void write(OutputStream os) throws IOException {
-        os.write(data);
-      }
-    };
-  }
+    /**
+     * Creates a writer callback that writes some byte array to the target stream.
+     * <p>
+     * <p>This writer can be used many times.
+     *
+     * @param data the bytes to write
+     * @return the writer callback
+     */
+    public static WriterCallback from(final byte[] data) {
+        return new WriterCallback() {
+            @Override
+            public void write(OutputStream os) throws IOException {
+                os.write(data);
+            }
+        };
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/disk/DefaultDiskStorage.java b/imagepipeline/src/main/java/com/facebook/cache/disk/DefaultDiskStorage.java
index 797fdb379..17f4c596b 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/disk/DefaultDiskStorage.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/disk/DefaultDiskStorage.java
@@ -38,616 +38,624 @@
  */
 public class DefaultDiskStorage implements DiskStorage {
 
-  private static final Class<?> TAG = DefaultDiskStorage.class;
-
-  private static final String CONTENT_FILE_EXTENSION = ".cnt";
-  private static final String TEMP_FILE_EXTENSION = ".tmp";
-
-  private static final String DEFAULT_DISK_STORAGE_VERSION_PREFIX = "v2";
-
-  /*
-   * We use sharding to avoid Samsung's RFS problem, and to avoid having one big directory
-   * containing thousands of files.
-   * This number of directories is large enough based on the following reasoning:
-   * - high usage: 150 photos per day
-   * - such usage will hit Samsung's 6,500 photos cap in 43 days
-   * - 100 buckets will extend that period to 4,300 days which is 11.78 years
-   */
-  private static final int SHARDING_BUCKET_COUNT = 100;
-
-  /**
-   * We will allow purging of any temp files older than this.
-   */
-  static final long TEMP_FILE_LIFETIME_MS = TimeUnit.MINUTES.toMillis(30);
-
-  /**
-   * The base directory used for the cache
-   */
-  private final File mRootDirectory;
-
-  /**
-   * All the sharding occurs inside a version-directory. That allows for easy version upgrade.
-   * When we find a base directory with no version-directory in it, it means that it's a different
-   * version and we should delete the whole directory (including itself) for both reasons:
-   * 1) clear all unusable files 2) avoid Samsung RFS problem that was hit with old implementations
-   * of DiskStorage which used a single directory for all the files.
-   */
-  private final File mVersionDirectory;
-
-  private final CacheErrorLogger mCacheErrorLogger;
-  private final Clock mClock;
-
-  /**
-   * Instantiates a ShardedDiskStorage that will use the directory to save a map between
-   * keys and files. The version is very important if clients change the format
-   * saved in those files. ShardedDiskStorage will assure that files saved with different
-   * version will be never used and eventually removed.
-   * @param rootDirectory root directory to create all content under
-   * @param version version of the format used in the files. If passed a different version
-*        files saved with the previous value will not be read and will be purged eventually.
-   * @param cacheErrorLogger logger for various events
-   */
-  public DefaultDiskStorage(
-      File rootDirectory,
-      int version,
-      CacheErrorLogger cacheErrorLogger) {
-    Preconditions.checkNotNull(rootDirectory);
-
-    mRootDirectory = rootDirectory;
-    // mVersionDirectory's name identifies:
-    // - the cache structure's version (sharded)
-    // - the content's version (version value)
-    // if structure changes, prefix will change... if content changes version will be different
-    // the ideal would be asking mSharding its name, but it's created receiving the directory
-    mVersionDirectory = new File(mRootDirectory, getVersionSubdirectoryName(version));
-    mCacheErrorLogger = cacheErrorLogger;
-    recreateDirectoryIfVersionChanges();
-    mClock = SystemClock.get();
-  }
-
-  @VisibleForTesting
-  static String getVersionSubdirectoryName(int version) {
-    return String.format(
-        (Locale) null,
-        "%s.ols%d.%d",
-        DEFAULT_DISK_STORAGE_VERSION_PREFIX,
-        SHARDING_BUCKET_COUNT,
-        version);
-  }
-
-  @Override
-  public boolean isEnabled() {
-    return true;
-  }
-
-  /**
-   * Checks if we have to recreate rootDirectory.
-   * This is needed because old versions of this storage created too much different files
-   * in the same dir, and Samsung's RFS has a bug that after the 13.000th creation fails.
-   * So if cache is not already in expected version let's destroy everything
-   * (if not in expected version... there's nothing to reuse here anyway).
-   */
-  private void recreateDirectoryIfVersionChanges() {
-    boolean recreateBase = false;
-    if (!mRootDirectory.exists()) {
-      recreateBase = true;
-    } else if (!mVersionDirectory.exists()) {
-      recreateBase = true;
-      FileTree.deleteRecursively(mRootDirectory);
-    }
+    private static final Class<?> TAG = DefaultDiskStorage.class;
 
-    if (recreateBase) {
-      try {
-        FileUtils.mkdirs(mVersionDirectory);
-      } catch (FileUtils.CreateDirectoryException e) {
-        // not the end of the world, when saving files we will try to create missing parent dirs
-        mCacheErrorLogger.logError(
-            CacheErrorLogger.CacheErrorCategory.WRITE_CREATE_DIR,
-            TAG,
-            "version directory could not be created: " + mVersionDirectory,
-            null);
-      }
-    }
-  }
-
-  @Override
-  public void updateResource(
-      final String resourceId,
-      final BinaryResource resource,
-      final WriterCallback callback,
-      final Object debugInfo)
-    throws IOException {
-    // Class-cast exception if this isn't the case
-    FileBinaryResource fileBinaryResource = (FileBinaryResource)resource;
-    File file = fileBinaryResource.getFile();
-    FileOutputStream fileStream = null;
-    try {
-      fileStream = new FileOutputStream(file);
-    } catch (FileNotFoundException fne) {
-      mCacheErrorLogger.logError(
-          CacheErrorLogger.CacheErrorCategory.WRITE_UPDATE_FILE_NOT_FOUND,
-          TAG,
-          "updateResource",
-          fne);
-      throw fne;
-    }
+    private static final String CONTENT_FILE_EXTENSION = ".cnt";
+    private static final String TEMP_FILE_EXTENSION = ".tmp";
 
-    long length = -1;
-    try {
-      CountingOutputStream countingStream = new CountingOutputStream(fileStream);
-      callback.write(countingStream);
-      // just in case underlying stream's close method doesn't flush:
-      // we flush it manually and inside the try/catch
-      countingStream.flush();
-      length = countingStream.getCount();
-    } finally {
-      // if it fails to close (or write the last piece) we really want to know
-      // Normally we would want this to be quiet because a closing exception would hide one
-      // inside the try/finally, but now we really want to know if something fails at flush or close
-      fileStream.close();
-    }
-    // this code should never throw, but if filesystem doesn't fail on a failing/uncomplete close
-    // we want to know and manually fail
-    if (file.length() != length) {
-      throw new IncompleteFileException(length, file.length());
-    }
-  }
+    private static final String DEFAULT_DISK_STORAGE_VERSION_PREFIX = "v2";
 
-  private static class IncompleteFileException extends IOException {
-    public final long expected;
-    public final long actual;
+    /*
+     * We use sharding to avoid Samsung's RFS problem, and to avoid having one big directory
+     * containing thousands of files.
+     * This number of directories is large enough based on the following reasoning:
+     * - high usage: 150 photos per day
+     * - such usage will hit Samsung's 6,500 photos cap in 43 days
+     * - 100 buckets will extend that period to 4,300 days which is 11.78 years
+     */
+    private static final int SHARDING_BUCKET_COUNT = 100;
 
-    public IncompleteFileException(long expected, long actual) {
-      super("File was not written completely. Expected: " + expected + ", found: " + actual);
-      this.expected = expected;
-      this.actual = actual;
-    }
-  }
-
-  /**
-   * Calculates which should be the CONTENT file for the given key
-   */
-  @VisibleForTesting
-  File getContentFileFor(String resourceId) {
-    FileInfo fileInfo = new FileInfo(FileType.CONTENT, resourceId);
-    File parent = getSubdirectory(fileInfo.resourceId);
-    return fileInfo.toFile(parent);
-  }
-
-  /**
-   * Gets the directory to use to store the given key
-   * @param resourceId the id of the file we're going to store
-   * @return the directory to store the file in
-   */
-  private File getSubdirectory(String resourceId) {
-    String subdirectory = String.valueOf(Math.abs(resourceId.hashCode() % SHARDING_BUCKET_COUNT));
-    return new File(mVersionDirectory, subdirectory);
-  }
-
-  /**
-   * Implementation of {@link FileTreeVisitor} to iterate over all the sharded files and
-   * collect those valid content files. It's used in entriesIterator method.
-   */
-  private class EntriesCollector implements FileTreeVisitor {
-
-    private final List<Entry> result = Lists.newArrayList();
+    /**
+     * We will allow purging of any temp files older than this.
+     */
+    static final long TEMP_FILE_LIFETIME_MS = TimeUnit.MINUTES.toMillis(30);
 
-    @Override
-    public void preVisitDirectory(File directory) {
-    }
+    /**
+     * The base directory used for the cache
+     */
+    private final File mRootDirectory;
 
-    @Override
-    public void visitFile(File file) {
-      FileInfo info = getShardFileInfo(file);
-      if (info != null && info.type == FileType.CONTENT) {
-        result.add(new EntryImpl(file));
-      }
+    /**
+     * All the sharding occurs inside a version-directory. That allows for easy version upgrade.
+     * When we find a base directory with no version-directory in it, it means that it's a different
+     * version and we should delete the whole directory (including itself) for both reasons:
+     * 1) clear all unusable files 2) avoid Samsung RFS problem that was hit with old implementations
+     * of DiskStorage which used a single directory for all the files.
+     */
+    private final File mVersionDirectory;
+
+    private final CacheErrorLogger mCacheErrorLogger;
+    private final Clock mClock;
+
+    /**
+     * Instantiates a ShardedDiskStorage that will use the directory to save a map between
+     * keys and files. The version is very important if clients change the format
+     * saved in those files. ShardedDiskStorage will assure that files saved with different
+     * version will be never used and eventually removed.
+     *
+     * @param rootDirectory    root directory to create all content under
+     * @param version          version of the format used in the files. If passed a different version
+     *                         files saved with the previous value will not be read and will be purged eventually.
+     * @param cacheErrorLogger logger for various events
+     */
+    public DefaultDiskStorage(
+            File rootDirectory,
+            int version,
+            CacheErrorLogger cacheErrorLogger) {
+        Preconditions.checkNotNull(rootDirectory);
+
+        mRootDirectory = rootDirectory;
+        // mVersionDirectory's name identifies:
+        // - the cache structure's version (sharded)
+        // - the content's version (version value)
+        // if structure changes, prefix will change... if content changes version will be different
+        // the ideal would be asking mSharding its name, but it's created receiving the directory
+        mVersionDirectory = new File(mRootDirectory, getVersionSubdirectoryName(version));
+        mCacheErrorLogger = cacheErrorLogger;
+        recreateDirectoryIfVersionChanges();
+        mClock = SystemClock.get();
+    }
+
+    @VisibleForTesting
+    static String getVersionSubdirectoryName(int version) {
+        return String.format(
+                (Locale) null,
+                "%s.ols%d.%d",
+                DEFAULT_DISK_STORAGE_VERSION_PREFIX,
+                SHARDING_BUCKET_COUNT,
+                version);
     }
 
     @Override
-    public void postVisitDirectory(File directory) {
+    public boolean isEnabled() {
+        return true;
     }
 
-    /** Returns an immutable list of the entries. */
-    public List<Entry> getEntries() {
-      return Collections.unmodifiableList(result);
+    /**
+     * Checks if we have to recreate rootDirectory.
+     * This is needed because old versions of this storage created too much different files
+     * in the same dir, and Samsung's RFS has a bug that after the 13.000th creation fails.
+     * So if cache is not already in expected version let's destroy everything
+     * (if not in expected version... there's nothing to reuse here anyway).
+     */
+    private void recreateDirectoryIfVersionChanges() {
+        boolean recreateBase = false;
+        if (!mRootDirectory.exists()) {
+            recreateBase = true;
+        } else if (!mVersionDirectory.exists()) {
+            recreateBase = true;
+            FileTree.deleteRecursively(mRootDirectory);
+        }
+
+        if (recreateBase) {
+            try {
+                FileUtils.mkdirs(mVersionDirectory);
+            } catch (FileUtils.CreateDirectoryException e) {
+                // not the end of the world, when saving files we will try to create missing parent dirs
+                mCacheErrorLogger.logError(
+                        CacheErrorLogger.CacheErrorCategory.WRITE_CREATE_DIR,
+                        TAG,
+                        "version directory could not be created: " + mVersionDirectory,
+                        null);
+            }
+        }
     }
-  }
-
-  /**
-   * This implements a  {@link FileTreeVisitor} to iterate over all the files in mDirectory
-   * and delete any unexpected file or directory. It also gets rid of any empty directory in
-   * the shard.
-   * As a shortcut it checks that things are inside (current) mVersionDirectory. If it's not
-   * then it's directly deleted. If it's inside then it checks if it's a recognized file and
-   * if it's in the correct shard according to its name (checkShard method). If it's unexpected
-   * file is deleted.
-   */
-  private class PurgingVisitor implements FileTreeVisitor {
-    private boolean insideBaseDirectory;
 
     @Override
-    public void preVisitDirectory(File directory) {
-      if (!insideBaseDirectory && directory.equals(mVersionDirectory)) {
-        // if we enter version-directory turn flag on
-        insideBaseDirectory = true;
-      }
+    public void updateResource(
+            final String resourceId,
+            final BinaryResource resource,
+            final WriterCallback callback,
+            final Object debugInfo)
+            throws IOException {
+        // Class-cast exception if this isn't the case
+        FileBinaryResource fileBinaryResource = (FileBinaryResource) resource;
+        File file = fileBinaryResource.getFile();
+        FileOutputStream fileStream = null;
+        try {
+            fileStream = new FileOutputStream(file);
+        } catch (FileNotFoundException fne) {
+            mCacheErrorLogger.logError(
+                    CacheErrorLogger.CacheErrorCategory.WRITE_UPDATE_FILE_NOT_FOUND,
+                    TAG,
+                    "updateResource",
+                    fne);
+            throw fne;
+        }
+
+        long length = -1;
+        try {
+            CountingOutputStream countingStream = new CountingOutputStream(fileStream);
+            callback.write(countingStream);
+            // just in case underlying stream's close method doesn't flush:
+            // we flush it manually and inside the try/catch
+            countingStream.flush();
+            length = countingStream.getCount();
+        } finally {
+            // if it fails to close (or write the last piece) we really want to know
+            // Normally we would want this to be quiet because a closing exception would hide one
+            // inside the try/finally, but now we really want to know if something fails at flush or close
+            fileStream.close();
+        }
+        // this code should never throw, but if filesystem doesn't fail on a failing/uncomplete close
+        // we want to know and manually fail
+        if (file.length() != length) {
+            throw new IncompleteFileException(length, file.length());
+        }
     }
 
-    @Override
-    public void visitFile(File file) {
-      if (!insideBaseDirectory || !isExpectedFile(file)) {
-        file.delete();
-      }
+    private static class IncompleteFileException extends IOException {
+        public final long expected;
+        public final long actual;
+
+        public IncompleteFileException(long expected, long actual) {
+            super("File was not written completely. Expected: " + expected + ", found: " + actual);
+            this.expected = expected;
+            this.actual = actual;
+        }
     }
 
-    @Override
-    public void postVisitDirectory(File directory) {
-      if (!mRootDirectory.equals(directory)) { // if it's root directory we must not touch it
-        if (!insideBaseDirectory) {
-          // if not in version-directory then it's unexpected!
-          directory.delete();
-        }
-      }
-      if (insideBaseDirectory && directory.equals(mVersionDirectory)) {
-        // if we just finished visiting version-directory turn flag off
-        insideBaseDirectory = false;
-      }
+    /**
+     * Calculates which should be the CONTENT file for the given key
+     */
+    @VisibleForTesting
+    File getContentFileFor(String resourceId) {
+        FileInfo fileInfo = new FileInfo(FileType.CONTENT, resourceId);
+        File parent = getSubdirectory(fileInfo.resourceId);
+        return fileInfo.toFile(parent);
     }
 
-    private boolean isExpectedFile(File file) {
-      FileInfo info = getShardFileInfo(file);
-      if (info == null) {
-        return false;
-      }
-      if (info.type == FileType.TEMP) {
-        return isRecentFile(file);
-      }
-      Preconditions.checkState(info.type == FileType.CONTENT);
-      return true;
+    /**
+     * Gets the directory to use to store the given key
+     *
+     * @param resourceId the id of the file we're going to store
+     * @return the directory to store the file in
+     */
+    private File getSubdirectory(String resourceId) {
+        String subdirectory = String.valueOf(Math.abs(resourceId.hashCode() % SHARDING_BUCKET_COUNT));
+        return new File(mVersionDirectory, subdirectory);
     }
 
     /**
-     * @return true if and only if the file is not old enough to be considered an old temp file
+     * Implementation of {@link FileTreeVisitor} to iterate over all the sharded files and
+     * collect those valid content files. It's used in entriesIterator method.
      */
-    private boolean isRecentFile(File file) {
-      return file.lastModified() > (mClock.now() - TEMP_FILE_LIFETIME_MS);
+    private class EntriesCollector implements FileTreeVisitor {
+
+        private final List<Entry> result = Lists.newArrayList();
+
+        @Override
+        public void preVisitDirectory(File directory) {
+        }
+
+        @Override
+        public void visitFile(File file) {
+            FileInfo info = getShardFileInfo(file);
+            if (info != null && info.type == FileType.CONTENT) {
+                result.add(new EntryImpl(file));
+            }
+        }
+
+        @Override
+        public void postVisitDirectory(File directory) {
+        }
+
+        /**
+         * Returns an immutable list of the entries.
+         */
+        public List<Entry> getEntries() {
+            return Collections.unmodifiableList(result);
+        }
     }
-  };
-
-  @Override
-  public void purgeUnexpectedResources() {
-    FileTree.walkFileTree(mRootDirectory, new PurgingVisitor());
-  }
-
-  /**
-   * Creates the directory (and its parents, if necessary).
-   * In case of an exception, log an error message with the relevant parameters
-   * @param directory the directory to create
-   * @param message message to use
-   * @throws IOException
-   */
-  private void mkdirs(File directory, String message) throws IOException {
-    try {
-      FileUtils.mkdirs(directory);
-    } catch (FileUtils.CreateDirectoryException cde) {
-      mCacheErrorLogger.logError(
-          CacheErrorLogger.CacheErrorCategory.WRITE_CREATE_DIR,
-          TAG,
-          message,
-          cde);
-      throw cde;
+
+    /**
+     * This implements a  {@link FileTreeVisitor} to iterate over all the files in mDirectory
+     * and delete any unexpected file or directory. It also gets rid of any empty directory in
+     * the shard.
+     * As a shortcut it checks that things are inside (current) mVersionDirectory. If it's not
+     * then it's directly deleted. If it's inside then it checks if it's a recognized file and
+     * if it's in the correct shard according to its name (checkShard method). If it's unexpected
+     * file is deleted.
+     */
+    private class PurgingVisitor implements FileTreeVisitor {
+        private boolean insideBaseDirectory;
+
+        @Override
+        public void preVisitDirectory(File directory) {
+            if (!insideBaseDirectory && directory.equals(mVersionDirectory)) {
+                // if we enter version-directory turn flag on
+                insideBaseDirectory = true;
+            }
+        }
+
+        @Override
+        public void visitFile(File file) {
+            if (!insideBaseDirectory || !isExpectedFile(file)) {
+                file.delete();
+            }
+        }
+
+        @Override
+        public void postVisitDirectory(File directory) {
+            if (!mRootDirectory.equals(directory)) { // if it's root directory we must not touch it
+                if (!insideBaseDirectory) {
+                    // if not in version-directory then it's unexpected!
+                    directory.delete();
+                }
+            }
+            if (insideBaseDirectory && directory.equals(mVersionDirectory)) {
+                // if we just finished visiting version-directory turn flag off
+                insideBaseDirectory = false;
+            }
+        }
+
+        private boolean isExpectedFile(File file) {
+            FileInfo info = getShardFileInfo(file);
+            if (info == null) {
+                return false;
+            }
+            if (info.type == FileType.TEMP) {
+                return isRecentFile(file);
+            }
+            Preconditions.checkState(info.type == FileType.CONTENT);
+            return true;
+        }
+
+        /**
+         * @return true if and only if the file is not old enough to be considered an old temp file
+         */
+        private boolean isRecentFile(File file) {
+            return file.lastModified() > (mClock.now() - TEMP_FILE_LIFETIME_MS);
+        }
     }
-  }
-
-  @Override
-  public FileBinaryResource createTemporary(
-      String resourceId,
-      Object debugInfo)
-      throws IOException {
-    // ensure that the parent directory exists
-    FileInfo info = new FileInfo(FileType.TEMP, resourceId);
-    File parent = getSubdirectory(info.resourceId);
-    if (!parent.exists()) {
-      mkdirs(parent, "createTemporary");
+
+    ;
+
+    @Override
+    public void purgeUnexpectedResources() {
+        FileTree.walkFileTree(mRootDirectory, new PurgingVisitor());
     }
 
-    try {
-      File file = info.createTempFile(parent);
-      return FileBinaryResource.createOrNull(file);
-    } catch (IOException ioe) {
-      mCacheErrorLogger.logError(
-          CacheErrorLogger.CacheErrorCategory.WRITE_CREATE_TEMPFILE,
-          TAG,
-          "createTemporary",
-          ioe);
-      throw ioe;
+    /**
+     * Creates the directory (and its parents, if necessary).
+     * In case of an exception, log an error message with the relevant parameters
+     *
+     * @param directory the directory to create
+     * @param message   message to use
+     * @throws IOException
+     */
+    private void mkdirs(File directory, String message) throws IOException {
+        try {
+            FileUtils.mkdirs(directory);
+        } catch (FileUtils.CreateDirectoryException cde) {
+            mCacheErrorLogger.logError(
+                    CacheErrorLogger.CacheErrorCategory.WRITE_CREATE_DIR,
+                    TAG,
+                    message,
+                    cde);
+            throw cde;
+        }
     }
-  }
-
-  @Override
-  public FileBinaryResource commit(String resourceId, BinaryResource temporary, Object debugInfo)
-      throws IOException {
-    // will cause a class-cast exception
-    FileBinaryResource tempFileResource = (FileBinaryResource) temporary;
-
-    File tempFile = tempFileResource.getFile();
-    File targetFile = getContentFileFor(resourceId);
-
-    try {
-      FileUtils.rename(tempFile, targetFile);
-    } catch (FileUtils.RenameException re) {
-      CacheErrorLogger.CacheErrorCategory category;
-      Throwable cause = re.getCause();
-      if (cause == null) {
-        category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_OTHER;
-      } else if (cause instanceof FileUtils.ParentDirNotFoundException) {
-        category =
-            CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_TEMPFILE_PARENT_NOT_FOUND;
-      } else if (cause instanceof FileNotFoundException) {
-        category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_TEMPFILE_NOT_FOUND;
-      } else {
-        category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_OTHER;
-      }
-      mCacheErrorLogger.logError(
-          category,
-          TAG,
-          "commit",
-          re);
-      throw re;
+
+    @Override
+    public FileBinaryResource createTemporary(
+            String resourceId,
+            Object debugInfo)
+            throws IOException {
+        // ensure that the parent directory exists
+        FileInfo info = new FileInfo(FileType.TEMP, resourceId);
+        File parent = getSubdirectory(info.resourceId);
+        if (!parent.exists()) {
+            mkdirs(parent, "createTemporary");
+        }
+
+        try {
+            File file = info.createTempFile(parent);
+            return FileBinaryResource.createOrNull(file);
+        } catch (IOException ioe) {
+            mCacheErrorLogger.logError(
+                    CacheErrorLogger.CacheErrorCategory.WRITE_CREATE_TEMPFILE,
+                    TAG,
+                    "createTemporary",
+                    ioe);
+            throw ioe;
+        }
     }
-    if (targetFile.exists()) {
-      targetFile.setLastModified(mClock.now());
+
+    @Override
+    public FileBinaryResource commit(String resourceId, BinaryResource temporary, Object debugInfo)
+            throws IOException {
+        // will cause a class-cast exception
+        FileBinaryResource tempFileResource = (FileBinaryResource) temporary;
+
+        File tempFile = tempFileResource.getFile();
+        File targetFile = getContentFileFor(resourceId);
+
+        try {
+            FileUtils.rename(tempFile, targetFile);
+        } catch (FileUtils.RenameException re) {
+            CacheErrorLogger.CacheErrorCategory category;
+            Throwable cause = re.getCause();
+            if (cause == null) {
+                category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_OTHER;
+            } else if (cause instanceof FileUtils.ParentDirNotFoundException) {
+                category =
+                        CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_TEMPFILE_PARENT_NOT_FOUND;
+            } else if (cause instanceof FileNotFoundException) {
+                category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_TEMPFILE_NOT_FOUND;
+            } else {
+                category = CacheErrorLogger.CacheErrorCategory.WRITE_RENAME_FILE_OTHER;
+            }
+            mCacheErrorLogger.logError(
+                    category,
+                    TAG,
+                    "commit",
+                    re);
+            throw re;
+        }
+        if (targetFile.exists()) {
+            targetFile.setLastModified(mClock.now());
+        }
+        return FileBinaryResource.createOrNull(targetFile);
     }
-    return FileBinaryResource.createOrNull(targetFile);
-  }
-
-  @Override
-  public FileBinaryResource getResource(String resourceId, Object debugInfo) {
-    final File file = getContentFileFor(resourceId);
-    if (file.exists()) {
-      file.setLastModified(mClock.now());
-      return FileBinaryResource.createOrNull(file);
+
+    @Override
+    public FileBinaryResource getResource(String resourceId, Object debugInfo) {
+        final File file = getContentFileFor(resourceId);
+        if (file.exists()) {
+            file.setLastModified(mClock.now());
+            return FileBinaryResource.createOrNull(file);
+        }
+        return null;
     }
-    return null;
-  }
-
-  @Override
-  public boolean contains(String resourceId, Object debugInfo) {
-    return query(resourceId, false);
-  }
-
-  @Override
-  public boolean touch(String resourceId, Object debugInfo) {
-    return query(resourceId, true);
-  }
-
-  private boolean query(String resourceId, boolean touch) {
-    File contentFile = getContentFileFor(resourceId);
-    boolean exists = contentFile.exists();
-    if (touch && exists) {
-      contentFile.setLastModified(mClock.now());
+
+    @Override
+    public boolean contains(String resourceId, Object debugInfo) {
+        return query(resourceId, false);
     }
-    return exists;
-  }
-
-  @Override
-  public long remove(Entry entry) {
-    // it should be one entry return by us :)
-    EntryImpl entryImpl = (EntryImpl) entry;
-    FileBinaryResource resource = entryImpl.getResource();
-    return doRemove(resource.getFile());
-  }
-
-  @Override
-  public long remove(final String resourceId) {
-    return doRemove(getContentFileFor(resourceId));
-  }
-
-  private long doRemove(final File contentFile) {
-    if (!contentFile.exists()) {
-      return 0;
+
+    @Override
+    public boolean touch(String resourceId, Object debugInfo) {
+        return query(resourceId, true);
     }
 
-    final long fileSize = contentFile.length();
-    if (contentFile.delete()) {
-      return fileSize;
+    private boolean query(String resourceId, boolean touch) {
+        File contentFile = getContentFileFor(resourceId);
+        boolean exists = contentFile.exists();
+        if (touch && exists) {
+            contentFile.setLastModified(mClock.now());
+        }
+        return exists;
     }
 
-    return -1;
-  }
-
-  public void clearAll() {
-    FileTree.deleteContents(mRootDirectory);
-  }
-
-  @Override
-  public DiskDumpInfo getDumpInfo() throws IOException {
-    List<Entry> entries = getEntries();
-
-    DiskDumpInfo dumpInfo = new DiskDumpInfo();
-    for (Entry entry : entries) {
-      DiskDumpInfoEntry infoEntry = dumpCacheEntry(entry);
-      String type = infoEntry.type;
-      if (!dumpInfo.typeCounts.containsKey(type)) {
-        dumpInfo.typeCounts.put(type, 0);
-      }
-      dumpInfo.typeCounts.put(type, dumpInfo.typeCounts.get(type)+1);
-      dumpInfo.entries.add(infoEntry);
+    @Override
+    public long remove(Entry entry) {
+        // it should be one entry return by us :)
+        EntryImpl entryImpl = (EntryImpl) entry;
+        FileBinaryResource resource = entryImpl.getResource();
+        return doRemove(resource.getFile());
     }
-    return dumpInfo;
-  }
-
-  private DiskDumpInfoEntry dumpCacheEntry(Entry entry) throws IOException {
-    EntryImpl entryImpl = (EntryImpl)entry;
-    String firstBits = "";
-    byte[] bytes = entryImpl.getResource().read();
-    String type = typeOfBytes(bytes);
-    if (type.equals("undefined") && bytes.length >= 4) {
-      firstBits = String.format(
-          (Locale) null, "0x%02X 0x%02X 0x%02X 0x%02X", bytes[0], bytes[1], bytes[2], bytes[3]);
+
+    @Override
+    public long remove(final String resourceId) {
+        return doRemove(getContentFileFor(resourceId));
     }
-    String path = entryImpl.getResource().getFile().getPath();
-    return new DiskDumpInfoEntry(path, type, entryImpl.getSize(), firstBits);
-  }
-
-  private String typeOfBytes(byte[] bytes) {
-    if (bytes.length >= 2) {
-      if (bytes[0] == (byte) 0xFF && bytes[1] == (byte) 0xD8) {
-        return "jpg";
-      } else if (bytes[0] == (byte) 0x89 && bytes[1] == (byte) 0x50) {
-        return "png";
-      } else if (bytes[0] == (byte) 0x52 && bytes[1] == (byte) 0x49) {
-        return "webp";
-      } else if (bytes[0] == (byte) 0x47 && bytes[1] == (byte) 0x49) {
-        return "gif";
-      }
+
+    private long doRemove(final File contentFile) {
+        if (!contentFile.exists()) {
+            return 0;
+        }
+
+        final long fileSize = contentFile.length();
+        if (contentFile.delete()) {
+            return fileSize;
+        }
+
+        return -1;
     }
-    return "undefined";
-  }
-
-  @Override
-  /**
-   * Returns a list of entries.
-   *
-   * <p>This list is immutable.
-   */
-  public List<Entry> getEntries() throws IOException {
-    EntriesCollector collector = new EntriesCollector();
-    FileTree.walkFileTree(mVersionDirectory, collector);
-    return collector.getEntries();
-  }
-
-  /**
-   * Implementation of Entry listed by entriesIterator.
-   */
-  @VisibleForTesting
-  class EntryImpl implements Entry {
-    private final FileBinaryResource resource;
-    private long size;
-    private long timestamp;
-
-    private EntryImpl(File cachedFile) {
-      Preconditions.checkNotNull(cachedFile);
-      this.resource = FileBinaryResource.createOrNull(cachedFile);
-      this.size = -1;
-      this.timestamp = -1;
+
+    public void clearAll() {
+        FileTree.deleteContents(mRootDirectory);
     }
 
     @Override
-    public long getTimestamp() {
-      if (timestamp < 0) {
-        final File cachedFile = resource.getFile();
-        timestamp = cachedFile.lastModified();
-      }
-      return timestamp;
+    public DiskDumpInfo getDumpInfo() throws IOException {
+        List<Entry> entries = getEntries();
+
+        DiskDumpInfo dumpInfo = new DiskDumpInfo();
+        for (Entry entry : entries) {
+            DiskDumpInfoEntry infoEntry = dumpCacheEntry(entry);
+            String type = infoEntry.type;
+            if (!dumpInfo.typeCounts.containsKey(type)) {
+                dumpInfo.typeCounts.put(type, 0);
+            }
+            dumpInfo.typeCounts.put(type, dumpInfo.typeCounts.get(type) + 1);
+            dumpInfo.entries.add(infoEntry);
+        }
+        return dumpInfo;
     }
 
-    @Override
-    public FileBinaryResource getResource() {
-      return resource;
+    private DiskDumpInfoEntry dumpCacheEntry(Entry entry) throws IOException {
+        EntryImpl entryImpl = (EntryImpl) entry;
+        String firstBits = "";
+        byte[] bytes = entryImpl.getResource().read();
+        String type = typeOfBytes(bytes);
+        if (type.equals("undefined") && bytes.length >= 4) {
+            firstBits = String.format(
+                    (Locale) null, "0x%02X 0x%02X 0x%02X 0x%02X", bytes[0], bytes[1], bytes[2], bytes[3]);
+        }
+        String path = entryImpl.getResource().getFile().getPath();
+        return new DiskDumpInfoEntry(path, type, entryImpl.getSize(), firstBits);
+    }
+
+    private String typeOfBytes(byte[] bytes) {
+        if (bytes.length >= 2) {
+            if (bytes[0] == (byte) 0xFF && bytes[1] == (byte) 0xD8) {
+                return "jpg";
+            } else if (bytes[0] == (byte) 0x89 && bytes[1] == (byte) 0x50) {
+                return "png";
+            } else if (bytes[0] == (byte) 0x52 && bytes[1] == (byte) 0x49) {
+                return "webp";
+            } else if (bytes[0] == (byte) 0x47 && bytes[1] == (byte) 0x49) {
+                return "gif";
+            }
+        }
+        return "undefined";
     }
 
     @Override
-    public long getSize() {
-      if (size < 0) {
-        size = resource.size();
-      }
-      return size;
-    }
-  }
-
-  /**
-   * Checks that the file is placed in the correct shard according to its
-   * filename (and hence the represented key). If it's correct its FileInfo is returned.
-   * @param file the file to check
-   * @return the corresponding FileInfo object if shard is correct, null otherwise
-   */
-  private FileInfo getShardFileInfo(File file) {
-    FileInfo info = FileInfo.fromFile(file);
-    if (info == null) {
-      return null; // file with incorrect name/extension
-    }
-    File expectedDirectory = getSubdirectory(info.resourceId);
-    boolean isCorrect = expectedDirectory.equals(file.getParentFile());
-    return isCorrect ? info : null;
-  }
-
-  /**
-   * Categories for the different internal files a ShardedDiskStorage maintains.
-   * CONTENT: the file that has the content
-   * TEMP: temporal files, used to write the content until they are switched to CONTENT files
-   */
-  private static enum FileType {
-    CONTENT(CONTENT_FILE_EXTENSION),
-    TEMP(TEMP_FILE_EXTENSION);
-
-    public final String extension;
-
-    FileType(String extension) {
-      this.extension = extension;
+    /**
+     * Returns a list of entries.
+     *
+     * <p>This list is immutable.
+     */
+    public List<Entry> getEntries() throws IOException {
+        EntriesCollector collector = new EntriesCollector();
+        FileTree.walkFileTree(mVersionDirectory, collector);
+        return collector.getEntries();
     }
 
-    public static FileType fromExtension(String extension) {
-      for (FileType ft: FileType.values()) {
-        if (ft.extension.equals(extension)) {
-          return ft;
+    /**
+     * Implementation of Entry listed by entriesIterator.
+     */
+    @VisibleForTesting
+    class EntryImpl implements Entry {
+        private final FileBinaryResource resource;
+        private long size;
+        private long timestamp;
+
+        private EntryImpl(File cachedFile) {
+            Preconditions.checkNotNull(cachedFile);
+            this.resource = FileBinaryResource.createOrNull(cachedFile);
+            this.size = -1;
+            this.timestamp = -1;
         }
-      }
-      return null;
-    }
-  }
 
-  /**
-   * Holds information about the different files this storage uses (content, tmp).
-   * All file name parsing should be done through here.
-   * Temp files creation is also handled here, to encapsulate naming.
-   */
-  private static class FileInfo {
+        @Override
+        public long getTimestamp() {
+            if (timestamp < 0) {
+                final File cachedFile = resource.getFile();
+                timestamp = cachedFile.lastModified();
+            }
+            return timestamp;
+        }
 
-    public final FileType type;
-    public final String resourceId;
+        @Override
+        public FileBinaryResource getResource() {
+            return resource;
+        }
 
-    private FileInfo(FileType type, String resourceId) {
-      this.type = type;
-      this.resourceId = resourceId;
+        @Override
+        public long getSize() {
+            if (size < 0) {
+                size = resource.size();
+            }
+            return size;
+        }
     }
 
-    @Override
-    public String toString() {
-      return type + "(" + resourceId + ")";
+    /**
+     * Checks that the file is placed in the correct shard according to its
+     * filename (and hence the represented key). If it's correct its FileInfo is returned.
+     *
+     * @param file the file to check
+     * @return the corresponding FileInfo object if shard is correct, null otherwise
+     */
+    private FileInfo getShardFileInfo(File file) {
+        FileInfo info = FileInfo.fromFile(file);
+        if (info == null) {
+            return null; // file with incorrect name/extension
+        }
+        File expectedDirectory = getSubdirectory(info.resourceId);
+        boolean isCorrect = expectedDirectory.equals(file.getParentFile());
+        return isCorrect ? info : null;
     }
 
-    public File toFile(File parentDir) {
-      return new File(parentDir, resourceId + type.extension);
-    }
+    /**
+     * Categories for the different internal files a ShardedDiskStorage maintains.
+     * CONTENT: the file that has the content
+     * TEMP: temporal files, used to write the content until they are switched to CONTENT files
+     */
+    private static enum FileType {
+        CONTENT(CONTENT_FILE_EXTENSION),
+        TEMP(TEMP_FILE_EXTENSION);
+
+        public final String extension;
 
-    public File createTempFile(File parent) throws IOException {
-      File f = File.createTempFile(resourceId + ".", TEMP_FILE_EXTENSION, parent);
-      return f;
+        FileType(String extension) {
+            this.extension = extension;
+        }
+
+        public static FileType fromExtension(String extension) {
+            for (FileType ft : FileType.values()) {
+                if (ft.extension.equals(extension)) {
+                    return ft;
+                }
+            }
+            return null;
+        }
     }
 
-    public static FileInfo fromFile(File file) {
-      String name = file.getName();
-      int pos = name.lastIndexOf('.');
-      if (pos <= 0) {
-        return null; // no name part
-      }
-      String ext = name.substring(pos);
-      FileType type = FileType.fromExtension(ext);
-      if (type == null) {
-        return null; // unknown!
-      }
-      String resourceId = name.substring(0, pos);
-      if (type.equals(FileType.TEMP)) {
-        int numPos = resourceId.lastIndexOf('.');
-        if (numPos <= 0) {
-          return null; // no resourceId.number
-        }
-        resourceId = resourceId.substring(0, numPos);
-      }
-
-      return new FileInfo(type, resourceId);
+    /**
+     * Holds information about the different files this storage uses (content, tmp).
+     * All file name parsing should be done through here.
+     * Temp files creation is also handled here, to encapsulate naming.
+     */
+    private static class FileInfo {
+
+        public final FileType type;
+        public final String resourceId;
+
+        private FileInfo(FileType type, String resourceId) {
+            this.type = type;
+            this.resourceId = resourceId;
+        }
+
+        @Override
+        public String toString() {
+            return type + "(" + resourceId + ")";
+        }
+
+        public File toFile(File parentDir) {
+            return new File(parentDir, resourceId + type.extension);
+        }
+
+        public File createTempFile(File parent) throws IOException {
+            File f = File.createTempFile(resourceId + ".", TEMP_FILE_EXTENSION, parent);
+            return f;
+        }
+
+        public static FileInfo fromFile(File file) {
+            String name = file.getName();
+            int pos = name.lastIndexOf('.');
+            if (pos <= 0) {
+                return null; // no name part
+            }
+            String ext = name.substring(pos);
+            FileType type = FileType.fromExtension(ext);
+            if (type == null) {
+                return null; // unknown!
+            }
+            String resourceId = name.substring(0, pos);
+            if (type.equals(FileType.TEMP)) {
+                int numPos = resourceId.lastIndexOf('.');
+                if (numPos <= 0) {
+                    return null; // no resourceId.number
+                }
+                resourceId = resourceId.substring(0, numPos);
+            }
+
+            return new FileInfo(type, resourceId);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/disk/DefaultDiskStorageSupplier.java b/imagepipeline/src/main/java/com/facebook/cache/disk/DefaultDiskStorageSupplier.java
index ddcc24e0c..fdc1129dd 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/disk/DefaultDiskStorageSupplier.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/disk/DefaultDiskStorageSupplier.java
@@ -26,92 +26,99 @@
  * A supplier of a DiskStorage concrete implementation.
  */
 public class DefaultDiskStorageSupplier implements DiskStorageSupplier {
-  private static final Class<?> TAG = DefaultDiskStorageSupplier.class;
+    private static final Class<?> TAG = DefaultDiskStorageSupplier.class;
 
-  private final int mVersion;
-  private final Supplier<File> mBaseDirectoryPathSupplier;
-  private final String mBaseDirectoryName;
-  private final CacheErrorLogger mCacheErrorLogger;
+    private final int mVersion;
+    private final Supplier<File> mBaseDirectoryPathSupplier;
+    private final String mBaseDirectoryName;
+    private final CacheErrorLogger mCacheErrorLogger;
 
-  @VisibleForTesting
-  volatile State mCurrentState;
+    @VisibleForTesting
+    volatile State mCurrentState;
 
-  /**
-   * Represents the current 'cached' state.
-   */
-  @VisibleForTesting static class State {
-    public final @Nullable DiskStorage storage;
-    public final @Nullable File rootDirectory;
+    /**
+     * Represents the current 'cached' state.
+     */
+    @VisibleForTesting
+    static class State {
+        public final
+        @Nullable
+        DiskStorage storage;
+        public final
+        @Nullable
+        File rootDirectory;
 
-    @VisibleForTesting State(@Nullable File rootDirectory, @Nullable DiskStorage storage) {
-      this.storage = storage;
-      this.rootDirectory = rootDirectory;
+        @VisibleForTesting
+        State(@Nullable File rootDirectory, @Nullable DiskStorage storage) {
+            this.storage = storage;
+            this.rootDirectory = rootDirectory;
+        }
     }
-  }
 
-  public DefaultDiskStorageSupplier(
-      int version,
-      Supplier<File> baseDirectoryPathSupplier,
-      String baseDirectoryName,
-      CacheErrorLogger cacheErrorLogger) {
-    mVersion = version;
-    mCacheErrorLogger = cacheErrorLogger;
-    mBaseDirectoryPathSupplier = baseDirectoryPathSupplier;
-    mBaseDirectoryName = baseDirectoryName;
-    mCurrentState = new State(null, null);
-  }
+    public DefaultDiskStorageSupplier(
+            int version,
+            Supplier<File> baseDirectoryPathSupplier,
+            String baseDirectoryName,
+            CacheErrorLogger cacheErrorLogger) {
+        mVersion = version;
+        mCacheErrorLogger = cacheErrorLogger;
+        mBaseDirectoryPathSupplier = baseDirectoryPathSupplier;
+        mBaseDirectoryName = baseDirectoryName;
+        mCurrentState = new State(null, null);
+    }
 
-  /**
-   * Gets a concrete disk-storage instance. If nothing has changed since the last call, then
-   * the last state is returned
-   * @return an instance of the appropriate DiskStorage class
-   * @throws IOException
-   */
-  @Override
-  public synchronized DiskStorage get() throws IOException {
-    if (shouldCreateNewStorage()) {
-      // discard anything we created
-      deleteOldStorageIfNecessary();
-      createStorage();
+    /**
+     * Gets a concrete disk-storage instance. If nothing has changed since the last call, then
+     * the last state is returned
+     *
+     * @return an instance of the appropriate DiskStorage class
+     * @throws IOException
+     */
+    @Override
+    public synchronized DiskStorage get() throws IOException {
+        if (shouldCreateNewStorage()) {
+            // discard anything we created
+            deleteOldStorageIfNecessary();
+            createStorage();
+        }
+        return Preconditions.checkNotNull(mCurrentState.storage);
     }
-    return Preconditions.checkNotNull(mCurrentState.storage);
-  }
 
-  private boolean shouldCreateNewStorage() {
-    State currentState = mCurrentState;
-    return (currentState.storage == null ||
-        currentState.rootDirectory == null ||
-        !currentState.rootDirectory.exists());
-  }
+    private boolean shouldCreateNewStorage() {
+        State currentState = mCurrentState;
+        return (currentState.storage == null ||
+                currentState.rootDirectory == null ||
+                !currentState.rootDirectory.exists());
+    }
 
-  @VisibleForTesting
-  void deleteOldStorageIfNecessary() {
-    if (mCurrentState.storage != null && mCurrentState.rootDirectory != null) {
-      // LATER: Actually delegate this call to the storage. We shouldn't be
-      // making an end-run around it
-      FileTree.deleteRecursively(mCurrentState.rootDirectory);
+    @VisibleForTesting
+    void deleteOldStorageIfNecessary() {
+        if (mCurrentState.storage != null && mCurrentState.rootDirectory != null) {
+            // LATER: Actually delegate this call to the storage. We shouldn't be
+            // making an end-run around it
+            FileTree.deleteRecursively(mCurrentState.rootDirectory);
+        }
     }
-  }
 
-  private void createStorage() throws IOException {
-    File rootDirectory = new File(mBaseDirectoryPathSupplier.get(), mBaseDirectoryName);
-    createRootDirectoryIfNecessary(rootDirectory);
-    DiskStorage storage = new DefaultDiskStorage(rootDirectory, mVersion, mCacheErrorLogger);
-    mCurrentState = new State(rootDirectory, storage);
-  }
+    private void createStorage() throws IOException {
+        File rootDirectory = new File(mBaseDirectoryPathSupplier.get(), mBaseDirectoryName);
+        createRootDirectoryIfNecessary(rootDirectory);
+        DiskStorage storage = new DefaultDiskStorage(rootDirectory, mVersion, mCacheErrorLogger);
+        mCurrentState = new State(rootDirectory, storage);
+    }
 
-  @VisibleForTesting
-  void createRootDirectoryIfNecessary(File rootDirectory) throws IOException {
-    try {
-      FileUtils.mkdirs(rootDirectory);
-    } catch (FileUtils.CreateDirectoryException cde) {
-      mCacheErrorLogger.logError(
-          CacheErrorLogger.CacheErrorCategory.WRITE_CREATE_DIR,
-          TAG,
-          "createRootDirectoryIfNecessary",
-          cde);
-      throw cde;
+    @VisibleForTesting
+    void createRootDirectoryIfNecessary(File rootDirectory) throws IOException {
+        try {
+            FileUtils.mkdirs(rootDirectory);
+        } catch (FileUtils.CreateDirectoryException cde) {
+            mCacheErrorLogger.logError(
+                    CacheErrorLogger.CacheErrorCategory.WRITE_CREATE_DIR,
+                    TAG,
+                    "createRootDirectoryIfNecessary",
+                    cde);
+            throw cde;
+        }
+        FLog.d(TAG, "Created cache directory %s", rootDirectory.getAbsolutePath());
     }
-    FLog.d(TAG, "Created cache directory %s", rootDirectory.getAbsolutePath());
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/disk/DiskCacheConfig.java b/imagepipeline/src/main/java/com/facebook/cache/disk/DiskCacheConfig.java
index fa8c9b627..87b975cd0 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/disk/DiskCacheConfig.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/disk/DiskCacheConfig.java
@@ -27,182 +27,182 @@
  */
 public class DiskCacheConfig {
 
-  private final int mVersion;
-  private final String mBaseDirectoryName;
-  private final Supplier<File> mBaseDirectoryPathSupplier;
-  private final long mDefaultSizeLimit;
-  private final long mLowDiskSpaceSizeLimit;
-  private final long mMinimumSizeLimit;
-  private final CacheErrorLogger mCacheErrorLogger;
-  private final CacheEventListener mCacheEventListener;
-  private final DiskTrimmableRegistry mDiskTrimmableRegistry;
-
-  private DiskCacheConfig(Builder builder) {
-    mVersion = builder.mVersion;
-    mBaseDirectoryName = Preconditions.checkNotNull(builder.mBaseDirectoryName);
-    mBaseDirectoryPathSupplier = Preconditions.checkNotNull(builder.mBaseDirectoryPathSupplier);
-    mDefaultSizeLimit = builder.mMaxCacheSize;
-    mLowDiskSpaceSizeLimit = builder.mMaxCacheSizeOnLowDiskSpace;
-    mMinimumSizeLimit = builder.mMaxCacheSizeOnVeryLowDiskSpace;
-    mCacheErrorLogger =
-        builder.mCacheErrorLogger == null ?
-            NoOpCacheErrorLogger.getInstance() :
-            builder.mCacheErrorLogger;
-    mCacheEventListener =
-        builder.mCacheEventListener == null ?
-            NoOpCacheEventListener.getInstance() :
-            builder.mCacheEventListener;
-    mDiskTrimmableRegistry =
-        builder.mDiskTrimmableRegistry == null ?
-            NoOpDiskTrimmableRegistry.getInstance() :
-            builder.mDiskTrimmableRegistry;
-  }
-
-  public int getVersion() {
-    return mVersion;
-  }
-
-  public String getBaseDirectoryName() {
-    return mBaseDirectoryName;
-  }
-
-  public Supplier<File> getBaseDirectoryPathSupplier() {
-    return mBaseDirectoryPathSupplier;
-  }
-
-  public long getDefaultSizeLimit() {
-    return mDefaultSizeLimit;
-  }
-
-  public long getLowDiskSpaceSizeLimit() {
-    return mLowDiskSpaceSizeLimit;
-  }
-
-  public long getMinimumSizeLimit() {
-    return mMinimumSizeLimit;
-  }
-
-  public CacheErrorLogger getCacheErrorLogger() {
-    return mCacheErrorLogger;
-  }
-
-  public CacheEventListener getCacheEventListener() {
-    return mCacheEventListener;
-  }
-
-  public DiskTrimmableRegistry getDiskTrimmableRegistry() {
-    return mDiskTrimmableRegistry;
-  }
-
-  public static Builder newBuilder() {
-    return new Builder();
-  }
-
-  public static class Builder {
-
-    public int mVersion = 1;
-    public String mBaseDirectoryName;
-    public Supplier<File> mBaseDirectoryPathSupplier;
-    public long mMaxCacheSize;
-    public long mMaxCacheSizeOnLowDiskSpace;
-    public long mMaxCacheSizeOnVeryLowDiskSpace;
-    public CacheErrorLogger mCacheErrorLogger;
-    public CacheEventListener mCacheEventListener;
-    public DiskTrimmableRegistry mDiskTrimmableRegistry;
-
-    private Builder() {
+    private final int mVersion;
+    private final String mBaseDirectoryName;
+    private final Supplier<File> mBaseDirectoryPathSupplier;
+    private final long mDefaultSizeLimit;
+    private final long mLowDiskSpaceSizeLimit;
+    private final long mMinimumSizeLimit;
+    private final CacheErrorLogger mCacheErrorLogger;
+    private final CacheEventListener mCacheEventListener;
+    private final DiskTrimmableRegistry mDiskTrimmableRegistry;
+
+    private DiskCacheConfig(Builder builder) {
+        mVersion = builder.mVersion;
+        mBaseDirectoryName = Preconditions.checkNotNull(builder.mBaseDirectoryName);
+        mBaseDirectoryPathSupplier = Preconditions.checkNotNull(builder.mBaseDirectoryPathSupplier);
+        mDefaultSizeLimit = builder.mMaxCacheSize;
+        mLowDiskSpaceSizeLimit = builder.mMaxCacheSizeOnLowDiskSpace;
+        mMinimumSizeLimit = builder.mMaxCacheSizeOnVeryLowDiskSpace;
+        mCacheErrorLogger =
+                builder.mCacheErrorLogger == null ?
+                        NoOpCacheErrorLogger.getInstance() :
+                        builder.mCacheErrorLogger;
+        mCacheEventListener =
+                builder.mCacheEventListener == null ?
+                        NoOpCacheEventListener.getInstance() :
+                        builder.mCacheEventListener;
+        mDiskTrimmableRegistry =
+                builder.mDiskTrimmableRegistry == null ?
+                        NoOpDiskTrimmableRegistry.getInstance() :
+                        builder.mDiskTrimmableRegistry;
     }
 
-    /**
-     * Sets the version.
-     *
-     * <p>The cache lives in a subdirectory identified by this version.
-     */
-    public Builder setVersion(int version) {
-      mVersion = version;
-      return this;
+    public int getVersion() {
+        return mVersion;
     }
 
-    /**
-     * Sets the name of the directory where the cache will be located.
-     */
-    public Builder setBaseDirectoryName(String baseDirectoryName) {
-      mBaseDirectoryName = baseDirectoryName;
-      return this;
+    public String getBaseDirectoryName() {
+        return mBaseDirectoryName;
     }
 
-    /**
-     * Sets the path to the base directory.
-     *
-     * <p>A directory with the given base directory name (see {@code setBaseDirectoryName}) will be
-     * appended to this path.
-     */
-    public Builder setBaseDirectoryPath(final File baseDirectoryPath) {
-      mBaseDirectoryPathSupplier = Suppliers.of(baseDirectoryPath);
-      return this;
+    public Supplier<File> getBaseDirectoryPathSupplier() {
+        return mBaseDirectoryPathSupplier;
     }
 
-    public Builder setBaseDirectoryPathSupplier(Supplier<File> baseDirectoryPathSupplier) {
-      mBaseDirectoryPathSupplier = baseDirectoryPathSupplier;
-      return this;
+    public long getDefaultSizeLimit() {
+        return mDefaultSizeLimit;
     }
 
-    /**
-     * This is the default maximum size of the cache.
-     */
-    public Builder setMaxCacheSize(long maxCacheSize) {
-      mMaxCacheSize = maxCacheSize;
-      return this;
+    public long getLowDiskSpaceSizeLimit() {
+        return mLowDiskSpaceSizeLimit;
     }
 
-    /**
-     * This is the maximum size of the cache that is used when the device is low on disk space.
-     *
-     * See {@link DiskTrimmable#trimToMinimum()}.
-     */
-    public Builder setMaxCacheSizeOnLowDiskSpace(long maxCacheSizeOnLowDiskSpace) {
-      mMaxCacheSizeOnLowDiskSpace = maxCacheSizeOnLowDiskSpace;
-      return this;
+    public long getMinimumSizeLimit() {
+        return mMinimumSizeLimit;
     }
 
-    /**
-     * This is the maximum size of the cache when the device is extremely low on disk space.
-     *
-     * See {@link DiskTrimmable#trimToNothing()}.
-     */
-    public Builder setMaxCacheSizeOnVeryLowDiskSpace(long maxCacheSizeOnVeryLowDiskSpace) {
-      mMaxCacheSizeOnVeryLowDiskSpace = maxCacheSizeOnVeryLowDiskSpace;
-      return this;
+    public CacheErrorLogger getCacheErrorLogger() {
+        return mCacheErrorLogger;
     }
 
-    /**
-     * The logger that is used to log errors made by the cache.
-     */
-    public Builder setCacheErrorLogger(CacheErrorLogger cacheErrorLogger) {
-      mCacheErrorLogger = cacheErrorLogger;
-      return this;
+    public CacheEventListener getCacheEventListener() {
+        return mCacheEventListener;
     }
 
-    /**
-     * The listener for cache events.
-     */
-    public Builder setCacheEventListener(CacheEventListener cacheEventListener) {
-      mCacheEventListener = cacheEventListener;
-      return this;
+    public DiskTrimmableRegistry getDiskTrimmableRegistry() {
+        return mDiskTrimmableRegistry;
     }
 
-    /**
-     * The class that will contain a registry of caches to be trimmed in low disk space conditions.
-     *
-     * <p>See {@link DiskTrimmableRegistry}.
-     */
-    public Builder setDiskTrimmableRegistry(DiskTrimmableRegistry diskTrimmableRegistry) {
-      mDiskTrimmableRegistry = diskTrimmableRegistry;
-      return this;
+    public static Builder newBuilder() {
+        return new Builder();
     }
 
-    public DiskCacheConfig build() {
-      return new DiskCacheConfig(this);
+    public static class Builder {
+
+        public int mVersion = 1;
+        public String mBaseDirectoryName;
+        public Supplier<File> mBaseDirectoryPathSupplier;
+        public long mMaxCacheSize;
+        public long mMaxCacheSizeOnLowDiskSpace;
+        public long mMaxCacheSizeOnVeryLowDiskSpace;
+        public CacheErrorLogger mCacheErrorLogger;
+        public CacheEventListener mCacheEventListener;
+        public DiskTrimmableRegistry mDiskTrimmableRegistry;
+
+        private Builder() {
+        }
+
+        /**
+         * Sets the version.
+         * <p>
+         * <p>The cache lives in a subdirectory identified by this version.
+         */
+        public Builder setVersion(int version) {
+            mVersion = version;
+            return this;
+        }
+
+        /**
+         * Sets the name of the directory where the cache will be located.
+         */
+        public Builder setBaseDirectoryName(String baseDirectoryName) {
+            mBaseDirectoryName = baseDirectoryName;
+            return this;
+        }
+
+        /**
+         * Sets the path to the base directory.
+         * <p>
+         * <p>A directory with the given base directory name (see {@code setBaseDirectoryName}) will be
+         * appended to this path.
+         */
+        public Builder setBaseDirectoryPath(final File baseDirectoryPath) {
+            mBaseDirectoryPathSupplier = Suppliers.of(baseDirectoryPath);
+            return this;
+        }
+
+        public Builder setBaseDirectoryPathSupplier(Supplier<File> baseDirectoryPathSupplier) {
+            mBaseDirectoryPathSupplier = baseDirectoryPathSupplier;
+            return this;
+        }
+
+        /**
+         * This is the default maximum size of the cache.
+         */
+        public Builder setMaxCacheSize(long maxCacheSize) {
+            mMaxCacheSize = maxCacheSize;
+            return this;
+        }
+
+        /**
+         * This is the maximum size of the cache that is used when the device is low on disk space.
+         * <p>
+         * See {@link DiskTrimmable#trimToMinimum()}.
+         */
+        public Builder setMaxCacheSizeOnLowDiskSpace(long maxCacheSizeOnLowDiskSpace) {
+            mMaxCacheSizeOnLowDiskSpace = maxCacheSizeOnLowDiskSpace;
+            return this;
+        }
+
+        /**
+         * This is the maximum size of the cache when the device is extremely low on disk space.
+         * <p>
+         * See {@link DiskTrimmable#trimToNothing()}.
+         */
+        public Builder setMaxCacheSizeOnVeryLowDiskSpace(long maxCacheSizeOnVeryLowDiskSpace) {
+            mMaxCacheSizeOnVeryLowDiskSpace = maxCacheSizeOnVeryLowDiskSpace;
+            return this;
+        }
+
+        /**
+         * The logger that is used to log errors made by the cache.
+         */
+        public Builder setCacheErrorLogger(CacheErrorLogger cacheErrorLogger) {
+            mCacheErrorLogger = cacheErrorLogger;
+            return this;
+        }
+
+        /**
+         * The listener for cache events.
+         */
+        public Builder setCacheEventListener(CacheEventListener cacheEventListener) {
+            mCacheEventListener = cacheEventListener;
+            return this;
+        }
+
+        /**
+         * The class that will contain a registry of caches to be trimmed in low disk space conditions.
+         * <p>
+         * <p>See {@link DiskTrimmableRegistry}.
+         */
+        public Builder setDiskTrimmableRegistry(DiskTrimmableRegistry diskTrimmableRegistry) {
+            mDiskTrimmableRegistry = diskTrimmableRegistry;
+            return this;
+        }
+
+        public DiskCacheConfig build() {
+            return new DiskCacheConfig(this);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/disk/DiskCacheFactory.java b/imagepipeline/src/main/java/com/facebook/cache/disk/DiskCacheFactory.java
index 463a0de62..3597e64ac 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/disk/DiskCacheFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/disk/DiskCacheFactory.java
@@ -14,28 +14,28 @@
  */
 public class DiskCacheFactory {
 
-  /**
-   * Creates a new {@link DiskStorageCache} from the given {@link DiskCacheConfig}
-   */
-  public static DiskStorageCache newDiskStorageCache(DiskCacheConfig diskCacheConfig) {
-    DiskStorageSupplier diskStorageSupplier = newDiskStorageSupplier(diskCacheConfig);
-    DiskStorageCache.Params params = new DiskStorageCache.Params(
-        diskCacheConfig.getMinimumSizeLimit(),
-        diskCacheConfig.getLowDiskSpaceSizeLimit(),
-        diskCacheConfig.getDefaultSizeLimit());
-    return new DiskStorageCache(
-        diskStorageSupplier,
-        params,
-        diskCacheConfig.getCacheEventListener(),
-        diskCacheConfig.getCacheErrorLogger(),
-        diskCacheConfig.getDiskTrimmableRegistry());
-  }
+    /**
+     * Creates a new {@link DiskStorageCache} from the given {@link DiskCacheConfig}
+     */
+    public static DiskStorageCache newDiskStorageCache(DiskCacheConfig diskCacheConfig) {
+        DiskStorageSupplier diskStorageSupplier = newDiskStorageSupplier(diskCacheConfig);
+        DiskStorageCache.Params params = new DiskStorageCache.Params(
+                diskCacheConfig.getMinimumSizeLimit(),
+                diskCacheConfig.getLowDiskSpaceSizeLimit(),
+                diskCacheConfig.getDefaultSizeLimit());
+        return new DiskStorageCache(
+                diskStorageSupplier,
+                params,
+                diskCacheConfig.getCacheEventListener(),
+                diskCacheConfig.getCacheErrorLogger(),
+                diskCacheConfig.getDiskTrimmableRegistry());
+    }
 
-  private static DiskStorageSupplier newDiskStorageSupplier(DiskCacheConfig diskCacheConfig) {
-    return new DefaultDiskStorageSupplier(
-        diskCacheConfig.getVersion(),
-        diskCacheConfig.getBaseDirectoryPathSupplier(),
-        diskCacheConfig.getBaseDirectoryName(),
-        diskCacheConfig.getCacheErrorLogger());
-  }
+    private static DiskStorageSupplier newDiskStorageSupplier(DiskCacheConfig diskCacheConfig) {
+        return new DefaultDiskStorageSupplier(
+                diskCacheConfig.getVersion(),
+                diskCacheConfig.getBaseDirectoryPathSupplier(),
+                diskCacheConfig.getBaseDirectoryName(),
+                diskCacheConfig.getCacheErrorLogger());
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorage.java b/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorage.java
index b94e7f4ce..6d24fc50a 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorage.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorage.java
@@ -25,147 +25,167 @@
  */
 public interface DiskStorage {
 
-  public static class DiskDumpInfoEntry {
-    public final String path;
-    public final String type;
-    public final float size;
-    public final String firstBits;
-    protected DiskDumpInfoEntry(String path, String type, float size, String firstBits) {
-      this.path = path;
-      this.type = type;
-      this.size = size;
-      this.firstBits = firstBits;
+    public static class DiskDumpInfoEntry {
+        public final String path;
+        public final String type;
+        public final float size;
+        public final String firstBits;
+
+        protected DiskDumpInfoEntry(String path, String type, float size, String firstBits) {
+            this.path = path;
+            this.type = type;
+            this.size = size;
+            this.firstBits = firstBits;
+        }
     }
-  }
-
-  public static class DiskDumpInfo {
-    public List<DiskDumpInfoEntry> entries;
-    public Map<String, Integer> typeCounts;
-    public DiskDumpInfo() {
-      entries = Lists.newArrayList();
-      typeCounts = Maps.newHashMap();
+
+    public static class DiskDumpInfo {
+        public List<DiskDumpInfoEntry> entries;
+        public Map<String, Integer> typeCounts;
+
+        public DiskDumpInfo() {
+            entries = Lists.newArrayList();
+            typeCounts = Maps.newHashMap();
+        }
+    }
+
+    /**
+     * is this storage enabled?
+     *
+     * @return true, if enabled
+     */
+    public boolean isEnabled();
+
+    /**
+     * Get the resource with the specified name
+     *
+     * @param resourceId id of the resource
+     * @param debugInfo  helper object for debugging
+     * @return the resource with the specified name. NULL if not found
+     * @throws IOException for unexpected behavior.
+     */
+    BinaryResource getResource(String resourceId, Object debugInfo) throws IOException;
+
+    /**
+     * Does a resource with this name exist?
+     *
+     * @param resourceId id of the resource
+     * @param debugInfo  helper object for debugging
+     * @return true, if the resource is present in the storage, false otherwise
+     * @throws IOException
+     */
+    boolean contains(String resourceId, Object debugInfo) throws IOException;
+
+    /**
+     * Does a resource with this name exist? If so, update the last-accessed time for the
+     * resource
+     *
+     * @param resourceId id of the resource
+     * @param debugInfo  helper object for debugging
+     * @return true, if the resource is present in the storage, false otherwise
+     * @throws IOException
+     */
+    boolean touch(String resourceId, Object debugInfo) throws IOException;
+
+    void purgeUnexpectedResources();
+
+    /**
+     * Creates a temporary resource for writing content. Split from commit()
+     * in order to allow concurrent writing of cache entries.
+     * This entry will not be available to cache clients until
+     * commit() is called passing in the resource returned
+     * from this method.
+     *
+     * @param resourceId id of the resource
+     * @param debugInfo  helper object for debugging
+     * @return the temporary resource created
+     * @throws IOException on errors during this operation
+     */
+    BinaryResource createTemporary(String resourceId, Object debugInfo) throws IOException;
+
+    /**
+     * Update the contents of the resource. Executes outside the session lock.
+     * The resource must exist. The writer callback will be provided with an
+     * OutputStream to write to. For high efficiency client should make sure that data
+     * is written in big chunks (for example by employing BufferedInputStream or writing all data
+     * at once).
+     *
+     * @param resourceId id of the resource
+     * @param resource   the existing resource (which will be overwritten)
+     * @param callback   the write callback
+     * @param debugInfo  helper object for debugging
+     * @throws IOException
+     */
+    public void updateResource(
+            String resourceId,
+            BinaryResource resource,
+            WriterCallback callback,
+            Object debugInfo)
+            throws IOException;
+
+    /**
+     * Commits the resource created by createTemporary() into the cache.
+     * Once this is called the entry will be available to clients of the cache.
+     *
+     * @param resourceId the id of the resource
+     * @param temporary  the temporary resource
+     * @param debugInfo  debug object for debugging
+     * @return the permanent resource created
+     * @throws IOException on errors during the commit
+     */
+    BinaryResource commit(
+            String resourceId,
+            BinaryResource temporary,
+            Object debugInfo)
+            throws IOException;
+
+    /**
+     * Get all entries currently in the storage
+     *
+     * @return a collection of entries in storage
+     * @throws IOException
+     */
+    Collection<Entry> getEntries() throws IOException;
+
+    /**
+     * Remove the resource represented by the entry
+     *
+     * @param entry entry of the resource to delete
+     * @return size of deleted file if successfully deleted, -1 otherwise
+     * @throws IOException
+     */
+    long remove(Entry entry) throws IOException;
+
+    /**
+     * Remove the resource with specified id
+     *
+     * @param resourceId
+     * @return size of deleted file if successfully deketed, -1 otherwise
+     * @throws IOException
+     */
+    long remove(String resourceId) throws IOException;
+
+    /**
+     * Clear all contents of the storage
+     *
+     * @throws IOException
+     * @throws IOException
+     */
+    void clearAll() throws IOException;
+
+    public DiskDumpInfo getDumpInfo() throws IOException;
+
+    public interface Entry {
+        /**
+         * calculated on first time and never changes so it can be used as immutable
+         **/
+        public long getTimestamp();
+
+        /**
+         * calculated on first time and never changes so it can be used as immutable
+         **/
+        public long getSize();
+
+        public BinaryResource getResource();
     }
-  }
-
-  /**
-   * is this storage enabled?
-   * @return true, if enabled
-   */
-  public boolean isEnabled();
-
-  /**
-   * Get the resource with the specified name
-   * @param resourceId id of the resource
-   * @param debugInfo helper object for debugging
-   * @return the resource with the specified name. NULL if not found
-   * @throws IOException for unexpected behavior.
-   */
-  BinaryResource getResource(String resourceId, Object debugInfo) throws IOException;
-
-  /**
-   * Does a resource with this name exist?
-   * @param resourceId id of the resource
-   * @param debugInfo helper object for debugging
-   * @return true, if the resource is present in the storage, false otherwise
-   * @throws IOException
-   */
-  boolean contains(String resourceId, Object debugInfo) throws IOException;
-
-  /**
-   * Does a resource with this name exist? If so, update the last-accessed time for the
-   * resource
-   * @param resourceId id of the resource
-   * @param debugInfo helper object for debugging
-   * @return true, if the resource is present in the storage, false otherwise
-   * @throws IOException
-   */
-  boolean touch(String resourceId, Object debugInfo) throws IOException;
-
-  void purgeUnexpectedResources();
-
-  /**
-   * Creates a temporary resource for writing content. Split from commit()
-   * in order to allow concurrent writing of cache entries.
-   * This entry will not be available to cache clients until
-   * commit() is called passing in the resource returned
-   * from this method.
-   * @param resourceId id of the resource
-   * @param debugInfo helper object for debugging
-   * @return the temporary resource created
-   * @exception IOException on errors during this operation
-   */
-  BinaryResource createTemporary(String resourceId, Object debugInfo) throws IOException;
-
-  /**
-   * Update the contents of the resource. Executes outside the session lock.
-   * The resource must exist. The writer callback will be provided with an
-   * OutputStream to write to. For high efficiency client should make sure that data
-   * is written in big chunks (for example by employing BufferedInputStream or writing all data
-   * at once).
-   * @param resourceId id of the resource
-   * @param resource the existing resource (which will be overwritten)
-   * @param callback the write callback
-   * @param debugInfo helper object for debugging
-   * @throws IOException
-   */
-  public void updateResource(
-      String resourceId,
-      BinaryResource resource,
-      WriterCallback callback,
-      Object debugInfo)
-      throws IOException;
-
-  /**
-   * Commits the resource created by createTemporary() into the cache.
-   * Once this is called the entry will be available to clients of the cache.
-   * @param resourceId the id of the resource
-   * @param temporary the temporary resource
-   * @param debugInfo debug object for debugging
-   * @return the permanent resource created
-   * @exception IOException on errors during the commit
-   */
-  BinaryResource commit(
-      String resourceId,
-      BinaryResource temporary,
-      Object debugInfo)
-      throws IOException;
-
-  /**
-   * Get all entries currently in the storage
-   * @return a collection of entries in storage
-   * @throws IOException
-   */
-  Collection<Entry> getEntries() throws IOException;
-
-  /**
-   * Remove the resource represented by the entry
-   * @param entry entry of the resource to delete
-   * @return size of deleted file if successfully deleted, -1 otherwise
-   * @throws IOException
-   */
-  long remove(Entry entry) throws IOException;
-
-  /**
-   * Remove the resource with specified id
-   * @param resourceId
-   * @return size of deleted file if successfully deketed, -1 otherwise
-   * @throws IOException
-   */
-  long remove(String resourceId) throws IOException;
-  /**
-   * Clear all contents of the storage
-   * @exception IOException
-   * @throws IOException
-   */
-  void clearAll() throws IOException;
-
-  public DiskDumpInfo getDumpInfo() throws IOException;
-
-  public interface Entry {
-    /** calculated on first time and never changes so it can be used as immutable **/
-    public long getTimestamp();
-    /** calculated on first time and never changes so it can be used as immutable **/
-    public long getSize();
-    public BinaryResource getResource();
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorageCache.java b/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorageCache.java
index ecf7ba723..320ec019e 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorageCache.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorageCache.java
@@ -45,589 +45,591 @@
 @ThreadSafe
 public class DiskStorageCache implements FileCache, DiskTrimmable {
 
-  private static final Class<?> TAG = DiskStorageCache.class;
+    private static final Class<?> TAG = DiskStorageCache.class;
 
-  // Any subclass that uses MediaCache/DiskCache's versioning system should use this
-  // constant as the very first entry in their list of versions.  When all
-  // subclasses of MediaCache have moved on to subsequent versions and are
-  // no longer using this constant, it can be removed.
-  public static final int START_OF_VERSIONING = 1;
-  private static final long FUTURE_TIMESTAMP_THRESHOLD_MS = TimeUnit.HOURS.toMillis(2);
-  // Force recalculation of the ground truth for filecache size at this interval
-  private static final long FILECACHE_SIZE_UPDATE_PERIOD_MS = TimeUnit.MINUTES.toMillis(30);
-  private static final double TRIMMING_LOWER_BOUND = 0.02;
-  private static final long UNINITIALIZED = -1;
+    // Any subclass that uses MediaCache/DiskCache's versioning system should use this
+    // constant as the very first entry in their list of versions.  When all
+    // subclasses of MediaCache have moved on to subsequent versions and are
+    // no longer using this constant, it can be removed.
+    public static final int START_OF_VERSIONING = 1;
+    private static final long FUTURE_TIMESTAMP_THRESHOLD_MS = TimeUnit.HOURS.toMillis(2);
+    // Force recalculation of the ground truth for filecache size at this interval
+    private static final long FILECACHE_SIZE_UPDATE_PERIOD_MS = TimeUnit.MINUTES.toMillis(30);
+    private static final double TRIMMING_LOWER_BOUND = 0.02;
+    private static final long UNINITIALIZED = -1;
 
-  private final long mLowDiskSpaceCacheSizeLimit;
-  private final long mDefaultCacheSizeLimit;
-  private long mCacheSizeLimit;
+    private final long mLowDiskSpaceCacheSizeLimit;
+    private final long mDefaultCacheSizeLimit;
+    private long mCacheSizeLimit;
 
-  private final CacheEventListener mCacheEventListener;
+    private final CacheEventListener mCacheEventListener;
 
-  @GuardedBy("mLock")
-  private long mCacheSizeLastUpdateTime;
+    @GuardedBy("mLock")
+    private long mCacheSizeLastUpdateTime;
 
-  private final long mCacheSizeLimitMinimum;
+    private final long mCacheSizeLimitMinimum;
 
-  private final StatFsHelper mStatFsHelper;
+    private final StatFsHelper mStatFsHelper;
 
-  private final DiskStorageSupplier mStorageSupplier;
-  private final CacheErrorLogger mCacheErrorLogger;
+    private final DiskStorageSupplier mStorageSupplier;
+    private final CacheErrorLogger mCacheErrorLogger;
 
-  private final CacheStats mCacheStats;
+    private final CacheStats mCacheStats;
 
-  private final Clock mClock;
+    private final Clock mClock;
 
-  // synchronization object.
-  private final Object mLock = new Object();
+    // synchronization object.
+    private final Object mLock = new Object();
 
-  /**
-   * Stats about the cache - currently size of the cache (in bytes) and number of items in
-   * the cache
-   */
-  @VisibleForTesting
-  static class CacheStats {
+    /**
+     * Stats about the cache - currently size of the cache (in bytes) and number of items in
+     * the cache
+     */
+    @VisibleForTesting
+    static class CacheStats {
 
-    private boolean mInitialized = false;
-    private long mSize = UNINITIALIZED;    // size of the cache (in bytes)
-    private long mCount = UNINITIALIZED;   // number of items in the cache
+        private boolean mInitialized = false;
+        private long mSize = UNINITIALIZED;    // size of the cache (in bytes)
+        private long mCount = UNINITIALIZED;   // number of items in the cache
 
-    public synchronized boolean isInitialized() {
-      return mInitialized;
-    }
+        public synchronized boolean isInitialized() {
+            return mInitialized;
+        }
 
-    public synchronized void reset() {
-      mInitialized = false;
-      mCount = UNINITIALIZED;
-      mSize = UNINITIALIZED;
-    }
+        public synchronized void reset() {
+            mInitialized = false;
+            mCount = UNINITIALIZED;
+            mSize = UNINITIALIZED;
+        }
 
-    public synchronized void set(long size, long count) {
-      mCount = count;
-      mSize = size;
-      mInitialized = true;
-    }
+        public synchronized void set(long size, long count) {
+            mCount = count;
+            mSize = size;
+            mInitialized = true;
+        }
 
-    public synchronized void increment(long sizeIncrement, long countIncrement) {
-      if (mInitialized) {
-        mSize += sizeIncrement;
-        mCount += countIncrement;
-      }
-    }
+        public synchronized void increment(long sizeIncrement, long countIncrement) {
+            if (mInitialized) {
+                mSize += sizeIncrement;
+                mCount += countIncrement;
+            }
+        }
 
-    public synchronized long getSize() {
-      return mSize;
-    }
+        public synchronized long getSize() {
+            return mSize;
+        }
 
-    public synchronized long getCount() {
-      return mCount;
+        public synchronized long getCount() {
+            return mCount;
+        }
     }
-  }
-
-  public static class Params {
-    public final long mCacheSizeLimitMinimum;
-    public final long mLowDiskSpaceCacheSizeLimit;
-    public final long mDefaultCacheSizeLimit;
-
-    public Params(
-        long cacheSizeLimitMinimum,
-        long lowDiskSpaceCacheSizeLimit,
-        long defaultCacheSizeLimit) {
-      mCacheSizeLimitMinimum = cacheSizeLimitMinimum;
-      mLowDiskSpaceCacheSizeLimit = lowDiskSpaceCacheSizeLimit;
-      mDefaultCacheSizeLimit = defaultCacheSizeLimit;
+
+    public static class Params {
+        public final long mCacheSizeLimitMinimum;
+        public final long mLowDiskSpaceCacheSizeLimit;
+        public final long mDefaultCacheSizeLimit;
+
+        public Params(
+                long cacheSizeLimitMinimum,
+                long lowDiskSpaceCacheSizeLimit,
+                long defaultCacheSizeLimit) {
+            mCacheSizeLimitMinimum = cacheSizeLimitMinimum;
+            mLowDiskSpaceCacheSizeLimit = lowDiskSpaceCacheSizeLimit;
+            mDefaultCacheSizeLimit = defaultCacheSizeLimit;
+        }
     }
-  }
 
-  public DiskStorageCache(
-      DiskStorageSupplier diskStorageSupplier,
-      Params params,
-      CacheEventListener cacheEventListener,
-      CacheErrorLogger cacheErrorLogger,
-      @Nullable DiskTrimmableRegistry diskTrimmableRegistry) {
-    this.mLowDiskSpaceCacheSizeLimit = params.mLowDiskSpaceCacheSizeLimit;
-    this.mDefaultCacheSizeLimit = params.mDefaultCacheSizeLimit;
-    this.mCacheSizeLimit = params.mDefaultCacheSizeLimit;
-    this.mStatFsHelper = StatFsHelper.getInstance();
+    public DiskStorageCache(
+            DiskStorageSupplier diskStorageSupplier,
+            Params params,
+            CacheEventListener cacheEventListener,
+            CacheErrorLogger cacheErrorLogger,
+            @Nullable DiskTrimmableRegistry diskTrimmableRegistry) {
+        this.mLowDiskSpaceCacheSizeLimit = params.mLowDiskSpaceCacheSizeLimit;
+        this.mDefaultCacheSizeLimit = params.mDefaultCacheSizeLimit;
+        this.mCacheSizeLimit = params.mDefaultCacheSizeLimit;
+        this.mStatFsHelper = StatFsHelper.getInstance();
 
-    this.mStorageSupplier = diskStorageSupplier;
+        this.mStorageSupplier = diskStorageSupplier;
 
-    this.mCacheSizeLastUpdateTime = UNINITIALIZED;
+        this.mCacheSizeLastUpdateTime = UNINITIALIZED;
 
-    this.mCacheEventListener = cacheEventListener;
+        this.mCacheEventListener = cacheEventListener;
 
-    this.mCacheSizeLimitMinimum = params.mCacheSizeLimitMinimum;
+        this.mCacheSizeLimitMinimum = params.mCacheSizeLimitMinimum;
 
-    this.mCacheErrorLogger = cacheErrorLogger;
+        this.mCacheErrorLogger = cacheErrorLogger;
 
-    this.mCacheStats = new CacheStats();
-    if (diskTrimmableRegistry != null) {
-      diskTrimmableRegistry.registerDiskTrimmable(this);
+        this.mCacheStats = new CacheStats();
+        if (diskTrimmableRegistry != null) {
+            diskTrimmableRegistry.registerDiskTrimmable(this);
+        }
+        this.mClock = com.facebook.common.time.SystemClock.get();
     }
-    this.mClock = com.facebook.common.time.SystemClock.get();
-  }
-
-  @Override
-  public DiskStorage.DiskDumpInfo getDumpInfo() throws IOException {
-    return mStorageSupplier.get().getDumpInfo();
-  }
-
-  @Override
-  public boolean isEnabled() {
-    try {
-      return mStorageSupplier.get().isEnabled();
-    } catch (IOException e) {
-      return false;
+
+    @Override
+    public DiskStorage.DiskDumpInfo getDumpInfo() throws IOException {
+        return mStorageSupplier.get().getDumpInfo();
     }
-  }
-
-  /**
-   * Retrieves the file corresponding to the mKey, if it is in the cache. Also
-   * touches the item, thus changing its LRU timestamp. If the file is not
-   * present in the file cache, returns null.
-   * <p>
-   * This should NOT be called on the UI thread.
-   *
-   * @param key the mKey to check
-   * @return The resource if present in cache, otherwise null
-   */
-  @Override
-  public BinaryResource getResource(final CacheKey key) {
-    try {
-      synchronized (mLock) {
-        BinaryResource resource = mStorageSupplier.get().getResource(getResourceId(key), key);
-        if (resource == null) {
-          mCacheEventListener.onMiss();
-        } else {
-          mCacheEventListener.onHit();
+
+    @Override
+    public boolean isEnabled() {
+        try {
+            return mStorageSupplier.get().isEnabled();
+        } catch (IOException e) {
+            return false;
         }
-        return resource;
-      }
-    } catch (IOException ioe) {
-      mCacheErrorLogger.logError(
-          CacheErrorLogger.CacheErrorCategory.GENERIC_IO,
-          TAG,
-          "getResource",
-          ioe);
-      mCacheEventListener.onReadException();
-      return null;
     }
-  }
-
-  /**
-   * Probes whether the object corresponding to the mKey is in the cache.
-   * Note that the act of probing touches the item (if present in cache),
-   * thus changing its LRU timestamp.
-   * <p>
-   * This will be faster than retrieving the object, but it still has
-   * file system accesses and should NOT be called on the UI thread.
-   *
-   * @param key the mKey to check
-   * @return whether the keyed mValue is in the cache
-   */
-  public boolean probe(final CacheKey key) {
-    try {
-      synchronized (mLock) {
-        return mStorageSupplier.get().touch(getResourceId(key), key);
-      }
-    } catch (IOException e) {
-      mCacheEventListener.onReadException();
-      return false;
+
+    /**
+     * Retrieves the file corresponding to the mKey, if it is in the cache. Also
+     * touches the item, thus changing its LRU timestamp. If the file is not
+     * present in the file cache, returns null.
+     * <p>
+     * This should NOT be called on the UI thread.
+     *
+     * @param key the mKey to check
+     * @return The resource if present in cache, otherwise null
+     */
+    @Override
+    public BinaryResource getResource(final CacheKey key) {
+        try {
+            synchronized (mLock) {
+                BinaryResource resource = mStorageSupplier.get().getResource(getResourceId(key), key);
+                if (resource == null) {
+                    mCacheEventListener.onMiss();
+                } else {
+                    mCacheEventListener.onHit();
+                }
+                return resource;
+            }
+        } catch (IOException ioe) {
+            mCacheErrorLogger.logError(
+                    CacheErrorLogger.CacheErrorCategory.GENERIC_IO,
+                    TAG,
+                    "getResource",
+                    ioe);
+            mCacheEventListener.onReadException();
+            return null;
+        }
     }
-  }
-
-  /**
-   * Creates a temp file for writing outside the session lock
-   */
-  private BinaryResource createTemporaryResource(
-      final String resourceId,
-      final CacheKey key)
-      throws IOException {
-    maybeEvictFilesInCacheDir();
-    return mStorageSupplier.get().createTemporary(resourceId, key);
-  }
-
-  private void deleteTemporaryResource(BinaryResource temporaryResource) {
-    if (!(temporaryResource instanceof FileBinaryResource)) {
-      return;
+
+    /**
+     * Probes whether the object corresponding to the mKey is in the cache.
+     * Note that the act of probing touches the item (if present in cache),
+     * thus changing its LRU timestamp.
+     * <p>
+     * This will be faster than retrieving the object, but it still has
+     * file system accesses and should NOT be called on the UI thread.
+     *
+     * @param key the mKey to check
+     * @return whether the keyed mValue is in the cache
+     */
+    public boolean probe(final CacheKey key) {
+        try {
+            synchronized (mLock) {
+                return mStorageSupplier.get().touch(getResourceId(key), key);
+            }
+        } catch (IOException e) {
+            mCacheEventListener.onReadException();
+            return false;
+        }
     }
-    FileBinaryResource fileResource = (FileBinaryResource)temporaryResource;
-    File tempFile = fileResource.getFile();
-
-    if (tempFile.exists()) {
-      FLog.e(TAG, "Temp file still on disk: %s ", tempFile);
-      if (!tempFile.delete()) {
-        FLog.e(TAG, "Failed to delete temp file: %s", tempFile);
-      }
+
+    /**
+     * Creates a temp file for writing outside the session lock
+     */
+    private BinaryResource createTemporaryResource(
+            final String resourceId,
+            final CacheKey key)
+            throws IOException {
+        maybeEvictFilesInCacheDir();
+        return mStorageSupplier.get().createTemporary(resourceId, key);
     }
-  }
-
-  /**
-   * Commits the provided temp file to the cache, renaming it to match
-   * the cache's hashing convention.
-   */
-  private BinaryResource commitResource(
-      final String resourceId,
-      final CacheKey key,
-      final BinaryResource temporary) throws IOException {
-    synchronized (mLock) {
-      BinaryResource resource = mStorageSupplier.get().commit(resourceId, temporary, key);
-      mCacheStats.increment(resource.size(), 1);
-      return resource;
+
+    private void deleteTemporaryResource(BinaryResource temporaryResource) {
+        if (!(temporaryResource instanceof FileBinaryResource)) {
+            return;
+        }
+        FileBinaryResource fileResource = (FileBinaryResource) temporaryResource;
+        File tempFile = fileResource.getFile();
+
+        if (tempFile.exists()) {
+            FLog.e(TAG, "Temp file still on disk: %s ", tempFile);
+            if (!tempFile.delete()) {
+                FLog.e(TAG, "Failed to delete temp file: %s", tempFile);
+            }
+        }
     }
-  }
-
-  @Override
-  public BinaryResource insert(CacheKey key, WriterCallback callback) throws IOException {
-    // Write to a temp file, then move it into place. This allows more parallelism
-    // when writing files.
-    mCacheEventListener.onWriteAttempt();
-    final String resourceId = getResourceId(key);
-    try {
-      // getting the file is synchronized
-      BinaryResource temporary = createTemporaryResource(resourceId, key);
-      try {
-        mStorageSupplier.get().updateResource(resourceId, temporary, callback, key);
-        // Committing the file is synchronized
-        return commitResource(resourceId, key, temporary);
-      } finally {
-        deleteTemporaryResource(temporary);
-      }
-    } catch (IOException ioe) {
-      mCacheEventListener.onWriteException();
-      FLog.d(TAG, "Failed inserting a file into the cache", ioe);
-      throw ioe;
+
+    /**
+     * Commits the provided temp file to the cache, renaming it to match
+     * the cache's hashing convention.
+     */
+    private BinaryResource commitResource(
+            final String resourceId,
+            final CacheKey key,
+            final BinaryResource temporary) throws IOException {
+        synchronized (mLock) {
+            BinaryResource resource = mStorageSupplier.get().commit(resourceId, temporary, key);
+            mCacheStats.increment(resource.size(), 1);
+            return resource;
+        }
     }
-  }
-
-  @Override
-  public void remove(CacheKey key) {
-    synchronized (mLock) {
-      try {
-        mStorageSupplier.get().remove(getResourceId(key));
-      } catch (IOException e) {
-        mCacheErrorLogger.logError(
-            CacheErrorLogger.CacheErrorCategory.DELETE_FILE,
-            TAG,
-            "delete: " + e.getMessage(),
-            e);
-      }
+
+    @Override
+    public BinaryResource insert(CacheKey key, WriterCallback callback) throws IOException {
+        // Write to a temp file, then move it into place. This allows more parallelism
+        // when writing files.
+        mCacheEventListener.onWriteAttempt();
+        final String resourceId = getResourceId(key);
+        try {
+            // getting the file is synchronized
+            BinaryResource temporary = createTemporaryResource(resourceId, key);
+            try {
+                mStorageSupplier.get().updateResource(resourceId, temporary, callback, key);
+                // Committing the file is synchronized
+                return commitResource(resourceId, key, temporary);
+            } finally {
+                deleteTemporaryResource(temporary);
+            }
+        } catch (IOException ioe) {
+            mCacheEventListener.onWriteException();
+            FLog.d(TAG, "Failed inserting a file into the cache", ioe);
+            throw ioe;
+        }
     }
-  }
-
-  /**
-   * Deletes old cache files.
-   * @param cacheExpirationMs files older than this will be deleted.
-   * @return the age in ms of the oldest file remaining in the cache.
-   */
-  @Override
-  public long clearOldEntries(long cacheExpirationMs) {
-    long oldestRemainingEntryAgeMs = 0L;
-    synchronized (mLock) {
-      try {
-        long now = mClock.now();
-        DiskStorage storage = mStorageSupplier.get();
-        Collection<DiskStorage.Entry> allEntries = storage.getEntries();
-        int itemsRemovedCount = 0;
-        long itemsRemovedSize = 0L;
-        for (DiskStorage.Entry entry : allEntries) {
-          // entry age of zero is disallowed.
-          long entryAgeMs = Math.max(1, Math.abs(now - entry.getTimestamp()));
-          if (entryAgeMs >= cacheExpirationMs) {
-            long entryRemovedSize = storage.remove(entry);
-            if (entryRemovedSize > 0) {
-              itemsRemovedCount++;
-              itemsRemovedSize += entryRemovedSize;
+
+    @Override
+    public void remove(CacheKey key) {
+        synchronized (mLock) {
+            try {
+                mStorageSupplier.get().remove(getResourceId(key));
+            } catch (IOException e) {
+                mCacheErrorLogger.logError(
+                        CacheErrorLogger.CacheErrorCategory.DELETE_FILE,
+                        TAG,
+                        "delete: " + e.getMessage(),
+                        e);
             }
-          } else {
-            oldestRemainingEntryAgeMs = Math.max(oldestRemainingEntryAgeMs, entryAgeMs);
-          }
         }
-        storage.purgeUnexpectedResources();
-        if (itemsRemovedCount > 0) {
-          maybeUpdateFileCacheSize();
-          mCacheStats.increment(-itemsRemovedSize, -itemsRemovedCount);
-          reportEviction(
-              CacheEventListener.EvictionReason.CONTENT_STALE,
-              itemsRemovedCount,
-              itemsRemovedSize);
+    }
+
+    /**
+     * Deletes old cache files.
+     *
+     * @param cacheExpirationMs files older than this will be deleted.
+     * @return the age in ms of the oldest file remaining in the cache.
+     */
+    @Override
+    public long clearOldEntries(long cacheExpirationMs) {
+        long oldestRemainingEntryAgeMs = 0L;
+        synchronized (mLock) {
+            try {
+                long now = mClock.now();
+                DiskStorage storage = mStorageSupplier.get();
+                Collection<DiskStorage.Entry> allEntries = storage.getEntries();
+                int itemsRemovedCount = 0;
+                long itemsRemovedSize = 0L;
+                for (DiskStorage.Entry entry : allEntries) {
+                    // entry age of zero is disallowed.
+                    long entryAgeMs = Math.max(1, Math.abs(now - entry.getTimestamp()));
+                    if (entryAgeMs >= cacheExpirationMs) {
+                        long entryRemovedSize = storage.remove(entry);
+                        if (entryRemovedSize > 0) {
+                            itemsRemovedCount++;
+                            itemsRemovedSize += entryRemovedSize;
+                        }
+                    } else {
+                        oldestRemainingEntryAgeMs = Math.max(oldestRemainingEntryAgeMs, entryAgeMs);
+                    }
+                }
+                storage.purgeUnexpectedResources();
+                if (itemsRemovedCount > 0) {
+                    maybeUpdateFileCacheSize();
+                    mCacheStats.increment(-itemsRemovedSize, -itemsRemovedCount);
+                    reportEviction(
+                            CacheEventListener.EvictionReason.CONTENT_STALE,
+                            itemsRemovedCount,
+                            itemsRemovedSize);
+                }
+            } catch (IOException ioe) {
+                mCacheErrorLogger.logError(
+                        CacheErrorLogger.CacheErrorCategory.EVICTION,
+                        TAG,
+                        "clearOldEntries: " + ioe.getMessage(),
+                        ioe);
+            }
         }
-      } catch (IOException ioe) {
-        mCacheErrorLogger.logError(
-            CacheErrorLogger.CacheErrorCategory.EVICTION,
-            TAG,
-            "clearOldEntries: " + ioe.getMessage(),
-            ioe);
-      }
+        return oldestRemainingEntryAgeMs;
     }
-    return oldestRemainingEntryAgeMs;
-  }
-
-  private void reportEviction(
-      CacheEventListener.EvictionReason reason,
-      int itemCount,
-      long itemSize) {
-    mCacheEventListener.onEviction(reason, itemCount, itemSize);
-  }
-
-  /**
-   * Test if the cache size has exceeded its limits, and if so, evict some files.
-   * It also calls maybeUpdateFileCacheSize
-   *
-   * This method uses mLock for synchronization purposes.
-   */
-  private void maybeEvictFilesInCacheDir() throws IOException {
-    synchronized (mLock) {
-      boolean calculatedRightNow = maybeUpdateFileCacheSize();
-
-      // Update the size limit (mCacheSizeLimit)
-      updateFileCacheSizeLimit();
-
-      long cacheSize = mCacheStats.getSize();
-      // If we are going to evict force a recalculation of the size
-      // (except if it was already calculated!)
-      if (cacheSize > mCacheSizeLimit && !calculatedRightNow) {
-        mCacheStats.reset();
-        maybeUpdateFileCacheSize();
-      }
-
-      // If size has exceeded the size limit, evict some files
-      if (cacheSize > mCacheSizeLimit) {
-      evictAboveSize(
-          mCacheSizeLimit * 9 / 10,
-          CacheEventListener.EvictionReason.CACHE_FULL); // 90%
-      }
+
+    private void reportEviction(
+            CacheEventListener.EvictionReason reason,
+            int itemCount,
+            long itemSize) {
+        mCacheEventListener.onEviction(reason, itemCount, itemSize);
+    }
+
+    /**
+     * Test if the cache size has exceeded its limits, and if so, evict some files.
+     * It also calls maybeUpdateFileCacheSize
+     * <p>
+     * This method uses mLock for synchronization purposes.
+     */
+    private void maybeEvictFilesInCacheDir() throws IOException {
+        synchronized (mLock) {
+            boolean calculatedRightNow = maybeUpdateFileCacheSize();
+
+            // Update the size limit (mCacheSizeLimit)
+            updateFileCacheSizeLimit();
+
+            long cacheSize = mCacheStats.getSize();
+            // If we are going to evict force a recalculation of the size
+            // (except if it was already calculated!)
+            if (cacheSize > mCacheSizeLimit && !calculatedRightNow) {
+                mCacheStats.reset();
+                maybeUpdateFileCacheSize();
+            }
+
+            // If size has exceeded the size limit, evict some files
+            if (cacheSize > mCacheSizeLimit) {
+                evictAboveSize(
+                        mCacheSizeLimit * 9 / 10,
+                        CacheEventListener.EvictionReason.CACHE_FULL); // 90%
+            }
+        }
     }
-  }
-
-  @GuardedBy("mLock")
-  private void evictAboveSize(
-      long desiredSize,
-      CacheEventListener.EvictionReason reason) throws IOException {
-    DiskStorage storage = mStorageSupplier.get();
-    Collection<DiskStorage.Entry> entries;
-    try {
-      entries = getSortedEntries(storage.getEntries());
-    } catch (IOException ioe) {
-      mCacheErrorLogger.logError(
-          CacheErrorLogger.CacheErrorCategory.EVICTION,
-          TAG,
-          "evictAboveSize: " + ioe.getMessage(),
-          ioe);
-      throw ioe;
+
+    @GuardedBy("mLock")
+    private void evictAboveSize(
+            long desiredSize,
+            CacheEventListener.EvictionReason reason) throws IOException {
+        DiskStorage storage = mStorageSupplier.get();
+        Collection<DiskStorage.Entry> entries;
+        try {
+            entries = getSortedEntries(storage.getEntries());
+        } catch (IOException ioe) {
+            mCacheErrorLogger.logError(
+                    CacheErrorLogger.CacheErrorCategory.EVICTION,
+                    TAG,
+                    "evictAboveSize: " + ioe.getMessage(),
+                    ioe);
+            throw ioe;
+        }
+
+        long deleteSize = mCacheStats.getSize() - desiredSize;
+        int itemCount = 0;
+        long sumItemSizes = 0L;
+        for (DiskStorage.Entry entry : entries) {
+            if (sumItemSizes > (deleteSize)) {
+                break;
+            }
+            long deletedSize = storage.remove(entry);
+            if (deletedSize > 0) {
+                itemCount++;
+                sumItemSizes += deletedSize;
+            }
+        }
+        mCacheStats.increment(-sumItemSizes, -itemCount);
+        storage.purgeUnexpectedResources();
+        reportEviction(reason, itemCount, sumItemSizes);
     }
 
-    long deleteSize = mCacheStats.getSize() - desiredSize;
-    int itemCount = 0;
-    long sumItemSizes = 0L;
-    for (DiskStorage.Entry entry: entries) {
-      if (sumItemSizes > (deleteSize)) {
-        break;
-      }
-      long deletedSize = storage.remove(entry);
-      if (deletedSize > 0) {
-        itemCount ++;
-        sumItemSizes += deletedSize;
-      }
+    /**
+     * If any file timestamp is in the future (beyond now + FUTURE_TIMESTAMP_THRESHOLD_MS), we will
+     * set its effective timestamp to 0 (the beginning of unix time), thus sending it to the head of
+     * the queue for eviction (entries with the lowest timestamps are evicted first). This is a
+     * safety check in case we get files that are written with a future timestamp.
+     * We are adding a small delta (this constant) to account for network time changes, timezone
+     * changes, etc.
+     */
+    private Collection<DiskStorage.Entry> getSortedEntries(
+            Collection<DiskStorage.Entry> allEntries) {
+        final ArrayList<DiskStorage.Entry> entriesList = Lists.newArrayList(allEntries);
+        final long threshold =
+                mClock.now() + DiskStorageCache.FUTURE_TIMESTAMP_THRESHOLD_MS;
+        Collections.sort(entriesList, new TimestampComparator(threshold));
+        return entriesList;
     }
-    mCacheStats.increment(-sumItemSizes, -itemCount);
-    storage.purgeUnexpectedResources();
-    reportEviction(reason, itemCount, sumItemSizes);
-  }
-
-  /**
-   * If any file timestamp is in the future (beyond now + FUTURE_TIMESTAMP_THRESHOLD_MS), we will
-   * set its effective timestamp to 0 (the beginning of unix time), thus sending it to the head of
-   * the queue for eviction (entries with the lowest timestamps are evicted first). This is a
-   * safety check in case we get files that are written with a future timestamp.
-   * We are adding a small delta (this constant) to account for network time changes, timezone
-   * changes, etc.
-   */
-  private Collection<DiskStorage.Entry> getSortedEntries(
-     Collection<DiskStorage.Entry> allEntries) {
-    final ArrayList<DiskStorage.Entry> entriesList = Lists.newArrayList(allEntries);
-    final long threshold =
-        mClock.now() + DiskStorageCache.FUTURE_TIMESTAMP_THRESHOLD_MS;
-    Collections.sort(entriesList, new TimestampComparator(threshold));
-    return entriesList;
-  }
-
-  /**
-   * Compares file timestamps, but files with timestamps more than some future threshold are
-   * considered to have a timestamp of zero so they are sent to the head of the queue for eviction.
-   */
-  private static class TimestampComparator implements Comparator<DiskStorage.Entry> {
-    private final long threshold;
-
-    public TimestampComparator(long threshold) {
-      this.threshold = threshold;
+
+    /**
+     * Compares file timestamps, but files with timestamps more than some future threshold are
+     * considered to have a timestamp of zero so they are sent to the head of the queue for eviction.
+     */
+    private static class TimestampComparator implements Comparator<DiskStorage.Entry> {
+        private final long threshold;
+
+        public TimestampComparator(long threshold) {
+            this.threshold = threshold;
+        }
+
+        @Override
+        public int compare(DiskStorage.Entry e1, DiskStorage.Entry e2) {
+            long time1 = e1.getTimestamp() <= threshold ? e1.getTimestamp() : 0;
+            long time2 = e2.getTimestamp() <= threshold ? e2.getTimestamp() : 0;
+            return time1 < time2 ? -1 : ((time2 > time1) ? 1 : 0);
+        }
     }
 
-    @Override
-    public int compare(DiskStorage.Entry e1, DiskStorage.Entry e2) {
-      long time1 = e1.getTimestamp() <= threshold ? e1.getTimestamp() : 0;
-      long time2 = e2.getTimestamp() <= threshold ? e2.getTimestamp() : 0;
-      return time1 < time2 ? -1 : ((time2 > time1) ? 1 : 0);
+    /**
+     * Helper method that sets the cache size limit to be either a high, or a low limit.
+     * If there is not enough free space to satisfy the high limit, it is set to the low limit.
+     */
+    @GuardedBy("mLock")
+    private void updateFileCacheSizeLimit() {
+        // Test if mCacheSizeLimit can be set to the high limit
+        boolean isAvailableSpaceLowerThanHighLimit =
+                mStatFsHelper.testLowDiskSpace(
+                        StatFsHelper.StorageType.INTERNAL,
+                        mDefaultCacheSizeLimit - mCacheStats.getSize());
+        if (isAvailableSpaceLowerThanHighLimit) {
+            mCacheSizeLimit = mLowDiskSpaceCacheSizeLimit;
+        } else {
+            mCacheSizeLimit = mDefaultCacheSizeLimit;
+        }
+    }
+
+    public long getSize() {
+        return mCacheStats.getSize();
     }
-  }
-
-  /**
-   * Helper method that sets the cache size limit to be either a high, or a low limit.
-   * If there is not enough free space to satisfy the high limit, it is set to the low limit.
-   */
-  @GuardedBy("mLock")
-  private void updateFileCacheSizeLimit() {
-    // Test if mCacheSizeLimit can be set to the high limit
-    boolean isAvailableSpaceLowerThanHighLimit =
-        mStatFsHelper.testLowDiskSpace(
-            StatFsHelper.StorageType.INTERNAL,
-            mDefaultCacheSizeLimit - mCacheStats.getSize());
-    if (isAvailableSpaceLowerThanHighLimit) {
-      mCacheSizeLimit = mLowDiskSpaceCacheSizeLimit;
-    } else {
-      mCacheSizeLimit = mDefaultCacheSizeLimit;
+
+    public void clearAll() {
+        synchronized (mLock) {
+            try {
+                mStorageSupplier.get().clearAll();
+            } catch (IOException ioe) {
+                mCacheErrorLogger.logError(
+                        CacheErrorLogger.CacheErrorCategory.EVICTION,
+                        TAG,
+                        "clearAll: " + ioe.getMessage(),
+                        ioe);
+            }
+
+            mCacheStats.reset();
+        }
     }
-  }
-
-  public long getSize() {
-    return mCacheStats.getSize();
-  }
-
-  public void clearAll() {
-    synchronized (mLock) {
-      try {
-        mStorageSupplier.get().clearAll();
-      } catch (IOException ioe) {
-        mCacheErrorLogger.logError(
-            CacheErrorLogger.CacheErrorCategory.EVICTION,
-            TAG,
-            "clearAll: " + ioe.getMessage(),
-            ioe);
-      }
-
-      mCacheStats.reset();
+
+    public boolean hasKey(final CacheKey key) {
+        try {
+            return mStorageSupplier.get().contains(getResourceId(key), key);
+        } catch (IOException e) {
+            return false;
+        }
     }
-  }
 
-  public boolean hasKey(final CacheKey key) {
-    try {
-      return mStorageSupplier.get().contains(getResourceId(key), key);
-    } catch (IOException e) {
-      return false;
+    @Override
+    public void trimToMinimum() {
+        synchronized (mLock) {
+            maybeUpdateFileCacheSize();
+            long cacheSize = mCacheStats.getSize();
+            if (mCacheSizeLimitMinimum <= 0 || cacheSize <= 0 || cacheSize < mCacheSizeLimitMinimum) {
+                return;
+            }
+            double trimRatio = 1 - (double) mCacheSizeLimitMinimum / (double) cacheSize;
+            if (trimRatio > TRIMMING_LOWER_BOUND) {
+                trimBy(trimRatio);
+            }
+        }
     }
-  }
-
-  @Override
-  public void trimToMinimum() {
-    synchronized (mLock) {
-      maybeUpdateFileCacheSize();
-      long cacheSize = mCacheStats.getSize();
-      if (mCacheSizeLimitMinimum <= 0 || cacheSize <= 0 || cacheSize < mCacheSizeLimitMinimum) {
-        return;
-      }
-      double trimRatio = 1 - (double) mCacheSizeLimitMinimum / (double) cacheSize;
-      if (trimRatio > TRIMMING_LOWER_BOUND) {
-        trimBy(trimRatio);
-      }
+
+    @Override
+    public void trimToNothing() {
+        clearAll();
     }
-  }
-
-  @Override
-  public void trimToNothing() {
-    clearAll();
-  }
-
-  private void trimBy(final double trimRatio) {
-    synchronized (mLock) {
-      try {
-        // Force update the ground truth if we are about to evict
-        mCacheStats.reset();
-        maybeUpdateFileCacheSize();
-        long cacheSize = mCacheStats.getSize();
-        long newMaxBytesInFiles = cacheSize - (long) (trimRatio * cacheSize);
-        evictAboveSize(
-            newMaxBytesInFiles,
-            CacheEventListener.EvictionReason.CACHE_MANAGER_TRIMMED);
-      } catch (IOException ioe) {
-        mCacheErrorLogger.logError(
-            CacheErrorLogger.CacheErrorCategory.EVICTION,
-            TAG,
-            "trimBy: " + ioe.getMessage(),
-            ioe);
-      }
+
+    private void trimBy(final double trimRatio) {
+        synchronized (mLock) {
+            try {
+                // Force update the ground truth if we are about to evict
+                mCacheStats.reset();
+                maybeUpdateFileCacheSize();
+                long cacheSize = mCacheStats.getSize();
+                long newMaxBytesInFiles = cacheSize - (long) (trimRatio * cacheSize);
+                evictAboveSize(
+                        newMaxBytesInFiles,
+                        CacheEventListener.EvictionReason.CACHE_MANAGER_TRIMMED);
+            } catch (IOException ioe) {
+                mCacheErrorLogger.logError(
+                        CacheErrorLogger.CacheErrorCategory.EVICTION,
+                        TAG,
+                        "trimBy: " + ioe.getMessage(),
+                        ioe);
+            }
+        }
     }
-  }
-
-  /**
-   * If file cache size is not calculated or if it was calculated
-   * a long time ago (FILECACHE_SIZE_UPDATE_PERIOD_MS) recalculated from file listing.
-   * @return true if it was recalculated, false otherwise.
-   */
-  @GuardedBy("mLock")
-  private boolean maybeUpdateFileCacheSize() {
-    boolean result = false;
-    long now = SystemClock.elapsedRealtime();
-    if ((!mCacheStats.isInitialized()) ||
-        mCacheSizeLastUpdateTime == UNINITIALIZED ||
-        (now - mCacheSizeLastUpdateTime) > FILECACHE_SIZE_UPDATE_PERIOD_MS) {
-      calcFileCacheSize();
-      mCacheSizeLastUpdateTime = now;
-      result = true;
+
+    /**
+     * If file cache size is not calculated or if it was calculated
+     * a long time ago (FILECACHE_SIZE_UPDATE_PERIOD_MS) recalculated from file listing.
+     *
+     * @return true if it was recalculated, false otherwise.
+     */
+    @GuardedBy("mLock")
+    private boolean maybeUpdateFileCacheSize() {
+        boolean result = false;
+        long now = SystemClock.elapsedRealtime();
+        if ((!mCacheStats.isInitialized()) ||
+                mCacheSizeLastUpdateTime == UNINITIALIZED ||
+                (now - mCacheSizeLastUpdateTime) > FILECACHE_SIZE_UPDATE_PERIOD_MS) {
+            calcFileCacheSize();
+            mCacheSizeLastUpdateTime = now;
+            result = true;
+        }
+        return result;
     }
-    return result;
-  }
-
-  @GuardedBy("mLock")
-  private void calcFileCacheSize() {
-    long size = 0;
-    int count = 0;
-    boolean foundFutureTimestamp = false;
-    int numFutureFiles = 0;
-    int sizeFutureFiles = 0;
-    long maxTimeDelta = -1;
-    long now = mClock.now();
-    long timeThreshold = now + FUTURE_TIMESTAMP_THRESHOLD_MS;
-    try {
-      DiskStorage storage = mStorageSupplier.get();
-      Collection<DiskStorage.Entry> entries = storage.getEntries();
-      for (DiskStorage.Entry entry: entries) {
-        count++;
-        size += entry.getSize();
-
-        //Check if any files have a future timestamp, beyond our threshold
-        if (entry.getTimestamp() > timeThreshold) {
-          foundFutureTimestamp = true;
-          numFutureFiles++;
-          sizeFutureFiles += entry.getSize();
-          maxTimeDelta = Math.max(entry.getTimestamp() - now, maxTimeDelta);
+
+    @GuardedBy("mLock")
+    private void calcFileCacheSize() {
+        long size = 0;
+        int count = 0;
+        boolean foundFutureTimestamp = false;
+        int numFutureFiles = 0;
+        int sizeFutureFiles = 0;
+        long maxTimeDelta = -1;
+        long now = mClock.now();
+        long timeThreshold = now + FUTURE_TIMESTAMP_THRESHOLD_MS;
+        try {
+            DiskStorage storage = mStorageSupplier.get();
+            Collection<DiskStorage.Entry> entries = storage.getEntries();
+            for (DiskStorage.Entry entry : entries) {
+                count++;
+                size += entry.getSize();
+
+                //Check if any files have a future timestamp, beyond our threshold
+                if (entry.getTimestamp() > timeThreshold) {
+                    foundFutureTimestamp = true;
+                    numFutureFiles++;
+                    sizeFutureFiles += entry.getSize();
+                    maxTimeDelta = Math.max(entry.getTimestamp() - now, maxTimeDelta);
+                }
+            }
+            if (foundFutureTimestamp) {
+                mCacheErrorLogger.logError(
+                        CacheErrorLogger.CacheErrorCategory.READ_INVALID_ENTRY,
+                        TAG,
+                        "Future timestamp found in " + numFutureFiles +
+                                " files , with a total size of " + sizeFutureFiles +
+                                " bytes, and a maximum time delta of " + maxTimeDelta + "ms",
+                        null);
+            }
+            mCacheStats.set(size, count);
+        } catch (IOException ioe) {
+            mCacheErrorLogger.logError(
+                    CacheErrorLogger.CacheErrorCategory.GENERIC_IO,
+                    TAG,
+                    "calcFileCacheSize: " + ioe.getMessage(),
+                    ioe);
         }
-      }
-      if (foundFutureTimestamp) {
-        mCacheErrorLogger.logError(
-            CacheErrorLogger.CacheErrorCategory.READ_INVALID_ENTRY,
-            TAG,
-            "Future timestamp found in " + numFutureFiles +
-                " files , with a total size of " + sizeFutureFiles +
-                " bytes, and a maximum time delta of " + maxTimeDelta + "ms",
-            null);
-      }
-      mCacheStats.set(size, count);
-    } catch (IOException ioe) {
-      mCacheErrorLogger.logError(
-          CacheErrorLogger.CacheErrorCategory.GENERIC_IO,
-          TAG,
-          "calcFileCacheSize: " + ioe.getMessage(),
-          ioe);
     }
-  }
-
-  @VisibleForTesting
-  String getResourceId(final CacheKey key) {
-    try {
-      return SecureHashUtil.makeSHA1HashBase64(key.toString().getBytes("UTF-8"));
-    } catch (UnsupportedEncodingException e) {
-      // This should never happen. All VMs support UTF-8
-      throw new RuntimeException(e);
+
+    @VisibleForTesting
+    String getResourceId(final CacheKey key) {
+        try {
+            return SecureHashUtil.makeSHA1HashBase64(key.toString().getBytes("UTF-8"));
+        } catch (UnsupportedEncodingException e) {
+            // This should never happen. All VMs support UTF-8
+            throw new RuntimeException(e);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorageSupplier.java b/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorageSupplier.java
index 5b6b01e33..7aea8df66 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorageSupplier.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/disk/DiskStorageSupplier.java
@@ -16,10 +16,11 @@
  */
 public interface DiskStorageSupplier {
 
-  /**
-   * Get a concrete instance of DiskStorage
-   * @return an instance of DiskStorage
-   * @throws IOException
-   */
-  public DiskStorage get() throws IOException;
+    /**
+     * Get a concrete instance of DiskStorage
+     *
+     * @return an instance of DiskStorage
+     * @throws IOException
+     */
+    public DiskStorage get() throws IOException;
 }
diff --git a/imagepipeline/src/main/java/com/facebook/cache/disk/FileCache.java b/imagepipeline/src/main/java/com/facebook/cache/disk/FileCache.java
index 72b0b7b79..5936caf30 100644
--- a/imagepipeline/src/main/java/com/facebook/cache/disk/FileCache.java
+++ b/imagepipeline/src/main/java/com/facebook/cache/disk/FileCache.java
@@ -21,49 +21,55 @@
  */
 public interface FileCache extends DiskTrimmable {
 
-  /**
-   * Tells if this cache is enabled. It's important for some caches that can be disabled
-   * without further notice (like in removable/unmountable storage). Anyway a disabled
-   * cache should just ignore calls, not fail.
-   * @return true if this cache is usable, false otherwise.
-   */
-  boolean isEnabled();
+    /**
+     * Tells if this cache is enabled. It's important for some caches that can be disabled
+     * without further notice (like in removable/unmountable storage). Anyway a disabled
+     * cache should just ignore calls, not fail.
+     *
+     * @return true if this cache is usable, false otherwise.
+     */
+    boolean isEnabled();
 
-  /**
-   * Returns the binary resource cached with key.
-   */
-  BinaryResource getResource(CacheKey key);
+    /**
+     * Returns the binary resource cached with key.
+     */
+    BinaryResource getResource(CacheKey key);
 
-  boolean hasKey(CacheKey key);
-  boolean probe(CacheKey key);
+    boolean hasKey(CacheKey key);
 
-  /**
-   * Inserts resource into file with key
-   * @param key cache key
-   * @param writer Callback that writes to an output stream
-   * @return a sequence of bytes
-   * @throws IOException
-   */
-  BinaryResource insert(CacheKey key, WriterCallback writer) throws IOException;
+    boolean probe(CacheKey key);
 
-  /**
-   * Removes a resource by key from cache.
-   * @param key cache key
-   */
-  void remove(CacheKey key);
+    /**
+     * Inserts resource into file with key
+     *
+     * @param key    cache key
+     * @param writer Callback that writes to an output stream
+     * @return a sequence of bytes
+     * @throws IOException
+     */
+    BinaryResource insert(CacheKey key, WriterCallback writer) throws IOException;
 
-  /**
-   * @return the in-use size of the cache
-   */
-  long getSize();
+    /**
+     * Removes a resource by key from cache.
+     *
+     * @param key cache key
+     */
+    void remove(CacheKey key);
 
-  /**
-   * Deletes old cache files.
-   * @param cacheExpirationMs files older than this will be deleted.
-   * @return the age in ms of the oldest file remaining in the cache.
-   */
-  long clearOldEntries(long cacheExpirationMs);
-  void clearAll();
+    /**
+     * @return the in-use size of the cache
+     */
+    long getSize();
 
-  public DiskStorage.DiskDumpInfo getDumpInfo() throws IOException;
+    /**
+     * Deletes old cache files.
+     *
+     * @param cacheExpirationMs files older than this will be deleted.
+     * @return the age in ms of the oldest file remaining in the cache.
+     */
+    long clearOldEntries(long cacheExpirationMs);
+
+    void clearAll();
+
+    public DiskStorage.DiskDumpInfo getDumpInfo() throws IOException;
 }
diff --git a/imagepipeline/src/main/java/com/facebook/drawable/base/DrawableWithCaches.java b/imagepipeline/src/main/java/com/facebook/drawable/base/DrawableWithCaches.java
index 98bfc58ab..6b39fdc2d 100644
--- a/imagepipeline/src/main/java/com/facebook/drawable/base/DrawableWithCaches.java
+++ b/imagepipeline/src/main/java/com/facebook/drawable/base/DrawableWithCaches.java
@@ -16,8 +16,8 @@
  */
 public interface DrawableWithCaches {
 
-  /**
-   * Informs the Drawable to drop its caches.
-   */
-  void dropCaches();
+    /**
+     * Informs the Drawable to drop its caches.
+     */
+    void dropCaches();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormat.java b/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormat.java
index 4c6e5e954..eb5270ab4 100644
--- a/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormat.java
+++ b/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormat.java
@@ -14,16 +14,16 @@
  */
 public enum ImageFormat {
 
-  WEBP_SIMPLE,
-  WEBP_LOSSLESS,
-  WEBP_EXTENDED,
-  WEBP_EXTENDED_WITH_ALPHA,
-  WEBP_ANIMATED,
-  JPEG,
-  PNG,
-  GIF,
-  /**
-   * Unknown image. This is needed in case we fail to detect any type for particular image.
-   */
-  UNKNOWN;
+    WEBP_SIMPLE,
+    WEBP_LOSSLESS,
+    WEBP_EXTENDED,
+    WEBP_EXTENDED_WITH_ALPHA,
+    WEBP_ANIMATED,
+    JPEG,
+    PNG,
+    GIF,
+    /**
+     * Unknown image. This is needed in case we fail to detect any type for particular image.
+     */
+    UNKNOWN;
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormatChecker.java b/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormatChecker.java
index d0f8c19fa..70d29f198 100644
--- a/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormatChecker.java
+++ b/imagepipeline/src/main/java/com/facebook/imageformat/ImageFormatChecker.java
@@ -25,346 +25,356 @@
  */
 public class ImageFormatChecker {
 
-  private ImageFormatChecker() {}
-
-  /**
-   * Tries to match imageHeaderByte and headerSize against every known image format.
-   * If any match succeeds, corresponding ImageFormat is returned.
-   * @param imageHeaderBytes
-   * @param headerSize
-   * @return ImageFormat for given imageHeaderBytes or UNKNOWN if no such type could be recognized
-   */
-  private static ImageFormat doGetImageFormat(
-      final byte[] imageHeaderBytes,
-      final int headerSize) {
-    Preconditions.checkNotNull(imageHeaderBytes);
-
-    if (isWebpHeader(imageHeaderBytes, headerSize)) {
-      return getWebpFormat(imageHeaderBytes, headerSize);
+    private ImageFormatChecker() {
     }
 
-    if (isJpegHeader(imageHeaderBytes, headerSize)) {
-      return ImageFormat.JPEG;
+    /**
+     * Tries to match imageHeaderByte and headerSize against every known image format.
+     * If any match succeeds, corresponding ImageFormat is returned.
+     *
+     * @param imageHeaderBytes
+     * @param headerSize
+     * @return ImageFormat for given imageHeaderBytes or UNKNOWN if no such type could be recognized
+     */
+    private static ImageFormat doGetImageFormat(
+            final byte[] imageHeaderBytes,
+            final int headerSize) {
+        Preconditions.checkNotNull(imageHeaderBytes);
+
+        if (isWebpHeader(imageHeaderBytes, headerSize)) {
+            return getWebpFormat(imageHeaderBytes, headerSize);
+        }
+
+        if (isJpegHeader(imageHeaderBytes, headerSize)) {
+            return ImageFormat.JPEG;
+        }
+
+        if (isPngHeader(imageHeaderBytes, headerSize)) {
+            return ImageFormat.PNG;
+        }
+
+        if (isGifHeader(imageHeaderBytes, headerSize)) {
+            return ImageFormat.GIF;
+        }
+
+        return ImageFormat.UNKNOWN;
     }
 
-    if (isPngHeader(imageHeaderBytes, headerSize)) {
-      return ImageFormat.PNG;
+    /**
+     * Reads up to MAX_HEADER_LENGTH bytes from is InputStream. If mark is supported by is, it is
+     * used to restore content of the stream after appropriate amount of data is read.
+     * Read bytes are stored in imageHeaderBytes, which should be capable of storing
+     * MAX_HEADER_LENGTH bytes.
+     *
+     * @param is
+     * @param imageHeaderBytes
+     * @return number of bytes read from is
+     * @throws IOException
+     */
+    private static int readHeaderFromStream(
+            final InputStream is,
+            final byte[] imageHeaderBytes)
+            throws IOException {
+        Preconditions.checkNotNull(is);
+        Preconditions.checkNotNull(imageHeaderBytes);
+        Preconditions.checkArgument(imageHeaderBytes.length >= MAX_HEADER_LENGTH);
+
+        // If mark is supported by the stream, use it to let the owner of the stream re-read the same
+        // data. Otherwise, just consume some data.
+        if (is.markSupported()) {
+            try {
+                is.mark(MAX_HEADER_LENGTH);
+                return ByteStreams.read(is, imageHeaderBytes, 0, MAX_HEADER_LENGTH);
+            } finally {
+                is.reset();
+            }
+        } else {
+            return ByteStreams.read(is, imageHeaderBytes, 0, MAX_HEADER_LENGTH);
+        }
     }
 
-    if (isGifHeader(imageHeaderBytes, headerSize)) {
-      return ImageFormat.GIF;
+    /**
+     * Tries to read up to MAX_HEADER_LENGTH bytes from InputStream is and use read bytes to
+     * determine type of the image contained in is. If provided input stream does not support mark,
+     * then this method consumes data from is and it is not safe to read further bytes from is after
+     * this method returns. Otherwise, if mark is supported, it will be used to preserve oryginal
+     * content of is.
+     *
+     * @param is
+     * @return ImageFormat matching content of is InputStream or UNKNOWN if no type is suitable
+     * @throws IOException if exception happens during read
+     */
+    public static ImageFormat getImageFormat(final InputStream is) throws IOException {
+        Preconditions.checkNotNull(is);
+        final byte[] imageHeaderBytes = new byte[MAX_HEADER_LENGTH];
+        final int headerSize = readHeaderFromStream(is, imageHeaderBytes);
+        return doGetImageFormat(imageHeaderBytes, headerSize);
     }
 
-    return ImageFormat.UNKNOWN;
-  }
-
-  /**
-   * Reads up to MAX_HEADER_LENGTH bytes from is InputStream. If mark is supported by is, it is
-   * used to restore content of the stream after appropriate amount of data is read.
-   * Read bytes are stored in imageHeaderBytes, which should be capable of storing
-   * MAX_HEADER_LENGTH bytes.
-   * @param is
-   * @param imageHeaderBytes
-   * @return number of bytes read from is
-   * @throws IOException
-   */
-  private static int readHeaderFromStream(
-      final InputStream is,
-      final byte[] imageHeaderBytes)
-      throws IOException {
-    Preconditions.checkNotNull(is);
-    Preconditions.checkNotNull(imageHeaderBytes);
-    Preconditions.checkArgument(imageHeaderBytes.length >= MAX_HEADER_LENGTH);
-
-    // If mark is supported by the stream, use it to let the owner of the stream re-read the same
-    // data. Otherwise, just consume some data.
-    if (is.markSupported()) {
-      try {
-        is.mark(MAX_HEADER_LENGTH);
-        return ByteStreams.read(is, imageHeaderBytes, 0, MAX_HEADER_LENGTH);
-      } finally {
-        is.reset();
-      }
-    } else {
-      return ByteStreams.read(is, imageHeaderBytes, 0, MAX_HEADER_LENGTH);
+    /*
+     * A variant of getImageFormat that wraps IOException with RuntimeException.
+     * This relieves clients of implementing dummy rethrow try-catch block.
+     */
+    public static ImageFormat getImageFormat_WrapIOException(final InputStream is) {
+        try {
+            return getImageFormat(is);
+        } catch (IOException ioe) {
+            throw Throwables.propagate(ioe);
+        }
     }
-  }
-
-  /**
-   * Tries to read up to MAX_HEADER_LENGTH bytes from InputStream is and use read bytes to
-   * determine type of the image contained in is. If provided input stream does not support mark,
-   * then this method consumes data from is and it is not safe to read further bytes from is after
-   * this method returns. Otherwise, if mark is supported, it will be used to preserve oryginal
-   * content of is.
-   * @param is
-   * @return ImageFormat matching content of is InputStream or UNKNOWN if no type is suitable
-   * @throws IOException if exception happens during read
-   */
-  public static ImageFormat getImageFormat(final InputStream is) throws IOException {
-    Preconditions.checkNotNull(is);
-    final byte[] imageHeaderBytes = new byte[MAX_HEADER_LENGTH];
-    final int headerSize = readHeaderFromStream(is, imageHeaderBytes);
-    return doGetImageFormat(imageHeaderBytes, headerSize);
-  }
-
-  /*
-   * A variant of getImageFormat that wraps IOException with RuntimeException.
-   * This relieves clients of implementing dummy rethrow try-catch block.
-   */
-  public static ImageFormat getImageFormat_WrapIOException(final InputStream is) {
-    try {
-      return getImageFormat(is);
-    } catch (IOException ioe) {
-      throw Throwables.propagate(ioe);
+
+    /**
+     * Reads image header from a file indicated by provided filename and determines
+     * its format. This method does not throw IOException if one occurs. In this case,
+     * ImageFormat.UNKNOWN will be returned.
+     *
+     * @param filename
+     * @return ImageFormat for image stored in filename
+     */
+    public static ImageFormat getImageFormat(String filename) {
+        FileInputStream fileInputStream = null;
+        try {
+            fileInputStream = new FileInputStream(filename);
+            return getImageFormat(fileInputStream);
+        } catch (IOException ioe) {
+            return ImageFormat.UNKNOWN;
+        } finally {
+            Closeables.closeQuietly(fileInputStream);
+        }
+    }
+
+    /**
+     * Checks if byteArray interpreted as sequence of bytes has a subsequence equal to pattern
+     * starting at position equal to offset.
+     *
+     * @param byteArray
+     * @param offset
+     * @param pattern
+     * @return true if match succeeds, false otherwise
+     */
+    private static boolean matchBytePattern(
+            final byte[] byteArray,
+            final int offset,
+            final byte[] pattern) {
+        Preconditions.checkNotNull(byteArray);
+        Preconditions.checkNotNull(pattern);
+        Preconditions.checkArgument(offset >= 0);
+        if (pattern.length + offset > byteArray.length) {
+            return false;
+        }
+
+        for (int i = 0; i < pattern.length; ++i) {
+            if (byteArray[i + offset] != pattern[i]) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * Helper method that transforms provided string into it's byte representation
+     * using ASCII encoding
+     *
+     * @param value
+     * @return byte array representing ascii encoded value
+     */
+    private static byte[] asciiBytes(String value) {
+        Preconditions.checkNotNull(value);
+        try {
+            return value.getBytes("ASCII");
+        } catch (UnsupportedEncodingException uee) {
+            // won't happen
+            throw new RuntimeException("ASCII not found!", uee);
+        }
+    }
+
+
+    /**
+     * Each WebP header should cosist of at least 20 bytes and start
+     * with "RIFF" bytes followed by some 4 bytes and "WEBP" bytes.
+     * More detailed description if WebP can be found here:
+     * <a href="https://developers.google.com/speed/webp/docs/riff_container">
+     * https://developers.google.com/speed/webp/docs/riff_container</a>
+     */
+    private static final int SIMPLE_WEBP_HEADER_LENGTH = 20;
+
+    /**
+     * Each VP8X WebP image has "features" byte following its ChunkHeader('VP8X')
+     */
+    private static final int EXTENDED_WEBP_HEADER_LENGTH = 21;
+
+    private static final byte[] WEBP_RIFF_BYTES = asciiBytes("RIFF");
+    private static final byte[] WEBP_NAME_BYTES = asciiBytes("WEBP");
+
+    /**
+     * This is a constant used to detect different WebP's formats: vp8, vp8l and vp8x.
+     */
+    private static final byte[] WEBP_VP8_BYTES = asciiBytes("VP8 ");
+    private static final byte[] WEBP_VP8L_BYTES = asciiBytes("VP8L");
+    private static final byte[] WEBP_VP8X_BYTES = asciiBytes("VP8X");
+
+    /**
+     * Checks if a WebP image is animated one
+     *
+     * @param imageHeaderBytes - byte array containing valid WebP header
+     * @return true if imageHeaderBytes is a header of animated webp
+     */
+    private static boolean isAnimatedWebpHeader(final byte[] imageHeaderBytes) {
+        boolean isVp8x = matchBytePattern(imageHeaderBytes, 12, WEBP_VP8X_BYTES);
+        // ANIM is 2nd bit (00000010 == 2) on 21st byte (imageHeaderBytes[20])
+        boolean hasAnimationBit = (imageHeaderBytes[20] & 2) == 2;
+        return isVp8x && hasAnimationBit;
+    }
+
+    private static boolean isSimpleWebpHeader(final byte[] imageHeaderBytes) {
+        return matchBytePattern(imageHeaderBytes, 12, WEBP_VP8_BYTES);
     }
-  }
-
-  /**
-   * Reads image header from a file indicated by provided filename and determines
-   * its format. This method does not throw IOException if one occurs. In this case,
-   * ImageFormat.UNKNOWN will be returned.
-   * @param filename
-   * @return ImageFormat for image stored in filename
-   */
-  public static ImageFormat getImageFormat(String filename) {
-    FileInputStream fileInputStream = null;
-    try {
-      fileInputStream = new FileInputStream(filename);
-      return getImageFormat(fileInputStream);
-    } catch (IOException ioe) {
-      return ImageFormat.UNKNOWN;
-    } finally {
-      Closeables.closeQuietly(fileInputStream);
+
+    private static boolean isLosslessWebpHeader(final byte[] imageHeaderBytes) {
+        return matchBytePattern(imageHeaderBytes, 12, WEBP_VP8L_BYTES);
     }
-  }
-
-  /**
-   * Checks if byteArray interpreted as sequence of bytes has a subsequence equal to pattern
-   * starting at position equal to offset.
-   * @param byteArray
-   * @param offset
-   * @param pattern
-   * @return true if match succeeds, false otherwise
-   */
-  private static boolean matchBytePattern(
-      final byte[] byteArray,
-      final int offset,
-      final byte[] pattern) {
-    Preconditions.checkNotNull(byteArray);
-    Preconditions.checkNotNull(pattern);
-    Preconditions.checkArgument(offset >= 0);
-    if (pattern.length + offset > byteArray.length) {
-      return false;
+
+    private static boolean isExtendedWebpHeaderWithAlpha(final byte[] imageHeaderBytes) {
+        boolean isVp8x = matchBytePattern(imageHeaderBytes, 12, WEBP_VP8X_BYTES);
+        // Has ALPHA is 5th bit (00010000 == 16) on 21st byte (imageHeaderBytes[20])
+        boolean hasAlphaBit = (imageHeaderBytes[20] & 16) == 16;
+        return isVp8x && hasAlphaBit;
     }
 
-    for (int i = 0; i < pattern.length; ++i) {
-      if (byteArray[i + offset] != pattern[i]) {
-        return false;
-      }
+
+    private static boolean isExtendedWebpHeader(final byte[] imageHeaderBytes, final int headerSize) {
+        return headerSize >= EXTENDED_WEBP_HEADER_LENGTH &&
+                matchBytePattern(imageHeaderBytes, 12, WEBP_VP8X_BYTES);
     }
 
-    return true;
-  }
-
-  /**
-   * Helper method that transforms provided string into it's byte representation
-   * using ASCII encoding
-   * @param value
-   * @return byte array representing ascii encoded value
-   */
-  private static byte[] asciiBytes(String value) {
-    Preconditions.checkNotNull(value);
-    try {
-      return value.getBytes("ASCII");
-    } catch (UnsupportedEncodingException uee) {
-      // won't happen
-      throw new RuntimeException("ASCII not found!", uee);
+    /**
+     * Checks if imageHeaderBytes contains WEBP_RIFF_BYTES and WEBP_NAME_BYTES and if the
+     * header is long enough to be WebP's header.
+     * WebP file format can be found here:
+     * <a href="https://developers.google.com/speed/webp/docs/riff_container">
+     * https://developers.google.com/speed/webp/docs/riff_container</a>
+     *
+     * @param imageHeaderBytes
+     * @return true if imageHeaderBytes contains a valid webp header
+     */
+    private static boolean isWebpHeader(final byte[] imageHeaderBytes, final int headerSize) {
+        Preconditions.checkNotNull(imageHeaderBytes);
+        return headerSize >= SIMPLE_WEBP_HEADER_LENGTH &&
+                matchBytePattern(imageHeaderBytes, 0, WEBP_RIFF_BYTES) &&
+                matchBytePattern(imageHeaderBytes, 8, WEBP_NAME_BYTES);
     }
-  }
-
-
-  /**
-   * Each WebP header should cosist of at least 20 bytes and start
-   * with "RIFF" bytes followed by some 4 bytes and "WEBP" bytes.
-   * More detailed description if WebP can be found here:
-   * <a href="https://developers.google.com/speed/webp/docs/riff_container">
-   *   https://developers.google.com/speed/webp/docs/riff_container</a>
-   */
-  private static final int SIMPLE_WEBP_HEADER_LENGTH = 20;
-
-  /**
-   * Each VP8X WebP image has "features" byte following its ChunkHeader('VP8X')
-   */
-  private static final int EXTENDED_WEBP_HEADER_LENGTH = 21;
-
-  private static final byte[] WEBP_RIFF_BYTES = asciiBytes("RIFF");
-  private static final byte[] WEBP_NAME_BYTES = asciiBytes("WEBP");
-
-  /**
-   * This is a constant used to detect different WebP's formats: vp8, vp8l and vp8x.
-   */
-  private static final byte[] WEBP_VP8_BYTES = asciiBytes("VP8 ");
-  private static final byte[] WEBP_VP8L_BYTES = asciiBytes("VP8L");
-  private static final byte[] WEBP_VP8X_BYTES = asciiBytes("VP8X");
-
-  /**
-   * Checks if a WebP image is animated one
-   * @param imageHeaderBytes - byte array containing valid WebP header
-   * @return true if imageHeaderBytes is a header of animated webp
-   */
-  private static boolean isAnimatedWebpHeader(final byte[] imageHeaderBytes) {
-    boolean isVp8x = matchBytePattern(imageHeaderBytes, 12, WEBP_VP8X_BYTES);
-    // ANIM is 2nd bit (00000010 == 2) on 21st byte (imageHeaderBytes[20])
-    boolean hasAnimationBit = (imageHeaderBytes[20] & 2) == 2;
-    return isVp8x && hasAnimationBit;
-  }
-
-  private static boolean isSimpleWebpHeader(final byte[] imageHeaderBytes) {
-    return matchBytePattern(imageHeaderBytes, 12, WEBP_VP8_BYTES);
-  }
-
-  private static boolean isLosslessWebpHeader(final byte[] imageHeaderBytes) {
-    return matchBytePattern(imageHeaderBytes, 12, WEBP_VP8L_BYTES);
-  }
-
-  private static boolean isExtendedWebpHeaderWithAlpha(final byte[] imageHeaderBytes) {
-    boolean isVp8x = matchBytePattern(imageHeaderBytes, 12, WEBP_VP8X_BYTES);
-    // Has ALPHA is 5th bit (00010000 == 16) on 21st byte (imageHeaderBytes[20])
-    boolean hasAlphaBit = (imageHeaderBytes[20] & 16) == 16;
-    return isVp8x && hasAlphaBit;
-  }
-
-
-
-
-  private static boolean isExtendedWebpHeader(final byte[] imageHeaderBytes, final int headerSize) {
-    return headerSize >= EXTENDED_WEBP_HEADER_LENGTH &&
-        matchBytePattern(imageHeaderBytes, 12, WEBP_VP8X_BYTES);
-  }
-
-  /**
-   * Checks if imageHeaderBytes contains WEBP_RIFF_BYTES and WEBP_NAME_BYTES and if the
-   * header is long enough to be WebP's header.
-   * WebP file format can be found here:
-   * <a href="https://developers.google.com/speed/webp/docs/riff_container">
-   *   https://developers.google.com/speed/webp/docs/riff_container</a>
-   * @param imageHeaderBytes
-   * @return true if imageHeaderBytes contains a valid webp header
-   */
-  private static boolean isWebpHeader(final byte[] imageHeaderBytes, final int headerSize) {
-    Preconditions.checkNotNull(imageHeaderBytes);
-    return headerSize >= SIMPLE_WEBP_HEADER_LENGTH &&
-        matchBytePattern(imageHeaderBytes, 0, WEBP_RIFF_BYTES) &&
-        matchBytePattern(imageHeaderBytes, 8, WEBP_NAME_BYTES);
-  }
-
-  /**
-   * Determines type of WebP image. imageHeaderBytes has to be header of a WebP image
-   */
-  private static ImageFormat getWebpFormat(final byte[] imageHeaderBytes, final int headerSize) {
-    Preconditions.checkArgument(isWebpHeader(imageHeaderBytes, headerSize));
-    if (isSimpleWebpHeader(imageHeaderBytes)) {
-      return ImageFormat.WEBP_SIMPLE;
+
+    /**
+     * Determines type of WebP image. imageHeaderBytes has to be header of a WebP image
+     */
+    private static ImageFormat getWebpFormat(final byte[] imageHeaderBytes, final int headerSize) {
+        Preconditions.checkArgument(isWebpHeader(imageHeaderBytes, headerSize));
+        if (isSimpleWebpHeader(imageHeaderBytes)) {
+            return ImageFormat.WEBP_SIMPLE;
+        }
+
+        if (isLosslessWebpHeader(imageHeaderBytes)) {
+            return ImageFormat.WEBP_LOSSLESS;
+        }
+
+        if (isExtendedWebpHeader(imageHeaderBytes, headerSize)) {
+            if (isAnimatedWebpHeader(imageHeaderBytes)) {
+                return ImageFormat.WEBP_ANIMATED;
+            }
+            if (isExtendedWebpHeaderWithAlpha(imageHeaderBytes)) {
+                return ImageFormat.WEBP_EXTENDED_WITH_ALPHA;
+            }
+            return ImageFormat.WEBP_EXTENDED;
+        }
+
+        return ImageFormat.UNKNOWN;
     }
 
-    if (isLosslessWebpHeader(imageHeaderBytes)) {
-      return ImageFormat.WEBP_LOSSLESS;
+    /**
+     * Every JPEG image should start with SOI mark (0xFF, 0xD8) followed by beginning
+     * of another segment (0xFF)
+     */
+    private static final byte[] JPEG_HEADER = new byte[]{(byte) 0xFF, (byte) 0xD8, (byte) 0xFF};
+
+    /**
+     * Checks if imageHeaderBytes starts with SOI (start of image) marker, followed by 0xFF.
+     * If headerSize is lower than 3 false is returned.
+     * Description of jpeg format can be found here:
+     * <a href="http://www.w3.org/Graphics/JPEG/itu-t81.pdf">
+     * http://www.w3.org/Graphics/JPEG/itu-t81.pdf</a>
+     * Annex B deals with compressed data format
+     *
+     * @param imageHeaderBytes
+     * @param headerSize
+     * @return true if imageHeaderBytes starts with SOI_BYTES and headerSize >= 3
+     */
+    private static boolean isJpegHeader(final byte[] imageHeaderBytes, final int headerSize) {
+        return headerSize >= JPEG_HEADER.length && matchBytePattern(imageHeaderBytes, 0, JPEG_HEADER);
     }
 
-    if (isExtendedWebpHeader(imageHeaderBytes, headerSize)) {
-      if (isAnimatedWebpHeader(imageHeaderBytes)) {
-        return ImageFormat.WEBP_ANIMATED;
-      }
-      if (isExtendedWebpHeaderWithAlpha(imageHeaderBytes)) {
-        return ImageFormat.WEBP_EXTENDED_WITH_ALPHA;
-      }
-      return ImageFormat.WEBP_EXTENDED;
+
+    /**
+     * Every PNG image starts with 8 byte signature consisting of
+     * following bytes
+     */
+    private static final byte[] PNG_HEADER = new byte[]{
+            (byte) 0x89,
+            'P', 'N', 'G',
+            (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};
+
+    /**
+     * Checks if array consisting of first headerSize bytes of imageHeaderBytes
+     * starts with png signature. More information on PNG can be found there:
+     * <a href="http://en.wikipedia.org/wiki/Portable_Network_Graphics">
+     * http://en.wikipedia.org/wiki/Portable_Network_Graphics</a>
+     *
+     * @param imageHeaderBytes
+     * @param headerSize
+     * @return true if imageHeaderBytes starts with PNG_HEADER
+     */
+    private static boolean isPngHeader(final byte[] imageHeaderBytes, final int headerSize) {
+        return headerSize >= PNG_HEADER.length && matchBytePattern(imageHeaderBytes, 0, PNG_HEADER);
     }
 
-    return ImageFormat.UNKNOWN;
-  }
-
-  /**
-   * Every JPEG image should start with SOI mark (0xFF, 0xD8) followed by beginning
-   * of another segment (0xFF)
-   */
-  private static final byte[] JPEG_HEADER = new byte[] {(byte)0xFF, (byte)0xD8, (byte)0xFF};
-
-  /**
-   * Checks if imageHeaderBytes starts with SOI (start of image) marker, followed by 0xFF.
-   * If headerSize is lower than 3 false is returned.
-   * Description of jpeg format can be found here:
-   * <a href="http://www.w3.org/Graphics/JPEG/itu-t81.pdf">
-   *   http://www.w3.org/Graphics/JPEG/itu-t81.pdf</a>
-   * Annex B deals with compressed data format
-   * @param imageHeaderBytes
-   * @param headerSize
-   * @return true if imageHeaderBytes starts with SOI_BYTES and headerSize >= 3
-   */
-  private static boolean isJpegHeader(final byte[] imageHeaderBytes, final int headerSize) {
-    return headerSize >= JPEG_HEADER.length && matchBytePattern(imageHeaderBytes, 0, JPEG_HEADER);
-  }
-
-
-  /**
-   * Every PNG image starts with 8 byte signature consisting of
-   * following bytes
-   */
-  private static final byte[] PNG_HEADER = new byte[] {
-      (byte) 0x89,
-      'P', 'N', 'G',
-      (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};
-
-  /**
-   * Checks if array consisting of first headerSize bytes of imageHeaderBytes
-   * starts with png signature. More information on PNG can be found there:
-   * <a href="http://en.wikipedia.org/wiki/Portable_Network_Graphics">
-   *   http://en.wikipedia.org/wiki/Portable_Network_Graphics</a>
-   * @param imageHeaderBytes
-   * @param headerSize
-   * @return true if imageHeaderBytes starts with PNG_HEADER
-   */
-  private static boolean isPngHeader(final byte[] imageHeaderBytes, final int headerSize) {
-    return headerSize >= PNG_HEADER.length && matchBytePattern(imageHeaderBytes, 0, PNG_HEADER);
-  }
-
-
-  /**
-   * Every gif image starts with "GIF" bytes followed by
-   * bytes indicating version of gif standard
-   */
-  private static final byte[] GIF_HEADER_87A = asciiBytes("GIF87a");
-  private static final byte[] GIF_HEADER_89A = asciiBytes("GIF89a");
-  private static final int GIF_HEADER_LENGTH = 6;
-
-  /**
-   * Checks if first headerSize bytes of imageHeaderBytes constitute a valid header for a gif image.
-   * Details on GIF header can be found <a href="http://www.w3.org/Graphics/GIF/spec-gif89a.txt">
-   *  on page 7</a>
-   * @param imageHeaderBytes
-   * @param headerSize
-   * @return true if imageHeaderBytes is a valid header for a gif image
-   */
-  private static boolean isGifHeader(final byte[] imageHeaderBytes, final int headerSize) {
-    if (headerSize < GIF_HEADER_LENGTH) {
-      return false;
+
+    /**
+     * Every gif image starts with "GIF" bytes followed by
+     * bytes indicating version of gif standard
+     */
+    private static final byte[] GIF_HEADER_87A = asciiBytes("GIF87a");
+    private static final byte[] GIF_HEADER_89A = asciiBytes("GIF89a");
+    private static final int GIF_HEADER_LENGTH = 6;
+
+    /**
+     * Checks if first headerSize bytes of imageHeaderBytes constitute a valid header for a gif image.
+     * Details on GIF header can be found <a href="http://www.w3.org/Graphics/GIF/spec-gif89a.txt">
+     * on page 7</a>
+     *
+     * @param imageHeaderBytes
+     * @param headerSize
+     * @return true if imageHeaderBytes is a valid header for a gif image
+     */
+    private static boolean isGifHeader(final byte[] imageHeaderBytes, final int headerSize) {
+        if (headerSize < GIF_HEADER_LENGTH) {
+            return false;
+        }
+        return matchBytePattern(imageHeaderBytes, 0, GIF_HEADER_87A) ||
+                matchBytePattern(imageHeaderBytes, 0, GIF_HEADER_89A);
     }
-    return matchBytePattern(imageHeaderBytes, 0, GIF_HEADER_87A) ||
-        matchBytePattern(imageHeaderBytes, 0, GIF_HEADER_89A);
-  }
-
-
-  /**
-   * Maximum header size for any image type.
-   *
-   * <p>This determines how much data {@link #getImageFormat(InputStream)
-   * reads from a stream. After changing any of the type detection algorithms, or adding a new one,
-   * this value should be edited.
-   */
-  private static final int MAX_HEADER_LENGTH = Ints.max(
-      EXTENDED_WEBP_HEADER_LENGTH,
-      SIMPLE_WEBP_HEADER_LENGTH,
-      JPEG_HEADER.length,
-      PNG_HEADER.length,
-      GIF_HEADER_LENGTH);
+
+
+    /**
+     * Maximum header size for any image type.
+     * <p>
+     * <p>This determines how much data {@link #getImageFormat(InputStream)
+     * reads from a stream. After changing any of the type detection algorithms, or adding a new one,
+     * this value should be edited.
+     */
+    private static final int MAX_HEADER_LENGTH = Ints.max(
+            EXTENDED_WEBP_HEADER_LENGTH,
+            SIMPLE_WEBP_HEADER_LENGTH,
+            JPEG_HEADER.length,
+            PNG_HEADER.length,
+            GIF_HEADER_LENGTH);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawable.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawable.java
index 2fbd8796f..3e7110ccb 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawable.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatableDrawable.java
@@ -18,27 +18,28 @@
  */
 public interface AnimatableDrawable extends Animatable {
 
-  /**
-   * An animator that will animate the drawable directly. The loop count and duration will
-   * be determined by metadata in the original image. Update listener is attached automatically.
-   *
-   * @return a new animator
-   */
-  ValueAnimator createValueAnimator();
+    /**
+     * An animator that will animate the drawable directly. The loop count and duration will
+     * be determined by metadata in the original image. Update listener is attached automatically.
+     *
+     * @return a new animator
+     */
+    ValueAnimator createValueAnimator();
 
-  /**
-   * An animator that will animate the drawable directly. The loop count will be set based on
-   * the specified duration. Update listener is attached automatically.
-   *
-   * @param maxDurationMs maximum duration animate
-   * @return a new animator
-   */
-  ValueAnimator createValueAnimator(int maxDurationMs);
+    /**
+     * An animator that will animate the drawable directly. The loop count will be set based on
+     * the specified duration. Update listener is attached automatically.
+     *
+     * @param maxDurationMs maximum duration animate
+     * @return a new animator
+     */
+    ValueAnimator createValueAnimator(int maxDurationMs);
 
-  /**
-   * Creates an animator update listener that will animate the drawable directly. This is useful
-   * when the drawable needs to be animated by an existing value animator.
-   * @return a new update listener
-   */
-  ValueAnimator.AnimatorUpdateListener createAnimatorUpdateListener();
+    /**
+     * Creates an animator update listener that will animate the drawable directly. This is useful
+     * when the drawable needs to be animated by an existing value animator.
+     *
+     * @return a new update listener
+     */
+    ValueAnimator.AnimatorUpdateListener createAnimatorUpdateListener();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawable.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawable.java
index 9937f4b47..206107fdb 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawable.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawable.java
@@ -39,553 +39,553 @@
  */
 public class AnimatedDrawable extends Drawable implements AnimatableDrawable, DrawableWithCaches {
 
-  private static final Class<?> TAG = AnimatedDrawable.class;
+    private static final Class<?> TAG = AnimatedDrawable.class;
 
-  private static final long WATCH_DOG_TIMER_POLL_INTERVAL_MS = 2000;
-  private static final long WATCH_DOG_TIMER_MIN_TIMEOUT_MS = 1000;
+    private static final long WATCH_DOG_TIMER_POLL_INTERVAL_MS = 2000;
+    private static final long WATCH_DOG_TIMER_MIN_TIMEOUT_MS = 1000;
 
-  private static final int POLL_FOR_RENDERED_FRAME_MS = 5;
-  private static final int NO_FRAME = -1;
+    private static final int POLL_FOR_RENDERED_FRAME_MS = 5;
+    private static final int NO_FRAME = -1;
 
-  private final ScheduledExecutorService mScheduledExecutorServiceForUiThread;
-  private final AnimatedDrawableDiagnostics mAnimatedDrawableDiagnostics;
-  private final MonotonicClock mMonotonicClock;
-  private final int mDurationMs;
-  private final int mFrameCount;
+    private final ScheduledExecutorService mScheduledExecutorServiceForUiThread;
+    private final AnimatedDrawableDiagnostics mAnimatedDrawableDiagnostics;
+    private final MonotonicClock mMonotonicClock;
+    private final int mDurationMs;
+    private final int mFrameCount;
 
-  // Paint used to draw on a Canvas
-  private final Paint mPaint = new Paint(Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG);
-  private final Rect mDstRect = new Rect();
-  private final Paint mTransparentPaint;
+    // Paint used to draw on a Canvas
+    private final Paint mPaint = new Paint(Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG);
+    private final Rect mDstRect = new Rect();
+    private final Paint mTransparentPaint;
 
-  private volatile String mLogId;
+    private volatile String mLogId;
 
-  private AnimatedDrawableCachingBackend mAnimatedDrawableBackend;
-  private long mStartTimeMs;
+    private AnimatedDrawableCachingBackend mAnimatedDrawableBackend;
+    private long mStartTimeMs;
 
-  // Index of frame scheduled to be drawn. Between 0 and mFrameCount - 1
-  private int mScheduledFrameNumber;
+    // Index of frame scheduled to be drawn. Between 0 and mFrameCount - 1
+    private int mScheduledFrameNumber;
 
-  // Index of frame scheduled to be drawn but never is reset to zero. Keeps growing.
-  private int mScheduledFrameMonotonicNumber;
+    // Index of frame scheduled to be drawn but never is reset to zero. Keeps growing.
+    private int mScheduledFrameMonotonicNumber;
 
-  // Index of frame that will be drawn next. Between 0 and mFrameCount - 1. May fall behind
-  // mScheduledFrameIndex if we can't keep up.
-  private int mPendingRenderedFrameNumber;
+    // Index of frame that will be drawn next. Between 0 and mFrameCount - 1. May fall behind
+    // mScheduledFrameIndex if we can't keep up.
+    private int mPendingRenderedFrameNumber;
 
-  // Corresponds to mPendingRenderedFrameNumber but keeps growing.
-  private int mPendingRenderedFrameMonotonicNumber;
+    // Corresponds to mPendingRenderedFrameNumber but keeps growing.
+    private int mPendingRenderedFrameMonotonicNumber;
 
-  // Index of last frame that was drawn.
-  private int mLastDrawnFrameNumber = -1;
+    // Index of last frame that was drawn.
+    private int mLastDrawnFrameNumber = -1;
 
-  // Corresponds to mLastDrawnFrameNumber but keeps growing.
-  private int mLastDrawnFrameMonotonicNumber = -1;
+    // Corresponds to mLastDrawnFrameNumber but keeps growing.
+    private int mLastDrawnFrameMonotonicNumber = -1;
 
-  // Bitmap for last drawn frame. Corresponds to mLastDrawnFrameNumber.
-  private CloseableReference<Bitmap> mLastDrawnFrame;
+    // Bitmap for last drawn frame. Corresponds to mLastDrawnFrameNumber.
+    private CloseableReference<Bitmap> mLastDrawnFrame;
 
-  private boolean mWaitingForDraw;
-  private long mLastInvalidateTimeMs = -1;
+    private boolean mWaitingForDraw;
+    private long mLastInvalidateTimeMs = -1;
 
-  private boolean mIsRunning;
-  private boolean mHaveWatchdogScheduled;
+    private boolean mIsRunning;
+    private boolean mHaveWatchdogScheduled;
 
-  private float mSx = 1f;
-  private float mSy = 1f;
-  private boolean mApplyTransformation;
-  private boolean mInvalidateTaskScheduled;
-  private long mNextFrameTaskMs = -1;
+    private float mSx = 1f;
+    private float mSy = 1f;
+    private boolean mApplyTransformation;
+    private boolean mInvalidateTaskScheduled;
+    private long mNextFrameTaskMs = -1;
 
-  private final Runnable mStartTask = new Runnable() {
-    @Override
-    public void run() {
-      onStart();
+    private final Runnable mStartTask = new Runnable() {
+        @Override
+        public void run() {
+            onStart();
+        }
+    };
+
+    private final Runnable mNextFrameTask = new Runnable() {
+        @Override
+        public void run() {
+            FLog.v(TAG, "(%s) Next Frame Task", mLogId);
+            onNextFrame();
+        }
+    };
+
+    private final Runnable mInvalidateTask = new Runnable() {
+        @Override
+        public void run() {
+            FLog.v(TAG, "(%s) Invalidate Task", mLogId);
+            mInvalidateTaskScheduled = false;
+            doInvalidateSelf();
+        }
+    };
+
+    private final Runnable mWatchdogTask = new Runnable() {
+        @Override
+        public void run() {
+            FLog.v(TAG, "(%s) Watchdog Task", mLogId);
+            doWatchdogCheck();
+        }
+    };
+
+    public AnimatedDrawable(
+            ScheduledExecutorService scheduledExecutorServiceForUiThread,
+            AnimatedDrawableCachingBackend animatedDrawableBackend,
+            AnimatedDrawableDiagnostics animatedDrawableDiagnostics,
+            MonotonicClock monotonicClock) {
+        mScheduledExecutorServiceForUiThread = scheduledExecutorServiceForUiThread;
+        mAnimatedDrawableBackend = animatedDrawableBackend;
+        mAnimatedDrawableDiagnostics = animatedDrawableDiagnostics;
+        mMonotonicClock = monotonicClock;
+        mDurationMs = mAnimatedDrawableBackend.getDurationMs();
+        mFrameCount = mAnimatedDrawableBackend.getFrameCount();
+        mAnimatedDrawableDiagnostics.setBackend(mAnimatedDrawableBackend);
+        mTransparentPaint = new Paint();
+        mTransparentPaint.setColor(Color.TRANSPARENT);
+        mTransparentPaint.setStyle(Paint.Style.FILL);
+
+        // Show last frame when not animating.
+        resetToPreviewFrame();
+    }
+
+    private void resetToPreviewFrame() {
+        mScheduledFrameNumber = mAnimatedDrawableBackend.getFrameForPreview();
+        mScheduledFrameMonotonicNumber = mScheduledFrameNumber;
+        mPendingRenderedFrameNumber = NO_FRAME;
+        mPendingRenderedFrameMonotonicNumber = NO_FRAME;
     }
-  };
 
-  private final Runnable mNextFrameTask = new Runnable() {
     @Override
-    public void run() {
-      FLog.v(TAG, "(%s) Next Frame Task", mLogId);
-      onNextFrame();
+    protected void finalize() throws Throwable {
+        super.finalize();
+        if (mLastDrawnFrame != null) {
+            mLastDrawnFrame.close();
+            mLastDrawnFrame = null;
+        }
+    }
+
+    /**
+     * Sets an id that will be logged with any of the logging calls. Useful for debugging.
+     *
+     * @param logId the id to log
+     */
+    public void setLogId(String logId) {
+        mLogId = logId;
     }
-  };
 
-  private final Runnable mInvalidateTask = new Runnable() {
     @Override
-    public void run() {
-      FLog.v(TAG, "(%s) Invalidate Task", mLogId);
-      mInvalidateTaskScheduled = false;
-      doInvalidateSelf();
+    public int getIntrinsicWidth() {
+        return mAnimatedDrawableBackend.getWidth();
     }
-  };
 
-  private final Runnable mWatchdogTask = new Runnable() {
     @Override
-    public void run() {
-      FLog.v(TAG, "(%s) Watchdog Task", mLogId);
-      doWatchdogCheck();
+    public int getIntrinsicHeight() {
+        return mAnimatedDrawableBackend.getHeight();
     }
-  };
-
-  public AnimatedDrawable(
-      ScheduledExecutorService scheduledExecutorServiceForUiThread,
-      AnimatedDrawableCachingBackend animatedDrawableBackend,
-      AnimatedDrawableDiagnostics animatedDrawableDiagnostics,
-      MonotonicClock monotonicClock) {
-    mScheduledExecutorServiceForUiThread = scheduledExecutorServiceForUiThread;
-    mAnimatedDrawableBackend = animatedDrawableBackend;
-    mAnimatedDrawableDiagnostics = animatedDrawableDiagnostics;
-    mMonotonicClock = monotonicClock;
-    mDurationMs = mAnimatedDrawableBackend.getDurationMs();
-    mFrameCount = mAnimatedDrawableBackend.getFrameCount();
-    mAnimatedDrawableDiagnostics.setBackend(mAnimatedDrawableBackend);
-    mTransparentPaint = new Paint();
-    mTransparentPaint.setColor(Color.TRANSPARENT);
-    mTransparentPaint.setStyle(Paint.Style.FILL);
-
-    // Show last frame when not animating.
-    resetToPreviewFrame();
-  }
-
-  private void resetToPreviewFrame() {
-    mScheduledFrameNumber = mAnimatedDrawableBackend.getFrameForPreview();
-    mScheduledFrameMonotonicNumber = mScheduledFrameNumber;
-    mPendingRenderedFrameNumber = NO_FRAME;
-    mPendingRenderedFrameMonotonicNumber = NO_FRAME;
-  }
-
-  @Override
-  protected void finalize() throws Throwable {
-    super.finalize();
-    if (mLastDrawnFrame != null) {
-      mLastDrawnFrame.close();
-      mLastDrawnFrame = null;
+
+    @Override
+    public void setAlpha(int alpha) {
+        mPaint.setAlpha(alpha);
+        doInvalidateSelf();
     }
-  }
-
-  /**
-   * Sets an id that will be logged with any of the logging calls. Useful for debugging.
-   *
-   * @param logId the id to log
-   */
-  public void setLogId(String logId) {
-    mLogId = logId;
-  }
-
-  @Override
-  public int getIntrinsicWidth() {
-    return mAnimatedDrawableBackend.getWidth();
-  }
-
-  @Override
-  public int getIntrinsicHeight() {
-    return mAnimatedDrawableBackend.getHeight();
-  }
-
-  @Override
-  public void setAlpha(int alpha) {
-    mPaint.setAlpha(alpha);
-    doInvalidateSelf();
-  }
-
-  @Override
-  public void setColorFilter(ColorFilter cf) {
-    mPaint.setColorFilter(cf);
-    doInvalidateSelf();
-  }
-
-  @Override
-  public int getOpacity() {
-    return PixelFormat.TRANSLUCENT;
-  }
-
-  @Override
-  protected void onBoundsChange(Rect bounds) {
-    super.onBoundsChange(bounds);
-    mApplyTransformation = true;
-    if (mLastDrawnFrame != null) {
-      mLastDrawnFrame.close();
-      mLastDrawnFrame = null;
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        mPaint.setColorFilter(cf);
+        doInvalidateSelf();
     }
-    mLastDrawnFrameNumber = -1;
-    mLastDrawnFrameMonotonicNumber = -1;
-    mAnimatedDrawableBackend.dropCaches();
-  }
-
-  private void onStart() {
-    if (!mIsRunning) {
-      return;
+
+    @Override
+    public int getOpacity() {
+        return PixelFormat.TRANSLUCENT;
     }
-    mAnimatedDrawableDiagnostics.onStartMethodBegin();
-    try {
-      mStartTimeMs = mMonotonicClock.now();
-      mScheduledFrameNumber = 0;
-      mScheduledFrameMonotonicNumber = 0;
-      long nextFrameMs = mStartTimeMs + mAnimatedDrawableBackend.getDurationMsForFrame(0);
-      scheduleSelf(mNextFrameTask, nextFrameMs);
-      mNextFrameTaskMs = nextFrameMs;
-      doInvalidateSelf();
-    } finally {
-      mAnimatedDrawableDiagnostics.onStartMethodEnd();
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        mApplyTransformation = true;
+        if (mLastDrawnFrame != null) {
+            mLastDrawnFrame.close();
+            mLastDrawnFrame = null;
+        }
+        mLastDrawnFrameNumber = -1;
+        mLastDrawnFrameMonotonicNumber = -1;
+        mAnimatedDrawableBackend.dropCaches();
     }
-  }
 
-  private void onNextFrame() {
-    mNextFrameTaskMs = -1;
-    if (!mIsRunning) {
-      return;
+    private void onStart() {
+        if (!mIsRunning) {
+            return;
+        }
+        mAnimatedDrawableDiagnostics.onStartMethodBegin();
+        try {
+            mStartTimeMs = mMonotonicClock.now();
+            mScheduledFrameNumber = 0;
+            mScheduledFrameMonotonicNumber = 0;
+            long nextFrameMs = mStartTimeMs + mAnimatedDrawableBackend.getDurationMsForFrame(0);
+            scheduleSelf(mNextFrameTask, nextFrameMs);
+            mNextFrameTaskMs = nextFrameMs;
+            doInvalidateSelf();
+        } finally {
+            mAnimatedDrawableDiagnostics.onStartMethodEnd();
+        }
     }
-    if (mDurationMs == 0) {
-      return;
+
+    private void onNextFrame() {
+        mNextFrameTaskMs = -1;
+        if (!mIsRunning) {
+            return;
+        }
+        if (mDurationMs == 0) {
+            return;
+        }
+        mAnimatedDrawableDiagnostics.onNextFrameMethodBegin();
+        try {
+            computeAndScheduleNextFrame(true /* schedule next frame */);
+        } finally {
+            mAnimatedDrawableDiagnostics.onNextFrameMethodEnd();
+        }
     }
-    mAnimatedDrawableDiagnostics.onNextFrameMethodBegin();
-    try {
-      computeAndScheduleNextFrame(true /* schedule next frame */);
-    } finally {
-      mAnimatedDrawableDiagnostics.onNextFrameMethodEnd();
+
+    private void computeAndScheduleNextFrame(boolean scheduleNextFrame) {
+        if (mDurationMs == 0) {
+            return;
+        }
+        long nowMs = mMonotonicClock.now();
+        int loops = (int) ((nowMs - mStartTimeMs) / mDurationMs);
+        int timestampMs = (int) ((nowMs - mStartTimeMs) % mDurationMs);
+        int newCurrentFrameNumber = mAnimatedDrawableBackend.getFrameForTimestampMs(timestampMs);
+        boolean changed = mScheduledFrameNumber != newCurrentFrameNumber;
+        mScheduledFrameNumber = newCurrentFrameNumber;
+        mScheduledFrameMonotonicNumber = loops * mFrameCount + newCurrentFrameNumber;
+
+        if (!scheduleNextFrame) {
+            // We're about to draw. We don't need to schedule anything because we're going to draw
+            // that frame right now. the onDraw method just wants to make sure the current frame is set.
+            return;
+        }
+
+        if (changed) {
+            doInvalidateSelf();
+        } else {
+            int durationMs = mAnimatedDrawableBackend.getTimestampMsForFrame(mScheduledFrameNumber) +
+                    mAnimatedDrawableBackend.getDurationMsForFrame(mScheduledFrameNumber) -
+                    timestampMs;
+            int nextFrame = (mScheduledFrameNumber + 1) % mFrameCount;
+            long nextFrameMs = nowMs + durationMs;
+            if (mNextFrameTaskMs == -1 || mNextFrameTaskMs > nextFrameMs) {
+                FLog.v(TAG, "(%s) Next frame (%d) in %d ms", mLogId, nextFrame, durationMs);
+                unscheduleSelf(mNextFrameTask); // Cancel any existing task.
+                scheduleSelf(mNextFrameTask, nextFrameMs);
+                mNextFrameTaskMs = nextFrameMs;
+            }
+        }
     }
-  }
 
-  private void computeAndScheduleNextFrame(boolean scheduleNextFrame) {
-    if (mDurationMs == 0) {
-      return;
+    @Override
+    public void draw(Canvas canvas) {
+        mAnimatedDrawableDiagnostics.onDrawMethodBegin();
+        try {
+            mWaitingForDraw = false;
+            if (mIsRunning && !mHaveWatchdogScheduled) {
+                mScheduledExecutorServiceForUiThread.schedule(
+                        mWatchdogTask,
+                        WATCH_DOG_TIMER_POLL_INTERVAL_MS,
+                        TimeUnit.MILLISECONDS);
+                mHaveWatchdogScheduled = true;
+            }
+
+            if (mApplyTransformation) {
+                mDstRect.set(getBounds());
+                if (!mDstRect.isEmpty()) {
+                    AnimatedDrawableCachingBackend newBackend =
+                            mAnimatedDrawableBackend.forNewBounds(mDstRect);
+                    if (newBackend != mAnimatedDrawableBackend) {
+                        mAnimatedDrawableBackend.dropCaches();
+                        mAnimatedDrawableBackend = newBackend;
+                        mAnimatedDrawableDiagnostics.setBackend(newBackend);
+                    }
+                    mSx = (float) mDstRect.width() / mAnimatedDrawableBackend.getRenderedWidth();
+                    mSy = (float) mDstRect.height() / mAnimatedDrawableBackend.getRenderedHeight();
+                    mApplyTransformation = false;
+                }
+            }
+
+            if (mDstRect.isEmpty()) {
+                // Don't try to draw if the dest rect is empty.
+                return;
+            }
+
+            canvas.save();
+            canvas.scale(mSx, mSy);
+
+            // TODO(6169940) we overdraw if both pending frame is ready and current frame is ready.
+            boolean didDrawFrame = false;
+            if (mPendingRenderedFrameNumber != NO_FRAME) {
+                // We tried to render a frame and it wasn't yet ready. See if it's ready now.
+                boolean rendered =
+                        renderFrame(canvas, mPendingRenderedFrameNumber, mPendingRenderedFrameMonotonicNumber);
+                didDrawFrame |= rendered;
+                if (rendered) {
+                    FLog.v(TAG, "(%s) Rendered pending frame %d", mLogId, mPendingRenderedFrameNumber);
+                    mPendingRenderedFrameNumber = NO_FRAME;
+                    mPendingRenderedFrameMonotonicNumber = NO_FRAME;
+                } else {
+                    // Try again later.
+                    FLog.v(TAG, "(%s) Trying again later for pending %d", mLogId, mPendingRenderedFrameNumber);
+                    scheduleInvalidatePoll();
+                }
+            }
+
+            if (mPendingRenderedFrameNumber == NO_FRAME) {
+                // We don't have a frame that's pending so render the current frame.
+                if (mIsRunning) {
+                    computeAndScheduleNextFrame(false /* don't schedule yet */);
+                }
+                boolean rendered = renderFrame(
+                        canvas,
+                        mScheduledFrameNumber,
+                        mScheduledFrameMonotonicNumber);
+                didDrawFrame |= rendered;
+                if (rendered) {
+                    FLog.v(TAG, "(%s) Rendered current frame %d", mLogId, mScheduledFrameNumber);
+                    if (mIsRunning) {
+                        computeAndScheduleNextFrame(true /* schedule next frame */);
+                    }
+                } else {
+                    FLog.v(TAG, "(%s) Trying again later for current %d", mLogId, mScheduledFrameNumber);
+                    mPendingRenderedFrameNumber = mScheduledFrameNumber;
+                    mPendingRenderedFrameMonotonicNumber = mScheduledFrameMonotonicNumber;
+                    scheduleInvalidatePoll();
+                }
+            }
+
+            if (!didDrawFrame) {
+                if (mLastDrawnFrame != null) {
+                    canvas.drawBitmap(mLastDrawnFrame.get(), 0f, 0f, mPaint);
+                    didDrawFrame = true;
+                    FLog.v(TAG, "(%s) Rendered last known frame %d", mLogId, mLastDrawnFrameNumber);
+                }
+            }
+
+            if (!didDrawFrame) {
+                // Last ditch effort, use preview bitmap.
+                CloseableReference<Bitmap> previewBitmapReference =
+                        mAnimatedDrawableBackend.getPreviewBitmap();
+                if (previewBitmapReference != null) {
+                    canvas.drawBitmap(previewBitmapReference.get(), 0f, 0f, mPaint);
+                    previewBitmapReference.close();
+                    FLog.v(TAG, "(%s) Rendered preview frame", mLogId);
+                    didDrawFrame = true;
+                }
+            }
+
+            if (!didDrawFrame) {
+                // TODO(6169940) this may not be necessary. Confirm with Rich.
+                canvas.drawRect(0, 0, mDstRect.width(), mDstRect.height(), mTransparentPaint);
+                FLog.v(TAG, "(%s) Failed to draw a frame", mLogId);
+            }
+
+            canvas.restore();
+            mAnimatedDrawableDiagnostics.drawDebugOverlay(canvas, mDstRect);
+        } finally {
+            mAnimatedDrawableDiagnostics.onDrawMethodEnd();
+        }
     }
-    long nowMs = mMonotonicClock.now();
-    int loops = (int) ((nowMs - mStartTimeMs) / mDurationMs);
-    int timestampMs = (int) ((nowMs - mStartTimeMs) % mDurationMs);
-    int newCurrentFrameNumber = mAnimatedDrawableBackend.getFrameForTimestampMs(timestampMs);
-    boolean changed = mScheduledFrameNumber != newCurrentFrameNumber;
-    mScheduledFrameNumber = newCurrentFrameNumber;
-    mScheduledFrameMonotonicNumber = loops * mFrameCount + newCurrentFrameNumber;
-
-    if (!scheduleNextFrame) {
-      // We're about to draw. We don't need to schedule anything because we're going to draw
-      // that frame right now. the onDraw method just wants to make sure the current frame is set.
-      return;
+
+    /**
+     * Schedule a task to invalidate the drawable. Used to poll for a rendered frame.
+     */
+    private void scheduleInvalidatePoll() {
+        if (mInvalidateTaskScheduled) {
+            return;
+        }
+        mInvalidateTaskScheduled = true;
+        scheduleSelf(mInvalidateTask, POLL_FOR_RENDERED_FRAME_MS);
     }
 
-    if (changed) {
-      doInvalidateSelf();
-    } else {
-      int durationMs = mAnimatedDrawableBackend.getTimestampMsForFrame(mScheduledFrameNumber) +
-          mAnimatedDrawableBackend.getDurationMsForFrame(mScheduledFrameNumber) -
-          timestampMs;
-      int nextFrame = (mScheduledFrameNumber + 1) % mFrameCount;
-      long nextFrameMs = nowMs + durationMs;
-      if (mNextFrameTaskMs == -1 || mNextFrameTaskMs > nextFrameMs) {
-        FLog.v(TAG, "(%s) Next frame (%d) in %d ms", mLogId, nextFrame, durationMs);
-        unscheduleSelf(mNextFrameTask); // Cancel any existing task.
-        scheduleSelf(mNextFrameTask, nextFrameMs);
-        mNextFrameTaskMs = nextFrameMs;
-      }
+    /**
+     * Returns whether a previous call to {@link #draw} would have rendered a frame.
+     *
+     * @return whether a previous call to {@link #draw} would have rendered a frame
+     */
+    public boolean didLastDrawRender() {
+        return mLastDrawnFrame != null;
     }
-  }
-
-  @Override
-  public void draw(Canvas canvas) {
-    mAnimatedDrawableDiagnostics.onDrawMethodBegin();
-    try {
-      mWaitingForDraw = false;
-      if (mIsRunning && !mHaveWatchdogScheduled) {
-        mScheduledExecutorServiceForUiThread.schedule(
-            mWatchdogTask,
-            WATCH_DOG_TIMER_POLL_INTERVAL_MS,
-            TimeUnit.MILLISECONDS);
-        mHaveWatchdogScheduled = true;
-      }
-
-      if (mApplyTransformation) {
-        mDstRect.set(getBounds());
-        if (!mDstRect.isEmpty()) {
-          AnimatedDrawableCachingBackend newBackend =
-              mAnimatedDrawableBackend.forNewBounds(mDstRect);
-          if (newBackend != mAnimatedDrawableBackend) {
-            mAnimatedDrawableBackend.dropCaches();
-            mAnimatedDrawableBackend = newBackend;
-            mAnimatedDrawableDiagnostics.setBackend(newBackend);
-          }
-          mSx = (float) mDstRect.width() / mAnimatedDrawableBackend.getRenderedWidth();
-          mSy = (float) mDstRect.height() / mAnimatedDrawableBackend.getRenderedHeight();
-          mApplyTransformation = false;
-        }
-      }
-
-      if (mDstRect.isEmpty()) {
-        // Don't try to draw if the dest rect is empty.
-        return;
-      }
-
-      canvas.save();
-      canvas.scale(mSx, mSy);
-
-      // TODO(6169940) we overdraw if both pending frame is ready and current frame is ready.
-      boolean didDrawFrame = false;
-      if (mPendingRenderedFrameNumber != NO_FRAME) {
-        // We tried to render a frame and it wasn't yet ready. See if it's ready now.
-        boolean rendered =
-            renderFrame(canvas, mPendingRenderedFrameNumber, mPendingRenderedFrameMonotonicNumber);
-        didDrawFrame |= rendered;
-        if (rendered) {
-          FLog.v(TAG, "(%s) Rendered pending frame %d", mLogId, mPendingRenderedFrameNumber);
-          mPendingRenderedFrameNumber = NO_FRAME;
-          mPendingRenderedFrameMonotonicNumber = NO_FRAME;
-        } else {
-          // Try again later.
-          FLog.v(TAG, "(%s) Trying again later for pending %d", mLogId, mPendingRenderedFrameNumber);
-          scheduleInvalidatePoll();
+
+    /**
+     * Renders the specified frame to the canvas.
+     *
+     * @param canvas               the canvas to render to
+     * @param frameNumber          the relative frame number (between 0 and frame count)
+     * @param frameMonotonicNumber the absolute frame number for stats purposes
+     * @return whether the frame was available and was rendered
+     */
+    private boolean renderFrame(
+            Canvas canvas,
+            int frameNumber,
+            int frameMonotonicNumber) {
+        CloseableReference<Bitmap> bitmapReference =
+                mAnimatedDrawableBackend.getBitmapForFrame(frameNumber);
+        if (bitmapReference != null) {
+            canvas.drawBitmap(bitmapReference.get(), 0f, 0f, mPaint);
+            if (mLastDrawnFrame != null) {
+                mLastDrawnFrame.close();
+            }
+
+            if (mIsRunning && frameMonotonicNumber > mLastDrawnFrameMonotonicNumber) {
+                int droppedFrames = frameMonotonicNumber - mLastDrawnFrameMonotonicNumber - 1;
+                mAnimatedDrawableDiagnostics.incrementDrawnFrames(1);
+                mAnimatedDrawableDiagnostics.incrementDroppedFrames(droppedFrames);
+                if (droppedFrames > 0) {
+                    FLog.v(TAG, "(%s) Dropped %d frames", mLogId, droppedFrames);
+                }
+            }
+            mLastDrawnFrame = bitmapReference;
+            mLastDrawnFrameNumber = frameNumber;
+            mLastDrawnFrameMonotonicNumber = frameMonotonicNumber;
+            FLog.v(TAG, "(%s) Drew frame %d", mLogId, frameNumber);
+            return true;
         }
-      }
+        return false;
+    }
 
-      if (mPendingRenderedFrameNumber == NO_FRAME) {
-        // We don't have a frame that's pending so render the current frame.
-        if (mIsRunning) {
-          computeAndScheduleNextFrame(false /* don't schedule yet */);
+    /**
+     * Checks to make sure we drop our caches if we haven't drawn in a while. There's no reliable
+     * way for a Drawable to determine if it's still actively part of a View, so we use a heuristic
+     * instead.
+     */
+    private void doWatchdogCheck() {
+        mHaveWatchdogScheduled = false;
+        if (!mIsRunning) {
+            return;
         }
-        boolean rendered = renderFrame(
-            canvas,
-            mScheduledFrameNumber,
-            mScheduledFrameMonotonicNumber);
-        didDrawFrame |= rendered;
-        if (rendered) {
-          FLog.v(TAG, "(%s) Rendered current frame %d", mLogId, mScheduledFrameNumber);
-          if (mIsRunning) {
-            computeAndScheduleNextFrame(true /* schedule next frame */);
-          }
+        long now = mMonotonicClock.now();
+
+        // Timeout if it's been more than 2 seconds with drawn since invalidation.
+        boolean hasNotDrawnWithinTimeout =
+                mWaitingForDraw && now - mLastInvalidateTimeMs > WATCH_DOG_TIMER_MIN_TIMEOUT_MS;
+
+        // Also timeout onNextFrame is more than 2 seconds late.
+        boolean hasNotAdvancedFrameWithinTimeout =
+                mNextFrameTaskMs != -1 && now - mNextFrameTaskMs > WATCH_DOG_TIMER_MIN_TIMEOUT_MS;
+
+        if (hasNotDrawnWithinTimeout || hasNotAdvancedFrameWithinTimeout) {
+            dropCaches();
+            doInvalidateSelf();
         } else {
-          FLog.v(TAG, "(%s) Trying again later for current %d", mLogId, mScheduledFrameNumber);
-          mPendingRenderedFrameNumber = mScheduledFrameNumber;
-          mPendingRenderedFrameMonotonicNumber = mScheduledFrameMonotonicNumber;
-          scheduleInvalidatePoll();
+            mScheduledExecutorServiceForUiThread.schedule(
+                    mWatchdogTask,
+                    WATCH_DOG_TIMER_POLL_INTERVAL_MS,
+                    TimeUnit.MILLISECONDS);
+            mHaveWatchdogScheduled = true;
         }
-      }
+    }
 
-      if (!didDrawFrame) {
-        if (mLastDrawnFrame != null) {
-          canvas.drawBitmap(mLastDrawnFrame.get(), 0f, 0f, mPaint);
-          didDrawFrame = true;
-          FLog.v(TAG, "(%s) Rendered last known frame %d", mLogId, mLastDrawnFrameNumber);
-        }
-      }
-
-      if (!didDrawFrame) {
-        // Last ditch effort, use preview bitmap.
-        CloseableReference<Bitmap> previewBitmapReference =
-            mAnimatedDrawableBackend.getPreviewBitmap();
-        if (previewBitmapReference != null) {
-          canvas.drawBitmap(previewBitmapReference.get(), 0f, 0f, mPaint);
-          previewBitmapReference.close();
-          FLog.v(TAG, "(%s) Rendered preview frame", mLogId);
-          didDrawFrame = true;
-        }
-      }
-
-      if (!didDrawFrame) {
-        // TODO(6169940) this may not be necessary. Confirm with Rich.
-        canvas.drawRect(0, 0, mDstRect.width(), mDstRect.height(), mTransparentPaint);
-        FLog.v(TAG, "(%s) Failed to draw a frame", mLogId);
-      }
-
-      canvas.restore();
-      mAnimatedDrawableDiagnostics.drawDebugOverlay(canvas, mDstRect);
-    } finally {
-      mAnimatedDrawableDiagnostics.onDrawMethodEnd();
+    private void doInvalidateSelf() {
+        mWaitingForDraw = true;
+        mLastInvalidateTimeMs = mMonotonicClock.now();
+        invalidateSelf();
     }
-  }
-
-  /**
-   * Schedule a task to invalidate the drawable. Used to poll for a rendered frame.
-   */
-  private void scheduleInvalidatePoll() {
-    if (mInvalidateTaskScheduled) {
-      return;
+
+    @VisibleForTesting
+    boolean isWaitingForDraw() {
+        return mWaitingForDraw;
     }
-    mInvalidateTaskScheduled = true;
-    scheduleSelf(mInvalidateTask, POLL_FOR_RENDERED_FRAME_MS);
-  }
-
-  /**
-   * Returns whether a previous call to {@link #draw} would have rendered a frame.
-   *
-   * @return whether a previous call to {@link #draw} would have rendered a frame
-   */
-  public boolean didLastDrawRender() {
-    return mLastDrawnFrame != null;
-  }
-
-  /**
-   * Renders the specified frame to the canvas.
-   *
-   * @param canvas the canvas to render to
-   * @param frameNumber the relative frame number (between 0 and frame count)
-   * @param frameMonotonicNumber the absolute frame number for stats purposes
-   * @return whether the frame was available and was rendered
-   */
-  private boolean renderFrame(
-      Canvas canvas,
-      int frameNumber,
-      int frameMonotonicNumber) {
-    CloseableReference<Bitmap> bitmapReference =
-        mAnimatedDrawableBackend.getBitmapForFrame(frameNumber);
-    if (bitmapReference != null) {
-      canvas.drawBitmap(bitmapReference.get(), 0f, 0f, mPaint);
-      if (mLastDrawnFrame != null) {
-        mLastDrawnFrame.close();
-      }
-
-      if (mIsRunning && frameMonotonicNumber > mLastDrawnFrameMonotonicNumber) {
-        int droppedFrames = frameMonotonicNumber - mLastDrawnFrameMonotonicNumber - 1;
-        mAnimatedDrawableDiagnostics.incrementDrawnFrames(1);
-        mAnimatedDrawableDiagnostics.incrementDroppedFrames(droppedFrames);
-        if (droppedFrames > 0) {
-          FLog.v(TAG, "(%s) Dropped %d frames", mLogId, droppedFrames);
+
+    @VisibleForTesting
+    boolean isWaitingForNextFrame() {
+        return mNextFrameTaskMs != -1;
+    }
+
+    @VisibleForTesting
+    int getScheduledFrameNumber() {
+        return mScheduledFrameNumber;
+    }
+
+    @Override
+    public void start() {
+        if (mDurationMs == 0 || mFrameCount <= 1) {
+            return;
         }
-      }
-      mLastDrawnFrame = bitmapReference;
-      mLastDrawnFrameNumber = frameNumber;
-      mLastDrawnFrameMonotonicNumber = frameMonotonicNumber;
-      FLog.v(TAG, "(%s) Drew frame %d", mLogId, frameNumber);
-      return true;
+        mIsRunning = true;
+        scheduleSelf(mStartTask, mMonotonicClock.now());
     }
-    return false;
-  }
-
-  /**
-   * Checks to make sure we drop our caches if we haven't drawn in a while. There's no reliable
-   * way for a Drawable to determine if it's still actively part of a View, so we use a heuristic
-   * instead.
-   */
-  private void doWatchdogCheck() {
-    mHaveWatchdogScheduled = false;
-    if (!mIsRunning) {
-      return;
+
+    @Override
+    public void stop() {
+        mIsRunning = false;
     }
-    long now = mMonotonicClock.now();
-
-    // Timeout if it's been more than 2 seconds with drawn since invalidation.
-    boolean hasNotDrawnWithinTimeout =
-        mWaitingForDraw && now - mLastInvalidateTimeMs > WATCH_DOG_TIMER_MIN_TIMEOUT_MS;
-
-    // Also timeout onNextFrame is more than 2 seconds late.
-    boolean hasNotAdvancedFrameWithinTimeout =
-        mNextFrameTaskMs != -1 && now - mNextFrameTaskMs > WATCH_DOG_TIMER_MIN_TIMEOUT_MS;
-
-    if (hasNotDrawnWithinTimeout || hasNotAdvancedFrameWithinTimeout) {
-      dropCaches();
-      doInvalidateSelf();
-    } else {
-      mScheduledExecutorServiceForUiThread.schedule(
-          mWatchdogTask,
-          WATCH_DOG_TIMER_POLL_INTERVAL_MS,
-          TimeUnit.MILLISECONDS);
-      mHaveWatchdogScheduled = true;
+
+    @Override
+    public boolean isRunning() {
+        return mIsRunning;
     }
-  }
-
-  private void doInvalidateSelf() {
-    mWaitingForDraw = true;
-    mLastInvalidateTimeMs = mMonotonicClock.now();
-    invalidateSelf();
-  }
-
-  @VisibleForTesting
-  boolean isWaitingForDraw() {
-    return mWaitingForDraw;
-  }
-
-  @VisibleForTesting
-  boolean isWaitingForNextFrame() {
-    return mNextFrameTaskMs != -1;
-  }
-
-  @VisibleForTesting
-  int getScheduledFrameNumber() {
-    return mScheduledFrameNumber;
-  }
-
-  @Override
-  public void start() {
-    if (mDurationMs == 0 || mFrameCount <= 1) {
-      return;
+
+    @Override
+    protected boolean onLevelChange(int level) {
+        if (mIsRunning) {
+            // If the client called start on us, they expect us to run the animation. In that case,
+            // we ignore level changes.
+            return false;
+        }
+        int frame = mAnimatedDrawableBackend.getFrameForTimestampMs(level);
+        if (frame == mScheduledFrameNumber) {
+            return false;
+        }
+
+        try {
+            mScheduledFrameNumber = frame;
+            mScheduledFrameMonotonicNumber = frame;
+            doInvalidateSelf();
+            return true;
+        } catch (IllegalStateException e) {
+            // The underlying image was disposed.
+            return false;
+        }
     }
-    mIsRunning = true;
-    scheduleSelf(mStartTask, mMonotonicClock.now());
-  }
-
-  @Override
-  public void stop() {
-    mIsRunning = false;
-  }
-
-  @Override
-  public boolean isRunning() {
-    return mIsRunning;
-  }
-
-  @Override
-  protected boolean onLevelChange(int level) {
-    if (mIsRunning) {
-      // If the client called start on us, they expect us to run the animation. In that case,
-      // we ignore level changes.
-      return false;
+
+    @Override
+    public ValueAnimator createValueAnimator(int maxDurationMs) {
+        ValueAnimator animator = createValueAnimator();
+        int repeatCount = Math.max((maxDurationMs / mAnimatedDrawableBackend.getDurationMs()), 1);
+        animator.setRepeatCount(repeatCount);
+        return animator;
     }
-    int frame = mAnimatedDrawableBackend.getFrameForTimestampMs(level);
-    if (frame == mScheduledFrameNumber) {
-      return false;
+
+    @Override
+    public ValueAnimator createValueAnimator() {
+        int loopCount = mAnimatedDrawableBackend.getLoopCount();
+        ValueAnimator animator = new ValueAnimator();
+        animator.setIntValues(0, mDurationMs);
+        animator.setDuration(mDurationMs);
+        animator.setRepeatCount(loopCount != 0 ? loopCount : ValueAnimator.INFINITE);
+        animator.setRepeatMode(ValueAnimator.RESTART);
+        animator.setInterpolator(new LinearInterpolator());
+        animator.addUpdateListener(createAnimatorUpdateListener());
+        return animator;
     }
 
-    try {
-      mScheduledFrameNumber = frame;
-      mScheduledFrameMonotonicNumber = frame;
-      doInvalidateSelf();
-      return true;
-    } catch (IllegalStateException e) {
-      // The underlying image was disposed.
-      return false;
+    @Override
+    public ValueAnimator.AnimatorUpdateListener createAnimatorUpdateListener() {
+        return new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(ValueAnimator animation) {
+                setLevel((Integer) animation.getAnimatedValue());
+            }
+        };
     }
-  }
-
-  @Override
-  public ValueAnimator createValueAnimator(int maxDurationMs) {
-    ValueAnimator animator = createValueAnimator();
-    int repeatCount = Math.max((maxDurationMs / mAnimatedDrawableBackend.getDurationMs()), 1);
-    animator.setRepeatCount(repeatCount);
-    return animator;
-  }
-
-  @Override
-  public ValueAnimator createValueAnimator() {
-    int loopCount = mAnimatedDrawableBackend.getLoopCount();
-    ValueAnimator animator = new ValueAnimator();
-    animator.setIntValues(0, mDurationMs);
-    animator.setDuration(mDurationMs);
-    animator.setRepeatCount(loopCount != 0 ? loopCount : ValueAnimator.INFINITE);
-    animator.setRepeatMode(ValueAnimator.RESTART);
-    animator.setInterpolator(new LinearInterpolator());
-    animator.addUpdateListener(createAnimatorUpdateListener());
-    return animator;
-  }
-
-  @Override
-  public ValueAnimator.AnimatorUpdateListener createAnimatorUpdateListener() {
-    return new ValueAnimator.AnimatorUpdateListener() {
-      @Override
-      public void onAnimationUpdate(ValueAnimator animation) {
-        setLevel((Integer) animation.getAnimatedValue());
-      }
-    };
-  }
-
-  @Override
-  public void dropCaches() {
-    FLog.v(TAG, "(%s) Dropping caches", mLogId);
-    if (mLastDrawnFrame != null) {
-      mLastDrawnFrame.close();
-      mLastDrawnFrame = null;
-      mLastDrawnFrameNumber = -1;
-      mLastDrawnFrameMonotonicNumber = -1;
+
+    @Override
+    public void dropCaches() {
+        FLog.v(TAG, "(%s) Dropping caches", mLogId);
+        if (mLastDrawnFrame != null) {
+            mLastDrawnFrame.close();
+            mLastDrawnFrame = null;
+            mLastDrawnFrameNumber = -1;
+            mLastDrawnFrameMonotonicNumber = -1;
+        }
+        mAnimatedDrawableBackend.dropCaches();
     }
-    mAnimatedDrawableBackend.dropCaches();
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableBackend.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableBackend.java
index 9512634a8..65ee943d8 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableBackend.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableBackend.java
@@ -22,149 +22,150 @@
  */
 public interface AnimatedDrawableBackend {
 
-  /**
-   * Gets the original result of the decode.
-   *
-   * @return the original result of the code
-   */
-  AnimatedImageResult getAnimatedImageResult();
-
-  /**
-   * Gets the duration of the animation.
-   *
-   * @return the duration of the animation in milliseconds
-   */
-  int getDurationMs();
-
-  /**
-   * Gets the number of frames in the animation.
-   *
-   * @return the number of frames in the animation
-   */
-  int getFrameCount();
-
-  /**
-   * Gets the number of loops to run the animation for.
-   *
-   * @return the number of loops, or 0 to indicate infinite
-   */
-  int getLoopCount();
-
-  /**
-   * Gets the width of the image.
-   *
-   * @return the width of the image
-   */
-  int getWidth();
-
-  /**
-   * Gets the height of the image.
-   *
-   * @return the height of the image
-   */
-  int getHeight();
-
-  /**
-   * Gets the rendered width of the image. This may be smaller than the underlying image width
-   * if the image is being rendered to a small bounds or to reduce memory requirements.
-   *
-   * @return the rendered width of the image
-   */
-  int getRenderedWidth();
-
-  /**
-   * Gets the rendered height of the image. This may be smaller than the underlying image height
-   * if the image is being rendered to a small bounds or to reduce memory requirements.
-   *
-   * @return the rendered height of the image
-   */
-  int getRenderedHeight();
-
-  /**
-   * Gets info about the specified frame.
-   *
-   * @param frameNumber the frame number (0-based)
-   * @return the frame info
-   */
-  AnimatedDrawableFrameInfo getFrameInfo(int frameNumber);
-
-  /**
-   * Renders the specified frame onto the canvas.
-   *
-   * @param frameNumber the frame number (0-based)
-   * @param canvas the canvas to render onto
-   */
-  void renderFrame(int frameNumber, Canvas canvas);
-
-  /**
-   * Gets the frame index for specified timestamp.
-   *
-   * @param timestampMs the timestamp
-   * @return the frame index for the timestamp or the last frame number if the timestamp is outside
-   *    the duration of the entire animation
-   */
-  int getFrameForTimestampMs(int timestampMs);
-
-  /**
-   * Gets the timestamp relative to the first frame that this frame number starts at.
-   *
-   * @param frameNumber the frame number
-   * @return the time in milliseconds
-   */
-  int getTimestampMsForFrame(int frameNumber);
-
-  /**
-   * Gets the duration of the specified frame.
-   *
-   * @param frameNumber the frame number
-   * @return the time in milliseconds
-   */
-  int getDurationMsForFrame(int frameNumber);
-
-  /**
-   * Gets the frame number to use for the preview frame.
-   *
-   * @return the frame number to use for the preview frame
-   */
-  int getFrameForPreview();
-
-  /**
-   * Creates a new {@link AnimatedDrawableBackend} with the same parameters but with a new bounds.
-   *
-   * @param bounds the bounds
-   * @return an {@link AnimatedDrawableBackend} with the new bounds (this may be the same instance
-   *    if the bounds don't require a new backend)
-   */
-  AnimatedDrawableBackend forNewBounds(Rect bounds);
-
-  /**
-   * Gets the number of bytes currently used by the backend for caching (for debugging)
-   *
-   * @return the number of bytes currently used by the backend for caching
-   */
-  int getMemoryUsage();
-
-  /**
-   * Gets a pre-decoded frame. This will only return non-null if the {@code ImageDecodeOptions}
-   * were configured to decode all frames at decode time.
-   *
-   * @param frameNumber the index of the frame to get
-   * @return a reference to the preview bitmap which must be released by the caller when done or
-   *     null if there is no preview bitmap set
-   */
-  @Nullable CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber);
-
-  /**
-   * Gets whether it has the decoded frame. This will only return true if the
-   * {@code ImageDecodeOptions} were configured to decode all frames at decode time.
-   *
-   * @param frameNumber the index of the frame to get
-   * @return true if the result has the decoded frame
-   */
-  boolean hasPreDecodedFrame(int frameNumber);
+    /**
+     * Gets the original result of the decode.
+     *
+     * @return the original result of the code
+     */
+    AnimatedImageResult getAnimatedImageResult();
+
+    /**
+     * Gets the duration of the animation.
+     *
+     * @return the duration of the animation in milliseconds
+     */
+    int getDurationMs();
+
+    /**
+     * Gets the number of frames in the animation.
+     *
+     * @return the number of frames in the animation
+     */
+    int getFrameCount();
+
+    /**
+     * Gets the number of loops to run the animation for.
+     *
+     * @return the number of loops, or 0 to indicate infinite
+     */
+    int getLoopCount();
+
+    /**
+     * Gets the width of the image.
+     *
+     * @return the width of the image
+     */
+    int getWidth();
+
+    /**
+     * Gets the height of the image.
+     *
+     * @return the height of the image
+     */
+    int getHeight();
+
+    /**
+     * Gets the rendered width of the image. This may be smaller than the underlying image width
+     * if the image is being rendered to a small bounds or to reduce memory requirements.
+     *
+     * @return the rendered width of the image
+     */
+    int getRenderedWidth();
+
+    /**
+     * Gets the rendered height of the image. This may be smaller than the underlying image height
+     * if the image is being rendered to a small bounds or to reduce memory requirements.
+     *
+     * @return the rendered height of the image
+     */
+    int getRenderedHeight();
+
+    /**
+     * Gets info about the specified frame.
+     *
+     * @param frameNumber the frame number (0-based)
+     * @return the frame info
+     */
+    AnimatedDrawableFrameInfo getFrameInfo(int frameNumber);
+
+    /**
+     * Renders the specified frame onto the canvas.
+     *
+     * @param frameNumber the frame number (0-based)
+     * @param canvas      the canvas to render onto
+     */
+    void renderFrame(int frameNumber, Canvas canvas);
+
+    /**
+     * Gets the frame index for specified timestamp.
+     *
+     * @param timestampMs the timestamp
+     * @return the frame index for the timestamp or the last frame number if the timestamp is outside
+     * the duration of the entire animation
+     */
+    int getFrameForTimestampMs(int timestampMs);
+
+    /**
+     * Gets the timestamp relative to the first frame that this frame number starts at.
+     *
+     * @param frameNumber the frame number
+     * @return the time in milliseconds
+     */
+    int getTimestampMsForFrame(int frameNumber);
+
+    /**
+     * Gets the duration of the specified frame.
+     *
+     * @param frameNumber the frame number
+     * @return the time in milliseconds
+     */
+    int getDurationMsForFrame(int frameNumber);
+
+    /**
+     * Gets the frame number to use for the preview frame.
+     *
+     * @return the frame number to use for the preview frame
+     */
+    int getFrameForPreview();
+
+    /**
+     * Creates a new {@link AnimatedDrawableBackend} with the same parameters but with a new bounds.
+     *
+     * @param bounds the bounds
+     * @return an {@link AnimatedDrawableBackend} with the new bounds (this may be the same instance
+     * if the bounds don't require a new backend)
+     */
+    AnimatedDrawableBackend forNewBounds(Rect bounds);
+
+    /**
+     * Gets the number of bytes currently used by the backend for caching (for debugging)
+     *
+     * @return the number of bytes currently used by the backend for caching
+     */
+    int getMemoryUsage();
+
+    /**
+     * Gets a pre-decoded frame. This will only return non-null if the {@code ImageDecodeOptions}
+     * were configured to decode all frames at decode time.
+     *
+     * @param frameNumber the index of the frame to get
+     * @return a reference to the preview bitmap which must be released by the caller when done or
+     * null if there is no preview bitmap set
+     */
+    @Nullable
+    CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber);
+
+    /**
+     * Gets whether it has the decoded frame. This will only return true if the
+     * {@code ImageDecodeOptions} were configured to decode all frames at decode time.
+     *
+     * @param frameNumber the index of the frame to get
+     * @return true if the result has the decoded frame
+     */
+    boolean hasPreDecodedFrame(int frameNumber);
 
     /**
      * Instructs the backend to drop its caches.
      */
-  void dropCaches();
+    void dropCaches();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableCachingBackend.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableCachingBackend.java
index de320b9a2..fc9ade4c1 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableCachingBackend.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableCachingBackend.java
@@ -19,34 +19,34 @@
  */
 public interface AnimatedDrawableCachingBackend extends AnimatedDrawableBackend {
 
-  /**
-   * Gets the bitmap for the specified frame number. The bitmap should be the size of the
-   * rendered image according to {@link #getRenderedWidth()} and {@link #getRenderedHeight()} and
-   * ready to be drawn in the Drawable's draw method.
-   *
-   * @param frameNumber the frame number (0-based)
-   * @return a reference to the bitmap which must be released by the caller when done or null
-   *    to indicate to the caller that the bitmap is not ready and it should try again later
-   */
-  CloseableReference<Bitmap> getBitmapForFrame(int frameNumber);
-
-  /**
-   * Gets the bitmap for the preview frame. This will only return non-null if the
-   * {@code ImageDecodeOptions} were configured to decode the preview frame.
-   *
-   * @return a reference to the preview bitmap which must be released by the caller when done or
-   *    null if there is no preview bitmap set
-   */
-  CloseableReference<Bitmap> getPreviewBitmap();
-
-  /**
-   * Appends a string about the state of the backend that might be useful for debugging.
-   *
-   * @param sb the builder to append to
-   */
-  void appendDebugOptionString(StringBuilder sb);
-
-  // Overridden to restrict the return type.
-  @Override
-  AnimatedDrawableCachingBackend forNewBounds(Rect bounds);
+    /**
+     * Gets the bitmap for the specified frame number. The bitmap should be the size of the
+     * rendered image according to {@link #getRenderedWidth()} and {@link #getRenderedHeight()} and
+     * ready to be drawn in the Drawable's draw method.
+     *
+     * @param frameNumber the frame number (0-based)
+     * @return a reference to the bitmap which must be released by the caller when done or null
+     * to indicate to the caller that the bitmap is not ready and it should try again later
+     */
+    CloseableReference<Bitmap> getBitmapForFrame(int frameNumber);
+
+    /**
+     * Gets the bitmap for the preview frame. This will only return non-null if the
+     * {@code ImageDecodeOptions} were configured to decode the preview frame.
+     *
+     * @return a reference to the preview bitmap which must be released by the caller when done or
+     * null if there is no preview bitmap set
+     */
+    CloseableReference<Bitmap> getPreviewBitmap();
+
+    /**
+     * Appends a string about the state of the backend that might be useful for debugging.
+     *
+     * @param sb the builder to append to
+     */
+    void appendDebugOptionString(StringBuilder sb);
+
+    // Overridden to restrict the return type.
+    @Override
+    AnimatedDrawableCachingBackend forNewBounds(Rect bounds);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableDiagnostics.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableDiagnostics.java
index 9b0a4c99e..0e9ae2a55 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableDiagnostics.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableDiagnostics.java
@@ -17,64 +17,64 @@
  */
 public interface AnimatedDrawableDiagnostics {
 
-  /**
-   * Sets the backend that the {@link AnimatedDrawable} is using.
-   *
-   * @param animatedDrawableBackend the backend
-   */
-  void setBackend(AnimatedDrawableCachingBackend animatedDrawableBackend);
+    /**
+     * Sets the backend that the {@link AnimatedDrawable} is using.
+     *
+     * @param animatedDrawableBackend the backend
+     */
+    void setBackend(AnimatedDrawableCachingBackend animatedDrawableBackend);
 
-  /**
-   * Called when the {@link AnimatedDrawable#onStart} method begins, which is the method that
-   * resets and starts the animation.
-   */
-  void onStartMethodBegin();
+    /**
+     * Called when the {@link AnimatedDrawable#onStart} method begins, which is the method that
+     * resets and starts the animation.
+     */
+    void onStartMethodBegin();
 
-  /**
-   * Called when the {@link AnimatedDrawable#onStart} method ends.
-   */
-  void onStartMethodEnd();
+    /**
+     * Called when the {@link AnimatedDrawable#onStart} method ends.
+     */
+    void onStartMethodEnd();
 
-  /**
-   * Called when the {@link AnimatedDrawable#onNextFrame} method begins, which is the method that
-   * determines the next frame to render and configures itself to do so.
-   */
-  void onNextFrameMethodBegin();
+    /**
+     * Called when the {@link AnimatedDrawable#onNextFrame} method begins, which is the method that
+     * determines the next frame to render and configures itself to do so.
+     */
+    void onNextFrameMethodBegin();
 
-  /**
-   * Called when the {@link AnimatedDrawable#onNextFrame} method ends.
-   */
-  void onNextFrameMethodEnd();
+    /**
+     * Called when the {@link AnimatedDrawable#onNextFrame} method ends.
+     */
+    void onNextFrameMethodEnd();
 
-  /**
-   * Increments the number of dropped frames for stats purposes.
-   *
-   * @param droppedFrames the number of dropped frames
-   */
-  void incrementDroppedFrames(int droppedFrames);
+    /**
+     * Increments the number of dropped frames for stats purposes.
+     *
+     * @param droppedFrames the number of dropped frames
+     */
+    void incrementDroppedFrames(int droppedFrames);
 
-  /**
-   * Increments the number of drawn frames for stats purposes.
-   *
-   * @param drawnFrames the number of drawn frames
-   */
-  void incrementDrawnFrames(int drawnFrames);
+    /**
+     * Increments the number of drawn frames for stats purposes.
+     *
+     * @param drawnFrames the number of drawn frames
+     */
+    void incrementDrawnFrames(int drawnFrames);
 
-  /**
-   * Called when the {@link AnimatedDrawable#draw} method begins.
-   */
-  void onDrawMethodBegin();
+    /**
+     * Called when the {@link AnimatedDrawable#draw} method begins.
+     */
+    void onDrawMethodBegin();
 
-  /**
-   * Called when the {@link AnimatedDrawable#draw} method emds.
-   */
-  void onDrawMethodEnd();
+    /**
+     * Called when the {@link AnimatedDrawable#draw} method emds.
+     */
+    void onDrawMethodEnd();
 
-  /**
-   * Allows the diagnostics code to draw an overlay that may be useful for debugging.
-   *
-   * @param canvas the canvas to draw to
-   * @param destRect the rectangle bounds to draw to
-   */
-  void drawDebugOverlay(Canvas canvas, Rect destRect);
+    /**
+     * Allows the diagnostics code to draw an overlay that may be useful for debugging.
+     *
+     * @param canvas   the canvas to draw to
+     * @param destRect the rectangle bounds to draw to
+     */
+    void drawDebugOverlay(Canvas canvas, Rect destRect);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableFrameInfo.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableFrameInfo.java
index e5bfe28b3..ba899dc4c 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableFrameInfo.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableFrameInfo.java
@@ -14,43 +14,49 @@
  */
 public class AnimatedDrawableFrameInfo {
 
-  /**
-   * How to dispose of the current frame before rendering the next frame.
-   */
-  public enum DisposalMethod {
-
-    /** Do not dipose the frame. Leave as-is. */
-    DISPOSE_DO_NOT,
-
-    /** Dispose to the background color */
-    DISPOSE_TO_BACKGROUND,
-
-    /** Dispose to the previous frame */
-    DISPOSE_TO_PREVIOUS
-  }
-
-  public final int frameNumber;
-  public final int xOffset;
-  public final int yOffset;
-  public final int width;
-  public final int height;
-  public final boolean shouldBlendWithPreviousFrame;
-  public final DisposalMethod disposalMethod;
-
-  public AnimatedDrawableFrameInfo(
-      int frameNumber,
-      int xOffset,
-      int yOffset,
-      int width,
-      int height,
-      boolean shouldBlendWithPreviousFrame,
-      DisposalMethod disposalMethod) {
-    this.frameNumber = frameNumber;
-    this.xOffset = xOffset;
-    this.yOffset = yOffset;
-    this.width = width;
-    this.height = height;
-    this.shouldBlendWithPreviousFrame = shouldBlendWithPreviousFrame;
-    this.disposalMethod = disposalMethod;
-  }
+    /**
+     * How to dispose of the current frame before rendering the next frame.
+     */
+    public enum DisposalMethod {
+
+        /**
+         * Do not dipose the frame. Leave as-is.
+         */
+        DISPOSE_DO_NOT,
+
+        /**
+         * Dispose to the background color
+         */
+        DISPOSE_TO_BACKGROUND,
+
+        /**
+         * Dispose to the previous frame
+         */
+        DISPOSE_TO_PREVIOUS
+    }
+
+    public final int frameNumber;
+    public final int xOffset;
+    public final int yOffset;
+    public final int width;
+    public final int height;
+    public final boolean shouldBlendWithPreviousFrame;
+    public final DisposalMethod disposalMethod;
+
+    public AnimatedDrawableFrameInfo(
+            int frameNumber,
+            int xOffset,
+            int yOffset,
+            int width,
+            int height,
+            boolean shouldBlendWithPreviousFrame,
+            DisposalMethod disposalMethod) {
+        this.frameNumber = frameNumber;
+        this.xOffset = xOffset;
+        this.yOffset = yOffset;
+        this.width = width;
+        this.height = height;
+        this.shouldBlendWithPreviousFrame = shouldBlendWithPreviousFrame;
+        this.disposalMethod = disposalMethod;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptions.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptions.java
index 25f5c5848..62c721175 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptions.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptions.java
@@ -17,48 +17,48 @@
 @Immutable
 public class AnimatedDrawableOptions {
 
-  /**
-   * Default options.
-   */
-  public static AnimatedDrawableOptions DEFAULTS = AnimatedDrawableOptions.newBuilder().build();
+    /**
+     * Default options.
+     */
+    public static AnimatedDrawableOptions DEFAULTS = AnimatedDrawableOptions.newBuilder().build();
 
-  /**
-   * Whether all the rendered frames should be held in memory disregarding other constraints.
-   */
-  public final boolean forceKeepAllFramesInMemory;
+    /**
+     * Whether all the rendered frames should be held in memory disregarding other constraints.
+     */
+    public final boolean forceKeepAllFramesInMemory;
 
-  /**
-   * Whether the drawable can use worker threads to optimistically prefetch frames.
-   */
-  public final boolean allowPrefetching;
+    /**
+     * Whether the drawable can use worker threads to optimistically prefetch frames.
+     */
+    public final boolean allowPrefetching;
 
-  /**
-   * The maximum bytes that the backend can use to cache image frames in memory or -1
-   * to use the default
-   */
-  public final int maximumBytes;
+    /**
+     * The maximum bytes that the backend can use to cache image frames in memory or -1
+     * to use the default
+     */
+    public final int maximumBytes;
 
-  /**
-   * Whether to enable additional verbose debugging diagnostics.
-   */
-  public final boolean enableDebugging;
+    /**
+     * Whether to enable additional verbose debugging diagnostics.
+     */
+    public final boolean enableDebugging;
 
-  /**
-   * Creates {@link AnimatedDrawableOptions} with default options.
-   */
-  public AnimatedDrawableOptions(AnimatedDrawableOptionsBuilder builder) {
-    this.forceKeepAllFramesInMemory = builder.getForceKeepAllFramesInMemory();
-    this.allowPrefetching = builder.getAllowPrefetching();
-    this.maximumBytes = builder.getMaximumBytes();
-    this.enableDebugging = builder.getEnableDebugging();
-  }
+    /**
+     * Creates {@link AnimatedDrawableOptions} with default options.
+     */
+    public AnimatedDrawableOptions(AnimatedDrawableOptionsBuilder builder) {
+        this.forceKeepAllFramesInMemory = builder.getForceKeepAllFramesInMemory();
+        this.allowPrefetching = builder.getAllowPrefetching();
+        this.maximumBytes = builder.getMaximumBytes();
+        this.enableDebugging = builder.getEnableDebugging();
+    }
 
-  /**
-   * Creates a new builder.
-   *
-   * @return the builder
-   */
-  public static AnimatedDrawableOptionsBuilder newBuilder() {
-    return new AnimatedDrawableOptionsBuilder();
-  }
+    /**
+     * Creates a new builder.
+     *
+     * @return the builder
+     */
+    public static AnimatedDrawableOptionsBuilder newBuilder() {
+        return new AnimatedDrawableOptionsBuilder();
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptionsBuilder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptionsBuilder.java
index 13ffbd734..6c3fc86fd 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptionsBuilder.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableOptionsBuilder.java
@@ -14,100 +14,100 @@
  */
 public class AnimatedDrawableOptionsBuilder {
 
-  private boolean mForceKeepAllFramesInMemory;
-  private boolean mAllowPrefetching = true;
-  private int mMaximumBytes = -1;
-  private boolean mEnableDebugging;
+    private boolean mForceKeepAllFramesInMemory;
+    private boolean mAllowPrefetching = true;
+    private int mMaximumBytes = -1;
+    private boolean mEnableDebugging;
 
-  /**
-   * Gets whether all the rendered frames should be held in memory disregarding other constraints.
-   *
-   * @return whether all the rendered frames should be held in memory
-   */
-  public boolean getForceKeepAllFramesInMemory() {
-    return mForceKeepAllFramesInMemory;
-  }
+    /**
+     * Gets whether all the rendered frames should be held in memory disregarding other constraints.
+     *
+     * @return whether all the rendered frames should be held in memory
+     */
+    public boolean getForceKeepAllFramesInMemory() {
+        return mForceKeepAllFramesInMemory;
+    }
 
-  /**
-   * Sets whether all the rendered frames should be held in memory disregarding other constraints.
-   *
-   * @param forceKeepAllFramesInMemory whether to force the frames to be held in memory
-   * @return this builder
-   */
-  public AnimatedDrawableOptionsBuilder setForceKeepAllFramesInMemory(
-      boolean forceKeepAllFramesInMemory) {
-    mForceKeepAllFramesInMemory = forceKeepAllFramesInMemory;
-    return this;
-  }
+    /**
+     * Sets whether all the rendered frames should be held in memory disregarding other constraints.
+     *
+     * @param forceKeepAllFramesInMemory whether to force the frames to be held in memory
+     * @return this builder
+     */
+    public AnimatedDrawableOptionsBuilder setForceKeepAllFramesInMemory(
+            boolean forceKeepAllFramesInMemory) {
+        mForceKeepAllFramesInMemory = forceKeepAllFramesInMemory;
+        return this;
+    }
 
-  /**
-   * Gets whether the drawable can use worker threads to optimistically prefetch frames.
-   *
-   * @return whether the backend can use worker threads to prefetch frames
-   */
-  public boolean getAllowPrefetching() {
-    return mAllowPrefetching;
-  }
+    /**
+     * Gets whether the drawable can use worker threads to optimistically prefetch frames.
+     *
+     * @return whether the backend can use worker threads to prefetch frames
+     */
+    public boolean getAllowPrefetching() {
+        return mAllowPrefetching;
+    }
 
-  /**
-   * Sets whether the drawable can use worker threads to optimistically prefetch frames.
-   *
-   * @param allowPrefetching whether the backend can use worker threads to prefetch frames
-   * @return this builder
-   */
-  public AnimatedDrawableOptionsBuilder setAllowPrefetching(boolean allowPrefetching) {
-    mAllowPrefetching = allowPrefetching;
-    return this;
-  }
+    /**
+     * Sets whether the drawable can use worker threads to optimistically prefetch frames.
+     *
+     * @param allowPrefetching whether the backend can use worker threads to prefetch frames
+     * @return this builder
+     */
+    public AnimatedDrawableOptionsBuilder setAllowPrefetching(boolean allowPrefetching) {
+        mAllowPrefetching = allowPrefetching;
+        return this;
+    }
 
-  /**
-   * Gets the maximum bytes that the backend can use to cache image frames in memory.
-   *
-   * @return maximumBytes maximum bytes that the backend can use to cache image frames in memory
-   *    or -1 to use the default
-   */
-  public int getMaximumBytes() {
-    return mMaximumBytes;
-  }
+    /**
+     * Gets the maximum bytes that the backend can use to cache image frames in memory.
+     *
+     * @return maximumBytes maximum bytes that the backend can use to cache image frames in memory
+     * or -1 to use the default
+     */
+    public int getMaximumBytes() {
+        return mMaximumBytes;
+    }
 
-  /**
-   * Sets the maximum bytes that the backend can use to cache image frames in memory.
-   *
-   * @param maximumBytes maximum bytes that the backend can use to cache image frames in memory or
-   *     -1 to use the default
-   * @return this builder
-   */
-  public AnimatedDrawableOptionsBuilder setMaximumBytes(int maximumBytes) {
-    mMaximumBytes = maximumBytes;
-    return this;
-  }
+    /**
+     * Sets the maximum bytes that the backend can use to cache image frames in memory.
+     *
+     * @param maximumBytes maximum bytes that the backend can use to cache image frames in memory or
+     *                     -1 to use the default
+     * @return this builder
+     */
+    public AnimatedDrawableOptionsBuilder setMaximumBytes(int maximumBytes) {
+        mMaximumBytes = maximumBytes;
+        return this;
+    }
 
-  /**
-   * Gets whether to enable additional verbose debugging diagnostics.
-   *
-   * @return whether to enable additional verbose debugging diagnostics
-   */
-  public boolean getEnableDebugging() {
-    return mEnableDebugging;
-  }
+    /**
+     * Gets whether to enable additional verbose debugging diagnostics.
+     *
+     * @return whether to enable additional verbose debugging diagnostics
+     */
+    public boolean getEnableDebugging() {
+        return mEnableDebugging;
+    }
 
-  /**
-   * Sets whether to enable additional verbose debugging diagnostics.
-   *
-   * @param enableDebugging whether to enable additional verbose debugging diagnostics
-   * @return this builder
-   */
-  public AnimatedDrawableOptionsBuilder setEnableDebugging(boolean enableDebugging) {
-    mEnableDebugging = enableDebugging;
-    return this;
-  }
+    /**
+     * Sets whether to enable additional verbose debugging diagnostics.
+     *
+     * @param enableDebugging whether to enable additional verbose debugging diagnostics
+     * @return this builder
+     */
+    public AnimatedDrawableOptionsBuilder setEnableDebugging(boolean enableDebugging) {
+        mEnableDebugging = enableDebugging;
+        return this;
+    }
 
-  /**
-   * Builds the immutable options instance.
-   *
-   * @return the options instance
-   */
-  public AnimatedDrawableOptions build() {
-    return new AnimatedDrawableOptions(this);
-  }
+    /**
+     * Builds the immutable options instance.
+     *
+     * @return the options instance
+     */
+    public AnimatedDrawableOptions build() {
+        return new AnimatedDrawableOptions(this);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImage.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImage.java
index 9bdacf5ca..57dfcff32 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImage.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImage.java
@@ -15,86 +15,86 @@
  */
 public interface AnimatedImage {
 
-  /**
-   * Disposes the instance. This will free native resources held by this instance. Once called,
-   * other methods on this instance may throw. Note, the underlying native resources may not
-   * actually be freed until all associated instances of {@link AnimatedImageFrame} are disposed or
-   * finalized as well.
-   */
-  void dispose();
+    /**
+     * Disposes the instance. This will free native resources held by this instance. Once called,
+     * other methods on this instance may throw. Note, the underlying native resources may not
+     * actually be freed until all associated instances of {@link AnimatedImageFrame} are disposed or
+     * finalized as well.
+     */
+    void dispose();
 
-  /**
-   * Gets the width of the image (also known as the canvas in WebP nomenclature).
-   *
-   * @return the width of the image
-   */
-  int getWidth();
+    /**
+     * Gets the width of the image (also known as the canvas in WebP nomenclature).
+     *
+     * @return the width of the image
+     */
+    int getWidth();
 
-  /**
-   * Gets the height of the image (also known as the canvas in WebP nomenclature).
-   *
-   * @return the height of the image
-   */
-  int getHeight();
+    /**
+     * Gets the height of the image (also known as the canvas in WebP nomenclature).
+     *
+     * @return the height of the image
+     */
+    int getHeight();
 
-  /**
-   * Gets the number of frames in the image.
-   *
-   * @return the number of frames in the image
-   */
-  int getFrameCount();
+    /**
+     * Gets the number of frames in the image.
+     *
+     * @return the number of frames in the image
+     */
+    int getFrameCount();
 
-  /**
-   * Gets the duration of the animated image.
-   *
-   * @return the duration of the animated image in milliseconds
-   */
-  int getDuration();
+    /**
+     * Gets the duration of the animated image.
+     *
+     * @return the duration of the animated image in milliseconds
+     */
+    int getDuration();
 
-  /**
-   * Gets the duration of each frame of the animated image.
-   *
-   * @return an array that is the size of the number of frames containing the duration of each frame
-   *     in milliseconds
-   */
-  int[] getFrameDurations();
+    /**
+     * Gets the duration of each frame of the animated image.
+     *
+     * @return an array that is the size of the number of frames containing the duration of each frame
+     * in milliseconds
+     */
+    int[] getFrameDurations();
 
-  /**
-   * Gets the number of loops to run the animation for.
-   *
-   * @return the number of loops, or 0 to indicate infinite
-   */
-  int getLoopCount();
+    /**
+     * Gets the number of loops to run the animation for.
+     *
+     * @return the number of loops, or 0 to indicate infinite
+     */
+    int getLoopCount();
 
-  /**
-   * Creates an {@link AnimatedImageFrame} at the specified index.
-   *
-   * @param frameNumber the index of the frame
-   * @return a newly created {@link AnimatedImageFrame}
-   */
-  AnimatedImageFrame getFrame(int frameNumber);
+    /**
+     * Creates an {@link AnimatedImageFrame} at the specified index.
+     *
+     * @param frameNumber the index of the frame
+     * @return a newly created {@link AnimatedImageFrame}
+     */
+    AnimatedImageFrame getFrame(int frameNumber);
 
-  /**
-   * Returns whether {@link AnimatedImageFrame#renderFrame} supports scaling to arbitrary
-   * sizes or whether scaling must be done externally.
-   *
-   * @return whether rendering supports scaling
-   */
-  boolean doesRenderSupportScaling();
+    /**
+     * Returns whether {@link AnimatedImageFrame#renderFrame} supports scaling to arbitrary
+     * sizes or whether scaling must be done externally.
+     *
+     * @return whether rendering supports scaling
+     */
+    boolean doesRenderSupportScaling();
 
-  /**
-   * Gets the size of bytes of the encoded image data (which is the data kept in memory for the
-   * image).
-   *
-   * @return the size in bytes of the encoded image data
-   */
-  int getSizeInBytes();
+    /**
+     * Gets the size of bytes of the encoded image data (which is the data kept in memory for the
+     * image).
+     *
+     * @return the size in bytes of the encoded image data
+     */
+    int getSizeInBytes();
 
-  /**
-   * Gets the frame info for the specified frame.
-   *
-   * @param frameNumber the frame to get the info for
-   * @return the frame info
-   */
-  AnimatedDrawableFrameInfo getFrameInfo(int frameNumber);
+    /**
+     * Gets the frame info for the specified frame.
+     *
+     * @param frameNumber the frame to get the info for
+     * @return the frame info
+     */
+    AnimatedDrawableFrameInfo getFrameInfo(int frameNumber);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java
index 75b52fb10..d1b6139b1 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageFrame.java
@@ -16,56 +16,56 @@
  */
 public interface AnimatedImageFrame {
 
-  /**
-   * Disposes the instance. This will free native resources held by this instance. Once called,
-   * other methods on this instance may throw. Note, the underlying native resources may not
-   * actually be freed until all associated instances {@link AnimatedImage} are disposed or
-   * finalized as well.
-   */
-  void dispose();
+    /**
+     * Disposes the instance. This will free native resources held by this instance. Once called,
+     * other methods on this instance may throw. Note, the underlying native resources may not
+     * actually be freed until all associated instances {@link AnimatedImage} are disposed or
+     * finalized as well.
+     */
+    void dispose();
 
-  /**
-   * Renders the frame to the specified bitmap. The bitmap must have a width and height that is
-   * at least as big as the specified width and height and it must be in RGBA_8888 color format.
-   *
-   * @param width the width to render to (the image is scaled to this width)
-   * @param height the height to render to (the image is scaled to this height)
-   * @param bitmap the bitmap to render into
-   */
-  void renderFrame(int width, int height, Bitmap bitmap);
+    /**
+     * Renders the frame to the specified bitmap. The bitmap must have a width and height that is
+     * at least as big as the specified width and height and it must be in RGBA_8888 color format.
+     *
+     * @param width  the width to render to (the image is scaled to this width)
+     * @param height the height to render to (the image is scaled to this height)
+     * @param bitmap the bitmap to render into
+     */
+    void renderFrame(int width, int height, Bitmap bitmap);
 
-  /**
-   * Gets the duration of the frame.
-   *
-   * @return the duration of the frame in milliseconds
-   */
-  int getDurationMs();
+    /**
+     * Gets the duration of the frame.
+     *
+     * @return the duration of the frame in milliseconds
+     */
+    int getDurationMs();
 
-  /**
-   * Gets the width of the frame.
-   *
-   * @return the width of the frame
-   */
-  int getWidth();
+    /**
+     * Gets the width of the frame.
+     *
+     * @return the width of the frame
+     */
+    int getWidth();
 
-  /**
-   * Gets the height of the frame.
-   *
-   * @return the height of the frame
-   */
-  int getHeight();
+    /**
+     * Gets the height of the frame.
+     *
+     * @return the height of the frame
+     */
+    int getHeight();
 
-  /**
-   * Gets the x-offset of the frame relative to the image canvas.
-   *
-   * @return the x-offset of the frame
-   */
-  int getXOffset();
+    /**
+     * Gets the x-offset of the frame relative to the image canvas.
+     *
+     * @return the x-offset of the frame
+     */
+    int getXOffset();
 
-  /**
-   * Gets the y-offset of the frame relative to the image canvas.
-   *
-   * @return the y-offset of the frame
-   */
-  int getYOffset();
+    /**
+     * Gets the y-offset of the frame relative to the image canvas.
+     *
+     * @return the y-offset of the frame
+     */
+    int getYOffset();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResult.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResult.java
index cd7ce57ff..f07ff38e2 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResult.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResult.java
@@ -24,106 +24,112 @@
  */
 public class AnimatedImageResult {
 
-  private final AnimatedImage mImage;
-  private final int mFrameForPreview;
-  private @Nullable CloseableReference<Bitmap> mPreviewBitmap;
-  private @Nullable List<CloseableReference<Bitmap>> mDecodedFrames;
-
-  AnimatedImageResult(AnimatedImageResultBuilder builder) {
-    mImage = Preconditions.checkNotNull(builder.getImage());
-    mFrameForPreview = builder.getFrameForPreview();
-    mPreviewBitmap = builder.getPreviewBitmap();
-    mDecodedFrames = builder.getDecodedFrames();
-  }
-
-  private AnimatedImageResult(AnimatedImage image) {
-    mImage = Preconditions.checkNotNull(image);
-    mFrameForPreview = 0;
-  }
-
-  /**
-   * Creates an {@link AnimatedImageResult} with no additional options.
-   *
-   * @param image the image
-   * @return the result
-   */
-  public static AnimatedImageResult forAnimatedImage(AnimatedImage image) {
-    return new AnimatedImageResult(image);
-  }
-
-  /**
-   * Creates an {@link AnimatedImageResultBuilder} for creating an {@link AnimatedImageResult}.
-   *
-   * @param image the image
-   * @return the builder
-   */
-  public static AnimatedImageResultBuilder newBuilder(AnimatedImage image) {
-    return new AnimatedImageResultBuilder(image);
-  }
-
-  /**
-   * Gets the underlying image.
-   *
-   * @return the underlying image
-   */
-  public AnimatedImage getImage() {
-    return mImage;
-  }
-
-  /**
-   * Gets the frame that should be used for the preview image. If the preview bitmap was fetched,
-   * this is the frame that it's for.
-   *
-   * @return the frame that should be used for the preview image
-   */
-  public int getFrameForPreview() {
-    return mFrameForPreview;
-  }
-
-  /**
-   * Gets a decoded frame. This will only return non-null if the {@code ImageDecodeOptions}
-   * were configured to decode all frames at decode time.
-   *
-   * @param index the index of the frame to get
-   * @return a reference to the preview bitmap which must be released by the caller when done or
-   *     null if there is no preview bitmap set
-   */
-  public synchronized @Nullable CloseableReference<Bitmap> getDecodedFrame(int index) {
-    if (mDecodedFrames != null) {
-      return CloseableReference.cloneOrNull(mDecodedFrames.get(index));
+    private final AnimatedImage mImage;
+    private final int mFrameForPreview;
+    private
+    @Nullable
+    CloseableReference<Bitmap> mPreviewBitmap;
+    private
+    @Nullable
+    List<CloseableReference<Bitmap>> mDecodedFrames;
+
+    AnimatedImageResult(AnimatedImageResultBuilder builder) {
+        mImage = Preconditions.checkNotNull(builder.getImage());
+        mFrameForPreview = builder.getFrameForPreview();
+        mPreviewBitmap = builder.getPreviewBitmap();
+        mDecodedFrames = builder.getDecodedFrames();
+    }
+
+    private AnimatedImageResult(AnimatedImage image) {
+        mImage = Preconditions.checkNotNull(image);
+        mFrameForPreview = 0;
+    }
+
+    /**
+     * Creates an {@link AnimatedImageResult} with no additional options.
+     *
+     * @param image the image
+     * @return the result
+     */
+    public static AnimatedImageResult forAnimatedImage(AnimatedImage image) {
+        return new AnimatedImageResult(image);
+    }
+
+    /**
+     * Creates an {@link AnimatedImageResultBuilder} for creating an {@link AnimatedImageResult}.
+     *
+     * @param image the image
+     * @return the builder
+     */
+    public static AnimatedImageResultBuilder newBuilder(AnimatedImage image) {
+        return new AnimatedImageResultBuilder(image);
+    }
+
+    /**
+     * Gets the underlying image.
+     *
+     * @return the underlying image
+     */
+    public AnimatedImage getImage() {
+        return mImage;
+    }
+
+    /**
+     * Gets the frame that should be used for the preview image. If the preview bitmap was fetched,
+     * this is the frame that it's for.
+     *
+     * @return the frame that should be used for the preview image
+     */
+    public int getFrameForPreview() {
+        return mFrameForPreview;
+    }
+
+    /**
+     * Gets a decoded frame. This will only return non-null if the {@code ImageDecodeOptions}
+     * were configured to decode all frames at decode time.
+     *
+     * @param index the index of the frame to get
+     * @return a reference to the preview bitmap which must be released by the caller when done or
+     * null if there is no preview bitmap set
+     */
+    public synchronized
+    @Nullable
+    CloseableReference<Bitmap> getDecodedFrame(int index) {
+        if (mDecodedFrames != null) {
+            return CloseableReference.cloneOrNull(mDecodedFrames.get(index));
+        }
+        return null;
+    }
+
+    /**
+     * Gets whether it has the decoded frame. This will only return true if the
+     * {@code ImageDecodeOptions} were configured to decode all frames at decode time.
+     *
+     * @param index the index of the frame to get
+     * @return true if the result has the decoded frame
+     */
+    public synchronized boolean hasDecodedFrame(int index) {
+        return mDecodedFrames != null && mDecodedFrames.get(index) != null;
+    }
+
+    /**
+     * Gets the bitmap for the preview frame. This will only return non-null if the
+     * {@code ImageDecodeOptions} were configured to decode the preview frame.
+     *
+     * @return a reference to the preview bitmap which must be released by the caller when done or
+     * null if there is no preview bitmap set
+     */
+    public synchronized CloseableReference<Bitmap> getPreviewBitmap() {
+        return CloseableReference.cloneOrNull(mPreviewBitmap);
+    }
+
+    /**
+     * Disposes the result, which releases the reference to any bitmaps.
+     */
+    public synchronized void dispose() {
+        CloseableReference.closeSafely(mPreviewBitmap);
+        mPreviewBitmap = null;
+        CloseableReference.closeSafely(mDecodedFrames);
+        mDecodedFrames = null;
     }
-    return null;
-  }
-
-  /**
-   * Gets whether it has the decoded frame. This will only return true if the
-   * {@code ImageDecodeOptions} were configured to decode all frames at decode time.
-   *
-   * @param index the index of the frame to get
-   * @return true if the result has the decoded frame
-   */
-  public synchronized boolean hasDecodedFrame(int index) {
-    return mDecodedFrames != null && mDecodedFrames.get(index) != null;
-  }
-
-  /**
-   * Gets the bitmap for the preview frame. This will only return non-null if the
-   * {@code ImageDecodeOptions} were configured to decode the preview frame.
-   *
-   * @return a reference to the preview bitmap which must be released by the caller when done or
-   *     null if there is no preview bitmap set
-   */
-  public synchronized CloseableReference<Bitmap> getPreviewBitmap() {
-    return CloseableReference.cloneOrNull(mPreviewBitmap);
-  }
-
-  /**
-   * Disposes the result, which releases the reference to any bitmaps.
-   */
-  public synchronized void dispose() {
-    CloseableReference.closeSafely(mPreviewBitmap);
-    mPreviewBitmap = null;
-    CloseableReference.closeSafely(mDecodedFrames);
-    mDecodedFrames = null;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResultBuilder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResultBuilder.java
index 541f4020d..31550a554 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResultBuilder.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/AnimatedImageResultBuilder.java
@@ -20,104 +20,104 @@
  */
 public class AnimatedImageResultBuilder {
 
-  private final AnimatedImage mImage;
-  private CloseableReference<Bitmap> mPreviewBitmap;
-  private List<CloseableReference<Bitmap>> mDecodedFrames;
-  private int mFrameForPreview;
+    private final AnimatedImage mImage;
+    private CloseableReference<Bitmap> mPreviewBitmap;
+    private List<CloseableReference<Bitmap>> mDecodedFrames;
+    private int mFrameForPreview;
 
-  AnimatedImageResultBuilder(AnimatedImage image) {
-    mImage = image;
-  }
+    AnimatedImageResultBuilder(AnimatedImage image) {
+        mImage = image;
+    }
 
-  /**
-   * Gets the image for the result.
-   *
-   * @return the image
-   */
-  public AnimatedImage getImage() {
-    return mImage;
-  }
+    /**
+     * Gets the image for the result.
+     *
+     * @return the image
+     */
+    public AnimatedImage getImage() {
+        return mImage;
+    }
 
-  /**
-   * Gets the preview bitmap. This method returns a new reference. The caller must close it.
-   *
-   * @return the reference to the preview bitmap or null if none was set. This returns a reference
-   *    that must be released by the caller
-   */
-  public CloseableReference<Bitmap> getPreviewBitmap() {
-    return CloseableReference.cloneOrNull(mPreviewBitmap);
-  }
+    /**
+     * Gets the preview bitmap. This method returns a new reference. The caller must close it.
+     *
+     * @return the reference to the preview bitmap or null if none was set. This returns a reference
+     * that must be released by the caller
+     */
+    public CloseableReference<Bitmap> getPreviewBitmap() {
+        return CloseableReference.cloneOrNull(mPreviewBitmap);
+    }
 
-  /**
-   * Sets a preview bitmap.
-   *
-   * @param previewBitmap the preview. The method clones the reference.
-   * @return this builder
-   */
-  public AnimatedImageResultBuilder setPreviewBitmap(CloseableReference<Bitmap> previewBitmap) {
-    mPreviewBitmap = CloseableReference.cloneOrNull(previewBitmap);
-    return this;
-  }
+    /**
+     * Sets a preview bitmap.
+     *
+     * @param previewBitmap the preview. The method clones the reference.
+     * @return this builder
+     */
+    public AnimatedImageResultBuilder setPreviewBitmap(CloseableReference<Bitmap> previewBitmap) {
+        mPreviewBitmap = CloseableReference.cloneOrNull(previewBitmap);
+        return this;
+    }
 
-  /**
-   * Gets the frame that should be used for the preview image. If the preview bitmap was fetched,
-   * this is the frame that it's for.
-   *
-   * @return the frame that should be used for the preview image
-   */
-  public int getFrameForPreview() {
-    return mFrameForPreview;
-  }
+    /**
+     * Gets the frame that should be used for the preview image. If the preview bitmap was fetched,
+     * this is the frame that it's for.
+     *
+     * @return the frame that should be used for the preview image
+     */
+    public int getFrameForPreview() {
+        return mFrameForPreview;
+    }
 
-  /**
-   * Sets the frame that should be used for the preview image. If the preview bitmap was fetched,
-   * this is the frame that it's for.
-   *
-   * @return the frame that should be used for the preview image
-   */
-  public AnimatedImageResultBuilder setFrameForPreview(int frameForPreview) {
-    mFrameForPreview = frameForPreview;
-    return this;
-  }
+    /**
+     * Sets the frame that should be used for the preview image. If the preview bitmap was fetched,
+     * this is the frame that it's for.
+     *
+     * @return the frame that should be used for the preview image
+     */
+    public AnimatedImageResultBuilder setFrameForPreview(int frameForPreview) {
+        mFrameForPreview = frameForPreview;
+        return this;
+    }
 
-  /**
-   * Gets the decoded frames. Only used if the {@code ImageDecodeOptions} were configured to
-   * decode all frames at decode time.
-   *
-   * @return the references to the decoded frames or null if none was set. This returns references
-   *    that must be released by the caller
-   */
-  public List<CloseableReference<Bitmap>> getDecodedFrames() {
-    return CloseableReference.cloneOrNull(mDecodedFrames);
-  }
+    /**
+     * Gets the decoded frames. Only used if the {@code ImageDecodeOptions} were configured to
+     * decode all frames at decode time.
+     *
+     * @return the references to the decoded frames or null if none was set. This returns references
+     * that must be released by the caller
+     */
+    public List<CloseableReference<Bitmap>> getDecodedFrames() {
+        return CloseableReference.cloneOrNull(mDecodedFrames);
+    }
 
-  /**
-   * Sets the decoded frames. Only used if the {@code ImageDecodeOptions} were configured to
-   * decode all frames at decode time.
-   *
-   * @param decodedFrames the decoded frames. The method clones the references.
-   */
-  public AnimatedImageResultBuilder setDecodedFrames(
-      List<CloseableReference<Bitmap>> decodedFrames) {
-    mDecodedFrames = CloseableReference.cloneOrNull(decodedFrames);
-    return this;
-  }
+    /**
+     * Sets the decoded frames. Only used if the {@code ImageDecodeOptions} were configured to
+     * decode all frames at decode time.
+     *
+     * @param decodedFrames the decoded frames. The method clones the references.
+     */
+    public AnimatedImageResultBuilder setDecodedFrames(
+            List<CloseableReference<Bitmap>> decodedFrames) {
+        mDecodedFrames = CloseableReference.cloneOrNull(decodedFrames);
+        return this;
+    }
 
-  /**
-   * Builds the {@link AnimatedImageResult}. The preview bitmap and the decoded frames are closed
-   * after build is called, so this should not be called more than once or those fields will be lost
-   * after the first call.
-   *
-   * @return the result
-   */
-  public AnimatedImageResult build() {
-    try {
-      return new AnimatedImageResult(this);
-    } finally {
-      CloseableReference.closeSafely(mPreviewBitmap);
-      mPreviewBitmap = null;
-      CloseableReference.closeSafely(mDecodedFrames);
-      mDecodedFrames = null;
+    /**
+     * Builds the {@link AnimatedImageResult}. The preview bitmap and the decoded frames are closed
+     * after build is called, so this should not be called more than once or those fields will be lost
+     * after the first call.
+     *
+     * @return the result
+     */
+    public AnimatedImageResult build() {
+        try {
+            return new AnimatedImageResult(this);
+        } finally {
+            CloseableReference.closeSafely(mPreviewBitmap);
+            mPreviewBitmap = null;
+            CloseableReference.closeSafely(mDecodedFrames);
+            mDecodedFrames = null;
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/DelegatingAnimatedDrawableBackend.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/DelegatingAnimatedDrawableBackend.java
index 7cf223c71..3196de860 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/DelegatingAnimatedDrawableBackend.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/base/DelegatingAnimatedDrawableBackend.java
@@ -20,103 +20,103 @@
  */
 public abstract class DelegatingAnimatedDrawableBackend implements AnimatedDrawableBackend {
 
-  private final AnimatedDrawableBackend mAnimatedDrawableBackend;
-
-  public DelegatingAnimatedDrawableBackend(AnimatedDrawableBackend animatedDrawableBackend) {
-    mAnimatedDrawableBackend = animatedDrawableBackend;
-  }
-
-  protected AnimatedDrawableBackend getDelegate() {
-    return mAnimatedDrawableBackend;
-  }
-
-  @Override
-  public AnimatedImageResult getAnimatedImageResult() {
-    return mAnimatedDrawableBackend.getAnimatedImageResult();
-  }
-
-  @Override
-  public int getDurationMs() {
-    return mAnimatedDrawableBackend.getDurationMs();
-  }
-
-  @Override
-  public int getFrameCount() {
-    return mAnimatedDrawableBackend.getFrameCount();
-  }
-
-  @Override
-  public int getLoopCount() {
-    return mAnimatedDrawableBackend.getLoopCount();
-  }
-
-  @Override
-  public int getWidth() {
-    return mAnimatedDrawableBackend.getWidth();
-  }
-
-  @Override
-  public int getHeight() {
-    return mAnimatedDrawableBackend.getHeight();
-  }
-
-  @Override
-  public int getRenderedWidth() {
-    return mAnimatedDrawableBackend.getRenderedWidth();
-  }
-
-  @Override
-  public int getRenderedHeight() {
-    return mAnimatedDrawableBackend.getRenderedHeight();
-  }
-
-  @Override
-  public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
-    return mAnimatedDrawableBackend.getFrameInfo(frameNumber);
-  }
-
-  @Override
-  public void renderFrame(int frameNumber, Canvas canvas) {
-    mAnimatedDrawableBackend.renderFrame(frameNumber, canvas);
-  }
-
-  @Override
-  public int getFrameForTimestampMs(int timestampMs) {
-    return mAnimatedDrawableBackend.getFrameForTimestampMs(timestampMs);
-  }
-
-  @Override
-  public int getTimestampMsForFrame(int frameNumber) {
-    return mAnimatedDrawableBackend.getTimestampMsForFrame(frameNumber);
-  }
-
-  @Override
-  public int getDurationMsForFrame(int frameNumber) {
-    return mAnimatedDrawableBackend.getDurationMsForFrame(frameNumber);
-  }
-
-  @Override
-  public int getFrameForPreview() {
-    return mAnimatedDrawableBackend.getFrameForPreview();
-  }
-
-  @Override
-  public int getMemoryUsage() {
-    return mAnimatedDrawableBackend.getMemoryUsage();
-  }
-
-  @Override
-  public CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber) {
-    return mAnimatedDrawableBackend.getPreDecodedFrame(frameNumber);
-  }
-
-  @Override
-  public boolean hasPreDecodedFrame(int frameNumber) {
-    return mAnimatedDrawableBackend.hasPreDecodedFrame(frameNumber);
-  }
-
-  @Override
-  public void dropCaches() {
-    mAnimatedDrawableBackend.dropCaches();
-  }
+    private final AnimatedDrawableBackend mAnimatedDrawableBackend;
+
+    public DelegatingAnimatedDrawableBackend(AnimatedDrawableBackend animatedDrawableBackend) {
+        mAnimatedDrawableBackend = animatedDrawableBackend;
+    }
+
+    protected AnimatedDrawableBackend getDelegate() {
+        return mAnimatedDrawableBackend;
+    }
+
+    @Override
+    public AnimatedImageResult getAnimatedImageResult() {
+        return mAnimatedDrawableBackend.getAnimatedImageResult();
+    }
+
+    @Override
+    public int getDurationMs() {
+        return mAnimatedDrawableBackend.getDurationMs();
+    }
+
+    @Override
+    public int getFrameCount() {
+        return mAnimatedDrawableBackend.getFrameCount();
+    }
+
+    @Override
+    public int getLoopCount() {
+        return mAnimatedDrawableBackend.getLoopCount();
+    }
+
+    @Override
+    public int getWidth() {
+        return mAnimatedDrawableBackend.getWidth();
+    }
+
+    @Override
+    public int getHeight() {
+        return mAnimatedDrawableBackend.getHeight();
+    }
+
+    @Override
+    public int getRenderedWidth() {
+        return mAnimatedDrawableBackend.getRenderedWidth();
+    }
+
+    @Override
+    public int getRenderedHeight() {
+        return mAnimatedDrawableBackend.getRenderedHeight();
+    }
+
+    @Override
+    public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
+        return mAnimatedDrawableBackend.getFrameInfo(frameNumber);
+    }
+
+    @Override
+    public void renderFrame(int frameNumber, Canvas canvas) {
+        mAnimatedDrawableBackend.renderFrame(frameNumber, canvas);
+    }
+
+    @Override
+    public int getFrameForTimestampMs(int timestampMs) {
+        return mAnimatedDrawableBackend.getFrameForTimestampMs(timestampMs);
+    }
+
+    @Override
+    public int getTimestampMsForFrame(int frameNumber) {
+        return mAnimatedDrawableBackend.getTimestampMsForFrame(frameNumber);
+    }
+
+    @Override
+    public int getDurationMsForFrame(int frameNumber) {
+        return mAnimatedDrawableBackend.getDurationMsForFrame(frameNumber);
+    }
+
+    @Override
+    public int getFrameForPreview() {
+        return mAnimatedDrawableBackend.getFrameForPreview();
+    }
+
+    @Override
+    public int getMemoryUsage() {
+        return mAnimatedDrawableBackend.getMemoryUsage();
+    }
+
+    @Override
+    public CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber) {
+        return mAnimatedDrawableBackend.getPreDecodedFrame(frameNumber);
+    }
+
+    @Override
+    public boolean hasPreDecodedFrame(int frameNumber) {
+        return mAnimatedDrawableBackend.hasPreDecodedFrame(frameNumber);
+    }
+
+    @Override
+    public void dropCaches() {
+        mAnimatedDrawableBackend.dropCaches();
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactory.java
index c201d9995..bffa170bd 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedDrawableFactory.java
@@ -36,80 +36,80 @@
  */
 public class AnimatedDrawableFactory {
 
-  private final AnimatedDrawableBackendProvider mAnimatedDrawableBackendProvider;
-  private final AnimatedDrawableCachingBackendImplProvider mAnimatedDrawableCachingBackendProvider;
-  private final AnimatedDrawableUtil mAnimatedDrawableUtil;
-  private final ScheduledExecutorService mScheduledExecutorServiceForUiThread;
-  private final MonotonicClock mMonotonicClock;
-  private final Resources mResources;
+    private final AnimatedDrawableBackendProvider mAnimatedDrawableBackendProvider;
+    private final AnimatedDrawableCachingBackendImplProvider mAnimatedDrawableCachingBackendProvider;
+    private final AnimatedDrawableUtil mAnimatedDrawableUtil;
+    private final ScheduledExecutorService mScheduledExecutorServiceForUiThread;
+    private final MonotonicClock mMonotonicClock;
+    private final Resources mResources;
 
-  public AnimatedDrawableFactory(
-      AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
-      AnimatedDrawableCachingBackendImplProvider animatedDrawableCachingBackendProvider,
-      AnimatedDrawableUtil animatedDrawableUtil,
-      ScheduledExecutorService scheduledExecutorService,
-      Resources resources) {
-    mAnimatedDrawableBackendProvider = animatedDrawableBackendProvider;
-    mAnimatedDrawableCachingBackendProvider = animatedDrawableCachingBackendProvider;
-    mAnimatedDrawableUtil = animatedDrawableUtil;
-    mScheduledExecutorServiceForUiThread = scheduledExecutorService;
-    mMonotonicClock = new MonotonicClock() {
-      @Override
-      public long now() {
-        // Must be SystemClock.uptimeMillis to be compatible with what Android's View uses.
-        return SystemClock.uptimeMillis();
-      }
-    };
-    mResources = resources;
-  }
-
-  /**
-   * Creates an {@link AnimatedDrawable} based on an {@link AnimatedImage}.
-   *
-   * @param animatedImageResult the result of the code
-   * @return a newly constructed {@link AnimatedDrawable}
-   */
-  public AnimatedDrawable create(AnimatedImageResult animatedImageResult) {
-    return create(animatedImageResult, AnimatedDrawableOptions.DEFAULTS);
-  }
+    public AnimatedDrawableFactory(
+            AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
+            AnimatedDrawableCachingBackendImplProvider animatedDrawableCachingBackendProvider,
+            AnimatedDrawableUtil animatedDrawableUtil,
+            ScheduledExecutorService scheduledExecutorService,
+            Resources resources) {
+        mAnimatedDrawableBackendProvider = animatedDrawableBackendProvider;
+        mAnimatedDrawableCachingBackendProvider = animatedDrawableCachingBackendProvider;
+        mAnimatedDrawableUtil = animatedDrawableUtil;
+        mScheduledExecutorServiceForUiThread = scheduledExecutorService;
+        mMonotonicClock = new MonotonicClock() {
+            @Override
+            public long now() {
+                // Must be SystemClock.uptimeMillis to be compatible with what Android's View uses.
+                return SystemClock.uptimeMillis();
+            }
+        };
+        mResources = resources;
+    }
 
-  /**
-   * Creates an {@link AnimatedDrawable} based on an {@link AnimatedImage}.
-   *
-   * @param animatedImageResult the result of the code
-   * @param options additional options
-   * @return a newly constructed {@link AnimatedDrawable}
-   */
-  public AnimatedDrawable create(
-      AnimatedImageResult animatedImageResult,
-      AnimatedDrawableOptions options) {
-    AnimatedImage animatedImage = animatedImageResult.getImage();
-    Rect initialBounds = new Rect(0, 0, animatedImage.getWidth(), animatedImage.getHeight());
-    AnimatedDrawableBackend animatedDrawableBackend =
-        mAnimatedDrawableBackendProvider.get(animatedImageResult, initialBounds);
-    return createAnimatedDrawable(options, animatedDrawableBackend);
-  }
+    /**
+     * Creates an {@link AnimatedDrawable} based on an {@link AnimatedImage}.
+     *
+     * @param animatedImageResult the result of the code
+     * @return a newly constructed {@link AnimatedDrawable}
+     */
+    public AnimatedDrawable create(AnimatedImageResult animatedImageResult) {
+        return create(animatedImageResult, AnimatedDrawableOptions.DEFAULTS);
+    }
 
-  private AnimatedDrawable createAnimatedDrawable(
-      AnimatedDrawableOptions options,
-      AnimatedDrawableBackend animatedDrawableBackend) {
-    DisplayMetrics displayMetrics = mResources.getDisplayMetrics();
-    AnimatedDrawableDiagnostics animatedDrawableDiagnostics;
-    AnimatedDrawableCachingBackend animatedDrawableCachingBackend =
-        mAnimatedDrawableCachingBackendProvider.get(
-            animatedDrawableBackend,
-            options);
-    if (options.enableDebugging) {
-      animatedDrawableDiagnostics =
-          new AnimatedDrawableDiagnosticsImpl(mAnimatedDrawableUtil, displayMetrics);
-    } else {
-      animatedDrawableDiagnostics = AnimatedDrawableDiagnosticsNoop.getInstance();
+    /**
+     * Creates an {@link AnimatedDrawable} based on an {@link AnimatedImage}.
+     *
+     * @param animatedImageResult the result of the code
+     * @param options             additional options
+     * @return a newly constructed {@link AnimatedDrawable}
+     */
+    public AnimatedDrawable create(
+            AnimatedImageResult animatedImageResult,
+            AnimatedDrawableOptions options) {
+        AnimatedImage animatedImage = animatedImageResult.getImage();
+        Rect initialBounds = new Rect(0, 0, animatedImage.getWidth(), animatedImage.getHeight());
+        AnimatedDrawableBackend animatedDrawableBackend =
+                mAnimatedDrawableBackendProvider.get(animatedImageResult, initialBounds);
+        return createAnimatedDrawable(options, animatedDrawableBackend);
     }
 
-    return new AnimatedDrawable(
-        mScheduledExecutorServiceForUiThread,
-        animatedDrawableCachingBackend,
-        animatedDrawableDiagnostics,
-        mMonotonicClock);
-  }
+    private AnimatedDrawable createAnimatedDrawable(
+            AnimatedDrawableOptions options,
+            AnimatedDrawableBackend animatedDrawableBackend) {
+        DisplayMetrics displayMetrics = mResources.getDisplayMetrics();
+        AnimatedDrawableDiagnostics animatedDrawableDiagnostics;
+        AnimatedDrawableCachingBackend animatedDrawableCachingBackend =
+                mAnimatedDrawableCachingBackendProvider.get(
+                        animatedDrawableBackend,
+                        options);
+        if (options.enableDebugging) {
+            animatedDrawableDiagnostics =
+                    new AnimatedDrawableDiagnosticsImpl(mAnimatedDrawableUtil, displayMetrics);
+        } else {
+            animatedDrawableDiagnostics = AnimatedDrawableDiagnosticsNoop.getInstance();
+        }
+
+        return new AnimatedDrawable(
+                mScheduledExecutorServiceForUiThread,
+                animatedDrawableCachingBackend,
+                animatedDrawableDiagnostics,
+                mMonotonicClock);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactory.java
index 6832be0ec..4b6b8d45a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactory.java
@@ -37,135 +37,135 @@
  */
 public class AnimatedImageFactory {
 
-  private final AnimatedDrawableBackendProvider mAnimatedDrawableBackendProvider;
-  private final PlatformBitmapFactory mBitmapFactory;
-
-  public AnimatedImageFactory(
-      AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
-      PlatformBitmapFactory bitmapFactory) {
-    mAnimatedDrawableBackendProvider = animatedDrawableBackendProvider;
-    mBitmapFactory = bitmapFactory;
-  }
-
-  /**
-   * Decodes a GIF into a CloseableImage.
-   *
-   * @param pooledByteBufferRef native byte array holding the encoded bytes
-   * @param options the options for the decode
-   * @return a {@link CloseableImage} for the GIF image
-   */
-  public CloseableImage decodeGif(
-      final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
-      final ImageDecodeOptions options) {
-    Preconditions.checkState(!options.forceOldAnimationCode);
-    final PooledByteBuffer input = pooledByteBufferRef.get();
-    GifImage gifImage = GifImage.create(input.getNativePtr(), input.size());
-
-    return getCloseableImage(options, gifImage);
-  }
-
-  /**
-   * Decode a WebP into a CloseableImage.
-   *
-   * @param pooledByteBufferRef native byte array holding the encoded bytes
-   * @param options the options for the decode
-   * @return a {@link CloseableImage} for the WebP image
-   */
-  public CloseableImage decodeWebP(
-      final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
-      final ImageDecodeOptions options) {
-    Preconditions.checkArgument(!options.forceOldAnimationCode);
-    final PooledByteBuffer input = pooledByteBufferRef.get();
-    WebPImage webPImage = WebPImage.create(input.getNativePtr(), input.size());
-    return getCloseableImage(options, webPImage);
-  }
-
-  private CloseableAnimatedImage getCloseableImage(
-      ImageDecodeOptions options,
-      AnimatedImage image) {
-    List<CloseableReference<Bitmap>> decodedFrames = null;
-    CloseableReference<Bitmap> previewBitmap = null;
-    try {
-      int frameForPreview = options.useLastFrameForPreview ? image.getFrameCount() - 1 : 0;
-      if (options.decodeAllFrames) {
-        decodedFrames = decodeAllFrames(image);
-        previewBitmap = CloseableReference.cloneOrNull(decodedFrames.get(frameForPreview));
-      }
-
-      if (options.decodePreviewFrame && previewBitmap == null) {
-        previewBitmap = createPreviewBitmap(image, frameForPreview);
-      }
-      AnimatedImageResult animatedImageResult = AnimatedImageResult.newBuilder(image)
-          .setPreviewBitmap(previewBitmap)
-          .setFrameForPreview(frameForPreview)
-          .setDecodedFrames(decodedFrames)
-          .build();
-      return new CloseableAnimatedImage(animatedImageResult);
-    } finally {
-      CloseableReference.closeSafely(previewBitmap);
-      CloseableReference.closeSafely(decodedFrames);
+    private final AnimatedDrawableBackendProvider mAnimatedDrawableBackendProvider;
+    private final PlatformBitmapFactory mBitmapFactory;
+
+    public AnimatedImageFactory(
+            AnimatedDrawableBackendProvider animatedDrawableBackendProvider,
+            PlatformBitmapFactory bitmapFactory) {
+        mAnimatedDrawableBackendProvider = animatedDrawableBackendProvider;
+        mBitmapFactory = bitmapFactory;
     }
-  }
-
-  private CloseableReference<Bitmap> createPreviewBitmap(
-      AnimatedImage image,
-      int frameForPreview) {
-    CloseableReference<Bitmap> bitmap = createBitmap(image.getWidth(), image.getHeight());
-    AnimatedImageResult tempResult = AnimatedImageResult.forAnimatedImage(image);
-    AnimatedDrawableBackend drawableBackend =
-        mAnimatedDrawableBackendProvider.get(tempResult, null);
-    AnimatedImageCompositor animatedImageCompositor = new AnimatedImageCompositor(
-        drawableBackend,
-        new AnimatedImageCompositor.Callback() {
-          @Override
-          public void onIntermediateResult(int frameNumber, Bitmap bitmap) {
-            // Don't care.
-          }
-
-          @Override
-          public CloseableReference<Bitmap> getCachedBitmap(int frameNumber) {
-            return null;
-          }
-        });
-    animatedImageCompositor.renderFrame(frameForPreview, bitmap.get());
-    return bitmap;
-  }
-
-  private List<CloseableReference<Bitmap>> decodeAllFrames(AnimatedImage image) {
-
-    final List<CloseableReference<Bitmap>> bitmaps = new ArrayList<>();
-    AnimatedImageResult tempResult = AnimatedImageResult.forAnimatedImage(image);
-    AnimatedDrawableBackend drawableBackend =
-        mAnimatedDrawableBackendProvider.get(tempResult, null);
-    AnimatedImageCompositor animatedImageCompositor = new AnimatedImageCompositor(
-        drawableBackend,
-        new AnimatedImageCompositor.Callback() {
-          @Override
-          public void onIntermediateResult(int frameNumber, Bitmap bitmap) {
-            // Don't care.
-          }
-
-          @Override
-          public CloseableReference<Bitmap> getCachedBitmap(int frameNumber) {
-            return CloseableReference.cloneOrNull(bitmaps.get(frameNumber));
-          }
-        });
-    for (int i = 0; i < drawableBackend.getFrameCount(); i++) {
-      CloseableReference<Bitmap> bitmap = createBitmap(
-          drawableBackend.getWidth(), drawableBackend.getHeight());
-      animatedImageCompositor.renderFrame(i, bitmap.get());
-      bitmaps.add(bitmap);
+
+    /**
+     * Decodes a GIF into a CloseableImage.
+     *
+     * @param pooledByteBufferRef native byte array holding the encoded bytes
+     * @param options             the options for the decode
+     * @return a {@link CloseableImage} for the GIF image
+     */
+    public CloseableImage decodeGif(
+            final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
+            final ImageDecodeOptions options) {
+        Preconditions.checkState(!options.forceOldAnimationCode);
+        final PooledByteBuffer input = pooledByteBufferRef.get();
+        GifImage gifImage = GifImage.create(input.getNativePtr(), input.size());
+
+        return getCloseableImage(options, gifImage);
+    }
+
+    /**
+     * Decode a WebP into a CloseableImage.
+     *
+     * @param pooledByteBufferRef native byte array holding the encoded bytes
+     * @param options             the options for the decode
+     * @return a {@link CloseableImage} for the WebP image
+     */
+    public CloseableImage decodeWebP(
+            final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
+            final ImageDecodeOptions options) {
+        Preconditions.checkArgument(!options.forceOldAnimationCode);
+        final PooledByteBuffer input = pooledByteBufferRef.get();
+        WebPImage webPImage = WebPImage.create(input.getNativePtr(), input.size());
+        return getCloseableImage(options, webPImage);
+    }
+
+    private CloseableAnimatedImage getCloseableImage(
+            ImageDecodeOptions options,
+            AnimatedImage image) {
+        List<CloseableReference<Bitmap>> decodedFrames = null;
+        CloseableReference<Bitmap> previewBitmap = null;
+        try {
+            int frameForPreview = options.useLastFrameForPreview ? image.getFrameCount() - 1 : 0;
+            if (options.decodeAllFrames) {
+                decodedFrames = decodeAllFrames(image);
+                previewBitmap = CloseableReference.cloneOrNull(decodedFrames.get(frameForPreview));
+            }
+
+            if (options.decodePreviewFrame && previewBitmap == null) {
+                previewBitmap = createPreviewBitmap(image, frameForPreview);
+            }
+            AnimatedImageResult animatedImageResult = AnimatedImageResult.newBuilder(image)
+                    .setPreviewBitmap(previewBitmap)
+                    .setFrameForPreview(frameForPreview)
+                    .setDecodedFrames(decodedFrames)
+                    .build();
+            return new CloseableAnimatedImage(animatedImageResult);
+        } finally {
+            CloseableReference.closeSafely(previewBitmap);
+            CloseableReference.closeSafely(decodedFrames);
+        }
     }
-    return bitmaps;
-  }
-
-  @SuppressLint("NewApi")
-  private CloseableReference<Bitmap> createBitmap(int width, int height) {
-    CloseableReference<Bitmap> bitmap = mBitmapFactory.createBitmap(width, height);
-    bitmap.get().eraseColor(Color.TRANSPARENT);
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
-      bitmap.get().setHasAlpha(true);
+
+    private CloseableReference<Bitmap> createPreviewBitmap(
+            AnimatedImage image,
+            int frameForPreview) {
+        CloseableReference<Bitmap> bitmap = createBitmap(image.getWidth(), image.getHeight());
+        AnimatedImageResult tempResult = AnimatedImageResult.forAnimatedImage(image);
+        AnimatedDrawableBackend drawableBackend =
+                mAnimatedDrawableBackendProvider.get(tempResult, null);
+        AnimatedImageCompositor animatedImageCompositor = new AnimatedImageCompositor(
+                drawableBackend,
+                new AnimatedImageCompositor.Callback() {
+                    @Override
+                    public void onIntermediateResult(int frameNumber, Bitmap bitmap) {
+                        // Don't care.
+                    }
+
+                    @Override
+                    public CloseableReference<Bitmap> getCachedBitmap(int frameNumber) {
+                        return null;
+                    }
+                });
+        animatedImageCompositor.renderFrame(frameForPreview, bitmap.get());
+        return bitmap;
+    }
+
+    private List<CloseableReference<Bitmap>> decodeAllFrames(AnimatedImage image) {
+
+        final List<CloseableReference<Bitmap>> bitmaps = new ArrayList<>();
+        AnimatedImageResult tempResult = AnimatedImageResult.forAnimatedImage(image);
+        AnimatedDrawableBackend drawableBackend =
+                mAnimatedDrawableBackendProvider.get(tempResult, null);
+        AnimatedImageCompositor animatedImageCompositor = new AnimatedImageCompositor(
+                drawableBackend,
+                new AnimatedImageCompositor.Callback() {
+                    @Override
+                    public void onIntermediateResult(int frameNumber, Bitmap bitmap) {
+                        // Don't care.
+                    }
+
+                    @Override
+                    public CloseableReference<Bitmap> getCachedBitmap(int frameNumber) {
+                        return CloseableReference.cloneOrNull(bitmaps.get(frameNumber));
+                    }
+                });
+        for (int i = 0; i < drawableBackend.getFrameCount(); i++) {
+            CloseableReference<Bitmap> bitmap = createBitmap(
+                    drawableBackend.getWidth(), drawableBackend.getHeight());
+            animatedImageCompositor.renderFrame(i, bitmap.get());
+            bitmaps.add(bitmap);
+        }
+        return bitmaps;
+    }
+
+    @SuppressLint("NewApi")
+    private CloseableReference<Bitmap> createBitmap(int width, int height) {
+        CloseableReference<Bitmap> bitmap = mBitmapFactory.createBitmap(width, height);
+        bitmap.get().eraseColor(Color.TRANSPARENT);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
+            bitmap.get().setHasAlpha(true);
+        }
+        return bitmap;
     }
-    return bitmap;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java
index 5cd0b6abc..ae76bb2bb 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendImpl.java
@@ -31,215 +31,215 @@
  */
 public class AnimatedDrawableBackendImpl implements AnimatedDrawableBackend {
 
-  private static final Class<?> TAG = AnimatedDrawableBackendImpl.class;
-
-  private final AnimatedDrawableUtil mAnimatedDrawableUtil;
-
-  private final AnimatedImageResult mAnimatedImageResult;
-  private final AnimatedImage mAnimatedImage;
-  private final Rect mRenderedBounds;
-  private final int[] mFrameDurationsMs;
-  private final int[] mFrameTimestampsMs;
-  private final int mDurationMs;
-  private final AnimatedDrawableFrameInfo[] mFrameInfos;
-
-  @GuardedBy("this")
-  private Bitmap mTempBitmap;
-
-  public AnimatedDrawableBackendImpl(
-      AnimatedDrawableUtil animatedDrawableUtil,
-      AnimatedImageResult animatedImageResult,
-      Rect bounds) {
-    mAnimatedDrawableUtil = animatedDrawableUtil;
-    mAnimatedImageResult = animatedImageResult;
-    mAnimatedImage = animatedImageResult.getImage();
-    mFrameDurationsMs = mAnimatedImage.getFrameDurations();
-    mAnimatedDrawableUtil.fixFrameDurations(mFrameDurationsMs);
-    mDurationMs = mAnimatedDrawableUtil.getTotalDurationFromFrameDurations(mFrameDurationsMs);
-    mFrameTimestampsMs = mAnimatedDrawableUtil.getFrameTimeStampsFromDurations(mFrameDurationsMs);
-    mRenderedBounds = getBoundsToUse(mAnimatedImage, bounds);
-    mFrameInfos = new AnimatedDrawableFrameInfo[mAnimatedImage.getFrameCount()];
-    for (int i = 0; i < mAnimatedImage.getFrameCount(); i++) {
-      mFrameInfos[i] = mAnimatedImage.getFrameInfo(i);
-    }
-  }
-
-  private static Rect getBoundsToUse(AnimatedImage image, Rect targetBounds) {
-    if (targetBounds == null) {
-      return new Rect(0, 0, image.getWidth(), image.getHeight());
-    }
-    return new Rect(
-        0,
-        0,
-        Math.min(targetBounds.width(), image.getWidth()),
-        Math.min(targetBounds.height(), image.getHeight()));
-  }
-
-  @Override
-  public AnimatedImageResult getAnimatedImageResult() {
-    return mAnimatedImageResult;
-  }
-
-  @Override
-  public int getDurationMs() {
-    return mDurationMs;
-  }
-
-  @Override
-  public int getFrameCount() {
-    return mAnimatedImage.getFrameCount();
-  }
-
-  @Override
-  public int getLoopCount() {
-    return mAnimatedImage.getLoopCount();
-  }
-
-  @Override
-  public int getWidth() {
-    return mAnimatedImage.getWidth();
-  }
-
-  @Override
-  public int getHeight() {
-    return mAnimatedImage.getHeight();
-  }
-
-  @Override
-  public int getRenderedWidth() {
-    return mRenderedBounds.width();
-  }
-
-  @Override
-  public int getRenderedHeight() {
-    return mRenderedBounds.height();
-  }
-
-  @Override
-  public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
-    return mFrameInfos[frameNumber];
-  }
-
-  @Override
-  public int getFrameForTimestampMs(int timestampMs) {
-    return mAnimatedDrawableUtil.getFrameForTimestampMs(mFrameTimestampsMs, timestampMs);
-  }
-
-  @Override
-  public int getTimestampMsForFrame(int frameNumber) {
-    Preconditions.checkElementIndex(frameNumber, mFrameTimestampsMs.length);
-    return mFrameTimestampsMs[frameNumber];
-  }
-
-  @Override
-  public int getDurationMsForFrame(int frameNumber) {
-    return mFrameDurationsMs[frameNumber];
-  }
-
-  @Override
-  public int getFrameForPreview() {
-    return mAnimatedImageResult.getFrameForPreview();
-  }
-
-  @Override
-  public AnimatedDrawableBackend forNewBounds(Rect bounds) {
-    Rect boundsToUse = getBoundsToUse(mAnimatedImage, bounds);
-    if (boundsToUse.equals(mRenderedBounds)) {
-      // Actual bounds aren't changed.
-      return this;
-    }
-    return new AnimatedDrawableBackendImpl(
-        mAnimatedDrawableUtil,
-        mAnimatedImageResult,
-        bounds);
-  }
-
-  @Override
-  public synchronized int getMemoryUsage() {
-    int bytes = 0;
-    if (mTempBitmap != null) {
-      bytes += mAnimatedDrawableUtil.getSizeOfBitmap(mTempBitmap);
-    }
-    bytes += mAnimatedImage.getSizeInBytes();
-    return bytes;
-  }
-
-  @Override
-  public CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber) {
-    return mAnimatedImageResult.getDecodedFrame(frameNumber);
-  }
-
-  @Override
-  public boolean hasPreDecodedFrame(int index) {
-    return mAnimatedImageResult.hasDecodedFrame(index);
-  }
-
-  @Override
-  public void renderFrame(int frameNumber, Canvas canvas) {
-    AnimatedImageFrame frame  = mAnimatedImage.getFrame(frameNumber);
-    try {
-      if (mAnimatedImage.doesRenderSupportScaling()) {
-        renderImageSupportsScaling(canvas, frame);
-      } else {
-        renderImageDoesNotSupportScaling(canvas, frame);
-      }
-    } finally {
-      frame.dispose();
-    }
-  }
-
-  private void renderImageSupportsScaling(Canvas canvas, AnimatedImageFrame frame) {
-    double xScale = (double) mRenderedBounds.width() / (double) mAnimatedImage.getWidth();
-    double yScale = (double) mRenderedBounds.height() / (double) mAnimatedImage.getHeight();
-
-    int frameWidth = (int) Math.round(frame.getWidth() * xScale);
-    int frameHeight = (int) Math.round(frame.getHeight() * yScale);
-    int xOffset = (int) (frame.getXOffset() * xScale);
-    int yOffset = (int) (frame.getYOffset() * yScale);
-
-    synchronized (this) {
-      if (mTempBitmap == null) {
-        mTempBitmap = Bitmap.createBitmap(
-            mRenderedBounds.width(),
-            mRenderedBounds.height(),
-            Bitmap.Config.ARGB_8888);
-      }
-      mTempBitmap.eraseColor(Color.TRANSPARENT);
-      frame.renderFrame(frameWidth, frameHeight, mTempBitmap);
-      canvas.drawBitmap(mTempBitmap, xOffset, yOffset, null);
-    }
-  }
-
-  public void renderImageDoesNotSupportScaling(Canvas canvas, AnimatedImageFrame frame) {
-    int frameWidth = frame.getWidth();
-    int frameHeight = frame.getHeight();
-    int xOffset = frame.getXOffset();
-    int yOffset = frame.getYOffset();
-    synchronized (this) {
-      if (mTempBitmap == null) {
-        mTempBitmap = Bitmap.createBitmap(
-            mAnimatedImage.getWidth(),
-            mAnimatedImage.getHeight(),
-            Bitmap.Config.ARGB_8888);
-      }
-      mTempBitmap.eraseColor(Color.TRANSPARENT);
-      frame.renderFrame(frameWidth, frameHeight, mTempBitmap);
-
-      float xScale = (float) mRenderedBounds.width() / (float) mAnimatedImage.getWidth();
-      float yScale = (float) mRenderedBounds.height() / (float) mAnimatedImage.getHeight();
-      canvas.save();
-      canvas.scale(xScale, yScale);
-      canvas.translate(xOffset, yOffset);
-      canvas.drawBitmap(mTempBitmap, 0, 0, null);
-      canvas.restore();
-    }
-  }
-
-  @Override
-  public synchronized void dropCaches() {
-    if (mTempBitmap != null) {
-      mTempBitmap.recycle();
-      mTempBitmap = null;
-    }
-  }
+    private static final Class<?> TAG = AnimatedDrawableBackendImpl.class;
+
+    private final AnimatedDrawableUtil mAnimatedDrawableUtil;
+
+    private final AnimatedImageResult mAnimatedImageResult;
+    private final AnimatedImage mAnimatedImage;
+    private final Rect mRenderedBounds;
+    private final int[] mFrameDurationsMs;
+    private final int[] mFrameTimestampsMs;
+    private final int mDurationMs;
+    private final AnimatedDrawableFrameInfo[] mFrameInfos;
+
+    @GuardedBy("this")
+    private Bitmap mTempBitmap;
+
+    public AnimatedDrawableBackendImpl(
+            AnimatedDrawableUtil animatedDrawableUtil,
+            AnimatedImageResult animatedImageResult,
+            Rect bounds) {
+        mAnimatedDrawableUtil = animatedDrawableUtil;
+        mAnimatedImageResult = animatedImageResult;
+        mAnimatedImage = animatedImageResult.getImage();
+        mFrameDurationsMs = mAnimatedImage.getFrameDurations();
+        mAnimatedDrawableUtil.fixFrameDurations(mFrameDurationsMs);
+        mDurationMs = mAnimatedDrawableUtil.getTotalDurationFromFrameDurations(mFrameDurationsMs);
+        mFrameTimestampsMs = mAnimatedDrawableUtil.getFrameTimeStampsFromDurations(mFrameDurationsMs);
+        mRenderedBounds = getBoundsToUse(mAnimatedImage, bounds);
+        mFrameInfos = new AnimatedDrawableFrameInfo[mAnimatedImage.getFrameCount()];
+        for (int i = 0; i < mAnimatedImage.getFrameCount(); i++) {
+            mFrameInfos[i] = mAnimatedImage.getFrameInfo(i);
+        }
+    }
+
+    private static Rect getBoundsToUse(AnimatedImage image, Rect targetBounds) {
+        if (targetBounds == null) {
+            return new Rect(0, 0, image.getWidth(), image.getHeight());
+        }
+        return new Rect(
+                0,
+                0,
+                Math.min(targetBounds.width(), image.getWidth()),
+                Math.min(targetBounds.height(), image.getHeight()));
+    }
+
+    @Override
+    public AnimatedImageResult getAnimatedImageResult() {
+        return mAnimatedImageResult;
+    }
+
+    @Override
+    public int getDurationMs() {
+        return mDurationMs;
+    }
+
+    @Override
+    public int getFrameCount() {
+        return mAnimatedImage.getFrameCount();
+    }
+
+    @Override
+    public int getLoopCount() {
+        return mAnimatedImage.getLoopCount();
+    }
+
+    @Override
+    public int getWidth() {
+        return mAnimatedImage.getWidth();
+    }
+
+    @Override
+    public int getHeight() {
+        return mAnimatedImage.getHeight();
+    }
+
+    @Override
+    public int getRenderedWidth() {
+        return mRenderedBounds.width();
+    }
+
+    @Override
+    public int getRenderedHeight() {
+        return mRenderedBounds.height();
+    }
+
+    @Override
+    public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
+        return mFrameInfos[frameNumber];
+    }
+
+    @Override
+    public int getFrameForTimestampMs(int timestampMs) {
+        return mAnimatedDrawableUtil.getFrameForTimestampMs(mFrameTimestampsMs, timestampMs);
+    }
+
+    @Override
+    public int getTimestampMsForFrame(int frameNumber) {
+        Preconditions.checkElementIndex(frameNumber, mFrameTimestampsMs.length);
+        return mFrameTimestampsMs[frameNumber];
+    }
+
+    @Override
+    public int getDurationMsForFrame(int frameNumber) {
+        return mFrameDurationsMs[frameNumber];
+    }
+
+    @Override
+    public int getFrameForPreview() {
+        return mAnimatedImageResult.getFrameForPreview();
+    }
+
+    @Override
+    public AnimatedDrawableBackend forNewBounds(Rect bounds) {
+        Rect boundsToUse = getBoundsToUse(mAnimatedImage, bounds);
+        if (boundsToUse.equals(mRenderedBounds)) {
+            // Actual bounds aren't changed.
+            return this;
+        }
+        return new AnimatedDrawableBackendImpl(
+                mAnimatedDrawableUtil,
+                mAnimatedImageResult,
+                bounds);
+    }
+
+    @Override
+    public synchronized int getMemoryUsage() {
+        int bytes = 0;
+        if (mTempBitmap != null) {
+            bytes += mAnimatedDrawableUtil.getSizeOfBitmap(mTempBitmap);
+        }
+        bytes += mAnimatedImage.getSizeInBytes();
+        return bytes;
+    }
+
+    @Override
+    public CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber) {
+        return mAnimatedImageResult.getDecodedFrame(frameNumber);
+    }
+
+    @Override
+    public boolean hasPreDecodedFrame(int index) {
+        return mAnimatedImageResult.hasDecodedFrame(index);
+    }
+
+    @Override
+    public void renderFrame(int frameNumber, Canvas canvas) {
+        AnimatedImageFrame frame = mAnimatedImage.getFrame(frameNumber);
+        try {
+            if (mAnimatedImage.doesRenderSupportScaling()) {
+                renderImageSupportsScaling(canvas, frame);
+            } else {
+                renderImageDoesNotSupportScaling(canvas, frame);
+            }
+        } finally {
+            frame.dispose();
+        }
+    }
+
+    private void renderImageSupportsScaling(Canvas canvas, AnimatedImageFrame frame) {
+        double xScale = (double) mRenderedBounds.width() / (double) mAnimatedImage.getWidth();
+        double yScale = (double) mRenderedBounds.height() / (double) mAnimatedImage.getHeight();
+
+        int frameWidth = (int) Math.round(frame.getWidth() * xScale);
+        int frameHeight = (int) Math.round(frame.getHeight() * yScale);
+        int xOffset = (int) (frame.getXOffset() * xScale);
+        int yOffset = (int) (frame.getYOffset() * yScale);
+
+        synchronized (this) {
+            if (mTempBitmap == null) {
+                mTempBitmap = Bitmap.createBitmap(
+                        mRenderedBounds.width(),
+                        mRenderedBounds.height(),
+                        Bitmap.Config.ARGB_8888);
+            }
+            mTempBitmap.eraseColor(Color.TRANSPARENT);
+            frame.renderFrame(frameWidth, frameHeight, mTempBitmap);
+            canvas.drawBitmap(mTempBitmap, xOffset, yOffset, null);
+        }
+    }
+
+    public void renderImageDoesNotSupportScaling(Canvas canvas, AnimatedImageFrame frame) {
+        int frameWidth = frame.getWidth();
+        int frameHeight = frame.getHeight();
+        int xOffset = frame.getXOffset();
+        int yOffset = frame.getYOffset();
+        synchronized (this) {
+            if (mTempBitmap == null) {
+                mTempBitmap = Bitmap.createBitmap(
+                        mAnimatedImage.getWidth(),
+                        mAnimatedImage.getHeight(),
+                        Bitmap.Config.ARGB_8888);
+            }
+            mTempBitmap.eraseColor(Color.TRANSPARENT);
+            frame.renderFrame(frameWidth, frameHeight, mTempBitmap);
+
+            float xScale = (float) mRenderedBounds.width() / (float) mAnimatedImage.getWidth();
+            float yScale = (float) mRenderedBounds.height() / (float) mAnimatedImage.getHeight();
+            canvas.save();
+            canvas.scale(xScale, yScale);
+            canvas.translate(xOffset, yOffset);
+            canvas.drawBitmap(mTempBitmap, 0, 0, null);
+            canvas.restore();
+        }
+    }
+
+    @Override
+    public synchronized void dropCaches() {
+        if (mTempBitmap != null) {
+            mTempBitmap.recycle();
+            mTempBitmap = null;
+        }
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendProvider.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendProvider.java
index 843a1d40f..a9e00cc1c 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendProvider.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableBackendProvider.java
@@ -19,12 +19,12 @@
  */
 public interface AnimatedDrawableBackendProvider {
 
-  /**
-   * Creates a new {@link AnimatedDrawableBackend}.
-   *
-   * @param animatedImageResult the image result.
-   * @param bounds the initial bounds for the drawable
-   * @return a new {@link AnimatedDrawableBackend}
-   */
-  AnimatedDrawableBackend get(AnimatedImageResult animatedImageResult, Rect bounds);
+    /**
+     * Creates a new {@link AnimatedDrawableBackend}.
+     *
+     * @param animatedImageResult the image result.
+     * @param bounds              the initial bounds for the drawable
+     * @return a new {@link AnimatedDrawableBackend}
+     */
+    AnimatedDrawableBackend get(AnimatedImageResult animatedImageResult, Rect bounds);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImpl.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImpl.java
index 195b7aacf..5cbebdf9e 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImpl.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImpl.java
@@ -50,505 +50,505 @@
  * A caching and prefetching layer that delegates to a {@link AnimatedDrawableBackend}.
  */
 public class AnimatedDrawableCachingBackendImpl extends DelegatingAnimatedDrawableBackend
-    implements AnimatedDrawableCachingBackend {
-
-  private static final Class<?> TAG = AnimatedDrawableCachingBackendImpl.class;
-
-  private static final AtomicInteger sTotalBitmaps = new AtomicInteger();
-
-  private static final int PREFETCH_FRAMES = 3;
-
-  private final SerialExecutorService mExecutorService;
-  private final AnimatedDrawableUtil mAnimatedDrawableUtil;
-  private final ActivityManager mActivityManager;
-  private final MonotonicClock mMonotonicClock;
-  private final AnimatedDrawableBackend mAnimatedDrawableBackend;
-  private final AnimatedDrawableOptions mAnimatedDrawableOptions;
-  private final AnimatedImageCompositor mAnimatedImageCompositor;
-  private final ResourceReleaser<Bitmap> mResourceReleaserForBitmaps;
-  private final int mMaximumBytes;
-
-  private final int mApproxBytesToHoldAllFrames;
-
-  @GuardedBy("this")
-  private final List<Bitmap> mFreeBitmaps;
-
-  @GuardedBy("this")
-  private final SparseArrayCompat<Task<Object>> mDecodesInFlight;
-
-  @GuardedBy("this")
-  private final SparseArrayCompat<CloseableReference<Bitmap>> mCachedBitmaps;
-
-  @GuardedBy("this")
-  private final WhatToKeepCachedArray mBitmapsToKeepCached;
-
-  @GuardedBy("ui-thread")
-  private int mCurrentFrameIndex;
-
-  public AnimatedDrawableCachingBackendImpl(
-      SerialExecutorService executorService,
-      ActivityManager activityManager,
-      AnimatedDrawableUtil animatedDrawableUtil,
-      MonotonicClock monotonicClock,
-      AnimatedDrawableBackend animatedDrawableBackend,
-      AnimatedDrawableOptions options) {
-    super(animatedDrawableBackend);
-    mExecutorService = executorService;
-    mActivityManager = activityManager;
-    mAnimatedDrawableUtil = animatedDrawableUtil;
-    mMonotonicClock = monotonicClock;
-    mAnimatedDrawableBackend = animatedDrawableBackend;
-    mAnimatedDrawableOptions = options;
-    mMaximumBytes = options.maximumBytes >= 0 ?
-        options.maximumBytes : getDefaultMaxBytes(activityManager);
-    mAnimatedImageCompositor = new AnimatedImageCompositor(
-        animatedDrawableBackend,
-        new AnimatedImageCompositor.Callback() {
-          @Override
-          public void onIntermediateResult(int frameNumber, Bitmap bitmap) {
-            maybeCacheBitmapDuringRender(frameNumber, bitmap);
-          }
-
-          @Override
-          public CloseableReference<Bitmap> getCachedBitmap(int frameNumber) {
-            return getCachedOrPredecodedFrame(frameNumber);
-          }
-        });
-    mResourceReleaserForBitmaps = new ResourceReleaser<Bitmap>() {
-      @Override
-      public void release(Bitmap value) {
-        releaseBitmapInternal(value);
-      }
-    };
-    mFreeBitmaps = new ArrayList<Bitmap>();
-    mDecodesInFlight = new SparseArrayCompat<Task<Object>>(10);
-    mCachedBitmaps = new SparseArrayCompat<CloseableReference<Bitmap>>(10);
-    mBitmapsToKeepCached = new WhatToKeepCachedArray(mAnimatedDrawableBackend.getFrameCount());
-    mApproxBytesToHoldAllFrames =
-        mAnimatedDrawableBackend.getFrameCount() *
-            mAnimatedDrawableBackend.getRenderedWidth() *
-            mAnimatedDrawableBackend.getRenderedHeight() * 4;
-  }
-
-  @Override
-  protected synchronized void finalize() throws Throwable {
-    super.finalize();
-    if (mCachedBitmaps.size() > 0) {
-      FLog.d(TAG, "Finalizing with rendered bitmaps");
+        implements AnimatedDrawableCachingBackend {
+
+    private static final Class<?> TAG = AnimatedDrawableCachingBackendImpl.class;
+
+    private static final AtomicInteger sTotalBitmaps = new AtomicInteger();
+
+    private static final int PREFETCH_FRAMES = 3;
+
+    private final SerialExecutorService mExecutorService;
+    private final AnimatedDrawableUtil mAnimatedDrawableUtil;
+    private final ActivityManager mActivityManager;
+    private final MonotonicClock mMonotonicClock;
+    private final AnimatedDrawableBackend mAnimatedDrawableBackend;
+    private final AnimatedDrawableOptions mAnimatedDrawableOptions;
+    private final AnimatedImageCompositor mAnimatedImageCompositor;
+    private final ResourceReleaser<Bitmap> mResourceReleaserForBitmaps;
+    private final int mMaximumBytes;
+
+    private final int mApproxBytesToHoldAllFrames;
+
+    @GuardedBy("this")
+    private final List<Bitmap> mFreeBitmaps;
+
+    @GuardedBy("this")
+    private final SparseArrayCompat<Task<Object>> mDecodesInFlight;
+
+    @GuardedBy("this")
+    private final SparseArrayCompat<CloseableReference<Bitmap>> mCachedBitmaps;
+
+    @GuardedBy("this")
+    private final WhatToKeepCachedArray mBitmapsToKeepCached;
+
+    @GuardedBy("ui-thread")
+    private int mCurrentFrameIndex;
+
+    public AnimatedDrawableCachingBackendImpl(
+            SerialExecutorService executorService,
+            ActivityManager activityManager,
+            AnimatedDrawableUtil animatedDrawableUtil,
+            MonotonicClock monotonicClock,
+            AnimatedDrawableBackend animatedDrawableBackend,
+            AnimatedDrawableOptions options) {
+        super(animatedDrawableBackend);
+        mExecutorService = executorService;
+        mActivityManager = activityManager;
+        mAnimatedDrawableUtil = animatedDrawableUtil;
+        mMonotonicClock = monotonicClock;
+        mAnimatedDrawableBackend = animatedDrawableBackend;
+        mAnimatedDrawableOptions = options;
+        mMaximumBytes = options.maximumBytes >= 0 ?
+                options.maximumBytes : getDefaultMaxBytes(activityManager);
+        mAnimatedImageCompositor = new AnimatedImageCompositor(
+                animatedDrawableBackend,
+                new AnimatedImageCompositor.Callback() {
+                    @Override
+                    public void onIntermediateResult(int frameNumber, Bitmap bitmap) {
+                        maybeCacheBitmapDuringRender(frameNumber, bitmap);
+                    }
+
+                    @Override
+                    public CloseableReference<Bitmap> getCachedBitmap(int frameNumber) {
+                        return getCachedOrPredecodedFrame(frameNumber);
+                    }
+                });
+        mResourceReleaserForBitmaps = new ResourceReleaser<Bitmap>() {
+            @Override
+            public void release(Bitmap value) {
+                releaseBitmapInternal(value);
+            }
+        };
+        mFreeBitmaps = new ArrayList<Bitmap>();
+        mDecodesInFlight = new SparseArrayCompat<Task<Object>>(10);
+        mCachedBitmaps = new SparseArrayCompat<CloseableReference<Bitmap>>(10);
+        mBitmapsToKeepCached = new WhatToKeepCachedArray(mAnimatedDrawableBackend.getFrameCount());
+        mApproxBytesToHoldAllFrames =
+                mAnimatedDrawableBackend.getFrameCount() *
+                        mAnimatedDrawableBackend.getRenderedWidth() *
+                        mAnimatedDrawableBackend.getRenderedHeight() * 4;
     }
-    sTotalBitmaps.addAndGet(-mFreeBitmaps.size());
-    mFreeBitmaps.clear();
-  }
-
-  private Bitmap createNewBitmap() {
-    FLog.v(TAG, "Creating new bitmap");
-    sTotalBitmaps.incrementAndGet();
-    FLog.v(TAG, "Total bitmaps: %d", sTotalBitmaps.get());
-    return Bitmap.createBitmap(
-        mAnimatedDrawableBackend.getRenderedWidth(),
-        mAnimatedDrawableBackend.getRenderedHeight(),
-        Bitmap.Config.ARGB_8888);
-  }
-
-  @Override
-  public void renderFrame(int frameNumber, Canvas canvas) {
-    // renderFrame method should not be called on cache.
-    throw new IllegalStateException();
-  }
-
-  @Override
-  public CloseableReference<Bitmap> getBitmapForFrame(int frameNumber) {
-    mCurrentFrameIndex = frameNumber;
-    CloseableReference<Bitmap> result = getBitmapForFrameInternal(frameNumber, false);
-    schedulePrefetches();
-    return result;
-  }
-
-  @Override
-  public CloseableReference<Bitmap> getPreviewBitmap() {
-    return getAnimatedImageResult().getPreviewBitmap();
-  }
-
-  @VisibleForTesting
-  CloseableReference<Bitmap> getBitmapForFrameBlocking(int frameNumber) {
-    mCurrentFrameIndex = frameNumber;
-    CloseableReference<Bitmap> result = getBitmapForFrameInternal(frameNumber, true);
-    schedulePrefetches();
-    return result;
-  }
-
-  @Override
-  public AnimatedDrawableCachingBackend forNewBounds(Rect bounds) {
-    AnimatedDrawableBackend newBackend = mAnimatedDrawableBackend.forNewBounds(bounds);
-    if (newBackend == mAnimatedDrawableBackend) {
-      return this;
+
+    @Override
+    protected synchronized void finalize() throws Throwable {
+        super.finalize();
+        if (mCachedBitmaps.size() > 0) {
+            FLog.d(TAG, "Finalizing with rendered bitmaps");
+        }
+        sTotalBitmaps.addAndGet(-mFreeBitmaps.size());
+        mFreeBitmaps.clear();
+    }
+
+    private Bitmap createNewBitmap() {
+        FLog.v(TAG, "Creating new bitmap");
+        sTotalBitmaps.incrementAndGet();
+        FLog.v(TAG, "Total bitmaps: %d", sTotalBitmaps.get());
+        return Bitmap.createBitmap(
+                mAnimatedDrawableBackend.getRenderedWidth(),
+                mAnimatedDrawableBackend.getRenderedHeight(),
+                Bitmap.Config.ARGB_8888);
     }
-    return new AnimatedDrawableCachingBackendImpl(
-        mExecutorService,
-        mActivityManager,
-        mAnimatedDrawableUtil,
-        mMonotonicClock,
-        newBackend,
-        mAnimatedDrawableOptions);
-  }
-
-  @Override
-  public synchronized void dropCaches() {
-    mBitmapsToKeepCached.setAll(false);
-    dropBitmapsThatShouldNotBeCached();
-    for (Bitmap freeBitmap : mFreeBitmaps) {
-      freeBitmap.recycle();
-      sTotalBitmaps.decrementAndGet();
+
+    @Override
+    public void renderFrame(int frameNumber, Canvas canvas) {
+        // renderFrame method should not be called on cache.
+        throw new IllegalStateException();
     }
-    mFreeBitmaps.clear();
-    mAnimatedDrawableBackend.dropCaches();
-    FLog.v(TAG, "Total bitmaps: %d", sTotalBitmaps.get());
-  }
-
-  @Override
-  public int getMemoryUsage() {
-    int bytes = 0;
-    synchronized (this) {
-      for (Bitmap bitmap : mFreeBitmaps) {
-        bytes += mAnimatedDrawableUtil.getSizeOfBitmap(bitmap);
-      }
-      for (int i = 0; i < mCachedBitmaps.size(); i++) {
-        CloseableReference<Bitmap> bitmapReference = mCachedBitmaps.valueAt(i);
-        bytes += mAnimatedDrawableUtil.getSizeOfBitmap(bitmapReference.get());
-      }
+
+    @Override
+    public CloseableReference<Bitmap> getBitmapForFrame(int frameNumber) {
+        mCurrentFrameIndex = frameNumber;
+        CloseableReference<Bitmap> result = getBitmapForFrameInternal(frameNumber, false);
+        schedulePrefetches();
+        return result;
     }
-    bytes += mAnimatedDrawableBackend.getMemoryUsage();
-    return bytes;
-  }
-
-  @Override
-  public void appendDebugOptionString(StringBuilder sb) {
-    if (mAnimatedDrawableOptions.forceKeepAllFramesInMemory) {
-      sb.append("Pinned To Memory");
-    } else {
-      if (mApproxBytesToHoldAllFrames < mMaximumBytes) {
-        sb.append("within ");
-      } else {
-        sb.append("exceeds ");
-      }
-      mAnimatedDrawableUtil.appendMemoryString(sb, mMaximumBytes);
+
+    @Override
+    public CloseableReference<Bitmap> getPreviewBitmap() {
+        return getAnimatedImageResult().getPreviewBitmap();
     }
-    if (shouldKeepAllFramesInMemory() && mAnimatedDrawableOptions.allowPrefetching) {
-      sb.append(" MT");
+
+    @VisibleForTesting
+    CloseableReference<Bitmap> getBitmapForFrameBlocking(int frameNumber) {
+        mCurrentFrameIndex = frameNumber;
+        CloseableReference<Bitmap> result = getBitmapForFrameInternal(frameNumber, true);
+        schedulePrefetches();
+        return result;
     }
-  }
-
-  private CloseableReference<Bitmap> getBitmapForFrameInternal(
-      int frameNumber,
-      boolean forceImmediate) {
-    boolean renderedOnCallingThread = false;
-    boolean deferred = false;
-    long startMs = mMonotonicClock.now();
-    try {
-      synchronized (this) {
-        mBitmapsToKeepCached.set(frameNumber, true);
-        CloseableReference<Bitmap> bitmapReference = getCachedOrPredecodedFrame(frameNumber);
-        if (bitmapReference != null) {
-          return bitmapReference;
+
+    @Override
+    public AnimatedDrawableCachingBackend forNewBounds(Rect bounds) {
+        AnimatedDrawableBackend newBackend = mAnimatedDrawableBackend.forNewBounds(bounds);
+        if (newBackend == mAnimatedDrawableBackend) {
+            return this;
         }
-      }
+        return new AnimatedDrawableCachingBackendImpl(
+                mExecutorService,
+                mActivityManager,
+                mAnimatedDrawableUtil,
+                mMonotonicClock,
+                newBackend,
+                mAnimatedDrawableOptions);
+    }
 
-      if (forceImmediate) {
-        // Give up and try to do it on the calling thread.
-        renderedOnCallingThread = true;
-        CloseableReference<Bitmap> bitmapReference = obtainBitmapInternal();
-        try {
-          mAnimatedImageCompositor.renderFrame(frameNumber, bitmapReference.get());
-          maybeCacheRenderedBitmap(frameNumber, bitmapReference);
-          return bitmapReference.clone();
-        } finally {
-          bitmapReference.close();
+    @Override
+    public synchronized void dropCaches() {
+        mBitmapsToKeepCached.setAll(false);
+        dropBitmapsThatShouldNotBeCached();
+        for (Bitmap freeBitmap : mFreeBitmaps) {
+            freeBitmap.recycle();
+            sTotalBitmaps.decrementAndGet();
         }
-      }
-      deferred = true;
-      return null;
-    } finally {
-      long elapsedMs = mMonotonicClock.now() - startMs;
-      if (elapsedMs > 10) {
-        String comment = "";
-        if (renderedOnCallingThread) {
-          comment = "renderedOnCallingThread";
-        } else if (deferred) {
-          comment = "deferred";
-        } else {
-          comment = "ok";
+        mFreeBitmaps.clear();
+        mAnimatedDrawableBackend.dropCaches();
+        FLog.v(TAG, "Total bitmaps: %d", sTotalBitmaps.get());
+    }
+
+    @Override
+    public int getMemoryUsage() {
+        int bytes = 0;
+        synchronized (this) {
+            for (Bitmap bitmap : mFreeBitmaps) {
+                bytes += mAnimatedDrawableUtil.getSizeOfBitmap(bitmap);
+            }
+            for (int i = 0; i < mCachedBitmaps.size(); i++) {
+                CloseableReference<Bitmap> bitmapReference = mCachedBitmaps.valueAt(i);
+                bytes += mAnimatedDrawableUtil.getSizeOfBitmap(bitmapReference.get());
+            }
         }
-        FLog.v(TAG, "obtainBitmap for frame %d took %d ms (%s)", frameNumber, elapsedMs, comment);
-      }
+        bytes += mAnimatedDrawableBackend.getMemoryUsage();
+        return bytes;
     }
-  }
-
-  /**
-   * Called while rendering intermediate frames into the bitmap. If this is a frame we want cached,
-   * we'll copy it and cache it.
-   *
-   * @param frameNumber the index of the frame
-   * @param bitmap the rendered bitmap for that frame
-   */
-  private void maybeCacheBitmapDuringRender(int frameNumber, Bitmap bitmap) {
-    boolean cacheBitmap = false;
-    synchronized (this) {
-      boolean shouldCache = mBitmapsToKeepCached.get(frameNumber);
-      if (shouldCache) {
-        cacheBitmap = mCachedBitmaps.get(frameNumber) == null;
-      }
+
+    @Override
+    public void appendDebugOptionString(StringBuilder sb) {
+        if (mAnimatedDrawableOptions.forceKeepAllFramesInMemory) {
+            sb.append("Pinned To Memory");
+        } else {
+            if (mApproxBytesToHoldAllFrames < mMaximumBytes) {
+                sb.append("within ");
+            } else {
+                sb.append("exceeds ");
+            }
+            mAnimatedDrawableUtil.appendMemoryString(sb, mMaximumBytes);
+        }
+        if (shouldKeepAllFramesInMemory() && mAnimatedDrawableOptions.allowPrefetching) {
+            sb.append(" MT");
+        }
     }
-    if (cacheBitmap) {
-      copyAndCacheBitmapDuringRendering(frameNumber, bitmap);
+
+    private CloseableReference<Bitmap> getBitmapForFrameInternal(
+            int frameNumber,
+            boolean forceImmediate) {
+        boolean renderedOnCallingThread = false;
+        boolean deferred = false;
+        long startMs = mMonotonicClock.now();
+        try {
+            synchronized (this) {
+                mBitmapsToKeepCached.set(frameNumber, true);
+                CloseableReference<Bitmap> bitmapReference = getCachedOrPredecodedFrame(frameNumber);
+                if (bitmapReference != null) {
+                    return bitmapReference;
+                }
+            }
+
+            if (forceImmediate) {
+                // Give up and try to do it on the calling thread.
+                renderedOnCallingThread = true;
+                CloseableReference<Bitmap> bitmapReference = obtainBitmapInternal();
+                try {
+                    mAnimatedImageCompositor.renderFrame(frameNumber, bitmapReference.get());
+                    maybeCacheRenderedBitmap(frameNumber, bitmapReference);
+                    return bitmapReference.clone();
+                } finally {
+                    bitmapReference.close();
+                }
+            }
+            deferred = true;
+            return null;
+        } finally {
+            long elapsedMs = mMonotonicClock.now() - startMs;
+            if (elapsedMs > 10) {
+                String comment = "";
+                if (renderedOnCallingThread) {
+                    comment = "renderedOnCallingThread";
+                } else if (deferred) {
+                    comment = "deferred";
+                } else {
+                    comment = "ok";
+                }
+                FLog.v(TAG, "obtainBitmap for frame %d took %d ms (%s)", frameNumber, elapsedMs, comment);
+            }
+        }
     }
-  }
-
-  /**
-   * Copies the source bitmap for the specified frame and caches it.
-   *
-   * @param frameNumber the frame number
-   * @param sourceBitmap the rendered bitmap to be cached (after copying)
-   */
-  private void copyAndCacheBitmapDuringRendering(int frameNumber, Bitmap sourceBitmap) {
-    CloseableReference<Bitmap> destBitmapReference = obtainBitmapInternal();
-    try {
-      Canvas copyCanvas = new Canvas(destBitmapReference.get());
-      copyCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.SRC);
-      copyCanvas.drawBitmap(sourceBitmap, 0, 0, null);
-      maybeCacheRenderedBitmap(frameNumber, destBitmapReference);
-    } finally {
-      destBitmapReference.close();
+
+    /**
+     * Called while rendering intermediate frames into the bitmap. If this is a frame we want cached,
+     * we'll copy it and cache it.
+     *
+     * @param frameNumber the index of the frame
+     * @param bitmap      the rendered bitmap for that frame
+     */
+    private void maybeCacheBitmapDuringRender(int frameNumber, Bitmap bitmap) {
+        boolean cacheBitmap = false;
+        synchronized (this) {
+            boolean shouldCache = mBitmapsToKeepCached.get(frameNumber);
+            if (shouldCache) {
+                cacheBitmap = mCachedBitmaps.get(frameNumber) == null;
+            }
+        }
+        if (cacheBitmap) {
+            copyAndCacheBitmapDuringRendering(frameNumber, bitmap);
+        }
     }
-  }
-
-  private CloseableReference<Bitmap> obtainBitmapInternal() {
-    Bitmap bitmap;
-    synchronized (this) {
-      long nowNanos = System.nanoTime();
-      long waitUntilNanos = nowNanos + TimeUnit.NANOSECONDS.convert(20, TimeUnit.MILLISECONDS);
-      while (mFreeBitmaps.isEmpty() && nowNanos < waitUntilNanos) {
+
+    /**
+     * Copies the source bitmap for the specified frame and caches it.
+     *
+     * @param frameNumber  the frame number
+     * @param sourceBitmap the rendered bitmap to be cached (after copying)
+     */
+    private void copyAndCacheBitmapDuringRendering(int frameNumber, Bitmap sourceBitmap) {
+        CloseableReference<Bitmap> destBitmapReference = obtainBitmapInternal();
         try {
-          TimeUnit.NANOSECONDS.timedWait(this, waitUntilNanos - nowNanos);
-          nowNanos = System.nanoTime();
-        } catch (InterruptedException e) {
-          Thread.currentThread().interrupt();
-          throw new RuntimeException(e);
+            Canvas copyCanvas = new Canvas(destBitmapReference.get());
+            copyCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.SRC);
+            copyCanvas.drawBitmap(sourceBitmap, 0, 0, null);
+            maybeCacheRenderedBitmap(frameNumber, destBitmapReference);
+        } finally {
+            destBitmapReference.close();
         }
-      }
-
-      if (mFreeBitmaps.isEmpty()) {
-        bitmap = createNewBitmap();
-      } else {
-        bitmap = mFreeBitmaps.remove(mFreeBitmaps.size() - 1);
-      }
     }
-    return CloseableReference.of(bitmap, mResourceReleaserForBitmaps);
-  }
-
-  synchronized void releaseBitmapInternal(Bitmap bitmap) {
-    mFreeBitmaps.add(bitmap);
-  }
-
-  private synchronized void schedulePrefetches() {
-    AnimatedDrawableFrameInfo frameInfo = mAnimatedDrawableBackend.getFrameInfo(mCurrentFrameIndex);
-    boolean keepOnePreceding = frameInfo.disposalMethod == DisposalMethod.DISPOSE_TO_PREVIOUS;
-
-    int startFrame = Math.max(0, mCurrentFrameIndex - (keepOnePreceding ? 1 : 0));
-    int numToPrefetch = mAnimatedDrawableOptions.allowPrefetching ? PREFETCH_FRAMES : 0;
-    numToPrefetch = Math.max(numToPrefetch, keepOnePreceding ? 1 : 0);
-    int endFrame = (startFrame + numToPrefetch) % mAnimatedDrawableBackend.getFrameCount();
-    cancelFuturesOutsideOfRange(startFrame, endFrame);
-
-    if (!shouldKeepAllFramesInMemory()) {
-      mBitmapsToKeepCached.setAll(true);
-      mBitmapsToKeepCached.removeOutsideRange(startFrame, endFrame);
-
-      // Keep one closest to startFrame that is already cached to reduce the number of frames we
-      // need to composite together to draw startFrame.
-      for (int frameNumber = startFrame; frameNumber >= 0; frameNumber--) {
-        if (mCachedBitmaps.get(frameNumber) != null) {
-          mBitmapsToKeepCached.set(frameNumber, true);
-          break;
+
+    private CloseableReference<Bitmap> obtainBitmapInternal() {
+        Bitmap bitmap;
+        synchronized (this) {
+            long nowNanos = System.nanoTime();
+            long waitUntilNanos = nowNanos + TimeUnit.NANOSECONDS.convert(20, TimeUnit.MILLISECONDS);
+            while (mFreeBitmaps.isEmpty() && nowNanos < waitUntilNanos) {
+                try {
+                    TimeUnit.NANOSECONDS.timedWait(this, waitUntilNanos - nowNanos);
+                    nowNanos = System.nanoTime();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                    throw new RuntimeException(e);
+                }
+            }
+
+            if (mFreeBitmaps.isEmpty()) {
+                bitmap = createNewBitmap();
+            } else {
+                bitmap = mFreeBitmaps.remove(mFreeBitmaps.size() - 1);
+            }
         }
-      }
-      dropBitmapsThatShouldNotBeCached();
+        return CloseableReference.of(bitmap, mResourceReleaserForBitmaps);
     }
-    if (mAnimatedDrawableOptions.allowPrefetching) {
-      doPrefetch(startFrame, numToPrefetch);
-    } else {
-      cancelFuturesOutsideOfRange(mCurrentFrameIndex, mCurrentFrameIndex);
+
+    synchronized void releaseBitmapInternal(Bitmap bitmap) {
+        mFreeBitmaps.add(bitmap);
     }
-  }
-
-  private static int getDefaultMaxBytes(ActivityManager activityManager) {
-    int memory = activityManager.getMemoryClass();
-    if (memory > 32) {
-      return 5 * 1024 * 1024;
-    } else {
-      return 3 * 1024 * 1024;
+
+    private synchronized void schedulePrefetches() {
+        AnimatedDrawableFrameInfo frameInfo = mAnimatedDrawableBackend.getFrameInfo(mCurrentFrameIndex);
+        boolean keepOnePreceding = frameInfo.disposalMethod == DisposalMethod.DISPOSE_TO_PREVIOUS;
+
+        int startFrame = Math.max(0, mCurrentFrameIndex - (keepOnePreceding ? 1 : 0));
+        int numToPrefetch = mAnimatedDrawableOptions.allowPrefetching ? PREFETCH_FRAMES : 0;
+        numToPrefetch = Math.max(numToPrefetch, keepOnePreceding ? 1 : 0);
+        int endFrame = (startFrame + numToPrefetch) % mAnimatedDrawableBackend.getFrameCount();
+        cancelFuturesOutsideOfRange(startFrame, endFrame);
+
+        if (!shouldKeepAllFramesInMemory()) {
+            mBitmapsToKeepCached.setAll(true);
+            mBitmapsToKeepCached.removeOutsideRange(startFrame, endFrame);
+
+            // Keep one closest to startFrame that is already cached to reduce the number of frames we
+            // need to composite together to draw startFrame.
+            for (int frameNumber = startFrame; frameNumber >= 0; frameNumber--) {
+                if (mCachedBitmaps.get(frameNumber) != null) {
+                    mBitmapsToKeepCached.set(frameNumber, true);
+                    break;
+                }
+            }
+            dropBitmapsThatShouldNotBeCached();
+        }
+        if (mAnimatedDrawableOptions.allowPrefetching) {
+            doPrefetch(startFrame, numToPrefetch);
+        } else {
+            cancelFuturesOutsideOfRange(mCurrentFrameIndex, mCurrentFrameIndex);
+        }
     }
-  }
 
-  private boolean shouldKeepAllFramesInMemory() {
-    if (mAnimatedDrawableOptions.forceKeepAllFramesInMemory) {
-      // This overrides everything.
-      return true;
+    private static int getDefaultMaxBytes(ActivityManager activityManager) {
+        int memory = activityManager.getMemoryClass();
+        if (memory > 32) {
+            return 5 * 1024 * 1024;
+        } else {
+            return 3 * 1024 * 1024;
+        }
     }
-    return mApproxBytesToHoldAllFrames < mMaximumBytes;
-  }
-
-  private synchronized void doPrefetch(int startFrame, int count) {
-    for (int i = 0; i < count; i++) {
-      final int frameNumber = (startFrame + i) % mAnimatedDrawableBackend.getFrameCount();
-      boolean hasCached = hasCachedOrPredecodedFrame(frameNumber);
-      Task<Object> future = mDecodesInFlight.get(frameNumber);
-      if (!hasCached && future == null) {
-        final Task<Object> newFuture = Task.call(
-            new Callable<Object>() {
-              @Override
-              public Object call() {
-                runPrefetch(frameNumber);
-                return null;
-              }
-            }, mExecutorService);
-        mDecodesInFlight.put(frameNumber, newFuture);
-        newFuture.continueWith(
-            new Continuation<Object, Object>() {
-              @Override
-              public Object then(Task<Object> task) throws Exception {
-                onFutureFinished(newFuture, frameNumber);
-                return null;
-              }
-            });
-      }
+
+    private boolean shouldKeepAllFramesInMemory() {
+        if (mAnimatedDrawableOptions.forceKeepAllFramesInMemory) {
+            // This overrides everything.
+            return true;
+        }
+        return mApproxBytesToHoldAllFrames < mMaximumBytes;
     }
-  }
-
-  /**
-   * Renders a frame and caches it. This runs on the worker thread.
-   *
-   * @param frameNumber the frame to render
-   */
-  private void runPrefetch(int frameNumber) {
-    synchronized (this) {
-      if (!mBitmapsToKeepCached.get(frameNumber)) {
-        // Looks like we're no longer supposed to keep this cached.
-        return;
-      }
-      if (hasCachedOrPredecodedFrame(frameNumber)) {
-        // Looks like it's already cached.
-        return;
-      }
+
+    private synchronized void doPrefetch(int startFrame, int count) {
+        for (int i = 0; i < count; i++) {
+            final int frameNumber = (startFrame + i) % mAnimatedDrawableBackend.getFrameCount();
+            boolean hasCached = hasCachedOrPredecodedFrame(frameNumber);
+            Task<Object> future = mDecodesInFlight.get(frameNumber);
+            if (!hasCached && future == null) {
+                final Task<Object> newFuture = Task.call(
+                        new Callable<Object>() {
+                            @Override
+                            public Object call() {
+                                runPrefetch(frameNumber);
+                                return null;
+                            }
+                        }, mExecutorService);
+                mDecodesInFlight.put(frameNumber, newFuture);
+                newFuture.continueWith(
+                        new Continuation<Object, Object>() {
+                            @Override
+                            public Object then(Task<Object> task) throws Exception {
+                                onFutureFinished(newFuture, frameNumber);
+                                return null;
+                            }
+                        });
+            }
+        }
     }
 
-    CloseableReference<Bitmap> preDecodedFrame =
-        mAnimatedDrawableBackend.getPreDecodedFrame(frameNumber);
-    try {
-      if (preDecodedFrame != null) {
-        maybeCacheRenderedBitmap(frameNumber, preDecodedFrame);
-      } else {
-        CloseableReference<Bitmap> bitmapReference = obtainBitmapInternal();
+    /**
+     * Renders a frame and caches it. This runs on the worker thread.
+     *
+     * @param frameNumber the frame to render
+     */
+    private void runPrefetch(int frameNumber) {
+        synchronized (this) {
+            if (!mBitmapsToKeepCached.get(frameNumber)) {
+                // Looks like we're no longer supposed to keep this cached.
+                return;
+            }
+            if (hasCachedOrPredecodedFrame(frameNumber)) {
+                // Looks like it's already cached.
+                return;
+            }
+        }
+
+        CloseableReference<Bitmap> preDecodedFrame =
+                mAnimatedDrawableBackend.getPreDecodedFrame(frameNumber);
         try {
-          mAnimatedImageCompositor.renderFrame(frameNumber, bitmapReference.get());
-          maybeCacheRenderedBitmap(frameNumber, bitmapReference);
-          FLog.v(TAG, "Prefetch rendered frame %d", frameNumber);
+            if (preDecodedFrame != null) {
+                maybeCacheRenderedBitmap(frameNumber, preDecodedFrame);
+            } else {
+                CloseableReference<Bitmap> bitmapReference = obtainBitmapInternal();
+                try {
+                    mAnimatedImageCompositor.renderFrame(frameNumber, bitmapReference.get());
+                    maybeCacheRenderedBitmap(frameNumber, bitmapReference);
+                    FLog.v(TAG, "Prefetch rendered frame %d", frameNumber);
+                } finally {
+                    bitmapReference.close();
+                }
+            }
         } finally {
-          bitmapReference.close();
+            CloseableReference.closeSafely(preDecodedFrame);
         }
-      }
-    } finally {
-      CloseableReference.closeSafely(preDecodedFrame);
     }
-  }
-
-  private synchronized void onFutureFinished(Task<?> future, int frameNumber) {
-    int index = mDecodesInFlight.indexOfKey(frameNumber);
-    if (index >= 0) {
-      Task<?> futureAtIndex = mDecodesInFlight.valueAt(index);
-      if (futureAtIndex == future) {
-        mDecodesInFlight.removeAt(index);
-        if (future.getError() != null) {
-          FLog.v(TAG, future.getError(), "Failed to render frame %d", frameNumber);
+
+    private synchronized void onFutureFinished(Task<?> future, int frameNumber) {
+        int index = mDecodesInFlight.indexOfKey(frameNumber);
+        if (index >= 0) {
+            Task<?> futureAtIndex = mDecodesInFlight.valueAt(index);
+            if (futureAtIndex == future) {
+                mDecodesInFlight.removeAt(index);
+                if (future.getError() != null) {
+                    FLog.v(TAG, future.getError(), "Failed to render frame %d", frameNumber);
+                }
+            }
         }
-      }
     }
-  }
-
-  private synchronized void cancelFuturesOutsideOfRange(int startFrame, int endFrame) {
-    int index = 0;
-    while (index < mDecodesInFlight.size()) {
-      int frameNumber = mDecodesInFlight.keyAt(index);
-      boolean outsideRange = AnimatedDrawableUtil.isOutsideRange(startFrame, endFrame, frameNumber);
-      if (outsideRange) {
-        Task<?> future = mDecodesInFlight.valueAt(index);
-        mDecodesInFlight.removeAt(index);
-        //future.cancel(false); -- TODO
-      } else {
-        index++;
-      }
+
+    private synchronized void cancelFuturesOutsideOfRange(int startFrame, int endFrame) {
+        int index = 0;
+        while (index < mDecodesInFlight.size()) {
+            int frameNumber = mDecodesInFlight.keyAt(index);
+            boolean outsideRange = AnimatedDrawableUtil.isOutsideRange(startFrame, endFrame, frameNumber);
+            if (outsideRange) {
+                Task<?> future = mDecodesInFlight.valueAt(index);
+                mDecodesInFlight.removeAt(index);
+                //future.cancel(false); -- TODO
+            } else {
+                index++;
+            }
+        }
     }
-  }
-
-  private synchronized void dropBitmapsThatShouldNotBeCached() {
-    int index = 0;
-    while (index < mCachedBitmaps.size()) {
-      int frameNumber = mCachedBitmaps.keyAt(index);
-      boolean keepCached = mBitmapsToKeepCached.get(frameNumber);
-      if (!keepCached) {
-        CloseableReference<Bitmap> bitmapReference = mCachedBitmaps.valueAt(index);
-        mCachedBitmaps.removeAt(index);
-        bitmapReference.close();
-      } else {
-        index++;
-      }
+
+    private synchronized void dropBitmapsThatShouldNotBeCached() {
+        int index = 0;
+        while (index < mCachedBitmaps.size()) {
+            int frameNumber = mCachedBitmaps.keyAt(index);
+            boolean keepCached = mBitmapsToKeepCached.get(frameNumber);
+            if (!keepCached) {
+                CloseableReference<Bitmap> bitmapReference = mCachedBitmaps.valueAt(index);
+                mCachedBitmaps.removeAt(index);
+                bitmapReference.close();
+            } else {
+                index++;
+            }
+        }
     }
-  }
 
-  private synchronized void maybeCacheRenderedBitmap(
-      int frameNumber,
-      CloseableReference<Bitmap> bitmapReference) {
-    if (!mBitmapsToKeepCached.get(frameNumber)) {
-      return;
+    private synchronized void maybeCacheRenderedBitmap(
+            int frameNumber,
+            CloseableReference<Bitmap> bitmapReference) {
+        if (!mBitmapsToKeepCached.get(frameNumber)) {
+            return;
+        }
+
+        int existingIndex = mCachedBitmaps.indexOfKey(frameNumber);
+        if (existingIndex >= 0) {
+            CloseableReference<Bitmap> oldReference = mCachedBitmaps.valueAt(existingIndex);
+            oldReference.close();
+            mCachedBitmaps.removeAt(existingIndex);
+        }
+        mCachedBitmaps.put(frameNumber, bitmapReference.clone());
     }
 
-    int existingIndex = mCachedBitmaps.indexOfKey(frameNumber);
-    if (existingIndex >= 0) {
-      CloseableReference<Bitmap> oldReference = mCachedBitmaps.valueAt(existingIndex);
-      oldReference.close();
-      mCachedBitmaps.removeAt(existingIndex);
+    private synchronized CloseableReference<Bitmap> getCachedOrPredecodedFrame(int frameNumber) {
+        CloseableReference<Bitmap> ret =
+                CloseableReference.cloneOrNull(mCachedBitmaps.get(frameNumber));
+        if (ret == null) {
+            ret = mAnimatedDrawableBackend.getPreDecodedFrame(frameNumber);
+        }
+        return ret;
     }
-    mCachedBitmaps.put(frameNumber, bitmapReference.clone());
-  }
-
-  private synchronized CloseableReference<Bitmap> getCachedOrPredecodedFrame(int frameNumber) {
-    CloseableReference<Bitmap> ret =
-        CloseableReference.cloneOrNull(mCachedBitmaps.get(frameNumber));
-    if (ret == null) {
-      ret = mAnimatedDrawableBackend.getPreDecodedFrame(frameNumber);
+
+    private synchronized boolean hasCachedOrPredecodedFrame(int frameNumber) {
+        return mCachedBitmaps.get(frameNumber) != null ||
+                mAnimatedDrawableBackend.hasPreDecodedFrame(frameNumber);
     }
-    return ret;
-  }
-
-  private synchronized boolean hasCachedOrPredecodedFrame(int frameNumber) {
-    return mCachedBitmaps.get(frameNumber) != null ||
-        mAnimatedDrawableBackend.hasPreDecodedFrame(frameNumber);
-  }
-
-  @VisibleForTesting
-  synchronized Map<Integer, Task<?>> getDecodesInFlight() {
-    Map<Integer, Task<?>> map = new HashMap<Integer, Task<?>>();
-    for (int i = 0; i < mDecodesInFlight.size(); i++) {
-      map.put(mDecodesInFlight.keyAt(i), mDecodesInFlight.valueAt(i));
+
+    @VisibleForTesting
+    synchronized Map<Integer, Task<?>> getDecodesInFlight() {
+        Map<Integer, Task<?>> map = new HashMap<Integer, Task<?>>();
+        for (int i = 0; i < mDecodesInFlight.size(); i++) {
+            map.put(mDecodesInFlight.keyAt(i), mDecodesInFlight.valueAt(i));
+        }
+        return map;
     }
-    return map;
-  }
-
-  @VisibleForTesting
-  synchronized Set<Integer> getFramesCached() {
-    Set<Integer> set = new HashSet<Integer>();
-    for (int i = 0; i < mCachedBitmaps.size(); i++) {
-      set.add(mCachedBitmaps.keyAt(i));
+
+    @VisibleForTesting
+    synchronized Set<Integer> getFramesCached() {
+        Set<Integer> set = new HashSet<Integer>();
+        for (int i = 0; i < mCachedBitmaps.size(); i++) {
+            set.add(mCachedBitmaps.keyAt(i));
+        }
+        return set;
     }
-    return set;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplProvider.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplProvider.java
index a5e07b861..d1efd6ded 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplProvider.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplProvider.java
@@ -17,14 +17,14 @@
  */
 public interface AnimatedDrawableCachingBackendImplProvider {
 
-  /**
-   * Creates a new {@link AnimatedDrawableCachingBackendImpl}.
-   *
-   * @param animatedDrawableBackend the backend to delegate to
-   * @param options the options for the drawable
-   * @return a new {@link AnimatedDrawableCachingBackendImpl}
-   */
-  AnimatedDrawableCachingBackendImpl get(
-      AnimatedDrawableBackend animatedDrawableBackend,
-      AnimatedDrawableOptions options);
+    /**
+     * Creates a new {@link AnimatedDrawableCachingBackendImpl}.
+     *
+     * @param animatedDrawableBackend the backend to delegate to
+     * @param options                 the options for the drawable
+     * @return a new {@link AnimatedDrawableCachingBackendImpl}
+     */
+    AnimatedDrawableCachingBackendImpl get(
+            AnimatedDrawableBackend animatedDrawableBackend,
+            AnimatedDrawableOptions options);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsImpl.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsImpl.java
index 22e2bb6da..eb0e0fb76 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsImpl.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsImpl.java
@@ -28,131 +28,131 @@
  */
 public class AnimatedDrawableDiagnosticsImpl implements AnimatedDrawableDiagnostics {
 
-  private static final Class<?> TAG = AnimatedDrawableDiagnostics.class;
-
-  private final AnimatedDrawableUtil mAnimatedDrawableUtil;
-  private final DisplayMetrics mDisplayMetrics;
-  private final TextPaint mDebugTextPaint;
-  private final StringBuilder sbTemp;
-  private final RollingStat mDroppedFramesStat;
-  private final RollingStat mDrawnFrames;
-
-  private AnimatedDrawableCachingBackend mAnimatedDrawableBackend;
-
-  private long mLastTimeStamp;
-
-  public AnimatedDrawableDiagnosticsImpl(
-      AnimatedDrawableUtil animatedDrawableUtil,
-      DisplayMetrics displayMetrics) {
-    mAnimatedDrawableUtil = animatedDrawableUtil;
-    mDisplayMetrics = displayMetrics;
-    mDroppedFramesStat = new RollingStat();
-    mDrawnFrames = new RollingStat();
-    sbTemp = new StringBuilder();
-    mDebugTextPaint = new TextPaint();
-    mDebugTextPaint.setColor(Color.BLUE);
-    mDebugTextPaint.setTextSize(convertDpToPx(14));
-  }
-
-  @Override
-  public void setBackend(AnimatedDrawableCachingBackend animatedDrawableBackend) {
-    mAnimatedDrawableBackend = animatedDrawableBackend;
-  }
-
-  @Override
-  public void onStartMethodBegin() {
-    mLastTimeStamp = SystemClock.elapsedRealtime();
-  }
-
-  @Override
-  public void onStartMethodEnd() {
-    long elapsedMs = SystemClock.elapsedRealtime() - mLastTimeStamp;
-    if (elapsedMs > 3) {
-      FLog.v(TAG, "onStart took %d", elapsedMs);
+    private static final Class<?> TAG = AnimatedDrawableDiagnostics.class;
+
+    private final AnimatedDrawableUtil mAnimatedDrawableUtil;
+    private final DisplayMetrics mDisplayMetrics;
+    private final TextPaint mDebugTextPaint;
+    private final StringBuilder sbTemp;
+    private final RollingStat mDroppedFramesStat;
+    private final RollingStat mDrawnFrames;
+
+    private AnimatedDrawableCachingBackend mAnimatedDrawableBackend;
+
+    private long mLastTimeStamp;
+
+    public AnimatedDrawableDiagnosticsImpl(
+            AnimatedDrawableUtil animatedDrawableUtil,
+            DisplayMetrics displayMetrics) {
+        mAnimatedDrawableUtil = animatedDrawableUtil;
+        mDisplayMetrics = displayMetrics;
+        mDroppedFramesStat = new RollingStat();
+        mDrawnFrames = new RollingStat();
+        sbTemp = new StringBuilder();
+        mDebugTextPaint = new TextPaint();
+        mDebugTextPaint.setColor(Color.BLUE);
+        mDebugTextPaint.setTextSize(convertDpToPx(14));
     }
-  }
-
-  @Override
-  public void onNextFrameMethodBegin() {
-    mLastTimeStamp = SystemClock.elapsedRealtime();
-  }
-
-  @Override
-  public void onNextFrameMethodEnd() {
-    long elapsedMs = SystemClock.elapsedRealtime() - mLastTimeStamp;
-    if (elapsedMs > 3) {
-      FLog.v(TAG, "onNextFrame took %d", elapsedMs);
+
+    @Override
+    public void setBackend(AnimatedDrawableCachingBackend animatedDrawableBackend) {
+        mAnimatedDrawableBackend = animatedDrawableBackend;
+    }
+
+    @Override
+    public void onStartMethodBegin() {
+        mLastTimeStamp = SystemClock.elapsedRealtime();
+    }
+
+    @Override
+    public void onStartMethodEnd() {
+        long elapsedMs = SystemClock.elapsedRealtime() - mLastTimeStamp;
+        if (elapsedMs > 3) {
+            FLog.v(TAG, "onStart took %d", elapsedMs);
+        }
+    }
+
+    @Override
+    public void onNextFrameMethodBegin() {
+        mLastTimeStamp = SystemClock.elapsedRealtime();
     }
-  }
 
-  @Override
-  public void incrementDroppedFrames(int droppedFrames) {
-    mDroppedFramesStat.incrementStats(droppedFrames);
-    if (droppedFrames > 0) {
-      FLog.v(TAG, "Dropped %d frames", droppedFrames);
+    @Override
+    public void onNextFrameMethodEnd() {
+        long elapsedMs = SystemClock.elapsedRealtime() - mLastTimeStamp;
+        if (elapsedMs > 3) {
+            FLog.v(TAG, "onNextFrame took %d", elapsedMs);
+        }
     }
-  }
-
-  @Override
-  public void incrementDrawnFrames(int drawnFrames) {
-    mDrawnFrames.incrementStats(drawnFrames);
-  }
-
-  @Override
-  public void onDrawMethodBegin() {
-    mLastTimeStamp = SystemClock.elapsedRealtime();
-  }
-
-  @Override
-  public void onDrawMethodEnd() {
-    long elapsedMs = SystemClock.elapsedRealtime() - mLastTimeStamp;
-    FLog.v(TAG, "draw took %d", elapsedMs);
-  }
-
-  public void drawDebugOverlay(Canvas canvas, Rect destRect) {
-    // Running percentage of frames shown (i.e. drop rate).
-    int droppedFrame10 = mDroppedFramesStat.getSum(10);
-    int drawnFrames10 = mDrawnFrames.getSum(10);
-    int totalFrames = drawnFrames10 + droppedFrame10;
-    int leftMargin = convertDpToPx(10);
-    int x = leftMargin;
-    int y = convertDpToPx(20);
-    int spacingBetweenTextPx = convertDpToPx(5);
-    if (totalFrames > 0) {
-      int percentage = drawnFrames10 * 100 / totalFrames;
-      sbTemp.setLength(0);
-      sbTemp.append(percentage);
-      sbTemp.append("%");
-      canvas.drawText(sbTemp, 0, sbTemp.length(), x, y, mDebugTextPaint);
-      x += mDebugTextPaint.measureText(sbTemp, 0, sbTemp.length());
-      x += spacingBetweenTextPx;
+
+    @Override
+    public void incrementDroppedFrames(int droppedFrames) {
+        mDroppedFramesStat.incrementStats(droppedFrames);
+        if (droppedFrames > 0) {
+            FLog.v(TAG, "Dropped %d frames", droppedFrames);
+        }
+    }
+
+    @Override
+    public void incrementDrawnFrames(int drawnFrames) {
+        mDrawnFrames.incrementStats(drawnFrames);
     }
 
-    // Memory usage.
-    int bytesUsed = mAnimatedDrawableBackend.getMemoryUsage();
-    sbTemp.setLength(0);
-    mAnimatedDrawableUtil.appendMemoryString(sbTemp, bytesUsed);
-    float textWidth = mDebugTextPaint.measureText(sbTemp, 0, sbTemp.length());
-    if (x + textWidth > destRect.width()) {
-      x = leftMargin;
-      y += mDebugTextPaint.getTextSize() + spacingBetweenTextPx;
+    @Override
+    public void onDrawMethodBegin() {
+        mLastTimeStamp = SystemClock.elapsedRealtime();
     }
-    canvas.drawText(sbTemp, 0, sbTemp.length(), x, y, mDebugTextPaint);
-    x += textWidth;
-    x += spacingBetweenTextPx;
-
-    // Options
-    sbTemp.setLength(0);
-    mAnimatedDrawableBackend.appendDebugOptionString(sbTemp);
-    textWidth = mDebugTextPaint.measureText(sbTemp, 0, sbTemp.length());
-    if (x + textWidth > destRect.width()) {
-      x = leftMargin;
-      y += mDebugTextPaint.getTextSize() + spacingBetweenTextPx;
+
+    @Override
+    public void onDrawMethodEnd() {
+        long elapsedMs = SystemClock.elapsedRealtime() - mLastTimeStamp;
+        FLog.v(TAG, "draw took %d", elapsedMs);
     }
-    canvas.drawText(sbTemp, 0, sbTemp.length(), x, y, mDebugTextPaint);
-  }
 
-  private int convertDpToPx(int dips) {
-    return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dips, mDisplayMetrics);
-  }
+    public void drawDebugOverlay(Canvas canvas, Rect destRect) {
+        // Running percentage of frames shown (i.e. drop rate).
+        int droppedFrame10 = mDroppedFramesStat.getSum(10);
+        int drawnFrames10 = mDrawnFrames.getSum(10);
+        int totalFrames = drawnFrames10 + droppedFrame10;
+        int leftMargin = convertDpToPx(10);
+        int x = leftMargin;
+        int y = convertDpToPx(20);
+        int spacingBetweenTextPx = convertDpToPx(5);
+        if (totalFrames > 0) {
+            int percentage = drawnFrames10 * 100 / totalFrames;
+            sbTemp.setLength(0);
+            sbTemp.append(percentage);
+            sbTemp.append("%");
+            canvas.drawText(sbTemp, 0, sbTemp.length(), x, y, mDebugTextPaint);
+            x += mDebugTextPaint.measureText(sbTemp, 0, sbTemp.length());
+            x += spacingBetweenTextPx;
+        }
+
+        // Memory usage.
+        int bytesUsed = mAnimatedDrawableBackend.getMemoryUsage();
+        sbTemp.setLength(0);
+        mAnimatedDrawableUtil.appendMemoryString(sbTemp, bytesUsed);
+        float textWidth = mDebugTextPaint.measureText(sbTemp, 0, sbTemp.length());
+        if (x + textWidth > destRect.width()) {
+            x = leftMargin;
+            y += mDebugTextPaint.getTextSize() + spacingBetweenTextPx;
+        }
+        canvas.drawText(sbTemp, 0, sbTemp.length(), x, y, mDebugTextPaint);
+        x += textWidth;
+        x += spacingBetweenTextPx;
+
+        // Options
+        sbTemp.setLength(0);
+        mAnimatedDrawableBackend.appendDebugOptionString(sbTemp);
+        textWidth = mDebugTextPaint.measureText(sbTemp, 0, sbTemp.length());
+        if (x + textWidth > destRect.width()) {
+            x = leftMargin;
+            y += mDebugTextPaint.getTextSize() + spacingBetweenTextPx;
+        }
+        canvas.drawText(sbTemp, 0, sbTemp.length(), x, y, mDebugTextPaint);
+    }
+
+    private int convertDpToPx(int dips) {
+        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dips, mDisplayMetrics);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsNoop.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsNoop.java
index 516f6c9aa..43ea56645 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsNoop.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableDiagnosticsNoop.java
@@ -20,49 +20,49 @@
  */
 public class AnimatedDrawableDiagnosticsNoop implements AnimatedDrawableDiagnostics {
 
-  private static AnimatedDrawableDiagnosticsNoop sInstance = new AnimatedDrawableDiagnosticsNoop();
+    private static AnimatedDrawableDiagnosticsNoop sInstance = new AnimatedDrawableDiagnosticsNoop();
 
-  public static AnimatedDrawableDiagnosticsNoop getInstance() {
-    return sInstance;
-  }
+    public static AnimatedDrawableDiagnosticsNoop getInstance() {
+        return sInstance;
+    }
 
-  @Override
-  public void setBackend(AnimatedDrawableCachingBackend animatedDrawableBackend) {
-  }
+    @Override
+    public void setBackend(AnimatedDrawableCachingBackend animatedDrawableBackend) {
+    }
 
-  @Override
-  public void onStartMethodBegin() {
-  }
+    @Override
+    public void onStartMethodBegin() {
+    }
 
-  @Override
-  public void onStartMethodEnd() {
-  }
+    @Override
+    public void onStartMethodEnd() {
+    }
 
-  @Override
-  public void onNextFrameMethodBegin() {
-  }
+    @Override
+    public void onNextFrameMethodBegin() {
+    }
 
-  @Override
-  public void onNextFrameMethodEnd() {
-  }
+    @Override
+    public void onNextFrameMethodEnd() {
+    }
 
-  @Override
-  public void incrementDroppedFrames(int droppedFrames) {
-  }
+    @Override
+    public void incrementDroppedFrames(int droppedFrames) {
+    }
 
-  @Override
-  public void incrementDrawnFrames(int drawnFrames) {
-  }
+    @Override
+    public void incrementDrawnFrames(int drawnFrames) {
+    }
 
-  @Override
-  public void onDrawMethodBegin() {
-  }
+    @Override
+    public void onDrawMethodBegin() {
+    }
 
-  @Override
-  public void onDrawMethodEnd() {
-  }
+    @Override
+    public void onDrawMethodEnd() {
+    }
 
-  @Override
-  public void drawDebugOverlay(Canvas canvas, Rect destRect) {
-  }
+    @Override
+    public void drawDebugOverlay(Canvas canvas, Rect destRect) {
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java
index a8ee456b4..4f8dddd22 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/AnimatedImageCompositor.java
@@ -31,193 +31,201 @@
  */
 public class AnimatedImageCompositor {
 
-  /**
-   * Callback for caching.
-   */
-  public interface Callback {
-
     /**
-     * Called from within {@link #renderFrame} to let the caller know that while trying generate
-     * the requested frame, an earlier frame was generated. This allows the caller to optionally
-     * cache the intermediate result. The caller must copy the Bitmap if it wishes to cache it
-     * as {@link #renderFrame} will continue using it generate the requested frame.
-     *
-     * @param frameNumber the frame number of the intermediate result
-     * @param bitmap the bitmap which must not be modified or directly cached
+     * Callback for caching.
      */
-    void onIntermediateResult(int frameNumber, Bitmap bitmap);
+    public interface Callback {
+
+        /**
+         * Called from within {@link #renderFrame} to let the caller know that while trying generate
+         * the requested frame, an earlier frame was generated. This allows the caller to optionally
+         * cache the intermediate result. The caller must copy the Bitmap if it wishes to cache it
+         * as {@link #renderFrame} will continue using it generate the requested frame.
+         *
+         * @param frameNumber the frame number of the intermediate result
+         * @param bitmap      the bitmap which must not be modified or directly cached
+         */
+        void onIntermediateResult(int frameNumber, Bitmap bitmap);
+
+        /**
+         * Called from within {@link #renderFrame} to ask the caller for a cached bitmap for the
+         * specified frame number. If the caller has the bitmap cached, it can greatly reduce the
+         * work required to render the requested frame.
+         *
+         * @param frameNumber the frame number to get
+         * @return a reference to the bitmap. The ownership of the reference is passed to the caller
+         * who must close it.
+         */
+        CloseableReference<Bitmap> getCachedBitmap(int frameNumber);
+    }
+
+    private final AnimatedDrawableBackend mAnimatedDrawableBackend;
+    private final Callback mCallback;
+    private final Paint mTransparentFillPaint;
+
+    public AnimatedImageCompositor(
+            AnimatedDrawableBackend animatedDrawableBackend,
+            Callback callback) {
+        mAnimatedDrawableBackend = animatedDrawableBackend;
+        mCallback = callback;
+        mTransparentFillPaint = new Paint();
+        mTransparentFillPaint.setColor(Color.TRANSPARENT);
+        mTransparentFillPaint.setStyle(Paint.Style.FILL);
+        mTransparentFillPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));
+    }
 
     /**
-     * Called from within {@link #renderFrame} to ask the caller for a cached bitmap for the
-     * specified frame number. If the caller has the bitmap cached, it can greatly reduce the
-     * work required to render the requested frame.
+     * Renders the specified frame. Only should be called on the rendering thread.
      *
-     * @param frameNumber the frame number to get
-     * @return a reference to the bitmap. The ownership of the reference is passed to the caller
-     *    who must close it.
+     * @param frameNumber the frame to render
+     * @param bitmap      the bitmap to render into
      */
-    CloseableReference<Bitmap> getCachedBitmap(int frameNumber);
-  }
-
-  private final AnimatedDrawableBackend mAnimatedDrawableBackend;
-  private final Callback mCallback;
-  private final Paint mTransparentFillPaint;
-
-  public AnimatedImageCompositor(
-      AnimatedDrawableBackend animatedDrawableBackend,
-      Callback callback) {
-    mAnimatedDrawableBackend = animatedDrawableBackend;
-    mCallback = callback;
-    mTransparentFillPaint = new Paint();
-    mTransparentFillPaint.setColor(Color.TRANSPARENT);
-    mTransparentFillPaint.setStyle(Paint.Style.FILL);
-    mTransparentFillPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));
-  }
-
-  /**
-   * Renders the specified frame. Only should be called on the rendering thread.
-   *
-   * @param frameNumber the frame to render
-   * @param bitmap the bitmap to render into
-   */
-  public void renderFrame(int frameNumber, Bitmap bitmap) {
-    Canvas canvas = new Canvas(bitmap);
-    canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.SRC);
-
-    // If blending is required, prepare the canvas with the nearest cached frame.
-    int nextIndex;
-    AnimatedDrawableFrameInfo frameInfo = mAnimatedDrawableBackend.getFrameInfo(frameNumber);
-    if (frameInfo.shouldBlendWithPreviousFrame && frameNumber > 0) {
-      // Blending is required. nextIndex points to the next index to render onto the canvas.
-      nextIndex = prepareCanvasWithClosestCachedFrame(frameNumber - 1, canvas);
-    } else {
-      // Blending isn't required. Start at the frame we're trying to render.
-      nextIndex = frameNumber;
+    public void renderFrame(int frameNumber, Bitmap bitmap) {
+        Canvas canvas = new Canvas(bitmap);
+        canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.SRC);
+
+        // If blending is required, prepare the canvas with the nearest cached frame.
+        int nextIndex;
+        AnimatedDrawableFrameInfo frameInfo = mAnimatedDrawableBackend.getFrameInfo(frameNumber);
+        if (frameInfo.shouldBlendWithPreviousFrame && frameNumber > 0) {
+            // Blending is required. nextIndex points to the next index to render onto the canvas.
+            nextIndex = prepareCanvasWithClosestCachedFrame(frameNumber - 1, canvas);
+        } else {
+            // Blending isn't required. Start at the frame we're trying to render.
+            nextIndex = frameNumber;
+        }
+
+        // Iterate from nextIndex to the frame number just preceding the one we're trying to render
+        // and composite them in order according to the Disposal Method.
+        for (int index = nextIndex; index < frameNumber; index++) {
+            frameInfo = mAnimatedDrawableBackend.getFrameInfo(index);
+            DisposalMethod disposalMethod = frameInfo.disposalMethod;
+            if (disposalMethod == DisposalMethod.DISPOSE_TO_PREVIOUS) {
+                continue;
+            }
+            mAnimatedDrawableBackend.renderFrame(index, canvas);
+            mCallback.onIntermediateResult(index, bitmap);
+            if (disposalMethod == DisposalMethod.DISPOSE_TO_BACKGROUND) {
+                canvas.drawRect(
+                        frameInfo.xOffset,
+                        frameInfo.yOffset,
+                        frameInfo.width,
+                        frameInfo.height,
+                        mTransparentFillPaint);
+            }
+        }
+
+        // Finally, we render the current frame. We don't dispose it.
+        mAnimatedDrawableBackend.renderFrame(frameNumber, canvas);
     }
 
-    // Iterate from nextIndex to the frame number just preceding the one we're trying to render
-    // and composite them in order according to the Disposal Method.
-    for (int index = nextIndex; index < frameNumber; index++) {
-      frameInfo = mAnimatedDrawableBackend.getFrameInfo(index);
-      DisposalMethod disposalMethod = frameInfo.disposalMethod;
-      if (disposalMethod == DisposalMethod.DISPOSE_TO_PREVIOUS) {
-        continue;
-      }
-      mAnimatedDrawableBackend.renderFrame(index, canvas);
-      mCallback.onIntermediateResult(index, bitmap);
-      if (disposalMethod == DisposalMethod.DISPOSE_TO_BACKGROUND) {
-        canvas.drawRect(
-            frameInfo.xOffset,
-            frameInfo.yOffset,
-            frameInfo.width,
-            frameInfo.height,
-            mTransparentFillPaint);
-      }
+    /**
+     * Return value for {@link #isFrameNeededForRendering} used in the compositing logic.
+     */
+    private enum FrameNeededResult {
+        /**
+         * The frame is required to render the next frame
+         */
+        REQUIRED,
+
+        /**
+         * The frame is not required to render the next frame.
+         */
+        NOT_REQUIRED,
+
+        /**
+         * Skip this frame and keep going. Used for GIF's DISPOSE_TO_PREVIOUS
+         */
+        SKIP,
+
+        /**
+         * Stop processing at this frame. This means the image didn't specify the disposal method
+         */
+        ABORT
     }
 
-    // Finally, we render the current frame. We don't dispose it.
-    mAnimatedDrawableBackend.renderFrame(frameNumber, canvas);
-  }
-
-  /**
-   * Return value for {@link #isFrameNeededForRendering} used in the compositing logic.
-   */
-  private enum FrameNeededResult {
-    /** The frame is required to render the next frame */
-    REQUIRED,
-
-    /** The frame is not required to render the next frame. */
-    NOT_REQUIRED,
-
-    /** Skip this frame and keep going. Used for GIF's DISPOSE_TO_PREVIOUS */
-    SKIP,
-
-    /** Stop processing at this frame. This means the image didn't specify the disposal method */
-    ABORT
-  }
-
-  /**
-   * Given a frame number, prepares the canvas to render based on the nearest cached frame
-   * at or before the frame. On return the canvas will be prepared as if the nearest cached
-   * frame had been rendered and disposed. The returned index is the next frame that needs to be
-   * composited onto the canvas.
-   *
-   * @param previousFrameNumber the frame number that is ones less than the one we're rendering
-   * @param canvas the canvas to prepare
-   * @return the index of the the next frame to process
-   */
-  private int prepareCanvasWithClosestCachedFrame(int previousFrameNumber, Canvas canvas) {
-    for (int index = previousFrameNumber; index >= 0; index--) {
-      FrameNeededResult neededResult = isFrameNeededForRendering(index);
-      switch (neededResult) {
-        case REQUIRED:
-          AnimatedDrawableFrameInfo frameInfo = mAnimatedDrawableBackend.getFrameInfo(index);
-          CloseableReference<Bitmap> startBitmap = mCallback.getCachedBitmap(index);
-          if (startBitmap != null) {
-            try {
-              canvas.drawBitmap(startBitmap.get(), 0, 0, null);
-              if (frameInfo.disposalMethod == DisposalMethod.DISPOSE_TO_BACKGROUND) {
-                canvas.drawRect(
-                    frameInfo.xOffset,
-                    frameInfo.yOffset,
-                    frameInfo.width,
-                    frameInfo.height,
-                    mTransparentFillPaint);
-              }
-              return index + 1;
-            } finally {
-              startBitmap.close();
+    /**
+     * Given a frame number, prepares the canvas to render based on the nearest cached frame
+     * at or before the frame. On return the canvas will be prepared as if the nearest cached
+     * frame had been rendered and disposed. The returned index is the next frame that needs to be
+     * composited onto the canvas.
+     *
+     * @param previousFrameNumber the frame number that is ones less than the one we're rendering
+     * @param canvas              the canvas to prepare
+     * @return the index of the the next frame to process
+     */
+    private int prepareCanvasWithClosestCachedFrame(int previousFrameNumber, Canvas canvas) {
+        for (int index = previousFrameNumber; index >= 0; index--) {
+            FrameNeededResult neededResult = isFrameNeededForRendering(index);
+            switch (neededResult) {
+                case REQUIRED:
+                    AnimatedDrawableFrameInfo frameInfo = mAnimatedDrawableBackend.getFrameInfo(index);
+                    CloseableReference<Bitmap> startBitmap = mCallback.getCachedBitmap(index);
+                    if (startBitmap != null) {
+                        try {
+                            canvas.drawBitmap(startBitmap.get(), 0, 0, null);
+                            if (frameInfo.disposalMethod == DisposalMethod.DISPOSE_TO_BACKGROUND) {
+                                canvas.drawRect(
+                                        frameInfo.xOffset,
+                                        frameInfo.yOffset,
+                                        frameInfo.width,
+                                        frameInfo.height,
+                                        mTransparentFillPaint);
+                            }
+                            return index + 1;
+                        } finally {
+                            startBitmap.close();
+                        }
+                    } else {
+                        if (!frameInfo.shouldBlendWithPreviousFrame) {
+                            return index;
+                        } else {
+                            // Keep going.
+                            break;
+                        }
+                    }
+                case NOT_REQUIRED:
+                    return index + 1;
+                case ABORT:
+                    return index;
+                case SKIP:
+                default:
+                    // Keep going.
             }
-          } else {
-            if (!frameInfo.shouldBlendWithPreviousFrame) {
-              return index;
+        }
+        return 0;
+    }
+
+    /**
+     * Returns whether the specified frame is needed for rendering the next frame. This is part of
+     * the compositing logic. See {@link FrameNeededResult} for more info about the results.
+     *
+     * @param index the frame to check
+     * @return whether the frame is required taking into account special conditions
+     */
+    private FrameNeededResult isFrameNeededForRendering(int index) {
+        AnimatedDrawableFrameInfo frameInfo = mAnimatedDrawableBackend.getFrameInfo(index);
+        DisposalMethod disposalMethod = frameInfo.disposalMethod;
+        if (disposalMethod == DisposalMethod.DISPOSE_DO_NOT) {
+            // Need this frame so keep going.
+            return FrameNeededResult.REQUIRED;
+        } else if (disposalMethod == DisposalMethod.DISPOSE_TO_BACKGROUND) {
+            if (frameInfo.xOffset == 0 &&
+                    frameInfo.yOffset == 0 &&
+                    frameInfo.width == mAnimatedDrawableBackend.getRenderedWidth() &&
+                    frameInfo.height == mAnimatedDrawableBackend.getRenderedHeight()) {
+                // The frame covered the whole image and we're disposing to background,
+                // so we don't even need to draw this frame.
+                return FrameNeededResult.NOT_REQUIRED;
             } else {
-              // Keep going.
-              break;
+                // We need to draw the image. Then erase the part the previous frame covered.
+                // So keep going.
+                return FrameNeededResult.REQUIRED;
             }
-          }
-        case NOT_REQUIRED:
-          return index + 1;
-        case ABORT:
-          return index;
-        case SKIP:
-        default:
-          // Keep going.
-      }
-    }
-    return 0;
-  }
-
-  /**
-   * Returns whether the specified frame is needed for rendering the next frame. This is part of
-   * the compositing logic. See {@link FrameNeededResult} for more info about the results.
-   *
-   * @param index the frame to check
-   * @return whether the frame is required taking into account special conditions
-   */
-  private FrameNeededResult isFrameNeededForRendering(int index) {
-    AnimatedDrawableFrameInfo frameInfo = mAnimatedDrawableBackend.getFrameInfo(index);
-    DisposalMethod disposalMethod = frameInfo.disposalMethod;
-    if (disposalMethod == DisposalMethod.DISPOSE_DO_NOT) {
-      // Need this frame so keep going.
-      return FrameNeededResult.REQUIRED;
-    } else if (disposalMethod == DisposalMethod.DISPOSE_TO_BACKGROUND) {
-      if (frameInfo.xOffset == 0 &&
-          frameInfo.yOffset == 0 &&
-          frameInfo.width == mAnimatedDrawableBackend.getRenderedWidth() &&
-          frameInfo.height == mAnimatedDrawableBackend.getRenderedHeight()) {
-        // The frame covered the whole image and we're disposing to background,
-        // so we don't even need to draw this frame.
-        return FrameNeededResult.NOT_REQUIRED;
-      } else {
-        // We need to draw the image. Then erase the part the previous frame covered.
-        // So keep going.
-        return FrameNeededResult.REQUIRED;
-      }
-    } else if (disposalMethod == DisposalMethod.DISPOSE_TO_PREVIOUS) {
-      return FrameNeededResult.SKIP;
-    } else {
-      return FrameNeededResult.ABORT;
+        } else if (disposalMethod == DisposalMethod.DISPOSE_TO_PREVIOUS) {
+            return FrameNeededResult.SKIP;
+        } else {
+            return FrameNeededResult.ABORT;
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/RollingStat.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/RollingStat.java
index 5fbed648a..6729d5ba5 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/RollingStat.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/RollingStat.java
@@ -16,50 +16,50 @@
  */
 class RollingStat {
 
-  private static final int WINDOWS = 60;
+    private static final int WINDOWS = 60;
 
-  private final short[] mStat;
+    private final short[] mStat;
 
-  public RollingStat() {
-    mStat = new short[WINDOWS];
-  }
+    public RollingStat() {
+        mStat = new short[WINDOWS];
+    }
 
-  void incrementStats(int toAdd) {
-    long nowMs = SystemClock.uptimeMillis();
-    long nowSeconds = nowMs / 1000;
-    int statsIndex = (int) (nowSeconds % WINDOWS);
-    int marker = (int) ((nowSeconds / WINDOWS) & 0xff);
+    void incrementStats(int toAdd) {
+        long nowMs = SystemClock.uptimeMillis();
+        long nowSeconds = nowMs / 1000;
+        int statsIndex = (int) (nowSeconds % WINDOWS);
+        int marker = (int) ((nowSeconds / WINDOWS) & 0xff);
 
-    short bucketData = mStat[statsIndex];
-    int prevCount = bucketData & 0xff;
-    int prevMarker = (bucketData >> 8) & 0xff;
+        short bucketData = mStat[statsIndex];
+        int prevCount = bucketData & 0xff;
+        int prevMarker = (bucketData >> 8) & 0xff;
 
-    int newCount;
-    if (marker != prevMarker) {
-      newCount = toAdd;
-    } else {
-      newCount = prevCount + toAdd;
-    }
+        int newCount;
+        if (marker != prevMarker) {
+            newCount = toAdd;
+        } else {
+            newCount = prevCount + toAdd;
+        }
 
-    int newData = (marker << 8) | newCount;
-    mStat[statsIndex] = (short) newData;
-  }
+        int newData = (marker << 8) | newCount;
+        mStat[statsIndex] = (short) newData;
+    }
 
-  int getSum(int previousSeconds) {
-    long nowMs = SystemClock.uptimeMillis();
-    long nowSeconds = nowMs / 1000;
-    int statsIndexStart = (int) ((nowSeconds - previousSeconds) % WINDOWS);
-    int currentMarker = (int) ((nowSeconds / WINDOWS) & 0xff);
+    int getSum(int previousSeconds) {
+        long nowMs = SystemClock.uptimeMillis();
+        long nowSeconds = nowMs / 1000;
+        int statsIndexStart = (int) ((nowSeconds - previousSeconds) % WINDOWS);
+        int currentMarker = (int) ((nowSeconds / WINDOWS) & 0xff);
 
-    int sum = 0;
-    for (int i = 0; i < previousSeconds; i++) {
-      short bucketData = mStat[(statsIndexStart + i) % WINDOWS];
-      int count = bucketData & 0xff;
-      int marker = (bucketData >> 8) & 0xff;
-      if (marker == currentMarker) {
-        sum += count;
-      }
+        int sum = 0;
+        for (int i = 0; i < previousSeconds; i++) {
+            short bucketData = mStat[(statsIndexStart + i) % WINDOWS];
+            int count = bucketData & 0xff;
+            int marker = (bucketData >> 8) & 0xff;
+            if (marker == currentMarker) {
+                sum += count;
+            }
+        }
+        return sum;
     }
-    return sum;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/WhatToKeepCachedArray.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/WhatToKeepCachedArray.java
index 7d0dff5c4..8fa16c8d8 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/WhatToKeepCachedArray.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/impl/WhatToKeepCachedArray.java
@@ -19,31 +19,31 @@
 @NotThreadSafe
 class WhatToKeepCachedArray {
 
-  private final boolean[] mData;
+    private final boolean[] mData;
 
-  WhatToKeepCachedArray(int size) {
-    mData = new boolean[size];
-  }
+    WhatToKeepCachedArray(int size) {
+        mData = new boolean[size];
+    }
 
-  boolean get(int index) {
-    return mData[index];
-  }
+    boolean get(int index) {
+        return mData[index];
+    }
 
-  void setAll(boolean value) {
-    for (int i = 0; i < mData.length; i++) {
-      mData[i] = value;
+    void setAll(boolean value) {
+        for (int i = 0; i < mData.length; i++) {
+            mData[i] = value;
+        }
     }
-  }
 
-  void removeOutsideRange(int start, int end) {
-    for (int i = 0; i < mData.length; i++) {
-      if (AnimatedDrawableUtil.isOutsideRange(start, end, i)) {
-        mData[i] = false;
-      }
+    void removeOutsideRange(int start, int end) {
+        for (int i = 0; i < mData.length; i++) {
+            if (AnimatedDrawableUtil.isOutsideRange(start, end, i)) {
+                mData[i] = false;
+            }
+        }
     }
-  }
 
-  void set(int index, boolean value) {
-    mData[index] = value;
-  }
+    void set(int index, boolean value) {
+        mData[index] = value;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtil.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtil.java
index f976bda60..27a9a7e15 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtil.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtil.java
@@ -22,126 +22,126 @@
  */
 public class AnimatedDrawableUtil {
 
-  // See comment in fixFrameDurations below.
-  private static final int MIN_FRAME_DURATION_MS = 11;
-  private static final int FRAME_DURATION_MS_FOR_MIN = 100;
+    // See comment in fixFrameDurations below.
+    private static final int MIN_FRAME_DURATION_MS = 11;
+    private static final int FRAME_DURATION_MS_FOR_MIN = 100;
 
-  public void appendMemoryString(StringBuilder sb, int bytes) {
-    int kbUsed = bytes / 1024;
-    if (kbUsed < 1024) {
-      sb.append(kbUsed);
-      sb.append("KB");
-    } else {
-      int mbUsed = kbUsed / 1024;
-      int mbUsedDecimal = (kbUsed % 1024) / 100;
-      sb.append(mbUsed);
-      sb.append(".");
-      sb.append(mbUsedDecimal);
-      sb.append("MB");
+    public void appendMemoryString(StringBuilder sb, int bytes) {
+        int kbUsed = bytes / 1024;
+        if (kbUsed < 1024) {
+            sb.append(kbUsed);
+            sb.append("KB");
+        } else {
+            int mbUsed = kbUsed / 1024;
+            int mbUsedDecimal = (kbUsed % 1024) / 100;
+            sb.append(mbUsed);
+            sb.append(".");
+            sb.append(mbUsedDecimal);
+            sb.append("MB");
+        }
     }
-  }
 
-  /**
-   * Adjusts the frame duration array to respect logic for minimum frame duration time.
-   *
-   * @param frameDurationMs the frame duration array
-   */
-  public void fixFrameDurations(int[] frameDurationMs) {
-    // We follow Chrome's behavior which comes from Firefox.
-    // Comment from Chrome's ImageSource.cpp follows:
-    // We follow Firefox's behavior and use a duration of 100 ms for any frames that specify
-    // a duration of <= 10 ms. See <rdar://problem/7689300> and <http://webkit.org/b/36082>
-    // for more information.
-    for (int i = 0; i < frameDurationMs.length; i++) {
-      if (frameDurationMs[i] < MIN_FRAME_DURATION_MS) {
-        frameDurationMs[i] = FRAME_DURATION_MS_FOR_MIN;
-      }
+    /**
+     * Adjusts the frame duration array to respect logic for minimum frame duration time.
+     *
+     * @param frameDurationMs the frame duration array
+     */
+    public void fixFrameDurations(int[] frameDurationMs) {
+        // We follow Chrome's behavior which comes from Firefox.
+        // Comment from Chrome's ImageSource.cpp follows:
+        // We follow Firefox's behavior and use a duration of 100 ms for any frames that specify
+        // a duration of <= 10 ms. See <rdar://problem/7689300> and <http://webkit.org/b/36082>
+        // for more information.
+        for (int i = 0; i < frameDurationMs.length; i++) {
+            if (frameDurationMs[i] < MIN_FRAME_DURATION_MS) {
+                frameDurationMs[i] = FRAME_DURATION_MS_FOR_MIN;
+            }
+        }
     }
-  }
 
-  /**
-   * Gets the total duration of an image by summing up the duration of the frames.
-   *
-   * @param frameDurationMs the frame duration array
-   * @return the total duration in milliseconds
-   */
-  public int getTotalDurationFromFrameDurations(int[] frameDurationMs) {
-    int totalMs = 0;
-    for (int i = 0; i < frameDurationMs.length; i++) {
-      totalMs += frameDurationMs[i];
+    /**
+     * Gets the total duration of an image by summing up the duration of the frames.
+     *
+     * @param frameDurationMs the frame duration array
+     * @return the total duration in milliseconds
+     */
+    public int getTotalDurationFromFrameDurations(int[] frameDurationMs) {
+        int totalMs = 0;
+        for (int i = 0; i < frameDurationMs.length; i++) {
+            totalMs += frameDurationMs[i];
+        }
+        return totalMs;
     }
-    return totalMs;
-  }
 
-  /**
-   * Given an array of frame durations, generate an array of timestamps corresponding to when each
-   * frame beings.
-   *
-   * @param frameDurationsMs an array of frame durations
-   * @return an array of timestamps
-   */
-  public int[] getFrameTimeStampsFromDurations(int[] frameDurationsMs) {
-    int[] frameTimestampsMs = new int[frameDurationsMs.length];
-    int accumulatedDurationMs = 0;
-    for (int i = 0; i < frameDurationsMs.length; i++) {
-      frameTimestampsMs[i] = accumulatedDurationMs;
-      accumulatedDurationMs += frameDurationsMs[i];
+    /**
+     * Given an array of frame durations, generate an array of timestamps corresponding to when each
+     * frame beings.
+     *
+     * @param frameDurationsMs an array of frame durations
+     * @return an array of timestamps
+     */
+    public int[] getFrameTimeStampsFromDurations(int[] frameDurationsMs) {
+        int[] frameTimestampsMs = new int[frameDurationsMs.length];
+        int accumulatedDurationMs = 0;
+        for (int i = 0; i < frameDurationsMs.length; i++) {
+            frameTimestampsMs[i] = accumulatedDurationMs;
+            accumulatedDurationMs += frameDurationsMs[i];
+        }
+        return frameTimestampsMs;
     }
-    return frameTimestampsMs;
-  }
 
-  /**
-   * Gets the frame index for specified timestamp.
-   *
-   * @param frameTimestampsMs an array of timestamps generated by {@link #getFrameForTimestampMs)}
-   * @param timestampMs the timestamp
-   * @return the frame index for the timestamp or the last frame number if the timestamp is outside
-   *    the duration of the entire animation
-   */
-  public int getFrameForTimestampMs(int frameTimestampsMs[], int timestampMs) {
-    int index = Arrays.binarySearch(frameTimestampsMs, timestampMs);
-    if (index < 0) {
-      return -index - 1 - 1;
-    } else {
-      return index;
+    /**
+     * Gets the frame index for specified timestamp.
+     *
+     * @param frameTimestampsMs an array of timestamps generated by {@link #getFrameForTimestampMs)}
+     * @param timestampMs       the timestamp
+     * @return the frame index for the timestamp or the last frame number if the timestamp is outside
+     * the duration of the entire animation
+     */
+    public int getFrameForTimestampMs(int frameTimestampsMs[], int timestampMs) {
+        int index = Arrays.binarySearch(frameTimestampsMs, timestampMs);
+        if (index < 0) {
+            return -index - 1 - 1;
+        } else {
+            return index;
+        }
     }
-  }
 
-  @SuppressLint("NewApi")
-  public int getSizeOfBitmap(Bitmap bitmap) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-      return bitmap.getAllocationByteCount();
-    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
-      return bitmap.getByteCount();
-    } else {
-      // Estimate for earlier platforms.
-      return bitmap.getWidth() * bitmap.getHeight() * 4;
+    @SuppressLint("NewApi")
+    public int getSizeOfBitmap(Bitmap bitmap) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+            return bitmap.getAllocationByteCount();
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
+            return bitmap.getByteCount();
+        } else {
+            // Estimate for earlier platforms.
+            return bitmap.getWidth() * bitmap.getHeight() * 4;
+        }
     }
-  }
 
-  /**
-   * Checks whether the specified frame number is outside the range inclusive of both start and end.
-   * If start <= end, start is within, end is within, and everything in between is within.
-   * If start > end, start is within, end is within, everything less than start is within and
-   * everything greater than end is within. This behavior is useful for handling the wrapping case.
-   *
-   * @param startFrame the start frame
-   * @param endFrame the end frame
-   * @param frameNumber the frame number
-   * @return whether the frame is outside the range of [start, end]
-   */
-  public static boolean isOutsideRange(int startFrame, int endFrame, int frameNumber) {
-    if (startFrame == -1 || endFrame == -1) {
-      // This means nothing should pass.
-      return true;
+    /**
+     * Checks whether the specified frame number is outside the range inclusive of both start and end.
+     * If start <= end, start is within, end is within, and everything in between is within.
+     * If start > end, start is within, end is within, everything less than start is within and
+     * everything greater than end is within. This behavior is useful for handling the wrapping case.
+     *
+     * @param startFrame  the start frame
+     * @param endFrame    the end frame
+     * @param frameNumber the frame number
+     * @return whether the frame is outside the range of [start, end]
+     */
+    public static boolean isOutsideRange(int startFrame, int endFrame, int frameNumber) {
+        if (startFrame == -1 || endFrame == -1) {
+            // This means nothing should pass.
+            return true;
+        }
+        boolean outsideRange;
+        if (startFrame <= endFrame) {
+            outsideRange = frameNumber < startFrame || frameNumber > endFrame;
+        } else {
+            // Wrapping
+            outsideRange = frameNumber < startFrame && frameNumber > endFrame;
+        }
+        return outsideRange;
     }
-    boolean outsideRange;
-    if (startFrame <= endFrame) {
-      outsideRange = frameNumber < startFrame || frameNumber > endFrame;
-    } else {
-      // Wrapping
-      outsideRange = frameNumber < startFrame && frameNumber > endFrame;
-    }
-    return outsideRange;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/ArtBitmapFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/ArtBitmapFactory.java
index b82f71227..609df21bf 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/ArtBitmapFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/ArtBitmapFactory.java
@@ -34,142 +34,142 @@
 @TargetApi(Build.VERSION_CODES.LOLLIPOP)
 public class ArtBitmapFactory {
 
-  /**
-   * Size of temporary array. Value recommended by Android docs for decoding Bitmaps.
-   */
-  private static final int DECODE_BUFFER_SIZE = 16 * 1024;
-
-  private final BitmapPool mBitmapPool;
-
-  /**
-   * ArtPlatformImageDecoder decodes images from InputStream - to do so we need to provide
-   * temporary buffer, otherwise framework will allocate one for us for each decode request
-   */
-  @GuardedBy("this")
-  private final byte[] mDecodeBuffer = new byte[DECODE_BUFFER_SIZE];
-
-
-  // TODO (5884402) - remove dependency on JfifUtil
-  private static final byte[] EOI_TAIL = new byte[] {
-      (byte) JfifUtil.MARKER_FIRST_BYTE,
-      (byte) JfifUtil.MARKER_EOI};
-
-  public ArtBitmapFactory(BitmapPool bitmapPool) {
-    mBitmapPool = bitmapPool;
-  }
-
-  /**
-   * Creates a bitmap of the specified width and height.
-   *
-   * @param width the width of the bitmap
-   * @param height the height of the bitmap
-   * @return a reference to the bitmap
-   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
-   */
-  CloseableReference<Bitmap> createBitmap(int width, int height) {
-    Bitmap bitmap = mBitmapPool.get(width * height);
-    Bitmaps.reconfigureBitmap(bitmap, width, height);
-    return CloseableReference.of(bitmap, mBitmapPool);
-  }
-
-  /**
-   * Creates a bitmap from encoded bytes.
-   *
-   * @param pooledByteBufferRef the reference to the encoded bytes
-   * @return the bitmap
-   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
-   */
-  CloseableReference<Bitmap> decodeFromPooledByteBuffer(
-      CloseableReference<PooledByteBuffer> pooledByteBufferRef) {
-    return doDecodeStaticImage(new PooledByteBufferInputStream(pooledByteBufferRef.get()));
-  }
-
-  /**
-   * Creates a bitmap from encoded JPEG bytes. Supports a partial JPEG image.
-   *
-   * @param pooledByteBufferRef the reference to the encoded bytes
-   * @param length the number of encoded bytes in the buffer
-   * @return the bitmap
-   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
-   */
-  CloseableReference<Bitmap> decodeJPEGFromPooledByteBuffer(
-      CloseableReference<PooledByteBuffer> pooledByteBufferRef,
-      int length) {
-    final PooledByteBuffer pooledByteBuffer = pooledByteBufferRef.get();
-    final InputStream jpegBufferInputStream = new PooledByteBufferInputStream(pooledByteBuffer);
-    jpegBufferInputStream.mark(Integer.MAX_VALUE);
-
-    boolean isJpegComplete;
-    try {
-      jpegBufferInputStream.skip(length - 2);
-      isJpegComplete = (jpegBufferInputStream.read() == JfifUtil.MARKER_FIRST_BYTE) &&
-          (jpegBufferInputStream.read() == JfifUtil.MARKER_EOI);
-      jpegBufferInputStream.reset();
-    } catch (IOException ioe) {
-      throw new RuntimeException(ioe);
-    }
+    /**
+     * Size of temporary array. Value recommended by Android docs for decoding Bitmaps.
+     */
+    private static final int DECODE_BUFFER_SIZE = 16 * 1024;
 
-    InputStream jpegDataStream = jpegBufferInputStream;
-    if (pooledByteBuffer.size() > length) {
-      jpegDataStream = new LimitedInputStream(jpegDataStream, length);
-    }
-    if (!isJpegComplete) {
-      jpegDataStream = new TailAppendingInputStream(jpegDataStream, EOI_TAIL);
-    }
-    return doDecodeStaticImage(jpegDataStream);
-  }
-
-  private CloseableReference<Bitmap> doDecodeStaticImage(InputStream inputStream) {
-    inputStream.mark(Integer.MAX_VALUE);
-    final BitmapFactory.Options options = getDecodeOptionsForStream(inputStream);
-    try {
-      inputStream.reset();
-    } catch (IOException ioe) {
-      throw new RuntimeException(ioe);
-    }
+    private final BitmapPool mBitmapPool;
+
+    /**
+     * ArtPlatformImageDecoder decodes images from InputStream - to do so we need to provide
+     * temporary buffer, otherwise framework will allocate one for us for each decode request
+     */
+    @GuardedBy("this")
+    private final byte[] mDecodeBuffer = new byte[DECODE_BUFFER_SIZE];
 
-    final Bitmap bitmapToReuse = mBitmapPool.get(options.outHeight * options.outWidth);
-    if (bitmapToReuse == null) {
-      throw new NullPointerException("BitmapPool.get returned null");
+
+    // TODO (5884402) - remove dependency on JfifUtil
+    private static final byte[] EOI_TAIL = new byte[]{
+            (byte) JfifUtil.MARKER_FIRST_BYTE,
+            (byte) JfifUtil.MARKER_EOI};
+
+    public ArtBitmapFactory(BitmapPool bitmapPool) {
+        mBitmapPool = bitmapPool;
     }
-    options.inBitmap = bitmapToReuse;
-
-    Bitmap decodedBitmap;
-    try {
-      decodedBitmap = BitmapFactory.decodeStream(inputStream, null, options);
-    } catch (RuntimeException re) {
-      mBitmapPool.release(bitmapToReuse);
-      throw re;
+
+    /**
+     * Creates a bitmap of the specified width and height.
+     *
+     * @param width  the width of the bitmap
+     * @param height the height of the bitmap
+     * @return a reference to the bitmap
+     * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
+     */
+    CloseableReference<Bitmap> createBitmap(int width, int height) {
+        Bitmap bitmap = mBitmapPool.get(width * height);
+        Bitmaps.reconfigureBitmap(bitmap, width, height);
+        return CloseableReference.of(bitmap, mBitmapPool);
     }
 
-    if (bitmapToReuse != decodedBitmap) {
-      mBitmapPool.release(bitmapToReuse);
-      decodedBitmap.recycle();
-      throw new IllegalStateException();
+    /**
+     * Creates a bitmap from encoded bytes.
+     *
+     * @param pooledByteBufferRef the reference to the encoded bytes
+     * @return the bitmap
+     * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
+     */
+    CloseableReference<Bitmap> decodeFromPooledByteBuffer(
+            CloseableReference<PooledByteBuffer> pooledByteBufferRef) {
+        return doDecodeStaticImage(new PooledByteBufferInputStream(pooledByteBufferRef.get()));
     }
 
-    return CloseableReference.of(decodedBitmap, mBitmapPool);
-  }
-
-  /**
-   * Options returned by this method are configured with mDecodeBuffer which is GuardedBy("this")
-   */
-  private BitmapFactory.Options getDecodeOptionsForStream(InputStream inputStream) {
-    final BitmapFactory.Options options = new BitmapFactory.Options();
-    options.inTempStorage = mDecodeBuffer;
-
-    options.inJustDecodeBounds = true;
-    // fill outWidth and outHeight
-    BitmapFactory.decodeStream(inputStream, null, options);
-    if (options.outWidth == -1 || options.outHeight == -1) {
-      throw new IllegalArgumentException();
+    /**
+     * Creates a bitmap from encoded JPEG bytes. Supports a partial JPEG image.
+     *
+     * @param pooledByteBufferRef the reference to the encoded bytes
+     * @param length              the number of encoded bytes in the buffer
+     * @return the bitmap
+     * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
+     */
+    CloseableReference<Bitmap> decodeJPEGFromPooledByteBuffer(
+            CloseableReference<PooledByteBuffer> pooledByteBufferRef,
+            int length) {
+        final PooledByteBuffer pooledByteBuffer = pooledByteBufferRef.get();
+        final InputStream jpegBufferInputStream = new PooledByteBufferInputStream(pooledByteBuffer);
+        jpegBufferInputStream.mark(Integer.MAX_VALUE);
+
+        boolean isJpegComplete;
+        try {
+            jpegBufferInputStream.skip(length - 2);
+            isJpegComplete = (jpegBufferInputStream.read() == JfifUtil.MARKER_FIRST_BYTE) &&
+                    (jpegBufferInputStream.read() == JfifUtil.MARKER_EOI);
+            jpegBufferInputStream.reset();
+        } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
+        }
+
+        InputStream jpegDataStream = jpegBufferInputStream;
+        if (pooledByteBuffer.size() > length) {
+            jpegDataStream = new LimitedInputStream(jpegDataStream, length);
+        }
+        if (!isJpegComplete) {
+            jpegDataStream = new TailAppendingInputStream(jpegDataStream, EOI_TAIL);
+        }
+        return doDecodeStaticImage(jpegDataStream);
     }
 
-    options.inJustDecodeBounds = false;
-    options.inDither = true;
-    options.inPreferredConfig = Bitmaps.BITMAP_CONFIG;
-    options.inMutable = true;
+    private CloseableReference<Bitmap> doDecodeStaticImage(InputStream inputStream) {
+        inputStream.mark(Integer.MAX_VALUE);
+        final BitmapFactory.Options options = getDecodeOptionsForStream(inputStream);
+        try {
+            inputStream.reset();
+        } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
+        }
+
+        final Bitmap bitmapToReuse = mBitmapPool.get(options.outHeight * options.outWidth);
+        if (bitmapToReuse == null) {
+            throw new NullPointerException("BitmapPool.get returned null");
+        }
+        options.inBitmap = bitmapToReuse;
+
+        Bitmap decodedBitmap;
+        try {
+            decodedBitmap = BitmapFactory.decodeStream(inputStream, null, options);
+        } catch (RuntimeException re) {
+            mBitmapPool.release(bitmapToReuse);
+            throw re;
+        }
+
+        if (bitmapToReuse != decodedBitmap) {
+            mBitmapPool.release(bitmapToReuse);
+            decodedBitmap.recycle();
+            throw new IllegalStateException();
+        }
+
+        return CloseableReference.of(decodedBitmap, mBitmapPool);
+    }
 
-    return options;
-  }
+    /**
+     * Options returned by this method are configured with mDecodeBuffer which is GuardedBy("this")
+     */
+    private BitmapFactory.Options getDecodeOptionsForStream(InputStream inputStream) {
+        final BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inTempStorage = mDecodeBuffer;
+
+        options.inJustDecodeBounds = true;
+        // fill outWidth and outHeight
+        BitmapFactory.decodeStream(inputStream, null, options);
+        if (options.outWidth == -1 || options.outHeight == -1) {
+            throw new IllegalArgumentException();
+        }
+
+        options.inJustDecodeBounds = false;
+        options.inDither = true;
+        options.inPreferredConfig = Bitmaps.BITMAP_CONFIG;
+        options.inMutable = true;
+
+        return options;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/DalvikBitmapFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/DalvikBitmapFactory.java
index d49b51d88..1a62b579f 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/DalvikBitmapFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/DalvikBitmapFactory.java
@@ -35,196 +35,196 @@
 @TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class DalvikBitmapFactory {
 
-  private final EmptyJpegGenerator mJpegGenerator;
-  private final BitmapCounter mUnpooledBitmapsCounter;
-  private final ResourceReleaser<Bitmap> mUnpooledBitmapsReleaser;
-  private final SharedByteArray mSharedByteArray;
-
-  public DalvikBitmapFactory(
-      EmptyJpegGenerator jpegGenerator,
-      SharedByteArray sharedByteArray) {
-    mJpegGenerator = jpegGenerator;
-    mSharedByteArray = sharedByteArray;
-    mUnpooledBitmapsCounter = BitmapCounterProvider.get();
-    mUnpooledBitmapsReleaser = new ResourceReleaser<Bitmap>() {
-      @Override
-      public void release(Bitmap value) {
+    private final EmptyJpegGenerator mJpegGenerator;
+    private final BitmapCounter mUnpooledBitmapsCounter;
+    private final ResourceReleaser<Bitmap> mUnpooledBitmapsReleaser;
+    private final SharedByteArray mSharedByteArray;
+
+    public DalvikBitmapFactory(
+            EmptyJpegGenerator jpegGenerator,
+            SharedByteArray sharedByteArray) {
+        mJpegGenerator = jpegGenerator;
+        mSharedByteArray = sharedByteArray;
+        mUnpooledBitmapsCounter = BitmapCounterProvider.get();
+        mUnpooledBitmapsReleaser = new ResourceReleaser<Bitmap>() {
+            @Override
+            public void release(Bitmap value) {
+                try {
+                    mUnpooledBitmapsCounter.decrease(value);
+                } finally {
+                    value.recycle();
+                }
+            }
+        };
+    }
+
+    /**
+     * Creates a bitmap of the specified width and height.
+     *
+     * @param width  the width of the bitmap
+     * @param height the height of the bitmap
+     * @return a reference to the bitmap
+     * @throws TooManyBitmapsException    if the pool is full
+     * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
+     */
+    CloseableReference<Bitmap> createBitmap(short width, short height) {
+        CloseableReference<PooledByteBuffer> jpgRef = mJpegGenerator.generate(width, height);
         try {
-          mUnpooledBitmapsCounter.decrease(value);
+            return decodeJPEGFromPooledByteBuffer(jpgRef, jpgRef.get().size());
         } finally {
-          value.recycle();
+            jpgRef.close();
         }
-      }
-    };
-  }
-
-  /**
-   * Creates a bitmap of the specified width and height.
-   *
-   * @param width the width of the bitmap
-   * @param height the height of the bitmap
-   * @return a reference to the bitmap
-   * @throws TooManyBitmapsException if the pool is full
-   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
-   */
-  CloseableReference<Bitmap> createBitmap(short width, short height) {
-    CloseableReference<PooledByteBuffer> jpgRef = mJpegGenerator.generate(width, height);
-    try {
-      return decodeJPEGFromPooledByteBuffer(jpgRef, jpgRef.get().size());
-    } finally {
-      jpgRef.close();
     }
-  }
-
-  /**
-   * Creates a bitmap from encoded bytes.
-   *
-   * @param pooledByteBufferRef the reference to the encoded bytes
-   * @return the bitmap
-   * @throws TooManyBitmapsException if the pool is full
-   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
-   */
-  CloseableReference<Bitmap> decodeFromPooledByteBuffer(
-      final CloseableReference<PooledByteBuffer> pooledByteBufferRef) {
-    final PooledByteBuffer pooledByteBuffer = pooledByteBufferRef.get();
-    final int length = pooledByteBuffer.size();
-    final CloseableReference<byte[]> encodedBytesArrayRef = mSharedByteArray.get(length);
-    try {
-      final byte[] encodedBytesArray = encodedBytesArrayRef.get();
-      pooledByteBuffer.read(0, encodedBytesArray, 0, length);
-      return doDecodeBitmap(encodedBytesArray, length);
-    } finally {
-      encodedBytesArrayRef.close();
+
+    /**
+     * Creates a bitmap from encoded bytes.
+     *
+     * @param pooledByteBufferRef the reference to the encoded bytes
+     * @return the bitmap
+     * @throws TooManyBitmapsException    if the pool is full
+     * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
+     */
+    CloseableReference<Bitmap> decodeFromPooledByteBuffer(
+            final CloseableReference<PooledByteBuffer> pooledByteBufferRef) {
+        final PooledByteBuffer pooledByteBuffer = pooledByteBufferRef.get();
+        final int length = pooledByteBuffer.size();
+        final CloseableReference<byte[]> encodedBytesArrayRef = mSharedByteArray.get(length);
+        try {
+            final byte[] encodedBytesArray = encodedBytesArrayRef.get();
+            pooledByteBuffer.read(0, encodedBytesArray, 0, length);
+            return doDecodeBitmap(encodedBytesArray, length);
+        } finally {
+            encodedBytesArrayRef.close();
+        }
     }
-  }
-
-  /**
-   * Creates a bitmap from encoded JPEG bytes. Supports a partial JPEG image.
-   *
-   * @param pooledByteBufferRef the reference to the encoded bytes
-   * @param length the number of encoded bytes in the buffer
-   * @return the bitmap
-   * @throws TooManyBitmapsException if the pool is full
-   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
-   */
-  CloseableReference<Bitmap> decodeJPEGFromPooledByteBuffer(
-      final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
-      int length) {
-    final PooledByteBuffer pooledByteBuffer = pooledByteBufferRef.get();
-    Preconditions.checkArgument(length <= pooledByteBuffer.size());
-    // allocate bigger array in case EOI needs to be added
-    final CloseableReference<byte[]> encodedBytesArrayRef = mSharedByteArray.get(length + 2);
-    try {
-      byte[] encodedBytesArray = encodedBytesArrayRef.get();
-      pooledByteBuffer.read(0, encodedBytesArray, 0, length);
-      if (!endsWithEOI(encodedBytesArray, length)) {
-        putEOI(encodedBytesArray, length);
-        length += 2;
-      }
-      return doDecodeBitmap(encodedBytesArray, length);
-    } finally {
-      encodedBytesArrayRef.close();
+
+    /**
+     * Creates a bitmap from encoded JPEG bytes. Supports a partial JPEG image.
+     *
+     * @param pooledByteBufferRef the reference to the encoded bytes
+     * @param length              the number of encoded bytes in the buffer
+     * @return the bitmap
+     * @throws TooManyBitmapsException    if the pool is full
+     * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
+     */
+    CloseableReference<Bitmap> decodeJPEGFromPooledByteBuffer(
+            final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
+            int length) {
+        final PooledByteBuffer pooledByteBuffer = pooledByteBufferRef.get();
+        Preconditions.checkArgument(length <= pooledByteBuffer.size());
+        // allocate bigger array in case EOI needs to be added
+        final CloseableReference<byte[]> encodedBytesArrayRef = mSharedByteArray.get(length + 2);
+        try {
+            byte[] encodedBytesArray = encodedBytesArrayRef.get();
+            pooledByteBuffer.read(0, encodedBytesArray, 0, length);
+            if (!endsWithEOI(encodedBytesArray, length)) {
+                putEOI(encodedBytesArray, length);
+                length += 2;
+            }
+            return doDecodeBitmap(encodedBytesArray, length);
+        } finally {
+            encodedBytesArrayRef.close();
+        }
     }
-  }
-
-  /**
-   * Performs the actual decoding.
-   */
-  private CloseableReference<Bitmap> doDecodeBitmap(
-      final byte[] encodedBytes,
-      final int length) {
-    final Bitmap bitmap = decodeAsPurgeableBitmap(encodedBytes, length);
-
-    try {
-      // Real decoding happens here - if the image was corrupted, this will throw an exception
-      Bitmaps.pinBitmap(bitmap);
-    } catch (Exception e) {
-      bitmap.recycle();
-      throw Throwables.propagate(e);
+
+    /**
+     * Performs the actual decoding.
+     */
+    private CloseableReference<Bitmap> doDecodeBitmap(
+            final byte[] encodedBytes,
+            final int length) {
+        final Bitmap bitmap = decodeAsPurgeableBitmap(encodedBytes, length);
+
+        try {
+            // Real decoding happens here - if the image was corrupted, this will throw an exception
+            Bitmaps.pinBitmap(bitmap);
+        } catch (Exception e) {
+            bitmap.recycle();
+            throw Throwables.propagate(e);
+        }
+
+        if (!mUnpooledBitmapsCounter.increase(bitmap)) {
+            bitmap.recycle();
+            throw new TooManyBitmapsException();
+        }
+
+        return CloseableReference.of(bitmap, mUnpooledBitmapsReleaser);
+    }
+
+    /**
+     * Decode the input into a purgeable bitmap
+     *
+     * @param encodedBytes the input encoded image
+     * @return a purgeable bitmap
+     */
+    @SuppressLint("NewApi")
+    private static Bitmap decodeAsPurgeableBitmap(byte[] encodedBytes, int size) {
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inDither = true; // known to improve picture quality at low cost
+        options.inPreferredConfig = Bitmaps.BITMAP_CONFIG;
+        // Decode the image into a 'purgeable' bitmap that lives on the ashmem heap
+        options.inPurgeable = true;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            options.inMutable = true;  // no known perf difference; allows postprocessing to work
+        }
+        Bitmap bitmap = BitmapFactory.decodeByteArray(
+                encodedBytes,
+                0,
+                size,
+                options);
+        return Preconditions.checkNotNull(bitmap, "BitmapFactory returned null");
     }
 
-    if (!mUnpooledBitmapsCounter.increase(bitmap)) {
-      bitmap.recycle();
-      throw new TooManyBitmapsException();
+    private static void putEOI(byte[] imageBytes, int offset) {
+        // TODO 5884402: remove dependency on JfifUtil
+        imageBytes[offset] = (byte) JfifUtil.MARKER_FIRST_BYTE;
+        imageBytes[offset + 1] = (byte) JfifUtil.MARKER_EOI;
     }
 
-    return CloseableReference.of(bitmap, mUnpooledBitmapsReleaser);
-  }
-
-  /**
-   * Decode the input into a purgeable bitmap
-   *
-   * @param encodedBytes the input encoded image
-   * @return a purgeable bitmap
-   */
-  @SuppressLint("NewApi")
-  private static Bitmap decodeAsPurgeableBitmap(byte[] encodedBytes, int size) {
-    BitmapFactory.Options options = new BitmapFactory.Options();
-    options.inDither = true; // known to improve picture quality at low cost
-    options.inPreferredConfig = Bitmaps.BITMAP_CONFIG;
-    // Decode the image into a 'purgeable' bitmap that lives on the ashmem heap
-    options.inPurgeable = true;
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-      options.inMutable = true;  // no known perf difference; allows postprocessing to work
+    private static boolean endsWithEOI(final byte[] imageBytes, int length) {
+        // TODO 5884402: remove dependency on JfifUtil
+        return length >= 2 &&
+                imageBytes[length - 2] == (byte) JfifUtil.MARKER_FIRST_BYTE &&
+                imageBytes[length - 1] == (byte) JfifUtil.MARKER_EOI;
     }
-    Bitmap bitmap = BitmapFactory.decodeByteArray(
-        encodedBytes,
-        0,
-        size,
-        options);
-    return Preconditions.checkNotNull(bitmap, "BitmapFactory returned null");
-  }
-
-  private static void putEOI(byte[] imageBytes, int offset) {
-    // TODO 5884402: remove dependency on JfifUtil
-    imageBytes[offset] = (byte) JfifUtil.MARKER_FIRST_BYTE;
-    imageBytes[offset + 1] = (byte) JfifUtil.MARKER_EOI;
-  }
-
-  private static boolean endsWithEOI(final byte[] imageBytes, int length) {
-    // TODO 5884402: remove dependency on JfifUtil
-    return length >= 2 &&
-        imageBytes[length - 2] == (byte) JfifUtil.MARKER_FIRST_BYTE &&
-        imageBytes[length - 1] == (byte) JfifUtil.MARKER_EOI;
-  }
-
-  /**
-   * Associates bitmaps with the current bitmap pool.
-   *
-   * <p> If this method throws TooManyBitmapsException, the code will have called
-   * {@link Bitmap#recycle} on the bitmaps.
-   *
-   * @param bitmaps the bitmaps to associate
-   * @return the references to the bitmaps that are now tied to the bitmap pool
-   * @throws TooManyBitmapsException if the pool is full
-   */
-  List<CloseableReference<Bitmap>> associateBitmapsWithBitmapCounter(
-      final List<Bitmap> bitmaps) {
-    int countedBitmaps = 0;
-    try {
-      for (; countedBitmaps < bitmaps.size(); ++countedBitmaps) {
-        final Bitmap bitmap = bitmaps.get(countedBitmaps);
-        // 'Pin' the bytes of the purgeable bitmap, so it is now not purgeable
-        Bitmaps.pinBitmap(bitmap);
-        if (!mUnpooledBitmapsCounter.increase(bitmap)) {
-          throw new TooManyBitmapsException();
-        }
-      }
-      List<CloseableReference<Bitmap>> ret = Lists.newArrayList();
-      for (Bitmap bitmap : bitmaps) {
-        ret.add(CloseableReference.of(bitmap, mUnpooledBitmapsReleaser));
-      }
-      return ret;
-    } catch (Exception exception) {
-      if (bitmaps != null) {
-        for (Bitmap bitmap : bitmaps) {
-          if (countedBitmaps-- > 0) {
-            mUnpooledBitmapsCounter.decrease(bitmap);
-          }
-          bitmap.recycle();
+
+    /**
+     * Associates bitmaps with the current bitmap pool.
+     * <p>
+     * <p> If this method throws TooManyBitmapsException, the code will have called
+     * {@link Bitmap#recycle} on the bitmaps.
+     *
+     * @param bitmaps the bitmaps to associate
+     * @return the references to the bitmaps that are now tied to the bitmap pool
+     * @throws TooManyBitmapsException if the pool is full
+     */
+    List<CloseableReference<Bitmap>> associateBitmapsWithBitmapCounter(
+            final List<Bitmap> bitmaps) {
+        int countedBitmaps = 0;
+        try {
+            for (; countedBitmaps < bitmaps.size(); ++countedBitmaps) {
+                final Bitmap bitmap = bitmaps.get(countedBitmaps);
+                // 'Pin' the bytes of the purgeable bitmap, so it is now not purgeable
+                Bitmaps.pinBitmap(bitmap);
+                if (!mUnpooledBitmapsCounter.increase(bitmap)) {
+                    throw new TooManyBitmapsException();
+                }
+            }
+            List<CloseableReference<Bitmap>> ret = Lists.newArrayList();
+            for (Bitmap bitmap : bitmaps) {
+                ret.add(CloseableReference.of(bitmap, mUnpooledBitmapsReleaser));
+            }
+            return ret;
+        } catch (Exception exception) {
+            if (bitmaps != null) {
+                for (Bitmap bitmap : bitmaps) {
+                    if (countedBitmaps-- > 0) {
+                        mUnpooledBitmapsCounter.decrease(bitmap);
+                    }
+                    bitmap.recycle();
+                }
+            }
+            throw Throwables.propagate(exception);
         }
-      }
-      throw Throwables.propagate(exception);
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/EmptyJpegGenerator.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/EmptyJpegGenerator.java
index 47e2fbf9b..266cc7c3e 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/EmptyJpegGenerator.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/EmptyJpegGenerator.java
@@ -18,171 +18,171 @@
 
 /**
  * Producer that emits a dummy, fixed-size JPEG bytearray.
- *
+ * <p>
  * <p>The purpose of this jpeg is to serve as the source for a purgeable bitmap which will
  * in turn have its contents overwritten, enabling us to copy into a purgeable bitmap.
  */
 public class EmptyJpegGenerator {
 
-  // The following JPEG was generated by compressing a 1x1 bitmap on an Android device
-  // and logcatting the output.
-
-  private static final byte[] EMPTY_JPEG_PREFIX = new byte[]{
-      (byte) 0xff, (byte) 0xd8, // Start of Image marker
-
-      // Quantization table
-      (byte) 0xff, (byte) 0xdb, // DQT marker
-      (byte) 0x00, (byte) 0x43, // Length
-      (byte) 0x00, // Precision: 0 Id: 0
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff,
-
-      // Frame data
-      (byte) 0xff, (byte) 0xc0, // SOF marker
-      (byte) 0x00, (byte) 0x11, // Frame length
-      (byte) 0x08, // Sample precision
-  };
-
-  // Width and height (16 bits each) are inserted between these two
-
-  private static final byte[] EMPTY_JPEG_SUFFIX = new byte[]{
-      (byte) 0x03, // Number of components
-      (byte) 0x01, // Component 1
-      (byte) 0x22, // Sampling factor
-      (byte) 0x00, // Quantization selector
-      (byte) 0x02, // Component 2
-      (byte) 0x11, // Sampling factor
-      (byte) 0x00, // Quantization selector
-      (byte) 0x03, // Component 3
-      (byte) 0x11, // Sampling factor
-      (byte) 0x00, // Quantization selector
-
-      // Huffman table
-      (byte) 0xff, (byte) 0xc4, // DHT marker
-      (byte) 0x00, (byte) 0x1f, // Length
-      (byte) 0x00, // Table class: DC id: 0
-      // Huffman code lengths
-      (byte) 0x00, (byte) 0x01, (byte) 0x05, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01,
-      (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00,
-      // Huffman code values
-      (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06,
-      (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x0a, (byte) 0x0b, (byte) 0xff, (byte) 0xc4,
-      (byte) 0x00, (byte) 0xb5, (byte) 0x10, (byte) 0x00, (byte) 0x02, (byte) 0x01, (byte) 0x03,
-      (byte) 0x03, (byte) 0x02, (byte) 0x04, (byte) 0x03, (byte) 0x05, (byte) 0x05, (byte) 0x04,
-      (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x7d, (byte) 0x01, (byte) 0x02,
-      (byte) 0x03, (byte) 0x00, (byte) 0x04, (byte) 0x11, (byte) 0x05, (byte) 0x12, (byte) 0x21,
-      (byte) 0x31, (byte) 0x41, (byte) 0x06, (byte) 0x13, (byte) 0x51, (byte) 0x61, (byte) 0x07,
-      (byte) 0x22, (byte) 0x71, (byte) 0x14, (byte) 0x32, (byte) 0x81, (byte) 0x91, (byte) 0xa1,
-      (byte) 0x08, (byte) 0x23, (byte) 0x42, (byte) 0xb1, (byte) 0xc1, (byte) 0x15, (byte) 0x52,
-      (byte) 0xd1, (byte) 0xf0, (byte) 0x24, (byte) 0x33, (byte) 0x62, (byte) 0x72, (byte) 0x82,
-      (byte) 0x09, (byte) 0x0a, (byte) 0x16, (byte) 0x17, (byte) 0x18, (byte) 0x19, (byte) 0x1a,
-      (byte) 0x25, (byte) 0x26, (byte) 0x27, (byte) 0x28, (byte) 0x29, (byte) 0x2a, (byte) 0x34,
-      (byte) 0x35, (byte) 0x36, (byte) 0x37, (byte) 0x38, (byte) 0x39, (byte) 0x3a, (byte) 0x43,
-      (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x48, (byte) 0x49, (byte) 0x4a,
-      (byte) 0x53, (byte) 0x54, (byte) 0x55, (byte) 0x56,
-      (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x5a, (byte) 0x63, (byte) 0x64, (byte) 0x65,
-      (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69, (byte) 0x6a, (byte) 0x73, (byte) 0x74,
-      (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x78, (byte) 0x79, (byte) 0x7a, (byte) 0x83,
-      (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x8a,
-      (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98,
-      (byte) 0x99, (byte) 0x9a, (byte) 0xa2, (byte) 0xa3, (byte) 0xa4, (byte) 0xa5, (byte) 0xa6,
-      (byte) 0xa7, (byte) 0xa8, (byte) 0xa9, (byte) 0xaa, (byte) 0xb2, (byte) 0xb3, (byte) 0xb4,
-      (byte) 0xb5, (byte) 0xb6, (byte) 0xb7, (byte) 0xb8, (byte) 0xb9, (byte) 0xba, (byte) 0xc2,
-      (byte) 0xc3, (byte) 0xc4, (byte) 0xc5, (byte) 0xc6, (byte) 0xc7, (byte) 0xc8, (byte) 0xc9,
-      (byte) 0xca, (byte) 0xd2, (byte) 0xd3, (byte) 0xd4, (byte) 0xd5, (byte) 0xd6, (byte) 0xd7,
-      (byte) 0xd8, (byte) 0xd9, (byte) 0xda, (byte) 0xe1, (byte) 0xe2, (byte) 0xe3, (byte) 0xe4,
-      (byte) 0xe5, (byte) 0xe6, (byte) 0xe7, (byte) 0xe8, (byte) 0xe9, (byte) 0xea, (byte) 0xf1,
-      (byte) 0xf2, (byte) 0xf3, (byte) 0xf4, (byte) 0xf5, (byte) 0xf6, (byte) 0xf7, (byte) 0xf8,
-      (byte) 0xf9, (byte) 0xfa, (byte) 0xff, (byte) 0xc4, (byte) 0x00, (byte) 0x1f, (byte) 0x01,
-      (byte) 0x00, (byte) 0x03, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01,
-      (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,
-      (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x0a, (byte) 0x0b,
-
-      (byte) 0xff, (byte) 0xc4, // DHT marker
-      (byte) 0x00, (byte) 0xb5, // Length
-      (byte) 0x11, // Table class: AC id: 1
-      // Huffman code lengths
-      (byte) 0x00, (byte) 0x02, (byte) 0x01, (byte) 0x02, (byte) 0x04, (byte) 0x04, (byte) 0x03,
-      (byte) 0x04, (byte) 0x07, (byte) 0x05, (byte) 0x04, (byte) 0x04, (byte) 0x00, (byte) 0x01,
-      (byte) 0x02, (byte) 0x77,
-      // Huffman code values
-      (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x11, (byte) 0x04, (byte) 0x05,
-      (byte) 0x21, (byte) 0x31, (byte) 0x06, (byte) 0x12, (byte) 0x41, (byte) 0x51, (byte) 0x07,
-      (byte) 0x61, (byte) 0x71, (byte) 0x13, (byte) 0x22, (byte) 0x32, (byte) 0x81, (byte) 0x08,
-      (byte) 0x14, (byte) 0x42, (byte) 0x91, (byte) 0xa1, (byte) 0xb1, (byte) 0xc1, (byte) 0x09,
-      (byte) 0x23, (byte) 0x33, (byte) 0x52, (byte) 0xf0, (byte) 0x15, (byte) 0x62, (byte) 0x72,
-      (byte) 0xd1, (byte) 0x0a, (byte) 0x16, (byte) 0x24, (byte) 0x34, (byte) 0xe1, (byte) 0x25,
-      (byte) 0xf1, (byte) 0x17, (byte) 0x18, (byte) 0x19, (byte) 0x1a, (byte) 0x26, (byte) 0x27,
-      (byte) 0x28, (byte) 0x29, (byte) 0x2a, (byte) 0x35, (byte) 0x36, (byte) 0x37, (byte) 0x38,
-      (byte) 0x39, (byte) 0x3a, (byte) 0x43, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47,
-      (byte) 0x48, (byte) 0x49, (byte) 0x4a, (byte) 0x53, (byte) 0x54, (byte) 0x55, (byte) 0x56,
-      (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x5a, (byte) 0x63, (byte) 0x64, (byte) 0x65,
-      (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69, (byte) 0x6a, (byte) 0x73, (byte) 0x74,
-      (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x78, (byte) 0x79, (byte) 0x7a, (byte) 0x82,
-      (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89,
-      (byte) 0x8a, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97,
-      (byte) 0x98, (byte) 0x99, (byte) 0x9a, (byte) 0xa2, (byte) 0xa3, (byte) 0xa4, (byte) 0xa5,
-      (byte) 0xa6, (byte) 0xa7, (byte) 0xa8, (byte) 0xa9, (byte) 0xaa, (byte) 0xb2, (byte) 0xb3,
-      (byte) 0xb4, (byte) 0xb5, (byte) 0xb6, (byte) 0xb7, (byte) 0xb8, (byte) 0xb9, (byte) 0xba,
-      (byte) 0xc2, (byte) 0xc3, (byte) 0xc4, (byte) 0xc5, (byte) 0xc6, (byte) 0xc7, (byte) 0xc8,
-      (byte) 0xc9, (byte) 0xca, (byte) 0xd2, (byte) 0xd3, (byte) 0xd4, (byte) 0xd5, (byte) 0xd6,
-      (byte) 0xd7, (byte) 0xd8, (byte) 0xd9, (byte) 0xda, (byte) 0xe2, (byte) 0xe3, (byte) 0xe4,
-      (byte) 0xe5, (byte) 0xe6, (byte) 0xe7, (byte) 0xe8, (byte) 0xe9, (byte) 0xea, (byte) 0xf2,
-      (byte) 0xf3, (byte) 0xf4, (byte) 0xf5, (byte) 0xf6, (byte) 0xf7, (byte) 0xf8, (byte) 0xf9,
-      (byte) 0xfa,
-
-      // Scan data
-      (byte) 0xff, (byte) 0xda, // Start of Scan marker
-      (byte) 0x00, (byte) 0x0c, // Scan header length
-      (byte) 0x03, // Number of components
-      (byte) 0x01, // Component 1
-      (byte) 0x00, // Coding table selector
-      (byte) 0x02, // Start spectral selectin
-      (byte) 0x11, // End spectral selection
-      (byte) 0x03, // Approximation bits
-
-      // Huffman-encoded data
-      (byte) 0x11, (byte) 0x00, (byte) 0x3f, (byte) 0x00, (byte) 0x8e, (byte) 0x8a, (byte) 0x28,
-      (byte) 0xa0, (byte) 0x0f,
-
-      // End of Image
-      (byte) 0xff, (byte) 0xd9, // EOI marker
-  };
-
-  private final PooledByteBufferFactory mPooledByteBufferFactory;
-
-  public EmptyJpegGenerator(PooledByteBufferFactory pooledByteBufferFactory) {
-    mPooledByteBufferFactory = pooledByteBufferFactory;
-  }
-
-  public CloseableReference<PooledByteBuffer> generate(short width, short height) {
-    PooledByteBufferOutputStream os = null;
-    try {
-      os = mPooledByteBufferFactory.newOutputStream(
-          EMPTY_JPEG_PREFIX.length + EMPTY_JPEG_SUFFIX.length + 4);
-      os.write(EMPTY_JPEG_PREFIX);
-      os.write((byte) (height >> 8));
-      os.write((byte) (height & 0x00ff));
-      os.write((byte) (width >> 8));
-      os.write((byte) (width & 0x00ff));
-      os.write(EMPTY_JPEG_SUFFIX);
-      return CloseableReference.of(os.toByteBuffer());
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    } finally {
-      if (os != null) {
-        os.close();
-      }
+    // The following JPEG was generated by compressing a 1x1 bitmap on an Android device
+    // and logcatting the output.
+
+    private static final byte[] EMPTY_JPEG_PREFIX = new byte[]{
+            (byte) 0xff, (byte) 0xd8, // Start of Image marker
+
+            // Quantization table
+            (byte) 0xff, (byte) 0xdb, // DQT marker
+            (byte) 0x00, (byte) 0x43, // Length
+            (byte) 0x00, // Precision: 0 Id: 0
+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+            (byte) 0xff,
+
+            // Frame data
+            (byte) 0xff, (byte) 0xc0, // SOF marker
+            (byte) 0x00, (byte) 0x11, // Frame length
+            (byte) 0x08, // Sample precision
+    };
+
+    // Width and height (16 bits each) are inserted between these two
+
+    private static final byte[] EMPTY_JPEG_SUFFIX = new byte[]{
+            (byte) 0x03, // Number of components
+            (byte) 0x01, // Component 1
+            (byte) 0x22, // Sampling factor
+            (byte) 0x00, // Quantization selector
+            (byte) 0x02, // Component 2
+            (byte) 0x11, // Sampling factor
+            (byte) 0x00, // Quantization selector
+            (byte) 0x03, // Component 3
+            (byte) 0x11, // Sampling factor
+            (byte) 0x00, // Quantization selector
+
+            // Huffman table
+            (byte) 0xff, (byte) 0xc4, // DHT marker
+            (byte) 0x00, (byte) 0x1f, // Length
+            (byte) 0x00, // Table class: DC id: 0
+            // Huffman code lengths
+            (byte) 0x00, (byte) 0x01, (byte) 0x05, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01,
+            (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+            (byte) 0x00, (byte) 0x00,
+            // Huffman code values
+            (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06,
+            (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x0a, (byte) 0x0b, (byte) 0xff, (byte) 0xc4,
+            (byte) 0x00, (byte) 0xb5, (byte) 0x10, (byte) 0x00, (byte) 0x02, (byte) 0x01, (byte) 0x03,
+            (byte) 0x03, (byte) 0x02, (byte) 0x04, (byte) 0x03, (byte) 0x05, (byte) 0x05, (byte) 0x04,
+            (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x7d, (byte) 0x01, (byte) 0x02,
+            (byte) 0x03, (byte) 0x00, (byte) 0x04, (byte) 0x11, (byte) 0x05, (byte) 0x12, (byte) 0x21,
+            (byte) 0x31, (byte) 0x41, (byte) 0x06, (byte) 0x13, (byte) 0x51, (byte) 0x61, (byte) 0x07,
+            (byte) 0x22, (byte) 0x71, (byte) 0x14, (byte) 0x32, (byte) 0x81, (byte) 0x91, (byte) 0xa1,
+            (byte) 0x08, (byte) 0x23, (byte) 0x42, (byte) 0xb1, (byte) 0xc1, (byte) 0x15, (byte) 0x52,
+            (byte) 0xd1, (byte) 0xf0, (byte) 0x24, (byte) 0x33, (byte) 0x62, (byte) 0x72, (byte) 0x82,
+            (byte) 0x09, (byte) 0x0a, (byte) 0x16, (byte) 0x17, (byte) 0x18, (byte) 0x19, (byte) 0x1a,
+            (byte) 0x25, (byte) 0x26, (byte) 0x27, (byte) 0x28, (byte) 0x29, (byte) 0x2a, (byte) 0x34,
+            (byte) 0x35, (byte) 0x36, (byte) 0x37, (byte) 0x38, (byte) 0x39, (byte) 0x3a, (byte) 0x43,
+            (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x48, (byte) 0x49, (byte) 0x4a,
+            (byte) 0x53, (byte) 0x54, (byte) 0x55, (byte) 0x56,
+            (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x5a, (byte) 0x63, (byte) 0x64, (byte) 0x65,
+            (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69, (byte) 0x6a, (byte) 0x73, (byte) 0x74,
+            (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x78, (byte) 0x79, (byte) 0x7a, (byte) 0x83,
+            (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x8a,
+            (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98,
+            (byte) 0x99, (byte) 0x9a, (byte) 0xa2, (byte) 0xa3, (byte) 0xa4, (byte) 0xa5, (byte) 0xa6,
+            (byte) 0xa7, (byte) 0xa8, (byte) 0xa9, (byte) 0xaa, (byte) 0xb2, (byte) 0xb3, (byte) 0xb4,
+            (byte) 0xb5, (byte) 0xb6, (byte) 0xb7, (byte) 0xb8, (byte) 0xb9, (byte) 0xba, (byte) 0xc2,
+            (byte) 0xc3, (byte) 0xc4, (byte) 0xc5, (byte) 0xc6, (byte) 0xc7, (byte) 0xc8, (byte) 0xc9,
+            (byte) 0xca, (byte) 0xd2, (byte) 0xd3, (byte) 0xd4, (byte) 0xd5, (byte) 0xd6, (byte) 0xd7,
+            (byte) 0xd8, (byte) 0xd9, (byte) 0xda, (byte) 0xe1, (byte) 0xe2, (byte) 0xe3, (byte) 0xe4,
+            (byte) 0xe5, (byte) 0xe6, (byte) 0xe7, (byte) 0xe8, (byte) 0xe9, (byte) 0xea, (byte) 0xf1,
+            (byte) 0xf2, (byte) 0xf3, (byte) 0xf4, (byte) 0xf5, (byte) 0xf6, (byte) 0xf7, (byte) 0xf8,
+            (byte) 0xf9, (byte) 0xfa, (byte) 0xff, (byte) 0xc4, (byte) 0x00, (byte) 0x1f, (byte) 0x01,
+            (byte) 0x00, (byte) 0x03, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01,
+            (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,
+            (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x0a, (byte) 0x0b,
+
+            (byte) 0xff, (byte) 0xc4, // DHT marker
+            (byte) 0x00, (byte) 0xb5, // Length
+            (byte) 0x11, // Table class: AC id: 1
+            // Huffman code lengths
+            (byte) 0x00, (byte) 0x02, (byte) 0x01, (byte) 0x02, (byte) 0x04, (byte) 0x04, (byte) 0x03,
+            (byte) 0x04, (byte) 0x07, (byte) 0x05, (byte) 0x04, (byte) 0x04, (byte) 0x00, (byte) 0x01,
+            (byte) 0x02, (byte) 0x77,
+            // Huffman code values
+            (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x11, (byte) 0x04, (byte) 0x05,
+            (byte) 0x21, (byte) 0x31, (byte) 0x06, (byte) 0x12, (byte) 0x41, (byte) 0x51, (byte) 0x07,
+            (byte) 0x61, (byte) 0x71, (byte) 0x13, (byte) 0x22, (byte) 0x32, (byte) 0x81, (byte) 0x08,
+            (byte) 0x14, (byte) 0x42, (byte) 0x91, (byte) 0xa1, (byte) 0xb1, (byte) 0xc1, (byte) 0x09,
+            (byte) 0x23, (byte) 0x33, (byte) 0x52, (byte) 0xf0, (byte) 0x15, (byte) 0x62, (byte) 0x72,
+            (byte) 0xd1, (byte) 0x0a, (byte) 0x16, (byte) 0x24, (byte) 0x34, (byte) 0xe1, (byte) 0x25,
+            (byte) 0xf1, (byte) 0x17, (byte) 0x18, (byte) 0x19, (byte) 0x1a, (byte) 0x26, (byte) 0x27,
+            (byte) 0x28, (byte) 0x29, (byte) 0x2a, (byte) 0x35, (byte) 0x36, (byte) 0x37, (byte) 0x38,
+            (byte) 0x39, (byte) 0x3a, (byte) 0x43, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47,
+            (byte) 0x48, (byte) 0x49, (byte) 0x4a, (byte) 0x53, (byte) 0x54, (byte) 0x55, (byte) 0x56,
+            (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x5a, (byte) 0x63, (byte) 0x64, (byte) 0x65,
+            (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69, (byte) 0x6a, (byte) 0x73, (byte) 0x74,
+            (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x78, (byte) 0x79, (byte) 0x7a, (byte) 0x82,
+            (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89,
+            (byte) 0x8a, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97,
+            (byte) 0x98, (byte) 0x99, (byte) 0x9a, (byte) 0xa2, (byte) 0xa3, (byte) 0xa4, (byte) 0xa5,
+            (byte) 0xa6, (byte) 0xa7, (byte) 0xa8, (byte) 0xa9, (byte) 0xaa, (byte) 0xb2, (byte) 0xb3,
+            (byte) 0xb4, (byte) 0xb5, (byte) 0xb6, (byte) 0xb7, (byte) 0xb8, (byte) 0xb9, (byte) 0xba,
+            (byte) 0xc2, (byte) 0xc3, (byte) 0xc4, (byte) 0xc5, (byte) 0xc6, (byte) 0xc7, (byte) 0xc8,
+            (byte) 0xc9, (byte) 0xca, (byte) 0xd2, (byte) 0xd3, (byte) 0xd4, (byte) 0xd5, (byte) 0xd6,
+            (byte) 0xd7, (byte) 0xd8, (byte) 0xd9, (byte) 0xda, (byte) 0xe2, (byte) 0xe3, (byte) 0xe4,
+            (byte) 0xe5, (byte) 0xe6, (byte) 0xe7, (byte) 0xe8, (byte) 0xe9, (byte) 0xea, (byte) 0xf2,
+            (byte) 0xf3, (byte) 0xf4, (byte) 0xf5, (byte) 0xf6, (byte) 0xf7, (byte) 0xf8, (byte) 0xf9,
+            (byte) 0xfa,
+
+            // Scan data
+            (byte) 0xff, (byte) 0xda, // Start of Scan marker
+            (byte) 0x00, (byte) 0x0c, // Scan header length
+            (byte) 0x03, // Number of components
+            (byte) 0x01, // Component 1
+            (byte) 0x00, // Coding table selector
+            (byte) 0x02, // Start spectral selectin
+            (byte) 0x11, // End spectral selection
+            (byte) 0x03, // Approximation bits
+
+            // Huffman-encoded data
+            (byte) 0x11, (byte) 0x00, (byte) 0x3f, (byte) 0x00, (byte) 0x8e, (byte) 0x8a, (byte) 0x28,
+            (byte) 0xa0, (byte) 0x0f,
+
+            // End of Image
+            (byte) 0xff, (byte) 0xd9, // EOI marker
+    };
+
+    private final PooledByteBufferFactory mPooledByteBufferFactory;
+
+    public EmptyJpegGenerator(PooledByteBufferFactory pooledByteBufferFactory) {
+        mPooledByteBufferFactory = pooledByteBufferFactory;
+    }
+
+    public CloseableReference<PooledByteBuffer> generate(short width, short height) {
+        PooledByteBufferOutputStream os = null;
+        try {
+            os = mPooledByteBufferFactory.newOutputStream(
+                    EMPTY_JPEG_PREFIX.length + EMPTY_JPEG_SUFFIX.length + 4);
+            os.write(EMPTY_JPEG_PREFIX);
+            os.write((byte) (height >> 8));
+            os.write((byte) (height & 0x00ff));
+            os.write((byte) (width >> 8));
+            os.write((byte) (width & 0x00ff));
+            os.write(EMPTY_JPEG_SUFFIX);
+            return CloseableReference.of(os.toByteBuffer());
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        } finally {
+            if (os != null) {
+                os.close();
+            }
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/GingerbreadBitmapFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/GingerbreadBitmapFactory.java
index 3e6e97ff9..daa20906b 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/GingerbreadBitmapFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/GingerbreadBitmapFactory.java
@@ -19,27 +19,27 @@
  */
 public class GingerbreadBitmapFactory {
 
-  private final ResourceReleaser<Bitmap> mBitmapResourceReleaser;
+    private final ResourceReleaser<Bitmap> mBitmapResourceReleaser;
 
-  public GingerbreadBitmapFactory() {
-    mBitmapResourceReleaser = new ResourceReleaser<Bitmap>() {
-      @Override
-      public void release(Bitmap value) {
-        value.recycle();
-      }
-    };
-  }
+    public GingerbreadBitmapFactory() {
+        mBitmapResourceReleaser = new ResourceReleaser<Bitmap>() {
+            @Override
+            public void release(Bitmap value) {
+                value.recycle();
+            }
+        };
+    }
 
-  /**
-   * Creates a bitmap of the specified width and height.
-   *
-   * @param width the width of the bitmap
-   * @param height the height of the bitmap
-   * @return a reference to the bitmap
-   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
-   */
-  CloseableReference<Bitmap> createBitmap(int width, int height) {
-    Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-    return CloseableReference.of(bitmap, mBitmapResourceReleaser);
-  }
+    /**
+     * Creates a bitmap of the specified width and height.
+     *
+     * @param width  the width of the bitmap
+     * @param height the height of the bitmap
+     * @return a reference to the bitmap
+     * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
+     */
+    CloseableReference<Bitmap> createBitmap(int width, int height) {
+        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+        return CloseableReference.of(bitmap, mBitmapResourceReleaser);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/PlatformBitmapFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/PlatformBitmapFactory.java
index 91551154e..c4437acf5 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/PlatformBitmapFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/bitmaps/PlatformBitmapFactory.java
@@ -23,89 +23,89 @@
  */
 public class PlatformBitmapFactory {
 
-  private final GingerbreadBitmapFactory mGingerbreadBitmapFactory;
-  private final DalvikBitmapFactory mDalvikBitmapFactory;
-  private final ArtBitmapFactory mArtBitmapFactory;
+    private final GingerbreadBitmapFactory mGingerbreadBitmapFactory;
+    private final DalvikBitmapFactory mDalvikBitmapFactory;
+    private final ArtBitmapFactory mArtBitmapFactory;
 
-  public PlatformBitmapFactory(
-      GingerbreadBitmapFactory gingerbreadBitmapFactory,
-      DalvikBitmapFactory dalvikBitmapFactory,
-      ArtBitmapFactory artBitmapFactory) {
-    mGingerbreadBitmapFactory = gingerbreadBitmapFactory;
-    mDalvikBitmapFactory = dalvikBitmapFactory;
-    mArtBitmapFactory = artBitmapFactory;
-  }
+    public PlatformBitmapFactory(
+            GingerbreadBitmapFactory gingerbreadBitmapFactory,
+            DalvikBitmapFactory dalvikBitmapFactory,
+            ArtBitmapFactory artBitmapFactory) {
+        mGingerbreadBitmapFactory = gingerbreadBitmapFactory;
+        mDalvikBitmapFactory = dalvikBitmapFactory;
+        mArtBitmapFactory = artBitmapFactory;
+    }
 
-  /**
-   * Creates a bitmap of the specified width and height.
-   *
-   * @param width the width of the bitmap
-   * @param height the height of the bitmap
-   * @return a reference to the bitmap
-   * @throws TooManyBitmapsException if the pool is full
-   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
-   */
-  @SuppressLint("NewApi")
-  public CloseableReference<Bitmap> createBitmap(int width, int height) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-      return mArtBitmapFactory.createBitmap(width, height);
-    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-      return mDalvikBitmapFactory.createBitmap((short) width, (short) height);
-    } else {
-      return mGingerbreadBitmapFactory.createBitmap(width, height);
+    /**
+     * Creates a bitmap of the specified width and height.
+     *
+     * @param width  the width of the bitmap
+     * @param height the height of the bitmap
+     * @return a reference to the bitmap
+     * @throws TooManyBitmapsException    if the pool is full
+     * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
+     */
+    @SuppressLint("NewApi")
+    public CloseableReference<Bitmap> createBitmap(int width, int height) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            return mArtBitmapFactory.createBitmap(width, height);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            return mDalvikBitmapFactory.createBitmap((short) width, (short) height);
+        } else {
+            return mGingerbreadBitmapFactory.createBitmap(width, height);
+        }
     }
-  }
 
-  /**
-   * Associates bitmaps with the bitmap counter.
-   *
-   * <p>If this method throws TooManyBitmapsException, the code will have called
-   * {@link Bitmap#recycle} on the bitmaps.</p>
-   *
-   * @param bitmaps the bitmaps to associate
-   * @return the references to the bitmaps that are now tied to the bitmap pool
-   * @throws TooManyBitmapsException if the pool is full
-   */
-  public synchronized List<CloseableReference<Bitmap>> associateBitmapsWithBitmapCounter(
-      final List<Bitmap> bitmaps) {
-    // Refactoring note, this code path always used ICS pool. Should this be a no-op on Lollipop?
-    return mDalvikBitmapFactory.associateBitmapsWithBitmapCounter(bitmaps);
-  }
+    /**
+     * Associates bitmaps with the bitmap counter.
+     * <p>
+     * <p>If this method throws TooManyBitmapsException, the code will have called
+     * {@link Bitmap#recycle} on the bitmaps.</p>
+     *
+     * @param bitmaps the bitmaps to associate
+     * @return the references to the bitmaps that are now tied to the bitmap pool
+     * @throws TooManyBitmapsException if the pool is full
+     */
+    public synchronized List<CloseableReference<Bitmap>> associateBitmapsWithBitmapCounter(
+            final List<Bitmap> bitmaps) {
+        // Refactoring note, this code path always used ICS pool. Should this be a no-op on Lollipop?
+        return mDalvikBitmapFactory.associateBitmapsWithBitmapCounter(bitmaps);
+    }
 
-  /**
-   * Creates a bitmap from encoded bytes. Supports JPEG but callers should use
-   * {@link #decodeJPEGFromPooledByteBuffer} for partial JPEGs.
-   *
-   * @param pooledByteBufferRef the reference to the encoded bytes
-   * @return the bitmap
-   * @throws TooManyBitmapsException if the pool is full
-   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
-   */
-  public CloseableReference<Bitmap> decodeFromPooledByteBuffer(
-      final CloseableReference<PooledByteBuffer> pooledByteBufferRef) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-      return mArtBitmapFactory.decodeFromPooledByteBuffer(pooledByteBufferRef);
-    } else {
-      return mDalvikBitmapFactory.decodeFromPooledByteBuffer(pooledByteBufferRef);
+    /**
+     * Creates a bitmap from encoded bytes. Supports JPEG but callers should use
+     * {@link #decodeJPEGFromPooledByteBuffer} for partial JPEGs.
+     *
+     * @param pooledByteBufferRef the reference to the encoded bytes
+     * @return the bitmap
+     * @throws TooManyBitmapsException    if the pool is full
+     * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
+     */
+    public CloseableReference<Bitmap> decodeFromPooledByteBuffer(
+            final CloseableReference<PooledByteBuffer> pooledByteBufferRef) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            return mArtBitmapFactory.decodeFromPooledByteBuffer(pooledByteBufferRef);
+        } else {
+            return mDalvikBitmapFactory.decodeFromPooledByteBuffer(pooledByteBufferRef);
+        }
     }
-  }
 
-  /**
-   * Creates a bitmap from encoded JPEG bytes. Supports a partial JPEG image.
-   *
-   * @param pooledByteBufferRef the reference to the encoded bytes
-   * @param length the number of encoded bytes in the buffer
-   * @return the bitmap
-   * @throws TooManyBitmapsException if the pool is full
-   * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
-   */
-  public CloseableReference<Bitmap> decodeJPEGFromPooledByteBuffer(
-      CloseableReference<PooledByteBuffer> pooledByteBufferRef,
-      int length) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-      return mArtBitmapFactory.decodeJPEGFromPooledByteBuffer(pooledByteBufferRef, length);
-    } else {
-      return mDalvikBitmapFactory.decodeJPEGFromPooledByteBuffer(pooledByteBufferRef, length);
+    /**
+     * Creates a bitmap from encoded JPEG bytes. Supports a partial JPEG image.
+     *
+     * @param pooledByteBufferRef the reference to the encoded bytes
+     * @param length              the number of encoded bytes in the buffer
+     * @return the bitmap
+     * @throws TooManyBitmapsException    if the pool is full
+     * @throws java.lang.OutOfMemoryError if the Bitmap cannot be allocated
+     */
+    public CloseableReference<Bitmap> decodeJPEGFromPooledByteBuffer(
+            CloseableReference<PooledByteBuffer> pooledByteBufferRef,
+            int length) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            return mArtBitmapFactory.decodeJPEGFromPooledByteBuffer(pooledByteBufferRef, length);
+        } else {
+            return mDalvikBitmapFactory.decodeJPEGFromPooledByteBuffer(pooledByteBufferRef, length);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapCountingMemoryCacheFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapCountingMemoryCacheFactory.java
index 6b78601bc..e0f5cab09 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapCountingMemoryCacheFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapCountingMemoryCacheFactory.java
@@ -15,25 +15,25 @@
 import com.facebook.imagepipeline.image.CloseableImage;
 
 public class BitmapCountingMemoryCacheFactory {
-  public static CountingMemoryCache<CacheKey, CloseableImage> get(
-      Supplier<MemoryCacheParams> bitmapMemoryCacheParamsSupplier,
-      MemoryTrimmableRegistry memoryTrimmableRegistry) {
+    public static CountingMemoryCache<CacheKey, CloseableImage> get(
+            Supplier<MemoryCacheParams> bitmapMemoryCacheParamsSupplier,
+            MemoryTrimmableRegistry memoryTrimmableRegistry) {
 
-    ValueDescriptor<CloseableImage> valueDescriptor =
-        new ValueDescriptor<CloseableImage>() {
-          @Override
-          public int getSizeInBytes(CloseableImage value) {
-            return value.getSizeInBytes();
-          }
-        };
+        ValueDescriptor<CloseableImage> valueDescriptor =
+                new ValueDescriptor<CloseableImage>() {
+                    @Override
+                    public int getSizeInBytes(CloseableImage value) {
+                        return value.getSizeInBytes();
+                    }
+                };
 
-    CountingMemoryCache.CacheTrimStrategy trimStrategy = new BitmapMemoryCacheTrimStrategy();
+        CountingMemoryCache.CacheTrimStrategy trimStrategy = new BitmapMemoryCacheTrimStrategy();
 
-    CountingMemoryCache<CacheKey, CloseableImage> countingCache =
-        new CountingMemoryCache<>(valueDescriptor, trimStrategy, bitmapMemoryCacheParamsSupplier);
+        CountingMemoryCache<CacheKey, CloseableImage> countingCache =
+                new CountingMemoryCache<>(valueDescriptor, trimStrategy, bitmapMemoryCacheParamsSupplier);
 
-     memoryTrimmableRegistry.registerMemoryTrimmable(countingCache);
+        memoryTrimmableRegistry.registerMemoryTrimmable(countingCache);
 
-    return countingCache;
-  }
+        return countingCache;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheFactory.java
index e6118eaec..dea28a2c5 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheFactory.java
@@ -14,29 +14,29 @@
 
 public class BitmapMemoryCacheFactory {
 
-  public static MemoryCache<CacheKey, CloseableImage> get(
-    final CountingMemoryCache<CacheKey, CloseableImage> bitmapCountingMemoryCache,
-    final ImageCacheStatsTracker imageCacheStatsTracker) {
-
-    imageCacheStatsTracker.registerBitmapMemoryCache(bitmapCountingMemoryCache);
-
-    MemoryCacheTracker memoryCacheTracker = new MemoryCacheTracker() {
-      @Override
-      public void onCacheHit() {
-        imageCacheStatsTracker.onBitmapCacheHit();
-      }
-
-      @Override
-      public void onCacheMiss() {
-        imageCacheStatsTracker.onBitmapCacheMiss();
-      }
-
-      @Override
-      public void onCachePut() {
-        imageCacheStatsTracker.onBitmapCachePut();
-      }
-    };
-
-    return new InstrumentedMemoryCache<>(bitmapCountingMemoryCache, memoryCacheTracker);
-  }
+    public static MemoryCache<CacheKey, CloseableImage> get(
+            final CountingMemoryCache<CacheKey, CloseableImage> bitmapCountingMemoryCache,
+            final ImageCacheStatsTracker imageCacheStatsTracker) {
+
+        imageCacheStatsTracker.registerBitmapMemoryCache(bitmapCountingMemoryCache);
+
+        MemoryCacheTracker memoryCacheTracker = new MemoryCacheTracker() {
+            @Override
+            public void onCacheHit() {
+                imageCacheStatsTracker.onBitmapCacheHit();
+            }
+
+            @Override
+            public void onCacheMiss() {
+                imageCacheStatsTracker.onBitmapCacheMiss();
+            }
+
+            @Override
+            public void onCachePut() {
+                imageCacheStatsTracker.onBitmapCachePut();
+            }
+        };
+
+        return new InstrumentedMemoryCache<>(bitmapCountingMemoryCache, memoryCacheTracker);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheKey.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheKey.java
index 0629eb48c..79e164b03 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheKey.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheKey.java
@@ -26,60 +26,62 @@
  * Cache key for BitmapMemoryCache
  */
 public class BitmapMemoryCacheKey implements CacheKey {
-  private final String mSourceString;
-  private final @Nullable ResizeOptions mResizeOptions;
-  private final boolean mAutoRotated;
-  private final ImageDecodeOptions mImageDecodeOptions;
-  private final int mHash;
+    private final String mSourceString;
+    private final
+    @Nullable
+    ResizeOptions mResizeOptions;
+    private final boolean mAutoRotated;
+    private final ImageDecodeOptions mImageDecodeOptions;
+    private final int mHash;
 
-  public BitmapMemoryCacheKey(
-      String sourceString,
-      @Nullable ResizeOptions resizeOptions,
-      boolean autoRotated,
-      ImageDecodeOptions imageDecodeOptions) {
-    mSourceString = Preconditions.checkNotNull(sourceString);
-    mResizeOptions = resizeOptions;
-    mAutoRotated = autoRotated;
-    mImageDecodeOptions = imageDecodeOptions;
-    mHash = HashCodeUtil.hashCode(
-        sourceString.hashCode(),
-        (resizeOptions != null) ? resizeOptions.hashCode() : 0,
-        autoRotated ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode(),
-        mImageDecodeOptions);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (!(o instanceof BitmapMemoryCacheKey)) {
-      return false;
+    public BitmapMemoryCacheKey(
+            String sourceString,
+            @Nullable ResizeOptions resizeOptions,
+            boolean autoRotated,
+            ImageDecodeOptions imageDecodeOptions) {
+        mSourceString = Preconditions.checkNotNull(sourceString);
+        mResizeOptions = resizeOptions;
+        mAutoRotated = autoRotated;
+        mImageDecodeOptions = imageDecodeOptions;
+        mHash = HashCodeUtil.hashCode(
+                sourceString.hashCode(),
+                (resizeOptions != null) ? resizeOptions.hashCode() : 0,
+                autoRotated ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode(),
+                mImageDecodeOptions);
     }
 
-    BitmapMemoryCacheKey otherKey = (BitmapMemoryCacheKey) o;
-    return mHash == otherKey.mHash &&
-        mSourceString.equals(otherKey.mSourceString) &&
-        Objects.equal(this.mResizeOptions, otherKey.mResizeOptions) &&
-        mAutoRotated == otherKey.mAutoRotated &&
-        Objects.equal(mImageDecodeOptions, otherKey.mImageDecodeOptions);
-  }
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof BitmapMemoryCacheKey)) {
+            return false;
+        }
+
+        BitmapMemoryCacheKey otherKey = (BitmapMemoryCacheKey) o;
+        return mHash == otherKey.mHash &&
+                mSourceString.equals(otherKey.mSourceString) &&
+                Objects.equal(this.mResizeOptions, otherKey.mResizeOptions) &&
+                mAutoRotated == otherKey.mAutoRotated &&
+                Objects.equal(mImageDecodeOptions, otherKey.mImageDecodeOptions);
+    }
 
-  @Override
-  public int hashCode() {
-    return mHash;
-  }
+    @Override
+    public int hashCode() {
+        return mHash;
+    }
 
-  public String getSourceUriString() {
-    return mSourceString;
-  }
+    public String getSourceUriString() {
+        return mSourceString;
+    }
 
-  @Override
-  public String toString() {
-    return String.format(
-        (Locale) null,
-        "%s_%s_%s_%s_%d",
-        mSourceString,
-        mResizeOptions,
-        Boolean.toString(mAutoRotated),
-        mImageDecodeOptions,
-        mHash);
-  }
+    @Override
+    public String toString() {
+        return String.format(
+                (Locale) null,
+                "%s_%s_%s_%s_%d",
+                mSourceString,
+                mResizeOptions,
+                Boolean.toString(mAutoRotated),
+                mImageDecodeOptions,
+                mHash);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheTrimStrategy.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheTrimStrategy.java
index 22e202ce6..08da57fcf 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheTrimStrategy.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BitmapMemoryCacheTrimStrategy.java
@@ -16,33 +16,33 @@
 
 /**
  * CountingMemoryCache eviction strategy appropriate for bitmap caches.
- *
+ * <p>
  * <p>If run on KitKat or below, then this TrimStrategy behaves exactly as
  * NativeMemoryCacheTrimStrategy. If run on Lollipop, then BitmapMemoryCacheTrimStrategy will trim
  * cache in one additional case: when OnCloseToDalvikHeapLimit trim type is received, cache's
  * eviction queue will be trimmed according to OnCloseToDalvikHeapLimit's suggested trim ratio.
  */
 public class BitmapMemoryCacheTrimStrategy implements CountingMemoryCache.CacheTrimStrategy {
-  private static final String TAG = "BitmapMemoryCacheTrimStrategy";
+    private static final String TAG = "BitmapMemoryCacheTrimStrategy";
 
-  @Override
-  public double getTrimRatio(MemoryTrimType trimType) {
-    switch (trimType) {
-      case OnCloseToDalvikHeapLimit:
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-          return MemoryTrimType.OnCloseToDalvikHeapLimit.getSuggestedTrimRatio();
-        } else {
-          // On pre-lollipop versions we keep bitmaps on the native heap, so no need to trim here
-          // as it wouldn't help Dalvik heap anyway.
-          return 0;
+    @Override
+    public double getTrimRatio(MemoryTrimType trimType) {
+        switch (trimType) {
+            case OnCloseToDalvikHeapLimit:
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                    return MemoryTrimType.OnCloseToDalvikHeapLimit.getSuggestedTrimRatio();
+                } else {
+                    // On pre-lollipop versions we keep bitmaps on the native heap, so no need to trim here
+                    // as it wouldn't help Dalvik heap anyway.
+                    return 0;
+                }
+            case OnAppBackgrounded:
+            case OnSystemLowMemoryWhileAppInForeground:
+            case OnSystemLowMemoryWhileAppInBackground:
+                return 1;
+            default:
+                FLog.wtf(TAG, "unknown trim type: %s", trimType);
+                return 0;
         }
-      case OnAppBackgrounded:
-      case OnSystemLowMemoryWhileAppInForeground:
-      case OnSystemLowMemoryWhileAppInBackground:
-        return 1;
-      default:
-        FLog.wtf(TAG, "unknown trim type: %s", trimType);
-        return 0;
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
index fe5f16812..45e2d9e38 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
@@ -36,204 +36,206 @@
  * read/writes.
  */
 public class BufferedDiskCache {
-  private static final Class<?> TAG = BufferedDiskCache.class;
-
-  private final FileCache mFileCache;
-  private final PooledByteBufferFactory mPooledByteBufferFactory;
-  private final PooledByteStreams mPooledByteStreams;
-  private final Executor mReadExecutor;
-  private final Executor mWriteExecutor;
-  private final StagingArea mStagingArea;
-  private final ImageCacheStatsTracker mImageCacheStatsTracker;
-
-  public BufferedDiskCache(
-      FileCache fileCache,
-      PooledByteBufferFactory pooledByteBufferFactory,
-      PooledByteStreams pooledByteStreams,
-      Executor readExecutor,
-      Executor writeExecutor,
-      ImageCacheStatsTracker imageCacheStatsTracker) {
-    mFileCache = fileCache;
-    mPooledByteBufferFactory = pooledByteBufferFactory;
-    mPooledByteStreams = pooledByteStreams;
-    mReadExecutor = readExecutor;
-    mWriteExecutor = writeExecutor;
-    mImageCacheStatsTracker = imageCacheStatsTracker;
-    mStagingArea = StagingArea.getInstance();
-  }
-
-  /**
-   * Performs key-value look up in disk cache. If value is not found in disk cache staging area
-   * then disk cache read is scheduled on background thread. Any error manifests itself as
-   * cache miss, i.e. the returned future resolves to null.
-   * @param key
-   * @return ListenableFuture that resolves to cached element or null if one cannot be retrieved;
-   *   returned future never rethrows any exception
-   */
-  public Task<CloseableReference<PooledByteBuffer>> get(
-      final CacheKey key,
-      final AtomicBoolean isCancelled) {
-    Preconditions.checkNotNull(key);
-    Preconditions.checkNotNull(isCancelled);
-
-    final CloseableReference<PooledByteBuffer> pinnedImage = mStagingArea.get(key);
-    if (pinnedImage != null) {
-      FLog.v(TAG, "Found image for %s in staging area", key.toString());
-      mImageCacheStatsTracker.onStagingAreaHit();
-      return Task.forResult(pinnedImage);
+    private static final Class<?> TAG = BufferedDiskCache.class;
+
+    private final FileCache mFileCache;
+    private final PooledByteBufferFactory mPooledByteBufferFactory;
+    private final PooledByteStreams mPooledByteStreams;
+    private final Executor mReadExecutor;
+    private final Executor mWriteExecutor;
+    private final StagingArea mStagingArea;
+    private final ImageCacheStatsTracker mImageCacheStatsTracker;
+
+    public BufferedDiskCache(
+            FileCache fileCache,
+            PooledByteBufferFactory pooledByteBufferFactory,
+            PooledByteStreams pooledByteStreams,
+            Executor readExecutor,
+            Executor writeExecutor,
+            ImageCacheStatsTracker imageCacheStatsTracker) {
+        mFileCache = fileCache;
+        mPooledByteBufferFactory = pooledByteBufferFactory;
+        mPooledByteStreams = pooledByteStreams;
+        mReadExecutor = readExecutor;
+        mWriteExecutor = writeExecutor;
+        mImageCacheStatsTracker = imageCacheStatsTracker;
+        mStagingArea = StagingArea.getInstance();
     }
 
-    try {
-      return Task.call(
-          new Callable<CloseableReference<PooledByteBuffer>>() {
-            @Override
-            public CloseableReference<PooledByteBuffer> call()
-                throws Exception {
-              if (isCancelled.get()) {
-                throw new CancellationException();
-              }
-              CloseableReference<PooledByteBuffer> result = mStagingArea.get(key);
-              if (result != null) {
-                FLog.v(TAG, "Found image for %s in staging area", key.toString());
-                mImageCacheStatsTracker.onStagingAreaHit();
-              } else {
-                FLog.v(TAG, "Did not find image for %s in staging area", key.toString());
-                mImageCacheStatsTracker.onStagingAreaMiss();
-
-                try {
-                  final PooledByteBuffer buffer = readFromDiskCache(key);
-                  result = CloseableReference.of(buffer);
-                } catch (Exception exception) {
-                  return null;
-                }
-              }
-
-              if (Thread.interrupted()) {
-                FLog.v(TAG, "Host thread was interrupted, decreasing reference count");
-                if (result != null) {
-                  result.close();
-                }
-                throw new InterruptedException();
-              } else {
-                return result;
-              }
-            }
-          },
-          mReadExecutor);
-    } catch (Exception exception) {
-      // Log failure
-      // TODO: 3697790
-      FLog.w(
-          TAG,
-          exception,
-          "Failed to schedule disk-cache read for %s",
-          key.toString());
-      return Task.forError(exception);
-    }
-  }
-
-  /**
-   * Associates byteBuffer with given key in disk cache. Disk write is performed on background
-   * thread, so the caller of this method is not blocked
-   */
-  public void put(
-      final CacheKey key,
-      CloseableReference<PooledByteBuffer> byteBuffer) {
-    Preconditions.checkNotNull(key);
-    Preconditions.checkArgument(CloseableReference.isValid(byteBuffer));
-
-    // Store byteBuffer in staging area
-    mStagingArea.put(key, byteBuffer);
-
-    // Write to disk cache. This will be executed on background thread, so increment the ref count.
-    // When this write completes (with success/failure), then we will bump down the ref count
-    // again.
-    final CloseableReference<PooledByteBuffer> finalByteBuffer = byteBuffer.clone();
-    try {
-      mWriteExecutor.execute(
-          new Runnable() {
-            @Override
-            public void run() {
-              try {
-                writeToDiskCache(key, finalByteBuffer.get());
-              } finally {
-                mStagingArea.remove(key, finalByteBuffer);
-                finalByteBuffer.close();
-              }
-            }
-          });
-    } catch (Exception exception) {
-      // We failed to enqueue cache write. Log failure and decrement ref count
-      // TODO: 3697790
-      FLog.w(
-          TAG,
-          exception,
-          "Failed to schedule disk-cache write for %s",
-          key.toString());
-      mStagingArea.remove(key, byteBuffer);
-      finalByteBuffer.close();
+    /**
+     * Performs key-value look up in disk cache. If value is not found in disk cache staging area
+     * then disk cache read is scheduled on background thread. Any error manifests itself as
+     * cache miss, i.e. the returned future resolves to null.
+     *
+     * @param key
+     * @return ListenableFuture that resolves to cached element or null if one cannot be retrieved;
+     * returned future never rethrows any exception
+     */
+    public Task<CloseableReference<PooledByteBuffer>> get(
+            final CacheKey key,
+            final AtomicBoolean isCancelled) {
+        Preconditions.checkNotNull(key);
+        Preconditions.checkNotNull(isCancelled);
+
+        final CloseableReference<PooledByteBuffer> pinnedImage = mStagingArea.get(key);
+        if (pinnedImage != null) {
+            FLog.v(TAG, "Found image for %s in staging area", key.toString());
+            mImageCacheStatsTracker.onStagingAreaHit();
+            return Task.forResult(pinnedImage);
+        }
+
+        try {
+            return Task.call(
+                    new Callable<CloseableReference<PooledByteBuffer>>() {
+                        @Override
+                        public CloseableReference<PooledByteBuffer> call()
+                                throws Exception {
+                            if (isCancelled.get()) {
+                                throw new CancellationException();
+                            }
+                            CloseableReference<PooledByteBuffer> result = mStagingArea.get(key);
+                            if (result != null) {
+                                FLog.v(TAG, "Found image for %s in staging area", key.toString());
+                                mImageCacheStatsTracker.onStagingAreaHit();
+                            } else {
+                                FLog.v(TAG, "Did not find image for %s in staging area", key.toString());
+                                mImageCacheStatsTracker.onStagingAreaMiss();
+
+                                try {
+                                    final PooledByteBuffer buffer = readFromDiskCache(key);
+                                    result = CloseableReference.of(buffer);
+                                } catch (Exception exception) {
+                                    return null;
+                                }
+                            }
+
+                            if (Thread.interrupted()) {
+                                FLog.v(TAG, "Host thread was interrupted, decreasing reference count");
+                                if (result != null) {
+                                    result.close();
+                                }
+                                throw new InterruptedException();
+                            } else {
+                                return result;
+                            }
+                        }
+                    },
+                    mReadExecutor);
+        } catch (Exception exception) {
+            // Log failure
+            // TODO: 3697790
+            FLog.w(
+                    TAG,
+                    exception,
+                    "Failed to schedule disk-cache read for %s",
+                    key.toString());
+            return Task.forError(exception);
+        }
     }
-  }
-
-  /**
-   * Performs disk cache read. In case of any exception null is returned.
-   */
-  private PooledByteBuffer readFromDiskCache(final CacheKey key) throws IOException {
-    try {
-      FLog.v(TAG, "Disk cache read for %s", key.toString());
-
-      final BinaryResource diskCacheResource = mFileCache.getResource(key);
-      if (diskCacheResource == null) {
-        FLog.v(TAG, "Disk cache miss for %s", key.toString());
-        mImageCacheStatsTracker.onDiskCacheMiss();
-        return null;
-      } else {
-        FLog.v(TAG, "Found entry in disk cache for %s", key.toString());
-        mImageCacheStatsTracker.onDiskCacheHit();
-      }
-
-      PooledByteBuffer byteBuffer;
-      final InputStream is = diskCacheResource.openStream();
-      try {
-        byteBuffer = mPooledByteBufferFactory.newByteBuffer(is, (int) diskCacheResource.size());
-      } finally {
-        is.close();
-      }
-
-      FLog.v(TAG, "Successful read from disk cache for %s", key.toString());
-      return byteBuffer;
-    } catch (IOException ioe) {
-      // TODO: 3697790 log failures
-      // TODO: 5258772 - uncomment line below
-      // mFileCache.remove(key);
-      FLog.w(TAG, ioe, "Exception reading from cache for %s", key.toString());
-      mImageCacheStatsTracker.onDiskCacheGetFail();
-      throw ioe;
+
+    /**
+     * Associates byteBuffer with given key in disk cache. Disk write is performed on background
+     * thread, so the caller of this method is not blocked
+     */
+    public void put(
+            final CacheKey key,
+            CloseableReference<PooledByteBuffer> byteBuffer) {
+        Preconditions.checkNotNull(key);
+        Preconditions.checkArgument(CloseableReference.isValid(byteBuffer));
+
+        // Store byteBuffer in staging area
+        mStagingArea.put(key, byteBuffer);
+
+        // Write to disk cache. This will be executed on background thread, so increment the ref count.
+        // When this write completes (with success/failure), then we will bump down the ref count
+        // again.
+        final CloseableReference<PooledByteBuffer> finalByteBuffer = byteBuffer.clone();
+        try {
+            mWriteExecutor.execute(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            try {
+                                writeToDiskCache(key, finalByteBuffer.get());
+                            } finally {
+                                mStagingArea.remove(key, finalByteBuffer);
+                                finalByteBuffer.close();
+                            }
+                        }
+                    });
+        } catch (Exception exception) {
+            // We failed to enqueue cache write. Log failure and decrement ref count
+            // TODO: 3697790
+            FLog.w(
+                    TAG,
+                    exception,
+                    "Failed to schedule disk-cache write for %s",
+                    key.toString());
+            mStagingArea.remove(key, byteBuffer);
+            finalByteBuffer.close();
+        }
     }
-  }
-
-  /**
-   * Writes to disk cache
-   * @throws IOException
-   */
-  private void writeToDiskCache(
-      final CacheKey key,
-      final PooledByteBuffer buffer) {
-    FLog.v(TAG, "About to write to disk-cache for key %s", key.toString());
-    try {
-      mFileCache.insert(
-          key, new WriterCallback() {
-            @Override
-            public void write(OutputStream os) throws IOException {
-              mPooledByteStreams.copy(new PooledByteBufferInputStream(buffer), os);
+
+    /**
+     * Performs disk cache read. In case of any exception null is returned.
+     */
+    private PooledByteBuffer readFromDiskCache(final CacheKey key) throws IOException {
+        try {
+            FLog.v(TAG, "Disk cache read for %s", key.toString());
+
+            final BinaryResource diskCacheResource = mFileCache.getResource(key);
+            if (diskCacheResource == null) {
+                FLog.v(TAG, "Disk cache miss for %s", key.toString());
+                mImageCacheStatsTracker.onDiskCacheMiss();
+                return null;
+            } else {
+                FLog.v(TAG, "Found entry in disk cache for %s", key.toString());
+                mImageCacheStatsTracker.onDiskCacheHit();
             }
-          }
-      );
-      FLog.v(TAG, "Successful disk-cache write for key %s", key.toString());
-    } catch (IOException ioe) {
-      // Log failure
-      // TODO: 3697790
-      FLog.w(TAG, ioe, "Failed to write to disk-cache for key %s", key.toString());
+
+            PooledByteBuffer byteBuffer;
+            final InputStream is = diskCacheResource.openStream();
+            try {
+                byteBuffer = mPooledByteBufferFactory.newByteBuffer(is, (int) diskCacheResource.size());
+            } finally {
+                is.close();
+            }
+
+            FLog.v(TAG, "Successful read from disk cache for %s", key.toString());
+            return byteBuffer;
+        } catch (IOException ioe) {
+            // TODO: 3697790 log failures
+            // TODO: 5258772 - uncomment line below
+            // mFileCache.remove(key);
+            FLog.w(TAG, ioe, "Exception reading from cache for %s", key.toString());
+            mImageCacheStatsTracker.onDiskCacheGetFail();
+            throw ioe;
+        }
+    }
+
+    /**
+     * Writes to disk cache
+     *
+     * @throws IOException
+     */
+    private void writeToDiskCache(
+            final CacheKey key,
+            final PooledByteBuffer buffer) {
+        FLog.v(TAG, "About to write to disk-cache for key %s", key.toString());
+        try {
+            mFileCache.insert(
+                    key, new WriterCallback() {
+                        @Override
+                        public void write(OutputStream os) throws IOException {
+                            mPooledByteStreams.copy(new PooledByteBufferInputStream(buffer), os);
+                        }
+                    }
+            );
+            FLog.v(TAG, "Successful disk-cache write for key %s", key.toString());
+        } catch (IOException ioe) {
+            // Log failure
+            // TODO: 3697790
+            FLog.w(TAG, ioe, "Failed to write to disk-cache for key %s", key.toString());
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CacheKeyFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CacheKeyFactory.java
index 8e4be0ffc..c1af614e7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CacheKeyFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CacheKeyFactory.java
@@ -19,18 +19,18 @@
  */
 public interface CacheKeyFactory {
 
-  /**
-   * @return {@link CacheKey} for doing bitmap cache lookups in the pipeline.
-   */
-  public CacheKey getBitmapCacheKey(ImageRequest request);
+    /**
+     * @return {@link CacheKey} for doing bitmap cache lookups in the pipeline.
+     */
+    public CacheKey getBitmapCacheKey(ImageRequest request);
 
-  /**
-   * @return {@link CacheKey} for doing encoded image lookups in the pipeline.
-   */
-  public CacheKey getEncodedCacheKey(ImageRequest request);
+    /**
+     * @return {@link CacheKey} for doing encoded image lookups in the pipeline.
+     */
+    public CacheKey getEncodedCacheKey(ImageRequest request);
 
-  /**
-   * @return a {@link String} that unambiguously indicates the source of the image.
-   */
-  public Uri getCacheKeySourceUri(Uri sourceUri);
+    /**
+     * @return a {@link String} that unambiguously indicates the source of the image.
+     */
+    public Uri getCacheKeySourceUri(Uri sourceUri);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingLruMap.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingLruMap.java
index fbe36675d..ef96b9aa0 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingLruMap.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingLruMap.java
@@ -26,110 +26,130 @@
 @ThreadSafe
 public class CountingLruMap<K, V> {
 
-  private final ValueDescriptor<V> mValueDescriptor;
-
-  @GuardedBy("this")
-  private final LinkedHashMap<K, V> mMap = new LinkedHashMap<>();
-  @GuardedBy("this")
-  private int mSizeInBytes = 0;
-
-  public CountingLruMap(ValueDescriptor<V> valueDescriptor) {
-    mValueDescriptor = valueDescriptor;
-  }
-
-  @VisibleForTesting
-  synchronized ArrayList<K> getKeys() {
-    return new ArrayList<>(mMap.keySet());
-  }
-
-  @VisibleForTesting
-  synchronized ArrayList<V> getValues() {
-    return new ArrayList<>(mMap.values());
-  }
-
-  /** Gets the count of the elements in the map. */
-  public synchronized int getCount() {
-    return mMap.size();
-  }
-
-  /** Gets the total size in bytes of the elements in the map. */
-  public synchronized int getSizeInBytes() {
-    return mSizeInBytes;
-  }
-
-  /** Gets the key of the first element in the map. */
-  @Nullable
-  public synchronized K getFirstKey() {
-    return mMap.isEmpty() ? null : mMap.keySet().iterator().next();
-  }
-
-  /** Gets the all matching elements. */
-  public synchronized ArrayList<LinkedHashMap.Entry<K, V>> getMatchingEntries(
-      @Nullable Predicate<K> predicate) {
-    ArrayList<LinkedHashMap.Entry<K, V>> matchingEntries = new ArrayList<>();
-    for (LinkedHashMap.Entry<K, V> entry : mMap.entrySet()) {
-      if (predicate == null || predicate.apply(entry.getKey())) {
-        matchingEntries.add(entry);
-      }
+    private final ValueDescriptor<V> mValueDescriptor;
+
+    @GuardedBy("this")
+    private final LinkedHashMap<K, V> mMap = new LinkedHashMap<>();
+    @GuardedBy("this")
+    private int mSizeInBytes = 0;
+
+    public CountingLruMap(ValueDescriptor<V> valueDescriptor) {
+        mValueDescriptor = valueDescriptor;
+    }
+
+    @VisibleForTesting
+    synchronized ArrayList<K> getKeys() {
+        return new ArrayList<>(mMap.keySet());
+    }
+
+    @VisibleForTesting
+    synchronized ArrayList<V> getValues() {
+        return new ArrayList<>(mMap.values());
+    }
+
+    /**
+     * Gets the count of the elements in the map.
+     */
+    public synchronized int getCount() {
+        return mMap.size();
+    }
+
+    /**
+     * Gets the total size in bytes of the elements in the map.
+     */
+    public synchronized int getSizeInBytes() {
+        return mSizeInBytes;
+    }
+
+    /**
+     * Gets the key of the first element in the map.
+     */
+    @Nullable
+    public synchronized K getFirstKey() {
+        return mMap.isEmpty() ? null : mMap.keySet().iterator().next();
+    }
+
+    /**
+     * Gets the all matching elements.
+     */
+    public synchronized ArrayList<LinkedHashMap.Entry<K, V>> getMatchingEntries(
+            @Nullable Predicate<K> predicate) {
+        ArrayList<LinkedHashMap.Entry<K, V>> matchingEntries = new ArrayList<>();
+        for (LinkedHashMap.Entry<K, V> entry : mMap.entrySet()) {
+            if (predicate == null || predicate.apply(entry.getKey())) {
+                matchingEntries.add(entry);
+            }
+        }
+        return matchingEntries;
     }
-    return matchingEntries;
-  }
-
-  /** Returns whether the map contains an element with the given key.  */
-  public synchronized boolean contains(K key) {
-    return mMap.containsKey(key);
-  }
-
-  /** Gets the element from the map. */
-  @Nullable
-  public synchronized V get(K key) {
-    return mMap.get(key);
-  }
-
-  /** Adds the element to the map, and removes the old element with the same key if any. */
-  @Nullable
-  public synchronized V put(K key, V value) {
-    // We do remove and insert instead of just replace, in order to cause a structural change
-    // to the map, as we always want the latest inserted element to be last in the queue.
-    V oldValue = mMap.remove(key);
-    mSizeInBytes -= getValueSizeInBytes(oldValue);
-    mMap.put(key, value);
-    mSizeInBytes += getValueSizeInBytes(value);
-    return oldValue;
-  }
-
-  /** Removes the element from the map. */
-  @Nullable
-  public synchronized V remove(K key) {
-      V oldValue = mMap.remove(key);
-      mSizeInBytes -= getValueSizeInBytes(oldValue);
-      return oldValue;
-  }
-
-  /** Removes all the matching elements from the map. */
-  public synchronized ArrayList<V> removeAll(@Nullable Predicate<K> predicate) {
-    ArrayList<V> oldValues = new ArrayList<>();
-    Iterator<LinkedHashMap.Entry<K, V>> iterator = mMap.entrySet().iterator();
-    while (iterator.hasNext()) {
-      LinkedHashMap.Entry<K, V> entry = iterator.next();
-      if (predicate == null || predicate.apply(entry.getKey())) {
-        oldValues.add(entry.getValue());
-        mSizeInBytes -= getValueSizeInBytes(entry.getValue());
-        iterator.remove();
-      }
+
+    /**
+     * Returns whether the map contains an element with the given key.
+     */
+    public synchronized boolean contains(K key) {
+        return mMap.containsKey(key);
+    }
+
+    /**
+     * Gets the element from the map.
+     */
+    @Nullable
+    public synchronized V get(K key) {
+        return mMap.get(key);
+    }
+
+    /**
+     * Adds the element to the map, and removes the old element with the same key if any.
+     */
+    @Nullable
+    public synchronized V put(K key, V value) {
+        // We do remove and insert instead of just replace, in order to cause a structural change
+        // to the map, as we always want the latest inserted element to be last in the queue.
+        V oldValue = mMap.remove(key);
+        mSizeInBytes -= getValueSizeInBytes(oldValue);
+        mMap.put(key, value);
+        mSizeInBytes += getValueSizeInBytes(value);
+        return oldValue;
+    }
+
+    /**
+     * Removes the element from the map.
+     */
+    @Nullable
+    public synchronized V remove(K key) {
+        V oldValue = mMap.remove(key);
+        mSizeInBytes -= getValueSizeInBytes(oldValue);
+        return oldValue;
+    }
+
+    /**
+     * Removes all the matching elements from the map.
+     */
+    public synchronized ArrayList<V> removeAll(@Nullable Predicate<K> predicate) {
+        ArrayList<V> oldValues = new ArrayList<>();
+        Iterator<LinkedHashMap.Entry<K, V>> iterator = mMap.entrySet().iterator();
+        while (iterator.hasNext()) {
+            LinkedHashMap.Entry<K, V> entry = iterator.next();
+            if (predicate == null || predicate.apply(entry.getKey())) {
+                oldValues.add(entry.getValue());
+                mSizeInBytes -= getValueSizeInBytes(entry.getValue());
+                iterator.remove();
+            }
+        }
+        return oldValues;
+    }
+
+    /**
+     * Clears the map.
+     */
+    public synchronized ArrayList<V> clear() {
+        ArrayList<V> oldValues = new ArrayList<>(mMap.values());
+        mMap.clear();
+        mSizeInBytes = 0;
+        return oldValues;
+    }
+
+    private int getValueSizeInBytes(V value) {
+        return (value == null) ? 0 : mValueDescriptor.getSizeInBytes(value);
     }
-    return oldValues;
-  }
-
-  /** Clears the map. */
-  public synchronized ArrayList<V> clear() {
-    ArrayList<V> oldValues = new ArrayList<>(mMap.values());
-    mMap.clear();
-    mSizeInBytes = 0;
-    return oldValues;
-  }
-
-  private int getValueSizeInBytes(V value) {
-    return (value == null) ? 0 : mValueDescriptor.getSizeInBytes(value);
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
index 944b049b4..90ac02a47 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCache.java
@@ -30,10 +30,10 @@
 
 /**
  * Layer of memory cache stack responsible for managing eviction of the the cached items.
- *
+ * <p>
  * <p> This layer is responsible for LRU eviction strategy and for maintaining the size boundaries
  * of the cached items.
- *
+ * <p>
  * <p> Only the exclusively owned elements, i.e. the elements not referenced by any client, can be
  * evicted.
  *
@@ -43,369 +43,405 @@
 @ThreadSafe
 public class CountingMemoryCache<K, V> implements MemoryCache<K, V>, MemoryTrimmable {
 
-  /**
-   * Interface used to specify the trimming strategy for the cache.
-   */
-  public static interface CacheTrimStrategy {
-    double getTrimRatio(MemoryTrimType trimType);
-  }
-
-  /**
-   * The internal representation of a key-value pair stored by the cache.
-   */
-  @VisibleForTesting
-  static class Entry<K, V> {
-    public final K key;
-    public final CloseableReference<V> valueRef;
-    // The number of clients that reference the value.
-    public int clientCount;
-    // Whether or not this entry is tracked by this cache. Orphans are not tracked by the cache and
-    // as soon as the last client of an orphaned entry closes their reference, the entry's copy is
-    // closed too.
-    public boolean isOrphan;
-
-    private Entry(K key, CloseableReference<V> valueRef) {
-      this.key = Preconditions.checkNotNull(key);
-      this.valueRef = Preconditions.checkNotNull(CloseableReference.cloneOrNull(valueRef));
-      this.clientCount = 0;
-      this.isOrphan = false;
+    /**
+     * Interface used to specify the trimming strategy for the cache.
+     */
+    public static interface CacheTrimStrategy {
+        double getTrimRatio(MemoryTrimType trimType);
+    }
+
+    /**
+     * The internal representation of a key-value pair stored by the cache.
+     */
+    @VisibleForTesting
+    static class Entry<K, V> {
+        public final K key;
+        public final CloseableReference<V> valueRef;
+        // The number of clients that reference the value.
+        public int clientCount;
+        // Whether or not this entry is tracked by this cache. Orphans are not tracked by the cache and
+        // as soon as the last client of an orphaned entry closes their reference, the entry's copy is
+        // closed too.
+        public boolean isOrphan;
+
+        private Entry(K key, CloseableReference<V> valueRef) {
+            this.key = Preconditions.checkNotNull(key);
+            this.valueRef = Preconditions.checkNotNull(CloseableReference.cloneOrNull(valueRef));
+            this.clientCount = 0;
+            this.isOrphan = false;
+        }
+
+        /**
+         * Creates a new entry with the usage count of 0.
+         */
+        @VisibleForTesting
+        static <K, V> Entry<K, V> of(final K key, final CloseableReference<V> valueRef) {
+            return new Entry<>(key, valueRef);
+        }
     }
 
-    /** Creates a new entry with the usage count of 0. */
+    // How often the cache checks for a new cache configuration.
+    @VisibleForTesting
+    static final long PARAMS_INTERCHECK_INTERVAL_MS = TimeUnit.MINUTES.toMillis(5);
+
+    // Contains the items that are not being used by any client and are hence viable for eviction.
+    @GuardedBy("this")
+    @VisibleForTesting
+    final CountingLruMap<K, Entry<K, V>> mExclusiveEntries;
+
+    // Contains all the cached items including the exclusively owned ones.
+    @GuardedBy("this")
     @VisibleForTesting
-    static <K, V> Entry<K, V> of(final K key, final CloseableReference<V> valueRef) {
-      return new Entry<>(key, valueRef);
+    final CountingLruMap<K, Entry<K, V>> mCachedEntries;
+
+    private final ValueDescriptor<V> mValueDescriptor;
+
+    private final CacheTrimStrategy mCacheTrimStrategy;
+
+    // Cache size constraints.
+    private final Supplier<MemoryCacheParams> mMemoryCacheParamsSupplier;
+    @GuardedBy("this")
+    protected MemoryCacheParams mMemoryCacheParams;
+    @GuardedBy("this")
+    private long mLastCacheParamsCheck;
+
+    public CountingMemoryCache(
+            ValueDescriptor<V> valueDescriptor,
+            CacheTrimStrategy cacheTrimStrategy,
+            Supplier<MemoryCacheParams> memoryCacheParamsSupplier) {
+        mValueDescriptor = valueDescriptor;
+        mExclusiveEntries = new CountingLruMap<>(wrapValueDescriptor(valueDescriptor));
+        mCachedEntries = new CountingLruMap<>(wrapValueDescriptor(valueDescriptor));
+        mCacheTrimStrategy = cacheTrimStrategy;
+        mMemoryCacheParamsSupplier = memoryCacheParamsSupplier;
+        mMemoryCacheParams = mMemoryCacheParamsSupplier.get();
+        mLastCacheParamsCheck = SystemClock.elapsedRealtime();
+    }
+
+    private ValueDescriptor<Entry<K, V>> wrapValueDescriptor(
+            final ValueDescriptor<V> evictableValueDescriptor) {
+        return new ValueDescriptor<Entry<K, V>>() {
+            @Override
+            public int getSizeInBytes(Entry<K, V> entry) {
+                return evictableValueDescriptor.getSizeInBytes(entry.valueRef.get());
+            }
+        };
+    }
+
+    /**
+     * Caches the given key-value pair.
+     * <p>
+     * <p> Important: the client should use the returned reference instead of the original one.
+     * It is the caller's responsibility to close the returned reference once not needed anymore.
+     *
+     * @return the new reference to be used, null if the value cannot be cached
+     */
+    public CloseableReference<V> cache(final K key, final CloseableReference<V> valueRef) {
+        Preconditions.checkNotNull(key);
+        Preconditions.checkNotNull(valueRef);
+
+        maybeUpdateCacheParams();
+
+        CloseableReference<V> oldRefToClose = null;
+        CloseableReference<V> clientRef = null;
+        synchronized (this) {
+            // remove the old item (if any) as it is stale now
+            mExclusiveEntries.remove(key);
+            Entry<K, V> oldEntry = mCachedEntries.remove(key);
+            if (oldEntry != null) {
+                makeOrphan(oldEntry);
+                oldRefToClose = referenceToClose(oldEntry);
+            }
+
+            if (canCacheNewValue(valueRef.get())) {
+                Entry<K, V> newEntry = Entry.of(key, valueRef);
+                mCachedEntries.put(key, newEntry);
+                clientRef = newClientReference(newEntry);
+            }
+        }
+        CloseableReference.closeSafely(oldRefToClose);
+
+        maybeEvictEntries();
+        return clientRef;
+    }
+
+    /**
+     * Checks the cache constraints to determine whether the new value can be cached or not.
+     */
+    private synchronized boolean canCacheNewValue(V value) {
+        int newValueSize = mValueDescriptor.getSizeInBytes(value);
+        return (newValueSize <= mMemoryCacheParams.maxCacheEntrySize) &&
+                (getInUseCount() + 1 <= mMemoryCacheParams.maxCacheEntries) &&
+                (getInUseSizeInBytes() + newValueSize <= mMemoryCacheParams.maxCacheSize);
+    }
+
+    /**
+     * Gets the item with the given key, or null if there is no such item.
+     * <p>
+     * <p> It is the caller's responsibility to close the returned reference once not needed anymore.
+     */
+    @Nullable
+    public CloseableReference<V> get(final K key) {
+        CloseableReference<V> clientRef = null;
+        synchronized (this) {
+            mExclusiveEntries.remove(key);
+            Entry<K, V> entry = mCachedEntries.get(key);
+            if (entry != null) {
+                clientRef = newClientReference(entry);
+            }
+        }
+        maybeUpdateCacheParams();
+        maybeEvictEntries();
+        return clientRef;
+    }
+
+    /**
+     * Creates a new reference for the client.
+     */
+    private synchronized CloseableReference<V> newClientReference(final Entry<K, V> entry) {
+        increaseClientCount(entry);
+        return CloseableReference.of(
+                entry.valueRef.get(),
+                new ResourceReleaser<V>() {
+                    @Override
+                    public void release(V unused) {
+                        releaseClientReference(entry);
+                    }
+                });
+    }
+
+    /**
+     * Called when the client closes its reference.
+     */
+    private void releaseClientReference(final Entry<K, V> entry) {
+        Preconditions.checkNotNull(entry);
+        CloseableReference<V> oldRefToClose;
+        synchronized (this) {
+            decreaseClientCount(entry);
+            maybeAddToExclusives(entry);
+            oldRefToClose = referenceToClose(entry);
+        }
+        CloseableReference.closeSafely(oldRefToClose);
+        maybeUpdateCacheParams();
+        maybeEvictEntries();
+    }
+
+    /**
+     * Adds the entry to the exclusively owned queue if it is viable for eviction.
+     */
+    private synchronized void maybeAddToExclusives(Entry<K, V> entry) {
+        if (!entry.isOrphan && entry.clientCount == 0) {
+            mExclusiveEntries.put(entry.key, entry);
+        }
     }
-  }
-
-  // How often the cache checks for a new cache configuration.
-  @VisibleForTesting
-  static final long PARAMS_INTERCHECK_INTERVAL_MS = TimeUnit.MINUTES.toMillis(5);
-
-  // Contains the items that are not being used by any client and are hence viable for eviction.
-  @GuardedBy("this")
-  @VisibleForTesting
-  final CountingLruMap<K, Entry<K, V>> mExclusiveEntries;
-
-  // Contains all the cached items including the exclusively owned ones.
-  @GuardedBy("this")
-  @VisibleForTesting
-  final CountingLruMap<K, Entry<K, V>> mCachedEntries;
-
-  private final ValueDescriptor<V> mValueDescriptor;
-
-  private final CacheTrimStrategy mCacheTrimStrategy;
-
-  // Cache size constraints.
-  private final Supplier<MemoryCacheParams> mMemoryCacheParamsSupplier;
-  @GuardedBy("this")
-  protected MemoryCacheParams mMemoryCacheParams;
-  @GuardedBy("this")
-  private long mLastCacheParamsCheck;
-
-  public CountingMemoryCache(
-      ValueDescriptor<V> valueDescriptor,
-      CacheTrimStrategy cacheTrimStrategy,
-      Supplier<MemoryCacheParams> memoryCacheParamsSupplier) {
-    mValueDescriptor = valueDescriptor;
-    mExclusiveEntries = new CountingLruMap<>(wrapValueDescriptor(valueDescriptor));
-    mCachedEntries = new CountingLruMap<>(wrapValueDescriptor(valueDescriptor));
-    mCacheTrimStrategy = cacheTrimStrategy;
-    mMemoryCacheParamsSupplier = memoryCacheParamsSupplier;
-    mMemoryCacheParams = mMemoryCacheParamsSupplier.get();
-    mLastCacheParamsCheck = SystemClock.elapsedRealtime();
-  }
-
-  private ValueDescriptor<Entry<K, V>> wrapValueDescriptor(
-      final ValueDescriptor<V> evictableValueDescriptor) {
-    return new ValueDescriptor<Entry<K,V>>() {
-      @Override
-      public int getSizeInBytes(Entry<K, V> entry) {
-        return evictableValueDescriptor.getSizeInBytes(entry.valueRef.get());
-      }
-    };
-  }
-
-  /**
-   * Caches the given key-value pair.
-   *
-   * <p> Important: the client should use the returned reference instead of the original one.
-   * It is the caller's responsibility to close the returned reference once not needed anymore.
-   *
-   * @return the new reference to be used, null if the value cannot be cached
-   */
-  public CloseableReference<V> cache(final K key, final CloseableReference<V> valueRef) {
-    Preconditions.checkNotNull(key);
-    Preconditions.checkNotNull(valueRef);
-
-    maybeUpdateCacheParams();
-
-    CloseableReference<V> oldRefToClose = null;
-    CloseableReference<V> clientRef = null;
-    synchronized (this) {
-      // remove the old item (if any) as it is stale now
-      mExclusiveEntries.remove(key);
-      Entry<K, V> oldEntry = mCachedEntries.remove(key);
-      if (oldEntry != null) {
-        makeOrphan(oldEntry);
-        oldRefToClose = referenceToClose(oldEntry);
-      }
-
-      if (canCacheNewValue(valueRef.get())) {
-        Entry<K, V> newEntry = Entry.of(key, valueRef);
-        mCachedEntries.put(key, newEntry);
-        clientRef = newClientReference(newEntry);
-      }
+
+    /**
+     * Removes all the items from the cache whose key matches the specified predicate.
+     *
+     * @param predicate returns true if an item with the given key should be removed
+     * @return number of the items removed from the cache
+     */
+    public int removeAll(Predicate<K> predicate) {
+        ArrayList<Entry<K, V>> oldEntries;
+        synchronized (this) {
+            mExclusiveEntries.removeAll(predicate);
+            oldEntries = mCachedEntries.removeAll(predicate);
+            makeOrphans(oldEntries);
+        }
+        maybeClose(oldEntries);
+        maybeUpdateCacheParams();
+        maybeEvictEntries();
+        return oldEntries.size();
     }
-    CloseableReference.closeSafely(oldRefToClose);
-
-    maybeEvictEntries();
-    return clientRef;
-  }
-
-  /** Checks the cache constraints to determine whether the new value can be cached or not. */
-  private synchronized boolean canCacheNewValue(V value) {
-    int newValueSize = mValueDescriptor.getSizeInBytes(value);
-    return (newValueSize <= mMemoryCacheParams.maxCacheEntrySize) &&
-        (getInUseCount() + 1 <= mMemoryCacheParams.maxCacheEntries) &&
-        (getInUseSizeInBytes() + newValueSize <= mMemoryCacheParams.maxCacheSize);
-  }
-
-  /**
-   * Gets the item with the given key, or null if there is no such item.
-   *
-   * <p> It is the caller's responsibility to close the returned reference once not needed anymore.
-   */
-  @Nullable
-  public CloseableReference<V> get(final K key) {
-    CloseableReference<V> clientRef = null;
-    synchronized (this) {
-      mExclusiveEntries.remove(key);
-      Entry<K, V> entry = mCachedEntries.get(key);
-      if (entry != null) {
-        clientRef = newClientReference(entry);
-      }
+
+    /**
+     * Removes all the items from the cache.
+     */
+    public void clear() {
+        ArrayList<Entry<K, V>> oldEntries;
+        synchronized (this) {
+            mExclusiveEntries.clear();
+            oldEntries = mCachedEntries.clear();
+            makeOrphans(oldEntries);
+        }
+        maybeClose(oldEntries);
+        maybeUpdateCacheParams();
     }
-    maybeUpdateCacheParams();
-    maybeEvictEntries();
-    return clientRef;
-  }
-
-  /** Creates a new reference for the client. */
-  private synchronized CloseableReference<V> newClientReference(final Entry<K, V> entry) {
-    increaseClientCount(entry);
-    return CloseableReference.of(
-        entry.valueRef.get(),
-        new ResourceReleaser<V>() {
-          @Override
-          public void release(V unused) {
-            releaseClientReference(entry);
-          }
-        });
-  }
-
-  /** Called when the client closes its reference. */
-  private void releaseClientReference(final Entry<K, V> entry) {
-    Preconditions.checkNotNull(entry);
-    CloseableReference<V> oldRefToClose;
-    synchronized (this) {
-      decreaseClientCount(entry);
-      maybeAddToExclusives(entry);
-      oldRefToClose = referenceToClose(entry);
+
+    /**
+     * Trims the cache according to the specified trimming strategy and the given trim type.
+     */
+    @Override
+    public void trim(MemoryTrimType trimType) {
+        ArrayList<Entry<K, V>> oldEntries;
+        final double trimRatio = mCacheTrimStrategy.getTrimRatio(trimType);
+        synchronized (this) {
+            int targetCacheSize = (int) (mCachedEntries.getSizeInBytes() * (1 - trimRatio));
+            int targetEvictionQueueSize = Math.max(0, targetCacheSize - getInUseSizeInBytes());
+            oldEntries = trimExclusivelyOwnedEntries(Integer.MAX_VALUE, targetEvictionQueueSize);
+            makeOrphans(oldEntries);
+        }
+        maybeClose(oldEntries);
+        maybeUpdateCacheParams();
+        maybeEvictEntries();
     }
-    CloseableReference.closeSafely(oldRefToClose);
-    maybeUpdateCacheParams();
-    maybeEvictEntries();
-  }
-
-  /** Adds the entry to the exclusively owned queue if it is viable for eviction. */
-  private synchronized void maybeAddToExclusives(Entry<K, V> entry) {
-    if (!entry.isOrphan && entry.clientCount == 0) {
-      mExclusiveEntries.put(entry.key, entry);
+
+    /**
+     * Updates the cache params (constraints) if enough time has passed since the last update.
+     */
+    private synchronized void maybeUpdateCacheParams() {
+        if (mLastCacheParamsCheck + PARAMS_INTERCHECK_INTERVAL_MS > SystemClock.elapsedRealtime()) {
+            return;
+        }
+        mLastCacheParamsCheck = SystemClock.elapsedRealtime();
+        mMemoryCacheParams = mMemoryCacheParamsSupplier.get();
     }
-  }
-
-  /**
-   * Removes all the items from the cache whose key matches the specified predicate.
-   *
-   * @param predicate returns true if an item with the given key should be removed
-   * @return number of the items removed from the cache
-   */
-  public int removeAll(Predicate<K> predicate) {
-    ArrayList<Entry<K, V>> oldEntries;
-    synchronized (this) {
-      mExclusiveEntries.removeAll(predicate);
-      oldEntries = mCachedEntries.removeAll(predicate);
-      makeOrphans(oldEntries);
+
+    /**
+     * Removes the exclusively owned items until the cache constraints are met.
+     * <p>
+     * <p> This method invokes the external {@link CloseableReference#close} method,
+     * so it must not be called while holding the <code>this</code> lock.
+     */
+    private void maybeEvictEntries() {
+        ArrayList<Entry<K, V>> oldEntries;
+        synchronized (this) {
+            int maxCount = Math.min(
+                    mMemoryCacheParams.maxEvictionQueueEntries,
+                    mMemoryCacheParams.maxCacheEntries - getInUseCount());
+            int maxSize = Math.min(
+                    mMemoryCacheParams.maxEvictionQueueSize,
+                    mMemoryCacheParams.maxCacheSize - getInUseSizeInBytes());
+            oldEntries = trimExclusivelyOwnedEntries(maxCount, maxSize);
+            makeOrphans(oldEntries);
+        }
+        maybeClose(oldEntries);
     }
-    maybeClose(oldEntries);
-    maybeUpdateCacheParams();
-    maybeEvictEntries();
-    return oldEntries.size();
-  }
-
-  /** Removes all the items from the cache. */
-  public void clear() {
-    ArrayList<Entry<K, V>> oldEntries;
-    synchronized (this) {
-      mExclusiveEntries.clear();
-      oldEntries = mCachedEntries.clear();
-      makeOrphans(oldEntries);
+
+    /**
+     * Removes the exclusively owned items until there is at most <code>count</code> of them
+     * and they occupy no more than <code>size</code> bytes.
+     * <p>
+     * <p> This method returns the removed items instead of actually closing them, so it is safe to
+     * be called while holding the <code>this</code> lock.
+     */
+    @Nullable
+    private synchronized ArrayList<Entry<K, V>> trimExclusivelyOwnedEntries(int count, int size) {
+        count = Math.max(count, 0);
+        size = Math.max(size, 0);
+        // fast path without array allocation if no eviction is necessary
+        if (mExclusiveEntries.getCount() <= count && mExclusiveEntries.getSizeInBytes() <= size) {
+            return null;
+        }
+        ArrayList<Entry<K, V>> oldEntries = new ArrayList<>();
+        while (mExclusiveEntries.getCount() > count || mExclusiveEntries.getSizeInBytes() > size) {
+            K key = mExclusiveEntries.getFirstKey();
+            mExclusiveEntries.remove(key);
+            oldEntries.add(mCachedEntries.remove(key));
+        }
+        return oldEntries;
     }
-    maybeClose(oldEntries);
-    maybeUpdateCacheParams();
-  }
-
-  /** Trims the cache according to the specified trimming strategy and the given trim type. */
-  @Override
-  public void trim(MemoryTrimType trimType) {
-    ArrayList<Entry<K, V>> oldEntries;
-    final double trimRatio = mCacheTrimStrategy.getTrimRatio(trimType);
-    synchronized (this) {
-      int targetCacheSize = (int) (mCachedEntries.getSizeInBytes() * (1 - trimRatio));
-      int targetEvictionQueueSize = Math.max(0, targetCacheSize - getInUseSizeInBytes());
-      oldEntries = trimExclusivelyOwnedEntries(Integer.MAX_VALUE, targetEvictionQueueSize);
-      makeOrphans(oldEntries);
+
+    /**
+     * Notifies the client that the cache no longer tracks the given items.
+     * <p>
+     * <p> This method invokes the external {@link CloseableReference#close} method,
+     * so it must not be called while holding the <code>this</code> lock.
+     */
+    private void maybeClose(@Nullable ArrayList<Entry<K, V>> oldEntries) {
+        if (oldEntries != null) {
+            for (Entry<K, V> oldEntry : oldEntries) {
+                CloseableReference.closeSafely(referenceToClose(oldEntry));
+            }
+        }
     }
-    maybeClose(oldEntries);
-    maybeUpdateCacheParams();
-    maybeEvictEntries();
-  }
-
-  /**
-   * Updates the cache params (constraints) if enough time has passed since the last update.
-   */
-  private synchronized void maybeUpdateCacheParams() {
-    if (mLastCacheParamsCheck + PARAMS_INTERCHECK_INTERVAL_MS > SystemClock.elapsedRealtime()) {
-      return;
+
+    /**
+     * Marks the given entries as orphans.
+     */
+    private synchronized void makeOrphans(@Nullable ArrayList<Entry<K, V>> oldEntries) {
+        if (oldEntries != null) {
+            for (Entry<K, V> oldEntry : oldEntries) {
+                makeOrphan(oldEntry);
+            }
+        }
     }
-    mLastCacheParamsCheck = SystemClock.elapsedRealtime();
-    mMemoryCacheParams = mMemoryCacheParamsSupplier.get();
-  }
-
-  /**
-   * Removes the exclusively owned items until the cache constraints are met.
-   *
-   * <p> This method invokes the external {@link CloseableReference#close} method,
-   * so it must not be called while holding the <code>this</code> lock.
-   */
-  private void maybeEvictEntries() {
-    ArrayList<Entry<K, V>> oldEntries;
-    synchronized (this) {
-      int maxCount = Math.min(
-          mMemoryCacheParams.maxEvictionQueueEntries,
-          mMemoryCacheParams.maxCacheEntries - getInUseCount());
-      int maxSize = Math.min(
-          mMemoryCacheParams.maxEvictionQueueSize,
-          mMemoryCacheParams.maxCacheSize - getInUseSizeInBytes());
-      oldEntries = trimExclusivelyOwnedEntries(maxCount, maxSize);
-      makeOrphans(oldEntries);
+
+    /**
+     * Marks the entry as orphan.
+     */
+    private synchronized void makeOrphan(Entry<K, V> entry) {
+        Preconditions.checkNotNull(entry);
+        Preconditions.checkState(!entry.isOrphan);
+        entry.isOrphan = true;
     }
-    maybeClose(oldEntries);
-  }
-
-  /**
-   * Removes the exclusively owned items until there is at most <code>count</code> of them
-   * and they occupy no more than <code>size</code> bytes.
-   *
-   * <p> This method returns the removed items instead of actually closing them, so it is safe to
-   * be called while holding the <code>this</code> lock.
-   */
-  @Nullable
-  private synchronized ArrayList<Entry<K, V>> trimExclusivelyOwnedEntries(int count, int size) {
-    count = Math.max(count, 0);
-    size = Math.max(size, 0);
-    // fast path without array allocation if no eviction is necessary
-    if (mExclusiveEntries.getCount() <= count && mExclusiveEntries.getSizeInBytes() <= size) {
-      return null;
+
+    /**
+     * Increases the entry's client count.
+     */
+    private synchronized void increaseClientCount(Entry<K, V> entry) {
+        Preconditions.checkNotNull(entry);
+        Preconditions.checkState(!entry.isOrphan);
+        entry.clientCount++;
     }
-    ArrayList<Entry<K, V>> oldEntries = new ArrayList<>();
-    while (mExclusiveEntries.getCount() > count || mExclusiveEntries.getSizeInBytes() > size) {
-      K key = mExclusiveEntries.getFirstKey();
-      mExclusiveEntries.remove(key);
-      oldEntries.add(mCachedEntries.remove(key));
+
+    /**
+     * Decreases the entry's client count.
+     */
+    private synchronized void decreaseClientCount(Entry<K, V> entry) {
+        Preconditions.checkNotNull(entry);
+        Preconditions.checkState(entry.clientCount > 0);
+        entry.clientCount--;
     }
-    return oldEntries;
-  }
-
-  /**
-   * Notifies the client that the cache no longer tracks the given items.
-   *
-   * <p> This method invokes the external {@link CloseableReference#close} method,
-   * so it must not be called while holding the <code>this</code> lock.
-   */
-  private void maybeClose(@Nullable ArrayList<Entry<K, V>> oldEntries) {
-    if (oldEntries != null) {
-      for (Entry<K, V> oldEntry : oldEntries) {
-        CloseableReference.closeSafely(referenceToClose(oldEntry));
-      }
+
+    /**
+     * Returns the value reference of the entry if it should be closed, null otherwise.
+     */
+    @Nullable
+    private synchronized CloseableReference<V> referenceToClose(Entry<K, V> entry) {
+        Preconditions.checkNotNull(entry);
+        return (entry.isOrphan && entry.clientCount == 0) ? entry.valueRef : null;
     }
-  }
-
-  /** Marks the given entries as orphans. */
-  private synchronized void makeOrphans(@Nullable ArrayList<Entry<K, V>> oldEntries) {
-    if (oldEntries != null) {
-      for (Entry<K, V> oldEntry : oldEntries) {
-        makeOrphan(oldEntry);
-      }
+
+    /**
+     * Gets the total number of all currently cached items.
+     */
+    public synchronized int getCount() {
+        return mCachedEntries.getCount();
+    }
+
+    /**
+     * Gets the total size in bytes of all currently cached items.
+     */
+    public synchronized int getSizeInBytes() {
+        return mCachedEntries.getSizeInBytes();
+    }
+
+    /**
+     * Gets the number of the cached items that are used by at least one client.
+     */
+    public synchronized int getInUseCount() {
+        return mCachedEntries.getCount() - mExclusiveEntries.getCount();
+    }
+
+    /**
+     * Gets the total size in bytes of the cached items that are used by at least one client.
+     */
+    public synchronized int getInUseSizeInBytes() {
+        return mCachedEntries.getSizeInBytes() - mExclusiveEntries.getSizeInBytes();
+    }
+
+    /**
+     * Gets the number of the exclusively owned items.
+     */
+    public synchronized int getEvictionQueueCount() {
+        return mExclusiveEntries.getCount();
+    }
+
+    /**
+     * Gets the total size in bytes of the exclusively owned items.
+     */
+    public synchronized int getEvictionQueueSizeInBytes() {
+        return mExclusiveEntries.getSizeInBytes();
     }
-  }
-
-  /** Marks the entry as orphan. */
-  private synchronized void makeOrphan(Entry<K, V> entry) {
-    Preconditions.checkNotNull(entry);
-    Preconditions.checkState(!entry.isOrphan);
-    entry.isOrphan = true;
-  }
-
-  /** Increases the entry's client count. */
-  private synchronized void increaseClientCount(Entry<K, V> entry) {
-    Preconditions.checkNotNull(entry);
-    Preconditions.checkState(!entry.isOrphan);
-    entry.clientCount++;
-  }
-
-  /** Decreases the entry's client count. */
-  private synchronized void decreaseClientCount(Entry<K, V> entry) {
-    Preconditions.checkNotNull(entry);
-    Preconditions.checkState(entry.clientCount > 0);
-    entry.clientCount--;
-  }
-
-  /** Returns the value reference of the entry if it should be closed, null otherwise. */
-  @Nullable
-  private synchronized CloseableReference<V> referenceToClose(Entry<K, V> entry) {
-    Preconditions.checkNotNull(entry);
-    return (entry.isOrphan && entry.clientCount == 0) ? entry.valueRef : null;
-  }
-
-  /** Gets the total number of all currently cached items. */
-  public synchronized int getCount() {
-    return mCachedEntries.getCount();
-  }
-
-  /** Gets the total size in bytes of all currently cached items. */
-  public synchronized int getSizeInBytes() {
-    return mCachedEntries.getSizeInBytes();
-  }
-
-  /** Gets the number of the cached items that are used by at least one client. */
-  public synchronized int getInUseCount() {
-    return mCachedEntries.getCount() - mExclusiveEntries.getCount();
-  }
-
-  /** Gets the total size in bytes of the cached items that are used by at least one client. */
-  public synchronized int getInUseSizeInBytes() {
-    return mCachedEntries.getSizeInBytes() - mExclusiveEntries.getSizeInBytes();
-  }
-
-  /** Gets the number of the exclusively owned items. */
-  public synchronized int getEvictionQueueCount() {
-    return mExclusiveEntries.getCount();
-  }
-
-  /** Gets the total size in bytes of the exclusively owned items. */
-  public synchronized int getEvictionQueueSizeInBytes() {
-    return mExclusiveEntries.getSizeInBytes();
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCacheInspector.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCacheInspector.java
index 614cd9e47..4b970edfc 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCacheInspector.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/CountingMemoryCacheInspector.java
@@ -22,96 +22,96 @@
  */
 public class CountingMemoryCacheInspector<K, V> {
 
-  /**
-   * Cache entry info for use by dumpers.
-   */
-  public static class DumpInfoEntry<K, V> {
-    // The key is immutable, so it's safe to store that directly
-    public final K key;
-
-    // The value
-    public final CloseableReference<V> value;
-
-    public DumpInfoEntry(
-        final K key,
-        final CloseableReference<V> valueRef) {
-      this.key = Preconditions.checkNotNull(key);
-      this.value = CloseableReference.cloneOrNull(valueRef);
-    }
+    /**
+     * Cache entry info for use by dumpers.
+     */
+    public static class DumpInfoEntry<K, V> {
+        // The key is immutable, so it's safe to store that directly
+        public final K key;
+
+        // The value
+        public final CloseableReference<V> value;
+
+        public DumpInfoEntry(
+                final K key,
+                final CloseableReference<V> valueRef) {
+            this.key = Preconditions.checkNotNull(key);
+            this.value = CloseableReference.cloneOrNull(valueRef);
+        }
 
-    public void release() {
-      CloseableReference.closeSafely(value);
+        public void release() {
+            CloseableReference.closeSafely(value);
+        }
     }
-  }
 
-  /**
-   * Info about the status of the cache for use by dumpers.
-   */
-  public static class DumpInfo<K, V> {
-    public final int maxSize;
-    public final int maxEntriesCount;
-    public final int maxEntrySize;
+    /**
+     * Info about the status of the cache for use by dumpers.
+     */
+    public static class DumpInfo<K, V> {
+        public final int maxSize;
+        public final int maxEntriesCount;
+        public final int maxEntrySize;
 
-    public final int size;
-    public final int lruSize;
+        public final int size;
+        public final int lruSize;
 
-    public final List<DumpInfoEntry<K, V>> lruEntries;
-    public final List<DumpInfoEntry<K, V>> sharedEntries;
+        public final List<DumpInfoEntry<K, V>> lruEntries;
+        public final List<DumpInfoEntry<K, V>> sharedEntries;
 
-    public DumpInfo(int size, int lruSize, MemoryCacheParams params) {
-      maxSize = params.maxCacheSize;
-      maxEntriesCount = params.maxCacheEntries;
-      maxEntrySize = params.maxCacheEntrySize;
+        public DumpInfo(int size, int lruSize, MemoryCacheParams params) {
+            maxSize = params.maxCacheSize;
+            maxEntriesCount = params.maxCacheEntries;
+            maxEntrySize = params.maxCacheEntrySize;
 
-      this.size = size;
-      this.lruSize = lruSize;
+            this.size = size;
+            this.lruSize = lruSize;
+
+            lruEntries = Lists.newArrayList();
+            sharedEntries = Lists.newArrayList();
+        }
 
-      lruEntries = Lists.newArrayList();
-      sharedEntries = Lists.newArrayList();
+        public void release() {
+            for (DumpInfoEntry entry : lruEntries) {
+                entry.release();
+            }
+            for (DumpInfoEntry entry : sharedEntries) {
+                entry.release();
+            }
+        }
     }
 
-    public void release() {
-      for (DumpInfoEntry entry : lruEntries) {
-        entry.release();
-      }
-      for (DumpInfoEntry entry : sharedEntries) {
-        entry.release();
-      }
+    private final CountingMemoryCache<K, V> mCountingBitmapCache;
+
+    public CountingMemoryCacheInspector(CountingMemoryCache<K, V> countingBitmapCache) {
+        mCountingBitmapCache = countingBitmapCache;
     }
-  }
-
-  private final CountingMemoryCache<K, V> mCountingBitmapCache;
-
-  public CountingMemoryCacheInspector(CountingMemoryCache<K, V> countingBitmapCache) {
-    mCountingBitmapCache = countingBitmapCache;
-  }
-
-  /**
-   * Iterates through all entries cached in counting cache and builds snapshot of its content.
-   * This should be used by tools that need to know current content of given cache.
-   * <p> Caller should call release method on returned DumpInfo after it is done with
-   * examining cache contents
-   */
-  public DumpInfo dumpCacheContent() {
-    synchronized (mCountingBitmapCache) {
-      DumpInfo<K, V> dumpInfo = new DumpInfo<>(
-          mCountingBitmapCache.getSizeInBytes(),
-          mCountingBitmapCache.getEvictionQueueSizeInBytes(),
-          mCountingBitmapCache.mMemoryCacheParams);
-
-      final List<LinkedHashMap.Entry<K, CountingMemoryCache.Entry<K, V>>> cachedEntries =
-          mCountingBitmapCache.mCachedEntries.getMatchingEntries(null);
-      for (LinkedHashMap.Entry<K, CountingMemoryCache.Entry<K, V>> cachedEntry : cachedEntries) {
-        CountingMemoryCache.Entry<K, V> entry = cachedEntry.getValue();
-        DumpInfoEntry<K, V> dumpEntry = new DumpInfoEntry<>(entry.key, entry.valueRef);
-        if (entry.clientCount > 0) {
-          dumpInfo.sharedEntries.add(dumpEntry);
-        } else {
-          dumpInfo.lruEntries.add(dumpEntry);
-        }
-      }
 
-      return dumpInfo;
+    /**
+     * Iterates through all entries cached in counting cache and builds snapshot of its content.
+     * This should be used by tools that need to know current content of given cache.
+     * <p> Caller should call release method on returned DumpInfo after it is done with
+     * examining cache contents
+     */
+    public DumpInfo dumpCacheContent() {
+        synchronized (mCountingBitmapCache) {
+            DumpInfo<K, V> dumpInfo = new DumpInfo<>(
+                    mCountingBitmapCache.getSizeInBytes(),
+                    mCountingBitmapCache.getEvictionQueueSizeInBytes(),
+                    mCountingBitmapCache.mMemoryCacheParams);
+
+            final List<LinkedHashMap.Entry<K, CountingMemoryCache.Entry<K, V>>> cachedEntries =
+                    mCountingBitmapCache.mCachedEntries.getMatchingEntries(null);
+            for (LinkedHashMap.Entry<K, CountingMemoryCache.Entry<K, V>> cachedEntry : cachedEntries) {
+                CountingMemoryCache.Entry<K, V> entry = cachedEntry.getValue();
+                DumpInfoEntry<K, V> dumpEntry = new DumpInfoEntry<>(entry.key, entry.valueRef);
+                if (entry.clientCount > 0) {
+                    dumpInfo.sharedEntries.add(dumpEntry);
+                } else {
+                    dumpInfo.lruEntries.add(dumpEntry);
+                }
+            }
+
+            return dumpInfo;
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultBitmapMemoryCacheParamsSupplier.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultBitmapMemoryCacheParamsSupplier.java
index de50ea3b5..4e9057d62 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultBitmapMemoryCacheParamsSupplier.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultBitmapMemoryCacheParamsSupplier.java
@@ -19,42 +19,42 @@
  * Supplies {@link MemoryCacheParams} for the bitmap memory cache.
  */
 public class DefaultBitmapMemoryCacheParamsSupplier implements Supplier<MemoryCacheParams> {
-  private static final int MAX_CACHE_ENTRIES = 256;
-  private static final int MAX_EVICTION_QUEUE_SIZE = Integer.MAX_VALUE;
-  private static final int MAX_EVICTION_QUEUE_ENTRIES = Integer.MAX_VALUE;
-  private static final int MAX_CACHE_ENTRY_SIZE = Integer.MAX_VALUE;
-
-  private final ActivityManager mActivityManager;
-
-  public DefaultBitmapMemoryCacheParamsSupplier(ActivityManager activityManager) {
-    mActivityManager = activityManager;
-  }
-
-  @Override
-  public MemoryCacheParams get() {
-    return new MemoryCacheParams(
-        getMaxCacheSize(),
-        MAX_CACHE_ENTRIES,
-        MAX_EVICTION_QUEUE_SIZE,
-        MAX_EVICTION_QUEUE_ENTRIES,
-        MAX_CACHE_ENTRY_SIZE);
-  }
-
-  private int getMaxCacheSize() {
-    final int maxMemory =
-        Math.min(mActivityManager.getMemoryClass() * ByteConstants.MB, Integer.MAX_VALUE);
-    if (maxMemory < 32 * ByteConstants.MB) {
-      return 4 * ByteConstants.MB;
-    } else if (maxMemory < 64 * ByteConstants.MB) {
-      return 6 * ByteConstants.MB;
-    } else {
-      // We don't want to use more ashmem on Gingerbread for now, since it doesn't respond well to
-      // native memory pressure (doesn't throw exceptions, crashes app, crashes phone)
-      if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.GINGERBREAD) {
-        return 8 * ByteConstants.MB;
-      } else {
-        return maxMemory / 4;
-      }
+    private static final int MAX_CACHE_ENTRIES = 256;
+    private static final int MAX_EVICTION_QUEUE_SIZE = Integer.MAX_VALUE;
+    private static final int MAX_EVICTION_QUEUE_ENTRIES = Integer.MAX_VALUE;
+    private static final int MAX_CACHE_ENTRY_SIZE = Integer.MAX_VALUE;
+
+    private final ActivityManager mActivityManager;
+
+    public DefaultBitmapMemoryCacheParamsSupplier(ActivityManager activityManager) {
+        mActivityManager = activityManager;
+    }
+
+    @Override
+    public MemoryCacheParams get() {
+        return new MemoryCacheParams(
+                getMaxCacheSize(),
+                MAX_CACHE_ENTRIES,
+                MAX_EVICTION_QUEUE_SIZE,
+                MAX_EVICTION_QUEUE_ENTRIES,
+                MAX_CACHE_ENTRY_SIZE);
+    }
+
+    private int getMaxCacheSize() {
+        final int maxMemory =
+                Math.min(mActivityManager.getMemoryClass() * ByteConstants.MB, Integer.MAX_VALUE);
+        if (maxMemory < 32 * ByteConstants.MB) {
+            return 4 * ByteConstants.MB;
+        } else if (maxMemory < 64 * ByteConstants.MB) {
+            return 6 * ByteConstants.MB;
+        } else {
+            // We don't want to use more ashmem on Gingerbread for now, since it doesn't respond well to
+            // native memory pressure (doesn't throw exceptions, crashes app, crashes phone)
+            if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.GINGERBREAD) {
+                return 8 * ByteConstants.MB;
+            } else {
+                return maxMemory / 4;
+            }
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultCacheKeyFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultCacheKeyFactory.java
index 758fd3f3f..6f2855bb2 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultCacheKeyFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultCacheKeyFactory.java
@@ -19,34 +19,34 @@
  * Default implementation of {@link CacheKeyFactory}.
  */
 public class DefaultCacheKeyFactory implements CacheKeyFactory {
-  private static DefaultCacheKeyFactory sInstance = null;
+    private static DefaultCacheKeyFactory sInstance = null;
 
-  protected DefaultCacheKeyFactory() {
-  }
+    protected DefaultCacheKeyFactory() {
+    }
+
+    public static synchronized DefaultCacheKeyFactory getInstance() {
+        if (sInstance == null) {
+            sInstance = new DefaultCacheKeyFactory();
+        }
+        return sInstance;
+    }
+
+    @Override
+    public CacheKey getBitmapCacheKey(ImageRequest request) {
+        return new BitmapMemoryCacheKey(
+                getCacheKeySourceUri(request.getSourceUri()).toString(),
+                request.getResizeOptions(),
+                request.getAutoRotateEnabled(),
+                request.getImageDecodeOptions());
+    }
+
+    @Override
+    public CacheKey getEncodedCacheKey(ImageRequest request) {
+        return new SimpleCacheKey(getCacheKeySourceUri(request.getSourceUri()).toString());
+    }
 
-  public static synchronized DefaultCacheKeyFactory getInstance() {
-    if (sInstance == null) {
-      sInstance = new DefaultCacheKeyFactory();
+    @Override
+    public Uri getCacheKeySourceUri(Uri sourceUri) {
+        return sourceUri;
     }
-    return sInstance;
-  }
-
-  @Override
-  public CacheKey getBitmapCacheKey(ImageRequest request) {
-    return new BitmapMemoryCacheKey(
-        getCacheKeySourceUri(request.getSourceUri()).toString(),
-        request.getResizeOptions(),
-        request.getAutoRotateEnabled(),
-        request.getImageDecodeOptions());
-  }
-
-  @Override
-  public CacheKey getEncodedCacheKey(ImageRequest request) {
-    return new SimpleCacheKey(getCacheKeySourceUri(request.getSourceUri()).toString());
-  }
-
-  @Override
-  public Uri getCacheKeySourceUri(Uri sourceUri) {
-    return sourceUri;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultEncodedMemoryCacheParamsSupplier.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultEncodedMemoryCacheParamsSupplier.java
index 34e7f3ccf..84c885e12 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultEncodedMemoryCacheParamsSupplier.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultEncodedMemoryCacheParamsSupplier.java
@@ -17,30 +17,30 @@
  */
 public class DefaultEncodedMemoryCacheParamsSupplier implements Supplier<MemoryCacheParams> {
 
-  // We want memory cache to be bound only by its memory consumption
-  private static final int MAX_CACHE_ENTRIES = Integer.MAX_VALUE;
-  private static final int MAX_EVICTION_QUEUE_ENTRIES = MAX_CACHE_ENTRIES;
+    // We want memory cache to be bound only by its memory consumption
+    private static final int MAX_CACHE_ENTRIES = Integer.MAX_VALUE;
+    private static final int MAX_EVICTION_QUEUE_ENTRIES = MAX_CACHE_ENTRIES;
 
-  @Override
-  public MemoryCacheParams get() {
-    final int maxCacheSize = getMaxCacheSize();
-    final int maxCacheEntrySize = maxCacheSize / 8;
-    return new MemoryCacheParams(
-        maxCacheSize,
-        MAX_CACHE_ENTRIES,
-        maxCacheSize,
-        MAX_EVICTION_QUEUE_ENTRIES,
-        maxCacheEntrySize);
-  }
+    @Override
+    public MemoryCacheParams get() {
+        final int maxCacheSize = getMaxCacheSize();
+        final int maxCacheEntrySize = maxCacheSize / 8;
+        return new MemoryCacheParams(
+                maxCacheSize,
+                MAX_CACHE_ENTRIES,
+                maxCacheSize,
+                MAX_EVICTION_QUEUE_ENTRIES,
+                maxCacheEntrySize);
+    }
 
-  private int getMaxCacheSize() {
-    final int maxMemory = (int) Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
-    if (maxMemory < 16 * ByteConstants.MB) {
-      return 1 * ByteConstants.MB;
-    } else if (maxMemory < 32 * ByteConstants.MB) {
-      return 2 * ByteConstants.MB;
-    } else {
-      return 4 * ByteConstants.MB;
+    private int getMaxCacheSize() {
+        final int maxMemory = (int) Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
+        if (maxMemory < 16 * ByteConstants.MB) {
+            return 1 * ByteConstants.MB;
+        } else if (maxMemory < 32 * ByteConstants.MB) {
+            return 2 * ByteConstants.MB;
+        } else {
+            return 4 * ByteConstants.MB;
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/EncodedCountingMemoryCacheFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/EncodedCountingMemoryCacheFactory.java
index 97680e2e7..e7bb3db9b 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/EncodedCountingMemoryCacheFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/EncodedCountingMemoryCacheFactory.java
@@ -16,25 +16,25 @@
 
 public class EncodedCountingMemoryCacheFactory {
 
-  public static CountingMemoryCache<CacheKey, PooledByteBuffer> get(
-      Supplier<MemoryCacheParams> encodedMemoryCacheParamsSupplier,
-      MemoryTrimmableRegistry memoryTrimmableRegistry) {
+    public static CountingMemoryCache<CacheKey, PooledByteBuffer> get(
+            Supplier<MemoryCacheParams> encodedMemoryCacheParamsSupplier,
+            MemoryTrimmableRegistry memoryTrimmableRegistry) {
 
-    ValueDescriptor<PooledByteBuffer> valueDescriptor =
-        new ValueDescriptor<PooledByteBuffer>() {
-          @Override
-          public int getSizeInBytes(PooledByteBuffer value) {
-            return value.size();
-          }
-        };
+        ValueDescriptor<PooledByteBuffer> valueDescriptor =
+                new ValueDescriptor<PooledByteBuffer>() {
+                    @Override
+                    public int getSizeInBytes(PooledByteBuffer value) {
+                        return value.size();
+                    }
+                };
 
-    CountingMemoryCache.CacheTrimStrategy trimStrategy = new NativeMemoryCacheTrimStrategy();
+        CountingMemoryCache.CacheTrimStrategy trimStrategy = new NativeMemoryCacheTrimStrategy();
 
-    CountingMemoryCache<CacheKey, PooledByteBuffer> countingCache =
-        new CountingMemoryCache<>(valueDescriptor, trimStrategy, encodedMemoryCacheParamsSupplier);
+        CountingMemoryCache<CacheKey, PooledByteBuffer> countingCache =
+                new CountingMemoryCache<>(valueDescriptor, trimStrategy, encodedMemoryCacheParamsSupplier);
 
-    memoryTrimmableRegistry.registerMemoryTrimmable(countingCache);
+        memoryTrimmableRegistry.registerMemoryTrimmable(countingCache);
 
-    return countingCache;
-  }
+        return countingCache;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/EncodedMemoryCacheFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/EncodedMemoryCacheFactory.java
index 9fdd8fbd5..77b6a4a09 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/EncodedMemoryCacheFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/EncodedMemoryCacheFactory.java
@@ -14,29 +14,29 @@
 
 public class EncodedMemoryCacheFactory {
 
-  public static MemoryCache<CacheKey, PooledByteBuffer> get(
-      final CountingMemoryCache<CacheKey, PooledByteBuffer> encodedCountingMemoryCache,
-      final ImageCacheStatsTracker imageCacheStatsTracker) {
-
-    imageCacheStatsTracker.registerEncodedMemoryCache(encodedCountingMemoryCache);
-
-    MemoryCacheTracker memoryCacheTracker = new MemoryCacheTracker() {
-      @Override
-      public void onCacheHit() {
-        imageCacheStatsTracker.onMemoryCacheHit();
-      }
-
-      @Override
-      public void onCacheMiss() {
-        imageCacheStatsTracker.onMemoryCacheMiss();
-      }
-
-      @Override
-      public void onCachePut() {
-        imageCacheStatsTracker.onMemoryCachePut();
-      }
-    };
-
-    return new InstrumentedMemoryCache<>(encodedCountingMemoryCache, memoryCacheTracker);
-  }
+    public static MemoryCache<CacheKey, PooledByteBuffer> get(
+            final CountingMemoryCache<CacheKey, PooledByteBuffer> encodedCountingMemoryCache,
+            final ImageCacheStatsTracker imageCacheStatsTracker) {
+
+        imageCacheStatsTracker.registerEncodedMemoryCache(encodedCountingMemoryCache);
+
+        MemoryCacheTracker memoryCacheTracker = new MemoryCacheTracker() {
+            @Override
+            public void onCacheHit() {
+                imageCacheStatsTracker.onMemoryCacheHit();
+            }
+
+            @Override
+            public void onCacheMiss() {
+                imageCacheStatsTracker.onMemoryCacheMiss();
+            }
+
+            @Override
+            public void onCachePut() {
+                imageCacheStatsTracker.onMemoryCachePut();
+            }
+        };
+
+        return new InstrumentedMemoryCache<>(encodedCountingMemoryCache, memoryCacheTracker);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/ImageCacheStatsTracker.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/ImageCacheStatsTracker.java
index 0bd468539..3500e8672 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/ImageCacheStatsTracker.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/ImageCacheStatsTracker.java
@@ -11,62 +11,82 @@
 
 /**
  * Interface for stats tracking for the image cache.
- *
+ * <p>
  * <p>An implementation of this interface, passed to
  * {@link com.facebook.imagepipeline.core.ImagePipelineConfig}, will be notified for each
  * of the following cache events. Use this to keep cache stats for your app.
  */
 public interface ImageCacheStatsTracker {
 
-  /** Called whenever decoded images are put into the bitmap cache. */
-  public void onBitmapCachePut();
+    /**
+     * Called whenever decoded images are put into the bitmap cache.
+     */
+    public void onBitmapCachePut();
 
-  /** Called on a bitmap cache hit. */
-  public void onBitmapCacheHit();
+    /**
+     * Called on a bitmap cache hit.
+     */
+    public void onBitmapCacheHit();
 
-  /** Called on a bitmap cache miss. */
-  public void onBitmapCacheMiss();
+    /**
+     * Called on a bitmap cache miss.
+     */
+    public void onBitmapCacheMiss();
 
-  /** Called whenever encoded images are put into the encoded memory cache. */
-  public void onMemoryCachePut();
+    /**
+     * Called whenever encoded images are put into the encoded memory cache.
+     */
+    public void onMemoryCachePut();
 
-  /** Called on an encoded memory cache hit. */
-  public void onMemoryCacheHit();
+    /**
+     * Called on an encoded memory cache hit.
+     */
+    public void onMemoryCacheHit();
 
-  /** Called on an encoded memory cache hit. */
-  public void onMemoryCacheMiss();
+    /**
+     * Called on an encoded memory cache hit.
+     */
+    public void onMemoryCacheMiss();
 
-  /**
-   * Called on an staging area hit.
-   *
-   * <p>The staging area stores encoded images. It gets the images before they are written
-   * to disk cache.
-   */
-  public void onStagingAreaHit();
+    /**
+     * Called on an staging area hit.
+     * <p>
+     * <p>The staging area stores encoded images. It gets the images before they are written
+     * to disk cache.
+     */
+    public void onStagingAreaHit();
 
-  /** Called on a staging area miss hit. */
-  public void onStagingAreaMiss();
+    /**
+     * Called on a staging area miss hit.
+     */
+    public void onStagingAreaMiss();
 
-  /** Called on a disk cache hit. */
-  public void onDiskCacheHit();
+    /**
+     * Called on a disk cache hit.
+     */
+    public void onDiskCacheHit();
 
-  /** Called on a disk cache miss. */
-  public void onDiskCacheMiss();
+    /**
+     * Called on a disk cache miss.
+     */
+    public void onDiskCacheMiss();
 
-  /** Called if an exception is thrown on a disk cache read. */
-  public void onDiskCacheGetFail();
+    /**
+     * Called if an exception is thrown on a disk cache read.
+     */
+    public void onDiskCacheGetFail();
 
-  /**
-   * Registers a bitmap cache with this tracker.
-   *
-   * <p>Use this method if you need access to the cache itself to compile your stats.
-   */
-  public void registerBitmapMemoryCache(CountingMemoryCache<?, ?> bitmapMemoryCache);
+    /**
+     * Registers a bitmap cache with this tracker.
+     * <p>
+     * <p>Use this method if you need access to the cache itself to compile your stats.
+     */
+    public void registerBitmapMemoryCache(CountingMemoryCache<?, ?> bitmapMemoryCache);
 
-  /**
-   * Registers an encoded memory cache with this tracker.
-   *
-   * <p>Use this method if you need access to the cache itself to compile your stats.
-   */
-  public void registerEncodedMemoryCache(CountingMemoryCache<?, ?> encodedMemoryCache);
+    /**
+     * Registers an encoded memory cache with this tracker.
+     * <p>
+     * <p>Use this method if you need access to the cache itself to compile your stats.
+     */
+    public void registerEncodedMemoryCache(CountingMemoryCache<?, ?> encodedMemoryCache);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/InstrumentedMemoryCache.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/InstrumentedMemoryCache.java
index 6b11d07c0..a8d444ef6 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/InstrumentedMemoryCache.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/InstrumentedMemoryCache.java
@@ -15,33 +15,33 @@
 
 public class InstrumentedMemoryCache<K, V> implements MemoryCache<K, V> {
 
-  private final MemoryCache<K, V> mDelegate;
-  private final MemoryCacheTracker mTracker;
-
-  public InstrumentedMemoryCache(MemoryCache<K, V> delegate, MemoryCacheTracker tracker) {
-    mDelegate = delegate;
-    mTracker = tracker;
-  }
-
-  @Override
-  public CloseableReference<V> get(K key) {
-    CloseableReference<V> result = mDelegate.get(key);
-    if (result == null) {
-      mTracker.onCacheMiss();
-    } else {
-      mTracker.onCacheHit();
+    private final MemoryCache<K, V> mDelegate;
+    private final MemoryCacheTracker mTracker;
+
+    public InstrumentedMemoryCache(MemoryCache<K, V> delegate, MemoryCacheTracker tracker) {
+        mDelegate = delegate;
+        mTracker = tracker;
+    }
+
+    @Override
+    public CloseableReference<V> get(K key) {
+        CloseableReference<V> result = mDelegate.get(key);
+        if (result == null) {
+            mTracker.onCacheMiss();
+        } else {
+            mTracker.onCacheHit();
+        }
+        return result;
+    }
+
+    @Override
+    public CloseableReference<V> cache(K key, CloseableReference<V> value) {
+        mTracker.onCachePut();
+        return mDelegate.cache(key, value);
+    }
+
+    @Override
+    public int removeAll(Predicate<K> predicate) {
+        return mDelegate.removeAll(predicate);
     }
-    return result;
-  }
-
-  @Override
-  public CloseableReference<V> cache(K key, CloseableReference<V> value) {
-    mTracker.onCachePut();
-    return mDelegate.cache(key, value);
-  }
-
-  @Override
-  public int removeAll(Predicate<K> predicate) {
-    return mDelegate.removeAll(predicate);
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCache.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCache.java
index da061d0e2..7cf140144 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCache.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCache.java
@@ -23,35 +23,35 @@
  */
 public interface MemoryCache<K, V> {
 
-  /**
-   * Caches the the given key-value pair.
-   *
-   * <p> The cache returns a new copy of the provided reference which should be used instead of the
-   * original one. The client should close the returned reference when it is not required anymore.
-   *
-   * <p> If the cache failed to cache the given value, then the null reference is returned.
-   *
-   * @param key
-   * @param value
-   * @return a new reference to be used, or null if the caching failed
-   */
-  @Nullable
-  public CloseableReference<V> cache(K key, CloseableReference<V> value);
-
-  /**
-   * Gets the item with the given key, or null if there is no such item.
-   *
-   * @param key
-   * @return a reference to the cached value, or null if the item was not found
-   */
-  @Nullable
-  public CloseableReference<V> get(K key);
-
-  /**
-   * Removes all the items from the cache whose keys match the specified predicate.
-   *
-   * @param predicate returns true if an item with the given key should be removed
-   * @return number of the items removed from the cache
-   */
-  public int removeAll(Predicate<K> predicate);
+    /**
+     * Caches the the given key-value pair.
+     * <p>
+     * <p> The cache returns a new copy of the provided reference which should be used instead of the
+     * original one. The client should close the returned reference when it is not required anymore.
+     * <p>
+     * <p> If the cache failed to cache the given value, then the null reference is returned.
+     *
+     * @param key
+     * @param value
+     * @return a new reference to be used, or null if the caching failed
+     */
+    @Nullable
+    public CloseableReference<V> cache(K key, CloseableReference<V> value);
+
+    /**
+     * Gets the item with the given key, or null if there is no such item.
+     *
+     * @param key
+     * @return a reference to the cached value, or null if the item was not found
+     */
+    @Nullable
+    public CloseableReference<V> get(K key);
+
+    /**
+     * Removes all the items from the cache whose keys match the specified predicate.
+     *
+     * @param predicate returns true if an item with the given key should be removed
+     * @return number of the items removed from the cache
+     */
+    public int removeAll(Predicate<K> predicate);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheParams.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheParams.java
index 81054f6ba..f5314c4f3 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheParams.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheParams.java
@@ -14,33 +14,33 @@
  */
 public class MemoryCacheParams {
 
-  public final int maxCacheSize;
-  public final int maxCacheEntries;
-  public final int maxEvictionQueueSize;
-  public final int maxEvictionQueueEntries;
-  public final int maxCacheEntrySize;
+    public final int maxCacheSize;
+    public final int maxCacheEntries;
+    public final int maxEvictionQueueSize;
+    public final int maxEvictionQueueEntries;
+    public final int maxCacheEntrySize;
 
-  /**
-   * Pass arguments to control the cache's behavior in the constructor.
-   *
-   * @param maxCacheSize The maximum size of the cache, in bytes.
-   * @param maxCacheEntries The maximum number of items that can live in the cache.
-   * @param maxEvictionQueueSize The eviction queue is an area of memory that stores items ready
-   *                             for eviction but have not yet been deleted. This is the maximum
-   *                             size of that queue in bytes.
-   * @param maxEvictionQueueEntries The maximum number of entries in the eviction queue.
-   * @param maxCacheEntrySize The maximum size of a single cache entry.
-   */
-  public MemoryCacheParams(
-      int maxCacheSize,
-      int maxCacheEntries,
-      int maxEvictionQueueSize,
-      int maxEvictionQueueEntries,
-      int maxCacheEntrySize) {
-    this.maxCacheSize = maxCacheSize;
-    this.maxCacheEntries = maxCacheEntries;
-    this.maxEvictionQueueSize = maxEvictionQueueSize;
-    this.maxEvictionQueueEntries = maxEvictionQueueEntries;
-    this.maxCacheEntrySize = maxCacheEntrySize;
-  }
+    /**
+     * Pass arguments to control the cache's behavior in the constructor.
+     *
+     * @param maxCacheSize            The maximum size of the cache, in bytes.
+     * @param maxCacheEntries         The maximum number of items that can live in the cache.
+     * @param maxEvictionQueueSize    The eviction queue is an area of memory that stores items ready
+     *                                for eviction but have not yet been deleted. This is the maximum
+     *                                size of that queue in bytes.
+     * @param maxEvictionQueueEntries The maximum number of entries in the eviction queue.
+     * @param maxCacheEntrySize       The maximum size of a single cache entry.
+     */
+    public MemoryCacheParams(
+            int maxCacheSize,
+            int maxCacheEntries,
+            int maxEvictionQueueSize,
+            int maxEvictionQueueEntries,
+            int maxCacheEntrySize) {
+        this.maxCacheSize = maxCacheSize;
+        this.maxCacheEntries = maxCacheEntries;
+        this.maxEvictionQueueSize = maxEvictionQueueSize;
+        this.maxEvictionQueueEntries = maxEvictionQueueEntries;
+        this.maxCacheEntrySize = maxCacheEntrySize;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheTracker.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheTracker.java
index 50ca04207..919efd513 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheTracker.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/MemoryCacheTracker.java
@@ -10,7 +10,9 @@
 package com.facebook.imagepipeline.cache;
 
 public interface MemoryCacheTracker {
-  void onCacheHit();
-  void onCacheMiss();
-  void onCachePut();
+    void onCacheHit();
+
+    void onCacheMiss();
+
+    void onCachePut();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/NativeMemoryCacheTrimStrategy.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/NativeMemoryCacheTrimStrategy.java
index c3c647161..8557c4629 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/NativeMemoryCacheTrimStrategy.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/NativeMemoryCacheTrimStrategy.java
@@ -15,28 +15,29 @@
 /**
  * CountingMemoryCache eviction strategy appropriate for caches that store resources off the Dalvik
  * heap.
- *
+ * <p>
  * <p>In case of OnCloseToDalvikHeapLimit nothing will be done. In case of other trim types
  * eviction queue of the cache will be cleared.
  */
 public class NativeMemoryCacheTrimStrategy implements CountingMemoryCache.CacheTrimStrategy {
-  private static final String TAG = "NativeMemoryCacheTrimStrategy";
+    private static final String TAG = "NativeMemoryCacheTrimStrategy";
 
-  public NativeMemoryCacheTrimStrategy() {}
+    public NativeMemoryCacheTrimStrategy() {
+    }
 
-  @Override
-  public double getTrimRatio(MemoryTrimType trimType) {
-    switch (trimType) {
-      case OnCloseToDalvikHeapLimit:
-        // Resources cached on native heap do not consume Dalvik heap, so no trimming here.
-        return 0;
-      case OnAppBackgrounded:
-      case OnSystemLowMemoryWhileAppInForeground:
-      case OnSystemLowMemoryWhileAppInBackground:
-        return 1;
-      default:
-        FLog.wtf(TAG, "unknown trim type: %s", trimType);
-        return 0;
+    @Override
+    public double getTrimRatio(MemoryTrimType trimType) {
+        switch (trimType) {
+            case OnCloseToDalvikHeapLimit:
+                // Resources cached on native heap do not consume Dalvik heap, so no trimming here.
+                return 0;
+            case OnAppBackgrounded:
+            case OnSystemLowMemoryWhileAppInForeground:
+            case OnSystemLowMemoryWhileAppInBackground:
+                return 1;
+            default:
+                FLog.wtf(TAG, "unknown trim type: %s", trimType);
+                return 0;
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/NoOpImageCacheStatsTracker.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/NoOpImageCacheStatsTracker.java
index 530de6368..9464cde6a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/NoOpImageCacheStatsTracker.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/NoOpImageCacheStatsTracker.java
@@ -13,67 +13,67 @@
  * Class that does no stats tracking at all
  */
 public class NoOpImageCacheStatsTracker implements ImageCacheStatsTracker {
-  private static NoOpImageCacheStatsTracker sInstance = null;
+    private static NoOpImageCacheStatsTracker sInstance = null;
 
-  private NoOpImageCacheStatsTracker() {
-  }
+    private NoOpImageCacheStatsTracker() {
+    }
 
-  public static synchronized NoOpImageCacheStatsTracker getInstance() {
-    if (sInstance == null) {
-      sInstance = new NoOpImageCacheStatsTracker();
+    public static synchronized NoOpImageCacheStatsTracker getInstance() {
+        if (sInstance == null) {
+            sInstance = new NoOpImageCacheStatsTracker();
+        }
+        return sInstance;
     }
-    return sInstance;
-  }
 
-  @Override
-  public void onBitmapCachePut() {
-  }
+    @Override
+    public void onBitmapCachePut() {
+    }
 
-  @Override
-  public void onBitmapCacheHit() {
-  }
+    @Override
+    public void onBitmapCacheHit() {
+    }
 
-  @Override
-  public void onBitmapCacheMiss() {
-  }
+    @Override
+    public void onBitmapCacheMiss() {
+    }
 
-  @Override
-  public void onMemoryCachePut() {
-  }
+    @Override
+    public void onMemoryCachePut() {
+    }
 
-  @Override
-  public void onMemoryCacheHit() {
-  }
+    @Override
+    public void onMemoryCacheHit() {
+    }
 
-  @Override
-  public void onMemoryCacheMiss() {
-  }
+    @Override
+    public void onMemoryCacheMiss() {
+    }
 
-  @Override
-  public void onStagingAreaHit() {
-  }
+    @Override
+    public void onStagingAreaHit() {
+    }
 
-  @Override
-  public void onStagingAreaMiss() {
-  }
+    @Override
+    public void onStagingAreaMiss() {
+    }
 
-  @Override
-  public void onDiskCacheHit() {
-  }
+    @Override
+    public void onDiskCacheHit() {
+    }
 
-  @Override
-  public void onDiskCacheMiss() {
-  }
+    @Override
+    public void onDiskCacheMiss() {
+    }
 
-  @Override
-  public void onDiskCacheGetFail() {
-  }
+    @Override
+    public void onDiskCacheGetFail() {
+    }
 
-  @Override
-  public void registerBitmapMemoryCache(CountingMemoryCache<?, ?> bitmapMemoryCache) {
-  }
+    @Override
+    public void registerBitmapMemoryCache(CountingMemoryCache<?, ?> bitmapMemoryCache) {
+    }
 
-  @Override
-  public void registerEncodedMemoryCache(CountingMemoryCache<?, ?> encodedMemoryCache) {
-  }
+    @Override
+    public void registerEncodedMemoryCache(CountingMemoryCache<?, ?> encodedMemoryCache) {
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/StagingArea.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/StagingArea.java
index 89e4156df..854ae78e3 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/StagingArea.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/StagingArea.java
@@ -26,97 +26,99 @@
  * to disk cache, so that they can be returned by parallel cache get operations.
  */
 public class StagingArea {
-  private static final Class<?> TAG = StagingArea.class;
-
-  @GuardedBy("this")
-  private Map<CacheKey, CloseableReference<PooledByteBuffer>> mMap;
-
-  private StagingArea() {
-    mMap = Maps.newHashMap();
-  }
-
-  public static StagingArea getInstance() {
-    return new StagingArea();
-  }
-
-  /**
-   * Stores key-value in this StagingArea. This call overrides previous value
-   * of stored reference if
-   * @param key
-   * @param bufferRef reference to be associated with key
-   */
-  public synchronized void put(
-      final CacheKey key,
-      final CloseableReference<PooledByteBuffer> bufferRef) {
-    Preconditions.checkNotNull(key);
-    Preconditions.checkArgument(CloseableReference.isValid(bufferRef));
-
-    // we're making a 'copy' of this reference - so duplicate it
-    final CloseableReference<?> oldEntry = mMap.put(key, bufferRef.clone());
-    if (oldEntry != null) {
-      oldEntry.close();
+    private static final Class<?> TAG = StagingArea.class;
+
+    @GuardedBy("this")
+    private Map<CacheKey, CloseableReference<PooledByteBuffer>> mMap;
+
+    private StagingArea() {
+        mMap = Maps.newHashMap();
+    }
+
+    public static StagingArea getInstance() {
+        return new StagingArea();
+    }
+
+    /**
+     * Stores key-value in this StagingArea. This call overrides previous value
+     * of stored reference if
+     *
+     * @param key
+     * @param bufferRef reference to be associated with key
+     */
+    public synchronized void put(
+            final CacheKey key,
+            final CloseableReference<PooledByteBuffer> bufferRef) {
+        Preconditions.checkNotNull(key);
+        Preconditions.checkArgument(CloseableReference.isValid(bufferRef));
+
+        // we're making a 'copy' of this reference - so duplicate it
+        final CloseableReference<?> oldEntry = mMap.put(key, bufferRef.clone());
+        if (oldEntry != null) {
+            oldEntry.close();
+        }
+        logStats();
     }
-    logStats();
-  }
-
-  /**
-   * Removes key-value from the StagingArea. Both key and value must match.
-   * @param key
-   * @param bufferRef value corresponding to key
-   * @return true if item was removed
-   */
-  public synchronized boolean remove(
-      final CacheKey key,
-      final CloseableReference<PooledByteBuffer> bufferRef) {
-    Preconditions.checkNotNull(key);
-    Preconditions.checkNotNull(bufferRef);
-    Preconditions.checkArgument(CloseableReference.isValid(bufferRef));
-
-    final CloseableReference<?> oldValue = mMap.get(key);
-
-    if (oldValue == null || oldValue.get() != bufferRef.get()) {
-      return false;
+
+    /**
+     * Removes key-value from the StagingArea. Both key and value must match.
+     *
+     * @param key
+     * @param bufferRef value corresponding to key
+     * @return true if item was removed
+     */
+    public synchronized boolean remove(
+            final CacheKey key,
+            final CloseableReference<PooledByteBuffer> bufferRef) {
+        Preconditions.checkNotNull(key);
+        Preconditions.checkNotNull(bufferRef);
+        Preconditions.checkArgument(CloseableReference.isValid(bufferRef));
+
+        final CloseableReference<?> oldValue = mMap.get(key);
+
+        if (oldValue == null || oldValue.get() != bufferRef.get()) {
+            return false;
+        }
+
+        mMap.remove(key);
+        oldValue.close();
+        logStats();
+        return true;
     }
 
-    mMap.remove(key);
-    oldValue.close();
-    logStats();
-    return true;
-  }
-
-  /**
-   * @param key
-   * @return value associated with given key or null if no value is associated
-   */
-  public synchronized CloseableReference<PooledByteBuffer> get(final CacheKey key) {
-    Preconditions.checkNotNull(key);
-    CloseableReference<PooledByteBuffer> storedRef = mMap.get(key);
-    if (storedRef != null) {
-      synchronized (storedRef) {
-        if (!CloseableReference.isValid(storedRef)) {
-          // Reference is not valid, this means that someone cleared reference while it was still in
-          // use. Log error
-          // TODO: 3697790
-          mMap.remove(key);
-          FLog.w(
-              TAG,
-              "Found closed reference %d for key %s (%d)",
-              System.identityHashCode(storedRef),
-              key.toString(),
-              System.identityHashCode(key));
-          return null;
+    /**
+     * @param key
+     * @return value associated with given key or null if no value is associated
+     */
+    public synchronized CloseableReference<PooledByteBuffer> get(final CacheKey key) {
+        Preconditions.checkNotNull(key);
+        CloseableReference<PooledByteBuffer> storedRef = mMap.get(key);
+        if (storedRef != null) {
+            synchronized (storedRef) {
+                if (!CloseableReference.isValid(storedRef)) {
+                    // Reference is not valid, this means that someone cleared reference while it was still in
+                    // use. Log error
+                    // TODO: 3697790
+                    mMap.remove(key);
+                    FLog.w(
+                            TAG,
+                            "Found closed reference %d for key %s (%d)",
+                            System.identityHashCode(storedRef),
+                            key.toString(),
+                            System.identityHashCode(key));
+                    return null;
+                }
+                storedRef = storedRef.clone();
+            }
         }
-        storedRef = storedRef.clone();
-      }
+        return storedRef;
+    }
+
+    /**
+     * Simple 'debug' logging of stats.
+     */
+    private synchronized void logStats() {
+        FLog.v(TAG, "Count = %d", mMap.size());
     }
-    return storedRef;
-  }
-
-  /**
-   * Simple 'debug' logging of stats.
-   */
-  private synchronized void logStats() {
-    FLog.v(TAG, "Count = %d", mMap.size());
-  }
 
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/ValueDescriptor.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/ValueDescriptor.java
index a6dea3fc7..b35264483 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/ValueDescriptor.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/ValueDescriptor.java
@@ -13,6 +13,8 @@
  */
 public interface ValueDescriptor<V> {
 
-  /** Returns the size in bytes of the given value. */
-  int getSizeInBytes(V value);
+    /**
+     * Returns the size in bytes of the given value.
+     */
+    int getSizeInBytes(V value);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptions.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptions.java
index 980b833dd..cc1629f76 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptions.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptions.java
@@ -17,87 +17,87 @@
 @Immutable
 public class ImageDecodeOptions {
 
-  private static final ImageDecodeOptions DEFAULTS = ImageDecodeOptions.newBuilder().build();
-
-  /**
-   * Decoding of intermediate results for an image won't happen more often that minDecodeIntervalMs.
-   */
-  public final int minDecodeIntervalMs;
-
-  /**
-   * Background color used when converting to image formats that don't support transparency.
-   */
-  public final int backgroundColor;
-
-  /**
-   * Forces use of the old animation drawable code that we're in process of deprecating.
-   */
-  public final boolean forceOldAnimationCode;
-
-  /**
-   * Whether to decode a preview frame for animated images.
-   */
-  public final boolean decodePreviewFrame;
-
-  /**
-   * Indicates that the last frame should be used as the preview frame instead of the first.
-   */
-  public final boolean useLastFrameForPreview;
-
-  /**
-   * Whether to decode all the frames and store them in memory. This should only ever be used
-   * for animations that are known to be small (e.g. stickers). Caching dozens of large Bitmaps
-   * in memory for general GIFs or WebP's will not fit in memory.
-   */
-  public final boolean decodeAllFrames;
-
-  ImageDecodeOptions(ImageDecodeOptionsBuilder b) {
-    this.minDecodeIntervalMs = b.getMinDecodeIntervalMs();
-    this.backgroundColor = b.getBackgroundColor();
-    this.forceOldAnimationCode = b.getForceOldAnimationCode();
-    this.decodePreviewFrame = b.getDecodePreviewFrame();
-    this.useLastFrameForPreview = b.getUseLastFrameForPreview();
-    this.decodeAllFrames = b.getDecodeAllFrames();
-  }
-
-  /**
-   * Gets the default options.
-   *
-   * @return  the default options
-   */
-  public static ImageDecodeOptions defaults() {
-    return DEFAULTS;
-  }
-
-  /**
-   * Creates a new builder.
-   *
-   * @return a new builder
-   */
-  public static ImageDecodeOptionsBuilder newBuilder() {
-    return new ImageDecodeOptionsBuilder();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    ImageDecodeOptions that = (ImageDecodeOptions) o;
-
-    if (backgroundColor != that.backgroundColor) return false;
-    if (forceOldAnimationCode != that.forceOldAnimationCode) return false;
-    if (decodePreviewFrame != that.decodePreviewFrame) return false;
-    if (useLastFrameForPreview != that.useLastFrameForPreview) return false;
-    if (decodeAllFrames != that.decodeAllFrames) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    int result = backgroundColor;
-    result = 31 * result + (forceOldAnimationCode ? 1 : 0);
-    return result;
-  }
+    private static final ImageDecodeOptions DEFAULTS = ImageDecodeOptions.newBuilder().build();
+
+    /**
+     * Decoding of intermediate results for an image won't happen more often that minDecodeIntervalMs.
+     */
+    public final int minDecodeIntervalMs;
+
+    /**
+     * Background color used when converting to image formats that don't support transparency.
+     */
+    public final int backgroundColor;
+
+    /**
+     * Forces use of the old animation drawable code that we're in process of deprecating.
+     */
+    public final boolean forceOldAnimationCode;
+
+    /**
+     * Whether to decode a preview frame for animated images.
+     */
+    public final boolean decodePreviewFrame;
+
+    /**
+     * Indicates that the last frame should be used as the preview frame instead of the first.
+     */
+    public final boolean useLastFrameForPreview;
+
+    /**
+     * Whether to decode all the frames and store them in memory. This should only ever be used
+     * for animations that are known to be small (e.g. stickers). Caching dozens of large Bitmaps
+     * in memory for general GIFs or WebP's will not fit in memory.
+     */
+    public final boolean decodeAllFrames;
+
+    ImageDecodeOptions(ImageDecodeOptionsBuilder b) {
+        this.minDecodeIntervalMs = b.getMinDecodeIntervalMs();
+        this.backgroundColor = b.getBackgroundColor();
+        this.forceOldAnimationCode = b.getForceOldAnimationCode();
+        this.decodePreviewFrame = b.getDecodePreviewFrame();
+        this.useLastFrameForPreview = b.getUseLastFrameForPreview();
+        this.decodeAllFrames = b.getDecodeAllFrames();
+    }
+
+    /**
+     * Gets the default options.
+     *
+     * @return the default options
+     */
+    public static ImageDecodeOptions defaults() {
+        return DEFAULTS;
+    }
+
+    /**
+     * Creates a new builder.
+     *
+     * @return a new builder
+     */
+    public static ImageDecodeOptionsBuilder newBuilder() {
+        return new ImageDecodeOptionsBuilder();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        ImageDecodeOptions that = (ImageDecodeOptions) o;
+
+        if (backgroundColor != that.backgroundColor) return false;
+        if (forceOldAnimationCode != that.forceOldAnimationCode) return false;
+        if (decodePreviewFrame != that.decodePreviewFrame) return false;
+        if (useLastFrameForPreview != that.useLastFrameForPreview) return false;
+        if (decodeAllFrames != that.decodeAllFrames) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = backgroundColor;
+        result = 31 * result + (forceOldAnimationCode ? 1 : 0);
+        return result;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptionsBuilder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptionsBuilder.java
index bff0b0159..3a353b44a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptionsBuilder.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ImageDecodeOptionsBuilder.java
@@ -14,168 +14,169 @@
  */
 public class ImageDecodeOptionsBuilder {
 
-  private int mMinDecodeIntervalMs = 100;
-  private int mBackgroundColor = 0xFFFFFF;
-  private boolean mForceOldAnimationCode;
-  private boolean mDecodePreviewFrame;
-  private boolean mUseLastFrameForPreview;
-  private boolean mDecodeAllFrames;
-
-  ImageDecodeOptionsBuilder() {
-  }
-
-  /**
-   * Sets the builder to be equivalent to the specified options.
-   *
-   * @param options the options to copy from
-   * @return this builder
-   */
-  public ImageDecodeOptionsBuilder setFrom(ImageDecodeOptions options) {
-    mBackgroundColor = options.backgroundColor;
-    mForceOldAnimationCode = options.forceOldAnimationCode;
-    mDecodePreviewFrame = options.decodePreviewFrame;
-    mUseLastFrameForPreview = options.useLastFrameForPreview;
-    mDecodeAllFrames = options.decodeAllFrames;
-    return this;
-  }
-
-  /**
-   * Sets the minimum decode interval.
-   *
-   * <p/> Decoding of intermediate results won't happen more often that intervalMs. If another
-   * intermediate result comes too soon, it will be decoded only after intervalMs since the last
-   * decode. If there were more intermediate results in between, only the last one gets decoded.
-   * @param intervalMs the minimum decode interval in milliseconds
-   * @return this builder
-   */
-  public ImageDecodeOptionsBuilder setMinDecodeIntervalMs(int intervalMs) {
-    mMinDecodeIntervalMs = intervalMs;
-    return this;
-  }
-
-  /**
-   * Gets the minimum decode interval.
-   *
-   * @return the minimum decode interval in milliseconds
-   */
-  public int getMinDecodeIntervalMs() {
-    return mMinDecodeIntervalMs;
-  }
-
-  /**
-   * Sets the background color used when converting to image formats that don't support
-   * transparency.
-   *
-   * @param backgroundColor the background color to use
-   * @return this builder
-   */
-  public ImageDecodeOptionsBuilder setBackgroundColor(int backgroundColor) {
-    mBackgroundColor = backgroundColor;
-    return this;
-  }
-
-  /**
-   * Gets the background color used when converting to image formats that don't support
-   * transparency.
-   *
-   * @return the background color to use
-   */
-  public int getBackgroundColor() {
-    return mBackgroundColor;
-  }
-
-  /**
-   * Sets whether to force use of the old animation drawable code that we're in process of
-   * deprecating.
-   *
-   * @param forceOldAnimationCode whether to force use of the old animation drawable code
-   * @return this builder
-   */
-  public ImageDecodeOptionsBuilder setForceOldAnimationCode(boolean forceOldAnimationCode) {
-    mForceOldAnimationCode = forceOldAnimationCode;
-    return this;
-  }
-
-  /**
-   * Gets whether to force use of the old animation drawable code that we're in process of
-   * deprecating.
-   *
-   * @return whether to force use of the old animation drawable code
-   */
-  public boolean getForceOldAnimationCode() {
-    return mForceOldAnimationCode;
-  }
-
-  /**
-   * Sets whether to decode a preview frame for animated images.
-   *
-   * @param decodePreviewFrame whether to decode a preview frame
-   * @return this builder
-   */
-  public ImageDecodeOptionsBuilder setDecodePreviewFrame(boolean decodePreviewFrame) {
-    mDecodePreviewFrame = decodePreviewFrame;
-    return this;
-  }
-
-  /**
-   * Gets whether to decode a preview frame for animated images.
-   *
-   * @return whether to decode a preview frame
-   */
-  public boolean getDecodePreviewFrame() {
-    return mDecodePreviewFrame;
-  }
-
-  /**
-   * Gets whether to use the last frame for the preview image (defaults to the first frame).
-   *
-   * @return whether to use the last frame for the preview image
-   */
-  public boolean getUseLastFrameForPreview() {
-    return mUseLastFrameForPreview;
-  }
-
-  /**
-   * Sets whether to use the last frame for the preview image (defaults to the first frame).
-   *
-   * @param useLastFrameForPreview whether to use the last frame for the preview image
-   * @return this builder
-   */
-  public ImageDecodeOptionsBuilder setUseLastFrameForPreview(boolean useLastFrameForPreview) {
-    mUseLastFrameForPreview = useLastFrameForPreview;
-    return this;
-  }
-
-  /**
-   * Gets whether to decode all the frames and store them in memory. This should only ever be used
-   * for animations that are known to be small (e.g. stickers). Caching dozens of large Bitmaps
-   * in memory for general GIFs or WebP's will not fit in memory.
-   *
-   * @return whether to decode all the frames and store them in memory
-   */
-  public boolean getDecodeAllFrames() {
-    return mDecodeAllFrames;
-  }
-
-  /**
-   * Sets whether to decode all the frames and store them in memory. This should only ever be used
-   * for animations that are known to be small (e.g. stickers). Caching dozens of large Bitmaps
-   * in memory for general GIFs or WebP's will not fit in memory.
-   *
-   * @param decodeAllFrames whether to decode all the frames and store them in memory
-   * @return this builder
-   */
-  public ImageDecodeOptionsBuilder setDecodeAllFrames(boolean decodeAllFrames) {
-    mDecodeAllFrames = decodeAllFrames;
-    return this;
-  }
-
-  /**
-   * Builds the immutable {@link ImageDecodeOptions} instance.
-   *
-   * @return the immutable instance
-   */
-  public ImageDecodeOptions build() {
-    return new ImageDecodeOptions(this);
-  }
+    private int mMinDecodeIntervalMs = 100;
+    private int mBackgroundColor = 0xFFFFFF;
+    private boolean mForceOldAnimationCode;
+    private boolean mDecodePreviewFrame;
+    private boolean mUseLastFrameForPreview;
+    private boolean mDecodeAllFrames;
+
+    ImageDecodeOptionsBuilder() {
+    }
+
+    /**
+     * Sets the builder to be equivalent to the specified options.
+     *
+     * @param options the options to copy from
+     * @return this builder
+     */
+    public ImageDecodeOptionsBuilder setFrom(ImageDecodeOptions options) {
+        mBackgroundColor = options.backgroundColor;
+        mForceOldAnimationCode = options.forceOldAnimationCode;
+        mDecodePreviewFrame = options.decodePreviewFrame;
+        mUseLastFrameForPreview = options.useLastFrameForPreview;
+        mDecodeAllFrames = options.decodeAllFrames;
+        return this;
+    }
+
+    /**
+     * Sets the minimum decode interval.
+     * <p>
+     * <p/> Decoding of intermediate results won't happen more often that intervalMs. If another
+     * intermediate result comes too soon, it will be decoded only after intervalMs since the last
+     * decode. If there were more intermediate results in between, only the last one gets decoded.
+     *
+     * @param intervalMs the minimum decode interval in milliseconds
+     * @return this builder
+     */
+    public ImageDecodeOptionsBuilder setMinDecodeIntervalMs(int intervalMs) {
+        mMinDecodeIntervalMs = intervalMs;
+        return this;
+    }
+
+    /**
+     * Gets the minimum decode interval.
+     *
+     * @return the minimum decode interval in milliseconds
+     */
+    public int getMinDecodeIntervalMs() {
+        return mMinDecodeIntervalMs;
+    }
+
+    /**
+     * Sets the background color used when converting to image formats that don't support
+     * transparency.
+     *
+     * @param backgroundColor the background color to use
+     * @return this builder
+     */
+    public ImageDecodeOptionsBuilder setBackgroundColor(int backgroundColor) {
+        mBackgroundColor = backgroundColor;
+        return this;
+    }
+
+    /**
+     * Gets the background color used when converting to image formats that don't support
+     * transparency.
+     *
+     * @return the background color to use
+     */
+    public int getBackgroundColor() {
+        return mBackgroundColor;
+    }
+
+    /**
+     * Sets whether to force use of the old animation drawable code that we're in process of
+     * deprecating.
+     *
+     * @param forceOldAnimationCode whether to force use of the old animation drawable code
+     * @return this builder
+     */
+    public ImageDecodeOptionsBuilder setForceOldAnimationCode(boolean forceOldAnimationCode) {
+        mForceOldAnimationCode = forceOldAnimationCode;
+        return this;
+    }
+
+    /**
+     * Gets whether to force use of the old animation drawable code that we're in process of
+     * deprecating.
+     *
+     * @return whether to force use of the old animation drawable code
+     */
+    public boolean getForceOldAnimationCode() {
+        return mForceOldAnimationCode;
+    }
+
+    /**
+     * Sets whether to decode a preview frame for animated images.
+     *
+     * @param decodePreviewFrame whether to decode a preview frame
+     * @return this builder
+     */
+    public ImageDecodeOptionsBuilder setDecodePreviewFrame(boolean decodePreviewFrame) {
+        mDecodePreviewFrame = decodePreviewFrame;
+        return this;
+    }
+
+    /**
+     * Gets whether to decode a preview frame for animated images.
+     *
+     * @return whether to decode a preview frame
+     */
+    public boolean getDecodePreviewFrame() {
+        return mDecodePreviewFrame;
+    }
+
+    /**
+     * Gets whether to use the last frame for the preview image (defaults to the first frame).
+     *
+     * @return whether to use the last frame for the preview image
+     */
+    public boolean getUseLastFrameForPreview() {
+        return mUseLastFrameForPreview;
+    }
+
+    /**
+     * Sets whether to use the last frame for the preview image (defaults to the first frame).
+     *
+     * @param useLastFrameForPreview whether to use the last frame for the preview image
+     * @return this builder
+     */
+    public ImageDecodeOptionsBuilder setUseLastFrameForPreview(boolean useLastFrameForPreview) {
+        mUseLastFrameForPreview = useLastFrameForPreview;
+        return this;
+    }
+
+    /**
+     * Gets whether to decode all the frames and store them in memory. This should only ever be used
+     * for animations that are known to be small (e.g. stickers). Caching dozens of large Bitmaps
+     * in memory for general GIFs or WebP's will not fit in memory.
+     *
+     * @return whether to decode all the frames and store them in memory
+     */
+    public boolean getDecodeAllFrames() {
+        return mDecodeAllFrames;
+    }
+
+    /**
+     * Sets whether to decode all the frames and store them in memory. This should only ever be used
+     * for animations that are known to be small (e.g. stickers). Caching dozens of large Bitmaps
+     * in memory for general GIFs or WebP's will not fit in memory.
+     *
+     * @param decodeAllFrames whether to decode all the frames and store them in memory
+     * @return this builder
+     */
+    public ImageDecodeOptionsBuilder setDecodeAllFrames(boolean decodeAllFrames) {
+        mDecodeAllFrames = decodeAllFrames;
+        return this;
+    }
+
+    /**
+     * Builds the immutable {@link ImageDecodeOptions} instance.
+     *
+     * @return the immutable instance
+     */
+    public ImageDecodeOptions build() {
+        return new ImageDecodeOptions(this);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/Priority.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/common/Priority.java
index e108c08b0..3f12b31ed 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/Priority.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/common/Priority.java
@@ -15,46 +15,47 @@
  * Priority levels recognized by the image pipeline.
  */
 public enum Priority {
-  /**
-   * NOTE: DO NOT CHANGE ORDERING OF THOSE CONSTANTS UNDER ANY CIRCUMSTANCES.
-   * Doing so will make ordering incorrect.
-   */
-
-  /**
-   * Lowest priority level. Used for prefetches of non-visible images.
-   */
-  LOW,
-
-  /**
-   * Medium priority level. Used for warming of images that might soon get visible.
-   */
-  MEDIUM,
-
-  /**
-   * Highest priority level. Used for images that are currently visible on screen.
-   */
-  HIGH;
-
-  /**
-   * Gets the higher priority among the two.
-   * @param priority1
-   * @param priority2
-   * @return higher priority
-   */
-  public static Priority getHigherPriority(
-      @Nullable Priority priority1,
-      @Nullable Priority priority2) {
-    if (priority1 == null) {
-      return priority2;
+    /**
+     * NOTE: DO NOT CHANGE ORDERING OF THOSE CONSTANTS UNDER ANY CIRCUMSTANCES.
+     * Doing so will make ordering incorrect.
+     */
+
+    /**
+     * Lowest priority level. Used for prefetches of non-visible images.
+     */
+    LOW,
+
+    /**
+     * Medium priority level. Used for warming of images that might soon get visible.
+     */
+    MEDIUM,
+
+    /**
+     * Highest priority level. Used for images that are currently visible on screen.
+     */
+    HIGH;
+
+    /**
+     * Gets the higher priority among the two.
+     *
+     * @param priority1
+     * @param priority2
+     * @return higher priority
+     */
+    public static Priority getHigherPriority(
+            @Nullable Priority priority1,
+            @Nullable Priority priority2) {
+        if (priority1 == null) {
+            return priority2;
+        }
+        if (priority2 == null) {
+            return priority1;
+        }
+        if (priority1.ordinal() > priority2.ordinal()) {
+            return priority1;
+        } else {
+            return priority2;
+        }
     }
-    if (priority2 == null) {
-      return priority1;
-    }
-    if (priority1.ordinal() > priority2.ordinal()) {
-      return priority1;
-    } else {
-      return priority2;
-    }
-  }
 
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ResizeOptions.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ResizeOptions.java
index 426624a6a..e800e4d6d 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ResizeOptions.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/common/ResizeOptions.java
@@ -16,49 +16,49 @@
 
 /**
  * Options for resizing.
- *
+ * <p>
  * <p> Describes the target bounds for the image (width, height) in pixels, as well as the
  * downscaling policy to employ.
  */
 public class ResizeOptions {
 
-  /* target width (in pixels) */
-  public final int width;
-
-  /* target height (in pixels) */
-  public final int height;
+    /* target width (in pixels) */
+    public final int width;
 
-  public ResizeOptions(
-      int width,
-      int height) {
-    Preconditions.checkArgument(width > 0);
-    Preconditions.checkArgument(height > 0);
-    this.width = width;
-    this.height = height;
-  }
+    /* target height (in pixels) */
+    public final int height;
 
-  @Override
-  public int hashCode() {
-    return HashCodeUtil.hashCode(
-        width,
-        height);
-  }
+    public ResizeOptions(
+            int width,
+            int height) {
+        Preconditions.checkArgument(width > 0);
+        Preconditions.checkArgument(height > 0);
+        this.width = width;
+        this.height = height;
+    }
 
-  @Override
-  public boolean equals(Object other) {
-    if (other == this) {
-      return true;
+    @Override
+    public int hashCode() {
+        return HashCodeUtil.hashCode(
+                width,
+                height);
     }
-    if (!(other instanceof ResizeOptions)) {
-      return false;
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof ResizeOptions)) {
+            return false;
+        }
+        ResizeOptions that = (ResizeOptions) other;
+        return this.width == that.width &&
+                this.height == that.height;
     }
-    ResizeOptions that = (ResizeOptions) other;
-    return this.width == that.width &&
-        this.height == that.height;
-  }
 
-  @Override
-  public String toString() {
-    return String.format((Locale) null, "%dx%d", width, height);
-  }
+    @Override
+    public String toString() {
+        return String.format((Locale) null, "%dx%d", width, height);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DefaultExecutorSupplier.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DefaultExecutorSupplier.java
index dcd8de175..a150a6957 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DefaultExecutorSupplier.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/DefaultExecutorSupplier.java
@@ -19,53 +19,53 @@
 
 /**
  * Basic implementation of {@link ExecutorSupplier}.
- *
+ * <p>
  * <p> Provides one thread pool for the CPU-bound operations and another thread pool for the
  * IO-bound operations. Decoding, a CPU-intensive operation, is limited to one thread.
  */
 public class DefaultExecutorSupplier implements ExecutorSupplier {
-  // Allows for simultaneous reads and writes.
-  private static final int NUM_IO_BOUND_THREADS = 2;
-  private static final int NUM_CPU_BOUND_THREADS = Runtime.getRuntime().availableProcessors();
-  private static final int KEEP_ALIVE_SECONDS = 60;
+    // Allows for simultaneous reads and writes.
+    private static final int NUM_IO_BOUND_THREADS = 2;
+    private static final int NUM_CPU_BOUND_THREADS = Runtime.getRuntime().availableProcessors();
+    private static final int KEEP_ALIVE_SECONDS = 60;
 
-  private final Executor mIoBoundExecutor;
-  private final Executor mCpuBoundExecutor;
-  private final Executor mDecodeExecutor;
+    private final Executor mIoBoundExecutor;
+    private final Executor mCpuBoundExecutor;
+    private final Executor mDecodeExecutor;
 
-  public DefaultExecutorSupplier() {
-    mIoBoundExecutor = Executors.newFixedThreadPool(NUM_IO_BOUND_THREADS);
-    mCpuBoundExecutor = new ThreadPoolExecutor(
-        1,                     // keep at least that many threads alive
-        NUM_CPU_BOUND_THREADS, // maximum number of allowed threads
-        KEEP_ALIVE_SECONDS,    // amount of seconds each cached thread waits before being terminated
-        TimeUnit.SECONDS,
-        new LinkedBlockingQueue<Runnable>());
-    mDecodeExecutor = new SerialDelegatingExecutor(mCpuBoundExecutor);
-  }
+    public DefaultExecutorSupplier() {
+        mIoBoundExecutor = Executors.newFixedThreadPool(NUM_IO_BOUND_THREADS);
+        mCpuBoundExecutor = new ThreadPoolExecutor(
+                1,                     // keep at least that many threads alive
+                NUM_CPU_BOUND_THREADS, // maximum number of allowed threads
+                KEEP_ALIVE_SECONDS,    // amount of seconds each cached thread waits before being terminated
+                TimeUnit.SECONDS,
+                new LinkedBlockingQueue<Runnable>());
+        mDecodeExecutor = new SerialDelegatingExecutor(mCpuBoundExecutor);
+    }
 
-  @Override
-  public Executor forLocalStorageRead() {
-    return mIoBoundExecutor;
-  }
+    @Override
+    public Executor forLocalStorageRead() {
+        return mIoBoundExecutor;
+    }
 
-  @Override
-  public Executor forLocalStorageWrite() {
-    return mIoBoundExecutor;
-  }
+    @Override
+    public Executor forLocalStorageWrite() {
+        return mIoBoundExecutor;
+    }
 
-  @Override
-  public Executor forDecode() {
-    return mDecodeExecutor;
-  }
+    @Override
+    public Executor forDecode() {
+        return mDecodeExecutor;
+    }
 
-  @Override
-  public Executor forTransform() {
-    return mCpuBoundExecutor;
-  }
+    @Override
+    public Executor forTransform() {
+        return mCpuBoundExecutor;
+    }
 
-  @Override
-  public Executor forBackground() {
-    return mCpuBoundExecutor;
-  }
+    @Override
+    public Executor forBackground() {
+        return mCpuBoundExecutor;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ExecutorSupplier.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ExecutorSupplier.java
index 7331a12ac..af17a9793 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ExecutorSupplier.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ExecutorSupplier.java
@@ -14,29 +14,39 @@
 /**
  * Implementations of this interface are responsible for supplying the different executors
  * used by different sections of the image pipeline.
- *
+ * <p>
  * <p>A very basic implementation would supply a single thread pool for all four operations.
  * It is recommended that {@link #forLocalStorageRead} and {@link #forLocalStorageWrite} at least
  * be different, as their threads will be I/O-bound, rather than CPU-bound as the others are.
- *
+ * <p>
  * <p>Implementations should return singleton objects from these methods.
- *
+ * <p>
  * <p>{@see Executor}
  */
 public interface ExecutorSupplier {
 
-  /** Executor used to do all disk reads, whether for disk cache or local files. */
-  Executor forLocalStorageRead();
-
-  /** Executor used to do all disk writes, whether for disk cache or local files. */
-  Executor forLocalStorageWrite();
-
-  /** Executor used for all decodes. */
-  Executor forDecode();
-
-  /** Executor used for all image transformations, such as transcoding, resizing, and rotating. */
-  Executor forTransform();
-
-  /** Executor used for background operations, such as postprocessing. */
-  Executor forBackground();
+    /**
+     * Executor used to do all disk reads, whether for disk cache or local files.
+     */
+    Executor forLocalStorageRead();
+
+    /**
+     * Executor used to do all disk writes, whether for disk cache or local files.
+     */
+    Executor forLocalStorageWrite();
+
+    /**
+     * Executor used for all decodes.
+     */
+    Executor forDecode();
+
+    /**
+     * Executor used for all image transformations, such as transcoding, resizing, and rotating.
+     */
+    Executor forTransform();
+
+    /**
+     * Executor used for background operations, such as postprocessing.
+     */
+    Executor forBackground();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
index a3f46d8d7..780b700b4 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
@@ -46,270 +46,279 @@
  */
 @ThreadSafe
 public class ImagePipeline {
-  private static final CancellationException PREFETCH_EXCEPTION =
-      new CancellationException("Prefetching is not enabled");
+    private static final CancellationException PREFETCH_EXCEPTION =
+            new CancellationException("Prefetching is not enabled");
 
-  private final ProducerSequenceFactory mProducerSequenceFactory;
-  private final RequestListener mRequestListener;
-  private final Supplier<Boolean> mIsPrefetchEnabledSupplier;
-  private final MemoryCache<CacheKey, CloseableImage> mBitmapMemoryCache;
-  private final MemoryCache<CacheKey, PooledByteBuffer> mEncodedMemoryCache;
-  private final CacheKeyFactory mCacheKeyFactory;
+    private final ProducerSequenceFactory mProducerSequenceFactory;
+    private final RequestListener mRequestListener;
+    private final Supplier<Boolean> mIsPrefetchEnabledSupplier;
+    private final MemoryCache<CacheKey, CloseableImage> mBitmapMemoryCache;
+    private final MemoryCache<CacheKey, PooledByteBuffer> mEncodedMemoryCache;
+    private final CacheKeyFactory mCacheKeyFactory;
 
-  private AtomicLong mIdCounter;
+    private AtomicLong mIdCounter;
 
-  public ImagePipeline(
-      ProducerSequenceFactory producerSequenceFactory,
-      Set<RequestListener> requestListeners,
-      Supplier<Boolean> isPrefetchEnabledSupplier,
-      MemoryCache<CacheKey, CloseableImage> bitmapMemoryCache,
-      MemoryCache<CacheKey, PooledByteBuffer> encodedMemoryCache,
-      CacheKeyFactory cacheKeyFactory) {
-    mIdCounter = new AtomicLong();
-    mProducerSequenceFactory = producerSequenceFactory;
-    mRequestListener = new ForwardingRequestListener(requestListeners);
-    mIsPrefetchEnabledSupplier = isPrefetchEnabledSupplier;
-    mBitmapMemoryCache = bitmapMemoryCache;
-    mEncodedMemoryCache = encodedMemoryCache;
-    mCacheKeyFactory = cacheKeyFactory;
-  }
+    public ImagePipeline(
+            ProducerSequenceFactory producerSequenceFactory,
+            Set<RequestListener> requestListeners,
+            Supplier<Boolean> isPrefetchEnabledSupplier,
+            MemoryCache<CacheKey, CloseableImage> bitmapMemoryCache,
+            MemoryCache<CacheKey, PooledByteBuffer> encodedMemoryCache,
+            CacheKeyFactory cacheKeyFactory) {
+        mIdCounter = new AtomicLong();
+        mProducerSequenceFactory = producerSequenceFactory;
+        mRequestListener = new ForwardingRequestListener(requestListeners);
+        mIsPrefetchEnabledSupplier = isPrefetchEnabledSupplier;
+        mBitmapMemoryCache = bitmapMemoryCache;
+        mEncodedMemoryCache = encodedMemoryCache;
+        mCacheKeyFactory = cacheKeyFactory;
+    }
 
-  /**
-   * Generates unique id for RequestFuture.
-   * @return unique id
-   */
-  private String generateUniqueFutureId() {
-    return String.valueOf(mIdCounter.getAndIncrement());
-  }
+    /**
+     * Generates unique id for RequestFuture.
+     *
+     * @return unique id
+     */
+    private String generateUniqueFutureId() {
+        return String.valueOf(mIdCounter.getAndIncrement());
+    }
 
-  /**
-   * Returns a DataSource supplier that will on get submit the request for execution and return a
-   * DataSource representing the pending results of the task.
-   * @param imageRequest the request to submit (what to execute).
-   * @param bitmapCacheOnly whether to only look for the image in the bitmap cache
-   * @return a DataSource representing pending results and completion of the request
-   */
-  public Supplier<DataSource<CloseableReference<CloseableImage>>> getDataSourceSupplier(
-      final ImageRequest imageRequest,
-      final Object callerContext,
-      final boolean bitmapCacheOnly) {
-    return new Supplier<DataSource<CloseableReference<CloseableImage>>>() {
-      @Override
-      public DataSource<CloseableReference<CloseableImage>> get() {
-        if (bitmapCacheOnly) {
-          return fetchImageFromBitmapCache(imageRequest, callerContext);
-        } else {
-          return fetchDecodedImage(imageRequest, callerContext);
-        }
-      }
-      @Override
-      public String toString() {
-        return Objects.toStringHelper(this)
-            .add("uri", imageRequest.getSourceUri())
-            .toString();
-      }
-    };
-  }
+    /**
+     * Returns a DataSource supplier that will on get submit the request for execution and return a
+     * DataSource representing the pending results of the task.
+     *
+     * @param imageRequest    the request to submit (what to execute).
+     * @param bitmapCacheOnly whether to only look for the image in the bitmap cache
+     * @return a DataSource representing pending results and completion of the request
+     */
+    public Supplier<DataSource<CloseableReference<CloseableImage>>> getDataSourceSupplier(
+            final ImageRequest imageRequest,
+            final Object callerContext,
+            final boolean bitmapCacheOnly) {
+        return new Supplier<DataSource<CloseableReference<CloseableImage>>>() {
+            @Override
+            public DataSource<CloseableReference<CloseableImage>> get() {
+                if (bitmapCacheOnly) {
+                    return fetchImageFromBitmapCache(imageRequest, callerContext);
+                } else {
+                    return fetchDecodedImage(imageRequest, callerContext);
+                }
+            }
 
-  /**
-   * Submits a request for bitmap cache lookup.
-   * @param imageRequest the request to submit
-   * @return a DataSource representing the image
-   */
-  public DataSource<CloseableReference<CloseableImage>> fetchImageFromBitmapCache(
-      ImageRequest imageRequest,
-      Object callerContext) {
-    try {
-      Producer<CloseableReference<CloseableImage>> producerSequence =
-          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);
-      return submitFetchRequest(
-          producerSequence,
-          imageRequest,
-          ImageRequest.RequestLevel.BITMAP_MEMORY_CACHE,
-          callerContext);
-    } catch (Exception exception) {
-      return DataSources.immediateFailedDataSource(exception);
+            @Override
+            public String toString() {
+                return Objects.toStringHelper(this)
+                        .add("uri", imageRequest.getSourceUri())
+                        .toString();
+            }
+        };
     }
-  }
 
-  /**
-   * Submits a request for execution and returns a DataSource representing the pending decoded
-   * image(s).
-   *
-   * <p>The returned DataSource must be closed once the client has finished with it.
-   * @param imageRequest the request to submit
-   * @return a DataSource representing the pending decoded image(s)
-   */
-  public DataSource<CloseableReference<CloseableImage>> fetchDecodedImage(
-      ImageRequest imageRequest,
-      Object callerContext) {
-    try {
-      Producer<CloseableReference<CloseableImage>> producerSequence =
-          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);
-      return submitFetchRequest(
-          producerSequence,
-          imageRequest,
-          ImageRequest.RequestLevel.FULL_FETCH,
-          callerContext);
-    } catch (Exception exception) {
-      return DataSources.immediateFailedDataSource(exception);
+    /**
+     * Submits a request for bitmap cache lookup.
+     *
+     * @param imageRequest the request to submit
+     * @return a DataSource representing the image
+     */
+    public DataSource<CloseableReference<CloseableImage>> fetchImageFromBitmapCache(
+            ImageRequest imageRequest,
+            Object callerContext) {
+        try {
+            Producer<CloseableReference<CloseableImage>> producerSequence =
+                    mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);
+            return submitFetchRequest(
+                    producerSequence,
+                    imageRequest,
+                    ImageRequest.RequestLevel.BITMAP_MEMORY_CACHE,
+                    callerContext);
+        } catch (Exception exception) {
+            return DataSources.immediateFailedDataSource(exception);
+        }
     }
-  }
 
-  /**
-   * Submits a request for execution and returns a DataSource representing the pending encoded
-   * image(s).
-   *
-   * <p>The returned DataSource must be closed once the client has finished with it.
-   * @param imageRequest the request to submit
-   * @return a DataSource representing the pending encoded image(s)
-   */
-  public DataSource<CloseableReference<PooledByteBuffer>> fetchEncodedImage(
-      ImageRequest imageRequest,
-      Object callerContext) {
-    try {
-      Producer<CloseableReference<PooledByteBuffer>> producerSequence =
-          mProducerSequenceFactory.getEncodedImageProducerSequence(imageRequest);
-      return submitFetchRequest(
-          producerSequence,
-          imageRequest,
-          ImageRequest.RequestLevel.FULL_FETCH,
-          callerContext);
-    } catch (Exception exception) {
-      return DataSources.immediateFailedDataSource(exception);
+    /**
+     * Submits a request for execution and returns a DataSource representing the pending decoded
+     * image(s).
+     * <p>
+     * <p>The returned DataSource must be closed once the client has finished with it.
+     *
+     * @param imageRequest the request to submit
+     * @return a DataSource representing the pending decoded image(s)
+     */
+    public DataSource<CloseableReference<CloseableImage>> fetchDecodedImage(
+            ImageRequest imageRequest,
+            Object callerContext) {
+        try {
+            Producer<CloseableReference<CloseableImage>> producerSequence =
+                    mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);
+            return submitFetchRequest(
+                    producerSequence,
+                    imageRequest,
+                    ImageRequest.RequestLevel.FULL_FETCH,
+                    callerContext);
+        } catch (Exception exception) {
+            return DataSources.immediateFailedDataSource(exception);
+        }
     }
-  }
 
-  /**
-   * Submits a request for prefetching to the bitmap cache.
-   * @param imageRequest the request to submit
-   * @return a DataSource that can safely be ignored.
-   */
-  public DataSource<Void> prefetchToBitmapCache(
-      ImageRequest imageRequest,
-      Object callerContext) {
-    if (!mIsPrefetchEnabledSupplier.get()) {
-      return DataSources.immediateFailedDataSource(PREFETCH_EXCEPTION);
-    }
-    try {
-      Producer<Void> producerSequence =
-          mProducerSequenceFactory.getDecodedImagePrefetchProducerSequence(imageRequest);
-      return submitPrefetchRequest(
-          producerSequence,
-          imageRequest,
-          ImageRequest.RequestLevel.FULL_FETCH,
-          callerContext);
-    } catch (Exception exception) {
-      return DataSources.immediateFailedDataSource(exception);
+    /**
+     * Submits a request for execution and returns a DataSource representing the pending encoded
+     * image(s).
+     * <p>
+     * <p>The returned DataSource must be closed once the client has finished with it.
+     *
+     * @param imageRequest the request to submit
+     * @return a DataSource representing the pending encoded image(s)
+     */
+    public DataSource<CloseableReference<PooledByteBuffer>> fetchEncodedImage(
+            ImageRequest imageRequest,
+            Object callerContext) {
+        try {
+            Producer<CloseableReference<PooledByteBuffer>> producerSequence =
+                    mProducerSequenceFactory.getEncodedImageProducerSequence(imageRequest);
+            return submitFetchRequest(
+                    producerSequence,
+                    imageRequest,
+                    ImageRequest.RequestLevel.FULL_FETCH,
+                    callerContext);
+        } catch (Exception exception) {
+            return DataSources.immediateFailedDataSource(exception);
+        }
     }
-  }
 
-  /**
-   * Submits a request for prefetching to the disk cache.
-   * @param imageRequest the request to submit
-   * @return a DataSource that can safely be ignored.
-   */
-  public DataSource<Void> prefetchToDiskCache(
-      ImageRequest imageRequest,
-      Object callerContext) {
-    if (!mIsPrefetchEnabledSupplier.get()) {
-      return DataSources.immediateFailedDataSource(PREFETCH_EXCEPTION);
+    /**
+     * Submits a request for prefetching to the bitmap cache.
+     *
+     * @param imageRequest the request to submit
+     * @return a DataSource that can safely be ignored.
+     */
+    public DataSource<Void> prefetchToBitmapCache(
+            ImageRequest imageRequest,
+            Object callerContext) {
+        if (!mIsPrefetchEnabledSupplier.get()) {
+            return DataSources.immediateFailedDataSource(PREFETCH_EXCEPTION);
+        }
+        try {
+            Producer<Void> producerSequence =
+                    mProducerSequenceFactory.getDecodedImagePrefetchProducerSequence(imageRequest);
+            return submitPrefetchRequest(
+                    producerSequence,
+                    imageRequest,
+                    ImageRequest.RequestLevel.FULL_FETCH,
+                    callerContext);
+        } catch (Exception exception) {
+            return DataSources.immediateFailedDataSource(exception);
+        }
     }
-    try {
-      Producer<Void> producerSequence =
-          mProducerSequenceFactory.getEncodedImagePrefetchProducerSequence(imageRequest);
-      return submitPrefetchRequest(
-          producerSequence,
-          imageRequest,
-          ImageRequest.RequestLevel.FULL_FETCH,
-          callerContext);
-    } catch (Exception exception) {
-      return DataSources.immediateFailedDataSource(exception);
+
+    /**
+     * Submits a request for prefetching to the disk cache.
+     *
+     * @param imageRequest the request to submit
+     * @return a DataSource that can safely be ignored.
+     */
+    public DataSource<Void> prefetchToDiskCache(
+            ImageRequest imageRequest,
+            Object callerContext) {
+        if (!mIsPrefetchEnabledSupplier.get()) {
+            return DataSources.immediateFailedDataSource(PREFETCH_EXCEPTION);
+        }
+        try {
+            Producer<Void> producerSequence =
+                    mProducerSequenceFactory.getEncodedImagePrefetchProducerSequence(imageRequest);
+            return submitPrefetchRequest(
+                    producerSequence,
+                    imageRequest,
+                    ImageRequest.RequestLevel.FULL_FETCH,
+                    callerContext);
+        } catch (Exception exception) {
+            return DataSources.immediateFailedDataSource(exception);
+        }
     }
-  }
 
-  /**
-   * Removes all images with the specified {@link Uri} from memory cache.
-   * @param uri
-   */
-  public void evictFromMemoryCache(final Uri uri) {
-    final String cacheKeySourceString = mCacheKeyFactory.getCacheKeySourceUri(uri).toString();
-    Predicate<CacheKey> bitmapCachePredicate =
-        new Predicate<CacheKey>() {
-          @Override
-          public boolean apply(CacheKey key) {
-            if (key instanceof BitmapMemoryCacheKey) {
-              return ((BitmapMemoryCacheKey) key).getSourceUriString().equals(cacheKeySourceString);
-            }
-            return false;
-          }
-        };
-    mBitmapMemoryCache.removeAll(bitmapCachePredicate);
+    /**
+     * Removes all images with the specified {@link Uri} from memory cache.
+     *
+     * @param uri
+     */
+    public void evictFromMemoryCache(final Uri uri) {
+        final String cacheKeySourceString = mCacheKeyFactory.getCacheKeySourceUri(uri).toString();
+        Predicate<CacheKey> bitmapCachePredicate =
+                new Predicate<CacheKey>() {
+                    @Override
+                    public boolean apply(CacheKey key) {
+                        if (key instanceof BitmapMemoryCacheKey) {
+                            return ((BitmapMemoryCacheKey) key).getSourceUriString().equals(cacheKeySourceString);
+                        }
+                        return false;
+                    }
+                };
+        mBitmapMemoryCache.removeAll(bitmapCachePredicate);
 
-    Predicate<CacheKey> encodedCachePredicate =
-        new Predicate<CacheKey>() {
-          @Override
-          public boolean apply(CacheKey key) {
-            return key.toString().equals(cacheKeySourceString);
-          }
-        };
-    mEncodedMemoryCache.removeAll(encodedCachePredicate);
-  }
+        Predicate<CacheKey> encodedCachePredicate =
+                new Predicate<CacheKey>() {
+                    @Override
+                    public boolean apply(CacheKey key) {
+                        return key.toString().equals(cacheKeySourceString);
+                    }
+                };
+        mEncodedMemoryCache.removeAll(encodedCachePredicate);
+    }
 
-  private <T> DataSource<CloseableReference<T>> submitFetchRequest(
-      Producer<CloseableReference<T>> producerSequence,
-      ImageRequest imageRequest,
-      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,
-      Object callerContext) {
-    try {
-      ImageRequest.RequestLevel lowestPermittedRequestLevel =
-          ImageRequest.RequestLevel.getMax(
-              imageRequest.getLowestPermittedRequestLevel(),
-              lowestPermittedRequestLevelOnSubmit);
-      SettableProducerContext settableProducerContext = new SettableProducerContext(
-          imageRequest,
-          generateUniqueFutureId(),
-          mRequestListener,
-          callerContext,
-          lowestPermittedRequestLevel,
+    private <T> DataSource<CloseableReference<T>> submitFetchRequest(
+            Producer<CloseableReference<T>> producerSequence,
+            ImageRequest imageRequest,
+            ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,
+            Object callerContext) {
+        try {
+            ImageRequest.RequestLevel lowestPermittedRequestLevel =
+                    ImageRequest.RequestLevel.getMax(
+                            imageRequest.getLowestPermittedRequestLevel(),
+                            lowestPermittedRequestLevelOnSubmit);
+            SettableProducerContext settableProducerContext = new SettableProducerContext(
+                    imageRequest,
+                    generateUniqueFutureId(),
+                    mRequestListener,
+                    callerContext,
+                    lowestPermittedRequestLevel,
         /* isPrefetch */ false,
-          imageRequest.getProgressiveRenderingEnabled() ||
-              !UriUtil.isNetworkUri(imageRequest.getSourceUri()),
-          imageRequest.getPriority());
-      return CloseableProducerToDataSourceAdapter.create(
-          producerSequence,
-          settableProducerContext,
-          mRequestListener);
-    } catch (Exception exception) {
-      return DataSources.immediateFailedDataSource(exception);
+                    imageRequest.getProgressiveRenderingEnabled() ||
+                            !UriUtil.isNetworkUri(imageRequest.getSourceUri()),
+                    imageRequest.getPriority());
+            return CloseableProducerToDataSourceAdapter.create(
+                    producerSequence,
+                    settableProducerContext,
+                    mRequestListener);
+        } catch (Exception exception) {
+            return DataSources.immediateFailedDataSource(exception);
+        }
     }
-  }
 
-  private DataSource<Void> submitPrefetchRequest(
-      Producer<Void> producerSequence,
-      ImageRequest imageRequest,
-      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,
-      Object callerContext) {
-    try {
-      ImageRequest.RequestLevel lowestPermittedRequestLevel =
-          ImageRequest.RequestLevel.getMax(
-              imageRequest.getLowestPermittedRequestLevel(),
-              lowestPermittedRequestLevelOnSubmit);
-      SettableProducerContext settableProducerContext = new SettableProducerContext(
-          imageRequest,
-          generateUniqueFutureId(),
-          mRequestListener,
-          callerContext,
-          lowestPermittedRequestLevel,
+    private DataSource<Void> submitPrefetchRequest(
+            Producer<Void> producerSequence,
+            ImageRequest imageRequest,
+            ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,
+            Object callerContext) {
+        try {
+            ImageRequest.RequestLevel lowestPermittedRequestLevel =
+                    ImageRequest.RequestLevel.getMax(
+                            imageRequest.getLowestPermittedRequestLevel(),
+                            lowestPermittedRequestLevelOnSubmit);
+            SettableProducerContext settableProducerContext = new SettableProducerContext(
+                    imageRequest,
+                    generateUniqueFutureId(),
+                    mRequestListener,
+                    callerContext,
+                    lowestPermittedRequestLevel,
         /* isPrefetch */ true,
         /* isIntermediateResultExpected */ false,
-          Priority.LOW);
-      return ProducerToDataSourceAdapter.create(
-          producerSequence,
-          settableProducerContext,
-          mRequestListener);
-    } catch (Exception exception) {
-      return DataSources.immediateFailedDataSource(exception);
+                    Priority.LOW);
+            return ProducerToDataSourceAdapter.create(
+                    producerSequence,
+                    settableProducerContext,
+                    mRequestListener);
+        } catch (Exception exception) {
+            return DataSources.immediateFailedDataSource(exception);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineConfig.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineConfig.java
index f35dc6119..dd8b5b174 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineConfig.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineConfig.java
@@ -53,334 +53,334 @@
 
 /**
  * Master configuration class for the image pipeline library.
- *
+ * <p>
  * To use:
  * <code>
- *   ImagePipelineConfig config = ImagePipelineConfig.newBuilder()
- *       .setXXX(xxx)
- *       .setYYY(yyy)
- *       .build();
- *   ImagePipelineFactory factory = new ImagePipelineFactory(config);
- *   ImagePipeline pipeline = factory.newPipeline();
+ * ImagePipelineConfig config = ImagePipelineConfig.newBuilder()
+ * .setXXX(xxx)
+ * .setYYY(yyy)
+ * .build();
+ * ImagePipelineFactory factory = new ImagePipelineFactory(config);
+ * ImagePipeline pipeline = factory.newPipeline();
  * </code>
- *
+ * <p>
  * <p>This should only be done once per process.
  */
 public class ImagePipelineConfig {
 
-  // There are a lot of parameters in this class. Please follow strict alphabetical order.
-
-  private final Supplier<MemoryCacheParams> mBitmapMemoryCacheParamsSupplier;
-  private final CacheKeyFactory mCacheKeyFactory;
-  private final Context mContext;
-  private final Supplier<MemoryCacheParams> mEncodedMemoryCacheParamsSupplier;
-  private final ExecutorSupplier mExecutorSupplier;
-  private final ImageCacheStatsTracker mImageCacheStatsTracker;
-  private final AnimatedDrawableUtil mAnimatedDrawableUtil;
-  private final AnimatedImageFactory mAnimatedImageFactory;
-  private final ImageDecoder mImageDecoder;
-  private final Supplier<Boolean> mIsPrefetchEnabledSupplier;
-  private final DiskCacheConfig mMainDiskCacheConfig;
-  private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;
-  private final NetworkFetcher mNetworkFetcher;
-  private final PoolFactory mPoolFactory;
-  private final ProgressiveJpegConfig mProgressiveJpegConfig;
-  private final Set<RequestListener> mRequestListeners;
-  private final boolean mResizeAndRotateEnabledForNetwork;
-  private final DiskCacheConfig mSmallImageDiskCacheConfig;
-  private final PlatformBitmapFactory mPlatformBitmapFactory;
-
-  private ImagePipelineConfig(Builder builder) {
-    mBitmapMemoryCacheParamsSupplier =
-        builder.mBitmapMemoryCacheParamsSupplier == null ?
-            new DefaultBitmapMemoryCacheParamsSupplier(
-                (ActivityManager) builder.mContext.getSystemService(Context.ACTIVITY_SERVICE)) :
-            builder.mBitmapMemoryCacheParamsSupplier;
-    mCacheKeyFactory =
-        builder.mCacheKeyFactory == null ?
-            DefaultCacheKeyFactory.getInstance() :
-            builder.mCacheKeyFactory;
-    mContext = Preconditions.checkNotNull(builder.mContext);
-    mEncodedMemoryCacheParamsSupplier =
-        builder.mEncodedMemoryCacheParamsSupplier == null ?
-            new DefaultEncodedMemoryCacheParamsSupplier() :
-            builder.mEncodedMemoryCacheParamsSupplier;
-    mExecutorSupplier =
-        builder.mExecutorSupplier == null ?
-            new DefaultExecutorSupplier() :
-            builder.mExecutorSupplier;
-    mImageCacheStatsTracker =
-        builder.mImageCacheStatsTracker == null ?
-            NoOpImageCacheStatsTracker.getInstance() :
-            builder.mImageCacheStatsTracker;
-    mIsPrefetchEnabledSupplier =
-          builder.mIsPrefetchEnabledSupplier == null ?
-              new Supplier<Boolean>() {
-                @Override
-                public Boolean get() {
-                  return true;
-                }
-              } :
-              builder.mIsPrefetchEnabledSupplier;
-    mMainDiskCacheConfig =
-        builder.mMainDiskCacheConfig == null ?
-            getDefaultMainDiskCacheConfig(builder.mContext) :
-            builder.mMainDiskCacheConfig;
-    mMemoryTrimmableRegistry =
-        builder.mMemoryTrimmableRegistry == null ?
-            NoOpMemoryTrimmableRegistry.getInstance() :
-            builder.mMemoryTrimmableRegistry;
-    mPoolFactory =
-        builder.mPoolFactory == null ?
-            new PoolFactory(PoolConfig.newBuilder().build()) :
-            builder.mPoolFactory;
-    mProgressiveJpegConfig =
-        builder.mProgressiveJpegConfig == null ?
-            new SimpleProgressiveJpegConfig() :
-            builder.mProgressiveJpegConfig;
-    mRequestListeners =
-        builder.mRequestListeners == null ?
-            new HashSet<RequestListener>() :
-            builder.mRequestListeners;
-    mResizeAndRotateEnabledForNetwork = builder.mResizeAndRotateEnabledForNetwork;
-    mSmallImageDiskCacheConfig =
-        builder.mSmallImageDiskCacheConfig == null ?
-            mMainDiskCacheConfig :
-            builder.mSmallImageDiskCacheConfig;
-
-    mAnimatedDrawableUtil = new AnimatedDrawableUtil();
-    AnimatedDrawableBackendProvider animatedDrawableBackendProvider =
-        new AnimatedDrawableBackendProvider() {
-      @Override
-      public AnimatedDrawableBackend get(AnimatedImageResult imageResult, Rect bounds) {
-        return new AnimatedDrawableBackendImpl(mAnimatedDrawableUtil, imageResult, bounds);
-      }
-    };
-    GingerbreadBitmapFactory factoryGingerbread = new GingerbreadBitmapFactory();
-    DalvikBitmapFactory factoryICS = new DalvikBitmapFactory(
-        new EmptyJpegGenerator(mPoolFactory.getPooledByteBufferFactory()),
-        mPoolFactory.getSharedByteArray());
-    ArtBitmapFactory factoryLollipop =
-        new ArtBitmapFactory(mPoolFactory.getBitmapPool());
-    mPlatformBitmapFactory =
-        new PlatformBitmapFactory(
-            factoryGingerbread,
-            factoryICS,
-            factoryLollipop);
-
-    mAnimatedImageFactory = builder.mAnimatedImageFactory == null ?
-        new AnimatedImageFactory(animatedDrawableBackendProvider, mPlatformBitmapFactory) :
-        builder.mAnimatedImageFactory;
-
-    mImageDecoder =
-        builder.mImageDecoder == null ?
-            new ImageDecoder(mAnimatedImageFactory, mPlatformBitmapFactory) :
-            builder.mImageDecoder;
-    mNetworkFetcher =
-        builder.mNetworkFetcher == null ?
-            new HttpUrlConnectionNetworkFetcher() :
-            builder.mNetworkFetcher;
-  }
-
-  private static DiskCacheConfig getDefaultMainDiskCacheConfig(final Context context) {
-    return DiskCacheConfig.newBuilder()
-        .setBaseDirectoryPathSupplier(
-            new Supplier<File>() {
-              @Override
-              public File get() {
-                return context.getApplicationContext().getCacheDir();
-              }
-            })
-        .setBaseDirectoryName("image_cache")
-        .setMaxCacheSize(40 * ByteConstants.MB)
-        .setMaxCacheSizeOnLowDiskSpace(10 * ByteConstants.MB)
-        .setMaxCacheSizeOnVeryLowDiskSpace(2 * ByteConstants.MB)
-        .build();
-  }
-
-  public Supplier<MemoryCacheParams> getBitmapMemoryCacheParamsSupplier() {
-    return mBitmapMemoryCacheParamsSupplier;
-  }
-
-  public CacheKeyFactory getCacheKeyFactory() {
-    return mCacheKeyFactory;
-  }
-
-  public Context getContext() {
-    return mContext;
-  }
-
-  public Supplier<MemoryCacheParams> getEncodedMemoryCacheParamsSupplier() {
-    return mEncodedMemoryCacheParamsSupplier;
-  }
-
-  public ExecutorSupplier getExecutorSupplier() {
-    return mExecutorSupplier;
-  }
-
-  public ImageCacheStatsTracker getImageCacheStatsTracker() {
-    return mImageCacheStatsTracker;
-  }
-
-  public ImageDecoder getImageDecoder() {
-    return mImageDecoder;
-  }
-
-  public Supplier<Boolean> getIsPrefetchEnabledSupplier() {
-    return mIsPrefetchEnabledSupplier;
-  }
-
-  public DiskCacheConfig getMainDiskCacheConfig() {
-    return mMainDiskCacheConfig;
-  }
-
-  public MemoryTrimmableRegistry getMemoryTrimmableRegistry() {
-    return mMemoryTrimmableRegistry;
-  }
-
-  public NetworkFetcher getNetworkFetcher() {
-    return mNetworkFetcher;
-  }
-
-  public PoolFactory getPoolFactory() {
-    return mPoolFactory;
-  }
-
-  public ProgressiveJpegConfig getProgressiveJpegConfig() {
-    return mProgressiveJpegConfig;
-  }
-
-  public Set<RequestListener> getRequestListeners() {
-    return Collections.unmodifiableSet(mRequestListeners);
-  }
-
-  public boolean isResizeAndRotateEnabledForNetwork() {
-    return mResizeAndRotateEnabledForNetwork;
-  }
-
-  public DiskCacheConfig getSmallImageDiskCacheConfig() {
-    return mSmallImageDiskCacheConfig;
-  }
-
-  public PlatformBitmapFactory getPlatformBitmapFactory() {
-    return mPlatformBitmapFactory;
-  }
-
-  public static Builder newBuilder(Context context) {
-    return new Builder(context);
-  }
-
-  public static class Builder {
-
-    private Supplier<MemoryCacheParams> mBitmapMemoryCacheParamsSupplier;
-    private CacheKeyFactory mCacheKeyFactory;
+    // There are a lot of parameters in this class. Please follow strict alphabetical order.
+
+    private final Supplier<MemoryCacheParams> mBitmapMemoryCacheParamsSupplier;
+    private final CacheKeyFactory mCacheKeyFactory;
     private final Context mContext;
-    private Supplier<MemoryCacheParams> mEncodedMemoryCacheParamsSupplier;
-    private ExecutorSupplier mExecutorSupplier;
-    private ImageCacheStatsTracker mImageCacheStatsTracker;
-    private ImageDecoder mImageDecoder;
-    private Supplier<Boolean> mIsPrefetchEnabledSupplier;
-    private DiskCacheConfig mMainDiskCacheConfig;
-    private MemoryTrimmableRegistry mMemoryTrimmableRegistry;
-    private NetworkFetcher mNetworkFetcher;
-    private PoolFactory mPoolFactory;
-    private ProgressiveJpegConfig mProgressiveJpegConfig;
-    private Set<RequestListener> mRequestListeners;
-    private boolean mResizeAndRotateEnabledForNetwork = true;
-    private DiskCacheConfig mSmallImageDiskCacheConfig;
-    private AnimatedImageFactory mAnimatedImageFactory;
-
-    private Builder(Context context) {
-      // Doesn't use a setter as always required.
-      mContext = Preconditions.checkNotNull(context);
+    private final Supplier<MemoryCacheParams> mEncodedMemoryCacheParamsSupplier;
+    private final ExecutorSupplier mExecutorSupplier;
+    private final ImageCacheStatsTracker mImageCacheStatsTracker;
+    private final AnimatedDrawableUtil mAnimatedDrawableUtil;
+    private final AnimatedImageFactory mAnimatedImageFactory;
+    private final ImageDecoder mImageDecoder;
+    private final Supplier<Boolean> mIsPrefetchEnabledSupplier;
+    private final DiskCacheConfig mMainDiskCacheConfig;
+    private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;
+    private final NetworkFetcher mNetworkFetcher;
+    private final PoolFactory mPoolFactory;
+    private final ProgressiveJpegConfig mProgressiveJpegConfig;
+    private final Set<RequestListener> mRequestListeners;
+    private final boolean mResizeAndRotateEnabledForNetwork;
+    private final DiskCacheConfig mSmallImageDiskCacheConfig;
+    private final PlatformBitmapFactory mPlatformBitmapFactory;
+
+    private ImagePipelineConfig(Builder builder) {
+        mBitmapMemoryCacheParamsSupplier =
+                builder.mBitmapMemoryCacheParamsSupplier == null ?
+                        new DefaultBitmapMemoryCacheParamsSupplier(
+                                (ActivityManager) builder.mContext.getSystemService(Context.ACTIVITY_SERVICE)) :
+                        builder.mBitmapMemoryCacheParamsSupplier;
+        mCacheKeyFactory =
+                builder.mCacheKeyFactory == null ?
+                        DefaultCacheKeyFactory.getInstance() :
+                        builder.mCacheKeyFactory;
+        mContext = Preconditions.checkNotNull(builder.mContext);
+        mEncodedMemoryCacheParamsSupplier =
+                builder.mEncodedMemoryCacheParamsSupplier == null ?
+                        new DefaultEncodedMemoryCacheParamsSupplier() :
+                        builder.mEncodedMemoryCacheParamsSupplier;
+        mExecutorSupplier =
+                builder.mExecutorSupplier == null ?
+                        new DefaultExecutorSupplier() :
+                        builder.mExecutorSupplier;
+        mImageCacheStatsTracker =
+                builder.mImageCacheStatsTracker == null ?
+                        NoOpImageCacheStatsTracker.getInstance() :
+                        builder.mImageCacheStatsTracker;
+        mIsPrefetchEnabledSupplier =
+                builder.mIsPrefetchEnabledSupplier == null ?
+                        new Supplier<Boolean>() {
+                            @Override
+                            public Boolean get() {
+                                return true;
+                            }
+                        } :
+                        builder.mIsPrefetchEnabledSupplier;
+        mMainDiskCacheConfig =
+                builder.mMainDiskCacheConfig == null ?
+                        getDefaultMainDiskCacheConfig(builder.mContext) :
+                        builder.mMainDiskCacheConfig;
+        mMemoryTrimmableRegistry =
+                builder.mMemoryTrimmableRegistry == null ?
+                        NoOpMemoryTrimmableRegistry.getInstance() :
+                        builder.mMemoryTrimmableRegistry;
+        mPoolFactory =
+                builder.mPoolFactory == null ?
+                        new PoolFactory(PoolConfig.newBuilder().build()) :
+                        builder.mPoolFactory;
+        mProgressiveJpegConfig =
+                builder.mProgressiveJpegConfig == null ?
+                        new SimpleProgressiveJpegConfig() :
+                        builder.mProgressiveJpegConfig;
+        mRequestListeners =
+                builder.mRequestListeners == null ?
+                        new HashSet<RequestListener>() :
+                        builder.mRequestListeners;
+        mResizeAndRotateEnabledForNetwork = builder.mResizeAndRotateEnabledForNetwork;
+        mSmallImageDiskCacheConfig =
+                builder.mSmallImageDiskCacheConfig == null ?
+                        mMainDiskCacheConfig :
+                        builder.mSmallImageDiskCacheConfig;
+
+        mAnimatedDrawableUtil = new AnimatedDrawableUtil();
+        AnimatedDrawableBackendProvider animatedDrawableBackendProvider =
+                new AnimatedDrawableBackendProvider() {
+                    @Override
+                    public AnimatedDrawableBackend get(AnimatedImageResult imageResult, Rect bounds) {
+                        return new AnimatedDrawableBackendImpl(mAnimatedDrawableUtil, imageResult, bounds);
+                    }
+                };
+        GingerbreadBitmapFactory factoryGingerbread = new GingerbreadBitmapFactory();
+        DalvikBitmapFactory factoryICS = new DalvikBitmapFactory(
+                new EmptyJpegGenerator(mPoolFactory.getPooledByteBufferFactory()),
+                mPoolFactory.getSharedByteArray());
+        ArtBitmapFactory factoryLollipop =
+                new ArtBitmapFactory(mPoolFactory.getBitmapPool());
+        mPlatformBitmapFactory =
+                new PlatformBitmapFactory(
+                        factoryGingerbread,
+                        factoryICS,
+                        factoryLollipop);
+
+        mAnimatedImageFactory = builder.mAnimatedImageFactory == null ?
+                new AnimatedImageFactory(animatedDrawableBackendProvider, mPlatformBitmapFactory) :
+                builder.mAnimatedImageFactory;
+
+        mImageDecoder =
+                builder.mImageDecoder == null ?
+                        new ImageDecoder(mAnimatedImageFactory, mPlatformBitmapFactory) :
+                        builder.mImageDecoder;
+        mNetworkFetcher =
+                builder.mNetworkFetcher == null ?
+                        new HttpUrlConnectionNetworkFetcher() :
+                        builder.mNetworkFetcher;
+    }
+
+    private static DiskCacheConfig getDefaultMainDiskCacheConfig(final Context context) {
+        return DiskCacheConfig.newBuilder()
+                .setBaseDirectoryPathSupplier(
+                        new Supplier<File>() {
+                            @Override
+                            public File get() {
+                                return context.getApplicationContext().getCacheDir();
+                            }
+                        })
+                .setBaseDirectoryName("image_cache")
+                .setMaxCacheSize(40 * ByteConstants.MB)
+                .setMaxCacheSizeOnLowDiskSpace(10 * ByteConstants.MB)
+                .setMaxCacheSizeOnVeryLowDiskSpace(2 * ByteConstants.MB)
+                .build();
+    }
+
+    public Supplier<MemoryCacheParams> getBitmapMemoryCacheParamsSupplier() {
+        return mBitmapMemoryCacheParamsSupplier;
+    }
+
+    public CacheKeyFactory getCacheKeyFactory() {
+        return mCacheKeyFactory;
     }
 
-    public Builder setBitmapMemoryCacheParamsSupplier(
-        Supplier<MemoryCacheParams> bitmapMemoryCacheParamsSupplier) {
-      mBitmapMemoryCacheParamsSupplier =
-          Preconditions.checkNotNull(bitmapMemoryCacheParamsSupplier);
-      return this;
+    public Context getContext() {
+        return mContext;
     }
 
-    public Builder setCacheKeyFactory(CacheKeyFactory cacheKeyFactory) {
-      mCacheKeyFactory = cacheKeyFactory;
-      return this;
+    public Supplier<MemoryCacheParams> getEncodedMemoryCacheParamsSupplier() {
+        return mEncodedMemoryCacheParamsSupplier;
     }
 
-    public Builder setEncodedMemoryCacheParamsSupplier(
-        Supplier<MemoryCacheParams> encodedMemoryCacheParamsSupplier) {
-      mEncodedMemoryCacheParamsSupplier =
-          Preconditions.checkNotNull(encodedMemoryCacheParamsSupplier);
-      return this;
+    public ExecutorSupplier getExecutorSupplier() {
+        return mExecutorSupplier;
     }
 
-    public Builder setExecutorSupplier(ExecutorSupplier executorSupplier) {
-      mExecutorSupplier = executorSupplier;
-      return this;
+    public ImageCacheStatsTracker getImageCacheStatsTracker() {
+        return mImageCacheStatsTracker;
     }
 
-    public Builder setImageCacheStatsTracker(ImageCacheStatsTracker imageCacheStatsTracker) {
-      mImageCacheStatsTracker = imageCacheStatsTracker;
-      return this;
+    public ImageDecoder getImageDecoder() {
+        return mImageDecoder;
     }
 
-    public Builder setAnimatedImageFactory(AnimatedImageFactory animatedImageFactory) {
-      mAnimatedImageFactory = animatedImageFactory;
-      return this;
+    public Supplier<Boolean> getIsPrefetchEnabledSupplier() {
+        return mIsPrefetchEnabledSupplier;
     }
 
-    public Builder setImageDecoder(ImageDecoder imageDecoder) {
-      mImageDecoder = imageDecoder;
-      return this;
+    public DiskCacheConfig getMainDiskCacheConfig() {
+        return mMainDiskCacheConfig;
     }
 
-    public Builder setIsPrefetchEnabledSupplier(Supplier<Boolean> isPrefetchEnabledSupplier) {
-      mIsPrefetchEnabledSupplier = isPrefetchEnabledSupplier;
-      return this;
+    public MemoryTrimmableRegistry getMemoryTrimmableRegistry() {
+        return mMemoryTrimmableRegistry;
     }
 
-    public Builder setMainDiskCacheConfig(DiskCacheConfig mainDiskCacheConfig) {
-      mMainDiskCacheConfig = mainDiskCacheConfig;
-      return this;
+    public NetworkFetcher getNetworkFetcher() {
+        return mNetworkFetcher;
     }
 
-    public Builder setMemoryTrimmableRegistry(MemoryTrimmableRegistry memoryTrimmableRegistry) {
-      mMemoryTrimmableRegistry = memoryTrimmableRegistry;
-      return this;
+    public PoolFactory getPoolFactory() {
+        return mPoolFactory;
     }
 
-    public Builder setNetworkFetcher(NetworkFetcher networkFetcher) {
-      mNetworkFetcher = networkFetcher;
-      return this;
+    public ProgressiveJpegConfig getProgressiveJpegConfig() {
+        return mProgressiveJpegConfig;
     }
 
-    public Builder setPoolFactory(PoolFactory poolFactory) {
-      mPoolFactory = poolFactory;
-      return this;
+    public Set<RequestListener> getRequestListeners() {
+        return Collections.unmodifiableSet(mRequestListeners);
     }
 
-    public Builder setProgressiveJpegConfig(ProgressiveJpegConfig progressiveJpegConfig) {
-      mProgressiveJpegConfig = progressiveJpegConfig;
-      return this;
+    public boolean isResizeAndRotateEnabledForNetwork() {
+        return mResizeAndRotateEnabledForNetwork;
     }
 
-    public Builder setRequestListeners(Set<RequestListener> requestListeners) {
-      mRequestListeners = requestListeners;
-      return this;
+    public DiskCacheConfig getSmallImageDiskCacheConfig() {
+        return mSmallImageDiskCacheConfig;
     }
 
-    public Builder setResizeAndRotateEnabledForNetwork(boolean resizeAndRotateEnabledForNetwork) {
-      mResizeAndRotateEnabledForNetwork = resizeAndRotateEnabledForNetwork;
-      return this;
+    public PlatformBitmapFactory getPlatformBitmapFactory() {
+        return mPlatformBitmapFactory;
     }
 
-    public Builder setSmallImageDiskCacheConfig(DiskCacheConfig smallImageDiskCacheConfig) {
-      mSmallImageDiskCacheConfig = smallImageDiskCacheConfig;
-      return this;
+    public static Builder newBuilder(Context context) {
+        return new Builder(context);
     }
 
-    public ImagePipelineConfig build() {
-      return new ImagePipelineConfig(this);
+    public static class Builder {
+
+        private Supplier<MemoryCacheParams> mBitmapMemoryCacheParamsSupplier;
+        private CacheKeyFactory mCacheKeyFactory;
+        private final Context mContext;
+        private Supplier<MemoryCacheParams> mEncodedMemoryCacheParamsSupplier;
+        private ExecutorSupplier mExecutorSupplier;
+        private ImageCacheStatsTracker mImageCacheStatsTracker;
+        private ImageDecoder mImageDecoder;
+        private Supplier<Boolean> mIsPrefetchEnabledSupplier;
+        private DiskCacheConfig mMainDiskCacheConfig;
+        private MemoryTrimmableRegistry mMemoryTrimmableRegistry;
+        private NetworkFetcher mNetworkFetcher;
+        private PoolFactory mPoolFactory;
+        private ProgressiveJpegConfig mProgressiveJpegConfig;
+        private Set<RequestListener> mRequestListeners;
+        private boolean mResizeAndRotateEnabledForNetwork = true;
+        private DiskCacheConfig mSmallImageDiskCacheConfig;
+        private AnimatedImageFactory mAnimatedImageFactory;
+
+        private Builder(Context context) {
+            // Doesn't use a setter as always required.
+            mContext = Preconditions.checkNotNull(context);
+        }
+
+        public Builder setBitmapMemoryCacheParamsSupplier(
+                Supplier<MemoryCacheParams> bitmapMemoryCacheParamsSupplier) {
+            mBitmapMemoryCacheParamsSupplier =
+                    Preconditions.checkNotNull(bitmapMemoryCacheParamsSupplier);
+            return this;
+        }
+
+        public Builder setCacheKeyFactory(CacheKeyFactory cacheKeyFactory) {
+            mCacheKeyFactory = cacheKeyFactory;
+            return this;
+        }
+
+        public Builder setEncodedMemoryCacheParamsSupplier(
+                Supplier<MemoryCacheParams> encodedMemoryCacheParamsSupplier) {
+            mEncodedMemoryCacheParamsSupplier =
+                    Preconditions.checkNotNull(encodedMemoryCacheParamsSupplier);
+            return this;
+        }
+
+        public Builder setExecutorSupplier(ExecutorSupplier executorSupplier) {
+            mExecutorSupplier = executorSupplier;
+            return this;
+        }
+
+        public Builder setImageCacheStatsTracker(ImageCacheStatsTracker imageCacheStatsTracker) {
+            mImageCacheStatsTracker = imageCacheStatsTracker;
+            return this;
+        }
+
+        public Builder setAnimatedImageFactory(AnimatedImageFactory animatedImageFactory) {
+            mAnimatedImageFactory = animatedImageFactory;
+            return this;
+        }
+
+        public Builder setImageDecoder(ImageDecoder imageDecoder) {
+            mImageDecoder = imageDecoder;
+            return this;
+        }
+
+        public Builder setIsPrefetchEnabledSupplier(Supplier<Boolean> isPrefetchEnabledSupplier) {
+            mIsPrefetchEnabledSupplier = isPrefetchEnabledSupplier;
+            return this;
+        }
+
+        public Builder setMainDiskCacheConfig(DiskCacheConfig mainDiskCacheConfig) {
+            mMainDiskCacheConfig = mainDiskCacheConfig;
+            return this;
+        }
+
+        public Builder setMemoryTrimmableRegistry(MemoryTrimmableRegistry memoryTrimmableRegistry) {
+            mMemoryTrimmableRegistry = memoryTrimmableRegistry;
+            return this;
+        }
+
+        public Builder setNetworkFetcher(NetworkFetcher networkFetcher) {
+            mNetworkFetcher = networkFetcher;
+            return this;
+        }
+
+        public Builder setPoolFactory(PoolFactory poolFactory) {
+            mPoolFactory = poolFactory;
+            return this;
+        }
+
+        public Builder setProgressiveJpegConfig(ProgressiveJpegConfig progressiveJpegConfig) {
+            mProgressiveJpegConfig = progressiveJpegConfig;
+            return this;
+        }
+
+        public Builder setRequestListeners(Set<RequestListener> requestListeners) {
+            mRequestListeners = requestListeners;
+            return this;
+        }
+
+        public Builder setResizeAndRotateEnabledForNetwork(boolean resizeAndRotateEnabledForNetwork) {
+            mResizeAndRotateEnabledForNetwork = resizeAndRotateEnabledForNetwork;
+            return this;
+        }
+
+        public Builder setSmallImageDiskCacheConfig(DiskCacheConfig smallImageDiskCacheConfig) {
+            mSmallImageDiskCacheConfig = smallImageDiskCacheConfig;
+            return this;
+        }
+
+        public ImagePipelineConfig build() {
+            return new ImagePipelineConfig(this);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
index 26e6ba3cc..069e1c6ab 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
@@ -48,9 +48,9 @@
 
 /**
  * Factory class for the image pipeline.
- *
+ * <p>
  * <p>This class constructs the pipeline and its dependencies from other libraries.
- *
+ * <p>
  * <p>As the pipeline object can be quite expensive to create, it is strongly
  * recommended that applications create just one instance of this class
  * and of the pipeline.
@@ -58,224 +58,232 @@
 @NotThreadSafe
 public class ImagePipelineFactory {
 
-  private static ImagePipelineFactory sInstance = null;
+    private static ImagePipelineFactory sInstance = null;
 
-  /** Gets the instance of {@link ImagePipelineFactory}. */
-  public static ImagePipelineFactory getInstance() {
-    return Preconditions.checkNotNull(sInstance, "ImagePipelineFactory was not initialized!");
-  }
+    /**
+     * Gets the instance of {@link ImagePipelineFactory}.
+     */
+    public static ImagePipelineFactory getInstance() {
+        return Preconditions.checkNotNull(sInstance, "ImagePipelineFactory was not initialized!");
+    }
 
-  /** Initializes {@link ImagePipelineFactory} with default config. */
-  public static void initialize(Context context) {
-    initialize(ImagePipelineConfig.newBuilder(context).build());
-  }
+    /**
+     * Initializes {@link ImagePipelineFactory} with default config.
+     */
+    public static void initialize(Context context) {
+        initialize(ImagePipelineConfig.newBuilder(context).build());
+    }
 
-  /** Initializes {@link ImagePipelineFactory} with the specified config. */
-  public static void initialize(ImagePipelineConfig imagePipelineConfig) {
-    sInstance = new ImagePipelineFactory(imagePipelineConfig);
-  }
+    /**
+     * Initializes {@link ImagePipelineFactory} with the specified config.
+     */
+    public static void initialize(ImagePipelineConfig imagePipelineConfig) {
+        sInstance = new ImagePipelineFactory(imagePipelineConfig);
+    }
 
-  /** Shuts {@link ImagePipelineFactory} down. */
-  public static void shutDown() {
-    if (sInstance != null) {
-      sInstance.getBitmapMemoryCache().removeAll(AndroidPredicates.<CacheKey>True());
-      sInstance.getEncodedMemoryCache().removeAll(AndroidPredicates.<CacheKey>True());
-      sInstance = null;
+    /**
+     * Shuts {@link ImagePipelineFactory} down.
+     */
+    public static void shutDown() {
+        if (sInstance != null) {
+            sInstance.getBitmapMemoryCache().removeAll(AndroidPredicates.<CacheKey>True());
+            sInstance.getEncodedMemoryCache().removeAll(AndroidPredicates.<CacheKey>True());
+            sInstance = null;
+        }
     }
-  }
 
-  private final ImagePipelineConfig mConfig;
+    private final ImagePipelineConfig mConfig;
 
-  private AnimatedDrawableFactory mAnimatedDrawableFactory;
-  private CountingMemoryCache<CacheKey, CloseableImage>
-      mBitmapCountingMemoryCache;
-  private MemoryCache<CacheKey, CloseableImage> mBitmapMemoryCache;
-  private EmptyJpegGenerator mEmptyJpegGenerator;
-  private CountingMemoryCache<CacheKey, PooledByteBuffer> mEncodedCountingMemoryCache;
-  private MemoryCache<CacheKey, PooledByteBuffer> mEncodedMemoryCache;
-  private BufferedDiskCache mMainBufferedDiskCache;
-  private DiskStorageCache mMainDiskStorageCache;
-  private ImagePipeline mImagePipeline;
-  private ProducerFactory mProducerFactory;
-  private ProducerSequenceFactory mProducerSequenceFactory;
-  private BufferedDiskCache mSmallImageBufferedDiskCache;
-  private DiskStorageCache mSmallImageDiskStorageCache;
+    private AnimatedDrawableFactory mAnimatedDrawableFactory;
+    private CountingMemoryCache<CacheKey, CloseableImage>
+            mBitmapCountingMemoryCache;
+    private MemoryCache<CacheKey, CloseableImage> mBitmapMemoryCache;
+    private EmptyJpegGenerator mEmptyJpegGenerator;
+    private CountingMemoryCache<CacheKey, PooledByteBuffer> mEncodedCountingMemoryCache;
+    private MemoryCache<CacheKey, PooledByteBuffer> mEncodedMemoryCache;
+    private BufferedDiskCache mMainBufferedDiskCache;
+    private DiskStorageCache mMainDiskStorageCache;
+    private ImagePipeline mImagePipeline;
+    private ProducerFactory mProducerFactory;
+    private ProducerSequenceFactory mProducerSequenceFactory;
+    private BufferedDiskCache mSmallImageBufferedDiskCache;
+    private DiskStorageCache mSmallImageDiskStorageCache;
 
-  public ImagePipelineFactory(ImagePipelineConfig config) {
-    mConfig = Preconditions.checkNotNull(config);
-  }
+    public ImagePipelineFactory(ImagePipelineConfig config) {
+        mConfig = Preconditions.checkNotNull(config);
+    }
 
-  // We need some of these methods public for now so internal code can use them.
+    // We need some of these methods public for now so internal code can use them.
 
-  public CountingMemoryCache<CacheKey, CloseableImage>
-      getBitmapCountingMemoryCache() {
-    if (mBitmapCountingMemoryCache == null) {
-      mBitmapCountingMemoryCache =
-          BitmapCountingMemoryCacheFactory.get(
-              mConfig.getBitmapMemoryCacheParamsSupplier(),
-              mConfig.getMemoryTrimmableRegistry());
+    public CountingMemoryCache<CacheKey, CloseableImage>
+    getBitmapCountingMemoryCache() {
+        if (mBitmapCountingMemoryCache == null) {
+            mBitmapCountingMemoryCache =
+                    BitmapCountingMemoryCacheFactory.get(
+                            mConfig.getBitmapMemoryCacheParamsSupplier(),
+                            mConfig.getMemoryTrimmableRegistry());
+        }
+        return mBitmapCountingMemoryCache;
     }
-    return mBitmapCountingMemoryCache;
-  }
 
-  public MemoryCache<CacheKey, CloseableImage> getBitmapMemoryCache() {
-    if (mBitmapMemoryCache == null) {
-      mBitmapMemoryCache =
-          BitmapMemoryCacheFactory.get(
-              getBitmapCountingMemoryCache(),
-              mConfig.getImageCacheStatsTracker());
+    public MemoryCache<CacheKey, CloseableImage> getBitmapMemoryCache() {
+        if (mBitmapMemoryCache == null) {
+            mBitmapMemoryCache =
+                    BitmapMemoryCacheFactory.get(
+                            getBitmapCountingMemoryCache(),
+                            mConfig.getImageCacheStatsTracker());
+        }
+        return mBitmapMemoryCache;
     }
-    return mBitmapMemoryCache;
-  }
 
-  public CountingMemoryCache<CacheKey, PooledByteBuffer> getEncodedCountingMemoryCache() {
-    if (mEncodedCountingMemoryCache == null) {
-      mEncodedCountingMemoryCache =
-          EncodedCountingMemoryCacheFactory.get(
-              mConfig.getEncodedMemoryCacheParamsSupplier(),
-              mConfig.getMemoryTrimmableRegistry());
+    public CountingMemoryCache<CacheKey, PooledByteBuffer> getEncodedCountingMemoryCache() {
+        if (mEncodedCountingMemoryCache == null) {
+            mEncodedCountingMemoryCache =
+                    EncodedCountingMemoryCacheFactory.get(
+                            mConfig.getEncodedMemoryCacheParamsSupplier(),
+                            mConfig.getMemoryTrimmableRegistry());
+        }
+        return mEncodedCountingMemoryCache;
     }
-    return mEncodedCountingMemoryCache;
-  }
 
-  public MemoryCache<CacheKey, PooledByteBuffer> getEncodedMemoryCache() {
-    if (mEncodedMemoryCache == null) {
-      mEncodedMemoryCache =
-          EncodedMemoryCacheFactory.get(
-              getEncodedCountingMemoryCache(),
-              mConfig.getImageCacheStatsTracker());
+    public MemoryCache<CacheKey, PooledByteBuffer> getEncodedMemoryCache() {
+        if (mEncodedMemoryCache == null) {
+            mEncodedMemoryCache =
+                    EncodedMemoryCacheFactory.get(
+                            getEncodedCountingMemoryCache(),
+                            mConfig.getImageCacheStatsTracker());
+        }
+        return mEncodedMemoryCache;
     }
-    return mEncodedMemoryCache;
-  }
 
-  private BufferedDiskCache getMainBufferedDiskCache() {
-    if (mMainBufferedDiskCache == null) {
-      mMainBufferedDiskCache =
-          new BufferedDiskCache(
-              getMainDiskStorageCache(),
-              mConfig.getPoolFactory().getPooledByteBufferFactory(),
-              mConfig.getPoolFactory().getPooledByteStreams(),
-              mConfig.getExecutorSupplier().forLocalStorageRead(),
-              mConfig.getExecutorSupplier().forLocalStorageWrite(),
-              mConfig.getImageCacheStatsTracker());
+    private BufferedDiskCache getMainBufferedDiskCache() {
+        if (mMainBufferedDiskCache == null) {
+            mMainBufferedDiskCache =
+                    new BufferedDiskCache(
+                            getMainDiskStorageCache(),
+                            mConfig.getPoolFactory().getPooledByteBufferFactory(),
+                            mConfig.getPoolFactory().getPooledByteStreams(),
+                            mConfig.getExecutorSupplier().forLocalStorageRead(),
+                            mConfig.getExecutorSupplier().forLocalStorageWrite(),
+                            mConfig.getImageCacheStatsTracker());
+        }
+        return mMainBufferedDiskCache;
     }
-    return mMainBufferedDiskCache;
-  }
 
-  public DiskStorageCache getMainDiskStorageCache() {
-    if (mMainDiskStorageCache == null) {
-      mMainDiskStorageCache =
-          DiskCacheFactory.newDiskStorageCache(mConfig.getMainDiskCacheConfig());
+    public DiskStorageCache getMainDiskStorageCache() {
+        if (mMainDiskStorageCache == null) {
+            mMainDiskStorageCache =
+                    DiskCacheFactory.newDiskStorageCache(mConfig.getMainDiskCacheConfig());
+        }
+        return mMainDiskStorageCache;
     }
-    return mMainDiskStorageCache;
-  }
 
-  public ImagePipeline getImagePipeline() {
-    if (mImagePipeline == null) {
-      mImagePipeline =
-          new ImagePipeline(
-              getProducerSequenceFactory(),
-              mConfig.getRequestListeners(),
-              mConfig.getIsPrefetchEnabledSupplier(),
-              getBitmapMemoryCache(),
-              getEncodedMemoryCache(),
-              mConfig.getCacheKeyFactory());
+    public ImagePipeline getImagePipeline() {
+        if (mImagePipeline == null) {
+            mImagePipeline =
+                    new ImagePipeline(
+                            getProducerSequenceFactory(),
+                            mConfig.getRequestListeners(),
+                            mConfig.getIsPrefetchEnabledSupplier(),
+                            getBitmapMemoryCache(),
+                            getEncodedMemoryCache(),
+                            mConfig.getCacheKeyFactory());
+        }
+        return mImagePipeline;
     }
-    return mImagePipeline;
-  }
 
-  private ProducerFactory getProducerFactory() {
-    if (mProducerFactory == null) {
-      mProducerFactory =
-          new ProducerFactory(
-              mConfig.getContext(),
-              mConfig.getPoolFactory().getCommonByteArrayPool(),
-              mConfig.getImageDecoder(),
-              mConfig.getProgressiveJpegConfig(),
-              mConfig.getExecutorSupplier(),
-              mConfig.getPoolFactory().getPooledByteBufferFactory(),
-              getBitmapMemoryCache(),
-              getEncodedMemoryCache(),
-              getMainBufferedDiskCache(),
-              getSmallImageBufferedDiskCache(),
-              mConfig.getCacheKeyFactory(),
-              mConfig.getPlatformBitmapFactory());
+    private ProducerFactory getProducerFactory() {
+        if (mProducerFactory == null) {
+            mProducerFactory =
+                    new ProducerFactory(
+                            mConfig.getContext(),
+                            mConfig.getPoolFactory().getCommonByteArrayPool(),
+                            mConfig.getImageDecoder(),
+                            mConfig.getProgressiveJpegConfig(),
+                            mConfig.getExecutorSupplier(),
+                            mConfig.getPoolFactory().getPooledByteBufferFactory(),
+                            getBitmapMemoryCache(),
+                            getEncodedMemoryCache(),
+                            getMainBufferedDiskCache(),
+                            getSmallImageBufferedDiskCache(),
+                            mConfig.getCacheKeyFactory(),
+                            mConfig.getPlatformBitmapFactory());
+        }
+        return mProducerFactory;
     }
-    return mProducerFactory;
-  }
 
-  private ProducerSequenceFactory getProducerSequenceFactory() {
-    if (mProducerSequenceFactory == null) {
-      mProducerSequenceFactory =
-          new ProducerSequenceFactory(
-              getProducerFactory(),
-              mConfig.getNetworkFetcher(),
-              mConfig.isResizeAndRotateEnabledForNetwork());
+    private ProducerSequenceFactory getProducerSequenceFactory() {
+        if (mProducerSequenceFactory == null) {
+            mProducerSequenceFactory =
+                    new ProducerSequenceFactory(
+                            getProducerFactory(),
+                            mConfig.getNetworkFetcher(),
+                            mConfig.isResizeAndRotateEnabledForNetwork());
+        }
+        return mProducerSequenceFactory;
     }
-    return mProducerSequenceFactory;
-  }
 
-  public DiskStorageCache getSmallImageDiskStorageCache() {
-    if (mSmallImageDiskStorageCache == null) {
-      mSmallImageDiskStorageCache =
-          DiskCacheFactory.newDiskStorageCache(mConfig.getSmallImageDiskCacheConfig());
+    public DiskStorageCache getSmallImageDiskStorageCache() {
+        if (mSmallImageDiskStorageCache == null) {
+            mSmallImageDiskStorageCache =
+                    DiskCacheFactory.newDiskStorageCache(mConfig.getSmallImageDiskCacheConfig());
+        }
+        return mSmallImageDiskStorageCache;
     }
-    return mSmallImageDiskStorageCache;
-  }
 
-  private BufferedDiskCache getSmallImageBufferedDiskCache() {
-    if (mSmallImageBufferedDiskCache == null) {
-      mSmallImageBufferedDiskCache =
-          new BufferedDiskCache(
-              getSmallImageDiskStorageCache(),
-              mConfig.getPoolFactory().getPooledByteBufferFactory(),
-              mConfig.getPoolFactory().getPooledByteStreams(),
-              mConfig.getExecutorSupplier().forLocalStorageRead(),
-              mConfig.getExecutorSupplier().forLocalStorageWrite(),
-              mConfig.getImageCacheStatsTracker());
+    private BufferedDiskCache getSmallImageBufferedDiskCache() {
+        if (mSmallImageBufferedDiskCache == null) {
+            mSmallImageBufferedDiskCache =
+                    new BufferedDiskCache(
+                            getSmallImageDiskStorageCache(),
+                            mConfig.getPoolFactory().getPooledByteBufferFactory(),
+                            mConfig.getPoolFactory().getPooledByteStreams(),
+                            mConfig.getExecutorSupplier().forLocalStorageRead(),
+                            mConfig.getExecutorSupplier().forLocalStorageWrite(),
+                            mConfig.getImageCacheStatsTracker());
+        }
+        return mSmallImageBufferedDiskCache;
     }
-    return mSmallImageBufferedDiskCache;
-  }
 
-  public AnimatedDrawableFactory getAnimatedDrawableFactory() {
-    if (mAnimatedDrawableFactory == null) {
-      final AnimatedDrawableUtil animatedDrawableUtil = new AnimatedDrawableUtil();
-      final MonotonicClock monotonicClock = RealtimeSinceBootClock.get();
-      final SerialExecutorService serialExecutorService =
-          new DefaultSerialExecutorService(mConfig.getExecutorSupplier().forDecode());
-      final ActivityManager activityManager =
-          (ActivityManager) mConfig.getContext().getSystemService(Context.ACTIVITY_SERVICE);
+    public AnimatedDrawableFactory getAnimatedDrawableFactory() {
+        if (mAnimatedDrawableFactory == null) {
+            final AnimatedDrawableUtil animatedDrawableUtil = new AnimatedDrawableUtil();
+            final MonotonicClock monotonicClock = RealtimeSinceBootClock.get();
+            final SerialExecutorService serialExecutorService =
+                    new DefaultSerialExecutorService(mConfig.getExecutorSupplier().forDecode());
+            final ActivityManager activityManager =
+                    (ActivityManager) mConfig.getContext().getSystemService(Context.ACTIVITY_SERVICE);
 
-      AnimatedDrawableCachingBackendImplProvider animatedDrawableCachingBackendImplProvider =
-          new AnimatedDrawableCachingBackendImplProvider() {
-            @Override
-            public AnimatedDrawableCachingBackendImpl get(
-                AnimatedDrawableBackend animatedDrawableBackend,
-                AnimatedDrawableOptions options) {
-              return new AnimatedDrawableCachingBackendImpl(
-                  serialExecutorService,
-                  activityManager,
-                  animatedDrawableUtil,
-                  monotonicClock,
-                  animatedDrawableBackend,
-                  options);
-            }
-          };
+            AnimatedDrawableCachingBackendImplProvider animatedDrawableCachingBackendImplProvider =
+                    new AnimatedDrawableCachingBackendImplProvider() {
+                        @Override
+                        public AnimatedDrawableCachingBackendImpl get(
+                                AnimatedDrawableBackend animatedDrawableBackend,
+                                AnimatedDrawableOptions options) {
+                            return new AnimatedDrawableCachingBackendImpl(
+                                    serialExecutorService,
+                                    activityManager,
+                                    animatedDrawableUtil,
+                                    monotonicClock,
+                                    animatedDrawableBackend,
+                                    options);
+                        }
+                    };
 
-      AnimatedDrawableBackendProvider backendProvider = new AnimatedDrawableBackendProvider() {
-        @Override
-        public AnimatedDrawableBackend get(AnimatedImageResult animatedImageResult, Rect bounds) {
-          return new AnimatedDrawableBackendImpl(animatedDrawableUtil, animatedImageResult, bounds);
-        }
-      };
+            AnimatedDrawableBackendProvider backendProvider = new AnimatedDrawableBackendProvider() {
+                @Override
+                public AnimatedDrawableBackend get(AnimatedImageResult animatedImageResult, Rect bounds) {
+                    return new AnimatedDrawableBackendImpl(animatedDrawableUtil, animatedImageResult, bounds);
+                }
+            };
 
-      mAnimatedDrawableFactory = new AnimatedDrawableFactory(
-          backendProvider,
-          animatedDrawableCachingBackendImplProvider,
-          animatedDrawableUtil,
-          UiThreadImmediateExecutorService.getInstance(),
-          mConfig.getContext().getResources());
+            mAnimatedDrawableFactory = new AnimatedDrawableFactory(
+                    backendProvider,
+                    animatedDrawableCachingBackendImplProvider,
+                    animatedDrawableUtil,
+                    UiThreadImmediateExecutorService.getInstance(),
+                    mConfig.getContext().getResources());
+        }
+        return mAnimatedDrawableFactory;
     }
-    return mAnimatedDrawableFactory;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
index 6e7b8310d..4683d325c 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerFactory.java
@@ -56,201 +56,201 @@
 import com.facebook.imagepipeline.producers.WebpTranscodeProducer;
 
 public class ProducerFactory {
-  // Local dependencies
-  private ContentResolver mContentResolver;
-  private Resources mResources;
-  private AssetManager mAssetManager;
-
-  // Decode dependencies
-  private final ByteArrayPool mByteArrayPool;
-  private final ImageDecoder mImageDecoder;
-  private final ProgressiveJpegConfig mProgressiveJpegConfig;
-
-  // Dependencies used by multiple steps
-  private final ExecutorSupplier mExecutorSupplier;
-  private final PooledByteBufferFactory mPooledByteBufferFactory;
-
-  // Cache dependencies
-  private final BufferedDiskCache mDefaultBufferedDiskCache;
-  private final BufferedDiskCache mSmallImageBufferedDiskCache;
-  private final MemoryCache<CacheKey, PooledByteBuffer> mEncodedMemoryCache;
-  private final MemoryCache<CacheKey, CloseableImage> mBitmapMemoryCache;
-  private final CacheKeyFactory mCacheKeyFactory;
-
-  // Postproc dependencies
-  private final PlatformBitmapFactory mPlatformBitmapFactory;
-
-  public ProducerFactory(
-      Context context,
-      ByteArrayPool byteArrayPool,
-      ImageDecoder imageDecoder,
-      ProgressiveJpegConfig progressiveJpegConfig,
-      ExecutorSupplier executorSupplier,
-      PooledByteBufferFactory pooledByteBufferFactory,
-      MemoryCache<CacheKey, CloseableImage> bitmapMemoryCache,
-      MemoryCache<CacheKey, PooledByteBuffer> encodedMemoryCache,
-      BufferedDiskCache defaultBufferedDiskCache,
-      BufferedDiskCache smallImageBufferedDiskCache,
-      CacheKeyFactory cacheKeyFactory,
-      PlatformBitmapFactory platformBitmapFactory) {
-    mContentResolver = context.getApplicationContext().getContentResolver();
-    mResources = context.getApplicationContext().getResources();
-    mAssetManager = context.getApplicationContext().getAssets();
-
-    mByteArrayPool = byteArrayPool;
-    mImageDecoder = imageDecoder;
-    mProgressiveJpegConfig = progressiveJpegConfig;
-
-    mExecutorSupplier = executorSupplier;
-    mPooledByteBufferFactory = pooledByteBufferFactory;
-
-    mBitmapMemoryCache = bitmapMemoryCache;
-    mEncodedMemoryCache = encodedMemoryCache;
-    mDefaultBufferedDiskCache = defaultBufferedDiskCache;
-    mSmallImageBufferedDiskCache = smallImageBufferedDiskCache;
-    mCacheKeyFactory = cacheKeyFactory;
-
-    mPlatformBitmapFactory = platformBitmapFactory;
-  }
-
-  public static AddImageTransformMetaDataProducer newAddImageTransformMetaDataProducer(
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    return new AddImageTransformMetaDataProducer(nextProducer);
-  }
-
-  public BitmapMemoryCacheGetProducer newBitmapMemoryCacheGetProducer(
-      Producer<CloseableReference<CloseableImage>> nextProducer) {
-    return new BitmapMemoryCacheGetProducer(mBitmapMemoryCache, mCacheKeyFactory, nextProducer);
-  }
-
-  public BitmapMemoryCacheKeyMultiplexProducer newBitmapMemoryCacheKeyMultiplexProducer(
-      Producer<CloseableReference<CloseableImage>> nextProducer) {
-    return new BitmapMemoryCacheKeyMultiplexProducer(mCacheKeyFactory, nextProducer);
-  }
-
-  public BitmapMemoryCacheProducer newBitmapMemoryCacheProducer(
-      Producer<CloseableReference<CloseableImage>> nextProducer) {
-    return new BitmapMemoryCacheProducer(mBitmapMemoryCache, mCacheKeyFactory, nextProducer);
-  }
-
-  public static BranchOnSeparateImagesProducer newBranchOnSeparateImagesProducer(
-      Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer1,
-      Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer2) {
-    return new BranchOnSeparateImagesProducer(nextProducer1, nextProducer2);
-  }
-
-  public DecodeProducer newDecodeProducer(
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    return new DecodeProducer(
-        mByteArrayPool,
-        mExecutorSupplier.forDecode(),
-        mImageDecoder,
-        mProgressiveJpegConfig,
-        nextProducer);
-  }
-
-  public DiskCacheProducer newDiskCacheProducer(
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    return new DiskCacheProducer(
-        mDefaultBufferedDiskCache,
-        mSmallImageBufferedDiskCache,
-        mCacheKeyFactory,
-        nextProducer);
-  }
-
-  public EncodedCacheKeyMultiplexProducer newEncodedCacheKeyMultiplexProducer(
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    return new EncodedCacheKeyMultiplexProducer(mCacheKeyFactory, nextProducer);
-  }
-
-  public EncodedMemoryCacheProducer newEncodedMemoryCacheProducer(
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    return new EncodedMemoryCacheProducer(mEncodedMemoryCache, mCacheKeyFactory, nextProducer);
-  }
-
-  public LocalAssetFetchProducer newLocalAssetFetchProducer() {
-    return new LocalAssetFetchProducer(
-        mExecutorSupplier.forLocalStorageRead(),
-        mPooledByteBufferFactory,
-        mAssetManager);
-  }
-
-  public LocalContentUriFetchProducer newContentUriFetchProducer() {
-    return new LocalContentUriFetchProducer(
-        mExecutorSupplier.forLocalStorageRead(),
-        mPooledByteBufferFactory,
-        mContentResolver);
-  }
-
-  public LocalExifThumbnailProducer newLocalExifThumbnailProducer() {
-    return new LocalExifThumbnailProducer(
-        mExecutorSupplier.forLocalStorageRead(),
-        mPooledByteBufferFactory);
-  }
-
-  public LocalFileFetchProducer newLocalFileFetchProducer() {
-    return new LocalFileFetchProducer(
-        mExecutorSupplier.forLocalStorageRead(),
-        mPooledByteBufferFactory);
-  }
-
-  public LocalResourceFetchProducer newLocalResourceFetchProducer() {
-    return new LocalResourceFetchProducer(
-        mExecutorSupplier.forLocalStorageRead(),
-        mPooledByteBufferFactory,
-        mResources);
-  }
-
-  public LocalVideoThumbnailProducer newLocalVideoThumbnailProducer() {
-    return new LocalVideoThumbnailProducer(mExecutorSupplier.forLocalStorageRead());
-  }
-
-  public NetworkFetchProducer newNetworkFetchProducer(NetworkFetcher networkFetcher) {
-    return new NetworkFetchProducer(mPooledByteBufferFactory, mByteArrayPool, networkFetcher);
-  }
-
-  public static <T> NullProducer<T> newNullProducer() {
-    return new NullProducer<T>();
-  }
-
-  public PostprocessorProducer newPostprocessorProducer(
-      Producer<CloseableReference<CloseableImage>> nextProducer) {
-    return new PostprocessorProducer(
-        nextProducer, mPlatformBitmapFactory, mExecutorSupplier.forBackground());
-  }
-
-  public static RemoveImageTransformMetaDataProducer newRemoveImageTransformMetaDataProducer(
-      Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer) {
-    return new RemoveImageTransformMetaDataProducer(nextProducer);
-  }
-
-  public ResizeAndRotateProducer newResizeAndRotateProducer(
-      Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer) {
-    return new ResizeAndRotateProducer(
-        mExecutorSupplier.forTransform(),
-        mPooledByteBufferFactory,
-        nextProducer);
-  }
-
-  public static <T> SwallowResultProducer<T> newSwallowResultProducer(Producer<T> nextProducer) {
-    return new SwallowResultProducer<T>(nextProducer);
-  }
-
-  public <T> ThreadHandoffProducer<T> newBackgroundThreadHandoffProducer(Producer<T> nextProducer) {
-    return new ThreadHandoffProducer<T>(mExecutorSupplier.forBackground(), nextProducer);
-  }
-
-  public static <T> ThrottlingProducer<T> newThrottlingProducer(
-      int maxSimultaneousRequests,
-      Producer<T> nextProducer) {
-    return new ThrottlingProducer<T>(maxSimultaneousRequests, nextProducer);
-  }
-
-  public WebpTranscodeProducer newWebpTranscodeProducer(
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    return new WebpTranscodeProducer(
-        mExecutorSupplier.forTransform(),
-        mPooledByteBufferFactory,
-        nextProducer);
-  }
+    // Local dependencies
+    private ContentResolver mContentResolver;
+    private Resources mResources;
+    private AssetManager mAssetManager;
+
+    // Decode dependencies
+    private final ByteArrayPool mByteArrayPool;
+    private final ImageDecoder mImageDecoder;
+    private final ProgressiveJpegConfig mProgressiveJpegConfig;
+
+    // Dependencies used by multiple steps
+    private final ExecutorSupplier mExecutorSupplier;
+    private final PooledByteBufferFactory mPooledByteBufferFactory;
+
+    // Cache dependencies
+    private final BufferedDiskCache mDefaultBufferedDiskCache;
+    private final BufferedDiskCache mSmallImageBufferedDiskCache;
+    private final MemoryCache<CacheKey, PooledByteBuffer> mEncodedMemoryCache;
+    private final MemoryCache<CacheKey, CloseableImage> mBitmapMemoryCache;
+    private final CacheKeyFactory mCacheKeyFactory;
+
+    // Postproc dependencies
+    private final PlatformBitmapFactory mPlatformBitmapFactory;
+
+    public ProducerFactory(
+            Context context,
+            ByteArrayPool byteArrayPool,
+            ImageDecoder imageDecoder,
+            ProgressiveJpegConfig progressiveJpegConfig,
+            ExecutorSupplier executorSupplier,
+            PooledByteBufferFactory pooledByteBufferFactory,
+            MemoryCache<CacheKey, CloseableImage> bitmapMemoryCache,
+            MemoryCache<CacheKey, PooledByteBuffer> encodedMemoryCache,
+            BufferedDiskCache defaultBufferedDiskCache,
+            BufferedDiskCache smallImageBufferedDiskCache,
+            CacheKeyFactory cacheKeyFactory,
+            PlatformBitmapFactory platformBitmapFactory) {
+        mContentResolver = context.getApplicationContext().getContentResolver();
+        mResources = context.getApplicationContext().getResources();
+        mAssetManager = context.getApplicationContext().getAssets();
+
+        mByteArrayPool = byteArrayPool;
+        mImageDecoder = imageDecoder;
+        mProgressiveJpegConfig = progressiveJpegConfig;
+
+        mExecutorSupplier = executorSupplier;
+        mPooledByteBufferFactory = pooledByteBufferFactory;
+
+        mBitmapMemoryCache = bitmapMemoryCache;
+        mEncodedMemoryCache = encodedMemoryCache;
+        mDefaultBufferedDiskCache = defaultBufferedDiskCache;
+        mSmallImageBufferedDiskCache = smallImageBufferedDiskCache;
+        mCacheKeyFactory = cacheKeyFactory;
+
+        mPlatformBitmapFactory = platformBitmapFactory;
+    }
+
+    public static AddImageTransformMetaDataProducer newAddImageTransformMetaDataProducer(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        return new AddImageTransformMetaDataProducer(nextProducer);
+    }
+
+    public BitmapMemoryCacheGetProducer newBitmapMemoryCacheGetProducer(
+            Producer<CloseableReference<CloseableImage>> nextProducer) {
+        return new BitmapMemoryCacheGetProducer(mBitmapMemoryCache, mCacheKeyFactory, nextProducer);
+    }
+
+    public BitmapMemoryCacheKeyMultiplexProducer newBitmapMemoryCacheKeyMultiplexProducer(
+            Producer<CloseableReference<CloseableImage>> nextProducer) {
+        return new BitmapMemoryCacheKeyMultiplexProducer(mCacheKeyFactory, nextProducer);
+    }
+
+    public BitmapMemoryCacheProducer newBitmapMemoryCacheProducer(
+            Producer<CloseableReference<CloseableImage>> nextProducer) {
+        return new BitmapMemoryCacheProducer(mBitmapMemoryCache, mCacheKeyFactory, nextProducer);
+    }
+
+    public static BranchOnSeparateImagesProducer newBranchOnSeparateImagesProducer(
+            Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer1,
+            Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer2) {
+        return new BranchOnSeparateImagesProducer(nextProducer1, nextProducer2);
+    }
+
+    public DecodeProducer newDecodeProducer(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        return new DecodeProducer(
+                mByteArrayPool,
+                mExecutorSupplier.forDecode(),
+                mImageDecoder,
+                mProgressiveJpegConfig,
+                nextProducer);
+    }
+
+    public DiskCacheProducer newDiskCacheProducer(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        return new DiskCacheProducer(
+                mDefaultBufferedDiskCache,
+                mSmallImageBufferedDiskCache,
+                mCacheKeyFactory,
+                nextProducer);
+    }
+
+    public EncodedCacheKeyMultiplexProducer newEncodedCacheKeyMultiplexProducer(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        return new EncodedCacheKeyMultiplexProducer(mCacheKeyFactory, nextProducer);
+    }
+
+    public EncodedMemoryCacheProducer newEncodedMemoryCacheProducer(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        return new EncodedMemoryCacheProducer(mEncodedMemoryCache, mCacheKeyFactory, nextProducer);
+    }
+
+    public LocalAssetFetchProducer newLocalAssetFetchProducer() {
+        return new LocalAssetFetchProducer(
+                mExecutorSupplier.forLocalStorageRead(),
+                mPooledByteBufferFactory,
+                mAssetManager);
+    }
+
+    public LocalContentUriFetchProducer newContentUriFetchProducer() {
+        return new LocalContentUriFetchProducer(
+                mExecutorSupplier.forLocalStorageRead(),
+                mPooledByteBufferFactory,
+                mContentResolver);
+    }
+
+    public LocalExifThumbnailProducer newLocalExifThumbnailProducer() {
+        return new LocalExifThumbnailProducer(
+                mExecutorSupplier.forLocalStorageRead(),
+                mPooledByteBufferFactory);
+    }
+
+    public LocalFileFetchProducer newLocalFileFetchProducer() {
+        return new LocalFileFetchProducer(
+                mExecutorSupplier.forLocalStorageRead(),
+                mPooledByteBufferFactory);
+    }
+
+    public LocalResourceFetchProducer newLocalResourceFetchProducer() {
+        return new LocalResourceFetchProducer(
+                mExecutorSupplier.forLocalStorageRead(),
+                mPooledByteBufferFactory,
+                mResources);
+    }
+
+    public LocalVideoThumbnailProducer newLocalVideoThumbnailProducer() {
+        return new LocalVideoThumbnailProducer(mExecutorSupplier.forLocalStorageRead());
+    }
+
+    public NetworkFetchProducer newNetworkFetchProducer(NetworkFetcher networkFetcher) {
+        return new NetworkFetchProducer(mPooledByteBufferFactory, mByteArrayPool, networkFetcher);
+    }
+
+    public static <T> NullProducer<T> newNullProducer() {
+        return new NullProducer<T>();
+    }
+
+    public PostprocessorProducer newPostprocessorProducer(
+            Producer<CloseableReference<CloseableImage>> nextProducer) {
+        return new PostprocessorProducer(
+                nextProducer, mPlatformBitmapFactory, mExecutorSupplier.forBackground());
+    }
+
+    public static RemoveImageTransformMetaDataProducer newRemoveImageTransformMetaDataProducer(
+            Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer) {
+        return new RemoveImageTransformMetaDataProducer(nextProducer);
+    }
+
+    public ResizeAndRotateProducer newResizeAndRotateProducer(
+            Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer) {
+        return new ResizeAndRotateProducer(
+                mExecutorSupplier.forTransform(),
+                mPooledByteBufferFactory,
+                nextProducer);
+    }
+
+    public static <T> SwallowResultProducer<T> newSwallowResultProducer(Producer<T> nextProducer) {
+        return new SwallowResultProducer<T>(nextProducer);
+    }
+
+    public <T> ThreadHandoffProducer<T> newBackgroundThreadHandoffProducer(Producer<T> nextProducer) {
+        return new ThreadHandoffProducer<T>(mExecutorSupplier.forBackground(), nextProducer);
+    }
+
+    public static <T> ThrottlingProducer<T> newThrottlingProducer(
+            int maxSimultaneousRequests,
+            Producer<T> nextProducer) {
+        return new ThrottlingProducer<T>(maxSimultaneousRequests, nextProducer);
+    }
+
+    public WebpTranscodeProducer newWebpTranscodeProducer(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        return new WebpTranscodeProducer(
+                mExecutorSupplier.forTransform(),
+                mPooledByteBufferFactory,
+                nextProducer);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
index a87900778..49638d3ea 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ProducerSequenceFactory.java
@@ -46,405 +46,421 @@
 import com.facebook.imagepipeline.request.ImageRequest;
 
 public class ProducerSequenceFactory {
-  private static final int MAX_SIMULTANEOUS_FILE_FETCH_AND_RESIZE = 5;
-
-  private final ProducerFactory mProducerFactory;
-  private final NetworkFetcher mNetworkFetcher;
-  private final boolean mResizeAndRotateEnabledForNetwork;
-
-  // Saved sequences
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mNetworkFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<PooledByteBuffer>>
-      mBackgroundNetworkFetchToEncodedMemorySequence;
-  @VisibleForTesting Producer<Void> mNetworkFetchToEncodedMemoryPrefetchSequence;
-  private Producer<CloseableReference<PooledByteBuffer>>
-      mCommonNetworkFetchToEncodedMemorySequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalImageFileFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalVideoFileFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalContentUriFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalResourceFetchSequence;
-  @VisibleForTesting Producer<CloseableReference<CloseableImage>> mLocalAssetFetchSequence;
-  @VisibleForTesting Map<
-      Producer<CloseableReference<CloseableImage>>,
-      Producer<CloseableReference<CloseableImage>>>
-      mPostprocessorSequences;
-  @VisibleForTesting Map<Producer<CloseableReference<CloseableImage>>, Producer<Void>>
-      mCloseableImagePrefetchSequences;
-
-  public ProducerSequenceFactory(
-      ProducerFactory producerFactory,
-      NetworkFetcher networkFetcher,
-      boolean resizeAndRotateEnabledForNetwork) {
-    mProducerFactory = producerFactory;
-    mNetworkFetcher = networkFetcher;
-    mResizeAndRotateEnabledForNetwork = resizeAndRotateEnabledForNetwork;
-    mPostprocessorSequences = Maps.newHashMap();
-    mCloseableImagePrefetchSequences = Maps.newHashMap();
-  }
-
-  /**
-   * Returns a sequence that can be used for a request for an encoded image.
-   *
-   * @param imageRequest the request that will be submitted
-   * @return the sequence that should be used to process the request
-   */
-  public Producer<CloseableReference<PooledByteBuffer>> getEncodedImageProducerSequence(
-      ImageRequest imageRequest) {
-    validateEncodedImageRequest(imageRequest);
-    return getBackgroundNetworkFetchToEncodedMemorySequence();
-  }
-
-  /**
-   * Returns a sequence that can be used for a prefetch request for an encoded image.
-   *
-   * <p>Guaranteed to return the same sequence as
-   * {@code getEncodedImageProducerSequence(request)}, except that it is pre-pended with a
-   * {@link SwallowResultProducer}.
-   * @param imageRequest the request that will be submitted
-   * @return the sequence that should be used to process the request
-   */
-  public Producer<Void> getEncodedImagePrefetchProducerSequence(ImageRequest imageRequest) {
-    validateEncodedImageRequest(imageRequest);
-    return getNetworkFetchToEncodedMemoryPrefetchSequence();
-  }
-
-  private static void validateEncodedImageRequest(ImageRequest imageRequest) {
-    Preconditions.checkNotNull(imageRequest);
-    Preconditions.checkArgument(UriUtil.isNetworkUri(imageRequest.getSourceUri()));
-    Preconditions.checkArgument(
-        imageRequest.getLowestPermittedRequestLevel().getValue() <=
-            ImageRequest.RequestLevel.ENCODED_MEMORY_CACHE.getValue());
-  }
-
-  /**
-   * Returns a sequence that can be used for a request for a decoded image.
-   *
-   * @param imageRequest the request that will be submitted
-   * @return the sequence that should be used to process the request
-   */
-  public Producer<CloseableReference<CloseableImage>> getDecodedImageProducerSequence(
-      ImageRequest imageRequest) {
-    Producer<CloseableReference<CloseableImage>> pipelineSequence =
-        getBasicDecodedImageSequence(imageRequest);
-    if (imageRequest.getPostprocessor() != null) {
-      return getPostprocessorSequence(pipelineSequence);
-    } else {
-      return pipelineSequence;
+    private static final int MAX_SIMULTANEOUS_FILE_FETCH_AND_RESIZE = 5;
+
+    private final ProducerFactory mProducerFactory;
+    private final NetworkFetcher mNetworkFetcher;
+    private final boolean mResizeAndRotateEnabledForNetwork;
+
+    // Saved sequences
+    @VisibleForTesting
+    Producer<CloseableReference<CloseableImage>> mNetworkFetchSequence;
+    @VisibleForTesting
+    Producer<CloseableReference<PooledByteBuffer>>
+            mBackgroundNetworkFetchToEncodedMemorySequence;
+    @VisibleForTesting
+    Producer<Void> mNetworkFetchToEncodedMemoryPrefetchSequence;
+    private Producer<CloseableReference<PooledByteBuffer>>
+            mCommonNetworkFetchToEncodedMemorySequence;
+    @VisibleForTesting
+    Producer<CloseableReference<CloseableImage>> mLocalImageFileFetchSequence;
+    @VisibleForTesting
+    Producer<CloseableReference<CloseableImage>> mLocalVideoFileFetchSequence;
+    @VisibleForTesting
+    Producer<CloseableReference<CloseableImage>> mLocalContentUriFetchSequence;
+    @VisibleForTesting
+    Producer<CloseableReference<CloseableImage>> mLocalResourceFetchSequence;
+    @VisibleForTesting
+    Producer<CloseableReference<CloseableImage>> mLocalAssetFetchSequence;
+    @VisibleForTesting
+    Map<
+            Producer<CloseableReference<CloseableImage>>,
+            Producer<CloseableReference<CloseableImage>>>
+            mPostprocessorSequences;
+    @VisibleForTesting
+    Map<Producer<CloseableReference<CloseableImage>>, Producer<Void>>
+            mCloseableImagePrefetchSequences;
+
+    public ProducerSequenceFactory(
+            ProducerFactory producerFactory,
+            NetworkFetcher networkFetcher,
+            boolean resizeAndRotateEnabledForNetwork) {
+        mProducerFactory = producerFactory;
+        mNetworkFetcher = networkFetcher;
+        mResizeAndRotateEnabledForNetwork = resizeAndRotateEnabledForNetwork;
+        mPostprocessorSequences = Maps.newHashMap();
+        mCloseableImagePrefetchSequences = Maps.newHashMap();
     }
-  }
-
-  /**
-   * Returns a sequence that can be used for a prefetch request for a decoded image.
-   *
-   * @param imageRequest the request that will be submitted
-   * @return the sequence that should be used to process the request
-   */
-  public Producer<Void> getDecodedImagePrefetchProducerSequence(
-      ImageRequest imageRequest) {
-    return getDecodedImagePrefetchSequence(getBasicDecodedImageSequence(imageRequest));
-  }
-
-  private Producer<CloseableReference<CloseableImage>> getBasicDecodedImageSequence(
-      ImageRequest imageRequest) {
-    Preconditions.checkNotNull(imageRequest);
-
-    Uri uri = imageRequest.getSourceUri();
-    Preconditions.checkNotNull(uri, "Uri is null.");
-    if (UriUtil.isNetworkUri(uri)) {
-      return getNetworkFetchSequence();
-    } else if (UriUtil.isLocalFileUri(uri)) {
-      if (MediaUtils.isVideo(MediaUtils.extractMime(uri.getPath()))) {
-        return getLocalVideoFileFetchSequence();
-      } else {
-        return getLocalImageFileFetchSequence();
-      }
-    } else if (UriUtil.isLocalContentUri(uri)) {
-      return getLocalContentUriFetchSequence();
-    } else if (UriUtil.isLocalAssetUri(uri)) {
-      return getLocalAssetFetchSequence();
-    } else if (UriUtil.isLocalResourceUri(uri)) {
-      return getLocalResourceFetchSequence();
-    } else {
-      String uriString = uri.toString();
-      if (uriString.length() > 30) {
-        uriString = uriString.substring(0, 30) + "...";
-      }
-      throw new RuntimeException("Unsupported uri scheme! Uri is: " + uriString);
+
+    /**
+     * Returns a sequence that can be used for a request for an encoded image.
+     *
+     * @param imageRequest the request that will be submitted
+     * @return the sequence that should be used to process the request
+     */
+    public Producer<CloseableReference<PooledByteBuffer>> getEncodedImageProducerSequence(
+            ImageRequest imageRequest) {
+        validateEncodedImageRequest(imageRequest);
+        return getBackgroundNetworkFetchToEncodedMemorySequence();
     }
-  }
-
-  /**
-   * swallow result if prefetch -> bitmap cache get -> wait if scrolling ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode -> multiplex ->
-   * encoded cache -> disk cache -> (webp transcode) -> network fetch.
-   */
-  private synchronized Producer<CloseableReference<CloseableImage>> getNetworkFetchSequence() {
-    if (mNetworkFetchSequence == null) {
-      mNetworkFetchSequence =
-          newBitmapCacheGetToDecodeSequence(getCommonNetworkFetchToEncodedMemorySequence());
+
+    /**
+     * Returns a sequence that can be used for a prefetch request for an encoded image.
+     * <p>
+     * <p>Guaranteed to return the same sequence as
+     * {@code getEncodedImageProducerSequence(request)}, except that it is pre-pended with a
+     * {@link SwallowResultProducer}.
+     *
+     * @param imageRequest the request that will be submitted
+     * @return the sequence that should be used to process the request
+     */
+    public Producer<Void> getEncodedImagePrefetchProducerSequence(ImageRequest imageRequest) {
+        validateEncodedImageRequest(imageRequest);
+        return getNetworkFetchToEncodedMemoryPrefetchSequence();
     }
-    return mNetworkFetchSequence;
-  }
-
-  /**
-   * background-thread hand-off -> multiplex -> encoded cache ->
-   * disk cache -> (webp transcode) -> network fetch.
-   */
-  private synchronized Producer<CloseableReference<PooledByteBuffer>>
-      getBackgroundNetworkFetchToEncodedMemorySequence() {
-    if (mBackgroundNetworkFetchToEncodedMemorySequence == null) {
-      // Use hand-off producer to ensure that we don't do any unnecessary work on the UI thread.
-      mBackgroundNetworkFetchToEncodedMemorySequence =
-          mProducerFactory.newBackgroundThreadHandoffProducer(
-              getCommonNetworkFetchToEncodedMemorySequence());
+
+    private static void validateEncodedImageRequest(ImageRequest imageRequest) {
+        Preconditions.checkNotNull(imageRequest);
+        Preconditions.checkArgument(UriUtil.isNetworkUri(imageRequest.getSourceUri()));
+        Preconditions.checkArgument(
+                imageRequest.getLowestPermittedRequestLevel().getValue() <=
+                        ImageRequest.RequestLevel.ENCODED_MEMORY_CACHE.getValue());
     }
-    return mBackgroundNetworkFetchToEncodedMemorySequence;
-  }
-
-  /**
-   * swallow-result -> background-thread hand-off -> multiplex -> encoded cache ->
-   * disk cache -> (webp transcode) -> network fetch.
-   */
-  private synchronized Producer<Void> getNetworkFetchToEncodedMemoryPrefetchSequence() {
-    if (mNetworkFetchToEncodedMemoryPrefetchSequence == null) {
-      mNetworkFetchToEncodedMemoryPrefetchSequence =
-          mProducerFactory.newSwallowResultProducer(
-              getBackgroundNetworkFetchToEncodedMemorySequence());
+
+    /**
+     * Returns a sequence that can be used for a request for a decoded image.
+     *
+     * @param imageRequest the request that will be submitted
+     * @return the sequence that should be used to process the request
+     */
+    public Producer<CloseableReference<CloseableImage>> getDecodedImageProducerSequence(
+            ImageRequest imageRequest) {
+        Producer<CloseableReference<CloseableImage>> pipelineSequence =
+                getBasicDecodedImageSequence(imageRequest);
+        if (imageRequest.getPostprocessor() != null) {
+            return getPostprocessorSequence(pipelineSequence);
+        } else {
+            return pipelineSequence;
+        }
     }
-    return mNetworkFetchToEncodedMemoryPrefetchSequence;
-  }
-
-  /**
-   * multiplex -> encoded cache -> disk cache -> (webp transcode) -> network fetch.
-   */
-  private synchronized Producer<CloseableReference<PooledByteBuffer>>
-      getCommonNetworkFetchToEncodedMemorySequence() {
-    if (mCommonNetworkFetchToEncodedMemorySequence == null) {
-      mCommonNetworkFetchToEncodedMemorySequence = newEncodedCacheMultiplexToTranscodeSequence(
-          mProducerFactory.newNetworkFetchProducer(mNetworkFetcher));
-      if (mResizeAndRotateEnabledForNetwork) {
-        mCommonNetworkFetchToEncodedMemorySequence =
-            newResizeAndRotateImagesSequence(mCommonNetworkFetchToEncodedMemorySequence);
-      }
+
+    /**
+     * Returns a sequence that can be used for a prefetch request for a decoded image.
+     *
+     * @param imageRequest the request that will be submitted
+     * @return the sequence that should be used to process the request
+     */
+    public Producer<Void> getDecodedImagePrefetchProducerSequence(
+            ImageRequest imageRequest) {
+        return getDecodedImagePrefetchSequence(getBasicDecodedImageSequence(imageRequest));
     }
-    return mCommonNetworkFetchToEncodedMemorySequence;
-  }
-
-  /**
-   * bitmap cache get -> wait if scrolling ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode ->
-   * branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
-   *   -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
-   *   (webp transcode) -> local file fetch.
-   */
-  private synchronized Producer<CloseableReference<CloseableImage>>
-      getLocalImageFileFetchSequence() {
-    if (mLocalImageFileFetchSequence == null) {
-      LocalFileFetchProducer localFileFetchProducer =
-          mProducerFactory.newLocalFileFetchProducer();
-      mLocalImageFileFetchSequence =
-          newBitmapCacheGetToTranscodeSequence(localFileFetchProducer, /* isLocal */true);
+
+    private Producer<CloseableReference<CloseableImage>> getBasicDecodedImageSequence(
+            ImageRequest imageRequest) {
+        Preconditions.checkNotNull(imageRequest);
+
+        Uri uri = imageRequest.getSourceUri();
+        Preconditions.checkNotNull(uri, "Uri is null.");
+        if (UriUtil.isNetworkUri(uri)) {
+            return getNetworkFetchSequence();
+        } else if (UriUtil.isLocalFileUri(uri)) {
+            if (MediaUtils.isVideo(MediaUtils.extractMime(uri.getPath()))) {
+                return getLocalVideoFileFetchSequence();
+            } else {
+                return getLocalImageFileFetchSequence();
+            }
+        } else if (UriUtil.isLocalContentUri(uri)) {
+            return getLocalContentUriFetchSequence();
+        } else if (UriUtil.isLocalAssetUri(uri)) {
+            return getLocalAssetFetchSequence();
+        } else if (UriUtil.isLocalResourceUri(uri)) {
+            return getLocalResourceFetchSequence();
+        } else {
+            String uriString = uri.toString();
+            if (uriString.length() > 30) {
+                uriString = uriString.substring(0, 30) + "...";
+            }
+            throw new RuntimeException("Unsupported uri scheme! Uri is: " + uriString);
+        }
     }
-    return mLocalImageFileFetchSequence;
-  }
-
-  /**
-   * Bitmap cache get -> wait if scrolling -> thread hand off -> multiplex -> bitmap cache ->
-   * local video thumbnail
-   */
-  private synchronized Producer<CloseableReference<CloseableImage>>
-      getLocalVideoFileFetchSequence() {
-    if (mLocalVideoFileFetchSequence == null) {
-      LocalVideoThumbnailProducer localVideoThumbnailProducer =
-          mProducerFactory.newLocalVideoThumbnailProducer();
-      mLocalVideoFileFetchSequence =
-          newBitmapCacheGetToBitmapCacheSequence(localVideoThumbnailProducer);
+
+    /**
+     * swallow result if prefetch -> bitmap cache get -> wait if scrolling ->
+     * background thread hand-off -> multiplex -> bitmap cache -> decode -> multiplex ->
+     * encoded cache -> disk cache -> (webp transcode) -> network fetch.
+     */
+    private synchronized Producer<CloseableReference<CloseableImage>> getNetworkFetchSequence() {
+        if (mNetworkFetchSequence == null) {
+            mNetworkFetchSequence =
+                    newBitmapCacheGetToDecodeSequence(getCommonNetworkFetchToEncodedMemorySequence());
+        }
+        return mNetworkFetchSequence;
     }
-    return mLocalVideoFileFetchSequence;
-  }
-
-  /**
-   * bitmap cache get -> wait if scrolling ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode ->
-   * branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
-   *   -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
-   *   (webp transcode) -> local content uri fetch.
-   */
-  private synchronized Producer<CloseableReference<CloseableImage>>
-      getLocalContentUriFetchSequence() {
-    if (mLocalContentUriFetchSequence == null) {
-      LocalContentUriFetchProducer localContentUriFetchProducer =
-          mProducerFactory.newContentUriFetchProducer();
-      mLocalContentUriFetchSequence =
-          newBitmapCacheGetToTranscodeSequence(localContentUriFetchProducer, /* isLocal */true);
+
+    /**
+     * background-thread hand-off -> multiplex -> encoded cache ->
+     * disk cache -> (webp transcode) -> network fetch.
+     */
+    private synchronized Producer<CloseableReference<PooledByteBuffer>>
+    getBackgroundNetworkFetchToEncodedMemorySequence() {
+        if (mBackgroundNetworkFetchToEncodedMemorySequence == null) {
+            // Use hand-off producer to ensure that we don't do any unnecessary work on the UI thread.
+            mBackgroundNetworkFetchToEncodedMemorySequence =
+                    mProducerFactory.newBackgroundThreadHandoffProducer(
+                            getCommonNetworkFetchToEncodedMemorySequence());
+        }
+        return mBackgroundNetworkFetchToEncodedMemorySequence;
     }
-    return mLocalContentUriFetchSequence;
-  }
-
-  /**
-   * bitmap cache get -> wait if scrolling ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode ->
-   * branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
-   *   -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
-   *   (webp transcode) -> local resource fetch.
-   */
-  private synchronized Producer<CloseableReference<CloseableImage>>
-      getLocalResourceFetchSequence() {
-    if (mLocalResourceFetchSequence == null) {
-      LocalResourceFetchProducer localResourceFetchProducer =
-          mProducerFactory.newLocalResourceFetchProducer();
-      mLocalResourceFetchSequence =
-          newBitmapCacheGetToTranscodeSequence(localResourceFetchProducer, /* isLocal */true);
+
+    /**
+     * swallow-result -> background-thread hand-off -> multiplex -> encoded cache ->
+     * disk cache -> (webp transcode) -> network fetch.
+     */
+    private synchronized Producer<Void> getNetworkFetchToEncodedMemoryPrefetchSequence() {
+        if (mNetworkFetchToEncodedMemoryPrefetchSequence == null) {
+            mNetworkFetchToEncodedMemoryPrefetchSequence =
+                    mProducerFactory.newSwallowResultProducer(
+                            getBackgroundNetworkFetchToEncodedMemorySequence());
+        }
+        return mNetworkFetchToEncodedMemoryPrefetchSequence;
     }
-    return mLocalResourceFetchSequence;
-  }
-
-  /**
-   * bitmap cache get -> wait if scrolling ->
-   * background thread hand-off -> multiplex -> bitmap cache -> decode ->
-   * branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
-   *   -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
-   *   (webp transcode) -> local asset fetch.
-   */
-  private synchronized Producer<CloseableReference<CloseableImage>> getLocalAssetFetchSequence() {
-    if (mLocalAssetFetchSequence == null) {
-      LocalAssetFetchProducer localAssetFetchProducer =
-          mProducerFactory.newLocalAssetFetchProducer();
-      mLocalAssetFetchSequence =
-          newBitmapCacheGetToTranscodeSequence(localAssetFetchProducer, /* isLocal */true);
+
+    /**
+     * multiplex -> encoded cache -> disk cache -> (webp transcode) -> network fetch.
+     */
+    private synchronized Producer<CloseableReference<PooledByteBuffer>>
+    getCommonNetworkFetchToEncodedMemorySequence() {
+        if (mCommonNetworkFetchToEncodedMemorySequence == null) {
+            mCommonNetworkFetchToEncodedMemorySequence = newEncodedCacheMultiplexToTranscodeSequence(
+                    mProducerFactory.newNetworkFetchProducer(mNetworkFetcher));
+            if (mResizeAndRotateEnabledForNetwork) {
+                mCommonNetworkFetchToEncodedMemorySequence =
+                        newResizeAndRotateImagesSequence(mCommonNetworkFetchToEncodedMemorySequence);
+            }
+        }
+        return mCommonNetworkFetchToEncodedMemorySequence;
+    }
+
+    /**
+     * bitmap cache get -> wait if scrolling ->
+     * background thread hand-off -> multiplex -> bitmap cache -> decode ->
+     * branch on separate images
+     * -> exif resize and rotate -> exif thumbnail creation
+     * -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
+     * (webp transcode) -> local file fetch.
+     */
+    private synchronized Producer<CloseableReference<CloseableImage>>
+    getLocalImageFileFetchSequence() {
+        if (mLocalImageFileFetchSequence == null) {
+            LocalFileFetchProducer localFileFetchProducer =
+                    mProducerFactory.newLocalFileFetchProducer();
+            mLocalImageFileFetchSequence =
+                    newBitmapCacheGetToTranscodeSequence(localFileFetchProducer, /* isLocal */true);
+        }
+        return mLocalImageFileFetchSequence;
+    }
+
+    /**
+     * Bitmap cache get -> wait if scrolling -> thread hand off -> multiplex -> bitmap cache ->
+     * local video thumbnail
+     */
+    private synchronized Producer<CloseableReference<CloseableImage>>
+    getLocalVideoFileFetchSequence() {
+        if (mLocalVideoFileFetchSequence == null) {
+            LocalVideoThumbnailProducer localVideoThumbnailProducer =
+                    mProducerFactory.newLocalVideoThumbnailProducer();
+            mLocalVideoFileFetchSequence =
+                    newBitmapCacheGetToBitmapCacheSequence(localVideoThumbnailProducer);
+        }
+        return mLocalVideoFileFetchSequence;
     }
-    return mLocalAssetFetchSequence;
-  }
-
-  /**
-   * Creates a new fetch sequence that just needs the source producer.
-   * @param nextProducer the source producer
-   * @param isLocal whether the image source is local or not
-   * @return the new sequence
-   */
-  private Producer<CloseableReference<CloseableImage>> newBitmapCacheGetToTranscodeSequence(
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer,
-      boolean isLocal) {
-    Producer<CloseableReference<PooledByteBuffer>> nextProducerAfterDecode =
-        newEncodedCacheMultiplexToTranscodeSequence(nextProducer);
-    if (isLocal) {
-      nextProducerAfterDecode = newLocalTransformationsSequence(nextProducerAfterDecode);
+
+    /**
+     * bitmap cache get -> wait if scrolling ->
+     * background thread hand-off -> multiplex -> bitmap cache -> decode ->
+     * branch on separate images
+     * -> exif resize and rotate -> exif thumbnail creation
+     * -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
+     * (webp transcode) -> local content uri fetch.
+     */
+    private synchronized Producer<CloseableReference<CloseableImage>>
+    getLocalContentUriFetchSequence() {
+        if (mLocalContentUriFetchSequence == null) {
+            LocalContentUriFetchProducer localContentUriFetchProducer =
+                    mProducerFactory.newContentUriFetchProducer();
+            mLocalContentUriFetchSequence =
+                    newBitmapCacheGetToTranscodeSequence(localContentUriFetchProducer, /* isLocal */true);
+        }
+        return mLocalContentUriFetchSequence;
     }
-    return newBitmapCacheGetToDecodeSequence(nextProducerAfterDecode);
-  }
-
-  /**
-   * Same as {@code newBitmapCacheGetToBitmapCacheSequence} but with an extra DecodeProducer.
-   * @param nextProducer next producer in the sequence after decode
-   * @return bitmap cache get to decode sequence
-   */
-  private Producer<CloseableReference<CloseableImage>> newBitmapCacheGetToDecodeSequence(
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    DecodeProducer decodeProducer = mProducerFactory.newDecodeProducer(nextProducer);
-    return newBitmapCacheGetToBitmapCacheSequence(decodeProducer);
-  }
-
-  /**
-   * encoded cache multiplex -> encoded cache -> (disk cache) -> (webp transcode)
-   * @param nextProducer next producer in the sequence
-   * @return encoded cache multiplex to webp transcode sequence
-   */
-  private Producer<CloseableReference<PooledByteBuffer>>
-      newEncodedCacheMultiplexToTranscodeSequence(
-          Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2) {
-      nextProducer = mProducerFactory.newWebpTranscodeProducer(nextProducer);
+
+    /**
+     * bitmap cache get -> wait if scrolling ->
+     * background thread hand-off -> multiplex -> bitmap cache -> decode ->
+     * branch on separate images
+     * -> exif resize and rotate -> exif thumbnail creation
+     * -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
+     * (webp transcode) -> local resource fetch.
+     */
+    private synchronized Producer<CloseableReference<CloseableImage>>
+    getLocalResourceFetchSequence() {
+        if (mLocalResourceFetchSequence == null) {
+            LocalResourceFetchProducer localResourceFetchProducer =
+                    mProducerFactory.newLocalResourceFetchProducer();
+            mLocalResourceFetchSequence =
+                    newBitmapCacheGetToTranscodeSequence(localResourceFetchProducer, /* isLocal */true);
+        }
+        return mLocalResourceFetchSequence;
     }
-    nextProducer = mProducerFactory.newDiskCacheProducer(nextProducer);
-    EncodedMemoryCacheProducer encodedMemoryCacheProducer =
-        mProducerFactory.newEncodedMemoryCacheProducer(nextProducer);
-    return mProducerFactory.newEncodedCacheKeyMultiplexProducer(encodedMemoryCacheProducer);
-  }
-
-  /**
-   * Bitmap cache get -> wait if scrolling -> thread hand off -> multiplex -> bitmap cache
-   * @param nextProducer next producer in the sequence after bitmap cache
-   * @return bitmap cache get to bitmap cache sequence
-   */
-  private Producer<CloseableReference<CloseableImage>> newBitmapCacheGetToBitmapCacheSequence(
-      Producer<CloseableReference<CloseableImage>> nextProducer) {
-    BitmapMemoryCacheProducer bitmapMemoryCacheProducer =
-        mProducerFactory.newBitmapMemoryCacheProducer(nextProducer);
-    BitmapMemoryCacheKeyMultiplexProducer bitmapKeyMultiplexProducer =
-        mProducerFactory.newBitmapMemoryCacheKeyMultiplexProducer(bitmapMemoryCacheProducer);
-    ThreadHandoffProducer<CloseableReference<CloseableImage>> threadHandoffProducer =
-        mProducerFactory.newBackgroundThreadHandoffProducer(bitmapKeyMultiplexProducer);
-    return mProducerFactory.newBitmapMemoryCacheGetProducer(threadHandoffProducer);
-  }
-
-  private Producer<CloseableReference<PooledByteBuffer>>
-      newResizeAndRotateImagesSequence(
-          Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    AddImageTransformMetaDataProducer addImageTransformMetaDataProducer =
-        ProducerFactory.newAddImageTransformMetaDataProducer(nextProducer);
-    ResizeAndRotateProducer networkImageResizeAndRotateProducer =
-        mProducerFactory.newResizeAndRotateProducer(addImageTransformMetaDataProducer);
-    return ProducerFactory.newRemoveImageTransformMetaDataProducer(
-            networkImageResizeAndRotateProducer);
-  }
-
-  /**
-   * Remove image transform meta data -> branch on separate images
-   *   -> exif resize and rotate -> exif thumbnail creation
-   *   -> local image resize and rotate -> add meta data producer
-   * @param nextProducer next producer in the sequence after add meta data producer
-   * @return local transformations sequence
-   */
-  private Producer<CloseableReference<PooledByteBuffer>> newLocalTransformationsSequence(
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    AddImageTransformMetaDataProducer addImageTransformMetaDataProducer =
-        mProducerFactory.newAddImageTransformMetaDataProducer(nextProducer);
-    ResizeAndRotateProducer localImageResizeAndRotateProducer =
-        mProducerFactory.newResizeAndRotateProducer(addImageTransformMetaDataProducer);
-    ThrottlingProducer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>>
-        localImageThrottlingProducer =
-        mProducerFactory.newThrottlingProducer(
-            MAX_SIMULTANEOUS_FILE_FETCH_AND_RESIZE,
-            localImageResizeAndRotateProducer);
-    LocalExifThumbnailProducer localExifThumbnailProducer =
-        mProducerFactory.newLocalExifThumbnailProducer();
-    ResizeAndRotateProducer exifThumbnailResizeAndRotateProducer =
-        mProducerFactory.newResizeAndRotateProducer(localExifThumbnailProducer);
-    BranchOnSeparateImagesProducer branchOnSeparateImagesProducer =
-        mProducerFactory.newBranchOnSeparateImagesProducer(
-            exifThumbnailResizeAndRotateProducer,
-            localImageThrottlingProducer);
-    return mProducerFactory.newRemoveImageTransformMetaDataProducer(branchOnSeparateImagesProducer);
-
-  }
-
-  /**
-   * post-processor producer -> copy producer -> next producer
-   */
-  private synchronized Producer<CloseableReference<CloseableImage>> getPostprocessorSequence(
-      Producer<CloseableReference<CloseableImage>> nextProducer) {
-    if (!mPostprocessorSequences.containsKey(nextProducer)) {
-      PostprocessorProducer postprocessorProducer =
-          mProducerFactory.newPostprocessorProducer(nextProducer);
-      mPostprocessorSequences.put(nextProducer, postprocessorProducer);
+
+    /**
+     * bitmap cache get -> wait if scrolling ->
+     * background thread hand-off -> multiplex -> bitmap cache -> decode ->
+     * branch on separate images
+     * -> exif resize and rotate -> exif thumbnail creation
+     * -> local image resize and rotate -> add meta data producer -> multiplex -> encoded cache ->
+     * (webp transcode) -> local asset fetch.
+     */
+    private synchronized Producer<CloseableReference<CloseableImage>> getLocalAssetFetchSequence() {
+        if (mLocalAssetFetchSequence == null) {
+            LocalAssetFetchProducer localAssetFetchProducer =
+                    mProducerFactory.newLocalAssetFetchProducer();
+            mLocalAssetFetchSequence =
+                    newBitmapCacheGetToTranscodeSequence(localAssetFetchProducer, /* isLocal */true);
+        }
+        return mLocalAssetFetchSequence;
     }
-    return mPostprocessorSequences.get(nextProducer);
-  }
-
-  /**
-   * swallow result producer -> next producer
-   */
-  private synchronized Producer<Void> getDecodedImagePrefetchSequence(
-      Producer<CloseableReference<CloseableImage>> nextProducer) {
-    if (!mCloseableImagePrefetchSequences.containsKey(nextProducer)) {
-      SwallowResultProducer<CloseableReference<CloseableImage>> swallowResultProducer =
-          mProducerFactory.newSwallowResultProducer(nextProducer);
-      mCloseableImagePrefetchSequences.put(nextProducer, swallowResultProducer);
+
+    /**
+     * Creates a new fetch sequence that just needs the source producer.
+     *
+     * @param nextProducer the source producer
+     * @param isLocal      whether the image source is local or not
+     * @return the new sequence
+     */
+    private Producer<CloseableReference<CloseableImage>> newBitmapCacheGetToTranscodeSequence(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer,
+            boolean isLocal) {
+        Producer<CloseableReference<PooledByteBuffer>> nextProducerAfterDecode =
+                newEncodedCacheMultiplexToTranscodeSequence(nextProducer);
+        if (isLocal) {
+            nextProducerAfterDecode = newLocalTransformationsSequence(nextProducerAfterDecode);
+        }
+        return newBitmapCacheGetToDecodeSequence(nextProducerAfterDecode);
+    }
+
+    /**
+     * Same as {@code newBitmapCacheGetToBitmapCacheSequence} but with an extra DecodeProducer.
+     *
+     * @param nextProducer next producer in the sequence after decode
+     * @return bitmap cache get to decode sequence
+     */
+    private Producer<CloseableReference<CloseableImage>> newBitmapCacheGetToDecodeSequence(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        DecodeProducer decodeProducer = mProducerFactory.newDecodeProducer(nextProducer);
+        return newBitmapCacheGetToBitmapCacheSequence(decodeProducer);
+    }
+
+    /**
+     * encoded cache multiplex -> encoded cache -> (disk cache) -> (webp transcode)
+     *
+     * @param nextProducer next producer in the sequence
+     * @return encoded cache multiplex to webp transcode sequence
+     */
+    private Producer<CloseableReference<PooledByteBuffer>>
+    newEncodedCacheMultiplexToTranscodeSequence(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            nextProducer = mProducerFactory.newWebpTranscodeProducer(nextProducer);
+        }
+        nextProducer = mProducerFactory.newDiskCacheProducer(nextProducer);
+        EncodedMemoryCacheProducer encodedMemoryCacheProducer =
+                mProducerFactory.newEncodedMemoryCacheProducer(nextProducer);
+        return mProducerFactory.newEncodedCacheKeyMultiplexProducer(encodedMemoryCacheProducer);
+    }
+
+    /**
+     * Bitmap cache get -> wait if scrolling -> thread hand off -> multiplex -> bitmap cache
+     *
+     * @param nextProducer next producer in the sequence after bitmap cache
+     * @return bitmap cache get to bitmap cache sequence
+     */
+    private Producer<CloseableReference<CloseableImage>> newBitmapCacheGetToBitmapCacheSequence(
+            Producer<CloseableReference<CloseableImage>> nextProducer) {
+        BitmapMemoryCacheProducer bitmapMemoryCacheProducer =
+                mProducerFactory.newBitmapMemoryCacheProducer(nextProducer);
+        BitmapMemoryCacheKeyMultiplexProducer bitmapKeyMultiplexProducer =
+                mProducerFactory.newBitmapMemoryCacheKeyMultiplexProducer(bitmapMemoryCacheProducer);
+        ThreadHandoffProducer<CloseableReference<CloseableImage>> threadHandoffProducer =
+                mProducerFactory.newBackgroundThreadHandoffProducer(bitmapKeyMultiplexProducer);
+        return mProducerFactory.newBitmapMemoryCacheGetProducer(threadHandoffProducer);
+    }
+
+    private Producer<CloseableReference<PooledByteBuffer>>
+    newResizeAndRotateImagesSequence(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        AddImageTransformMetaDataProducer addImageTransformMetaDataProducer =
+                ProducerFactory.newAddImageTransformMetaDataProducer(nextProducer);
+        ResizeAndRotateProducer networkImageResizeAndRotateProducer =
+                mProducerFactory.newResizeAndRotateProducer(addImageTransformMetaDataProducer);
+        return ProducerFactory.newRemoveImageTransformMetaDataProducer(
+                networkImageResizeAndRotateProducer);
+    }
+
+    /**
+     * Remove image transform meta data -> branch on separate images
+     * -> exif resize and rotate -> exif thumbnail creation
+     * -> local image resize and rotate -> add meta data producer
+     *
+     * @param nextProducer next producer in the sequence after add meta data producer
+     * @return local transformations sequence
+     */
+    private Producer<CloseableReference<PooledByteBuffer>> newLocalTransformationsSequence(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        AddImageTransformMetaDataProducer addImageTransformMetaDataProducer =
+                mProducerFactory.newAddImageTransformMetaDataProducer(nextProducer);
+        ResizeAndRotateProducer localImageResizeAndRotateProducer =
+                mProducerFactory.newResizeAndRotateProducer(addImageTransformMetaDataProducer);
+        ThrottlingProducer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>>
+                localImageThrottlingProducer =
+                mProducerFactory.newThrottlingProducer(
+                        MAX_SIMULTANEOUS_FILE_FETCH_AND_RESIZE,
+                        localImageResizeAndRotateProducer);
+        LocalExifThumbnailProducer localExifThumbnailProducer =
+                mProducerFactory.newLocalExifThumbnailProducer();
+        ResizeAndRotateProducer exifThumbnailResizeAndRotateProducer =
+                mProducerFactory.newResizeAndRotateProducer(localExifThumbnailProducer);
+        BranchOnSeparateImagesProducer branchOnSeparateImagesProducer =
+                mProducerFactory.newBranchOnSeparateImagesProducer(
+                        exifThumbnailResizeAndRotateProducer,
+                        localImageThrottlingProducer);
+        return mProducerFactory.newRemoveImageTransformMetaDataProducer(branchOnSeparateImagesProducer);
+
+    }
+
+    /**
+     * post-processor producer -> copy producer -> next producer
+     */
+    private synchronized Producer<CloseableReference<CloseableImage>> getPostprocessorSequence(
+            Producer<CloseableReference<CloseableImage>> nextProducer) {
+        if (!mPostprocessorSequences.containsKey(nextProducer)) {
+            PostprocessorProducer postprocessorProducer =
+                    mProducerFactory.newPostprocessorProducer(nextProducer);
+            mPostprocessorSequences.put(nextProducer, postprocessorProducer);
+        }
+        return mPostprocessorSequences.get(nextProducer);
+    }
+
+    /**
+     * swallow result producer -> next producer
+     */
+    private synchronized Producer<Void> getDecodedImagePrefetchSequence(
+            Producer<CloseableReference<CloseableImage>> nextProducer) {
+        if (!mCloseableImagePrefetchSequences.containsKey(nextProducer)) {
+            SwallowResultProducer<CloseableReference<CloseableImage>> swallowResultProducer =
+                    mProducerFactory.newSwallowResultProducer(nextProducer);
+            mCloseableImagePrefetchSequences.put(nextProducer, swallowResultProducer);
+        }
+        return mCloseableImagePrefetchSequences.get(nextProducer);
     }
-    return mCloseableImagePrefetchSequences.get(nextProducer);
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/AbstractProducerToDataSourceAdapter.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/AbstractProducerToDataSourceAdapter.java
index 7b67bbcd4..94c9a9f50 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/AbstractProducerToDataSourceAdapter.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/AbstractProducerToDataSourceAdapter.java
@@ -28,81 +28,81 @@
 @ThreadSafe
 public abstract class AbstractProducerToDataSourceAdapter<T> extends AbstractDataSource<T> {
 
-  private final SettableProducerContext mSettableProducerContext;
-  private final RequestListener mRequestListener;
+    private final SettableProducerContext mSettableProducerContext;
+    private final RequestListener mRequestListener;
 
-  protected AbstractProducerToDataSourceAdapter(
-      Producer<T> producer,
-      SettableProducerContext settableProducerContext,
-      RequestListener requestListener) {
-    mSettableProducerContext = settableProducerContext;
-    mRequestListener = requestListener;
-    mRequestListener.onRequestStart(
-        settableProducerContext.getImageRequest(),
-        mSettableProducerContext.getCallerContext(),
-        mSettableProducerContext.getId(),
-        mSettableProducerContext.isPrefetch());
-    producer.produceResults(createConsumer(), settableProducerContext);
-  }
-
-  private Consumer<T> createConsumer() {
-    return new BaseConsumer<T>() {
-      @Override
-      protected void onNewResultImpl(@Nullable T newResult, boolean isLast) {
-        AbstractProducerToDataSourceAdapter.this.onNewResultImpl(newResult, isLast);
-      }
+    protected AbstractProducerToDataSourceAdapter(
+            Producer<T> producer,
+            SettableProducerContext settableProducerContext,
+            RequestListener requestListener) {
+        mSettableProducerContext = settableProducerContext;
+        mRequestListener = requestListener;
+        mRequestListener.onRequestStart(
+                settableProducerContext.getImageRequest(),
+                mSettableProducerContext.getCallerContext(),
+                mSettableProducerContext.getId(),
+                mSettableProducerContext.isPrefetch());
+        producer.produceResults(createConsumer(), settableProducerContext);
+    }
 
-      @Override
-      protected void onFailureImpl(Throwable throwable) {
-        AbstractProducerToDataSourceAdapter.this.onFailureImpl(throwable);
-      }
+    private Consumer<T> createConsumer() {
+        return new BaseConsumer<T>() {
+            @Override
+            protected void onNewResultImpl(@Nullable T newResult, boolean isLast) {
+                AbstractProducerToDataSourceAdapter.this.onNewResultImpl(newResult, isLast);
+            }
 
-      @Override
-      protected void onCancellationImpl() {
-        AbstractProducerToDataSourceAdapter.this.onCancellationImpl();
-      }
+            @Override
+            protected void onFailureImpl(Throwable throwable) {
+                AbstractProducerToDataSourceAdapter.this.onFailureImpl(throwable);
+            }
 
-      @Override
-      protected void onProgressUpdateImpl(float progress) {
-        AbstractProducerToDataSourceAdapter.this.setProgress(progress);
-      }
-    };
-  }
+            @Override
+            protected void onCancellationImpl() {
+                AbstractProducerToDataSourceAdapter.this.onCancellationImpl();
+            }
 
-  protected void onNewResultImpl(@Nullable T result, boolean isLast) {
-    if (super.setResult(result, isLast)) {
-      if (isLast) {
-        mRequestListener.onRequestSuccess(
-            mSettableProducerContext.getImageRequest(),
-            mSettableProducerContext.getId(),
-            mSettableProducerContext.isPrefetch());
-      }
+            @Override
+            protected void onProgressUpdateImpl(float progress) {
+                AbstractProducerToDataSourceAdapter.this.setProgress(progress);
+            }
+        };
     }
-  }
 
-  private void onFailureImpl(Throwable throwable) {
-    if (super.setFailure(throwable)) {
-      mRequestListener.onRequestFailure(
-          mSettableProducerContext.getImageRequest(),
-          mSettableProducerContext.getId(),
-          throwable,
-          mSettableProducerContext.isPrefetch());
+    protected void onNewResultImpl(@Nullable T result, boolean isLast) {
+        if (super.setResult(result, isLast)) {
+            if (isLast) {
+                mRequestListener.onRequestSuccess(
+                        mSettableProducerContext.getImageRequest(),
+                        mSettableProducerContext.getId(),
+                        mSettableProducerContext.isPrefetch());
+            }
+        }
     }
-  }
 
-  private synchronized void onCancellationImpl() {
-    Preconditions.checkState(isClosed());
-  }
+    private void onFailureImpl(Throwable throwable) {
+        if (super.setFailure(throwable)) {
+            mRequestListener.onRequestFailure(
+                    mSettableProducerContext.getImageRequest(),
+                    mSettableProducerContext.getId(),
+                    throwable,
+                    mSettableProducerContext.isPrefetch());
+        }
+    }
 
-  @Override
-  public boolean close() {
-    if (!super.close()) {
-      return false;
+    private synchronized void onCancellationImpl() {
+        Preconditions.checkState(isClosed());
     }
-    if (!super.isFinished()) {
-      mRequestListener.onRequestCancellation(mSettableProducerContext.getId());
-      mSettableProducerContext.cancel();
+
+    @Override
+    public boolean close() {
+        if (!super.close()) {
+            return false;
+        }
+        if (!super.isFinished()) {
+            mRequestListener.onRequestCancellation(mSettableProducerContext.getId());
+            mSettableProducerContext.cancel();
+        }
+        return true;
     }
-    return true;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/BaseBitmapDataSubscriber.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/BaseBitmapDataSubscriber.java
index 2f4f23eee..a50631502 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/BaseBitmapDataSubscriber.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/BaseBitmapDataSubscriber.java
@@ -22,7 +22,7 @@
 
 /**
  * Implementation of {@link DataSubscriber} for cases where the client wants access to a bitmap.
- *
+ * <p>
  * <p>
  * Sample usage:
  * <pre>
@@ -45,34 +45,35 @@
  * </pre>
  */
 public abstract class BaseBitmapDataSubscriber extends
-    BaseDataSubscriber<CloseableReference<CloseableImage>> {
+        BaseDataSubscriber<CloseableReference<CloseableImage>> {
 
-  @Override
-  public void onNewResultImpl(DataSource<CloseableReference<CloseableImage>> dataSource) {
-    if (!dataSource.isFinished()) {
-      return;
-    }
+    @Override
+    public void onNewResultImpl(DataSource<CloseableReference<CloseableImage>> dataSource) {
+        if (!dataSource.isFinished()) {
+            return;
+        }
 
-    CloseableReference<CloseableImage> closeableImageRef = dataSource.getResult();
-    Bitmap bitmap = null;
-    if (closeableImageRef != null &&
-        closeableImageRef.get() instanceof CloseableBitmap) {
-      bitmap = ((CloseableBitmap) closeableImageRef.get()).getUnderlyingBitmap();
-    }
+        CloseableReference<CloseableImage> closeableImageRef = dataSource.getResult();
+        Bitmap bitmap = null;
+        if (closeableImageRef != null &&
+                closeableImageRef.get() instanceof CloseableBitmap) {
+            bitmap = ((CloseableBitmap) closeableImageRef.get()).getUnderlyingBitmap();
+        }
 
-    try {
-      onNewResultImpl(bitmap);
-    } finally {
-      CloseableReference.closeSafely(closeableImageRef);
+        try {
+            onNewResultImpl(bitmap);
+        } finally {
+            CloseableReference.closeSafely(closeableImageRef);
+        }
     }
-  }
 
-  /**
-   * The bitmap provided to this method is only guaranteed to be around for the lifespan of the
-   * method.
-   *
-   * <p>The framework will free the bitmap's memory after this method has completed.
-   * @param bitmap
-   */
-  protected abstract void onNewResultImpl(@Nullable Bitmap bitmap);
+    /**
+     * The bitmap provided to this method is only guaranteed to be around for the lifespan of the
+     * method.
+     * <p>
+     * <p>The framework will free the bitmap's memory after this method has completed.
+     *
+     * @param bitmap
+     */
+    protected abstract void onNewResultImpl(@Nullable Bitmap bitmap);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/BaseListBitmapDataSubscriber.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/BaseListBitmapDataSubscriber.java
index cd2c4ddab..bdde399f5 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/BaseListBitmapDataSubscriber.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/BaseListBitmapDataSubscriber.java
@@ -24,63 +24,62 @@
 /**
  * Implementation of {@link DataSubscriber} for cases where the client wants to access
  * a list of bitmaps.
- *
+ * <p>
  * <p>
  * Sample usage:
  * <code>
- *   dataSource.subscribe(
- *     new BaseListBitmapDataSubscriber() {
- *       @Override
- *       public void onNewResultImpl(@Nullable List<Bitmap> bitmapList) {
- *         // Pass bitmap list to system, which makes a copy of it.
- *         update(bitmapList);
- *         // No need to do any cleanup.
- *       }
+ * dataSource.subscribe(
+ * new BaseListBitmapDataSubscriber() {
  *
- *       @Override
- *       public void onFailureImpl(DataSource dataSource) {
- *         // No cleanup required here.
- *       }
- *     }
+ * @Override public void onNewResultImpl(@Nullable List<Bitmap> bitmapList) {
+ * // Pass bitmap list to system, which makes a copy of it.
+ * update(bitmapList);
+ * // No need to do any cleanup.
+ * }
+ * @Override public void onFailureImpl(DataSource dataSource) {
+ * // No cleanup required here.
+ * }
+ * }
  * </code>
  */
 public abstract class BaseListBitmapDataSubscriber extends
-    BaseDataSubscriber<List<CloseableReference<CloseableImage>>> {
+        BaseDataSubscriber<List<CloseableReference<CloseableImage>>> {
 
-  @Override
-  public void onNewResultImpl(DataSource<List<CloseableReference<CloseableImage>>> dataSource) {
-    if (!dataSource.isFinished()) {
-      return;
-    }
-    List<CloseableReference<CloseableImage>> imageRefList = dataSource.getResult();
-    if (imageRefList == null) {
-      onNewResultListImpl(null);
-      return;
-    }
-    try {
-      List<Bitmap> bitmapList =  Lists.newArrayListWithCapacity(imageRefList.size());
-      for (CloseableReference<CloseableImage> closeableImageRef: imageRefList) {
-        if (closeableImageRef != null && closeableImageRef.get() instanceof CloseableBitmap) {
-          bitmapList.add(((CloseableBitmap) closeableImageRef.get()).getUnderlyingBitmap());
-        } else {
-          //This is so that client gets list with same length
-          bitmapList.add(null);
+    @Override
+    public void onNewResultImpl(DataSource<List<CloseableReference<CloseableImage>>> dataSource) {
+        if (!dataSource.isFinished()) {
+            return;
+        }
+        List<CloseableReference<CloseableImage>> imageRefList = dataSource.getResult();
+        if (imageRefList == null) {
+            onNewResultListImpl(null);
+            return;
+        }
+        try {
+            List<Bitmap> bitmapList = Lists.newArrayListWithCapacity(imageRefList.size());
+            for (CloseableReference<CloseableImage> closeableImageRef : imageRefList) {
+                if (closeableImageRef != null && closeableImageRef.get() instanceof CloseableBitmap) {
+                    bitmapList.add(((CloseableBitmap) closeableImageRef.get()).getUnderlyingBitmap());
+                } else {
+                    //This is so that client gets list with same length
+                    bitmapList.add(null);
+                }
+            }
+            onNewResultListImpl(bitmapList);
+        } finally {
+            for (CloseableReference<CloseableImage> closeableImageRef : imageRefList) {
+                CloseableReference.closeSafely(closeableImageRef);
+            }
         }
-      }
-      onNewResultListImpl(bitmapList);
-    } finally {
-      for (CloseableReference<CloseableImage> closeableImageRef: imageRefList) {
-        CloseableReference.closeSafely(closeableImageRef);
-      }
     }
-  }
 
-  /**
-   * The bitmap list provided to this method is only guaranteed to be around for the lifespan of the
-   * method. This list can be null or the elements in it can be null.
-   *
-   * <p>The framework will free the bitmaps in the list from memory after this method has completed.
-   * @param bitmapList
-   */
-  protected abstract void onNewResultListImpl(List<Bitmap> bitmapList);
+    /**
+     * The bitmap list provided to this method is only guaranteed to be around for the lifespan of the
+     * method. This list can be null or the elements in it can be null.
+     * <p>
+     * <p>The framework will free the bitmaps in the list from memory after this method has completed.
+     *
+     * @param bitmapList
+     */
+    protected abstract void onNewResultListImpl(List<Bitmap> bitmapList);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/CloseableProducerToDataSourceAdapter.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/CloseableProducerToDataSourceAdapter.java
index 229960451..bce5f4119 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/CloseableProducerToDataSourceAdapter.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/CloseableProducerToDataSourceAdapter.java
@@ -25,36 +25,36 @@
  */
 @ThreadSafe
 public class CloseableProducerToDataSourceAdapter<T>
-    extends AbstractProducerToDataSourceAdapter<CloseableReference<T>> {
-
-  public static <T> DataSource<CloseableReference<T>> create(
-      Producer<CloseableReference<T>> producer,
-      SettableProducerContext settableProducerContext,
-      RequestListener listener) {
-    return new CloseableProducerToDataSourceAdapter<T>(
-        producer, settableProducerContext, listener);
-  }
-
-  private CloseableProducerToDataSourceAdapter(
-      Producer<CloseableReference<T>> producer,
-      SettableProducerContext settableProducerContext,
-      RequestListener listener) {
-    super(producer, settableProducerContext, listener);
-  }
-
-  @Override
-  @Nullable
-  public CloseableReference<T> getResult() {
-    return CloseableReference.cloneOrNull(super.getResult());
-  }
-
-  @Override
-  protected void closeResult(CloseableReference<T> result) {
-    CloseableReference.closeSafely(result);
-  }
-
-  @Override
-  protected void onNewResultImpl(CloseableReference<T> result, boolean isLast) {
-    super.onNewResultImpl(CloseableReference.cloneOrNull(result), isLast);
-  }
+        extends AbstractProducerToDataSourceAdapter<CloseableReference<T>> {
+
+    public static <T> DataSource<CloseableReference<T>> create(
+            Producer<CloseableReference<T>> producer,
+            SettableProducerContext settableProducerContext,
+            RequestListener listener) {
+        return new CloseableProducerToDataSourceAdapter<T>(
+                producer, settableProducerContext, listener);
+    }
+
+    private CloseableProducerToDataSourceAdapter(
+            Producer<CloseableReference<T>> producer,
+            SettableProducerContext settableProducerContext,
+            RequestListener listener) {
+        super(producer, settableProducerContext, listener);
+    }
+
+    @Override
+    @Nullable
+    public CloseableReference<T> getResult() {
+        return CloseableReference.cloneOrNull(super.getResult());
+    }
+
+    @Override
+    protected void closeResult(CloseableReference<T> result) {
+        CloseableReference.closeSafely(result);
+    }
+
+    @Override
+    protected void onNewResultImpl(CloseableReference<T> result, boolean isLast) {
+        super.onNewResultImpl(CloseableReference.cloneOrNull(result), isLast);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/ListDataSource.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/ListDataSource.java
index 4af199284..e10f8d047 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/ListDataSource.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/ListDataSource.java
@@ -27,121 +27,121 @@
  * Data source that wraps number of other data sources and waits until all of them are finished.
  * After that each call to getResult() returns list of final results of wrapped data sources.
  * Caller of getResult() is responsible for closing all each of the results separately.
- *
+ * <p>
  * <p> This data source does not propagate intermediate results.
  *
  * @param <T>
  */
 public class ListDataSource<T> extends AbstractDataSource<ArrayList<CloseableReference<T>>> {
-  private final DataSource<CloseableReference<T>>[] mDataSources;
-  @GuardedBy("this")
-  private int mFinishedDataSources;
-
-  protected ListDataSource(DataSource<CloseableReference<T>>[] dataSources) {
-    mDataSources = dataSources;
-    mFinishedDataSources = 0;
-  }
-
-  public static <T> ListDataSource<T> create(
-      DataSource<CloseableReference<T>>... dataSources) {
-    Preconditions.checkNotNull(dataSources);
-    Preconditions.checkState(dataSources.length > 0);
-    ListDataSource<T> listDataSource = new ListDataSource<T>(dataSources);
-    for (DataSource<CloseableReference<T>> dataSource : dataSources) {
-      dataSource.subscribe(
-          listDataSource.new InternalDataSubscriber(),
-          CallerThreadExecutor.getInstance());
-    }
-    return listDataSource;
-  }
-
-  @Override
-  @Nullable
-  public synchronized ArrayList<CloseableReference<T>> getResult() {
-    if (!hasResult()) {
-      return null;
-    }
-    ArrayList<CloseableReference<T>> results = Lists.newArrayListWithCapacity(mDataSources.length);
-    for (DataSource<CloseableReference<T>> dataSource : mDataSources) {
-      results.add(dataSource.getResult());
-    }
-    return results;
-  }
-
-  @Override
-  public synchronized boolean hasResult() {
-    return !isClosed() && (mFinishedDataSources == mDataSources.length);
-  }
-
-  @Override
-  public boolean close() {
-    if (!super.close()) {
-      return false;
-    }
-    for (DataSource<?> dataSource : mDataSources) {
-      dataSource.close();
+    private final DataSource<CloseableReference<T>>[] mDataSources;
+    @GuardedBy("this")
+    private int mFinishedDataSources;
+
+    protected ListDataSource(DataSource<CloseableReference<T>>[] dataSources) {
+        mDataSources = dataSources;
+        mFinishedDataSources = 0;
     }
-    return true;
-  }
 
-  private void onDataSourceFinished() {
-    if (increaseAndCheckIfLast()) {
-      setResult(null, /* isLast */ true);
+    public static <T> ListDataSource<T> create(
+            DataSource<CloseableReference<T>>... dataSources) {
+        Preconditions.checkNotNull(dataSources);
+        Preconditions.checkState(dataSources.length > 0);
+        ListDataSource<T> listDataSource = new ListDataSource<T>(dataSources);
+        for (DataSource<CloseableReference<T>> dataSource : dataSources) {
+            dataSource.subscribe(
+                    listDataSource.new InternalDataSubscriber(),
+                    CallerThreadExecutor.getInstance());
+        }
+        return listDataSource;
     }
-  }
 
-  private synchronized boolean increaseAndCheckIfLast() {
-    return ++mFinishedDataSources == mDataSources.length;
-  }
+    @Override
+    @Nullable
+    public synchronized ArrayList<CloseableReference<T>> getResult() {
+        if (!hasResult()) {
+            return null;
+        }
+        ArrayList<CloseableReference<T>> results = Lists.newArrayListWithCapacity(mDataSources.length);
+        for (DataSource<CloseableReference<T>> dataSource : mDataSources) {
+            results.add(dataSource.getResult());
+        }
+        return results;
+    }
 
-  private void onDataSourceFailed(DataSource<CloseableReference<T>> dataSource) {
-    setFailure(dataSource.getFailureCause());
-  }
+    @Override
+    public synchronized boolean hasResult() {
+        return !isClosed() && (mFinishedDataSources == mDataSources.length);
+    }
 
-  private void onDataSourceCancelled() {
-    setFailure(new CancellationException());
-  }
+    @Override
+    public boolean close() {
+        if (!super.close()) {
+            return false;
+        }
+        for (DataSource<?> dataSource : mDataSources) {
+            dataSource.close();
+        }
+        return true;
+    }
 
-  private void onDataSourceProgress() {
-    float progress = 0;
-    for (DataSource<?> dataSource : mDataSources) {
-      progress += dataSource.getProgress();
+    private void onDataSourceFinished() {
+        if (increaseAndCheckIfLast()) {
+            setResult(null, /* isLast */ true);
+        }
     }
-    setProgress(progress / mDataSources.length);
-  }
-
-  private class InternalDataSubscriber implements DataSubscriber<CloseableReference<T>> {
-    @GuardedBy("InternalDataSubscriber.this")
-    boolean mFinished = false;
-
-    private synchronized boolean tryFinish() {
-      if (mFinished) {
-        return false;
-      }
-      mFinished = true;
-      return true;
+
+    private synchronized boolean increaseAndCheckIfLast() {
+        return ++mFinishedDataSources == mDataSources.length;
     }
 
-    @Override
-    public void onFailure(DataSource<CloseableReference<T>> dataSource) {
-      ListDataSource.this.onDataSourceFailed(dataSource);
+    private void onDataSourceFailed(DataSource<CloseableReference<T>> dataSource) {
+        setFailure(dataSource.getFailureCause());
     }
 
-    @Override
-    public void onCancellation(DataSource<CloseableReference<T>> dataSource) {
-      ListDataSource.this.onDataSourceCancelled();
+    private void onDataSourceCancelled() {
+        setFailure(new CancellationException());
     }
 
-    @Override
-    public void onNewResult(DataSource<CloseableReference<T>> dataSource) {
-      if (dataSource.isFinished() && tryFinish()) {
-        ListDataSource.this.onDataSourceFinished();
-      }
+    private void onDataSourceProgress() {
+        float progress = 0;
+        for (DataSource<?> dataSource : mDataSources) {
+            progress += dataSource.getProgress();
+        }
+        setProgress(progress / mDataSources.length);
     }
 
-    @Override
-    public void onProgressUpdate(DataSource<CloseableReference<T>> dataSource) {
-      ListDataSource.this.onDataSourceProgress();
+    private class InternalDataSubscriber implements DataSubscriber<CloseableReference<T>> {
+        @GuardedBy("InternalDataSubscriber.this")
+        boolean mFinished = false;
+
+        private synchronized boolean tryFinish() {
+            if (mFinished) {
+                return false;
+            }
+            mFinished = true;
+            return true;
+        }
+
+        @Override
+        public void onFailure(DataSource<CloseableReference<T>> dataSource) {
+            ListDataSource.this.onDataSourceFailed(dataSource);
+        }
+
+        @Override
+        public void onCancellation(DataSource<CloseableReference<T>> dataSource) {
+            ListDataSource.this.onDataSourceCancelled();
+        }
+
+        @Override
+        public void onNewResult(DataSource<CloseableReference<T>> dataSource) {
+            if (dataSource.isFinished() && tryFinish()) {
+                ListDataSource.this.onDataSourceFinished();
+            }
+        }
+
+        @Override
+        public void onProgressUpdate(DataSource<CloseableReference<T>> dataSource) {
+            ListDataSource.this.onDataSourceProgress();
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/ProducerToDataSourceAdapter.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/ProducerToDataSourceAdapter.java
index 6c59b31f4..df148fd22 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/ProducerToDataSourceAdapter.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/ProducerToDataSourceAdapter.java
@@ -23,22 +23,22 @@
  */
 @ThreadSafe
 public class ProducerToDataSourceAdapter<T>
-    extends AbstractProducerToDataSourceAdapter<T> {
+        extends AbstractProducerToDataSourceAdapter<T> {
 
-  public static <T> DataSource<T> create(
-      Producer<T> producer,
-      SettableProducerContext settableProducerContext,
-      RequestListener listener) {
-    return new ProducerToDataSourceAdapter<T>(
-        producer,
-        settableProducerContext,
-        listener);
-  }
+    public static <T> DataSource<T> create(
+            Producer<T> producer,
+            SettableProducerContext settableProducerContext,
+            RequestListener listener) {
+        return new ProducerToDataSourceAdapter<T>(
+                producer,
+                settableProducerContext,
+                listener);
+    }
 
-  private ProducerToDataSourceAdapter(
-      Producer<T> producer,
-      SettableProducerContext settableProducerContext,
-      RequestListener listener) {
-    super(producer, settableProducerContext, listener);
-  }
+    private ProducerToDataSourceAdapter(
+            Producer<T> producer,
+            SettableProducerContext settableProducerContext,
+            RequestListener listener) {
+        super(producer, settableProducerContext, listener);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/SettableDataSource.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/SettableDataSource.java
index 339c64cdc..3a35a443c 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/SettableDataSource.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/datasource/SettableDataSource.java
@@ -19,77 +19,77 @@
 /**
  * A {@link DataSource} whose result may be set by a {@link #set(CloseableReference<T>)} or
  * {@link #setException(Throwable)} call. It may also be closed.
- *
+ * <p>
  * <p>This data source has no intermediate results - calling {@link #set(CloseableReference<T>)}
  * means that the data source is finished.
  */
 @ThreadSafe
 public final class SettableDataSource<T> extends AbstractDataSource<CloseableReference<T>> {
 
-  /**
-   * Creates a new {@code SettableDataSource}
-   */
-  public static <V> SettableDataSource<V> create() {
-    return new SettableDataSource<V>();
-  }
+    /**
+     * Creates a new {@code SettableDataSource}
+     */
+    public static <V> SettableDataSource<V> create() {
+        return new SettableDataSource<V>();
+    }
 
-  private SettableDataSource() {
-  }
+    private SettableDataSource() {
+    }
 
-  /**
-   * Sets the value of this data source.
-   *
-   * <p> This method will return {@code true} if the value was successfully set, or
-   * {@code false} if the data source has already been set, failed or closed.
-   *
-   * <p> Passed CloseableReference is cloned, caller of this method still owns passed reference
-   * after the method returns.
-   *
-   * @param valueRef closeable reference to the value the data source should hold.
-   * @return true if the value was successfully set.
-   */
-  public boolean set(@Nullable CloseableReference<T> valueRef) {
-    CloseableReference<T> clonedRef = CloseableReference.cloneOrNull(valueRef);
-    return super.setResult(clonedRef, /* isLast */ true);
-  }
+    /**
+     * Sets the value of this data source.
+     * <p>
+     * <p> This method will return {@code true} if the value was successfully set, or
+     * {@code false} if the data source has already been set, failed or closed.
+     * <p>
+     * <p> Passed CloseableReference is cloned, caller of this method still owns passed reference
+     * after the method returns.
+     *
+     * @param valueRef closeable reference to the value the data source should hold.
+     * @return true if the value was successfully set.
+     */
+    public boolean set(@Nullable CloseableReference<T> valueRef) {
+        CloseableReference<T> clonedRef = CloseableReference.cloneOrNull(valueRef);
+        return super.setResult(clonedRef, /* isLast */ true);
+    }
 
-  /**
-   * Sets the data source to having failed with the given exception.
-   *
-   * <p> This method will return {@code true} if the exception was successfully set, or
-   * {@code false} if the data source has already been set, failed or closed.
-   *
-   * @param throwable the exception the data source should hold.
-   * @return true if the exception was successfully set.
-   */
-  public boolean setException(Throwable throwable) {
-    return super.setFailure(throwable);
-  }
+    /**
+     * Sets the data source to having failed with the given exception.
+     * <p>
+     * <p> This method will return {@code true} if the exception was successfully set, or
+     * {@code false} if the data source has already been set, failed or closed.
+     *
+     * @param throwable the exception the data source should hold.
+     * @return true if the exception was successfully set.
+     */
+    public boolean setException(Throwable throwable) {
+        return super.setFailure(throwable);
+    }
 
-  /**
-   * Sets the progress.
-   *
-   * @param progress the progress in range [0, 1] to be set.
-   * @return true if the progress was successfully set.
-   */
-  @Override
-  public boolean setProgress(float progress) {
-    return super.setProgress(progress);
-  }
+    /**
+     * Sets the progress.
+     *
+     * @param progress the progress in range [0, 1] to be set.
+     * @return true if the progress was successfully set.
+     */
+    @Override
+    public boolean setProgress(float progress) {
+        return super.setProgress(progress);
+    }
 
-  /**
-   * Gets the result if any, null otherwise.
-   *
-   * <p> Value will be cloned and it's the caller's responsibility to close the returned value.
-   */
-  @Override
-  @Nullable
-  public CloseableReference<T> getResult() {
-    return CloseableReference.cloneOrNull(super.getResult());
-  }
+    /**
+     * Gets the result if any, null otherwise.
+     * <p>
+     * <p> Value will be cloned and it's the caller's responsibility to close the returned value.
+     */
+    @Override
+    @Nullable
+    public CloseableReference<T> getResult() {
+        return CloseableReference.cloneOrNull(super.getResult());
+    }
 
-  @Override
-  protected void closeResult(@Nullable CloseableReference<T> result) {
-    CloseableReference.closeSafely(result);
-  }
+    @Override
+    protected void closeResult(@Nullable CloseableReference<T> result) {
+        CloseableReference.closeSafely(result);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DecodeException.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DecodeException.java
index 97a2f85e9..1ecfb0225 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DecodeException.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DecodeException.java
@@ -10,11 +10,11 @@
 package com.facebook.imagepipeline.decoder;
 
 public class DecodeException extends RuntimeException {
-  public DecodeException(String message) {
-    super(message);
-  }
+    public DecodeException(String message) {
+        super(message);
+    }
 
-  public DecodeException(String message, Throwable t) {
-    super(message, t);
-  }
+    public DecodeException(String message, Throwable t) {
+        super(message, t);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ImageDecoder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ImageDecoder.java
index 42aa767c8..da42ef202 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ImageDecoder.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ImageDecoder.java
@@ -28,132 +28,132 @@
 
 /**
  * Decodes images.
- *
+ * <p>
  * <p> ImageDecoder implements image type recognition and passes decode requests to
  * specialized methods implemented by subclasses.
- *
+ * <p>
  * On dalvik, it produces 'pinned' purgeable bitmaps.
- *
+ * <p>
  * <p> Pinned purgeables behave as specified in
  * {@link android.graphics.BitmapFactory.Options#inPurgeable} with one modification. The bitmap is
  * 'pinned' so is never purged.
- *
+ * <p>
  * <p> For API 21 and higher, this class produces standard Bitmaps, as purgeability is not supported
  * on the most recent versions of Android.
  */
 public class ImageDecoder {
 
-  private final AnimatedImageFactory mAnimatedImageFactory;
-  private final PlatformBitmapFactory mBitmapFactoryWithPool;
-
-  public ImageDecoder(
-      final AnimatedImageFactory animatedImageFactory,
-      final PlatformBitmapFactory bitmapFactoryWithPool) {
-    mAnimatedImageFactory = animatedImageFactory;
-    mBitmapFactoryWithPool = bitmapFactoryWithPool;
-  }
-
-  /**
-   * Decodes image.
-   *
-   * @param pooledByteBufferRef buffer containing image data
-   * @param imageFormat if not null and not UNKNOWN, then format check is skipped and this one is
-   *   assumed.
-   * @param length if image type supports decoding incomplete image then determines where
-   *   the image data should be cut for decoding.
-   * @param qualityInfo quality information for the image
-   * @param options options that cange decode behavior
-   */
-  public CloseableImage decodeImage(
-      final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
-      @Nullable ImageFormat imageFormat,
-      final int length,
-      final QualityInfo qualityInfo,
-      final ImageDecodeOptions options) {
-    if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) {
-      imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(
-          new PooledByteBufferInputStream(pooledByteBufferRef.get()));
-    }
-
-    switch (imageFormat) {
-      case UNKNOWN:
-        throw new IllegalArgumentException("unknown image format");
+    private final AnimatedImageFactory mAnimatedImageFactory;
+    private final PlatformBitmapFactory mBitmapFactoryWithPool;
 
-      case JPEG:
-        return decodeJpeg(pooledByteBufferRef, length, qualityInfo);
+    public ImageDecoder(
+            final AnimatedImageFactory animatedImageFactory,
+            final PlatformBitmapFactory bitmapFactoryWithPool) {
+        mAnimatedImageFactory = animatedImageFactory;
+        mBitmapFactoryWithPool = bitmapFactoryWithPool;
+    }
 
-      case GIF:
-        return decodeAnimatedGif(pooledByteBufferRef, options);
+    /**
+     * Decodes image.
+     *
+     * @param pooledByteBufferRef buffer containing image data
+     * @param imageFormat         if not null and not UNKNOWN, then format check is skipped and this one is
+     *                            assumed.
+     * @param length              if image type supports decoding incomplete image then determines where
+     *                            the image data should be cut for decoding.
+     * @param qualityInfo         quality information for the image
+     * @param options             options that cange decode behavior
+     */
+    public CloseableImage decodeImage(
+            final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
+            @Nullable ImageFormat imageFormat,
+            final int length,
+            final QualityInfo qualityInfo,
+            final ImageDecodeOptions options) {
+        if (imageFormat == null || imageFormat == ImageFormat.UNKNOWN) {
+            imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(
+                    new PooledByteBufferInputStream(pooledByteBufferRef.get()));
+        }
+
+        switch (imageFormat) {
+            case UNKNOWN:
+                throw new IllegalArgumentException("unknown image format");
+
+            case JPEG:
+                return decodeJpeg(pooledByteBufferRef, length, qualityInfo);
+
+            case GIF:
+                return decodeAnimatedGif(pooledByteBufferRef, options);
+
+            case WEBP_ANIMATED:
+                return decodeAnimatedWebp(pooledByteBufferRef, options);
+
+            default:
+                return decodeStaticImage(pooledByteBufferRef);
+        }
+    }
 
-      case WEBP_ANIMATED:
-        return decodeAnimatedWebp(pooledByteBufferRef, options);
+    /**
+     * Decodes gif into CloseableImage.
+     *
+     * @param pooledByteBufferRef
+     * @return a CloseableGifImage
+     */
+    public CloseableImage decodeAnimatedGif(
+            CloseableReference<PooledByteBuffer> pooledByteBufferRef,
+            ImageDecodeOptions options) {
+        return mAnimatedImageFactory.decodeGif(pooledByteBufferRef, options);
+    }
 
-      default:
-        return decodeStaticImage(pooledByteBufferRef);
+    /**
+     * @param pooledByteBufferRef input image (encoded bytes)
+     * @return a CloseableStaticBitmap
+     */
+    public synchronized CloseableStaticBitmap decodeStaticImage(
+            final CloseableReference<PooledByteBuffer> pooledByteBufferRef) {
+        CloseableReference<Bitmap> bitmapReference =
+                mBitmapFactoryWithPool.decodeFromPooledByteBuffer(pooledByteBufferRef);
+        try {
+            return new CloseableStaticBitmap(bitmapReference, ImmutableQualityInfo.FULL_QUALITY);
+        } finally {
+            bitmapReference.close();
+        }
     }
-  }
-
-  /**
-   * Decodes gif into CloseableImage.
-   *
-   * @param pooledByteBufferRef
-   * @return a CloseableGifImage
-   */
-  public CloseableImage decodeAnimatedGif(
-      CloseableReference<PooledByteBuffer> pooledByteBufferRef,
-      ImageDecodeOptions options) {
-    return mAnimatedImageFactory.decodeGif(pooledByteBufferRef, options);
-  }
-
-  /**
-   * @param pooledByteBufferRef input image (encoded bytes)
-   * @return a CloseableStaticBitmap
-   */
-  public synchronized CloseableStaticBitmap decodeStaticImage(
-      final CloseableReference<PooledByteBuffer> pooledByteBufferRef) {
-    CloseableReference<Bitmap> bitmapReference =
-        mBitmapFactoryWithPool.decodeFromPooledByteBuffer(pooledByteBufferRef);
-    try {
-      return new CloseableStaticBitmap(bitmapReference, ImmutableQualityInfo.FULL_QUALITY);
-    } finally {
-      bitmapReference.close();
+
+    /**
+     * Decodes a partial jpeg.
+     *
+     * @param pooledByteBufferRef
+     * @param length              amount of currently available data in bytes
+     * @param qualityInfo         quality info for the image
+     * @return a CloseableStaticBitmap
+     */
+    public synchronized CloseableStaticBitmap decodeJpeg(
+            final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
+            int length,
+            QualityInfo qualityInfo) {
+        CloseableReference<Bitmap> bitmapReference =
+                mBitmapFactoryWithPool.decodeJPEGFromPooledByteBuffer(pooledByteBufferRef, length);
+        try {
+            return new CloseableStaticBitmap(bitmapReference, qualityInfo);
+        } finally {
+            bitmapReference.close();
+        }
     }
-  }
-
-  /**
-   * Decodes a partial jpeg.
-   *
-   * @param pooledByteBufferRef
-   * @param length amount of currently available data in bytes
-   * @param qualityInfo quality info for the image
-   * @return a CloseableStaticBitmap
-   */
-  public synchronized CloseableStaticBitmap decodeJpeg(
-      final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
-      int length,
-      QualityInfo qualityInfo) {
-    CloseableReference<Bitmap> bitmapReference =
-        mBitmapFactoryWithPool.decodeJPEGFromPooledByteBuffer(pooledByteBufferRef, length);
-    try {
-      return new CloseableStaticBitmap(bitmapReference, qualityInfo);
-    } finally {
-      bitmapReference.close();
+
+    /**
+     * Decode a webp animated image into a CloseableImage.
+     * <p>
+     * <p> The image is decoded into a 'pinned' purgeable bitmap.
+     *
+     * @param pooledByteBufferRef input image (encoded bytes)
+     * @param options
+     * @return a {@link CloseableImage}
+     */
+    public CloseableImage decodeAnimatedWebp(
+            final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
+            final ImageDecodeOptions options) {
+        return mAnimatedImageFactory.decodeWebP(pooledByteBufferRef, options);
     }
-  }
-
-  /**
-   * Decode a webp animated image into a CloseableImage.
-   *
-   * <p> The image is decoded into a 'pinned' purgeable bitmap.
-   *
-   * @param pooledByteBufferRef input image (encoded bytes)
-   * @param options
-   * @return a {@link CloseableImage}
-   */
-  public CloseableImage decodeAnimatedWebp(
-      final CloseableReference<PooledByteBuffer> pooledByteBufferRef,
-      final ImageDecodeOptions options) {
-    return mAnimatedImageFactory.decodeWebP(pooledByteBufferRef, options);
-  }
 
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ProgressiveJpegConfig.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ProgressiveJpegConfig.java
index 69059b8ef..e3d62bdd6 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ProgressiveJpegConfig.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ProgressiveJpegConfig.java
@@ -16,13 +16,13 @@
  */
 public interface ProgressiveJpegConfig {
 
-  /**
-   * Gets the next scan-number that should be decoded after the given scan-number.
-   */
-  public int getNextScanNumberToDecode(int scanNumber);
+    /**
+     * Gets the next scan-number that should be decoded after the given scan-number.
+     */
+    public int getNextScanNumberToDecode(int scanNumber);
 
-  /**
-   * Gets the quality information for the given scan-number.
-   */
-  public QualityInfo getQualityInfo(int scanNumber);
+    /**
+     * Gets the quality information for the given scan-number.
+     */
+    public QualityInfo getQualityInfo(int scanNumber);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ProgressiveJpegParser.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ProgressiveJpegParser.java
index 944d06870..be97c1d91 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ProgressiveJpegParser.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ProgressiveJpegParser.java
@@ -26,247 +26,249 @@
 /**
  * Progressively scans jpeg data and instructs caller when enough data is available to decode
  * a partial image.
- *
+ * <p>
  * <p> This class treats any sequence of bytes starting with 0xFFD8 as a valid jpeg image
- *
+ * <p>
  * <p> Users should call parseMoreData method each time new chunk of data is received. The buffer
  * passed as a parameter should include entire image data received so far.
  */
 public class ProgressiveJpegParser {
 
-  /**
-   * Initial state of the parser. Next byte read by the parser should be 0xFF.
-   */
-  private static final int READ_FIRST_JPEG_BYTE = 0;
-
-  /**
-   * Parser saw only one byte so far (0xFF). Next byte should be second byte of SOI marker
-   */
-  private static final int READ_SECOND_JPEG_BYTE = 1;
-
-  /**
-   * Next byte is either entropy coded data or first byte of a marker. First byte of marker
-   * cannot appear in entropy coded data, unless it is followed by 0x00 escape byte.
-   */
-  private static final int READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA = 2;
-
-  /**
-   * Last read byte is 0xFF, possible start of marker (possible, because next byte might be
-   * "escape byte" or 0xFF again)
-   */
-  private static final int READ_MARKER_SECOND_BYTE = 3;
-
-  /**
-   * Last two bytes constitute a marker that indicates start of a segment, the following two bytes
-   * denote 16bit size of the segment
-   */
-  private static final int READ_SIZE_FIRST_BYTE = 4;
-
-  /**
-   * Last three bytes are marker and first byte of segment size, after reading next byte, bytes
-   * constituting remaining part of segment will be skipped
-   */
-  private static final int READ_SIZE_SECOND_BYTE = 5;
-
-  /**
-   * Parsed data is not a JPEG file
-   */
-  private static final int NOT_A_JPEG = 6;
-
-  /** The buffer size in bytes to use. */
-  private static final int BUFFER_SIZE = 16 * 1024;
-
-  private int mParserState;
-  private int mLastByteRead;
-
-  /**
-   * number of bytes consumed so far
-   */
-  private int mBytesParsed;
-
-  /**
-   * number of next fully parsed scan after reaching next SOS or EOI markers
-   */
-  private int mNextFullScanNumber;
-
-  private int mBestScanNumber;
-  private int mBestScanEndOffset;
-
-  private final ByteArrayPool mByteArrayPool;
-
-  public ProgressiveJpegParser(ByteArrayPool byteArrayPool) {
-    mByteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    mBytesParsed = 0;
-    mLastByteRead = 0;
-    mNextFullScanNumber = 0;
-    mBestScanEndOffset = 0;
-    mBestScanNumber = 0;
-    mParserState = READ_FIRST_JPEG_BYTE;
-
-  }
-
-  /**
-   * If this is the first time calling this method, the buffer will be checked to make sure it
-   * starts with SOI marker (0xffd8). If the image has been identified as a non-JPEG, data will be
-   * ignored and false will be returned immediately on all subsequent calls.
-   *
-   * This object maintains state of the position of the last read byte. On repeated calls to this
-   * method, it will continue from where it left off.
-   *
-   * @param dataBufferRef Next set of bytes received by the caller
-   * @return true if a new full scan has been found
-   */
-  public boolean parseMoreData(final CloseableReference<PooledByteBuffer> dataBufferRef) {
-    if (mParserState == NOT_A_JPEG) {
-      return false;
+    /**
+     * Initial state of the parser. Next byte read by the parser should be 0xFF.
+     */
+    private static final int READ_FIRST_JPEG_BYTE = 0;
+
+    /**
+     * Parser saw only one byte so far (0xFF). Next byte should be second byte of SOI marker
+     */
+    private static final int READ_SECOND_JPEG_BYTE = 1;
+
+    /**
+     * Next byte is either entropy coded data or first byte of a marker. First byte of marker
+     * cannot appear in entropy coded data, unless it is followed by 0x00 escape byte.
+     */
+    private static final int READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA = 2;
+
+    /**
+     * Last read byte is 0xFF, possible start of marker (possible, because next byte might be
+     * "escape byte" or 0xFF again)
+     */
+    private static final int READ_MARKER_SECOND_BYTE = 3;
+
+    /**
+     * Last two bytes constitute a marker that indicates start of a segment, the following two bytes
+     * denote 16bit size of the segment
+     */
+    private static final int READ_SIZE_FIRST_BYTE = 4;
+
+    /**
+     * Last three bytes are marker and first byte of segment size, after reading next byte, bytes
+     * constituting remaining part of segment will be skipped
+     */
+    private static final int READ_SIZE_SECOND_BYTE = 5;
+
+    /**
+     * Parsed data is not a JPEG file
+     */
+    private static final int NOT_A_JPEG = 6;
+
+    /**
+     * The buffer size in bytes to use.
+     */
+    private static final int BUFFER_SIZE = 16 * 1024;
+
+    private int mParserState;
+    private int mLastByteRead;
+
+    /**
+     * number of bytes consumed so far
+     */
+    private int mBytesParsed;
+
+    /**
+     * number of next fully parsed scan after reaching next SOS or EOI markers
+     */
+    private int mNextFullScanNumber;
+
+    private int mBestScanNumber;
+    private int mBestScanEndOffset;
+
+    private final ByteArrayPool mByteArrayPool;
+
+    public ProgressiveJpegParser(ByteArrayPool byteArrayPool) {
+        mByteArrayPool = Preconditions.checkNotNull(byteArrayPool);
+        mBytesParsed = 0;
+        mLastByteRead = 0;
+        mNextFullScanNumber = 0;
+        mBestScanEndOffset = 0;
+        mBestScanNumber = 0;
+        mParserState = READ_FIRST_JPEG_BYTE;
+
     }
 
-    final PooledByteBuffer dataBuffer = dataBufferRef.get();
-    final int dataBufferSize = dataBuffer.size();
+    /**
+     * If this is the first time calling this method, the buffer will be checked to make sure it
+     * starts with SOI marker (0xffd8). If the image has been identified as a non-JPEG, data will be
+     * ignored and false will be returned immediately on all subsequent calls.
+     * <p>
+     * This object maintains state of the position of the last read byte. On repeated calls to this
+     * method, it will continue from where it left off.
+     *
+     * @param dataBufferRef Next set of bytes received by the caller
+     * @return true if a new full scan has been found
+     */
+    public boolean parseMoreData(final CloseableReference<PooledByteBuffer> dataBufferRef) {
+        if (mParserState == NOT_A_JPEG) {
+            return false;
+        }
 
-    // Is there any new data to parse?
-    // mBytesParsed might be greater than size of dataBuffer - that happens when
-    // we skip more data than is available to read inside doParseMoreData method
-    if (dataBufferSize <= mBytesParsed) {
-      return false;
-    }
+        final PooledByteBuffer dataBuffer = dataBufferRef.get();
+        final int dataBufferSize = dataBuffer.size();
 
-    final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream(
-        new PooledByteBufferInputStream(dataBuffer),
-        mByteArrayPool.get(BUFFER_SIZE),
-        mByteArrayPool);
-    try {
-      StreamUtil.skip(bufferedDataStream, mBytesParsed);
-      return doParseMoreData(bufferedDataStream);
-    } catch (IOException ioe) {
-      // Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions
-      Throwables.propagate(ioe);
-      return false;
-    } finally {
-      Closeables.closeQuietly(bufferedDataStream);
+        // Is there any new data to parse?
+        // mBytesParsed might be greater than size of dataBuffer - that happens when
+        // we skip more data than is available to read inside doParseMoreData method
+        if (dataBufferSize <= mBytesParsed) {
+            return false;
+        }
+
+        final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream(
+                new PooledByteBufferInputStream(dataBuffer),
+                mByteArrayPool.get(BUFFER_SIZE),
+                mByteArrayPool);
+        try {
+            StreamUtil.skip(bufferedDataStream, mBytesParsed);
+            return doParseMoreData(bufferedDataStream);
+        } catch (IOException ioe) {
+            // Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions
+            Throwables.propagate(ioe);
+            return false;
+        } finally {
+            Closeables.closeQuietly(bufferedDataStream);
+        }
     }
-  }
-
-  /**
-   * Parses more data from inputStream.
-   *
-   * @param inputStream instance of buffered pooled byte buffer input stream
-   */
-  private boolean doParseMoreData(final InputStream inputStream) {
-    final int oldBestScanNumber = mBestScanNumber;
-    try {
-      int nextByte;
-      while (mParserState != NOT_A_JPEG && (nextByte = inputStream.read()) != -1) {
-        mBytesParsed++;
-
-        switch (mParserState) {
-          case READ_FIRST_JPEG_BYTE:
-            if (nextByte == JfifUtil.MARKER_FIRST_BYTE) {
-              mParserState = READ_SECOND_JPEG_BYTE;
-            } else {
-              mParserState = NOT_A_JPEG;
-            }
-            break;
 
-          case READ_SECOND_JPEG_BYTE:
-            if (nextByte == JfifUtil.MARKER_SOI) {
-              mParserState = READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA;
-            } else {
-              mParserState = NOT_A_JPEG;
+    /**
+     * Parses more data from inputStream.
+     *
+     * @param inputStream instance of buffered pooled byte buffer input stream
+     */
+    private boolean doParseMoreData(final InputStream inputStream) {
+        final int oldBestScanNumber = mBestScanNumber;
+        try {
+            int nextByte;
+            while (mParserState != NOT_A_JPEG && (nextByte = inputStream.read()) != -1) {
+                mBytesParsed++;
+
+                switch (mParserState) {
+                    case READ_FIRST_JPEG_BYTE:
+                        if (nextByte == JfifUtil.MARKER_FIRST_BYTE) {
+                            mParserState = READ_SECOND_JPEG_BYTE;
+                        } else {
+                            mParserState = NOT_A_JPEG;
+                        }
+                        break;
+
+                    case READ_SECOND_JPEG_BYTE:
+                        if (nextByte == JfifUtil.MARKER_SOI) {
+                            mParserState = READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA;
+                        } else {
+                            mParserState = NOT_A_JPEG;
+                        }
+                        break;
+
+                    case READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA:
+                        if (nextByte == JfifUtil.MARKER_FIRST_BYTE) {
+                            mParserState = READ_MARKER_SECOND_BYTE;
+                        }
+                        break;
+
+                    case READ_MARKER_SECOND_BYTE:
+                        if (nextByte == JfifUtil.MARKER_FIRST_BYTE) {
+                            mParserState = READ_MARKER_SECOND_BYTE;
+                        } else if (nextByte == JfifUtil.MARKER_ESCAPE_BYTE) {
+                            mParserState = READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA;
+                        } else {
+                            if (nextByte == JfifUtil.MARKER_SOS || nextByte == JfifUtil.MARKER_EOI) {
+                                newScanOrImageEndFound(mBytesParsed - 2);
+                            }
+
+                            if (doesMarkerStartSegment(nextByte)) {
+                                mParserState = READ_SIZE_FIRST_BYTE;
+                            } else {
+                                mParserState = READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA;
+                            }
+                        }
+                        break;
+
+                    case READ_SIZE_FIRST_BYTE:
+                        mParserState = READ_SIZE_SECOND_BYTE;
+                        break;
+
+                    case READ_SIZE_SECOND_BYTE:
+                        final int size = (mLastByteRead << 8) + nextByte;
+                        // We need to jump after the end of the segment - skip size-2 next bytes.
+                        // We might want to skip more data than is available to read, in which case we will
+                        // consume entire data in inputStream and exit this function before entering another
+                        // iteration of the loop.
+                        final int bytesToSkip = size - 2;
+                        StreamUtil.skip(inputStream, bytesToSkip);
+                        mBytesParsed += bytesToSkip;
+                        mParserState = READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA;
+                        break;
+
+                    case NOT_A_JPEG:
+                    default:
+                        Preconditions.checkState(false);
+                }
+
+                mLastByteRead = nextByte;
             }
-            break;
+        } catch (IOException ioe) {
+            // does not happen, input stream returned by pooled byte buffer does not throw IOExceptions
+            Throwables.propagate(ioe);
+        }
+        return mParserState != NOT_A_JPEG && mBestScanNumber != oldBestScanNumber;
+    }
 
-          case READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA:
-            if (nextByte == JfifUtil.MARKER_FIRST_BYTE) {
-              mParserState = READ_MARKER_SECOND_BYTE;
-            }
-            break;
-
-          case READ_MARKER_SECOND_BYTE:
-            if (nextByte == JfifUtil.MARKER_FIRST_BYTE) {
-              mParserState = READ_MARKER_SECOND_BYTE;
-            } else if (nextByte == JfifUtil.MARKER_ESCAPE_BYTE) {
-              mParserState = READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA;
-            } else {
-              if (nextByte == JfifUtil.MARKER_SOS || nextByte == JfifUtil.MARKER_EOI) {
-                newScanOrImageEndFound(mBytesParsed - 2);
-              }
-
-              if (doesMarkerStartSegment(nextByte)) {
-                mParserState = READ_SIZE_FIRST_BYTE;
-              } else {
-                mParserState = READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA;
-              }
-            }
-            break;
-
-          case READ_SIZE_FIRST_BYTE:
-            mParserState = READ_SIZE_SECOND_BYTE;
-            break;
-
-          case READ_SIZE_SECOND_BYTE:
-            final int size = (mLastByteRead << 8) + nextByte;
-            // We need to jump after the end of the segment - skip size-2 next bytes.
-            // We might want to skip more data than is available to read, in which case we will
-            // consume entire data in inputStream and exit this function before entering another
-            // iteration of the loop.
-            final int bytesToSkip = size - 2;
-            StreamUtil.skip(inputStream, bytesToSkip);
-            mBytesParsed += bytesToSkip;
-            mParserState = READ_MARKER_FIRST_BYTE_OR_ENTROPY_DATA;
-            break;
-
-          case NOT_A_JPEG:
-          default:
-            Preconditions.checkState(false);
+    /**
+     * Not every marker is followed by associated segment
+     */
+    private static boolean doesMarkerStartSegment(int markerSecondByte) {
+        if (markerSecondByte == JfifUtil.MARKER_TEM) {
+            return false;
         }
 
-        mLastByteRead = nextByte;
-      }
-    } catch (IOException ioe) {
-      // does not happen, input stream returned by pooled byte buffer does not throw IOExceptions
-      Throwables.propagate(ioe);
+        if (markerSecondByte >= JfifUtil.MARKER_RST0 && markerSecondByte <= JfifUtil.MARKER_RST7) {
+            return false;
+        }
+
+        return markerSecondByte != JfifUtil.MARKER_EOI && markerSecondByte != JfifUtil.MARKER_SOI;
     }
-    return mParserState != NOT_A_JPEG && mBestScanNumber != oldBestScanNumber;
-  }
-
-  /**
-   * Not every marker is followed by associated segment
-   */
-  private static boolean doesMarkerStartSegment(int markerSecondByte) {
-    if (markerSecondByte == JfifUtil.MARKER_TEM) {
-      return false;
+
+    private void newScanOrImageEndFound(int offset) {
+        if (mNextFullScanNumber > 0) {
+            mBestScanEndOffset = offset;
+        }
+        mBestScanNumber = mNextFullScanNumber++;
     }
 
-    if (markerSecondByte >= JfifUtil.MARKER_RST0 && markerSecondByte <= JfifUtil.MARKER_RST7) {
-      return false;
+    public boolean isJpeg() {
+        return mBytesParsed > 1 && mParserState != NOT_A_JPEG;
     }
 
-    return markerSecondByte != JfifUtil.MARKER_EOI && markerSecondByte != JfifUtil.MARKER_SOI;
-  }
+    /**
+     * @return offset at which parsed data should be cut to decode best available partial result
+     */
+    public int getBestScanEndOffset() {
+        return mBestScanEndOffset;
+    }
 
-  private void newScanOrImageEndFound(int offset) {
-    if (mNextFullScanNumber > 0) {
-      mBestScanEndOffset = offset;
+    /**
+     * @return number of the best scan found so far
+     */
+    public int getBestScanNumber() {
+        return mBestScanNumber;
     }
-    mBestScanNumber = mNextFullScanNumber++;
-  }
-
-  public boolean isJpeg() {
-    return mBytesParsed > 1 && mParserState != NOT_A_JPEG;
-  }
-
-  /**
-   * @return offset at which parsed data should be cut to decode best available partial result
-   */
-  public int getBestScanEndOffset() {
-    return mBestScanEndOffset;
-  }
-
-  /**
-   * @return number of the best scan found so far
-   */
-  public int getBestScanNumber() {
-    return mBestScanNumber;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/SimpleProgressiveJpegConfig.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/SimpleProgressiveJpegConfig.java
index bf0daf5b1..f7048241d 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/SimpleProgressiveJpegConfig.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/SimpleProgressiveJpegConfig.java
@@ -17,42 +17,42 @@
 
 /**
  * Simple {@link ProgressiveJpegConfig} with predefined scans to decode and good-enough scan number.
- *
+ * <p>
  * <p/> If no specific scans to decode are provided, every scan is allowed to be decoded.
  */
 public class SimpleProgressiveJpegConfig implements ProgressiveJpegConfig {
-  private final List<Integer> mScansToDecode;
-  private final int mGoodEnoughScanNumber;
-
-  public SimpleProgressiveJpegConfig() {
-    this(new ArrayList<Integer>(), 0);
-  }
-
-  public SimpleProgressiveJpegConfig(
-      List<Integer> scansToDecode,
-      int goodEnoughScanNumber) {
-    mScansToDecode = scansToDecode;
-    mGoodEnoughScanNumber = goodEnoughScanNumber;
-  }
-
-  @Override
-  public int getNextScanNumberToDecode(int scanNumber) {
-    if (mScansToDecode == null || mScansToDecode.isEmpty()) {
-      return scanNumber + 1;
+    private final List<Integer> mScansToDecode;
+    private final int mGoodEnoughScanNumber;
+
+    public SimpleProgressiveJpegConfig() {
+        this(new ArrayList<Integer>(), 0);
+    }
+
+    public SimpleProgressiveJpegConfig(
+            List<Integer> scansToDecode,
+            int goodEnoughScanNumber) {
+        mScansToDecode = scansToDecode;
+        mGoodEnoughScanNumber = goodEnoughScanNumber;
     }
-    for (int i = 0; i < mScansToDecode.size(); i++) {
-      if (mScansToDecode.get(i) > scanNumber) {
-        return mScansToDecode.get(i);
-      }
+
+    @Override
+    public int getNextScanNumberToDecode(int scanNumber) {
+        if (mScansToDecode == null || mScansToDecode.isEmpty()) {
+            return scanNumber + 1;
+        }
+        for (int i = 0; i < mScansToDecode.size(); i++) {
+            if (mScansToDecode.get(i) > scanNumber) {
+                return mScansToDecode.get(i);
+            }
+        }
+        return Integer.MAX_VALUE;
     }
-    return Integer.MAX_VALUE;
-  }
 
-  @Override
-  public QualityInfo getQualityInfo(int scanNumber) {
-    return ImmutableQualityInfo.of(
-        scanNumber,
+    @Override
+    public QualityInfo getQualityInfo(int scanNumber) {
+        return ImmutableQualityInfo.of(
+                scanNumber,
         /* isOfGoodEnoughQuality */ scanNumber >= mGoodEnoughScanNumber,
         /* isOfFullQuality */ false);
-  }
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifFrame.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifFrame.java
index dc503878e..d2ee4a1ab 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifFrame.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifFrame.java
@@ -22,77 +22,86 @@
 @ThreadSafe
 public class GifFrame implements AnimatedImageFrame {
 
-  // Accessed by native methods
-  @SuppressWarnings("unused")
-  @DoNotStrip
-  private int mNativeContext;
-
-  /**
-   * Constructs the frame with the native pointer. This is called by native code.
-   *
-   * @param nativeContext the native pointer
-   */
-  @DoNotStrip
-  GifFrame(int nativeContext) {
-    mNativeContext = nativeContext;
-  }
-
-  @Override
-  protected void finalize() {
-    nativeFinalize();
-  }
-
-  @Override
-  public void dispose() {
-    nativeDispose();
-  }
-
-  @Override
-  public void renderFrame(int width, int height, Bitmap bitmap) {
-    nativeRenderFrame(width, height, bitmap);
-  }
-
-  @Override
-  public int getDurationMs() {
-    return nativeGetDurationMs();
-  }
-
-  @Override
-  public int getWidth() {
-    return nativeGetWidth();
-  }
-
-  @Override
-  public int getHeight() {
-    return nativeGetHeight();
-  }
-
-  @Override
-  public int getXOffset() {
-    return nativeGetXOffset();
-  }
-
-  @Override
-  public int getYOffset() {
-    return nativeGetYOffset();
-  }
-
-  public boolean hasTransparency() {
-    return nativeHasTransparency();
-  }
-
-  public int getDisposalMode() {
-    return nativeGetDisposalMode();
-  }
-
-  private native void nativeRenderFrame(int width, int height, Bitmap bitmap);
-  private native int nativeGetDurationMs();
-  private native int nativeGetWidth();
-  private native int nativeGetHeight();
-  private native int nativeGetXOffset();
-  private native int nativeGetYOffset();
-  private native int nativeGetDisposalMode();
-  private native boolean nativeHasTransparency();
-  private native void nativeDispose();
-  private native void nativeFinalize();
+    // Accessed by native methods
+    @SuppressWarnings("unused")
+    @DoNotStrip
+    private int mNativeContext;
+
+    /**
+     * Constructs the frame with the native pointer. This is called by native code.
+     *
+     * @param nativeContext the native pointer
+     */
+    @DoNotStrip
+    GifFrame(int nativeContext) {
+        mNativeContext = nativeContext;
+    }
+
+    @Override
+    protected void finalize() {
+        nativeFinalize();
+    }
+
+    @Override
+    public void dispose() {
+        nativeDispose();
+    }
+
+    @Override
+    public void renderFrame(int width, int height, Bitmap bitmap) {
+        nativeRenderFrame(width, height, bitmap);
+    }
+
+    @Override
+    public int getDurationMs() {
+        return nativeGetDurationMs();
+    }
+
+    @Override
+    public int getWidth() {
+        return nativeGetWidth();
+    }
+
+    @Override
+    public int getHeight() {
+        return nativeGetHeight();
+    }
+
+    @Override
+    public int getXOffset() {
+        return nativeGetXOffset();
+    }
+
+    @Override
+    public int getYOffset() {
+        return nativeGetYOffset();
+    }
+
+    public boolean hasTransparency() {
+        return nativeHasTransparency();
+    }
+
+    public int getDisposalMode() {
+        return nativeGetDisposalMode();
+    }
+
+    private native void nativeRenderFrame(int width, int height, Bitmap bitmap);
+
+    private native int nativeGetDurationMs();
+
+    private native int nativeGetWidth();
+
+    private native int nativeGetHeight();
+
+    private native int nativeGetXOffset();
+
+    private native int nativeGetYOffset();
+
+    private native int nativeGetDisposalMode();
+
+    private native boolean nativeHasTransparency();
+
+    private native void nativeDispose();
+
+    private native void nativeFinalize();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifImage.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifImage.java
index c9beab29d..8e70d89ae 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifImage.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/gif/GifImage.java
@@ -27,149 +27,160 @@
 @ThreadSafe
 public class GifImage implements AnimatedImage {
 
-  private volatile static boolean sInitialized;
-
-  // Accessed by native methods
-  @SuppressWarnings("unused")
-  @DoNotStrip
-  private int mNativeContext;
-
-  private static synchronized void ensure() {
-    if (!sInitialized) {
-      sInitialized = true;
-      SoLoaderShim.loadLibrary("gifimage");
-    }
-  }
-
-  /**
-   * Creates a {@link GifImage} from the specified encoded data. This will throw if it fails
-   * to create. This is meant to be called on a worker thread.
-   *
-   * @param source the data to the image (a copy will be made)
-   */
-  public static GifImage create(byte[] source) {
-    ensure();
-    Preconditions.checkNotNull(source);
-
-    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(source.length);
-    byteBuffer.put(source);
-    byteBuffer.rewind();
-
-    return nativeCreateFromDirectByteBuffer(byteBuffer);
-  }
-
-  public static GifImage create(long nativePtr, int sizeInBytes) {
-    ensure();
-    Preconditions.checkArgument(nativePtr != 0);
-    return nativeCreateFromNativeMemory(nativePtr, sizeInBytes);
-  }
-
-  /**
-   * Constructs the image with the native pointer. This is called by native code.
-   *
-   * @param nativeContext the native pointer
-   */
-  @DoNotStrip
-  GifImage(int nativeContext) {
-    mNativeContext = nativeContext;
-  }
-
-  @Override
-  protected void finalize() {
-    nativeFinalize();
-  }
-
-  @Override
-  public void dispose() {
-    nativeDispose();
-  }
-
-  @Override
-  public int getWidth() {
-    return nativeGetWidth();
-  }
-
-  @Override
-  public int getHeight() {
-    return nativeGetHeight();
-  }
-
-  @Override
-  public int getFrameCount() {
-    return nativeGetFrameCount();
-  }
-
-  @Override
-  public int getDuration() {
-    return nativeGetDuration();
-  }
-
-  @Override
-  public int[] getFrameDurations() {
-    return nativeGetFrameDurations();
-  }
-
-  @Override
-  public int getLoopCount() {
-    return nativeGetLoopCount();
-  }
-
-  @Override
-  public GifFrame getFrame(int frameNumber) {
-    return nativeGetFrame(frameNumber);
-  }
-
-  @Override
-  public boolean doesRenderSupportScaling() {
-    return false;
-  }
-
-  @Override
-  public int getSizeInBytes() {
-    return nativeGetSizeInBytes();
-  }
-
-  @Override
-  public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
-    GifFrame frame = getFrame(frameNumber);
-    try {
-      return new AnimatedDrawableFrameInfo(
-          frameNumber,
-          frame.getXOffset(),
-          frame.getYOffset(),
-          frame.getWidth(),
-          frame.getHeight(),
-          true,
-          fromGifDisposalMethod(frame.getDisposalMode()));
-    } finally {
-      frame.dispose();
-    }
-  }
-
-  private static AnimatedDrawableFrameInfo.DisposalMethod fromGifDisposalMethod(int disposalMode) {
-    if (disposalMode == 0 /* DISPOSAL_UNSPECIFIED */) {
-      return AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_DO_NOT;
-    } else if (disposalMode == 1 /* DISPOSE_DO_NOT */) {
-      return AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_DO_NOT;
-    } else if (disposalMode == 2 /* DISPOSE_BACKGROUND */) {
-      return AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_TO_BACKGROUND;
-    } else if (disposalMode == 3 /* DISPOSE_PREVIOUS */) {
-      return AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_TO_PREVIOUS;
-    } else {
-      return AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_DO_NOT;
-    }
-  }
-
-  private static native GifImage nativeCreateFromDirectByteBuffer(ByteBuffer buffer);
-  private static native GifImage nativeCreateFromNativeMemory(long nativePtr, int sizeInBytes);
-  private native int nativeGetWidth();
-  private native int nativeGetHeight();
-  private native int nativeGetDuration();
-  private native int nativeGetFrameCount();
-  private native int[] nativeGetFrameDurations();
-  private native int nativeGetLoopCount();
-  private native GifFrame nativeGetFrame(int frameNumber);
-  private native int nativeGetSizeInBytes();
-  private native void nativeDispose();
-  private native void nativeFinalize();
+    private volatile static boolean sInitialized;
+
+    // Accessed by native methods
+    @SuppressWarnings("unused")
+    @DoNotStrip
+    private int mNativeContext;
+
+    private static synchronized void ensure() {
+        if (!sInitialized) {
+            sInitialized = true;
+            SoLoaderShim.loadLibrary("gifimage");
+        }
+    }
+
+    /**
+     * Creates a {@link GifImage} from the specified encoded data. This will throw if it fails
+     * to create. This is meant to be called on a worker thread.
+     *
+     * @param source the data to the image (a copy will be made)
+     */
+    public static GifImage create(byte[] source) {
+        ensure();
+        Preconditions.checkNotNull(source);
+
+        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(source.length);
+        byteBuffer.put(source);
+        byteBuffer.rewind();
+
+        return nativeCreateFromDirectByteBuffer(byteBuffer);
+    }
+
+    public static GifImage create(long nativePtr, int sizeInBytes) {
+        ensure();
+        Preconditions.checkArgument(nativePtr != 0);
+        return nativeCreateFromNativeMemory(nativePtr, sizeInBytes);
+    }
+
+    /**
+     * Constructs the image with the native pointer. This is called by native code.
+     *
+     * @param nativeContext the native pointer
+     */
+    @DoNotStrip
+    GifImage(int nativeContext) {
+        mNativeContext = nativeContext;
+    }
+
+    @Override
+    protected void finalize() {
+        nativeFinalize();
+    }
+
+    @Override
+    public void dispose() {
+        nativeDispose();
+    }
+
+    @Override
+    public int getWidth() {
+        return nativeGetWidth();
+    }
+
+    @Override
+    public int getHeight() {
+        return nativeGetHeight();
+    }
+
+    @Override
+    public int getFrameCount() {
+        return nativeGetFrameCount();
+    }
+
+    @Override
+    public int getDuration() {
+        return nativeGetDuration();
+    }
+
+    @Override
+    public int[] getFrameDurations() {
+        return nativeGetFrameDurations();
+    }
+
+    @Override
+    public int getLoopCount() {
+        return nativeGetLoopCount();
+    }
+
+    @Override
+    public GifFrame getFrame(int frameNumber) {
+        return nativeGetFrame(frameNumber);
+    }
+
+    @Override
+    public boolean doesRenderSupportScaling() {
+        return false;
+    }
+
+    @Override
+    public int getSizeInBytes() {
+        return nativeGetSizeInBytes();
+    }
+
+    @Override
+    public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
+        GifFrame frame = getFrame(frameNumber);
+        try {
+            return new AnimatedDrawableFrameInfo(
+                    frameNumber,
+                    frame.getXOffset(),
+                    frame.getYOffset(),
+                    frame.getWidth(),
+                    frame.getHeight(),
+                    true,
+                    fromGifDisposalMethod(frame.getDisposalMode()));
+        } finally {
+            frame.dispose();
+        }
+    }
+
+    private static AnimatedDrawableFrameInfo.DisposalMethod fromGifDisposalMethod(int disposalMode) {
+        if (disposalMode == 0 /* DISPOSAL_UNSPECIFIED */) {
+            return AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_DO_NOT;
+        } else if (disposalMode == 1 /* DISPOSE_DO_NOT */) {
+            return AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_DO_NOT;
+        } else if (disposalMode == 2 /* DISPOSE_BACKGROUND */) {
+            return AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_TO_BACKGROUND;
+        } else if (disposalMode == 3 /* DISPOSE_PREVIOUS */) {
+            return AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_TO_PREVIOUS;
+        } else {
+            return AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_DO_NOT;
+        }
+    }
+
+    private static native GifImage nativeCreateFromDirectByteBuffer(ByteBuffer buffer);
+
+    private static native GifImage nativeCreateFromNativeMemory(long nativePtr, int sizeInBytes);
+
+    private native int nativeGetWidth();
+
+    private native int nativeGetHeight();
+
+    private native int nativeGetDuration();
+
+    private native int nativeGetFrameCount();
+
+    private native int[] nativeGetFrameDurations();
+
+    private native int nativeGetLoopCount();
+
+    private native GifFrame nativeGetFrame(int frameNumber);
+
+    private native int nativeGetSizeInBytes();
+
+    private native void nativeDispose();
+
+    private native void nativeFinalize();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedBitmap.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedBitmap.java
index e154c62c0..79527479f 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedBitmap.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedBitmap.java
@@ -27,132 +27,136 @@
 @ThreadSafe
 public class CloseableAnimatedBitmap extends CloseableBitmap {
 
-  // bitmap frames
-  @GuardedBy("this")
-  private List<CloseableReference<Bitmap>> mBitmapReferences;
-  private volatile List<Bitmap> mBitmaps;
-
-  // frame durations
-  private volatile List<Integer> mDurations;
-
-  public CloseableAnimatedBitmap(
-      List<CloseableReference<Bitmap>> bitmapReferences,
-      List<Integer> durations) {
-    Preconditions.checkNotNull(bitmapReferences);
-    Preconditions.checkState(bitmapReferences.size() >= 1, "Need at least 1 frame!");
-    mBitmapReferences = Lists.newArrayList();
-    mBitmaps = Lists.newArrayList();
-    for (CloseableReference<Bitmap> bitmapReference : bitmapReferences) {
-      mBitmapReferences.add(bitmapReference.clone());
-      mBitmaps.add(bitmapReference.get());
+    // bitmap frames
+    @GuardedBy("this")
+    private List<CloseableReference<Bitmap>> mBitmapReferences;
+    private volatile List<Bitmap> mBitmaps;
+
+    // frame durations
+    private volatile List<Integer> mDurations;
+
+    public CloseableAnimatedBitmap(
+            List<CloseableReference<Bitmap>> bitmapReferences,
+            List<Integer> durations) {
+        Preconditions.checkNotNull(bitmapReferences);
+        Preconditions.checkState(bitmapReferences.size() >= 1, "Need at least 1 frame!");
+        mBitmapReferences = Lists.newArrayList();
+        mBitmaps = Lists.newArrayList();
+        for (CloseableReference<Bitmap> bitmapReference : bitmapReferences) {
+            mBitmapReferences.add(bitmapReference.clone());
+            mBitmaps.add(bitmapReference.get());
+        }
+        mDurations = Preconditions.checkNotNull(durations);
+        Preconditions.checkState(mDurations.size() == mBitmaps.size(), "Arrays length mismatch!");
     }
-    mDurations = Preconditions.checkNotNull(durations);
-    Preconditions.checkState(mDurations.size() == mBitmaps.size(), "Arrays length mismatch!");
-  }
-
-  /**
-   * Creates a new instance of a CloseableStaticBitmap.
-   * @param bitmaps the bitmap frames. This list must be immutable.
-   * @param durations the frame durations, This list must be immutable.
-   * @param resourceReleaser ResourceReleaser to release the bitmaps to
-   */
-  public CloseableAnimatedBitmap(
-      List<Bitmap> bitmaps,
-      List<Integer> durations,
-      ResourceReleaser<Bitmap> resourceReleaser) {
-    Preconditions.checkNotNull(bitmaps);
-    Preconditions.checkState(bitmaps.size() >= 1, "Need at least 1 frame!");
-    mBitmaps = Lists.newArrayList();
-    mBitmapReferences = Lists.newArrayList();
-    for (Bitmap bitmap : bitmaps) {
-      mBitmapReferences.add(CloseableReference.of(bitmap, resourceReleaser));
-      mBitmaps.add(bitmap);
+
+    /**
+     * Creates a new instance of a CloseableStaticBitmap.
+     *
+     * @param bitmaps          the bitmap frames. This list must be immutable.
+     * @param durations        the frame durations, This list must be immutable.
+     * @param resourceReleaser ResourceReleaser to release the bitmaps to
+     */
+    public CloseableAnimatedBitmap(
+            List<Bitmap> bitmaps,
+            List<Integer> durations,
+            ResourceReleaser<Bitmap> resourceReleaser) {
+        Preconditions.checkNotNull(bitmaps);
+        Preconditions.checkState(bitmaps.size() >= 1, "Need at least 1 frame!");
+        mBitmaps = Lists.newArrayList();
+        mBitmapReferences = Lists.newArrayList();
+        for (Bitmap bitmap : bitmaps) {
+            mBitmapReferences.add(CloseableReference.of(bitmap, resourceReleaser));
+            mBitmaps.add(bitmap);
+        }
+        mDurations = Preconditions.checkNotNull(durations);
+        Preconditions.checkState(mDurations.size() == mBitmaps.size(), "Arrays length mismatch!");
+    }
+
+    /**
+     * Releases the bitmaps to the pool.
+     */
+    @Override
+    public void close() {
+        List<CloseableReference<Bitmap>> bitmapReferences;
+        synchronized (this) {
+            if (mBitmapReferences == null) {
+                return;
+            }
+            bitmapReferences = mBitmapReferences;
+            mBitmapReferences = null;
+            mBitmaps = null;
+            mDurations = null;
+        }
+        CloseableReference.closeSafely(bitmapReferences);
+    }
+
+    /**
+     * Returns whether this instance is closed.
+     */
+    @Override
+    public synchronized boolean isClosed() {
+        return mBitmaps == null;
+    }
+
+    /**
+     * Gets the bitmap frames.
+     *
+     * @return bitmap frames
+     */
+    public List<Bitmap> getBitmaps() {
+        return mBitmaps;
     }
-    mDurations = Preconditions.checkNotNull(durations);
-    Preconditions.checkState(mDurations.size() == mBitmaps.size(), "Arrays length mismatch!");
-  }
-
-  /**
-   * Releases the bitmaps to the pool.
-   */
-  @Override
-  public void close() {
-    List<CloseableReference<Bitmap>> bitmapReferences;
-    synchronized (this) {
-      if (mBitmapReferences == null) {
-        return;
-      }
-      bitmapReferences = mBitmapReferences;
-      mBitmapReferences = null;
-      mBitmaps = null;
-      mDurations = null;
+
+    /**
+     * Gets the frame durations.
+     *
+     * @return frame durations
+     */
+    public List<Integer> getDurations() {
+        return mDurations;
     }
-    CloseableReference.closeSafely(bitmapReferences);
-  }
-
-  /**
-   * Returns whether this instance is closed.
-   */
-  @Override
-  public synchronized boolean isClosed() {
-    return mBitmaps == null;
-  }
-
-  /**
-   * Gets the bitmap frames.
-   * @return bitmap frames
-   */
-  public List<Bitmap> getBitmaps() {
-    return mBitmaps;
-  }
-
-  /**
-   * Gets the frame durations.
-   * @return frame durations
-   */
-  public List<Integer> getDurations() {
-    return mDurations;
-  }
-
-  /**
-   * Gets the first frame.
-   * @return the first frame
-   */
-  @Override
-  public Bitmap getUnderlyingBitmap() {
-    List<Bitmap> bitmaps = mBitmaps;
-    return (bitmaps != null) ? bitmaps.get(0) : null;
-  }
-
-  /**
-   * @return size in bytes all bitmaps in sum
-   */
-  @Override
-  public int getSizeInBytes() {
-    List<Bitmap> bitmaps = mBitmaps;
-    if (bitmaps == null) {
-      return 0;
-    } else {
-      return bitmaps.get(0).getHeight() * bitmaps.get(0).getRowBytes() * bitmaps.size();
+
+    /**
+     * Gets the first frame.
+     *
+     * @return the first frame
+     */
+    @Override
+    public Bitmap getUnderlyingBitmap() {
+        List<Bitmap> bitmaps = mBitmaps;
+        return (bitmaps != null) ? bitmaps.get(0) : null;
+    }
+
+    /**
+     * @return size in bytes all bitmaps in sum
+     */
+    @Override
+    public int getSizeInBytes() {
+        List<Bitmap> bitmaps = mBitmaps;
+        if (bitmaps == null) {
+            return 0;
+        } else {
+            return bitmaps.get(0).getHeight() * bitmaps.get(0).getRowBytes() * bitmaps.size();
+        }
+    }
+
+    /**
+     * @return width of the image
+     */
+    @Override
+    public int getWidth() {
+        List<Bitmap> bitmaps = mBitmaps;
+        return (bitmaps == null) ? 0 : bitmaps.get(0).getWidth();
+    }
+
+    /**
+     * @return height of the image
+     */
+    @Override
+    public int getHeight() {
+        List<Bitmap> bitmaps = mBitmaps;
+        return (bitmaps == null) ? 0 : bitmaps.get(0).getHeight();
     }
-  }
-
-  /**
-   * @return width of the image
-   */
-  @Override
-  public int getWidth() {
-    List<Bitmap> bitmaps = mBitmaps;
-    return (bitmaps == null) ? 0 : bitmaps.get(0).getWidth();
-  }
-
-  /**
-   * @return height of the image
-   */
-  @Override
-  public int getHeight() {
-    List<Bitmap> bitmaps = mBitmaps;
-    return (bitmaps == null) ? 0 : bitmaps.get(0).getHeight();
-  }
 
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedImage.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedImage.java
index 1437397db..7912ca31a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedImage.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableAnimatedImage.java
@@ -18,55 +18,55 @@
  */
 public class CloseableAnimatedImage extends CloseableImage {
 
-  private AnimatedImageResult mImageResult;
+    private AnimatedImageResult mImageResult;
 
-  public CloseableAnimatedImage(AnimatedImageResult imageResult) {
-    mImageResult = imageResult;
-  }
+    public CloseableAnimatedImage(AnimatedImageResult imageResult) {
+        mImageResult = imageResult;
+    }
 
-  @Override
-  public synchronized int getWidth() {
-    return isClosed() ? 0 : mImageResult.getImage().getWidth();
-  }
+    @Override
+    public synchronized int getWidth() {
+        return isClosed() ? 0 : mImageResult.getImage().getWidth();
+    }
 
-  @Override
-  public synchronized int getHeight() {
-    return isClosed() ? 0 : mImageResult.getImage().getHeight();
-  }
+    @Override
+    public synchronized int getHeight() {
+        return isClosed() ? 0 : mImageResult.getImage().getHeight();
+    }
 
-  @Override
-  public void close() {
-    AnimatedImageResult imageResult;
-    synchronized (this) {
-      if (mImageResult == null) {
-        return;
-      }
-      imageResult = mImageResult;
-      mImageResult = null;
+    @Override
+    public void close() {
+        AnimatedImageResult imageResult;
+        synchronized (this) {
+            if (mImageResult == null) {
+                return;
+            }
+            imageResult = mImageResult;
+            mImageResult = null;
+        }
+        imageResult.dispose();
     }
-    imageResult.dispose();
-  }
 
-  @Override
-  public synchronized boolean isClosed() {
-    return mImageResult == null;
-  }
+    @Override
+    public synchronized boolean isClosed() {
+        return mImageResult == null;
+    }
 
-  @Override
-  public synchronized int getSizeInBytes() {
-    return isClosed() ? 0 : mImageResult.getImage().getSizeInBytes();
-  }
+    @Override
+    public synchronized int getSizeInBytes() {
+        return isClosed() ? 0 : mImageResult.getImage().getSizeInBytes();
+    }
 
-  @Override
-  public boolean isStateful() {
-    return true;
-  }
+    @Override
+    public boolean isStateful() {
+        return true;
+    }
 
-  public synchronized AnimatedImageResult getImageResult() {
-    return mImageResult;
-  }
+    public synchronized AnimatedImageResult getImageResult() {
+        return mImageResult;
+    }
 
-  public synchronized AnimatedImage getImage() {
-    return isClosed() ? null : mImageResult.getImage();
-  }
+    public synchronized AnimatedImage getImage() {
+        return isClosed() ? null : mImageResult.getImage();
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableBitmap.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableBitmap.java
index a710f3599..ad85a6602 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableBitmap.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableBitmap.java
@@ -15,12 +15,13 @@
  */
 public abstract class CloseableBitmap extends CloseableImage {
 
-  /**
-   * Gets the underlying bitmap.
-   * Note: care must be taken because subclasses might be more sophisticated than that. For example,
-   * animated bitmap may have many frames and this method will only return the first one.
-   * @return the underlying bitmap
-   */
-  public abstract Bitmap getUnderlyingBitmap();
+    /**
+     * Gets the underlying bitmap.
+     * Note: care must be taken because subclasses might be more sophisticated than that. For example,
+     * animated bitmap may have many frames and this method will only return the first one.
+     *
+     * @return the underlying bitmap
+     */
+    public abstract Bitmap getUnderlyingBitmap();
 
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableImage.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableImage.java
index b35241d3d..3d057c895 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableImage.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableImage.java
@@ -17,58 +17,58 @@
  * A simple wrapper around an image that implements {@link Closeable}
  */
 public abstract class CloseableImage implements Closeable, ImageInfo {
-  private static final Class<?> TAG = CloseableImage.class;
+    private static final Class<?> TAG = CloseableImage.class;
 
-  /**
-   * @return size in bytes of the bitmap(s)
-   */
-  public abstract int getSizeInBytes();
+    /**
+     * @return size in bytes of the bitmap(s)
+     */
+    public abstract int getSizeInBytes();
 
-  /**
-   * Closes this instance and releases the resources.
-   */
-  @Override
-  public abstract void close();
+    /**
+     * Closes this instance and releases the resources.
+     */
+    @Override
+    public abstract void close();
 
-  /**
-   * Returns whether this instance is closed.
-   */
-  public abstract boolean isClosed();
+    /**
+     * Returns whether this instance is closed.
+     */
+    public abstract boolean isClosed();
 
-  /**
-   * Returns quality information for the image.
-   * <p> Image classes that can contain intermediate results should override this as appropriate.
-   */
-  @Override
-  public QualityInfo getQualityInfo() {
-    return ImmutableQualityInfo.FULL_QUALITY;
-  }
-
-  /**
-   * Whether or not this image contains state for a particular view of the image (for example,
-   * the image for an animated GIF might contain the current frame being viewed). This means
-   * that the image should not be stored in the bitmap cache.
-   */
-  public boolean isStateful() {
-    return false;
-  }
+    /**
+     * Returns quality information for the image.
+     * <p> Image classes that can contain intermediate results should override this as appropriate.
+     */
+    @Override
+    public QualityInfo getQualityInfo() {
+        return ImmutableQualityInfo.FULL_QUALITY;
+    }
 
-  /**
-   * Ensures that the underlying resources are always properly released.
-   */
-  @Override
-  protected void finalize() throws Throwable {
-    if (isClosed()) {
-      return;
+    /**
+     * Whether or not this image contains state for a particular view of the image (for example,
+     * the image for an animated GIF might contain the current frame being viewed). This means
+     * that the image should not be stored in the bitmap cache.
+     */
+    public boolean isStateful() {
+        return false;
     }
-    FLog.w(
-        TAG,
-        "finalize: CloseableImage %x still open.",
-        System.identityHashCode(this));
-    try {
-      close();
-    } finally {
-      super.finalize();
+
+    /**
+     * Ensures that the underlying resources are always properly released.
+     */
+    @Override
+    protected void finalize() throws Throwable {
+        if (isClosed()) {
+            return;
+        }
+        FLog.w(
+                TAG,
+                "finalize: CloseableImage %x still open.",
+                System.identityHashCode(this));
+        try {
+            close();
+        } finally {
+            super.finalize();
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableStaticBitmap.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableStaticBitmap.java
index fa496b892..b025caa37 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableStaticBitmap.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/CloseableStaticBitmap.java
@@ -24,112 +24,113 @@
 @ThreadSafe
 public class CloseableStaticBitmap extends CloseableBitmap {
 
-  @GuardedBy("this")
-  private CloseableReference<Bitmap> mBitmapReference;
-
-  private volatile Bitmap mBitmap;
-
-  // quality info
-  private final QualityInfo mQualityInfo;
-
-
-  /**
-   * Creates a new instance of a CloseableStaticBitmap.
-   *
-   * @param bitmap the bitmap to wrap
-   * @param resourceReleaser ResourceReleaser to release the bitmap to
-   */
-  public CloseableStaticBitmap(
-      Bitmap bitmap,
-      ResourceReleaser<Bitmap> resourceReleaser,
-      QualityInfo qualityInfo) {
-    mBitmap = Preconditions.checkNotNull(bitmap);
-    mBitmapReference = CloseableReference.of(
-        mBitmap,
-        Preconditions.checkNotNull(resourceReleaser));
-    mQualityInfo = qualityInfo;
-  }
-
-  /**
-   * Creates a new instance of a CloseableStaticBitmap from an existing CloseableReference. The
-   * CloseableStaticBitmap will hold a reference to the Bitmap until it's closed.
-   *
-   * @param bitmapReference the bitmap reference.
-   */
-  public CloseableStaticBitmap(
-      CloseableReference<Bitmap> bitmapReference,
-      QualityInfo qualityInfo) {
-    mBitmapReference = Preconditions.checkNotNull(bitmapReference.cloneOrNull());
-    mBitmap = mBitmapReference.get();
-    mQualityInfo = qualityInfo;
-  }
-
-  /**
-   * Releases the bitmap to the pool.
-   */
-  @Override
-  public void close() {
-    CloseableReference<Bitmap> reference;
-    synchronized (this) {
-      if (mBitmapReference == null) {
-        return;
-      }
-      reference = mBitmapReference;
-      mBitmapReference = null;
-      mBitmap = null;
+    @GuardedBy("this")
+    private CloseableReference<Bitmap> mBitmapReference;
+
+    private volatile Bitmap mBitmap;
+
+    // quality info
+    private final QualityInfo mQualityInfo;
+
+
+    /**
+     * Creates a new instance of a CloseableStaticBitmap.
+     *
+     * @param bitmap           the bitmap to wrap
+     * @param resourceReleaser ResourceReleaser to release the bitmap to
+     */
+    public CloseableStaticBitmap(
+            Bitmap bitmap,
+            ResourceReleaser<Bitmap> resourceReleaser,
+            QualityInfo qualityInfo) {
+        mBitmap = Preconditions.checkNotNull(bitmap);
+        mBitmapReference = CloseableReference.of(
+                mBitmap,
+                Preconditions.checkNotNull(resourceReleaser));
+        mQualityInfo = qualityInfo;
+    }
+
+    /**
+     * Creates a new instance of a CloseableStaticBitmap from an existing CloseableReference. The
+     * CloseableStaticBitmap will hold a reference to the Bitmap until it's closed.
+     *
+     * @param bitmapReference the bitmap reference.
+     */
+    public CloseableStaticBitmap(
+            CloseableReference<Bitmap> bitmapReference,
+            QualityInfo qualityInfo) {
+        mBitmapReference = Preconditions.checkNotNull(bitmapReference.cloneOrNull());
+        mBitmap = mBitmapReference.get();
+        mQualityInfo = qualityInfo;
+    }
+
+    /**
+     * Releases the bitmap to the pool.
+     */
+    @Override
+    public void close() {
+        CloseableReference<Bitmap> reference;
+        synchronized (this) {
+            if (mBitmapReference == null) {
+                return;
+            }
+            reference = mBitmapReference;
+            mBitmapReference = null;
+            mBitmap = null;
+        }
+        reference.close();
+    }
+
+    /**
+     * Returns whether this instance is closed.
+     */
+    @Override
+    public synchronized boolean isClosed() {
+        return mBitmapReference == null;
+    }
+
+    /**
+     * Gets the underlying bitmap.
+     *
+     * @return the underlying bitmap
+     */
+    @Override
+    public Bitmap getUnderlyingBitmap() {
+        return mBitmap;
+    }
+
+    /**
+     * @return size in bytes of the underlying bitmap
+     */
+    @Override
+    public int getSizeInBytes() {
+        Bitmap bitmap = mBitmap;
+        return (bitmap == null) ? 0 : bitmap.getHeight() * bitmap.getRowBytes();
+    }
+
+    /**
+     * @return width of the image
+     */
+    @Override
+    public int getWidth() {
+        Bitmap bitmap = mBitmap;
+        return (bitmap == null) ? 0 : bitmap.getWidth();
+    }
+
+    /**
+     * @return height of the image
+     */
+    @Override
+    public int getHeight() {
+        Bitmap bitmap = mBitmap;
+        return (bitmap == null) ? 0 : bitmap.getHeight();
+    }
+
+    /**
+     * Returns quality information for the image.
+     */
+    @Override
+    public QualityInfo getQualityInfo() {
+        return mQualityInfo;
     }
-    reference.close();
-  }
-
-  /**
-   * Returns whether this instance is closed.
-   */
-  @Override
-  public synchronized boolean isClosed() {
-    return mBitmapReference == null;
-  }
-
-  /**
-   * Gets the underlying bitmap.
-   * @return the underlying bitmap
-   */
-  @Override
-  public Bitmap getUnderlyingBitmap() {
-    return mBitmap;
-  }
-
-  /**
-   * @return size in bytes of the underlying bitmap
-   */
-  @Override
-  public int getSizeInBytes() {
-    Bitmap bitmap = mBitmap;
-    return (bitmap == null) ? 0 : bitmap.getHeight() * bitmap.getRowBytes();
-  }
-
-  /**
-   * @return width of the image
-   */
-  @Override
-  public int getWidth() {
-    Bitmap bitmap = mBitmap;
-    return (bitmap == null) ? 0 : bitmap.getWidth();
-  }
-
-  /**
-   * @return height of the image
-   */
-  @Override
-  public int getHeight() {
-    Bitmap bitmap = mBitmap;
-    return (bitmap == null) ? 0 : bitmap.getHeight();
-  }
-
-  /**
-   * Returns quality information for the image.
-   */
-  @Override
-  public QualityInfo getQualityInfo() {
-    return mQualityInfo;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/ImageInfo.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/ImageInfo.java
index 90b45b723..addb887c7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/ImageInfo.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/ImageInfo.java
@@ -14,18 +14,18 @@
  */
 public interface ImageInfo {
 
-  /**
-   * @return width of the image
-   */
-  public int getWidth();
+    /**
+     * @return width of the image
+     */
+    public int getWidth();
 
-  /**
-   * @return height of the image
-   */
-  public int getHeight();
+    /**
+     * @return height of the image
+     */
+    public int getHeight();
 
-  /**
-   * @return quality information for the image
-   */
-  public QualityInfo getQualityInfo();
+    /**
+     * @return quality information for the image
+     */
+    public QualityInfo getQualityInfo();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/ImmutableQualityInfo.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/ImmutableQualityInfo.java
index 351b2e870..4113242b1 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/ImmutableQualityInfo.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/ImmutableQualityInfo.java
@@ -14,59 +14,59 @@
  */
 public class ImmutableQualityInfo implements QualityInfo {
 
-  public static final QualityInfo FULL_QUALITY = of(Integer.MAX_VALUE, true, true);
+    public static final QualityInfo FULL_QUALITY = of(Integer.MAX_VALUE, true, true);
 
-  int mQuality;
-  boolean mIsOfGoodEnoughQuality;
-  boolean mIsOfFullQuality;
+    int mQuality;
+    boolean mIsOfGoodEnoughQuality;
+    boolean mIsOfFullQuality;
 
-  private ImmutableQualityInfo(
-      int quality,
-      boolean isOfGoodEnoughQuality,
-      boolean isOfFullQuality) {
-    mQuality = quality;
-    mIsOfGoodEnoughQuality = isOfGoodEnoughQuality;
-    mIsOfFullQuality = isOfFullQuality;
-  }
-
-  @Override
-  public int getQuality() {
-    return mQuality;
-  }
+    private ImmutableQualityInfo(
+            int quality,
+            boolean isOfGoodEnoughQuality,
+            boolean isOfFullQuality) {
+        mQuality = quality;
+        mIsOfGoodEnoughQuality = isOfGoodEnoughQuality;
+        mIsOfFullQuality = isOfFullQuality;
+    }
 
-  @Override
-  public boolean isOfGoodEnoughQuality() {
-    return mIsOfGoodEnoughQuality;
-  }
+    @Override
+    public int getQuality() {
+        return mQuality;
+    }
 
-  @Override
-  public boolean isOfFullQuality() {
-    return mIsOfFullQuality;
-  }
+    @Override
+    public boolean isOfGoodEnoughQuality() {
+        return mIsOfGoodEnoughQuality;
+    }
 
-  @Override
-  public int hashCode() {
-    return mQuality ^ (mIsOfGoodEnoughQuality ? 0x400000 : 0) ^ (mIsOfFullQuality ? 0x800000 : 0);
-  }
+    @Override
+    public boolean isOfFullQuality() {
+        return mIsOfFullQuality;
+    }
 
-  @Override
-  public boolean equals(Object other) {
-    if (other == this) {
-      return true;
+    @Override
+    public int hashCode() {
+        return mQuality ^ (mIsOfGoodEnoughQuality ? 0x400000 : 0) ^ (mIsOfFullQuality ? 0x800000 : 0);
     }
-    if (!(other instanceof ImmutableQualityInfo)) {
-      return false;
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof ImmutableQualityInfo)) {
+            return false;
+        }
+        ImmutableQualityInfo that = (ImmutableQualityInfo) other;
+        return mQuality == that.mQuality &&
+                mIsOfGoodEnoughQuality == that.mIsOfGoodEnoughQuality &&
+                mIsOfFullQuality == that.mIsOfFullQuality;
     }
-    ImmutableQualityInfo that = (ImmutableQualityInfo) other;
-    return mQuality == that.mQuality &&
-        mIsOfGoodEnoughQuality == that.mIsOfGoodEnoughQuality &&
-        mIsOfFullQuality == that.mIsOfFullQuality;
-  }
 
-  public static QualityInfo of(
-      int quality,
-      boolean isOfGoodEnoughQuality,
-      boolean isOfFullQuality) {
-    return new ImmutableQualityInfo(quality, isOfGoodEnoughQuality, isOfFullQuality);
-  }
+    public static QualityInfo of(
+            int quality,
+            boolean isOfGoodEnoughQuality,
+            boolean isOfFullQuality) {
+        return new ImmutableQualityInfo(quality, isOfGoodEnoughQuality, isOfFullQuality);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/QualityInfo.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/QualityInfo.java
index 9be8b92dd..b5393fd15 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/image/QualityInfo.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/image/QualityInfo.java
@@ -14,25 +14,25 @@
  */
 public interface QualityInfo {
 
-  /**
-   * Used only to compare quality of two images that points to the same resource (uri).
-   * <p> Higher number means higher quality.
-   * <p> This is useful for caching in order to determine whether the new result is of higher
-   * quality than what's already in the cache.
-   */
-  public int getQuality();
+    /**
+     * Used only to compare quality of two images that points to the same resource (uri).
+     * <p> Higher number means higher quality.
+     * <p> This is useful for caching in order to determine whether the new result is of higher
+     * quality than what's already in the cache.
+     */
+    public int getQuality();
 
-  /**
-   * Whether the image is of good-enough quality.
-   * <p> When fetching image progressively, the few first results can be of really poor quality,
-   * but eventually, they get really close to original image, and we mark those as good-enough.
-   */
-  public boolean isOfGoodEnoughQuality();
+    /**
+     * Whether the image is of good-enough quality.
+     * <p> When fetching image progressively, the few first results can be of really poor quality,
+     * but eventually, they get really close to original image, and we mark those as good-enough.
+     */
+    public boolean isOfGoodEnoughQuality();
 
-  /**
-   * Whether the image is of full quality.
-   * <p> For progressive JPEGs, this is the final scan. For other image types, this is always true.
-   */
-  public boolean isOfFullQuality();
+    /**
+     * Whether the image is of full quality.
+     * <p> For progressive JPEGs, this is the final scan. For other image types, this is always true.
+     */
+    public boolean isOfFullQuality();
 
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/BaseRequestListener.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/BaseRequestListener.java
index 2b6426278..1aff2bff7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/BaseRequestListener.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/BaseRequestListener.java
@@ -16,53 +16,53 @@
 
 public class BaseRequestListener implements RequestListener {
 
-  @Override
-  public void onRequestStart(
-      ImageRequest request, Object callerContext, String requestId, boolean isPrefetch) {
-  }
+    @Override
+    public void onRequestStart(
+            ImageRequest request, Object callerContext, String requestId, boolean isPrefetch) {
+    }
 
-  @Override
-  public void onRequestSuccess(
-      ImageRequest request, String requestId, boolean isPrefetch) {
-  }
+    @Override
+    public void onRequestSuccess(
+            ImageRequest request, String requestId, boolean isPrefetch) {
+    }
 
-  @Override
-  public void onRequestFailure(
-      ImageRequest request, String requestId, Throwable throwable, boolean isPrefetch) {
-  }
+    @Override
+    public void onRequestFailure(
+            ImageRequest request, String requestId, Throwable throwable, boolean isPrefetch) {
+    }
 
-  @Override
-  public void onRequestCancellation(String requestId) {
-  }
+    @Override
+    public void onRequestCancellation(String requestId) {
+    }
 
-  @Override
-  public void onProducerStart(String requestId, String producerName) {
-  }
+    @Override
+    public void onProducerStart(String requestId, String producerName) {
+    }
 
-  @Override
-  public void onProducerEvent(String requestId, String producerName, String eventName) {
-  }
+    @Override
+    public void onProducerEvent(String requestId, String producerName, String eventName) {
+    }
 
-  @Override
-  public void onProducerFinishWithSuccess(
-      String requestId, String producerName, @Nullable Map<String, String> extraMap) {
-  }
+    @Override
+    public void onProducerFinishWithSuccess(
+            String requestId, String producerName, @Nullable Map<String, String> extraMap) {
+    }
 
-  @Override
-  public void onProducerFinishWithFailure(
-      String requestId,
-      String producerName,
-      Throwable t,
-      @Nullable Map<String, String> extraMap) {
-  }
+    @Override
+    public void onProducerFinishWithFailure(
+            String requestId,
+            String producerName,
+            Throwable t,
+            @Nullable Map<String, String> extraMap) {
+    }
 
-  @Override
-  public void onProducerFinishWithCancellation(
-      String requestId, String producerName, @Nullable Map<String, String> extraMap) {
-  }
+    @Override
+    public void onProducerFinishWithCancellation(
+            String requestId, String producerName, @Nullable Map<String, String> extraMap) {
+    }
 
-  @Override
-  public boolean requiresExtraMap(String requestId) {
-    return false;
-  }
+    @Override
+    public boolean requiresExtraMap(String requestId) {
+        return false;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/ForwardingRequestListener.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/ForwardingRequestListener.java
index 6ce79482f..a86ff3257 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/ForwardingRequestListener.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/ForwardingRequestListener.java
@@ -20,167 +20,167 @@
 import com.facebook.imagepipeline.request.ImageRequest;
 
 public class ForwardingRequestListener implements RequestListener {
-  private static final String TAG = "ForwardingRequestListener";
+    private static final String TAG = "ForwardingRequestListener";
 
-  private final List<RequestListener> mRequestListeners;
+    private final List<RequestListener> mRequestListeners;
 
-  public ForwardingRequestListener(
-      Set<RequestListener> requestListeners) {
-    mRequestListeners = Lists.newArrayListWithCapacity(requestListeners.size());
-    for (RequestListener requestListener : requestListeners) {
-      mRequestListeners.add(requestListener);
+    public ForwardingRequestListener(
+            Set<RequestListener> requestListeners) {
+        mRequestListeners = Lists.newArrayListWithCapacity(requestListeners.size());
+        for (RequestListener requestListener : requestListeners) {
+            mRequestListeners.add(requestListener);
+        }
     }
-  }
-
-  @Override
-  public void onRequestStart(
-      ImageRequest request, Object callerContext, String requestId, boolean isPrefetch) {
-    final int numberOfListeners = mRequestListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      RequestListener listener = mRequestListeners.get(i);
-      try {
-        listener.onRequestStart(request, callerContext, requestId, isPrefetch);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onRequestStart", exception);
-      }
+
+    @Override
+    public void onRequestStart(
+            ImageRequest request, Object callerContext, String requestId, boolean isPrefetch) {
+        final int numberOfListeners = mRequestListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            RequestListener listener = mRequestListeners.get(i);
+            try {
+                listener.onRequestStart(request, callerContext, requestId, isPrefetch);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onRequestStart", exception);
+            }
+        }
     }
-  }
-
-  @Override
-  public void onProducerStart(String requestId, String producerName) {
-    final int numberOfListeners = mRequestListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      RequestListener listener = mRequestListeners.get(i);
-      try {
-        listener.onProducerStart(requestId, producerName);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onProducerStart", exception);
-      }
+
+    @Override
+    public void onProducerStart(String requestId, String producerName) {
+        final int numberOfListeners = mRequestListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            RequestListener listener = mRequestListeners.get(i);
+            try {
+                listener.onProducerStart(requestId, producerName);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onProducerStart", exception);
+            }
+        }
     }
-  }
-
-  @Override
-  public void onProducerFinishWithSuccess(
-      String requestId, String producerName, @Nullable Map<String, String> extraMap) {
-    final int numberOfListeners = mRequestListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      RequestListener listener = mRequestListeners.get(i);
-      try {
-        listener.onProducerFinishWithSuccess(requestId, producerName, extraMap);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onProducerFinishWithSuccess", exception);
-      }
+
+    @Override
+    public void onProducerFinishWithSuccess(
+            String requestId, String producerName, @Nullable Map<String, String> extraMap) {
+        final int numberOfListeners = mRequestListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            RequestListener listener = mRequestListeners.get(i);
+            try {
+                listener.onProducerFinishWithSuccess(requestId, producerName, extraMap);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onProducerFinishWithSuccess", exception);
+            }
+        }
     }
-  }
-
-  @Override
-  public void onProducerFinishWithFailure(
-      String requestId,
-      String producerName,
-      Throwable t,
-      @Nullable Map<String, String> extraMap) {
-    final int numberOfListeners = mRequestListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      RequestListener listener = mRequestListeners.get(i);
-      try {
-        listener.onProducerFinishWithFailure(requestId, producerName, t, extraMap);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onProducerFinishWithFailure", exception);
-      }
+
+    @Override
+    public void onProducerFinishWithFailure(
+            String requestId,
+            String producerName,
+            Throwable t,
+            @Nullable Map<String, String> extraMap) {
+        final int numberOfListeners = mRequestListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            RequestListener listener = mRequestListeners.get(i);
+            try {
+                listener.onProducerFinishWithFailure(requestId, producerName, t, extraMap);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onProducerFinishWithFailure", exception);
+            }
+        }
     }
-  }
-
-  @Override
-  public void onProducerFinishWithCancellation(
-      String requestId, String producerName, @Nullable Map<String, String> extraMap) {
-    final int numberOfListeners = mRequestListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      RequestListener listener = mRequestListeners.get(i);
-      try {
-        listener.onProducerFinishWithCancellation(requestId, producerName, extraMap);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onProducerFinishWithCancellation", exception);
-      }
+
+    @Override
+    public void onProducerFinishWithCancellation(
+            String requestId, String producerName, @Nullable Map<String, String> extraMap) {
+        final int numberOfListeners = mRequestListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            RequestListener listener = mRequestListeners.get(i);
+            try {
+                listener.onProducerFinishWithCancellation(requestId, producerName, extraMap);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onProducerFinishWithCancellation", exception);
+            }
+        }
     }
-  }
-
-  @Override
-  public void onProducerEvent(
-      String requestId, String producerName, String producerEventName) {
-    final int numberOfListeners = mRequestListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      RequestListener listener = mRequestListeners.get(i);
-      try {
-        listener.onProducerEvent(requestId, producerName, producerEventName);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onIntermediateChunkStart", exception);
-      }
+
+    @Override
+    public void onProducerEvent(
+            String requestId, String producerName, String producerEventName) {
+        final int numberOfListeners = mRequestListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            RequestListener listener = mRequestListeners.get(i);
+            try {
+                listener.onProducerEvent(requestId, producerName, producerEventName);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onIntermediateChunkStart", exception);
+            }
+        }
     }
-  }
-
-  @Override
-  public void onRequestSuccess(ImageRequest request, String requestId, boolean isPrefetch) {
-    final int numberOfListeners = mRequestListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      RequestListener listener = mRequestListeners.get(i);
-      try {
-        listener.onRequestSuccess(request, requestId, isPrefetch);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onRequestSuccess", exception);
-      }
+
+    @Override
+    public void onRequestSuccess(ImageRequest request, String requestId, boolean isPrefetch) {
+        final int numberOfListeners = mRequestListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            RequestListener listener = mRequestListeners.get(i);
+            try {
+                listener.onRequestSuccess(request, requestId, isPrefetch);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onRequestSuccess", exception);
+            }
+        }
     }
-  }
-
-  @Override
-  public void onRequestFailure(
-      ImageRequest request,
-      String requestId,
-      Throwable throwable,
-      boolean isPrefetch) {
-    final int numberOfListeners = mRequestListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      RequestListener listener = mRequestListeners.get(i);
-      try {
-        listener.onRequestFailure(request, requestId, throwable, isPrefetch);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onRequestFailure", exception);
-      }
+
+    @Override
+    public void onRequestFailure(
+            ImageRequest request,
+            String requestId,
+            Throwable throwable,
+            boolean isPrefetch) {
+        final int numberOfListeners = mRequestListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            RequestListener listener = mRequestListeners.get(i);
+            try {
+                listener.onRequestFailure(request, requestId, throwable, isPrefetch);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onRequestFailure", exception);
+            }
+        }
     }
-  }
-
-  @Override
-  public void onRequestCancellation(String requestId) {
-    final int numberOfListeners = mRequestListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      RequestListener listener = mRequestListeners.get(i);
-      try {
-        listener.onRequestCancellation(requestId);
-      } catch (Exception exception) {
-        // Don't punish the other listeners if we're given a bad one.
-        onException("InternalListener exception in onRequestCancellation", exception);
-      }
+
+    @Override
+    public void onRequestCancellation(String requestId) {
+        final int numberOfListeners = mRequestListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            RequestListener listener = mRequestListeners.get(i);
+            try {
+                listener.onRequestCancellation(requestId);
+            } catch (Exception exception) {
+                // Don't punish the other listeners if we're given a bad one.
+                onException("InternalListener exception in onRequestCancellation", exception);
+            }
+        }
     }
-  }
-
-  public boolean requiresExtraMap(String id) {
-    final int numberOfListeners = mRequestListeners.size();
-    for (int i = 0; i < numberOfListeners; ++i) {
-      if (mRequestListeners.get(i).requiresExtraMap(id)) {
-        return true;
-      }
+
+    public boolean requiresExtraMap(String id) {
+        final int numberOfListeners = mRequestListeners.size();
+        for (int i = 0; i < numberOfListeners; ++i) {
+            if (mRequestListeners.get(i).requiresExtraMap(id)) {
+                return true;
+            }
+        }
+        return false;
     }
-    return false;
-  }
 
-  private void onException(String message, Throwable t) {
-    FLog.e(TAG, message, t);
-  }
+    private void onException(String message, Throwable t) {
+        FLog.e(TAG, message, t);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/RequestListener.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/RequestListener.java
index 37b7c9c56..5fe647987 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/RequestListener.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/listener/RequestListener.java
@@ -16,43 +16,47 @@
  * Listener for {@link ImageRequest}.
  */
 public interface RequestListener extends ProducerListener {
-  /**
-   * Called when request is about to be submitted to the Orchestrator's executor queue.
-   * @param request which triggered the event
-   * @param callerContext context of the caller of the request
-   * @param requestId unique id generated automatically for each request submission
-   * @param isPrefetch whether the request is a prefetch or not
-   */
-  void onRequestStart(
-      ImageRequest request,
-      Object callerContext,
-      String requestId,
-      boolean isPrefetch);
+    /**
+     * Called when request is about to be submitted to the Orchestrator's executor queue.
+     *
+     * @param request       which triggered the event
+     * @param callerContext context of the caller of the request
+     * @param requestId     unique id generated automatically for each request submission
+     * @param isPrefetch    whether the request is a prefetch or not
+     */
+    void onRequestStart(
+            ImageRequest request,
+            Object callerContext,
+            String requestId,
+            boolean isPrefetch);
 
-  /**
-   * Called after successful completion of the request (all producers completed successfully).
-   * @param request which triggered the event
-   * @param requestId unique id generated automatically for each request submission
-   * @param isPrefetch whether the request is a prefetch or not
-   */
-  void onRequestSuccess(ImageRequest request, String requestId, boolean isPrefetch);
+    /**
+     * Called after successful completion of the request (all producers completed successfully).
+     *
+     * @param request    which triggered the event
+     * @param requestId  unique id generated automatically for each request submission
+     * @param isPrefetch whether the request is a prefetch or not
+     */
+    void onRequestSuccess(ImageRequest request, String requestId, boolean isPrefetch);
 
-  /**
-   * Called after failure to complete the request (some producer failed).
-   * @param request which triggered the event
-   * @param requestId unique id generated automatically for each request submission
-   * @param throwable cause of failure
-   * @param isPrefetch whether the request is a prefetch or not
-   */
-  void onRequestFailure(
-      ImageRequest request,
-      String requestId,
-      Throwable throwable,
-      boolean isPrefetch);
+    /**
+     * Called after failure to complete the request (some producer failed).
+     *
+     * @param request    which triggered the event
+     * @param requestId  unique id generated automatically for each request submission
+     * @param throwable  cause of failure
+     * @param isPrefetch whether the request is a prefetch or not
+     */
+    void onRequestFailure(
+            ImageRequest request,
+            String requestId,
+            Throwable throwable,
+            boolean isPrefetch);
 
-  /**
-   * Called after the request is cancelled.
-   * @param requestId unique id generated automatically for each request submission
-   */
-  void onRequestCancellation(String requestId);
+    /**
+     * Called after the request is cancelled.
+     *
+     * @param requestId unique id generated automatically for each request submission
+     */
+    void onRequestCancellation(String requestId);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BasePool.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BasePool.java
index b63920dc0..830fde7f0 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BasePool.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BasePool.java
@@ -39,9 +39,9 @@
  * <p>
  * The pool supports two main operations:
  * <ul>
- *   <li> {@link #get(int)} - returns a value of size that's the same or larger than specified, hopefully
- *   from the pool; otherwise, this value is allocated (via the alloc function)</li>
- *   <li> {@link #release(V)} - releases a value to the pool</li>
+ * <li> {@link #get(int)} - returns a value of size that's the same or larger than specified, hopefully
+ * from the pool; otherwise, this value is allocated (via the alloc function)</li>
+ * <li> {@link #release(V)} - releases a value to the pool</li>
  * </ul>
  * In addition, the pool subscribes to the {@link MemoryTrimmableRegistry}, and responds to
  * low-memory events (calls to trim). Some percent (perhaps all) of the values in the pool are then
@@ -51,31 +51,31 @@
  * There are 3 different notions of sizes we consider here (not all of them may be relevant for
  * each use case).
  * <ul>
- *   <li>Logical size is simply the size of the value in terms appropriate for the value. For
- *   example, for byte arrays, the size is simply the length. For a bitmap, the size is just the
- *   number of pixels.</li>
- *   <li>Bucketed size typically represents one of discrete set of logical sizes - such that each
- *   bucketed size can accommodate a range of logical sizes. For example, for byte arrays, using
- *   sizes that are powers of 2 for bucketed sizes allows these byte arrays to support a number
- *   of logical sizes.</li>
- *   <li>Finally, Size-in-bytes is exactly that - the size of the value in bytes.</li>
+ * <li>Logical size is simply the size of the value in terms appropriate for the value. For
+ * example, for byte arrays, the size is simply the length. For a bitmap, the size is just the
+ * number of pixels.</li>
+ * <li>Bucketed size typically represents one of discrete set of logical sizes - such that each
+ * bucketed size can accommodate a range of logical sizes. For example, for byte arrays, using
+ * sizes that are powers of 2 for bucketed sizes allows these byte arrays to support a number
+ * of logical sizes.</li>
+ * <li>Finally, Size-in-bytes is exactly that - the size of the value in bytes.</li>
  * </ul>
  * Logical Size and BucketedSize are both represented by the type parameter S, while size-in-bytes
  * is represented by an int.
  * <p>
  * Each concrete subclass of the pool must implement the following methods
  * <ul>
- *   <li>{@link #getBucketedSize(int)} - returns the bucketized size for the given request size</li>
- *   <li>{@link #getBucketedSizeForValue(Object)} - returns the bucketized size for a given
- *   value</li>
- *   <li>{@link #getSizeInBytes(int)} - gets the size in bytes for a given bucketized size</li>
- *   <li>{@link #alloc(int)} - allocates a value of given size</li>
- *   <li>{@link #free(Object)} - frees the value V</li>
+ * <li>{@link #getBucketedSize(int)} - returns the bucketized size for the given request size</li>
+ * <li>{@link #getBucketedSizeForValue(Object)} - returns the bucketized size for a given
+ * value</li>
+ * <li>{@link #getSizeInBytes(int)} - gets the size in bytes for a given bucketized size</li>
+ * <li>{@link #alloc(int)} - allocates a value of given size</li>
+ * <li>{@link #free(Object)} - frees the value V</li>
  * Subclasses may optionally implement
- *   <li>{@link #onParamsChanged()} - called whenever this class determines to re-read the pool
- *   params</li>
- *   <li>{@link #isReusable(Object)} - used to determine if a value can be reused or must be
- *   freed</li>
+ * <li>{@link #onParamsChanged()} - called whenever this class determines to re-read the pool
+ * params</li>
+ * <li>{@link #isReusable(Object)} - used to determine if a value can be reused or must be
+ * freed</li>
  * </ul>
  * <p>
  * InUse values
@@ -88,779 +88,796 @@
  * Pools are "configured" with a set of parameters (the PoolParams) supplied via a provider.
  * This set of parameters includes
  * <ul>
- *   <li> {@link PoolParams#maxSizeSoftCap}
- *   The size of a pool includes its used and free space. The maxSize setting
- *   for a pool is a soft cap on the overall size of the pool. A key point is that {@link #get(int)}
- *   requests will not fail because the max size has been exceeded (unless the underlying
- *   {@link #alloc(int)} function fails). However, the pool's free portion will be trimmed
- *   as much as possible so that the pool's size may fall below the max size. Note that when the
- *   free portion has fallen to zero, the pool may still be larger than its maxSizeSoftCap.
- *   On a {@link #release(Object)} request, the value will be 'freed' instead of being added to
- *   the free portion of the pool, if the pool exceeds its maxSizeSoftCap.
- *   The invariant we want to maintain - see {@link #ensurePoolSizeInvariant()} - is that the pool
- *   must be below the max size soft cap OR the free lists must be empty. </li>
- *   <li> {@link PoolParams#maxSizeHardCap}
- *   The hard cap is a stronger limit on the pool size. When this limit is reached, we first
- *   attempt to trim the pool. If the pool size is still over the hard, the
- *   {@link #get(int)} call will fail with a {@link PoolSizeViolationException} </li>
- *   <li> {@link PoolParams#bucketSizes}
- *   The pool can be configured with a set of 'sizes' - a bucket is created for each such size.
- *   Additionally, each bucket can have a a max-length specified, which is the sum of the used and
- *   free items in that bucket. As with the MaxSize parameter above, the maxLength here is a soft
- *   cap, in that it will not cause an exception on get; it simply controls the release path.
- *   If the BucketSizes parameter is null, then the pool will dynamically create buckets on demand.
- *   </li>
+ * <li> {@link PoolParams#maxSizeSoftCap}
+ * The size of a pool includes its used and free space. The maxSize setting
+ * for a pool is a soft cap on the overall size of the pool. A key point is that {@link #get(int)}
+ * requests will not fail because the max size has been exceeded (unless the underlying
+ * {@link #alloc(int)} function fails). However, the pool's free portion will be trimmed
+ * as much as possible so that the pool's size may fall below the max size. Note that when the
+ * free portion has fallen to zero, the pool may still be larger than its maxSizeSoftCap.
+ * On a {@link #release(Object)} request, the value will be 'freed' instead of being added to
+ * the free portion of the pool, if the pool exceeds its maxSizeSoftCap.
+ * The invariant we want to maintain - see {@link #ensurePoolSizeInvariant()} - is that the pool
+ * must be below the max size soft cap OR the free lists must be empty. </li>
+ * <li> {@link PoolParams#maxSizeHardCap}
+ * The hard cap is a stronger limit on the pool size. When this limit is reached, we first
+ * attempt to trim the pool. If the pool size is still over the hard, the
+ * {@link #get(int)} call will fail with a {@link PoolSizeViolationException} </li>
+ * <li> {@link PoolParams#bucketSizes}
+ * The pool can be configured with a set of 'sizes' - a bucket is created for each such size.
+ * Additionally, each bucket can have a a max-length specified, which is the sum of the used and
+ * free items in that bucket. As with the MaxSize parameter above, the maxLength here is a soft
+ * cap, in that it will not cause an exception on get; it simply controls the release path.
+ * If the BucketSizes parameter is null, then the pool will dynamically create buckets on demand.
+ * </li>
  * </ul>
  */
 public abstract class BasePool<V> implements Pool<V> {
-  private final Class<?> TAG = this.getClass();
-
-  /**
-   * The memory manager to register with
-   */
-  final MemoryTrimmableRegistry mMemoryTrimmableRegistry;
-
-  /**
-   * Provider for pool parameters
-   */
-  final PoolParams mPoolParams;
-
-  /**
-   * The buckets - representing different 'sizes'
-   */
-  @VisibleForTesting
-  final SparseArray<Bucket<V>> mBuckets;
-
-  /**
-   * An Identity hash-set to keep track of values by reference equality
-   */
-  @VisibleForTesting
-  final Set<V> mInUseValues;
-
-  /**
-   * Determines if new buckets can be created
-   */
-  private boolean mAllowNewBuckets;
-
-  /**
-   * tracks 'used space' - space allocated via the pool
-   */
-  @VisibleForTesting
-  @GuardedBy("this")
-  final Counter mUsed;
-
-  /**
-   * tracks 'free space' in the pool
-   */
-  @VisibleForTesting
-  @GuardedBy("this")
-  final Counter mFree;
-
-  /**
-   * tracks memory "reserved" for allocation. It is expected that this is done
-   * after a call to canAllocate() and will be decremented immediately after a
-   * call to alloc either on a success or failure.
-   */
-  @GuardedBy("this")
-  private int mReservedBytes;
-
-  private final PoolStatsTracker mPoolStatsTracker;
-
-  /**
-   * Creates a new instance of the pool.
-   * @param poolParams pool parameters
-   * @param poolStatsTracker
-   */
-  public BasePool(
-      MemoryTrimmableRegistry memoryTrimmableRegistry,
-      PoolParams poolParams,
-      PoolStatsTracker poolStatsTracker) {
-    mMemoryTrimmableRegistry = Preconditions.checkNotNull(memoryTrimmableRegistry);
-    mPoolParams = Preconditions.checkNotNull(poolParams);
-    mPoolStatsTracker = Preconditions.checkNotNull(poolStatsTracker);
-
-    // initialize the buckets
-    mBuckets = new SparseArray<Bucket<V>>();
-    initBuckets(new SparseIntArray(0));
-
-    mInUseValues = Sets.newIdentityHashSet();
-
-    mFree = new Counter();
-    mUsed = new Counter();
-  }
-
-  /**
-   * Finish pool initialization.
-   */
-  protected void initialize() {
-    mMemoryTrimmableRegistry.registerMemoryTrimmable(this);
-    mPoolStatsTracker.setBasePool(this);
-  }
-
-  /**
-   * Gets a new 'value' from the pool, if available. Allocates a new value if necessary.
-   * If we need to perform an allocation,
-   *   - If the pool size exceeds the max-size soft cap, then we attempt to trim the free portion
-   *     of the pool.
-   *   - If the pool size exceeds the max-size hard-cap (after trimming), then we throw an
-   *     {@link PoolSizeViolationException}
-   * Bucket length constraints are not considered in this function
-   * @param size the logical size to allocate
-   * @return a new value
-   * @throws InvalidSizeException
-   */
-  public V get(int size) {
-    ensurePoolSizeInvariant();
-
-    int bucketedSize = getBucketedSize(size);
-    Bucket<V> bucket = getBucket(bucketedSize);
-    int sizeInBytes = -1;
-
-    synchronized (this) {
-      if (bucket != null) {
-        // find an existing value that we can reuse
-        V value = bucket.get();
-        if (value != null) {
-          Preconditions.checkState(mInUseValues.add(value));
-
-          // It is possible that we got a 'larger' value than we asked for.
-          // lets recompute size in bytes here
-          bucketedSize = getBucketedSizeForValue(value);
-          sizeInBytes = getSizeInBytes(bucketedSize);
-          mUsed.increment(sizeInBytes);
-          mFree.decrement(sizeInBytes);
-          mPoolStatsTracker.onValueReuse(sizeInBytes);
-          logStats();
-          if (FLog.isLoggable(FLog.VERBOSE)) {
-            FLog.v(
-                TAG,
-                "get (reuse) (object, size) = (%x, %s)",
-                System.identityHashCode(value),
-                bucketedSize);
-          }
-          return value;
-        }
-        // fall through
-      }
-      // check to see if we can allocate a value of the given size without exceeding the hard cap
-      sizeInBytes = getSizeInBytes(bucketedSize);
-      if (!canAllocate(sizeInBytes)) {
-        throw new PoolSizeViolationException(
-            mPoolParams.maxSizeHardCap,
-            mUsed.mNumBytes,
-            mFree.mNumBytes,
-            sizeInBytes);
-      }
-      // the allocation can succeed. So reserve the bytes to prevent another
-      // call to get() to not succeed by mistake.
-      mReservedBytes += sizeInBytes;
-    }
+    private final Class<?> TAG = this.getClass();
+
+    /**
+     * The memory manager to register with
+     */
+    final MemoryTrimmableRegistry mMemoryTrimmableRegistry;
+
+    /**
+     * Provider for pool parameters
+     */
+    final PoolParams mPoolParams;
+
+    /**
+     * The buckets - representing different 'sizes'
+     */
+    @VisibleForTesting
+    final SparseArray<Bucket<V>> mBuckets;
+
+    /**
+     * An Identity hash-set to keep track of values by reference equality
+     */
+    @VisibleForTesting
+    final Set<V> mInUseValues;
+
+    /**
+     * Determines if new buckets can be created
+     */
+    private boolean mAllowNewBuckets;
+
+    /**
+     * tracks 'used space' - space allocated via the pool
+     */
+    @VisibleForTesting
+    @GuardedBy("this")
+    final Counter mUsed;
+
+    /**
+     * tracks 'free space' in the pool
+     */
+    @VisibleForTesting
+    @GuardedBy("this")
+    final Counter mFree;
 
-    V value = null;
-    try {
-      // allocate the value outside the synchronized block, because it can be pretty expensive
-      // we could have done the allocation inside the synchronized block,
-      // but that would have blocked out other operations on the pool
-      value = alloc(bucketedSize);
-
-    } catch (Throwable e) {
-      // Remove this from reserved byte count if this alloc failed,
-      // without altering the code flow
-      synchronized (this) {
-        Preconditions.checkArgument(mReservedBytes >= sizeInBytes);
-        mReservedBytes -= sizeInBytes;
-      }
-      Throwables.propagateIfPossible(e);
+    /**
+     * tracks memory "reserved" for allocation. It is expected that this is done
+     * after a call to canAllocate() and will be decremented immediately after a
+     * call to alloc either on a success or failure.
+     */
+    @GuardedBy("this")
+    private int mReservedBytes;
+
+    private final PoolStatsTracker mPoolStatsTracker;
+
+    /**
+     * Creates a new instance of the pool.
+     *
+     * @param poolParams       pool parameters
+     * @param poolStatsTracker
+     */
+    public BasePool(
+            MemoryTrimmableRegistry memoryTrimmableRegistry,
+            PoolParams poolParams,
+            PoolStatsTracker poolStatsTracker) {
+        mMemoryTrimmableRegistry = Preconditions.checkNotNull(memoryTrimmableRegistry);
+        mPoolParams = Preconditions.checkNotNull(poolParams);
+        mPoolStatsTracker = Preconditions.checkNotNull(poolStatsTracker);
+
+        // initialize the buckets
+        mBuckets = new SparseArray<Bucket<V>>();
+        initBuckets(new SparseIntArray(0));
+
+        mInUseValues = Sets.newIdentityHashSet();
+
+        mFree = new Counter();
+        mUsed = new Counter();
     }
 
-    // NOTE: We checked for hard caps earlier, and then did the alloc above. Now we need to
-    // update state - but it is possible that a concurrent thread did a similar operation - with
-    // the result being that we're now over the hard cap.
-    // We are willing to live with that situation - especially since the trim call below should
-    // be able to trim back memory usage.
-    synchronized(this) {
-      Preconditions.checkState(mInUseValues.add(value));
-      Preconditions.checkArgument(mReservedBytes >= sizeInBytes);
-      mUsed.increment(sizeInBytes);
-      mReservedBytes -= sizeInBytes;
-
-      if (bucket != null) {
-        bucket.incrementInUseCount();
-      }
-      // If we're over the pool's max size, try to trim the pool appropriately
-      trimToSoftCap();
-      mPoolStatsTracker.onAlloc(sizeInBytes);
-      logStats();
-      if (FLog.isLoggable(FLog.VERBOSE)) {
-        FLog.v(
-            TAG,
-            "get (alloc) (object, size) = (%x, %s)",
-            System.identityHashCode(value),
-            bucketedSize);
-      }
+    /**
+     * Finish pool initialization.
+     */
+    protected void initialize() {
+        mMemoryTrimmableRegistry.registerMemoryTrimmable(this);
+        mPoolStatsTracker.setBasePool(this);
     }
 
-    return value;
-  }
-
-  /**
-   * Releases the given value to the pool.
-   * In a few cases, the value is 'freed' instead of being released to the pool. If
-   *   - the pool currently exceeds its max size OR
-   *   - if the value does not map to a bucket that's currently maintained by the pool, OR
-   *   - if the bucket for the value exceeds its maxLength, OR
-   *   - if the value is not recognized by the pool
-   *  then, the value is 'freed'.
-   * @param value the value to release to the pool
-   */
-  @Override
-  public void release(V value) {
-    Preconditions.checkNotNull(value);
-
-    final int bucketedSize = getBucketedSizeForValue(value);
-    final int sizeInBytes = getSizeInBytes(bucketedSize);
-    final Bucket<V> bucket = getBucket(bucketedSize);
-    synchronized (this) {
-      if (!mInUseValues.remove(value)) {
-        // This value was not 'known' to the pool (i.e.) allocated via the pool.
-        // Something is going wrong, so let's free the value and report soft error.
-        FLog.e(
-            TAG,
-            "release (free, value unrecognized) (object, size) = (%x, %s)",
-            System.identityHashCode(value),
-            bucketedSize);
-        free(value);
-        mPoolStatsTracker.onFree(sizeInBytes);
-      } else {
-        // free the value, if
-        //  - pool exceeds maxSize
-        //  - there is no bucket for this value
-        //  - there is a bucket for this value, but it has exceeded its maxLength
-        //  - the value is not reusable
-        // If no bucket was found for the value, simply free it
-        // We should free the value if no bucket is found, or if the bucket length cap is exceeded.
-        // However, if the pool max size softcap is exceeded, it may not always be best to free
-        // *this* value.
-        if (bucket == null ||
-            bucket.isMaxLengthExceeded() ||
-            isMaxSizeSoftCapExceeded() ||
-            !isReusable(value)) {
-          if (bucket != null) {
-            bucket.decrementInUseCount();
-          }
-
-          if (FLog.isLoggable(FLog.VERBOSE)) {
-            FLog.v(
-                TAG,
-                "release (free) (object, size) = (%x, %s)",
-                System.identityHashCode(value),
-                bucketedSize);
-          }
-          free(value);
-          mUsed.decrement(sizeInBytes);
-          mPoolStatsTracker.onFree(sizeInBytes);
-        } else {
-          bucket.release(value);
-          mFree.increment(sizeInBytes);
-          mUsed.decrement(sizeInBytes);
-          mPoolStatsTracker.onValueRelease(sizeInBytes);
-          if (FLog.isLoggable(FLog.VERBOSE)) {
-            FLog.v(
-                TAG,
-                "release (reuse) (object, size) = (%x, %s)",
-                System.identityHashCode(value),
-                bucketedSize);
-          }
+    /**
+     * Gets a new 'value' from the pool, if available. Allocates a new value if necessary.
+     * If we need to perform an allocation,
+     * - If the pool size exceeds the max-size soft cap, then we attempt to trim the free portion
+     * of the pool.
+     * - If the pool size exceeds the max-size hard-cap (after trimming), then we throw an
+     * {@link PoolSizeViolationException}
+     * Bucket length constraints are not considered in this function
+     *
+     * @param size the logical size to allocate
+     * @return a new value
+     * @throws InvalidSizeException
+     */
+    public V get(int size) {
+        ensurePoolSizeInvariant();
+
+        int bucketedSize = getBucketedSize(size);
+        Bucket<V> bucket = getBucket(bucketedSize);
+        int sizeInBytes = -1;
+
+        synchronized (this) {
+            if (bucket != null) {
+                // find an existing value that we can reuse
+                V value = bucket.get();
+                if (value != null) {
+                    Preconditions.checkState(mInUseValues.add(value));
+
+                    // It is possible that we got a 'larger' value than we asked for.
+                    // lets recompute size in bytes here
+                    bucketedSize = getBucketedSizeForValue(value);
+                    sizeInBytes = getSizeInBytes(bucketedSize);
+                    mUsed.increment(sizeInBytes);
+                    mFree.decrement(sizeInBytes);
+                    mPoolStatsTracker.onValueReuse(sizeInBytes);
+                    logStats();
+                    if (FLog.isLoggable(FLog.VERBOSE)) {
+                        FLog.v(
+                                TAG,
+                                "get (reuse) (object, size) = (%x, %s)",
+                                System.identityHashCode(value),
+                                bucketedSize);
+                    }
+                    return value;
+                }
+                // fall through
+            }
+            // check to see if we can allocate a value of the given size without exceeding the hard cap
+            sizeInBytes = getSizeInBytes(bucketedSize);
+            if (!canAllocate(sizeInBytes)) {
+                throw new PoolSizeViolationException(
+                        mPoolParams.maxSizeHardCap,
+                        mUsed.mNumBytes,
+                        mFree.mNumBytes,
+                        sizeInBytes);
+            }
+            // the allocation can succeed. So reserve the bytes to prevent another
+            // call to get() to not succeed by mistake.
+            mReservedBytes += sizeInBytes;
         }
-      }
-      logStats();
-    }
-  }
-
-  /**
-   * 'Take over' the specified value, and keep track of it in the in-use-values.
-   *  Callers can use the {@link #takeOver(Object)} method to transfer ownership of a value to
-   *  the pool - once the value has been taken over, it is now known to the pool, it is reflected
-   *  in the pool's usage stats, and {@link #release(Object)} can then reuse/free it.
-   *  {@link #takeOver(Object)} is intended to be called by the producer of the value, and gives us
-   *  explicit signal about the ownership - while the {@link #release(Object)} may be called by
-   *  any consumer of the value.
-   *  If the value cannot be successfully taken over by the pool, this function returns false.
-   *  Currently the only case is when taking over the value will cause the pool to exceed its
-   *  max cap.
-   * @param value the value to take over
-   * @return true, if the value was successfully taken over
-   */
-  public boolean takeOver(V value) {
-    Preconditions.checkNotNull(value);
-    ensurePoolSizeInvariant();
-
-    final int bucketedSize = getBucketedSizeForValue(value);
-    final int sizeInBytes = getSizeInBytes(bucketedSize);
-    final Bucket<V> bucket = getBucket(bucketedSize);
-
-    synchronized (this) {
-      // if adding this value to the pool would cause the hard cap to be exceeded, then
-      // return false right away
-      if (!canAllocate(sizeInBytes)) {
-        return false;
-      }
-
-      if (mInUseValues.add(value)) {
-        mUsed.increment(sizeInBytes);
-        if (bucket != null) {
-          bucket.incrementInUseCount();
+
+        V value = null;
+        try {
+            // allocate the value outside the synchronized block, because it can be pretty expensive
+            // we could have done the allocation inside the synchronized block,
+            // but that would have blocked out other operations on the pool
+            value = alloc(bucketedSize);
+
+        } catch (Throwable e) {
+            // Remove this from reserved byte count if this alloc failed,
+            // without altering the code flow
+            synchronized (this) {
+                Preconditions.checkArgument(mReservedBytes >= sizeInBytes);
+                mReservedBytes -= sizeInBytes;
+            }
+            Throwables.propagateIfPossible(e);
         }
-        trimToSoftCap();
-        if (FLog.isLoggable(FLog.VERBOSE)) {
-          FLog.v(
-              TAG,
-              "takeover (object, size) = (%x, %s)",
-              System.identityHashCode(value),
-              bucketedSize);
+
+        // NOTE: We checked for hard caps earlier, and then did the alloc above. Now we need to
+        // update state - but it is possible that a concurrent thread did a similar operation - with
+        // the result being that we're now over the hard cap.
+        // We are willing to live with that situation - especially since the trim call below should
+        // be able to trim back memory usage.
+        synchronized (this) {
+            Preconditions.checkState(mInUseValues.add(value));
+            Preconditions.checkArgument(mReservedBytes >= sizeInBytes);
+            mUsed.increment(sizeInBytes);
+            mReservedBytes -= sizeInBytes;
+
+            if (bucket != null) {
+                bucket.incrementInUseCount();
+            }
+            // If we're over the pool's max size, try to trim the pool appropriately
+            trimToSoftCap();
+            mPoolStatsTracker.onAlloc(sizeInBytes);
+            logStats();
+            if (FLog.isLoggable(FLog.VERBOSE)) {
+                FLog.v(
+                        TAG,
+                        "get (alloc) (object, size) = (%x, %s)",
+                        System.identityHashCode(value),
+                        bucketedSize);
+            }
         }
-      } else {
-        FLog.w(
-            TAG,
-            "takeover (ignore) (object, size) = (%x, %s)",
-            System.identityHashCode(value),
-            bucketedSize);
-      }
-      logStats();
-    }
-    return true;
-  }
-
-  /**
-   * Trims the pool in response to low-memory states (invoked from MemoryManager)
-   * For now, we'll do the simplest thing, and simply clear out the entire pool. We may consider
-   * more sophisticated approaches later.
-   * In other words, we ignore the memoryTrimType parameter
-   * @param memoryTrimType the kind of trimming we want to perform
-   */
-  public void trim(MemoryTrimType memoryTrimType) {
-    trimToNothing();
-  }
-
-  /**
-   * Allocates a new 'value' with the given size
-   * @param bucketedSize the logical size to allocate
-   * @return a new value
-   */
-  protected abstract V alloc(int bucketedSize);
-
-  /**
-   * Frees the 'value'
-   * @param value the value to free
-   */
-  @VisibleForTesting
-  protected abstract void free(V value);
-
-  /**
-   * Gets the bucketed size (typically something the same or larger than the requested size)
-   * @param requestSize the logical request size
-   * @return the 'bucketed' size
-   * @throws InvalidSizeException, if the size of the value doesn't match the pool's constraints
-   */
-  protected abstract int getBucketedSize(int requestSize);
-
-  /**
-   * Gets the bucketed size of the value
-   * @param value the value
-   * @return bucketed size of the value
-   * @throws InvalidSizeException, if the size of the value doesn't match the pool's constraints
-   * @throws InvalidValueException, if the value is invalid
-   */
-  protected abstract int getBucketedSizeForValue(V value);
-
-  /**
-   * Gets the size in bytes for the given bucketed size
-   * @param bucketedSize the bucketed size
-   * @return size in bytes
-   */
-  protected abstract int getSizeInBytes(int bucketedSize);
-
-  /**
-   * The pool parameters may have changed. Subclasses can override this to update any state they
-   * were maintaining
-   */
-  protected void onParamsChanged() {
-  }
-
-  /**
-   * Determines if the supplied value is 'reusable'.
-   * This is called during {@link #release(Object)}, and determines if the value can be added
-   * to the freelists of the pool (for future reuse), or must be released right away.
-   * Subclasses can override this to provide custom implementations
-   * @param value the value to test for reusability
-   * @return true if the value is reusable
-   */
-  protected boolean isReusable(V value) {
-    Preconditions.checkNotNull(value);
-    return true;
-  }
-
-  /**
-   * Ensure pool size invariants.
-   * The pool must either be below the soft-cap OR it must have no free values left
-   */
-  private synchronized void ensurePoolSizeInvariant() {
-    Preconditions.checkState(!isMaxSizeSoftCapExceeded() || mFree.mNumBytes == 0);
-  }
-
-  /**
-   * Initialize the list of buckets. Get the bucket sizes (and bucket lengths) from the bucket
-   * sizes provider
-   * @param inUseCounts map of current buckets and their in use counts
-   */
-  private synchronized void initBuckets(SparseIntArray inUseCounts) {
-    Preconditions.checkNotNull(inUseCounts);
-
-    // clear out all the buckets
-    mBuckets.clear();
-
-    // create the new buckets
-    final SparseIntArray bucketSizes = mPoolParams.bucketSizes;
-    if (bucketSizes != null) {
-      for (int i = 0; i < bucketSizes.size(); ++i) {
-        final int bucketSize = bucketSizes.keyAt(i);
-        final int maxLength = bucketSizes.valueAt(i);
-        int bucketInUseCount = inUseCounts.get(bucketSize, 0);
-        mBuckets.put(
-            bucketSize,
-            new Bucket<V>(
-                getSizeInBytes(bucketSize),
-                maxLength,
-                bucketInUseCount));
-      }
-      mAllowNewBuckets = false;
-    } else {
-      mAllowNewBuckets = true;
+
+        return value;
     }
-  }
-
-  /**
-   * Gets rid of all free values in the pool
-   * At the end of this method, mFreeSpace will be zero (reflecting that there are no more free
-   * values in the pool). mUsedSpace will however not be reset, since that's a reflection of the
-   * values that were allocated via the pool, but are in use elsewhere
-   */
-  @VisibleForTesting
-  void trimToNothing() {
-    final List<Queue<V>> freeListList = new ArrayList<Queue<V>>(mBuckets.size());
-    final SparseIntArray inUseCounts = new SparseIntArray();
-
-    synchronized (this) {
-      for (int i = 0; i < mBuckets.size(); ++i) {
-        final Bucket<V> bucket = mBuckets.valueAt(i);
-        if (!bucket.mFreeList.isEmpty()) {
-          freeListList.add(bucket.mFreeList);
-        }
-        inUseCounts.put(mBuckets.keyAt(i), bucket.mInUseLength);
-      }
 
-      // reinitialize the buckets
-      initBuckets(inUseCounts);
+    /**
+     * Releases the given value to the pool.
+     * In a few cases, the value is 'freed' instead of being released to the pool. If
+     * - the pool currently exceeds its max size OR
+     * - if the value does not map to a bucket that's currently maintained by the pool, OR
+     * - if the bucket for the value exceeds its maxLength, OR
+     * - if the value is not recognized by the pool
+     * then, the value is 'freed'.
+     *
+     * @param value the value to release to the pool
+     */
+    @Override
+    public void release(V value) {
+        Preconditions.checkNotNull(value);
+
+        final int bucketedSize = getBucketedSizeForValue(value);
+        final int sizeInBytes = getSizeInBytes(bucketedSize);
+        final Bucket<V> bucket = getBucket(bucketedSize);
+        synchronized (this) {
+            if (!mInUseValues.remove(value)) {
+                // This value was not 'known' to the pool (i.e.) allocated via the pool.
+                // Something is going wrong, so let's free the value and report soft error.
+                FLog.e(
+                        TAG,
+                        "release (free, value unrecognized) (object, size) = (%x, %s)",
+                        System.identityHashCode(value),
+                        bucketedSize);
+                free(value);
+                mPoolStatsTracker.onFree(sizeInBytes);
+            } else {
+                // free the value, if
+                //  - pool exceeds maxSize
+                //  - there is no bucket for this value
+                //  - there is a bucket for this value, but it has exceeded its maxLength
+                //  - the value is not reusable
+                // If no bucket was found for the value, simply free it
+                // We should free the value if no bucket is found, or if the bucket length cap is exceeded.
+                // However, if the pool max size softcap is exceeded, it may not always be best to free
+                // *this* value.
+                if (bucket == null ||
+                        bucket.isMaxLengthExceeded() ||
+                        isMaxSizeSoftCapExceeded() ||
+                        !isReusable(value)) {
+                    if (bucket != null) {
+                        bucket.decrementInUseCount();
+                    }
+
+                    if (FLog.isLoggable(FLog.VERBOSE)) {
+                        FLog.v(
+                                TAG,
+                                "release (free) (object, size) = (%x, %s)",
+                                System.identityHashCode(value),
+                                bucketedSize);
+                    }
+                    free(value);
+                    mUsed.decrement(sizeInBytes);
+                    mPoolStatsTracker.onFree(sizeInBytes);
+                } else {
+                    bucket.release(value);
+                    mFree.increment(sizeInBytes);
+                    mUsed.decrement(sizeInBytes);
+                    mPoolStatsTracker.onValueRelease(sizeInBytes);
+                    if (FLog.isLoggable(FLog.VERBOSE)) {
+                        FLog.v(
+                                TAG,
+                                "release (reuse) (object, size) = (%x, %s)",
+                                System.identityHashCode(value),
+                                bucketedSize);
+                    }
+                }
+            }
+            logStats();
+        }
+    }
 
-      // free up the stats
-      mFree.reset();
-      logStats();
+    /**
+     * 'Take over' the specified value, and keep track of it in the in-use-values.
+     * Callers can use the {@link #takeOver(Object)} method to transfer ownership of a value to
+     * the pool - once the value has been taken over, it is now known to the pool, it is reflected
+     * in the pool's usage stats, and {@link #release(Object)} can then reuse/free it.
+     * {@link #takeOver(Object)} is intended to be called by the producer of the value, and gives us
+     * explicit signal about the ownership - while the {@link #release(Object)} may be called by
+     * any consumer of the value.
+     * If the value cannot be successfully taken over by the pool, this function returns false.
+     * Currently the only case is when taking over the value will cause the pool to exceed its
+     * max cap.
+     *
+     * @param value the value to take over
+     * @return true, if the value was successfully taken over
+     */
+    public boolean takeOver(V value) {
+        Preconditions.checkNotNull(value);
+        ensurePoolSizeInvariant();
+
+        final int bucketedSize = getBucketedSizeForValue(value);
+        final int sizeInBytes = getSizeInBytes(bucketedSize);
+        final Bucket<V> bucket = getBucket(bucketedSize);
+
+        synchronized (this) {
+            // if adding this value to the pool would cause the hard cap to be exceeded, then
+            // return false right away
+            if (!canAllocate(sizeInBytes)) {
+                return false;
+            }
+
+            if (mInUseValues.add(value)) {
+                mUsed.increment(sizeInBytes);
+                if (bucket != null) {
+                    bucket.incrementInUseCount();
+                }
+                trimToSoftCap();
+                if (FLog.isLoggable(FLog.VERBOSE)) {
+                    FLog.v(
+                            TAG,
+                            "takeover (object, size) = (%x, %s)",
+                            System.identityHashCode(value),
+                            bucketedSize);
+                }
+            } else {
+                FLog.w(
+                        TAG,
+                        "takeover (ignore) (object, size) = (%x, %s)",
+                        System.identityHashCode(value),
+                        bucketedSize);
+            }
+            logStats();
+        }
+        return true;
     }
 
-    // the pool parameters 'may' have changed.
-    onParamsChanged();
-
-    // Explicitly free all the values.
-    // All the core data structures have now been reset. We no longer need to block other calls.
-    // This is true even for a concurrent trim() call
-    for (int i = 0; i < freeListList.size(); ++i) {
-      final Queue<V> freeList = freeListList.get(i);
-      while (!freeList.isEmpty()) {
-        // what happens if we run into an exception during the recycle. I'm going to ignore
-        // these exceptions for now, and let the GC handle the rest of the to-be-recycled-bitmaps
-        // in its usual fashion
-        free(freeList.poll());
-      }
+    /**
+     * Trims the pool in response to low-memory states (invoked from MemoryManager)
+     * For now, we'll do the simplest thing, and simply clear out the entire pool. We may consider
+     * more sophisticated approaches later.
+     * In other words, we ignore the memoryTrimType parameter
+     *
+     * @param memoryTrimType the kind of trimming we want to perform
+     */
+    public void trim(MemoryTrimType memoryTrimType) {
+        trimToNothing();
     }
-  }
-
-  /**
-   * Trim the (free portion of the) pool so that the pool size is at or below the soft cap.
-   * This will try to free up values in the free portion of the pool, until
-   *   (a) the pool size is now below the soft cap configured OR
-   *   (b) the free portion of the pool is empty
-   */
-  @VisibleForTesting
-  synchronized void trimToSoftCap() {
-    if (isMaxSizeSoftCapExceeded()) {
-      trimToSize(mPoolParams.maxSizeSoftCap);
+
+    /**
+     * Allocates a new 'value' with the given size
+     *
+     * @param bucketedSize the logical size to allocate
+     * @return a new value
+     */
+    protected abstract V alloc(int bucketedSize);
+
+    /**
+     * Frees the 'value'
+     *
+     * @param value the value to free
+     */
+    @VisibleForTesting
+    protected abstract void free(V value);
+
+    /**
+     * Gets the bucketed size (typically something the same or larger than the requested size)
+     *
+     * @param requestSize the logical request size
+     * @return the 'bucketed' size
+     * @throws InvalidSizeException, if the size of the value doesn't match the pool's constraints
+     */
+    protected abstract int getBucketedSize(int requestSize);
+
+    /**
+     * Gets the bucketed size of the value
+     *
+     * @param value the value
+     * @return bucketed size of the value
+     * @throws InvalidSizeException,  if the size of the value doesn't match the pool's constraints
+     * @throws InvalidValueException, if the value is invalid
+     */
+    protected abstract int getBucketedSizeForValue(V value);
+
+    /**
+     * Gets the size in bytes for the given bucketed size
+     *
+     * @param bucketedSize the bucketed size
+     * @return size in bytes
+     */
+    protected abstract int getSizeInBytes(int bucketedSize);
+
+    /**
+     * The pool parameters may have changed. Subclasses can override this to update any state they
+     * were maintaining
+     */
+    protected void onParamsChanged() {
     }
-  }
-
-  /**
-   * (Try to) trim the pool until its total space falls below the max size (soft cap). This will
-   * get rid of values on the free list, until the free lists are empty, or we fall below the
-   * max size; whichever comes first.
-   * NOTE: It is NOT an error if we have eliminated all the free values, but the pool is still
-   * above its max size (soft cap)
-   * <p>
-   * The approach we take is to go from the smallest sized bucket down to the largest sized
-   * bucket. This may seem a bit counter-intuitive, but the rationale is that allocating
-   * larger-sized values is more expensive than the smaller-sized ones, so we want to keep them
-   * around for a while.
-   * @param targetSize target size to trim to
-   */
-  @VisibleForTesting
-  synchronized void trimToSize(int targetSize) {
-    // find how much we need to free
-    int bytesToFree = Math.min(mUsed.mNumBytes + mFree.mNumBytes - targetSize, mFree.mNumBytes);
-    if (bytesToFree <= 0) {
-      return;
+
+    /**
+     * Determines if the supplied value is 'reusable'.
+     * This is called during {@link #release(Object)}, and determines if the value can be added
+     * to the freelists of the pool (for future reuse), or must be released right away.
+     * Subclasses can override this to provide custom implementations
+     *
+     * @param value the value to test for reusability
+     * @return true if the value is reusable
+     */
+    protected boolean isReusable(V value) {
+        Preconditions.checkNotNull(value);
+        return true;
     }
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(
-          TAG,
-          "trimToSize: TargetSize = %d; Initial Size = %d; Bytes to free = %d",
-          targetSize,
-          mUsed.mNumBytes + mFree.mNumBytes,
-          bytesToFree);
+
+    /**
+     * Ensure pool size invariants.
+     * The pool must either be below the soft-cap OR it must have no free values left
+     */
+    private synchronized void ensurePoolSizeInvariant() {
+        Preconditions.checkState(!isMaxSizeSoftCapExceeded() || mFree.mNumBytes == 0);
     }
-    logStats();
-
-    // now walk through the buckets from the smallest to the largest. Keep freeing things
-    // until we've gotten to what we want
-    for (int i = 0; i < mBuckets.size(); ++i) {
-      if (bytesToFree <= 0) {
-        break;
-      }
-      Bucket<V> bucket = mBuckets.valueAt(i);
-      while (bytesToFree > 0) {
-        V value = bucket.pop();
-        if (value == null) {
-          break;
+
+    /**
+     * Initialize the list of buckets. Get the bucket sizes (and bucket lengths) from the bucket
+     * sizes provider
+     *
+     * @param inUseCounts map of current buckets and their in use counts
+     */
+    private synchronized void initBuckets(SparseIntArray inUseCounts) {
+        Preconditions.checkNotNull(inUseCounts);
+
+        // clear out all the buckets
+        mBuckets.clear();
+
+        // create the new buckets
+        final SparseIntArray bucketSizes = mPoolParams.bucketSizes;
+        if (bucketSizes != null) {
+            for (int i = 0; i < bucketSizes.size(); ++i) {
+                final int bucketSize = bucketSizes.keyAt(i);
+                final int maxLength = bucketSizes.valueAt(i);
+                int bucketInUseCount = inUseCounts.get(bucketSize, 0);
+                mBuckets.put(
+                        bucketSize,
+                        new Bucket<V>(
+                                getSizeInBytes(bucketSize),
+                                maxLength,
+                                bucketInUseCount));
+            }
+            mAllowNewBuckets = false;
+        } else {
+            mAllowNewBuckets = true;
         }
-        free(value);
-        bytesToFree -= bucket.mItemSize;
-        mFree.decrement(bucket.mItemSize);
-      }
     }
 
-    // dump stats at the end
-    logStats();
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(
-          TAG,
-          "trimToSize: TargetSize = %d; Final Size = %d",
-          targetSize,
-          mUsed.mNumBytes + mFree.mNumBytes);
+    /**
+     * Gets rid of all free values in the pool
+     * At the end of this method, mFreeSpace will be zero (reflecting that there are no more free
+     * values in the pool). mUsedSpace will however not be reset, since that's a reflection of the
+     * values that were allocated via the pool, but are in use elsewhere
+     */
+    @VisibleForTesting
+    void trimToNothing() {
+        final List<Queue<V>> freeListList = new ArrayList<Queue<V>>(mBuckets.size());
+        final SparseIntArray inUseCounts = new SparseIntArray();
+
+        synchronized (this) {
+            for (int i = 0; i < mBuckets.size(); ++i) {
+                final Bucket<V> bucket = mBuckets.valueAt(i);
+                if (!bucket.mFreeList.isEmpty()) {
+                    freeListList.add(bucket.mFreeList);
+                }
+                inUseCounts.put(mBuckets.keyAt(i), bucket.mInUseLength);
+            }
+
+            // reinitialize the buckets
+            initBuckets(inUseCounts);
+
+            // free up the stats
+            mFree.reset();
+            logStats();
+        }
+
+        // the pool parameters 'may' have changed.
+        onParamsChanged();
+
+        // Explicitly free all the values.
+        // All the core data structures have now been reset. We no longer need to block other calls.
+        // This is true even for a concurrent trim() call
+        for (int i = 0; i < freeListList.size(); ++i) {
+            final Queue<V> freeList = freeListList.get(i);
+            while (!freeList.isEmpty()) {
+                // what happens if we run into an exception during the recycle. I'm going to ignore
+                // these exceptions for now, and let the GC handle the rest of the to-be-recycled-bitmaps
+                // in its usual fashion
+                free(freeList.poll());
+            }
+        }
     }
-  }
-
-
-  /**
-   * Gets the freelist for the specified bucket. Create the freelist if there isn't one
-   * @param bucketedSize the bucket size
-   * @return the freelist for the bucket
-   */
-  @VisibleForTesting
-  synchronized Bucket<V> getBucket(int bucketedSize) {
-    // get an existing bucket
-    Bucket<V> bucket = mBuckets.get(bucketedSize);
-    if (bucket != null || !mAllowNewBuckets) {
-      return bucket;
+
+    /**
+     * Trim the (free portion of the) pool so that the pool size is at or below the soft cap.
+     * This will try to free up values in the free portion of the pool, until
+     * (a) the pool size is now below the soft cap configured OR
+     * (b) the free portion of the pool is empty
+     */
+    @VisibleForTesting
+    synchronized void trimToSoftCap() {
+        if (isMaxSizeSoftCapExceeded()) {
+            trimToSize(mPoolParams.maxSizeSoftCap);
+        }
     }
 
-    // create a new bucket
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(TAG, "creating new bucket %s", bucketedSize);
+    /**
+     * (Try to) trim the pool until its total space falls below the max size (soft cap). This will
+     * get rid of values on the free list, until the free lists are empty, or we fall below the
+     * max size; whichever comes first.
+     * NOTE: It is NOT an error if we have eliminated all the free values, but the pool is still
+     * above its max size (soft cap)
+     * <p>
+     * The approach we take is to go from the smallest sized bucket down to the largest sized
+     * bucket. This may seem a bit counter-intuitive, but the rationale is that allocating
+     * larger-sized values is more expensive than the smaller-sized ones, so we want to keep them
+     * around for a while.
+     *
+     * @param targetSize target size to trim to
+     */
+    @VisibleForTesting
+    synchronized void trimToSize(int targetSize) {
+        // find how much we need to free
+        int bytesToFree = Math.min(mUsed.mNumBytes + mFree.mNumBytes - targetSize, mFree.mNumBytes);
+        if (bytesToFree <= 0) {
+            return;
+        }
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(
+                    TAG,
+                    "trimToSize: TargetSize = %d; Initial Size = %d; Bytes to free = %d",
+                    targetSize,
+                    mUsed.mNumBytes + mFree.mNumBytes,
+                    bytesToFree);
+        }
+        logStats();
+
+        // now walk through the buckets from the smallest to the largest. Keep freeing things
+        // until we've gotten to what we want
+        for (int i = 0; i < mBuckets.size(); ++i) {
+            if (bytesToFree <= 0) {
+                break;
+            }
+            Bucket<V> bucket = mBuckets.valueAt(i);
+            while (bytesToFree > 0) {
+                V value = bucket.pop();
+                if (value == null) {
+                    break;
+                }
+                free(value);
+                bytesToFree -= bucket.mItemSize;
+                mFree.decrement(bucket.mItemSize);
+            }
+        }
+
+        // dump stats at the end
+        logStats();
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(
+                    TAG,
+                    "trimToSize: TargetSize = %d; Final Size = %d",
+                    targetSize,
+                    mUsed.mNumBytes + mFree.mNumBytes);
+        }
     }
-    Bucket<V> newBucket = new Bucket<V>(
+
+
+    /**
+     * Gets the freelist for the specified bucket. Create the freelist if there isn't one
+     *
+     * @param bucketedSize the bucket size
+     * @return the freelist for the bucket
+     */
+    @VisibleForTesting
+    synchronized Bucket<V> getBucket(int bucketedSize) {
+        // get an existing bucket
+        Bucket<V> bucket = mBuckets.get(bucketedSize);
+        if (bucket != null || !mAllowNewBuckets) {
+            return bucket;
+        }
+
+        // create a new bucket
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(TAG, "creating new bucket %s", bucketedSize);
+        }
+        Bucket<V> newBucket = new Bucket<V>(
         /*itemSize*/getSizeInBytes(bucketedSize),
         /*maxLength*/Integer.MAX_VALUE,
         /*inUseLength*/0);
-    mBuckets.put(bucketedSize, newBucket);
-    return newBucket;
-  }
-
-  /**
-   * Returns true if the pool size (sum of the used and the free portions) exceeds its 'max size'
-   * soft cap as specified by the pool parameters.
-   */
-  @VisibleForTesting
-  synchronized boolean isMaxSizeSoftCapExceeded() {
-    final boolean isMaxSizeSoftCapExceeded =
-        (mUsed.mNumBytes + mFree.mNumBytes) > mPoolParams.maxSizeSoftCap;
-    if (isMaxSizeSoftCapExceeded) {
-      mPoolStatsTracker.onSoftCapReached();
-    }
-    return isMaxSizeSoftCapExceeded;
-  }
-
-  /**
-   * Can we allocate a value of size 'sizeInBytes' without exceeding the hard cap on the pool size?
-   * If allocating this value will take the pool over the hard cap, we will first trim the pool down
-   * to its soft cap, and then check again.
-   * If the current used bytes + this new value will take us above the hard cap, then we return
-   * false immediately - there is no point freeing up anything.
-   * This will also take into account mReservedBytes
-   * @param sizeInBytes the size (in bytes) of the value to allocate
-   * @return true, if we can allocate this; false otherwise
-   */
-  @VisibleForTesting
-  synchronized boolean canAllocate(int sizeInBytes) {
-    int hardCap = mPoolParams.maxSizeHardCap;
-
-    // even with our best effort we cannot ensure hard cap limit.
-    // Return immediately - no point in trimming any space
-    if ((mUsed.mNumBytes + mReservedBytes + sizeInBytes) > hardCap) {
-      mPoolStatsTracker.onHardCapReached();
-      return false;
+        mBuckets.put(bucketedSize, newBucket);
+        return newBucket;
     }
 
-    // trim if we need to
-    int softCap = mPoolParams.maxSizeSoftCap;
-    if ((mUsed.mNumBytes + mFree.mNumBytes + mReservedBytes + sizeInBytes) > softCap) {
-      trimToSize(softCap - sizeInBytes);
+    /**
+     * Returns true if the pool size (sum of the used and the free portions) exceeds its 'max size'
+     * soft cap as specified by the pool parameters.
+     */
+    @VisibleForTesting
+    synchronized boolean isMaxSizeSoftCapExceeded() {
+        final boolean isMaxSizeSoftCapExceeded =
+                (mUsed.mNumBytes + mFree.mNumBytes) > mPoolParams.maxSizeSoftCap;
+        if (isMaxSizeSoftCapExceeded) {
+            mPoolStatsTracker.onSoftCapReached();
+        }
+        return isMaxSizeSoftCapExceeded;
     }
 
-    // check again to see if we're below the hard cap
-    if (mUsed.mNumBytes + mFree.mNumBytes + mReservedBytes + sizeInBytes > hardCap) {
-      mPoolStatsTracker.onHardCapReached();
-      return false;
-    }
+    /**
+     * Can we allocate a value of size 'sizeInBytes' without exceeding the hard cap on the pool size?
+     * If allocating this value will take the pool over the hard cap, we will first trim the pool down
+     * to its soft cap, and then check again.
+     * If the current used bytes + this new value will take us above the hard cap, then we return
+     * false immediately - there is no point freeing up anything.
+     * This will also take into account mReservedBytes
+     *
+     * @param sizeInBytes the size (in bytes) of the value to allocate
+     * @return true, if we can allocate this; false otherwise
+     */
+    @VisibleForTesting
+    synchronized boolean canAllocate(int sizeInBytes) {
+        int hardCap = mPoolParams.maxSizeHardCap;
+
+        // even with our best effort we cannot ensure hard cap limit.
+        // Return immediately - no point in trimming any space
+        if ((mUsed.mNumBytes + mReservedBytes + sizeInBytes) > hardCap) {
+            mPoolStatsTracker.onHardCapReached();
+            return false;
+        }
 
-    return true;
-  }
-
-  /**
-   * Simple 'debug' logging of stats.
-   * WARNING: The caller is responsible for synchronization
-   */
-  @SuppressLint("InvalidAccessToGuardedField")
-  private void logStats() {
-    if (FLog.isLoggable(FLog.VERBOSE)) {
-      FLog.v(
-          TAG,
-          "Used = (%d, %d); Free = (%d, %d)",
-          mUsed.mCount,
-          mUsed.mNumBytes,
-          mFree.mCount,
-          mFree.mNumBytes);
-    }
-  }
-
-  /**
-   * Export memory stats regarding buckets used, memory caps, reused values.
-   */
-  public synchronized Map<String, Integer> getStats() {
-    Map<String, Integer> stats = new HashMap<String, Integer>();
-    for (int i = 0; i < mBuckets.size(); ++i) {
-      final int bucketedSize = mBuckets.keyAt(i);
-      final Bucket<V> bucket = mBuckets.valueAt(i);
-      final String BUCKET_USED_KEY =
-          PoolStatsTracker.BUCKETS_USED_PREFIX + getSizeInBytes(bucketedSize);
-      stats.put(BUCKET_USED_KEY, bucket.mInUseLength);
+        // trim if we need to
+        int softCap = mPoolParams.maxSizeSoftCap;
+        if ((mUsed.mNumBytes + mFree.mNumBytes + mReservedBytes + sizeInBytes) > softCap) {
+            trimToSize(softCap - sizeInBytes);
+        }
+
+        // check again to see if we're below the hard cap
+        if (mUsed.mNumBytes + mFree.mNumBytes + mReservedBytes + sizeInBytes > hardCap) {
+            mPoolStatsTracker.onHardCapReached();
+            return false;
+        }
+
+        return true;
     }
 
-    stats.put(PoolStatsTracker.SOFT_CAP, mPoolParams.maxSizeSoftCap);
-    stats.put(PoolStatsTracker.HARD_CAP, mPoolParams.maxSizeHardCap);
-    stats.put(PoolStatsTracker.USED_COUNT, mUsed.mCount);
-    stats.put(PoolStatsTracker.USED_BYTES, mUsed.mNumBytes);
-    stats.put(PoolStatsTracker.FREE_COUNT, mFree.mCount);
-    stats.put(PoolStatsTracker.FREE_BYTES, mFree.mNumBytes);
-
-    return stats;
-  }
-
-  /**
-   * A simple 'counter' that keeps track of the number of items (mCount) as well as the byte
-   * mCount for the number of items
-   * WARNING: this class is not synchronized - the caller must ensure the appropriate
-   * synchronization
-   */
-  @NotThreadSafe
-  @VisibleForTesting
-  static class Counter {
-    private static final String TAG = "com.facebook.imagepipeline.common.BasePool.Counter";
-
-    int mCount;
-    int mNumBytes;
-
-    /**
-     * Add a new item to the counter
-     * @param numBytes size of the item in bytes
-     */
-    public void increment(int numBytes) {
-      this.mCount++;
-      this.mNumBytes += numBytes;
+    /**
+     * Simple 'debug' logging of stats.
+     * WARNING: The caller is responsible for synchronization
+     */
+    @SuppressLint("InvalidAccessToGuardedField")
+    private void logStats() {
+        if (FLog.isLoggable(FLog.VERBOSE)) {
+            FLog.v(
+                    TAG,
+                    "Used = (%d, %d); Free = (%d, %d)",
+                    mUsed.mCount,
+                    mUsed.mNumBytes,
+                    mFree.mCount,
+                    mFree.mNumBytes);
+        }
     }
 
     /**
-     * 'Decrement' an item from the counter
-     * @param numBytes size of the item in bytes
-     */
-    public void decrement(int numBytes) {
-      if (this.mNumBytes >= numBytes && this.mCount > 0) {
-        this.mCount--;
-        this.mNumBytes -= numBytes;
-      } else {
-        FLog.wtf(
-            TAG,
-            "Unexpected decrement of %d. Current numBytes = %d, count = %d",
-            numBytes,
-            this.mNumBytes,
-            this.mCount);
-      }
+     * Export memory stats regarding buckets used, memory caps, reused values.
+     */
+    public synchronized Map<String, Integer> getStats() {
+        Map<String, Integer> stats = new HashMap<String, Integer>();
+        for (int i = 0; i < mBuckets.size(); ++i) {
+            final int bucketedSize = mBuckets.keyAt(i);
+            final Bucket<V> bucket = mBuckets.valueAt(i);
+            final String BUCKET_USED_KEY =
+                    PoolStatsTracker.BUCKETS_USED_PREFIX + getSizeInBytes(bucketedSize);
+            stats.put(BUCKET_USED_KEY, bucket.mInUseLength);
+        }
+
+        stats.put(PoolStatsTracker.SOFT_CAP, mPoolParams.maxSizeSoftCap);
+        stats.put(PoolStatsTracker.HARD_CAP, mPoolParams.maxSizeHardCap);
+        stats.put(PoolStatsTracker.USED_COUNT, mUsed.mCount);
+        stats.put(PoolStatsTracker.USED_BYTES, mUsed.mNumBytes);
+        stats.put(PoolStatsTracker.FREE_COUNT, mFree.mCount);
+        stats.put(PoolStatsTracker.FREE_BYTES, mFree.mNumBytes);
+
+        return stats;
     }
 
     /**
-     * Reset the counter
+     * A simple 'counter' that keeps track of the number of items (mCount) as well as the byte
+     * mCount for the number of items
+     * WARNING: this class is not synchronized - the caller must ensure the appropriate
+     * synchronization
      */
-    public void reset() {
-      this.mCount = 0;
-      this.mNumBytes = 0;
+    @NotThreadSafe
+    @VisibleForTesting
+    static class Counter {
+        private static final String TAG = "com.facebook.imagepipeline.common.BasePool.Counter";
+
+        int mCount;
+        int mNumBytes;
+
+        /**
+         * Add a new item to the counter
+         *
+         * @param numBytes size of the item in bytes
+         */
+        public void increment(int numBytes) {
+            this.mCount++;
+            this.mNumBytes += numBytes;
+        }
+
+        /**
+         * 'Decrement' an item from the counter
+         *
+         * @param numBytes size of the item in bytes
+         */
+        public void decrement(int numBytes) {
+            if (this.mNumBytes >= numBytes && this.mCount > 0) {
+                this.mCount--;
+                this.mNumBytes -= numBytes;
+            } else {
+                FLog.wtf(
+                        TAG,
+                        "Unexpected decrement of %d. Current numBytes = %d, count = %d",
+                        numBytes,
+                        this.mNumBytes,
+                        this.mCount);
+            }
+        }
+
+        /**
+         * Reset the counter
+         */
+        public void reset() {
+            this.mCount = 0;
+            this.mNumBytes = 0;
+        }
     }
-  }
-
-  /**
-   * An exception to indicate if the 'value' is invalid.
-   */
-  public static class InvalidValueException extends RuntimeException {
-    public InvalidValueException(Object value) {
-      super("Invalid value: " + value.toString());
+
+    /**
+     * An exception to indicate if the 'value' is invalid.
+     */
+    public static class InvalidValueException extends RuntimeException {
+        public InvalidValueException(Object value) {
+            super("Invalid value: " + value.toString());
+        }
     }
-  }
-
-  /**
-   * An exception to indicate that the requested size was invalid
-   */
-  public static class InvalidSizeException extends RuntimeException {
-    public InvalidSizeException(Object size) {
-      super("Invalid size: " + size.toString());
+
+    /**
+     * An exception to indicate that the requested size was invalid
+     */
+    public static class InvalidSizeException extends RuntimeException {
+        public InvalidSizeException(Object size) {
+            super("Invalid size: " + size.toString());
+        }
     }
-  }
-
-  /**
-   * A specific case of InvalidSizeException used to indicate that the requested size was too large
-   */
-  public static class SizeTooLargeException extends InvalidSizeException {
-    public SizeTooLargeException(Object size) {
-      super(size);
+
+    /**
+     * A specific case of InvalidSizeException used to indicate that the requested size was too large
+     */
+    public static class SizeTooLargeException extends InvalidSizeException {
+        public SizeTooLargeException(Object size) {
+            super(size);
+        }
     }
-  }
-
-  /**
-   * Indicates that the pool size will exceed the hard cap if we allocated a value
-   * of size 'allocSize'
-   */
-  public static class PoolSizeViolationException extends RuntimeException {
-    public PoolSizeViolationException(int hardCap, int usedBytes, int freeBytes, int allocSize) {
-      super(
-          "Pool hard cap violation? " +
-              "Hard cap = " + hardCap +
-              "Used size = " + usedBytes +
-              "Free size = " + freeBytes +
-              "Request size = " + allocSize);
+
+    /**
+     * Indicates that the pool size will exceed the hard cap if we allocated a value
+     * of size 'allocSize'
+     */
+    public static class PoolSizeViolationException extends RuntimeException {
+        public PoolSizeViolationException(int hardCap, int usedBytes, int freeBytes, int allocSize) {
+            super(
+                    "Pool hard cap violation? " +
+                            "Hard cap = " + hardCap +
+                            "Used size = " + usedBytes +
+                            "Free size = " + freeBytes +
+                            "Request size = " + allocSize);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapCounter.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapCounter.java
index 74acac801..52cf4ffbb 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapCounter.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapCounter.java
@@ -20,70 +20,70 @@
  */
 public class BitmapCounter {
 
-  @GuardedBy("this")
-  private int mCount;
-
-  @GuardedBy("this")
-  private long mSize;
-
-  private final int mMaxCount;
-  private final int mMaxSize;
-
-  public BitmapCounter(int maxCount, int maxSize) {
-    Preconditions.checkArgument(maxCount > 0);
-    Preconditions.checkArgument(maxSize > 0);
-    mMaxCount = maxCount;
-    mMaxSize = maxSize;
-  }
-
-  /**
-   * Includes given bitmap in the bitmap count. The bitmap is included only if doing so does not
-   * violate configured limit
-   *
-   * @param bitmap to include in the count
-   * @return true if and only if bitmap is successfully included in the count
-   */
-  public synchronized boolean increase(Bitmap bitmap) {
-    final int bitmapSize = getBitmapSize(bitmap);
-    if (mCount >= mMaxCount || mSize + bitmapSize > mMaxSize) {
-      return false;
+    @GuardedBy("this")
+    private int mCount;
+
+    @GuardedBy("this")
+    private long mSize;
+
+    private final int mMaxCount;
+    private final int mMaxSize;
+
+    public BitmapCounter(int maxCount, int maxSize) {
+        Preconditions.checkArgument(maxCount > 0);
+        Preconditions.checkArgument(maxSize > 0);
+        mMaxCount = maxCount;
+        mMaxSize = maxSize;
+    }
+
+    /**
+     * Includes given bitmap in the bitmap count. The bitmap is included only if doing so does not
+     * violate configured limit
+     *
+     * @param bitmap to include in the count
+     * @return true if and only if bitmap is successfully included in the count
+     */
+    public synchronized boolean increase(Bitmap bitmap) {
+        final int bitmapSize = getBitmapSize(bitmap);
+        if (mCount >= mMaxCount || mSize + bitmapSize > mMaxSize) {
+            return false;
+        }
+
+        mCount++;
+        mSize += bitmapSize;
+        return true;
+    }
+
+    /**
+     * Excludes given bitmap from the count.
+     *
+     * @param bitmap to be excluded from the count
+     */
+    public synchronized void decrease(Bitmap bitmap) {
+        final int bitmapSize = getBitmapSize(bitmap);
+        Preconditions.checkArgument(bitmapSize <= mSize);
+        Preconditions.checkArgument(mCount > 0);
+
+        mSize -= bitmapSize;
+        mCount--;
+    }
+
+    /**
+     * @return number of counted bitmaps
+     */
+    public synchronized int getCount() {
+        return mCount;
     }
 
-    mCount++;
-    mSize += bitmapSize;
-    return true;
-  }
-
-  /**
-   * Excludes given bitmap from the count.
-   *
-   * @param bitmap to be excluded from the count
-   */
-  public synchronized void decrease(Bitmap bitmap) {
-    final int bitmapSize = getBitmapSize(bitmap);
-    Preconditions.checkArgument(bitmapSize <= mSize);
-    Preconditions.checkArgument(mCount > 0);
-
-    mSize -= bitmapSize;
-    mCount--;
-  }
-
-  /**
-   * @return number of counted bitmaps
-   */
-  public synchronized int getCount() {
-    return mCount;
-  }
-
-  /**
-   * @return total size in bytes of counted bitmaps
-   */
-  public synchronized long getSize() {
-    return mSize;
-  }
-
-  public static int getBitmapSize(Bitmap bitmap) {
-    Preconditions.checkNotNull(bitmap);
-    return bitmap.getRowBytes() * bitmap.getHeight();
-  }
+    /**
+     * @return total size in bytes of counted bitmaps
+     */
+    public synchronized long getSize() {
+        return mSize;
+    }
+
+    public static int getBitmapSize(Bitmap bitmap) {
+        Preconditions.checkNotNull(bitmap);
+        return bitmap.getRowBytes() * bitmap.getHeight();
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapCounterProvider.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapCounterProvider.java
index 6f56ecb88..aa5cf968e 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapCounterProvider.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapCounterProvider.java
@@ -10,29 +10,29 @@
 package com.facebook.imagepipeline.memory;
 
 public class BitmapCounterProvider {
-  private static final long KB = 1024;
-  private static final long MB = 1024 * KB;
+    private static final long KB = 1024;
+    private static final long MB = 1024 * KB;
 
-  /**
-   * Our Bitmaps live in ashmem, meaning that they are pinned in Android's shared native memory.
-   *
-   * <p> Therefore, we are not constrained by the max heap size of the dalvik heap, but we want to
-   * make sure we don't use too much memory on low end devices, so that we don't force other
-   * background process to be killed.
-   */
-  public static final int MAX_BITMAP_TOTAL_SIZE = getMaxSizeHardCap();
-  public static final int MAX_BITMAP_COUNT = 384;
+    /**
+     * Our Bitmaps live in ashmem, meaning that they are pinned in Android's shared native memory.
+     * <p>
+     * <p> Therefore, we are not constrained by the max heap size of the dalvik heap, but we want to
+     * make sure we don't use too much memory on low end devices, so that we don't force other
+     * background process to be killed.
+     */
+    public static final int MAX_BITMAP_TOTAL_SIZE = getMaxSizeHardCap();
+    public static final int MAX_BITMAP_COUNT = 384;
 
-  private static int getMaxSizeHardCap() {
-    final int maxMemory = (int) Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
-    if (maxMemory > 16 * MB) {
-      return maxMemory / 4 * 3;
-    } else {
-      return maxMemory / 2;
+    private static int getMaxSizeHardCap() {
+        final int maxMemory = (int) Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
+        if (maxMemory > 16 * MB) {
+            return maxMemory / 4 * 3;
+        } else {
+            return maxMemory / 2;
+        }
     }
-  }
 
-  public static BitmapCounter get() {
-    return new BitmapCounter(MAX_BITMAP_COUNT, MAX_BITMAP_TOTAL_SIZE);
-  }
+    public static BitmapCounter get() {
+        return new BitmapCounter(MAX_BITMAP_COUNT, MAX_BITMAP_TOTAL_SIZE);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapPool.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapPool.java
index d25b63084..94c392ef3 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapPool.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/BitmapPool.java
@@ -31,91 +31,98 @@
 @TargetApi(21)
 public class BitmapPool extends BasePool<Bitmap> {
 
-  /**
-   * Creates an instance of a bitmap pool.
-   * @param memoryTrimmableRegistry the memory manager to register with
-   * @param poolParams pool parameters
-   */
-  public BitmapPool(
-      MemoryTrimmableRegistry memoryTrimmableRegistry,
-      PoolParams poolParams,
-      PoolStatsTracker poolStatsTracker) {
-    super(memoryTrimmableRegistry, poolParams, poolStatsTracker);
-    initialize();
-  }
+    /**
+     * Creates an instance of a bitmap pool.
+     *
+     * @param memoryTrimmableRegistry the memory manager to register with
+     * @param poolParams              pool parameters
+     */
+    public BitmapPool(
+            MemoryTrimmableRegistry memoryTrimmableRegistry,
+            PoolParams poolParams,
+            PoolStatsTracker poolStatsTracker) {
+        super(memoryTrimmableRegistry, poolParams, poolStatsTracker);
+        initialize();
+    }
 
-  /**
-   * Allocate a bitmap with the specified width and height.
-   * The bitmap's config is controlled by the BITMAP_CONFIG we've defined above.
-   * @param size the 'size' of the bitmap
-   * @return a new bitmap with the specified dimensions
-   */
-  @Override
-  protected Bitmap alloc(int size) {
-    return Bitmap.createBitmap(1, size, Bitmaps.BITMAP_CONFIG);
-  }
+    /**
+     * Allocate a bitmap with the specified width and height.
+     * The bitmap's config is controlled by the BITMAP_CONFIG we've defined above.
+     *
+     * @param size the 'size' of the bitmap
+     * @return a new bitmap with the specified dimensions
+     */
+    @Override
+    protected Bitmap alloc(int size) {
+        return Bitmap.createBitmap(1, size, Bitmaps.BITMAP_CONFIG);
+    }
 
-  /**
-   * Frees the bitmap
-   * @param value the bitmap to free
-   */
-  @Override
-  protected void free(Bitmap value) {
-    Preconditions.checkNotNull(value);
-    value.recycle();
-  }
+    /**
+     * Frees the bitmap
+     *
+     * @param value the bitmap to free
+     */
+    @Override
+    protected void free(Bitmap value) {
+        Preconditions.checkNotNull(value);
+        value.recycle();
+    }
 
-  /**
-   * Gets the bucketed size (typically something the same or larger than the requested size)
-   * @param requestSize the logical request size
-   * @return the 'bucketed' size
-   */
-  @Override
-  protected int getBucketedSize(int requestSize) {
-    return requestSize;
-  }
+    /**
+     * Gets the bucketed size (typically something the same or larger than the requested size)
+     *
+     * @param requestSize the logical request size
+     * @return the 'bucketed' size
+     */
+    @Override
+    protected int getBucketedSize(int requestSize) {
+        return requestSize;
+    }
 
-  /**
-   * Gets the bucketed size of the value.
-   * We don't check the 'validity' of the value (beyond the not-null check). That's handled
-   * in {@link #isReusable(Bitmap)}
-   * @param value the value
-   * @return bucketed size of the value
-   */
-  @Override
-  protected int getBucketedSizeForValue(Bitmap value) {
-    Preconditions.checkNotNull(value);
-    final int allocationByteCount = value.getAllocationByteCount();
-    return allocationByteCount / Bitmaps.BYTES_PER_PIXEL;
-  }
+    /**
+     * Gets the bucketed size of the value.
+     * We don't check the 'validity' of the value (beyond the not-null check). That's handled
+     * in {@link #isReusable(Bitmap)}
+     *
+     * @param value the value
+     * @return bucketed size of the value
+     */
+    @Override
+    protected int getBucketedSizeForValue(Bitmap value) {
+        Preconditions.checkNotNull(value);
+        final int allocationByteCount = value.getAllocationByteCount();
+        return allocationByteCount / Bitmaps.BYTES_PER_PIXEL;
+    }
 
-  /**
-   * Gets the size in bytes for the given bucketed size
-   * This will use the BYTES_PER_PIXEL constant defined above (which is dependent on the specific
-   * BITMAP_CONFIG above)
-   * @param bucketedSize the bucketed size
-   * @return size in bytes
-   */
-  @Override
-  protected int getSizeInBytes(int bucketedSize) {
-    return Bitmaps.BYTES_PER_PIXEL * bucketedSize;
-  }
+    /**
+     * Gets the size in bytes for the given bucketed size
+     * This will use the BYTES_PER_PIXEL constant defined above (which is dependent on the specific
+     * BITMAP_CONFIG above)
+     *
+     * @param bucketedSize the bucketed size
+     * @return size in bytes
+     */
+    @Override
+    protected int getSizeInBytes(int bucketedSize) {
+        return Bitmaps.BYTES_PER_PIXEL * bucketedSize;
+    }
 
-  /**
-   * Determine if this bitmap is reusable (i.e.) if subsequent {@link #get(int)} requests can
-   * use this value.
-   * The bitmap is reusable if
-   *  - it has not already been recycled AND
-   *  - it is mutable AND
-   *  - it has the desired bitmap-config
-   * @param value the value to test for reusability
-   * @return true, if the bitmap can be reused
-   */
-  @Override
-  protected boolean isReusable(Bitmap value) {
-    Preconditions.checkNotNull(value);
-    return !value.isRecycled() &&
-        value.isMutable() &&
-        Bitmaps.BITMAP_CONFIG.equals(value.getConfig());
-  }
+    /**
+     * Determine if this bitmap is reusable (i.e.) if subsequent {@link #get(int)} requests can
+     * use this value.
+     * The bitmap is reusable if
+     * - it has not already been recycled AND
+     * - it is mutable AND
+     * - it has the desired bitmap-config
+     *
+     * @param value the value to test for reusability
+     * @return true, if the bitmap can be reused
+     */
+    @Override
+    protected boolean isReusable(Bitmap value) {
+        Preconditions.checkNotNull(value);
+        return !value.isRecycled() &&
+                value.isMutable() &&
+                Bitmaps.BITMAP_CONFIG.equals(value.getConfig());
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Bucket.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Bucket.java
index 829340a74..7c1d3c774 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Bucket.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Bucket.java
@@ -39,98 +39,103 @@
  * (mInUseCount), plus the size of the freeList. The maxLength of the bucket is that maximum length
  * that this bucket should grow to - and is used by the pool to determine whether values should
  * be released to the bucket ot freed.
+ *
  * @param <V> type of values to be 'stored' in the bucket
  */
 @NotThreadSafe
 @VisibleForTesting
 class Bucket<V> {
-  private static final String TAG = "com.facebook.imagepipeline.common.Bucket";
-
-  public final int mItemSize; // size in bytes of items in this bucket
-  public final int mMaxLength; // 'max' length for this bucket
-  public final ConcurrentLinkedQueue<V> mFreeList; // the free list for this bucket
-
-  @VisibleForTesting
-  int mInUseLength; // current number of entries 'in use' (i.e.) not in the free list
-
-  /**
-   * Constructs a new Bucket instance. The constructed bucket will have an empty freelist
-   * @param itemSize size in bytes of each item in this bucket
-   * @param maxLength max length for the bucket (used + free)
-   * @param inUseLength current in-use-length for the bucket
-   */
-  public Bucket(int itemSize, int maxLength, int inUseLength) {
-    Preconditions.checkState(itemSize > 0);
-    Preconditions.checkState(maxLength >= 0);
-    Preconditions.checkState(inUseLength >= 0);
-
-    mItemSize = itemSize;
-    mMaxLength = maxLength;
-    mFreeList = new ConcurrentLinkedQueue<V>();
-    mInUseLength = inUseLength;
-  }
-
-  /**
-   * Determines if the current length of the bucket (free + used) exceeds the max length
-   * specified
-   */
-  public boolean isMaxLengthExceeded() {
-    return (mInUseLength + mFreeList.size() > mMaxLength);
-  }
-
-  /**
-   * Gets a free item if possible from the freelist. Returns null if the free list is empty
-   * Updates the bucket inUse count
-   * @return an item from the free list, if available
-   */
-  @Nullable
-  public V get() {
-    V value = pop();
-    if (value != null) {
-      mInUseLength ++;
+    private static final String TAG = "com.facebook.imagepipeline.common.Bucket";
+
+    public final int mItemSize; // size in bytes of items in this bucket
+    public final int mMaxLength; // 'max' length for this bucket
+    public final ConcurrentLinkedQueue<V> mFreeList; // the free list for this bucket
+
+    @VisibleForTesting
+    int mInUseLength; // current number of entries 'in use' (i.e.) not in the free list
+
+    /**
+     * Constructs a new Bucket instance. The constructed bucket will have an empty freelist
+     *
+     * @param itemSize    size in bytes of each item in this bucket
+     * @param maxLength   max length for the bucket (used + free)
+     * @param inUseLength current in-use-length for the bucket
+     */
+    public Bucket(int itemSize, int maxLength, int inUseLength) {
+        Preconditions.checkState(itemSize > 0);
+        Preconditions.checkState(maxLength >= 0);
+        Preconditions.checkState(inUseLength >= 0);
+
+        mItemSize = itemSize;
+        mMaxLength = maxLength;
+        mFreeList = new ConcurrentLinkedQueue<V>();
+        mInUseLength = inUseLength;
+    }
+
+    /**
+     * Determines if the current length of the bucket (free + used) exceeds the max length
+     * specified
+     */
+    public boolean isMaxLengthExceeded() {
+        return (mInUseLength + mFreeList.size() > mMaxLength);
+    }
+
+    /**
+     * Gets a free item if possible from the freelist. Returns null if the free list is empty
+     * Updates the bucket inUse count
+     *
+     * @return an item from the free list, if available
+     */
+    @Nullable
+    public V get() {
+        V value = pop();
+        if (value != null) {
+            mInUseLength++;
+        }
+        return value;
+    }
+
+    /**
+     * Remove the first item (if any) from the freelist. Returns null if the free list is empty
+     * Does not update the bucket inUse count
+     *
+     * @return the first value (if any) from the free list
+     */
+    @Nullable
+    public V pop() {
+        return mFreeList.poll();
+    }
+
+    /**
+     * Increment the mInUseCount field.
+     * Used by the pool to update the bucket info when a value was 'alloc'ed (because no free value
+     * was available)
+     */
+    public void incrementInUseCount() {
+        mInUseLength++;
     }
-    return value;
-  }
-
-  /**
-   * Remove the first item (if any) from the freelist. Returns null if the free list is empty
-   * Does not update the bucket inUse count
-   * @return the first value (if any) from the free list
-   */
-  @Nullable
-  public V pop() {
-    return mFreeList.poll();
-  }
-
-  /**
-   * Increment the mInUseCount field.
-   * Used by the pool to update the bucket info when a value was 'alloc'ed (because no free value
-   * was available)
-   */
-  public void incrementInUseCount() {
-    mInUseLength ++;
-  }
-
-  /**
-   * Releases a value to this bucket and decrements the inUse count
-   * @param value the value to release
-   */
-  public void release(V value) {
-    Preconditions.checkNotNull(value);
-    if (mInUseLength > 0) {
-      mInUseLength --;
-    } else {
-      FLog.wtf(TAG, "Bucket inUseLength currently at %d", mInUseLength);
+
+    /**
+     * Releases a value to this bucket and decrements the inUse count
+     *
+     * @param value the value to release
+     */
+    public void release(V value) {
+        Preconditions.checkNotNull(value);
+        if (mInUseLength > 0) {
+            mInUseLength--;
+        } else {
+            FLog.wtf(TAG, "Bucket inUseLength currently at %d", mInUseLength);
+        }
+        mFreeList.add(value);
+    }
+
+    /**
+     * Decrement the mInUseCount field.
+     * Used by the pool to update the bucket info when a value was freed, instead of being returned
+     * to the bucket's free list
+     */
+    public void decrementInUseCount() {
+        mInUseLength--;
     }
-    mFreeList.add(value);
-  }
-
-  /**
-   * Decrement the mInUseCount field.
-   * Used by the pool to update the bucket info when a value was freed, instead of being returned
-   * to the bucket's free list
-   */
-  public void decrementInUseCount() {
-    mInUseLength --;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultBitmapPoolParams.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultBitmapPoolParams.java
index b5a6904d4..3b772582f 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultBitmapPoolParams.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultBitmapPoolParams.java
@@ -17,39 +17,39 @@
  * Provides pool parameters for {@link BitmapPool}
  */
 public class DefaultBitmapPoolParams {
-  /**
-   * We are not reusing Bitmaps and want to free them as soon as possible.
-   */
-  private static final int MAX_SIZE_SOFT_CAP = 0;
-
-  private DefaultBitmapPoolParams() {
-  }
-
-  /**
-   * Our Bitmaps live in ashmem, meaning that they are pinned in androids' shared native memory.
-   * Therefore, we are not constrained by the max heap size of the dalvik heap, but we want to make
-   * sure we don't use too much memory on low end devices, so that we don't force other background
-   * process to be evicted.
-   */
-  private static int getMaxSizeHardCap() {
-    final int maxMemory = (int)Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
-    if (maxMemory > 16 * ByteConstants.MB) {
-      return maxMemory / 4 * 3;
-    } else {
-      return maxMemory / 2;
+    /**
+     * We are not reusing Bitmaps and want to free them as soon as possible.
+     */
+    private static final int MAX_SIZE_SOFT_CAP = 0;
+
+    private DefaultBitmapPoolParams() {
+    }
+
+    /**
+     * Our Bitmaps live in ashmem, meaning that they are pinned in androids' shared native memory.
+     * Therefore, we are not constrained by the max heap size of the dalvik heap, but we want to make
+     * sure we don't use too much memory on low end devices, so that we don't force other background
+     * process to be evicted.
+     */
+    private static int getMaxSizeHardCap() {
+        final int maxMemory = (int) Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
+        if (maxMemory > 16 * ByteConstants.MB) {
+            return maxMemory / 4 * 3;
+        } else {
+            return maxMemory / 2;
+        }
+    }
+
+    /**
+     * This will cause all get/release calls to behave like alloc/free calls i.e. no pooling.
+     */
+    private static final SparseIntArray DEFAULT_BUCKETS = new SparseIntArray(0);
+
+    public static PoolParams get() {
+        return new PoolParams(
+                MAX_SIZE_SOFT_CAP,
+                getMaxSizeHardCap(),
+                DEFAULT_BUCKETS
+        );
     }
-  }
-
-  /**
-   * This will cause all get/release calls to behave like alloc/free calls i.e. no pooling.
-   */
-  private static final SparseIntArray DEFAULT_BUCKETS = new SparseIntArray(0);
-
-  public static PoolParams get() {
-    return new PoolParams(
-        MAX_SIZE_SOFT_CAP,
-        getMaxSizeHardCap(),
-        DEFAULT_BUCKETS
-    );
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultByteArrayPoolParams.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultByteArrayPoolParams.java
index fe1a4dea6..acaad59bb 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultByteArrayPoolParams.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultByteArrayPoolParams.java
@@ -17,32 +17,32 @@
  * Provides pool parameters ({@link PoolParams}) for common {@link ByteArrayPool}
  */
 public class DefaultByteArrayPoolParams {
-  private static final int DEFAULT_IO_BUFFER_SIZE = 16 * ByteConstants.KB;
+    private static final int DEFAULT_IO_BUFFER_SIZE = 16 * ByteConstants.KB;
 
-  /*
-   * There are up to 5 simultaneous IO operations in new pipeline performed by:
-   * - 3 image-fetch threads
-   * - 2 image-cache threads
-   * We should be able to satisfy these requirements without any allocations
-   */
-  private static final int DEFAULT_BUCKET_SIZE = 5;
-  private static final int MAX_SIZE_SOFT_CAP = 5 * DEFAULT_IO_BUFFER_SIZE;
+    /*
+     * There are up to 5 simultaneous IO operations in new pipeline performed by:
+     * - 3 image-fetch threads
+     * - 2 image-cache threads
+     * We should be able to satisfy these requirements without any allocations
+     */
+    private static final int DEFAULT_BUCKET_SIZE = 5;
+    private static final int MAX_SIZE_SOFT_CAP = 5 * DEFAULT_IO_BUFFER_SIZE;
 
-  /**
-   * We don't need hard cap here.
-   */
-  private static final int MAX_SIZE_HARD_CAP = 1 * ByteConstants.MB;
+    /**
+     * We don't need hard cap here.
+     */
+    private static final int MAX_SIZE_HARD_CAP = 1 * ByteConstants.MB;
 
-  /**
-   * Get default {@link PoolParams}.
-   */
-  public static PoolParams get() {
-    // This pool supports only one bucket size: DEFAULT_IO_BUFFER_SIZE
-    SparseIntArray defaultBuckets = new SparseIntArray();
-    defaultBuckets.put(DEFAULT_IO_BUFFER_SIZE, DEFAULT_BUCKET_SIZE);
-    return new PoolParams(
-        MAX_SIZE_SOFT_CAP,
-        MAX_SIZE_HARD_CAP,
-        defaultBuckets);
-  }
+    /**
+     * Get default {@link PoolParams}.
+     */
+    public static PoolParams get() {
+        // This pool supports only one bucket size: DEFAULT_IO_BUFFER_SIZE
+        SparseIntArray defaultBuckets = new SparseIntArray();
+        defaultBuckets.put(DEFAULT_IO_BUFFER_SIZE, DEFAULT_BUCKET_SIZE);
+        return new PoolParams(
+                MAX_SIZE_SOFT_CAP,
+                MAX_SIZE_HARD_CAP,
+                defaultBuckets);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultNativeMemoryChunkPoolParams.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultNativeMemoryChunkPoolParams.java
index ae5db2c43..4ca895374 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultNativeMemoryChunkPoolParams.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultNativeMemoryChunkPoolParams.java
@@ -15,65 +15,64 @@
 
 /**
  * Provides pool parameters ({@link PoolParams}) for {@link NativeMemoryChunkPool}
- *
  */
 public class DefaultNativeMemoryChunkPoolParams {
-  /**
-   * Length of 'small' sized buckets. Bucket lengths for these buckets are larger because
-   * they're smaller in size
-   */
-  private static final int SMALL_BUCKET_LENGTH = 5;
+    /**
+     * Length of 'small' sized buckets. Bucket lengths for these buckets are larger because
+     * they're smaller in size
+     */
+    private static final int SMALL_BUCKET_LENGTH = 5;
 
-  /**
-   * Bucket lengths for 'large' (> 256KB) buckets
-   */
-  private static final int LARGE_BUCKET_LENGTH = 2;
+    /**
+     * Bucket lengths for 'large' (> 256KB) buckets
+     */
+    private static final int LARGE_BUCKET_LENGTH = 2;
 
-  public static PoolParams get() {
-    SparseIntArray DEFAULT_BUCKETS = new SparseIntArray();
-    DEFAULT_BUCKETS.put(1 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
-    DEFAULT_BUCKETS.put(2 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
-    DEFAULT_BUCKETS.put(4 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
-    DEFAULT_BUCKETS.put(8 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
-    DEFAULT_BUCKETS.put(16 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
-    DEFAULT_BUCKETS.put(32 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
-    DEFAULT_BUCKETS.put(64 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
-    DEFAULT_BUCKETS.put(128 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
-    DEFAULT_BUCKETS.put(256 * ByteConstants.KB, LARGE_BUCKET_LENGTH);
-    DEFAULT_BUCKETS.put(512 * ByteConstants.KB, LARGE_BUCKET_LENGTH);
-    DEFAULT_BUCKETS.put(1024 * ByteConstants.KB, LARGE_BUCKET_LENGTH);
-    return new PoolParams(
-        getMaxSizeSoftCap(),
-        getMaxSizeHardCap(),
-        DEFAULT_BUCKETS);
-  }
+    public static PoolParams get() {
+        SparseIntArray DEFAULT_BUCKETS = new SparseIntArray();
+        DEFAULT_BUCKETS.put(1 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
+        DEFAULT_BUCKETS.put(2 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
+        DEFAULT_BUCKETS.put(4 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
+        DEFAULT_BUCKETS.put(8 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
+        DEFAULT_BUCKETS.put(16 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
+        DEFAULT_BUCKETS.put(32 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
+        DEFAULT_BUCKETS.put(64 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
+        DEFAULT_BUCKETS.put(128 * ByteConstants.KB, SMALL_BUCKET_LENGTH);
+        DEFAULT_BUCKETS.put(256 * ByteConstants.KB, LARGE_BUCKET_LENGTH);
+        DEFAULT_BUCKETS.put(512 * ByteConstants.KB, LARGE_BUCKET_LENGTH);
+        DEFAULT_BUCKETS.put(1024 * ByteConstants.KB, LARGE_BUCKET_LENGTH);
+        return new PoolParams(
+                getMaxSizeSoftCap(),
+                getMaxSizeHardCap(),
+                DEFAULT_BUCKETS);
+    }
 
-  /**
-   * {@link NativeMemoryChunkPool} manages memory on the native heap, so we don't need as strict
-   * caps as we would if we were on the Dalvik heap. However, since native memory OOMs are
-   * significantly more problematic than Dalvik OOMs, we would like to stay conservative.
-   */
-  private static int getMaxSizeSoftCap() {
-    final int maxMemory = (int)Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
-    if (maxMemory < 16 * ByteConstants.MB) {
-      return 3 * ByteConstants.MB;
-    } else if (maxMemory < 32 * ByteConstants.MB) {
-      return 6 * ByteConstants.MB;
-    } else {
-      return 12 * ByteConstants.MB;
+    /**
+     * {@link NativeMemoryChunkPool} manages memory on the native heap, so we don't need as strict
+     * caps as we would if we were on the Dalvik heap. However, since native memory OOMs are
+     * significantly more problematic than Dalvik OOMs, we would like to stay conservative.
+     */
+    private static int getMaxSizeSoftCap() {
+        final int maxMemory = (int) Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
+        if (maxMemory < 16 * ByteConstants.MB) {
+            return 3 * ByteConstants.MB;
+        } else if (maxMemory < 32 * ByteConstants.MB) {
+            return 6 * ByteConstants.MB;
+        } else {
+            return 12 * ByteConstants.MB;
+        }
     }
-  }
 
-  /**
-   * We need a smaller cap for devices with less then 16 MB so that we don't run the risk of
-   * evicting other processes from the native heap.
-   */
-  private static int getMaxSizeHardCap() {
-    final int maxMemory = (int) Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
-    if (maxMemory < 16 * ByteConstants.MB) {
-      return maxMemory / 2;
-    } else {
-      return maxMemory / 4 * 3;
+    /**
+     * We need a smaller cap for devices with less then 16 MB so that we don't run the risk of
+     * evicting other processes from the native heap.
+     */
+    private static int getMaxSizeHardCap() {
+        final int maxMemory = (int) Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);
+        if (maxMemory < 16 * ByteConstants.MB) {
+            return maxMemory / 2;
+        } else {
+            return maxMemory / 4 * 3;
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultSharedByteArrayParams.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultSharedByteArrayParams.java
index 5f5fa58b3..d30624509 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultSharedByteArrayParams.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/DefaultSharedByteArrayParams.java
@@ -15,21 +15,21 @@
  * Provides pool parameters ({@link PoolParams}) for {@link SharedByteArray}
  */
 public class DefaultSharedByteArrayParams {
-  // the default max buffer size we'll use
-  private static final int DEFAULT_MAX_BYTE_ARRAY_SIZE = 4 * ByteConstants.MB;
-  // the min buffer size we'll use
-  private static final int DEFAULT_MIN_BYTE_ARRAY_SIZE = 128 * ByteConstants.KB;
+    // the default max buffer size we'll use
+    private static final int DEFAULT_MAX_BYTE_ARRAY_SIZE = 4 * ByteConstants.MB;
+    // the min buffer size we'll use
+    private static final int DEFAULT_MIN_BYTE_ARRAY_SIZE = 128 * ByteConstants.KB;
 
-  private DefaultSharedByteArrayParams() {
-  }
+    private DefaultSharedByteArrayParams() {
+    }
 
-  public static PoolParams get() {
-    return new PoolParams(
-        DEFAULT_MAX_BYTE_ARRAY_SIZE,
-        DEFAULT_MAX_BYTE_ARRAY_SIZE,
-        null,
-        DEFAULT_MIN_BYTE_ARRAY_SIZE,
-        DEFAULT_MAX_BYTE_ARRAY_SIZE
-    );
-  }
+    public static PoolParams get() {
+        return new PoolParams(
+                DEFAULT_MAX_BYTE_ARRAY_SIZE,
+                DEFAULT_MAX_BYTE_ARRAY_SIZE,
+                null,
+                DEFAULT_MIN_BYTE_ARRAY_SIZE,
+                DEFAULT_MAX_BYTE_ARRAY_SIZE
+        );
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/GenericByteArrayPool.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/GenericByteArrayPool.java
index 8dd1a1ef5..e890de3d3 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/GenericByteArrayPool.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/GenericByteArrayPool.java
@@ -28,103 +28,110 @@
  */
 @ThreadSafe
 public class GenericByteArrayPool extends BasePool<byte[]> implements ByteArrayPool {
-  private final int[] mBucketSizes;
+    private final int[] mBucketSizes;
 
-  /**
-   * Creates a new instance of the GenericByteArrayPool class
-   * @param memoryTrimmableRegistry the memory manager to register with
-   * @param poolParams provider for pool parameters
-   * @param poolStatsTracker
-   */
-  public GenericByteArrayPool(
-      MemoryTrimmableRegistry memoryTrimmableRegistry,
-      PoolParams poolParams,
-      PoolStatsTracker poolStatsTracker) {
-    super(memoryTrimmableRegistry, poolParams, poolStatsTracker);
-    final SparseIntArray bucketSizes = poolParams.bucketSizes;
-    mBucketSizes = new int[bucketSizes.size()];
-    for (int i = 0; i < bucketSizes.size(); ++i) {
-      mBucketSizes[i] = bucketSizes.keyAt(i);
+    /**
+     * Creates a new instance of the GenericByteArrayPool class
+     *
+     * @param memoryTrimmableRegistry the memory manager to register with
+     * @param poolParams              provider for pool parameters
+     * @param poolStatsTracker
+     */
+    public GenericByteArrayPool(
+            MemoryTrimmableRegistry memoryTrimmableRegistry,
+            PoolParams poolParams,
+            PoolStatsTracker poolStatsTracker) {
+        super(memoryTrimmableRegistry, poolParams, poolStatsTracker);
+        final SparseIntArray bucketSizes = poolParams.bucketSizes;
+        mBucketSizes = new int[bucketSizes.size()];
+        for (int i = 0; i < bucketSizes.size(); ++i) {
+            mBucketSizes[i] = bucketSizes.keyAt(i);
+        }
+        initialize();
     }
-    initialize();
-  }
 
-  /**
-   * Gets the smallest buffer size supported by the pool
-   * @return the smallest buffer size supported by the pool
-   */
-  public int getMinBufferSize() {
-    return mBucketSizes[0];
-  }
-
-  /**
-   * Allocate a buffer greater than or equal to the specified size
-   * @param bucketedSize size of the buffer requested
-   * @return a byte array of the specified or larger size. Null if the size is invalid
-   */
-  @Override
-  protected byte[] alloc(int bucketedSize) {
-    return new byte[bucketedSize];
-  }
-
-  /**
-   * Frees the 'value'
-   * @param value the value to free
-   */
-  @Override
-  protected void free(byte[] value) {
-    Preconditions.checkNotNull(value);
-    // do nothing. Let the GC take care of this
-  }
+    /**
+     * Gets the smallest buffer size supported by the pool
+     *
+     * @return the smallest buffer size supported by the pool
+     */
+    public int getMinBufferSize() {
+        return mBucketSizes[0];
+    }
 
-  /**
-   * Gets the size in bytes for the given 'bucketed' size
-   * @param bucketedSize the bucketed size
-   * @return size in bytes
-   */
-  @Override
-  protected int getSizeInBytes(int bucketedSize) {
-    return bucketedSize;
-  }
+    /**
+     * Allocate a buffer greater than or equal to the specified size
+     *
+     * @param bucketedSize size of the buffer requested
+     * @return a byte array of the specified or larger size. Null if the size is invalid
+     */
+    @Override
+    protected byte[] alloc(int bucketedSize) {
+        return new byte[bucketedSize];
+    }
 
-  /**
-   * Get the 'bucketed' size for the given request size. The 'bucketed' size is a size that is
-   * the same or larger than the request size. We walk through our list of pre-defined bucket
-   * sizes, and use that to determine the smallest bucket size that is larger than the requested
-   * size.
-   * If no such 'bucketedSize' is found, then we simply return "requestSize"
-   * @param requestSize the logical request size
-   * @return the bucketed size
-   * @throws InvalidSizeException, if the requested size was invalid
-   */
-  @Override
-  protected int getBucketedSize(int requestSize) {
-    int intRequestSize = requestSize;
-    if (intRequestSize <= 0) {
-      throw new InvalidSizeException(requestSize);
+    /**
+     * Frees the 'value'
+     *
+     * @param value the value to free
+     */
+    @Override
+    protected void free(byte[] value) {
+        Preconditions.checkNotNull(value);
+        // do nothing. Let the GC take care of this
     }
 
-    // find the smallest bucketed size that is larger than the requested size
-    for (int bucketedSize : mBucketSizes) {
-      if (bucketedSize >= intRequestSize) {
+    /**
+     * Gets the size in bytes for the given 'bucketed' size
+     *
+     * @param bucketedSize the bucketed size
+     * @return size in bytes
+     */
+    @Override
+    protected int getSizeInBytes(int bucketedSize) {
         return bucketedSize;
-      }
     }
 
-    // requested size doesn't match our existing buckets - just return the requested size
-    // this will eventually translate into a plain alloc/free paradigm
-    return requestSize;
-  }
+    /**
+     * Get the 'bucketed' size for the given request size. The 'bucketed' size is a size that is
+     * the same or larger than the request size. We walk through our list of pre-defined bucket
+     * sizes, and use that to determine the smallest bucket size that is larger than the requested
+     * size.
+     * If no such 'bucketedSize' is found, then we simply return "requestSize"
+     *
+     * @param requestSize the logical request size
+     * @return the bucketed size
+     * @throws InvalidSizeException, if the requested size was invalid
+     */
+    @Override
+    protected int getBucketedSize(int requestSize) {
+        int intRequestSize = requestSize;
+        if (intRequestSize <= 0) {
+            throw new InvalidSizeException(requestSize);
+        }
 
-  /**
-   * Gets the bucketed size of the value
-   * @param value the value
-   * @return just the length of the value
-   */
-  @Override
-  protected int getBucketedSizeForValue(byte[] value) {
-    Preconditions.checkNotNull(value);
-    return value.length;
-  }
+        // find the smallest bucketed size that is larger than the requested size
+        for (int bucketedSize : mBucketSizes) {
+            if (bucketedSize >= intRequestSize) {
+                return bucketedSize;
+            }
+        }
+
+        // requested size doesn't match our existing buckets - just return the requested size
+        // this will eventually translate into a plain alloc/free paradigm
+        return requestSize;
+    }
+
+    /**
+     * Gets the bucketed size of the value
+     *
+     * @param value the value
+     * @return just the length of the value
+     */
+    @Override
+    protected int getBucketedSizeForValue(byte[] value) {
+        Preconditions.checkNotNull(value);
+        return value.length;
+    }
 }
 
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativeMemoryChunk.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativeMemoryChunk.java
index d7f255554..c0de0dbc3 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativeMemoryChunk.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativeMemoryChunk.java
@@ -21,300 +21,308 @@
 
 /**
  * Wrapper around chunk of native memory.
- *
+ * <p>
  * <p> This class uses JNI to obtain pointer to native memory and read/write data from/to it.
- *
+ * <p>
  * <p> Native code used by this class is shipped as part of libimagepipeline_memory.so
  *
  * @ThreadSafe
  */
 @DoNotStrip
 public class NativeMemoryChunk implements Closeable {
-  private static final String TAG = "NativeMemoryChunk";
-
-  static {
-    SoLoaderShim.loadLibrary("memchunk");
-  }
-
-  /**
-   * Address of memory chunk wrapped by this NativeMemoryChunk
-   */
-  private final long mNativePtr;
-
-  /**
-   * size of the memory region
-   */
-  private final int mSize;
-
-  /**
-   * flag indicating if this object was closed
-   * @GuardedBy("this")
-   */
-  private boolean mClosed;
-
-  public NativeMemoryChunk(final int size) {
-    Preconditions.checkArgument(size > 0);
-    mSize = size;
-    mNativePtr = nativeAllocate(mSize);
-    mClosed = false;
-  }
-
-  @VisibleForTesting
-  public NativeMemoryChunk() {
-    mSize = 0;
-    mNativePtr = 0;
-    mClosed = true;
-  }
-
-  /**
-   * This has to be called before we get rid of this object in order to release underlying memory
-   */
-  public synchronized void close() {
-    if (!mClosed) {
-      mClosed = true;
-      nativeFree(mNativePtr);
+    private static final String TAG = "NativeMemoryChunk";
+
+    static {
+        SoLoaderShim.loadLibrary("memchunk");
+    }
+
+    /**
+     * Address of memory chunk wrapped by this NativeMemoryChunk
+     */
+    private final long mNativePtr;
+
+    /**
+     * size of the memory region
+     */
+    private final int mSize;
+
+    /**
+     * flag indicating if this object was closed
+     *
+     * @GuardedBy("this")
+     */
+    private boolean mClosed;
+
+    public NativeMemoryChunk(final int size) {
+        Preconditions.checkArgument(size > 0);
+        mSize = size;
+        mNativePtr = nativeAllocate(mSize);
+        mClosed = false;
+    }
+
+    @VisibleForTesting
+    public NativeMemoryChunk() {
+        mSize = 0;
+        mNativePtr = 0;
+        mClosed = true;
+    }
+
+    /**
+     * This has to be called before we get rid of this object in order to release underlying memory
+     */
+    public synchronized void close() {
+        if (!mClosed) {
+            mClosed = true;
+            nativeFree(mNativePtr);
+        }
+    }
+
+    /**
+     * Is this chunk already closed (aka freed) ?
+     *
+     * @return true, if this chunk has already been closed
+     */
+    public synchronized boolean isClosed() {
+        return mClosed;
+    }
+
+    /**
+     * Get the size of this memory chunk.
+     * Ignores if this chunk has been closed
+     */
+    public int getSize() {
+        return mSize;
+    }
+
+    /**
+     * Copy bytes from byte array to native memory.
+     *
+     * @param nativeMemoryOffset number of first byte to be written by copy operation
+     * @param byteArray          byte array to copy from
+     * @param byteArrayOffset    number of first byte in byteArray to copy
+     * @param count              number of bytes to copy
+     * @return number of bytes written
+     */
+    public synchronized int write(
+            int nativeMemoryOffset,
+            final byte[] byteArray,
+            int byteArrayOffset,
+            int count) {
+        Preconditions.checkNotNull(byteArray);
+        Preconditions.checkState(!isClosed());
+        final int actualCount = adjustByteCount(nativeMemoryOffset, count);
+        checkBounds(nativeMemoryOffset, byteArray.length, byteArrayOffset, actualCount);
+        nativeCopyFromByteArray(
+                mNativePtr + nativeMemoryOffset,
+                byteArray,
+                byteArrayOffset,
+                actualCount);
+        return actualCount;
     }
-  }
-
-  /**
-   * Is this chunk already closed (aka freed) ?
-   * @return true, if this chunk has already been closed
-   */
-  public synchronized boolean isClosed() {
-    return mClosed;
-  }
-
-  /**
-   * Get the size of this memory chunk.
-   * Ignores if this chunk has been closed
-   */
-  public int getSize() {
-    return mSize;
-  }
-
-  /**
-   * Copy bytes from byte array to native memory.
-   * @param nativeMemoryOffset number of first byte to be written by copy operation
-   * @param byteArray byte array to copy from
-   * @param byteArrayOffset number of first byte in byteArray to copy
-   * @param count number of bytes to copy
-   * @return number of bytes written
-   */
-  public synchronized int write(
-      int nativeMemoryOffset,
-      final byte[] byteArray,
-      int byteArrayOffset,
-      int count) {
-    Preconditions.checkNotNull(byteArray);
-    Preconditions.checkState(!isClosed());
-    final int actualCount = adjustByteCount(nativeMemoryOffset, count);
-    checkBounds(nativeMemoryOffset, byteArray.length, byteArrayOffset, actualCount);
-    nativeCopyFromByteArray(
-        mNativePtr + nativeMemoryOffset,
-        byteArray,
-        byteArrayOffset,
-        actualCount);
-    return actualCount;
-  }
-
-  /**
-   * Copy bytes from native memory to byte array.
-   * @param nativeMemoryOffset number of first byte to copy
-   * @param byteArray byte array to copy to
-   * @param byteArrayOffset number of first byte in byte array to be written
-   * @param count number of bytes to copy
-   * @return number of bytes read
-   */
-  public synchronized int read(
-      final int nativeMemoryOffset,
-      final byte[] byteArray,
-      final int byteArrayOffset,
-      final int count) {
-    Preconditions.checkNotNull(byteArray);
-    Preconditions.checkState(!isClosed());
-    final int actualCount = adjustByteCount(nativeMemoryOffset, count);
-    checkBounds(nativeMemoryOffset, byteArray.length, byteArrayOffset, actualCount);
-    nativeCopyToByteArray(mNativePtr + nativeMemoryOffset, byteArray, byteArrayOffset, actualCount);
-    return actualCount;
-  }
-
-  /**
-   * Read byte at given offset.
-   * @param offset
-   * @return byte at given offset
-   */
-  public synchronized byte read(int offset) {
-    Preconditions.checkState(!isClosed());
-    Preconditions.checkArgument(offset >= 0);
-    Preconditions.checkArgument(offset < mSize);
-    return nativeReadByte(mNativePtr + offset);
-  }
-
-  /**
-   * Copy bytes from native memory wrapped by this NativeMemoryChunk instance to
-   * native memory wrapped by other NativeMemoryChunk
-   * @param offset number of first byte to copy
-   * @param other other NativeMemoryChunk to copy to
-   * @param otherOffset number of first byte to write to
-   * @param count number of bytes to copy
-   */
-  public void copy(
-      final int offset,
-      final NativeMemoryChunk other,
-      final int otherOffset,
-      final int count) {
-    Preconditions.checkNotNull(other);
-
-    // This implementation acquires locks on this and other objects and then delegates to
-    // doCopy which does actual copy. In order to avoid deadlocks we have to establish some linear
-    // order on all NativeMemoryChunks and acquire locks according to this order. Fortunately
-    // we can use mNativePtr for that purpose. So we have to address 3 cases:
-
-    // Case 1: other memory chunk == this memory chunk
-    if (other.mNativePtr == mNativePtr) {
-      // we do not allow copying to the same address
-      // lets log warning and not copy
-      Log.w(
-          TAG,
-          "Copying from NativeMemoryChunk " +
-              Integer.toHexString(System.identityHashCode(this)) +
-              " to NativeMemoryChunk " +
-              Integer.toHexString(System.identityHashCode(other)) +
-              " which share the same address " +
-              Long.toHexString(mNativePtr));
-      Preconditions.checkArgument(false);
+
+    /**
+     * Copy bytes from native memory to byte array.
+     *
+     * @param nativeMemoryOffset number of first byte to copy
+     * @param byteArray          byte array to copy to
+     * @param byteArrayOffset    number of first byte in byte array to be written
+     * @param count              number of bytes to copy
+     * @return number of bytes read
+     */
+    public synchronized int read(
+            final int nativeMemoryOffset,
+            final byte[] byteArray,
+            final int byteArrayOffset,
+            final int count) {
+        Preconditions.checkNotNull(byteArray);
+        Preconditions.checkState(!isClosed());
+        final int actualCount = adjustByteCount(nativeMemoryOffset, count);
+        checkBounds(nativeMemoryOffset, byteArray.length, byteArrayOffset, actualCount);
+        nativeCopyToByteArray(mNativePtr + nativeMemoryOffset, byteArray, byteArrayOffset, actualCount);
+        return actualCount;
+    }
+
+    /**
+     * Read byte at given offset.
+     *
+     * @param offset
+     * @return byte at given offset
+     */
+    public synchronized byte read(int offset) {
+        Preconditions.checkState(!isClosed());
+        Preconditions.checkArgument(offset >= 0);
+        Preconditions.checkArgument(offset < mSize);
+        return nativeReadByte(mNativePtr + offset);
     }
 
-    // Case 2: other memory chunk < this memory chunk
-    if (other.mNativePtr < mNativePtr) {
-      synchronized (other) {
+    /**
+     * Copy bytes from native memory wrapped by this NativeMemoryChunk instance to
+     * native memory wrapped by other NativeMemoryChunk
+     *
+     * @param offset      number of first byte to copy
+     * @param other       other NativeMemoryChunk to copy to
+     * @param otherOffset number of first byte to write to
+     * @param count       number of bytes to copy
+     */
+    public void copy(
+            final int offset,
+            final NativeMemoryChunk other,
+            final int otherOffset,
+            final int count) {
+        Preconditions.checkNotNull(other);
+
+        // This implementation acquires locks on this and other objects and then delegates to
+        // doCopy which does actual copy. In order to avoid deadlocks we have to establish some linear
+        // order on all NativeMemoryChunks and acquire locks according to this order. Fortunately
+        // we can use mNativePtr for that purpose. So we have to address 3 cases:
+
+        // Case 1: other memory chunk == this memory chunk
+        if (other.mNativePtr == mNativePtr) {
+            // we do not allow copying to the same address
+            // lets log warning and not copy
+            Log.w(
+                    TAG,
+                    "Copying from NativeMemoryChunk " +
+                            Integer.toHexString(System.identityHashCode(this)) +
+                            " to NativeMemoryChunk " +
+                            Integer.toHexString(System.identityHashCode(other)) +
+                            " which share the same address " +
+                            Long.toHexString(mNativePtr));
+            Preconditions.checkArgument(false);
+        }
+
+        // Case 2: other memory chunk < this memory chunk
+        if (other.mNativePtr < mNativePtr) {
+            synchronized (other) {
+                synchronized (this) {
+                    doCopy(offset, other, otherOffset, count);
+                }
+            }
+            return;
+        }
+
+        // Case 3: other memory chunk > this memory chunk
         synchronized (this) {
-          doCopy(offset, other, otherOffset, count);
+            synchronized (other) {
+                doCopy(offset, other, otherOffset, count);
+            }
         }
-      }
-      return;
     }
 
-    // Case 3: other memory chunk > this memory chunk
-    synchronized (this) {
-      synchronized (other) {
-        doCopy(offset, other, otherOffset, count);
-      }
+    public long getNativePtr() {
+        return mNativePtr;
+    }
+
+    /**
+     * This does actual copy. It should be called only when we hold locks on both this and
+     * other objects
+     */
+    private void doCopy(
+            final int offset,
+            final NativeMemoryChunk other,
+            final int otherOffset,
+            final int count) {
+        Preconditions.checkState(!isClosed());
+        Preconditions.checkState(!other.isClosed());
+        checkBounds(offset, other.mSize, otherOffset, count);
+        nativeMemcpy(other.mNativePtr + otherOffset, mNativePtr + offset, count);
+    }
+
+    /**
+     * A finalizer, just in case. Just delegates to {@link #close()}
+     *
+     * @throws Throwable
+     */
+    @Override
+    protected void finalize() throws Throwable {
+        if (isClosed()) {
+            return;
+        }
+
+        Log.w(
+                TAG,
+                "finalize: Chunk " +
+                        Integer.toHexString(System.identityHashCode(this)) +
+                        " still active. Underlying address = " +
+                        Long.toHexString(mNativePtr));
+        // do the actual clearing
+        try {
+            close();
+        } finally {
+            super.finalize();
+        }
     }
-  }
-
-  public long getNativePtr() {
-    return mNativePtr;
-  }
-
-  /**
-   * This does actual copy. It should be called only when we hold locks on both this and
-   * other objects
-   */
-  private void doCopy(
-      final int offset,
-      final NativeMemoryChunk other,
-      final int otherOffset,
-      final int count) {
-    Preconditions.checkState(!isClosed());
-    Preconditions.checkState(!other.isClosed());
-    checkBounds(offset, other.mSize, otherOffset, count);
-    nativeMemcpy(other.mNativePtr + otherOffset, mNativePtr + offset, count);
-  }
-
-  /**
-   * A finalizer, just in case. Just delegates to {@link #close()}
-   * @throws Throwable
-   */
-  @Override
-  protected void finalize() throws Throwable {
-    if (isClosed()) {
-      return;
+
+    /**
+     * Computes number of bytes that can be safely read/written starting at given offset, but no more
+     * than count.
+     */
+    private int adjustByteCount(final int offset, final int count) {
+        final int available = Math.max(0, mSize - offset);
+        return Math.min(available, count);
     }
 
-    Log.w(
-        TAG,
-        "finalize: Chunk " +
-            Integer.toHexString(System.identityHashCode(this)) +
-            " still active. Underlying address = " +
-            Long.toHexString(mNativePtr));
-    // do the actual clearing
-    try {
-      close();
-    } finally {
-      super.finalize();
+    /**
+     * Check that copy/read/write operation won't access memory it should not
+     */
+    private void checkBounds(
+            final int myOffset,
+            final int otherLength,
+            final int otherOffset,
+            final int count) {
+        Preconditions.checkArgument(count >= 0);
+        Preconditions.checkArgument(myOffset >= 0);
+        Preconditions.checkArgument(otherOffset >= 0);
+        Preconditions.checkArgument(myOffset + count <= mSize);
+        Preconditions.checkArgument(otherOffset + count <= otherLength);
     }
-  }
-
-  /**
-   * Computes number of bytes that can be safely read/written starting at given offset, but no more
-   * than count.
-   */
-  private int adjustByteCount(final int offset, final int count) {
-    final int available = Math.max(0, mSize - offset);
-    return Math.min(available, count);
-  }
-
-  /**
-   * Check that copy/read/write operation won't access memory it should not
-   */
-  private void checkBounds(
-      final int myOffset,
-      final int otherLength,
-      final int otherOffset,
-      final int count) {
-    Preconditions.checkArgument(count >= 0);
-    Preconditions.checkArgument(myOffset >= 0);
-    Preconditions.checkArgument(otherOffset >= 0);
-    Preconditions.checkArgument(myOffset + count <= mSize);
-    Preconditions.checkArgument(otherOffset + count <= otherLength);
-  }
-
-  /**
-   * Delegate to one of native memory allocation function
-   */
-  @DoNotStrip
-  private static native long nativeAllocate(int size);
-
-  /**
-   * Delegate to appropriate memory releasing function
-   */
-  @DoNotStrip
-  private static native void nativeFree(long address);
-
-  /**
-   * Copy count bytes pointed by mNativePtr to array, starting at position offset
-   */
-  @DoNotStrip
-  private static native void nativeCopyToByteArray(
-      long address,
-      byte[] array,
-      int offset,
-      int count);
-
-  /**
-   * Copy count bytes from byte array to native memory pointed by mNativePtr.
-   */
-  @DoNotStrip
-  private static native void nativeCopyFromByteArray(
-      long address,
-      byte[] array,
-      int offset,
-      int count);
-
-  /**
-   * Copy count bytes from memory pointed by fromPtr to memory pointed by toPtr
-   */
-  @DoNotStrip
-  private static native void nativeMemcpy(
-      long toPtr,
-      long fromPtr,
-      int count);
-
-  /**
-   * Read single byte from given address
-   * @param fromPtr address to read byte from
-   */
-  @DoNotStrip
-  private static native byte nativeReadByte(long fromPtr);
+
+    /**
+     * Delegate to one of native memory allocation function
+     */
+    @DoNotStrip
+    private static native long nativeAllocate(int size);
+
+    /**
+     * Delegate to appropriate memory releasing function
+     */
+    @DoNotStrip
+    private static native void nativeFree(long address);
+
+    /**
+     * Copy count bytes pointed by mNativePtr to array, starting at position offset
+     */
+    @DoNotStrip
+    private static native void nativeCopyToByteArray(
+            long address,
+            byte[] array,
+            int offset,
+            int count);
+
+    /**
+     * Copy count bytes from byte array to native memory pointed by mNativePtr.
+     */
+    @DoNotStrip
+    private static native void nativeCopyFromByteArray(
+            long address,
+            byte[] array,
+            int offset,
+            int count);
+
+    /**
+     * Copy count bytes from memory pointed by fromPtr to memory pointed by toPtr
+     */
+    @DoNotStrip
+    private static native void nativeMemcpy(
+            long toPtr,
+            long fromPtr,
+            int count);
+
+    /**
+     * Read single byte from given address
+     *
+     * @param fromPtr address to read byte from
+     */
+    @DoNotStrip
+    private static native byte nativeReadByte(long fromPtr);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativeMemoryChunkPool.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativeMemoryChunkPool.java
index b7bd38c23..bc91458c1 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativeMemoryChunkPool.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativeMemoryChunkPool.java
@@ -21,115 +21,123 @@
  */
 @ThreadSafe
 public class NativeMemoryChunkPool extends BasePool<NativeMemoryChunk> {
-  private final int[] mBucketSizes;
+    private final int[] mBucketSizes;
 
-  /**
-   * Creates a new instance of the NativeMemoryChunkPool class
-   * @param memoryTrimmableRegistry the memory manager to register with
-   * @param poolParams provider for pool parameters
-   * @param nativeMemoryChunkPoolStatsTracker
-   */
-  public NativeMemoryChunkPool(
-      MemoryTrimmableRegistry memoryTrimmableRegistry,
-      PoolParams poolParams,
-      PoolStatsTracker nativeMemoryChunkPoolStatsTracker) {
-    super(memoryTrimmableRegistry, poolParams, nativeMemoryChunkPoolStatsTracker);
-    SparseIntArray bucketSizes = poolParams.bucketSizes;
-    mBucketSizes = new int[bucketSizes.size()];
-    for (int i = 0; i < mBucketSizes.length; ++i) {
-      mBucketSizes[i] = bucketSizes.keyAt(i);
+    /**
+     * Creates a new instance of the NativeMemoryChunkPool class
+     *
+     * @param memoryTrimmableRegistry           the memory manager to register with
+     * @param poolParams                        provider for pool parameters
+     * @param nativeMemoryChunkPoolStatsTracker
+     */
+    public NativeMemoryChunkPool(
+            MemoryTrimmableRegistry memoryTrimmableRegistry,
+            PoolParams poolParams,
+            PoolStatsTracker nativeMemoryChunkPoolStatsTracker) {
+        super(memoryTrimmableRegistry, poolParams, nativeMemoryChunkPoolStatsTracker);
+        SparseIntArray bucketSizes = poolParams.bucketSizes;
+        mBucketSizes = new int[bucketSizes.size()];
+        for (int i = 0; i < mBucketSizes.length; ++i) {
+            mBucketSizes[i] = bucketSizes.keyAt(i);
+        }
+        initialize();
     }
-    initialize();
-  }
 
-  /**
-   * Gets the smallest size supported by the pool
-   * @return the smallest size supported by the pool
-   */
-  public int getMinBufferSize() {
-    return mBucketSizes[0];
-  }
-
-  /**
-   * Allocate a native memory chunk larger than or equal to the specified size
-   * @param bucketedSize size of the buffer requested
-   * @return a native memory chunk of the specified or larger size. Null if the size is invalid
-   */
-  @Override
-  protected NativeMemoryChunk alloc(int bucketedSize) {
-    return new NativeMemoryChunk(bucketedSize);
-  }
-
-  /**
-   * Frees the 'value'
-   * @param value the value to free
-   */
-  @Override
-  protected void free(NativeMemoryChunk value) {
-    Preconditions.checkNotNull(value);
-    value.close();
-  }
+    /**
+     * Gets the smallest size supported by the pool
+     *
+     * @return the smallest size supported by the pool
+     */
+    public int getMinBufferSize() {
+        return mBucketSizes[0];
+    }
 
-  /**
-   * Gets the size in bytes for the given 'bucketed' size
-   * @param bucketedSize the bucketed size
-   * @return size in bytes
-   */
-  @Override
-  protected int getSizeInBytes(int bucketedSize) {
-    return bucketedSize;
-  }
+    /**
+     * Allocate a native memory chunk larger than or equal to the specified size
+     *
+     * @param bucketedSize size of the buffer requested
+     * @return a native memory chunk of the specified or larger size. Null if the size is invalid
+     */
+    @Override
+    protected NativeMemoryChunk alloc(int bucketedSize) {
+        return new NativeMemoryChunk(bucketedSize);
+    }
 
-  /**
-   * Get the 'bucketed' size for the given request size. The 'bucketed' size is a size that is
-   * the same or larger than the request size. We walk through our list of pre-defined bucket
-   * sizes, and use that to determine the smallest bucket size that is larger than the requested
-   * size.
-   * If no such 'bucketedSize' is found, then we simply return "requestSize"
-   * @param requestSize the logical request size
-   * @return the bucketed size
-   * @throws InvalidSizeException, if the requested size was invalid
-   */
-  @Override
-  protected int getBucketedSize(int requestSize) {
-    int intRequestSize = requestSize;
-    if (intRequestSize <= 0) {
-      throw new InvalidSizeException(requestSize);
+    /**
+     * Frees the 'value'
+     *
+     * @param value the value to free
+     */
+    @Override
+    protected void free(NativeMemoryChunk value) {
+        Preconditions.checkNotNull(value);
+        value.close();
     }
 
-    // find the smallest bucketed size that is larger than the requested size
-    for (int bucketedSize : mBucketSizes) {
-      if (bucketedSize >= intRequestSize) {
+    /**
+     * Gets the size in bytes for the given 'bucketed' size
+     *
+     * @param bucketedSize the bucketed size
+     * @return size in bytes
+     */
+    @Override
+    protected int getSizeInBytes(int bucketedSize) {
         return bucketedSize;
-      }
     }
 
-    // requested size doesn't match our existing buckets - just return the requested size
-    // this will eventually translate into a plain alloc/free paradigm
-    return requestSize;
-  }
+    /**
+     * Get the 'bucketed' size for the given request size. The 'bucketed' size is a size that is
+     * the same or larger than the request size. We walk through our list of pre-defined bucket
+     * sizes, and use that to determine the smallest bucket size that is larger than the requested
+     * size.
+     * If no such 'bucketedSize' is found, then we simply return "requestSize"
+     *
+     * @param requestSize the logical request size
+     * @return the bucketed size
+     * @throws InvalidSizeException, if the requested size was invalid
+     */
+    @Override
+    protected int getBucketedSize(int requestSize) {
+        int intRequestSize = requestSize;
+        if (intRequestSize <= 0) {
+            throw new InvalidSizeException(requestSize);
+        }
 
-  /**
-   * Gets the bucketed size of the value
-   * @param value the value
-   * @return just the length of the value
-   */
-  @Override
-  protected int getBucketedSizeForValue(NativeMemoryChunk value) {
-    Preconditions.checkNotNull(value);
-    return value.getSize();
-  }
+        // find the smallest bucketed size that is larger than the requested size
+        for (int bucketedSize : mBucketSizes) {
+            if (bucketedSize >= intRequestSize) {
+                return bucketedSize;
+            }
+        }
 
-  /**
-   * Checks if the value is reusable (for subseequent {@link #get(int)} operations.
-   * The value is reusable, if
-   *  - it hasn't already been freed
-   * @param value the value to test for reusability
-   * @return true, if the value is reusable
-   */
-  @Override
-  protected boolean isReusable(NativeMemoryChunk value) {
-    Preconditions.checkNotNull(value);
-    return !value.isClosed();
-  }
+        // requested size doesn't match our existing buckets - just return the requested size
+        // this will eventually translate into a plain alloc/free paradigm
+        return requestSize;
+    }
+
+    /**
+     * Gets the bucketed size of the value
+     *
+     * @param value the value
+     * @return just the length of the value
+     */
+    @Override
+    protected int getBucketedSizeForValue(NativeMemoryChunk value) {
+        Preconditions.checkNotNull(value);
+        return value.getSize();
+    }
+
+    /**
+     * Checks if the value is reusable (for subseequent {@link #get(int)} operations.
+     * The value is reusable, if
+     * - it hasn't already been freed
+     *
+     * @param value the value to test for reusability
+     * @return true, if the value is reusable
+     */
+    @Override
+    protected boolean isReusable(NativeMemoryChunk value) {
+        Preconditions.checkNotNull(value);
+        return !value.isClosed();
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBuffer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBuffer.java
index 193d80a3b..53713346e 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBuffer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBuffer.java
@@ -26,83 +26,86 @@
 @ThreadSafe
 public class NativePooledByteBuffer implements PooledByteBuffer {
 
-  private final int mSize;
-
-  @GuardedBy("this")
-  @VisibleForTesting
-  CloseableReference<NativeMemoryChunk> mBufRef;
-
-  public NativePooledByteBuffer(CloseableReference<NativeMemoryChunk> bufRef, int size) {
-    Preconditions.checkNotNull(bufRef);
-    Preconditions.checkArgument(size >= 0 && size <= bufRef.get().getSize());
-    mBufRef = bufRef.clone();
-    mSize = size;
-  }
-
-  /**
-   * Gets the size of the bytebuffer if it is valid. Otherwise, an exception is raised
-   * @return the size of the bytebuffer if it is not closed.
-   * @throws {@link ClosedException}
-   */
-  @Override
-  public synchronized int size() {
-    ensureValid();
-    return mSize;
-  }
-
-  @Override
-  public synchronized byte read(int offset) {
-    ensureValid();
-    Preconditions.checkArgument(offset >= 0);
-    Preconditions.checkArgument(offset < mSize);
-    return mBufRef.get().read(offset);
-  }
-
-  @Override
-  public synchronized void read(int offset, byte[] buffer, int bufferOffset, int length) {
-    ensureValid();
-    // We need to make sure that PooledByteBuffer's length is preserved.
-    // Al the other bounds checks will be performed by NativeMemoryChunk.read method.
-    Preconditions.checkArgument(offset + length <= mSize);
-    mBufRef.get().read(offset, buffer, bufferOffset, length);
-  }
-
-  @Override
-  public synchronized long getNativePtr() {
-    ensureValid();
-    return mBufRef.get().getNativePtr();
-  }
-
-  /**
-   * Check if this bytebuffer is already closed
-   * @return true if this bytebuffer is closed.
-   */
-  @Override
-  public synchronized boolean isClosed() {
-    return !CloseableReference.isValid(mBufRef);
-  }
-
-  /**
-   * Closes this instance, and releases the underlying buffer to the pool.
-   * Once the bytebuffer has been closed, subsequent operations (especially {@code getStream()} will
-   * fail.
-   * Note: It is not an error to close an already closed bytebuffer
-   */
-  @Override
-  public synchronized void close() {
-    CloseableReference.closeSafely(mBufRef);
-    mBufRef = null;
-  }
-
-  /**
-   * Validates that the bytebuffer instance is valid (aka not closed). If it is closed, then we
-   * raise a ClosedException
-   * This doesn't really need to be synchronized, but lint won't shut up otherwise
-   * @throws ClosedException
-   */
-  synchronized void ensureValid() {
-    if (isClosed()) {
-      throw new ClosedException();
+    private final int mSize;
+
+    @GuardedBy("this")
+    @VisibleForTesting
+    CloseableReference<NativeMemoryChunk> mBufRef;
+
+    public NativePooledByteBuffer(CloseableReference<NativeMemoryChunk> bufRef, int size) {
+        Preconditions.checkNotNull(bufRef);
+        Preconditions.checkArgument(size >= 0 && size <= bufRef.get().getSize());
+        mBufRef = bufRef.clone();
+        mSize = size;
+    }
+
+    /**
+     * Gets the size of the bytebuffer if it is valid. Otherwise, an exception is raised
+     *
+     * @return the size of the bytebuffer if it is not closed.
+     * @throws {@link ClosedException}
+     */
+    @Override
+    public synchronized int size() {
+        ensureValid();
+        return mSize;
+    }
+
+    @Override
+    public synchronized byte read(int offset) {
+        ensureValid();
+        Preconditions.checkArgument(offset >= 0);
+        Preconditions.checkArgument(offset < mSize);
+        return mBufRef.get().read(offset);
+    }
+
+    @Override
+    public synchronized void read(int offset, byte[] buffer, int bufferOffset, int length) {
+        ensureValid();
+        // We need to make sure that PooledByteBuffer's length is preserved.
+        // Al the other bounds checks will be performed by NativeMemoryChunk.read method.
+        Preconditions.checkArgument(offset + length <= mSize);
+        mBufRef.get().read(offset, buffer, bufferOffset, length);
+    }
+
+    @Override
+    public synchronized long getNativePtr() {
+        ensureValid();
+        return mBufRef.get().getNativePtr();
+    }
+
+    /**
+     * Check if this bytebuffer is already closed
+     *
+     * @return true if this bytebuffer is closed.
+     */
+    @Override
+    public synchronized boolean isClosed() {
+        return !CloseableReference.isValid(mBufRef);
+    }
+
+    /**
+     * Closes this instance, and releases the underlying buffer to the pool.
+     * Once the bytebuffer has been closed, subsequent operations (especially {@code getStream()} will
+     * fail.
+     * Note: It is not an error to close an already closed bytebuffer
+     */
+    @Override
+    public synchronized void close() {
+        CloseableReference.closeSafely(mBufRef);
+        mBufRef = null;
+    }
+
+    /**
+     * Validates that the bytebuffer instance is valid (aka not closed). If it is closed, then we
+     * raise a ClosedException
+     * This doesn't really need to be synchronized, but lint won't shut up otherwise
+     *
+     * @throws ClosedException
+     */
+    synchronized void ensureValid() {
+        if (isClosed()) {
+            throw new ClosedException();
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBufferFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBufferFactory.java
index 7219a194b..c50a4348f 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBufferFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBufferFactory.java
@@ -26,118 +26,124 @@
 @ThreadSafe
 public class NativePooledByteBufferFactory implements PooledByteBufferFactory {
 
-  private final PooledByteStreams mPooledByteStreams;
-  private final NativeMemoryChunkPool mPool;    // native memory pool
+    private final PooledByteStreams mPooledByteStreams;
+    private final NativeMemoryChunkPool mPool;    // native memory pool
 
-  public NativePooledByteBufferFactory(
-      NativeMemoryChunkPool pool,
-      PooledByteStreams pooledByteStreams) {
-    mPool = pool;
-    mPooledByteStreams = pooledByteStreams;
-  }
+    public NativePooledByteBufferFactory(
+            NativeMemoryChunkPool pool,
+            PooledByteStreams pooledByteStreams) {
+        mPool = pool;
+        mPooledByteStreams = pooledByteStreams;
+    }
 
-  @Override
-  public NativePooledByteBuffer newByteBuffer(int size) {
-    Preconditions.checkArgument(size > 0);
-    CloseableReference<NativeMemoryChunk> chunkRef = CloseableReference.of(mPool.get(size), mPool);
-    try {
-      return new NativePooledByteBuffer(chunkRef, size);
-    } finally {
-      chunkRef.close();
+    @Override
+    public NativePooledByteBuffer newByteBuffer(int size) {
+        Preconditions.checkArgument(size > 0);
+        CloseableReference<NativeMemoryChunk> chunkRef = CloseableReference.of(mPool.get(size), mPool);
+        try {
+            return new NativePooledByteBuffer(chunkRef, size);
+        } finally {
+            chunkRef.close();
+        }
     }
-  }
 
-  /**
-   * Creates a new NativePooledByteBuffer instance by reading in the entire contents of the
-   * input stream
-   * @param inputStream the input stream to read from
-   * @return an instance of the NativePooledByteBuffer
-   * @throws IOException
-   */
-  @Override
-  public NativePooledByteBuffer newByteBuffer(InputStream inputStream) throws IOException {
-    NativePooledByteBufferOutputStream outputStream = new NativePooledByteBufferOutputStream(mPool);
-    try {
-      return newByteBuf(inputStream, outputStream);
-    } finally {
-      outputStream.close();
+    /**
+     * Creates a new NativePooledByteBuffer instance by reading in the entire contents of the
+     * input stream
+     *
+     * @param inputStream the input stream to read from
+     * @return an instance of the NativePooledByteBuffer
+     * @throws IOException
+     */
+    @Override
+    public NativePooledByteBuffer newByteBuffer(InputStream inputStream) throws IOException {
+        NativePooledByteBufferOutputStream outputStream = new NativePooledByteBufferOutputStream(mPool);
+        try {
+            return newByteBuf(inputStream, outputStream);
+        } finally {
+            outputStream.close();
+        }
     }
-  }
 
-  /**
-   * Creates a new NativePooledByteBuffer instance by reading in the entire contents of the
-   * byte array
-   * @param bytes the byte array to read from
-   * @return an instance of the NativePooledByteBuffer
-   */
-  @Override
-  public NativePooledByteBuffer newByteBuffer(byte[] bytes) {
-    NativePooledByteBufferOutputStream outputStream =
-        new NativePooledByteBufferOutputStream(mPool, bytes.length);
-    try {
-      outputStream.write(bytes, 0, bytes.length);
-      return outputStream.toByteBuffer();
-    } catch (IOException ioe) {
-      throw Throwables.propagate(ioe);
-    } finally {
-      outputStream.close();
+    /**
+     * Creates a new NativePooledByteBuffer instance by reading in the entire contents of the
+     * byte array
+     *
+     * @param bytes the byte array to read from
+     * @return an instance of the NativePooledByteBuffer
+     */
+    @Override
+    public NativePooledByteBuffer newByteBuffer(byte[] bytes) {
+        NativePooledByteBufferOutputStream outputStream =
+                new NativePooledByteBufferOutputStream(mPool, bytes.length);
+        try {
+            outputStream.write(bytes, 0, bytes.length);
+            return outputStream.toByteBuffer();
+        } catch (IOException ioe) {
+            throw Throwables.propagate(ioe);
+        } finally {
+            outputStream.close();
+        }
     }
-  }
 
-  /**
-   * Creates a new NativePooledByteBuffer instance with an initial capacity, and reading the entire
-   * contents of the input stream
-   * @param inputStream the input stream to read from
-   * @param initialCapacity initial allocation size for the PooledByteBuffer
-   * @return an instance of NativePooledByteBuffer
-   * @throws IOException
-   */
-  @Override
-  public NativePooledByteBuffer newByteBuffer(InputStream inputStream, int initialCapacity)
-      throws IOException {
-    NativePooledByteBufferOutputStream outputStream =
-        new NativePooledByteBufferOutputStream(mPool, initialCapacity);
-    try {
-      return newByteBuf(inputStream, outputStream);
-    } finally {
-      outputStream.close();
+    /**
+     * Creates a new NativePooledByteBuffer instance with an initial capacity, and reading the entire
+     * contents of the input stream
+     *
+     * @param inputStream     the input stream to read from
+     * @param initialCapacity initial allocation size for the PooledByteBuffer
+     * @return an instance of NativePooledByteBuffer
+     * @throws IOException
+     */
+    @Override
+    public NativePooledByteBuffer newByteBuffer(InputStream inputStream, int initialCapacity)
+            throws IOException {
+        NativePooledByteBufferOutputStream outputStream =
+                new NativePooledByteBufferOutputStream(mPool, initialCapacity);
+        try {
+            return newByteBuf(inputStream, outputStream);
+        } finally {
+            outputStream.close();
+        }
     }
-  }
 
-  /**
-   * Reads all bytes from inputStream and writes them to outputStream. When all bytes
-   * are read outputStream.toByteBuffer is called and obtained NativePooledByteBuffer is returned
-   * @param inputStream the input stream to read from
-   * @param outputStream output stream used to transform content of input stream to
-   *   NativePooledByteBuffer
-   * @return an instance of NativePooledByteBuffer
-   * @throws IOException
-   */
-  @VisibleForTesting
-  NativePooledByteBuffer newByteBuf(
-      InputStream inputStream,
-      NativePooledByteBufferOutputStream outputStream)
-      throws IOException {
-    mPooledByteStreams.copy(inputStream, outputStream);
-    return outputStream.toByteBuffer();
-  }
+    /**
+     * Reads all bytes from inputStream and writes them to outputStream. When all bytes
+     * are read outputStream.toByteBuffer is called and obtained NativePooledByteBuffer is returned
+     *
+     * @param inputStream  the input stream to read from
+     * @param outputStream output stream used to transform content of input stream to
+     *                     NativePooledByteBuffer
+     * @return an instance of NativePooledByteBuffer
+     * @throws IOException
+     */
+    @VisibleForTesting
+    NativePooledByteBuffer newByteBuf(
+            InputStream inputStream,
+            NativePooledByteBufferOutputStream outputStream)
+            throws IOException {
+        mPooledByteStreams.copy(inputStream, outputStream);
+        return outputStream.toByteBuffer();
+    }
 
-  /**
-   * Creates a new NativePooledByteBufferOutputStream instance with default initial capacity
-   * @return a new NativePooledByteBufferOutputStream
-   */
-  @Override
-  public NativePooledByteBufferOutputStream newOutputStream() {
-    return new NativePooledByteBufferOutputStream(mPool);
-  }
+    /**
+     * Creates a new NativePooledByteBufferOutputStream instance with default initial capacity
+     *
+     * @return a new NativePooledByteBufferOutputStream
+     */
+    @Override
+    public NativePooledByteBufferOutputStream newOutputStream() {
+        return new NativePooledByteBufferOutputStream(mPool);
+    }
 
-  /**
-   * Creates a new NativePooledByteBufferOutputStream instance with the specified initial capacity
-   * @param initialCapacity initial allocation size for the underlying output stream
-   * @return a new NativePooledByteBufferOutputStream
-   */
-  @Override
-  public NativePooledByteBufferOutputStream newOutputStream(int initialCapacity) {
-    return new NativePooledByteBufferOutputStream(mPool, initialCapacity);
-  }
+    /**
+     * Creates a new NativePooledByteBufferOutputStream instance with the specified initial capacity
+     *
+     * @param initialCapacity initial allocation size for the underlying output stream
+     * @return a new NativePooledByteBufferOutputStream
+     */
+    @Override
+    public NativePooledByteBufferOutputStream newOutputStream(int initialCapacity) {
+        return new NativePooledByteBufferOutputStream(mPool, initialCapacity);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBufferOutputStream.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBufferOutputStream.java
index fd3bbe986..86156e7b0 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBufferOutputStream.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NativePooledByteBufferOutputStream.java
@@ -24,145 +24,152 @@
  */
 @NotThreadSafe
 public class NativePooledByteBufferOutputStream extends PooledByteBufferOutputStream {
-  private final NativeMemoryChunkPool mPool;  // the pool to allocate memory chunks from
-  private CloseableReference<NativeMemoryChunk> mBufRef; // the current chunk that we're writing to
-  private int mCount; // number of bytes 'used' in the current chunk
-
-  /**
-   * Construct a new instance of this outputstream
-   * @param pool the pool to use
-   */
-  public NativePooledByteBufferOutputStream(NativeMemoryChunkPool pool) {
-    this(pool, pool.getMinBufferSize());
-  }
-
-  /**
-   * Construct a new instance of this output stream with this initial capacity
-   * It is not an error to have this initial capacity be inaccurate. If the actual contents
-   * end up being larger than the initialCapacity, then we will reallocate memory
-   * if needed. If the actual contents are smaller, then we'll end up wasting some memory
-   * @param pool the pool to use
-   * @param initialCapacity initial capacity to allocate for this stream
-   */
-  public NativePooledByteBufferOutputStream(NativeMemoryChunkPool pool, int initialCapacity) {
-    super();
-
-    Preconditions.checkArgument(initialCapacity > 0);
-    mPool = Preconditions.checkNotNull(pool);
-    mCount = 0;
-    mBufRef = CloseableReference.of(mPool.get(initialCapacity), mPool);
-  }
-
-  /**
-   * Gets a PooledByteBuffer from the current contents. If the stream has already been closed, then
-   * an InvalidStreamException is thrown.
-   * @return a PooledByteBuffer instance for the contents of the stream
-   * @throws InvalidStreamException if the stream is invalid
-   */
-  @Override
-  public NativePooledByteBuffer toByteBuffer() {
-    ensureValid();
-    return new NativePooledByteBuffer(mBufRef, mCount);
-  }
-
-  /**
-   * Returns the total number of bytes written to this stream so far.
-   * @return the number of bytes written to this stream.
-   */
-  @Override
-  public int size() {
-    return mCount;
-  }
-
-  /**
-   * Write one byte to the underlying stream. The underlying stream MUST be valid
-   * @param oneByte the one byte to write
-   * @throws InvalidStreamException if the stream is invalid
-   * @throws IOException in case of an I/O error during the write
-   */
-  @Override
-  public void write(int oneByte) throws IOException {
-    byte[] buf = new byte[1];
-    buf[0] = (byte)oneByte;
-    this.write(buf);
-  }
-
-  /**
-   * Writes {@code count} bytes from the byte array {@code buffer} starting at
-   * position {@code offset} to this stream.
-   * The underlying stream MUST be valid
-   *
-   * @param buffer the source buffer to read from
-   * @param offset the start position in {@code buffer} from where to get bytes.
-   * @param count the number of bytes from {@code buffer} to write to this stream.
-   * @throws IOException if an error occurs while writing to this stream.
-   * @throws IndexOutOfBoundsException
-   *             if {@code offset < 0} or {@code count < 0}, or if
-   *             {@code offset + count} is bigger than the length of
-   *             {@code buffer}.
-   * @throws InvalidStreamException if the stream is invalid
-   */
-  public void write(byte[] buffer, int offset, int count) throws IOException {
-    if (offset < 0 || count < 0 || offset + count > buffer.length) {
-      throw new ArrayIndexOutOfBoundsException("length=" + buffer.length + "; regionStart=" + offset
-          + "; regionLength=" + count);
+    private final NativeMemoryChunkPool mPool;  // the pool to allocate memory chunks from
+    private CloseableReference<NativeMemoryChunk> mBufRef; // the current chunk that we're writing to
+    private int mCount; // number of bytes 'used' in the current chunk
+
+    /**
+     * Construct a new instance of this outputstream
+     *
+     * @param pool the pool to use
+     */
+    public NativePooledByteBufferOutputStream(NativeMemoryChunkPool pool) {
+        this(pool, pool.getMinBufferSize());
     }
-    ensureValid();
-    realloc(mCount + count);
-    mBufRef.get().write(mCount, buffer, offset, count);
-    mCount += count;
-  }
-
-  /**
-   * Closes the stream. Owned resources are released back to the pool. It is not allowed to call
-   * toByteBuffer after call to this method.
-   * @throws IOException
-   */
-  @Override
-  public void close() {
-    CloseableReference.closeSafely(mBufRef);
-    mBufRef = null;
-    mCount = -1;
-    super.close();
-  }
-
-  /**
-   * Reallocate the local buffer to hold the new length specified.
-   * Also copy over existing data to this new buffer
-   * @param newLength new length of buffer
-   * @throws InvalidStreamException if the stream is invalid
-   * @throws BasePool.SizeTooLargeException if the allocation from the pool fails
-   */
-  @VisibleForTesting
-  void realloc(int newLength) {
-    ensureValid();
+
+    /**
+     * Construct a new instance of this output stream with this initial capacity
+     * It is not an error to have this initial capacity be inaccurate. If the actual contents
+     * end up being larger than the initialCapacity, then we will reallocate memory
+     * if needed. If the actual contents are smaller, then we'll end up wasting some memory
+     *
+     * @param pool            the pool to use
+     * @param initialCapacity initial capacity to allocate for this stream
+     */
+    public NativePooledByteBufferOutputStream(NativeMemoryChunkPool pool, int initialCapacity) {
+        super();
+
+        Preconditions.checkArgument(initialCapacity > 0);
+        mPool = Preconditions.checkNotNull(pool);
+        mCount = 0;
+        mBufRef = CloseableReference.of(mPool.get(initialCapacity), mPool);
+    }
+
+    /**
+     * Gets a PooledByteBuffer from the current contents. If the stream has already been closed, then
+     * an InvalidStreamException is thrown.
+     *
+     * @return a PooledByteBuffer instance for the contents of the stream
+     * @throws InvalidStreamException if the stream is invalid
+     */
+    @Override
+    public NativePooledByteBuffer toByteBuffer() {
+        ensureValid();
+        return new NativePooledByteBuffer(mBufRef, mCount);
+    }
+
+    /**
+     * Returns the total number of bytes written to this stream so far.
+     *
+     * @return the number of bytes written to this stream.
+     */
+    @Override
+    public int size() {
+        return mCount;
+    }
+
+    /**
+     * Write one byte to the underlying stream. The underlying stream MUST be valid
+     *
+     * @param oneByte the one byte to write
+     * @throws InvalidStreamException if the stream is invalid
+     * @throws IOException            in case of an I/O error during the write
+     */
+    @Override
+    public void write(int oneByte) throws IOException {
+        byte[] buf = new byte[1];
+        buf[0] = (byte) oneByte;
+        this.write(buf);
+    }
+
+    /**
+     * Writes {@code count} bytes from the byte array {@code buffer} starting at
+     * position {@code offset} to this stream.
+     * The underlying stream MUST be valid
+     *
+     * @param buffer the source buffer to read from
+     * @param offset the start position in {@code buffer} from where to get bytes.
+     * @param count  the number of bytes from {@code buffer} to write to this stream.
+     * @throws IOException               if an error occurs while writing to this stream.
+     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code count < 0}, or if
+     *                                   {@code offset + count} is bigger than the length of
+     *                                   {@code buffer}.
+     * @throws InvalidStreamException    if the stream is invalid
+     */
+    public void write(byte[] buffer, int offset, int count) throws IOException {
+        if (offset < 0 || count < 0 || offset + count > buffer.length) {
+            throw new ArrayIndexOutOfBoundsException("length=" + buffer.length + "; regionStart=" + offset
+                    + "; regionLength=" + count);
+        }
+        ensureValid();
+        realloc(mCount + count);
+        mBufRef.get().write(mCount, buffer, offset, count);
+        mCount += count;
+    }
+
+    /**
+     * Closes the stream. Owned resources are released back to the pool. It is not allowed to call
+     * toByteBuffer after call to this method.
+     *
+     * @throws IOException
+     */
+    @Override
+    public void close() {
+        CloseableReference.closeSafely(mBufRef);
+        mBufRef = null;
+        mCount = -1;
+        super.close();
+    }
+
+    /**
+     * Reallocate the local buffer to hold the new length specified.
+     * Also copy over existing data to this new buffer
+     *
+     * @param newLength new length of buffer
+     * @throws InvalidStreamException         if the stream is invalid
+     * @throws BasePool.SizeTooLargeException if the allocation from the pool fails
+     */
+    @VisibleForTesting
+    void realloc(int newLength) {
+        ensureValid();
     /* Can the buffer handle @i more bytes, if not expand it */
-    if (newLength <= mBufRef.get().getSize()) {
-      return;
+        if (newLength <= mBufRef.get().getSize()) {
+            return;
+        }
+        NativeMemoryChunk newbuf = mPool.get(newLength);
+        mBufRef.get().copy(0, newbuf, 0, mCount);
+        mBufRef.close();
+        mBufRef = CloseableReference.of(newbuf, mPool);
     }
-    NativeMemoryChunk newbuf = mPool.get(newLength);
-    mBufRef.get().copy(0, newbuf, 0, mCount);
-    mBufRef.close();
-    mBufRef = CloseableReference.of(newbuf, mPool);
-  }
-
-  /**
-   * Ensure that the current stream is valid, that is underlying closeable reference is not null
-   * and is valid
-   * @throws InvalidStreamException if the stream is invalid
-   */
-  private void ensureValid() {
-    if (!CloseableReference.isValid(mBufRef)) {
-      throw new InvalidStreamException();
+
+    /**
+     * Ensure that the current stream is valid, that is underlying closeable reference is not null
+     * and is valid
+     *
+     * @throws InvalidStreamException if the stream is invalid
+     */
+    private void ensureValid() {
+        if (!CloseableReference.isValid(mBufRef)) {
+            throw new InvalidStreamException();
+        }
     }
-  }
-
-  /**
-   * An exception indicating that this stream is no longer valid
-   */
-  public static class InvalidStreamException extends RuntimeException {
-    public InvalidStreamException() {
-      super("OutputStream no longer valid");
+
+    /**
+     * An exception indicating that this stream is no longer valid
+     */
+    public static class InvalidStreamException extends RuntimeException {
+        public InvalidStreamException() {
+            super("OutputStream no longer valid");
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NoOpPoolStatsTracker.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NoOpPoolStatsTracker.java
index 24e7a2b25..893cb0e0a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NoOpPoolStatsTracker.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/NoOpPoolStatsTracker.java
@@ -13,43 +13,43 @@
  * Empty implementation of PoolStatsTracker that does not perform any tracking.
  */
 public class NoOpPoolStatsTracker implements PoolStatsTracker {
-  private static NoOpPoolStatsTracker sInstance = null;
+    private static NoOpPoolStatsTracker sInstance = null;
 
-  private NoOpPoolStatsTracker() {
-  }
+    private NoOpPoolStatsTracker() {
+    }
 
-  public static synchronized NoOpPoolStatsTracker getInstance() {
-    if (sInstance == null) {
-      sInstance = new NoOpPoolStatsTracker();
+    public static synchronized NoOpPoolStatsTracker getInstance() {
+        if (sInstance == null) {
+            sInstance = new NoOpPoolStatsTracker();
+        }
+        return sInstance;
     }
-    return sInstance;
-  }
 
-  @Override
-  public void setBasePool(BasePool basePool) {
-  }
+    @Override
+    public void setBasePool(BasePool basePool) {
+    }
 
-  @Override
-  public void onValueReuse(int bucketedSize) {
-  }
+    @Override
+    public void onValueReuse(int bucketedSize) {
+    }
 
-  @Override
-  public void onSoftCapReached() {
-  }
+    @Override
+    public void onSoftCapReached() {
+    }
 
-  @Override
-  public void onHardCapReached() {
-  }
+    @Override
+    public void onHardCapReached() {
+    }
 
-  @Override
-  public void onAlloc(int size) {
-  }
+    @Override
+    public void onAlloc(int size) {
+    }
 
-  @Override
-  public void onFree(int sizeInBytes) {
-  }
+    @Override
+    public void onFree(int sizeInBytes) {
+    }
 
-  @Override
-  public void onValueRelease(int sizeInBytes) {
-  }
+    @Override
+    public void onValueRelease(int sizeInBytes) {
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Pool.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Pool.java
index 58a7f93bc..3ef985832 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Pool.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/Pool.java
@@ -27,20 +27,22 @@
  */
 public interface Pool<V> extends ResourceReleaser<V>, MemoryTrimmable {
 
-  /**
-   * Gets a 'value' of size 'S' (or larger) from the pool, if available.
-   * Allocates a new value if necessary.
-   * @param size the logical size to allocate
-   * @return a new value
-   */
-  public V get(int size);
+    /**
+     * Gets a 'value' of size 'S' (or larger) from the pool, if available.
+     * Allocates a new value if necessary.
+     *
+     * @param size the logical size to allocate
+     * @return a new value
+     */
+    public V get(int size);
 
-  /**
-   * Releases the given value to the pool.
-   * The pool may decide to
-   *  - reuse the value (for future {@link #get(int)} operations OR
-   *  - 'free' the value
-   * @param value the value to release to the pool
-   */
-  public void release(V value);
+    /**
+     * Releases the given value to the pool.
+     * The pool may decide to
+     * - reuse the value (for future {@link #get(int)} operations OR
+     * - 'free' the value
+     *
+     * @param value the value to release to the pool
+     */
+    public void release(V value);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolConfig.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolConfig.java
index baab25cd0..7026ca475 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolConfig.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolConfig.java
@@ -18,150 +18,150 @@
  */
 public class PoolConfig {
 
-  // There are a lot of parameters in this class. Please follow strict alphabetical order.
-
-  private final PoolParams mBitmapPoolParams;
-  private final PoolStatsTracker mBitmapPoolStatsTracker;
-  private final PoolParams mCommonByteArrayPoolParams;
-  private final PoolStatsTracker mCommonByteArrayPoolStatsTracker;
-  private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;
-  private final PoolParams mNativeMemoryChunkPoolParams;
-  private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;
-  private final PoolParams mSharedByteArrayParams;
-
-  private PoolConfig(Builder builder) {
-    mBitmapPoolParams =
-        builder.mBitmapPoolParams == null ?
-            DefaultBitmapPoolParams.get() :
-            builder.mBitmapPoolParams;
-    mBitmapPoolStatsTracker =
-        builder.mBitmapPoolStatsTracker == null ?
-            NoOpPoolStatsTracker.getInstance() :
-            builder.mBitmapPoolStatsTracker;
-    mCommonByteArrayPoolParams =
-        builder.mCommonByteArrayPoolParams == null ?
-            DefaultByteArrayPoolParams.get() :
-            builder.mCommonByteArrayPoolParams;
-    mCommonByteArrayPoolStatsTracker =
-        builder.mCommonByteArrayPoolStatsTracker == null ?
-            NoOpPoolStatsTracker.getInstance() :
-            builder.mCommonByteArrayPoolStatsTracker;
-    mMemoryTrimmableRegistry =
-        builder.mMemoryTrimmableRegistry == null ?
-            NoOpMemoryTrimmableRegistry.getInstance() :
-            builder.mMemoryTrimmableRegistry;
-    mNativeMemoryChunkPoolParams =
-        builder.mNativeMemoryChunkPoolParams == null ?
-            DefaultNativeMemoryChunkPoolParams.get() :
-            builder.mNativeMemoryChunkPoolParams;
-    mNativeMemoryChunkPoolStatsTracker =
-        builder.mNativeMemoryChunkPoolStatsTracker == null ?
-            NoOpPoolStatsTracker.getInstance() :
-            builder.mNativeMemoryChunkPoolStatsTracker;
-    mSharedByteArrayParams =
-        builder.mSharedByteArrayParams == null ?
-            DefaultSharedByteArrayParams.get() :
-            builder.mSharedByteArrayParams;
-  }
-
-  public PoolParams getBitmapPoolParams() {
-    return mBitmapPoolParams;
-  }
-
-  public PoolStatsTracker getBitmapPoolStatsTracker() {
-    return mBitmapPoolStatsTracker;
-  }
-
-  public PoolParams getCommonByteArrayPoolParams() {
-    return mCommonByteArrayPoolParams;
-  }
-
-  public PoolStatsTracker getCommonByteArrayPoolStatsTracker() {
-    return mCommonByteArrayPoolStatsTracker;
-  }
-
-  public MemoryTrimmableRegistry getMemoryTrimmableRegistry() {
-    return mMemoryTrimmableRegistry;
-  }
-
-  public PoolParams getNativeMemoryChunkPoolParams() {
-    return mNativeMemoryChunkPoolParams;
-  }
-
-  public PoolStatsTracker getNativeMemoryChunkPoolStatsTracker() {
-    return mNativeMemoryChunkPoolStatsTracker;
-  }
-
-  public PoolParams getSharedByteArrayParams() {
-    return mSharedByteArrayParams;
-  }
-
-
-  public static Builder newBuilder() {
-    return new Builder();
-  }
-
-  public static class Builder {
-
-    private PoolParams mBitmapPoolParams;
-    private PoolStatsTracker mBitmapPoolStatsTracker;
-    private PoolParams mCommonByteArrayPoolParams;
-    private PoolStatsTracker mCommonByteArrayPoolStatsTracker;
-    private MemoryTrimmableRegistry mMemoryTrimmableRegistry;
-    private PoolParams mNativeMemoryChunkPoolParams;
-    private PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;
-    private PoolParams mSharedByteArrayParams;
-
-    private Builder() {
+    // There are a lot of parameters in this class. Please follow strict alphabetical order.
+
+    private final PoolParams mBitmapPoolParams;
+    private final PoolStatsTracker mBitmapPoolStatsTracker;
+    private final PoolParams mCommonByteArrayPoolParams;
+    private final PoolStatsTracker mCommonByteArrayPoolStatsTracker;
+    private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;
+    private final PoolParams mNativeMemoryChunkPoolParams;
+    private final PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;
+    private final PoolParams mSharedByteArrayParams;
+
+    private PoolConfig(Builder builder) {
+        mBitmapPoolParams =
+                builder.mBitmapPoolParams == null ?
+                        DefaultBitmapPoolParams.get() :
+                        builder.mBitmapPoolParams;
+        mBitmapPoolStatsTracker =
+                builder.mBitmapPoolStatsTracker == null ?
+                        NoOpPoolStatsTracker.getInstance() :
+                        builder.mBitmapPoolStatsTracker;
+        mCommonByteArrayPoolParams =
+                builder.mCommonByteArrayPoolParams == null ?
+                        DefaultByteArrayPoolParams.get() :
+                        builder.mCommonByteArrayPoolParams;
+        mCommonByteArrayPoolStatsTracker =
+                builder.mCommonByteArrayPoolStatsTracker == null ?
+                        NoOpPoolStatsTracker.getInstance() :
+                        builder.mCommonByteArrayPoolStatsTracker;
+        mMemoryTrimmableRegistry =
+                builder.mMemoryTrimmableRegistry == null ?
+                        NoOpMemoryTrimmableRegistry.getInstance() :
+                        builder.mMemoryTrimmableRegistry;
+        mNativeMemoryChunkPoolParams =
+                builder.mNativeMemoryChunkPoolParams == null ?
+                        DefaultNativeMemoryChunkPoolParams.get() :
+                        builder.mNativeMemoryChunkPoolParams;
+        mNativeMemoryChunkPoolStatsTracker =
+                builder.mNativeMemoryChunkPoolStatsTracker == null ?
+                        NoOpPoolStatsTracker.getInstance() :
+                        builder.mNativeMemoryChunkPoolStatsTracker;
+        mSharedByteArrayParams =
+                builder.mSharedByteArrayParams == null ?
+                        DefaultSharedByteArrayParams.get() :
+                        builder.mSharedByteArrayParams;
     }
 
-    public Builder setBitmapPoolParams(PoolParams bitmapPoolParams) {
-      mBitmapPoolParams = Preconditions.checkNotNull(bitmapPoolParams);
-      return this;
+    public PoolParams getBitmapPoolParams() {
+        return mBitmapPoolParams;
     }
 
-    public Builder setBitmapPoolStatsTracker(
-        PoolStatsTracker bitmapPoolStatsTracker) {
-      mBitmapPoolStatsTracker = Preconditions.checkNotNull(bitmapPoolStatsTracker);
-      return this;
+    public PoolStatsTracker getBitmapPoolStatsTracker() {
+        return mBitmapPoolStatsTracker;
     }
 
-    public Builder setCommonByteArrayPoolParams(PoolParams commonByteArrayPoolParams) {
-      mCommonByteArrayPoolParams = Preconditions.checkNotNull(commonByteArrayPoolParams);
-      return this;
+    public PoolParams getCommonByteArrayPoolParams() {
+        return mCommonByteArrayPoolParams;
     }
 
-    public Builder setCommonByteArrayPoolStatsTracker(
-        PoolStatsTracker commonByteArrayPoolStatsTracker) {
-      mCommonByteArrayPoolStatsTracker =
-          Preconditions.checkNotNull(commonByteArrayPoolStatsTracker);
-      return this;
+    public PoolStatsTracker getCommonByteArrayPoolStatsTracker() {
+        return mCommonByteArrayPoolStatsTracker;
     }
 
-    public Builder setMemoryTrimmableRegistry(MemoryTrimmableRegistry memoryTrimmableRegistry) {
-      mMemoryTrimmableRegistry = memoryTrimmableRegistry;
-      return this;
+    public MemoryTrimmableRegistry getMemoryTrimmableRegistry() {
+        return mMemoryTrimmableRegistry;
     }
 
-    public Builder setNativeMemoryChunkPoolParams(PoolParams nativeMemoryChunkPoolParams) {
-      mNativeMemoryChunkPoolParams = Preconditions.checkNotNull(nativeMemoryChunkPoolParams);
-      return this;
+    public PoolParams getNativeMemoryChunkPoolParams() {
+        return mNativeMemoryChunkPoolParams;
     }
 
-    public Builder setNativeMemoryChunkPoolStatsTracker(
-        PoolStatsTracker nativeMemoryChunkPoolStatsTracker) {
-      mNativeMemoryChunkPoolStatsTracker =
-          Preconditions.checkNotNull(nativeMemoryChunkPoolStatsTracker);
-      return this;
+    public PoolStatsTracker getNativeMemoryChunkPoolStatsTracker() {
+        return mNativeMemoryChunkPoolStatsTracker;
     }
 
-    public Builder setSharedByteArrayParams(PoolParams sharedByteArrayParams) {
-      mSharedByteArrayParams = sharedByteArrayParams;
-      return this;
+    public PoolParams getSharedByteArrayParams() {
+        return mSharedByteArrayParams;
     }
 
-    public PoolConfig build() {
-      return new PoolConfig(this);
+
+    public static Builder newBuilder() {
+        return new Builder();
+    }
+
+    public static class Builder {
+
+        private PoolParams mBitmapPoolParams;
+        private PoolStatsTracker mBitmapPoolStatsTracker;
+        private PoolParams mCommonByteArrayPoolParams;
+        private PoolStatsTracker mCommonByteArrayPoolStatsTracker;
+        private MemoryTrimmableRegistry mMemoryTrimmableRegistry;
+        private PoolParams mNativeMemoryChunkPoolParams;
+        private PoolStatsTracker mNativeMemoryChunkPoolStatsTracker;
+        private PoolParams mSharedByteArrayParams;
+
+        private Builder() {
+        }
+
+        public Builder setBitmapPoolParams(PoolParams bitmapPoolParams) {
+            mBitmapPoolParams = Preconditions.checkNotNull(bitmapPoolParams);
+            return this;
+        }
+
+        public Builder setBitmapPoolStatsTracker(
+                PoolStatsTracker bitmapPoolStatsTracker) {
+            mBitmapPoolStatsTracker = Preconditions.checkNotNull(bitmapPoolStatsTracker);
+            return this;
+        }
+
+        public Builder setCommonByteArrayPoolParams(PoolParams commonByteArrayPoolParams) {
+            mCommonByteArrayPoolParams = Preconditions.checkNotNull(commonByteArrayPoolParams);
+            return this;
+        }
+
+        public Builder setCommonByteArrayPoolStatsTracker(
+                PoolStatsTracker commonByteArrayPoolStatsTracker) {
+            mCommonByteArrayPoolStatsTracker =
+                    Preconditions.checkNotNull(commonByteArrayPoolStatsTracker);
+            return this;
+        }
+
+        public Builder setMemoryTrimmableRegistry(MemoryTrimmableRegistry memoryTrimmableRegistry) {
+            mMemoryTrimmableRegistry = memoryTrimmableRegistry;
+            return this;
+        }
+
+        public Builder setNativeMemoryChunkPoolParams(PoolParams nativeMemoryChunkPoolParams) {
+            mNativeMemoryChunkPoolParams = Preconditions.checkNotNull(nativeMemoryChunkPoolParams);
+            return this;
+        }
+
+        public Builder setNativeMemoryChunkPoolStatsTracker(
+                PoolStatsTracker nativeMemoryChunkPoolStatsTracker) {
+            mNativeMemoryChunkPoolStatsTracker =
+                    Preconditions.checkNotNull(nativeMemoryChunkPoolStatsTracker);
+            return this;
+        }
+
+        public Builder setSharedByteArrayParams(PoolParams sharedByteArrayParams) {
+            mSharedByteArrayParams = sharedByteArrayParams;
+            return this;
+        }
+
+        public PoolConfig build() {
+            return new PoolConfig(this);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolFactory.java
index f522c807b..f4a7f23a8 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolFactory.java
@@ -19,71 +19,71 @@
 @NotThreadSafe
 public class PoolFactory {
 
-  private final PoolConfig mConfig;
+    private final PoolConfig mConfig;
 
-  private BitmapPool mBitmapPool;
-  private ByteArrayPool mCommonByteArrayPool;
-  private NativeMemoryChunkPool mNativeMemoryChunkPool;
-  private PooledByteBufferFactory mPooledByteBufferFactory;
-  private PooledByteStreams mPooledByteStreams;
-  private SharedByteArray mSharedByteArray;
+    private BitmapPool mBitmapPool;
+    private ByteArrayPool mCommonByteArrayPool;
+    private NativeMemoryChunkPool mNativeMemoryChunkPool;
+    private PooledByteBufferFactory mPooledByteBufferFactory;
+    private PooledByteStreams mPooledByteStreams;
+    private SharedByteArray mSharedByteArray;
 
-  public PoolFactory(PoolConfig config) {
-    mConfig = Preconditions.checkNotNull(config);
-  }
+    public PoolFactory(PoolConfig config) {
+        mConfig = Preconditions.checkNotNull(config);
+    }
 
-  public BitmapPool getBitmapPool() {
-    if (mBitmapPool == null) {
-      mBitmapPool = new BitmapPool(
-          mConfig.getMemoryTrimmableRegistry(),
-          mConfig.getBitmapPoolParams(),
-          mConfig.getBitmapPoolStatsTracker());
+    public BitmapPool getBitmapPool() {
+        if (mBitmapPool == null) {
+            mBitmapPool = new BitmapPool(
+                    mConfig.getMemoryTrimmableRegistry(),
+                    mConfig.getBitmapPoolParams(),
+                    mConfig.getBitmapPoolStatsTracker());
+        }
+        return mBitmapPool;
     }
-    return mBitmapPool;
-  }
 
-  public ByteArrayPool getCommonByteArrayPool() {
-    if (mCommonByteArrayPool == null) {
-      mCommonByteArrayPool = new GenericByteArrayPool(
-          mConfig.getMemoryTrimmableRegistry(),
-          mConfig.getCommonByteArrayPoolParams(),
-          mConfig.getCommonByteArrayPoolStatsTracker());
+    public ByteArrayPool getCommonByteArrayPool() {
+        if (mCommonByteArrayPool == null) {
+            mCommonByteArrayPool = new GenericByteArrayPool(
+                    mConfig.getMemoryTrimmableRegistry(),
+                    mConfig.getCommonByteArrayPoolParams(),
+                    mConfig.getCommonByteArrayPoolStatsTracker());
+        }
+        return mCommonByteArrayPool;
     }
-    return mCommonByteArrayPool;
-  }
 
-  public NativeMemoryChunkPool getNativeMemoryChunkPool() {
-    if (mNativeMemoryChunkPool == null) {
-      mNativeMemoryChunkPool = new NativeMemoryChunkPool(
-          mConfig.getMemoryTrimmableRegistry(),
-          mConfig.getNativeMemoryChunkPoolParams(),
-          mConfig.getNativeMemoryChunkPoolStatsTracker());
+    public NativeMemoryChunkPool getNativeMemoryChunkPool() {
+        if (mNativeMemoryChunkPool == null) {
+            mNativeMemoryChunkPool = new NativeMemoryChunkPool(
+                    mConfig.getMemoryTrimmableRegistry(),
+                    mConfig.getNativeMemoryChunkPoolParams(),
+                    mConfig.getNativeMemoryChunkPoolStatsTracker());
+        }
+        return mNativeMemoryChunkPool;
     }
-    return mNativeMemoryChunkPool;
-  }
 
-  public PooledByteBufferFactory getPooledByteBufferFactory() {
-    if (mPooledByteBufferFactory == null) {
-      mPooledByteBufferFactory = new NativePooledByteBufferFactory(
-          getNativeMemoryChunkPool(),
-          getPooledByteStreams());
+    public PooledByteBufferFactory getPooledByteBufferFactory() {
+        if (mPooledByteBufferFactory == null) {
+            mPooledByteBufferFactory = new NativePooledByteBufferFactory(
+                    getNativeMemoryChunkPool(),
+                    getPooledByteStreams());
+        }
+        return mPooledByteBufferFactory;
     }
-    return mPooledByteBufferFactory;
-  }
 
-  public PooledByteStreams getPooledByteStreams() {
-    if (mPooledByteStreams == null) {
-      mPooledByteStreams = new PooledByteStreams(getCommonByteArrayPool());
+    public PooledByteStreams getPooledByteStreams() {
+        if (mPooledByteStreams == null) {
+            mPooledByteStreams = new PooledByteStreams(getCommonByteArrayPool());
+        }
+        return mPooledByteStreams;
     }
-    return mPooledByteStreams;
-  }
 
-  public SharedByteArray getSharedByteArray() {
-    if (mSharedByteArray == null) {
-      mSharedByteArray = new SharedByteArray(
-          mConfig.getMemoryTrimmableRegistry(),
-          mConfig.getSharedByteArrayParams());
+    public SharedByteArray getSharedByteArray() {
+        if (mSharedByteArray == null) {
+            mSharedByteArray = new SharedByteArray(
+                    mConfig.getMemoryTrimmableRegistry(),
+                    mConfig.getSharedByteArrayParams());
+        }
+        return mSharedByteArray;
     }
-    return mSharedByteArray;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolParams.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolParams.java
index f28be82b0..6237987fe 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolParams.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolParams.java
@@ -48,50 +48,53 @@
  * thrown.
  */
 public class PoolParams {
-  public final int maxSizeHardCap;
-  public final int maxSizeSoftCap;
-  public final SparseIntArray bucketSizes;
-  public final int minBucketSize;
-  public final int maxBucketSize;
+    public final int maxSizeHardCap;
+    public final int maxSizeSoftCap;
+    public final SparseIntArray bucketSizes;
+    public final int minBucketSize;
+    public final int maxBucketSize;
 
-  /**
-   * Set up pool params
-   * @param maxSize soft-cap and hard-cap on size of the pool
-   * @param bucketSizes (optional) bucket sizes and lengths for the pool
-   */
-  public PoolParams(int maxSize, @Nullable SparseIntArray bucketSizes) {
-    this(maxSize, maxSize, bucketSizes, 0, Integer.MAX_VALUE);
-  }
+    /**
+     * Set up pool params
+     *
+     * @param maxSize     soft-cap and hard-cap on size of the pool
+     * @param bucketSizes (optional) bucket sizes and lengths for the pool
+     */
+    public PoolParams(int maxSize, @Nullable SparseIntArray bucketSizes) {
+        this(maxSize, maxSize, bucketSizes, 0, Integer.MAX_VALUE);
+    }
 
-  /**
-   * Set up pool params
-   * @param maxSizeSoftCap soft cap on max size of the pool
-   * @param maxSizeHardCap hard cap on max size of the pool
-   * @param bucketSizes (optional) bucket sizes and lengths for the pool
-   */
-  public PoolParams(int maxSizeSoftCap, int maxSizeHardCap, @Nullable SparseIntArray bucketSizes) {
-    this(maxSizeSoftCap, maxSizeHardCap, bucketSizes, 0, Integer.MAX_VALUE);
-  }
+    /**
+     * Set up pool params
+     *
+     * @param maxSizeSoftCap soft cap on max size of the pool
+     * @param maxSizeHardCap hard cap on max size of the pool
+     * @param bucketSizes    (optional) bucket sizes and lengths for the pool
+     */
+    public PoolParams(int maxSizeSoftCap, int maxSizeHardCap, @Nullable SparseIntArray bucketSizes) {
+        this(maxSizeSoftCap, maxSizeHardCap, bucketSizes, 0, Integer.MAX_VALUE);
+    }
 
-  /**
-   * Set up pool params
-   * @param maxSizeSoftCap soft cap on max size of the pool
-   * @param maxSizeHardCap hard cap on max size of the pool
-   * @param bucketSizes (optional) bucket sizes and lengths for the pool
-   * @param minBucketSize min bucket size for the pool
-   * @param maxBucketSize max bucket size for the pool
-   */
-  public PoolParams(
-      int maxSizeSoftCap,
-      int maxSizeHardCap,
-      @Nullable SparseIntArray bucketSizes,
-      int minBucketSize,
-      int maxBucketSize) {
-    Preconditions.checkState(maxSizeSoftCap >= 0 && maxSizeHardCap >= maxSizeSoftCap);
-    this.maxSizeSoftCap = maxSizeSoftCap;
-    this.maxSizeHardCap = maxSizeHardCap;
-    this.bucketSizes = bucketSizes;
-    this.minBucketSize = minBucketSize;
-    this.maxBucketSize = maxBucketSize;
-  }
+    /**
+     * Set up pool params
+     *
+     * @param maxSizeSoftCap soft cap on max size of the pool
+     * @param maxSizeHardCap hard cap on max size of the pool
+     * @param bucketSizes    (optional) bucket sizes and lengths for the pool
+     * @param minBucketSize  min bucket size for the pool
+     * @param maxBucketSize  max bucket size for the pool
+     */
+    public PoolParams(
+            int maxSizeSoftCap,
+            int maxSizeHardCap,
+            @Nullable SparseIntArray bucketSizes,
+            int minBucketSize,
+            int maxBucketSize) {
+        Preconditions.checkState(maxSizeSoftCap >= 0 && maxSizeHardCap >= maxSizeSoftCap);
+        this.maxSizeSoftCap = maxSizeSoftCap;
+        this.maxSizeHardCap = maxSizeHardCap;
+        this.bucketSizes = bucketSizes;
+        this.minBucketSize = minBucketSize;
+        this.maxBucketSize = maxBucketSize;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolStatsTracker.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolStatsTracker.java
index f132b834e..0a719bcff 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolStatsTracker.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PoolStatsTracker.java
@@ -13,25 +13,25 @@
  * Listener that logs pool statistics.
  */
 public interface PoolStatsTracker {
-  public static final String BUCKETS_USED_PREFIX = "buckets_used_";
-  public static final String USED_COUNT = "used_count";
-  public static final String USED_BYTES = "used_bytes";
-  public static final String FREE_COUNT = "free_count";
-  public static final String FREE_BYTES = "free_bytes";
-  public static final String SOFT_CAP = "soft_cap";
-  public static final String HARD_CAP = "hard_cap";
+    public static final String BUCKETS_USED_PREFIX = "buckets_used_";
+    public static final String USED_COUNT = "used_count";
+    public static final String USED_BYTES = "used_bytes";
+    public static final String FREE_COUNT = "free_count";
+    public static final String FREE_BYTES = "free_bytes";
+    public static final String SOFT_CAP = "soft_cap";
+    public static final String HARD_CAP = "hard_cap";
 
-  public void setBasePool(BasePool basePool);
+    public void setBasePool(BasePool basePool);
 
-  public void onValueReuse(int bucketedSize);
+    public void onValueReuse(int bucketedSize);
 
-  public void onSoftCapReached();
+    public void onSoftCapReached();
 
-  public void onHardCapReached();
+    public void onHardCapReached();
 
-  public void onAlloc(int size);
+    public void onAlloc(int size);
 
-  public void onFree(int sizeInBytes);
+    public void onFree(int sizeInBytes);
 
-  public void onValueRelease(int sizeInBytes);
+    public void onValueRelease(int sizeInBytes);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStream.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStream.java
index 64fa5fa5e..c54056e17 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStream.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStream.java
@@ -20,134 +20,134 @@
 
 /**
  * InputStream that wraps another input stream and buffers all reads.
- *
+ * <p>
  * <p> For purpose of buffering a byte array is used. It is provided during construction time
  * together with ResourceReleaser responsible for releasing it when the stream is closed.
  */
 @NotThreadSafe
 public class PooledByteArrayBufferedInputStream extends InputStream {
 
-  private static final String TAG = "PooledByteInputStream";
-
-  private final InputStream mInputStream;
-  private final byte[] mByteArray;
-  private final ResourceReleaser<byte[]> mResourceReleaser;
-
-  /**
-   * how many bytes in mByteArray were set by last call to mInputStream.read
-   */
-  private int mBufferedSize;
-  /**
-   * position of next buffered byte in mByteArray to be read
-   *
-   * <p> invariant: 0 <= mBufferOffset <= mBufferedSize
-   */
-  private int mBufferOffset;
-
-  private boolean mClosed;
-
-  public PooledByteArrayBufferedInputStream(
-      InputStream inputStream,
-      byte[] byteArray,
-      ResourceReleaser<byte[]> resourceReleaser) {
-    mInputStream = Preconditions.checkNotNull(inputStream);
-    mByteArray = Preconditions.checkNotNull(byteArray);
-    mResourceReleaser = Preconditions.checkNotNull(resourceReleaser);
-    mBufferedSize = 0;
-    mBufferOffset = 0;
-    mClosed = false;
-  }
-
-  @Override
-  public int read() throws IOException {
-    Preconditions.checkState(mBufferOffset <= mBufferedSize);
-    ensureNotClosed();
-    if (!ensureDataInBuffer()) {
-      return -1;
+    private static final String TAG = "PooledByteInputStream";
+
+    private final InputStream mInputStream;
+    private final byte[] mByteArray;
+    private final ResourceReleaser<byte[]> mResourceReleaser;
+
+    /**
+     * how many bytes in mByteArray were set by last call to mInputStream.read
+     */
+    private int mBufferedSize;
+    /**
+     * position of next buffered byte in mByteArray to be read
+     * <p>
+     * <p> invariant: 0 <= mBufferOffset <= mBufferedSize
+     */
+    private int mBufferOffset;
+
+    private boolean mClosed;
+
+    public PooledByteArrayBufferedInputStream(
+            InputStream inputStream,
+            byte[] byteArray,
+            ResourceReleaser<byte[]> resourceReleaser) {
+        mInputStream = Preconditions.checkNotNull(inputStream);
+        mByteArray = Preconditions.checkNotNull(byteArray);
+        mResourceReleaser = Preconditions.checkNotNull(resourceReleaser);
+        mBufferedSize = 0;
+        mBufferOffset = 0;
+        mClosed = false;
     }
 
-    return mByteArray[mBufferOffset++] & 0xFF;
-  }
+    @Override
+    public int read() throws IOException {
+        Preconditions.checkState(mBufferOffset <= mBufferedSize);
+        ensureNotClosed();
+        if (!ensureDataInBuffer()) {
+            return -1;
+        }
 
-  @Override
-  public int read(byte[] buffer, int offset, int length) throws IOException {
-    Preconditions.checkState(mBufferOffset <= mBufferedSize);
-    ensureNotClosed();
-    if (!ensureDataInBuffer()) {
-      return -1;
+        return mByteArray[mBufferOffset++] & 0xFF;
     }
 
-    final int bytesToRead = Math.min(mBufferedSize - mBufferOffset, length);
-    System.arraycopy(mByteArray, mBufferOffset, buffer, offset, bytesToRead);
-    mBufferOffset += bytesToRead;
-    return bytesToRead;
-  }
-
-  @Override
-  public int available() throws IOException {
-    Preconditions.checkState(mBufferOffset <= mBufferedSize);
-    ensureNotClosed();
-    return mBufferedSize - mBufferOffset + mInputStream.available();
-  }
-
-  @Override
-  public void close() throws IOException {
-    if (!mClosed) {
-      mClosed = true;
-      mResourceReleaser.release(mByteArray);
-      super.close();
+    @Override
+    public int read(byte[] buffer, int offset, int length) throws IOException {
+        Preconditions.checkState(mBufferOffset <= mBufferedSize);
+        ensureNotClosed();
+        if (!ensureDataInBuffer()) {
+            return -1;
+        }
+
+        final int bytesToRead = Math.min(mBufferedSize - mBufferOffset, length);
+        System.arraycopy(mByteArray, mBufferOffset, buffer, offset, bytesToRead);
+        mBufferOffset += bytesToRead;
+        return bytesToRead;
     }
-  }
-
-  @Override
-  public long skip(long byteCount) throws IOException {
-    Preconditions.checkState(mBufferOffset <= mBufferedSize);
-    ensureNotClosed();
-    final int bytesLeftInBuffer = mBufferedSize - mBufferOffset;
-    if (bytesLeftInBuffer >= byteCount) {
-      mBufferOffset += byteCount;
-      return byteCount;
+
+    @Override
+    public int available() throws IOException {
+        Preconditions.checkState(mBufferOffset <= mBufferedSize);
+        ensureNotClosed();
+        return mBufferedSize - mBufferOffset + mInputStream.available();
     }
 
-    mBufferOffset = mBufferedSize;
-    return bytesLeftInBuffer + mInputStream.skip(byteCount - bytesLeftInBuffer);
-  }
-
-  /**
-   * Checks if there is some data left in the buffer. If not but buffered stream still has some
-   * data to be read, then more data is buffered.
-   *
-   * @return false if and only if there is no more data and underlying input stream has no more data
-   *   to be read
-   * @throws IOException
-   */
-  private boolean ensureDataInBuffer() throws IOException {
-    if (mBufferOffset < mBufferedSize) {
-      return true;
+    @Override
+    public void close() throws IOException {
+        if (!mClosed) {
+            mClosed = true;
+            mResourceReleaser.release(mByteArray);
+            super.close();
+        }
     }
 
-    final int readData = mInputStream.read(mByteArray);
-    if (readData <= 0) {
-      return false;
+    @Override
+    public long skip(long byteCount) throws IOException {
+        Preconditions.checkState(mBufferOffset <= mBufferedSize);
+        ensureNotClosed();
+        final int bytesLeftInBuffer = mBufferedSize - mBufferOffset;
+        if (bytesLeftInBuffer >= byteCount) {
+            mBufferOffset += byteCount;
+            return byteCount;
+        }
+
+        mBufferOffset = mBufferedSize;
+        return bytesLeftInBuffer + mInputStream.skip(byteCount - bytesLeftInBuffer);
     }
 
-    mBufferedSize = readData;
-    mBufferOffset = 0;
-    return true;
-  }
+    /**
+     * Checks if there is some data left in the buffer. If not but buffered stream still has some
+     * data to be read, then more data is buffered.
+     *
+     * @return false if and only if there is no more data and underlying input stream has no more data
+     * to be read
+     * @throws IOException
+     */
+    private boolean ensureDataInBuffer() throws IOException {
+        if (mBufferOffset < mBufferedSize) {
+            return true;
+        }
+
+        final int readData = mInputStream.read(mByteArray);
+        if (readData <= 0) {
+            return false;
+        }
+
+        mBufferedSize = readData;
+        mBufferOffset = 0;
+        return true;
+    }
 
-  private void ensureNotClosed() throws IOException {
-    if (mClosed) {
-      throw new IOException("stream already closed");
+    private void ensureNotClosed() throws IOException {
+        if (mClosed) {
+            throw new IOException("stream already closed");
+        }
     }
-  }
 
-  @Override
-  protected void finalize() throws Throwable {
-    if (!mClosed) {
-      FLog.e(TAG, "Finalized without closing");
-      close();
+    @Override
+    protected void finalize() throws Throwable {
+        if (!mClosed) {
+            FLog.e(TAG, "Finalized without closing");
+            close();
+        }
+        super.finalize();
     }
-    super.finalize();
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBuffer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBuffer.java
index 82073623b..2459dd983 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBuffer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBuffer.java
@@ -18,53 +18,56 @@
  */
 public interface PooledByteBuffer extends Closeable {
 
-  /**
-   * Get the size of the byte buffer
-   * @return the size of the byte buffer
-   */
-  int size();
+    /**
+     * Get the size of the byte buffer
+     *
+     * @return the size of the byte buffer
+     */
+    int size();
 
-  /**
-   * Read byte at given offset
-   * @param offset
-   * @return byte at given offset
-   */
-  byte read(int offset);
+    /**
+     * Read byte at given offset
+     *
+     * @param offset
+     * @return byte at given offset
+     */
+    byte read(int offset);
 
-  /**
-   * Read consecutive bytes.
-   *
-   * @param offset the position in the PooledByteBuffer of the first byte to read
-   * @param buffer the byte array where read bytes will be copied to
-   * @param bufferOffset the position within the buffer of the first copied byte
-   * @param length number of bytes to copy
-   * @return number of bytes copied
-   */
-  void read(int offset, byte[] buffer, int bufferOffset, int length);
+    /**
+     * Read consecutive bytes.
+     *
+     * @param offset       the position in the PooledByteBuffer of the first byte to read
+     * @param buffer       the byte array where read bytes will be copied to
+     * @param bufferOffset the position within the buffer of the first copied byte
+     * @param length       number of bytes to copy
+     * @return number of bytes copied
+     */
+    void read(int offset, byte[] buffer, int bufferOffset, int length);
 
-  /**
-   * @return pointer to native memory backing this buffer
-   */
-  long getNativePtr();
+    /**
+     * @return pointer to native memory backing this buffer
+     */
+    long getNativePtr();
 
-  /**
-   * Close this PooledByteBuffer and release all underlying resources
-   */
-  @Override
-  void close();
+    /**
+     * Close this PooledByteBuffer and release all underlying resources
+     */
+    @Override
+    void close();
 
-  /**
-   * Check if this instance has already been closed
-   * @return true, if the instance has been closed
-   */
-  boolean isClosed();
+    /**
+     * Check if this instance has already been closed
+     *
+     * @return true, if the instance has been closed
+     */
+    boolean isClosed();
 
-  /**
-   * Exception indicating that the PooledByteBuffer is closed
-   */
-  public static class ClosedException extends RuntimeException {
-    public ClosedException() {
-      super("Invalid bytebuf. Already closed");
+    /**
+     * Exception indicating that the PooledByteBuffer is closed
+     */
+    public static class ClosedException extends RuntimeException {
+        public ClosedException() {
+            super("Invalid bytebuf. Already closed");
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferFactory.java
index ef3368819..247132403 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferFactory.java
@@ -17,48 +17,54 @@
  */
 public interface PooledByteBufferFactory {
 
-  /**
-   * Creates a new PooledByteBuffer instance of given size.
-   * @param size in bytes
-   * @return an instance of PooledByteBuffer
-   */
-  PooledByteBuffer newByteBuffer(int size);
+    /**
+     * Creates a new PooledByteBuffer instance of given size.
+     *
+     * @param size in bytes
+     * @return an instance of PooledByteBuffer
+     */
+    PooledByteBuffer newByteBuffer(int size);
 
-  /**
-   * Creates a new bytebuf instance by reading in the entire contents of the input stream
-   * @param inputStream the input stream to read from
-   * @return an instance of the PooledByteBuffer
-   * @throws IOException
-   */
-  PooledByteBuffer newByteBuffer(InputStream inputStream) throws IOException;
+    /**
+     * Creates a new bytebuf instance by reading in the entire contents of the input stream
+     *
+     * @param inputStream the input stream to read from
+     * @return an instance of the PooledByteBuffer
+     * @throws IOException
+     */
+    PooledByteBuffer newByteBuffer(InputStream inputStream) throws IOException;
 
-  /**
-   * Creates a new bytebuf instance by reading in the entire contents of the byte array
-   * @param bytes the byte array to read from
-   * @return an instance of the PooledByteBuffer
-   */
-  PooledByteBuffer newByteBuffer(byte[] bytes);
+    /**
+     * Creates a new bytebuf instance by reading in the entire contents of the byte array
+     *
+     * @param bytes the byte array to read from
+     * @return an instance of the PooledByteBuffer
+     */
+    PooledByteBuffer newByteBuffer(byte[] bytes);
 
-  /**
-   * Creates a new PooledByteBuffer instance with an initial capacity, and reading the entire
-   * contents of the input stream
-   * @param inputStream the input stream to read from
-   * @param initialCapacity initial allocation size for the bytebuf
-   * @return an instance of PooledByteBuffer
-   * @throws IOException
-   */
-  PooledByteBuffer newByteBuffer(InputStream inputStream, int initialCapacity) throws IOException;
+    /**
+     * Creates a new PooledByteBuffer instance with an initial capacity, and reading the entire
+     * contents of the input stream
+     *
+     * @param inputStream     the input stream to read from
+     * @param initialCapacity initial allocation size for the bytebuf
+     * @return an instance of PooledByteBuffer
+     * @throws IOException
+     */
+    PooledByteBuffer newByteBuffer(InputStream inputStream, int initialCapacity) throws IOException;
 
-  /**
-   * Creates a new PooledByteBufferOutputStream instance with default initial capacity
-   * @return a new PooledByteBufferOutputStream
-   */
-  PooledByteBufferOutputStream newOutputStream();
+    /**
+     * Creates a new PooledByteBufferOutputStream instance with default initial capacity
+     *
+     * @return a new PooledByteBufferOutputStream
+     */
+    PooledByteBufferOutputStream newOutputStream();
 
-  /**
-   * Creates a new PooledByteBufferOutputStream instance with the specified initial capacity
-   * @param initialCapacity initial allocation size for the underlying output stream
-   * @return a new PooledByteBufferOutputStream
-   */
-  PooledByteBufferOutputStream newOutputStream(int initialCapacity);
+    /**
+     * Creates a new PooledByteBufferOutputStream instance with the specified initial capacity
+     *
+     * @param initialCapacity initial allocation size for the underlying output stream
+     * @return a new PooledByteBufferOutputStream
+     */
+    PooledByteBufferOutputStream newOutputStream(int initialCapacity);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStream.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStream.java
index e7f6e3e6e..ee5aa9d8c 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStream.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStream.java
@@ -23,119 +23,123 @@
 @NotThreadSafe
 public class PooledByteBufferInputStream extends InputStream {
 
-  @VisibleForTesting
-  final PooledByteBuffer mPooledByteBuffer;
-
-  @VisibleForTesting
-  int mOffset; // current offset in the chunk
-  @VisibleForTesting
-  int mMark; // position of 'mark' if any
-
-  /**
-   * Creates a new inputstream instance over the specific buffer.
-   * @param pooledByteBuffer the buffer to read from
-   */
-  public PooledByteBufferInputStream(PooledByteBuffer pooledByteBuffer) {
-    super();
-    Preconditions.checkArgument(!pooledByteBuffer.isClosed());
-    mPooledByteBuffer = Preconditions.checkNotNull(pooledByteBuffer);
-    mOffset = 0;
-    mMark = 0;
-  }
-
-  /**
-   * Returns the number of bytes still available to read
-   */
-  @Override
-  public int available() {
-    return mPooledByteBuffer.size() - mOffset;
-  }
-
-  /**
-   * Sets a mark position in this inputstream.
-   * The parameter {@code readlimit} is ignored.
-   * Sending {@link #reset()}  will reposition the stream back to the marked position.
-   * @param readlimit ignored.
-   */
-  @Override
-  public void mark(int readlimit) {
-    mMark = mOffset;
-  }
-
-  /**
-   * Returns {@code true} since this class supports {@link #mark(int)} and {@link #reset()}
-   * methods
-   */
-  @Override
-  public boolean markSupported() {
-    return true;
-  }
-
-  @Override
-  public int read() {
-    if (available() <= 0) {
-      return -1;
+    @VisibleForTesting
+    final PooledByteBuffer mPooledByteBuffer;
+
+    @VisibleForTesting
+    int mOffset; // current offset in the chunk
+    @VisibleForTesting
+    int mMark; // position of 'mark' if any
+
+    /**
+     * Creates a new inputstream instance over the specific buffer.
+     *
+     * @param pooledByteBuffer the buffer to read from
+     */
+    public PooledByteBufferInputStream(PooledByteBuffer pooledByteBuffer) {
+        super();
+        Preconditions.checkArgument(!pooledByteBuffer.isClosed());
+        mPooledByteBuffer = Preconditions.checkNotNull(pooledByteBuffer);
+        mOffset = 0;
+        mMark = 0;
     }
-    return ((int) mPooledByteBuffer.read(mOffset++))  & 0xFF;
-  }
-
-  @Override
-  public int read(byte[] buffer) {
-    return read(buffer, 0, buffer.length);
-  }
-
-  /**
-   * Reads at most {@code length} bytes from this stream and stores them in byte array
-   * {@code buffer} starting at {@code offset}.
-   * @param buffer the buffer to read data into
-   * @param offset start offset in the buffer
-   * @param length max number of bytes to read
-   * @return number of bytes read
-   */
-  @Override
-  public int read(byte[] buffer, int offset, int length) {
-    if (offset < 0 || length < 0 || offset + length > buffer.length) {
-      throw new ArrayIndexOutOfBoundsException(
-          "length=" + buffer.length +
-          "; regionStart=" + offset +
-          "; regionLength=" + length);
+
+    /**
+     * Returns the number of bytes still available to read
+     */
+    @Override
+    public int available() {
+        return mPooledByteBuffer.size() - mOffset;
+    }
+
+    /**
+     * Sets a mark position in this inputstream.
+     * The parameter {@code readlimit} is ignored.
+     * Sending {@link #reset()}  will reposition the stream back to the marked position.
+     *
+     * @param readlimit ignored.
+     */
+    @Override
+    public void mark(int readlimit) {
+        mMark = mOffset;
+    }
+
+    /**
+     * Returns {@code true} since this class supports {@link #mark(int)} and {@link #reset()}
+     * methods
+     */
+    @Override
+    public boolean markSupported() {
+        return true;
     }
 
-    final int available = available();
-    if (available <= 0) {
-      return -1;
+    @Override
+    public int read() {
+        if (available() <= 0) {
+            return -1;
+        }
+        return ((int) mPooledByteBuffer.read(mOffset++)) & 0xFF;
     }
 
-    if (length <= 0) {
-      return 0;
+    @Override
+    public int read(byte[] buffer) {
+        return read(buffer, 0, buffer.length);
     }
 
-    int numToRead = Math.min(available, length);
-    mPooledByteBuffer.read(mOffset, buffer, offset, numToRead);
-    mOffset += numToRead;
-    return numToRead;
-  }
-
-  /**
-   * Resets this stream to the last marked location. This implementation
-   * resets the position to either the marked position, the start position
-   * supplied in the constructor or 0 if neither has been provided.
-   */
-  @Override
-  public void reset() {
-    mOffset = mMark;
-  }
-
-  /**
-   * Skips byteCount (or however many bytes are available) bytes in the stream
-   * @param byteCount number of bytes to skip
-   * @return number of bytes actually skipped
-   */
-  @Override
-  public long skip(long byteCount) {
-    Preconditions.checkArgument(byteCount >= 0);
-    int skipped = Math.min((int) byteCount, available());
-    mOffset += skipped;
-    return skipped;
-  }
+    /**
+     * Reads at most {@code length} bytes from this stream and stores them in byte array
+     * {@code buffer} starting at {@code offset}.
+     *
+     * @param buffer the buffer to read data into
+     * @param offset start offset in the buffer
+     * @param length max number of bytes to read
+     * @return number of bytes read
+     */
+    @Override
+    public int read(byte[] buffer, int offset, int length) {
+        if (offset < 0 || length < 0 || offset + length > buffer.length) {
+            throw new ArrayIndexOutOfBoundsException(
+                    "length=" + buffer.length +
+                            "; regionStart=" + offset +
+                            "; regionLength=" + length);
+        }
+
+        final int available = available();
+        if (available <= 0) {
+            return -1;
+        }
+
+        if (length <= 0) {
+            return 0;
+        }
+
+        int numToRead = Math.min(available, length);
+        mPooledByteBuffer.read(mOffset, buffer, offset, numToRead);
+        mOffset += numToRead;
+        return numToRead;
+    }
+
+    /**
+     * Resets this stream to the last marked location. This implementation
+     * resets the position to either the marked position, the start position
+     * supplied in the constructor or 0 if neither has been provided.
+     */
+    @Override
+    public void reset() {
+        mOffset = mMark;
+    }
+
+    /**
+     * Skips byteCount (or however many bytes are available) bytes in the stream
+     *
+     * @param byteCount number of bytes to skip
+     * @return number of bytes actually skipped
+     */
+    @Override
+    public long skip(long byteCount) {
+        Preconditions.checkArgument(byteCount >= 0);
+        int skipped = Math.min((int) byteCount, available());
+        mOffset += skipped;
+        return skipped;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferOutputStream.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferOutputStream.java
index aac439e45..496c11c9a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferOutputStream.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteBufferOutputStream.java
@@ -16,39 +16,41 @@
 
 /**
  * An OutputStream that produces a PooledByteBuffer.
- *
+ * <p>
  * <p> Expected use for such stream is to first write sequence of bytes to the stream and then call
  * toByteBuffer to produce PooledByteBuffer containing written data. After toByteBuffer returns
  * client can continue writing new data and call toByteBuffer over and over again.
- *
+ * <p>
  * <p> Streams implementing this interface are closeable resources and need to be closed in order
  * to release underlying resources. Close is idempotent operation and after stream was closed, no
  * other method should be called. Streams subclassing PooledByteBufferOutputStream are not allowed
  * to throw IOException from close method.
  */
 public abstract class PooledByteBufferOutputStream extends OutputStream {
-  /**
-   * Creates a PooledByteBuffer from the contents of the stream.
-   * @return
-   */
-  public abstract PooledByteBuffer toByteBuffer();
+    /**
+     * Creates a PooledByteBuffer from the contents of the stream.
+     *
+     * @return
+     */
+    public abstract PooledByteBuffer toByteBuffer();
 
-  /**
-   * Returns the total number of bytes written to this stream so far.
-   * @return the number of bytes written to this stream.
-   */
-  public abstract int size();
+    /**
+     * Returns the total number of bytes written to this stream so far.
+     *
+     * @return the number of bytes written to this stream.
+     */
+    public abstract int size();
 
-  /**
-   * Closes the stream.
-   */
-  @Override
-  public void close() {
-    try {
-      super.close();
-    } catch (IOException ioe) {
-      // does not happen
-      Throwables.propagate(ioe);
+    /**
+     * Closes the stream.
+     */
+    @Override
+    public void close() {
+        try {
+            super.close();
+        } catch (IOException ioe) {
+            // does not happen
+            Throwables.propagate(ioe);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteStreams.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteStreams.java
index cbfcae501..3f9e33d88 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteStreams.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/PooledByteStreams.java
@@ -21,78 +21,80 @@
  * To prevent numerous allocations of temp buffers pool of byte arrays is used.
  */
 public class PooledByteStreams {
-  /**
-   * Size of temporary buffer to use for copying (16 kb)
-   */
-  private static final int DEFAULT_TEMP_BUF_SIZE = 16 * 1024;
+    /**
+     * Size of temporary buffer to use for copying (16 kb)
+     */
+    private static final int DEFAULT_TEMP_BUF_SIZE = 16 * 1024;
 
-  private final int mTempBufSize;
-  private final ByteArrayPool mByteArrayPool;
+    private final int mTempBufSize;
+    private final ByteArrayPool mByteArrayPool;
 
-  public PooledByteStreams(ByteArrayPool byteArrayPool) {
-    this(byteArrayPool, DEFAULT_TEMP_BUF_SIZE);
-  }
+    public PooledByteStreams(ByteArrayPool byteArrayPool) {
+        this(byteArrayPool, DEFAULT_TEMP_BUF_SIZE);
+    }
 
-  @VisibleForTesting
-  PooledByteStreams(ByteArrayPool byteArrayPool, int tempBufSize) {
-    Preconditions.checkArgument(tempBufSize > 0);
-    mTempBufSize = tempBufSize;
-    mByteArrayPool = byteArrayPool;
-  }
+    @VisibleForTesting
+    PooledByteStreams(ByteArrayPool byteArrayPool, int tempBufSize) {
+        Preconditions.checkArgument(tempBufSize > 0);
+        mTempBufSize = tempBufSize;
+        mByteArrayPool = byteArrayPool;
+    }
 
-  /**
-   * Copy all bytes from InputStream to OutputStream.
-   * @param from InputStream
-   * @param to OutputStream
-   * @return number of copied bytes
-   * @throws IOException
-   */
-  public long copy(final InputStream from, final OutputStream to) throws IOException {
-    long count = 0;
-    byte[] tmp = mByteArrayPool.get(mTempBufSize);
+    /**
+     * Copy all bytes from InputStream to OutputStream.
+     *
+     * @param from InputStream
+     * @param to   OutputStream
+     * @return number of copied bytes
+     * @throws IOException
+     */
+    public long copy(final InputStream from, final OutputStream to) throws IOException {
+        long count = 0;
+        byte[] tmp = mByteArrayPool.get(mTempBufSize);
 
-    try {
-      while (true) {
-        int read = from.read(tmp, 0, mTempBufSize);
-        if (read == -1) {
-          return count;
+        try {
+            while (true) {
+                int read = from.read(tmp, 0, mTempBufSize);
+                if (read == -1) {
+                    return count;
+                }
+                to.write(tmp, 0, read);
+                count += read;
+            }
+        } finally {
+            mByteArrayPool.release(tmp);
         }
-        to.write(tmp, 0, read);
-        count += read;
-      }
-    } finally {
-      mByteArrayPool.release(tmp);
     }
-  }
 
-  /**
-   * Copy at most number of bytes from InputStream to OutputStream.
-   * @param from InputStream
-   * @param to OutputStream
-   * @param bytesToCopy bytes to copy
-   * @return number of copied bytes
-   * @throws IOException
-   */
-  public long copy(
-      final InputStream from,
-      final OutputStream to,
-      final long bytesToCopy) throws IOException {
-    Preconditions.checkState(bytesToCopy > 0);
-    long copied = 0;
-    byte[] tmp = mByteArrayPool.get(mTempBufSize);
+    /**
+     * Copy at most number of bytes from InputStream to OutputStream.
+     *
+     * @param from        InputStream
+     * @param to          OutputStream
+     * @param bytesToCopy bytes to copy
+     * @return number of copied bytes
+     * @throws IOException
+     */
+    public long copy(
+            final InputStream from,
+            final OutputStream to,
+            final long bytesToCopy) throws IOException {
+        Preconditions.checkState(bytesToCopy > 0);
+        long copied = 0;
+        byte[] tmp = mByteArrayPool.get(mTempBufSize);
 
-    try {
-      while (copied < bytesToCopy) {
-        int read = from.read(tmp, 0, (int) Math.min(mTempBufSize, bytesToCopy - copied));
-        if (read == -1) {
-          return copied;
+        try {
+            while (copied < bytesToCopy) {
+                int read = from.read(tmp, 0, (int) Math.min(mTempBufSize, bytesToCopy - copied));
+                if (read == -1) {
+                    return copied;
+                }
+                to.write(tmp, 0, read);
+                copied += read;
+            }
+            return copied;
+        } finally {
+            mByteArrayPool.release(tmp);
         }
-        to.write(tmp, 0, read);
-        copied += read;
-      }
-      return copied;
-    } finally {
-      mByteArrayPool.release(tmp);
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/SharedByteArray.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/SharedByteArray.java
index f81b367a1..776936221 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/SharedByteArray.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/memory/SharedByteArray.java
@@ -25,119 +25,119 @@
 
 /**
  * Maintains a shareable reference to a byte array.
- *
+ * <p>
  * <p> When accessing the shared array proper synchronization is guaranteed.
  * Under hood the get method acquires an exclusive lock, which is released
  * whenever the returned CloseableReference is closed.
- *
+ * <p>
  * <p> If the currently available byte array is too small for a request
  * it is replaced with a bigger one.
- *
+ * <p>
  * <p> This class will also release the byte array if it is unused and
  * collecting it can prevent an OOM.
  */
 @ThreadSafe
 public class SharedByteArray implements MemoryTrimmable {
-  @VisibleForTesting
-  final int mMinByteArraySize;
-  @VisibleForTesting
-  final int mMaxByteArraySize;
-
-  /**
-   * The underlying byte array.
-   *
-   * <p> If we receive a memory trim notification, or the runtime runs pre-OOM gc
-   * it will be cleared to reduce memory pressure.
-   */
-  @VisibleForTesting
-  final OOMSoftReference<byte[]> mByteArraySoftRef;
-
-  /**
-   * Synchronization primitive used by this implementation
-   */
-  @VisibleForTesting
-  final Semaphore mSemaphore;
-
-  private final ResourceReleaser<byte[]> mResourceReleaser;
-
-  public SharedByteArray(
-      MemoryTrimmableRegistry memoryTrimmableRegistry,
-      PoolParams params) {
-    Preconditions.checkNotNull(memoryTrimmableRegistry);
-    Preconditions.checkArgument(params.minBucketSize > 0);
-    Preconditions.checkArgument(params.maxBucketSize >= params.minBucketSize);
-
-    mMaxByteArraySize = params.maxBucketSize;
-    mMinByteArraySize = params.minBucketSize;
-    mByteArraySoftRef = new OOMSoftReference<byte[]>();
-    mSemaphore = new Semaphore(1);
-    mResourceReleaser = new ResourceReleaser<byte[]>() {
-      @Override
-      public void release(byte[] unused) {
-        mSemaphore.release();
-      }
-    };
-
-    memoryTrimmableRegistry.registerMemoryTrimmable(this);
-  }
-
-  /**
-   * Get exclusive access to the byte array of size greater or equal to the passed one.
-   *
-   * <p> Under the hood this method acquires an exclusive lock that is released when
-   * the returned reference is closed.
-   */
-  public CloseableReference<byte[]> get(int size) {
-    Preconditions.checkArgument(size > 0, "Size must be greater than zero");
-    Preconditions.checkArgument(size <= mMaxByteArraySize, "Requested size is too big");
-    mSemaphore.acquireUninterruptibly();
-    try {
-      byte[] byteArray = getByteArray(size);
-      return CloseableReference.of(byteArray, mResourceReleaser);
-    } catch (Throwable t) {
-      mSemaphore.release();
-      throw Throwables.propagate(t);
+    @VisibleForTesting
+    final int mMinByteArraySize;
+    @VisibleForTesting
+    final int mMaxByteArraySize;
+
+    /**
+     * The underlying byte array.
+     * <p>
+     * <p> If we receive a memory trim notification, or the runtime runs pre-OOM gc
+     * it will be cleared to reduce memory pressure.
+     */
+    @VisibleForTesting
+    final OOMSoftReference<byte[]> mByteArraySoftRef;
+
+    /**
+     * Synchronization primitive used by this implementation
+     */
+    @VisibleForTesting
+    final Semaphore mSemaphore;
+
+    private final ResourceReleaser<byte[]> mResourceReleaser;
+
+    public SharedByteArray(
+            MemoryTrimmableRegistry memoryTrimmableRegistry,
+            PoolParams params) {
+        Preconditions.checkNotNull(memoryTrimmableRegistry);
+        Preconditions.checkArgument(params.minBucketSize > 0);
+        Preconditions.checkArgument(params.maxBucketSize >= params.minBucketSize);
+
+        mMaxByteArraySize = params.maxBucketSize;
+        mMinByteArraySize = params.minBucketSize;
+        mByteArraySoftRef = new OOMSoftReference<byte[]>();
+        mSemaphore = new Semaphore(1);
+        mResourceReleaser = new ResourceReleaser<byte[]>() {
+            @Override
+            public void release(byte[] unused) {
+                mSemaphore.release();
+            }
+        };
+
+        memoryTrimmableRegistry.registerMemoryTrimmable(this);
     }
-  }
 
-  private byte[] getByteArray(int requestedSize) {
-    final int bucketedSize = getBucketedSize(requestedSize);
-    byte[] byteArray = mByteArraySoftRef.get();
-    if (byteArray == null || byteArray.length < bucketedSize) {
-      byteArray = allocateByteArray(bucketedSize);
+    /**
+     * Get exclusive access to the byte array of size greater or equal to the passed one.
+     * <p>
+     * <p> Under the hood this method acquires an exclusive lock that is released when
+     * the returned reference is closed.
+     */
+    public CloseableReference<byte[]> get(int size) {
+        Preconditions.checkArgument(size > 0, "Size must be greater than zero");
+        Preconditions.checkArgument(size <= mMaxByteArraySize, "Requested size is too big");
+        mSemaphore.acquireUninterruptibly();
+        try {
+            byte[] byteArray = getByteArray(size);
+            return CloseableReference.of(byteArray, mResourceReleaser);
+        } catch (Throwable t) {
+            mSemaphore.release();
+            throw Throwables.propagate(t);
+        }
     }
-    return byteArray;
-  }
-
-  /**
-   * Responds to memory pressure by simply 'discarding' the local byte array if it is not used
-   * at the moment.
-   *
-   * @param trimType kind of trimming to perform (ignored)
-   */
-  @Override
-  public void trim(MemoryTrimType trimType) {
-    if (!mSemaphore.tryAcquire()) {
-      return;
+
+    private byte[] getByteArray(int requestedSize) {
+        final int bucketedSize = getBucketedSize(requestedSize);
+        byte[] byteArray = mByteArraySoftRef.get();
+        if (byteArray == null || byteArray.length < bucketedSize) {
+            byteArray = allocateByteArray(bucketedSize);
+        }
+        return byteArray;
     }
-    try {
-      mByteArraySoftRef.clear();
-    } finally {
-      mSemaphore.release();
+
+    /**
+     * Responds to memory pressure by simply 'discarding' the local byte array if it is not used
+     * at the moment.
+     *
+     * @param trimType kind of trimming to perform (ignored)
+     */
+    @Override
+    public void trim(MemoryTrimType trimType) {
+        if (!mSemaphore.tryAcquire()) {
+            return;
+        }
+        try {
+            mByteArraySoftRef.clear();
+        } finally {
+            mSemaphore.release();
+        }
+    }
+
+    @VisibleForTesting
+    int getBucketedSize(int size) {
+        size = Math.max(size, mMinByteArraySize);
+        return Integer.highestOneBit(size - 1) * 2;
+    }
+
+    private synchronized byte[] allocateByteArray(int size) {
+        // Start with clearing reference and releasing currently owned byte array
+        mByteArraySoftRef.clear();
+        byte[] byteArray = new byte[size];
+        mByteArraySoftRef.set(byteArray);
+        return byteArray;
     }
-  }
-
-  @VisibleForTesting
-  int getBucketedSize(int size) {
-    size = Math.max(size, mMinByteArraySize);
-    return Integer.highestOneBit(size - 1) * 2;
-  }
-
-  private synchronized byte[] allocateByteArray(int size) {
-    // Start with clearing reference and releasing currently owned byte array
-    mByteArraySoftRef.clear();
-    byte[] byteArray = new byte[size];
-    mByteArraySoftRef.set(byteArray);
-    return byteArray;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/Bitmaps.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/Bitmaps.java
index 008fdc513..5734c7c03 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/Bitmaps.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/Bitmaps.java
@@ -21,85 +21,87 @@
  */
 @DoNotStrip
 public class Bitmaps {
-  /**
-   * The only bitmap config we use. Every bitmap managed by this pool will use this config.
-   * If we need to change this, please change BYTES_PER_PIXEL below.
-   */
-  public static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888;
+    /**
+     * The only bitmap config we use. Every bitmap managed by this pool will use this config.
+     * If we need to change this, please change BYTES_PER_PIXEL below.
+     */
+    public static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888;
 
-  /**
-   * Bytes per pixel - corresponds to the specific BITMAP_CONFIG above ARGB_8888.
-   * Must change if the Config above changes
-   */
-  public static final int BYTES_PER_PIXEL = 4;
+    /**
+     * Bytes per pixel - corresponds to the specific BITMAP_CONFIG above ARGB_8888.
+     * Must change if the Config above changes
+     */
+    public static final int BYTES_PER_PIXEL = 4;
 
-  static {
-    SoLoaderShim.loadLibrary("bitmaps");
-  }
+    static {
+        SoLoaderShim.loadLibrary("bitmaps");
+    }
 
-  /**
-   * Pin the bitmap so that it cannot be 'purged'. Only makes sense for purgeable bitmaps
-   * WARNING: Use with caution. Make sure that the pinned bitmap is recycled eventually. Otherwise,
-   * this will simply eat up ashmem memory and eventually lead to unfortunate crashes.
-   * We *may* eventually provide an unpin method - but we don't yet have a compelling use case for
-   * that.
-   * @param bitmap the purgeable bitmap to pin
-   */
-  public static void pinBitmap(Bitmap bitmap) {
-    Preconditions.checkNotNull(bitmap);
-    nativePinBitmap(bitmap);
-  }
+    /**
+     * Pin the bitmap so that it cannot be 'purged'. Only makes sense for purgeable bitmaps
+     * WARNING: Use with caution. Make sure that the pinned bitmap is recycled eventually. Otherwise,
+     * this will simply eat up ashmem memory and eventually lead to unfortunate crashes.
+     * We *may* eventually provide an unpin method - but we don't yet have a compelling use case for
+     * that.
+     *
+     * @param bitmap the purgeable bitmap to pin
+     */
+    public static void pinBitmap(Bitmap bitmap) {
+        Preconditions.checkNotNull(bitmap);
+        nativePinBitmap(bitmap);
+    }
 
 
-  /**
-   * This blits the pixel data from src to dest.
-   * <p>The destination bitmap must have both a height and a width equal to the source. For maximum
-   * speed stride should be equal as well.
-   * <p>Both bitmaps must be in {@link android.graphics.Bitmap.Config#ARGB_8888} format.
-   * <p>If the src is purgeable, it will be decoded as part of this operation if it was purged.
-   * The dest should not be purgeable. If it is, the copy will still take place,
-   * but will be lost the next time the dest gets purged, without warning.
-   * <p>The dest must be mutable.
-   * @param dest Bitmap to copy into
-   * @param src Bitmap to copy out of
-   */
-  public static void copyBitmap(Bitmap dest, Bitmap src) {
-    Preconditions.checkArgument(src.getConfig() == Bitmap.Config.ARGB_8888);
-    Preconditions.checkArgument(dest.getConfig() == Bitmap.Config.ARGB_8888);
-    Preconditions.checkArgument(dest.isMutable());
-    Preconditions.checkArgument(dest.getWidth() == src.getWidth());
-    Preconditions.checkArgument(dest.getHeight() == src.getHeight());
-    nativeCopyBitmap(
-        dest,
-        dest.getRowBytes(),
-        src,
-        src.getRowBytes(),
-        dest.getHeight());
-  }
+    /**
+     * This blits the pixel data from src to dest.
+     * <p>The destination bitmap must have both a height and a width equal to the source. For maximum
+     * speed stride should be equal as well.
+     * <p>Both bitmaps must be in {@link android.graphics.Bitmap.Config#ARGB_8888} format.
+     * <p>If the src is purgeable, it will be decoded as part of this operation if it was purged.
+     * The dest should not be purgeable. If it is, the copy will still take place,
+     * but will be lost the next time the dest gets purged, without warning.
+     * <p>The dest must be mutable.
+     *
+     * @param dest Bitmap to copy into
+     * @param src  Bitmap to copy out of
+     */
+    public static void copyBitmap(Bitmap dest, Bitmap src) {
+        Preconditions.checkArgument(src.getConfig() == Bitmap.Config.ARGB_8888);
+        Preconditions.checkArgument(dest.getConfig() == Bitmap.Config.ARGB_8888);
+        Preconditions.checkArgument(dest.isMutable());
+        Preconditions.checkArgument(dest.getWidth() == src.getWidth());
+        Preconditions.checkArgument(dest.getHeight() == src.getHeight());
+        nativeCopyBitmap(
+                dest,
+                dest.getRowBytes(),
+                src,
+                src.getRowBytes(),
+                dest.getHeight());
+    }
 
-  /**
-   * Reconfigures bitmap after checking its allocation size.
-   *
-   * <p> This method is here to overcome our testing framework limit. Robolectric does not provide
-   * KitKat specific APIs: {@link Bitmap#reconfigure} and {@link Bitmap#getAllocationByteCount}
-   * are part of that.
-   */
-  @TargetApi(19)
-  public static void reconfigureBitmap(Bitmap bitmap, int width, int height) {
-    Preconditions.checkArgument(
-        bitmap.getAllocationByteCount() >= width * height * BYTES_PER_PIXEL);
-    bitmap.reconfigure(width, height, BITMAP_CONFIG);
-  }
+    /**
+     * Reconfigures bitmap after checking its allocation size.
+     * <p>
+     * <p> This method is here to overcome our testing framework limit. Robolectric does not provide
+     * KitKat specific APIs: {@link Bitmap#reconfigure} and {@link Bitmap#getAllocationByteCount}
+     * are part of that.
+     */
+    @TargetApi(19)
+    public static void reconfigureBitmap(Bitmap bitmap, int width, int height) {
+        Preconditions.checkArgument(
+                bitmap.getAllocationByteCount() >= width * height * BYTES_PER_PIXEL);
+        bitmap.reconfigure(width, height, BITMAP_CONFIG);
+    }
 
 
-  @DoNotStrip
-  private static native void nativePinBitmap(Bitmap bitmap);
+    @DoNotStrip
+    private static native void nativePinBitmap(Bitmap bitmap);
 
-  @DoNotStrip
-  private static native void nativeCopyBitmap(
-      Bitmap dest,
-      int destStride,
-      Bitmap src,
-      int srcStride,
-      int rows);
+    @DoNotStrip
+    private static native void nativeCopyBitmap(
+            Bitmap dest,
+            int destStride,
+            Bitmap src,
+            int srcStride,
+            int rows);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/ImagePipelineNativeLoader.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/ImagePipelineNativeLoader.java
index b529f2fa5..fd7fe6187 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/ImagePipelineNativeLoader.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/ImagePipelineNativeLoader.java
@@ -17,33 +17,34 @@
 
 /**
  * Single place responsible for loading libimagepipeline.so and its dependencies.
- *
+ * <p>
  * If your class has a native method whose implementation lives in libimagepipeline.so then call
  * {@link ImagePipelineNativeLoader#load} in its static initializer:
  * <code>
- *   public class ClassWithNativeMethod {
- *     static {
- *       ImagePipelineNativeLoader.load();
- *     }
- *
- *     private static native void aNativeMethod();
- *   }
+ * public class ClassWithNativeMethod {
+ * static {
+ * ImagePipelineNativeLoader.load();
+ * }
+ * <p>
+ * private static native void aNativeMethod();
+ * }
  * </code>
  */
 public class ImagePipelineNativeLoader {
-  public static final String DSO_NAME = "imagepipeline";
+    public static final String DSO_NAME = "imagepipeline";
 
-  public static final List<String> DEPENDENCIES;
-  static {
-    List<String> dependencies = new ArrayList<String>();
-    dependencies.add("webp");
-    DEPENDENCIES = Collections.unmodifiableList(dependencies);
-  }
+    public static final List<String> DEPENDENCIES;
+
+    static {
+        List<String> dependencies = new ArrayList<String>();
+        dependencies.add("webp");
+        DEPENDENCIES = Collections.unmodifiableList(dependencies);
+    }
 
-  public static void load() {
-    for (int i = 0; i < DEPENDENCIES.size(); ++i) {
-      SoLoaderShim.loadLibrary(DEPENDENCIES.get(i));
+    public static void load() {
+        for (int i = 0; i < DEPENDENCIES.size(); ++i) {
+            SoLoaderShim.loadLibrary(DEPENDENCIES.get(i));
+        }
+        SoLoaderShim.loadLibrary(DSO_NAME);
     }
-    SoLoaderShim.loadLibrary(DSO_NAME);
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/JpegTranscoder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/JpegTranscoder.java
index 272d0c32a..2cac3a8df 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/JpegTranscoder.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/JpegTranscoder.java
@@ -22,60 +22,60 @@
 @DoNotStrip
 public class JpegTranscoder {
 
-  static {
-    ImagePipelineNativeLoader.load();
-  }
+    static {
+        ImagePipelineNativeLoader.load();
+    }
 
-  public static final int MIN_QUALITY = 0;
-  public static final int MAX_QUALITY = 100;
-  public static final int MIN_SCALE_NUMERATOR = 1;
-  public static final int MAX_SCALE_NUMERATOR = 16;
-  public static final int SCALE_DENOMINATOR = 8;
+    public static final int MIN_QUALITY = 0;
+    public static final int MAX_QUALITY = 100;
+    public static final int MIN_SCALE_NUMERATOR = 1;
+    public static final int MAX_SCALE_NUMERATOR = 16;
+    public static final int SCALE_DENOMINATOR = 8;
 
-  /**
-   * @return true if and only if given number of degrees is allowed rotation angle, that is
-   *   it is equal to 0, 90, 180 or 270
-   */
-  public static boolean isRotationAngleAllowed(int degrees) {
-    return (degrees >= 0) && (degrees <= 270) && (degrees % 90 == 0);
-  }
+    /**
+     * @return true if and only if given number of degrees is allowed rotation angle, that is
+     * it is equal to 0, 90, 180 or 270
+     */
+    public static boolean isRotationAngleAllowed(int degrees) {
+        return (degrees >= 0) && (degrees <= 270) && (degrees % 90 == 0);
+    }
 
-  /**
-   * Downscales and rotates jpeg image
-   *
-   * @param inputStream
-   * @param outputStream
-   * @param rotationAngle 0, 90, 180 or 270
-   * @param scaleNumerator 1 - 16, image will be scaled using scaleNumerator/8 factor
-   * @param quality 1 - 100
-   */
-  public static void transcodeJpeg(
-      final InputStream inputStream,
-      final OutputStream outputStream,
-      final int rotationAngle,
-      final int scaleNumerator,
-      final int quality) throws IOException {
-    Preconditions.checkArgument(scaleNumerator >= MIN_SCALE_NUMERATOR);
-    Preconditions.checkArgument(scaleNumerator <= MAX_SCALE_NUMERATOR);
-    Preconditions.checkArgument(quality >= MIN_QUALITY);
-    Preconditions.checkArgument(quality <= MAX_QUALITY);
-    Preconditions.checkArgument(isRotationAngleAllowed(rotationAngle));
-    Preconditions.checkArgument(
-        scaleNumerator != SCALE_DENOMINATOR || rotationAngle != 0,
-        "no transformation requested");
-    nativeTranscodeJpeg(
-        Preconditions.checkNotNull(inputStream),
-        Preconditions.checkNotNull(outputStream),
-        rotationAngle,
-        scaleNumerator,
-        quality);
-  }
+    /**
+     * Downscales and rotates jpeg image
+     *
+     * @param inputStream
+     * @param outputStream
+     * @param rotationAngle  0, 90, 180 or 270
+     * @param scaleNumerator 1 - 16, image will be scaled using scaleNumerator/8 factor
+     * @param quality        1 - 100
+     */
+    public static void transcodeJpeg(
+            final InputStream inputStream,
+            final OutputStream outputStream,
+            final int rotationAngle,
+            final int scaleNumerator,
+            final int quality) throws IOException {
+        Preconditions.checkArgument(scaleNumerator >= MIN_SCALE_NUMERATOR);
+        Preconditions.checkArgument(scaleNumerator <= MAX_SCALE_NUMERATOR);
+        Preconditions.checkArgument(quality >= MIN_QUALITY);
+        Preconditions.checkArgument(quality <= MAX_QUALITY);
+        Preconditions.checkArgument(isRotationAngleAllowed(rotationAngle));
+        Preconditions.checkArgument(
+                scaleNumerator != SCALE_DENOMINATOR || rotationAngle != 0,
+                "no transformation requested");
+        nativeTranscodeJpeg(
+                Preconditions.checkNotNull(inputStream),
+                Preconditions.checkNotNull(outputStream),
+                rotationAngle,
+                scaleNumerator,
+                quality);
+    }
 
-  @DoNotStrip
-  private static native void nativeTranscodeJpeg(
-      InputStream inputStream,
-      OutputStream outputStream,
-      int rotationAngle,
-      int scaleNominator,
-      int quality) throws IOException;
+    @DoNotStrip
+    private static native void nativeTranscodeJpeg(
+            InputStream inputStream,
+            OutputStream outputStream,
+            int rotationAngle,
+            int scaleNominator,
+            int quality) throws IOException;
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/WebpTranscoder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/WebpTranscoder.java
index 0211159f2..df7285e58 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/WebpTranscoder.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/nativecode/WebpTranscoder.java
@@ -27,99 +27,99 @@
 @DoNotStrip
 public class WebpTranscoder {
 
-  static {
-    ImagePipelineNativeLoader.load();
-  }
-
-  /**
-   * BASE64 encoded extended WebP image.
-   */
-  private static final String VP8X_WEBP_BASE64 = "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAw" +
-      "AAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==";
-  private static final boolean mIsExtendedWebpSupported = isExtendedWebpSupported();
-
-  /**
-   * Checks whether underlying platform supports extended WebPs
-   */
-  private static boolean isExtendedWebpSupported() {
-    // Lossless and extended formats are supported on Android 4.2.1+
-    // Unfortunately SDK_INT is not enough to distinguish 4.2 and 4.2.1
-    // (both are API level 17 (JELLY_BEAN_MR1))
-    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
-      return false;
+    static {
+        ImagePipelineNativeLoader.load();
     }
 
-    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {
-      // Let's test if extended webp is supported
-      // To this end we will try to decode bounds of vp8x webp with alpha channel
-      byte[] decodedBytes = Base64.decode(VP8X_WEBP_BASE64, Base64.DEFAULT);
-      BitmapFactory.Options opts = new BitmapFactory.Options();
-      opts.inJustDecodeBounds = true;
-      BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.length, opts);
-
-      // If Android managed to find appropriate decoder then opts.outHeight and opts.outWidth
-      // should be set. Warning ! Unfortunately we can not assume that outMimeType is set.
-      // Android guys forgot to update logic for mime types when they introduced support for webp.
-      // For example, on 4.2.2 this field is not set for webp images.
-      if (opts.outHeight != 1 || opts.outWidth != 1) {
-        return false;
-      }
+    /**
+     * BASE64 encoded extended WebP image.
+     */
+    private static final String VP8X_WEBP_BASE64 = "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAw" +
+            "AAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==";
+    private static final boolean mIsExtendedWebpSupported = isExtendedWebpSupported();
+
+    /**
+     * Checks whether underlying platform supports extended WebPs
+     */
+    private static boolean isExtendedWebpSupported() {
+        // Lossless and extended formats are supported on Android 4.2.1+
+        // Unfortunately SDK_INT is not enough to distinguish 4.2 and 4.2.1
+        // (both are API level 17 (JELLY_BEAN_MR1))
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            return false;
+        }
+
+        if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            // Let's test if extended webp is supported
+            // To this end we will try to decode bounds of vp8x webp with alpha channel
+            byte[] decodedBytes = Base64.decode(VP8X_WEBP_BASE64, Base64.DEFAULT);
+            BitmapFactory.Options opts = new BitmapFactory.Options();
+            opts.inJustDecodeBounds = true;
+            BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.length, opts);
+
+            // If Android managed to find appropriate decoder then opts.outHeight and opts.outWidth
+            // should be set. Warning ! Unfortunately we can not assume that outMimeType is set.
+            // Android guys forgot to update logic for mime types when they introduced support for webp.
+            // For example, on 4.2.2 this field is not set for webp images.
+            if (opts.outHeight != 1 || opts.outWidth != 1) {
+                return false;
+            }
+        }
+
+        return true;
     }
 
-    return true;
-  }
-
-  /**
-   * @return true if given type of WebP is supported natively by the framework
-   */
-  public static boolean isWebpNativelySupported(ImageFormat webpFormat) {
-    switch (webpFormat) {
-      case WEBP_SIMPLE: // Simple WebPs are supported on Android 4.0+
-        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-      case WEBP_LOSSLESS:
-      case WEBP_EXTENDED:
-      case WEBP_EXTENDED_WITH_ALPHA:
-        return mIsExtendedWebpSupported;
-      case WEBP_ANIMATED:
-        return false;
-      default:
-        Preconditions.checkArgument(false);
-        return false;
+    /**
+     * @return true if given type of WebP is supported natively by the framework
+     */
+    public static boolean isWebpNativelySupported(ImageFormat webpFormat) {
+        switch (webpFormat) {
+            case WEBP_SIMPLE: // Simple WebPs are supported on Android 4.0+
+                return Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH;
+            case WEBP_LOSSLESS:
+            case WEBP_EXTENDED:
+            case WEBP_EXTENDED_WITH_ALPHA:
+                return mIsExtendedWebpSupported;
+            case WEBP_ANIMATED:
+                return false;
+            default:
+                Preconditions.checkArgument(false);
+                return false;
+        }
     }
-  }
-
-  /**
-   * Transcodes webp image given by input stream into jpeg.
-   */
-  public static void transcodeWebpToJpeg(
-      InputStream inputStream,
-      OutputStream outputStream,
-      int quality) throws IOException {
-    nativeTranscodeWebpToJpeg(
-        Preconditions.checkNotNull(inputStream),
-        Preconditions.checkNotNull(outputStream),
-        quality);
-  }
-
-  /**
-   * Transcodes Webp image given by input stream into png.
-   */
-  public static void transcodeWebpToPng(
-      InputStream inputStream,
-      OutputStream outputStream) throws IOException {
-    nativeTranscodeWebpToPng(
-        Preconditions.checkNotNull(inputStream),
-        Preconditions.checkNotNull(outputStream));
-  }
-
-  @DoNotStrip
-  private static native void nativeTranscodeWebpToJpeg(
-      InputStream inputStream,
-      OutputStream outputStream,
-      int quality) throws IOException;
-
-  @DoNotStrip
-  private static native void nativeTranscodeWebpToPng(
-      InputStream inputStream,
-      OutputStream outputStream) throws IOException;
+
+    /**
+     * Transcodes webp image given by input stream into jpeg.
+     */
+    public static void transcodeWebpToJpeg(
+            InputStream inputStream,
+            OutputStream outputStream,
+            int quality) throws IOException {
+        nativeTranscodeWebpToJpeg(
+                Preconditions.checkNotNull(inputStream),
+                Preconditions.checkNotNull(outputStream),
+                quality);
+    }
+
+    /**
+     * Transcodes Webp image given by input stream into png.
+     */
+    public static void transcodeWebpToPng(
+            InputStream inputStream,
+            OutputStream outputStream) throws IOException {
+        nativeTranscodeWebpToPng(
+                Preconditions.checkNotNull(inputStream),
+                Preconditions.checkNotNull(outputStream));
+    }
+
+    @DoNotStrip
+    private static native void nativeTranscodeWebpToJpeg(
+            InputStream inputStream,
+            OutputStream outputStream,
+            int quality) throws IOException;
+
+    @DoNotStrip
+    private static native void nativeTranscodeWebpToPng(
+            InputStream inputStream,
+            OutputStream outputStream) throws IOException;
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/AddImageTransformMetaDataProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/AddImageTransformMetaDataProducer.java
index 145cf67e5..4dd716a04 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/AddImageTransformMetaDataProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/AddImageTransformMetaDataProducer.java
@@ -21,59 +21,59 @@
 
 /**
  * Add image transform meta data producer
- *
+ * <p>
  * <p>Extracts meta data from the results passed down from the next producer, and adds it to the
  * result that it returns to the consumer.
  */
 public class AddImageTransformMetaDataProducer
-    implements Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> {
-  private final Producer<CloseableReference<PooledByteBuffer>> mNextProducer;
+        implements Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> {
+    private final Producer<CloseableReference<PooledByteBuffer>> mNextProducer;
 
-  public AddImageTransformMetaDataProducer(
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    mNextProducer = nextProducer;
-  }
+    public AddImageTransformMetaDataProducer(
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        mNextProducer = nextProducer;
+    }
 
-  @Override
-  public void produceResults(
-      Consumer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> consumer,
-      ProducerContext context) {
-    mNextProducer.produceResults(new AddImageTransformMetaDataConsumer(consumer), context);
-  }
+    @Override
+    public void produceResults(
+            Consumer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> consumer,
+            ProducerContext context) {
+        mNextProducer.produceResults(new AddImageTransformMetaDataConsumer(consumer), context);
+    }
 
-  private class AddImageTransformMetaDataConsumer extends DelegatingConsumer<
-      CloseableReference<PooledByteBuffer>,
-      Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> {
-    private final ImageTransformMetaData.Builder mMetaDataBuilder;
+    private class AddImageTransformMetaDataConsumer extends DelegatingConsumer<
+            CloseableReference<PooledByteBuffer>,
+            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> {
+        private final ImageTransformMetaData.Builder mMetaDataBuilder;
 
-    private AddImageTransformMetaDataConsumer(
-        Consumer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> consumer) {
-      super(consumer);
-      mMetaDataBuilder = new ImageTransformMetaData.Builder();
-    }
+        private AddImageTransformMetaDataConsumer(
+                Consumer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> consumer) {
+            super(consumer);
+            mMetaDataBuilder = new ImageTransformMetaData.Builder();
+        }
 
-    @Override
-    protected void onNewResultImpl(
-        CloseableReference<PooledByteBuffer> newResult, boolean isLast) {
-      final ImageFormat imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(
-          new PooledByteBufferInputStream(newResult.get()));
-      mMetaDataBuilder.reset();
-      mMetaDataBuilder.setImageFormat(imageFormat);
-      if (imageFormat == ImageFormat.JPEG && isLast) {
-        mMetaDataBuilder.setRotationAngle(getRotationAngle(newResult));
-        Rect dimensions = JfifUtil.getDimensions(new PooledByteBufferInputStream(newResult.get()));
-        if (dimensions != null) {
-          mMetaDataBuilder.setWidth(dimensions.width());
-          mMetaDataBuilder.setHeight(dimensions.height());
+        @Override
+        protected void onNewResultImpl(
+                CloseableReference<PooledByteBuffer> newResult, boolean isLast) {
+            final ImageFormat imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(
+                    new PooledByteBufferInputStream(newResult.get()));
+            mMetaDataBuilder.reset();
+            mMetaDataBuilder.setImageFormat(imageFormat);
+            if (imageFormat == ImageFormat.JPEG && isLast) {
+                mMetaDataBuilder.setRotationAngle(getRotationAngle(newResult));
+                Rect dimensions = JfifUtil.getDimensions(new PooledByteBufferInputStream(newResult.get()));
+                if (dimensions != null) {
+                    mMetaDataBuilder.setWidth(dimensions.width());
+                    mMetaDataBuilder.setHeight(dimensions.height());
+                }
+            }
+            getConsumer().onNewResult(Pair.create(newResult, mMetaDataBuilder.build()), isLast);
         }
-      }
-      getConsumer().onNewResult(Pair.create(newResult, mMetaDataBuilder.build()), isLast);
-    }
 
-    // Gets the correction angle based on the image's orientation
-    private int getRotationAngle(final CloseableReference<PooledByteBuffer> inputRef) {
-      return JfifUtil.getAutoRotateAngleFromOrientation(
-          JfifUtil.getOrientation(new PooledByteBufferInputStream(inputRef.get())));
+        // Gets the correction angle based on the image's orientation
+        private int getRotationAngle(final CloseableReference<PooledByteBuffer> inputRef) {
+            return JfifUtil.getAutoRotateAngleFromOrientation(
+                    JfifUtil.getOrientation(new PooledByteBufferInputStream(inputRef.get())));
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseConsumer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseConsumer.java
index a3fba11c2..e8f6dab8d 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseConsumer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseConsumer.java
@@ -17,10 +17,10 @@
 /**
  * Base implementation of Consumer that implements error handling conforming to the
  * Consumer's contract.
- *
+ * <p>
  * <p> This class also prevents execution of callbacks if one of final methods was called before:
  * onFinish(isLast = true), onFailure or onCancellation.
- *
+ * <p>
  * <p> All callbacks are executed within a synchronized block, so that clients can act as if all
  * callbacks are called on single thread.
  *
@@ -29,97 +29,97 @@
 @ThreadSafe
 public abstract class BaseConsumer<T> implements Consumer<T> {
 
-  /**
-   * Set to true when onNewResult(isLast = true), onFailure or onCancellation is called. Further
-   * calls to any of the 3 methods are not propagated
-   */
-  private boolean mIsFinished;
-
-  public BaseConsumer() {
-    mIsFinished = false;
-  }
+    /**
+     * Set to true when onNewResult(isLast = true), onFailure or onCancellation is called. Further
+     * calls to any of the 3 methods are not propagated
+     */
+    private boolean mIsFinished;
 
-  @Override
-  public synchronized void onNewResult(@Nullable T newResult, boolean isLast) {
-    if (mIsFinished) {
-      return;
+    public BaseConsumer() {
+        mIsFinished = false;
     }
-    mIsFinished = isLast;
-    try {
-      onNewResultImpl(newResult, isLast);
-    } catch (Exception e) {
-      onUnhandledException(e);
-    }
-  }
 
-  @Override
-  public synchronized void onFailure(Throwable t) {
-    if (mIsFinished) {
-      return;
-    }
-    mIsFinished = true;
-    try {
-      onFailureImpl(t);
-    } catch (Exception e) {
-      onUnhandledException(e);
+    @Override
+    public synchronized void onNewResult(@Nullable T newResult, boolean isLast) {
+        if (mIsFinished) {
+            return;
+        }
+        mIsFinished = isLast;
+        try {
+            onNewResultImpl(newResult, isLast);
+        } catch (Exception e) {
+            onUnhandledException(e);
+        }
     }
-  }
 
-  @Override
-  public synchronized void onCancellation() {
-    if (mIsFinished) {
-      return;
+    @Override
+    public synchronized void onFailure(Throwable t) {
+        if (mIsFinished) {
+            return;
+        }
+        mIsFinished = true;
+        try {
+            onFailureImpl(t);
+        } catch (Exception e) {
+            onUnhandledException(e);
+        }
     }
-    mIsFinished = true;
-    try {
-      onCancellationImpl();
-    } catch (Exception e) {
-      onUnhandledException(e);
-    }
-  }
 
-  /**
-   * Called when the progress updates.
-   *
-   * @param progress in range [0, 1]
-   */
-  @Override
-  public synchronized void onProgressUpdate(float progress) {
-    if (mIsFinished) {
-      return;
+    @Override
+    public synchronized void onCancellation() {
+        if (mIsFinished) {
+            return;
+        }
+        mIsFinished = true;
+        try {
+            onCancellationImpl();
+        } catch (Exception e) {
+            onUnhandledException(e);
+        }
     }
-    try {
-      onProgressUpdateImpl(progress);
-    } catch (Exception e) {
-      onUnhandledException(e);
+
+    /**
+     * Called when the progress updates.
+     *
+     * @param progress in range [0, 1]
+     */
+    @Override
+    public synchronized void onProgressUpdate(float progress) {
+        if (mIsFinished) {
+            return;
+        }
+        try {
+            onProgressUpdateImpl(progress);
+        } catch (Exception e) {
+            onUnhandledException(e);
+        }
     }
-  }
 
-  /**
-   * Called by onNewResult, override this method instead.
-   */
-  protected abstract void onNewResultImpl(T newResult, boolean isLast);
+    /**
+     * Called by onNewResult, override this method instead.
+     */
+    protected abstract void onNewResultImpl(T newResult, boolean isLast);
 
-  /**
-   * Called by onFailure, override this method instead
-   */
-  protected abstract void onFailureImpl(Throwable t);
+    /**
+     * Called by onFailure, override this method instead
+     */
+    protected abstract void onFailureImpl(Throwable t);
 
-  /**
-   * Called by onCancellation, override this method instead
-   */
-  protected abstract void onCancellationImpl();
+    /**
+     * Called by onCancellation, override this method instead
+     */
+    protected abstract void onCancellationImpl();
 
-  /**
-   * Called when the progress updates
-   */
-  protected void onProgressUpdateImpl(float progress) {
-  }
+    /**
+     * Called when the progress updates
+     */
+    protected void onProgressUpdateImpl(float progress) {
+    }
 
-  /**
-   * Called whenever onNewResultImpl or onFailureImpl throw an exception
-   */
-  protected void onUnhandledException(Exception e) {
-    FLog.wtf(this.getClass(), "unhandled exception", e);
-  }
+    /**
+     * Called whenever onNewResultImpl or onFailureImpl throw an exception
+     */
+    protected void onUnhandledException(Exception e) {
+        FLog.wtf(this.getClass(), "unhandled exception", e);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseNetworkFetcher.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseNetworkFetcher.java
index 30ad69c99..400067090 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseNetworkFetcher.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseNetworkFetcher.java
@@ -15,26 +15,26 @@
 
 /**
  * Base class for {@link NetworkFetcher}.
- *
+ * <p>
  * <p> Intermediate results are propagated.
  * <p> {#code getExtraMap} returns null.
  */
 public abstract class BaseNetworkFetcher<FETCH_STATE extends FetchState>
-    implements NetworkFetcher<FETCH_STATE> {
+        implements NetworkFetcher<FETCH_STATE> {
 
-  @Override
-  public boolean shouldPropagate(FETCH_STATE fetchState) {
-    return true;
-  }
+    @Override
+    public boolean shouldPropagate(FETCH_STATE fetchState) {
+        return true;
+    }
 
-  @Override
-  public void onFetchCompletion(FETCH_STATE fetchState, int byteSize) {
-    // no-op
-  }
+    @Override
+    public void onFetchCompletion(FETCH_STATE fetchState, int byteSize) {
+        // no-op
+    }
 
-  @Nullable
-  @Override
-  public Map<String, String> getExtraMap(FETCH_STATE fetchState, int byteSize) {
-    return null;
-  }
+    @Nullable
+    @Override
+    public Map<String, String> getExtraMap(FETCH_STATE fetchState, int byteSize) {
+        return null;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseProducerContextCallbacks.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseProducerContextCallbacks.java
index b6d03d3d0..b3e72e404 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseProducerContextCallbacks.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BaseProducerContextCallbacks.java
@@ -14,19 +14,19 @@
  */
 public class BaseProducerContextCallbacks implements ProducerContextCallbacks {
 
-  @Override
-  public void onCancellationRequested() {
-  }
+    @Override
+    public void onCancellationRequested() {
+    }
 
-  @Override
-  public void onIsPrefetchChanged() {
-  }
+    @Override
+    public void onIsPrefetchChanged() {
+    }
 
-  @Override
-  public void onIsIntermediateResultExpectedChanged() {
-  }
+    @Override
+    public void onIsIntermediateResultExpectedChanged() {
+    }
 
-  @Override
-  public void onPriorityChanged() {
-  }
+    @Override
+    public void onPriorityChanged() {
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheGetProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheGetProducer.java
index 431e1b1db..ec3298fb7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheGetProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheGetProducer.java
@@ -22,47 +22,48 @@
  * Memory cache producer for the bitmap memory cache.
  */
 public class BitmapMemoryCacheGetProducer
-    extends MemoryCacheProducer<CacheKey, CloseableImage> {
-  @VisibleForTesting static final String PRODUCER_NAME = "BitmapMemoryCacheGetProducer";
+        extends MemoryCacheProducer<CacheKey, CloseableImage> {
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "BitmapMemoryCacheGetProducer";
 
-  public BitmapMemoryCacheGetProducer(
-      MemoryCache<CacheKey, CloseableImage> memoryCache,
-      CacheKeyFactory cacheKeyFactory,
-      Producer<CloseableReference<CloseableImage>> nextProducer) {
-    super(memoryCache, cacheKeyFactory, nextProducer);
-  }
+    public BitmapMemoryCacheGetProducer(
+            MemoryCache<CacheKey, CloseableImage> memoryCache,
+            CacheKeyFactory cacheKeyFactory,
+            Producer<CloseableReference<CloseableImage>> nextProducer) {
+        super(memoryCache, cacheKeyFactory, nextProducer);
+    }
 
-  @Override
-  protected CacheKey getCacheKey(ImageRequest imageRequest) {
-    return mCacheKeyFactory.getBitmapCacheKey(imageRequest);
-  }
+    @Override
+    protected CacheKey getCacheKey(ImageRequest imageRequest) {
+        return mCacheKeyFactory.getBitmapCacheKey(imageRequest);
+    }
 
-  @Override
-  protected boolean isResultFinal(
-      CloseableReference<CloseableImage> cachedResultFound) {
-    return cachedResultFound.get().getQualityInfo().isOfFullQuality();
-  }
+    @Override
+    protected boolean isResultFinal(
+            CloseableReference<CloseableImage> cachedResultFound) {
+        return cachedResultFound.get().getQualityInfo().isOfFullQuality();
+    }
 
-  @Override
-  protected ImageRequest.RequestLevel getProducerRequestLevel() {
-    return ImageRequest.RequestLevel.BITMAP_MEMORY_CACHE;
-  }
+    @Override
+    protected ImageRequest.RequestLevel getProducerRequestLevel() {
+        return ImageRequest.RequestLevel.BITMAP_MEMORY_CACHE;
+    }
 
-  @Override
-  protected boolean shouldCacheReturnedValues() {
-    return false;
-  }
+    @Override
+    protected boolean shouldCacheReturnedValues() {
+        return false;
+    }
 
-  @Override
-  protected boolean shouldCacheResult(
-      CloseableReference<CloseableImage> result,
-      CacheKey cacheKey,
-      boolean isLast) {
-    return false;
-  }
+    @Override
+    protected boolean shouldCacheResult(
+            CloseableReference<CloseableImage> result,
+            CacheKey cacheKey,
+            boolean isLast) {
+        return false;
+    }
 
-  @Override
-  protected String getProducerName() {
-    return PRODUCER_NAME;
-  }
+    @Override
+    protected String getProducerName() {
+        return PRODUCER_NAME;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheKeyMultiplexProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheKeyMultiplexProducer.java
index f2685149f..7f52d03b7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheKeyMultiplexProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheKeyMultiplexProducer.java
@@ -20,22 +20,22 @@
  * Multiplex producer that uses the bitmap memory cache key to combine requests.
  */
 public class BitmapMemoryCacheKeyMultiplexProducer extends
-    MultiplexProducer<Pair<CacheKey, ImageRequest.RequestLevel>, CloseableImage> {
-
-  private final CacheKeyFactory mCacheKeyFactory;
-
-  public BitmapMemoryCacheKeyMultiplexProducer(
-      CacheKeyFactory cacheKeyFactory,
-      Producer nextProducer) {
-    super(nextProducer);
-    mCacheKeyFactory = cacheKeyFactory;
-  }
-
-  protected Pair<CacheKey, ImageRequest.RequestLevel> getKey(
-      ProducerContext producerContext) {
-    return Pair.create(
-        mCacheKeyFactory.getBitmapCacheKey(producerContext.getImageRequest()),
-        producerContext.getLowestPermittedRequestLevel());
-  }
+        MultiplexProducer<Pair<CacheKey, ImageRequest.RequestLevel>, CloseableImage> {
+
+    private final CacheKeyFactory mCacheKeyFactory;
+
+    public BitmapMemoryCacheKeyMultiplexProducer(
+            CacheKeyFactory cacheKeyFactory,
+            Producer nextProducer) {
+        super(nextProducer);
+        mCacheKeyFactory = cacheKeyFactory;
+    }
+
+    protected Pair<CacheKey, ImageRequest.RequestLevel> getKey(
+            ProducerContext producerContext) {
+        return Pair.create(
+                mCacheKeyFactory.getBitmapCacheKey(producerContext.getImageRequest()),
+                producerContext.getLowestPermittedRequestLevel());
+    }
 
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheProducer.java
index 6b32d54be..5752b60c4 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BitmapMemoryCacheProducer.java
@@ -22,66 +22,67 @@
  * Memory cache producer for the bitmap memory cache.
  */
 public class BitmapMemoryCacheProducer
-    extends MemoryCacheProducer<CacheKey, CloseableImage> {
-  @VisibleForTesting static final String PRODUCER_NAME = "BitmapMemoryCacheProducer";
+        extends MemoryCacheProducer<CacheKey, CloseableImage> {
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "BitmapMemoryCacheProducer";
 
-  public BitmapMemoryCacheProducer(
-      MemoryCache<CacheKey, CloseableImage> memoryCache,
-      CacheKeyFactory cacheKeyFactory,
-      Producer<CloseableReference<CloseableImage>> nextProducer) {
-    super(memoryCache, cacheKeyFactory, nextProducer);
-  }
-
-  @Override
-  protected CacheKey getCacheKey(ImageRequest imageRequest) {
-    return mCacheKeyFactory.getBitmapCacheKey(imageRequest);
-  }
+    public BitmapMemoryCacheProducer(
+            MemoryCache<CacheKey, CloseableImage> memoryCache,
+            CacheKeyFactory cacheKeyFactory,
+            Producer<CloseableReference<CloseableImage>> nextProducer) {
+        super(memoryCache, cacheKeyFactory, nextProducer);
+    }
 
-  @Override
-  protected boolean isResultFinal(
-      CloseableReference<CloseableImage> cachedResultFound) {
-    return cachedResultFound.get().getQualityInfo().isOfFullQuality();
-  }
+    @Override
+    protected CacheKey getCacheKey(ImageRequest imageRequest) {
+        return mCacheKeyFactory.getBitmapCacheKey(imageRequest);
+    }
 
-  @Override
-  protected ImageRequest.RequestLevel getProducerRequestLevel() {
-    return ImageRequest.RequestLevel.BITMAP_MEMORY_CACHE;
-  }
+    @Override
+    protected boolean isResultFinal(
+            CloseableReference<CloseableImage> cachedResultFound) {
+        return cachedResultFound.get().getQualityInfo().isOfFullQuality();
+    }
 
-  @Override
-  protected boolean shouldCacheReturnedValues() {
-    return true;
-  }
+    @Override
+    protected ImageRequest.RequestLevel getProducerRequestLevel() {
+        return ImageRequest.RequestLevel.BITMAP_MEMORY_CACHE;
+    }
 
-  @Override
-  protected boolean shouldCacheResult(
-      CloseableReference<CloseableImage> result,
-      CacheKey cacheKey,
-      boolean isLast) {
-    if (result.get().isStateful()) {
-      return false;
+    @Override
+    protected boolean shouldCacheReturnedValues() {
+        return true;
     }
-    return isLast || shouldCacheIntermediateResult(result, cacheKey);
-  }
 
-  private boolean shouldCacheIntermediateResult(
-      CloseableReference<CloseableImage> newResult,
-      CacheKey cacheKey) {
-    CloseableReference<CloseableImage> currentCachedResult = mMemoryCache.get(cacheKey);
-    if (currentCachedResult == null) {
-      return true;
+    @Override
+    protected boolean shouldCacheResult(
+            CloseableReference<CloseableImage> result,
+            CacheKey cacheKey,
+            boolean isLast) {
+        if (result.get().isStateful()) {
+            return false;
+        }
+        return isLast || shouldCacheIntermediateResult(result, cacheKey);
     }
-    try {
-      QualityInfo currentQualityInfo = currentCachedResult.get().getQualityInfo();
-      return !currentQualityInfo.isOfFullQuality() &&
-          newResult.get().getQualityInfo().getQuality() > currentQualityInfo.getQuality();
-    } finally {
-      CloseableReference.closeSafely(currentCachedResult);
+
+    private boolean shouldCacheIntermediateResult(
+            CloseableReference<CloseableImage> newResult,
+            CacheKey cacheKey) {
+        CloseableReference<CloseableImage> currentCachedResult = mMemoryCache.get(cacheKey);
+        if (currentCachedResult == null) {
+            return true;
+        }
+        try {
+            QualityInfo currentQualityInfo = currentCachedResult.get().getQualityInfo();
+            return !currentQualityInfo.isOfFullQuality() &&
+                    newResult.get().getQualityInfo().getQuality() > currentQualityInfo.getQuality();
+        } finally {
+            CloseableReference.closeSafely(currentCachedResult);
+        }
     }
-  }
 
-  @Override
-  protected String getProducerName() {
-    return PRODUCER_NAME;
-  }
+    @Override
+    protected String getProducerName() {
+        return PRODUCER_NAME;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducer.java
index a3bc87771..1693eabfe 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/BranchOnSeparateImagesProducer.java
@@ -17,75 +17,75 @@
 
 /**
  * Producer that coordinates fetching two separate images.
- *
+ * <p>
  * <p>The first producer is kicked off, and once it has returned all its results, the second
  * producer is kicked off if necessary.
  */
 public class BranchOnSeparateImagesProducer
-    implements Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> {
-  private final Producer<
-      Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> mNextProducer1;
-  private final Producer<
-      Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> mNextProducer2;
+        implements Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> {
+    private final Producer<
+            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> mNextProducer1;
+    private final Producer<
+            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> mNextProducer2;
 
-  public BranchOnSeparateImagesProducer(
-      Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer1,
-      Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer2) {
-    mNextProducer1 = nextProducer1;
-    mNextProducer2 = nextProducer2;
-  }
+    public BranchOnSeparateImagesProducer(
+            Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer1,
+            Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer2) {
+        mNextProducer1 = nextProducer1;
+        mNextProducer2 = nextProducer2;
+    }
 
-  @Override
-  public void produceResults(
-      Consumer<Pair<CloseableReference<PooledByteBuffer>,
-          ImageTransformMetaData>> consumer,
-      ProducerContext context) {
-    OnFirstImageConsumer onFirstImageConsumer = new OnFirstImageConsumer(consumer, context);
-    mNextProducer1.produceResults(onFirstImageConsumer, context);
-  }
+    @Override
+    public void produceResults(
+            Consumer<Pair<CloseableReference<PooledByteBuffer>,
+                    ImageTransformMetaData>> consumer,
+            ProducerContext context) {
+        OnFirstImageConsumer onFirstImageConsumer = new OnFirstImageConsumer(consumer, context);
+        mNextProducer1.produceResults(onFirstImageConsumer, context);
+    }
 
-  private class OnFirstImageConsumer extends DelegatingConsumer<
-      Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>,
-      Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> {
+    private class OnFirstImageConsumer extends DelegatingConsumer<
+            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>,
+            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> {
 
-    private ProducerContext mProducerContext;
+        private ProducerContext mProducerContext;
 
-    private OnFirstImageConsumer(
-        Consumer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> consumer,
-        ProducerContext producerContext) {
-      super(consumer);
-      mProducerContext = producerContext;
-    }
+        private OnFirstImageConsumer(
+                Consumer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> consumer,
+                ProducerContext producerContext) {
+            super(consumer);
+            mProducerContext = producerContext;
+        }
 
-    @Override
-    protected void onNewResultImpl(
-        Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> newResult,
-        boolean isLast) {
-      ImageRequest request = mProducerContext.getImageRequest();
-      boolean isGoodEnough = isResultGoodEnough(newResult, request);
-      if (newResult != null && (isGoodEnough || request.getLocalThumbnailPreviewsEnabled())) {
-        getConsumer().onNewResult(newResult, isLast && isGoodEnough);
-      }
-      if (isLast && !isGoodEnough) {
-        mNextProducer2.produceResults(getConsumer(), mProducerContext);
-      }
-    }
+        @Override
+        protected void onNewResultImpl(
+                Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> newResult,
+                boolean isLast) {
+            ImageRequest request = mProducerContext.getImageRequest();
+            boolean isGoodEnough = isResultGoodEnough(newResult, request);
+            if (newResult != null && (isGoodEnough || request.getLocalThumbnailPreviewsEnabled())) {
+                getConsumer().onNewResult(newResult, isLast && isGoodEnough);
+            }
+            if (isLast && !isGoodEnough) {
+                mNextProducer2.produceResults(getConsumer(), mProducerContext);
+            }
+        }
 
-    @Override
-    protected void onFailureImpl(Throwable t) {
-      mNextProducer2.produceResults(getConsumer(), mProducerContext);
-    }
+        @Override
+        protected void onFailureImpl(Throwable t) {
+            mNextProducer2.produceResults(getConsumer(), mProducerContext);
+        }
 
-    private boolean isResultGoodEnough(
-        Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> newResult,
-        ImageRequest imageRequest) {
-      if (newResult == null) {
-        return false;
-      }
+        private boolean isResultGoodEnough(
+                Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> newResult,
+                ImageRequest imageRequest) {
+            if (newResult == null) {
+                return false;
+            }
 
-      ImageTransformMetaData metaData = newResult.second;
-      return metaData.getWidth() >= imageRequest.getPreferredWidth() &&
-          metaData.getHeight() >= imageRequest.getPreferredHeight();
+            ImageTransformMetaData metaData = newResult.second;
+            return metaData.getWidth() >= imageRequest.getPreferredWidth() &&
+                    metaData.getHeight() >= imageRequest.getPreferredHeight();
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/Consumer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/Consumer.java
index 1feb8d3eb..043c3d77d 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/Consumer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/Consumer.java
@@ -11,22 +11,22 @@
 
 /**
  * Consumes data produced by {@link Producer}.<T>
- *
+ * <p>
  * <p> The producer uses this interface to notify its client when new data is ready or an error
  * occurs. Execution of the image request is structured as a sequence of Producers. Each one
  * consumes data produced by producer preceding it in the sequence.
- *
+ * <p>
  * <p>For example decode is a producer that consumes data produced by the disk cache get producer.
- *
+ * <p>
  * <p> The consumer is passed new intermediate results via onNewResult(isLast = false) method. Each
  * consumer should expect that one of the following methods will be called exactly once, as the very
  * last producer call:
  * <ul>
- *   <li> onNewResult(isLast = true) if producer finishes successfully with a final result </li>
- *   <li> onFailure if producer failed to produce a final result </li>
- *   <li> onCancellation if producer was cancelled before a final result could be created </li>
+ * <li> onNewResult(isLast = true) if producer finishes successfully with a final result </li>
+ * <li> onFailure if producer failed to produce a final result </li>
+ * <li> onCancellation if producer was cancelled before a final result could be created </li>
  * </ul>
- *
+ * <p>
  * <p> Implementations of this interface must be thread safe, as callback methods might be called
  * on different threads.
  *
@@ -34,35 +34,35 @@
  */
 public interface Consumer<T> {
 
-  /**
-   * Called by a producer whenever new data is produced. This method should not throw an exception.
-   *
-   * <p> In case when result is closeable resource producer will close it after onNewResult returns.
-   * Consumer needs to make copy of it if the resource must be accessed after that. Fortunately,
-   * with CloseableReferences, that should not impose too much overhead.
-   *
-   * @param newResult
-   * @param isLast true if newResult is the last result
-   */
-  void onNewResult(T newResult, boolean isLast);
+    /**
+     * Called by a producer whenever new data is produced. This method should not throw an exception.
+     * <p>
+     * <p> In case when result is closeable resource producer will close it after onNewResult returns.
+     * Consumer needs to make copy of it if the resource must be accessed after that. Fortunately,
+     * with CloseableReferences, that should not impose too much overhead.
+     *
+     * @param newResult
+     * @param isLast    true if newResult is the last result
+     */
+    void onNewResult(T newResult, boolean isLast);
 
-  /**
-   * Called by a producer whenever it terminates further work due to Throwable being thrown. This
-   * method should not throw an exception.
-   *
-   * @param t
-   */
-  void onFailure(Throwable t);
+    /**
+     * Called by a producer whenever it terminates further work due to Throwable being thrown. This
+     * method should not throw an exception.
+     *
+     * @param t
+     */
+    void onFailure(Throwable t);
 
-  /**
-   * Called by a producer whenever it is cancelled and won't produce any more results
-   */
-  void onCancellation();
+    /**
+     * Called by a producer whenever it is cancelled and won't produce any more results
+     */
+    void onCancellation();
 
-  /**
-   * Called when the progress updates.
-   *
-   * @param progress in range [0, 1]
-   */
-  void onProgressUpdate(float progress);
+    /**
+     * Called when the progress updates.
+     *
+     * @param progress in range [0, 1]
+     */
+    void onProgressUpdate(float progress);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java
index fdc6e7515..3905af7de 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java
@@ -38,370 +38,382 @@
 
 /**
  * Decodes images.
- *
+ * <p>
  * <p/> Progressive JPEGs are decoded progressively as new data arrives.
  */
 public class DecodeProducer implements Producer<CloseableReference<CloseableImage>> {
 
-  public static final String PRODUCER_NAME = "DecodeProducer";
-
-  // keys for extra map
-  private static final String QUEUE_TIME_KEY = "queueTime";
-  private static final String HAS_GOOD_QUALITY_KEY = "hasGoodQuality";
-  private static final String IS_FINAL_KEY = "isFinal";
-
-  private final ByteArrayPool mByteArrayPool;
-  private final Executor mExecutor;
-  private final ImageDecoder mImageDecoder;
-  private final ProgressiveJpegConfig mProgressiveJpegConfig;
-  private final Producer<CloseableReference<PooledByteBuffer>> mNextProducer;
-
-  public DecodeProducer(
-      final ByteArrayPool byteArrayPool,
-      final Executor executor,
-      final ImageDecoder imageDecoder,
-      final ProgressiveJpegConfig progressiveJpegConfig,
-      final Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    mByteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    mExecutor = Preconditions.checkNotNull(executor);
-    mImageDecoder = Preconditions.checkNotNull(imageDecoder);
-    mProgressiveJpegConfig = Preconditions.checkNotNull(progressiveJpegConfig);
-    mNextProducer = Preconditions.checkNotNull(nextProducer);
-  }
-
-  @Override
-  public void produceResults(
-      final Consumer<CloseableReference<CloseableImage>> consumer,
-      final ProducerContext context) {
-    final ImageRequest imageRequest = context.getImageRequest();
-    ProgressiveDecoder progressiveDecoder;
-    if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) {
-      progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, context);
-    } else {
-      ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);
-      progressiveDecoder = new NetworkImagesProgressiveDecoder(
-          consumer,
-          context,
-          jpegParser,
-          mProgressiveJpegConfig);
-    }
-    mNextProducer.produceResults(progressiveDecoder, context);
-  }
-
-  @VisibleForTesting
-  abstract class ProgressiveDecoder extends DelegatingConsumer<
-      CloseableReference<PooledByteBuffer>,
-      CloseableReference<CloseableImage>> {
-
-    protected final ProducerContext mProducerContext;
-    private final ProducerListener mProducerListener;
-    private final ImageDecodeOptions mImageDecodeOptions;
-
-    private final Runnable mSubmitDecodeRunnable;
-
-    @GuardedBy("this")
-    private boolean mIsFinished;
-
-    // This class is responsible for closing old, non-null reference, and for storing the reference
-    // to the latest data. One thing to note is that the reference is overtaken in doDecode().
-    // Right before decode happens, reference is cloned (to be held during the decode), and then
-    // released (so that we don't issue another decode of the same image). The cloned reference gets
-    // released after decode finishes. As a slight optimization, instead of cloning and releasing,
-    // reference is just moved.
-    @GuardedBy("this")
-    @VisibleForTesting CloseableReference<PooledByteBuffer> mImageBytesRef;
-    @GuardedBy("this")
-    private boolean mIsLast;
-    @GuardedBy("this")
-    private boolean mIsDecodeSubmitted;
-    @GuardedBy("this")
-    private long mLastDecodeTime;
-
-    public ProgressiveDecoder(
-        final Consumer<CloseableReference<CloseableImage>> consumer,
-        final ProducerContext producerContext) {
-      super(consumer);
-      mProducerContext = producerContext;
-      mProducerListener = producerContext.getListener();
-      mImageDecodeOptions = producerContext.getImageRequest().getImageDecodeOptions();
-      mIsFinished = false;
-      mProducerContext.addCallbacks(
-          new BaseProducerContextCallbacks() {
-            @Override
-            public void onIsIntermediateResultExpectedChanged() {
-              if (mProducerContext.isIntermediateResultExpected()) {
-                scheduleDecodeJob(mImageDecodeOptions.minDecodeIntervalMs);
-              }
-            }
-          });
-      mSubmitDecodeRunnable = new Runnable() {
-        @Override
-        public void run() {
-          submitDecode();
-        }
-      };
-    }
+    public static final String PRODUCER_NAME = "DecodeProducer";
 
-    @Override
-    public void onNewResultImpl(CloseableReference<PooledByteBuffer> newResult, boolean isLast) {
-      if (!updateDecodeJob(newResult, isLast)) {
-        return;
-      }
-      if (isLast || mProducerContext.isIntermediateResultExpected()) {
-        scheduleDecodeJob(isLast ? 0 : mImageDecodeOptions.minDecodeIntervalMs);
-      }
-    }
+    // keys for extra map
+    private static final String QUEUE_TIME_KEY = "queueTime";
+    private static final String HAS_GOOD_QUALITY_KEY = "hasGoodQuality";
+    private static final String IS_FINAL_KEY = "isFinal";
 
-    @Override
-    public void onFailureImpl(Throwable t) {
-      handleError(t);
+    private final ByteArrayPool mByteArrayPool;
+    private final Executor mExecutor;
+    private final ImageDecoder mImageDecoder;
+    private final ProgressiveJpegConfig mProgressiveJpegConfig;
+    private final Producer<CloseableReference<PooledByteBuffer>> mNextProducer;
+
+    public DecodeProducer(
+            final ByteArrayPool byteArrayPool,
+            final Executor executor,
+            final ImageDecoder imageDecoder,
+            final ProgressiveJpegConfig progressiveJpegConfig,
+            final Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        mByteArrayPool = Preconditions.checkNotNull(byteArrayPool);
+        mExecutor = Preconditions.checkNotNull(executor);
+        mImageDecoder = Preconditions.checkNotNull(imageDecoder);
+        mProgressiveJpegConfig = Preconditions.checkNotNull(progressiveJpegConfig);
+        mNextProducer = Preconditions.checkNotNull(nextProducer);
     }
 
     @Override
-    public void onCancellationImpl() {
-      handleCancellation();
+    public void produceResults(
+            final Consumer<CloseableReference<CloseableImage>> consumer,
+            final ProducerContext context) {
+        final ImageRequest imageRequest = context.getImageRequest();
+        ProgressiveDecoder progressiveDecoder;
+        if (!UriUtil.isNetworkUri(imageRequest.getSourceUri())) {
+            progressiveDecoder = new LocalImagesProgressiveDecoder(consumer, context);
+        } else {
+            ProgressiveJpegParser jpegParser = new ProgressiveJpegParser(mByteArrayPool);
+            progressiveDecoder = new NetworkImagesProgressiveDecoder(
+                    consumer,
+                    context,
+                    jpegParser,
+                    mProgressiveJpegConfig);
+        }
+        mNextProducer.produceResults(progressiveDecoder, context);
     }
 
-    /** Updates the decode job. */
-    protected synchronized boolean updateDecodeJob(
-        CloseableReference<PooledByteBuffer> imageBytesRef,
-        boolean isLast) {
-      // ignore invalid intermediate results (should not happen ever, but being defensive)
-      if (!isLast && !CloseableReference.isValid(imageBytesRef)) {
-        return false;
-      }
-      CloseableReference.closeSafely(mImageBytesRef);
-      mImageBytesRef = CloseableReference.cloneOrNull(imageBytesRef);
-      mIsLast = isLast;
-      return true;
-    }
+    @VisibleForTesting
+    abstract class ProgressiveDecoder extends DelegatingConsumer<
+            CloseableReference<PooledByteBuffer>,
+            CloseableReference<CloseableImage>> {
+
+        protected final ProducerContext mProducerContext;
+        private final ProducerListener mProducerListener;
+        private final ImageDecodeOptions mImageDecodeOptions;
+
+        private final Runnable mSubmitDecodeRunnable;
+
+        @GuardedBy("this")
+        private boolean mIsFinished;
+
+        // This class is responsible for closing old, non-null reference, and for storing the reference
+        // to the latest data. One thing to note is that the reference is overtaken in doDecode().
+        // Right before decode happens, reference is cloned (to be held during the decode), and then
+        // released (so that we don't issue another decode of the same image). The cloned reference gets
+        // released after decode finishes. As a slight optimization, instead of cloning and releasing,
+        // reference is just moved.
+        @GuardedBy("this")
+        @VisibleForTesting
+        CloseableReference<PooledByteBuffer> mImageBytesRef;
+        @GuardedBy("this")
+        private boolean mIsLast;
+        @GuardedBy("this")
+        private boolean mIsDecodeSubmitted;
+        @GuardedBy("this")
+        private long mLastDecodeTime;
+
+        public ProgressiveDecoder(
+                final Consumer<CloseableReference<CloseableImage>> consumer,
+                final ProducerContext producerContext) {
+            super(consumer);
+            mProducerContext = producerContext;
+            mProducerListener = producerContext.getListener();
+            mImageDecodeOptions = producerContext.getImageRequest().getImageDecodeOptions();
+            mIsFinished = false;
+            mProducerContext.addCallbacks(
+                    new BaseProducerContextCallbacks() {
+                        @Override
+                        public void onIsIntermediateResultExpectedChanged() {
+                            if (mProducerContext.isIntermediateResultExpected()) {
+                                scheduleDecodeJob(mImageDecodeOptions.minDecodeIntervalMs);
+                            }
+                        }
+                    });
+            mSubmitDecodeRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    submitDecode();
+                }
+            };
+        }
 
-    /** Schedules the decode, but no sooner than minDecodeIntervalMs since the last decode. */
-    private synchronized void scheduleDecodeJob(int minDecodeIntervalMs) {
-      if (!mIsDecodeSubmitted) {
-        mIsDecodeSubmitted = true;
-        long now = SystemClock.uptimeMillis();
-        long when = Math.max(mLastDecodeTime + minDecodeIntervalMs, now);
-        if (when > now) {
-          UiThreadExecutorService.getInstance()
-              .schedule(mSubmitDecodeRunnable, when - now, TimeUnit.MILLISECONDS);
-        } else {
-          mSubmitDecodeRunnable.run();
+        @Override
+        public void onNewResultImpl(CloseableReference<PooledByteBuffer> newResult, boolean isLast) {
+            if (!updateDecodeJob(newResult, isLast)) {
+                return;
+            }
+            if (isLast || mProducerContext.isIntermediateResultExpected()) {
+                scheduleDecodeJob(isLast ? 0 : mImageDecodeOptions.minDecodeIntervalMs);
+            }
+        }
+
+        @Override
+        public void onFailureImpl(Throwable t) {
+            handleError(t);
+        }
+
+        @Override
+        public void onCancellationImpl() {
+            handleCancellation();
         }
-      }
-    }
 
-    /** Submits the decode to the executor. */
-    protected void submitDecode() {
-      final long submitTime = SystemClock.uptimeMillis();
-      mExecutor.execute(
-          new Runnable() {
-            @Override
-            public void run() {
-              final long queueTime = SystemClock.uptimeMillis() - submitTime;
-              doDecode(queueTime);
+        /**
+         * Updates the decode job.
+         */
+        protected synchronized boolean updateDecodeJob(
+                CloseableReference<PooledByteBuffer> imageBytesRef,
+                boolean isLast) {
+            // ignore invalid intermediate results (should not happen ever, but being defensive)
+            if (!isLast && !CloseableReference.isValid(imageBytesRef)) {
+                return false;
             }
-          });
-    }
+            CloseableReference.closeSafely(mImageBytesRef);
+            mImageBytesRef = CloseableReference.cloneOrNull(imageBytesRef);
+            mIsLast = isLast;
+            return true;
+        }
 
-    /** Performs the decode synchronously. */
-    private void doDecode(long queueTime) {
-      CloseableReference<PooledByteBuffer> bytesRef;
-      boolean isLast;
-      synchronized (ProgressiveDecoder.this) {
-        bytesRef = mImageBytesRef;
-        mImageBytesRef = null;
-        isLast = mIsLast;
-        mIsDecodeSubmitted = false;
-        mLastDecodeTime = SystemClock.uptimeMillis();
-      }
-
-      try {
-        if (isFinished() || !CloseableReference.isValid(bytesRef)) {
-          return;
+        /**
+         * Schedules the decode, but no sooner than minDecodeIntervalMs since the last decode.
+         */
+        private synchronized void scheduleDecodeJob(int minDecodeIntervalMs) {
+            if (!mIsDecodeSubmitted) {
+                mIsDecodeSubmitted = true;
+                long now = SystemClock.uptimeMillis();
+                long when = Math.max(mLastDecodeTime + minDecodeIntervalMs, now);
+                if (when > now) {
+                    UiThreadExecutorService.getInstance()
+                            .schedule(mSubmitDecodeRunnable, when - now, TimeUnit.MILLISECONDS);
+                } else {
+                    mSubmitDecodeRunnable.run();
+                }
+            }
         }
 
-        ImageFormat format = isLast ? ImageFormat.UNKNOWN : getImageFormat(bytesRef);
-        int length = isLast ? bytesRef.get().size() : getIntermediateImageEndOffset(bytesRef);
-        QualityInfo quality = isLast ? ImmutableQualityInfo.FULL_QUALITY : getQualityInfo(bytesRef);
-
-        mProducerListener.onProducerStart(mProducerContext.getId(), PRODUCER_NAME);
-        CloseableImage decodedImage;
-        try {
-          decodedImage =
-              mImageDecoder.decodeImage(bytesRef, format, length, quality, mImageDecodeOptions);
-        } catch (Exception e) {
-          Map<String, String> extraMap = getExtraMap(queueTime, quality, isLast);
-          mProducerListener.
-              onProducerFinishWithFailure(mProducerContext.getId(), PRODUCER_NAME, e, extraMap);
-          handleError(e);
-          return;
+        /**
+         * Submits the decode to the executor.
+         */
+        protected void submitDecode() {
+            final long submitTime = SystemClock.uptimeMillis();
+            mExecutor.execute(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            final long queueTime = SystemClock.uptimeMillis() - submitTime;
+                            doDecode(queueTime);
+                        }
+                    });
         }
-        Map<String, String> extraMap = getExtraMap(queueTime, quality, isLast);
-        mProducerListener.
-            onProducerFinishWithSuccess(mProducerContext.getId(), PRODUCER_NAME, extraMap);
-        handleResult(decodedImage, isLast);
-      } finally {
-        CloseableReference.closeSafely(bytesRef);
-      }
-    }
 
-    private Map<String, String> getExtraMap(
-        final long queueTime,
-        final QualityInfo qualityInfo,
-        final boolean isFinal) {
-      if (!mProducerListener.requiresExtraMap(mProducerContext.getId())) {
-        return null;
-      }
-      return ImmutableMap.of(
-          QUEUE_TIME_KEY,
-          String.valueOf(queueTime),
-          HAS_GOOD_QUALITY_KEY,
-          String.valueOf(qualityInfo.isOfGoodEnoughQuality()),
-          IS_FINAL_KEY,
-          String.valueOf(isFinal));
-    }
+        /**
+         * Performs the decode synchronously.
+         */
+        private void doDecode(long queueTime) {
+            CloseableReference<PooledByteBuffer> bytesRef;
+            boolean isLast;
+            synchronized (ProgressiveDecoder.this) {
+                bytesRef = mImageBytesRef;
+                mImageBytesRef = null;
+                isLast = mIsLast;
+                mIsDecodeSubmitted = false;
+                mLastDecodeTime = SystemClock.uptimeMillis();
+            }
 
-    /**
-     * @return true if producer is finished
-     */
-    private synchronized boolean isFinished() {
-      return mIsFinished;
-    }
+            try {
+                if (isFinished() || !CloseableReference.isValid(bytesRef)) {
+                    return;
+                }
+
+                ImageFormat format = isLast ? ImageFormat.UNKNOWN : getImageFormat(bytesRef);
+                int length = isLast ? bytesRef.get().size() : getIntermediateImageEndOffset(bytesRef);
+                QualityInfo quality = isLast ? ImmutableQualityInfo.FULL_QUALITY : getQualityInfo(bytesRef);
+
+                mProducerListener.onProducerStart(mProducerContext.getId(), PRODUCER_NAME);
+                CloseableImage decodedImage;
+                try {
+                    decodedImage =
+                            mImageDecoder.decodeImage(bytesRef, format, length, quality, mImageDecodeOptions);
+                } catch (Exception e) {
+                    Map<String, String> extraMap = getExtraMap(queueTime, quality, isLast);
+                    mProducerListener.
+                            onProducerFinishWithFailure(mProducerContext.getId(), PRODUCER_NAME, e, extraMap);
+                    handleError(e);
+                    return;
+                }
+                Map<String, String> extraMap = getExtraMap(queueTime, quality, isLast);
+                mProducerListener.
+                        onProducerFinishWithSuccess(mProducerContext.getId(), PRODUCER_NAME, extraMap);
+                handleResult(decodedImage, isLast);
+            } finally {
+                CloseableReference.closeSafely(bytesRef);
+            }
+        }
 
-    /**
-     * Finishes if not already finished and {@code finish} is specified.
-     * <p> If just finished, the intermediate image gets released.
-     */
-    private synchronized void maybeFinish(boolean finish) {
-      if (mIsFinished) {
-        return;
-      }
-      mIsFinished = finish;
-      if (finish) {
-        CloseableReference.closeSafely(mImageBytesRef);
-        mImageBytesRef = null;
-      }
-    }
+        private Map<String, String> getExtraMap(
+                final long queueTime,
+                final QualityInfo qualityInfo,
+                final boolean isFinal) {
+            if (!mProducerListener.requiresExtraMap(mProducerContext.getId())) {
+                return null;
+            }
+            return ImmutableMap.of(
+                    QUEUE_TIME_KEY,
+                    String.valueOf(queueTime),
+                    HAS_GOOD_QUALITY_KEY,
+                    String.valueOf(qualityInfo.isOfGoodEnoughQuality()),
+                    IS_FINAL_KEY,
+                    String.valueOf(isFinal));
+        }
 
-    /**
-     * Notifies consumer of new result and finishes if the result is final.
-     */
-    private void handleResult(final CloseableImage decodedImage, final boolean isFinal) {
-      CloseableReference<CloseableImage> decodedImageRef = CloseableReference.of(decodedImage);
-      try {
-        maybeFinish(isFinal);
-        getConsumer().onNewResult(decodedImageRef, isFinal);
-      } finally {
-        CloseableReference.closeSafely(decodedImageRef);
-      }
-    }
+        /**
+         * @return true if producer is finished
+         */
+        private synchronized boolean isFinished() {
+            return mIsFinished;
+        }
 
-    /**
-     * Notifies consumer about the failure and finishes.
-     */
-    private void handleError(Throwable t) {
-      maybeFinish(true);
-      getConsumer().onFailure(t);
-    }
+        /**
+         * Finishes if not already finished and {@code finish} is specified.
+         * <p> If just finished, the intermediate image gets released.
+         */
+        private synchronized void maybeFinish(boolean finish) {
+            if (mIsFinished) {
+                return;
+            }
+            mIsFinished = finish;
+            if (finish) {
+                CloseableReference.closeSafely(mImageBytesRef);
+                mImageBytesRef = null;
+            }
+        }
 
-    /**
-     * Notifies consumer about the cancellation and finishes.
-     */
-    private void handleCancellation() {
-      maybeFinish(true);
-      getConsumer().onCancellation();
-    }
+        /**
+         * Notifies consumer of new result and finishes if the result is final.
+         */
+        private void handleResult(final CloseableImage decodedImage, final boolean isFinal) {
+            CloseableReference<CloseableImage> decodedImageRef = CloseableReference.of(decodedImage);
+            try {
+                maybeFinish(isFinal);
+                getConsumer().onNewResult(decodedImageRef, isFinal);
+            } finally {
+                CloseableReference.closeSafely(decodedImageRef);
+            }
+        }
 
-    /**
-     * All these abstract methods are thread-safe.
-     */
-    @Nullable protected abstract ImageFormat getImageFormat(
-        CloseableReference<PooledByteBuffer> imageBytesRef);
+        /**
+         * Notifies consumer about the failure and finishes.
+         */
+        private void handleError(Throwable t) {
+            maybeFinish(true);
+            getConsumer().onFailure(t);
+        }
 
-    protected abstract int getIntermediateImageEndOffset(
-        CloseableReference<PooledByteBuffer> imageBytesRef);
+        /**
+         * Notifies consumer about the cancellation and finishes.
+         */
+        private void handleCancellation() {
+            maybeFinish(true);
+            getConsumer().onCancellation();
+        }
 
-    protected abstract QualityInfo getQualityInfo(
-        CloseableReference<PooledByteBuffer> imageBytesRef);
-  }
+        /**
+         * All these abstract methods are thread-safe.
+         */
+        @Nullable
+        protected abstract ImageFormat getImageFormat(
+                CloseableReference<PooledByteBuffer> imageBytesRef);
 
-  class LocalImagesProgressiveDecoder extends ProgressiveDecoder {
+        protected abstract int getIntermediateImageEndOffset(
+                CloseableReference<PooledByteBuffer> imageBytesRef);
 
-    public LocalImagesProgressiveDecoder(
-        final Consumer<CloseableReference<CloseableImage>> consumer,
-        final ProducerContext producerContext) {
-      super(consumer, producerContext);
+        protected abstract QualityInfo getQualityInfo(
+                CloseableReference<PooledByteBuffer> imageBytesRef);
     }
 
-    @Override
-    @Nullable protected ImageFormat getImageFormat(
-        CloseableReference<PooledByteBuffer> imageBytesRef) {
-      return null;
-    }
+    class LocalImagesProgressiveDecoder extends ProgressiveDecoder {
 
-    @Override
-    protected int getIntermediateImageEndOffset(
-        CloseableReference<PooledByteBuffer> imageBytesRef) {
-      return imageBytesRef.get().size();
-    }
+        public LocalImagesProgressiveDecoder(
+                final Consumer<CloseableReference<CloseableImage>> consumer,
+                final ProducerContext producerContext) {
+            super(consumer, producerContext);
+        }
 
-    @Override
-    protected QualityInfo getQualityInfo(CloseableReference<PooledByteBuffer> imageBytesRef) {
-      return ImmutableQualityInfo.of(0, false, false);
-    }
-  }
+        @Override
+        @Nullable
+        protected ImageFormat getImageFormat(
+                CloseableReference<PooledByteBuffer> imageBytesRef) {
+            return null;
+        }
 
-  class NetworkImagesProgressiveDecoder extends ProgressiveDecoder {
-    private final ProgressiveJpegParser mProgressiveJpegParser;
-    private final ProgressiveJpegConfig mProgressiveJpegConfig;
-    private int mLastScheduledScanNumber;
-
-    public NetworkImagesProgressiveDecoder(
-        final Consumer<CloseableReference<CloseableImage>> consumer,
-        final ProducerContext producerContext,
-        final ProgressiveJpegParser progressiveJpegParser,
-        final ProgressiveJpegConfig progressiveJpegConfig) {
-      super(consumer, producerContext);
-      mProgressiveJpegParser = Preconditions.checkNotNull(progressiveJpegParser);
-      mProgressiveJpegConfig = Preconditions.checkNotNull(progressiveJpegConfig);
-      mLastScheduledScanNumber = 0;
+        @Override
+        protected int getIntermediateImageEndOffset(
+                CloseableReference<PooledByteBuffer> imageBytesRef) {
+            return imageBytesRef.get().size();
+        }
+
+        @Override
+        protected QualityInfo getQualityInfo(CloseableReference<PooledByteBuffer> imageBytesRef) {
+            return ImmutableQualityInfo.of(0, false, false);
+        }
     }
 
-    @Override
-    protected synchronized boolean updateDecodeJob(
-        CloseableReference<PooledByteBuffer> imageBytesRef,
-        boolean isLast) {
-      boolean ret = super.updateDecodeJob(imageBytesRef, isLast);
-      if (!isLast && CloseableReference.isValid(imageBytesRef)) {
-        if (!mProgressiveJpegParser.parseMoreData(imageBytesRef)) {
-          return false;
+    class NetworkImagesProgressiveDecoder extends ProgressiveDecoder {
+        private final ProgressiveJpegParser mProgressiveJpegParser;
+        private final ProgressiveJpegConfig mProgressiveJpegConfig;
+        private int mLastScheduledScanNumber;
+
+        public NetworkImagesProgressiveDecoder(
+                final Consumer<CloseableReference<CloseableImage>> consumer,
+                final ProducerContext producerContext,
+                final ProgressiveJpegParser progressiveJpegParser,
+                final ProgressiveJpegConfig progressiveJpegConfig) {
+            super(consumer, producerContext);
+            mProgressiveJpegParser = Preconditions.checkNotNull(progressiveJpegParser);
+            mProgressiveJpegConfig = Preconditions.checkNotNull(progressiveJpegConfig);
+            mLastScheduledScanNumber = 0;
         }
-        int scanNum = mProgressiveJpegParser.getBestScanNumber();
-        if (scanNum <= mLastScheduledScanNumber ||
-            scanNum < mProgressiveJpegConfig.getNextScanNumberToDecode(mLastScheduledScanNumber)) {
-          return false;
+
+        @Override
+        protected synchronized boolean updateDecodeJob(
+                CloseableReference<PooledByteBuffer> imageBytesRef,
+                boolean isLast) {
+            boolean ret = super.updateDecodeJob(imageBytesRef, isLast);
+            if (!isLast && CloseableReference.isValid(imageBytesRef)) {
+                if (!mProgressiveJpegParser.parseMoreData(imageBytesRef)) {
+                    return false;
+                }
+                int scanNum = mProgressiveJpegParser.getBestScanNumber();
+                if (scanNum <= mLastScheduledScanNumber ||
+                        scanNum < mProgressiveJpegConfig.getNextScanNumberToDecode(mLastScheduledScanNumber)) {
+                    return false;
+                }
+                mLastScheduledScanNumber = scanNum;
+            }
+            return ret;
         }
-        mLastScheduledScanNumber = scanNum;
-      }
-      return ret;
-    }
 
-    @Override
-    @Nullable protected ImageFormat getImageFormat(
-        CloseableReference<PooledByteBuffer> imageBytesRef) {
-      return mProgressiveJpegParser.isJpeg() ? ImageFormat.JPEG : ImageFormat.UNKNOWN;
-    }
+        @Override
+        @Nullable
+        protected ImageFormat getImageFormat(
+                CloseableReference<PooledByteBuffer> imageBytesRef) {
+            return mProgressiveJpegParser.isJpeg() ? ImageFormat.JPEG : ImageFormat.UNKNOWN;
+        }
 
-    @Override
-    protected int getIntermediateImageEndOffset(
-        CloseableReference<PooledByteBuffer> imageBytesRef) {
-      return mProgressiveJpegParser.getBestScanEndOffset();
-    }
+        @Override
+        protected int getIntermediateImageEndOffset(
+                CloseableReference<PooledByteBuffer> imageBytesRef) {
+            return mProgressiveJpegParser.getBestScanEndOffset();
+        }
 
-    @Override
-    protected QualityInfo getQualityInfo(CloseableReference<PooledByteBuffer> imageBytesRef) {
-      return mProgressiveJpegConfig.getQualityInfo(mProgressiveJpegParser.getBestScanNumber());
+        @Override
+        protected QualityInfo getQualityInfo(CloseableReference<PooledByteBuffer> imageBytesRef) {
+            return mProgressiveJpegConfig.getQualityInfo(mProgressiveJpegParser.getBestScanNumber());
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DelegatingConsumer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DelegatingConsumer.java
index 93c92a1ce..4ef4ba385 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DelegatingConsumer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DelegatingConsumer.java
@@ -13,28 +13,28 @@
  */
 public abstract class DelegatingConsumer<I, O> extends BaseConsumer<I> {
 
-  private final Consumer<O> mConsumer;
+    private final Consumer<O> mConsumer;
 
-  public DelegatingConsumer(Consumer<O> consumer) {
-    mConsumer = consumer;
-  }
+    public DelegatingConsumer(Consumer<O> consumer) {
+        mConsumer = consumer;
+    }
 
-  public Consumer<O> getConsumer() {
-    return mConsumer;
-  }
+    public Consumer<O> getConsumer() {
+        return mConsumer;
+    }
 
-  @Override
-  protected void onFailureImpl(Throwable t) {
-    mConsumer.onFailure(t);
-  }
+    @Override
+    protected void onFailureImpl(Throwable t) {
+        mConsumer.onFailure(t);
+    }
 
-  @Override
-  protected void onCancellationImpl() {
-    mConsumer.onCancellation();
-  }
+    @Override
+    protected void onCancellationImpl() {
+        mConsumer.onCancellation();
+    }
 
-  @Override
-  protected void onProgressUpdateImpl(float progress) {
-    mConsumer.onProgressUpdate(progress);
-  }
+    @Override
+    protected void onProgressUpdateImpl(float progress) {
+        mConsumer.onProgressUpdate(progress);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java
index 3e462c092..2edbd07b7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DiskCacheProducer.java
@@ -27,163 +27,165 @@
 
 /**
  * Disk cache producer.
- *
+ * <p>
  * <p>This producer looks in the disk cache for the requested image. If the image is found, then it
  * is passed to the consumer. If the image is not found, then the request is passed to the next
  * producer in the sequence. Any results that the producer returns are passed to the consumer, and
  * the last result is also put into the disk cache.
- *
+ * <p>
  * <p>This implementation delegates disk cache requests to BufferedDiskCache.
  */
 public class DiskCacheProducer implements Producer<CloseableReference<PooledByteBuffer>> {
-  @VisibleForTesting static final String PRODUCER_NAME = "DiskCacheProducer";
-  @VisibleForTesting static final String VALUE_FOUND = "cached_value_found";
-
-  private final BufferedDiskCache mDefaultBufferedDiskCache;
-  private final BufferedDiskCache mSmallImageBufferedDiskCache;
-  private final CacheKeyFactory mCacheKeyFactory;
-  private final Producer<CloseableReference<PooledByteBuffer>> mNextProducer;
-
-  public DiskCacheProducer(
-      BufferedDiskCache defaultBufferedDiskCache,
-      BufferedDiskCache smallImageBufferedDiskCache,
-      CacheKeyFactory cacheKeyFactory,
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    mDefaultBufferedDiskCache = defaultBufferedDiskCache;
-    mSmallImageBufferedDiskCache = smallImageBufferedDiskCache;
-    mCacheKeyFactory = cacheKeyFactory;
-    mNextProducer = nextProducer;
-  }
-
-  public void produceResults(
-      final Consumer<CloseableReference<PooledByteBuffer>> consumer,
-      final ProducerContext producerContext) {
-    ImageRequest imageRequest = producerContext.getImageRequest();
-    if (!imageRequest.isDiskCacheEnabled()) {
-      maybeStartNextProducer(consumer, consumer, producerContext);
-      return;
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "DiskCacheProducer";
+    @VisibleForTesting
+    static final String VALUE_FOUND = "cached_value_found";
+
+    private final BufferedDiskCache mDefaultBufferedDiskCache;
+    private final BufferedDiskCache mSmallImageBufferedDiskCache;
+    private final CacheKeyFactory mCacheKeyFactory;
+    private final Producer<CloseableReference<PooledByteBuffer>> mNextProducer;
+
+    public DiskCacheProducer(
+            BufferedDiskCache defaultBufferedDiskCache,
+            BufferedDiskCache smallImageBufferedDiskCache,
+            CacheKeyFactory cacheKeyFactory,
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        mDefaultBufferedDiskCache = defaultBufferedDiskCache;
+        mSmallImageBufferedDiskCache = smallImageBufferedDiskCache;
+        mCacheKeyFactory = cacheKeyFactory;
+        mNextProducer = nextProducer;
     }
 
-    final ProducerListener listener = producerContext.getListener();
-    final String requestId = producerContext.getId();
-    listener.onProducerStart(requestId, PRODUCER_NAME);
-
-    final CacheKey cacheKey = mCacheKeyFactory.getEncodedCacheKey(imageRequest);
-    final BufferedDiskCache cache =
-        imageRequest.getImageType() == ImageRequest.ImageType.SMALL
-            ? mSmallImageBufferedDiskCache
-            : mDefaultBufferedDiskCache;
-    Continuation<CloseableReference<PooledByteBuffer>, Void> continuation =
-        new Continuation<CloseableReference<PooledByteBuffer>, Void>() {
-          @Override
-          public Void then(Task<CloseableReference<PooledByteBuffer>> task)
-              throws Exception {
-            if (task.isCancelled() ||
-                (task.isFaulted() && task.getError() instanceof CancellationException)) {
-              listener.onProducerFinishWithCancellation(requestId, PRODUCER_NAME, null);
-              consumer.onCancellation();
-            } else if (task.isFaulted()) {
-              listener.onProducerFinishWithFailure(requestId, PRODUCER_NAME, task.getError(), null);
-              maybeStartNextProducer(
-                  consumer,
-                  new DiskCacheConsumer(consumer, cache, cacheKey),
-                  producerContext);
-            } else {
-              CloseableReference<PooledByteBuffer> cachedReference = task.getResult();
-              if (cachedReference != null) {
-                listener.onProducerFinishWithSuccess(
-                    requestId,
-                    PRODUCER_NAME,
-                    getExtraMap(listener, requestId, true));
-                consumer.onProgressUpdate(1);
-                consumer.onNewResult(cachedReference, true);
-                cachedReference.close();
-              } else {
-                listener.onProducerFinishWithSuccess(
-                    requestId,
-                    PRODUCER_NAME,
-                    getExtraMap(listener, requestId, false));
-                maybeStartNextProducer(
-                    consumer,
-                    new DiskCacheConsumer(consumer, cache, cacheKey),
-                    producerContext);
-              }
-            }
-            return null;
-          }
-        };
-
-    AtomicBoolean isCancelled = new AtomicBoolean(false);
-    final Task<CloseableReference<PooledByteBuffer>> diskCacheLookupTask =
-        cache.get(cacheKey, isCancelled);
-    diskCacheLookupTask.continueWith(continuation);
-    subscribeTaskForRequestCancellation(isCancelled, producerContext);
-  }
-
-  private void maybeStartNextProducer(
-      Consumer<CloseableReference<PooledByteBuffer>> consumerOfDiskCacheProducer,
-      Consumer<CloseableReference<PooledByteBuffer>> consumerOfNextProducer,
-      ProducerContext producerContext) {
-    if (producerContext.getLowestPermittedRequestLevel().getValue() >=
-        ImageRequest.RequestLevel.DISK_CACHE.getValue()) {
-      consumerOfDiskCacheProducer.onNewResult(null, true);
-      return;
+    public void produceResults(
+            final Consumer<CloseableReference<PooledByteBuffer>> consumer,
+            final ProducerContext producerContext) {
+        ImageRequest imageRequest = producerContext.getImageRequest();
+        if (!imageRequest.isDiskCacheEnabled()) {
+            maybeStartNextProducer(consumer, consumer, producerContext);
+            return;
+        }
+
+        final ProducerListener listener = producerContext.getListener();
+        final String requestId = producerContext.getId();
+        listener.onProducerStart(requestId, PRODUCER_NAME);
+
+        final CacheKey cacheKey = mCacheKeyFactory.getEncodedCacheKey(imageRequest);
+        final BufferedDiskCache cache =
+                imageRequest.getImageType() == ImageRequest.ImageType.SMALL
+                        ? mSmallImageBufferedDiskCache
+                        : mDefaultBufferedDiskCache;
+        Continuation<CloseableReference<PooledByteBuffer>, Void> continuation =
+                new Continuation<CloseableReference<PooledByteBuffer>, Void>() {
+                    @Override
+                    public Void then(Task<CloseableReference<PooledByteBuffer>> task)
+                            throws Exception {
+                        if (task.isCancelled() ||
+                                (task.isFaulted() && task.getError() instanceof CancellationException)) {
+                            listener.onProducerFinishWithCancellation(requestId, PRODUCER_NAME, null);
+                            consumer.onCancellation();
+                        } else if (task.isFaulted()) {
+                            listener.onProducerFinishWithFailure(requestId, PRODUCER_NAME, task.getError(), null);
+                            maybeStartNextProducer(
+                                    consumer,
+                                    new DiskCacheConsumer(consumer, cache, cacheKey),
+                                    producerContext);
+                        } else {
+                            CloseableReference<PooledByteBuffer> cachedReference = task.getResult();
+                            if (cachedReference != null) {
+                                listener.onProducerFinishWithSuccess(
+                                        requestId,
+                                        PRODUCER_NAME,
+                                        getExtraMap(listener, requestId, true));
+                                consumer.onProgressUpdate(1);
+                                consumer.onNewResult(cachedReference, true);
+                                cachedReference.close();
+                            } else {
+                                listener.onProducerFinishWithSuccess(
+                                        requestId,
+                                        PRODUCER_NAME,
+                                        getExtraMap(listener, requestId, false));
+                                maybeStartNextProducer(
+                                        consumer,
+                                        new DiskCacheConsumer(consumer, cache, cacheKey),
+                                        producerContext);
+                            }
+                        }
+                        return null;
+                    }
+                };
+
+        AtomicBoolean isCancelled = new AtomicBoolean(false);
+        final Task<CloseableReference<PooledByteBuffer>> diskCacheLookupTask =
+                cache.get(cacheKey, isCancelled);
+        diskCacheLookupTask.continueWith(continuation);
+        subscribeTaskForRequestCancellation(isCancelled, producerContext);
     }
 
-    mNextProducer.produceResults(consumerOfNextProducer, producerContext);
-  }
+    private void maybeStartNextProducer(
+            Consumer<CloseableReference<PooledByteBuffer>> consumerOfDiskCacheProducer,
+            Consumer<CloseableReference<PooledByteBuffer>> consumerOfNextProducer,
+            ProducerContext producerContext) {
+        if (producerContext.getLowestPermittedRequestLevel().getValue() >=
+                ImageRequest.RequestLevel.DISK_CACHE.getValue()) {
+            consumerOfDiskCacheProducer.onNewResult(null, true);
+            return;
+        }
+
+        mNextProducer.produceResults(consumerOfNextProducer, producerContext);
+    }
 
-  @VisibleForTesting
-  static Map<String, String> getExtraMap(
-      final ProducerListener listener,
-      final String requestId,
-      final boolean valueFound) {
-    if (!listener.requiresExtraMap(requestId)) {
-      return null;
+    @VisibleForTesting
+    static Map<String, String> getExtraMap(
+            final ProducerListener listener,
+            final String requestId,
+            final boolean valueFound) {
+        if (!listener.requiresExtraMap(requestId)) {
+            return null;
+        }
+        return ImmutableMap.of(VALUE_FOUND, String.valueOf(valueFound));
     }
-    return ImmutableMap.of(VALUE_FOUND, String.valueOf(valueFound));
-  }
-
-  private void subscribeTaskForRequestCancellation(
-      final AtomicBoolean isCancelled,
-      ProducerContext producerContext) {
-    producerContext.addCallbacks(
-        new BaseProducerContextCallbacks() {
-          @Override
-          public void onCancellationRequested() {
-            isCancelled.set(true);
-          }
-        });
-  }
-
-  /**
-   * Consumer that consumes results from next producer in the sequence.
-   *
-   * <p>The consumer puts the last result received into disk cache, and passes all results (success
-   * or failure) down to the next consumer.
-   */
-  private class DiskCacheConsumer extends DelegatingConsumer<
-          CloseableReference<PooledByteBuffer>,
-          CloseableReference<PooledByteBuffer>> {
-
-    private final BufferedDiskCache mCache;
-    private final CacheKey mCacheKey;
-
-    private DiskCacheConsumer(
-        final Consumer<CloseableReference<PooledByteBuffer>> consumer,
-        final BufferedDiskCache cache,
-        final CacheKey cacheKey) {
-      super(consumer);
-      mCache = cache;
-      mCacheKey = cacheKey;
+
+    private void subscribeTaskForRequestCancellation(
+            final AtomicBoolean isCancelled,
+            ProducerContext producerContext) {
+        producerContext.addCallbacks(
+                new BaseProducerContextCallbacks() {
+                    @Override
+                    public void onCancellationRequested() {
+                        isCancelled.set(true);
+                    }
+                });
     }
 
-    @Override
-    public void onNewResultImpl(CloseableReference<PooledByteBuffer> newResult, boolean isLast) {
-      if (newResult != null && isLast) {
-        mCache.put(mCacheKey, newResult);
-      }
-      getConsumer().onNewResult(newResult, isLast);
+    /**
+     * Consumer that consumes results from next producer in the sequence.
+     * <p>
+     * <p>The consumer puts the last result received into disk cache, and passes all results (success
+     * or failure) down to the next consumer.
+     */
+    private class DiskCacheConsumer extends DelegatingConsumer<
+            CloseableReference<PooledByteBuffer>,
+            CloseableReference<PooledByteBuffer>> {
+
+        private final BufferedDiskCache mCache;
+        private final CacheKey mCacheKey;
+
+        private DiskCacheConsumer(
+                final Consumer<CloseableReference<PooledByteBuffer>> consumer,
+                final BufferedDiskCache cache,
+                final CacheKey cacheKey) {
+            super(consumer);
+            mCache = cache;
+            mCacheKey = cacheKey;
+        }
+
+        @Override
+        public void onNewResultImpl(CloseableReference<PooledByteBuffer> newResult, boolean isLast) {
+            if (newResult != null && isLast) {
+                mCache.put(mCacheKey, newResult);
+            }
+            getConsumer().onNewResult(newResult, isLast);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedCacheKeyMultiplexProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedCacheKeyMultiplexProducer.java
index b8a2bb085..25d541e20 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedCacheKeyMultiplexProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedCacheKeyMultiplexProducer.java
@@ -20,18 +20,18 @@
  * Multiplex producer that uses the encoded cache key to combine requests.
  */
 public class EncodedCacheKeyMultiplexProducer extends
-    MultiplexProducer<Pair<CacheKey, ImageRequest.RequestLevel>, PooledByteBuffer> {
+        MultiplexProducer<Pair<CacheKey, ImageRequest.RequestLevel>, PooledByteBuffer> {
 
-  private final CacheKeyFactory mCacheKeyFactory;
+    private final CacheKeyFactory mCacheKeyFactory;
 
-  public EncodedCacheKeyMultiplexProducer(CacheKeyFactory cacheKeyFactory, Producer nextProducer) {
-    super(nextProducer);
-    mCacheKeyFactory = cacheKeyFactory;
-  }
+    public EncodedCacheKeyMultiplexProducer(CacheKeyFactory cacheKeyFactory, Producer nextProducer) {
+        super(nextProducer);
+        mCacheKeyFactory = cacheKeyFactory;
+    }
 
-  protected Pair<CacheKey, ImageRequest.RequestLevel> getKey(ProducerContext producerContext) {
-    return Pair.create(
-        mCacheKeyFactory.getEncodedCacheKey(producerContext.getImageRequest()),
-        producerContext.getLowestPermittedRequestLevel());
-  }
+    protected Pair<CacheKey, ImageRequest.RequestLevel> getKey(ProducerContext producerContext) {
+        return Pair.create(
+                mCacheKeyFactory.getEncodedCacheKey(producerContext.getImageRequest()),
+                producerContext.getLowestPermittedRequestLevel());
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java
index bdd319355..3ea53ae1a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java
@@ -22,46 +22,47 @@
  * Memory cache producer for the encoded memory cache.
  */
 public class EncodedMemoryCacheProducer extends MemoryCacheProducer<CacheKey, PooledByteBuffer> {
-  @VisibleForTesting static final String PRODUCER_NAME = "EncodedMemoryCacheProducer";
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "EncodedMemoryCacheProducer";
 
-  public EncodedMemoryCacheProducer(
-      MemoryCache<CacheKey, PooledByteBuffer> memoryCache,
-      CacheKeyFactory cacheKeyFactory,
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    super(memoryCache, cacheKeyFactory, nextProducer);
-  }
+    public EncodedMemoryCacheProducer(
+            MemoryCache<CacheKey, PooledByteBuffer> memoryCache,
+            CacheKeyFactory cacheKeyFactory,
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        super(memoryCache, cacheKeyFactory, nextProducer);
+    }
 
-  @Override
-  protected CacheKey getCacheKey(ImageRequest imageRequest) {
-    return mCacheKeyFactory.getEncodedCacheKey(imageRequest);
-  }
+    @Override
+    protected CacheKey getCacheKey(ImageRequest imageRequest) {
+        return mCacheKeyFactory.getEncodedCacheKey(imageRequest);
+    }
 
-  @Override
-  protected boolean isResultFinal(
-      CloseableReference<PooledByteBuffer> cachedResultFound) {
-    return true;
-  }
+    @Override
+    protected boolean isResultFinal(
+            CloseableReference<PooledByteBuffer> cachedResultFound) {
+        return true;
+    }
 
-  @Override
-  protected ImageRequest.RequestLevel getProducerRequestLevel() {
-    return ImageRequest.RequestLevel.ENCODED_MEMORY_CACHE;
-  }
+    @Override
+    protected ImageRequest.RequestLevel getProducerRequestLevel() {
+        return ImageRequest.RequestLevel.ENCODED_MEMORY_CACHE;
+    }
 
-  @Override
-  protected boolean shouldCacheReturnedValues() {
-    return true;
-  }
+    @Override
+    protected boolean shouldCacheReturnedValues() {
+        return true;
+    }
 
-  @Override
-  protected boolean shouldCacheResult(
-      CloseableReference<PooledByteBuffer> result,
-      CacheKey cacheKey,
-      boolean isLast) {
-    return isLast;
-  }
+    @Override
+    protected boolean shouldCacheResult(
+            CloseableReference<PooledByteBuffer> result,
+            CacheKey cacheKey,
+            boolean isLast) {
+        return isLast;
+    }
 
-  @Override
-  protected String getProducerName() {
-    return PRODUCER_NAME;
-  }
+    @Override
+    protected String getProducerName() {
+        return PRODUCER_NAME;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/FetchState.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/FetchState.java
index 0a62a765a..e182565c1 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/FetchState.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/FetchState.java
@@ -16,48 +16,48 @@
 
 /**
  * Used by {@link NetworkFetcher} to encapsulate the state of one network fetch.
- *
+ * <p>
  * <p>Implementations can subclass this to store additional fetch-scoped fields.
  */
 public class FetchState {
 
-  private final Consumer<CloseableReference<PooledByteBuffer>> mConsumer;
-  private final ProducerContext mContext;
-  private long mLastIntermediateResultTimeMs;
-
-  public FetchState(
-      Consumer<CloseableReference<PooledByteBuffer>> consumer,
-      ProducerContext context) {
-    mConsumer = consumer;
-    mContext = context;
-    mLastIntermediateResultTimeMs = 0;
-  }
-
-  public Consumer<CloseableReference<PooledByteBuffer>> getConsumer() {
-    return mConsumer;
-  }
-
-  public ProducerContext getContext() {
-    return mContext;
-  }
-
-  public String getId() {
-    return mContext.getId();
-  }
-
-  public ProducerListener getListener() {
-    return mContext.getListener();
-  }
-
-  public Uri getUri() {
-    return mContext.getImageRequest().getSourceUri();
-  }
-
-  public long getLastIntermediateResultTimeMs() {
-    return mLastIntermediateResultTimeMs;
-  }
-
-  public void setLastIntermediateResultTimeMs(long lastIntermediateResultTimeMs) {
-    mLastIntermediateResultTimeMs = lastIntermediateResultTimeMs;
-  }
+    private final Consumer<CloseableReference<PooledByteBuffer>> mConsumer;
+    private final ProducerContext mContext;
+    private long mLastIntermediateResultTimeMs;
+
+    public FetchState(
+            Consumer<CloseableReference<PooledByteBuffer>> consumer,
+            ProducerContext context) {
+        mConsumer = consumer;
+        mContext = context;
+        mLastIntermediateResultTimeMs = 0;
+    }
+
+    public Consumer<CloseableReference<PooledByteBuffer>> getConsumer() {
+        return mConsumer;
+    }
+
+    public ProducerContext getContext() {
+        return mContext;
+    }
+
+    public String getId() {
+        return mContext.getId();
+    }
+
+    public ProducerListener getListener() {
+        return mContext.getListener();
+    }
+
+    public Uri getUri() {
+        return mContext.getImageRequest().getSourceUri();
+    }
+
+    public long getLastIntermediateResultTimeMs() {
+        return mLastIntermediateResultTimeMs;
+    }
+
+    public void setLastIntermediateResultTimeMs(long lastIntermediateResultTimeMs) {
+        mLastIntermediateResultTimeMs = lastIntermediateResultTimeMs;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java
index f68296d3f..2bf7edd22 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/HttpUrlConnectionNetworkFetcher.java
@@ -23,57 +23,57 @@
 
 /**
  * Network fetcher that uses the simplest Android stack.
- *
+ * <p>
  * <p> Apps requiring more sophisticated networking should implement their own
  * {@link NetworkFetcher}.
  */
 public class HttpUrlConnectionNetworkFetcher extends BaseNetworkFetcher<FetchState> {
 
-  private static final int NUM_NETWORK_THREADS = 3;
+    private static final int NUM_NETWORK_THREADS = 3;
 
-  private final ExecutorService mExecutorService;
+    private final ExecutorService mExecutorService;
 
-  public HttpUrlConnectionNetworkFetcher() {
-    mExecutorService = Executors.newFixedThreadPool(NUM_NETWORK_THREADS);
-  }
+    public HttpUrlConnectionNetworkFetcher() {
+        mExecutorService = Executors.newFixedThreadPool(NUM_NETWORK_THREADS);
+    }
 
-  @Override
-  public FetchState createFetchState(
-      Consumer<CloseableReference<PooledByteBuffer>> consumer,
-      ProducerContext context) {
-    return new FetchState(consumer, context);
-  }
+    @Override
+    public FetchState createFetchState(
+            Consumer<CloseableReference<PooledByteBuffer>> consumer,
+            ProducerContext context) {
+        return new FetchState(consumer, context);
+    }
 
-  @Override
-  public void fetch(final FetchState fetchState, final Callback callback) {
-    final Future<?> future = mExecutorService.submit(
-        new Runnable() {
-          @Override
-          public void run() {
-            HttpURLConnection connection = null;
-            try {
-              Uri uri = fetchState.getUri();
-              URL url = new URL(uri.toString());
-              connection = (HttpURLConnection) url.openConnection();
-              InputStream is = connection.getInputStream();
-              callback.onResponse(is, -1);
-            } catch (Exception e) {
-              callback.onFailure(e);
-            } finally {
-              if (connection != null) {
-                connection.disconnect();
-              }
-            }
-          }
-        });
-    fetchState.getContext().addCallbacks(
-        new BaseProducerContextCallbacks() {
-          @Override
-          public void onCancellationRequested() {
-            if (future.cancel(false)) {
-              callback.onCancellation();
-            }
-          }
-        });
-  }
+    @Override
+    public void fetch(final FetchState fetchState, final Callback callback) {
+        final Future<?> future = mExecutorService.submit(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        HttpURLConnection connection = null;
+                        try {
+                            Uri uri = fetchState.getUri();
+                            URL url = new URL(uri.toString());
+                            connection = (HttpURLConnection) url.openConnection();
+                            InputStream is = connection.getInputStream();
+                            callback.onResponse(is, -1);
+                        } catch (Exception e) {
+                            callback.onFailure(e);
+                        } finally {
+                            if (connection != null) {
+                                connection.disconnect();
+                            }
+                        }
+                    }
+                });
+        fetchState.getContext().addCallbacks(
+                new BaseProducerContextCallbacks() {
+                    @Override
+                    public void onCancellationRequested() {
+                        if (future.cancel(false)) {
+                            callback.onCancellation();
+                        }
+                    }
+                });
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageTransformMetaData.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageTransformMetaData.java
index df3098704..e7eb4858e 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageTransformMetaData.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageTransformMetaData.java
@@ -13,99 +13,102 @@
 
 /**
  * Extracted meta data that is useful for image transforms.
- *
+ * <p>
  * <p>Currently the data is useful for rotation and resize.
  */
 public class ImageTransformMetaData {
-  private final ImageFormat mImageFormat;
-  private final int mRotationAngle;
-  private final int mWidth;
-  private final int mHeight;
-
-  private ImageTransformMetaData(
-      ImageFormat imageFormat,
-      int rotationAngle,
-      int width,
-      int height) {
-    mImageFormat = imageFormat;
-    mRotationAngle = rotationAngle;
-    mWidth = width;
-    mHeight = height;
-  }
-
-  public ImageFormat getImageFormat() {
-    return mImageFormat;
-  }
-
-  /**
-   * Only valid if the image format is JPEG.
-   * @return the rotation angle if the rotation angle is known, else -1. The rotation angle may not
-   * be known if the image is incomplete (e.g. for progressive JPEGs).
-   */
-  public int getRotationAngle() {
-    return mRotationAngle;
-  }
-
-  /**
-   * Only valid if the image format is JPEG.
-   * @return width if the width is known, else -1.
-   */
-  public int getWidth() {
-    return mWidth;
-  }
-
-  /**
-   * Only valid if the image format is JPEG.
-   * @return height if the height is known, else -1.
-   */
-  public int getHeight() {
-    return mHeight;
-  }
-
-  public static Builder newBuilder() {
-    return new Builder();
-  }
-
-  public static class Builder {
-    private ImageFormat mImageFormat;
-    private int mRotationAngle;
-    private int mWidth;
-    private int mHeight;
-
-    public Builder() {
-      reset();
+    private final ImageFormat mImageFormat;
+    private final int mRotationAngle;
+    private final int mWidth;
+    private final int mHeight;
+
+    private ImageTransformMetaData(
+            ImageFormat imageFormat,
+            int rotationAngle,
+            int width,
+            int height) {
+        mImageFormat = imageFormat;
+        mRotationAngle = rotationAngle;
+        mWidth = width;
+        mHeight = height;
     }
 
-    public Builder reset() {
-      mImageFormat = ImageFormat.UNKNOWN;
-      mRotationAngle = -1;
-      mWidth = -1;
-      mHeight = -1;
-      return this;
+    public ImageFormat getImageFormat() {
+        return mImageFormat;
     }
 
-    public Builder setImageFormat(ImageFormat imageFormat) {
-      mImageFormat = imageFormat;
-      return this;
+    /**
+     * Only valid if the image format is JPEG.
+     *
+     * @return the rotation angle if the rotation angle is known, else -1. The rotation angle may not
+     * be known if the image is incomplete (e.g. for progressive JPEGs).
+     */
+    public int getRotationAngle() {
+        return mRotationAngle;
     }
 
-    public Builder setRotationAngle(int rotationAngle) {
-      mRotationAngle = rotationAngle;
-      return this;
+    /**
+     * Only valid if the image format is JPEG.
+     *
+     * @return width if the width is known, else -1.
+     */
+    public int getWidth() {
+        return mWidth;
     }
 
-    public Builder setWidth(int width) {
-      mWidth = width;
-      return this;
+    /**
+     * Only valid if the image format is JPEG.
+     *
+     * @return height if the height is known, else -1.
+     */
+    public int getHeight() {
+        return mHeight;
     }
 
-    public Builder setHeight(int height) {
-      mHeight = height;
-      return this;
+    public static Builder newBuilder() {
+        return new Builder();
     }
 
-    public ImageTransformMetaData build() {
-      return new ImageTransformMetaData(mImageFormat, mRotationAngle, mWidth, mHeight);
+    public static class Builder {
+        private ImageFormat mImageFormat;
+        private int mRotationAngle;
+        private int mWidth;
+        private int mHeight;
+
+        public Builder() {
+            reset();
+        }
+
+        public Builder reset() {
+            mImageFormat = ImageFormat.UNKNOWN;
+            mRotationAngle = -1;
+            mWidth = -1;
+            mHeight = -1;
+            return this;
+        }
+
+        public Builder setImageFormat(ImageFormat imageFormat) {
+            mImageFormat = imageFormat;
+            return this;
+        }
+
+        public Builder setRotationAngle(int rotationAngle) {
+            mRotationAngle = rotationAngle;
+            return this;
+        }
+
+        public Builder setWidth(int width) {
+            mWidth = width;
+            return this;
+        }
+
+        public Builder setHeight(int height) {
+            mHeight = height;
+            return this;
+        }
+
+        public ImageTransformMetaData build() {
+            return new ImageTransformMetaData(mImageFormat, mRotationAngle, mWidth, mHeight);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageTransformProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageTransformProducer.java
index 877c82f28..3181e14d7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageTransformProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ImageTransformProducer.java
@@ -24,179 +24,180 @@
 /**
  * Base class for producers that wait for entire image and then transform it in some way:
  * rotate, resize, transcode to different format.
- *
+ * <p>
  * <p> Subclasses should provide implementations for shouldTransform and transform methods.
  * The first one is called when producer receives new image data to determine whether any work has
  * to be done on image bytes when entire image is available. Second one is called only if first one
  * returns true and is responsible for doing any required transformation.
- *
+ * <p>
  * <p>E is the type of any extra information that the producer requires.
  */
 public abstract class ImageTransformProducer<T, E>
-    implements Producer<T> {
-
-  private final Executor mExecutor;
-  private final PooledByteBufferFactory mPooledByteBufferFactory;
-  private final Producer<T> mNextProducer;
-
-  protected ImageTransformProducer(
-      Executor executor,
-      PooledByteBufferFactory pooledByteBufferFactory,
-      Producer<T> nextProducer) {
-    mExecutor = Preconditions.checkNotNull(executor);
-    mPooledByteBufferFactory = Preconditions.checkNotNull(pooledByteBufferFactory);
-    mNextProducer = Preconditions.checkNotNull(nextProducer);
-  }
-
-  @Override
-  public void produceResults(final Consumer<T> consumer, final ProducerContext context) {
-    mNextProducer.produceResults(new TransformingConsumer(consumer, context), context);
-  }
-
-  private class TransformingConsumer extends DelegatingConsumer<T, T> {
-
-    private final ProducerContext mContext;
-    private TriState mShouldTransformWhenFinished;
-
-    public TransformingConsumer(final Consumer<T> consumer, final ProducerContext context) {
-      super(consumer);
-      mContext = context;
-      mShouldTransformWhenFinished = TriState.UNSET;
+        implements Producer<T> {
+
+    private final Executor mExecutor;
+    private final PooledByteBufferFactory mPooledByteBufferFactory;
+    private final Producer<T> mNextProducer;
+
+    protected ImageTransformProducer(
+            Executor executor,
+            PooledByteBufferFactory pooledByteBufferFactory,
+            Producer<T> nextProducer) {
+        mExecutor = Preconditions.checkNotNull(executor);
+        mPooledByteBufferFactory = Preconditions.checkNotNull(pooledByteBufferFactory);
+        mNextProducer = Preconditions.checkNotNull(nextProducer);
     }
 
     @Override
-    protected void onNewResultImpl(@Nullable T newResult, boolean isLast) {
-      // try to determine if the last result should be transformed
-      if (mShouldTransformWhenFinished == TriState.UNSET && newResult != null) {
-        mShouldTransformWhenFinished =
-            shouldTransform(newResult, mContext.getImageRequest(), isLast);
-      }
-
-      // just propagate result if it shouldn't be transformed
-      if (mShouldTransformWhenFinished == TriState.NO) {
-        getConsumer().onNewResult(newResult, isLast);
-        return;
-      }
-
-      if (isLast) {
-        if (mShouldTransformWhenFinished == TriState.YES) {
-          transformLastResult(newResult, getConsumer(), mContext);
-        } else {
-          getConsumer().onNewResult(newResult, isLast);
-        }
-      }
+    public void produceResults(final Consumer<T> consumer, final ProducerContext context) {
+        mNextProducer.produceResults(new TransformingConsumer(consumer, context), context);
     }
-  }
-
-  private void transformLastResult(
-      final T originalResult,
-      final Consumer<T> consumer,
-      final ProducerContext producerContext) {
-    final ProducerListener listener = producerContext.getListener();
-    final String requestId = producerContext.getId();
-    final CloseableReference<PooledByteBuffer> imageRefCopy = getImageCopy(originalResult);
-    final E extraInformation = getExtraInformation(originalResult);
-    final StatefulProducerRunnable<T> cancellableProducerRunnable =
-        new StatefulProducerRunnable<T>(consumer, listener, getProducerName(), requestId) {
-          @Override
-          protected T getResult() throws Exception {
-            ImageRequest imageRequest = producerContext.getImageRequest();
-            PooledByteBufferOutputStream outputStream = mPooledByteBufferFactory.newOutputStream();
-            try {
-              transform(imageRefCopy, outputStream, imageRequest, extraInformation);
-              return createReturnValue(outputStream.toByteBuffer(), extraInformation);
-            } finally {
-              outputStream.close();
+
+    private class TransformingConsumer extends DelegatingConsumer<T, T> {
+
+        private final ProducerContext mContext;
+        private TriState mShouldTransformWhenFinished;
+
+        public TransformingConsumer(final Consumer<T> consumer, final ProducerContext context) {
+            super(consumer);
+            mContext = context;
+            mShouldTransformWhenFinished = TriState.UNSET;
+        }
+
+        @Override
+        protected void onNewResultImpl(@Nullable T newResult, boolean isLast) {
+            // try to determine if the last result should be transformed
+            if (mShouldTransformWhenFinished == TriState.UNSET && newResult != null) {
+                mShouldTransformWhenFinished =
+                        shouldTransform(newResult, mContext.getImageRequest(), isLast);
             }
-          }
-
-          @Override
-          protected void disposeResult(T result) {
-            closeReturnValue(result);
-          }
-
-          @Override
-          protected void onSuccess(T result) {
-            imageRefCopy.close();
-            super.onSuccess(result);
-          }
-
-          @Override
-          protected void onFailure(Exception e) {
-            imageRefCopy.close();
-            super.onFailure(e);
-          }
-
-          @Override
-          protected void onCancellation() {
-            imageRefCopy.close();
-            super.onCancellation();
-          }
-        };
-    if (shouldAllowCancellation()) {
-      producerContext.addCallbacks(
-          new BaseProducerContextCallbacks() {
-            @Override
-            public void onCancellationRequested() {
-              cancellableProducerRunnable.cancel();
+
+            // just propagate result if it shouldn't be transformed
+            if (mShouldTransformWhenFinished == TriState.NO) {
+                getConsumer().onNewResult(newResult, isLast);
+                return;
+            }
+
+            if (isLast) {
+                if (mShouldTransformWhenFinished == TriState.YES) {
+                    transformLastResult(newResult, getConsumer(), mContext);
+                } else {
+                    getConsumer().onNewResult(newResult, isLast);
+                }
             }
-          });
+        }
     }
-    mExecutor.execute(cancellableProducerRunnable);
-  }
-
-  /**
-   * @return YES if encoded image referenced by imageRef needs to be transformed when final result
-   * is received. Can be called subsequently, and as soon as it returns result other than UNSET -
-   * it becomes final
-   */
-  protected abstract TriState shouldTransform(
-      T input,
-      ImageRequest imageRequest,
-      boolean isLast);
-
-  /**
-   * Transforms image bytes
-   *
-   * @param imageRef image bytes
-   * @param outputStream stream to write transformed image to
-   * @param imageRequest image request
-   * @param extraData any extra data passed to the producer
-   * @throws Exception
-   */
-  protected abstract void transform(
-      CloseableReference<PooledByteBuffer> imageRef,
-      PooledByteBufferOutputStream outputStream,
-      ImageRequest imageRequest,
-      E extraData) throws Exception;
-
-  /**
-   * Extracts a copy of the image bytes from the result received from the next producer.
-   */
-  protected abstract CloseableReference<PooledByteBuffer> getImageCopy(T originalResult);
-
-  /**
-   * Extracts any extra data that was received.
-   */
-  @Nullable protected abstract E getExtraInformation(T originalResult);
-
-  /**
-   * Creates a return value to pass to the consumer from the transformed bytes.
-   */
-  protected abstract T createReturnValue(PooledByteBuffer transformedBytes, E extraInformation);
-
-  /**
-   * Closes the return value that was passed to the consumer.
-   */
-  protected abstract void closeReturnValue(T returnValue);
-
-  /**
-   * Gets the name of the producer
-   */
-  protected abstract String getProducerName();
-
-  /**
-   * Should return true if cancellation after transformation has been scheduled is desired
-   */
-  protected abstract boolean shouldAllowCancellation();
+
+    private void transformLastResult(
+            final T originalResult,
+            final Consumer<T> consumer,
+            final ProducerContext producerContext) {
+        final ProducerListener listener = producerContext.getListener();
+        final String requestId = producerContext.getId();
+        final CloseableReference<PooledByteBuffer> imageRefCopy = getImageCopy(originalResult);
+        final E extraInformation = getExtraInformation(originalResult);
+        final StatefulProducerRunnable<T> cancellableProducerRunnable =
+                new StatefulProducerRunnable<T>(consumer, listener, getProducerName(), requestId) {
+                    @Override
+                    protected T getResult() throws Exception {
+                        ImageRequest imageRequest = producerContext.getImageRequest();
+                        PooledByteBufferOutputStream outputStream = mPooledByteBufferFactory.newOutputStream();
+                        try {
+                            transform(imageRefCopy, outputStream, imageRequest, extraInformation);
+                            return createReturnValue(outputStream.toByteBuffer(), extraInformation);
+                        } finally {
+                            outputStream.close();
+                        }
+                    }
+
+                    @Override
+                    protected void disposeResult(T result) {
+                        closeReturnValue(result);
+                    }
+
+                    @Override
+                    protected void onSuccess(T result) {
+                        imageRefCopy.close();
+                        super.onSuccess(result);
+                    }
+
+                    @Override
+                    protected void onFailure(Exception e) {
+                        imageRefCopy.close();
+                        super.onFailure(e);
+                    }
+
+                    @Override
+                    protected void onCancellation() {
+                        imageRefCopy.close();
+                        super.onCancellation();
+                    }
+                };
+        if (shouldAllowCancellation()) {
+            producerContext.addCallbacks(
+                    new BaseProducerContextCallbacks() {
+                        @Override
+                        public void onCancellationRequested() {
+                            cancellableProducerRunnable.cancel();
+                        }
+                    });
+        }
+        mExecutor.execute(cancellableProducerRunnable);
+    }
+
+    /**
+     * @return YES if encoded image referenced by imageRef needs to be transformed when final result
+     * is received. Can be called subsequently, and as soon as it returns result other than UNSET -
+     * it becomes final
+     */
+    protected abstract TriState shouldTransform(
+            T input,
+            ImageRequest imageRequest,
+            boolean isLast);
+
+    /**
+     * Transforms image bytes
+     *
+     * @param imageRef     image bytes
+     * @param outputStream stream to write transformed image to
+     * @param imageRequest image request
+     * @param extraData    any extra data passed to the producer
+     * @throws Exception
+     */
+    protected abstract void transform(
+            CloseableReference<PooledByteBuffer> imageRef,
+            PooledByteBufferOutputStream outputStream,
+            ImageRequest imageRequest,
+            E extraData) throws Exception;
+
+    /**
+     * Extracts a copy of the image bytes from the result received from the next producer.
+     */
+    protected abstract CloseableReference<PooledByteBuffer> getImageCopy(T originalResult);
+
+    /**
+     * Extracts any extra data that was received.
+     */
+    @Nullable
+    protected abstract E getExtraInformation(T originalResult);
+
+    /**
+     * Creates a return value to pass to the consumer from the transformed bytes.
+     */
+    protected abstract T createReturnValue(PooledByteBuffer transformedBytes, E extraInformation);
+
+    /**
+     * Closes the return value that was passed to the consumer.
+     */
+    protected abstract void closeReturnValue(T returnValue);
+
+    /**
+     * Gets the name of the producer
+     */
+    protected abstract String getProducerName();
+
+    /**
+     * Should return true if cancellation after transformation has been scheduled is desired
+     */
+    protected abstract boolean shouldAllowCancellation();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalAssetFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalAssetFetchProducer.java
index 857bbd7cd..a0e72bb57 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalAssetFetchProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalAssetFetchProducer.java
@@ -24,48 +24,49 @@
  * Executes a local fetch from an asset.
  */
 public class LocalAssetFetchProducer extends LocalFetchProducer {
-  @VisibleForTesting static final String PRODUCER_NAME = "LocalAssetFetchProducer";
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "LocalAssetFetchProducer";
 
-  private final AssetManager mAssetManager;
+    private final AssetManager mAssetManager;
 
-  public LocalAssetFetchProducer(
-      Executor executor,
-      PooledByteBufferFactory pooledByteBufferFactory,
-      AssetManager assetManager) {
-    super(executor, pooledByteBufferFactory);
-    mAssetManager = assetManager;
-  }
+    public LocalAssetFetchProducer(
+            Executor executor,
+            PooledByteBufferFactory pooledByteBufferFactory,
+            AssetManager assetManager) {
+        super(executor, pooledByteBufferFactory);
+        mAssetManager = assetManager;
+    }
 
-  @Override
-  protected InputStream getInputStream(ImageRequest imageRequest) throws IOException {
-    return mAssetManager.open(getAssetName(imageRequest), AssetManager.ACCESS_STREAMING);
-  }
+    @Override
+    protected InputStream getInputStream(ImageRequest imageRequest) throws IOException {
+        return mAssetManager.open(getAssetName(imageRequest), AssetManager.ACCESS_STREAMING);
+    }
 
-  @Override
-  protected int getLength(ImageRequest imageRequest) {
-    AssetFileDescriptor fd = null;
-    try {
-      fd = mAssetManager.openFd(getAssetName(imageRequest));
-      return (int) fd.getLength();
-    } catch (IOException e) {
-      return -1;
-    } finally {
-      try {
-        if (fd != null) {
-          fd.close();
+    @Override
+    protected int getLength(ImageRequest imageRequest) {
+        AssetFileDescriptor fd = null;
+        try {
+            fd = mAssetManager.openFd(getAssetName(imageRequest));
+            return (int) fd.getLength();
+        } catch (IOException e) {
+            return -1;
+        } finally {
+            try {
+                if (fd != null) {
+                    fd.close();
+                }
+            } catch (IOException ignored) {
+                // There's nothing we can do with the exception when closing descriptor.
+            }
         }
-      } catch (IOException ignored) {
-        // There's nothing we can do with the exception when closing descriptor.
-      }
     }
-  }
 
-  @Override
-  protected String getProducerName() {
-    return PRODUCER_NAME;
-  }
+    @Override
+    protected String getProducerName() {
+        return PRODUCER_NAME;
+    }
 
-  private static String getAssetName(ImageRequest imageRequest) {
-    return imageRequest.getSourceUri().getPath().substring(1);
-  }
+    private static String getAssetName(ImageRequest imageRequest) {
+        return imageRequest.getSourceUri().getPath().substring(1);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducer.java
index 4a11d1cbf..b94c0089d 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalContentUriFetchProducer.java
@@ -25,47 +25,49 @@
  * Represents a local content Uri fetch producer.
  */
 public class LocalContentUriFetchProducer extends LocalFetchProducer {
-  @VisibleForTesting static final String PRODUCER_NAME = "LocalContentUriFetchProducer";
-  private static final String DISPLAY_PHOTO_PATH =
-      Uri.withAppendedPath(ContactsContract.AUTHORITY_URI, "display_photo").getPath();
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "LocalContentUriFetchProducer";
+    private static final String DISPLAY_PHOTO_PATH =
+            Uri.withAppendedPath(ContactsContract.AUTHORITY_URI, "display_photo").getPath();
 
-  private final ContentResolver mContentResolver;
+    private final ContentResolver mContentResolver;
 
-  public LocalContentUriFetchProducer(
-      Executor executor,
-      PooledByteBufferFactory pooledByteBufferFactory,
-      ContentResolver contentResolver) {
-    super(executor, pooledByteBufferFactory);
-    mContentResolver = contentResolver;
-  }
+    public LocalContentUriFetchProducer(
+            Executor executor,
+            PooledByteBufferFactory pooledByteBufferFactory,
+            ContentResolver contentResolver) {
+        super(executor, pooledByteBufferFactory);
+        mContentResolver = contentResolver;
+    }
 
-  @Override
-  protected InputStream getInputStream(ImageRequest imageRequest) throws IOException {
-    Uri uri = imageRequest.getSourceUri();
-    if (isContactUri(uri)) {
-      // If a Contact URI is provided, use the special helper to open that contact's photo.
-      return ContactsContract.Contacts.openContactPhotoInputStream(mContentResolver, uri);
+    @Override
+    protected InputStream getInputStream(ImageRequest imageRequest) throws IOException {
+        Uri uri = imageRequest.getSourceUri();
+        if (isContactUri(uri)) {
+            // If a Contact URI is provided, use the special helper to open that contact's photo.
+            return ContactsContract.Contacts.openContactPhotoInputStream(mContentResolver, uri);
+        }
+        return mContentResolver.openInputStream(uri);
     }
-    return mContentResolver.openInputStream(uri);
-  }
 
-  /**
-   * Checks if the given URI is a general Contact URI, and not a specific display photo.
-   * @param uri the URI to check
-   * @return true if the uri is a a Contact URI, and is not already specifying a display photo.
-   */
-  private boolean isContactUri(Uri uri) {
-    return ContactsContract.AUTHORITY.equals(uri.getAuthority()) &&
-        !uri.getPath().startsWith(DISPLAY_PHOTO_PATH);
-  }
+    /**
+     * Checks if the given URI is a general Contact URI, and not a specific display photo.
+     *
+     * @param uri the URI to check
+     * @return true if the uri is a a Contact URI, and is not already specifying a display photo.
+     */
+    private boolean isContactUri(Uri uri) {
+        return ContactsContract.AUTHORITY.equals(uri.getAuthority()) &&
+                !uri.getPath().startsWith(DISPLAY_PHOTO_PATH);
+    }
 
-  @Override
-  protected int getLength(ImageRequest imageRequest) {
-    return -1;
-  }
+    @Override
+    protected int getLength(ImageRequest imageRequest) {
+        return -1;
+    }
 
-  @Override
-  protected String getProducerName() {
-    return PRODUCER_NAME;
-  }
+    @Override
+    protected String getProducerName() {
+        return PRODUCER_NAME;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalExifThumbnailProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalExifThumbnailProducer.java
index 8c13f1fe4..225fde2c9 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalExifThumbnailProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalExifThumbnailProducer.java
@@ -29,103 +29,106 @@
 
 /**
  * A producer that retrieves exif thumbnails.
- *
+ * <p>
  * <p>At present, these thumbnails are retrieved on the java heap before being put into native
  * memory.
  */
 public class LocalExifThumbnailProducer implements
-    Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> {
-
-  @VisibleForTesting static final String PRODUCER_NAME = "LocalExifThumbnailProducer";
-  @VisibleForTesting static final String CREATED_THUMBNAIL = "createdThumbnail";
-
-  private final Executor mExecutor;
-  private final PooledByteBufferFactory mPooledByteBufferFactory;
-
-  public LocalExifThumbnailProducer(
-      Executor executor,
-      PooledByteBufferFactory pooledByteBufferFactory) {
-    mExecutor = executor;
-    mPooledByteBufferFactory = pooledByteBufferFactory;
-  }
-
-  @Override
-  public void produceResults(
-      final Consumer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> consumer,
-      final ProducerContext producerContext) {
-
-    final ProducerListener listener = producerContext.getListener();
-    final String requestId = producerContext.getId();
-    final ImageRequest imageRequest = producerContext.getImageRequest();
-
-    final StatefulProducerRunnable cancellableProducerRunnable =
-        new StatefulProducerRunnable<
-            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>>(
-            consumer,
-            listener,
-            PRODUCER_NAME,
-            requestId) {
-          @Override
-          protected Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> getResult()
-              throws Exception {
-            final ExifInterface exifInterface =
-                getExifInterface(imageRequest.getSourceFile().getPath());
-            if (!exifInterface.hasThumbnail()) {
-              return null;
-            }
-
-            byte[] bytes = exifInterface.getThumbnail();
-            PooledByteBuffer pooledByteBuffer = mPooledByteBufferFactory.newByteBuffer(bytes);
-            ImageTransformMetaData imageTransformMetaData =
-                getImageTransformMetaData(pooledByteBuffer, exifInterface);
-            return Pair.create(CloseableReference.of(pooledByteBuffer), imageTransformMetaData);
-          }
-
-          @Override
-          protected void disposeResult(
-              Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> result) {
-            if (result != null) {
-              CloseableReference.closeSafely(result.first);
-            }
-          }
-
-          @Override
-          protected Map<String, String> getExtraMapOnSuccess(
-              final Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> result) {
-            return ImmutableMap.of(CREATED_THUMBNAIL, Boolean.toString(result != null));
-          }
-        };
-    producerContext.addCallbacks(
-        new BaseProducerContextCallbacks() {
-          @Override
-          public void onCancellationRequested() {
-            cancellableProducerRunnable.cancel();
-          }
-        });
-    mExecutor.execute(cancellableProducerRunnable);
-  }
-
-  @VisibleForTesting ExifInterface getExifInterface(String path) throws IOException {
-    return new ExifInterface(path);
-  }
-
-  private ImageTransformMetaData getImageTransformMetaData(
-      PooledByteBuffer imageBytes,
-      ExifInterface exifInterface) {
-    ImageTransformMetaData.Builder builder = ImageTransformMetaData.newBuilder()
-        .setImageFormat(ImageFormat.JPEG);
-    builder.setRotationAngle(getRotationAngle(exifInterface));
-    Rect dimensions = JfifUtil.getDimensions(new PooledByteBufferInputStream(imageBytes));
-    if (dimensions != null) {
-      builder.setWidth(dimensions.width());
-      builder.setHeight(dimensions.height());
+        Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> {
+
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "LocalExifThumbnailProducer";
+    @VisibleForTesting
+    static final String CREATED_THUMBNAIL = "createdThumbnail";
+
+    private final Executor mExecutor;
+    private final PooledByteBufferFactory mPooledByteBufferFactory;
+
+    public LocalExifThumbnailProducer(
+            Executor executor,
+            PooledByteBufferFactory pooledByteBufferFactory) {
+        mExecutor = executor;
+        mPooledByteBufferFactory = pooledByteBufferFactory;
+    }
+
+    @Override
+    public void produceResults(
+            final Consumer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> consumer,
+            final ProducerContext producerContext) {
+
+        final ProducerListener listener = producerContext.getListener();
+        final String requestId = producerContext.getId();
+        final ImageRequest imageRequest = producerContext.getImageRequest();
+
+        final StatefulProducerRunnable cancellableProducerRunnable =
+                new StatefulProducerRunnable<
+                        Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>>(
+                        consumer,
+                        listener,
+                        PRODUCER_NAME,
+                        requestId) {
+                    @Override
+                    protected Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> getResult()
+                            throws Exception {
+                        final ExifInterface exifInterface =
+                                getExifInterface(imageRequest.getSourceFile().getPath());
+                        if (!exifInterface.hasThumbnail()) {
+                            return null;
+                        }
+
+                        byte[] bytes = exifInterface.getThumbnail();
+                        PooledByteBuffer pooledByteBuffer = mPooledByteBufferFactory.newByteBuffer(bytes);
+                        ImageTransformMetaData imageTransformMetaData =
+                                getImageTransformMetaData(pooledByteBuffer, exifInterface);
+                        return Pair.create(CloseableReference.of(pooledByteBuffer), imageTransformMetaData);
+                    }
+
+                    @Override
+                    protected void disposeResult(
+                            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> result) {
+                        if (result != null) {
+                            CloseableReference.closeSafely(result.first);
+                        }
+                    }
+
+                    @Override
+                    protected Map<String, String> getExtraMapOnSuccess(
+                            final Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> result) {
+                        return ImmutableMap.of(CREATED_THUMBNAIL, Boolean.toString(result != null));
+                    }
+                };
+        producerContext.addCallbacks(
+                new BaseProducerContextCallbacks() {
+                    @Override
+                    public void onCancellationRequested() {
+                        cancellableProducerRunnable.cancel();
+                    }
+                });
+        mExecutor.execute(cancellableProducerRunnable);
+    }
+
+    @VisibleForTesting
+    ExifInterface getExifInterface(String path) throws IOException {
+        return new ExifInterface(path);
+    }
+
+    private ImageTransformMetaData getImageTransformMetaData(
+            PooledByteBuffer imageBytes,
+            ExifInterface exifInterface) {
+        ImageTransformMetaData.Builder builder = ImageTransformMetaData.newBuilder()
+                .setImageFormat(ImageFormat.JPEG);
+        builder.setRotationAngle(getRotationAngle(exifInterface));
+        Rect dimensions = JfifUtil.getDimensions(new PooledByteBufferInputStream(imageBytes));
+        if (dimensions != null) {
+            builder.setWidth(dimensions.width());
+            builder.setHeight(dimensions.height());
+        }
+        return builder.build();
+    }
+
+    // Gets the correction angle based on the image's orientation
+    private int getRotationAngle(final ExifInterface exifInterface) {
+        return JfifUtil.getAutoRotateAngleFromOrientation(
+                Integer.parseInt(exifInterface.getAttribute(ExifInterface.TAG_ORIENTATION)));
     }
-    return builder.build();
-  }
-
-  // Gets the correction angle based on the image's orientation
-  private int getRotationAngle(final ExifInterface exifInterface) {
-    return JfifUtil.getAutoRotateAngleFromOrientation(
-        Integer.parseInt(exifInterface.getAttribute(ExifInterface.TAG_ORIENTATION)));
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalFetchProducer.java
index 13fa3a5c5..c8276fd67 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalFetchProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalFetchProducer.java
@@ -23,82 +23,84 @@
  */
 public abstract class LocalFetchProducer implements Producer<CloseableReference<PooledByteBuffer>> {
 
-  private final Executor mExecutor;
-  private final PooledByteBufferFactory mPooledByteBufferFactory;
+    private final Executor mExecutor;
+    private final PooledByteBufferFactory mPooledByteBufferFactory;
 
-  protected LocalFetchProducer(
-      Executor executor,
-      PooledByteBufferFactory pooledByteBufferFactory) {
-    mExecutor = executor;
-    mPooledByteBufferFactory = pooledByteBufferFactory;
-  }
+    protected LocalFetchProducer(
+            Executor executor,
+            PooledByteBufferFactory pooledByteBufferFactory) {
+        mExecutor = executor;
+        mPooledByteBufferFactory = pooledByteBufferFactory;
+    }
 
-  @Override
-  public void produceResults(
-      final Consumer<CloseableReference<PooledByteBuffer>> consumer,
-      final ProducerContext producerContext) {
+    @Override
+    public void produceResults(
+            final Consumer<CloseableReference<PooledByteBuffer>> consumer,
+            final ProducerContext producerContext) {
 
-    final ProducerListener listener = producerContext.getListener();
-    final String requestId = producerContext.getId();
-    final ImageRequest imageRequest = producerContext.getImageRequest();
-    final StatefulProducerRunnable cancellableProducerRunnable =
-        new StatefulProducerRunnable<CloseableReference<PooledByteBuffer>>(
-            consumer,
-            listener,
-            getProducerName(),
-            requestId) {
+        final ProducerListener listener = producerContext.getListener();
+        final String requestId = producerContext.getId();
+        final ImageRequest imageRequest = producerContext.getImageRequest();
+        final StatefulProducerRunnable cancellableProducerRunnable =
+                new StatefulProducerRunnable<CloseableReference<PooledByteBuffer>>(
+                        consumer,
+                        listener,
+                        getProducerName(),
+                        requestId) {
 
-          @Override
-          protected CloseableReference<PooledByteBuffer> getResult() throws Exception {
-            InputStream inputStream = null;
-            try {
-              inputStream = getInputStream(imageRequest);
-              int length = getLength(imageRequest);
-              if (length < 0) {
-                return CloseableReference.of(mPooledByteBufferFactory.newByteBuffer(inputStream));
-              } else {
-                return CloseableReference.of(
-                    mPooledByteBufferFactory.newByteBuffer(inputStream, length));
-              }
-            } finally {
-              if (inputStream != null) {
-                inputStream.close();
-              }
-            }
-          }
+                    @Override
+                    protected CloseableReference<PooledByteBuffer> getResult() throws Exception {
+                        InputStream inputStream = null;
+                        try {
+                            inputStream = getInputStream(imageRequest);
+                            int length = getLength(imageRequest);
+                            if (length < 0) {
+                                return CloseableReference.of(mPooledByteBufferFactory.newByteBuffer(inputStream));
+                            } else {
+                                return CloseableReference.of(
+                                        mPooledByteBufferFactory.newByteBuffer(inputStream, length));
+                            }
+                        } finally {
+                            if (inputStream != null) {
+                                inputStream.close();
+                            }
+                        }
+                    }
 
-          @Override
-          protected void disposeResult(CloseableReference<PooledByteBuffer> result) {
-            CloseableReference.closeSafely(result);
-          }
-        };
+                    @Override
+                    protected void disposeResult(CloseableReference<PooledByteBuffer> result) {
+                        CloseableReference.closeSafely(result);
+                    }
+                };
 
-    producerContext.addCallbacks(
-        new BaseProducerContextCallbacks() {
-          @Override
-          public void onCancellationRequested() {
-            cancellableProducerRunnable.cancel();
-          }
-        });
-    mExecutor.execute(cancellableProducerRunnable);
-  }
+        producerContext.addCallbacks(
+                new BaseProducerContextCallbacks() {
+                    @Override
+                    public void onCancellationRequested() {
+                        cancellableProducerRunnable.cancel();
+                    }
+                });
+        mExecutor.execute(cancellableProducerRunnable);
+    }
 
-  /**
-   * Gets an input stream from the local resource.
-   * @param imageRequest request that includes the local resource that is being accessed
-   * @throws IOException
-   */
-  protected abstract InputStream getInputStream(ImageRequest imageRequest) throws IOException;
+    /**
+     * Gets an input stream from the local resource.
+     *
+     * @param imageRequest request that includes the local resource that is being accessed
+     * @throws IOException
+     */
+    protected abstract InputStream getInputStream(ImageRequest imageRequest) throws IOException;
 
-  /**
-   * Gets the length of the input from the payload.
-   * @param imageRequest request that includes the local resource that is being accessed
-   * @return length of the input indicated by the payload. -1 indicates that the length is unknown.
-   */
-  protected abstract int getLength(ImageRequest imageRequest);
+    /**
+     * Gets the length of the input from the payload.
+     *
+     * @param imageRequest request that includes the local resource that is being accessed
+     * @return length of the input indicated by the payload. -1 indicates that the length is unknown.
+     */
+    protected abstract int getLength(ImageRequest imageRequest);
 
-  /**
-   * @return name of the Producer
-   */
-  protected abstract String getProducerName();
+    /**
+     * @return name of the Producer
+     */
+    protected abstract String getProducerName();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalFileFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalFileFetchProducer.java
index 66534118f..b53df03fa 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalFileFetchProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalFileFetchProducer.java
@@ -22,26 +22,27 @@
  * Represents a local file fetch producer.
  */
 public class LocalFileFetchProducer extends LocalFetchProducer {
-  @VisibleForTesting static final String PRODUCER_NAME = "LocalFileFetchProducer";
-
-  public LocalFileFetchProducer(
-      Executor executor,
-      PooledByteBufferFactory pooledByteBufferFactory) {
-    super(executor, pooledByteBufferFactory);
-  }
-
-  @Override
-  protected InputStream getInputStream(ImageRequest imageRequest) throws IOException {
-    return new FileInputStream(imageRequest.getSourceFile());
-  }
-
-  @Override
-  protected int getLength(ImageRequest imageRequest) {
-    return (int) imageRequest.getSourceFile().length();
-  }
-
-  @Override
-  protected String getProducerName() {
-    return PRODUCER_NAME;
-  }
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "LocalFileFetchProducer";
+
+    public LocalFileFetchProducer(
+            Executor executor,
+            PooledByteBufferFactory pooledByteBufferFactory) {
+        super(executor, pooledByteBufferFactory);
+    }
+
+    @Override
+    protected InputStream getInputStream(ImageRequest imageRequest) throws IOException {
+        return new FileInputStream(imageRequest.getSourceFile());
+    }
+
+    @Override
+    protected int getLength(ImageRequest imageRequest) {
+        return (int) imageRequest.getSourceFile().length();
+    }
+
+    @Override
+    protected String getProducerName() {
+        return PRODUCER_NAME;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalResourceFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalResourceFetchProducer.java
index 8156884f2..4072332be 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalResourceFetchProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalResourceFetchProducer.java
@@ -24,48 +24,49 @@
  * Executes a local fetch from a resource.
  */
 public class LocalResourceFetchProducer extends LocalFetchProducer {
-  @VisibleForTesting static final String PRODUCER_NAME = "LocalResourceFetchProducer";
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "LocalResourceFetchProducer";
 
-  private final Resources mResources;
+    private final Resources mResources;
 
-  public LocalResourceFetchProducer(
-      Executor executor,
-      PooledByteBufferFactory pooledByteBufferFactory,
-      Resources resources) {
-    super(executor, pooledByteBufferFactory);
-    mResources = resources;
-  }
+    public LocalResourceFetchProducer(
+            Executor executor,
+            PooledByteBufferFactory pooledByteBufferFactory,
+            Resources resources) {
+        super(executor, pooledByteBufferFactory);
+        mResources = resources;
+    }
 
-  @Override
-  protected InputStream getInputStream(ImageRequest imageRequest) throws IOException {
-    return mResources.openRawResource(getResourceId(imageRequest));
-  }
+    @Override
+    protected InputStream getInputStream(ImageRequest imageRequest) throws IOException {
+        return mResources.openRawResource(getResourceId(imageRequest));
+    }
 
-  @Override
-  protected int getLength(ImageRequest imageRequest) {
-    AssetFileDescriptor fd = null;
-    try {
-      fd = mResources.openRawResourceFd(getResourceId(imageRequest));
-      return (int) fd.getLength();
-    } catch (Resources.NotFoundException e) {
-      return -1;
-    } finally {
-      try {
-        if (fd != null) {
-          fd.close();
+    @Override
+    protected int getLength(ImageRequest imageRequest) {
+        AssetFileDescriptor fd = null;
+        try {
+            fd = mResources.openRawResourceFd(getResourceId(imageRequest));
+            return (int) fd.getLength();
+        } catch (Resources.NotFoundException e) {
+            return -1;
+        } finally {
+            try {
+                if (fd != null) {
+                    fd.close();
+                }
+            } catch (IOException ignored) {
+                // There's nothing we can do with the exception when closing descriptor.
+            }
         }
-      } catch (IOException ignored) {
-        // There's nothing we can do with the exception when closing descriptor.
-      }
     }
-  }
 
-  @Override
-  protected String getProducerName() {
-    return PRODUCER_NAME;
-  }
+    @Override
+    protected String getProducerName() {
+        return PRODUCER_NAME;
+    }
 
-  private static int getResourceId(ImageRequest imageRequest) {
-    return Integer.parseInt(imageRequest.getSourceUri().getPath().substring(1));
-  }
+    private static int getResourceId(ImageRequest imageRequest) {
+        return Integer.parseInt(imageRequest.getSourceUri().getPath().substring(1));
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalVideoThumbnailProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalVideoThumbnailProducer.java
index 7c0dfdd15..19fce255c 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalVideoThumbnailProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/LocalVideoThumbnailProducer.java
@@ -27,82 +27,84 @@
 
 /**
  * A producer that creates video thumbnails.
- *
+ * <p>
  * <p>At present, these thumbnails are created on the java heap rather than being pinned
  * purgeables. This is deemed okay as the thumbnails are only very small.
  */
 public class LocalVideoThumbnailProducer implements
-    Producer<CloseableReference<CloseableImage>> {
+        Producer<CloseableReference<CloseableImage>> {
 
-  @VisibleForTesting static final String PRODUCER_NAME = "VideoThumbnailProducer";
-  @VisibleForTesting static final String CREATED_THUMBNAIL = "createdThumbnail";
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "VideoThumbnailProducer";
+    @VisibleForTesting
+    static final String CREATED_THUMBNAIL = "createdThumbnail";
 
-  private final Executor mExecutor;
+    private final Executor mExecutor;
 
-  public LocalVideoThumbnailProducer(Executor executor) {
-    mExecutor = executor;
-  }
+    public LocalVideoThumbnailProducer(Executor executor) {
+        mExecutor = executor;
+    }
 
-  @Override
-  public void produceResults(
-      final Consumer<CloseableReference<CloseableImage>> consumer,
-      final ProducerContext producerContext) {
+    @Override
+    public void produceResults(
+            final Consumer<CloseableReference<CloseableImage>> consumer,
+            final ProducerContext producerContext) {
 
-    final ProducerListener listener = producerContext.getListener();
-    final String requestId = producerContext.getId();
-    final ImageRequest imageRequest = producerContext.getImageRequest();
-    final StatefulProducerRunnable cancellableProducerRunnable =
-        new StatefulProducerRunnable<CloseableReference<CloseableImage>>(
-            consumer,
-            listener,
-            PRODUCER_NAME,
-            requestId) {
-          @Override
-          protected CloseableReference<CloseableImage> getResult() throws Exception {
-            Bitmap thumbnailBitmap = ThumbnailUtils.createVideoThumbnail(
-                imageRequest.getSourceFile().getPath(),
-                calculateKind(imageRequest));
-            if (thumbnailBitmap == null) {
-              return null;
-            }
+        final ProducerListener listener = producerContext.getListener();
+        final String requestId = producerContext.getId();
+        final ImageRequest imageRequest = producerContext.getImageRequest();
+        final StatefulProducerRunnable cancellableProducerRunnable =
+                new StatefulProducerRunnable<CloseableReference<CloseableImage>>(
+                        consumer,
+                        listener,
+                        PRODUCER_NAME,
+                        requestId) {
+                    @Override
+                    protected CloseableReference<CloseableImage> getResult() throws Exception {
+                        Bitmap thumbnailBitmap = ThumbnailUtils.createVideoThumbnail(
+                                imageRequest.getSourceFile().getPath(),
+                                calculateKind(imageRequest));
+                        if (thumbnailBitmap == null) {
+                            return null;
+                        }
 
-            return CloseableReference.<CloseableImage>of(
-                new CloseableStaticBitmap(
-                    thumbnailBitmap,
-                    new ResourceReleaser<Bitmap>() {
-                      @Override
-                      public void release(Bitmap value) {
-                        value.recycle();
-                      }
-                    },
-                    ImmutableQualityInfo.FULL_QUALITY));
-          }
+                        return CloseableReference.<CloseableImage>of(
+                                new CloseableStaticBitmap(
+                                        thumbnailBitmap,
+                                        new ResourceReleaser<Bitmap>() {
+                                            @Override
+                                            public void release(Bitmap value) {
+                                                value.recycle();
+                                            }
+                                        },
+                                        ImmutableQualityInfo.FULL_QUALITY));
+                    }
 
-          @Override
-          protected Map<String, String> getExtraMapOnSuccess(
-              final CloseableReference<CloseableImage> result) {
-            return ImmutableMap.of(CREATED_THUMBNAIL, String.valueOf(result != null));
-          }
+                    @Override
+                    protected Map<String, String> getExtraMapOnSuccess(
+                            final CloseableReference<CloseableImage> result) {
+                        return ImmutableMap.of(CREATED_THUMBNAIL, String.valueOf(result != null));
+                    }
 
-          @Override
-          protected void disposeResult(CloseableReference<CloseableImage> result) {
-            CloseableReference.closeSafely(result);
-          }
-        };
-    producerContext.addCallbacks(
-        new BaseProducerContextCallbacks() {
-          @Override
-          public void onCancellationRequested() {
-            cancellableProducerRunnable.cancel();
-          }
-        });
-    mExecutor.execute(cancellableProducerRunnable);
-  }
+                    @Override
+                    protected void disposeResult(CloseableReference<CloseableImage> result) {
+                        CloseableReference.closeSafely(result);
+                    }
+                };
+        producerContext.addCallbacks(
+                new BaseProducerContextCallbacks() {
+                    @Override
+                    public void onCancellationRequested() {
+                        cancellableProducerRunnable.cancel();
+                    }
+                });
+        mExecutor.execute(cancellableProducerRunnable);
+    }
 
-  private static int calculateKind(ImageRequest imageRequest) {
-    if (imageRequest.getPreferredWidth() > 96 || imageRequest.getPreferredHeight() > 96) {
-      return MediaStore.Images.Thumbnails.MINI_KIND;
+    private static int calculateKind(ImageRequest imageRequest) {
+        if (imageRequest.getPreferredWidth() > 96 || imageRequest.getPreferredHeight() > 96) {
+            return MediaStore.Images.Thumbnails.MINI_KIND;
+        }
+        return MediaStore.Images.Thumbnails.MICRO_KIND;
     }
-    return MediaStore.Images.Thumbnails.MICRO_KIND;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/MemoryCacheProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/MemoryCacheProducer.java
index 07bd46aaa..7ee781f84 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/MemoryCacheProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/MemoryCacheProducer.java
@@ -18,114 +18,115 @@
 
 /**
  * Memory cache producer.
- *
+ * <p>
  * <p>This producer looks in the specified memory cache for the requested image. If the image is
  * found, then it is passed to the consumer. If the image is not found, then the request is passed
  * to the next producer in the sequence. Any results that the producer returns are passed to the
  * consumer, and the last result is also put into the memory cache.
  */
 public abstract class MemoryCacheProducer<K, T> implements Producer<CloseableReference<T>> {
-  @VisibleForTesting static final String CACHED_VALUE_FOUND = "cached_value_found";
-
-  protected final MemoryCache<K, T> mMemoryCache;
-  protected final CacheKeyFactory mCacheKeyFactory;
-  private final Producer<CloseableReference<T>> mNextProducer;
-
-  protected MemoryCacheProducer(
-      MemoryCache<K, T> memoryCache,
-      CacheKeyFactory cacheKeyFactory,
-      Producer<CloseableReference<T>> nextProducer) {
-    mMemoryCache = memoryCache;
-    mCacheKeyFactory = cacheKeyFactory;
-    mNextProducer = nextProducer;
-  }
-
-  @Override
-  public void produceResults(
-      final Consumer<CloseableReference<T>> consumer,
-      final ProducerContext producerContext) {
-
-    final ProducerListener listener = producerContext.getListener();
-    final String requestId = producerContext.getId();
-    listener.onProducerStart(requestId, getProducerName());
-
-    final K cacheKey = getCacheKey(producerContext.getImageRequest());
-    CloseableReference<T> cachedReference = mMemoryCache.get(cacheKey);
-    if (cachedReference != null) {
-      boolean isLast = isResultFinal(cachedReference);
-      if (isLast) {
-        listener.onProducerFinishWithSuccess(
-            requestId,
-            getProducerName(),
-            listener.requiresExtraMap(requestId) ?
-                ImmutableMap.of(CACHED_VALUE_FOUND, "true") :
-                null);
-        consumer.onProgressUpdate(1f);
-      }
-      consumer.onNewResult(cachedReference, isLast);
-      cachedReference.close();
-      if (isLast) {
-        return;
-      }
-    }
-
-    if (producerContext.getLowestPermittedRequestLevel().getValue() >=
-        getProducerRequestLevel().getValue()) {
-      listener.onProducerFinishWithSuccess(
-          requestId,
-          getProducerName(),
-          listener.requiresExtraMap(requestId) ?
-              ImmutableMap.of(CACHED_VALUE_FOUND, "false") :
-              null);
-      consumer.onNewResult(null, true);
-      return;
+    @VisibleForTesting
+    static final String CACHED_VALUE_FOUND = "cached_value_found";
+
+    protected final MemoryCache<K, T> mMemoryCache;
+    protected final CacheKeyFactory mCacheKeyFactory;
+    private final Producer<CloseableReference<T>> mNextProducer;
+
+    protected MemoryCacheProducer(
+            MemoryCache<K, T> memoryCache,
+            CacheKeyFactory cacheKeyFactory,
+            Producer<CloseableReference<T>> nextProducer) {
+        mMemoryCache = memoryCache;
+        mCacheKeyFactory = cacheKeyFactory;
+        mNextProducer = nextProducer;
     }
 
-    Consumer<CloseableReference<T>> consumerOfNextProducer;
-    if (!shouldCacheReturnedValues()) {
-      consumerOfNextProducer = consumer;
-    } else {
-      consumerOfNextProducer =
-          new DelegatingConsumer<CloseableReference<T>, CloseableReference<T>>(consumer) {
-            @Override
-            public void onNewResultImpl(CloseableReference<T> newResult, boolean isLast) {
-              CloseableReference<T> cachedResult = null;
-              if (newResult != null && shouldCacheResult(newResult, cacheKey, isLast)) {
-                cachedResult = mMemoryCache.cache(cacheKey, newResult);
-              }
-              try {
-                CloseableReference<T> result = (cachedResult != null) ? cachedResult : newResult;
-                if (CloseableReference.isValid(result) && isLast) {
-                  getConsumer().onProgressUpdate(1f);
-                }
-                getConsumer().onNewResult(result, isLast);
-              } finally {
-                // we only own cachedResult, newResult is owned by the caller
-                CloseableReference.closeSafely(cachedResult);
-              }
+    @Override
+    public void produceResults(
+            final Consumer<CloseableReference<T>> consumer,
+            final ProducerContext producerContext) {
+
+        final ProducerListener listener = producerContext.getListener();
+        final String requestId = producerContext.getId();
+        listener.onProducerStart(requestId, getProducerName());
+
+        final K cacheKey = getCacheKey(producerContext.getImageRequest());
+        CloseableReference<T> cachedReference = mMemoryCache.get(cacheKey);
+        if (cachedReference != null) {
+            boolean isLast = isResultFinal(cachedReference);
+            if (isLast) {
+                listener.onProducerFinishWithSuccess(
+                        requestId,
+                        getProducerName(),
+                        listener.requiresExtraMap(requestId) ?
+                                ImmutableMap.of(CACHED_VALUE_FOUND, "true") :
+                                null);
+                consumer.onProgressUpdate(1f);
             }
-          };
-    }
+            consumer.onNewResult(cachedReference, isLast);
+            cachedReference.close();
+            if (isLast) {
+                return;
+            }
+        }
+
+        if (producerContext.getLowestPermittedRequestLevel().getValue() >=
+                getProducerRequestLevel().getValue()) {
+            listener.onProducerFinishWithSuccess(
+                    requestId,
+                    getProducerName(),
+                    listener.requiresExtraMap(requestId) ?
+                            ImmutableMap.of(CACHED_VALUE_FOUND, "false") :
+                            null);
+            consumer.onNewResult(null, true);
+            return;
+        }
+
+        Consumer<CloseableReference<T>> consumerOfNextProducer;
+        if (!shouldCacheReturnedValues()) {
+            consumerOfNextProducer = consumer;
+        } else {
+            consumerOfNextProducer =
+                    new DelegatingConsumer<CloseableReference<T>, CloseableReference<T>>(consumer) {
+                        @Override
+                        public void onNewResultImpl(CloseableReference<T> newResult, boolean isLast) {
+                            CloseableReference<T> cachedResult = null;
+                            if (newResult != null && shouldCacheResult(newResult, cacheKey, isLast)) {
+                                cachedResult = mMemoryCache.cache(cacheKey, newResult);
+                            }
+                            try {
+                                CloseableReference<T> result = (cachedResult != null) ? cachedResult : newResult;
+                                if (CloseableReference.isValid(result) && isLast) {
+                                    getConsumer().onProgressUpdate(1f);
+                                }
+                                getConsumer().onNewResult(result, isLast);
+                            } finally {
+                                // we only own cachedResult, newResult is owned by the caller
+                                CloseableReference.closeSafely(cachedResult);
+                            }
+                        }
+                    };
+        }
 
-    listener.onProducerFinishWithSuccess(
-        requestId,
-        getProducerName(),
-        listener.requiresExtraMap(requestId) ? ImmutableMap.of(CACHED_VALUE_FOUND, "false") : null);
-    mNextProducer.produceResults(consumerOfNextProducer, producerContext);
-  }
+        listener.onProducerFinishWithSuccess(
+                requestId,
+                getProducerName(),
+                listener.requiresExtraMap(requestId) ? ImmutableMap.of(CACHED_VALUE_FOUND, "false") : null);
+        mNextProducer.produceResults(consumerOfNextProducer, producerContext);
+    }
 
-  protected abstract K getCacheKey(ImageRequest imageRequest);
+    protected abstract K getCacheKey(ImageRequest imageRequest);
 
-  protected abstract boolean isResultFinal(CloseableReference<T> cachedResultFound);
+    protected abstract boolean isResultFinal(CloseableReference<T> cachedResultFound);
 
-  protected abstract ImageRequest.RequestLevel getProducerRequestLevel();
+    protected abstract ImageRequest.RequestLevel getProducerRequestLevel();
 
-  protected abstract boolean shouldCacheReturnedValues();
+    protected abstract boolean shouldCacheReturnedValues();
 
-  protected abstract boolean shouldCacheResult(
-      CloseableReference<T> result,
-      K cacheKey,
-      boolean isLast);
+    protected abstract boolean shouldCacheResult(
+            CloseableReference<T> result,
+            K cacheKey,
+            boolean isLast);
 
-  protected abstract String getProducerName();
+    protected abstract String getProducerName();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/MultiplexProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/MultiplexProducer.java
index f7c39434b..5515907cf 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/MultiplexProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/MultiplexProducer.java
@@ -28,7 +28,7 @@
 
 /**
  * Producer for combining multiple identical requests into a single request.
- *
+ * <p>
  * <p>Requests using the same key will be combined into a single request. This request is only
  * cancelled when all underlying requests are cancelled, and returns values to all underlying
  * consumers. If the request has already return one or more results but has not finished, then
@@ -40,470 +40,472 @@
 @ThreadSafe
 public abstract class MultiplexProducer<K, T> implements Producer<CloseableReference<T>> {
 
-  /**
-   * Map of multiplexers guarded by "this" lock. The lock should be used only to synchronize
-   * accesses to this map. In particular, no callbacks or third party code should be run under
-   * "this" lock.
-   *
-   * <p> The map might contain entries in progress, entries in progress for which cancellation
-   * has been requested and ignored, or cancelled entries for which onCancellation has not been
-   * called yet.
-   */
-  @GuardedBy("this")
-  @VisibleForTesting final Map<K, Multiplexer> mMultiplexers;
-  private final Producer<CloseableReference<T>> mNextProducer;
-
-  protected MultiplexProducer(Producer nextProducer) {
-    mNextProducer = nextProducer;
-    mMultiplexers = Maps.newHashMap();
-  }
-
-  @Override
-  public void produceResults(Consumer<CloseableReference<T>> consumer, ProducerContext context) {
-    K key = getKey(context);
-    Multiplexer multiplexer;
-    boolean createdNewMultiplexer;
-    // We do want to limit scope of this lock to guard only accesses to mMultiplexers map.
-    // However what we would like to do here is to atomically lookup mMultiplexers, add new
-    // consumer to consumers set associated with the map's entry and call consumer's callback with
-    // last intermediate result. We should not do all of those things under this lock.
-    do {
-      createdNewMultiplexer = false;
-      synchronized (this) {
-        multiplexer = getExistingMultiplexer(key);
-        if (multiplexer == null) {
-          multiplexer = createAndPutNewMultiplexer(key);
-          createdNewMultiplexer = true;
-        }
-      }
-      // addNewConsumer may call consumer's onNewResult method immediately. For this reason
-      // we release "this" lock. If multiplexer is removed from mMultiplexers in the meantime,
-      // which is not very probable, then addNewConsumer will fail and we will be able to retry.
-    } while (!multiplexer.addNewConsumer(consumer, context));
-
-    if (createdNewMultiplexer) {
-      multiplexer.startNextProducerIfHasAttachedConsumers();
-    }
-  }
-
-  private synchronized Multiplexer getExistingMultiplexer(K key) {
-    return mMultiplexers.get(key);
-  }
-
-  private synchronized Multiplexer createAndPutNewMultiplexer(K key) {
-    Multiplexer multiplexer = new Multiplexer(key);
-    mMultiplexers.put(key, multiplexer);
-    return multiplexer;
-  }
-
-  private synchronized void removeMultiplexer(K key, Multiplexer multiplexer) {
-    if (mMultiplexers.get(key) == multiplexer) {
-      mMultiplexers.remove(key);
-    }
-  }
-
-  protected abstract K getKey(ProducerContext producerContext);
-
-  /**
-   * Multiplexes same requests - passes the same result to multiple consumers, manages cancellation
-   * and maintains last intermediate result.
-   *
-   * <p> Multiplexed computation might be in one of 3 states:
-   * <ul>
-   *   <li> in progress </li>
-   *   <li> in progress after requesting cancellation (cancellation has been denied) </li>
-   *   <li> cancelled, but without onCancellation method being called yet </li>
-   * </ul>
-   *
-   * <p> In last case new consumers may be added before onCancellation is called. When it is, the
-   * Multiplexer has to check if it is the case and start next producer once again if so.
-   */
-  @VisibleForTesting class Multiplexer {
-    private final K mKey;
-
     /**
-     * Set of consumer-context pairs participating in multiplexing. Cancelled pairs
-     * are removed from the set.
-     *
-     * <p> Following invariant is maintained: if mConsumerContextPairs is not empty, then this
-     * instance of Multiplexer is present in mMultiplexers map. This way all ongoing multiplexed
-     * requests might be attached to by other requests
-     *
-     * <p> A Multiplexer is removed from the map only if
-     * <ul>
-     *   <li> final result is received </li>
-     *   <li> error is received </li>
-     *   <li> cancellation notification is received and mConsumerContextPairs is empty </li>
-     * </ul>
+     * Map of multiplexers guarded by "this" lock. The lock should be used only to synchronize
+     * accesses to this map. In particular, no callbacks or third party code should be run under
+     * "this" lock.
+     * <p>
+     * <p> The map might contain entries in progress, entries in progress for which cancellation
+     * has been requested and ignored, or cancelled entries for which onCancellation has not been
+     * called yet.
      */
-    private final CopyOnWriteArraySet<Pair<Consumer<CloseableReference<T>>, ProducerContext>>
-        mConsumerContextPairs;
-
-    @GuardedBy("Multiplexer.this")
-    @Nullable
-    private CloseableReference<T> mLastIntermediateResult;
-    @GuardedBy("Multiplexer.this")
-    private float mLastProgress;
+    @GuardedBy("this")
+    @VisibleForTesting
+    final Map<K, Multiplexer> mMultiplexers;
+    private final Producer<CloseableReference<T>> mNextProducer;
+
+    protected MultiplexProducer(Producer nextProducer) {
+        mNextProducer = nextProducer;
+        mMultiplexers = Maps.newHashMap();
+    }
 
-    /**
-     * Producer context used for cancelling producers below MultiplexProducers, and for setting
-     * whether the request is a prefetch or not.
-     *
-     * <p> If not null, then underlying computation has been started, and no onCancellation callback
-     * has been received yet.
-     */
-    @GuardedBy("Multiplexer.this")
-    @Nullable
-    private SettableProducerContext mMultiplexProducerContext;
+    @Override
+    public void produceResults(Consumer<CloseableReference<T>> consumer, ProducerContext context) {
+        K key = getKey(context);
+        Multiplexer multiplexer;
+        boolean createdNewMultiplexer;
+        // We do want to limit scope of this lock to guard only accesses to mMultiplexers map.
+        // However what we would like to do here is to atomically lookup mMultiplexers, add new
+        // consumer to consumers set associated with the map's entry and call consumer's callback with
+        // last intermediate result. We should not do all of those things under this lock.
+        do {
+            createdNewMultiplexer = false;
+            synchronized (this) {
+                multiplexer = getExistingMultiplexer(key);
+                if (multiplexer == null) {
+                    multiplexer = createAndPutNewMultiplexer(key);
+                    createdNewMultiplexer = true;
+                }
+            }
+            // addNewConsumer may call consumer's onNewResult method immediately. For this reason
+            // we release "this" lock. If multiplexer is removed from mMultiplexers in the meantime,
+            // which is not very probable, then addNewConsumer will fail and we will be able to retry.
+        } while (!multiplexer.addNewConsumer(consumer, context));
 
-    /**
-     * Currently used consumer of next producer.
-     *
-     * <p> The same Multiplexer might call mNextProducer.produceResults multiple times when
-     * cancellation happens. This field is used to guard against late callbacks.
-     *
-     * <p>  If not null, then underlying computation has been started, and no onCancellation
-     * callback has been received yet.
-     */
-    @GuardedBy("Multiplexer.this")
-    @Nullable
-    private ForwardingConsumer mForwardingConsumer;
+        if (createdNewMultiplexer) {
+            multiplexer.startNextProducerIfHasAttachedConsumers();
+        }
+    }
 
-    public Multiplexer(K key) {
-      mConsumerContextPairs = Sets.newCopyOnWriteArraySet();
-      mKey = key;
+    private synchronized Multiplexer getExistingMultiplexer(K key) {
+        return mMultiplexers.get(key);
     }
 
-    /**
-     * Tries to add consumer to set of consumers participating in multiplexing. If successful and
-     * appropriate intermediate result is already known, then it will be passed to the consumer.
-     *
-     * <p> This function will fail and return false if the multiplexer is not present in
-     * mMultiplexers map.
-     *
-     * @return true if consumer was added successfully
-     */
-    public boolean addNewConsumer(
-        final Consumer<CloseableReference<T>> consumer,
-        final ProducerContext producerContext) {
-      final Pair<Consumer<CloseableReference<T>>, ProducerContext> consumerContextPair =
-          Pair.create(consumer, producerContext);
-      CloseableReference<T> lastIntermediateResult;
-      float lastProgress;
-
-      // Check if Multiplexer is still in mMultiplexers map, and if so add new consumer.
-      // Also store current intermediate result - we will notify consumer after acquiring
-      // appropriate lock.
-      synchronized (Multiplexer.this) {
-        if (getExistingMultiplexer(mKey) != this) {
-          return false;
-        }
-        mConsumerContextPairs.add(consumerContextPair);
-        if (mMultiplexProducerContext != null) {
-          if (mMultiplexProducerContext.isPrefetch()) {
-            mMultiplexProducerContext.setIsPrefetch(consumerContextPair.second.isPrefetch());
-          }
-          if (!mMultiplexProducerContext.isIntermediateResultExpected()) {
-            mMultiplexProducerContext.setIsIntermediateResultExpected(
-                consumerContextPair.second.isIntermediateResultExpected());
-          }
-          mMultiplexProducerContext.setPriority(
-              Priority.getHigherPriority(
-                  mMultiplexProducerContext.getPriority(),
-                  consumerContextPair.second.getPriority()));
-        }
-        lastIntermediateResult = mLastIntermediateResult;
-        lastProgress = mLastProgress;
-      }
-
-      synchronized (consumerContextPair) {
-        // check if last result changed in the mean time. In such case we should not propagate it
-        synchronized (Multiplexer.this) {
-          if (lastIntermediateResult != mLastIntermediateResult) {
-            lastIntermediateResult = null;
-          } else if (lastIntermediateResult != null) {
-            lastIntermediateResult = lastIntermediateResult.clone();
-          }
-        }
+    private synchronized Multiplexer createAndPutNewMultiplexer(K key) {
+        Multiplexer multiplexer = new Multiplexer(key);
+        mMultiplexers.put(key, multiplexer);
+        return multiplexer;
+    }
 
-        if (lastIntermediateResult != null) {
-          if (lastProgress > 0) {
-            consumer.onProgressUpdate(lastProgress);
-          }
-          consumer.onNewResult(lastIntermediateResult, false);
-          lastIntermediateResult.close();
+    private synchronized void removeMultiplexer(K key, Multiplexer multiplexer) {
+        if (mMultiplexers.get(key) == multiplexer) {
+            mMultiplexers.remove(key);
         }
-      }
-
-      addCallbacks(consumerContextPair, producerContext);
-      return true;
     }
 
+    protected abstract K getKey(ProducerContext producerContext);
+
     /**
-     * Register callbacks to be called when cancellation of consumer is requested, or if the
-     * prefetch status of the consumer changes.
+     * Multiplexes same requests - passes the same result to multiple consumers, manages cancellation
+     * and maintains last intermediate result.
+     * <p>
+     * <p> Multiplexed computation might be in one of 3 states:
+     * <ul>
+     * <li> in progress </li>
+     * <li> in progress after requesting cancellation (cancellation has been denied) </li>
+     * <li> cancelled, but without onCancellation method being called yet </li>
+     * </ul>
+     * <p>
+     * <p> In last case new consumers may be added before onCancellation is called. When it is, the
+     * Multiplexer has to check if it is the case and start next producer once again if so.
      */
-    private void addCallbacks(
-        final Pair<Consumer<CloseableReference<T>>, ProducerContext> consumerContextPair,
-        final ProducerContext producerContext) {
-      producerContext.addCallbacks(
-          new BaseProducerContextCallbacks() {
-            @Override
-            public void onCancellationRequested() {
-              SettableProducerContext contextToCancel = null;
-              boolean pairWasRemoved = false;
-              synchronized (Multiplexer.this) {
-                pairWasRemoved = mConsumerContextPairs.remove(consumerContextPair);
-                if (pairWasRemoved) {
-                  if (mConsumerContextPairs.isEmpty()) {
-                    contextToCancel = mMultiplexProducerContext;
-                  } else if (mMultiplexProducerContext != null) {
-                    if (!mMultiplexProducerContext.isPrefetch() &&
-                        !consumerContextPair.second.isPrefetch()) {
-                      mMultiplexProducerContext.setIsPrefetch(isPrefetch());
-                    }
-                    if (consumerContextPair.second.isIntermediateResultExpected()) {
-                      mMultiplexProducerContext.setIsIntermediateResultExpected(
-                          isIntermediateResultExpected());
+    @VisibleForTesting
+    class Multiplexer {
+        private final K mKey;
+
+        /**
+         * Set of consumer-context pairs participating in multiplexing. Cancelled pairs
+         * are removed from the set.
+         * <p>
+         * <p> Following invariant is maintained: if mConsumerContextPairs is not empty, then this
+         * instance of Multiplexer is present in mMultiplexers map. This way all ongoing multiplexed
+         * requests might be attached to by other requests
+         * <p>
+         * <p> A Multiplexer is removed from the map only if
+         * <ul>
+         * <li> final result is received </li>
+         * <li> error is received </li>
+         * <li> cancellation notification is received and mConsumerContextPairs is empty </li>
+         * </ul>
+         */
+        private final CopyOnWriteArraySet<Pair<Consumer<CloseableReference<T>>, ProducerContext>>
+                mConsumerContextPairs;
+
+        @GuardedBy("Multiplexer.this")
+        @Nullable
+        private CloseableReference<T> mLastIntermediateResult;
+        @GuardedBy("Multiplexer.this")
+        private float mLastProgress;
+
+        /**
+         * Producer context used for cancelling producers below MultiplexProducers, and for setting
+         * whether the request is a prefetch or not.
+         * <p>
+         * <p> If not null, then underlying computation has been started, and no onCancellation callback
+         * has been received yet.
+         */
+        @GuardedBy("Multiplexer.this")
+        @Nullable
+        private SettableProducerContext mMultiplexProducerContext;
+
+        /**
+         * Currently used consumer of next producer.
+         * <p>
+         * <p> The same Multiplexer might call mNextProducer.produceResults multiple times when
+         * cancellation happens. This field is used to guard against late callbacks.
+         * <p>
+         * <p>  If not null, then underlying computation has been started, and no onCancellation
+         * callback has been received yet.
+         */
+        @GuardedBy("Multiplexer.this")
+        @Nullable
+        private ForwardingConsumer mForwardingConsumer;
+
+        public Multiplexer(K key) {
+            mConsumerContextPairs = Sets.newCopyOnWriteArraySet();
+            mKey = key;
+        }
+
+        /**
+         * Tries to add consumer to set of consumers participating in multiplexing. If successful and
+         * appropriate intermediate result is already known, then it will be passed to the consumer.
+         * <p>
+         * <p> This function will fail and return false if the multiplexer is not present in
+         * mMultiplexers map.
+         *
+         * @return true if consumer was added successfully
+         */
+        public boolean addNewConsumer(
+                final Consumer<CloseableReference<T>> consumer,
+                final ProducerContext producerContext) {
+            final Pair<Consumer<CloseableReference<T>>, ProducerContext> consumerContextPair =
+                    Pair.create(consumer, producerContext);
+            CloseableReference<T> lastIntermediateResult;
+            float lastProgress;
+
+            // Check if Multiplexer is still in mMultiplexers map, and if so add new consumer.
+            // Also store current intermediate result - we will notify consumer after acquiring
+            // appropriate lock.
+            synchronized (Multiplexer.this) {
+                if (getExistingMultiplexer(mKey) != this) {
+                    return false;
+                }
+                mConsumerContextPairs.add(consumerContextPair);
+                if (mMultiplexProducerContext != null) {
+                    if (mMultiplexProducerContext.isPrefetch()) {
+                        mMultiplexProducerContext.setIsPrefetch(consumerContextPair.second.isPrefetch());
                     }
-                    if (mMultiplexProducerContext.getPriority().equals(
-                        consumerContextPair.second.getPriority())) {
-                      mMultiplexProducerContext.setPriority(getPriority());
+                    if (!mMultiplexProducerContext.isIntermediateResultExpected()) {
+                        mMultiplexProducerContext.setIsIntermediateResultExpected(
+                                consumerContextPair.second.isIntermediateResultExpected());
                     }
-                  }
+                    mMultiplexProducerContext.setPriority(
+                            Priority.getHigherPriority(
+                                    mMultiplexProducerContext.getPriority(),
+                                    consumerContextPair.second.getPriority()));
                 }
-              }
-              if (contextToCancel != null) {
-                contextToCancel.cancel();
-              }
-              if (pairWasRemoved) {
-                consumerContextPair.first.onCancellation();
-              }
+                lastIntermediateResult = mLastIntermediateResult;
+                lastProgress = mLastProgress;
             }
 
-            @Override
-            public void onIsPrefetchChanged() {
-              synchronized (Multiplexer.this) {
-                if (mMultiplexProducerContext != null) {
-                  if (mMultiplexProducerContext.isPrefetch()) {
-                    mMultiplexProducerContext.setIsPrefetch(
-                        consumerContextPair.second.isPrefetch());
-                  } else if (consumerContextPair.second.isPrefetch()) {
-                    mMultiplexProducerContext.setIsPrefetch(isPrefetch());
-                  }
+            synchronized (consumerContextPair) {
+                // check if last result changed in the mean time. In such case we should not propagate it
+                synchronized (Multiplexer.this) {
+                    if (lastIntermediateResult != mLastIntermediateResult) {
+                        lastIntermediateResult = null;
+                    } else if (lastIntermediateResult != null) {
+                        lastIntermediateResult = lastIntermediateResult.clone();
+                    }
                 }
-              }
-            }
 
-            @Override
-            public void onIsIntermediateResultExpectedChanged() {
-              synchronized (Multiplexer.this) {
-                if (mMultiplexProducerContext != null) {
-                  if (consumerContextPair.second.isIntermediateResultExpected()) {
-                    mMultiplexProducerContext.setIsIntermediateResultExpected(true);
-                  } else if (mMultiplexProducerContext.isIntermediateResultExpected()) {
-                    mMultiplexProducerContext.setIsIntermediateResultExpected(
-                        isIntermediateResultExpected());
-                  }
+                if (lastIntermediateResult != null) {
+                    if (lastProgress > 0) {
+                        consumer.onProgressUpdate(lastProgress);
+                    }
+                    consumer.onNewResult(lastIntermediateResult, false);
+                    lastIntermediateResult.close();
                 }
-              }
             }
 
-            @Override
-            public void onPriorityChanged() {
-              synchronized (Multiplexer.this) {
-                if (mMultiplexProducerContext != null) {
-                  Priority newPriority = consumerContextPair.second.getPriority();
-                  if (Priority.getHigherPriority(
-                          mMultiplexProducerContext.getPriority(),
-                          newPriority).equals(newPriority)) {
-                    mMultiplexProducerContext.setPriority(newPriority);
-                  } else {
-                    mMultiplexProducerContext.setPriority(getPriority());
-                  }
-                }
-              }
-            }
-          });
-    }
+            addCallbacks(consumerContextPair, producerContext);
+            return true;
+        }
 
-    /**
-     * Starts next producer if it is not started yet and there is at least one Consumer waiting for
-     * the data. If all consumers are cancelled, then this multiplexer is removed from mRequest
-     * map to clean up.
-     */
-    private void startNextProducerIfHasAttachedConsumers() {
-      SettableProducerContext multiplexProducerContext;
-      ForwardingConsumer forwardingConsumer;
-      synchronized (Multiplexer.this) {
-        Preconditions.checkArgument(mMultiplexProducerContext == null);
-        Preconditions.checkArgument(mForwardingConsumer == null);
-
-        // Cleanup if all consumers have been cancelled before this method was called
-        if (mConsumerContextPairs.isEmpty()) {
-          removeMultiplexer(mKey, this);
-          return;
+        /**
+         * Register callbacks to be called when cancellation of consumer is requested, or if the
+         * prefetch status of the consumer changes.
+         */
+        private void addCallbacks(
+                final Pair<Consumer<CloseableReference<T>>, ProducerContext> consumerContextPair,
+                final ProducerContext producerContext) {
+            producerContext.addCallbacks(
+                    new BaseProducerContextCallbacks() {
+                        @Override
+                        public void onCancellationRequested() {
+                            SettableProducerContext contextToCancel = null;
+                            boolean pairWasRemoved = false;
+                            synchronized (Multiplexer.this) {
+                                pairWasRemoved = mConsumerContextPairs.remove(consumerContextPair);
+                                if (pairWasRemoved) {
+                                    if (mConsumerContextPairs.isEmpty()) {
+                                        contextToCancel = mMultiplexProducerContext;
+                                    } else if (mMultiplexProducerContext != null) {
+                                        if (!mMultiplexProducerContext.isPrefetch() &&
+                                                !consumerContextPair.second.isPrefetch()) {
+                                            mMultiplexProducerContext.setIsPrefetch(isPrefetch());
+                                        }
+                                        if (consumerContextPair.second.isIntermediateResultExpected()) {
+                                            mMultiplexProducerContext.setIsIntermediateResultExpected(
+                                                    isIntermediateResultExpected());
+                                        }
+                                        if (mMultiplexProducerContext.getPriority().equals(
+                                                consumerContextPair.second.getPriority())) {
+                                            mMultiplexProducerContext.setPriority(getPriority());
+                                        }
+                                    }
+                                }
+                            }
+                            if (contextToCancel != null) {
+                                contextToCancel.cancel();
+                            }
+                            if (pairWasRemoved) {
+                                consumerContextPair.first.onCancellation();
+                            }
+                        }
+
+                        @Override
+                        public void onIsPrefetchChanged() {
+                            synchronized (Multiplexer.this) {
+                                if (mMultiplexProducerContext != null) {
+                                    if (mMultiplexProducerContext.isPrefetch()) {
+                                        mMultiplexProducerContext.setIsPrefetch(
+                                                consumerContextPair.second.isPrefetch());
+                                    } else if (consumerContextPair.second.isPrefetch()) {
+                                        mMultiplexProducerContext.setIsPrefetch(isPrefetch());
+                                    }
+                                }
+                            }
+                        }
+
+                        @Override
+                        public void onIsIntermediateResultExpectedChanged() {
+                            synchronized (Multiplexer.this) {
+                                if (mMultiplexProducerContext != null) {
+                                    if (consumerContextPair.second.isIntermediateResultExpected()) {
+                                        mMultiplexProducerContext.setIsIntermediateResultExpected(true);
+                                    } else if (mMultiplexProducerContext.isIntermediateResultExpected()) {
+                                        mMultiplexProducerContext.setIsIntermediateResultExpected(
+                                                isIntermediateResultExpected());
+                                    }
+                                }
+                            }
+                        }
+
+                        @Override
+                        public void onPriorityChanged() {
+                            synchronized (Multiplexer.this) {
+                                if (mMultiplexProducerContext != null) {
+                                    Priority newPriority = consumerContextPair.second.getPriority();
+                                    if (Priority.getHigherPriority(
+                                            mMultiplexProducerContext.getPriority(),
+                                            newPriority).equals(newPriority)) {
+                                        mMultiplexProducerContext.setPriority(newPriority);
+                                    } else {
+                                        mMultiplexProducerContext.setPriority(getPriority());
+                                    }
+                                }
+                            }
+                        }
+                    });
         }
 
-        ProducerContext producerContext = mConsumerContextPairs.iterator().next().second;
-        mMultiplexProducerContext = new SettableProducerContext(
-            producerContext.getImageRequest(),
-            producerContext.getId(),
-            producerContext.getListener(),
-            producerContext.getCallerContext(),
-            producerContext.getLowestPermittedRequestLevel(),
-            isPrefetch(),
-            isIntermediateResultExpected(),
-            getPriority());
-        mForwardingConsumer = new ForwardingConsumer();
-        multiplexProducerContext = mMultiplexProducerContext;
-        forwardingConsumer = mForwardingConsumer;
-      }
-      mNextProducer.produceResults(
-          forwardingConsumer,
-          multiplexProducerContext);
-    }
+        /**
+         * Starts next producer if it is not started yet and there is at least one Consumer waiting for
+         * the data. If all consumers are cancelled, then this multiplexer is removed from mRequest
+         * map to clean up.
+         */
+        private void startNextProducerIfHasAttachedConsumers() {
+            SettableProducerContext multiplexProducerContext;
+            ForwardingConsumer forwardingConsumer;
+            synchronized (Multiplexer.this) {
+                Preconditions.checkArgument(mMultiplexProducerContext == null);
+                Preconditions.checkArgument(mForwardingConsumer == null);
+
+                // Cleanup if all consumers have been cancelled before this method was called
+                if (mConsumerContextPairs.isEmpty()) {
+                    removeMultiplexer(mKey, this);
+                    return;
+                }
 
-    private synchronized boolean isPrefetch() {
-      for (Pair<Consumer<CloseableReference<T>>, ProducerContext> pair : mConsumerContextPairs) {
-        if (!pair.second.isPrefetch()) {
-          return false;
+                ProducerContext producerContext = mConsumerContextPairs.iterator().next().second;
+                mMultiplexProducerContext = new SettableProducerContext(
+                        producerContext.getImageRequest(),
+                        producerContext.getId(),
+                        producerContext.getListener(),
+                        producerContext.getCallerContext(),
+                        producerContext.getLowestPermittedRequestLevel(),
+                        isPrefetch(),
+                        isIntermediateResultExpected(),
+                        getPriority());
+                mForwardingConsumer = new ForwardingConsumer();
+                multiplexProducerContext = mMultiplexProducerContext;
+                forwardingConsumer = mForwardingConsumer;
+            }
+            mNextProducer.produceResults(
+                    forwardingConsumer,
+                    multiplexProducerContext);
         }
-      }
-      return true;
-    }
 
-    private synchronized boolean isIntermediateResultExpected() {
-      for (Pair<Consumer<CloseableReference<T>>, ProducerContext> pair : mConsumerContextPairs) {
-        if (pair.second.isIntermediateResultExpected()) {
-          return true;
+        private synchronized boolean isPrefetch() {
+            for (Pair<Consumer<CloseableReference<T>>, ProducerContext> pair : mConsumerContextPairs) {
+                if (!pair.second.isPrefetch()) {
+                    return false;
+                }
+            }
+            return true;
         }
-      }
-      return false;
-    }
 
-    private synchronized Priority getPriority() {
-      Priority priority = Priority.LOW;
-      for (Pair<Consumer<CloseableReference<T>>, ProducerContext> pair : mConsumerContextPairs) {
-        priority = Priority.getHigherPriority(priority, pair.second.getPriority());
-      }
-      return priority;
-    }
+        private synchronized boolean isIntermediateResultExpected() {
+            for (Pair<Consumer<CloseableReference<T>>, ProducerContext> pair : mConsumerContextPairs) {
+                if (pair.second.isIntermediateResultExpected()) {
+                    return true;
+                }
+            }
+            return false;
+        }
 
-    public void onFailure(final ForwardingConsumer consumer, final Throwable t) {
-      Iterator<Pair<Consumer<CloseableReference<T>>, ProducerContext>> iterator;
-      synchronized (Multiplexer.this) {
-        // check for late callbacks
-        if (mForwardingConsumer != consumer) {
-          return;
+        private synchronized Priority getPriority() {
+            Priority priority = Priority.LOW;
+            for (Pair<Consumer<CloseableReference<T>>, ProducerContext> pair : mConsumerContextPairs) {
+                priority = Priority.getHigherPriority(priority, pair.second.getPriority());
+            }
+            return priority;
         }
 
-        iterator = mConsumerContextPairs.iterator();
+        public void onFailure(final ForwardingConsumer consumer, final Throwable t) {
+            Iterator<Pair<Consumer<CloseableReference<T>>, ProducerContext>> iterator;
+            synchronized (Multiplexer.this) {
+                // check for late callbacks
+                if (mForwardingConsumer != consumer) {
+                    return;
+                }
 
-        mConsumerContextPairs.clear();
-        removeMultiplexer(mKey, this);
-        CloseableReference.closeSafely(mLastIntermediateResult);
-        mLastIntermediateResult = null;
-      }
+                iterator = mConsumerContextPairs.iterator();
 
-      while (iterator.hasNext()) {
-        Pair<Consumer<CloseableReference<T>>, ProducerContext> pair = iterator.next();
-        synchronized (pair) {
-          pair.first.onFailure(t);
-        }
-      }
-    }
+                mConsumerContextPairs.clear();
+                removeMultiplexer(mKey, this);
+                CloseableReference.closeSafely(mLastIntermediateResult);
+                mLastIntermediateResult = null;
+            }
 
-    public void onNextResult(
-        final ForwardingConsumer consumer,
-        final CloseableReference<T> closeableReference,
-        final boolean isFinal) {
-      Iterator<Pair<Consumer<CloseableReference<T>>, ProducerContext>> iterator;
-      synchronized (Multiplexer.this) {
-        // check for late callbacks
-        if (mForwardingConsumer != consumer) {
-          return;
+            while (iterator.hasNext()) {
+                Pair<Consumer<CloseableReference<T>>, ProducerContext> pair = iterator.next();
+                synchronized (pair) {
+                    pair.first.onFailure(t);
+                }
+            }
         }
 
-        CloseableReference.closeSafely(mLastIntermediateResult);
-        mLastIntermediateResult = null;
+        public void onNextResult(
+                final ForwardingConsumer consumer,
+                final CloseableReference<T> closeableReference,
+                final boolean isFinal) {
+            Iterator<Pair<Consumer<CloseableReference<T>>, ProducerContext>> iterator;
+            synchronized (Multiplexer.this) {
+                // check for late callbacks
+                if (mForwardingConsumer != consumer) {
+                    return;
+                }
 
-        iterator = mConsumerContextPairs.iterator();
-        if (!isFinal) {
-          mLastIntermediateResult = closeableReference.clone();
-        } else {
-          mConsumerContextPairs.clear();
-          removeMultiplexer(mKey, this);
-        }
-      }
+                CloseableReference.closeSafely(mLastIntermediateResult);
+                mLastIntermediateResult = null;
 
-      while (iterator.hasNext()) {
-        Pair<Consumer<CloseableReference<T>>, ProducerContext> pair = iterator.next();
-        synchronized (pair) {
-          pair.first.onNewResult(closeableReference, isFinal);
-        }
-      }
-    }
+                iterator = mConsumerContextPairs.iterator();
+                if (!isFinal) {
+                    mLastIntermediateResult = closeableReference.clone();
+                } else {
+                    mConsumerContextPairs.clear();
+                    removeMultiplexer(mKey, this);
+                }
+            }
 
-    public void onCancelled(final ForwardingConsumer forwardingConsumer) {
-      synchronized (Multiplexer.this) {
-        // check for late callbacks
-        if (mForwardingConsumer != forwardingConsumer) {
-          return;
+            while (iterator.hasNext()) {
+                Pair<Consumer<CloseableReference<T>>, ProducerContext> pair = iterator.next();
+                synchronized (pair) {
+                    pair.first.onNewResult(closeableReference, isFinal);
+                }
+            }
         }
 
-        mForwardingConsumer = null;
-        mMultiplexProducerContext = null;
-        CloseableReference.closeSafely(mLastIntermediateResult);
-        mLastIntermediateResult = null;
-      }
+        public void onCancelled(final ForwardingConsumer forwardingConsumer) {
+            synchronized (Multiplexer.this) {
+                // check for late callbacks
+                if (mForwardingConsumer != forwardingConsumer) {
+                    return;
+                }
 
-      startNextProducerIfHasAttachedConsumers();
-    }
+                mForwardingConsumer = null;
+                mMultiplexProducerContext = null;
+                CloseableReference.closeSafely(mLastIntermediateResult);
+                mLastIntermediateResult = null;
+            }
 
-    public void onProgressUpdate(ForwardingConsumer forwardingConsumer, float progress) {
-      Iterator<Pair<Consumer<CloseableReference<T>>, ProducerContext>> iterator;
-      synchronized (Multiplexer.this) {
-        // check for late callbacks
-        if (mForwardingConsumer != forwardingConsumer) {
-          return;
+            startNextProducerIfHasAttachedConsumers();
         }
 
-        mLastProgress = progress;
-        iterator = mConsumerContextPairs.iterator();
-      }
+        public void onProgressUpdate(ForwardingConsumer forwardingConsumer, float progress) {
+            Iterator<Pair<Consumer<CloseableReference<T>>, ProducerContext>> iterator;
+            synchronized (Multiplexer.this) {
+                // check for late callbacks
+                if (mForwardingConsumer != forwardingConsumer) {
+                    return;
+                }
 
-      while (iterator.hasNext()) {
-        Pair<Consumer<CloseableReference<T>>, ProducerContext> pair = iterator.next();
-        synchronized (pair) {
-          pair.first.onProgressUpdate(progress);
+                mLastProgress = progress;
+                iterator = mConsumerContextPairs.iterator();
+            }
+
+            while (iterator.hasNext()) {
+                Pair<Consumer<CloseableReference<T>>, ProducerContext> pair = iterator.next();
+                synchronized (pair) {
+                    pair.first.onProgressUpdate(progress);
+                }
+            }
         }
-      }
-    }
 
-    /**
-     * Forwards {@link Consumer} methods to Multiplexer.
-     */
-    private class ForwardingConsumer extends BaseConsumer<CloseableReference<T>> {
-      @Override
-      protected void onNewResultImpl(CloseableReference<T> newResult, boolean isLast) {
-        Multiplexer.this.onNextResult(this, newResult, isLast);
-      }
-
-      @Override
-      protected void onFailureImpl(Throwable t) {
-        Multiplexer.this.onFailure(this, t);
-      }
-
-      @Override
-      protected void onCancellationImpl() {
-        Multiplexer.this.onCancelled(this);
-      }
-
-      @Override
-      protected void onProgressUpdateImpl(float progress) {
-        Multiplexer.this.onProgressUpdate(this, progress);
-      }
+        /**
+         * Forwards {@link Consumer} methods to Multiplexer.
+         */
+        private class ForwardingConsumer extends BaseConsumer<CloseableReference<T>> {
+            @Override
+            protected void onNewResultImpl(CloseableReference<T> newResult, boolean isLast) {
+                Multiplexer.this.onNextResult(this, newResult, isLast);
+            }
+
+            @Override
+            protected void onFailureImpl(Throwable t) {
+                Multiplexer.this.onFailure(this, t);
+            }
+
+            @Override
+            protected void onCancellationImpl() {
+                Multiplexer.this.onCancelled(this);
+            }
+
+            @Override
+            protected void onProgressUpdateImpl(float progress) {
+                Multiplexer.this.onProgressUpdate(this, progress);
+            }
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java
index 17658fa17..4c208d6f6 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetchProducer.java
@@ -26,170 +26,172 @@
 
 /**
  * A producer to actually fetch images from the network.
- *
+ * <p>
  * <p> Downloaded bytes may be passed to the consumer as they are downloaded, but not more often
  * than {@link #TIME_BETWEEN_PARTIAL_RESULTS_MS}.
-
+ * <p>
  * <p>Clients should provide an instance of {@link NetworkFetcher} to make use of their networking
  * stack. Use {@link HttpUrlConnectionNetworkFetcher} as a model.
  */
 public class NetworkFetchProducer implements Producer<CloseableReference<PooledByteBuffer>> {
 
-  @VisibleForTesting static final String PRODUCER_NAME = "NetworkFetchProducer";
-  public static final String INTERMEDIATE_RESULT_PRODUCER_EVENT = "intermediate_result";
-  private static final int READ_SIZE = 16 * 1024;
-
-  /**
-   * Time between two consecutive partial results are propagated upstream
-   *
-   * TODO 5399646: make this configurable
-   */
-  @VisibleForTesting static final long TIME_BETWEEN_PARTIAL_RESULTS_MS = 100;
-
-  private final PooledByteBufferFactory mPooledByteBufferFactory;
-  private final ByteArrayPool mByteArrayPool;
-  private final NetworkFetcher mNetworkFetcher;
-
-  public NetworkFetchProducer(
-      PooledByteBufferFactory pooledByteBufferFactory,
-      ByteArrayPool byteArrayPool,
-      NetworkFetcher networkFetcher) {
-    mPooledByteBufferFactory = pooledByteBufferFactory;
-    mByteArrayPool = byteArrayPool;
-    mNetworkFetcher = networkFetcher;
-  }
-
-  @Override
-  public void produceResults(
-      Consumer<CloseableReference<PooledByteBuffer>> consumer,
-      ProducerContext context) {
-    context.getListener()
-        .onProducerStart(context.getId(), PRODUCER_NAME);
-    final FetchState fetchState = mNetworkFetcher.createFetchState(consumer, context);
-    mNetworkFetcher.fetch(
-        fetchState, new NetworkFetcher.Callback() {
-          @Override
-          public void onResponse(InputStream response, int responseLength) throws IOException {
-            NetworkFetchProducer.this.onResponse(fetchState, response, responseLength);
-          }
-
-          @Override
-          public void onFailure(Throwable throwable) {
-            NetworkFetchProducer.this.onFailure(fetchState, throwable);
-          }
-
-          @Override
-          public void onCancellation() {
-            NetworkFetchProducer.this.onCancellation(fetchState);
-          }
-        });
-  }
-
-  private void onResponse(
-      FetchState fetchState,
-      InputStream responseData,
-      int responseContentLength)
-      throws IOException {
-    final PooledByteBufferOutputStream pooledOutputStream;
-    if (responseContentLength > 0) {
-      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);
-    } else {
-      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "NetworkFetchProducer";
+    public static final String INTERMEDIATE_RESULT_PRODUCER_EVENT = "intermediate_result";
+    private static final int READ_SIZE = 16 * 1024;
+
+    /**
+     * Time between two consecutive partial results are propagated upstream
+     * <p>
+     * TODO 5399646: make this configurable
+     */
+    @VisibleForTesting
+    static final long TIME_BETWEEN_PARTIAL_RESULTS_MS = 100;
+
+    private final PooledByteBufferFactory mPooledByteBufferFactory;
+    private final ByteArrayPool mByteArrayPool;
+    private final NetworkFetcher mNetworkFetcher;
+
+    public NetworkFetchProducer(
+            PooledByteBufferFactory pooledByteBufferFactory,
+            ByteArrayPool byteArrayPool,
+            NetworkFetcher networkFetcher) {
+        mPooledByteBufferFactory = pooledByteBufferFactory;
+        mByteArrayPool = byteArrayPool;
+        mNetworkFetcher = networkFetcher;
+    }
+
+    @Override
+    public void produceResults(
+            Consumer<CloseableReference<PooledByteBuffer>> consumer,
+            ProducerContext context) {
+        context.getListener()
+                .onProducerStart(context.getId(), PRODUCER_NAME);
+        final FetchState fetchState = mNetworkFetcher.createFetchState(consumer, context);
+        mNetworkFetcher.fetch(
+                fetchState, new NetworkFetcher.Callback() {
+                    @Override
+                    public void onResponse(InputStream response, int responseLength) throws IOException {
+                        NetworkFetchProducer.this.onResponse(fetchState, response, responseLength);
+                    }
+
+                    @Override
+                    public void onFailure(Throwable throwable) {
+                        NetworkFetchProducer.this.onFailure(fetchState, throwable);
+                    }
+
+                    @Override
+                    public void onCancellation() {
+                        NetworkFetchProducer.this.onCancellation(fetchState);
+                    }
+                });
     }
-    final byte[] ioArray = mByteArrayPool.get(READ_SIZE);
-    try {
-      int length;
-      while ((length = responseData.read(ioArray)) >= 0) {
-        if (length > 0) {
-          pooledOutputStream.write(ioArray, 0, length);
-          maybeHandleIntermediateResult(pooledOutputStream, fetchState);
-          float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);
-          fetchState.getConsumer().onProgressUpdate(progress);
+
+    private void onResponse(
+            FetchState fetchState,
+            InputStream responseData,
+            int responseContentLength)
+            throws IOException {
+        final PooledByteBufferOutputStream pooledOutputStream;
+        if (responseContentLength > 0) {
+            pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);
+        } else {
+            pooledOutputStream = mPooledByteBufferFactory.newOutputStream();
+        }
+        final byte[] ioArray = mByteArrayPool.get(READ_SIZE);
+        try {
+            int length;
+            while ((length = responseData.read(ioArray)) >= 0) {
+                if (length > 0) {
+                    pooledOutputStream.write(ioArray, 0, length);
+                    maybeHandleIntermediateResult(pooledOutputStream, fetchState);
+                    float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);
+                    fetchState.getConsumer().onProgressUpdate(progress);
+                }
+            }
+            mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());
+            handleFinalResult(pooledOutputStream, fetchState);
+        } finally {
+            mByteArrayPool.release(ioArray);
+            pooledOutputStream.close();
         }
-      }
-      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());
-      handleFinalResult(pooledOutputStream, fetchState);
-    } finally {
-      mByteArrayPool.release(ioArray);
-      pooledOutputStream.close();
     }
-  }
-
-  private static float calculateProgress(int downloaded, int total) {
-    if (total > 0) {
-      return (float) downloaded / total;
-    } else {
-      // If we don't know the total number of bytes, we approximate the progress by an exponential
-      // that approaches 1. Here are some values of the progress, given the number of bytes:
-      // 0.5 kB ~  1%
-      // 2.5 kB ~  5%
-      //   5 kB ~ 10%
-      //  14 kB ~ 25%
-      //  34 kB ~ 50%
-      //  68 kB ~ 75%
-      // 113 kB ~ 90%
-      // 147 kB ~ 95%
-      // 225 kB ~ 99%
-      return 1 - (float) Math.exp(-downloaded / 5e4);
+
+    private static float calculateProgress(int downloaded, int total) {
+        if (total > 0) {
+            return (float) downloaded / total;
+        } else {
+            // If we don't know the total number of bytes, we approximate the progress by an exponential
+            // that approaches 1. Here are some values of the progress, given the number of bytes:
+            // 0.5 kB ~  1%
+            // 2.5 kB ~  5%
+            //   5 kB ~ 10%
+            //  14 kB ~ 25%
+            //  34 kB ~ 50%
+            //  68 kB ~ 75%
+            // 113 kB ~ 90%
+            // 147 kB ~ 95%
+            // 225 kB ~ 99%
+            return 1 - (float) Math.exp(-downloaded / 5e4);
+        }
     }
-  }
-
-  private void maybeHandleIntermediateResult(
-      PooledByteBufferOutputStream pooledOutputStream,
-      FetchState fetchState) {
-    final long nowMs = SystemClock.elapsedRealtime();
-    if (shouldPropagateIntermediateResults(fetchState) &&
-        nowMs - fetchState.getLastIntermediateResultTimeMs() >= TIME_BETWEEN_PARTIAL_RESULTS_MS) {
-      fetchState.setLastIntermediateResultTimeMs(nowMs);
-      fetchState.getListener()
-          .onProducerEvent(fetchState.getId(), PRODUCER_NAME, INTERMEDIATE_RESULT_PRODUCER_EVENT);
-      notifyConsumer(pooledOutputStream, false, fetchState.getConsumer());
+
+    private void maybeHandleIntermediateResult(
+            PooledByteBufferOutputStream pooledOutputStream,
+            FetchState fetchState) {
+        final long nowMs = SystemClock.elapsedRealtime();
+        if (shouldPropagateIntermediateResults(fetchState) &&
+                nowMs - fetchState.getLastIntermediateResultTimeMs() >= TIME_BETWEEN_PARTIAL_RESULTS_MS) {
+            fetchState.setLastIntermediateResultTimeMs(nowMs);
+            fetchState.getListener()
+                    .onProducerEvent(fetchState.getId(), PRODUCER_NAME, INTERMEDIATE_RESULT_PRODUCER_EVENT);
+            notifyConsumer(pooledOutputStream, false, fetchState.getConsumer());
+        }
     }
-  }
-
-  private void handleFinalResult(
-      PooledByteBufferOutputStream pooledOutputStream,
-      FetchState fetchState) {
-    Map<String, String> extraMap = getExtraMap(fetchState, pooledOutputStream.size());
-    fetchState.getListener()
-        .onProducerFinishWithSuccess(fetchState.getId(), PRODUCER_NAME, extraMap);
-    notifyConsumer(pooledOutputStream, true, fetchState.getConsumer());
-  }
-
-  private void notifyConsumer(
-      PooledByteBufferOutputStream pooledOutputStream,
-      boolean isFinal,
-      Consumer<CloseableReference<PooledByteBuffer>> consumer) {
-    CloseableReference<PooledByteBuffer> result =
-        CloseableReference.of(pooledOutputStream.toByteBuffer());
-    consumer.onNewResult(result, isFinal);
-    CloseableReference.closeSafely(result);
-  }
-
-  private void onFailure(FetchState fetchState, Throwable e) {
-    fetchState.getListener()
-        .onProducerFinishWithFailure(fetchState.getId(), PRODUCER_NAME, e, null);
-    fetchState.getConsumer().onFailure(e);
-  }
-
-  private void onCancellation(FetchState fetchState) {
-    fetchState.getListener()
-        .onProducerFinishWithCancellation(fetchState.getId(), PRODUCER_NAME, null);
-    fetchState.getConsumer().onCancellation();
-  }
-
-  private boolean shouldPropagateIntermediateResults(FetchState fetchState) {
-    if (!fetchState.getContext().getImageRequest().getProgressiveRenderingEnabled()) {
-      return false;
+
+    private void handleFinalResult(
+            PooledByteBufferOutputStream pooledOutputStream,
+            FetchState fetchState) {
+        Map<String, String> extraMap = getExtraMap(fetchState, pooledOutputStream.size());
+        fetchState.getListener()
+                .onProducerFinishWithSuccess(fetchState.getId(), PRODUCER_NAME, extraMap);
+        notifyConsumer(pooledOutputStream, true, fetchState.getConsumer());
     }
-    return mNetworkFetcher.shouldPropagate(fetchState);
-  }
 
-  @Nullable
-  private Map<String, String> getExtraMap(FetchState fetchState, int byteSize) {
-    if (!fetchState.getListener().requiresExtraMap(fetchState.getId())) {
-      return null;
+    private void notifyConsumer(
+            PooledByteBufferOutputStream pooledOutputStream,
+            boolean isFinal,
+            Consumer<CloseableReference<PooledByteBuffer>> consumer) {
+        CloseableReference<PooledByteBuffer> result =
+                CloseableReference.of(pooledOutputStream.toByteBuffer());
+        consumer.onNewResult(result, isFinal);
+        CloseableReference.closeSafely(result);
+    }
+
+    private void onFailure(FetchState fetchState, Throwable e) {
+        fetchState.getListener()
+                .onProducerFinishWithFailure(fetchState.getId(), PRODUCER_NAME, e, null);
+        fetchState.getConsumer().onFailure(e);
+    }
+
+    private void onCancellation(FetchState fetchState) {
+        fetchState.getListener()
+                .onProducerFinishWithCancellation(fetchState.getId(), PRODUCER_NAME, null);
+        fetchState.getConsumer().onCancellation();
+    }
+
+    private boolean shouldPropagateIntermediateResults(FetchState fetchState) {
+        if (!fetchState.getContext().getImageRequest().getProgressiveRenderingEnabled()) {
+            return false;
+        }
+        return mNetworkFetcher.shouldPropagate(fetchState);
+    }
+
+    @Nullable
+    private Map<String, String> getExtraMap(FetchState fetchState, int byteSize) {
+        if (!fetchState.getListener().requiresExtraMap(fetchState.getId())) {
+            return null;
+        }
+        return mNetworkFetcher.getExtraMap(fetchState, byteSize);
     }
-    return mNetworkFetcher.getExtraMap(fetchState, byteSize);
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetcher.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetcher.java
index 6d76205a7..3c4dbf074 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetcher.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NetworkFetcher.java
@@ -20,10 +20,10 @@
 
 /**
  * Interface that specifies network fetcher used by the image pipeline.
- *
+ * <p>
  * <p>It is strongly recommended that implementations use an {@link Executor} in their
  * {@link #fetch} method to execute the network request on a different thread.
- *
+ * <p>
  * <p> When the fetch from the network fails or is cancelled, the subclass is responsible for
  * calling {@link Callback} methods. If these are not called, the pipeline will not know that the
  * image fetch has failed and the application may not behave properly.
@@ -32,86 +32,86 @@
  */
 public interface NetworkFetcher<FETCH_STATE extends FetchState> {
 
-  /**
-   * Callback used to inform the network fetch producer.
-   */
-  public interface Callback {
+    /**
+     * Callback used to inform the network fetch producer.
+     */
+    public interface Callback {
+
+        /**
+         * Called upon a response from the network stack.
+         *
+         * @param response       the InputStream for the data
+         * @param responseLength the length of the data if known, -1 otherwise
+         */
+        public void onResponse(InputStream response, int responseLength) throws IOException;
+
+        /**
+         * Called upon a failure in the network stack.
+         *
+         * @param throwable the cause of failure
+         */
+        public void onFailure(Throwable throwable);
+
+        /**
+         * Called upon a cancellation of the request.
+         */
+        public void onCancellation();
+    }
 
     /**
-     * Called upon a response from the network stack.
+     * Creates a new instance of the {@link FetchState}-derived object used to store state.
      *
-     * @param response the InputStream for the data
-     * @param responseLength the length of the data if known, -1 otherwise
+     * @param consumer        the consumer
+     * @param producerContext the producer's context
+     * @return a new fetch state instance
      */
-    public void onResponse(InputStream response, int responseLength) throws IOException;
+    public FETCH_STATE createFetchState(
+            Consumer<CloseableReference<PooledByteBuffer>> consumer,
+            ProducerContext producerContext);
 
     /**
-     * Called upon a failure in the network stack.
+     * Initiates the network fetch and informs the producer when a response is received via the
+     * provided callback.
      *
-     * @param throwable the cause of failure
+     * @param fetchState the fetch-specific state
+     * @param callback   the callback used to inform the network fetch producer
      */
-    public void onFailure(Throwable throwable);
+    public void fetch(FETCH_STATE fetchState, Callback callback);
 
     /**
-     * Called upon a cancellation of the request.
+     * Gets whether the intermediate results should be propagated.
+     * <p>
+     * <p>In <i>addition</i> to the requirements of this method, intermediate results are throttled so
+     * that a maximum of one every 100 ms is propagated. This is to conserve CPU and other resources.
+     * <p>
+     * <p>Not applicable if progressive rendering is disabled or not supported for this image.
+     *
+     * @param fetchState the fetch-specific state
+     * @return whether the intermediate results should be propagated
      */
-    public void onCancellation();
-  }
-
-  /**
-   * Creates a new instance of the {@link FetchState}-derived object used to store state.
-   *
-   * @param consumer the consumer
-   * @param producerContext the producer's context
-   * @return a new fetch state instance
-   */
-  public FETCH_STATE createFetchState(
-      Consumer<CloseableReference<PooledByteBuffer>> consumer,
-      ProducerContext producerContext);
+    public boolean shouldPropagate(FETCH_STATE fetchState);
 
-  /**
-   * Initiates the network fetch and informs the producer when a response is received via the
-   * provided callback.
-   *
-   * @param fetchState the fetch-specific state
-   * @param callback the callback used to inform the network fetch producer
-   */
-  public void fetch(FETCH_STATE fetchState, Callback callback);
-
-  /**
-   * Gets whether the intermediate results should be propagated.
-   *
-   * <p>In <i>addition</i> to the requirements of this method, intermediate results are throttled so
-   * that a maximum of one every 100 ms is propagated. This is to conserve CPU and other resources.
-   *
-   * <p>Not applicable if progressive rendering is disabled or not supported for this image.
-   *
-   * @param fetchState the fetch-specific state
-   * @return whether the intermediate results should be propagated
-   */
-  public boolean shouldPropagate(FETCH_STATE fetchState);
-
-  /**
-   * Called after the fetch completes.
-   *
-   * <p> Implementing this method is optional and is useful for instrumentation purposes.
-   *
-   * @param fetchState the fetch-specific state
-   * @param byteSize size of the data in bytes
-   */
-  public void onFetchCompletion(FETCH_STATE fetchState, int byteSize);
+    /**
+     * Called after the fetch completes.
+     * <p>
+     * <p> Implementing this method is optional and is useful for instrumentation purposes.
+     *
+     * @param fetchState the fetch-specific state
+     * @param byteSize   size of the data in bytes
+     */
+    public void onFetchCompletion(FETCH_STATE fetchState, int byteSize);
 
-  /**
-   * Gets a map containing extra parameters to pass to the listeners.
-   *
-   * <p> Returning map is optional and is useful for instrumentation purposes.
-   *
-   * <p> This map won't be modified by the caller.
-   *
-   * @param fetchState the fetch-specific state
-   * @param byteSize size of the data in bytes
-   * @return a map with extra parameters
-   */
-  @Nullable
-  public Map<String, String> getExtraMap(FETCH_STATE fetchState, int byteSize);
+    /**
+     * Gets a map containing extra parameters to pass to the listeners.
+     * <p>
+     * <p> Returning map is optional and is useful for instrumentation purposes.
+     * <p>
+     * <p> This map won't be modified by the caller.
+     *
+     * @param fetchState the fetch-specific state
+     * @param byteSize   size of the data in bytes
+     * @return a map with extra parameters
+     */
+    @Nullable
+    public Map<String, String> getExtraMap(FETCH_STATE fetchState, int byteSize);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NullProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NullProducer.java
index 2f24bccdc..34bf8a2aa 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NullProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/NullProducer.java
@@ -11,19 +11,20 @@
 
 /**
  * Producer that never produces anything, but just returns null.
- *
+ * <p>
  * <p>This producer can be used to terminate a sequence, e.g. for a bitmap cache get only sequence,
  * just use BitmapMemoryCacheGetProducer followed by NullProducer.
  */
 public class NullProducer<T> implements Producer<T> {
 
-  /**
-   * Start producing results for given context. Provided consumer is notified whenever progress is
-   * made (new value is ready or error occurs).
-   * @param consumer
-   * @param context
-   */
-  public void produceResults(Consumer<T> consumer, ProducerContext context) {
-    consumer.onNewResult((T) null, true);
-  }
+    /**
+     * Start producing results for given context. Provided consumer is notified whenever progress is
+     * made (new value is ready or error occurs).
+     *
+     * @param consumer
+     * @param context
+     */
+    public void produceResults(Consumer<T> consumer, ProducerContext context) {
+        consumer.onNewResult((T) null, true);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/PostprocessorProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/PostprocessorProducer.java
index b5feef2f2..d8918285e 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/PostprocessorProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/PostprocessorProducer.java
@@ -30,397 +30,399 @@
 
 /**
  * Runs a caller-supplied post-processor object.
- *
+ * <p>
  * <p>Post-processors are only supported for static bitmaps. If the request is for an animated
  * image, the post-processor step will be skipped without warning.
  */
 public class PostprocessorProducer implements Producer<CloseableReference<CloseableImage>> {
 
-  @VisibleForTesting static final String NAME = "PostprocessorProducer";
-  @VisibleForTesting static final String POSTPROCESSOR = "Postprocessor";
-
-  private final Producer<CloseableReference<CloseableImage>> mNextProducer;
-  private final PlatformBitmapFactory mBitmapFactory;
-  private final Executor mExecutor;
-
-  public PostprocessorProducer(
-      Producer<CloseableReference<CloseableImage>> nextProducer,
-      PlatformBitmapFactory platformBitmapFactory,
-      Executor executor) {
-    mNextProducer = Preconditions.checkNotNull(nextProducer);
-    mBitmapFactory = platformBitmapFactory;
-    mExecutor = Preconditions.checkNotNull(executor);
-  }
-
-  @Override
-  public void produceResults(
-      final Consumer<CloseableReference<CloseableImage>> consumer,
-      ProducerContext context) {
-    final ProducerListener listener = context.getListener();
-    final Postprocessor postprocessor = context.getImageRequest().getPostprocessor();
-    final PostprocessorConsumer basePostprocessorConsumer =
-        new PostprocessorConsumer(consumer, listener, context.getId(), postprocessor, context);
-    final Consumer<CloseableReference<CloseableImage>> postprocessorConsumer;
-    if (postprocessor instanceof RepeatedPostprocessor) {
-      postprocessorConsumer = new RepeatedPostprocessorConsumer(
-          basePostprocessorConsumer,
-          (RepeatedPostprocessor) postprocessor,
-          context);
-    } else {
-      postprocessorConsumer = new SingleUsePostprocessorConsumer(basePostprocessorConsumer);
-    }
-    mNextProducer.produceResults(postprocessorConsumer, context);
-  }
-
-  /**
-   * Performs postprocessing and takes care of scheduling.
-   */
-  private class PostprocessorConsumer extends DelegatingConsumer<
-      CloseableReference<CloseableImage>,
-      CloseableReference<CloseableImage>> {
-
-    private final ProducerListener mListener;
-    private final String mRequestId;
-    private final Postprocessor mPostprocessor;
-
-    @GuardedBy("PostprocessorConsumer.this")
-    private boolean mIsClosed;
-    @GuardedBy("PostprocessorConsumer.this")
-    @Nullable
-    private CloseableReference<CloseableImage> mSourceImageRef = null;
-    @GuardedBy("PostprocessorConsumer.this")
-    private boolean mIsLast = false;
-    @GuardedBy("PostprocessorConsumer.this")
-    private boolean mIsDirty = false;
-    @GuardedBy("PostprocessorConsumer.this")
-    private boolean mIsPostProcessingRunning = false;
-
-    public PostprocessorConsumer(
-        Consumer<CloseableReference<CloseableImage>> consumer,
-        ProducerListener listener,
-        String requestId,
-        Postprocessor postprocessor,
-        ProducerContext producerContext) {
-      super(consumer);
-      mListener = listener;
-      mRequestId = requestId;
-      mPostprocessor = postprocessor;
-      producerContext.addCallbacks(
-          new BaseProducerContextCallbacks() {
-            @Override
-            public void onCancellationRequested() {
-              maybeNotifyOnCancellation();
-            }
-          });
+    @VisibleForTesting
+    static final String NAME = "PostprocessorProducer";
+    @VisibleForTesting
+    static final String POSTPROCESSOR = "Postprocessor";
+
+    private final Producer<CloseableReference<CloseableImage>> mNextProducer;
+    private final PlatformBitmapFactory mBitmapFactory;
+    private final Executor mExecutor;
+
+    public PostprocessorProducer(
+            Producer<CloseableReference<CloseableImage>> nextProducer,
+            PlatformBitmapFactory platformBitmapFactory,
+            Executor executor) {
+        mNextProducer = Preconditions.checkNotNull(nextProducer);
+        mBitmapFactory = platformBitmapFactory;
+        mExecutor = Preconditions.checkNotNull(executor);
     }
 
     @Override
-    protected void onNewResultImpl(CloseableReference<CloseableImage> newResult, boolean isLast) {
-      if (!CloseableReference.isValid(newResult)) {
-        // try to propagate if the last result is invalid
-        if (isLast) {
-          maybeNotifyOnNewResult(null, true);
+    public void produceResults(
+            final Consumer<CloseableReference<CloseableImage>> consumer,
+            ProducerContext context) {
+        final ProducerListener listener = context.getListener();
+        final Postprocessor postprocessor = context.getImageRequest().getPostprocessor();
+        final PostprocessorConsumer basePostprocessorConsumer =
+                new PostprocessorConsumer(consumer, listener, context.getId(), postprocessor, context);
+        final Consumer<CloseableReference<CloseableImage>> postprocessorConsumer;
+        if (postprocessor instanceof RepeatedPostprocessor) {
+            postprocessorConsumer = new RepeatedPostprocessorConsumer(
+                    basePostprocessorConsumer,
+                    (RepeatedPostprocessor) postprocessor,
+                    context);
+        } else {
+            postprocessorConsumer = new SingleUsePostprocessorConsumer(basePostprocessorConsumer);
         }
-        // ignore if invalid
-        return;
-      }
-      updateSourceImageRef(newResult, isLast);
+        mNextProducer.produceResults(postprocessorConsumer, context);
     }
 
-    @Override
-    protected void onFailureImpl(Throwable t) {
-      maybeNotifyOnFailure(t);
-    }
+    /**
+     * Performs postprocessing and takes care of scheduling.
+     */
+    private class PostprocessorConsumer extends DelegatingConsumer<
+            CloseableReference<CloseableImage>,
+            CloseableReference<CloseableImage>> {
+
+        private final ProducerListener mListener;
+        private final String mRequestId;
+        private final Postprocessor mPostprocessor;
+
+        @GuardedBy("PostprocessorConsumer.this")
+        private boolean mIsClosed;
+        @GuardedBy("PostprocessorConsumer.this")
+        @Nullable
+        private CloseableReference<CloseableImage> mSourceImageRef = null;
+        @GuardedBy("PostprocessorConsumer.this")
+        private boolean mIsLast = false;
+        @GuardedBy("PostprocessorConsumer.this")
+        private boolean mIsDirty = false;
+        @GuardedBy("PostprocessorConsumer.this")
+        private boolean mIsPostProcessingRunning = false;
+
+        public PostprocessorConsumer(
+                Consumer<CloseableReference<CloseableImage>> consumer,
+                ProducerListener listener,
+                String requestId,
+                Postprocessor postprocessor,
+                ProducerContext producerContext) {
+            super(consumer);
+            mListener = listener;
+            mRequestId = requestId;
+            mPostprocessor = postprocessor;
+            producerContext.addCallbacks(
+                    new BaseProducerContextCallbacks() {
+                        @Override
+                        public void onCancellationRequested() {
+                            maybeNotifyOnCancellation();
+                        }
+                    });
+        }
 
-    @Override
-    protected void onCancellationImpl() {
-      maybeNotifyOnCancellation();
-    }
+        @Override
+        protected void onNewResultImpl(CloseableReference<CloseableImage> newResult, boolean isLast) {
+            if (!CloseableReference.isValid(newResult)) {
+                // try to propagate if the last result is invalid
+                if (isLast) {
+                    maybeNotifyOnNewResult(null, true);
+                }
+                // ignore if invalid
+                return;
+            }
+            updateSourceImageRef(newResult, isLast);
+        }
 
-    private void updateSourceImageRef(
-        @Nullable CloseableReference<CloseableImage> sourceImageRef,
-        boolean isLast) {
-      CloseableReference<CloseableImage> oldSourceImageRef;
-      boolean shouldSubmit;
-      synchronized (PostprocessorConsumer.this) {
-        if (mIsClosed) {
-          return;
+        @Override
+        protected void onFailureImpl(Throwable t) {
+            maybeNotifyOnFailure(t);
         }
-        oldSourceImageRef = mSourceImageRef;
-        mSourceImageRef = CloseableReference.cloneOrNull(sourceImageRef);
-        mIsLast = isLast;
-        mIsDirty = true;
-        shouldSubmit = setRunningIfDirtyAndNotRunning();
-      }
-      CloseableReference.closeSafely(oldSourceImageRef);
-      if (shouldSubmit) {
-        submitPostprocessing();
-      }
-    }
 
-    private void submitPostprocessing() {
-      mExecutor.execute(
-          new Runnable() {
-            @Override
-            public void run() {
-              CloseableReference<CloseableImage> closeableImageRef;
-              boolean isLast;
-              synchronized (PostprocessorConsumer.this) {
-                // instead of cloning and closing the reference, we do a more efficient move.
-                closeableImageRef = mSourceImageRef;
-                isLast = mIsLast;
-                mSourceImageRef = null;
-                mIsDirty = false;
-              }
+        @Override
+        protected void onCancellationImpl() {
+            maybeNotifyOnCancellation();
+        }
 
-              if (CloseableReference.isValid(closeableImageRef)) {
-                try {
-                  doPostprocessing(closeableImageRef, isLast);
-                } finally {
-                  CloseableReference.closeSafely(closeableImageRef);
+        private void updateSourceImageRef(
+                @Nullable CloseableReference<CloseableImage> sourceImageRef,
+                boolean isLast) {
+            CloseableReference<CloseableImage> oldSourceImageRef;
+            boolean shouldSubmit;
+            synchronized (PostprocessorConsumer.this) {
+                if (mIsClosed) {
+                    return;
                 }
-              }
-              clearRunningAndStartIfDirty();
+                oldSourceImageRef = mSourceImageRef;
+                mSourceImageRef = CloseableReference.cloneOrNull(sourceImageRef);
+                mIsLast = isLast;
+                mIsDirty = true;
+                shouldSubmit = setRunningIfDirtyAndNotRunning();
             }
-          });
-    }
+            CloseableReference.closeSafely(oldSourceImageRef);
+            if (shouldSubmit) {
+                submitPostprocessing();
+            }
+        }
 
-    private void clearRunningAndStartIfDirty() {
-      boolean shouldExecuteAgain;
-      synchronized (PostprocessorConsumer.this) {
-        mIsPostProcessingRunning = false;
-        shouldExecuteAgain = setRunningIfDirtyAndNotRunning();
-      }
-      if (shouldExecuteAgain) {
-        submitPostprocessing();
-      }
-    }
+        private void submitPostprocessing() {
+            mExecutor.execute(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            CloseableReference<CloseableImage> closeableImageRef;
+                            boolean isLast;
+                            synchronized (PostprocessorConsumer.this) {
+                                // instead of cloning and closing the reference, we do a more efficient move.
+                                closeableImageRef = mSourceImageRef;
+                                isLast = mIsLast;
+                                mSourceImageRef = null;
+                                mIsDirty = false;
+                            }
+
+                            if (CloseableReference.isValid(closeableImageRef)) {
+                                try {
+                                    doPostprocessing(closeableImageRef, isLast);
+                                } finally {
+                                    CloseableReference.closeSafely(closeableImageRef);
+                                }
+                            }
+                            clearRunningAndStartIfDirty();
+                        }
+                    });
+        }
 
-    private synchronized boolean setRunningIfDirtyAndNotRunning() {
-      if (!mIsClosed && mIsDirty && !mIsPostProcessingRunning &&
-          CloseableReference.isValid(mSourceImageRef)) {
-        mIsPostProcessingRunning = true;
-        return true;
-      }
-      return false;
-    }
+        private void clearRunningAndStartIfDirty() {
+            boolean shouldExecuteAgain;
+            synchronized (PostprocessorConsumer.this) {
+                mIsPostProcessingRunning = false;
+                shouldExecuteAgain = setRunningIfDirtyAndNotRunning();
+            }
+            if (shouldExecuteAgain) {
+                submitPostprocessing();
+            }
+        }
 
-    private void doPostprocessing(
-        CloseableReference<CloseableImage> sourceImageRef,
-        boolean isLast) {
-      Preconditions.checkArgument(CloseableReference.isValid(sourceImageRef));
-      if (!shouldPostprocess(sourceImageRef.get())) {
-        maybeNotifyOnNewResult(sourceImageRef, isLast);
-        return;
-      }
-      mListener.onProducerStart(mRequestId, NAME);
-      CloseableReference<CloseableImage> destImageRef = null;
-      try {
-        try {
-          destImageRef = postprocessInternal(sourceImageRef.get());
-        } catch (Exception e) {
-          mListener.onProducerFinishWithFailure(
-              mRequestId, NAME, e, getExtraMap(mListener, mRequestId, mPostprocessor));
-          maybeNotifyOnFailure(e);
-          return;
+        private synchronized boolean setRunningIfDirtyAndNotRunning() {
+            if (!mIsClosed && mIsDirty && !mIsPostProcessingRunning &&
+                    CloseableReference.isValid(mSourceImageRef)) {
+                mIsPostProcessingRunning = true;
+                return true;
+            }
+            return false;
         }
-        mListener.onProducerFinishWithSuccess(
-            mRequestId, NAME, getExtraMap(mListener, mRequestId, mPostprocessor));
-        maybeNotifyOnNewResult(destImageRef, isLast);
-      } finally {
-        CloseableReference.closeSafely(destImageRef);
-      }
-    }
 
-    private Map<String, String> getExtraMap(
-        ProducerListener listener,
-        String requestId,
-        Postprocessor postprocessor) {
-      if (!listener.requiresExtraMap(requestId)) {
-        return null;
-      }
-      return ImmutableMap.of(POSTPROCESSOR, postprocessor.getName());
-    }
+        private void doPostprocessing(
+                CloseableReference<CloseableImage> sourceImageRef,
+                boolean isLast) {
+            Preconditions.checkArgument(CloseableReference.isValid(sourceImageRef));
+            if (!shouldPostprocess(sourceImageRef.get())) {
+                maybeNotifyOnNewResult(sourceImageRef, isLast);
+                return;
+            }
+            mListener.onProducerStart(mRequestId, NAME);
+            CloseableReference<CloseableImage> destImageRef = null;
+            try {
+                try {
+                    destImageRef = postprocessInternal(sourceImageRef.get());
+                } catch (Exception e) {
+                    mListener.onProducerFinishWithFailure(
+                            mRequestId, NAME, e, getExtraMap(mListener, mRequestId, mPostprocessor));
+                    maybeNotifyOnFailure(e);
+                    return;
+                }
+                mListener.onProducerFinishWithSuccess(
+                        mRequestId, NAME, getExtraMap(mListener, mRequestId, mPostprocessor));
+                maybeNotifyOnNewResult(destImageRef, isLast);
+            } finally {
+                CloseableReference.closeSafely(destImageRef);
+            }
+        }
 
-    private boolean shouldPostprocess(CloseableImage sourceImage) {
-      return (sourceImage instanceof CloseableStaticBitmap);
-    }
+        private Map<String, String> getExtraMap(
+                ProducerListener listener,
+                String requestId,
+                Postprocessor postprocessor) {
+            if (!listener.requiresExtraMap(requestId)) {
+                return null;
+            }
+            return ImmutableMap.of(POSTPROCESSOR, postprocessor.getName());
+        }
 
-    private CloseableReference<CloseableImage> postprocessInternal(CloseableImage sourceImage) {
-      Bitmap sourceBitmap = ((CloseableStaticBitmap) sourceImage).getUnderlyingBitmap();
-      CloseableReference<Bitmap> bitmapRef = mPostprocessor.process(sourceBitmap, mBitmapFactory);
-      try {
-        return CloseableReference.<CloseableImage>of(
-            new CloseableStaticBitmap(bitmapRef, sourceImage.getQualityInfo()));
-      } finally {
-        CloseableReference.closeSafely(bitmapRef);
-      }
-    }
+        private boolean shouldPostprocess(CloseableImage sourceImage) {
+            return (sourceImage instanceof CloseableStaticBitmap);
+        }
 
-    private void maybeNotifyOnNewResult(CloseableReference<CloseableImage> newRef, boolean isLast) {
-      if ((!isLast && !isClosed()) || (isLast && close())) {
-        getConsumer().onNewResult(newRef, isLast);
-      }
-    }
+        private CloseableReference<CloseableImage> postprocessInternal(CloseableImage sourceImage) {
+            Bitmap sourceBitmap = ((CloseableStaticBitmap) sourceImage).getUnderlyingBitmap();
+            CloseableReference<Bitmap> bitmapRef = mPostprocessor.process(sourceBitmap, mBitmapFactory);
+            try {
+                return CloseableReference.<CloseableImage>of(
+                        new CloseableStaticBitmap(bitmapRef, sourceImage.getQualityInfo()));
+            } finally {
+                CloseableReference.closeSafely(bitmapRef);
+            }
+        }
 
-    private void maybeNotifyOnFailure(Throwable throwable) {
-      if (close()) {
-        getConsumer().onFailure(throwable);
-      }
-    }
+        private void maybeNotifyOnNewResult(CloseableReference<CloseableImage> newRef, boolean isLast) {
+            if ((!isLast && !isClosed()) || (isLast && close())) {
+                getConsumer().onNewResult(newRef, isLast);
+            }
+        }
 
-    private void maybeNotifyOnCancellation() {
-      if (close()) {
-        getConsumer().onCancellation();
-      }
-    }
+        private void maybeNotifyOnFailure(Throwable throwable) {
+            if (close()) {
+                getConsumer().onFailure(throwable);
+            }
+        }
 
-    private synchronized boolean isClosed() {
-      return mIsClosed;
-    }
+        private void maybeNotifyOnCancellation() {
+            if (close()) {
+                getConsumer().onCancellation();
+            }
+        }
 
-    private boolean close() {
-      CloseableReference<CloseableImage> oldSourceImageRef;
-      synchronized (PostprocessorConsumer.this) {
-        if (mIsClosed) {
-          return false;
+        private synchronized boolean isClosed() {
+            return mIsClosed;
+        }
+
+        private boolean close() {
+            CloseableReference<CloseableImage> oldSourceImageRef;
+            synchronized (PostprocessorConsumer.this) {
+                if (mIsClosed) {
+                    return false;
+                }
+                oldSourceImageRef = mSourceImageRef;
+                mSourceImageRef = null;
+                mIsClosed = true;
+            }
+            CloseableReference.closeSafely(oldSourceImageRef);
+            return true;
         }
-        oldSourceImageRef = mSourceImageRef;
-        mSourceImageRef = null;
-        mIsClosed = true;
-      }
-      CloseableReference.closeSafely(oldSourceImageRef);
-      return true;
     }
-  }
 
-  /**
-   * PostprocessorConsumer wrapper that ignores intermediate results.
-   */
-  class SingleUsePostprocessorConsumer extends DelegatingConsumer<
-      CloseableReference<CloseableImage>,
-      CloseableReference<CloseableImage>> {
+    /**
+     * PostprocessorConsumer wrapper that ignores intermediate results.
+     */
+    class SingleUsePostprocessorConsumer extends DelegatingConsumer<
+            CloseableReference<CloseableImage>,
+            CloseableReference<CloseableImage>> {
 
-    private SingleUsePostprocessorConsumer(PostprocessorConsumer postprocessorConsumer) {
-      super(postprocessorConsumer);
-    }
+        private SingleUsePostprocessorConsumer(PostprocessorConsumer postprocessorConsumer) {
+            super(postprocessorConsumer);
+        }
 
-    @Override
-    protected void onNewResultImpl(
-        final CloseableReference<CloseableImage> newResult,
-        final boolean isLast) {
-      // ignore intermediate results
-      if (!isLast) {
-        return;
-      }
-      getConsumer().onNewResult(newResult, isLast);
-    }
-  }
-
-  /**
-   * PostprocessorConsumer wrapper that allows repeated postprocessing.
-   *
-   * <p> Reference to the last result received is cloned and kept until the request is cancelled.
-   * In order to allow multiple postprocessing, results are always propagated as non-final. When
-   * {@link #update()} is called, a new postprocessing of the last received result is requested.
-   *
-   * <p> Intermediate results are ignored.
-   */
-  class RepeatedPostprocessorConsumer extends DelegatingConsumer<
-      CloseableReference<CloseableImage>,
-      CloseableReference<CloseableImage>> implements RepeatedPostprocessorRunner {
-
-    @GuardedBy("RepeatedPostprocessorConsumer.this")
-    private boolean mIsClosed = false;
-    @GuardedBy("RepeatedPostprocessorConsumer.this")
-    @Nullable
-    private CloseableReference<CloseableImage> mSourceImageRef = null;
-
-    private RepeatedPostprocessorConsumer(
-        PostprocessorConsumer postprocessorConsumer,
-        RepeatedPostprocessor repeatedPostprocessor,
-        ProducerContext context) {
-      super(postprocessorConsumer);
-      repeatedPostprocessor.setCallback(RepeatedPostprocessorConsumer.this);
-      context.addCallbacks(
-          new BaseProducerContextCallbacks() {
-            @Override
-            public void onCancellationRequested() {
-              if (close()) {
-                getConsumer().onCancellation();
-              }
+        @Override
+        protected void onNewResultImpl(
+                final CloseableReference<CloseableImage> newResult,
+                final boolean isLast) {
+            // ignore intermediate results
+            if (!isLast) {
+                return;
             }
-          });
+            getConsumer().onNewResult(newResult, isLast);
+        }
     }
 
-    @Override
-    protected void onNewResultImpl(CloseableReference<CloseableImage> newResult, boolean isLast) {
-      // ignore intermediate results
-      if (!isLast) {
-        return;
-      }
-      setSourceImageRef(newResult);
-      updateInternal();
-    }
+    /**
+     * PostprocessorConsumer wrapper that allows repeated postprocessing.
+     * <p>
+     * <p> Reference to the last result received is cloned and kept until the request is cancelled.
+     * In order to allow multiple postprocessing, results are always propagated as non-final. When
+     * {@link #update()} is called, a new postprocessing of the last received result is requested.
+     * <p>
+     * <p> Intermediate results are ignored.
+     */
+    class RepeatedPostprocessorConsumer extends DelegatingConsumer<
+            CloseableReference<CloseableImage>,
+            CloseableReference<CloseableImage>> implements RepeatedPostprocessorRunner {
+
+        @GuardedBy("RepeatedPostprocessorConsumer.this")
+        private boolean mIsClosed = false;
+        @GuardedBy("RepeatedPostprocessorConsumer.this")
+        @Nullable
+        private CloseableReference<CloseableImage> mSourceImageRef = null;
+
+        private RepeatedPostprocessorConsumer(
+                PostprocessorConsumer postprocessorConsumer,
+                RepeatedPostprocessor repeatedPostprocessor,
+                ProducerContext context) {
+            super(postprocessorConsumer);
+            repeatedPostprocessor.setCallback(RepeatedPostprocessorConsumer.this);
+            context.addCallbacks(
+                    new BaseProducerContextCallbacks() {
+                        @Override
+                        public void onCancellationRequested() {
+                            if (close()) {
+                                getConsumer().onCancellation();
+                            }
+                        }
+                    });
+        }
 
-    @Override
-    protected void onFailureImpl(Throwable throwable) {
-      if (close()) {
-        getConsumer().onFailure(throwable);
-      }
-    }
+        @Override
+        protected void onNewResultImpl(CloseableReference<CloseableImage> newResult, boolean isLast) {
+            // ignore intermediate results
+            if (!isLast) {
+                return;
+            }
+            setSourceImageRef(newResult);
+            updateInternal();
+        }
 
-    @Override
-    protected void onCancellationImpl() {
-      if (close()) {
-        getConsumer().onCancellation();
-      }
-    }
+        @Override
+        protected void onFailureImpl(Throwable throwable) {
+            if (close()) {
+                getConsumer().onFailure(throwable);
+            }
+        }
 
-    @Override
-    public synchronized void update() {
-      updateInternal();
-    }
+        @Override
+        protected void onCancellationImpl() {
+            if (close()) {
+                getConsumer().onCancellation();
+            }
+        }
 
-    private void updateInternal() {
-      CloseableReference<CloseableImage> sourceImageRef;
-      synchronized (RepeatedPostprocessorConsumer.this) {
-        if (mIsClosed) {
-          return;
+        @Override
+        public synchronized void update() {
+            updateInternal();
         }
-        sourceImageRef = CloseableReference.cloneOrNull(mSourceImageRef);
-      }
-      try {
-        getConsumer().onNewResult(sourceImageRef, false /* isLast */);
-      } finally {
-        CloseableReference.closeSafely(sourceImageRef);
-      }
-    }
 
-    private void setSourceImageRef(CloseableReference<CloseableImage> sourceImageRef) {
-      CloseableReference<CloseableImage> oldSourceImageRef;
-      synchronized (RepeatedPostprocessorConsumer.this) {
-        if (mIsClosed) {
-          return;
+        private void updateInternal() {
+            CloseableReference<CloseableImage> sourceImageRef;
+            synchronized (RepeatedPostprocessorConsumer.this) {
+                if (mIsClosed) {
+                    return;
+                }
+                sourceImageRef = CloseableReference.cloneOrNull(mSourceImageRef);
+            }
+            try {
+                getConsumer().onNewResult(sourceImageRef, false /* isLast */);
+            } finally {
+                CloseableReference.closeSafely(sourceImageRef);
+            }
         }
-        oldSourceImageRef = mSourceImageRef;
-        mSourceImageRef = CloseableReference.cloneOrNull(sourceImageRef);
-      }
-      CloseableReference.closeSafely(oldSourceImageRef);
-    }
 
-    private boolean close() {
-      CloseableReference<CloseableImage> oldSourceImageRef;
-      synchronized (RepeatedPostprocessorConsumer.this) {
-        if (mIsClosed) {
-          return false;
+        private void setSourceImageRef(CloseableReference<CloseableImage> sourceImageRef) {
+            CloseableReference<CloseableImage> oldSourceImageRef;
+            synchronized (RepeatedPostprocessorConsumer.this) {
+                if (mIsClosed) {
+                    return;
+                }
+                oldSourceImageRef = mSourceImageRef;
+                mSourceImageRef = CloseableReference.cloneOrNull(sourceImageRef);
+            }
+            CloseableReference.closeSafely(oldSourceImageRef);
+        }
+
+        private boolean close() {
+            CloseableReference<CloseableImage> oldSourceImageRef;
+            synchronized (RepeatedPostprocessorConsumer.this) {
+                if (mIsClosed) {
+                    return false;
+                }
+                oldSourceImageRef = mSourceImageRef;
+                mSourceImageRef = null;
+                mIsClosed = true;
+            }
+            CloseableReference.closeSafely(oldSourceImageRef);
+            return true;
         }
-        oldSourceImageRef = mSourceImageRef;
-        mSourceImageRef = null;
-        mIsClosed = true;
-      }
-      CloseableReference.closeSafely(oldSourceImageRef);
-      return true;
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/Producer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/Producer.java
index 93d2607af..de278b748 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/Producer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/Producer.java
@@ -11,23 +11,24 @@
 
 /**
  * Building block for image processing in the image pipeline.
- *
+ * <p>
  * <p> Execution of image request consists of multiple different tasks such as network fetch,
  * disk caching, memory caching, decoding, applying transformations etc. Producer<T> represents
  * single task whose result is an instance of T. Breaking entire request into sequence of
  * Producers allows us to construct different requests while reusing the same blocks.
- *
+ * <p>
  * <p> Producer supports multiple values and streaming.
  *
  * @param <T>
  */
 public interface Producer<T> {
 
-  /**
-   * Start producing results for given context. Provided consumer is notified whenever progress is
-   * made (new value is ready or error occurs).
-   * @param consumer
-   * @param context
-   */
-  void produceResults(Consumer<T> consumer, ProducerContext context);
+    /**
+     * Start producing results for given context. Provided consumer is notified whenever progress is
+     * made (new value is ready or error occurs).
+     *
+     * @param consumer
+     * @param context
+     */
+    void produceResults(Consumer<T> consumer, ProducerContext context);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerContext.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerContext.java
index 449a48225..18f973028 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerContext.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerContext.java
@@ -14,61 +14,62 @@
 
 /**
  * Used to pass context information to producers.
- *
+ * <p>
  * <p> Object implementing this interface is passed to all producers participating in pipeline
  * request {@see Producer#produceResults}. Its responsibility is to instruct producers which image
  * should be fetched/decoded/resized/cached etc. This class also handles request cancellation.
- *
+ * <p>
  * <p>  In order to be notified when cancellation is requested, a producer should use the
  * {@code runOnCancellationRequested} method which takes an instance of Runnable and executes it
  * when the pipeline client cancels the image request.
  */
 public interface ProducerContext {
 
-  /**
-   * @return image request that is being executed
-   */
-  public ImageRequest getImageRequest();
+    /**
+     * @return image request that is being executed
+     */
+    public ImageRequest getImageRequest();
 
-  /**
-   * @return id of this request
-   */
-  public String getId();
+    /**
+     * @return id of this request
+     */
+    public String getId();
 
-  /**
-   * @return ProducerListener for producer's events
-   */
-  public ProducerListener getListener();
+    /**
+     * @return ProducerListener for producer's events
+     */
+    public ProducerListener getListener();
 
-  /**
-   * @return the {@link Object} that indicates the caller's context
-   */
-  public Object getCallerContext();
+    /**
+     * @return the {@link Object} that indicates the caller's context
+     */
+    public Object getCallerContext();
 
-  /**
-   * @return the lowest permitted {@link ImageRequest.RequestLevel}
-   */
-  public ImageRequest.RequestLevel getLowestPermittedRequestLevel();
+    /**
+     * @return the lowest permitted {@link ImageRequest.RequestLevel}
+     */
+    public ImageRequest.RequestLevel getLowestPermittedRequestLevel();
 
-  /**
-   * @return true if the request is a prefetch, false otherwise.
-   */
-  public boolean isPrefetch();
+    /**
+     * @return true if the request is a prefetch, false otherwise.
+     */
+    public boolean isPrefetch();
 
-  /**
-   * @return priority of the request.
-   */
-  public Priority getPriority();
+    /**
+     * @return priority of the request.
+     */
+    public Priority getPriority();
 
-  /**
-   * @return true if request's owner expects intermediate results
-   */
-  public boolean isIntermediateResultExpected();
+    /**
+     * @return true if request's owner expects intermediate results
+     */
+    public boolean isIntermediateResultExpected();
 
-  /**
-   * Adds callbacks to the set of callbacks that are executed at various points during the
-   * processing of a request.
-   * @param callbacks callbacks to be executed
-   */
-  public void addCallbacks(ProducerContextCallbacks callbacks);
+    /**
+     * Adds callbacks to the set of callbacks that are executed at various points during the
+     * processing of a request.
+     *
+     * @param callbacks callbacks to be executed
+     */
+    public void addCallbacks(ProducerContextCallbacks callbacks);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerContextCallbacks.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerContextCallbacks.java
index c6d8775b1..4b99a32b3 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerContextCallbacks.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerContextCallbacks.java
@@ -14,23 +14,23 @@
  */
 public interface ProducerContextCallbacks {
 
-  /**
-   * Method that is called when a client cancels the request.
-   */
-  public void onCancellationRequested();
+    /**
+     * Method that is called when a client cancels the request.
+     */
+    public void onCancellationRequested();
 
-  /**
-   * Method that is called when a request is no longer a prefetch, or vice versa.
-   */
-  public void onIsPrefetchChanged();
+    /**
+     * Method that is called when a request is no longer a prefetch, or vice versa.
+     */
+    public void onIsPrefetchChanged();
 
-  /**
-   * Method that is called when intermediate results start or stop being expected.
-   */
-  public void onIsIntermediateResultExpectedChanged();
+    /**
+     * Method that is called when intermediate results start or stop being expected.
+     */
+    public void onIsIntermediateResultExpectedChanged();
 
-  /**
-   * Method that is called when the priority of the request changes.
-   */
-  public void onPriorityChanged();
+    /**
+     * Method that is called when the priority of the request changes.
+     */
+    public void onPriorityChanged();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerListener.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerListener.java
index 68ab31770..cd970a651 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerListener.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ProducerListener.java
@@ -15,63 +15,63 @@
 
 /**
  * Instrumentation for Producers.
- *
+ * <p>
  * <p> Implementation of a producer should call these methods when appropriate to notify other
  * components interested in execution progress.
  */
 public interface ProducerListener {
 
-  /**
-   * Called whenever a producer starts processing unit of work. This method might be called multiple
-   * times, but between any two consecutive calls to onProducerStart onProducerFinishWithSuccess
-   * will be called exactly once.
-   */
-  void onProducerStart(String requestId, String producerName);
+    /**
+     * Called whenever a producer starts processing unit of work. This method might be called multiple
+     * times, but between any two consecutive calls to onProducerStart onProducerFinishWithSuccess
+     * will be called exactly once.
+     */
+    void onProducerStart(String requestId, String producerName);
 
-  /**
-   * Called whenever an important producer-specific event occurs. This may only be called if
-   * onProducerStart has been called, but corresponding onProducerFinishWith* method has not been
-   * called yet.
-   */
-  void onProducerEvent(String requestId, String producerName, String eventName);
+    /**
+     * Called whenever an important producer-specific event occurs. This may only be called if
+     * onProducerStart has been called, but corresponding onProducerFinishWith* method has not been
+     * called yet.
+     */
+    void onProducerEvent(String requestId, String producerName, String eventName);
 
-  /**
-   * Called when a producer successfully finishes processing current unit of work.
-   *
-   * @param extraMap Additional parameters about the producer. This map is immutable and will
-   * throw an exception if attempts are made to modify it.
-   */
-  void onProducerFinishWithSuccess(
-      String requestId,
-      String producerName,
-      @Nullable Map<String, String> extraMap);
+    /**
+     * Called when a producer successfully finishes processing current unit of work.
+     *
+     * @param extraMap Additional parameters about the producer. This map is immutable and will
+     *                 throw an exception if attempts are made to modify it.
+     */
+    void onProducerFinishWithSuccess(
+            String requestId,
+            String producerName,
+            @Nullable Map<String, String> extraMap);
 
-  /**
-   * Called when producer finishes processing current unit of work due to an error.
-   *
-   * @param extraMap Additional parameters about the producer. This map is immutable and will
-   * throw an exception if attempts are made to modify it.
-   */
-  void onProducerFinishWithFailure(
-      String requestId,
-      String producerName,
-      Throwable t,
-      @Nullable Map<String, String> extraMap);
+    /**
+     * Called when producer finishes processing current unit of work due to an error.
+     *
+     * @param extraMap Additional parameters about the producer. This map is immutable and will
+     *                 throw an exception if attempts are made to modify it.
+     */
+    void onProducerFinishWithFailure(
+            String requestId,
+            String producerName,
+            Throwable t,
+            @Nullable Map<String, String> extraMap);
 
-  /**
-   * Called once when producer finishes due to cancellation.
-   *
-   * @param extraMap Additional parameters about the producer. This map is immutable and will
-   * throw an exception if attempts are made to modify it.
-   */
-  void onProducerFinishWithCancellation(
-      String requestId,
-      String producerName,
-      @Nullable Map<String, String> extraMap);
+    /**
+     * Called once when producer finishes due to cancellation.
+     *
+     * @param extraMap Additional parameters about the producer. This map is immutable and will
+     *                 throw an exception if attempts are made to modify it.
+     */
+    void onProducerFinishWithCancellation(
+            String requestId,
+            String producerName,
+            @Nullable Map<String, String> extraMap);
 
-  /**
-   * @return true if listener makes use of extra map
-   * @param requestId
-   */
-  boolean requiresExtraMap(String requestId);
+    /**
+     * @param requestId
+     * @return true if listener makes use of extra map
+     */
+    boolean requiresExtraMap(String requestId);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/RemoveImageTransformMetaDataProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/RemoveImageTransformMetaDataProducer.java
index 8aac0c905..23f80a7e9 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/RemoveImageTransformMetaDataProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/RemoveImageTransformMetaDataProducer.java
@@ -16,41 +16,41 @@
 
 /**
  * Remove image transform meta data producer
- *
+ * <p>
  * <p>Remove the {@link ImageTransformMetaData} object from the results passed down from the next
  * producer, and adds it to the result that it returns to the consumer.
  */
 public class RemoveImageTransformMetaDataProducer
-    implements Producer<CloseableReference<PooledByteBuffer>> {
-  private final Producer<
-      Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> mNextProducer;
-
-  public RemoveImageTransformMetaDataProducer(
-      Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer) {
-    mNextProducer = nextProducer;
-  }
-
-  @Override
-  public void produceResults(
-      Consumer<CloseableReference<PooledByteBuffer>> consumer,
-      ProducerContext context) {
-    mNextProducer.produceResults(new RemoveImageTransformMetaDataConsumer(consumer), context);
-  }
-
-  private class RemoveImageTransformMetaDataConsumer extends DelegatingConsumer<
-      Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>,
-      CloseableReference<PooledByteBuffer>> {
-
-    private RemoveImageTransformMetaDataConsumer(
-        Consumer<CloseableReference<PooledByteBuffer>> consumer) {
-      super(consumer);
+        implements Producer<CloseableReference<PooledByteBuffer>> {
+    private final Producer<
+            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> mNextProducer;
+
+    public RemoveImageTransformMetaDataProducer(
+            Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer) {
+        mNextProducer = nextProducer;
     }
 
     @Override
-    protected void onNewResultImpl(
-        Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> newResult,
-        boolean isLast) {
-      getConsumer().onNewResult(newResult == null ? null : newResult.first, isLast);
+    public void produceResults(
+            Consumer<CloseableReference<PooledByteBuffer>> consumer,
+            ProducerContext context) {
+        mNextProducer.produceResults(new RemoveImageTransformMetaDataConsumer(consumer), context);
+    }
+
+    private class RemoveImageTransformMetaDataConsumer extends DelegatingConsumer<
+            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>,
+            CloseableReference<PooledByteBuffer>> {
+
+        private RemoveImageTransformMetaDataConsumer(
+                Consumer<CloseableReference<PooledByteBuffer>> consumer) {
+            super(consumer);
+        }
+
+        @Override
+        protected void onNewResultImpl(
+                Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> newResult,
+                boolean isLast) {
+            getConsumer().onNewResult(newResult == null ? null : newResult.first, isLast);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ResizeAndRotateProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ResizeAndRotateProducer.java
index 22be0985e..37d534d24 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ResizeAndRotateProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ResizeAndRotateProducer.java
@@ -27,128 +27,130 @@
 
 /**
  * Resizes and rotates jpeg image according to exif orientation data.
- *
+ * <p>
  * <p> If image is not jpeg then no transformation is applied.
  */
 public class ResizeAndRotateProducer extends ImageTransformProducer<
-    Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>, ImageTransformMetaData> {
-  private static final String PRODUCER_NAME = "ResizeAndRotateProducer";
-  @VisibleForTesting static final int DEFAULT_JPEG_QUALITY = 85;
-  @VisibleForTesting static final int MAX_JPEG_SCALE_NUMERATOR = JpegTranscoder.SCALE_DENOMINATOR;
-
-  public ResizeAndRotateProducer(
-      Executor executor,
-      PooledByteBufferFactory pooledByteBufferFactory,
-      Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer) {
-    super(executor, pooledByteBufferFactory, nextProducer);
-  }
-
-  @Override
-  protected TriState shouldTransform(
-      final Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> input,
-      final ImageRequest imageRequest,
-      boolean isLast) {
-    ImageTransformMetaData metaData = input.second;
-    switch (metaData.getImageFormat()) {
-      case JPEG:
-        return isLast ?
-            TriState.valueOf(
-                getRotationAngle(imageRequest, metaData) != 0 ||
-                    getScaleNumerator(imageRequest, metaData) != JpegTranscoder.SCALE_DENOMINATOR) :
-            TriState.UNSET;
-      case UNKNOWN:
-        return isLast ? TriState.NO : TriState.UNSET;
-      default:
-        return TriState.NO;
+        Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>, ImageTransformMetaData> {
+    private static final String PRODUCER_NAME = "ResizeAndRotateProducer";
+    @VisibleForTesting
+    static final int DEFAULT_JPEG_QUALITY = 85;
+    @VisibleForTesting
+    static final int MAX_JPEG_SCALE_NUMERATOR = JpegTranscoder.SCALE_DENOMINATOR;
+
+    public ResizeAndRotateProducer(
+            Executor executor,
+            PooledByteBufferFactory pooledByteBufferFactory,
+            Producer<Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData>> nextProducer) {
+        super(executor, pooledByteBufferFactory, nextProducer);
+    }
+
+    @Override
+    protected TriState shouldTransform(
+            final Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> input,
+            final ImageRequest imageRequest,
+            boolean isLast) {
+        ImageTransformMetaData metaData = input.second;
+        switch (metaData.getImageFormat()) {
+            case JPEG:
+                return isLast ?
+                        TriState.valueOf(
+                                getRotationAngle(imageRequest, metaData) != 0 ||
+                                        getScaleNumerator(imageRequest, metaData) != JpegTranscoder.SCALE_DENOMINATOR) :
+                        TriState.UNSET;
+            case UNKNOWN:
+                return isLast ? TriState.NO : TriState.UNSET;
+            default:
+                return TriState.NO;
+        }
+    }
+
+    @Override
+    protected void transform(
+            final CloseableReference<PooledByteBuffer> imageRef,
+            final PooledByteBufferOutputStream outputStream,
+            final ImageRequest imageRequest,
+            final ImageTransformMetaData metaData)
+            throws Exception {
+        JpegTranscoder.transcodeJpeg(
+                new PooledByteBufferInputStream(imageRef.get()),
+                outputStream,
+                getRotationAngle(imageRequest, metaData),
+                getScaleNumerator(imageRequest, metaData),
+                DEFAULT_JPEG_QUALITY);
+    }
+
+    @Override
+    protected CloseableReference<PooledByteBuffer> getImageCopy(
+            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> originalResult) {
+        return originalResult.first.clone();
     }
-  }
-
-  @Override
-  protected void transform(
-      final CloseableReference<PooledByteBuffer> imageRef,
-      final PooledByteBufferOutputStream outputStream,
-      final ImageRequest imageRequest,
-      final ImageTransformMetaData metaData)
-      throws Exception {
-    JpegTranscoder.transcodeJpeg(
-        new PooledByteBufferInputStream(imageRef.get()),
-        outputStream,
-        getRotationAngle(imageRequest, metaData),
-        getScaleNumerator(imageRequest, metaData),
-        DEFAULT_JPEG_QUALITY);
-  }
-
-  @Override
-  protected CloseableReference<PooledByteBuffer> getImageCopy(
-      Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> originalResult) {
-    return originalResult.first.clone();
-  }
-
-  @Override
-  protected ImageTransformMetaData getExtraInformation(
-      Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> originalResult) {
-    return originalResult.second;
-  }
-
-  @Override
-  protected Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> createReturnValue(
-      PooledByteBuffer transformedBytes,
-      ImageTransformMetaData metaData) {
-    return Pair.create(CloseableReference.of(transformedBytes), metaData);
-  }
-
-  @Override
-  protected void closeReturnValue(
-      Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> returnValue) {
-    CloseableReference.closeSafely(returnValue.first);
-  }
-
-  @Override
-  protected String getProducerName() {
-    return PRODUCER_NAME;
-  }
-
-  @Override
-  protected boolean shouldAllowCancellation() {
-    return true;
-  }
-
-  private static int getScaleNumerator(
-      final ImageRequest imageRequest,
-      final ImageTransformMetaData metaData) {
-    final ResizeOptions resizeOptions = imageRequest.getResizeOptions();
-    if (resizeOptions == null) {
-      return JpegTranscoder.SCALE_DENOMINATOR;
+
+    @Override
+    protected ImageTransformMetaData getExtraInformation(
+            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> originalResult) {
+        return originalResult.second;
     }
 
-    final int rotationAngle = getRotationAngle(imageRequest, metaData);
-    final boolean swapDimensions = rotationAngle == 90 || rotationAngle == 270;
-    final int widthAfterRotation = swapDimensions ? metaData.getHeight() : metaData.getWidth();
-    final int heightAfterRotation = swapDimensions ? metaData.getWidth() : metaData.getHeight();
+    @Override
+    protected Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> createReturnValue(
+            PooledByteBuffer transformedBytes,
+            ImageTransformMetaData metaData) {
+        return Pair.create(CloseableReference.of(transformedBytes), metaData);
+    }
 
-    final float widthRatio = ((float) resizeOptions.width) / widthAfterRotation;
-    final float heightRatio = ((float) resizeOptions.height) / heightAfterRotation;
-    final int numerator =
-        (int) Math.ceil(Math.max(widthRatio, heightRatio) * JpegTranscoder.SCALE_DENOMINATOR);
+    @Override
+    protected void closeReturnValue(
+            Pair<CloseableReference<PooledByteBuffer>, ImageTransformMetaData> returnValue) {
+        CloseableReference.closeSafely(returnValue.first);
+    }
 
-    if (numerator > MAX_JPEG_SCALE_NUMERATOR) {
-      return JpegTranscoder.SCALE_DENOMINATOR;
+    @Override
+    protected String getProducerName() {
+        return PRODUCER_NAME;
     }
-    if (numerator < 1) {
-      return 1;
+
+    @Override
+    protected boolean shouldAllowCancellation() {
+        return true;
     }
-    return numerator;
-  }
-
-  private static int getRotationAngle(
-      final ImageRequest imageRequest,
-      final ImageTransformMetaData metaData) {
-    if (!imageRequest.getAutoRotateEnabled()) {
-      return 0;
+
+    private static int getScaleNumerator(
+            final ImageRequest imageRequest,
+            final ImageTransformMetaData metaData) {
+        final ResizeOptions resizeOptions = imageRequest.getResizeOptions();
+        if (resizeOptions == null) {
+            return JpegTranscoder.SCALE_DENOMINATOR;
+        }
+
+        final int rotationAngle = getRotationAngle(imageRequest, metaData);
+        final boolean swapDimensions = rotationAngle == 90 || rotationAngle == 270;
+        final int widthAfterRotation = swapDimensions ? metaData.getHeight() : metaData.getWidth();
+        final int heightAfterRotation = swapDimensions ? metaData.getWidth() : metaData.getHeight();
+
+        final float widthRatio = ((float) resizeOptions.width) / widthAfterRotation;
+        final float heightRatio = ((float) resizeOptions.height) / heightAfterRotation;
+        final int numerator =
+                (int) Math.ceil(Math.max(widthRatio, heightRatio) * JpegTranscoder.SCALE_DENOMINATOR);
+
+        if (numerator > MAX_JPEG_SCALE_NUMERATOR) {
+            return JpegTranscoder.SCALE_DENOMINATOR;
+        }
+        if (numerator < 1) {
+            return 1;
+        }
+        return numerator;
+    }
+
+    private static int getRotationAngle(
+            final ImageRequest imageRequest,
+            final ImageTransformMetaData metaData) {
+        if (!imageRequest.getAutoRotateEnabled()) {
+            return 0;
+        }
+        int rotationAngle = metaData.getRotationAngle();
+        Preconditions.checkArgument(
+                rotationAngle == 0 || rotationAngle == 90 || rotationAngle == 180 || rotationAngle == 270);
+        return rotationAngle;
     }
-    int rotationAngle = metaData.getRotationAngle();
-    Preconditions.checkArgument(
-        rotationAngle == 0 || rotationAngle == 90 || rotationAngle == 180 || rotationAngle == 270);
-    return rotationAngle;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/SettableProducerContext.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/SettableProducerContext.java
index aec363654..dbc7a30c5 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/SettableProducerContext.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/SettableProducerContext.java
@@ -26,179 +26,182 @@
 @ThreadSafe
 public class SettableProducerContext implements ProducerContext {
 
-  private final ImageRequest mImageRequest;
-  private final String mId;
-  private final ProducerListener mProducerListener;
-  private final Object mCallerContext;
-  private final ImageRequest.RequestLevel mLowestPermittedRequestLevel;
-  @GuardedBy("this")
-  private final List<ProducerContextCallbacks> mCallbacks;
-  @GuardedBy("this")
-  private boolean mIsCancelled;
-  @GuardedBy("this")
-  private boolean mIsPrefetch;
-  @GuardedBy("this")
-  private Priority mPriority;
-  @GuardedBy("this")
-  private boolean mIsIntermediateResultExpected;
-
-  public SettableProducerContext(
-      ImageRequest imageRequest,
-      String id,
-      ProducerListener producerListener,
-      Object callerContext,
-      ImageRequest.RequestLevel lowestPermittedRequestLevel,
-      boolean isPrefetch,
-      boolean isIntermediateResultExpected,
-      Priority priority) {
-    mImageRequest = Preconditions.checkNotNull(imageRequest);
-    mId = Preconditions.checkNotNull(id);
-    mProducerListener = Preconditions.checkNotNull(producerListener);
-    mCallerContext = callerContext;
-    mLowestPermittedRequestLevel = Preconditions.checkNotNull(lowestPermittedRequestLevel);
-    mIsPrefetch = isPrefetch;
-    mIsIntermediateResultExpected = isIntermediateResultExpected;
-    mPriority = priority;
-    mIsCancelled = false;
-    mCallbacks = Lists.newArrayList();
-  }
-
-  @Override
-  public ImageRequest getImageRequest() {
-    return mImageRequest;
-  }
-
-  @Override
-  public String getId() {
-    return mId;
-  }
-
-  @Override
-  public ProducerListener getListener() {
-    return mProducerListener;
-  }
-
-  @Override
-  public Object getCallerContext() {
-    return mCallerContext;
-  }
-
-  @Override
-  public ImageRequest.RequestLevel getLowestPermittedRequestLevel() {
-    return mLowestPermittedRequestLevel;
-  }
-
-  @Override
-  public synchronized boolean isPrefetch() {
-    return mIsPrefetch;
-  }
-
-  @Override
-  public synchronized Priority getPriority() {
-    return mPriority;
-  }
-
-  @Override
-  public synchronized boolean isIntermediateResultExpected() {
-    return mIsIntermediateResultExpected;
-  }
-
-  @Override
-  public void addCallbacks(ProducerContextCallbacks callbacks) {
-    boolean cancelImmediately = false;
-    synchronized (this) {
-      mCallbacks.add(callbacks);
-      if (mIsCancelled) {
-        cancelImmediately = true;
-      }
+    private final ImageRequest mImageRequest;
+    private final String mId;
+    private final ProducerListener mProducerListener;
+    private final Object mCallerContext;
+    private final ImageRequest.RequestLevel mLowestPermittedRequestLevel;
+    @GuardedBy("this")
+    private final List<ProducerContextCallbacks> mCallbacks;
+    @GuardedBy("this")
+    private boolean mIsCancelled;
+    @GuardedBy("this")
+    private boolean mIsPrefetch;
+    @GuardedBy("this")
+    private Priority mPriority;
+    @GuardedBy("this")
+    private boolean mIsIntermediateResultExpected;
+
+    public SettableProducerContext(
+            ImageRequest imageRequest,
+            String id,
+            ProducerListener producerListener,
+            Object callerContext,
+            ImageRequest.RequestLevel lowestPermittedRequestLevel,
+            boolean isPrefetch,
+            boolean isIntermediateResultExpected,
+            Priority priority) {
+        mImageRequest = Preconditions.checkNotNull(imageRequest);
+        mId = Preconditions.checkNotNull(id);
+        mProducerListener = Preconditions.checkNotNull(producerListener);
+        mCallerContext = callerContext;
+        mLowestPermittedRequestLevel = Preconditions.checkNotNull(lowestPermittedRequestLevel);
+        mIsPrefetch = isPrefetch;
+        mIsIntermediateResultExpected = isIntermediateResultExpected;
+        mPriority = priority;
+        mIsCancelled = false;
+        mCallbacks = Lists.newArrayList();
     }
 
-    if (cancelImmediately) {
-      callbacks.onCancellationRequested();
+    @Override
+    public ImageRequest getImageRequest() {
+        return mImageRequest;
     }
-  }
-
-  /**
-   * Cancels the request processing.
-   */
-  public void cancel() {
-    List<ProducerContextCallbacks> callbacks = null;
-    synchronized (this) {
-      if (!mIsCancelled) {
-        mIsCancelled = true;
-        callbacks = Lists.newArrayList(mCallbacks);
-      }
+
+    @Override
+    public String getId() {
+        return mId;
     }
 
-    if (callbacks != null) {
-      for (ProducerContextCallbacks callback : callbacks) {
-        callback.onCancellationRequested();
-      }
+    @Override
+    public ProducerListener getListener() {
+        return mProducerListener;
     }
-  }
-
-  /**
-   * Set whether the request is a prefetch request or not.
-   * @param isPrefetch
-   */
-  public void setIsPrefetch(boolean isPrefetch) {
-    List<ProducerContextCallbacks> callbacks = null;
-    synchronized (this) {
-      if (mIsPrefetch != isPrefetch) {
-        mIsPrefetch = isPrefetch;
-        callbacks = Lists.newArrayList(mCallbacks);
-      }
+
+    @Override
+    public Object getCallerContext() {
+        return mCallerContext;
     }
 
-    if (callbacks != null) {
-      for (ProducerContextCallbacks callback : callbacks) {
-        callback.onIsPrefetchChanged();
-      }
+    @Override
+    public ImageRequest.RequestLevel getLowestPermittedRequestLevel() {
+        return mLowestPermittedRequestLevel;
     }
-  }
-
-  /**
-   * Set whether intermediate result is expected or not
-   * @param isIntermediateResultExpected
-   */
-  public void setIsIntermediateResultExpected(boolean isIntermediateResultExpected) {
-    List<ProducerContextCallbacks> callbacks = null;
-    synchronized (this) {
-      if (mIsIntermediateResultExpected != isIntermediateResultExpected) {
-        mIsIntermediateResultExpected = isIntermediateResultExpected;
-        callbacks = Lists.newArrayList(mCallbacks);
-      }
+
+    @Override
+    public synchronized boolean isPrefetch() {
+        return mIsPrefetch;
     }
 
-    if (callbacks != null) {
-      for (ProducerContextCallbacks callback : callbacks) {
-        callback.onIsIntermediateResultExpectedChanged();
-      }
+    @Override
+    public synchronized Priority getPriority() {
+        return mPriority;
     }
-  }
-
-  /**
-   * Set the priority of the request
-   * @param priority
-   */
-  public void setPriority(Priority priority) {
-    List<ProducerContextCallbacks> callbacks = null;
-    synchronized (this) {
-      if (mPriority != priority) {
-        mPriority = priority;
-        callbacks = Lists.newArrayList(mCallbacks);
-      }
+
+    @Override
+    public synchronized boolean isIntermediateResultExpected() {
+        return mIsIntermediateResultExpected;
     }
 
-    if (callbacks != null) {
-      for (ProducerContextCallbacks callback : callbacks) {
-        callback.onPriorityChanged();
-      }
+    @Override
+    public void addCallbacks(ProducerContextCallbacks callbacks) {
+        boolean cancelImmediately = false;
+        synchronized (this) {
+            mCallbacks.add(callbacks);
+            if (mIsCancelled) {
+                cancelImmediately = true;
+            }
+        }
+
+        if (cancelImmediately) {
+            callbacks.onCancellationRequested();
+        }
     }
-  }
 
-  @VisibleForTesting
-  synchronized boolean isCancelled() {
-    return mIsCancelled;
-  }
+    /**
+     * Cancels the request processing.
+     */
+    public void cancel() {
+        List<ProducerContextCallbacks> callbacks = null;
+        synchronized (this) {
+            if (!mIsCancelled) {
+                mIsCancelled = true;
+                callbacks = Lists.newArrayList(mCallbacks);
+            }
+        }
+
+        if (callbacks != null) {
+            for (ProducerContextCallbacks callback : callbacks) {
+                callback.onCancellationRequested();
+            }
+        }
+    }
+
+    /**
+     * Set whether the request is a prefetch request or not.
+     *
+     * @param isPrefetch
+     */
+    public void setIsPrefetch(boolean isPrefetch) {
+        List<ProducerContextCallbacks> callbacks = null;
+        synchronized (this) {
+            if (mIsPrefetch != isPrefetch) {
+                mIsPrefetch = isPrefetch;
+                callbacks = Lists.newArrayList(mCallbacks);
+            }
+        }
+
+        if (callbacks != null) {
+            for (ProducerContextCallbacks callback : callbacks) {
+                callback.onIsPrefetchChanged();
+            }
+        }
+    }
+
+    /**
+     * Set whether intermediate result is expected or not
+     *
+     * @param isIntermediateResultExpected
+     */
+    public void setIsIntermediateResultExpected(boolean isIntermediateResultExpected) {
+        List<ProducerContextCallbacks> callbacks = null;
+        synchronized (this) {
+            if (mIsIntermediateResultExpected != isIntermediateResultExpected) {
+                mIsIntermediateResultExpected = isIntermediateResultExpected;
+                callbacks = Lists.newArrayList(mCallbacks);
+            }
+        }
+
+        if (callbacks != null) {
+            for (ProducerContextCallbacks callback : callbacks) {
+                callback.onIsIntermediateResultExpectedChanged();
+            }
+        }
+    }
+
+    /**
+     * Set the priority of the request
+     *
+     * @param priority
+     */
+    public void setPriority(Priority priority) {
+        List<ProducerContextCallbacks> callbacks = null;
+        synchronized (this) {
+            if (mPriority != priority) {
+                mPriority = priority;
+                callbacks = Lists.newArrayList(mCallbacks);
+            }
+        }
+
+        if (callbacks != null) {
+            for (ProducerContextCallbacks callback : callbacks) {
+                callback.onPriorityChanged();
+            }
+        }
+    }
+
+    @VisibleForTesting
+    synchronized boolean isCancelled() {
+        return mIsCancelled;
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/StatefulProducerRunnable.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/StatefulProducerRunnable.java
index b022f44e7..a2721201b 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/StatefulProducerRunnable.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/StatefulProducerRunnable.java
@@ -15,80 +15,80 @@
 
 /**
  * {@link StatefulRunnable} intended to be used by producers.
- *
+ * <p>
  * <p> Class implements common functionality related to handling producer instrumentation and
  * resource management.
  */
 public abstract class StatefulProducerRunnable<T>
-    extends StatefulRunnable<T> {
+        extends StatefulRunnable<T> {
 
-  private final Consumer<T> mConsumer;
-  private final ProducerListener mProducerListener;
-  private final String mProducerName;
-  private final String mRequestId;
+    private final Consumer<T> mConsumer;
+    private final ProducerListener mProducerListener;
+    private final String mProducerName;
+    private final String mRequestId;
 
-  public StatefulProducerRunnable(
-      Consumer<T> consumer,
-      ProducerListener producerListener,
-      String producerName,
-      String requestId) {
-    mConsumer = consumer;
-    mProducerListener = producerListener;
-    mProducerName = producerName;
-    mRequestId = requestId;
+    public StatefulProducerRunnable(
+            Consumer<T> consumer,
+            ProducerListener producerListener,
+            String producerName,
+            String requestId) {
+        mConsumer = consumer;
+        mProducerListener = producerListener;
+        mProducerName = producerName;
+        mRequestId = requestId;
 
-    mProducerListener.onProducerStart(mRequestId, mProducerName);
-  }
+        mProducerListener.onProducerStart(mRequestId, mProducerName);
+    }
 
-  @Override
-  protected void onSuccess(T result) {
-    mProducerListener.onProducerFinishWithSuccess(
-        mRequestId,
-        mProducerName,
-        mProducerListener.requiresExtraMap(mRequestId) ? getExtraMapOnSuccess(result) : null);
-    mConsumer.onNewResult(result, true);
-  }
+    @Override
+    protected void onSuccess(T result) {
+        mProducerListener.onProducerFinishWithSuccess(
+                mRequestId,
+                mProducerName,
+                mProducerListener.requiresExtraMap(mRequestId) ? getExtraMapOnSuccess(result) : null);
+        mConsumer.onNewResult(result, true);
+    }
 
-  @Override
-  protected void onFailure(Exception e) {
-    mProducerListener.onProducerFinishWithFailure(
-        mRequestId,
-        mProducerName,
-        e,
-        mProducerListener.requiresExtraMap(mRequestId) ? getExtraMapOnFailure(e) : null);
-    mConsumer.onFailure(e);
-  }
+    @Override
+    protected void onFailure(Exception e) {
+        mProducerListener.onProducerFinishWithFailure(
+                mRequestId,
+                mProducerName,
+                e,
+                mProducerListener.requiresExtraMap(mRequestId) ? getExtraMapOnFailure(e) : null);
+        mConsumer.onFailure(e);
+    }
 
-  @Override
-  protected void onCancellation() {
-    mProducerListener.onProducerFinishWithCancellation(
-        mRequestId,
-        mProducerName,
-        mProducerListener.requiresExtraMap(mRequestId) ? getExtraMapOnCancellation() : null);
-    mConsumer.onCancellation();
-  }
+    @Override
+    protected void onCancellation() {
+        mProducerListener.onProducerFinishWithCancellation(
+                mRequestId,
+                mProducerName,
+                mProducerListener.requiresExtraMap(mRequestId) ? getExtraMapOnCancellation() : null);
+        mConsumer.onCancellation();
+    }
 
-  /**
-   * Create extra map for result
-   */
-  protected Map<String, String> getExtraMapOnSuccess(T result) {
-    return null;
-  }
+    /**
+     * Create extra map for result
+     */
+    protected Map<String, String> getExtraMapOnSuccess(T result) {
+        return null;
+    }
 
-  /**
-   * Create extra map for exception
-   */
-  protected Map<String, String> getExtraMapOnFailure(Exception exception) {
-    return null;
-  }
+    /**
+     * Create extra map for exception
+     */
+    protected Map<String, String> getExtraMapOnFailure(Exception exception) {
+        return null;
+    }
 
-  /**
-   * Create extra map for cancellation
-   */
-  protected Map<String, String> getExtraMapOnCancellation() {
-    return null;
-  }
+    /**
+     * Create extra map for cancellation
+     */
+    protected Map<String, String> getExtraMapOnCancellation() {
+        return null;
+    }
 
-  @Override
-  protected abstract void disposeResult(T result);
+    @Override
+    protected abstract void disposeResult(T result);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/SwallowResultProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/SwallowResultProducer.java
index 9dd6c3fe4..71c522479 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/SwallowResultProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/SwallowResultProducer.java
@@ -11,26 +11,26 @@
 
 /**
  * Swallow result producer.
- *
+ * <p>
  * <p>This producer just inserts a consumer that swallows results into the stack of consumers.
  */
 public class SwallowResultProducer<T> implements Producer<Void> {
-  private final Producer<T> mNextProducer;
+    private final Producer<T> mNextProducer;
 
-  public SwallowResultProducer(Producer<T> nextProducer) {
-    mNextProducer = nextProducer;
-  }
+    public SwallowResultProducer(Producer<T> nextProducer) {
+        mNextProducer = nextProducer;
+    }
 
-  @Override
-  public void produceResults(Consumer<Void> consumer, ProducerContext producerContext) {
-    DelegatingConsumer<T, Void> swallowResultConsumer = new DelegatingConsumer<T, Void>(consumer) {
-      @Override
-      protected void onNewResultImpl(T newResult, boolean isLast) {
-        if (isLast) {
-          getConsumer().onNewResult(null, isLast);
-        }
-      }
-    };
-    mNextProducer.produceResults(swallowResultConsumer, producerContext);
-  }
+    @Override
+    public void produceResults(Consumer<Void> consumer, ProducerContext producerContext) {
+        DelegatingConsumer<T, Void> swallowResultConsumer = new DelegatingConsumer<T, Void>(consumer) {
+            @Override
+            protected void onNewResultImpl(T newResult, boolean isLast) {
+                if (isLast) {
+                    getConsumer().onNewResult(null, isLast);
+                }
+            }
+        };
+        mNextProducer.produceResults(swallowResultConsumer, producerContext);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThreadHandoffProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThreadHandoffProducer.java
index 61e8ef856..f15233198 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThreadHandoffProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThreadHandoffProducer.java
@@ -19,47 +19,48 @@
  */
 public class ThreadHandoffProducer<T> implements Producer<T> {
 
-  @VisibleForTesting
-  protected static final String PRODUCER_NAME = "BackgroundThreadHandoffProducer";
+    @VisibleForTesting
+    protected static final String PRODUCER_NAME = "BackgroundThreadHandoffProducer";
 
-  private final Executor mExecutor;
-  private final Producer<T> mNextProducer;
+    private final Executor mExecutor;
+    private final Producer<T> mNextProducer;
 
-  public ThreadHandoffProducer(final Executor executorService, final Producer<T> nextProducer) {
-    mExecutor = Preconditions.checkNotNull(executorService);
-    mNextProducer = Preconditions.checkNotNull(nextProducer);
-  }
+    public ThreadHandoffProducer(final Executor executorService, final Producer<T> nextProducer) {
+        mExecutor = Preconditions.checkNotNull(executorService);
+        mNextProducer = Preconditions.checkNotNull(nextProducer);
+    }
 
-  @Override
-  public void produceResults(final Consumer<T> consumer, final ProducerContext context) {
-    final ProducerListener producerListener = context.getListener();
-    final String requestId = context.getId();
-    final StatefulProducerRunnable<T> statefulRunnable = new StatefulProducerRunnable<T>(
-        consumer,
-        producerListener,
-        PRODUCER_NAME,
-        requestId) {
-      @Override
-      protected void onSuccess(T ignored) {
-        producerListener.onProducerFinishWithSuccess(requestId, PRODUCER_NAME, null);
-        mNextProducer.produceResults(consumer, context);
-      }
+    @Override
+    public void produceResults(final Consumer<T> consumer, final ProducerContext context) {
+        final ProducerListener producerListener = context.getListener();
+        final String requestId = context.getId();
+        final StatefulProducerRunnable<T> statefulRunnable = new StatefulProducerRunnable<T>(
+                consumer,
+                producerListener,
+                PRODUCER_NAME,
+                requestId) {
+            @Override
+            protected void onSuccess(T ignored) {
+                producerListener.onProducerFinishWithSuccess(requestId, PRODUCER_NAME, null);
+                mNextProducer.produceResults(consumer, context);
+            }
 
-      @Override
-      protected void disposeResult(T ignored) {}
+            @Override
+            protected void disposeResult(T ignored) {
+            }
 
-      @Override
-      protected T getResult() throws Exception {
-        return null;
-      }
-    };
-    context.addCallbacks(
-        new BaseProducerContextCallbacks() {
-          @Override
-          public void onCancellationRequested() {
-            statefulRunnable.cancel();
-          }
-        });
-    mExecutor.execute(statefulRunnable);
-  }
+            @Override
+            protected T getResult() throws Exception {
+                return null;
+            }
+        };
+        context.addCallbacks(
+                new BaseProducerContextCallbacks() {
+                    @Override
+                    public void onCancellationRequested() {
+                        statefulRunnable.cancel();
+                    }
+                });
+        mExecutor.execute(statefulRunnable);
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThrottlingProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThrottlingProducer.java
index d60504820..32b3816d3 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThrottlingProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/ThrottlingProducer.java
@@ -24,88 +24,89 @@
  */
 public class ThrottlingProducer<T> implements Producer<T> {
 
-  @VisibleForTesting static final String PRODUCER_NAME = "ThrottlingProducer";
-
-  private final Producer<T> mNextProducer;
-  private final int mMaxSimultaneousRequests;
-
-  @GuardedBy("this")
-  private int mNumCurrentRequests;
-  @GuardedBy("this")
-  private final ConcurrentLinkedQueue<Pair<Consumer<T>, ProducerContext>> mPendingRequests;
-
-  public ThrottlingProducer(int maxSimultaneousRequests, final Producer<T> nextProducer) {
-    mMaxSimultaneousRequests = maxSimultaneousRequests;
-    mNextProducer = Preconditions.checkNotNull(nextProducer);
-    mPendingRequests = new ConcurrentLinkedQueue<Pair<Consumer<T>, ProducerContext>>();
-    mNumCurrentRequests = 0;
-  }
-
-  @Override
-  public void produceResults(final Consumer<T> consumer, final ProducerContext producerContext) {
-    final ProducerListener producerListener = producerContext.getListener();
-    producerListener.onProducerStart(producerContext.getId(), PRODUCER_NAME);
-
-    boolean delayRequest;
-    synchronized (this) {
-      if (mNumCurrentRequests >= mMaxSimultaneousRequests) {
-        mPendingRequests.add(Pair.create(consumer, producerContext));
-        delayRequest = true;
-      } else {
-        mNumCurrentRequests++;
-        delayRequest = false;
-      }
+    @VisibleForTesting
+    static final String PRODUCER_NAME = "ThrottlingProducer";
+
+    private final Producer<T> mNextProducer;
+    private final int mMaxSimultaneousRequests;
+
+    @GuardedBy("this")
+    private int mNumCurrentRequests;
+    @GuardedBy("this")
+    private final ConcurrentLinkedQueue<Pair<Consumer<T>, ProducerContext>> mPendingRequests;
+
+    public ThrottlingProducer(int maxSimultaneousRequests, final Producer<T> nextProducer) {
+        mMaxSimultaneousRequests = maxSimultaneousRequests;
+        mNextProducer = Preconditions.checkNotNull(nextProducer);
+        mPendingRequests = new ConcurrentLinkedQueue<Pair<Consumer<T>, ProducerContext>>();
+        mNumCurrentRequests = 0;
     }
 
-    if (!delayRequest) {
-      produceResultsInternal(consumer, producerContext);
-    }
-  }
-
-  void produceResultsInternal(Consumer<T> consumer, ProducerContext producerContext) {
-    ProducerListener producerListener = producerContext.getListener();
-    producerListener.onProducerFinishWithSuccess(producerContext.getId(), PRODUCER_NAME, null);
-    mNextProducer.produceResults(new ThrottlerConsumer(consumer), producerContext);
-  }
-
-  private class ThrottlerConsumer extends DelegatingConsumer<T, T> {
+    @Override
+    public void produceResults(final Consumer<T> consumer, final ProducerContext producerContext) {
+        final ProducerListener producerListener = producerContext.getListener();
+        producerListener.onProducerStart(producerContext.getId(), PRODUCER_NAME);
+
+        boolean delayRequest;
+        synchronized (this) {
+            if (mNumCurrentRequests >= mMaxSimultaneousRequests) {
+                mPendingRequests.add(Pair.create(consumer, producerContext));
+                delayRequest = true;
+            } else {
+                mNumCurrentRequests++;
+                delayRequest = false;
+            }
+        }
 
-    private ThrottlerConsumer(Consumer<T> consumer) {
-      super(consumer);
+        if (!delayRequest) {
+            produceResultsInternal(consumer, producerContext);
+        }
     }
 
-    @Override
-    protected void onNewResultImpl(T newResult, boolean isLast) {
-      getConsumer().onNewResult(newResult, isLast);
-      if (isLast) {
-        onRequestFinished();
-      }
+    void produceResultsInternal(Consumer<T> consumer, ProducerContext producerContext) {
+        ProducerListener producerListener = producerContext.getListener();
+        producerListener.onProducerFinishWithSuccess(producerContext.getId(), PRODUCER_NAME, null);
+        mNextProducer.produceResults(new ThrottlerConsumer(consumer), producerContext);
     }
 
-    @Override
-    protected void onFailureImpl(Throwable t) {
-      getConsumer().onFailure(t);
-      onRequestFinished();
-    }
+    private class ThrottlerConsumer extends DelegatingConsumer<T, T> {
 
-    @Override
-    protected void onCancellationImpl() {
-      getConsumer().onCancellation();
-      onRequestFinished();
-    }
+        private ThrottlerConsumer(Consumer<T> consumer) {
+            super(consumer);
+        }
+
+        @Override
+        protected void onNewResultImpl(T newResult, boolean isLast) {
+            getConsumer().onNewResult(newResult, isLast);
+            if (isLast) {
+                onRequestFinished();
+            }
+        }
+
+        @Override
+        protected void onFailureImpl(Throwable t) {
+            getConsumer().onFailure(t);
+            onRequestFinished();
+        }
 
-    private void onRequestFinished() {
-      Pair<Consumer<T>, ProducerContext> nextRequestPair;
-      synchronized (ThrottlingProducer.this) {
-        nextRequestPair = mPendingRequests.poll();
-        if (nextRequestPair == null) {
-          mNumCurrentRequests--;
+        @Override
+        protected void onCancellationImpl() {
+            getConsumer().onCancellation();
+            onRequestFinished();
         }
-      }
 
-      if (nextRequestPair != null) {
-        produceResultsInternal(nextRequestPair.first, nextRequestPair.second);
-      }
+        private void onRequestFinished() {
+            Pair<Consumer<T>, ProducerContext> nextRequestPair;
+            synchronized (ThrottlingProducer.this) {
+                nextRequestPair = mPendingRequests.poll();
+                if (nextRequestPair == null) {
+                    mNumCurrentRequests--;
+                }
+            }
+
+            if (nextRequestPair != null) {
+                produceResultsInternal(nextRequestPair.first, nextRequestPair.second);
+            }
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/WebpTranscodeProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/WebpTranscodeProducer.java
index 1cf0e10ee..1ae64fb2b 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/WebpTranscodeProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/WebpTranscodeProducer.java
@@ -25,99 +25,99 @@
 
 /**
  * Transcodes webps to jpegs.
- *
+ * <p>
  * <p> If processed image is one of VP8, VP8X or VP8L non-animated webps then
  * it is transcoded to jpeg if Android's decoder does not support this format.
  * If image is of any other type, no transformation is applied.
  */
 public class WebpTranscodeProducer
-    extends ImageTransformProducer<CloseableReference<PooledByteBuffer>, Void> {
-  private static final String PRODUCER_NAME = "WebpTranscodeProducer";
-  private static final int DEFAULT_JPEG_QUALITY = 80;
-
-  public WebpTranscodeProducer(
-      Executor executor,
-      PooledByteBufferFactory pooledByteBufferFactory,
-      Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
-    super(executor, pooledByteBufferFactory, nextProducer);
-  }
-
-  @Override
-  protected TriState shouldTransform(
-      final CloseableReference<PooledByteBuffer> imageRef,
-      final ImageRequest imageRequest,
-      boolean isLast) {
-    InputStream imageInputStream = new PooledByteBufferInputStream(imageRef.get());
-    ImageFormat imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(imageInputStream);
-
-    switch (imageFormat) {
-      case WEBP_SIMPLE:
-      case WEBP_LOSSLESS:
-      case WEBP_EXTENDED:
-      case WEBP_EXTENDED_WITH_ALPHA:
-        return TriState.valueOf(!WebpTranscoder.isWebpNativelySupported(imageFormat));
-      case UNKNOWN:
-        return isLast ? TriState.NO : TriState.UNSET;
-      default:
-        return TriState.NO;
+        extends ImageTransformProducer<CloseableReference<PooledByteBuffer>, Void> {
+    private static final String PRODUCER_NAME = "WebpTranscodeProducer";
+    private static final int DEFAULT_JPEG_QUALITY = 80;
+
+    public WebpTranscodeProducer(
+            Executor executor,
+            PooledByteBufferFactory pooledByteBufferFactory,
+            Producer<CloseableReference<PooledByteBuffer>> nextProducer) {
+        super(executor, pooledByteBufferFactory, nextProducer);
+    }
+
+    @Override
+    protected TriState shouldTransform(
+            final CloseableReference<PooledByteBuffer> imageRef,
+            final ImageRequest imageRequest,
+            boolean isLast) {
+        InputStream imageInputStream = new PooledByteBufferInputStream(imageRef.get());
+        ImageFormat imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(imageInputStream);
+
+        switch (imageFormat) {
+            case WEBP_SIMPLE:
+            case WEBP_LOSSLESS:
+            case WEBP_EXTENDED:
+            case WEBP_EXTENDED_WITH_ALPHA:
+                return TriState.valueOf(!WebpTranscoder.isWebpNativelySupported(imageFormat));
+            case UNKNOWN:
+                return isLast ? TriState.NO : TriState.UNSET;
+            default:
+                return TriState.NO;
+        }
+    }
+
+    @Override
+    protected void transform(
+            final CloseableReference<PooledByteBuffer> imageRef,
+            final PooledByteBufferOutputStream outputStream,
+            ImageRequest imageRequest,
+            Void unused) throws Exception {
+        InputStream imageInputStream = new PooledByteBufferInputStream(imageRef.get());
+        ImageFormat imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(imageInputStream);
+        switch (imageFormat) {
+            case WEBP_SIMPLE:
+            case WEBP_EXTENDED:
+                WebpTranscoder.transcodeWebpToJpeg(imageInputStream, outputStream, DEFAULT_JPEG_QUALITY);
+                break;
+
+            case WEBP_LOSSLESS:
+            case WEBP_EXTENDED_WITH_ALPHA:
+                WebpTranscoder.transcodeWebpToPng(imageInputStream, outputStream);
+                break;
+
+            default:
+                throw new IllegalArgumentException("Wrong image format");
+        }
+    }
+
+    @Override
+    protected CloseableReference<PooledByteBuffer> getImageCopy(
+            CloseableReference<PooledByteBuffer> originalResult) {
+        return originalResult.clone();
+    }
+
+    @Override
+    protected Void getExtraInformation(
+            CloseableReference<PooledByteBuffer> originalResult) {
+        return null;
+    }
+
+    @Override
+    protected CloseableReference<PooledByteBuffer> createReturnValue(
+            PooledByteBuffer transformedBytes,
+            Void unused) {
+        return CloseableReference.of(transformedBytes);
+    }
+
+    @Override
+    protected void closeReturnValue(CloseableReference<PooledByteBuffer> returnValue) {
+        CloseableReference.closeSafely(returnValue);
+    }
+
+    @Override
+    protected String getProducerName() {
+        return PRODUCER_NAME;
     }
-  }
-
-  @Override
-  protected void transform(
-      final CloseableReference<PooledByteBuffer> imageRef,
-      final PooledByteBufferOutputStream outputStream,
-      ImageRequest imageRequest,
-      Void unused) throws Exception {
-    InputStream imageInputStream = new PooledByteBufferInputStream(imageRef.get());
-    ImageFormat imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(imageInputStream);
-    switch (imageFormat) {
-      case WEBP_SIMPLE:
-      case WEBP_EXTENDED:
-        WebpTranscoder.transcodeWebpToJpeg(imageInputStream, outputStream, DEFAULT_JPEG_QUALITY);
-        break;
-
-      case WEBP_LOSSLESS:
-      case WEBP_EXTENDED_WITH_ALPHA:
-        WebpTranscoder.transcodeWebpToPng(imageInputStream, outputStream);
-        break;
-
-      default:
-        throw new IllegalArgumentException("Wrong image format");
+
+    @Override
+    protected boolean shouldAllowCancellation() {
+        return false;
     }
-  }
-
-  @Override
-  protected CloseableReference<PooledByteBuffer> getImageCopy(
-      CloseableReference<PooledByteBuffer> originalResult) {
-    return originalResult.clone();
-  }
-
-  @Override
-  protected Void getExtraInformation(
-      CloseableReference<PooledByteBuffer> originalResult) {
-    return null;
-  }
-
-  @Override
-  protected CloseableReference<PooledByteBuffer> createReturnValue(
-      PooledByteBuffer transformedBytes,
-      Void unused) {
-    return CloseableReference.of(transformedBytes);
-  }
-
-  @Override
-  protected void closeReturnValue(CloseableReference<PooledByteBuffer> returnValue) {
-    CloseableReference.closeSafely(returnValue);
-  }
-
-  @Override
-  protected String getProducerName() {
-    return PRODUCER_NAME;
-  }
-
-  @Override
-  protected boolean shouldAllowCancellation() {
-    return false;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/BasePostprocessor.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/BasePostprocessor.java
index 17c0caa2e..873a0b6bf 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/BasePostprocessor.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/BasePostprocessor.java
@@ -17,71 +17,71 @@
 
 /**
  * Base implementation of {@link Postprocessor} interface.
- *
+ * <p>
  * <p> Clients should override exactly one of the three provided {@link #process} methods.
  */
 public abstract class BasePostprocessor implements Postprocessor {
 
-  @Override
-  public String getName() {
-    return "Unknown postprocessor";
-  }
+    @Override
+    public String getName() {
+        return "Unknown postprocessor";
+    }
 
-  /**
-   * Clients should override this method only if the post-processed bitmap has to be of a different
-   * size than the source bitmap. If the post-processed bitmap is of the same size, clients should
-   * override one of the other two methods.
-   *
-   * <p> The source bitmap must not be modified as it may be shared by the other clients. The
-   * implementation must create a new bitmap that is safe to be modified and return a reference
-   * to it. Clients should use <code>bitmapFactory</code> to create a new bitmap.
-   *
-   * @param sourceBitmap The source bitmap.
-   * @param bitmapFactory The factory to create a destination bitmap.
-   * @return a reference to the newly created bitmap
-   */
-  @Override
-  public CloseableReference<Bitmap> process(
-      Bitmap sourceBitmap,
-      PlatformBitmapFactory bitmapFactory) {
-    CloseableReference<Bitmap> destBitmapRef =
-        bitmapFactory.createBitmap(sourceBitmap.getWidth(), sourceBitmap.getHeight());
-    try {
-      process(destBitmapRef.get(), sourceBitmap);
-      return CloseableReference.cloneOrNull(destBitmapRef);
-    } finally {
-      CloseableReference.closeSafely(destBitmapRef);
+    /**
+     * Clients should override this method only if the post-processed bitmap has to be of a different
+     * size than the source bitmap. If the post-processed bitmap is of the same size, clients should
+     * override one of the other two methods.
+     * <p>
+     * <p> The source bitmap must not be modified as it may be shared by the other clients. The
+     * implementation must create a new bitmap that is safe to be modified and return a reference
+     * to it. Clients should use <code>bitmapFactory</code> to create a new bitmap.
+     *
+     * @param sourceBitmap  The source bitmap.
+     * @param bitmapFactory The factory to create a destination bitmap.
+     * @return a reference to the newly created bitmap
+     */
+    @Override
+    public CloseableReference<Bitmap> process(
+            Bitmap sourceBitmap,
+            PlatformBitmapFactory bitmapFactory) {
+        CloseableReference<Bitmap> destBitmapRef =
+                bitmapFactory.createBitmap(sourceBitmap.getWidth(), sourceBitmap.getHeight());
+        try {
+            process(destBitmapRef.get(), sourceBitmap);
+            return CloseableReference.cloneOrNull(destBitmapRef);
+        } finally {
+            CloseableReference.closeSafely(destBitmapRef);
+        }
     }
-  }
 
-  /**
-   * Clients should override this method if the post-processing cannot be done in place. If the
-   * post-processing can be done in place, clients should override the {@link #process(Bitmap)}
-   * method.
-   *
-   * <p> The provided destination bitmap is of the same size as the source bitmap. There are no
-   * guarantees on the initial content of the destination bitmap, so the implementation has to make
-   * sure that it properly populates it.
-   *
-   * <p> The source bitmap must not be modified as it may be shared by the other clients.
-   * The implementation must use the provided destination bitmap as its output.
-   *
-   * @param destBitmap the destination bitmap to be used as output
-   * @param sourceBitmap the source bitmap to be used as input
-   */
-  public void process(Bitmap destBitmap, Bitmap sourceBitmap) {
-    Bitmaps.copyBitmap(destBitmap, sourceBitmap);
-    process(destBitmap);
-  }
+    /**
+     * Clients should override this method if the post-processing cannot be done in place. If the
+     * post-processing can be done in place, clients should override the {@link #process(Bitmap)}
+     * method.
+     * <p>
+     * <p> The provided destination bitmap is of the same size as the source bitmap. There are no
+     * guarantees on the initial content of the destination bitmap, so the implementation has to make
+     * sure that it properly populates it.
+     * <p>
+     * <p> The source bitmap must not be modified as it may be shared by the other clients.
+     * The implementation must use the provided destination bitmap as its output.
+     *
+     * @param destBitmap   the destination bitmap to be used as output
+     * @param sourceBitmap the source bitmap to be used as input
+     */
+    public void process(Bitmap destBitmap, Bitmap sourceBitmap) {
+        Bitmaps.copyBitmap(destBitmap, sourceBitmap);
+        process(destBitmap);
+    }
 
-  /**
-   * Clients should override this method if the post-processing can be done in place.
-   *
-   * <p> The provided bitmap is a copy of the source bitmap and the implementation is free to
-   * modify it.
-   *
-   * @param bitmap the bitmap to be used both as input and as output
-   */
-  public void process(Bitmap bitmap) {
-  }
+    /**
+     * Clients should override this method if the post-processing can be done in place.
+     * <p>
+     * <p> The provided bitmap is a copy of the source bitmap and the implementation is free to
+     * modify it.
+     *
+     * @param bitmap the bitmap to be used both as input and as output
+     */
+    public void process(Bitmap bitmap) {
+    }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/BaseRepeatedPostProcessor.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/BaseRepeatedPostProcessor.java
index e388eb9e7..72c9a72c6 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/BaseRepeatedPostProcessor.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/BaseRepeatedPostProcessor.java
@@ -10,22 +10,22 @@
 package com.facebook.imagepipeline.request;
 
 public abstract class BaseRepeatedPostProcessor extends BasePostprocessor
-    implements RepeatedPostprocessor {
-  private RepeatedPostprocessorRunner mCallback;
+        implements RepeatedPostprocessor {
+    private RepeatedPostprocessorRunner mCallback;
 
-  @Override
-  public synchronized void setCallback(RepeatedPostprocessorRunner runner) {
-    mCallback = runner;
-  }
+    @Override
+    public synchronized void setCallback(RepeatedPostprocessorRunner runner) {
+        mCallback = runner;
+    }
 
-  private synchronized RepeatedPostprocessorRunner getCallback() {
-    return mCallback;
-  }
+    private synchronized RepeatedPostprocessorRunner getCallback() {
+        return mCallback;
+    }
 
-  public void update() {
-    RepeatedPostprocessorRunner callback = getCallback();
-    if (callback != null) {
-      callback.update();
+    public void update() {
+        RepeatedPostprocessorRunner callback = getCallback();
+        if (callback != null) {
+            callback.update();
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequest.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequest.java
index 10066452a..956b1692a 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequest.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequest.java
@@ -26,168 +26,194 @@
 @Immutable
 public class ImageRequest {
 
-  /** image type */
-  private final ImageType mImageType;
-
-  /** Source Uri */
-  private final Uri mSourceUri;
-
-  /** Source File - for local fetches only, lazily initialized */
-  private File mSourceFile;
-
-  /** If set - the client will receive intermediate results */
-  private final boolean mProgressiveRenderingEnabled;
-
-  /** If set the client will receive thumbnail previews for local images, before the whole image */
-  private final boolean mLocalThumbnailPreviewsEnabled;
-
-  private final ImageDecodeOptions mImageDecodeOptions;
-
-  /** resize options */
-  @Nullable
-  ResizeOptions mResizeOptions = null;
-
-  /** Is auto-rotate enabled? */
-  private final boolean mAutoRotateEnabled;
-
-  /** Priority levels of this request. */
-  private final Priority mRequestPriority;
-
-  /** Lowest level that is permitted to fetch an image from */
-  private final RequestLevel mLowestPermittedRequestLevel;
-
-  /** Whether the disk cache should be used for this request */
-  private final boolean mIsDiskCacheEnabled;
-
-  /** Postprocessor to run on the output bitmap. */
-  private final Postprocessor mPostprocessor;
-
-  public static ImageRequest fromUri(@Nullable Uri uri) {
-    return (uri == null) ? null : ImageRequestBuilder.newBuilderWithSource(uri).build();
-  }
+    /**
+     * image type
+     */
+    private final ImageType mImageType;
+
+    /**
+     * Source Uri
+     */
+    private final Uri mSourceUri;
+
+    /**
+     * Source File - for local fetches only, lazily initialized
+     */
+    private File mSourceFile;
+
+    /**
+     * If set - the client will receive intermediate results
+     */
+    private final boolean mProgressiveRenderingEnabled;
+
+    /**
+     * If set the client will receive thumbnail previews for local images, before the whole image
+     */
+    private final boolean mLocalThumbnailPreviewsEnabled;
+
+    private final ImageDecodeOptions mImageDecodeOptions;
+
+    /**
+     * resize options
+     */
+    @Nullable
+    ResizeOptions mResizeOptions = null;
+
+    /**
+     * Is auto-rotate enabled?
+     */
+    private final boolean mAutoRotateEnabled;
+
+    /**
+     * Priority levels of this request.
+     */
+    private final Priority mRequestPriority;
+
+    /**
+     * Lowest level that is permitted to fetch an image from
+     */
+    private final RequestLevel mLowestPermittedRequestLevel;
+
+    /**
+     * Whether the disk cache should be used for this request
+     */
+    private final boolean mIsDiskCacheEnabled;
+
+    /**
+     * Postprocessor to run on the output bitmap.
+     */
+    private final Postprocessor mPostprocessor;
+
+    public static ImageRequest fromUri(@Nullable Uri uri) {
+        return (uri == null) ? null : ImageRequestBuilder.newBuilderWithSource(uri).build();
+    }
 
-  public static ImageRequest fromUri(@Nullable String uriString) {
-    return (uriString == null || uriString.length() == 0) ? null : fromUri(Uri.parse(uriString));
-  }
+    public static ImageRequest fromUri(@Nullable String uriString) {
+        return (uriString == null || uriString.length() == 0) ? null : fromUri(Uri.parse(uriString));
+    }
 
-  protected ImageRequest(ImageRequestBuilder builder) {
-    mImageType = builder.getImageType();
-    mSourceUri = builder.getSourceUri();
+    protected ImageRequest(ImageRequestBuilder builder) {
+        mImageType = builder.getImageType();
+        mSourceUri = builder.getSourceUri();
 
-    mProgressiveRenderingEnabled = builder.isProgressiveRenderingEnabled();
-    mLocalThumbnailPreviewsEnabled = builder.isLocalThumbnailPreviewsEnabled();
+        mProgressiveRenderingEnabled = builder.isProgressiveRenderingEnabled();
+        mLocalThumbnailPreviewsEnabled = builder.isLocalThumbnailPreviewsEnabled();
 
-    mImageDecodeOptions = builder.getImageDecodeOptions();
+        mImageDecodeOptions = builder.getImageDecodeOptions();
 
-    mResizeOptions = builder.getResizeOptions();
-    mAutoRotateEnabled = builder.isAutoRotateEnabled();
+        mResizeOptions = builder.getResizeOptions();
+        mAutoRotateEnabled = builder.isAutoRotateEnabled();
 
-    mRequestPriority = builder.getRequestPriority();
-    mLowestPermittedRequestLevel = builder.getLowestPermittedRequestLevel();
-    mIsDiskCacheEnabled = builder.isDiskCacheEnabled();
+        mRequestPriority = builder.getRequestPriority();
+        mLowestPermittedRequestLevel = builder.getLowestPermittedRequestLevel();
+        mIsDiskCacheEnabled = builder.isDiskCacheEnabled();
 
-    mPostprocessor = builder.getPostprocessor();
-  }
+        mPostprocessor = builder.getPostprocessor();
+    }
 
-  public ImageType getImageType() {
-    return mImageType;
-  }
+    public ImageType getImageType() {
+        return mImageType;
+    }
 
-  public Uri getSourceUri() {
-    return mSourceUri;
-  }
+    public Uri getSourceUri() {
+        return mSourceUri;
+    }
 
-  public int getPreferredWidth() {
-    return (mResizeOptions != null) ? mResizeOptions.width : -1;
-  }
+    public int getPreferredWidth() {
+        return (mResizeOptions != null) ? mResizeOptions.width : -1;
+    }
 
-  public int getPreferredHeight() {
-    return (mResizeOptions != null) ? mResizeOptions.height : -1;
-  }
+    public int getPreferredHeight() {
+        return (mResizeOptions != null) ? mResizeOptions.height : -1;
+    }
 
-  public @Nullable ResizeOptions getResizeOptions() {
-    return mResizeOptions;
-  }
+    public
+    @Nullable
+    ResizeOptions getResizeOptions() {
+        return mResizeOptions;
+    }
 
-  public ImageDecodeOptions getImageDecodeOptions() {
-    return mImageDecodeOptions;
-  }
+    public ImageDecodeOptions getImageDecodeOptions() {
+        return mImageDecodeOptions;
+    }
 
-  public boolean getAutoRotateEnabled() {
-    return mAutoRotateEnabled;
-  }
+    public boolean getAutoRotateEnabled() {
+        return mAutoRotateEnabled;
+    }
 
-  public boolean getProgressiveRenderingEnabled() {
-    return mProgressiveRenderingEnabled;
-  }
+    public boolean getProgressiveRenderingEnabled() {
+        return mProgressiveRenderingEnabled;
+    }
 
-  public boolean getLocalThumbnailPreviewsEnabled() {
-    return mLocalThumbnailPreviewsEnabled;
-  }
+    public boolean getLocalThumbnailPreviewsEnabled() {
+        return mLocalThumbnailPreviewsEnabled;
+    }
 
-  public Priority getPriority() {
-    return mRequestPriority;
-  }
+    public Priority getPriority() {
+        return mRequestPriority;
+    }
 
-  public RequestLevel getLowestPermittedRequestLevel() {
-    return mLowestPermittedRequestLevel;
-  }
+    public RequestLevel getLowestPermittedRequestLevel() {
+        return mLowestPermittedRequestLevel;
+    }
 
-  public boolean isDiskCacheEnabled() {
-    return mIsDiskCacheEnabled;
-  }
+    public boolean isDiskCacheEnabled() {
+        return mIsDiskCacheEnabled;
+    }
 
-  public synchronized File getSourceFile() {
-    if (mSourceFile == null) {
-      mSourceFile = new File(mSourceUri.getPath());
+    public synchronized File getSourceFile() {
+        if (mSourceFile == null) {
+            mSourceFile = new File(mSourceUri.getPath());
+        }
+        return mSourceFile;
     }
-    return mSourceFile;
-  }
 
-  public @Nullable Postprocessor getPostprocessor() {
-    return mPostprocessor;
-  }
+    public
+    @Nullable
+    Postprocessor getPostprocessor() {
+        return mPostprocessor;
+    }
 
-  /**
-   * An enum describing type of the image.
-   */
-  public enum ImageType {
-    /* Indicates that this image should go in the small disk cache, if one is being used */
-    SMALL,
+    /**
+     * An enum describing type of the image.
+     */
+    public enum ImageType {
+        /* Indicates that this image should go in the small disk cache, if one is being used */
+        SMALL,
 
-    /* Default */
-    DEFAULT,
-  }
+        /* Default */
+        DEFAULT,
+    }
 
-  /**
-   * Level down to we are willing to go in order to find an image. E.g., we might only want to go
-   * down to bitmap memory cache, and not check the disk cache or do a full fetch.
-   */
-  public enum RequestLevel {
-    /* Fetch (from the network or local storage) */
-    FULL_FETCH(1),
+    /**
+     * Level down to we are willing to go in order to find an image. E.g., we might only want to go
+     * down to bitmap memory cache, and not check the disk cache or do a full fetch.
+     */
+    public enum RequestLevel {
+        /* Fetch (from the network or local storage) */
+        FULL_FETCH(1),
 
-    /* Disk caching */
-    DISK_CACHE(2),
+        /* Disk caching */
+        DISK_CACHE(2),
 
-    /* Encoded memory caching */
-    ENCODED_MEMORY_CACHE(3),
+        /* Encoded memory caching */
+        ENCODED_MEMORY_CACHE(3),
 
-    /* Bitmap caching */
-    BITMAP_MEMORY_CACHE(4);
+        /* Bitmap caching */
+        BITMAP_MEMORY_CACHE(4);
 
-    private int mValue;
+        private int mValue;
 
-    private RequestLevel(int value) {
-      mValue = value;
-    }
+        private RequestLevel(int value) {
+            mValue = value;
+        }
 
-    public int getValue() {
-      return mValue;
-    }
+        public int getValue() {
+            return mValue;
+        }
 
-    public static RequestLevel getMax(RequestLevel requestLevel1, RequestLevel requestLevel2) {
-      return requestLevel1.getValue() > requestLevel2.getValue() ? requestLevel1 : requestLevel2;
+        public static RequestLevel getMax(RequestLevel requestLevel1, RequestLevel requestLevel2) {
+            return requestLevel1.getValue() > requestLevel2.getValue() ? requestLevel1 : requestLevel2;
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequestBuilder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequestBuilder.java
index c777a7d14..75259e83b 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequestBuilder.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/ImageRequestBuilder.java
@@ -27,248 +27,291 @@
  */
 public class ImageRequestBuilder {
 
-  private Uri mSourceUri = null;
-  private RequestLevel mLowestPermittedRequestLevel = RequestLevel.FULL_FETCH;
-  private boolean mAutoRotateEnabled = false;
-  private @Nullable ResizeOptions mResizeOptions = null;
-  private ImageDecodeOptions mImageDecodeOptions = ImageDecodeOptions.defaults();
-  private ImageType mImageType = ImageType.DEFAULT;
-  private boolean mProgressiveRenderingEnabled = false;
-  private boolean mLocalThumbnailPreviewsEnabled = false;
-  private Priority mRequestPriority = Priority.HIGH;
-  private @Nullable Postprocessor mPostprocessor = null;
-
-  /**
-   * Creates a new request builder instance. The setting will be done according to the source type.
-   * @param uri the uri to fetch
-   * @return a new request builder instance
-   */
-  public static ImageRequestBuilder newBuilderWithSource(Uri uri) {
-    return new ImageRequestBuilder().setSource(uri);
-  }
-
-  /**
-   * Creates a new request builder instance for a local resource image.
-   *
-   * <p>Only image resources can be used with the image pipeline (PNG, JPG, GIF). Other resource
-   * types such as Strings or XML Drawables make no sense in the context of the image pipeline and
-   * so cannot be supported. Attempts to do so will throw an
-   * {@link java.lang.IllegalArgumentException} when the pipeline tries to decode the resource.
-   *
-   * <p>One potentially confusing case is drawable declared in XML (e.g. ShapeDrawable). This is not
-   * an image. If you want to display an XML drawable as the main image, then set it as a
-   * placeholder and do not set a URI.
-   * <p/>
-   *
-   * @param resId local image resource id.
-   * @return a new request builder instance.
-   */
-  public static ImageRequestBuilder newBuilderWithResourceId(int resId) {
-    Uri uri = new Uri.Builder()
-        .scheme(UriUtil.LOCAL_RESOURCE_SCHEME)
-        .path(String.valueOf(resId))
-        .build();
-
-    return newBuilderWithSource(uri);
-  }
-
-  private ImageRequestBuilder() {
-  }
-
-  /**
-   * Sets the source uri (both network and local uris are supported).
-   * Note: this will enable disk caching for network sources, and disable it for local sources.
-   * @param uri the uri to fetch the image from
-   * @return the updated builder instance
-   */
-  public ImageRequestBuilder setSource(Uri uri) {
-    Preconditions.checkNotNull(uri);
-
-    mSourceUri = uri;
-    return this;
-  }
-
-  /** Gets the source Uri. */
-  public Uri getSourceUri() {
-    return mSourceUri;
-  }
-
-  /**
-   * Sets the lowest level that is permitted to request the image from.
-   * @param requestLevel the lowest request level that is allowed
-   * @return the updated builder instance
-   */
-  public ImageRequestBuilder setLowestPermittedRequestLevel(RequestLevel requestLevel) {
-    mLowestPermittedRequestLevel = requestLevel;
-    return this;
-  }
-
-  /** Gets the lowest permitted request level. */
-  public RequestLevel getLowestPermittedRequestLevel() {
-    return mLowestPermittedRequestLevel;
-  }
-
-  /**
-   * Enables or disables auto-rotate for the image in case image has orientation.
-   * @return the updated builder instance
-   * @param enabled
-   */
-  public ImageRequestBuilder setAutoRotateEnabled(boolean enabled) {
-    mAutoRotateEnabled = enabled;
-    return this;
-  }
-
-  /** Returns whether auto-rotate is enabled. */
-  public boolean isAutoRotateEnabled() {
-    return mAutoRotateEnabled;
-  }
-
-  /**
-   * Sets resize options in case resize should be performed.
-   * @param resizeOptions resize options
-   * @return the modified builder instance
-   */
-  public ImageRequestBuilder setResizeOptions(ResizeOptions resizeOptions) {
-    mResizeOptions = resizeOptions;
-    return this;
-  }
-
-  /** Gets the resize options if set, null otherwise. */
-  public @Nullable ResizeOptions getResizeOptions() {
-    return mResizeOptions;
-  }
-
-  public ImageRequestBuilder setImageDecodeOptions(ImageDecodeOptions imageDecodeOptions) {
-    mImageDecodeOptions = imageDecodeOptions;
-    return this;
-  }
-
-  public ImageDecodeOptions getImageDecodeOptions() {
-    return mImageDecodeOptions;
-  }
-
-  /**
-   * Sets the image type. Pipeline might use different caches and eviction policies for each
-   * image type.
-   * @param imageType the image type to set
-   * @return the modified builder instance
-   */
-  public ImageRequestBuilder setImageType(ImageType imageType) {
-    mImageType = imageType;
-    return this;
-  }
-
-  /** Gets the image type (profile image or default). */
-  public ImageType getImageType() {
-    return mImageType;
-  }
-
-  /**
-   * Enables or disables progressive rendering.
-   * @param enabled
-   * @return the modified builder instance
-   */
-  public ImageRequestBuilder setProgressiveRenderingEnabled(boolean enabled) {
-    mProgressiveRenderingEnabled = enabled;
-    return this;
-  }
-
-  /** Returns whether progressive loading is enabled. */
-  public boolean isProgressiveRenderingEnabled() {
-    return mProgressiveRenderingEnabled;
-  }
-
-  /**
-   * Enables or disables the use of local thumbnails as previews.
-   * @param enabled
-   * @return the modified builder instance
-   */
-  public ImageRequestBuilder setLocalThumbnailPreviewsEnabled(boolean enabled) {
-    mLocalThumbnailPreviewsEnabled = enabled;
-    return this;
-  }
-
-  /** Returns whether the use of local thumbnails for previews is enabled */
-  public boolean isLocalThumbnailPreviewsEnabled() {
-    return mLocalThumbnailPreviewsEnabled;
-  }
-
-  /** Returns whether the use of the disk cache is enabled */
-  public boolean isDiskCacheEnabled() {
-    return UriUtil.isNetworkUri(mSourceUri);
-  }
-
-  /**
-   * Set priority for the request.
-   * @param requestPriority
-   * @return the modified builder instance
-   */
-  public ImageRequestBuilder setRequestPriority(Priority requestPriority) {
-    mRequestPriority = requestPriority;
-    return this;
-  }
-
-  /** Returns the request priority */
-  public Priority getRequestPriority() {
-    return mRequestPriority;
-  }
-
-  /**
-   * Sets the postprocessor.
-   * @param postprocessor postprocessor to postprocess the output bitmap with.
-   */
-  public ImageRequestBuilder setPostprocessor(Postprocessor postprocessor) {
-    mPostprocessor = postprocessor;
-    return this;
-  }
-
-  /** Gets postprocessor if set, null otherwise. */
-  public @Nullable Postprocessor getPostprocessor() {
-    return mPostprocessor;
-  }
-
-  /**
-   * Builds the Request.
-   * @return a valid image request
-   */
-  public ImageRequest build() {
-    validate();
-    return new ImageRequest(this);
-  }
-
-  /** An exception class for builder methods. */
-  public static class BuilderException extends RuntimeException {
-    public BuilderException(String message) {
-      super("Invalid request builder: " + message);
+    private Uri mSourceUri = null;
+    private RequestLevel mLowestPermittedRequestLevel = RequestLevel.FULL_FETCH;
+    private boolean mAutoRotateEnabled = false;
+    private
+    @Nullable
+    ResizeOptions mResizeOptions = null;
+    private ImageDecodeOptions mImageDecodeOptions = ImageDecodeOptions.defaults();
+    private ImageType mImageType = ImageType.DEFAULT;
+    private boolean mProgressiveRenderingEnabled = false;
+    private boolean mLocalThumbnailPreviewsEnabled = false;
+    private Priority mRequestPriority = Priority.HIGH;
+    private
+    @Nullable
+    Postprocessor mPostprocessor = null;
+
+    /**
+     * Creates a new request builder instance. The setting will be done according to the source type.
+     *
+     * @param uri the uri to fetch
+     * @return a new request builder instance
+     */
+    public static ImageRequestBuilder newBuilderWithSource(Uri uri) {
+        return new ImageRequestBuilder().setSource(uri);
     }
-  }
 
-  /** Performs validation. */
-  protected void validate() {
-    // make sure that the source uri is set correctly.
-    if (mSourceUri == null) {
-      throw new BuilderException("Source must be set!");
+    /**
+     * Creates a new request builder instance for a local resource image.
+     * <p>
+     * <p>Only image resources can be used with the image pipeline (PNG, JPG, GIF). Other resource
+     * types such as Strings or XML Drawables make no sense in the context of the image pipeline and
+     * so cannot be supported. Attempts to do so will throw an
+     * {@link java.lang.IllegalArgumentException} when the pipeline tries to decode the resource.
+     * <p>
+     * <p>One potentially confusing case is drawable declared in XML (e.g. ShapeDrawable). This is not
+     * an image. If you want to display an XML drawable as the main image, then set it as a
+     * placeholder and do not set a URI.
+     * <p>
+     *
+     * @param resId local image resource id.
+     * @return a new request builder instance.
+     */
+    public static ImageRequestBuilder newBuilderWithResourceId(int resId) {
+        Uri uri = new Uri.Builder()
+                .scheme(UriUtil.LOCAL_RESOURCE_SCHEME)
+                .path(String.valueOf(resId))
+                .build();
+
+        return newBuilderWithSource(uri);
     }
 
-    // For local resource we require caller to specify statically generated resource id as a path.
-    if (UriUtil.isLocalResourceUri(mSourceUri)) {
-      if (!mSourceUri.isAbsolute()) {
-        throw new BuilderException("Resource URI path must be absolute.");
-      }
-      if (mSourceUri.getPath().isEmpty()) {
-        throw new BuilderException("Resource URI must not be empty");
-      }
-      try {
-        Integer.parseInt(mSourceUri.getPath().substring(1));
-      } catch (NumberFormatException ignored) {
-        throw new BuilderException("Resource URI path must be a resource id.");
-      }
+    private ImageRequestBuilder() {
     }
 
-    // For local asset we require caller to specify absolute path of an asset, which will be
-    // resolved by AssetManager relative to configured asset folder of an app.
-    if (UriUtil.isLocalAssetUri(mSourceUri) && !mSourceUri.isAbsolute()) {
-      throw new BuilderException("Asset URI path must be absolute.");
+    /**
+     * Sets the source uri (both network and local uris are supported).
+     * Note: this will enable disk caching for network sources, and disable it for local sources.
+     *
+     * @param uri the uri to fetch the image from
+     * @return the updated builder instance
+     */
+    public ImageRequestBuilder setSource(Uri uri) {
+        Preconditions.checkNotNull(uri);
+
+        mSourceUri = uri;
+        return this;
+    }
+
+    /**
+     * Gets the source Uri.
+     */
+    public Uri getSourceUri() {
+        return mSourceUri;
+    }
+
+    /**
+     * Sets the lowest level that is permitted to request the image from.
+     *
+     * @param requestLevel the lowest request level that is allowed
+     * @return the updated builder instance
+     */
+    public ImageRequestBuilder setLowestPermittedRequestLevel(RequestLevel requestLevel) {
+        mLowestPermittedRequestLevel = requestLevel;
+        return this;
+    }
+
+    /**
+     * Gets the lowest permitted request level.
+     */
+    public RequestLevel getLowestPermittedRequestLevel() {
+        return mLowestPermittedRequestLevel;
+    }
+
+    /**
+     * Enables or disables auto-rotate for the image in case image has orientation.
+     *
+     * @param enabled
+     * @return the updated builder instance
+     */
+    public ImageRequestBuilder setAutoRotateEnabled(boolean enabled) {
+        mAutoRotateEnabled = enabled;
+        return this;
+    }
+
+    /**
+     * Returns whether auto-rotate is enabled.
+     */
+    public boolean isAutoRotateEnabled() {
+        return mAutoRotateEnabled;
+    }
+
+    /**
+     * Sets resize options in case resize should be performed.
+     *
+     * @param resizeOptions resize options
+     * @return the modified builder instance
+     */
+    public ImageRequestBuilder setResizeOptions(ResizeOptions resizeOptions) {
+        mResizeOptions = resizeOptions;
+        return this;
+    }
+
+    /**
+     * Gets the resize options if set, null otherwise.
+     */
+    public
+    @Nullable
+    ResizeOptions getResizeOptions() {
+        return mResizeOptions;
+    }
+
+    public ImageRequestBuilder setImageDecodeOptions(ImageDecodeOptions imageDecodeOptions) {
+        mImageDecodeOptions = imageDecodeOptions;
+        return this;
+    }
+
+    public ImageDecodeOptions getImageDecodeOptions() {
+        return mImageDecodeOptions;
+    }
+
+    /**
+     * Sets the image type. Pipeline might use different caches and eviction policies for each
+     * image type.
+     *
+     * @param imageType the image type to set
+     * @return the modified builder instance
+     */
+    public ImageRequestBuilder setImageType(ImageType imageType) {
+        mImageType = imageType;
+        return this;
+    }
+
+    /**
+     * Gets the image type (profile image or default).
+     */
+    public ImageType getImageType() {
+        return mImageType;
+    }
+
+    /**
+     * Enables or disables progressive rendering.
+     *
+     * @param enabled
+     * @return the modified builder instance
+     */
+    public ImageRequestBuilder setProgressiveRenderingEnabled(boolean enabled) {
+        mProgressiveRenderingEnabled = enabled;
+        return this;
+    }
+
+    /**
+     * Returns whether progressive loading is enabled.
+     */
+    public boolean isProgressiveRenderingEnabled() {
+        return mProgressiveRenderingEnabled;
+    }
+
+    /**
+     * Enables or disables the use of local thumbnails as previews.
+     *
+     * @param enabled
+     * @return the modified builder instance
+     */
+    public ImageRequestBuilder setLocalThumbnailPreviewsEnabled(boolean enabled) {
+        mLocalThumbnailPreviewsEnabled = enabled;
+        return this;
+    }
+
+    /**
+     * Returns whether the use of local thumbnails for previews is enabled
+     */
+    public boolean isLocalThumbnailPreviewsEnabled() {
+        return mLocalThumbnailPreviewsEnabled;
+    }
+
+    /**
+     * Returns whether the use of the disk cache is enabled
+     */
+    public boolean isDiskCacheEnabled() {
+        return UriUtil.isNetworkUri(mSourceUri);
+    }
+
+    /**
+     * Set priority for the request.
+     *
+     * @param requestPriority
+     * @return the modified builder instance
+     */
+    public ImageRequestBuilder setRequestPriority(Priority requestPriority) {
+        mRequestPriority = requestPriority;
+        return this;
+    }
+
+    /**
+     * Returns the request priority
+     */
+    public Priority getRequestPriority() {
+        return mRequestPriority;
+    }
+
+    /**
+     * Sets the postprocessor.
+     *
+     * @param postprocessor postprocessor to postprocess the output bitmap with.
+     */
+    public ImageRequestBuilder setPostprocessor(Postprocessor postprocessor) {
+        mPostprocessor = postprocessor;
+        return this;
+    }
+
+    /**
+     * Gets postprocessor if set, null otherwise.
+     */
+    public
+    @Nullable
+    Postprocessor getPostprocessor() {
+        return mPostprocessor;
+    }
+
+    /**
+     * Builds the Request.
+     *
+     * @return a valid image request
+     */
+    public ImageRequest build() {
+        validate();
+        return new ImageRequest(this);
+    }
+
+    /**
+     * An exception class for builder methods.
+     */
+    public static class BuilderException extends RuntimeException {
+        public BuilderException(String message) {
+            super("Invalid request builder: " + message);
+        }
+    }
+
+    /**
+     * Performs validation.
+     */
+    protected void validate() {
+        // make sure that the source uri is set correctly.
+        if (mSourceUri == null) {
+            throw new BuilderException("Source must be set!");
+        }
+
+        // For local resource we require caller to specify statically generated resource id as a path.
+        if (UriUtil.isLocalResourceUri(mSourceUri)) {
+            if (!mSourceUri.isAbsolute()) {
+                throw new BuilderException("Resource URI path must be absolute.");
+            }
+            if (mSourceUri.getPath().isEmpty()) {
+                throw new BuilderException("Resource URI must not be empty");
+            }
+            try {
+                Integer.parseInt(mSourceUri.getPath().substring(1));
+            } catch (NumberFormatException ignored) {
+                throw new BuilderException("Resource URI path must be a resource id.");
+            }
+        }
+
+        // For local asset we require caller to specify absolute path of an asset, which will be
+        // resolved by AssetManager relative to configured asset folder of an app.
+        if (UriUtil.isLocalAssetUri(mSourceUri) && !mSourceUri.isAbsolute()) {
+            throw new BuilderException("Asset URI path must be absolute.");
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/Postprocessor.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/Postprocessor.java
index a6ad8a338..b43284d6c 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/Postprocessor.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/Postprocessor.java
@@ -19,22 +19,22 @@
  */
 public interface Postprocessor {
 
-  /**
-   * Called by the pipeline after completing other steps.
-   *
-   * @param sourceBitmap The source bitmap.
-   * @param bitmapFactory The factory to create a destination bitmap.
-   *
-   * <p> The Postprocessor must not modify the source bitmap as it may be shared by the other
-   * clients. The implementation must create a new bitmap that is safe to be modified and return a
-   * reference to it. To create a bitmap, use the provided <code>bitmapFactory</code>.
-   */
-  CloseableReference<Bitmap> process(Bitmap sourceBitmap, PlatformBitmapFactory bitmapFactory);
+    /**
+     * Called by the pipeline after completing other steps.
+     *
+     * @param sourceBitmap  The source bitmap.
+     * @param bitmapFactory The factory to create a destination bitmap.
+     *                      <p>
+     *                      <p> The Postprocessor must not modify the source bitmap as it may be shared by the other
+     *                      clients. The implementation must create a new bitmap that is safe to be modified and return a
+     *                      reference to it. To create a bitmap, use the provided <code>bitmapFactory</code>.
+     */
+    CloseableReference<Bitmap> process(Bitmap sourceBitmap, PlatformBitmapFactory bitmapFactory);
 
-  /**
-   * Returns the name of this postprocessor.
-   *
-   * <p>Used for logging and analytics.
-   */
-  String getName();
+    /**
+     * Returns the name of this postprocessor.
+     * <p>
+     * <p>Used for logging and analytics.
+     */
+    String getName();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/RepeatedPostprocessor.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/RepeatedPostprocessor.java
index 980a69512..d9f6f6809 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/RepeatedPostprocessor.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/RepeatedPostprocessor.java
@@ -12,15 +12,16 @@
 /**
  * Use an instance of this interface to perform post-process operations that must be performed
  * more than once.
- *
+ * <p>
  * <p>Postprocessors are not supported on Gingerbread and below.
  */
 public interface RepeatedPostprocessor extends Postprocessor {
 
-  /**
-   * Callback used to pass the postprocessor a reference to the object that will run the
-   * postprocessor's {@code PostProcessor#process} method when the client requires.
-   * @param runner
-   */
-  void setCallback(RepeatedPostprocessorRunner runner);
+    /**
+     * Callback used to pass the postprocessor a reference to the object that will run the
+     * postprocessor's {@code PostProcessor#process} method when the client requires.
+     *
+     * @param runner
+     */
+    void setCallback(RepeatedPostprocessorRunner runner);
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/RepeatedPostprocessorRunner.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/RepeatedPostprocessorRunner.java
index fd061ea02..7f7093319 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/request/RepeatedPostprocessorRunner.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/request/RepeatedPostprocessorRunner.java
@@ -14,5 +14,5 @@
  */
 public interface RepeatedPostprocessorRunner {
 
-  void update();
+    void update();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPFrame.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPFrame.java
index 4f8deab63..263fa7333 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPFrame.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPFrame.java
@@ -22,77 +22,86 @@
 @ThreadSafe
 public class WebPFrame implements AnimatedImageFrame {
 
-  // Accessed by native methods
-  @SuppressWarnings("unused")
-  @DoNotStrip
-  private int mNativeContext;
-
-  /**
-   * Constructs the frame with the native pointer. This is called by native code.
-   *
-   * @param nativeContext the native pointer
-   */
-  @DoNotStrip
-  WebPFrame(int nativeContext) {
-    mNativeContext = nativeContext;
-  }
-
-  @Override
-  protected void finalize() {
-    nativeFinalize();
-  }
-
-  @Override
-  public void dispose() {
-    nativeDispose();
-  }
-
-  @Override
-  public void renderFrame(int width, int height, Bitmap bitmap) {
-    nativeRenderFrame(width, height, bitmap);
-  }
-
-  @Override
-  public int getDurationMs() {
-    return nativeGetDurationMs();
-  }
-
-  @Override
-  public int getWidth() {
-    return nativeGetWidth();
-  }
-
-  @Override
-  public int getHeight() {
-    return nativeGetHeight();
-  }
-
-  @Override
-  public int getXOffset() {
-    return nativeGetXOffset();
-  }
-
-  @Override
-  public int getYOffset() {
-    return nativeGetYOffset();
-  }
-
-  public boolean shouldDisposeToBackgroundColor() {
-    return nativeShouldDisposeToBackgroundColor();
-  }
-
-  public boolean shouldBlendWithPreviousFrame() {
-    return nativeShouldBlendWithPreviousFrame();
-  }
-
-  private native void nativeRenderFrame(int width, int height, Bitmap bitmap);
-  private native int nativeGetDurationMs();
-  private native int nativeGetWidth();
-  private native int nativeGetHeight();
-  private native int nativeGetXOffset();
-  private native int nativeGetYOffset();
-  private native boolean nativeShouldDisposeToBackgroundColor();
-  private native boolean nativeShouldBlendWithPreviousFrame();
-  private native void nativeDispose();
-  private native void nativeFinalize();
+    // Accessed by native methods
+    @SuppressWarnings("unused")
+    @DoNotStrip
+    private int mNativeContext;
+
+    /**
+     * Constructs the frame with the native pointer. This is called by native code.
+     *
+     * @param nativeContext the native pointer
+     */
+    @DoNotStrip
+    WebPFrame(int nativeContext) {
+        mNativeContext = nativeContext;
+    }
+
+    @Override
+    protected void finalize() {
+        nativeFinalize();
+    }
+
+    @Override
+    public void dispose() {
+        nativeDispose();
+    }
+
+    @Override
+    public void renderFrame(int width, int height, Bitmap bitmap) {
+        nativeRenderFrame(width, height, bitmap);
+    }
+
+    @Override
+    public int getDurationMs() {
+        return nativeGetDurationMs();
+    }
+
+    @Override
+    public int getWidth() {
+        return nativeGetWidth();
+    }
+
+    @Override
+    public int getHeight() {
+        return nativeGetHeight();
+    }
+
+    @Override
+    public int getXOffset() {
+        return nativeGetXOffset();
+    }
+
+    @Override
+    public int getYOffset() {
+        return nativeGetYOffset();
+    }
+
+    public boolean shouldDisposeToBackgroundColor() {
+        return nativeShouldDisposeToBackgroundColor();
+    }
+
+    public boolean shouldBlendWithPreviousFrame() {
+        return nativeShouldBlendWithPreviousFrame();
+    }
+
+    private native void nativeRenderFrame(int width, int height, Bitmap bitmap);
+
+    private native int nativeGetDurationMs();
+
+    private native int nativeGetWidth();
+
+    private native int nativeGetHeight();
+
+    private native int nativeGetXOffset();
+
+    private native int nativeGetYOffset();
+
+    private native boolean nativeShouldDisposeToBackgroundColor();
+
+    private native boolean nativeShouldBlendWithPreviousFrame();
+
+    private native void nativeDispose();
+
+    private native void nativeFinalize();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPImage.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPImage.java
index 622c2eab9..8573f394e 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPImage.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/webp/WebPImage.java
@@ -28,138 +28,149 @@
 @ThreadSafe
 public class WebPImage implements AnimatedImage {
 
-  private volatile static boolean sInitialized;
-
-  // Accessed by native methods
-  @SuppressWarnings("unused")
-  @DoNotStrip
-  private int mNativeContext;
-
-  private static synchronized void ensure() {
-    if (!sInitialized) {
-      sInitialized = true;
-      SoLoaderShim.loadLibrary("webp");
-      SoLoaderShim.loadLibrary("webpimage");
-    }
-  }
-
-  /**
-   * Constructs the image with the native pointer. This is called by native code.
-   *
-   * @param nativeContext the native pointer
-   */
-  @DoNotStrip
-  WebPImage(int nativeContext) {
-    mNativeContext = nativeContext;
-  }
-
-  @Override
-  protected void finalize() {
-    nativeFinalize();
-  }
-
-  @Override
-  public void dispose() {
-    nativeDispose();
-  }
-
-  /**
-   * Creates a {@link WebPImage} from the specified encoded data. This will throw if it fails
-   * to create. This is meant to be called on a worker thread.
-   *
-   * @param source the data to the image (a copy will be made)
-   */
-  public static WebPImage create(byte[] source) {
-    ensure();
-    Preconditions.checkNotNull(source);
-
-    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(source.length);
-    byteBuffer.put(source);
-    byteBuffer.rewind();
-
-    return nativeCreateFromDirectByteBuffer(byteBuffer);
-  }
-
-  public static WebPImage create(long nativePtr, int sizeInBytes) {
-    ensure();
-    Preconditions.checkArgument(nativePtr != 0);
-    return nativeCreateFromNativeMemory(nativePtr, sizeInBytes);
-  }
-
-  @Override
-  public int getWidth() {
-    return nativeGetWidth();
-  }
-
-  @Override
-  public int getHeight() {
-    return nativeGetHeight();
-  }
-
-  @Override
-  public int getFrameCount() {
-    return nativeGetFrameCount();
-  }
-
-  @Override
-  public int getDuration() {
-    return nativeGetDuration();
-  }
-
-  @Override
-  public int[] getFrameDurations() {
-    return nativeGetFrameDurations();
-  }
-
-  @Override
-  public int getLoopCount() {
-    return nativeGetLoopCount();
-  }
-
-  @Override
-  public WebPFrame getFrame(int frameNumber) {
-    return nativeGetFrame(frameNumber);
-  }
-
-  @Override
-  public int getSizeInBytes() {
-    return nativeGetSizeInBytes();
-  }
-
-  @Override
-  public boolean doesRenderSupportScaling() {
-    return true;
-  }
-
-  @Override
-  public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
-    WebPFrame frame = getFrame(frameNumber);
-    try {
-      return new AnimatedDrawableFrameInfo(
-          frameNumber,
-          frame.getXOffset(),
-          frame.getYOffset(),
-          frame.getWidth(),
-          frame.getHeight(),
-          frame.shouldBlendWithPreviousFrame(),
-          frame.shouldDisposeToBackgroundColor() ?
-              DisposalMethod.DISPOSE_TO_BACKGROUND :
-              DisposalMethod.DISPOSE_DO_NOT);
-    } finally {
-      frame.dispose();
-    }
-  }
-
-  private static native WebPImage nativeCreateFromDirectByteBuffer(ByteBuffer buffer);
-  private static native WebPImage nativeCreateFromNativeMemory(long nativePtr, int sizeInBytes);
-  private native int nativeGetWidth();
-  private native int nativeGetHeight();
-  private native int nativeGetDuration();
-  private native int nativeGetFrameCount();
-  private native int[] nativeGetFrameDurations();
-  private native int nativeGetLoopCount();
-  private native WebPFrame nativeGetFrame(int frameNumber);
-  private native int nativeGetSizeInBytes();
-  private native void nativeDispose();
-  private native void nativeFinalize();
+    private volatile static boolean sInitialized;
+
+    // Accessed by native methods
+    @SuppressWarnings("unused")
+    @DoNotStrip
+    private int mNativeContext;
+
+    private static synchronized void ensure() {
+        if (!sInitialized) {
+            sInitialized = true;
+            SoLoaderShim.loadLibrary("webp");
+            SoLoaderShim.loadLibrary("webpimage");
+        }
+    }
+
+    /**
+     * Constructs the image with the native pointer. This is called by native code.
+     *
+     * @param nativeContext the native pointer
+     */
+    @DoNotStrip
+    WebPImage(int nativeContext) {
+        mNativeContext = nativeContext;
+    }
+
+    @Override
+    protected void finalize() {
+        nativeFinalize();
+    }
+
+    @Override
+    public void dispose() {
+        nativeDispose();
+    }
+
+    /**
+     * Creates a {@link WebPImage} from the specified encoded data. This will throw if it fails
+     * to create. This is meant to be called on a worker thread.
+     *
+     * @param source the data to the image (a copy will be made)
+     */
+    public static WebPImage create(byte[] source) {
+        ensure();
+        Preconditions.checkNotNull(source);
+
+        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(source.length);
+        byteBuffer.put(source);
+        byteBuffer.rewind();
+
+        return nativeCreateFromDirectByteBuffer(byteBuffer);
+    }
+
+    public static WebPImage create(long nativePtr, int sizeInBytes) {
+        ensure();
+        Preconditions.checkArgument(nativePtr != 0);
+        return nativeCreateFromNativeMemory(nativePtr, sizeInBytes);
+    }
+
+    @Override
+    public int getWidth() {
+        return nativeGetWidth();
+    }
+
+    @Override
+    public int getHeight() {
+        return nativeGetHeight();
+    }
+
+    @Override
+    public int getFrameCount() {
+        return nativeGetFrameCount();
+    }
+
+    @Override
+    public int getDuration() {
+        return nativeGetDuration();
+    }
+
+    @Override
+    public int[] getFrameDurations() {
+        return nativeGetFrameDurations();
+    }
+
+    @Override
+    public int getLoopCount() {
+        return nativeGetLoopCount();
+    }
+
+    @Override
+    public WebPFrame getFrame(int frameNumber) {
+        return nativeGetFrame(frameNumber);
+    }
+
+    @Override
+    public int getSizeInBytes() {
+        return nativeGetSizeInBytes();
+    }
+
+    @Override
+    public boolean doesRenderSupportScaling() {
+        return true;
+    }
+
+    @Override
+    public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
+        WebPFrame frame = getFrame(frameNumber);
+        try {
+            return new AnimatedDrawableFrameInfo(
+                    frameNumber,
+                    frame.getXOffset(),
+                    frame.getYOffset(),
+                    frame.getWidth(),
+                    frame.getHeight(),
+                    frame.shouldBlendWithPreviousFrame(),
+                    frame.shouldDisposeToBackgroundColor() ?
+                            DisposalMethod.DISPOSE_TO_BACKGROUND :
+                            DisposalMethod.DISPOSE_DO_NOT);
+        } finally {
+            frame.dispose();
+        }
+    }
+
+    private static native WebPImage nativeCreateFromDirectByteBuffer(ByteBuffer buffer);
+
+    private static native WebPImage nativeCreateFromNativeMemory(long nativePtr, int sizeInBytes);
+
+    private native int nativeGetWidth();
+
+    private native int nativeGetHeight();
+
+    private native int nativeGetDuration();
+
+    private native int nativeGetFrameCount();
+
+    private native int[] nativeGetFrameDurations();
+
+    private native int nativeGetLoopCount();
+
+    private native WebPFrame nativeGetFrame(int frameNumber);
+
+    private native int nativeGetSizeInBytes();
+
+    private native void nativeDispose();
+
+    private native void nativeFinalize();
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imageutils/JfifUtil.java b/imagepipeline/src/main/java/com/facebook/imageutils/JfifUtil.java
index 9bee32273..303a466f6 100644
--- a/imagepipeline/src/main/java/com/facebook/imageutils/JfifUtil.java
+++ b/imagepipeline/src/main/java/com/facebook/imageutils/JfifUtil.java
@@ -23,185 +23,192 @@
  */
 public class JfifUtil {
 
-  private static final Class<?> TAG = JfifUtil.class;
-
-  /**
-   * Definitions of jpeg markers as well as overall description of jpeg file format can be found
-   * here: <a href="http://www.w3.org/Graphics/JPEG/itu-t81.pdf">Recommendation T.81</a>
-   */
-  public static final int MARKER_FIRST_BYTE = 0xFF;
-  public static final int MARKER_ESCAPE_BYTE = 0x00;
-  public static final int MARKER_SOI = 0xD8;
-  public static final int MARKER_TEM = 0x01;
-  public static final int MARKER_EOI = 0xD9;
-  public static final int MARKER_SOS = 0xDA;
-  public static final int MARKER_APP1 = 0xE1;
-  public static final int MARKER_SOFn = 0xC0;
-  public static final int MARKER_RST0 = 0xD0;
-  public static final int MARKER_RST7 = 0xD7;
-  public static final int APP1_EXIF_MAGIC = 0x45786966;
-
-  private JfifUtil() {
-  }
-
-  /**
-   * Determines auto-rotate angle based on orientation information.
-   * @param orientation orientation information, one of {1, 3, 6, 8}.
-   * @return orientation: 1/3/6/8 -> 0/180/90/270.
-   */
-  public static int getAutoRotateAngleFromOrientation(int orientation) {
-    return TiffUtil.getAutoRotateAngleFromOrientation(orientation);
-  }
-
-  /**
-   * Gets orientation information from jpeg byte array.
-   * @param jpeg the input byte array of jpeg image
-   * @return orientation: 1/8/3/6. Returns 0 if there is no valid orientation information.
-   */
-  public static int getOrientation(byte[] jpeg) {
-    // wrapping with ByteArrayInputStream is cheap and we don't have duplicate implementation
-    return getOrientation(new ByteArrayInputStream(jpeg));
-  }
-
-  /**
-   * Get orientation information from jpeg input stream.
-   * @param is the input stream of jpeg image
-   * @return orientation: 1/8/3/6. Returns 0 if there is no valid orientation information.
-   */
-  public static int getOrientation(InputStream is) {
-    try {
-      int length = moveToAPP1EXIF(is);
-      if (length == 0) {
-        return 0; // unknown orientation
-      }
-      return TiffUtil.readOrientationFromTIFF(is, length);
-    } catch (IOException ioe) {
-      return 0;
+    private static final Class<?> TAG = JfifUtil.class;
+
+    /**
+     * Definitions of jpeg markers as well as overall description of jpeg file format can be found
+     * here: <a href="http://www.w3.org/Graphics/JPEG/itu-t81.pdf">Recommendation T.81</a>
+     */
+    public static final int MARKER_FIRST_BYTE = 0xFF;
+    public static final int MARKER_ESCAPE_BYTE = 0x00;
+    public static final int MARKER_SOI = 0xD8;
+    public static final int MARKER_TEM = 0x01;
+    public static final int MARKER_EOI = 0xD9;
+    public static final int MARKER_SOS = 0xDA;
+    public static final int MARKER_APP1 = 0xE1;
+    public static final int MARKER_SOFn = 0xC0;
+    public static final int MARKER_RST0 = 0xD0;
+    public static final int MARKER_RST7 = 0xD7;
+    public static final int APP1_EXIF_MAGIC = 0x45786966;
+
+    private JfifUtil() {
     }
-  }
-
-  /**
-   * Get image width and height from jpeg header
-   * @param jpeg the input byte array of jpeg image
-   * @return dimensions of the image in form of Rect.
-   */
-  public static Rect getDimensions(byte[] jpeg) {
-    // wrapping with ByteArrayInputStream is cheap and we don't have duplicate implementation
-    return getDimensions(new ByteArrayInputStream(jpeg));
-  }
-
-  /**
-   * Get image width and height from jpeg header
-   * @param is the input stream of jpeg image
-   * @return dimensions of the image in form of Rect
-   */
-  public static Rect getDimensions(InputStream is) {
-    try {
-      if (moveToMarker(is, MARKER_SOFn)) {
-        // read block length
-        // subtract 2 as length contain SIZE field we just read
-        int length = StreamProcessor.readPackedInt(is, 2, false) - 2;
-        if (length > 6) {
-          // SOFn structure: 0xFFCn|length(2)|bitDepth(1)|height(2)|width(2)|...
-          int bitDepth = StreamProcessor.readPackedInt(is, 1, false);
-          int height = StreamProcessor.readPackedInt(is, 2, false);
-          int width = StreamProcessor.readPackedInt(is, 2, false);
-          return new Rect(0, 0, width, height);
+
+    /**
+     * Determines auto-rotate angle based on orientation information.
+     *
+     * @param orientation orientation information, one of {1, 3, 6, 8}.
+     * @return orientation: 1/3/6/8 -> 0/180/90/270.
+     */
+    public static int getAutoRotateAngleFromOrientation(int orientation) {
+        return TiffUtil.getAutoRotateAngleFromOrientation(orientation);
+    }
+
+    /**
+     * Gets orientation information from jpeg byte array.
+     *
+     * @param jpeg the input byte array of jpeg image
+     * @return orientation: 1/8/3/6. Returns 0 if there is no valid orientation information.
+     */
+    public static int getOrientation(byte[] jpeg) {
+        // wrapping with ByteArrayInputStream is cheap and we don't have duplicate implementation
+        return getOrientation(new ByteArrayInputStream(jpeg));
+    }
+
+    /**
+     * Get orientation information from jpeg input stream.
+     *
+     * @param is the input stream of jpeg image
+     * @return orientation: 1/8/3/6. Returns 0 if there is no valid orientation information.
+     */
+    public static int getOrientation(InputStream is) {
+        try {
+            int length = moveToAPP1EXIF(is);
+            if (length == 0) {
+                return 0; // unknown orientation
+            }
+            return TiffUtil.readOrientationFromTIFF(is, length);
+        } catch (IOException ioe) {
+            return 0;
         }
-      }
-    } catch (IOException ioe) {
-      FLog.e(TAG, ioe, "%x: getDimensions", is.hashCode());
-      // log and return null.
     }
-    return null;
-  }
-
-  /**
-   *  Reads the content of the input stream until specified marker is found. Marker will be
-   *  consumed and the input stream will be positioned after the specified marker.
-   *  @param is the input stream to read bytes from
-   *  @param markerToFind the marker we are looking for
-   *  @return boolean: whether or not we found the expected marker from input stream.
-   */
-  public static boolean moveToMarker(InputStream is, int markerToFind) throws IOException {
-    Preconditions.checkNotNull(is);
-    // ISO/IEC 10918-1:1993(E)
-    while (StreamProcessor.readPackedInt(is, 1, false) == MARKER_FIRST_BYTE) {
-      int marker = MARKER_FIRST_BYTE;
-      while (marker == MARKER_FIRST_BYTE) {
-        marker = StreamProcessor.readPackedInt(is, 1, false);
-      }
-
-      if (markerToFind == MARKER_SOFn && isSOFn(marker)) {
-        return true;
-      }
-      if (marker == markerToFind) {
-        return true;
-      }
-
-      // Check if the marker is SOI or TEM. These two don't have length field, so we skip it.
-      if (marker == MARKER_SOI || marker == MARKER_TEM) {
-        continue;
-      }
-
-      // Check if the marker is EOI or SOS. We will stop reading since metadata markers don't
-      // come after these two markers.
-      if (marker == MARKER_EOI || marker == MARKER_SOS) {
-        return false;
-      }
 
-      // read block length
-      // subtract 2 as length contain SIZE field we just read
-      int length = StreamProcessor.readPackedInt(is, 2, false) - 2;
-      // Skip other markers.
-      is.skip(length);
+    /**
+     * Get image width and height from jpeg header
+     *
+     * @param jpeg the input byte array of jpeg image
+     * @return dimensions of the image in form of Rect.
+     */
+    public static Rect getDimensions(byte[] jpeg) {
+        // wrapping with ByteArrayInputStream is cheap and we don't have duplicate implementation
+        return getDimensions(new ByteArrayInputStream(jpeg));
     }
-    return false;
-  }
-
-  private static boolean isSOFn(int marker) {
-    // There are no SOF4, SOF8, SOF12
-    switch (marker) {
-      case 0xC0:
-      case 0xC1:
-      case 0xC2:
-      case 0xC3:
-      case 0xC5:
-      case 0xC6:
-      case 0xC7:
-      case 0xC9:
-      case 0xCA:
-      case 0xCB:
-      case 0xCD:
-      case 0xCE:
-      case 0xCF:
-        return true;
-      default:
+
+    /**
+     * Get image width and height from jpeg header
+     *
+     * @param is the input stream of jpeg image
+     * @return dimensions of the image in form of Rect
+     */
+    public static Rect getDimensions(InputStream is) {
+        try {
+            if (moveToMarker(is, MARKER_SOFn)) {
+                // read block length
+                // subtract 2 as length contain SIZE field we just read
+                int length = StreamProcessor.readPackedInt(is, 2, false) - 2;
+                if (length > 6) {
+                    // SOFn structure: 0xFFCn|length(2)|bitDepth(1)|height(2)|width(2)|...
+                    int bitDepth = StreamProcessor.readPackedInt(is, 1, false);
+                    int height = StreamProcessor.readPackedInt(is, 2, false);
+                    int width = StreamProcessor.readPackedInt(is, 2, false);
+                    return new Rect(0, 0, width, height);
+                }
+            }
+        } catch (IOException ioe) {
+            FLog.e(TAG, ioe, "%x: getDimensions", is.hashCode());
+            // log and return null.
+        }
+        return null;
+    }
+
+    /**
+     * Reads the content of the input stream until specified marker is found. Marker will be
+     * consumed and the input stream will be positioned after the specified marker.
+     *
+     * @param is           the input stream to read bytes from
+     * @param markerToFind the marker we are looking for
+     * @return boolean: whether or not we found the expected marker from input stream.
+     */
+    public static boolean moveToMarker(InputStream is, int markerToFind) throws IOException {
+        Preconditions.checkNotNull(is);
+        // ISO/IEC 10918-1:1993(E)
+        while (StreamProcessor.readPackedInt(is, 1, false) == MARKER_FIRST_BYTE) {
+            int marker = MARKER_FIRST_BYTE;
+            while (marker == MARKER_FIRST_BYTE) {
+                marker = StreamProcessor.readPackedInt(is, 1, false);
+            }
+
+            if (markerToFind == MARKER_SOFn && isSOFn(marker)) {
+                return true;
+            }
+            if (marker == markerToFind) {
+                return true;
+            }
+
+            // Check if the marker is SOI or TEM. These two don't have length field, so we skip it.
+            if (marker == MARKER_SOI || marker == MARKER_TEM) {
+                continue;
+            }
+
+            // Check if the marker is EOI or SOS. We will stop reading since metadata markers don't
+            // come after these two markers.
+            if (marker == MARKER_EOI || marker == MARKER_SOS) {
+                return false;
+            }
+
+            // read block length
+            // subtract 2 as length contain SIZE field we just read
+            int length = StreamProcessor.readPackedInt(is, 2, false) - 2;
+            // Skip other markers.
+            is.skip(length);
+        }
         return false;
     }
-  }
-
-  /**
-   * Positions the given input stream to the beginning of the EXIF data in the JPEG APP1 block.
-   * @param is the input stream of jpeg image
-   * @return length of EXIF data
-   */
-  private static int moveToAPP1EXIF(InputStream is) throws IOException {
-    if (moveToMarker(is, MARKER_APP1)) {
-      // read block length
-      // subtract 2 as length contain SIZE field we just read
-      int length = StreamProcessor.readPackedInt(is, 2, false) - 2;
-      if (length > 6) {
-        int magic = StreamProcessor.readPackedInt(is, 4, false);
-        length -= 4;
-        int zero = StreamProcessor.readPackedInt(is, 2, false);
-        length -= 2;
-        if (magic == APP1_EXIF_MAGIC && zero == 0) {
-          // JEITA CP-3451 Exif Version 2.2
-          return length;
+
+    private static boolean isSOFn(int marker) {
+        // There are no SOF4, SOF8, SOF12
+        switch (marker) {
+            case 0xC0:
+            case 0xC1:
+            case 0xC2:
+            case 0xC3:
+            case 0xC5:
+            case 0xC6:
+            case 0xC7:
+            case 0xC9:
+            case 0xCA:
+            case 0xCB:
+            case 0xCD:
+            case 0xCE:
+            case 0xCF:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Positions the given input stream to the beginning of the EXIF data in the JPEG APP1 block.
+     *
+     * @param is the input stream of jpeg image
+     * @return length of EXIF data
+     */
+    private static int moveToAPP1EXIF(InputStream is) throws IOException {
+        if (moveToMarker(is, MARKER_APP1)) {
+            // read block length
+            // subtract 2 as length contain SIZE field we just read
+            int length = StreamProcessor.readPackedInt(is, 2, false) - 2;
+            if (length > 6) {
+                int magic = StreamProcessor.readPackedInt(is, 4, false);
+                length -= 4;
+                int zero = StreamProcessor.readPackedInt(is, 2, false);
+                length -= 2;
+                if (magic == APP1_EXIF_MAGIC && zero == 0) {
+                    // JEITA CP-3451 Exif Version 2.2
+                    return length;
+                }
+            }
         }
-      }
+        return 0;
     }
-    return 0;
-  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imageutils/StreamProcessor.java b/imagepipeline/src/main/java/com/facebook/imageutils/StreamProcessor.java
index 8d4178208..57390bd59 100644
--- a/imagepipeline/src/main/java/com/facebook/imageutils/StreamProcessor.java
+++ b/imagepipeline/src/main/java/com/facebook/imageutils/StreamProcessor.java
@@ -17,29 +17,30 @@
  */
 class StreamProcessor {
 
-  /**
-   *  Consumes up to 4 bytes and returns them as int (taking into account endianess).
-   *  Throws exception if specified number of bytes cannot be consumed.
-   *  @param is the input stream to read bytes from
-   *  @param numBytes the number of bytes to read
-   *  @param isLittleEndian whether the bytes should be interpreted in little or big endian format
-   *  @return packed int read from input stream and constructed according to endianess
-   */
-  public static int readPackedInt(InputStream is, int numBytes, boolean isLittleEndian)
-      throws IOException {
-    int value = 0;
-    for (int i = 0; i < numBytes; i++) {
-      int b = is.read();
-      if (b == -1) {
-        throw new IOException("no more bytes");
-      }
-      if (isLittleEndian) {
-        value |= (b & 0xFF) << (i * 8);
-      } else {
-        value = (value << 8) | (b & 0xFF);
-      }
+    /**
+     * Consumes up to 4 bytes and returns them as int (taking into account endianess).
+     * Throws exception if specified number of bytes cannot be consumed.
+     *
+     * @param is             the input stream to read bytes from
+     * @param numBytes       the number of bytes to read
+     * @param isLittleEndian whether the bytes should be interpreted in little or big endian format
+     * @return packed int read from input stream and constructed according to endianess
+     */
+    public static int readPackedInt(InputStream is, int numBytes, boolean isLittleEndian)
+            throws IOException {
+        int value = 0;
+        for (int i = 0; i < numBytes; i++) {
+            int b = is.read();
+            if (b == -1) {
+                throw new IOException("no more bytes");
+            }
+            if (isLittleEndian) {
+                value |= (b & 0xFF) << (i * 8);
+            } else {
+                value = (value << 8) | (b & 0xFF);
+            }
+        }
+        return value;
     }
-    return value;
-  }
 
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imageutils/TiffUtil.java b/imagepipeline/src/main/java/com/facebook/imageutils/TiffUtil.java
index 86ee66f23..ae7a0e276 100644
--- a/imagepipeline/src/main/java/com/facebook/imageutils/TiffUtil.java
+++ b/imagepipeline/src/main/java/com/facebook/imageutils/TiffUtil.java
@@ -19,163 +19,168 @@
  */
 class TiffUtil {
 
-  private static final Class<?> TAG = TiffUtil.class;
-
-  public static final int TIFF_BYTE_ORDER_BIG_END = 0x4D4D002A;
-  public static final int TIFF_BYTE_ORDER_LITTLE_END = 0x49492A00;
-  public static final int TIFF_TAG_ORIENTATION = 0x0112;
-  public static final int TIFF_TYPE_SHORT = 3;
-
-  /**
-   * Determines auto-rotate angle based on orientation information.
-   * @param orientation orientation information read from APP1 EXIF (TIFF) block.
-   * @return orientation: 1/3/6/8 -> 0/180/90/270.
-   */
-  public static int getAutoRotateAngleFromOrientation(int orientation) {
-    switch (orientation) {
-      case 1:
+    private static final Class<?> TAG = TiffUtil.class;
+
+    public static final int TIFF_BYTE_ORDER_BIG_END = 0x4D4D002A;
+    public static final int TIFF_BYTE_ORDER_LITTLE_END = 0x49492A00;
+    public static final int TIFF_TAG_ORIENTATION = 0x0112;
+    public static final int TIFF_TYPE_SHORT = 3;
+
+    /**
+     * Determines auto-rotate angle based on orientation information.
+     *
+     * @param orientation orientation information read from APP1 EXIF (TIFF) block.
+     * @return orientation: 1/3/6/8 -> 0/180/90/270.
+     */
+    public static int getAutoRotateAngleFromOrientation(int orientation) {
+        switch (orientation) {
+            case 1:
+                return 0;
+            case 3:
+                return 180;
+            case 6:
+                return 90;
+            case 8:
+                return 270;
+        }
+        FLog.i(TAG, "Unsupported orientation");
         return 0;
-      case 3:
-        return 180;
-      case 6:
-        return 90;
-      case 8:
-        return 270;
-    }
-    FLog.i(TAG, "Unsupported orientation");
-    return 0;
-  }
-
-  /**
-   * Reads orientation information from TIFF data.
-   * @param is the input stream of TIFF data
-   * @param length length of the TIFF data
-   * @return orientation information (1/3/6/8 on success, 0 if not found)
-   */
-  public static int readOrientationFromTIFF(InputStream is, int length) throws IOException {
-    // read tiff header
-    TiffHeader tiffHeader = new TiffHeader();
-    length = readTiffHeader(is, length, tiffHeader);
-
-    // move to the first IFD
-    // offset is relative to the beginning of the TIFF data
-    // and we already consumed the first 8 bytes of header
-    int toSkip = tiffHeader.firstIfdOffset - 8;
-    if (length == 0 || toSkip > length) {
-      return 0;
-    }
-    is.skip(toSkip);
-    length -= toSkip;
-
-    // move to the entry with orientation tag
-    length = moveToTiffEntryWithTag(is, length, tiffHeader.isLittleEndian, TIFF_TAG_ORIENTATION);
-
-    // read orientation
-    return getOrientationFromTiffEntry(is, length, tiffHeader.isLittleEndian);
-  }
-
-  /**
-   * Structure that holds TIFF header.
-   */
-  private static class TiffHeader {
-    boolean isLittleEndian;
-    int byteOrder;
-    int firstIfdOffset;
-  }
-
-  /**
-   * Reads the TIFF header to the provided structure.
-   * @param is the input stream of TIFF data
-   * @param length length of the TIFF data
-   * @return remaining length of the data on success, 0 on failure
-   * @throws IOException
-   */
-  private static int readTiffHeader(InputStream is, int length, TiffHeader tiffHeader)
-      throws IOException {
-    if (length <= 8) {
-      return 0;
     }
 
-    // read the byte order
-    tiffHeader.byteOrder = StreamProcessor.readPackedInt(is, 4, false);
-    length -= 4;
-    if (tiffHeader.byteOrder != TIFF_BYTE_ORDER_LITTLE_END &&
-        tiffHeader.byteOrder != TIFF_BYTE_ORDER_BIG_END) {
-      FLog.e(TAG, "Invalid TIFF header");
-      return 0;
-    }
-    tiffHeader.isLittleEndian = (tiffHeader.byteOrder == TIFF_BYTE_ORDER_LITTLE_END);
-
-    // read the offset of the first IFD and check if it is reasonable
-    tiffHeader.firstIfdOffset = StreamProcessor.readPackedInt(is, 4, tiffHeader.isLittleEndian);
-    length -= 4;
-    if (tiffHeader.firstIfdOffset < 8 || tiffHeader.firstIfdOffset - 8 > length) {
-      FLog.e(TAG, "Invalid offset");
-      return 0;
+    /**
+     * Reads orientation information from TIFF data.
+     *
+     * @param is     the input stream of TIFF data
+     * @param length length of the TIFF data
+     * @return orientation information (1/3/6/8 on success, 0 if not found)
+     */
+    public static int readOrientationFromTIFF(InputStream is, int length) throws IOException {
+        // read tiff header
+        TiffHeader tiffHeader = new TiffHeader();
+        length = readTiffHeader(is, length, tiffHeader);
+
+        // move to the first IFD
+        // offset is relative to the beginning of the TIFF data
+        // and we already consumed the first 8 bytes of header
+        int toSkip = tiffHeader.firstIfdOffset - 8;
+        if (length == 0 || toSkip > length) {
+            return 0;
+        }
+        is.skip(toSkip);
+        length -= toSkip;
+
+        // move to the entry with orientation tag
+        length = moveToTiffEntryWithTag(is, length, tiffHeader.isLittleEndian, TIFF_TAG_ORIENTATION);
+
+        // read orientation
+        return getOrientationFromTiffEntry(is, length, tiffHeader.isLittleEndian);
     }
 
-    return length;
-  }
-
-  /**
-   * Positions the given input stream to the entry that has a specified tag. Tag will be consumed.
-   * @param is the input stream of TIFF data positioned to the beginning of an IFD.
-   * @param length length of the available data in the given input stream.
-   * @param isLittleEndian whether the TIFF data is stored in little or big endian format
-   * @param tagToFind tag to find
-   * @return remaining length of the data on success, 0 on failure
-   */
-  private static int moveToTiffEntryWithTag(
-      InputStream is,
-      int length,
-      boolean isLittleEndian,
-      int tagToFind)
-      throws IOException {
-    if (length < 14) {
-      return 0;
+    /**
+     * Structure that holds TIFF header.
+     */
+    private static class TiffHeader {
+        boolean isLittleEndian;
+        int byteOrder;
+        int firstIfdOffset;
     }
-    // read the number of entries and go through all of them
-    // each IFD entry has length of 12 bytes and is composed of
-    // {TAG [2], TYPE [2], COUNT [4], VALUE/OFFSET [4]}
-    int numEntries = StreamProcessor.readPackedInt(is, 2, isLittleEndian);
-    length -= 2;
-    while (numEntries-- > 0 && length >= 12) {
-      int tag = StreamProcessor.readPackedInt(is, 2, isLittleEndian);
-      length -= 2;
-      if (tag == tagToFind) {
+
+    /**
+     * Reads the TIFF header to the provided structure.
+     *
+     * @param is     the input stream of TIFF data
+     * @param length length of the TIFF data
+     * @return remaining length of the data on success, 0 on failure
+     * @throws IOException
+     */
+    private static int readTiffHeader(InputStream is, int length, TiffHeader tiffHeader)
+            throws IOException {
+        if (length <= 8) {
+            return 0;
+        }
+
+        // read the byte order
+        tiffHeader.byteOrder = StreamProcessor.readPackedInt(is, 4, false);
+        length -= 4;
+        if (tiffHeader.byteOrder != TIFF_BYTE_ORDER_LITTLE_END &&
+                tiffHeader.byteOrder != TIFF_BYTE_ORDER_BIG_END) {
+            FLog.e(TAG, "Invalid TIFF header");
+            return 0;
+        }
+        tiffHeader.isLittleEndian = (tiffHeader.byteOrder == TIFF_BYTE_ORDER_LITTLE_END);
+
+        // read the offset of the first IFD and check if it is reasonable
+        tiffHeader.firstIfdOffset = StreamProcessor.readPackedInt(is, 4, tiffHeader.isLittleEndian);
+        length -= 4;
+        if (tiffHeader.firstIfdOffset < 8 || tiffHeader.firstIfdOffset - 8 > length) {
+            FLog.e(TAG, "Invalid offset");
+            return 0;
+        }
+
         return length;
-      }
-      is.skip(10);
-      length -= 10;
     }
-    return 0;
-  }
-
-  /**
-   * Reads the orientation information from the TIFF entry.
-   * It is assumed that the entry has a TIFF orientation tag and that tag has already been consumed.
-   * @param is the input stream positioned at the TIFF entry with tag already being consumed
-   * @param isLittleEndian whether the TIFF data is stored in little or big endian format
-   * @return Orientation value in TIFF IFD entry.
-   */
-  private static int getOrientationFromTiffEntry(InputStream is, int length, boolean isLittleEndian)
-      throws IOException {
-    if (length < 10) {
-      return 0;
-    }
-    // orientation entry has type = short
-    int type = StreamProcessor.readPackedInt(is, 2, isLittleEndian);
-    if (type != TIFF_TYPE_SHORT) {
-      return 0;
+
+    /**
+     * Positions the given input stream to the entry that has a specified tag. Tag will be consumed.
+     *
+     * @param is             the input stream of TIFF data positioned to the beginning of an IFD.
+     * @param length         length of the available data in the given input stream.
+     * @param isLittleEndian whether the TIFF data is stored in little or big endian format
+     * @param tagToFind      tag to find
+     * @return remaining length of the data on success, 0 on failure
+     */
+    private static int moveToTiffEntryWithTag(
+            InputStream is,
+            int length,
+            boolean isLittleEndian,
+            int tagToFind)
+            throws IOException {
+        if (length < 14) {
+            return 0;
+        }
+        // read the number of entries and go through all of them
+        // each IFD entry has length of 12 bytes and is composed of
+        // {TAG [2], TYPE [2], COUNT [4], VALUE/OFFSET [4]}
+        int numEntries = StreamProcessor.readPackedInt(is, 2, isLittleEndian);
+        length -= 2;
+        while (numEntries-- > 0 && length >= 12) {
+            int tag = StreamProcessor.readPackedInt(is, 2, isLittleEndian);
+            length -= 2;
+            if (tag == tagToFind) {
+                return length;
+            }
+            is.skip(10);
+            length -= 10;
+        }
+        return 0;
     }
-    // orientation entry has count = 1
-    int count = StreamProcessor.readPackedInt(is, 4, isLittleEndian);
-    if (count != 1) {
-      return 0;
+
+    /**
+     * Reads the orientation information from the TIFF entry.
+     * It is assumed that the entry has a TIFF orientation tag and that tag has already been consumed.
+     *
+     * @param is             the input stream positioned at the TIFF entry with tag already being consumed
+     * @param isLittleEndian whether the TIFF data is stored in little or big endian format
+     * @return Orientation value in TIFF IFD entry.
+     */
+    private static int getOrientationFromTiffEntry(InputStream is, int length, boolean isLittleEndian)
+            throws IOException {
+        if (length < 10) {
+            return 0;
+        }
+        // orientation entry has type = short
+        int type = StreamProcessor.readPackedInt(is, 2, isLittleEndian);
+        if (type != TIFF_TYPE_SHORT) {
+            return 0;
+        }
+        // orientation entry has count = 1
+        int count = StreamProcessor.readPackedInt(is, 4, isLittleEndian);
+        if (count != 1) {
+            return 0;
+        }
+        int value = StreamProcessor.readPackedInt(is, 2, isLittleEndian);
+        int padding = StreamProcessor.readPackedInt(is, 2, isLittleEndian);
+        return value;
     }
-    int value = StreamProcessor.readPackedInt(is, 2, isLittleEndian);
-    int padding = StreamProcessor.readPackedInt(is, 2, isLittleEndian);
-    return value;
-  }
 
 }
diff --git a/imagepipeline/src/test/java/com/facebook/cache/disk/DefaultDiskStorageSupplierTest.java b/imagepipeline/src/test/java/com/facebook/cache/disk/DefaultDiskStorageSupplierTest.java
index a68d00e80..adc79576d 100644
--- a/imagepipeline/src/test/java/com/facebook/cache/disk/DefaultDiskStorageSupplierTest.java
+++ b/imagepipeline/src/test/java/com/facebook/cache/disk/DefaultDiskStorageSupplierTest.java
@@ -32,173 +32,173 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class DefaultDiskStorageSupplierTest {
 
-  private int mVersion;
-  private String mBaseDirectoryName;
-  private CacheErrorLogger mCacheErrorLogger;
-  private Context mContext;
-
-  @Before
-  public void setUp() {
-    mContext = Robolectric.application.getApplicationContext();
-    mVersion = 1;
-    mBaseDirectoryName = "base";
-    mCacheErrorLogger = mock(CacheErrorLogger.class);
-  }
-
-  private DefaultDiskStorageSupplier createSupplier(boolean useFilesDirInsteadOfCacheDir) {
-    return new DefaultDiskStorageSupplier(
-        mVersion,
-        useFilesDirInsteadOfCacheDir ?
-            Suppliers.of(mContext.getFilesDir()) :
-            Suppliers.of(mContext.getCacheDir()),
-        mBaseDirectoryName,
-        mCacheErrorLogger);
-  }
-
-  private DefaultDiskStorageSupplier createInternalCacheDirSupplier() {
-    return createSupplier(false);
-  }
-
-  private DefaultDiskStorageSupplier createInternalFilesDirSupplier() {
-    return createSupplier(true);
-  }
-
-  private File getStorageSubdirectory(File rootDir, int version) {
-    return new File(rootDir, DefaultDiskStorage.getVersionSubdirectoryName(version));
-  }
-
-  @Test
-  public void testGet_InternalCacheDir() throws Exception {
-    File cacheDir = mContext.getCacheDir();
-
-    DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
-
-    // initial state
-    Assert.assertNull(supplier.mCurrentState.storage);
-
-    // after first initialization
-    DiskStorage storage = supplier.get();
-    Assert.assertEquals(storage, supplier.mCurrentState.storage);
-    Assert.assertTrue(storage instanceof DefaultDiskStorage);
-
-    File baseDir = new File(cacheDir, mBaseDirectoryName);
-    Assert.assertTrue(baseDir.exists());
-    Assert.assertTrue(getStorageSubdirectory(baseDir, 1).exists());
-
-    // no change => should get back the same storage instance
-    DiskStorage storage2 = supplier.get();
-    Assert.assertEquals(storage, storage2);
-
-    // root directory has been moved (proxy for delete). So we should get back a different instance
-    File baseDirOrig = baseDir.getAbsoluteFile();
-    Assert.assertTrue(baseDirOrig.renameTo(new File(cacheDir, "dummydir")));
-    DiskStorage storage3 = supplier.get();
-    Assert.assertNotSame(storage, storage3);
-    Assert.assertTrue(storage3 instanceof DefaultDiskStorage);
-    Assert.assertTrue(baseDir.exists());
-    Assert.assertTrue(getStorageSubdirectory(baseDir, 1).exists());
-  }
-
-  @Test
-  public void testGet_InternalFilesDir() throws Exception {
-    File dir = mContext.getFilesDir();
-
-    DefaultDiskStorageSupplier supplier = createInternalFilesDirSupplier();
-
-    // initial state
-    Assert.assertNull(supplier.mCurrentState.storage);
-
-    // after first initialization
-    DiskStorage storage = supplier.get();
-    Assert.assertEquals(storage, supplier.mCurrentState.storage);
-    Assert.assertTrue(storage instanceof DefaultDiskStorage);
-
-    File baseDir = new File(dir, mBaseDirectoryName);
-    Assert.assertTrue(baseDir.exists());
-    Assert.assertTrue(getStorageSubdirectory(baseDir, 1).exists());
-
-    // no change => should get back the same storage instance
-    DiskStorage storage2 = supplier.get();
-    Assert.assertEquals(storage, storage2);
-
-    // root directory has been moved (proxy for delete). So we should get back a different instance
-    File baseDirOrig = baseDir.getAbsoluteFile();
-    Assert.assertTrue(baseDirOrig.renameTo(new File(dir, "dummydir")));
-    DiskStorage storage3 = supplier.get();
-    Assert.assertNotSame(storage, storage3);
-    Assert.assertTrue(storage3 instanceof DefaultDiskStorage);
-    Assert.assertTrue(baseDir.exists());
-    Assert.assertTrue(getStorageSubdirectory(baseDir, 1).exists());
-  }
-
-  @Test
-  public void testCreateRootDirectoryIfNecessary() throws Exception {
-    DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
-    Assert.assertNull(supplier.mCurrentState.storage);
-    File baseDir = new File(mContext.getCacheDir(), mBaseDirectoryName);
-
-    // directory is clean
-    supplier.createRootDirectoryIfNecessary(baseDir);
-    Assert.assertTrue(baseDir.exists());
-
-    // cleanup
-    FileTree.deleteRecursively(baseDir);
-
-    // a file with the same name exists - this should clobber the file, and create a directory
-    // instead
-    File dummyFile = new File(mContext.getCacheDir(), mBaseDirectoryName);
-    Assert.assertTrue(dummyFile.createNewFile());
-    Assert.assertTrue(dummyFile.exists());
-    supplier.createRootDirectoryIfNecessary(baseDir);
-    Assert.assertTrue(baseDir.exists());
-    Assert.assertTrue(baseDir.isDirectory());
-
-    // cleanup
-    FileTree.deleteRecursively(baseDir);
-
-    // a directory with the same name exists - and with a file in it.
-    // Everything should stay the same
-    Assert.assertTrue(baseDir.mkdirs());
-    File dummyFile2 = new File(baseDir, "dummy1");
-    Assert.assertTrue(dummyFile2.createNewFile());
-    Assert.assertTrue(dummyFile2.exists());
-    supplier.createRootDirectoryIfNecessary(baseDir);
-    Assert.assertTrue(dummyFile2.exists());
-  }
-
-  @Test
-  public void testDeleteStorage() throws Exception {
-    DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
-    Assert.assertNull(supplier.mCurrentState.storage);
-    supplier.deleteOldStorageIfNecessary();
-
-    DefaultDiskStorage storage = (DefaultDiskStorage)supplier.get();
-    File versionDir = getStorageSubdirectory(
-        new File(mContext.getCacheDir(), mBaseDirectoryName),
-        mVersion);
-    Assert.assertTrue(versionDir.exists());
-    File dummyFile = new File(versionDir, "dummy");
-    Assert.assertTrue(dummyFile.createNewFile());
-    Assert.assertTrue(dummyFile.exists());
-    supplier.deleteOldStorageIfNecessary();
-    Assert.assertFalse(dummyFile.exists());
-    Assert.assertFalse(versionDir.exists());
-    Assert.assertFalse(versionDir.getParentFile().exists());
-  }
-
-  @Test
-  public void testCreateStorage() throws Exception {
-    DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
-
-    File baseDir = new File(mContext.getCacheDir(), mBaseDirectoryName);
-    File versionDir = getStorageSubdirectory(
-        baseDir,
-        mVersion);
-
-    Assert.assertFalse(versionDir.exists());
-    Assert.assertFalse(baseDir.exists());
-    supplier.get();
-    Assert.assertTrue(baseDir.exists());
-    Assert.assertTrue(versionDir.exists());
-  }
+    private int mVersion;
+    private String mBaseDirectoryName;
+    private CacheErrorLogger mCacheErrorLogger;
+    private Context mContext;
+
+    @Before
+    public void setUp() {
+        mContext = Robolectric.application.getApplicationContext();
+        mVersion = 1;
+        mBaseDirectoryName = "base";
+        mCacheErrorLogger = mock(CacheErrorLogger.class);
+    }
+
+    private DefaultDiskStorageSupplier createSupplier(boolean useFilesDirInsteadOfCacheDir) {
+        return new DefaultDiskStorageSupplier(
+                mVersion,
+                useFilesDirInsteadOfCacheDir ?
+                        Suppliers.of(mContext.getFilesDir()) :
+                        Suppliers.of(mContext.getCacheDir()),
+                mBaseDirectoryName,
+                mCacheErrorLogger);
+    }
+
+    private DefaultDiskStorageSupplier createInternalCacheDirSupplier() {
+        return createSupplier(false);
+    }
+
+    private DefaultDiskStorageSupplier createInternalFilesDirSupplier() {
+        return createSupplier(true);
+    }
+
+    private File getStorageSubdirectory(File rootDir, int version) {
+        return new File(rootDir, DefaultDiskStorage.getVersionSubdirectoryName(version));
+    }
+
+    @Test
+    public void testGet_InternalCacheDir() throws Exception {
+        File cacheDir = mContext.getCacheDir();
+
+        DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
+
+        // initial state
+        Assert.assertNull(supplier.mCurrentState.storage);
+
+        // after first initialization
+        DiskStorage storage = supplier.get();
+        Assert.assertEquals(storage, supplier.mCurrentState.storage);
+        Assert.assertTrue(storage instanceof DefaultDiskStorage);
+
+        File baseDir = new File(cacheDir, mBaseDirectoryName);
+        Assert.assertTrue(baseDir.exists());
+        Assert.assertTrue(getStorageSubdirectory(baseDir, 1).exists());
+
+        // no change => should get back the same storage instance
+        DiskStorage storage2 = supplier.get();
+        Assert.assertEquals(storage, storage2);
+
+        // root directory has been moved (proxy for delete). So we should get back a different instance
+        File baseDirOrig = baseDir.getAbsoluteFile();
+        Assert.assertTrue(baseDirOrig.renameTo(new File(cacheDir, "dummydir")));
+        DiskStorage storage3 = supplier.get();
+        Assert.assertNotSame(storage, storage3);
+        Assert.assertTrue(storage3 instanceof DefaultDiskStorage);
+        Assert.assertTrue(baseDir.exists());
+        Assert.assertTrue(getStorageSubdirectory(baseDir, 1).exists());
+    }
+
+    @Test
+    public void testGet_InternalFilesDir() throws Exception {
+        File dir = mContext.getFilesDir();
+
+        DefaultDiskStorageSupplier supplier = createInternalFilesDirSupplier();
+
+        // initial state
+        Assert.assertNull(supplier.mCurrentState.storage);
+
+        // after first initialization
+        DiskStorage storage = supplier.get();
+        Assert.assertEquals(storage, supplier.mCurrentState.storage);
+        Assert.assertTrue(storage instanceof DefaultDiskStorage);
+
+        File baseDir = new File(dir, mBaseDirectoryName);
+        Assert.assertTrue(baseDir.exists());
+        Assert.assertTrue(getStorageSubdirectory(baseDir, 1).exists());
+
+        // no change => should get back the same storage instance
+        DiskStorage storage2 = supplier.get();
+        Assert.assertEquals(storage, storage2);
+
+        // root directory has been moved (proxy for delete). So we should get back a different instance
+        File baseDirOrig = baseDir.getAbsoluteFile();
+        Assert.assertTrue(baseDirOrig.renameTo(new File(dir, "dummydir")));
+        DiskStorage storage3 = supplier.get();
+        Assert.assertNotSame(storage, storage3);
+        Assert.assertTrue(storage3 instanceof DefaultDiskStorage);
+        Assert.assertTrue(baseDir.exists());
+        Assert.assertTrue(getStorageSubdirectory(baseDir, 1).exists());
+    }
+
+    @Test
+    public void testCreateRootDirectoryIfNecessary() throws Exception {
+        DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
+        Assert.assertNull(supplier.mCurrentState.storage);
+        File baseDir = new File(mContext.getCacheDir(), mBaseDirectoryName);
+
+        // directory is clean
+        supplier.createRootDirectoryIfNecessary(baseDir);
+        Assert.assertTrue(baseDir.exists());
+
+        // cleanup
+        FileTree.deleteRecursively(baseDir);
+
+        // a file with the same name exists - this should clobber the file, and create a directory
+        // instead
+        File dummyFile = new File(mContext.getCacheDir(), mBaseDirectoryName);
+        Assert.assertTrue(dummyFile.createNewFile());
+        Assert.assertTrue(dummyFile.exists());
+        supplier.createRootDirectoryIfNecessary(baseDir);
+        Assert.assertTrue(baseDir.exists());
+        Assert.assertTrue(baseDir.isDirectory());
+
+        // cleanup
+        FileTree.deleteRecursively(baseDir);
+
+        // a directory with the same name exists - and with a file in it.
+        // Everything should stay the same
+        Assert.assertTrue(baseDir.mkdirs());
+        File dummyFile2 = new File(baseDir, "dummy1");
+        Assert.assertTrue(dummyFile2.createNewFile());
+        Assert.assertTrue(dummyFile2.exists());
+        supplier.createRootDirectoryIfNecessary(baseDir);
+        Assert.assertTrue(dummyFile2.exists());
+    }
+
+    @Test
+    public void testDeleteStorage() throws Exception {
+        DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
+        Assert.assertNull(supplier.mCurrentState.storage);
+        supplier.deleteOldStorageIfNecessary();
+
+        DefaultDiskStorage storage = (DefaultDiskStorage) supplier.get();
+        File versionDir = getStorageSubdirectory(
+                new File(mContext.getCacheDir(), mBaseDirectoryName),
+                mVersion);
+        Assert.assertTrue(versionDir.exists());
+        File dummyFile = new File(versionDir, "dummy");
+        Assert.assertTrue(dummyFile.createNewFile());
+        Assert.assertTrue(dummyFile.exists());
+        supplier.deleteOldStorageIfNecessary();
+        Assert.assertFalse(dummyFile.exists());
+        Assert.assertFalse(versionDir.exists());
+        Assert.assertFalse(versionDir.getParentFile().exists());
+    }
+
+    @Test
+    public void testCreateStorage() throws Exception {
+        DefaultDiskStorageSupplier supplier = createInternalCacheDirSupplier();
+
+        File baseDir = new File(mContext.getCacheDir(), mBaseDirectoryName);
+        File versionDir = getStorageSubdirectory(
+                baseDir,
+                mVersion);
+
+        Assert.assertFalse(versionDir.exists());
+        Assert.assertFalse(baseDir.exists());
+        supplier.get();
+        Assert.assertTrue(baseDir.exists());
+        Assert.assertTrue(versionDir.exists());
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/cache/disk/DefaultDiskStorageTest.java b/imagepipeline/src/test/java/com/facebook/cache/disk/DefaultDiskStorageTest.java
index b05ff42d1..9e62c5e5f 100644
--- a/imagepipeline/src/test/java/com/facebook/cache/disk/DefaultDiskStorageTest.java
+++ b/imagepipeline/src/test/java/com/facebook/cache/disk/DefaultDiskStorageTest.java
@@ -53,525 +53,532 @@
 @PrepareOnlyThisForTest({SystemClock.class})
 public class DefaultDiskStorageTest {
 
-  private File mDirectory;
-  private SystemClock mClock;
-
-  @Before
-  public void before() throws Exception {
-    mClock = mock(SystemClock.class);
-    PowerMockito.mockStatic(SystemClock.class);
-    PowerMockito.when(SystemClock.get()).thenReturn(mClock);
-    mDirectory = new File(Robolectric.application.getCacheDir(), "sharded-disk-storage-test");
-    Assert.assertTrue(mDirectory.mkdirs());
-    FileTree.deleteContents(mDirectory);
-  }
-
-  private Supplier<DefaultDiskStorage> getStorageSupplier(final int version) {
-    return new Supplier<DefaultDiskStorage>() {
-      @Override
-      public DefaultDiskStorage get() {
-        return new DefaultDiskStorage(
-            mDirectory,
-            version,
-            mock(CacheErrorLogger.class));
-      }
-    };
-  }
-
-  @Test
-  public void testStartup() throws Exception {
-    // create a bogus file
-    File bogusFile = new File(mDirectory, "bogus");
-    Assert.assertTrue(bogusFile.createNewFile());
-
-    // create the storage now. Bogus files should be gone now
-    DefaultDiskStorage storage = getStorageSupplier(1).get();
-    Assert.assertFalse(bogusFile.exists());
-    String version1Dir = DefaultDiskStorage.getVersionSubdirectoryName(1);
-    Assert.assertTrue(new File(mDirectory, version1Dir).exists());
-
-    // create a new version
-    storage = getStorageSupplier(2).get();
-    Assert.assertNotNull(storage);
-    Assert.assertFalse(new File(mDirectory, version1Dir).exists());
-    String version2Dir = DefaultDiskStorage.getVersionSubdirectoryName(2);
-    Assert.assertTrue(new File(mDirectory, version2Dir).exists());
-  }
-
-  @Test
-  public void testIsEnabled() {
-    DefaultDiskStorage storage = getStorageSupplier(1).get();
-    Assert.assertTrue(storage.isEnabled());
-  }
-
-  @Test
-  public void testBasicOperations() throws Exception {
-    DefaultDiskStorage storage = getStorageSupplier(1).get();
-    final String resourceId1 = "R1";
-    final String resourceId2 = "R2";
-
-    // no file - get should fail
-    FileBinaryResource resource1 = storage.getResource(resourceId1, null);
-    Assert.assertNull(resource1);
-
-    // write out the file now
-    byte[] key1Contents = new byte[] {0, 1, 2};
-    writeToStorage(storage, resourceId1, key1Contents);
-    // get should succeed now
-    resource1 = storage.getResource(resourceId1, null);
-    Assert.assertNotNull(resource1);
-    Assert.assertArrayEquals(key1Contents, Files.toByteArray(resource1.getFile()));
-    // remove the file now - get should fail again
-    Assert.assertTrue(resource1.getFile().delete());
-    resource1 = storage.getResource(resourceId1, null);
-    Assert.assertNull(resource1);
-    // no file
-    FileBinaryResource resource2 = storage.getResource(resourceId2, null);
-    Assert.assertNull(resource2);
-  }
-
-  /**
-   * Test that a file is stored in a new file,
-   * and the bytes are stored plainly in the file.
-   * @throws Exception
-   */
-  @Test
-  public void testStoreFile() throws Exception {
-    DefaultDiskStorage storage = getStorageSupplier(1).get();
-    final String resourceId1 = "resource1";
-    final byte[] value1 = new byte[100];
-    value1[80] = 101;
-    File file1 = writeFileToStorage(storage, resourceId1, value1);
-
-    Set<File> files = Sets.newHashSet();
-    Assert.assertTrue(mDirectory.exists());
-    List<File> founds1 = findNewFiles(mDirectory, files, /*recurse*/true);
-    Assert.assertNotNull(file1);
-    Assert.assertTrue(founds1.contains(file1));
-    Assert.assertTrue(file1.exists());
-    assertEquals(100, file1.length());
-    Assert.assertArrayEquals(value1, Files.toByteArray(file1));
-  }
-
-  /**
-   * Inserts 3 files with different dates.
-   * Check what files are there.
-   * Uses an iterator to remove the one in the middle.
-   * Check that later.
-   * @throws Exception
-   */
-  @Test
-  public void testRemoveWithIterator() throws Exception {
-    DefaultDiskStorage storage = getStorageSupplier(1).get();
-
-    final String resourceId1 = "resource1";
-    final byte[] value1 = new byte[100];
-    value1[80] = 101;
-    final String resourceId2 = "resource2";
-    final byte[] value2 = new byte[104];
-    value2[80] = 102;
-    final String resourceId3 = "resource3";
-    final byte[] value3 = new byte[106];
-    value3[80] = 103;
-
-    writeFileToStorage(storage, resourceId1, value1);
-
-    final long time2 = 1000L;
-    when(mClock.now()).thenReturn(time2);
-    writeFileToStorage(storage, resourceId2, value2);
-
-    when(mClock.now()).thenReturn(2000L);
-    writeFileToStorage(storage, resourceId3, value3);
-
-    List<File> files = findNewFiles(mDirectory, Collections.<File>emptySet(), /*recurse*/true);
-
-    // there should be 1 file per entry
-    assertEquals(3, files.size());
-
-    // now delete entry2
-    Collection<DiskStorage.Entry> entries = storage.getEntries();
-    for (DiskStorage.Entry entry : entries) {
-      if (Math.abs(entry.getTimestamp() - time2) < 500) {
-        storage.remove(entry);
-      }
+    private File mDirectory;
+    private SystemClock mClock;
+
+    @Before
+    public void before() throws Exception {
+        mClock = mock(SystemClock.class);
+        PowerMockito.mockStatic(SystemClock.class);
+        PowerMockito.when(SystemClock.get()).thenReturn(mClock);
+        mDirectory = new File(Robolectric.application.getCacheDir(), "sharded-disk-storage-test");
+        Assert.assertTrue(mDirectory.mkdirs());
+        FileTree.deleteContents(mDirectory);
     }
 
-    assertFalse(storage.contains(resourceId2, null));
-    List<File> remaining = findNewFiles(mDirectory, Collections.<File>emptySet(), /*recurse*/true);
-
-    // 2 entries remain
-    assertEquals(2, remaining.size());
-
-    // none of them with timestamp close to time2
-    List<DiskStorage.Entry> entries1 = Lists.newArrayList(storage.getEntries());
-    assertEquals(2, entries1.size());
-    // first
-    DiskStorage.Entry entry = entries1.get(0);
-    assertFalse(Math.abs(entry.getTimestamp() - time2) < 500);
-    // second
-    entry = entries1.get(1);
-    assertFalse(Math.abs(entry.getTimestamp() - time2) < 500);
-  }
-
-  @Test
-  public void testTouch() throws Exception {
-    DefaultDiskStorage storage = getStorageSupplier(1).get();
-    final long startTime = 0;
-
-    final String resourceId1 = "resource1";
-    final byte[] value1 = new byte[100];
-    final File file1 = writeFileToStorage(storage, resourceId1, value1);
-    assertTrue(Math.abs(file1.lastModified() - startTime) <= 500);
-
-    final long time2 = startTime + 10000;
-    when(mClock.now()).thenReturn(time2);
-    final String resourceId2 = "resource2";
-    final byte[] value2 = new byte[100];
-    final File file2 = writeFileToStorage(storage, resourceId2, value2);
-    assertTrue(Math.abs(file1.lastModified() - startTime) <= 500);
-    assertTrue(Math.abs(file2.lastModified() - time2) <= 500);
-
-    final long time3 = time2 + 10000;
-    when(mClock.now()).thenReturn(time3);
-    storage.touch(resourceId1, null);
-    assertTrue(Math.abs(file1.lastModified() - time3) <= 500);
-    assertTrue(Math.abs(file2.lastModified() - time2) <= 500);
-  }
-
-  @Test
-  public void testRemoveById() throws Exception {
-    final DefaultDiskStorage storage = getStorageSupplier(1).get();
-
-    final String resourceId1 = "resource1";
-    final byte[] value1 = new byte[100];
-    writeFileToStorage(storage, resourceId1, value1);
-    final String resourceId2 = "resource2";
-    final byte[] value2 = new byte[100];
-    writeFileToStorage(storage, resourceId2, value2);
-    final String resourceId3 = "resource3";
-    final byte[] value3 = new byte[100];
-    writeFileToStorage(storage, resourceId3, value3);
-
-    assertTrue(storage.contains(resourceId1, null));
-    assertTrue(storage.contains(resourceId2, null));
-    assertTrue(storage.contains(resourceId3, null));
-
-    storage.remove(resourceId2);
-    assertTrue(storage.contains(resourceId1, null));
-    assertFalse(storage.contains(resourceId2, null));
-    assertTrue(storage.contains(resourceId3, null));
-
-    storage.remove(resourceId1);
-    assertFalse(storage.contains(resourceId1, null));
-    assertFalse(storage.contains(resourceId2, null));
-    assertTrue(storage.contains(resourceId3, null));
-
-    storage.remove(resourceId3);
-    assertFalse(storage.contains(resourceId1, null));
-    assertFalse(storage.contains(resourceId2, null));
-    assertFalse(storage.contains(resourceId3, null));
-  }
-
-  @Test
-  public void testEntryImmutable() throws Exception {
-    DefaultDiskStorage storage = getStorageSupplier(1).get();
-
-    final String resourceId1 = "resource1";
-    final byte[] value1 = new byte[100];
-    value1[80] = 123;
-    final File file1 = writeFileToStorage(storage, resourceId1, value1);
-
-    assertEquals(100, file1.length());
-    List<DiskStorage.Entry> entries = storage.getEntries();
-    DiskStorage.Entry entry = entries.get(0);
-    long timestamp = entry.getTimestamp();
-    when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(1));
-    storage.getResource(resourceId1, null);
-
-    // now the new timestamp show be higher, but the entry should have the same value
-    List<DiskStorage.Entry> newEntries = storage.getEntries();
-    DiskStorage.Entry newEntry = newEntries.get(0);
-    assertTrue(timestamp < newEntry.getTimestamp());
-    assertEquals(timestamp, entry.getTimestamp());
-  }
-
-  @Test
-  public void testTempFileEviction() throws IOException {
-    when(mClock.now()).thenReturn(TimeUnit.DAYS.toMillis(1000));
-    DefaultDiskStorage storage = getStorageSupplier(1).get();
-
-    final String resourceId1 = "resource1";
-    final File tempFile = storage.createTemporary(resourceId1, null).getFile();
-
-    // Make sure that we don't evict a recent temp file
-    purgeUnexpectedFiles(storage);
-    assertTrue(tempFile.exists());
-
-    // Mark it old, then try eviction again. It should be gone.
-    if (!tempFile.setLastModified(mClock.now() - DefaultDiskStorage.TEMP_FILE_LIFETIME_MS - 1000)) {
-      throw new IOException("Unable to update timestamp of file: " + tempFile);
+    private Supplier<DefaultDiskStorage> getStorageSupplier(final int version) {
+        return new Supplier<DefaultDiskStorage>() {
+            @Override
+            public DefaultDiskStorage get() {
+                return new DefaultDiskStorage(
+                        mDirectory,
+                        version,
+                        mock(CacheErrorLogger.class));
+            }
+        };
     }
-    purgeUnexpectedFiles(storage);
-    assertFalse(tempFile.exists());
-  }
-
-  /**
-   * Test that purgeUnexpectedResources deletes all files/directories outside the version directory
-   * but leaves untouched the version directory and the content files.
-   * @throws Exception
-   */
-  @Test
-  public void testPurgeUnexpectedFiles() throws Exception {
-    final DiskStorage storage = getStorageSupplier(1).get();
-
-    final String resourceId = "file1";
-    final byte[] CONTENT = "content".getBytes("UTF-8");
-
-    File file = writeFileToStorage(storage, resourceId, CONTENT);
-
-    // check file exists
-    Assert.assertTrue(file.exists());
-    Assert.assertArrayEquals(CONTENT, Files.toByteArray(file));
-
-    final File unexpectedFile1 = new File(mDirectory, "unexpected-file-1");
-    final File unexpectedFile2 = new File(mDirectory, "unexpected-file-2");
-
-    Assert.assertTrue(unexpectedFile1.createNewFile());
-    Assert.assertTrue(unexpectedFile2.createNewFile());
-
-    final File unexpectedDir1 = new File(mDirectory, "unexpected-dir-1");
-    Assert.assertTrue(unexpectedDir1.mkdirs());
-
-    final File unexpectedDir2 = new File(mDirectory, "unexpected-dir-2");
-    Assert.assertTrue(unexpectedDir2.mkdirs());
-    final File unexpectedSubfile1 = new File(unexpectedDir2, "unexpected-sub-file-1");
-    Assert.assertTrue(unexpectedSubfile1.createNewFile());
-
-    Assert.assertEquals(5, mDirectory.listFiles().length); // 4 unexpected (files+dirs) + ver. dir
-    Assert.assertEquals(1, unexpectedDir2.listFiles().length);
-    Assert.assertEquals(0, unexpectedDir1.listFiles().length);
-
-    File unexpectedFileInShard = new File(file.getParentFile(), "unexpected-in-shard");
-    Assert.assertTrue(unexpectedFileInShard.createNewFile());
-
-    storage.purgeUnexpectedResources();
-    Assert.assertFalse(unexpectedFile1.exists());
-    Assert.assertFalse(unexpectedFile2.exists());
-    Assert.assertFalse(unexpectedSubfile1.exists());
-    Assert.assertFalse(unexpectedDir1.exists());
-    Assert.assertFalse(unexpectedDir2.exists());
-
-    // check file still exists
-    Assert.assertTrue(file.exists());
-    // check unexpected sibling is gone
-    Assert.assertFalse(unexpectedFileInShard.exists());
-    // check the only thing in root is the version directory
-    Assert.assertEquals(1, mDirectory.listFiles().length); // just the version directory
-  }
-
-  /**
-   * Tests that an existing directory is nuked when it's not current version (doens't have
-   * the version directory used for the structure)
-   * @throws Exception
-   */
-  @Test
-  public void testDirectoryIsNuked() throws Exception {
-    Assert.assertEquals(0, mDirectory.listFiles().length);
-
-    // create file before setting final test date
-    Assert.assertTrue(new File(mDirectory, "something-arbitrary").createNewFile());
-
-    long lastModified = mDirectory.lastModified() - 1000;
-    // some previous date to the "now" used for file creation
-    Assert.assertTrue(mDirectory.setLastModified(lastModified));
-    // check it was changed
-    Assert.assertEquals(lastModified, mDirectory.lastModified());
-
-    getStorageSupplier(1).get();
-
-    // mDirectory exists...
-    Assert.assertTrue(mDirectory.exists());
-    // but it was created now
-    Assert.assertTrue(lastModified < mDirectory.lastModified());
-  }
-
-  /**
-   * Tests that an existing directory is not nuked if the version directory used for the structure
-   * exists (so it's current version and doesn't suffer Samsung RFS problem)
-   * @throws Exception
-   */
-  @Test
-  public void testDirectoryIsNotNuked() throws Exception {
-    Assert.assertEquals(0, mDirectory.listFiles().length);
-
-    final DiskStorage storage = getStorageSupplier(1).get();
-    final String resourceId = "file1";
-
-    final byte[] CONTENT = "content".getBytes("UTF-8");
-
-    // create a file so we know version directory really exists
-    BinaryResource temporary = storage.createTemporary(resourceId, null);
-    writeToResource(storage, resourceId, temporary, CONTENT);
-    storage.commit(resourceId, temporary, null);
-
-    // assign some previous date to the "now" used for file creation
-    long lastModified = mDirectory.lastModified() - 1000;
-    Assert.assertTrue(mDirectory.setLastModified(lastModified));
-    // check it was changed
-    Assert.assertEquals(lastModified, mDirectory.lastModified());
-
-    // create again, it shouldn't delete the directory
-    getStorageSupplier(1).get();
-
-    // mDirectory exists...
-    Assert.assertTrue(mDirectory.exists());
-    // and it's the same as before
-    Assert.assertEquals(lastModified, mDirectory.lastModified());
-  }
-
-  /**
-   * Test the iterator returned is ok and deletion through the iterator is ok too.
-   * This is the required functionality that eviction needs.
-   * @throws Exception
-   */
-  @Test
-  public void testIterationAndRemoval() throws Exception {
-    DiskStorage storage = getStorageSupplier(1).get();
-    final String resourceId0 = "file0";
-    final String resourceId1 = "file1";
-    final String resourceId2 = "file2";
-    final String resourceId3 = "file3";
-
-    final byte[] CONTENT0 = "content0".getBytes("UTF-8");
-    final byte[] CONTENT1 = "content1-bigger".getBytes("UTF-8");
-    final byte[] CONTENT2 = "content2".getBytes("UTF-8");
-    final byte[] CONTENT3 = "content3-biggest".getBytes("UTF-8");
-
-    List<File> files = Lists.newArrayListWithCapacity(4);
-    files.add(write(storage, resourceId0, CONTENT0));
-    when(mClock.now()).thenReturn(1000L);
-    files.add(write(storage, resourceId1, CONTENT1));
-    when(mClock.now()).thenReturn(2000L);
-    files.add(write(storage, resourceId2, CONTENT2));
-    when(mClock.now()).thenReturn(3000L);
-    files.add(write(storage, resourceId3, CONTENT3));
-
-    List<DefaultDiskStorage.EntryImpl> entries = retrieveEntries(storage);
-    Assert.assertEquals(4, entries.size());
-    Assert.assertEquals(files.get(0), entries.get(0).getResource().getFile());
-    Assert.assertEquals(files.get(1), entries.get(1).getResource().getFile());
-    Assert.assertEquals(files.get(2), entries.get(2).getResource().getFile());
-    Assert.assertEquals(files.get(3), entries.get(3).getResource().getFile());
-
-    // try the same after removing 2 entries
-    for (DiskStorage.Entry entry : storage.getEntries()) {
-      // delete the 2 biggest files: key1 and key3 (see the content values)
-      if (entry.getSize() >= CONTENT1.length) {
-        storage.remove(entry);
-      }
+
+    @Test
+    public void testStartup() throws Exception {
+        // create a bogus file
+        File bogusFile = new File(mDirectory, "bogus");
+        Assert.assertTrue(bogusFile.createNewFile());
+
+        // create the storage now. Bogus files should be gone now
+        DefaultDiskStorage storage = getStorageSupplier(1).get();
+        Assert.assertFalse(bogusFile.exists());
+        String version1Dir = DefaultDiskStorage.getVersionSubdirectoryName(1);
+        Assert.assertTrue(new File(mDirectory, version1Dir).exists());
+
+        // create a new version
+        storage = getStorageSupplier(2).get();
+        Assert.assertNotNull(storage);
+        Assert.assertFalse(new File(mDirectory, version1Dir).exists());
+        String version2Dir = DefaultDiskStorage.getVersionSubdirectoryName(2);
+        Assert.assertTrue(new File(mDirectory, version2Dir).exists());
+    }
+
+    @Test
+    public void testIsEnabled() {
+        DefaultDiskStorage storage = getStorageSupplier(1).get();
+        Assert.assertTrue(storage.isEnabled());
+    }
+
+    @Test
+    public void testBasicOperations() throws Exception {
+        DefaultDiskStorage storage = getStorageSupplier(1).get();
+        final String resourceId1 = "R1";
+        final String resourceId2 = "R2";
+
+        // no file - get should fail
+        FileBinaryResource resource1 = storage.getResource(resourceId1, null);
+        Assert.assertNull(resource1);
+
+        // write out the file now
+        byte[] key1Contents = new byte[]{0, 1, 2};
+        writeToStorage(storage, resourceId1, key1Contents);
+        // get should succeed now
+        resource1 = storage.getResource(resourceId1, null);
+        Assert.assertNotNull(resource1);
+        Assert.assertArrayEquals(key1Contents, Files.toByteArray(resource1.getFile()));
+        // remove the file now - get should fail again
+        Assert.assertTrue(resource1.getFile().delete());
+        resource1 = storage.getResource(resourceId1, null);
+        Assert.assertNull(resource1);
+        // no file
+        FileBinaryResource resource2 = storage.getResource(resourceId2, null);
+        Assert.assertNull(resource2);
+    }
+
+    /**
+     * Test that a file is stored in a new file,
+     * and the bytes are stored plainly in the file.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testStoreFile() throws Exception {
+        DefaultDiskStorage storage = getStorageSupplier(1).get();
+        final String resourceId1 = "resource1";
+        final byte[] value1 = new byte[100];
+        value1[80] = 101;
+        File file1 = writeFileToStorage(storage, resourceId1, value1);
+
+        Set<File> files = Sets.newHashSet();
+        Assert.assertTrue(mDirectory.exists());
+        List<File> founds1 = findNewFiles(mDirectory, files, /*recurse*/true);
+        Assert.assertNotNull(file1);
+        Assert.assertTrue(founds1.contains(file1));
+        Assert.assertTrue(file1.exists());
+        assertEquals(100, file1.length());
+        Assert.assertArrayEquals(value1, Files.toByteArray(file1));
+    }
+
+    /**
+     * Inserts 3 files with different dates.
+     * Check what files are there.
+     * Uses an iterator to remove the one in the middle.
+     * Check that later.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testRemoveWithIterator() throws Exception {
+        DefaultDiskStorage storage = getStorageSupplier(1).get();
+
+        final String resourceId1 = "resource1";
+        final byte[] value1 = new byte[100];
+        value1[80] = 101;
+        final String resourceId2 = "resource2";
+        final byte[] value2 = new byte[104];
+        value2[80] = 102;
+        final String resourceId3 = "resource3";
+        final byte[] value3 = new byte[106];
+        value3[80] = 103;
+
+        writeFileToStorage(storage, resourceId1, value1);
+
+        final long time2 = 1000L;
+        when(mClock.now()).thenReturn(time2);
+        writeFileToStorage(storage, resourceId2, value2);
+
+        when(mClock.now()).thenReturn(2000L);
+        writeFileToStorage(storage, resourceId3, value3);
+
+        List<File> files = findNewFiles(mDirectory, Collections.<File>emptySet(), /*recurse*/true);
+
+        // there should be 1 file per entry
+        assertEquals(3, files.size());
+
+        // now delete entry2
+        Collection<DiskStorage.Entry> entries = storage.getEntries();
+        for (DiskStorage.Entry entry : entries) {
+            if (Math.abs(entry.getTimestamp() - time2) < 500) {
+                storage.remove(entry);
+            }
+        }
+
+        assertFalse(storage.contains(resourceId2, null));
+        List<File> remaining = findNewFiles(mDirectory, Collections.<File>emptySet(), /*recurse*/true);
+
+        // 2 entries remain
+        assertEquals(2, remaining.size());
+
+        // none of them with timestamp close to time2
+        List<DiskStorage.Entry> entries1 = Lists.newArrayList(storage.getEntries());
+        assertEquals(2, entries1.size());
+        // first
+        DiskStorage.Entry entry = entries1.get(0);
+        assertFalse(Math.abs(entry.getTimestamp() - time2) < 500);
+        // second
+        entry = entries1.get(1);
+        assertFalse(Math.abs(entry.getTimestamp() - time2) < 500);
+    }
+
+    @Test
+    public void testTouch() throws Exception {
+        DefaultDiskStorage storage = getStorageSupplier(1).get();
+        final long startTime = 0;
+
+        final String resourceId1 = "resource1";
+        final byte[] value1 = new byte[100];
+        final File file1 = writeFileToStorage(storage, resourceId1, value1);
+        assertTrue(Math.abs(file1.lastModified() - startTime) <= 500);
+
+        final long time2 = startTime + 10000;
+        when(mClock.now()).thenReturn(time2);
+        final String resourceId2 = "resource2";
+        final byte[] value2 = new byte[100];
+        final File file2 = writeFileToStorage(storage, resourceId2, value2);
+        assertTrue(Math.abs(file1.lastModified() - startTime) <= 500);
+        assertTrue(Math.abs(file2.lastModified() - time2) <= 500);
+
+        final long time3 = time2 + 10000;
+        when(mClock.now()).thenReturn(time3);
+        storage.touch(resourceId1, null);
+        assertTrue(Math.abs(file1.lastModified() - time3) <= 500);
+        assertTrue(Math.abs(file2.lastModified() - time2) <= 500);
+    }
+
+    @Test
+    public void testRemoveById() throws Exception {
+        final DefaultDiskStorage storage = getStorageSupplier(1).get();
+
+        final String resourceId1 = "resource1";
+        final byte[] value1 = new byte[100];
+        writeFileToStorage(storage, resourceId1, value1);
+        final String resourceId2 = "resource2";
+        final byte[] value2 = new byte[100];
+        writeFileToStorage(storage, resourceId2, value2);
+        final String resourceId3 = "resource3";
+        final byte[] value3 = new byte[100];
+        writeFileToStorage(storage, resourceId3, value3);
+
+        assertTrue(storage.contains(resourceId1, null));
+        assertTrue(storage.contains(resourceId2, null));
+        assertTrue(storage.contains(resourceId3, null));
+
+        storage.remove(resourceId2);
+        assertTrue(storage.contains(resourceId1, null));
+        assertFalse(storage.contains(resourceId2, null));
+        assertTrue(storage.contains(resourceId3, null));
+
+        storage.remove(resourceId1);
+        assertFalse(storage.contains(resourceId1, null));
+        assertFalse(storage.contains(resourceId2, null));
+        assertTrue(storage.contains(resourceId3, null));
+
+        storage.remove(resourceId3);
+        assertFalse(storage.contains(resourceId1, null));
+        assertFalse(storage.contains(resourceId2, null));
+        assertFalse(storage.contains(resourceId3, null));
     }
 
-    List<DefaultDiskStorage.EntryImpl> entriesAfterRemoval = retrieveEntries(storage);
-    Assert.assertEquals(2, entriesAfterRemoval.size());
-    Assert.assertEquals(files.get(0), entriesAfterRemoval.get(0).getResource().getFile());
-    Assert.assertEquals(files.get(2), entriesAfterRemoval.get(1).getResource().getFile());
-  }
-
-  private static FileBinaryResource writeToStorage(
-      final DiskStorage storage,
-      final String resourceId,
-      final byte[] value) throws IOException {
-    BinaryResource temporary = storage.createTemporary(resourceId, null);
-    writeToResource(storage, resourceId, temporary, value);
-    BinaryResource resource = storage.commit(resourceId, temporary, null);
-    return (FileBinaryResource)resource;
-  }
-
-  private static File writeFileToStorage(
-      DiskStorage storage,
-      String resourceId,
-      byte[] value) throws IOException {
-    return writeToStorage(storage, resourceId, value).getFile();
-  }
-
-  private static File write(
-      DiskStorage storage,
-      String resourceId,
-      byte[] content) throws IOException {
-    BinaryResource temporary = storage.createTemporary(resourceId, null);
-    File file = ((FileBinaryResource)temporary).getFile();
-    FileOutputStream fos = new FileOutputStream(file);
-    try {
-      fos.write(content);
-    } finally {
-      fos.close();
+    @Test
+    public void testEntryImmutable() throws Exception {
+        DefaultDiskStorage storage = getStorageSupplier(1).get();
+
+        final String resourceId1 = "resource1";
+        final byte[] value1 = new byte[100];
+        value1[80] = 123;
+        final File file1 = writeFileToStorage(storage, resourceId1, value1);
+
+        assertEquals(100, file1.length());
+        List<DiskStorage.Entry> entries = storage.getEntries();
+        DiskStorage.Entry entry = entries.get(0);
+        long timestamp = entry.getTimestamp();
+        when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(1));
+        storage.getResource(resourceId1, null);
+
+        // now the new timestamp show be higher, but the entry should have the same value
+        List<DiskStorage.Entry> newEntries = storage.getEntries();
+        DiskStorage.Entry newEntry = newEntries.get(0);
+        assertTrue(timestamp < newEntry.getTimestamp());
+        assertEquals(timestamp, entry.getTimestamp());
     }
-    return ((FileBinaryResource)storage.commit(resourceId, temporary, null)).getFile();
-  }
-
-  private static void writeToResource(
-      DiskStorage storage,
-      String resourceId,
-      BinaryResource resource,
-      final byte[] content) throws IOException {
-    storage.updateResource(resourceId, resource, new WriterCallback() {
-      @Override
-      public void write(OutputStream os) throws IOException {
-        os.write(content);
-      }
-    }, null);
-  }
-
-  private void purgeUnexpectedFiles(DefaultDiskStorage storage)
-      throws IOException {
-    storage.purgeUnexpectedResources();
-  }
-
-  private List<File> findNewFiles(File directory, Set<File> existing, boolean recurse) {
-    List<File> result = Lists.newArrayList();
-    findNewFiles(directory, existing, recurse, result);
-    return result;
-  }
-
-  private void findNewFiles(
-      File directory,
-      Set<File> existing,
-      boolean recurse,
-      List<File> result) {
-    File[] files = directory.listFiles();
-    if (files != null) {
-      for (File file: files) {
-        if (file.isDirectory() && recurse) {
-          findNewFiles(file, existing, true, result);
-        } else if (!existing.contains(file)) {
-          result.add(file);
+
+    @Test
+    public void testTempFileEviction() throws IOException {
+        when(mClock.now()).thenReturn(TimeUnit.DAYS.toMillis(1000));
+        DefaultDiskStorage storage = getStorageSupplier(1).get();
+
+        final String resourceId1 = "resource1";
+        final File tempFile = storage.createTemporary(resourceId1, null).getFile();
+
+        // Make sure that we don't evict a recent temp file
+        purgeUnexpectedFiles(storage);
+        assertTrue(tempFile.exists());
+
+        // Mark it old, then try eviction again. It should be gone.
+        if (!tempFile.setLastModified(mClock.now() - DefaultDiskStorage.TEMP_FILE_LIFETIME_MS - 1000)) {
+            throw new IOException("Unable to update timestamp of file: " + tempFile);
         }
-      }
+        purgeUnexpectedFiles(storage);
+        assertFalse(tempFile.exists());
+    }
+
+    /**
+     * Test that purgeUnexpectedResources deletes all files/directories outside the version directory
+     * but leaves untouched the version directory and the content files.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testPurgeUnexpectedFiles() throws Exception {
+        final DiskStorage storage = getStorageSupplier(1).get();
+
+        final String resourceId = "file1";
+        final byte[] CONTENT = "content".getBytes("UTF-8");
+
+        File file = writeFileToStorage(storage, resourceId, CONTENT);
+
+        // check file exists
+        Assert.assertTrue(file.exists());
+        Assert.assertArrayEquals(CONTENT, Files.toByteArray(file));
+
+        final File unexpectedFile1 = new File(mDirectory, "unexpected-file-1");
+        final File unexpectedFile2 = new File(mDirectory, "unexpected-file-2");
+
+        Assert.assertTrue(unexpectedFile1.createNewFile());
+        Assert.assertTrue(unexpectedFile2.createNewFile());
+
+        final File unexpectedDir1 = new File(mDirectory, "unexpected-dir-1");
+        Assert.assertTrue(unexpectedDir1.mkdirs());
+
+        final File unexpectedDir2 = new File(mDirectory, "unexpected-dir-2");
+        Assert.assertTrue(unexpectedDir2.mkdirs());
+        final File unexpectedSubfile1 = new File(unexpectedDir2, "unexpected-sub-file-1");
+        Assert.assertTrue(unexpectedSubfile1.createNewFile());
+
+        Assert.assertEquals(5, mDirectory.listFiles().length); // 4 unexpected (files+dirs) + ver. dir
+        Assert.assertEquals(1, unexpectedDir2.listFiles().length);
+        Assert.assertEquals(0, unexpectedDir1.listFiles().length);
+
+        File unexpectedFileInShard = new File(file.getParentFile(), "unexpected-in-shard");
+        Assert.assertTrue(unexpectedFileInShard.createNewFile());
+
+        storage.purgeUnexpectedResources();
+        Assert.assertFalse(unexpectedFile1.exists());
+        Assert.assertFalse(unexpectedFile2.exists());
+        Assert.assertFalse(unexpectedSubfile1.exists());
+        Assert.assertFalse(unexpectedDir1.exists());
+        Assert.assertFalse(unexpectedDir2.exists());
+
+        // check file still exists
+        Assert.assertTrue(file.exists());
+        // check unexpected sibling is gone
+        Assert.assertFalse(unexpectedFileInShard.exists());
+        // check the only thing in root is the version directory
+        Assert.assertEquals(1, mDirectory.listFiles().length); // just the version directory
     }
-  }
-
-  /**
-   * Retrieves a list of entries (the one returned by DiskStorage.Session.entriesIterator)
-   * ordered by timestamp.
-   * @param storage
-   */
-  private static List<DefaultDiskStorage.EntryImpl> retrieveEntries(
-      DiskStorage storage)
-      throws IOException {
-    List<DiskStorage.Entry> entries = Lists.newArrayList(storage.getEntries());
-
-    Collections.sort(entries, new Comparator<DiskStorage.Entry>() {
-      @Override
-      public int compare(DefaultDiskStorage.Entry a, DefaultDiskStorage.Entry b) {
-        long al = a.getTimestamp();
-        long bl = b.getTimestamp();
-        return (al < bl) ? -1 : ((al > bl) ? 1 : 0);
-      }
-    });
-    List<DefaultDiskStorage.EntryImpl> newEntries = Lists.newArrayList();
-    for (DiskStorage.Entry entry: entries) {
-      newEntries.add((DefaultDiskStorage.EntryImpl)entry);
+
+    /**
+     * Tests that an existing directory is nuked when it's not current version (doens't have
+     * the version directory used for the structure)
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testDirectoryIsNuked() throws Exception {
+        Assert.assertEquals(0, mDirectory.listFiles().length);
+
+        // create file before setting final test date
+        Assert.assertTrue(new File(mDirectory, "something-arbitrary").createNewFile());
+
+        long lastModified = mDirectory.lastModified() - 1000;
+        // some previous date to the "now" used for file creation
+        Assert.assertTrue(mDirectory.setLastModified(lastModified));
+        // check it was changed
+        Assert.assertEquals(lastModified, mDirectory.lastModified());
+
+        getStorageSupplier(1).get();
+
+        // mDirectory exists...
+        Assert.assertTrue(mDirectory.exists());
+        // but it was created now
+        Assert.assertTrue(lastModified < mDirectory.lastModified());
+    }
+
+    /**
+     * Tests that an existing directory is not nuked if the version directory used for the structure
+     * exists (so it's current version and doesn't suffer Samsung RFS problem)
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testDirectoryIsNotNuked() throws Exception {
+        Assert.assertEquals(0, mDirectory.listFiles().length);
+
+        final DiskStorage storage = getStorageSupplier(1).get();
+        final String resourceId = "file1";
+
+        final byte[] CONTENT = "content".getBytes("UTF-8");
+
+        // create a file so we know version directory really exists
+        BinaryResource temporary = storage.createTemporary(resourceId, null);
+        writeToResource(storage, resourceId, temporary, CONTENT);
+        storage.commit(resourceId, temporary, null);
+
+        // assign some previous date to the "now" used for file creation
+        long lastModified = mDirectory.lastModified() - 1000;
+        Assert.assertTrue(mDirectory.setLastModified(lastModified));
+        // check it was changed
+        Assert.assertEquals(lastModified, mDirectory.lastModified());
+
+        // create again, it shouldn't delete the directory
+        getStorageSupplier(1).get();
+
+        // mDirectory exists...
+        Assert.assertTrue(mDirectory.exists());
+        // and it's the same as before
+        Assert.assertEquals(lastModified, mDirectory.lastModified());
+    }
+
+    /**
+     * Test the iterator returned is ok and deletion through the iterator is ok too.
+     * This is the required functionality that eviction needs.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testIterationAndRemoval() throws Exception {
+        DiskStorage storage = getStorageSupplier(1).get();
+        final String resourceId0 = "file0";
+        final String resourceId1 = "file1";
+        final String resourceId2 = "file2";
+        final String resourceId3 = "file3";
+
+        final byte[] CONTENT0 = "content0".getBytes("UTF-8");
+        final byte[] CONTENT1 = "content1-bigger".getBytes("UTF-8");
+        final byte[] CONTENT2 = "content2".getBytes("UTF-8");
+        final byte[] CONTENT3 = "content3-biggest".getBytes("UTF-8");
+
+        List<File> files = Lists.newArrayListWithCapacity(4);
+        files.add(write(storage, resourceId0, CONTENT0));
+        when(mClock.now()).thenReturn(1000L);
+        files.add(write(storage, resourceId1, CONTENT1));
+        when(mClock.now()).thenReturn(2000L);
+        files.add(write(storage, resourceId2, CONTENT2));
+        when(mClock.now()).thenReturn(3000L);
+        files.add(write(storage, resourceId3, CONTENT3));
+
+        List<DefaultDiskStorage.EntryImpl> entries = retrieveEntries(storage);
+        Assert.assertEquals(4, entries.size());
+        Assert.assertEquals(files.get(0), entries.get(0).getResource().getFile());
+        Assert.assertEquals(files.get(1), entries.get(1).getResource().getFile());
+        Assert.assertEquals(files.get(2), entries.get(2).getResource().getFile());
+        Assert.assertEquals(files.get(3), entries.get(3).getResource().getFile());
+
+        // try the same after removing 2 entries
+        for (DiskStorage.Entry entry : storage.getEntries()) {
+            // delete the 2 biggest files: key1 and key3 (see the content values)
+            if (entry.getSize() >= CONTENT1.length) {
+                storage.remove(entry);
+            }
+        }
+
+        List<DefaultDiskStorage.EntryImpl> entriesAfterRemoval = retrieveEntries(storage);
+        Assert.assertEquals(2, entriesAfterRemoval.size());
+        Assert.assertEquals(files.get(0), entriesAfterRemoval.get(0).getResource().getFile());
+        Assert.assertEquals(files.get(2), entriesAfterRemoval.get(1).getResource().getFile());
+    }
+
+    private static FileBinaryResource writeToStorage(
+            final DiskStorage storage,
+            final String resourceId,
+            final byte[] value) throws IOException {
+        BinaryResource temporary = storage.createTemporary(resourceId, null);
+        writeToResource(storage, resourceId, temporary, value);
+        BinaryResource resource = storage.commit(resourceId, temporary, null);
+        return (FileBinaryResource) resource;
+    }
+
+    private static File writeFileToStorage(
+            DiskStorage storage,
+            String resourceId,
+            byte[] value) throws IOException {
+        return writeToStorage(storage, resourceId, value).getFile();
+    }
+
+    private static File write(
+            DiskStorage storage,
+            String resourceId,
+            byte[] content) throws IOException {
+        BinaryResource temporary = storage.createTemporary(resourceId, null);
+        File file = ((FileBinaryResource) temporary).getFile();
+        FileOutputStream fos = new FileOutputStream(file);
+        try {
+            fos.write(content);
+        } finally {
+            fos.close();
+        }
+        return ((FileBinaryResource) storage.commit(resourceId, temporary, null)).getFile();
+    }
+
+    private static void writeToResource(
+            DiskStorage storage,
+            String resourceId,
+            BinaryResource resource,
+            final byte[] content) throws IOException {
+        storage.updateResource(resourceId, resource, new WriterCallback() {
+            @Override
+            public void write(OutputStream os) throws IOException {
+                os.write(content);
+            }
+        }, null);
+    }
+
+    private void purgeUnexpectedFiles(DefaultDiskStorage storage)
+            throws IOException {
+        storage.purgeUnexpectedResources();
+    }
+
+    private List<File> findNewFiles(File directory, Set<File> existing, boolean recurse) {
+        List<File> result = Lists.newArrayList();
+        findNewFiles(directory, existing, recurse, result);
+        return result;
+    }
+
+    private void findNewFiles(
+            File directory,
+            Set<File> existing,
+            boolean recurse,
+            List<File> result) {
+        File[] files = directory.listFiles();
+        if (files != null) {
+            for (File file : files) {
+                if (file.isDirectory() && recurse) {
+                    findNewFiles(file, existing, true, result);
+                } else if (!existing.contains(file)) {
+                    result.add(file);
+                }
+            }
+        }
+    }
+
+    /**
+     * Retrieves a list of entries (the one returned by DiskStorage.Session.entriesIterator)
+     * ordered by timestamp.
+     *
+     * @param storage
+     */
+    private static List<DefaultDiskStorage.EntryImpl> retrieveEntries(
+            DiskStorage storage)
+            throws IOException {
+        List<DiskStorage.Entry> entries = Lists.newArrayList(storage.getEntries());
+
+        Collections.sort(entries, new Comparator<DiskStorage.Entry>() {
+            @Override
+            public int compare(DefaultDiskStorage.Entry a, DefaultDiskStorage.Entry b) {
+                long al = a.getTimestamp();
+                long bl = b.getTimestamp();
+                return (al < bl) ? -1 : ((al > bl) ? 1 : 0);
+            }
+        });
+        List<DefaultDiskStorage.EntryImpl> newEntries = Lists.newArrayList();
+        for (DiskStorage.Entry entry : entries) {
+            newEntries.add((DefaultDiskStorage.EntryImpl) entry);
+        }
+        return newEntries;
     }
-    return newEntries;
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/cache/disk/DiskStorageCacheTest.java b/imagepipeline/src/test/java/com/facebook/cache/disk/DiskStorageCacheTest.java
index 8b9e5cf13..f8914c9f4 100644
--- a/imagepipeline/src/test/java/com/facebook/cache/disk/DiskStorageCacheTest.java
+++ b/imagepipeline/src/test/java/com/facebook/cache/disk/DiskStorageCacheTest.java
@@ -58,419 +58,419 @@
 @PrepareOnlyThisForTest({SystemClock.class})
 public class DiskStorageCacheTest {
 
-  private static final String CACHE_TYPE = "media_test";
-
-  private static final int TESTCACHE_VERSION_START_OF_VERSIONING = 1;
-  private static final int TESTCACHE_CURRENT_VERSION = TESTCACHE_VERSION_START_OF_VERSIONING;
-  private static final int TESTCACHE_NEXT_VERSION = TESTCACHE_CURRENT_VERSION + 1;
-
-  private File mCacheDirectory;
-  private DiskStorageSupplier mStorageSupplier;
-  private DiskStorageCache mCache;
-  private DiskTrimmableRegistry mDiskTrimmableRegistry;
-  private CacheEventListener mCacheEventListener;
-  private SystemClock mClock;
-
-  @Before
-  public void setUp() {
-    mClock = mock(SystemClock.class);
-    PowerMockito.mockStatic(SystemClock.class);
-    PowerMockito.when(SystemClock.get()).thenReturn(mClock);
-    mDiskTrimmableRegistry = mock(DiskTrimmableRegistry.class);
-    mCacheEventListener = mock(CacheEventListener.class);
-
-    // we know the directory will be this
-    mCacheDirectory = new File(Robolectric.application.getCacheDir(), CACHE_TYPE);
-    mCacheDirectory.mkdirs();
-    if (!mCacheDirectory.exists()) {
-      throw new RuntimeException(
-          String.format(
-              (Locale) null,
-              "Cannot create cache dir: %s: directory %s",
-              mCacheDirectory.getAbsolutePath(),
-              mCacheDirectory.exists() ? "already exists" : "does not exist"));
+    private static final String CACHE_TYPE = "media_test";
+
+    private static final int TESTCACHE_VERSION_START_OF_VERSIONING = 1;
+    private static final int TESTCACHE_CURRENT_VERSION = TESTCACHE_VERSION_START_OF_VERSIONING;
+    private static final int TESTCACHE_NEXT_VERSION = TESTCACHE_CURRENT_VERSION + 1;
+
+    private File mCacheDirectory;
+    private DiskStorageSupplier mStorageSupplier;
+    private DiskStorageCache mCache;
+    private DiskTrimmableRegistry mDiskTrimmableRegistry;
+    private CacheEventListener mCacheEventListener;
+    private SystemClock mClock;
+
+    @Before
+    public void setUp() {
+        mClock = mock(SystemClock.class);
+        PowerMockito.mockStatic(SystemClock.class);
+        PowerMockito.when(SystemClock.get()).thenReturn(mClock);
+        mDiskTrimmableRegistry = mock(DiskTrimmableRegistry.class);
+        mCacheEventListener = mock(CacheEventListener.class);
+
+        // we know the directory will be this
+        mCacheDirectory = new File(Robolectric.application.getCacheDir(), CACHE_TYPE);
+        mCacheDirectory.mkdirs();
+        if (!mCacheDirectory.exists()) {
+            throw new RuntimeException(
+                    String.format(
+                            (Locale) null,
+                            "Cannot create cache dir: %s: directory %s",
+                            mCacheDirectory.getAbsolutePath(),
+                            mCacheDirectory.exists() ? "already exists" : "does not exist"));
+        }
+        mStorageSupplier = createDiskStorageSupplier(TESTCACHE_VERSION_START_OF_VERSIONING);
+        mCache = createDiskCache(mStorageSupplier);
+        verify(mDiskTrimmableRegistry).registerDiskTrimmable(mCache);
     }
-    mStorageSupplier = createDiskStorageSupplier(TESTCACHE_VERSION_START_OF_VERSIONING);
-    mCache = createDiskCache(mStorageSupplier);
-    verify(mDiskTrimmableRegistry).registerDiskTrimmable(mCache);
-  }
-
-  // The threshold (in bytes) for the size of file cache
-  private static final long FILE_CACHE_MAX_SIZE_HIGH_LIMIT = 200;
-  private static final long FILE_CACHE_MAX_SIZE_LOW_LIMIT = 200;
-
-  private DiskStorageSupplier createDiskStorageSupplier(int version) {
-    return new DefaultDiskStorageSupplier(
-        version,
-        Suppliers.of(Robolectric.application.getApplicationContext().getCacheDir()),
-        CACHE_TYPE,
-        mock(CacheErrorLogger.class));
-  }
-
-  private DiskStorageCache createDiskCache(DiskStorageSupplier diskStorageSupplier) {
-    DiskStorageCache.Params diskStorageCacheParams =
-        new DiskStorageCache.Params(
-            0,
-            FILE_CACHE_MAX_SIZE_LOW_LIMIT,
-            FILE_CACHE_MAX_SIZE_HIGH_LIMIT);
-
-    return new DiskStorageCache(
-        diskStorageSupplier,
-        diskStorageCacheParams,
-        mCacheEventListener,
-        mock(CacheErrorLogger.class),
-        mDiskTrimmableRegistry);
-  }
-
-  @Test
-  public void testCacheEventListener() throws Exception {
-    // 1. Add first cache file
-    CacheKey key1 = new SimpleCacheKey("foo");
-    byte[] value1 = new byte[101];
-    value1[80] = 'c'; // just so it's not all zeros for the equality test below.
-    BinaryResource resource1 = mCache.insert(key1, WriterCallbacks.from(value1));
-    verify(mCacheEventListener).onWriteAttempt();
-
-    BinaryResource resource1Again = mCache.getResource(key1);
-    assertEquals(resource1, resource1Again);
-    verify(mCacheEventListener).onHit();
-    BinaryResource resource1Again2 = mCache.getResource(key1);
-    assertEquals(resource1, resource1Again2);
-    verify(mCacheEventListener, times(2)).onHit();
-
-    BinaryResource res2 = mCache.getResource(new SimpleCacheKey("nonexistent_key"));
-    assertNull(res2);
-    verify(mCacheEventListener).onMiss();
-
-    verifyNoMoreInteractions(mCacheEventListener);
-  }
-
-
-  private BinaryResource getResource(
-      DiskStorageSupplier supplier,
-      final CacheKey key) throws IOException {
-     return supplier.get().getResource(mCache.getResourceId(key), key);
-  }
-
-  private BinaryResource getResource(final CacheKey key) throws IOException {
-    return mStorageSupplier.get().getResource(mCache.getResourceId(key), key);
-  }
-
-  private byte[] getContents(BinaryResource resource) throws IOException {
-    return ByteStreams.toByteArray(resource.openStream());
-  }
-
-  /**
-   * Tests size based file eviction of cache files. Also tests that unexpected
-   * files (which are not in the format expected by the cache) do not count
-   * towards the cache size, and are also evicted during both evictions (LRU and Old).
-   *
-   * @throws Exception
-   */
-  @Test
-  public void testCacheFile() throws Exception {
-    if (!mCacheDirectory.exists() && !mCacheDirectory.mkdirs()) {
-      throw new RuntimeException("Cannot create cache dir");
+
+    // The threshold (in bytes) for the size of file cache
+    private static final long FILE_CACHE_MAX_SIZE_HIGH_LIMIT = 200;
+    private static final long FILE_CACHE_MAX_SIZE_LOW_LIMIT = 200;
+
+    private DiskStorageSupplier createDiskStorageSupplier(int version) {
+        return new DefaultDiskStorageSupplier(
+                version,
+                Suppliers.of(Robolectric.application.getApplicationContext().getCacheDir()),
+                CACHE_TYPE,
+                mock(CacheErrorLogger.class));
     }
-    // Write non-cache, non-lru file in the cache directory
-    File unexpected1 = new File(mCacheDirectory, "unexpected1");
-    RandomAccessFile rf1 = new RandomAccessFile(unexpected1, "rw");
-    rf1.setLength(110);
-    // Touch the non-cache, non-lru file, and assert that it succeeds.
-    when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(1));
-    assertTrue(unexpected1.setLastModified(mClock.now()));
-
-    // 1. Add first cache file
-    CacheKey key1 = new SimpleCacheKey("foo");
-    byte[] value1 = new byte[101];
-    value1[80] = 'c'; // just so it's not all zeros for the equality test below.
-    mCache.insert(key1, WriterCallbacks.from(value1));
-
-    // verify resource
-    assertArrayEquals(value1, getContents(getResource(key1)));
-
-    // 1. Touch the LRU file, and assert that it succeeds.
-    // Note: It might seem more natural to increment the clock before calling
-    // MediaCache.insertCachedMedia() to apply a desired timestamp to the
-    // files. But the time is being explicitly modified here so that any
-    // failures in setting/re-setting file timestamps are caught by the assert,
-    // instead of being hidden inside MediaCache code that can lead to
-    // intermittent test failures which are very tricky to debug.
-    // Note: For MediaCache.markForLru() to update the lru time, the clock
-    // needs to be incremented by at least MediaCache.CACHE_UPDATE_PERIOD_MS
-    when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(2));
-    assertTrue(mCache.probe(key1));
-
-    // The cache size should be the size of the first file only
-    // The unexpected files should not count towards size
-    assertTrue(mCache.getSize() == 101);
-
-    // Write another non-cache, non-lru file in the cache directory
-    File unexpected2 = new File(mCacheDirectory, "unexpected2");
-    RandomAccessFile rf2 = new RandomAccessFile(unexpected2, "rw");
-    rf2.setLength(120);
-    // Touch the non-cache, non-lru file, and assert that it succeeds.
-    when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(3));
-    assertTrue(unexpected2.setLastModified(mClock.now()));
-
-    // 2. Add second cache file
-    CacheKey key2 = new SimpleCacheKey("bar");
-    byte[] value2 = new byte[102];
-    value2[80] = 'd'; // just so it's not all zeros for the equality test below.
-    mCache.insert(key2, WriterCallbacks.from(value2));
-    // 2. Touch the LRU file, and assert that it succeeds.
-    when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(4));
-    assertTrue(mCache.probe(key2));
-
-    // The cache size should be the size of the first + second cache files
-    // The unexpected files should not count towards size
-    assertTrue(mCache.getSize() == 203);
-
-    // At this point, the filecache size has exceeded
-    // FILE_CACHE_MAX_SIZE_HIGH_LIMIT. However, eviction will be triggered
-    // only when the next value will be inserted (to be more particular,
-    // before the next value is inserted).
-
-    // 3. Add third cache file
-    CacheKey key3 = new SimpleCacheKey("foobar");
-    byte[] value3 = new byte[103];
-    value3[80] = 'e'; // just so it's not all zeros for the equality test below.
-    mCache.insert(key3, WriterCallbacks.from(value3));
-
-    // At this point, the first file should have been evicted. Only the
-    // files associated with the second and third entries should be in cache.
-
-    // 1. Verify that the first cache, lru files are deleted
-    assertNull(getResource(key1));
-
-    // Verify the first unexpected file is deleted, but that eviction stops
-    // before the second unexpected file
-    assertFalse(unexpected1.exists());
-    assertFalse(unexpected2.exists());
-
-    // 2. Verify the second cache, lru files exist
-    assertArrayEquals(value2, getContents(getResource(key2)));
-
-    // 3. Verify that cache, lru files for third entry still exists
-    assertArrayEquals(value3, getContents(getResource(key3)));
-
-    // The cache size should be the size of the second + third files
-    assertTrue(mCache.getSize() == 205);
-
-    // Write another non-cache, non-lru file in the cache directory
-    File unexpected3 = new File(mCacheDirectory, "unexpected3");
-    RandomAccessFile rf3 = new RandomAccessFile(unexpected3, "rw");
-    rf3.setLength(120);
-    assertTrue(unexpected3.exists());
-    // After a clear, cache file size should be uninitialized (-1)
-    mCache.clearAll();
-    assertEquals(-1, mCache.getSize());
-    assertFalse(unexpected3.exists());
-    assertNull(getResource(key2));
-    assertNull(getResource(key3));
-  }
-
-  @Test
-  public void testCacheFileWithIOException() throws IOException {
-    CacheKey key1 = new SimpleCacheKey("aaa");
-
-    // Before inserting, make sure files not exist.
-    final BinaryResource resource1 = getResource(key1);
-    assertNull(resource1);
-
-
-    // Should not create cache files if IOException happens in the middle.
-    try {
-      mCache.insert(
-          key1, new WriterCallback() {
-            @Override
-            public void write(OutputStream os) throws IOException {
-              throw new IOException();
-            }
-          });
-      fail();
-    } catch (IOException e) {
-      assertNull(getResource(key1));
+
+    private DiskStorageCache createDiskCache(DiskStorageSupplier diskStorageSupplier) {
+        DiskStorageCache.Params diskStorageCacheParams =
+                new DiskStorageCache.Params(
+                        0,
+                        FILE_CACHE_MAX_SIZE_LOW_LIMIT,
+                        FILE_CACHE_MAX_SIZE_HIGH_LIMIT);
+
+        return new DiskStorageCache(
+                diskStorageSupplier,
+                diskStorageCacheParams,
+                mCacheEventListener,
+                mock(CacheErrorLogger.class),
+                mDiskTrimmableRegistry);
     }
 
-    try {
-      // Should create cache files if everything is ok.
-      mCache.insert(key1, WriterCallbacks.from(new byte[100]));
-      assertNotNull(getResource(key1));
-    } catch (IOException e) {
-      fail();
+    @Test
+    public void testCacheEventListener() throws Exception {
+        // 1. Add first cache file
+        CacheKey key1 = new SimpleCacheKey("foo");
+        byte[] value1 = new byte[101];
+        value1[80] = 'c'; // just so it's not all zeros for the equality test below.
+        BinaryResource resource1 = mCache.insert(key1, WriterCallbacks.from(value1));
+        verify(mCacheEventListener).onWriteAttempt();
+
+        BinaryResource resource1Again = mCache.getResource(key1);
+        assertEquals(resource1, resource1Again);
+        verify(mCacheEventListener).onHit();
+        BinaryResource resource1Again2 = mCache.getResource(key1);
+        assertEquals(resource1, resource1Again2);
+        verify(mCacheEventListener, times(2)).onHit();
+
+        BinaryResource res2 = mCache.getResource(new SimpleCacheKey("nonexistent_key"));
+        assertNull(res2);
+        verify(mCacheEventListener).onMiss();
+
+        verifyNoMoreInteractions(mCacheEventListener);
     }
 
-    // Should not create a new file if reading hits an IOException.
-    CacheKey key2 = new SimpleCacheKey("bbb");
-    try {
-      mCache.insert(
-          key2, new WriterCallback() {
-            @Override
-            public void write(OutputStream os) throws IOException {
-              throw new IOException();
-            }
-          });
-      fail();
-    } catch (IOException e) {
-      assertNull(getResource(key2));
+
+    private BinaryResource getResource(
+            DiskStorageSupplier supplier,
+            final CacheKey key) throws IOException {
+        return supplier.get().getResource(mCache.getResourceId(key), key);
+    }
+
+    private BinaryResource getResource(final CacheKey key) throws IOException {
+        return mStorageSupplier.get().getResource(mCache.getResourceId(key), key);
     }
-  }
-
-  @Test
-  public void testCleanOldCache() throws IOException, NoSuchFieldException, IllegalAccessException {
-    long cacheExpirationMs = TimeUnit.DAYS.toMillis(5);
-    int value1size = 41;
-    int value2size = 42;
-    CacheKey key1 = new SimpleCacheKey("aaa");
-    byte[] value1 = new byte[value1size];
-    value1[25] = 'a';
-    mCache.insert(key1, WriterCallbacks.from(value1));
-
-    CacheKey key2 = new SimpleCacheKey("bbb");
-    byte[] value2 = new byte[value2size];
-    value2[25] = 'b';
-    mCache.insert(key2, WriterCallbacks.from(value2));
-
-    // Increment clock by default expiration time + 1 day
-    when(mClock.now())
-        .thenReturn(cacheExpirationMs + TimeUnit.DAYS.toMillis(1));
-
-    CacheKey key3 = new SimpleCacheKey("ccc");
-    byte[] value3 = new byte[43];
-    value3[25] = 'c';
-    mCache.insert(key3, WriterCallbacks.from(value3));
-    long valueAge3 = TimeUnit.HOURS.toMillis(1);
-    when(mClock.now()).thenReturn(
-        cacheExpirationMs+ TimeUnit.DAYS.toMillis(1) + valueAge3);
-
-    long oldestEntry = mCache.clearOldEntries(cacheExpirationMs);
-    assertEquals(valueAge3, oldestEntry);
-
-    assertArrayEquals(value3, getContents(getResource(key3)));
-    assertNull(getResource(key1));
-    assertNull(getResource(key2));
-
-    verify(mCacheEventListener)
-        .onEviction(CacheEventListener.EvictionReason.CONTENT_STALE, 2, value1size + value2size);
-  }
-
-  @Test
-  public void testCleanOldCacheNoEntriesRemaining() throws IOException {
-    long cacheExpirationMs = TimeUnit.DAYS.toMillis(5);
-    CacheKey key1 = new SimpleCacheKey("aaa");
-    byte[] value1 = new byte[41];
-    mCache.insert(key1, WriterCallbacks.from(value1));
-
-    CacheKey key2 = new SimpleCacheKey("bbb");
-    byte[] value2 = new byte[42];
-    mCache.insert(key2, WriterCallbacks.from(value2));
-
-    // Increment clock by default expiration time + 1 day
-    when(mClock.now())
-        .thenReturn(cacheExpirationMs+ TimeUnit.DAYS.toMillis(1));
-
-    long oldestEntry = mCache.clearOldEntries(cacheExpirationMs);
-    assertEquals(0L, oldestEntry);
-  }
-
-  /**
-   * Test to make sure that the same item stored with two different versions
-   * of the cache will be stored with two different file names.
-   *
-   * @throws UnsupportedEncodingException
-   */
-  @Test
-  public void testVersioning() throws IOException {
-
-    // Define data that will be written to cache
-    CacheKey key = new SimpleCacheKey("version_test");
-    byte[] value = new byte[32];
-    value[0] = 'v';
-
-    // Set up cache with version == 1
-    DiskStorageSupplier storageSupplier1 = createDiskStorageSupplier(TESTCACHE_CURRENT_VERSION);
-    DiskStorageCache cache1 = createDiskCache(storageSupplier1);
-
-    // Write test data to cache 1
-    cache1.insert(key, WriterCallbacks.from(value));
-
-    // Get cached file
-    BinaryResource resource1 = getResource(storageSupplier1, key);
-    assertNotNull(resource1);
-
-    // Set up cache with version == 2
-    DiskStorageSupplier storageSupplier2 =
-        createDiskStorageSupplier(TESTCACHE_NEXT_VERSION);
-    DiskStorageCache cache2 = createDiskCache(storageSupplier2);
-
-    // Write test data to cache 2
-    cache2.insert(key, WriterCallbacks.from(value));
-
-    // Get cached file
-    BinaryResource resource2 = getResource(storageSupplier2, key);
-    assertNotNull(resource2);
-
-    // Make sure filenames of the two file are different
-    assertFalse(resource2.equals(resource1));
-  }
-
-  /**
-   * Verify that multiple threads can write to the cache at the same time.
-   */
-  @Test
-  public void testConcurrency() throws Exception {
-    final CyclicBarrier barrier = new CyclicBarrier(3);
-    WriterCallback writerCallback = new WriterCallback() {
-      @Override
-      public void write(OutputStream os) throws IOException {
+
+    private byte[] getContents(BinaryResource resource) throws IOException {
+        return ByteStreams.toByteArray(resource.openStream());
+    }
+
+    /**
+     * Tests size based file eviction of cache files. Also tests that unexpected
+     * files (which are not in the format expected by the cache) do not count
+     * towards the cache size, and are also evicted during both evictions (LRU and Old).
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testCacheFile() throws Exception {
+        if (!mCacheDirectory.exists() && !mCacheDirectory.mkdirs()) {
+            throw new RuntimeException("Cannot create cache dir");
+        }
+        // Write non-cache, non-lru file in the cache directory
+        File unexpected1 = new File(mCacheDirectory, "unexpected1");
+        RandomAccessFile rf1 = new RandomAccessFile(unexpected1, "rw");
+        rf1.setLength(110);
+        // Touch the non-cache, non-lru file, and assert that it succeeds.
+        when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(1));
+        assertTrue(unexpected1.setLastModified(mClock.now()));
+
+        // 1. Add first cache file
+        CacheKey key1 = new SimpleCacheKey("foo");
+        byte[] value1 = new byte[101];
+        value1[80] = 'c'; // just so it's not all zeros for the equality test below.
+        mCache.insert(key1, WriterCallbacks.from(value1));
+
+        // verify resource
+        assertArrayEquals(value1, getContents(getResource(key1)));
+
+        // 1. Touch the LRU file, and assert that it succeeds.
+        // Note: It might seem more natural to increment the clock before calling
+        // MediaCache.insertCachedMedia() to apply a desired timestamp to the
+        // files. But the time is being explicitly modified here so that any
+        // failures in setting/re-setting file timestamps are caught by the assert,
+        // instead of being hidden inside MediaCache code that can lead to
+        // intermittent test failures which are very tricky to debug.
+        // Note: For MediaCache.markForLru() to update the lru time, the clock
+        // needs to be incremented by at least MediaCache.CACHE_UPDATE_PERIOD_MS
+        when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(2));
+        assertTrue(mCache.probe(key1));
+
+        // The cache size should be the size of the first file only
+        // The unexpected files should not count towards size
+        assertTrue(mCache.getSize() == 101);
+
+        // Write another non-cache, non-lru file in the cache directory
+        File unexpected2 = new File(mCacheDirectory, "unexpected2");
+        RandomAccessFile rf2 = new RandomAccessFile(unexpected2, "rw");
+        rf2.setLength(120);
+        // Touch the non-cache, non-lru file, and assert that it succeeds.
+        when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(3));
+        assertTrue(unexpected2.setLastModified(mClock.now()));
+
+        // 2. Add second cache file
+        CacheKey key2 = new SimpleCacheKey("bar");
+        byte[] value2 = new byte[102];
+        value2[80] = 'd'; // just so it's not all zeros for the equality test below.
+        mCache.insert(key2, WriterCallbacks.from(value2));
+        // 2. Touch the LRU file, and assert that it succeeds.
+        when(mClock.now()).thenReturn(TimeUnit.HOURS.toMillis(4));
+        assertTrue(mCache.probe(key2));
+
+        // The cache size should be the size of the first + second cache files
+        // The unexpected files should not count towards size
+        assertTrue(mCache.getSize() == 203);
+
+        // At this point, the filecache size has exceeded
+        // FILE_CACHE_MAX_SIZE_HIGH_LIMIT. However, eviction will be triggered
+        // only when the next value will be inserted (to be more particular,
+        // before the next value is inserted).
+
+        // 3. Add third cache file
+        CacheKey key3 = new SimpleCacheKey("foobar");
+        byte[] value3 = new byte[103];
+        value3[80] = 'e'; // just so it's not all zeros for the equality test below.
+        mCache.insert(key3, WriterCallbacks.from(value3));
+
+        // At this point, the first file should have been evicted. Only the
+        // files associated with the second and third entries should be in cache.
+
+        // 1. Verify that the first cache, lru files are deleted
+        assertNull(getResource(key1));
+
+        // Verify the first unexpected file is deleted, but that eviction stops
+        // before the second unexpected file
+        assertFalse(unexpected1.exists());
+        assertFalse(unexpected2.exists());
+
+        // 2. Verify the second cache, lru files exist
+        assertArrayEquals(value2, getContents(getResource(key2)));
+
+        // 3. Verify that cache, lru files for third entry still exists
+        assertArrayEquals(value3, getContents(getResource(key3)));
+
+        // The cache size should be the size of the second + third files
+        assertTrue(mCache.getSize() == 205);
+
+        // Write another non-cache, non-lru file in the cache directory
+        File unexpected3 = new File(mCacheDirectory, "unexpected3");
+        RandomAccessFile rf3 = new RandomAccessFile(unexpected3, "rw");
+        rf3.setLength(120);
+        assertTrue(unexpected3.exists());
+        // After a clear, cache file size should be uninitialized (-1)
+        mCache.clearAll();
+        assertEquals(-1, mCache.getSize());
+        assertFalse(unexpected3.exists());
+        assertNull(getResource(key2));
+        assertNull(getResource(key3));
+    }
+
+    @Test
+    public void testCacheFileWithIOException() throws IOException {
+        CacheKey key1 = new SimpleCacheKey("aaa");
+
+        // Before inserting, make sure files not exist.
+        final BinaryResource resource1 = getResource(key1);
+        assertNull(resource1);
+
+
+        // Should not create cache files if IOException happens in the middle.
         try {
-          // Both threads will need to hit this barrier. If writing is serialized,
-          // the second thread will never reach here as the first will hold
-          // the write lock forever.
-          barrier.await(10, TimeUnit.SECONDS);
-        } catch (Exception e) {
-          throw new RuntimeException(e);
+            mCache.insert(
+                    key1, new WriterCallback() {
+                        @Override
+                        public void write(OutputStream os) throws IOException {
+                            throw new IOException();
+                        }
+                    });
+            fail();
+        } catch (IOException e) {
+            assertNull(getResource(key1));
         }
-      }
-    };
-    CacheKey key1 = new SimpleCacheKey("concurrent1");
-    CacheKey key2 = new SimpleCacheKey("concurrent2");
-    Thread t1 = runInsertionInSeparateThread(key1, writerCallback);
-    Thread t2 = runInsertionInSeparateThread(key2, writerCallback);
-    barrier.await(10, TimeUnit.SECONDS);
-    t1.join(1000);
-    t2.join(1000);
-  }
-
-  @Test
-  public void testIsEnabled() throws Exception {
-    DiskStorage storageMock = mock(DiskStorage.class);
-    when(storageMock.isEnabled()).thenReturn(true).thenReturn(false);
-    DiskStorageSupplier supplierMock = mock(DiskStorageSupplier.class);
-    when(supplierMock.get()).thenReturn(storageMock);
-
-    DiskStorageCache cache = createDiskCache(supplierMock);
-    assertTrue(cache.isEnabled());
-    assertFalse(cache.isEnabled());
-  }
-
-  private Thread runInsertionInSeparateThread(final CacheKey key,
-      final WriterCallback callback) {
-    Runnable runnable = new Runnable() {
-
-      @Override
-      public void run() {
+
         try {
-          mCache.insert(key, callback);
+            // Should create cache files if everything is ok.
+            mCache.insert(key1, WriterCallbacks.from(new byte[100]));
+            assertNotNull(getResource(key1));
         } catch (IOException e) {
-          fail();
+            fail();
         }
-      }
-    };
-    Thread thread = new Thread(runnable);
-    thread.setDaemon(true);
-    thread.start();
-    return thread;
-  }
+
+        // Should not create a new file if reading hits an IOException.
+        CacheKey key2 = new SimpleCacheKey("bbb");
+        try {
+            mCache.insert(
+                    key2, new WriterCallback() {
+                        @Override
+                        public void write(OutputStream os) throws IOException {
+                            throw new IOException();
+                        }
+                    });
+            fail();
+        } catch (IOException e) {
+            assertNull(getResource(key2));
+        }
+    }
+
+    @Test
+    public void testCleanOldCache() throws IOException, NoSuchFieldException, IllegalAccessException {
+        long cacheExpirationMs = TimeUnit.DAYS.toMillis(5);
+        int value1size = 41;
+        int value2size = 42;
+        CacheKey key1 = new SimpleCacheKey("aaa");
+        byte[] value1 = new byte[value1size];
+        value1[25] = 'a';
+        mCache.insert(key1, WriterCallbacks.from(value1));
+
+        CacheKey key2 = new SimpleCacheKey("bbb");
+        byte[] value2 = new byte[value2size];
+        value2[25] = 'b';
+        mCache.insert(key2, WriterCallbacks.from(value2));
+
+        // Increment clock by default expiration time + 1 day
+        when(mClock.now())
+                .thenReturn(cacheExpirationMs + TimeUnit.DAYS.toMillis(1));
+
+        CacheKey key3 = new SimpleCacheKey("ccc");
+        byte[] value3 = new byte[43];
+        value3[25] = 'c';
+        mCache.insert(key3, WriterCallbacks.from(value3));
+        long valueAge3 = TimeUnit.HOURS.toMillis(1);
+        when(mClock.now()).thenReturn(
+                cacheExpirationMs + TimeUnit.DAYS.toMillis(1) + valueAge3);
+
+        long oldestEntry = mCache.clearOldEntries(cacheExpirationMs);
+        assertEquals(valueAge3, oldestEntry);
+
+        assertArrayEquals(value3, getContents(getResource(key3)));
+        assertNull(getResource(key1));
+        assertNull(getResource(key2));
+
+        verify(mCacheEventListener)
+                .onEviction(CacheEventListener.EvictionReason.CONTENT_STALE, 2, value1size + value2size);
+    }
+
+    @Test
+    public void testCleanOldCacheNoEntriesRemaining() throws IOException {
+        long cacheExpirationMs = TimeUnit.DAYS.toMillis(5);
+        CacheKey key1 = new SimpleCacheKey("aaa");
+        byte[] value1 = new byte[41];
+        mCache.insert(key1, WriterCallbacks.from(value1));
+
+        CacheKey key2 = new SimpleCacheKey("bbb");
+        byte[] value2 = new byte[42];
+        mCache.insert(key2, WriterCallbacks.from(value2));
+
+        // Increment clock by default expiration time + 1 day
+        when(mClock.now())
+                .thenReturn(cacheExpirationMs + TimeUnit.DAYS.toMillis(1));
+
+        long oldestEntry = mCache.clearOldEntries(cacheExpirationMs);
+        assertEquals(0L, oldestEntry);
+    }
+
+    /**
+     * Test to make sure that the same item stored with two different versions
+     * of the cache will be stored with two different file names.
+     *
+     * @throws UnsupportedEncodingException
+     */
+    @Test
+    public void testVersioning() throws IOException {
+
+        // Define data that will be written to cache
+        CacheKey key = new SimpleCacheKey("version_test");
+        byte[] value = new byte[32];
+        value[0] = 'v';
+
+        // Set up cache with version == 1
+        DiskStorageSupplier storageSupplier1 = createDiskStorageSupplier(TESTCACHE_CURRENT_VERSION);
+        DiskStorageCache cache1 = createDiskCache(storageSupplier1);
+
+        // Write test data to cache 1
+        cache1.insert(key, WriterCallbacks.from(value));
+
+        // Get cached file
+        BinaryResource resource1 = getResource(storageSupplier1, key);
+        assertNotNull(resource1);
+
+        // Set up cache with version == 2
+        DiskStorageSupplier storageSupplier2 =
+                createDiskStorageSupplier(TESTCACHE_NEXT_VERSION);
+        DiskStorageCache cache2 = createDiskCache(storageSupplier2);
+
+        // Write test data to cache 2
+        cache2.insert(key, WriterCallbacks.from(value));
+
+        // Get cached file
+        BinaryResource resource2 = getResource(storageSupplier2, key);
+        assertNotNull(resource2);
+
+        // Make sure filenames of the two file are different
+        assertFalse(resource2.equals(resource1));
+    }
+
+    /**
+     * Verify that multiple threads can write to the cache at the same time.
+     */
+    @Test
+    public void testConcurrency() throws Exception {
+        final CyclicBarrier barrier = new CyclicBarrier(3);
+        WriterCallback writerCallback = new WriterCallback() {
+            @Override
+            public void write(OutputStream os) throws IOException {
+                try {
+                    // Both threads will need to hit this barrier. If writing is serialized,
+                    // the second thread will never reach here as the first will hold
+                    // the write lock forever.
+                    barrier.await(10, TimeUnit.SECONDS);
+                } catch (Exception e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        };
+        CacheKey key1 = new SimpleCacheKey("concurrent1");
+        CacheKey key2 = new SimpleCacheKey("concurrent2");
+        Thread t1 = runInsertionInSeparateThread(key1, writerCallback);
+        Thread t2 = runInsertionInSeparateThread(key2, writerCallback);
+        barrier.await(10, TimeUnit.SECONDS);
+        t1.join(1000);
+        t2.join(1000);
+    }
+
+    @Test
+    public void testIsEnabled() throws Exception {
+        DiskStorage storageMock = mock(DiskStorage.class);
+        when(storageMock.isEnabled()).thenReturn(true).thenReturn(false);
+        DiskStorageSupplier supplierMock = mock(DiskStorageSupplier.class);
+        when(supplierMock.get()).thenReturn(storageMock);
+
+        DiskStorageCache cache = createDiskCache(supplierMock);
+        assertTrue(cache.isEnabled());
+        assertFalse(cache.isEnabled());
+    }
+
+    private Thread runInsertionInSeparateThread(final CacheKey key,
+                                                final WriterCallback callback) {
+        Runnable runnable = new Runnable() {
+
+            @Override
+            public void run() {
+                try {
+                    mCache.insert(key, callback);
+                } catch (IOException e) {
+                    fail();
+                }
+            }
+        };
+        Thread thread = new Thread(runnable);
+        thread.setDaemon(true);
+        thread.start();
+        return thread;
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imageformat/ImageFormatCheckerTest.java b/imagepipeline/src/test/java/com/facebook/imageformat/ImageFormatCheckerTest.java
index 6665ac970..e50c486e1 100644
--- a/imagepipeline/src/test/java/com/facebook/imageformat/ImageFormatCheckerTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imageformat/ImageFormatCheckerTest.java
@@ -28,126 +28,126 @@
 /**
  * Tests {@link ImageFormatChecker}
  */
-@Config(manifest=Config.NONE)
+@Config(manifest = Config.NONE)
 @RunWith(WithTestDefaultsRunner.class)
 public class ImageFormatCheckerTest {
 
-  @Test
-  public void testSimpleWebps() throws Exception {
-    singleImageTypeTest(getSimpleWebpNames(), ImageFormat.WEBP_SIMPLE);
-  }
-
-  @Test
-  public void testLosslessWebps() throws Exception {
-    singleImageTypeTest(getLosslessWebpNames(), ImageFormat.WEBP_LOSSLESS);
-  }
-
-  @Test
-  public void testExtendedWebpsWithAlpha() throws Exception {
-    singleImageTypeTest(getExtendedWebpWithAlphaNames(), ImageFormat.WEBP_EXTENDED_WITH_ALPHA);
-  }
-
-  @Test
-  public void testExtendedWebpsWithoutAlpha() throws Exception {
-    singleImageTypeTest(getExtendedWebpWithoutAlphaNames(), ImageFormat.WEBP_EXTENDED);
-  }
-
-  @Test
-  public void testAnimatedWebps() throws Exception {
-    singleImageTypeTest(getAnimatedWebpNames(), ImageFormat.WEBP_ANIMATED);
-  }
-
-  @Test
-  public void testJpegs() throws Exception {
-    singleImageTypeTest(getJpegNames(), ImageFormat.JPEG);
-  }
-
-  @Test
-  public void testPngs() throws Exception {
-    singleImageTypeTest(getPngNames(), ImageFormat.PNG);
-  }
-
-  @Test
-  public void testGifs() throws Exception {
-    singleImageTypeTest(getGifsNames(), ImageFormat.GIF);
-  }
-
-  private void singleImageTypeTest(
-      final List<String> resourceNames,
-      final ImageFormat expectedImageType)
-      throws Exception {
-    for (String name : resourceNames) {
-      final InputStream resourceStream = getResourceStream(name);
-      try {
-        assertSame(
-            "failed with resource: " + name,
-            expectedImageType,
-            ImageFormatChecker.getImageFormat(resourceStream));
-      } finally {
-        resourceStream.close();
-      }
-    }
-  }
-
-  private List<String> getSimpleWebpNames() {
-    List<String> result = Lists.newArrayList();
-    for (int i = 1; i <= 2; ++i) {
-      result.add(String.format("webps/%d_webp_plain.webp", i));
-    }
-    return result;
-  }
-
-  private List<String> getLosslessWebpNames() {
-    List<String> result = Lists.newArrayList();
-    for (int i = 1; i <= 5; ++i) {
-      result.add(String.format("webps/%d_webp_ll.webp", i));
-    }
-    return result;
-  }
-
-  private List<String> getExtendedWebpWithoutAlphaNames() {
-    return Lists.newArrayList("webps/1_webp_e.webp");
-  }
-
-  private List<String> getExtendedWebpWithAlphaNames() {
-    List<String> result = Lists.newArrayList();
-    for (int i = 1; i <= 5; ++i) {
-      result.add(String.format("webps/%d_webp_ea.webp", i));
-    }
-    return result;
-  }
-
-  private List<String> getAnimatedWebpNames() {
-    return Lists.newArrayList("webps/1_webp_anim.webp");
-  }
-
-  private List<String> getJpegNames() {
-    List<String> result = Lists.newArrayList();
-    for (int i = 1; i <= 5; ++i) {
-      result.add(String.format("jpegs/%d.jpeg", i));
-    }
-    return result;
-  }
-
-  private List<String> getPngNames() {
-    List<String> result = Lists.newArrayList();
-    for (int i = 1; i <= 5; ++i) {
-      result.add(String.format("pngs/%d.png", i));
-    }
-    return result;
-  }
-
-  private List<String> getGifsNames() {
-    List<String> result = Lists.newArrayList();
-    for (int i = 1; i <= 5; ++i) {
-      result.add(String.format("gifs/%d.gif", i));
-    }
-    return result;
-  }
-
-  private InputStream getResourceStream(String name) throws IOException {
-    InputStream is = ImageFormatCheckerTest.class.getResourceAsStream(name);
-    assertNotNull("failed to read resource: " + name, is);
-    return is;
-  }
+    @Test
+    public void testSimpleWebps() throws Exception {
+        singleImageTypeTest(getSimpleWebpNames(), ImageFormat.WEBP_SIMPLE);
+    }
+
+    @Test
+    public void testLosslessWebps() throws Exception {
+        singleImageTypeTest(getLosslessWebpNames(), ImageFormat.WEBP_LOSSLESS);
+    }
+
+    @Test
+    public void testExtendedWebpsWithAlpha() throws Exception {
+        singleImageTypeTest(getExtendedWebpWithAlphaNames(), ImageFormat.WEBP_EXTENDED_WITH_ALPHA);
+    }
+
+    @Test
+    public void testExtendedWebpsWithoutAlpha() throws Exception {
+        singleImageTypeTest(getExtendedWebpWithoutAlphaNames(), ImageFormat.WEBP_EXTENDED);
+    }
+
+    @Test
+    public void testAnimatedWebps() throws Exception {
+        singleImageTypeTest(getAnimatedWebpNames(), ImageFormat.WEBP_ANIMATED);
+    }
+
+    @Test
+    public void testJpegs() throws Exception {
+        singleImageTypeTest(getJpegNames(), ImageFormat.JPEG);
+    }
+
+    @Test
+    public void testPngs() throws Exception {
+        singleImageTypeTest(getPngNames(), ImageFormat.PNG);
+    }
+
+    @Test
+    public void testGifs() throws Exception {
+        singleImageTypeTest(getGifsNames(), ImageFormat.GIF);
+    }
+
+    private void singleImageTypeTest(
+            final List<String> resourceNames,
+            final ImageFormat expectedImageType)
+            throws Exception {
+        for (String name : resourceNames) {
+            final InputStream resourceStream = getResourceStream(name);
+            try {
+                assertSame(
+                        "failed with resource: " + name,
+                        expectedImageType,
+                        ImageFormatChecker.getImageFormat(resourceStream));
+            } finally {
+                resourceStream.close();
+            }
+        }
+    }
+
+    private List<String> getSimpleWebpNames() {
+        List<String> result = Lists.newArrayList();
+        for (int i = 1; i <= 2; ++i) {
+            result.add(String.format("webps/%d_webp_plain.webp", i));
+        }
+        return result;
+    }
+
+    private List<String> getLosslessWebpNames() {
+        List<String> result = Lists.newArrayList();
+        for (int i = 1; i <= 5; ++i) {
+            result.add(String.format("webps/%d_webp_ll.webp", i));
+        }
+        return result;
+    }
+
+    private List<String> getExtendedWebpWithoutAlphaNames() {
+        return Lists.newArrayList("webps/1_webp_e.webp");
+    }
+
+    private List<String> getExtendedWebpWithAlphaNames() {
+        List<String> result = Lists.newArrayList();
+        for (int i = 1; i <= 5; ++i) {
+            result.add(String.format("webps/%d_webp_ea.webp", i));
+        }
+        return result;
+    }
+
+    private List<String> getAnimatedWebpNames() {
+        return Lists.newArrayList("webps/1_webp_anim.webp");
+    }
+
+    private List<String> getJpegNames() {
+        List<String> result = Lists.newArrayList();
+        for (int i = 1; i <= 5; ++i) {
+            result.add(String.format("jpegs/%d.jpeg", i));
+        }
+        return result;
+    }
+
+    private List<String> getPngNames() {
+        List<String> result = Lists.newArrayList();
+        for (int i = 1; i <= 5; ++i) {
+            result.add(String.format("pngs/%d.png", i));
+        }
+        return result;
+    }
+
+    private List<String> getGifsNames() {
+        List<String> result = Lists.newArrayList();
+        for (int i = 1; i <= 5; ++i) {
+            result.add(String.format("gifs/%d.gif", i));
+        }
+        return result;
+    }
+
+    private InputStream getResourceStream(String name) throws IOException {
+        InputStream is = ImageFormatCheckerTest.class.getResourceAsStream(name);
+        assertNotNull("failed to read resource: " + name, is);
+        return is;
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableTest.java
index 67d3bb634..31b16b428 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/base/AnimatedDrawableTest.java
@@ -29,6 +29,7 @@
 import com.facebook.imagepipeline.animated.testing.TestScheduledExecutorService;
 
 import com.nineoldandroids.animation.ValueAnimator;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -44,267 +45,267 @@
 @Config(shadows = {MyShadowCanvas.class, MyShadowBitmap.class})
 public class AnimatedDrawableTest {
 
-  private static final int WIDTH = 200;
-  private static final int HEIGHT = 100;
-  private static final int[] FRAME_DURATIONS = new int[]{ 60, 30, 15, 30, 60 };
-  private static final int[] FRAME_DURATIONS_LONG = new int[]{ 10000, 10000 };
-
-  private FakeClock mFakeClock;
-  private TestScheduledExecutorService mTestScheduledExecutorService;
-  private TestAnimatedDrawableBackend mBackend;
-  private TestAnimatedDrawableCachingBackend mCachingBackend;
-  private MyCallback mCallback;
-  private AnimatedDrawable mDrawable;
-
-  @Before
-  public void setup() {
-    mFakeClock = new FakeClock();
-    mTestScheduledExecutorService = new TestScheduledExecutorService(mFakeClock);
-    mBackend = new TestAnimatedDrawableBackend(WIDTH, HEIGHT, FRAME_DURATIONS);
-    mCachingBackend = new TestAnimatedDrawableCachingBackend(mBackend);
-    mCallback = new MyCallback(mFakeClock);
-    mDrawable = new AnimatedDrawable(
-        mTestScheduledExecutorService,
-        mCachingBackend,
-        AnimatedDrawableDiagnosticsNoop.getInstance(),
-        mFakeClock);
-    mDrawable.setCallback(mCallback);
-  }
-
-  @Test
-  public void testIntrinsicDimensions() {
-    assertEquals(WIDTH, mDrawable.getIntrinsicWidth());
-    assertEquals(HEIGHT, mDrawable.getIntrinsicHeight());
-  }
-
-  @Test
-  public void testValueAnimator() {
-    ValueAnimator valueAnimator = mDrawable.createValueAnimator();
-    assertEquals(mBackend.getDurationMs(), valueAnimator.getDuration());
-    assertEquals(ValueAnimator.INFINITE, valueAnimator.getRepeatCount());
-  }
-
-  @Test
-  public void testScheduling() {
-    Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
-    Canvas canvas = new Canvas(bitmap);
-    prepareDrawable();
-
-    // Spot check a pixel. Should be frame 0.
-    mDrawable.draw(canvas);
-    assertEquals(pixelValue(0, 10, 20), bitmap.getPixel(10, 20));
-
-    // Advance just before next frame.
-    mFakeClock.incrementBy(FRAME_DURATIONS[0] - 1);
-    mDrawable.draw(canvas);
-    assertEquals(pixelValue(0, 10, 20), bitmap.getPixel(10, 20));
-
-    // Advance just to second frame.
-    mFakeClock.incrementBy(1);
-    mDrawable.draw(canvas);
-    assertEquals(pixelValue(1, 10, 20), bitmap.getPixel(10, 20));
-
-    // Advance to the last millisecond of the last frame.
-    mFakeClock.incrementBy(FRAME_DURATIONS[1]);
-    mFakeClock.incrementBy(FRAME_DURATIONS[2]);
-    mFakeClock.incrementBy(FRAME_DURATIONS[3]);
-    mFakeClock.incrementBy(FRAME_DURATIONS[4] - 1);
-    mDrawable.draw(canvas);
-    assertEquals(pixelValue(4, 10, 20), bitmap.getPixel(10, 20));
-
-    // Make sure wrapping works.
-    mFakeClock.incrementBy(1);
-    mDrawable.draw(canvas);
-    assertEquals(pixelValue(0, 10, 20), bitmap.getPixel(10, 20));
-    assertEquals(1, mBackend.getDropCachesCallCount());
-  }
-
-  @Test
-  public void testDropCachesAfterDrawTimeout() {
-    Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
-    Canvas canvas = new Canvas(bitmap);
-    prepareDrawable();
-
-    // Draw and advance to next frame.
-    mDrawable.draw(canvas);
-
-    // Make sure caches are dropped after couple seconds without a draw call.
-    assertFalse(mDrawable.isWaitingForDraw());
-    mFakeClock.incrementBy(60);
-    assertTrue(mDrawable.isWaitingForDraw());
-    mFakeClock.incrementBy(1940);
-    assertEquals(2, mBackend.getDropCachesCallCount());
-  }
-
-  @Test
-  public void testDropCachesAfterNextFrameTimeout() {
-    Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
-    Canvas canvas = new Canvas(bitmap);
-    prepareDrawable();
-
-    // Draw and advance to next frame.
-    mDrawable.draw(canvas);
-
-    // Make sure caches are dropped after couple seconds.
-    assertFalse(mDrawable.isWaitingForDraw());
-    assertTrue(mDrawable.isWaitingForNextFrame());
-    mCallback.setDropCallbacks(true);
-    mFakeClock.incrementBy(2000);
-    assertEquals(2, mBackend.getDropCachesCallCount());
-  }
-
-  @Test
-  public void testDoNotDropCacheIfFramesAreLongDurationSpecialCase() {
-    mBackend = new TestAnimatedDrawableBackend(WIDTH, HEIGHT, FRAME_DURATIONS_LONG);
-    mCachingBackend = new TestAnimatedDrawableCachingBackend(mBackend);
-    mCallback = new MyCallback(mFakeClock);
-    mDrawable = new AnimatedDrawable(
-        mTestScheduledExecutorService,
-        mCachingBackend,
-        AnimatedDrawableDiagnosticsNoop.getInstance(),
-        mFakeClock);
-    mDrawable.setCallback(mCallback);
-
-    Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
-    Canvas canvas = new Canvas(bitmap);
-    prepareDrawable();
-
-    // Draw and advance to next frame.
-    mDrawable.draw(canvas);
-
-    // After 10 seconds, it should move to the next frame. It shouldn't drop the caches though
-    // until it's 2 seconds after the invalidate.
-    assertFalse(mDrawable.isWaitingForDraw());
-    assertTrue(mDrawable.isWaitingForNextFrame());
-    assertEquals(0, mDrawable.getScheduledFrameNumber());
-    mFakeClock.incrementBy(10000);
-    assertTrue(mDrawable.isWaitingForDraw());
-    assertFalse(mDrawable.isWaitingForNextFrame());
-    assertEquals(1, mDrawable.getScheduledFrameNumber());
-    assertEquals(1, mBackend.getDropCachesCallCount());
-    mFakeClock.incrementBy(1000);
-    assertEquals(1, mBackend.getDropCachesCallCount());
-    mFakeClock.incrementBy(2000);
-    assertEquals(2, mBackend.getDropCachesCallCount());
-  }
-
-  private void prepareDrawable() {
-    mDrawable.start();
-    mFakeClock.incrementBy(0); // Just to trigger the callbacks to run.
-    mDrawable.setBounds(0, 0, 200, 100);
-    assertEquals(1, mBackend.getDropCachesCallCount());
-  }
-
-  private static class ScheduledRunnable {
-
-    final Runnable runnable;
-    final long when;
-
-    private ScheduledRunnable(Runnable runnable, long when) {
-      this.runnable = runnable;
-      this.when = when;
+    private static final int WIDTH = 200;
+    private static final int HEIGHT = 100;
+    private static final int[] FRAME_DURATIONS = new int[]{60, 30, 15, 30, 60};
+    private static final int[] FRAME_DURATIONS_LONG = new int[]{10000, 10000};
+
+    private FakeClock mFakeClock;
+    private TestScheduledExecutorService mTestScheduledExecutorService;
+    private TestAnimatedDrawableBackend mBackend;
+    private TestAnimatedDrawableCachingBackend mCachingBackend;
+    private MyCallback mCallback;
+    private AnimatedDrawable mDrawable;
+
+    @Before
+    public void setup() {
+        mFakeClock = new FakeClock();
+        mTestScheduledExecutorService = new TestScheduledExecutorService(mFakeClock);
+        mBackend = new TestAnimatedDrawableBackend(WIDTH, HEIGHT, FRAME_DURATIONS);
+        mCachingBackend = new TestAnimatedDrawableCachingBackend(mBackend);
+        mCallback = new MyCallback(mFakeClock);
+        mDrawable = new AnimatedDrawable(
+                mTestScheduledExecutorService,
+                mCachingBackend,
+                AnimatedDrawableDiagnosticsNoop.getInstance(),
+                mFakeClock);
+        mDrawable.setCallback(mCallback);
     }
-  }
-
-  private static class TestAnimatedDrawableCachingBackend extends DelegatingAnimatedDrawableBackend
-      implements AnimatedDrawableCachingBackend {
 
-    public TestAnimatedDrawableCachingBackend(AnimatedDrawableBackend animatedDrawableBackend) {
-      super(animatedDrawableBackend);
+    @Test
+    public void testIntrinsicDimensions() {
+        assertEquals(WIDTH, mDrawable.getIntrinsicWidth());
+        assertEquals(HEIGHT, mDrawable.getIntrinsicHeight());
     }
 
-    @Override
-    public CloseableReference<Bitmap> getBitmapForFrame(int frameNumber) {
-      Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
-      getDelegate().renderFrame(frameNumber, new Canvas(bitmap));
-      return CloseableReference.of(
-          bitmap,
-          new ResourceReleaser<Bitmap>() {
-            @Override
-            public void release(Bitmap value) {
+    @Test
+    public void testValueAnimator() {
+        ValueAnimator valueAnimator = mDrawable.createValueAnimator();
+        assertEquals(mBackend.getDurationMs(), valueAnimator.getDuration());
+        assertEquals(ValueAnimator.INFINITE, valueAnimator.getRepeatCount());
+    }
 
-            }
-          });
+    @Test
+    public void testScheduling() {
+        Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+        Canvas canvas = new Canvas(bitmap);
+        prepareDrawable();
+
+        // Spot check a pixel. Should be frame 0.
+        mDrawable.draw(canvas);
+        assertEquals(pixelValue(0, 10, 20), bitmap.getPixel(10, 20));
+
+        // Advance just before next frame.
+        mFakeClock.incrementBy(FRAME_DURATIONS[0] - 1);
+        mDrawable.draw(canvas);
+        assertEquals(pixelValue(0, 10, 20), bitmap.getPixel(10, 20));
+
+        // Advance just to second frame.
+        mFakeClock.incrementBy(1);
+        mDrawable.draw(canvas);
+        assertEquals(pixelValue(1, 10, 20), bitmap.getPixel(10, 20));
+
+        // Advance to the last millisecond of the last frame.
+        mFakeClock.incrementBy(FRAME_DURATIONS[1]);
+        mFakeClock.incrementBy(FRAME_DURATIONS[2]);
+        mFakeClock.incrementBy(FRAME_DURATIONS[3]);
+        mFakeClock.incrementBy(FRAME_DURATIONS[4] - 1);
+        mDrawable.draw(canvas);
+        assertEquals(pixelValue(4, 10, 20), bitmap.getPixel(10, 20));
+
+        // Make sure wrapping works.
+        mFakeClock.incrementBy(1);
+        mDrawable.draw(canvas);
+        assertEquals(pixelValue(0, 10, 20), bitmap.getPixel(10, 20));
+        assertEquals(1, mBackend.getDropCachesCallCount());
     }
 
-    @Override
-    public CloseableReference<Bitmap> getPreviewBitmap() {
-      return null;
+    @Test
+    public void testDropCachesAfterDrawTimeout() {
+        Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+        Canvas canvas = new Canvas(bitmap);
+        prepareDrawable();
+
+        // Draw and advance to next frame.
+        mDrawable.draw(canvas);
+
+        // Make sure caches are dropped after couple seconds without a draw call.
+        assertFalse(mDrawable.isWaitingForDraw());
+        mFakeClock.incrementBy(60);
+        assertTrue(mDrawable.isWaitingForDraw());
+        mFakeClock.incrementBy(1940);
+        assertEquals(2, mBackend.getDropCachesCallCount());
     }
 
-    @Override
-    public CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber) {
-      return null;
+    @Test
+    public void testDropCachesAfterNextFrameTimeout() {
+        Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+        Canvas canvas = new Canvas(bitmap);
+        prepareDrawable();
+
+        // Draw and advance to next frame.
+        mDrawable.draw(canvas);
+
+        // Make sure caches are dropped after couple seconds.
+        assertFalse(mDrawable.isWaitingForDraw());
+        assertTrue(mDrawable.isWaitingForNextFrame());
+        mCallback.setDropCallbacks(true);
+        mFakeClock.incrementBy(2000);
+        assertEquals(2, mBackend.getDropCachesCallCount());
     }
 
-    @Override
-    public void appendDebugOptionString(StringBuilder sb) {
+    @Test
+    public void testDoNotDropCacheIfFramesAreLongDurationSpecialCase() {
+        mBackend = new TestAnimatedDrawableBackend(WIDTH, HEIGHT, FRAME_DURATIONS_LONG);
+        mCachingBackend = new TestAnimatedDrawableCachingBackend(mBackend);
+        mCallback = new MyCallback(mFakeClock);
+        mDrawable = new AnimatedDrawable(
+                mTestScheduledExecutorService,
+                mCachingBackend,
+                AnimatedDrawableDiagnosticsNoop.getInstance(),
+                mFakeClock);
+        mDrawable.setCallback(mCallback);
+
+        Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+        Canvas canvas = new Canvas(bitmap);
+        prepareDrawable();
+
+        // Draw and advance to next frame.
+        mDrawable.draw(canvas);
+
+        // After 10 seconds, it should move to the next frame. It shouldn't drop the caches though
+        // until it's 2 seconds after the invalidate.
+        assertFalse(mDrawable.isWaitingForDraw());
+        assertTrue(mDrawable.isWaitingForNextFrame());
+        assertEquals(0, mDrawable.getScheduledFrameNumber());
+        mFakeClock.incrementBy(10000);
+        assertTrue(mDrawable.isWaitingForDraw());
+        assertFalse(mDrawable.isWaitingForNextFrame());
+        assertEquals(1, mDrawable.getScheduledFrameNumber());
+        assertEquals(1, mBackend.getDropCachesCallCount());
+        mFakeClock.incrementBy(1000);
+        assertEquals(1, mBackend.getDropCachesCallCount());
+        mFakeClock.incrementBy(2000);
+        assertEquals(2, mBackend.getDropCachesCallCount());
     }
 
-    @Override
-    public AnimatedDrawableCachingBackend forNewBounds(Rect bounds) {
-      return this;
+    private void prepareDrawable() {
+        mDrawable.start();
+        mFakeClock.incrementBy(0); // Just to trigger the callbacks to run.
+        mDrawable.setBounds(0, 0, 200, 100);
+        assertEquals(1, mBackend.getDropCachesCallCount());
     }
-  }
 
-  private static class MyCallback implements Drawable.Callback {
+    private static class ScheduledRunnable {
 
-    private final FakeClock mFakeClock;
-    private final List<ScheduledRunnable> mScheduledRunnables = new ArrayList<>();
-    private boolean mDropCallbacks;
+        final Runnable runnable;
+        final long when;
 
-    MyCallback(FakeClock fakeClock) {
-      mFakeClock = fakeClock;
-      mFakeClock.addListener(
-          new FakeClock.OnTickListener() {
-            @Override
-            public void onTick() {
-              runReadyTasks();
-            }
-          });
+        private ScheduledRunnable(Runnable runnable, long when) {
+            this.runnable = runnable;
+            this.when = when;
+        }
     }
 
-    @Override
-    public void invalidateDrawable(Drawable who) {
+    private static class TestAnimatedDrawableCachingBackend extends DelegatingAnimatedDrawableBackend
+            implements AnimatedDrawableCachingBackend {
 
-    }
+        public TestAnimatedDrawableCachingBackend(AnimatedDrawableBackend animatedDrawableBackend) {
+            super(animatedDrawableBackend);
+        }
 
-    @Override
-    public void scheduleDrawable(Drawable who, Runnable what, long when) {
-      mScheduledRunnables.add(new ScheduledRunnable(what, when));
-    }
+        @Override
+        public CloseableReference<Bitmap> getBitmapForFrame(int frameNumber) {
+            Bitmap bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+            getDelegate().renderFrame(frameNumber, new Canvas(bitmap));
+            return CloseableReference.of(
+                    bitmap,
+                    new ResourceReleaser<Bitmap>() {
+                        @Override
+                        public void release(Bitmap value) {
+
+                        }
+                    });
+        }
 
-    @Override
-    public void unscheduleDrawable(Drawable who, Runnable what) {
-      Iterator<ScheduledRunnable> iterator = mScheduledRunnables.iterator();
-      while (iterator.hasNext()) {
-        ScheduledRunnable next = iterator.next();
-        if (next.runnable == what) {
-          iterator.remove();
+        @Override
+        public CloseableReference<Bitmap> getPreviewBitmap() {
+            return null;
         }
-      }
-    }
 
-    void runReadyTasks() {
-      List<Runnable> toRun = new ArrayList<>();
-      long now = mFakeClock.now();
-      Iterator<ScheduledRunnable> iterator = mScheduledRunnables.iterator();
-      while (iterator.hasNext()) {
-        ScheduledRunnable next = iterator.next();
-        if (next.when <= now) {
-          iterator.remove();
-          toRun.add(next.runnable);
+        @Override
+        public CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber) {
+            return null;
         }
-      }
-      if (!mDropCallbacks) {
-        for (Runnable runnable : toRun) {
-          runnable.run();
+
+        @Override
+        public void appendDebugOptionString(StringBuilder sb) {
+        }
+
+        @Override
+        public AnimatedDrawableCachingBackend forNewBounds(Rect bounds) {
+            return this;
         }
-      }
     }
 
-    void setDropCallbacks(boolean dropCallbacks) {
-      mDropCallbacks = dropCallbacks;
+    private static class MyCallback implements Drawable.Callback {
+
+        private final FakeClock mFakeClock;
+        private final List<ScheduledRunnable> mScheduledRunnables = new ArrayList<>();
+        private boolean mDropCallbacks;
+
+        MyCallback(FakeClock fakeClock) {
+            mFakeClock = fakeClock;
+            mFakeClock.addListener(
+                    new FakeClock.OnTickListener() {
+                        @Override
+                        public void onTick() {
+                            runReadyTasks();
+                        }
+                    });
+        }
+
+        @Override
+        public void invalidateDrawable(Drawable who) {
+
+        }
+
+        @Override
+        public void scheduleDrawable(Drawable who, Runnable what, long when) {
+            mScheduledRunnables.add(new ScheduledRunnable(what, when));
+        }
+
+        @Override
+        public void unscheduleDrawable(Drawable who, Runnable what) {
+            Iterator<ScheduledRunnable> iterator = mScheduledRunnables.iterator();
+            while (iterator.hasNext()) {
+                ScheduledRunnable next = iterator.next();
+                if (next.runnable == what) {
+                    iterator.remove();
+                }
+            }
+        }
+
+        void runReadyTasks() {
+            List<Runnable> toRun = new ArrayList<>();
+            long now = mFakeClock.now();
+            Iterator<ScheduledRunnable> iterator = mScheduledRunnables.iterator();
+            while (iterator.hasNext()) {
+                ScheduledRunnable next = iterator.next();
+                if (next.when <= now) {
+                    iterator.remove();
+                    toRun.add(next.runnable);
+                }
+            }
+            if (!mDropCallbacks) {
+                for (Runnable runnable : toRun) {
+                    runnable.run();
+                }
+            }
+        }
+
+        void setDropCallbacks(boolean dropCallbacks) {
+            mDropCallbacks = dropCallbacks;
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryTest.java
index 005050a3c..0e7d24e2b 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/factory/AnimatedImageFactoryTest.java
@@ -35,178 +35,178 @@
  */
 @RunWith(WithTestDefaultsRunner.class)
 @PrepareOnlyThisForTest({
-    WebPImage.class,
-    AnimatedImageFactory.class,
-    AnimatedImageCompositor.class})
+        WebPImage.class,
+        AnimatedImageFactory.class,
+        AnimatedImageCompositor.class})
 public class AnimatedImageFactoryTest {
 
-  static {
-    SoLoaderShim.setInTestMode();
-  }
+    static {
+        SoLoaderShim.setInTestMode();
+    }
+
+    private static ResourceReleaser<PooledByteBuffer> FAKE_RESOURCE_RELEASER =
+            new ResourceReleaser<PooledByteBuffer>() {
+
+                @Override
+                public void release(PooledByteBuffer value) {
+                }
+            };
+
+    private static ResourceReleaser<Bitmap> FAKE_BITMAP_RESOURCE_RELEASER =
+            new ResourceReleaser<Bitmap>() {
+
+                @Override
+                public void release(Bitmap value) {
+                }
+            };
+
+    private AnimatedDrawableBackendProvider mMockAnimatedDrawableBackendProvider;
+    private PlatformBitmapFactory mMockBitmapFactory;
+    private AnimatedImageFactory mAnimatedImageFactory;
+
+    @Before
+    public void setup() {
+        PowerMockito.mockStatic(WebPImage.class);
+
+        mMockAnimatedDrawableBackendProvider = mock(AnimatedDrawableBackendProvider.class);
+        mMockBitmapFactory = mock(PlatformBitmapFactory.class);
 
-  private static ResourceReleaser<PooledByteBuffer> FAKE_RESOURCE_RELEASER =
-      new ResourceReleaser<PooledByteBuffer>() {
+        mAnimatedImageFactory = new AnimatedImageFactory(
+                mMockAnimatedDrawableBackendProvider,
+                mMockBitmapFactory);
+    }
+
+    @Test
+    public void testCreateDefaults() {
+        WebPImage mockWebPImage = mock(WebPImage.class);
+
+        // Expect a call to WebPImage.create
+        TrivialPooledByteBuffer byteBuffer = createByteBuffer();
+        when(WebPImage.create(byteBuffer.getNativePtr(), byteBuffer.size()))
+                .thenReturn(mockWebPImage);
+
+        CloseableAnimatedImage closeableImage =
+                (CloseableAnimatedImage) mAnimatedImageFactory.decodeWebP(
+                        CloseableReference.of(byteBuffer, FAKE_RESOURCE_RELEASER),
+                        ImageDecodeOptions.defaults());
+
+        // Verify we got the right result
+        AnimatedImageResult imageResult = closeableImage.getImageResult();
+        assertSame(mockWebPImage, imageResult.getImage());
+        assertNull(imageResult.getPreviewBitmap());
+        assertFalse(imageResult.hasDecodedFrame(0));
+
+        // Should not have interacted with these.
+        verifyZeroInteractions(mMockAnimatedDrawableBackendProvider);
+        verifyZeroInteractions(mMockBitmapFactory);
+    }
+
+    @Test
+    public void testCreateWithPreviewBitmap() throws Exception {
+        WebPImage mockWebPImage = mock(WebPImage.class);
+
+        Bitmap mockBitmap = MockBitmapFactory.create(50, 50);
+
+        // Expect a call to WebPImage.create
+        TrivialPooledByteBuffer byteBuffer = createByteBuffer();
+        when(WebPImage.create(byteBuffer.getNativePtr(), byteBuffer.size()))
+                .thenReturn(mockWebPImage);
+        when(mockWebPImage.getWidth()).thenReturn(50);
+        when(mockWebPImage.getHeight()).thenReturn(50);
+
+        // For decoding preview frame, expect some calls.
+        when(mMockAnimatedDrawableBackendProvider.get(
+                any(AnimatedImageResult.class),
+                isNull(Rect.class)))
+                .thenReturn(new TestAnimatedDrawableBackend(50, 50, new int[]{100}));
+        when(mMockBitmapFactory.createBitmap(50, 50))
+                .thenReturn(CloseableReference.of(mockBitmap, FAKE_BITMAP_RESOURCE_RELEASER));
+        AnimatedImageCompositor mockCompositor = mock(AnimatedImageCompositor.class);
+        PowerMockito.whenNew(AnimatedImageCompositor.class)
+                .withAnyArguments()
+                .thenReturn(mockCompositor);
+
+        ImageDecodeOptions imageDecodeOptions = ImageDecodeOptions.newBuilder()
+                .setDecodePreviewFrame(true)
+                .build();
+        CloseableAnimatedImage closeableImage =
+                (CloseableAnimatedImage) mAnimatedImageFactory.decodeWebP(
+                        CloseableReference.of(byteBuffer, FAKE_RESOURCE_RELEASER),
+                        imageDecodeOptions);
+
+        // Verify we got the right result
+        AnimatedImageResult imageResult = closeableImage.getImageResult();
+        assertSame(mockWebPImage, imageResult.getImage());
+        assertNotNull(imageResult.getPreviewBitmap());
+        assertFalse(imageResult.hasDecodedFrame(0));
+
+        // Should not have interacted with these.
+        verify(mMockAnimatedDrawableBackendProvider).get(
+                any(AnimatedImageResult.class),
+                isNull(Rect.class));
+        verifyNoMoreInteractions(mMockAnimatedDrawableBackendProvider);
+        verify(mMockBitmapFactory).createBitmap(50, 50);
+        verifyNoMoreInteractions(mMockBitmapFactory);
+        verify(mockCompositor).renderFrame(0, mockBitmap);
+    }
+
+    @Test
+    public void testCreateWithDecodeAlFrames() throws Exception {
+        WebPImage mockWebPImage = mock(WebPImage.class);
+
+        Bitmap mockBitmap1 = MockBitmapFactory.create(50, 50);
+        Bitmap mockBitmap2 = MockBitmapFactory.create(50, 50);
+
+        // Expect a call to WebPImage.create
+        TrivialPooledByteBuffer byteBuffer = createByteBuffer();
+        when(WebPImage.create(byteBuffer.getNativePtr(), byteBuffer.size()))
+                .thenReturn(mockWebPImage);
+        when(mockWebPImage.getWidth()).thenReturn(50);
+        when(mockWebPImage.getHeight()).thenReturn(50);
+
+        // For decoding preview frame, expect some calls.
+        when(
+                mMockAnimatedDrawableBackendProvider.get(
+                        any(AnimatedImageResult.class),
+                        isNull(Rect.class)))
+                .thenReturn(new TestAnimatedDrawableBackend(50, 50, new int[]{100, 200}));
+        when(mMockBitmapFactory.createBitmap(50, 50))
+                .thenReturn(CloseableReference.of(mockBitmap1, FAKE_BITMAP_RESOURCE_RELEASER))
+                .thenReturn(CloseableReference.of(mockBitmap2, FAKE_BITMAP_RESOURCE_RELEASER));
+        AnimatedImageCompositor mockCompositor = mock(AnimatedImageCompositor.class);
+        PowerMockito.whenNew(AnimatedImageCompositor.class)
+                .withAnyArguments()
+                .thenReturn(mockCompositor);
+
+        ImageDecodeOptions imageDecodeOptions = ImageDecodeOptions.newBuilder()
+                .setDecodePreviewFrame(true)
+                .setDecodeAllFrames(true)
+                .build();
+        CloseableAnimatedImage closeableImage =
+                (CloseableAnimatedImage) mAnimatedImageFactory.decodeWebP(
+                        CloseableReference.of(byteBuffer, FAKE_RESOURCE_RELEASER),
+                        imageDecodeOptions);
+
+        // Verify we got the right result
+        AnimatedImageResult imageResult = closeableImage.getImageResult();
+        assertSame(mockWebPImage, imageResult.getImage());
+        assertNotNull(imageResult.getDecodedFrame(0));
+        assertNotNull(imageResult.getDecodedFrame(1));
+        assertNotNull(imageResult.getPreviewBitmap());
+
+        // Should not have interacted with these.
+        verify(mMockAnimatedDrawableBackendProvider).get(
+                any(AnimatedImageResult.class),
+                isNull(Rect.class));
+        verifyNoMoreInteractions(mMockAnimatedDrawableBackendProvider);
+        verify(mMockBitmapFactory, times(2)).createBitmap(50, 50);
+        verifyNoMoreInteractions(mMockBitmapFactory);
+        verify(mockCompositor).renderFrame(0, mockBitmap1);
+        verify(mockCompositor).renderFrame(1, mockBitmap2);
+    }
 
-    @Override
-    public void release(PooledByteBuffer value) {
+    private TrivialPooledByteBuffer createByteBuffer() {
+        byte[] buf = new byte[16];
+        return new TrivialPooledByteBuffer(buf);
     }
-  };
-
-  private static ResourceReleaser<Bitmap> FAKE_BITMAP_RESOURCE_RELEASER =
-      new ResourceReleaser<Bitmap>() {
-
-        @Override
-        public void release(Bitmap value) {
-        }
-      };
-
-  private AnimatedDrawableBackendProvider mMockAnimatedDrawableBackendProvider;
-  private PlatformBitmapFactory mMockBitmapFactory;
-  private AnimatedImageFactory mAnimatedImageFactory;
-
-  @Before
-  public void setup() {
-    PowerMockito.mockStatic(WebPImage.class);
-
-    mMockAnimatedDrawableBackendProvider = mock(AnimatedDrawableBackendProvider.class);
-    mMockBitmapFactory = mock(PlatformBitmapFactory.class);
-
-    mAnimatedImageFactory = new AnimatedImageFactory(
-        mMockAnimatedDrawableBackendProvider,
-        mMockBitmapFactory);
-  }
-
-  @Test
-  public void testCreateDefaults() {
-    WebPImage mockWebPImage = mock(WebPImage.class);
-
-    // Expect a call to WebPImage.create
-    TrivialPooledByteBuffer byteBuffer = createByteBuffer();
-    when(WebPImage.create(byteBuffer.getNativePtr(), byteBuffer.size()))
-        .thenReturn(mockWebPImage);
-
-    CloseableAnimatedImage closeableImage =
-        (CloseableAnimatedImage) mAnimatedImageFactory.decodeWebP(
-            CloseableReference.of(byteBuffer, FAKE_RESOURCE_RELEASER),
-            ImageDecodeOptions.defaults());
-
-    // Verify we got the right result
-    AnimatedImageResult imageResult = closeableImage.getImageResult();
-    assertSame(mockWebPImage, imageResult.getImage());
-    assertNull(imageResult.getPreviewBitmap());
-    assertFalse(imageResult.hasDecodedFrame(0));
-
-    // Should not have interacted with these.
-    verifyZeroInteractions(mMockAnimatedDrawableBackendProvider);
-    verifyZeroInteractions(mMockBitmapFactory);
-  }
-
-  @Test
-  public void testCreateWithPreviewBitmap() throws Exception {
-    WebPImage mockWebPImage = mock(WebPImage.class);
-
-    Bitmap mockBitmap = MockBitmapFactory.create(50, 50);
-
-    // Expect a call to WebPImage.create
-    TrivialPooledByteBuffer byteBuffer = createByteBuffer();
-    when(WebPImage.create(byteBuffer.getNativePtr(), byteBuffer.size()))
-        .thenReturn(mockWebPImage);
-    when(mockWebPImage.getWidth()).thenReturn(50);
-    when(mockWebPImage.getHeight()).thenReturn(50);
-
-    // For decoding preview frame, expect some calls.
-    when(mMockAnimatedDrawableBackendProvider.get(
-            any(AnimatedImageResult.class),
-            isNull(Rect.class)))
-        .thenReturn(new TestAnimatedDrawableBackend(50, 50, new int[]{100}));
-    when(mMockBitmapFactory.createBitmap(50, 50))
-        .thenReturn(CloseableReference.of(mockBitmap, FAKE_BITMAP_RESOURCE_RELEASER));
-    AnimatedImageCompositor mockCompositor = mock(AnimatedImageCompositor.class);
-    PowerMockito.whenNew(AnimatedImageCompositor.class)
-        .withAnyArguments()
-        .thenReturn(mockCompositor);
-
-    ImageDecodeOptions imageDecodeOptions = ImageDecodeOptions.newBuilder()
-        .setDecodePreviewFrame(true)
-        .build();
-    CloseableAnimatedImage closeableImage =
-        (CloseableAnimatedImage) mAnimatedImageFactory.decodeWebP(
-            CloseableReference.of(byteBuffer, FAKE_RESOURCE_RELEASER),
-            imageDecodeOptions);
-
-    // Verify we got the right result
-    AnimatedImageResult imageResult = closeableImage.getImageResult();
-    assertSame(mockWebPImage, imageResult.getImage());
-    assertNotNull(imageResult.getPreviewBitmap());
-    assertFalse(imageResult.hasDecodedFrame(0));
-
-    // Should not have interacted with these.
-    verify(mMockAnimatedDrawableBackendProvider).get(
-        any(AnimatedImageResult.class),
-        isNull(Rect.class));
-    verifyNoMoreInteractions(mMockAnimatedDrawableBackendProvider);
-    verify(mMockBitmapFactory).createBitmap(50, 50);
-    verifyNoMoreInteractions(mMockBitmapFactory);
-    verify(mockCompositor).renderFrame(0, mockBitmap);
-  }
-
-  @Test
-  public void testCreateWithDecodeAlFrames() throws Exception {
-    WebPImage mockWebPImage = mock(WebPImage.class);
-
-    Bitmap mockBitmap1 = MockBitmapFactory.create(50, 50);
-    Bitmap mockBitmap2 = MockBitmapFactory.create(50, 50);
-
-    // Expect a call to WebPImage.create
-    TrivialPooledByteBuffer byteBuffer = createByteBuffer();
-    when(WebPImage.create(byteBuffer.getNativePtr(), byteBuffer.size()))
-        .thenReturn(mockWebPImage);
-    when(mockWebPImage.getWidth()).thenReturn(50);
-    when(mockWebPImage.getHeight()).thenReturn(50);
-
-    // For decoding preview frame, expect some calls.
-    when(
-        mMockAnimatedDrawableBackendProvider.get(
-            any(AnimatedImageResult.class),
-            isNull(Rect.class)))
-        .thenReturn(new TestAnimatedDrawableBackend(50, 50, new int[]{ 100, 200 }));
-    when(mMockBitmapFactory.createBitmap(50, 50))
-        .thenReturn(CloseableReference.of(mockBitmap1, FAKE_BITMAP_RESOURCE_RELEASER))
-        .thenReturn(CloseableReference.of(mockBitmap2, FAKE_BITMAP_RESOURCE_RELEASER));
-    AnimatedImageCompositor mockCompositor = mock(AnimatedImageCompositor.class);
-    PowerMockito.whenNew(AnimatedImageCompositor.class)
-        .withAnyArguments()
-        .thenReturn(mockCompositor);
-
-    ImageDecodeOptions imageDecodeOptions = ImageDecodeOptions.newBuilder()
-        .setDecodePreviewFrame(true)
-        .setDecodeAllFrames(true)
-        .build();
-    CloseableAnimatedImage closeableImage =
-        (CloseableAnimatedImage) mAnimatedImageFactory.decodeWebP(
-            CloseableReference.of(byteBuffer, FAKE_RESOURCE_RELEASER),
-            imageDecodeOptions);
-
-    // Verify we got the right result
-    AnimatedImageResult imageResult = closeableImage.getImageResult();
-    assertSame(mockWebPImage, imageResult.getImage());
-    assertNotNull(imageResult.getDecodedFrame(0));
-    assertNotNull(imageResult.getDecodedFrame(1));
-    assertNotNull(imageResult.getPreviewBitmap());
-
-    // Should not have interacted with these.
-    verify(mMockAnimatedDrawableBackendProvider).get(
-        any(AnimatedImageResult.class),
-        isNull(Rect.class));
-    verifyNoMoreInteractions(mMockAnimatedDrawableBackendProvider);
-    verify(mMockBitmapFactory, times(2)).createBitmap(50, 50);
-    verifyNoMoreInteractions(mMockBitmapFactory);
-    verify(mockCompositor).renderFrame(0, mockBitmap1);
-    verify(mockCompositor).renderFrame(1, mockBitmap2);
-  }
-
-  private TrivialPooledByteBuffer createByteBuffer() {
-    byte[] buf = new byte[16];
-    return new TrivialPooledByteBuffer(buf);
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplTest.java
index 3b8c75953..77c804b87 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/impl/AnimatedDrawableCachingBackendImplTest.java
@@ -26,6 +26,7 @@
 import com.facebook.imagepipeline.animated.util.AnimatedDrawableUtil;
 
 import bolts.Task;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -43,123 +44,123 @@
 @Config(shadows = {MyShadowCanvas.class, MyShadowBitmap.class})
 public class AnimatedDrawableCachingBackendImplTest {
 
-  private static final int WIDTH = 200;
-  private static final int HEIGHT = 100;
-  private static final int[] FRAME_DURATIONS = new int[] { 60, 30, 15, 30, 60, 30, 45, 15, 30 };
-
-  private FakeClock mFakeClock;
-  private TestExecutorService mExecutorService;
-  private ActivityManager mActivityManager;
-  private AnimatedDrawableUtil mAnimatedDrawableUtil;
-  private TestAnimatedDrawableBackend mDrawableBackend;
-  private AnimatedDrawableCachingBackendImpl mCachingBackend;
-
-  @Before
-  public void setup() {
-    mActivityManager =
-        (ActivityManager) Robolectric.application.getSystemService(Context.ACTIVITY_SERVICE);
-    mFakeClock = new FakeClock();
-    mExecutorService = new TestExecutorService(mFakeClock);
-    mAnimatedDrawableUtil = new AnimatedDrawableUtil();
-    mDrawableBackend = new TestAnimatedDrawableBackend(WIDTH, HEIGHT, FRAME_DURATIONS);
-  }
-
-  @Test
-  public void testForceImmediate() {
-    mCachingBackend = makeCachingBackend(0 /* no caching */);
-
-    // Spot check a pixel on frame 0
-    CloseableReference<Bitmap> bitmap0 = mCachingBackend.getBitmapForFrameBlocking(0);
-    assertNotNull(bitmap0);
-    assertEquals(pixelValue(0, 10, 20), bitmap0.get().getPixel(10, 20));
-  }
-
-  @Test
-  public void testAsyncFetches() {
-    mCachingBackend = makeCachingBackend(0 /* no caching */);
-
-    // Fetch frame with async API. Verify it returns null initially and put the decodes in flight.
-    CloseableReference<Bitmap> bitmap0 = mCachingBackend.getBitmapForFrame(0);
-    assertNull(bitmap0);
-    assertDecodesInFlight(0, 1, 2);
-
-    // Complete one command verify we now get the frame back.
-    mExecutorService.getScheduledQueue().runNextPendingCommand();
-    bitmap0 = mCachingBackend.getBitmapForFrame(0);
-    assertNotNull(bitmap0);
-    assertEquals(pixelValue(0, 10, 20), bitmap0.get().getPixel(10, 20));
-    assertDecodesInFlight(1, 2);
-
-    // Verify next frame returns null and puts one more decode in flight.
-    CloseableReference<Bitmap> bitmap1 = mCachingBackend.getBitmapForFrame(1);
-    assertNull(bitmap1);
-    assertDecodesInFlight(1, 2, 3);
-
-    // Make two more commands complete.
-    mExecutorService.getScheduledQueue().runNextPendingCommand();
-    mExecutorService.getScheduledQueue().runNextPendingCommand();
-    assertDecodesInFlight(3);
-
-    // Verify next two frames returns non-null and puts more decodes in flight.
-    bitmap1 = mCachingBackend.getBitmapForFrame(1);
-    assertNotNull(bitmap1);
-    CloseableReference<Bitmap> bitmap2 = mCachingBackend.getBitmapForFrame(2);
-    assertNotNull(bitmap2);
-    assertDecodesInFlight(3, 4);
-
-    // Skip to asking for frame
-    CloseableReference<Bitmap> bitmap7 = mCachingBackend.getBitmapForFrame(7);
-    assertNull(bitmap7);
-
-    // Expect decodes in flight to change based on new current frame.
-    assertDecodesInFlight(7, 8, 0);
-    mExecutorService.getScheduledQueue().runNextPendingCommand(); // cancelled frame 3
-    assertDecodesInFlight(7, 8, 0);
-    mExecutorService.getScheduledQueue().runNextPendingCommand(); // cancelled frame 4
-    assertDecodesInFlight(7, 8, 0);
-    mExecutorService.getScheduledQueue().runNextPendingCommand(); // frame 7
-    assertDecodesInFlight(8, 0);
-    mExecutorService.getScheduledQueue().runNextPendingCommand(); // frame 8
-    assertDecodesInFlight(0);
-    mExecutorService.getScheduledQueue().runNextPendingCommand(); // frame 0
-    assertDecodesInFlight();
-  }
-
-  @Test
-  public void testFramesCachedInMemory() {
-    mCachingBackend = makeCachingBackend(50 * 1024 * 1024); // Enough to cache all frames
-
-    // Fetch frames and verify they stay cached.
-    for (int i = 0; i < FRAME_DURATIONS.length; i++) {
-      CloseableReference<Bitmap> bitmap = mCachingBackend.getBitmapForFrameBlocking(i);
-      assertNotNull(bitmap);
-      mExecutorService.getScheduledQueue().runUntilIdle();
+    private static final int WIDTH = 200;
+    private static final int HEIGHT = 100;
+    private static final int[] FRAME_DURATIONS = new int[]{60, 30, 15, 30, 60, 30, 45, 15, 30};
+
+    private FakeClock mFakeClock;
+    private TestExecutorService mExecutorService;
+    private ActivityManager mActivityManager;
+    private AnimatedDrawableUtil mAnimatedDrawableUtil;
+    private TestAnimatedDrawableBackend mDrawableBackend;
+    private AnimatedDrawableCachingBackendImpl mCachingBackend;
+
+    @Before
+    public void setup() {
+        mActivityManager =
+                (ActivityManager) Robolectric.application.getSystemService(Context.ACTIVITY_SERVICE);
+        mFakeClock = new FakeClock();
+        mExecutorService = new TestExecutorService(mFakeClock);
+        mAnimatedDrawableUtil = new AnimatedDrawableUtil();
+        mDrawableBackend = new TestAnimatedDrawableBackend(WIDTH, HEIGHT, FRAME_DURATIONS);
+    }
+
+    @Test
+    public void testForceImmediate() {
+        mCachingBackend = makeCachingBackend(0 /* no caching */);
+
+        // Spot check a pixel on frame 0
+        CloseableReference<Bitmap> bitmap0 = mCachingBackend.getBitmapForFrameBlocking(0);
+        assertNotNull(bitmap0);
+        assertEquals(pixelValue(0, 10, 20), bitmap0.get().getPixel(10, 20));
+    }
+
+    @Test
+    public void testAsyncFetches() {
+        mCachingBackend = makeCachingBackend(0 /* no caching */);
+
+        // Fetch frame with async API. Verify it returns null initially and put the decodes in flight.
+        CloseableReference<Bitmap> bitmap0 = mCachingBackend.getBitmapForFrame(0);
+        assertNull(bitmap0);
+        assertDecodesInFlight(0, 1, 2);
+
+        // Complete one command verify we now get the frame back.
+        mExecutorService.getScheduledQueue().runNextPendingCommand();
+        bitmap0 = mCachingBackend.getBitmapForFrame(0);
+        assertNotNull(bitmap0);
+        assertEquals(pixelValue(0, 10, 20), bitmap0.get().getPixel(10, 20));
+        assertDecodesInFlight(1, 2);
+
+        // Verify next frame returns null and puts one more decode in flight.
+        CloseableReference<Bitmap> bitmap1 = mCachingBackend.getBitmapForFrame(1);
+        assertNull(bitmap1);
+        assertDecodesInFlight(1, 2, 3);
+
+        // Make two more commands complete.
+        mExecutorService.getScheduledQueue().runNextPendingCommand();
+        mExecutorService.getScheduledQueue().runNextPendingCommand();
+        assertDecodesInFlight(3);
+
+        // Verify next two frames returns non-null and puts more decodes in flight.
+        bitmap1 = mCachingBackend.getBitmapForFrame(1);
+        assertNotNull(bitmap1);
+        CloseableReference<Bitmap> bitmap2 = mCachingBackend.getBitmapForFrame(2);
+        assertNotNull(bitmap2);
+        assertDecodesInFlight(3, 4);
+
+        // Skip to asking for frame
+        CloseableReference<Bitmap> bitmap7 = mCachingBackend.getBitmapForFrame(7);
+        assertNull(bitmap7);
+
+        // Expect decodes in flight to change based on new current frame.
+        assertDecodesInFlight(7, 8, 0);
+        mExecutorService.getScheduledQueue().runNextPendingCommand(); // cancelled frame 3
+        assertDecodesInFlight(7, 8, 0);
+        mExecutorService.getScheduledQueue().runNextPendingCommand(); // cancelled frame 4
+        assertDecodesInFlight(7, 8, 0);
+        mExecutorService.getScheduledQueue().runNextPendingCommand(); // frame 7
+        assertDecodesInFlight(8, 0);
+        mExecutorService.getScheduledQueue().runNextPendingCommand(); // frame 8
+        assertDecodesInFlight(0);
+        mExecutorService.getScheduledQueue().runNextPendingCommand(); // frame 0
+        assertDecodesInFlight();
     }
-    assertDecodesInFlight();
-    assertEquals(9, mCachingBackend.getFramesCached().size());
-  }
-
-  private void assertDecodesInFlight(int... frames) {
-    assertTrue(mExecutorService.getScheduledQueue().getPendingCount() >= frames.length);
-    Map<Integer, Task<?>> decodesInFlight =  mCachingBackend.getDecodesInFlight();
-    for (int i = 0; i < frames.length; i++) {
-      if (!decodesInFlight.containsKey(frames[i])) {
-        fail("Expected " + frames[i] + " to be in flight");
-      }
+
+    @Test
+    public void testFramesCachedInMemory() {
+        mCachingBackend = makeCachingBackend(50 * 1024 * 1024); // Enough to cache all frames
+
+        // Fetch frames and verify they stay cached.
+        for (int i = 0; i < FRAME_DURATIONS.length; i++) {
+            CloseableReference<Bitmap> bitmap = mCachingBackend.getBitmapForFrameBlocking(i);
+            assertNotNull(bitmap);
+            mExecutorService.getScheduledQueue().runUntilIdle();
+        }
+        assertDecodesInFlight();
+        assertEquals(9, mCachingBackend.getFramesCached().size());
+    }
+
+    private void assertDecodesInFlight(int... frames) {
+        assertTrue(mExecutorService.getScheduledQueue().getPendingCount() >= frames.length);
+        Map<Integer, Task<?>> decodesInFlight = mCachingBackend.getDecodesInFlight();
+        for (int i = 0; i < frames.length; i++) {
+            if (!decodesInFlight.containsKey(frames[i])) {
+                fail("Expected " + frames[i] + " to be in flight");
+            }
+        }
+        assertEquals(frames.length, decodesInFlight.size());
+    }
+
+    private AnimatedDrawableCachingBackendImpl makeCachingBackend(int maxBytes) {
+        AnimatedDrawableOptions options = AnimatedDrawableOptions.newBuilder()
+                .setMaximumBytes(maxBytes)
+                .build();
+        return new AnimatedDrawableCachingBackendImpl(
+                mExecutorService,
+                mActivityManager,
+                mAnimatedDrawableUtil,
+                mFakeClock,
+                mDrawableBackend,
+                options);
     }
-    assertEquals(frames.length, decodesInFlight.size());
-  }
-
-  private AnimatedDrawableCachingBackendImpl makeCachingBackend(int maxBytes) {
-    AnimatedDrawableOptions options = AnimatedDrawableOptions.newBuilder()
-        .setMaximumBytes(maxBytes)
-        .build();
-    return new AnimatedDrawableCachingBackendImpl(
-        mExecutorService,
-        mActivityManager,
-        mAnimatedDrawableUtil,
-        mFakeClock,
-        mDrawableBackend,
-        options);
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/DeltaQueue.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/DeltaQueue.java
index 20231e489..211435932 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/DeltaQueue.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/DeltaQueue.java
@@ -16,189 +16,189 @@
  * @param <T> the type of node
  */
 public class DeltaQueue<T> {
-  /**
-   * A node in the queue.
-   *
-   * @param <T> the type of node
-   */
-  private static class Node<T> {
-    public final T value;
-    public long delay;
-    public Node<T> next = null;
-
-    public Node(T value, long nanos) {
-      this.value = value;
-      this.delay = nanos;
-    }
-  }
-
-  private Node<T> head = null;
-  private int size;
-
-  /**
-   * Gets whether the queue is empty.
-   *
-   * @return whether the queue is empty
-   */
-  public boolean isEmpty() {
-    return head == null;
-  }
-
-  /**
-   * Gets whether there are items in the queue.
-   *
-   * @return whether there are items in the queue
-   */
-  public boolean isNotEmpty() {
-    return !isEmpty();
-  }
-
-  /**
-   * Gets the next item in the queue without removing it.
-   *
-   * @return the next item in the queue
-   */
-  public T next() {
-    return head.value;
-  }
-
-  /**
-   * Gets the delay until the next item in the queue.
-   *
-   * @return the delay until the next item
-   */
-  public long delay() {
-    return head.delay;
-  }
-
-  /**
-   * Adds a node to the queue.
-   *
-   * @param delay the delay
-   * @param value the node to add
-   */
-  public void add(long delay, T value) {
-    Node<T> newNode = new Node<T>(value, delay);
-
-    Node<T> prev = null;
-    Node<T> next = head;
-
-    while (next != null && next.delay <= newNode.delay) {
-      newNode.delay -= next.delay;
-      prev = next;
-      next = next.next;
+    /**
+     * A node in the queue.
+     *
+     * @param <T> the type of node
+     */
+    private static class Node<T> {
+        public final T value;
+        public long delay;
+        public Node<T> next = null;
+
+        public Node(T value, long nanos) {
+            this.value = value;
+            this.delay = nanos;
+        }
     }
 
-    if (prev == null) {
-      head = newNode;
-    } else {
-      prev.next = newNode;
-    }
+    private Node<T> head = null;
+    private int size;
 
-    if (next != null) {
-      next.delay -= newNode.delay;
+    /**
+     * Gets whether the queue is empty.
+     *
+     * @return whether the queue is empty
+     */
+    public boolean isEmpty() {
+        return head == null;
+    }
 
-      newNode.next = next;
+    /**
+     * Gets whether there are items in the queue.
+     *
+     * @return whether there are items in the queue
+     */
+    public boolean isNotEmpty() {
+        return !isEmpty();
     }
-    size++;
-  }
-
-  /**
-   * Simulates the passage of time.
-   *
-   * @param timeUnits the units of time that are desired to have passed
-   * @return the time units that were not yet consumed.
-   */
-  public long tick(long timeUnits) {
-    if (head == null) {
-      return 0L;
-    } else if (head.delay >= timeUnits) {
-      head.delay -= timeUnits;
-      return 0L;
-    } else {
-      long leftover = timeUnits - head.delay;
-      head.delay = 0L;
-      return leftover;
+
+    /**
+     * Gets the next item in the queue without removing it.
+     *
+     * @return the next item in the queue
+     */
+    public T next() {
+        return head.value;
     }
-  }
-
-  /**
-   * Pops the next element off the queue. Only valid to call if the head is ready to be pop'd
-   * because of the passage of time.
-   *
-   * @return the next element off the queue.
-   */
-  public T pop() {
-    if (head.delay > 0) {
-      throw new IllegalStateException("cannot pop the head element when it has a non-zero delay");
+
+    /**
+     * Gets the delay until the next item in the queue.
+     *
+     * @return the delay until the next item
+     */
+    public long delay() {
+        return head.delay;
     }
 
-    T popped = head.value;
-    head = head.next;
-    size--;
-    return popped;
-  }
-
-  /**
-   * Removes the specified element from the queue.
-   *
-   * @param element the element to remove
-   * @return whether the element was removed
-   */
-  public boolean remove(T element) {
-    Node<T> prev = null;
-    Node<T> node = head;
-    while (node != null && node.value != element) {
-      prev = node;
-      node = node.next;
+    /**
+     * Adds a node to the queue.
+     *
+     * @param delay the delay
+     * @param value the node to add
+     */
+    public void add(long delay, T value) {
+        Node<T> newNode = new Node<T>(value, delay);
+
+        Node<T> prev = null;
+        Node<T> next = head;
+
+        while (next != null && next.delay <= newNode.delay) {
+            newNode.delay -= next.delay;
+            prev = next;
+            next = next.next;
+        }
+
+        if (prev == null) {
+            head = newNode;
+        } else {
+            prev.next = newNode;
+        }
+
+        if (next != null) {
+            next.delay -= newNode.delay;
+
+            newNode.next = next;
+        }
+        size++;
     }
 
-    if (node == null) {
-      return false;
+    /**
+     * Simulates the passage of time.
+     *
+     * @param timeUnits the units of time that are desired to have passed
+     * @return the time units that were not yet consumed.
+     */
+    public long tick(long timeUnits) {
+        if (head == null) {
+            return 0L;
+        } else if (head.delay >= timeUnits) {
+            head.delay -= timeUnits;
+            return 0L;
+        } else {
+            long leftover = timeUnits - head.delay;
+            head.delay = 0L;
+            return leftover;
+        }
     }
 
-    if (node.next != null) {
-      node.next.delay += node.delay;
+    /**
+     * Pops the next element off the queue. Only valid to call if the head is ready to be pop'd
+     * because of the passage of time.
+     *
+     * @return the next element off the queue.
+     */
+    public T pop() {
+        if (head.delay > 0) {
+            throw new IllegalStateException("cannot pop the head element when it has a non-zero delay");
+        }
+
+        T popped = head.value;
+        head = head.next;
+        size--;
+        return popped;
     }
 
-    if (prev == null) {
-      head = node.next;
-    } else {
-      prev.next = node.next;
+    /**
+     * Removes the specified element from the queue.
+     *
+     * @param element the element to remove
+     * @return whether the element was removed
+     */
+    public boolean remove(T element) {
+        Node<T> prev = null;
+        Node<T> node = head;
+        while (node != null && node.value != element) {
+            prev = node;
+            node = node.next;
+        }
+
+        if (node == null) {
+            return false;
+        }
+
+        if (node.next != null) {
+            node.next.delay += node.delay;
+        }
+
+        if (prev == null) {
+            head = node.next;
+        } else {
+            prev.next = node.next;
+        }
+        size--;
+        return true;
     }
-    size--;
-    return true;
-  }
-
-  /**
-   * Gets the number of items in the queue. This returns in constant time.
-   *
-   * @return number of elements in the queue
-   */
-  public int size() {
-    return size;
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder();
-    sb.append(getClass().getSimpleName())
-        .append("[");
-
-    Node<T> node = head;
-    while (node != null) {
-      if (node != head) {
-        sb.append(", ");
-      }
-      sb.append("+")
-          .append(node.delay)
-          .append(": ")
-          .append(node.value);
-
-      node = node.next;
+
+    /**
+     * Gets the number of items in the queue. This returns in constant time.
+     *
+     * @return number of elements in the queue
+     */
+    public int size() {
+        return size;
     }
-    sb.append("]");
 
-    return sb.toString();
-  }
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(getClass().getSimpleName())
+                .append("[");
+
+        Node<T> node = head;
+        while (node != null) {
+            if (node != head) {
+                sb.append(", ");
+            }
+            sb.append("+")
+                    .append(node.delay)
+                    .append(": ")
+                    .append(node.value);
+
+            node = node.next;
+        }
+        sb.append("]");
+
+        return sb.toString();
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowBitmap.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowBitmap.java
index d49f3414e..bc849727f 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowBitmap.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowBitmap.java
@@ -21,57 +21,57 @@
 @Implements(Bitmap.class)
 public class MyShadowBitmap {
 
-  private int width;
-  private int height;
-  private int[] mPixels;
+    private int width;
+    private int height;
+    private int[] mPixels;
 
-  @Implementation
-  public int getWidth() {
-    return width;
-  }
+    @Implementation
+    public int getWidth() {
+        return width;
+    }
 
-  @Implementation
-  public int getHeight() {
-    return height;
-  }
+    @Implementation
+    public int getHeight() {
+        return height;
+    }
 
-  @Implementation
-  public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
-    Bitmap bitmap = Robolectric.newInstanceOf(Bitmap.class);
-    MyShadowBitmap shadowBitmap = Robolectric.shadowOf_(bitmap);
-    shadowBitmap.width = width;
-    shadowBitmap.height = height;
-    shadowBitmap.mPixels = new int[width * height];
-    return bitmap;
-  }
+    @Implementation
+    public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
+        Bitmap bitmap = Robolectric.newInstanceOf(Bitmap.class);
+        MyShadowBitmap shadowBitmap = Robolectric.shadowOf_(bitmap);
+        shadowBitmap.width = width;
+        shadowBitmap.height = height;
+        shadowBitmap.mPixels = new int[width * height];
+        return bitmap;
+    }
 
-  @Implementation
-  public static Bitmap createBitmap(int colors[], int width, int height, Bitmap.Config config) {
-    Bitmap bitmap = Robolectric.newInstanceOf(Bitmap.class);
-    MyShadowBitmap shadowBitmap = Robolectric.shadowOf_(bitmap);
-    shadowBitmap.width = width;
-    shadowBitmap.height = height;
-    shadowBitmap.mPixels = new int[width * height];
-    for (int i = 0; i < colors.length; i++) {
-      shadowBitmap.mPixels[i] = colors[i];
+    @Implementation
+    public static Bitmap createBitmap(int colors[], int width, int height, Bitmap.Config config) {
+        Bitmap bitmap = Robolectric.newInstanceOf(Bitmap.class);
+        MyShadowBitmap shadowBitmap = Robolectric.shadowOf_(bitmap);
+        shadowBitmap.width = width;
+        shadowBitmap.height = height;
+        shadowBitmap.mPixels = new int[width * height];
+        for (int i = 0; i < colors.length; i++) {
+            shadowBitmap.mPixels[i] = colors[i];
+        }
+        return bitmap;
     }
-    return bitmap;
-  }
 
-  @Implementation
-  public void setPixel(int x, int y, int color) {
-    mPixels[y * width + x] = color;
-  }
+    @Implementation
+    public void setPixel(int x, int y, int color) {
+        mPixels[y * width + x] = color;
+    }
 
-  @Implementation
-  public int getPixel(int x, int y) {
-    return mPixels[y * width + x];
-  }
+    @Implementation
+    public int getPixel(int x, int y) {
+        return mPixels[y * width + x];
+    }
 
-  @Implementation
-  public void eraseColor(int c) {
-    for (int i = 0; i < mPixels.length; i++) {
-      mPixels[i] = c;
+    @Implementation
+    public void eraseColor(int c) {
+        for (int i = 0; i < mPixels.length; i++) {
+            mPixels[i] = c;
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowCanvas.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowCanvas.java
index 6d459039e..e3f3b4cc8 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowCanvas.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/MyShadowCanvas.java
@@ -23,19 +23,20 @@
 @Implements(Canvas.class)
 public class MyShadowCanvas {
 
-  @RealObject private Canvas mRealCanvas;
-  private Bitmap mBitmap;
+    @RealObject
+    private Canvas mRealCanvas;
+    private Bitmap mBitmap;
 
-  public void __constructor__(Bitmap bitmap) {
-    mBitmap = bitmap;
-  }
+    public void __constructor__(Bitmap bitmap) {
+        mBitmap = bitmap;
+    }
 
-  @Implementation
-  public void drawBitmap(Bitmap bitmap, float left, float top, Paint paint) {
-    for (int x = 0; x < bitmap.getWidth(); x++) {
-      for (int y = 0; y < bitmap.getHeight(); y++) {
-        mBitmap.setPixel(x, y, bitmap.getPixel(x, y));
-      }
+    @Implementation
+    public void drawBitmap(Bitmap bitmap, float left, float top, Paint paint) {
+        for (int x = 0; x < bitmap.getWidth(); x++) {
+            for (int y = 0; y < bitmap.getHeight(); y++) {
+                mBitmap.setPixel(x, y, bitmap.getPixel(x, y));
+            }
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/ScheduledQueue.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/ScheduledQueue.java
index 1120562ac..2f24e4ac1 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/ScheduledQueue.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/ScheduledQueue.java
@@ -17,121 +17,122 @@
  */
 public class ScheduledQueue {
 
-  private final FakeClock clock;
-  private final DeltaQueue<Runnable> deltaQueue = new DeltaQueue<Runnable>();
-  private long now;
-  private boolean isTicking;
-  private long tickRemaining;
+    private final FakeClock clock;
+    private final DeltaQueue<Runnable> deltaQueue = new DeltaQueue<Runnable>();
+    private long now;
+    private boolean isTicking;
+    private long tickRemaining;
 
-  public ScheduledQueue(FakeClock clock) {
-    this.clock = clock;
-    now = clock.now();
-    clock.addListener(
-        new FakeClock.OnTickListener() {
-          @Override
-          public void onTick() {
-            ScheduledQueue.this.tick();
-          }
-        });
-  }
+    public ScheduledQueue(FakeClock clock) {
+        this.clock = clock;
+        now = clock.now();
+        clock.addListener(
+                new FakeClock.OnTickListener() {
+                    @Override
+                    public void onTick() {
+                        ScheduledQueue.this.tick();
+                    }
+                });
+    }
 
-  /**
-   * Runs time forwards by a given duration, executing any commands scheduled for
-   * execution during that time period, and any background tasks spawned by the
-   * scheduled tasks.  Therefore, when a call to tick returns, the executor
-   * will be idle.
-   */
-  private void tick() {
-    long newNow = clock.now();
-    Preconditions.checkState(!isTicking);
-    isTicking = true;
-    try {
-      tickRemaining = newNow - now;
-      now = newNow;
-      do {
-        tickRemaining = deltaQueue.tick(tickRemaining);
-        runUntilIdle();
-      } while (deltaQueue.isNotEmpty() && tickRemaining > 0);
-      Preconditions.checkState(isTicking);
-    } finally {
-      isTicking = false;
-      tickRemaining = 0;
+    /**
+     * Runs time forwards by a given duration, executing any commands scheduled for
+     * execution during that time period, and any background tasks spawned by the
+     * scheduled tasks.  Therefore, when a call to tick returns, the executor
+     * will be idle.
+     */
+    private void tick() {
+        long newNow = clock.now();
+        Preconditions.checkState(!isTicking);
+        isTicking = true;
+        try {
+            tickRemaining = newNow - now;
+            now = newNow;
+            do {
+                tickRemaining = deltaQueue.tick(tickRemaining);
+                runUntilIdle();
+            } while (deltaQueue.isNotEmpty() && tickRemaining > 0);
+            Preconditions.checkState(isTicking);
+        } finally {
+            isTicking = false;
+            tickRemaining = 0;
+        }
     }
-  }
 
-  /**
-   * Runs all commands scheduled to be executed immediately but does
-   * not tick time forward.
-   */
-  public void runUntilIdle() {
-    while (!isIdle()) {
-      runNextPendingCommand();
+    /**
+     * Runs all commands scheduled to be executed immediately but does
+     * not tick time forward.
+     */
+    public void runUntilIdle() {
+        while (!isIdle()) {
+            runNextPendingCommand();
+        }
     }
-  }
 
-  /**
-   * Gets whether the queue is idle.
-   *
-   * @return whether there are no more items in the queue that are ready to be processed
-   */
-  public boolean isIdle() {
-    return deltaQueue.isEmpty() || deltaQueue.delay() > 0;
-  }
+    /**
+     * Gets whether the queue is idle.
+     *
+     * @return whether there are no more items in the queue that are ready to be processed
+     */
+    public boolean isIdle() {
+        return deltaQueue.isEmpty() || deltaQueue.delay() > 0;
+    }
 
-  /**
-   * Runs the next command scheduled to be executed immediately.
-   */
-  public void runNextPendingCommand() {
-    Runnable runnable = deltaQueue.pop();
-    runnable.run();
-  }
+    /**
+     * Runs the next command scheduled to be executed immediately.
+     */
+    public void runNextPendingCommand() {
+        Runnable runnable = deltaQueue.pop();
+        runnable.run();
+    }
 
-  /**
-   * Returns how much time left until next command.
-   *
-   * If there are no pending commands left will throw and exception.
-   */
-  public long getNextPendingCommandDelay() {
-    if (getPendingCount() == 0) {
-      throw new IllegalStateException();
+    /**
+     * Returns how much time left until next command.
+     * <p>
+     * If there are no pending commands left will throw and exception.
+     */
+    public long getNextPendingCommandDelay() {
+        if (getPendingCount() == 0) {
+            throw new IllegalStateException();
+        }
+        return deltaQueue.delay();
     }
-    return deltaQueue.delay();
-  }
 
-  /**
-   * Adds a task to the queue that is ready to be executed.
-   *
-   * @param runnable the task to execute
-   */
-  public void add(Runnable runnable) {
-    deltaQueue.add(tickRemaining, runnable);
-  }
+    /**
+     * Adds a task to the queue that is ready to be executed.
+     *
+     * @param runnable the task to execute
+     */
+    public void add(Runnable runnable) {
+        deltaQueue.add(tickRemaining, runnable);
+    }
 
-  /**
-   * Adds a task to the queue that is to be executed to after the specified delay.
-   *
-   * @param runnable the task to execute
-   * @param delayMs the delay before the task should be executed
-   */
-  public void add(Runnable runnable, long delayMs) {
-    deltaQueue.add(tickRemaining + delayMs, runnable);
-  }
+    /**
+     * Adds a task to the queue that is to be executed to after the specified delay.
+     *
+     * @param runnable the task to execute
+     * @param delayMs  the delay before the task should be executed
+     */
+    public void add(Runnable runnable, long delayMs) {
+        deltaQueue.add(tickRemaining + delayMs, runnable);
+    }
 
-  /**
-   * Removes a task from the queue
-   * @param runnable The runnable to remove
-   * @return whether the element was removed
-   */
-  public boolean remove(Runnable runnable) {
-    return deltaQueue.remove(runnable);
-  }
+    /**
+     * Removes a task from the queue
+     *
+     * @param runnable The runnable to remove
+     * @return whether the element was removed
+     */
+    public boolean remove(Runnable runnable) {
+        return deltaQueue.remove(runnable);
+    }
 
-  /**
-   * Gets the count of queued runnables, regardless of whether they are ready to be run.
-   *
-   * @return the count of queued runnables
-   */
-  public int getPendingCount() {
-    return deltaQueue.size();
-  }
+    /**
+     * Gets the count of queued runnables, regardless of whether they are ready to be run.
+     *
+     * @return the count of queued runnables
+     */
+    public int getPendingCount() {
+        return deltaQueue.size();
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableBackend.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableBackend.java
index 34dd3b831..70a431b3e 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableBackend.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestAnimatedDrawableBackend.java
@@ -23,147 +23,147 @@
  */
 public class TestAnimatedDrawableBackend implements AnimatedDrawableBackend {
 
-  private final int mWidth;
-  private final int mHeight;
-  private final int[] mFrameDurations;
-  private final int[] mAccumulatedDurationsMs;
-
-  private int mDropCachesCallCount;
-
-  public TestAnimatedDrawableBackend(int width, int height, int[] frameDurations) {
-    mWidth = width;
-    mHeight = height;
-    mFrameDurations = frameDurations;
-    mAccumulatedDurationsMs = new int[mFrameDurations.length];
-    int accumulatedDurationMs = 0;
-    for (int i = 0; i < mAccumulatedDurationsMs.length; i++) {
-      mAccumulatedDurationsMs[i] = accumulatedDurationMs + mFrameDurations[i];
-      accumulatedDurationMs = mAccumulatedDurationsMs[i];
-    }
-  }
-
-  public static int pixelValue(int frameNumber, int x, int y) {
-    return ((frameNumber & 0xff) << 16) | ((x & 0xff) << 8) | ((y & 0xff));
-  }
-
-  @Override
-  public AnimatedImageResult getAnimatedImageResult() {
-    return null;
-  }
-
-  @Override
-  public int getDurationMs() {
-    return mAccumulatedDurationsMs[mAccumulatedDurationsMs.length - 1];
-  }
-
-  @Override
-  public int getFrameCount() {
-    return mFrameDurations.length;
-  }
-
-  @Override
-  public int getLoopCount() {
-    return 0;
-  }
-
-  @Override
-  public int getWidth() {
-    return mWidth;
-  }
-
-  @Override
-  public int getHeight() {
-    return mHeight;
-  }
-
-  @Override
-  public int getRenderedWidth() {
-    return mWidth;
-  }
-
-  @Override
-  public int getRenderedHeight() {
-    return mHeight;
-  }
-
-  @Override
-  public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
-    return new AnimatedDrawableFrameInfo(
-        frameNumber,
-        0,
-        0,
-        mWidth,
-        mHeight,
-        false,
-        AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_DO_NOT);
-  }
-
-  @Override
-  public void renderFrame(int frameNumber, Canvas canvas) {
-    int[] pixels = new int[mWidth * mHeight];
-    for (int i = 0; i < pixels.length; i++) {
-      // We store the frame number in the R, the x in the G, and the y in the B.
-      int x = i % mWidth;
-      int y = i / mWidth;
-      pixels[i] = pixelValue(frameNumber, x, y);
-    }
-    Bitmap bitmap = Bitmap.createBitmap(pixels, mWidth, mHeight, Bitmap.Config.ARGB_8888);
-    canvas.drawBitmap(bitmap, 0, 0, null);
-  }
-
-  @Override
-  public int getFrameForTimestampMs(int timestampMs) {
-    int accumulator = 0;
-    for (int i = 0; i < mFrameDurations.length; i++) {
-      if (timestampMs < accumulator + mFrameDurations[i]) {
-        return i;
-      }
-      accumulator += mFrameDurations[i];
-    }
-    return mFrameDurations.length - 1;
-  }
-
-  @Override
-  public int getTimestampMsForFrame(int frameNumber) {
-    return frameNumber == 0 ? 0 : mAccumulatedDurationsMs[frameNumber - 1];
-  }
-
-  @Override
-  public int getDurationMsForFrame(int frameNumber) {
-    return mFrameDurations[frameNumber];
-  }
-
-  @Override
-  public int getFrameForPreview() {
-    return 0;
-  }
-
-  @Override
-  public AnimatedDrawableBackend forNewBounds(Rect bounds) {
-    return this;
-  }
-
-  @Override
-  public int getMemoryUsage() {
-    return 0;
-  }
-
-  @Override
-  public CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber) {
-    return null;
-  }
-
-  @Override
-  public boolean hasPreDecodedFrame(int frameNumber) {
-    return false;
-  }
-
-  public int getDropCachesCallCount() {
-    return mDropCachesCallCount;
-  }
-
-  @Override
-  public void dropCaches() {
-    mDropCachesCallCount++;
-  }
+    private final int mWidth;
+    private final int mHeight;
+    private final int[] mFrameDurations;
+    private final int[] mAccumulatedDurationsMs;
+
+    private int mDropCachesCallCount;
+
+    public TestAnimatedDrawableBackend(int width, int height, int[] frameDurations) {
+        mWidth = width;
+        mHeight = height;
+        mFrameDurations = frameDurations;
+        mAccumulatedDurationsMs = new int[mFrameDurations.length];
+        int accumulatedDurationMs = 0;
+        for (int i = 0; i < mAccumulatedDurationsMs.length; i++) {
+            mAccumulatedDurationsMs[i] = accumulatedDurationMs + mFrameDurations[i];
+            accumulatedDurationMs = mAccumulatedDurationsMs[i];
+        }
+    }
+
+    public static int pixelValue(int frameNumber, int x, int y) {
+        return ((frameNumber & 0xff) << 16) | ((x & 0xff) << 8) | ((y & 0xff));
+    }
+
+    @Override
+    public AnimatedImageResult getAnimatedImageResult() {
+        return null;
+    }
+
+    @Override
+    public int getDurationMs() {
+        return mAccumulatedDurationsMs[mAccumulatedDurationsMs.length - 1];
+    }
+
+    @Override
+    public int getFrameCount() {
+        return mFrameDurations.length;
+    }
+
+    @Override
+    public int getLoopCount() {
+        return 0;
+    }
+
+    @Override
+    public int getWidth() {
+        return mWidth;
+    }
+
+    @Override
+    public int getHeight() {
+        return mHeight;
+    }
+
+    @Override
+    public int getRenderedWidth() {
+        return mWidth;
+    }
+
+    @Override
+    public int getRenderedHeight() {
+        return mHeight;
+    }
+
+    @Override
+    public AnimatedDrawableFrameInfo getFrameInfo(int frameNumber) {
+        return new AnimatedDrawableFrameInfo(
+                frameNumber,
+                0,
+                0,
+                mWidth,
+                mHeight,
+                false,
+                AnimatedDrawableFrameInfo.DisposalMethod.DISPOSE_DO_NOT);
+    }
+
+    @Override
+    public void renderFrame(int frameNumber, Canvas canvas) {
+        int[] pixels = new int[mWidth * mHeight];
+        for (int i = 0; i < pixels.length; i++) {
+            // We store the frame number in the R, the x in the G, and the y in the B.
+            int x = i % mWidth;
+            int y = i / mWidth;
+            pixels[i] = pixelValue(frameNumber, x, y);
+        }
+        Bitmap bitmap = Bitmap.createBitmap(pixels, mWidth, mHeight, Bitmap.Config.ARGB_8888);
+        canvas.drawBitmap(bitmap, 0, 0, null);
+    }
+
+    @Override
+    public int getFrameForTimestampMs(int timestampMs) {
+        int accumulator = 0;
+        for (int i = 0; i < mFrameDurations.length; i++) {
+            if (timestampMs < accumulator + mFrameDurations[i]) {
+                return i;
+            }
+            accumulator += mFrameDurations[i];
+        }
+        return mFrameDurations.length - 1;
+    }
+
+    @Override
+    public int getTimestampMsForFrame(int frameNumber) {
+        return frameNumber == 0 ? 0 : mAccumulatedDurationsMs[frameNumber - 1];
+    }
+
+    @Override
+    public int getDurationMsForFrame(int frameNumber) {
+        return mFrameDurations[frameNumber];
+    }
+
+    @Override
+    public int getFrameForPreview() {
+        return 0;
+    }
+
+    @Override
+    public AnimatedDrawableBackend forNewBounds(Rect bounds) {
+        return this;
+    }
+
+    @Override
+    public int getMemoryUsage() {
+        return 0;
+    }
+
+    @Override
+    public CloseableReference<Bitmap> getPreDecodedFrame(int frameNumber) {
+        return null;
+    }
+
+    @Override
+    public boolean hasPreDecodedFrame(int frameNumber) {
+        return false;
+    }
+
+    public int getDropCachesCallCount() {
+        return mDropCachesCallCount;
+    }
+
+    @Override
+    public void dropCaches() {
+        mDropCachesCallCount++;
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestExecutorService.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestExecutorService.java
index 02298f1de..f924022b4 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestExecutorService.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestExecutorService.java
@@ -23,79 +23,79 @@
  */
 public class TestExecutorService extends AbstractExecutorService implements SerialExecutorService {
 
-  protected final ScheduledQueue scheduledQueue;
-  private final FakeClock fakeClock;
-
-  public TestExecutorService(FakeClock fakeClock) {
-    this.fakeClock = fakeClock;
-    this.scheduledQueue = new ScheduledQueue(fakeClock);
-  }
-
-  protected FakeClock getFakeClock() {
-    return fakeClock;
-  }
-
-  /**
-   * Gets the underlying queue that backs the executor service.
-   *
-   * @return the underlying queue
-   */
-  public ScheduledQueue getScheduledQueue() {
-    return scheduledQueue;
-  }
-
-  @Override
-  public void shutdown() {
-  }
-
-  @Override
-  public List<Runnable> shutdownNow() {
-    return null;
-  }
-
-  @Override
-  public boolean isShutdown() {
-    return false;
-  }
-
-  @Override
-  public boolean isTerminated() {
-    return false;
-  }
-
-  @Override
-  public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {
-    throw new RuntimeException();
-  }
-
-  @Override
-  public void execute(Runnable runnable) {
-    scheduledQueue.add(runnable);
-  }
-
-  @Override
-  protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
-    return super.newTaskFor(runnable, value);
-  }
-
-  @Override
-  protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
-    return super.newTaskFor(callable);
-  }
-
-  public int getPendingCount() {
-    return scheduledQueue.getPendingCount();
-  }
-
-  public void runUntilIdle() {
-    scheduledQueue.runUntilIdle();
-  }
-
-  public void runNextPendingCommand() {
-    scheduledQueue.runNextPendingCommand();
-  }
-
-  public boolean isIdle() {
-    return scheduledQueue.isIdle();
-  }
+    protected final ScheduledQueue scheduledQueue;
+    private final FakeClock fakeClock;
+
+    public TestExecutorService(FakeClock fakeClock) {
+        this.fakeClock = fakeClock;
+        this.scheduledQueue = new ScheduledQueue(fakeClock);
+    }
+
+    protected FakeClock getFakeClock() {
+        return fakeClock;
+    }
+
+    /**
+     * Gets the underlying queue that backs the executor service.
+     *
+     * @return the underlying queue
+     */
+    public ScheduledQueue getScheduledQueue() {
+        return scheduledQueue;
+    }
+
+    @Override
+    public void shutdown() {
+    }
+
+    @Override
+    public List<Runnable> shutdownNow() {
+        return null;
+    }
+
+    @Override
+    public boolean isShutdown() {
+        return false;
+    }
+
+    @Override
+    public boolean isTerminated() {
+        return false;
+    }
+
+    @Override
+    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {
+        throw new RuntimeException();
+    }
+
+    @Override
+    public void execute(Runnable runnable) {
+        scheduledQueue.add(runnable);
+    }
+
+    @Override
+    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
+        return super.newTaskFor(runnable, value);
+    }
+
+    @Override
+    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
+        return super.newTaskFor(callable);
+    }
+
+    public int getPendingCount() {
+        return scheduledQueue.getPendingCount();
+    }
+
+    public void runUntilIdle() {
+        scheduledQueue.runUntilIdle();
+    }
+
+    public void runNextPendingCommand() {
+        scheduledQueue.runNextPendingCommand();
+    }
+
+    public boolean isIdle() {
+        return scheduledQueue.isIdle();
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestScheduledExecutorService.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestScheduledExecutorService.java
index 575789eb8..a09cea7d1 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestScheduledExecutorService.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestScheduledExecutorService.java
@@ -17,45 +17,45 @@
 import com.facebook.common.testing.FakeClock;
 
 public class TestScheduledExecutorService extends TestExecutorService
-    implements ScheduledExecutorService {
-
-  public TestScheduledExecutorService(FakeClock fakeClock) {
-    super(fakeClock);
-  }
-
-  @Override
-  public ScheduledFuture<?> schedule(final Runnable runnable, long delay, TimeUnit timeUnit) {
-    return new TestScheduledFuture(
-        getFakeClock(),
-        scheduledQueue,
-        TimeUnit.MILLISECONDS.convert(delay, timeUnit),
-        runnable);
-  }
-
-  @Override
-  public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit timeUnit) {
-    return new TestScheduledFuture<V>(
-        getFakeClock(),
-        scheduledQueue,
-        TimeUnit.MILLISECONDS.convert(delay, timeUnit),
-        callable);
-  }
-
-  @Override
-  public ScheduledFuture<?> scheduleAtFixedRate(
-      Runnable runnable,
-      long initialDelay,
-      long period,
-      TimeUnit timeUnit) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public ScheduledFuture<?> scheduleWithFixedDelay(
-      Runnable runnable,
-      long initialDelay,
-      long delay,
-      TimeUnit timeUnit) {
-    throw new UnsupportedOperationException();
-  }
+        implements ScheduledExecutorService {
+
+    public TestScheduledExecutorService(FakeClock fakeClock) {
+        super(fakeClock);
+    }
+
+    @Override
+    public ScheduledFuture<?> schedule(final Runnable runnable, long delay, TimeUnit timeUnit) {
+        return new TestScheduledFuture(
+                getFakeClock(),
+                scheduledQueue,
+                TimeUnit.MILLISECONDS.convert(delay, timeUnit),
+                runnable);
+    }
+
+    @Override
+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit timeUnit) {
+        return new TestScheduledFuture<V>(
+                getFakeClock(),
+                scheduledQueue,
+                TimeUnit.MILLISECONDS.convert(delay, timeUnit),
+                callable);
+    }
+
+    @Override
+    public ScheduledFuture<?> scheduleAtFixedRate(
+            Runnable runnable,
+            long initialDelay,
+            long period,
+            TimeUnit timeUnit) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ScheduledFuture<?> scheduleWithFixedDelay(
+            Runnable runnable,
+            long initialDelay,
+            long delay,
+            TimeUnit timeUnit) {
+        throw new UnsupportedOperationException();
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestScheduledFuture.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestScheduledFuture.java
index c8b6b5baf..f9c51d989 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestScheduledFuture.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/testing/TestScheduledFuture.java
@@ -21,98 +21,99 @@
 
 public class TestScheduledFuture<V> implements ScheduledFuture<V> {
 
-  private final FakeClock mFakeClock;
-  private final ScheduledQueue mScheduledQueue;
-  private final long mScheduledTime;
-  private final Runnable mWrap;
-  private boolean mIsCanceled;
-  private boolean mIsDone;
-  private V mResult;
-  private Throwable mResultThrowable;
+    private final FakeClock mFakeClock;
+    private final ScheduledQueue mScheduledQueue;
+    private final long mScheduledTime;
+    private final Runnable mWrap;
+    private boolean mIsCanceled;
+    private boolean mIsDone;
+    private V mResult;
+    private Throwable mResultThrowable;
 
-  TestScheduledFuture(
-      FakeClock fakeClock,
-      ScheduledQueue scheduledQueue,
-      long delay,
-      final Runnable runnable) {
-    this(
-        fakeClock,
-        scheduledQueue,
-        delay,
-        Executors.<V>callable(runnable, null));
-  }
-
-  TestScheduledFuture(
-      FakeClock fakeClock,
-      ScheduledQueue scheduledQueue,
-      long delay,
-      final Callable<V> callable) {
-    mFakeClock = fakeClock;
-    mScheduledQueue = scheduledQueue;
-    mScheduledTime = mFakeClock.now() + delay;
-    mWrap = new Runnable() {
-      @Override
-      public void run() {
-        try {
-          mResult = callable.call();
-        } catch (Throwable t) {
-          mResultThrowable = t;
-        }
-        mIsDone = true;
-      }
-    };
-    mScheduledQueue.add(mWrap, delay);
-  }
+    TestScheduledFuture(
+            FakeClock fakeClock,
+            ScheduledQueue scheduledQueue,
+            long delay,
+            final Runnable runnable) {
+        this(
+                fakeClock,
+                scheduledQueue,
+                delay,
+                Executors.<V>callable(runnable, null));
+    }
 
-  @Override
-  public long getDelay(TimeUnit timeUnit) {
-    return timeUnit.convert(mFakeClock.now() - mScheduledTime, TimeUnit.MILLISECONDS);
-  }
+    TestScheduledFuture(
+            FakeClock fakeClock,
+            ScheduledQueue scheduledQueue,
+            long delay,
+            final Callable<V> callable) {
+        mFakeClock = fakeClock;
+        mScheduledQueue = scheduledQueue;
+        mScheduledTime = mFakeClock.now() + delay;
+        mWrap = new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    mResult = callable.call();
+                } catch (Throwable t) {
+                    mResultThrowable = t;
+                }
+                mIsDone = true;
+            }
+        };
+        mScheduledQueue.add(mWrap, delay);
+    }
 
-  @Override
-  public int compareTo(Delayed delayed) {
-    long me = getDelay(TimeUnit.MILLISECONDS);
-    long other = delayed.getDelay(TimeUnit.MILLISECONDS);
-    if (me < other) {
-      return -1;
-    } if (me > other) {
-      return 1;
-    } else {
-      return 0;
+    @Override
+    public long getDelay(TimeUnit timeUnit) {
+        return timeUnit.convert(mFakeClock.now() - mScheduledTime, TimeUnit.MILLISECONDS);
     }
-  }
 
-  @Override
-  public boolean cancel(boolean b) {
-    mIsCanceled = mScheduledQueue.remove(mWrap);
-    return mIsCanceled;
-  }
+    @Override
+    public int compareTo(Delayed delayed) {
+        long me = getDelay(TimeUnit.MILLISECONDS);
+        long other = delayed.getDelay(TimeUnit.MILLISECONDS);
+        if (me < other) {
+            return -1;
+        }
+        if (me > other) {
+            return 1;
+        } else {
+            return 0;
+        }
+    }
 
-  @Override
-  public boolean isCancelled() {
-    return mIsCanceled;
-  }
+    @Override
+    public boolean cancel(boolean b) {
+        mIsCanceled = mScheduledQueue.remove(mWrap);
+        return mIsCanceled;
+    }
 
-  @Override
-  public boolean isDone() {
-    return mIsDone;
-  }
+    @Override
+    public boolean isCancelled() {
+        return mIsCanceled;
+    }
 
-  @Override
-  public V get() throws InterruptedException, ExecutionException {
-    if (!mIsDone) {
-      throw new IllegalStateException("Not yet done. We don't support blocking in tests");
+    @Override
+    public boolean isDone() {
+        return mIsDone;
     }
-    if (mResultThrowable != null) {
-      throw new ExecutionException(mResultThrowable);
-    } else {
-      return mResult;
+
+    @Override
+    public V get() throws InterruptedException, ExecutionException {
+        if (!mIsDone) {
+            throw new IllegalStateException("Not yet done. We don't support blocking in tests");
+        }
+        if (mResultThrowable != null) {
+            throw new ExecutionException(mResultThrowable);
+        } else {
+            return mResult;
+        }
     }
-  }
 
-  @Override
-  public V get(long l, TimeUnit timeUnit)
-      throws InterruptedException, ExecutionException, TimeoutException {
-    return get();
-  }
+    @Override
+    public V get(long l, TimeUnit timeUnit)
+            throws InterruptedException, ExecutionException, TimeoutException {
+        return get();
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtilTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtilTest.java
index 539b65dca..af9033858 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtilTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/animated/util/AnimatedDrawableUtilTest.java
@@ -23,70 +23,70 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class AnimatedDrawableUtilTest {
 
-  @Test
-  public void testGetFrameTimeStampsFromDurations() {
-    int[] frameDurationsMs = new int[] { 30, 30, 60, 30, 30};
-    AnimatedDrawableUtil util = new AnimatedDrawableUtil();
-    int[] frameTimestampsMs = util.getFrameTimeStampsFromDurations(frameDurationsMs);
-    int[] expected = new int[] {0, 30, 60, 120, 150};
-    assertArrayEquals(expected, frameTimestampsMs);
-  }
+    @Test
+    public void testGetFrameTimeStampsFromDurations() {
+        int[] frameDurationsMs = new int[]{30, 30, 60, 30, 30};
+        AnimatedDrawableUtil util = new AnimatedDrawableUtil();
+        int[] frameTimestampsMs = util.getFrameTimeStampsFromDurations(frameDurationsMs);
+        int[] expected = new int[]{0, 30, 60, 120, 150};
+        assertArrayEquals(expected, frameTimestampsMs);
+    }
 
-  @Test
-  public void testGetFrameTimeStampsFromDurationsWithEmptyArray() {
-    int[] frameDurationsMs = new int[0];
-    AnimatedDrawableUtil util = new AnimatedDrawableUtil();
-    int[] frameTimestampsMs = util.getFrameTimeStampsFromDurations(frameDurationsMs);
-    assertEquals(0, frameTimestampsMs.length);
-  }
+    @Test
+    public void testGetFrameTimeStampsFromDurationsWithEmptyArray() {
+        int[] frameDurationsMs = new int[0];
+        AnimatedDrawableUtil util = new AnimatedDrawableUtil();
+        int[] frameTimestampsMs = util.getFrameTimeStampsFromDurations(frameDurationsMs);
+        assertEquals(0, frameTimestampsMs.length);
+    }
 
-  @Test
-  public void testGetFrameForTimestampMs() {
-    int[] frameTimestampsMs = new int[] { 0, 50, 75, 100, 200};
-    AnimatedDrawableUtil util = new AnimatedDrawableUtil();
-    assertEquals(0, util.getFrameForTimestampMs(frameTimestampsMs, 0));
-    assertEquals(0, util.getFrameForTimestampMs(frameTimestampsMs, 1));
-    assertEquals(0, util.getFrameForTimestampMs(frameTimestampsMs, 49));
-    assertEquals(1, util.getFrameForTimestampMs(frameTimestampsMs, 50));
-    assertEquals(1, util.getFrameForTimestampMs(frameTimestampsMs, 74));
-    assertEquals(2, util.getFrameForTimestampMs(frameTimestampsMs, 75));
-    assertEquals(2, util.getFrameForTimestampMs(frameTimestampsMs, 76));
-    assertEquals(2, util.getFrameForTimestampMs(frameTimestampsMs, 99));
-    assertEquals(3, util.getFrameForTimestampMs(frameTimestampsMs, 100));
-    assertEquals(3, util.getFrameForTimestampMs(frameTimestampsMs, 101));
-    assertEquals(4, util.getFrameForTimestampMs(frameTimestampsMs, 200));
-  }
+    @Test
+    public void testGetFrameForTimestampMs() {
+        int[] frameTimestampsMs = new int[]{0, 50, 75, 100, 200};
+        AnimatedDrawableUtil util = new AnimatedDrawableUtil();
+        assertEquals(0, util.getFrameForTimestampMs(frameTimestampsMs, 0));
+        assertEquals(0, util.getFrameForTimestampMs(frameTimestampsMs, 1));
+        assertEquals(0, util.getFrameForTimestampMs(frameTimestampsMs, 49));
+        assertEquals(1, util.getFrameForTimestampMs(frameTimestampsMs, 50));
+        assertEquals(1, util.getFrameForTimestampMs(frameTimestampsMs, 74));
+        assertEquals(2, util.getFrameForTimestampMs(frameTimestampsMs, 75));
+        assertEquals(2, util.getFrameForTimestampMs(frameTimestampsMs, 76));
+        assertEquals(2, util.getFrameForTimestampMs(frameTimestampsMs, 99));
+        assertEquals(3, util.getFrameForTimestampMs(frameTimestampsMs, 100));
+        assertEquals(3, util.getFrameForTimestampMs(frameTimestampsMs, 101));
+        assertEquals(4, util.getFrameForTimestampMs(frameTimestampsMs, 200));
+    }
 
-  @Test
-  public void testIsOutsideRange() {
-    assertTrue(AnimatedDrawableUtil.isOutsideRange(-1, -1, 1)); // Always outside range
+    @Test
+    public void testIsOutsideRange() {
+        assertTrue(AnimatedDrawableUtil.isOutsideRange(-1, -1, 1)); // Always outside range
 
-    // Test before, within, and after 2 through 5.
-    int start = 2;
-    int end = 5;
-    assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 1));
-    assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 2));
-    assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 3));
-    assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 4));
-    assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 5));
-    assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 6));
+        // Test before, within, and after 2 through 5.
+        int start = 2;
+        int end = 5;
+        assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 1));
+        assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 2));
+        assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 3));
+        assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 4));
+        assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 5));
+        assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 6));
 
-    // Test wrapping case when start is greater than end
-    // Test before, within, and after 4 through 1
-    start = 4;
-    end = 1;
-    assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 0));
-    assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 1));
-    assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 2));
-    assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 3));
-    assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 4));
-    assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 5));
+        // Test wrapping case when start is greater than end
+        // Test before, within, and after 4 through 1
+        start = 4;
+        end = 1;
+        assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 0));
+        assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 1));
+        assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 2));
+        assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 3));
+        assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 4));
+        assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 5));
 
-    // Test cases where start == end
-    start = 2;
-    end = 2;
-    assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 1));
-    assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 2));
-    assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 3));
-  }
+        // Test cases where start == end
+        start = 2;
+        end = 2;
+        assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 1));
+        assertFalse(AnimatedDrawableUtil.isOutsideRange(start, end, 2));
+        assertTrue(AnimatedDrawableUtil.isOutsideRange(start, end, 3));
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/bitmaps/ArtBitmapFactoryTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/bitmaps/ArtBitmapFactoryTest.java
index 16ab90498..83c1352cd 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/bitmaps/ArtBitmapFactoryTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/bitmaps/ArtBitmapFactoryTest.java
@@ -57,209 +57,209 @@
 @TargetApi(Build.VERSION_CODES.LOLLIPOP)
 public class ArtBitmapFactoryTest {
 
-  static {
-    SoLoaderShim.setInTestMode();
-  }
-
-  private static final int RANDOM_SEED = 10101;
-  private static final int ENCODED_BYTES_LENGTH = 128;
-
-  private BitmapPool mBitmapPool;
-  private PooledByteBuffer mPooledByteBuffer;
-
-  private ArtBitmapFactory mArtBitmapFactory;
-
-  public Bitmap mBitmap;
-  public Answer<Bitmap> mBitmapFactoryDefaultAnswer;
-  private CloseableReference<PooledByteBuffer> mEncodedImageRef;
-  private byte[] mEncodedBytes;
-
-
-  @Before
-  public void setUp() throws Exception {
-    final Random random = new Random();
-    random.setSeed(RANDOM_SEED);
-    mEncodedBytes = new byte[ENCODED_BYTES_LENGTH];
-    random.nextBytes(mEncodedBytes);
-
-    mPooledByteBuffer = new TrivialPooledByteBuffer(mEncodedBytes);
-    mBitmapPool = mock(BitmapPool.class);
-    mArtBitmapFactory = new ArtBitmapFactory(mBitmapPool);
-
-    mEncodedImageRef = CloseableReference.of(mPooledByteBuffer);
-    mBitmap = MockBitmapFactory.create();
-    doReturn(mBitmap).when(mBitmapPool).get(MockBitmapFactory.DEFAULT_BITMAP_PIXELS);
-
-    mBitmapFactoryDefaultAnswer = new Answer<Bitmap>() {
-      @Override
-      public Bitmap answer(InvocationOnMock invocation) throws Throwable {
-        final BitmapFactory.Options options = (BitmapFactory.Options) invocation.getArguments()[2];
-        options.outWidth = MockBitmapFactory.DEFAULT_BITMAP_WIDTH;
-        options.outHeight = MockBitmapFactory.DEFAULT_BITMAP_HEIGHT;
-        verifyBitmapFactoryOptions(options);
-        return options.inJustDecodeBounds ? null : mBitmap;
-      }
-    };
-
-    whenBitmapFactoryDecodeStream().thenAnswer(mBitmapFactoryDefaultAnswer);
-  }
-
-  @Test
-  public void testDecodeStaticDecodesFromStream() {
-    mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
-    verifyDecodedFromStream();
-  }
-
-  @Test
-  public void testDecodeStaticDoesNotLeak() {
-    mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
-    verifyNoLeaks();
-  }
-
-  @Test
-  public void testStaticImageUsesPooledByteBufferWithPixels() {
-    CloseableReference<Bitmap> decodedImage =
+    static {
+        SoLoaderShim.setInTestMode();
+    }
+
+    private static final int RANDOM_SEED = 10101;
+    private static final int ENCODED_BYTES_LENGTH = 128;
+
+    private BitmapPool mBitmapPool;
+    private PooledByteBuffer mPooledByteBuffer;
+
+    private ArtBitmapFactory mArtBitmapFactory;
+
+    public Bitmap mBitmap;
+    public Answer<Bitmap> mBitmapFactoryDefaultAnswer;
+    private CloseableReference<PooledByteBuffer> mEncodedImageRef;
+    private byte[] mEncodedBytes;
+
+
+    @Before
+    public void setUp() throws Exception {
+        final Random random = new Random();
+        random.setSeed(RANDOM_SEED);
+        mEncodedBytes = new byte[ENCODED_BYTES_LENGTH];
+        random.nextBytes(mEncodedBytes);
+
+        mPooledByteBuffer = new TrivialPooledByteBuffer(mEncodedBytes);
+        mBitmapPool = mock(BitmapPool.class);
+        mArtBitmapFactory = new ArtBitmapFactory(mBitmapPool);
+
+        mEncodedImageRef = CloseableReference.of(mPooledByteBuffer);
+        mBitmap = MockBitmapFactory.create();
+        doReturn(mBitmap).when(mBitmapPool).get(MockBitmapFactory.DEFAULT_BITMAP_PIXELS);
+
+        mBitmapFactoryDefaultAnswer = new Answer<Bitmap>() {
+            @Override
+            public Bitmap answer(InvocationOnMock invocation) throws Throwable {
+                final BitmapFactory.Options options = (BitmapFactory.Options) invocation.getArguments()[2];
+                options.outWidth = MockBitmapFactory.DEFAULT_BITMAP_WIDTH;
+                options.outHeight = MockBitmapFactory.DEFAULT_BITMAP_HEIGHT;
+                verifyBitmapFactoryOptions(options);
+                return options.inJustDecodeBounds ? null : mBitmap;
+            }
+        };
+
+        whenBitmapFactoryDecodeStream().thenAnswer(mBitmapFactoryDefaultAnswer);
+    }
+
+    @Test
+    public void testDecodeStaticDecodesFromStream() {
+        mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
+        verifyDecodedFromStream();
+    }
+
+    @Test
+    public void testDecodeStaticDoesNotLeak() {
         mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
-    closeAndVerifyClosed(decodedImage);
-  }
-
-  @Test(expected = NullPointerException.class)
-  public void testPoolsReturnsNull() {
-    doReturn(null).when(mBitmapPool).get(anyInt());
-    mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void testBitmapFactoryReturnsNewBitmap() {
-    whenBitmapFactoryDecodeStream()
-        .thenAnswer(mBitmapFactoryDefaultAnswer)
-        .thenReturn(MockBitmapFactory.create());
-    try {
-      mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
-    } finally {
-      verify(mBitmapPool).release(mBitmap);
+        verifyNoLeaks();
+    }
+
+    @Test
+    public void testStaticImageUsesPooledByteBufferWithPixels() {
+        CloseableReference<Bitmap> decodedImage =
+                mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
+        closeAndVerifyClosed(decodedImage);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testPoolsReturnsNull() {
+        doReturn(null).when(mBitmapPool).get(anyInt());
+        mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testBitmapFactoryReturnsNewBitmap() {
+        whenBitmapFactoryDecodeStream()
+                .thenAnswer(mBitmapFactoryDefaultAnswer)
+                .thenReturn(MockBitmapFactory.create());
+        try {
+            mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
+        } finally {
+            verify(mBitmapPool).release(mBitmap);
+        }
+    }
+
+    @Test(expected = ConcurrentModificationException.class)
+    public void testBitmapFactoryThrowsAnException() {
+        whenBitmapFactoryDecodeStream()
+                .thenAnswer(mBitmapFactoryDefaultAnswer)
+                .thenThrow(new ConcurrentModificationException());
+        try {
+            mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
+        } finally {
+            verify(mBitmapPool).release(mBitmap);
+        }
+    }
+
+    @Test
+    public void testDecodeJpeg_allBytes_complete() {
+        jpegTestCase(true, ENCODED_BYTES_LENGTH);
+    }
+
+    @Test
+    public void testDecodeJpeg_notAllBytes_complete() {
+        jpegTestCase(true, ENCODED_BYTES_LENGTH / 2);
+    }
+
+    @Test
+    public void testDecodeJpeg_allBytes_incomplete() {
+        jpegTestCase(false, ENCODED_BYTES_LENGTH);
+    }
+
+    @Test
+    public void testDecodeJpeg_notAllBytes_incomplete() {
+        jpegTestCase(false, ENCODED_BYTES_LENGTH / 2);
     }
-  }
-
-  @Test(expected = ConcurrentModificationException.class)
-  public void testBitmapFactoryThrowsAnException() {
-    whenBitmapFactoryDecodeStream()
-        .thenAnswer(mBitmapFactoryDefaultAnswer)
-        .thenThrow(new ConcurrentModificationException());
-    try {
-      mArtBitmapFactory.decodeFromPooledByteBuffer(mEncodedImageRef);
-    } finally {
-      verify(mBitmapPool).release(mBitmap);
+
+    private void jpegTestCase(boolean complete, int dataLength) {
+        if (complete) {
+            mEncodedBytes[dataLength - 2] = (byte) JfifUtil.MARKER_FIRST_BYTE;
+            mEncodedBytes[dataLength - 1] = (byte) JfifUtil.MARKER_EOI;
+        }
+        CloseableReference<Bitmap> result =
+                mArtBitmapFactory.decodeJPEGFromPooledByteBuffer(mEncodedImageRef, dataLength);
+        verifyDecodedFromStream();
+        verifyNoLeaks();
+        verifyDecodedBytes(complete, dataLength);
+        closeAndVerifyClosed(result);
+    }
+
+    private byte[] getDecodedBytes() {
+        ArgumentCaptor<InputStream> inputStreamArgumentCaptor =
+                ArgumentCaptor.forClass(InputStream.class);
+        verifyStatic(times(2));
+        BitmapFactory.decodeStream(
+                inputStreamArgumentCaptor.capture(),
+                isNull(Rect.class),
+                any(BitmapFactory.Options.class));
+        InputStream decodedStream = inputStreamArgumentCaptor.getValue();
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try {
+            ByteStreams.copy(decodedStream, baos);
+        } catch (IOException ioe) {
+            throw Throwables.propagate(ioe);
+        }
+        return baos.toByteArray();
     }
-  }
-
-  @Test
-  public void testDecodeJpeg_allBytes_complete() {
-    jpegTestCase(true, ENCODED_BYTES_LENGTH);
-  }
-
-  @Test
-  public void testDecodeJpeg_notAllBytes_complete() {
-    jpegTestCase(true, ENCODED_BYTES_LENGTH / 2);
-  }
-
-  @Test
-  public void testDecodeJpeg_allBytes_incomplete() {
-    jpegTestCase(false, ENCODED_BYTES_LENGTH);
-  }
-
-  @Test
-  public void testDecodeJpeg_notAllBytes_incomplete() {
-    jpegTestCase(false, ENCODED_BYTES_LENGTH / 2);
-  }
-
-  private void jpegTestCase(boolean complete, int dataLength) {
-    if (complete) {
-      mEncodedBytes[dataLength - 2] = (byte) JfifUtil.MARKER_FIRST_BYTE;
-      mEncodedBytes[dataLength - 1] = (byte) JfifUtil.MARKER_EOI;
+
+    private void verifyBitmapFactoryOptions(BitmapFactory.Options options) {
+        assertNotNull(options.inTempStorage);
+        if (!options.inJustDecodeBounds) {
+            assertTrue(options.inDither);
+            assertTrue(options.inMutable);
+            assertSame(Bitmaps.BITMAP_CONFIG, options.inPreferredConfig);
+            assertNotNull(options.inBitmap);
+            final int inBitmapWidth = options.inBitmap.getWidth();
+            final int inBitmapHeight = options.inBitmap.getHeight();
+            assertTrue(inBitmapWidth * inBitmapHeight >= MockBitmapFactory.DEFAULT_BITMAP_PIXELS);
+        }
     }
-    CloseableReference<Bitmap> result =
-        mArtBitmapFactory.decodeJPEGFromPooledByteBuffer(mEncodedImageRef, dataLength);
-    verifyDecodedFromStream();
-    verifyNoLeaks();
-    verifyDecodedBytes(complete, dataLength);
-    closeAndVerifyClosed(result);
-  }
-
-  private byte[] getDecodedBytes() {
-    ArgumentCaptor<InputStream> inputStreamArgumentCaptor =
-        ArgumentCaptor.forClass(InputStream.class);
-    verifyStatic(times(2));
-    BitmapFactory.decodeStream(
-        inputStreamArgumentCaptor.capture(),
-        isNull(Rect.class),
-        any(BitmapFactory.Options.class));
-    InputStream decodedStream = inputStreamArgumentCaptor.getValue();
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    try {
-      ByteStreams.copy(decodedStream, baos);
-    } catch (IOException ioe) {
-      throw Throwables.propagate(ioe);
+
+    private OngoingStubbing<Bitmap> whenBitmapFactoryDecodeStream() {
+        mockStatic(BitmapFactory.class);
+        return when(BitmapFactory.decodeStream(
+                any(InputStream.class),
+                isNull(Rect.class),
+                any(BitmapFactory.Options.class)));
     }
-    return baos.toByteArray();
-  }
-
-  private void verifyBitmapFactoryOptions(BitmapFactory.Options options) {
-    assertNotNull(options.inTempStorage);
-    if (!options.inJustDecodeBounds) {
-      assertTrue(options.inDither);
-      assertTrue(options.inMutable);
-      assertSame(Bitmaps.BITMAP_CONFIG, options.inPreferredConfig);
-      assertNotNull(options.inBitmap);
-      final int inBitmapWidth = options.inBitmap.getWidth();
-      final int inBitmapHeight = options.inBitmap.getHeight();
-      assertTrue(inBitmapWidth * inBitmapHeight >= MockBitmapFactory.DEFAULT_BITMAP_PIXELS);
+
+    private void closeAndVerifyClosed(CloseableReference<Bitmap> closeableImage) {
+        verify(mBitmapPool, never()).release(mBitmap);
+        closeableImage.close();
+        verify(mBitmapPool).release(mBitmap);
     }
-  }
-
-  private OngoingStubbing<Bitmap> whenBitmapFactoryDecodeStream() {
-    mockStatic(BitmapFactory.class);
-    return when(BitmapFactory.decodeStream(
-            any(InputStream.class),
-            isNull(Rect.class),
-            any(BitmapFactory.Options.class)));
-  }
-
-  private void closeAndVerifyClosed(CloseableReference<Bitmap> closeableImage) {
-    verify(mBitmapPool, never()).release(mBitmap);
-    closeableImage.close();
-    verify(mBitmapPool).release(mBitmap);
-  }
-
-  private void verifyNoLeaks() {
-    assertEquals(1, mEncodedImageRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-  }
-
-  private void verifyDecodedFromStream() {
-    verifyStatic(times(2));
-    BitmapFactory.decodeStream(
-        any(ByteArrayInputStream.class),
-        isNull(Rect.class),
-        any(BitmapFactory.Options.class));
-  }
-
-  private void verifyDecodedBytes(boolean complete, int length) {
-    byte[] decodedBytes = getDecodedBytes();
-    assertArrayEquals(
-        Arrays.copyOfRange(
-            mEncodedBytes,
-            0,
-            length),
-        Arrays.copyOfRange(
-            decodedBytes,
-            0,
-            length));
-    if (complete) {
-      assertEquals(length, decodedBytes.length);
-    } else {
-      assertEquals(length + 2, decodedBytes.length);
-      assertEquals((byte) JfifUtil.MARKER_FIRST_BYTE, decodedBytes[length]);
-      assertEquals((byte) JfifUtil.MARKER_EOI, decodedBytes[length + 1]);
+
+    private void verifyNoLeaks() {
+        assertEquals(1, mEncodedImageRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+    }
+
+    private void verifyDecodedFromStream() {
+        verifyStatic(times(2));
+        BitmapFactory.decodeStream(
+                any(ByteArrayInputStream.class),
+                isNull(Rect.class),
+                any(BitmapFactory.Options.class));
+    }
+
+    private void verifyDecodedBytes(boolean complete, int length) {
+        byte[] decodedBytes = getDecodedBytes();
+        assertArrayEquals(
+                Arrays.copyOfRange(
+                        mEncodedBytes,
+                        0,
+                        length),
+                Arrays.copyOfRange(
+                        decodedBytes,
+                        0,
+                        length));
+        if (complete) {
+            assertEquals(length, decodedBytes.length);
+        } else {
+            assertEquals(length + 2, decodedBytes.length);
+            assertEquals((byte) JfifUtil.MARKER_FIRST_BYTE, decodedBytes[length]);
+            assertEquals((byte) JfifUtil.MARKER_EOI, decodedBytes[length + 1]);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/bitmaps/DalvikBitmapFactoryTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/bitmaps/DalvikBitmapFactoryTest.java
index ea4b5b2e6..26b2727e1 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/bitmaps/DalvikBitmapFactoryTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/bitmaps/DalvikBitmapFactoryTest.java
@@ -47,163 +47,163 @@
 @TargetApi(Build.VERSION_CODES.HONEYCOMB)
 @RunWith(WithTestDefaultsRunner.class)
 @PrepareOnlyThisForTest({
-    BitmapCounterProvider.class,
-    BitmapFactory.class,
-    Bitmaps.class})
+        BitmapCounterProvider.class,
+        BitmapFactory.class,
+        Bitmaps.class})
 public class DalvikBitmapFactoryTest {
 
-  static {
-    SoLoaderShim.setInTestMode();
-  }
-
-  private static final int IMAGE_SIZE = 5;
-  private static final int LENGTH = 10;
-  private static final long POINTER = 1000L;
-  private static final int MAX_BITMAP_COUNT = 2;
-  private static final int MAX_BITMAP_SIZE =
-      MAX_BITMAP_COUNT * MockBitmapFactory.DEFAULT_BITMAP_SIZE;
-
-  private SharedByteArray mSharedByteArray;
-
-  private DalvikBitmapFactory mDalvikBitmapFactory;
-  private CloseableReference<PooledByteBuffer> mInputImageRef;
-  private byte[] mInputBuf;
-  private byte[] mDecodeBuf;
-  private CloseableReference<byte[]> mDecodeBufRef;
-  private Bitmap mBitmap;
-  private BitmapCounter mBitmapCounter;
-
-  @Before
-  public void setUp() {
-    mSharedByteArray = mock(SharedByteArray.class);
-
-    mBitmap = MockBitmapFactory.create();
-    mBitmapCounter = new BitmapCounter(MAX_BITMAP_COUNT, MAX_BITMAP_SIZE);
-
-    mockStatic(BitmapCounterProvider.class);
-    when(BitmapCounterProvider.get()).thenReturn(mBitmapCounter);
-
-    mockStatic(BitmapFactory.class);
-    when(BitmapFactory.decodeByteArray(
-            any(byte[].class),
-            anyInt(),
-            anyInt(),
-            any(BitmapFactory.Options.class)))
-        .thenReturn(mBitmap);
-
-    mInputBuf = new byte[LENGTH];
-    PooledByteBuffer input = new TrivialPooledByteBuffer(mInputBuf, POINTER);
-    mInputImageRef = CloseableReference.of(input);
-
-    mDecodeBuf = new byte[LENGTH + 2];
-    mDecodeBufRef = CloseableReference.of(mDecodeBuf, mock(ResourceReleaser.class));
-    when(mSharedByteArray.get(Integer.valueOf(LENGTH))).thenReturn(mDecodeBufRef);
-
-    mockStatic(Bitmaps.class);
-    mDalvikBitmapFactory = new DalvikBitmapFactory(
-        null,
-        mSharedByteArray);
-  }
-
-  @Test
-  public void testDecode_Jpeg_Detailed() {
-    setUpJpegDecode();
-    CloseableReference<Bitmap> result = mDalvikBitmapFactory.decodeJPEGFromPooledByteBuffer(
-        mInputImageRef,
-        IMAGE_SIZE);
-    verifyDecodesJpeg(result);
-  }
-
-  @Test
-  public void testDecodeJpeg_incomplete() {
-    when(mSharedByteArray.get(IMAGE_SIZE + 2)).thenReturn(mDecodeBufRef);
-    CloseableReference<Bitmap> result =
-        mDalvikBitmapFactory.decodeJPEGFromPooledByteBuffer(mInputImageRef, IMAGE_SIZE);
-    verify(mSharedByteArray).get(IMAGE_SIZE + 2);
-    verifyStatic();
-    BitmapFactory.decodeByteArray(
-        same(mDecodeBuf),
-        eq(0),
-        eq(IMAGE_SIZE + 2),
-        argThat(new BitmapFactoryOptionsMatcher()));
-    assertEquals((byte) 0xff, mDecodeBuf[5]);
-    assertEquals((byte) 0xd9, mDecodeBuf[6]);
-    assertEquals(1, mInputImageRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-    assertEquals(mBitmap, result.get());
-    assertTrue(result.isValid());
-    assertEquals(1, mBitmapCounter.getCount());
-    assertEquals(MockBitmapFactory.DEFAULT_BITMAP_SIZE, mBitmapCounter.getSize());
-  }
-
-
-  @Test(expected = TooManyBitmapsException.class)
-  public void testHitBitmapLimit_static() {
-    mBitmapCounter.increase(MockBitmapFactory.createForSize(MAX_BITMAP_SIZE));
-    try {
-      mDalvikBitmapFactory.decodeFromPooledByteBuffer(mInputImageRef);
-    } finally {
-      verify(mBitmap).recycle();
-      assertEquals(1, mBitmapCounter.getCount());
-      assertEquals(MAX_BITMAP_SIZE, mBitmapCounter.getSize());
+    static {
+        SoLoaderShim.setInTestMode();
     }
-  }
-
-  @Test(expected = ConcurrentModificationException.class)
-  public void testPinBitmapFailure_static() {
-    PowerMockito.doThrow(new ConcurrentModificationException()).when(Bitmaps.class);
-    Bitmaps.pinBitmap(any(Bitmap.class));
-    try {
-      mDalvikBitmapFactory.decodeFromPooledByteBuffer(mInputImageRef);
-    } finally {
-      verify(mBitmap).recycle();
-      assertEquals(0, mBitmapCounter.getCount());
-      assertEquals(0, mBitmapCounter.getSize());
+
+    private static final int IMAGE_SIZE = 5;
+    private static final int LENGTH = 10;
+    private static final long POINTER = 1000L;
+    private static final int MAX_BITMAP_COUNT = 2;
+    private static final int MAX_BITMAP_SIZE =
+            MAX_BITMAP_COUNT * MockBitmapFactory.DEFAULT_BITMAP_SIZE;
+
+    private SharedByteArray mSharedByteArray;
+
+    private DalvikBitmapFactory mDalvikBitmapFactory;
+    private CloseableReference<PooledByteBuffer> mInputImageRef;
+    private byte[] mInputBuf;
+    private byte[] mDecodeBuf;
+    private CloseableReference<byte[]> mDecodeBufRef;
+    private Bitmap mBitmap;
+    private BitmapCounter mBitmapCounter;
+
+    @Before
+    public void setUp() {
+        mSharedByteArray = mock(SharedByteArray.class);
+
+        mBitmap = MockBitmapFactory.create();
+        mBitmapCounter = new BitmapCounter(MAX_BITMAP_COUNT, MAX_BITMAP_SIZE);
+
+        mockStatic(BitmapCounterProvider.class);
+        when(BitmapCounterProvider.get()).thenReturn(mBitmapCounter);
+
+        mockStatic(BitmapFactory.class);
+        when(BitmapFactory.decodeByteArray(
+                any(byte[].class),
+                anyInt(),
+                anyInt(),
+                any(BitmapFactory.Options.class)))
+                .thenReturn(mBitmap);
+
+        mInputBuf = new byte[LENGTH];
+        PooledByteBuffer input = new TrivialPooledByteBuffer(mInputBuf, POINTER);
+        mInputImageRef = CloseableReference.of(input);
+
+        mDecodeBuf = new byte[LENGTH + 2];
+        mDecodeBufRef = CloseableReference.of(mDecodeBuf, mock(ResourceReleaser.class));
+        when(mSharedByteArray.get(Integer.valueOf(LENGTH))).thenReturn(mDecodeBufRef);
+
+        mockStatic(Bitmaps.class);
+        mDalvikBitmapFactory = new DalvikBitmapFactory(
+                null,
+                mSharedByteArray);
+    }
+
+    @Test
+    public void testDecode_Jpeg_Detailed() {
+        setUpJpegDecode();
+        CloseableReference<Bitmap> result = mDalvikBitmapFactory.decodeJPEGFromPooledByteBuffer(
+                mInputImageRef,
+                IMAGE_SIZE);
+        verifyDecodesJpeg(result);
+    }
+
+    @Test
+    public void testDecodeJpeg_incomplete() {
+        when(mSharedByteArray.get(IMAGE_SIZE + 2)).thenReturn(mDecodeBufRef);
+        CloseableReference<Bitmap> result =
+                mDalvikBitmapFactory.decodeJPEGFromPooledByteBuffer(mInputImageRef, IMAGE_SIZE);
+        verify(mSharedByteArray).get(IMAGE_SIZE + 2);
+        verifyStatic();
+        BitmapFactory.decodeByteArray(
+                same(mDecodeBuf),
+                eq(0),
+                eq(IMAGE_SIZE + 2),
+                argThat(new BitmapFactoryOptionsMatcher()));
+        assertEquals((byte) 0xff, mDecodeBuf[5]);
+        assertEquals((byte) 0xd9, mDecodeBuf[6]);
+        assertEquals(1, mInputImageRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+        assertEquals(mBitmap, result.get());
+        assertTrue(result.isValid());
+        assertEquals(1, mBitmapCounter.getCount());
+        assertEquals(MockBitmapFactory.DEFAULT_BITMAP_SIZE, mBitmapCounter.getSize());
     }
-  }
-
-  private void verifyDecodesStatic(CloseableReference<Bitmap> result) {
-    assertEquals(1, mInputImageRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-    assertEquals(mBitmap, result.get());
-    assertTrue(result.isValid());
-    assertEquals(1, mBitmapCounter.getCount());
-    assertEquals(MockBitmapFactory.DEFAULT_BITMAP_SIZE, mBitmapCounter.getSize());
-    verifyStatic();
-    Bitmaps.pinBitmap(mBitmap);
-    assertFalse(CloseableReference.isValid(mDecodeBufRef));
-  }
-
-  private void setUpJpegDecode() {
-    mInputBuf[3] = (byte) 0xff;
-    mInputBuf[4] = (byte) 0xd9;
-    when(mSharedByteArray.get(IMAGE_SIZE + 2)).thenReturn(mDecodeBufRef);
-  }
-
-  private void verifyDecodesJpeg(CloseableReference<Bitmap> result) {
-    verify(mSharedByteArray).get(IMAGE_SIZE + 2);
-    verifyStatic();
-    BitmapFactory.decodeByteArray(
-        same(mDecodeBuf),
-        eq(0),
-        eq(IMAGE_SIZE),
-        argThat(new BitmapFactoryOptionsMatcher()));
-    assertEquals(1, mInputImageRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-    assertEquals(mBitmap, result.get());
-    assertTrue(result.isValid());
-    assertEquals(1, mBitmapCounter.getCount());
-    assertEquals(MockBitmapFactory.DEFAULT_BITMAP_SIZE, mBitmapCounter.getSize());
-  }
-
-  private static class BitmapFactoryOptionsMatcher
-      extends ArgumentMatcher<BitmapFactory.Options> {
-    @Override
-    public boolean matches(Object argument) {
-      if (argument == null) {
-        return false;
-      }
-      BitmapFactory.Options options = (BitmapFactory.Options) argument;
-      return options.inDither &&
-          options.inPreferredConfig == Bitmaps.BITMAP_CONFIG &&
-          options.inPurgeable;
+
+
+    @Test(expected = TooManyBitmapsException.class)
+    public void testHitBitmapLimit_static() {
+        mBitmapCounter.increase(MockBitmapFactory.createForSize(MAX_BITMAP_SIZE));
+        try {
+            mDalvikBitmapFactory.decodeFromPooledByteBuffer(mInputImageRef);
+        } finally {
+            verify(mBitmap).recycle();
+            assertEquals(1, mBitmapCounter.getCount());
+            assertEquals(MAX_BITMAP_SIZE, mBitmapCounter.getSize());
+        }
+    }
+
+    @Test(expected = ConcurrentModificationException.class)
+    public void testPinBitmapFailure_static() {
+        PowerMockito.doThrow(new ConcurrentModificationException()).when(Bitmaps.class);
+        Bitmaps.pinBitmap(any(Bitmap.class));
+        try {
+            mDalvikBitmapFactory.decodeFromPooledByteBuffer(mInputImageRef);
+        } finally {
+            verify(mBitmap).recycle();
+            assertEquals(0, mBitmapCounter.getCount());
+            assertEquals(0, mBitmapCounter.getSize());
+        }
+    }
+
+    private void verifyDecodesStatic(CloseableReference<Bitmap> result) {
+        assertEquals(1, mInputImageRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+        assertEquals(mBitmap, result.get());
+        assertTrue(result.isValid());
+        assertEquals(1, mBitmapCounter.getCount());
+        assertEquals(MockBitmapFactory.DEFAULT_BITMAP_SIZE, mBitmapCounter.getSize());
+        verifyStatic();
+        Bitmaps.pinBitmap(mBitmap);
+        assertFalse(CloseableReference.isValid(mDecodeBufRef));
+    }
+
+    private void setUpJpegDecode() {
+        mInputBuf[3] = (byte) 0xff;
+        mInputBuf[4] = (byte) 0xd9;
+        when(mSharedByteArray.get(IMAGE_SIZE + 2)).thenReturn(mDecodeBufRef);
+    }
+
+    private void verifyDecodesJpeg(CloseableReference<Bitmap> result) {
+        verify(mSharedByteArray).get(IMAGE_SIZE + 2);
+        verifyStatic();
+        BitmapFactory.decodeByteArray(
+                same(mDecodeBuf),
+                eq(0),
+                eq(IMAGE_SIZE),
+                argThat(new BitmapFactoryOptionsMatcher()));
+        assertEquals(1, mInputImageRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+        assertEquals(mBitmap, result.get());
+        assertTrue(result.isValid());
+        assertEquals(1, mBitmapCounter.getCount());
+        assertEquals(MockBitmapFactory.DEFAULT_BITMAP_SIZE, mBitmapCounter.getSize());
+    }
+
+    private static class BitmapFactoryOptionsMatcher
+            extends ArgumentMatcher<BitmapFactory.Options> {
+        @Override
+        public boolean matches(Object argument) {
+            if (argument == null) {
+                return false;
+            }
+            BitmapFactory.Options options = (BitmapFactory.Options) argument;
+            return options.inDither &&
+                    options.inPreferredConfig == Bitmaps.BITMAP_CONFIG &&
+                    options.inPurgeable;
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/BasePoolTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/BasePoolTest.java
index 84899a762..2f449e52e 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/BasePoolTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/BasePoolTest.java
@@ -17,6 +17,7 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
+
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
@@ -29,549 +30,550 @@
  */
 @RunWith(WithTestDefaultsRunner.class)
 public class BasePoolTest {
-  private TestPool mPool;
-  private PoolStats<byte[]> mStats;
-
-  @Before
-  public void setup() {
-    mPool = new TestPool(10, 14);
-    mStats = new PoolStats<byte[]>(mPool);
-  }
-
-  // Test out the alloc method
-  @Test
-  public void testAlloc() throws Exception {
-    Assert.assertEquals(1, mPool.alloc(1).length);
-    Assert.assertEquals(3, mPool.alloc(3).length);
-    Assert.assertEquals(2, mPool.alloc(2).length);
-  }
-
-  @Test
-  public void testFree() throws Exception {
-  }
-
-  // tests out the getBucketedSize method
-  @Test
-  public void testGetBucketedSize() throws Exception {
-    Assert.assertEquals(2, mPool.getBucketedSize(1));
-    Assert.assertEquals(2, mPool.getBucketedSize(2));
-    Assert.assertEquals(4, mPool.getBucketedSize(3));
-    Assert.assertEquals(6, mPool.getBucketedSize(6));
-    Assert.assertEquals(8, mPool.getBucketedSize(7));
-  }
-
-  // tests out the getBucketedSize method for invalid inputs
-  @Test
-  public void testGetBucketedSize_Invalid() throws Exception {
-    int[] sizes = new int[] {-1, 0};
-    for (int s: sizes) {
-      try {
-        mPool.getBucketedSize(s);
-        Assert.fail("Failed size: " + s);
-      } catch (BasePool.InvalidSizeException e) {
-        // do nothing
-      }
+    private TestPool mPool;
+    private PoolStats<byte[]> mStats;
+
+    @Before
+    public void setup() {
+        mPool = new TestPool(10, 14);
+        mStats = new PoolStats<byte[]>(mPool);
     }
-  }
-
-  // tests out the getBucketedSizeForValue method
-  @Test
-  public void testGetBucketedSizeForValue() throws Exception {
-    Assert.assertEquals(2, mPool.getBucketedSizeForValue(new byte[2]));
-    Assert.assertEquals(3, mPool.getBucketedSizeForValue(new byte[3]));
-    Assert.assertEquals(6, mPool.getBucketedSizeForValue(new byte[6]));
-  }
-
-  @Test
-  public void testGetSizeInBytes() throws Exception {
-    Assert.assertEquals(1, mPool.getSizeInBytes(1));
-    Assert.assertEquals(2, mPool.getSizeInBytes(2));
-    Assert.assertEquals(3, mPool.getSizeInBytes(3));
-    Assert.assertEquals(5, mPool.getSizeInBytes(5));
-    Assert.assertEquals(4, mPool.getSizeInBytes(4));
-  }
-
-  // Get via alloc
-  @Test
-  public void testGet_Alloc() throws Exception {
-    // get a buffer - causes an alloc
-    byte[] b1 = mPool.get(1);
-    Assert.assertNotNull(b1);
-    Assert.assertEquals(2, b1.length);
-    Assert.assertTrue(mPool.mInUseValues.contains(b1));
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(2, new IntPair(1, 0)),
-        mStats.mBucketStats);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(2, mStats.mUsedBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-    Assert.assertEquals(1, mStats.mUsedCount);
-
-    // release this buffer
-    mPool.release(b1);
-    Assert.assertFalse(mPool.mInUseValues.contains(b1));
-
-    // get another buffer, but of a different size. No reuse possible
-    byte[] b2 = mPool.get(3);
-    Assert.assertNotNull(b2);
-    Assert.assertEquals(4, b2.length);
-    Assert.assertTrue(mPool.mInUseValues.contains(b2));
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            2, new IntPair(0, 1),
-            4, new IntPair(1, 0)),
-        mStats.mBucketStats);
-    Assert.assertEquals(2, mStats.mFreeBytes);
-    Assert.assertEquals(4, mStats.mUsedBytes);
-    Assert.assertEquals(1, mStats.mFreeCount);
-    Assert.assertEquals(1, mStats.mUsedCount);
-  }
-
-  // Get via alloc+trim
-  @Test
-  public void testGet_AllocAndTrim() throws Exception {
-    mPool = new TestPool(10, 10, makeBucketSizeArray(2, 2, 4, 2, 6, 2));
-    mStats.setPool(mPool);
-
-    // allocate and release multiple buffers
-    byte[] b1;
-    b1 = mPool.get(2);
-    mPool.release(b1);
-    b1 = mPool.get(6);
-    mPool.release(b1);
-
-    // get current stats
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            2, new IntPair(0, 1),
-            4, new IntPair(0, 0),
-            6, new IntPair(0, 1)),
-        mStats.mBucketStats);
-
-    // get a new buffer; this should cause an alloc and a trim
-    mPool.get(3);
-    mStats.refresh();
-    // validate stats
-    Assert.assertEquals(
-        ImmutableMap.of(
-            2, new IntPair(0, 0),
-            4, new IntPair(1, 0),
-            6, new IntPair(0, 1)),
-        mStats.mBucketStats);
-    Assert.assertEquals(6, mStats.mFreeBytes);
-    Assert.assertEquals(4, mStats.mUsedBytes);
-    Assert.assertEquals(1, mStats.mFreeCount);
-    Assert.assertEquals(1, mStats.mUsedCount);
-  }
-
-  // Tests that we can reuse a free buffer in the pool
-  @Test
-  public void testGet_Reuse() throws Exception {
-    // get a buffer, and immediately release it
-    byte[] b1 = mPool.get(1);
-    mPool.release(b1);
-    Assert.assertNotNull(b1);
-    Assert.assertEquals(2, b1.length);
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(2, new IntPair(0, 1)),
-        mStats.mBucketStats);
-    Assert.assertEquals(2, mStats.mFreeBytes);
-    Assert.assertEquals(0, mStats.mUsedBytes);
-    Assert.assertEquals(1, mStats.mFreeCount);
-    Assert.assertEquals(0, mStats.mUsedCount);
-
-    // get another buffer of the same size as above. We should be able to reuse it
-    byte[] b2 = mPool.get(1);
-    Assert.assertNotNull(b2);
-    Assert.assertEquals(2, b2.length);
-    Assert.assertTrue(mPool.mInUseValues.contains(b2));
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(2, new IntPair(1, 0)),
-        mStats.mBucketStats);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(2, mStats.mUsedBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-    Assert.assertEquals(1, mStats.mUsedCount);
-  }
-
-  // Get via alloc - exception on max size hard cap
-  @Test
-  public void testGet_AllocFailure() throws Exception {
-    TestPool pool = new TestPool(4, 5);
-    pool.get(4);
-    try {
-      pool.get(4);
-      Assert.fail();
-    } catch (PoolSizeViolationException e) {
-      // expected exception
+
+    // Test out the alloc method
+    @Test
+    public void testAlloc() throws Exception {
+        Assert.assertEquals(1, mPool.alloc(1).length);
+        Assert.assertEquals(3, mPool.alloc(3).length);
+        Assert.assertEquals(2, mPool.alloc(2).length);
     }
-  }
-
-  // test a simple release
-  @Test
-  public void testRelease() throws Exception {
-    // get a buffer - causes an alloc
-    byte[] b1 = mPool.get(1);
-    // release this buffer
-    mPool.release(b1);
-
-    // verify stats
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(2, new IntPair(0, 1)),
-        mStats.mBucketStats);
-    Assert.assertEquals(2, mStats.mFreeBytes);
-    Assert.assertEquals(0, mStats.mUsedBytes);
-    Assert.assertEquals(1, mStats.mFreeCount);
-    Assert.assertEquals(0, mStats.mUsedCount);
-  }
-
-  // test out release(), when it should free the value, instead of adding to the pool
-  @Test
-  public void testRelease_Free() throws Exception {
-    // get a set of buffers that bump up above the max size
-    mPool.get(6);
-    // get and release another buffer. this should cause a free
-    byte[] b3 = mPool.get(6);
-    mPool.release(b3);
-
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(6, new IntPair(1, 0)),
-        mStats.mBucketStats);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(6, mStats.mUsedBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-    Assert.assertEquals(1, mStats.mUsedCount);
-  }
-
-  // test release on  zero-sized pool
-  @Test
-  public void testRelease_Free2() throws Exception {
-    // create a new pool with a max size cap of zero.
-    mPool = new TestPool(0, 10);
-    mStats.setPool(mPool);
-
-    // get a buffer and release it - this should trigger the soft cap
-    byte[] b1 = mPool.get(4);
-    mPool.release(b1);
-
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            4, new IntPair(0, 0)),
-        mStats.mBucketStats);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(0, mStats.mUsedBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-    Assert.assertEquals(0, mStats.mUsedCount);
-  }
-
-  // Test release with bucket length constraints
-  @Test
-  public void testRelease_BucketLengths() throws Exception {
-    mPool = new TestPool(Integer.MAX_VALUE, Integer.MAX_VALUE, makeBucketSizeArray(2, 2));
-    mStats.setPool(mPool);
-
-    byte[] b0 = mPool.get(2);
-    mPool.get(2);
-    mPool.get(2);
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            2, new IntPair(3, 0)),
-        mStats.mBucketStats);
-    Assert.assertEquals(6, mStats.mUsedBytes);
-    Assert.assertEquals(3, mStats.mUsedCount);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-
-    // now release one of the buffers
-    mPool.release(b0);
-
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            2, new IntPair(2, 0)),
-        mStats.mBucketStats);
-    Assert.assertEquals(4, mStats.mUsedBytes);
-    Assert.assertEquals(2, mStats.mUsedCount);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-  }
-
-  // Test releasing an 'unknown' value
-  @Test
-  public void testRelease_UnknownValue() throws Exception {
-    // get a buffer from the pool
-    mPool.get(1);
-
-    // allocate a buffer outside the pool
-    byte[] b2 = new byte[2];
-    // try to release this buffer to the pool
-    mPool.release(b2);
-
-    // verify stats
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(2, new IntPair(1, 0)),
-        mStats.mBucketStats);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(2, mStats.mUsedBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-    Assert.assertEquals(1, mStats.mUsedCount);
-  }
-
-  // Test 'taking-over' a value
-  @Test
-  public void testTakeOver() throws Exception {
-    // allocate a buffer outside the pool
-    byte[] b2 = new byte[2];
-    Assert.assertTrue(mPool.takeOver(b2));
-    // verify stats
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(2, new IntPair(1, 0)),
-        mStats.mBucketStats);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(2, mStats.mUsedBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-    Assert.assertEquals(1, mStats.mUsedCount);
-
-    // try to take it over again. Nothing should change
-    Assert.assertTrue(mPool.takeOver(b2));
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(2, new IntPair(1, 0)),
-        mStats.mBucketStats);
-
-    byte[] b3 = new byte[14];
-    Assert.assertFalse(mPool.takeOver(b3));
-    Assert.assertEquals(
-        ImmutableMap.of(2, new IntPair(1, 0)),
-        mStats.mBucketStats);
-  }
-
-  // test out release with non reusable values
-  @Test
-  public void testRelease_NonReusable() throws Exception {
-    TestPool pool = new TestPool(100, 100, makeBucketSizeArray(2, 3));
-    mPool.mIsReusable = false;
-    mStats.setPool(pool);
-
-    // get a buffer, and then release it
-    byte[] b1 = mPool.get(2);
-    mPool.release(b1);
-
-    // verify stats
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(2, new IntPair(0, 0)),
-        mStats.mBucketStats);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(0, mStats.mUsedBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-    Assert.assertEquals(0, mStats.mUsedCount);
-
-  }
-
-  // test buffers outside the 'normal' bucket sizes
-  @Test
-  public void testGetRelease_NonBucketSizes() throws Exception {
-    mPool = new TestPool(10, 10, makeBucketSizeArray(2, 1, 4, 1, 6, 1));
-    mStats.setPool(mPool);
-
-    mPool.get(2);
-    byte[] b1 = mPool.get(7);
-    mStats.refresh();
-    Assert.assertEquals(10, mStats.mUsedBytes);
-    Assert.assertEquals(2, mStats.mUsedCount);
-    mPool.release(b1);
-    mStats.refresh();
-    Assert.assertEquals(2, mStats.mUsedBytes);
-    Assert.assertEquals(1, mStats.mUsedCount);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-
-    byte[] b2 = new byte[3];
-    mPool.release(b2);
-    mStats.refresh();
-    Assert.assertEquals(2, mStats.mUsedBytes);
-    Assert.assertEquals(1, mStats.mUsedCount);
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(0, mStats.mFreeCount);
-  }
-
-  // test illegal arguments to get
-  @Test
-  public void testGetWithErrors() throws Exception {
-    int[] sizes = new int[] {-1, 0};
-    for (int s: sizes) {
-      try {
-        mPool.get(s);
-        Assert.fail("Failed size: " + s);
-      } catch (BasePool.InvalidSizeException e) {
-        // do nothing
-      }
+
+    @Test
+    public void testFree() throws Exception {
     }
-  }
-
-  // test out trimToNothing functionality
-  @Test
-  public void testTrimToNothing() throws Exception {
-    // alloc a buffer and then release it
-    byte[] b1 = mPool.get(1);
-    mPool.release(b1);
-    mPool.get(3);
-    mStats.refresh();
-    Assert.assertEquals(2, mStats.mFreeBytes);
-    Assert.assertEquals(4, mStats.mUsedBytes);
-
-    // trim the pool and check
-    mPool.trimToNothing();
-    mStats.refresh();
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(4, mStats.mUsedBytes);
-  }
-
-  // test out trimToSize functionality
-  @Test
-  public void testTrimToSize() throws Exception {
-    mPool = new TestPool(100, 100, makeBucketSizeArray(2, 2, 4, 2, 6, 2));
-    mStats.setPool(mPool);
-
-    // allocate and release multiple buffers
-    byte[] b1;
-    mPool.get(2);
-    b1 = mPool.get(2);
-    mPool.release(b1);
-    b1 = mPool.get(6);
-    mPool.release(b1);
-    b1 = mPool.get(4);
-    mPool.release(b1);
-
-    mStats.refresh();
-    Assert.assertEquals(12, mStats.mFreeBytes);
-    Assert.assertEquals(2, mStats.mUsedBytes);
-
-    // perform a dummy trim - nothing should happen
-    mPool.trimToSize(100);
-    mStats.refresh();
-    Assert.assertEquals(12, mStats.mFreeBytes);
-    Assert.assertEquals(2, mStats.mUsedBytes);
-
-    // now perform the real trim
-    mPool.trimToSize(8);
-    mStats.refresh();
-    Assert.assertEquals(6, mStats.mFreeBytes);
-    Assert.assertEquals(2, mStats.mUsedBytes);
-    Assert.assertEquals(
-        ImmutableMap.of(
-            2, new IntPair(1, 0),
-            4, new IntPair(0, 0),
-            6, new IntPair(0, 1)),
-        mStats.mBucketStats);
-
-    // perform another trim
-    mPool.trimToSize(1);
-    mStats.refresh();
-    Assert.assertEquals(0, mStats.mFreeBytes);
-    Assert.assertEquals(2, mStats.mUsedBytes);
-    Assert.assertEquals(
-        ImmutableMap.of(
-            2, new IntPair(1, 0),
-            4, new IntPair(0, 0),
-            6, new IntPair(0, 0)),
-        mStats.mBucketStats);
-  }
-
-  @Test
-  public void test_canAllocate() throws Exception {
-    TestPool pool = new TestPool(4, 8);
-
-    pool.get(4);
-    Assert.assertFalse(pool.isMaxSizeSoftCapExceeded());
-    Assert.assertTrue(pool.canAllocate(2));
-    pool.get(2);
-    Assert.assertTrue(pool.isMaxSizeSoftCapExceeded());
-    Assert.assertTrue(pool.canAllocate(2));
-    Assert.assertFalse(pool.canAllocate(4));
-  }
-
-  /**
-   * A simple test pool that allocates byte arrays, and always allocates buffers of double
-   * the size requested
-   */
-  public static class TestPool extends BasePool<byte[]> {
-    public boolean mIsReusable;
-
-    public TestPool(int maxPoolSizeSoftCap, int maxPoolSizeHardCap) {
-      this(maxPoolSizeSoftCap, maxPoolSizeHardCap, null);
+
+    // tests out the getBucketedSize method
+    @Test
+    public void testGetBucketedSize() throws Exception {
+        Assert.assertEquals(2, mPool.getBucketedSize(1));
+        Assert.assertEquals(2, mPool.getBucketedSize(2));
+        Assert.assertEquals(4, mPool.getBucketedSize(3));
+        Assert.assertEquals(6, mPool.getBucketedSize(6));
+        Assert.assertEquals(8, mPool.getBucketedSize(7));
     }
 
-    public TestPool(
-        int maxPoolSizeSoftCap,
-        int maxPoolSizeHardCap,
-        SparseIntArray bucketSizes) {
-      super(
-          mock(MemoryTrimmableRegistry.class),
-          new PoolParams(maxPoolSizeSoftCap, maxPoolSizeHardCap, bucketSizes),
-          mock(PoolStatsTracker.class));
-      mIsReusable = true;
-      initialize();
+    // tests out the getBucketedSize method for invalid inputs
+    @Test
+    public void testGetBucketedSize_Invalid() throws Exception {
+        int[] sizes = new int[]{-1, 0};
+        for (int s : sizes) {
+            try {
+                mPool.getBucketedSize(s);
+                Assert.fail("Failed size: " + s);
+            } catch (BasePool.InvalidSizeException e) {
+                // do nothing
+            }
+        }
     }
 
-    @Override
-    protected byte[] alloc(int bucketedSize) {
-      return new byte[bucketedSize];
+    // tests out the getBucketedSizeForValue method
+    @Test
+    public void testGetBucketedSizeForValue() throws Exception {
+        Assert.assertEquals(2, mPool.getBucketedSizeForValue(new byte[2]));
+        Assert.assertEquals(3, mPool.getBucketedSizeForValue(new byte[3]));
+        Assert.assertEquals(6, mPool.getBucketedSizeForValue(new byte[6]));
     }
 
-    @Override
-    protected void free(byte[] value) {
+    @Test
+    public void testGetSizeInBytes() throws Exception {
+        Assert.assertEquals(1, mPool.getSizeInBytes(1));
+        Assert.assertEquals(2, mPool.getSizeInBytes(2));
+        Assert.assertEquals(3, mPool.getSizeInBytes(3));
+        Assert.assertEquals(5, mPool.getSizeInBytes(5));
+        Assert.assertEquals(4, mPool.getSizeInBytes(4));
     }
 
-    @Override
-    protected boolean isReusable(byte[] value) {
-      return mIsReusable;
+    // Get via alloc
+    @Test
+    public void testGet_Alloc() throws Exception {
+        // get a buffer - causes an alloc
+        byte[] b1 = mPool.get(1);
+        Assert.assertNotNull(b1);
+        Assert.assertEquals(2, b1.length);
+        Assert.assertTrue(mPool.mInUseValues.contains(b1));
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(2, new IntPair(1, 0)),
+                mStats.mBucketStats);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(2, mStats.mUsedBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
+        Assert.assertEquals(1, mStats.mUsedCount);
+
+        // release this buffer
+        mPool.release(b1);
+        Assert.assertFalse(mPool.mInUseValues.contains(b1));
+
+        // get another buffer, but of a different size. No reuse possible
+        byte[] b2 = mPool.get(3);
+        Assert.assertNotNull(b2);
+        Assert.assertEquals(4, b2.length);
+        Assert.assertTrue(mPool.mInUseValues.contains(b2));
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        2, new IntPair(0, 1),
+                        4, new IntPair(1, 0)),
+                mStats.mBucketStats);
+        Assert.assertEquals(2, mStats.mFreeBytes);
+        Assert.assertEquals(4, mStats.mUsedBytes);
+        Assert.assertEquals(1, mStats.mFreeCount);
+        Assert.assertEquals(1, mStats.mUsedCount);
     }
 
-    /**
-     * Allocate the smallest even number than is greater than or equal to the requested size
-     * @param requestSize the logical request size
-     * @return the slightly higher size
-     */
-    @Override
-    protected int getBucketedSize(int requestSize) {
-      if (requestSize <= 0) {
-        throw new InvalidSizeException(requestSize);
-      }
+    // Get via alloc+trim
+    @Test
+    public void testGet_AllocAndTrim() throws Exception {
+        mPool = new TestPool(10, 10, makeBucketSizeArray(2, 2, 4, 2, 6, 2));
+        mStats.setPool(mPool);
+
+        // allocate and release multiple buffers
+        byte[] b1;
+        b1 = mPool.get(2);
+        mPool.release(b1);
+        b1 = mPool.get(6);
+        mPool.release(b1);
+
+        // get current stats
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        2, new IntPair(0, 1),
+                        4, new IntPair(0, 0),
+                        6, new IntPair(0, 1)),
+                mStats.mBucketStats);
+
+        // get a new buffer; this should cause an alloc and a trim
+        mPool.get(3);
+        mStats.refresh();
+        // validate stats
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        2, new IntPair(0, 0),
+                        4, new IntPair(1, 0),
+                        6, new IntPair(0, 1)),
+                mStats.mBucketStats);
+        Assert.assertEquals(6, mStats.mFreeBytes);
+        Assert.assertEquals(4, mStats.mUsedBytes);
+        Assert.assertEquals(1, mStats.mFreeCount);
+        Assert.assertEquals(1, mStats.mUsedCount);
+    }
+
+    // Tests that we can reuse a free buffer in the pool
+    @Test
+    public void testGet_Reuse() throws Exception {
+        // get a buffer, and immediately release it
+        byte[] b1 = mPool.get(1);
+        mPool.release(b1);
+        Assert.assertNotNull(b1);
+        Assert.assertEquals(2, b1.length);
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(2, new IntPair(0, 1)),
+                mStats.mBucketStats);
+        Assert.assertEquals(2, mStats.mFreeBytes);
+        Assert.assertEquals(0, mStats.mUsedBytes);
+        Assert.assertEquals(1, mStats.mFreeCount);
+        Assert.assertEquals(0, mStats.mUsedCount);
+
+        // get another buffer of the same size as above. We should be able to reuse it
+        byte[] b2 = mPool.get(1);
+        Assert.assertNotNull(b2);
+        Assert.assertEquals(2, b2.length);
+        Assert.assertTrue(mPool.mInUseValues.contains(b2));
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(2, new IntPair(1, 0)),
+                mStats.mBucketStats);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(2, mStats.mUsedBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
+        Assert.assertEquals(1, mStats.mUsedCount);
+    }
+
+    // Get via alloc - exception on max size hard cap
+    @Test
+    public void testGet_AllocFailure() throws Exception {
+        TestPool pool = new TestPool(4, 5);
+        pool.get(4);
+        try {
+            pool.get(4);
+            Assert.fail();
+        } catch (PoolSizeViolationException e) {
+            // expected exception
+        }
+    }
+
+    // test a simple release
+    @Test
+    public void testRelease() throws Exception {
+        // get a buffer - causes an alloc
+        byte[] b1 = mPool.get(1);
+        // release this buffer
+        mPool.release(b1);
+
+        // verify stats
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(2, new IntPair(0, 1)),
+                mStats.mBucketStats);
+        Assert.assertEquals(2, mStats.mFreeBytes);
+        Assert.assertEquals(0, mStats.mUsedBytes);
+        Assert.assertEquals(1, mStats.mFreeCount);
+        Assert.assertEquals(0, mStats.mUsedCount);
+    }
+
+    // test out release(), when it should free the value, instead of adding to the pool
+    @Test
+    public void testRelease_Free() throws Exception {
+        // get a set of buffers that bump up above the max size
+        mPool.get(6);
+        // get and release another buffer. this should cause a free
+        byte[] b3 = mPool.get(6);
+        mPool.release(b3);
+
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(6, new IntPair(1, 0)),
+                mStats.mBucketStats);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(6, mStats.mUsedBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
+        Assert.assertEquals(1, mStats.mUsedCount);
+    }
+
+    // test release on  zero-sized pool
+    @Test
+    public void testRelease_Free2() throws Exception {
+        // create a new pool with a max size cap of zero.
+        mPool = new TestPool(0, 10);
+        mStats.setPool(mPool);
+
+        // get a buffer and release it - this should trigger the soft cap
+        byte[] b1 = mPool.get(4);
+        mPool.release(b1);
+
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        4, new IntPair(0, 0)),
+                mStats.mBucketStats);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(0, mStats.mUsedBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
+        Assert.assertEquals(0, mStats.mUsedCount);
+    }
 
-      return (requestSize % 2 == 0) ? requestSize : requestSize + 1;
+    // Test release with bucket length constraints
+    @Test
+    public void testRelease_BucketLengths() throws Exception {
+        mPool = new TestPool(Integer.MAX_VALUE, Integer.MAX_VALUE, makeBucketSizeArray(2, 2));
+        mStats.setPool(mPool);
+
+        byte[] b0 = mPool.get(2);
+        mPool.get(2);
+        mPool.get(2);
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        2, new IntPair(3, 0)),
+                mStats.mBucketStats);
+        Assert.assertEquals(6, mStats.mUsedBytes);
+        Assert.assertEquals(3, mStats.mUsedCount);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
+
+        // now release one of the buffers
+        mPool.release(b0);
+
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        2, new IntPair(2, 0)),
+                mStats.mBucketStats);
+        Assert.assertEquals(4, mStats.mUsedBytes);
+        Assert.assertEquals(2, mStats.mUsedCount);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
     }
 
-    @Override
-    protected int getBucketedSizeForValue(byte[] value) {
-      return value.length;
+    // Test releasing an 'unknown' value
+    @Test
+    public void testRelease_UnknownValue() throws Exception {
+        // get a buffer from the pool
+        mPool.get(1);
+
+        // allocate a buffer outside the pool
+        byte[] b2 = new byte[2];
+        // try to release this buffer to the pool
+        mPool.release(b2);
+
+        // verify stats
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(2, new IntPair(1, 0)),
+                mStats.mBucketStats);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(2, mStats.mUsedBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
+        Assert.assertEquals(1, mStats.mUsedCount);
     }
 
-    @Override
-    protected int getSizeInBytes(int bucketedSize) {
-      return bucketedSize;
+    // Test 'taking-over' a value
+    @Test
+    public void testTakeOver() throws Exception {
+        // allocate a buffer outside the pool
+        byte[] b2 = new byte[2];
+        Assert.assertTrue(mPool.takeOver(b2));
+        // verify stats
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(2, new IntPair(1, 0)),
+                mStats.mBucketStats);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(2, mStats.mUsedBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
+        Assert.assertEquals(1, mStats.mUsedCount);
+
+        // try to take it over again. Nothing should change
+        Assert.assertTrue(mPool.takeOver(b2));
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(2, new IntPair(1, 0)),
+                mStats.mBucketStats);
+
+        byte[] b3 = new byte[14];
+        Assert.assertFalse(mPool.takeOver(b3));
+        Assert.assertEquals(
+                ImmutableMap.of(2, new IntPair(1, 0)),
+                mStats.mBucketStats);
+    }
+
+    // test out release with non reusable values
+    @Test
+    public void testRelease_NonReusable() throws Exception {
+        TestPool pool = new TestPool(100, 100, makeBucketSizeArray(2, 3));
+        mPool.mIsReusable = false;
+        mStats.setPool(pool);
+
+        // get a buffer, and then release it
+        byte[] b1 = mPool.get(2);
+        mPool.release(b1);
+
+        // verify stats
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(2, new IntPair(0, 0)),
+                mStats.mBucketStats);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(0, mStats.mUsedBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
+        Assert.assertEquals(0, mStats.mUsedCount);
+
+    }
+
+    // test buffers outside the 'normal' bucket sizes
+    @Test
+    public void testGetRelease_NonBucketSizes() throws Exception {
+        mPool = new TestPool(10, 10, makeBucketSizeArray(2, 1, 4, 1, 6, 1));
+        mStats.setPool(mPool);
+
+        mPool.get(2);
+        byte[] b1 = mPool.get(7);
+        mStats.refresh();
+        Assert.assertEquals(10, mStats.mUsedBytes);
+        Assert.assertEquals(2, mStats.mUsedCount);
+        mPool.release(b1);
+        mStats.refresh();
+        Assert.assertEquals(2, mStats.mUsedBytes);
+        Assert.assertEquals(1, mStats.mUsedCount);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
+
+        byte[] b2 = new byte[3];
+        mPool.release(b2);
+        mStats.refresh();
+        Assert.assertEquals(2, mStats.mUsedBytes);
+        Assert.assertEquals(1, mStats.mUsedCount);
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(0, mStats.mFreeCount);
+    }
+
+    // test illegal arguments to get
+    @Test
+    public void testGetWithErrors() throws Exception {
+        int[] sizes = new int[]{-1, 0};
+        for (int s : sizes) {
+            try {
+                mPool.get(s);
+                Assert.fail("Failed size: " + s);
+            } catch (BasePool.InvalidSizeException e) {
+                // do nothing
+            }
+        }
+    }
+
+    // test out trimToNothing functionality
+    @Test
+    public void testTrimToNothing() throws Exception {
+        // alloc a buffer and then release it
+        byte[] b1 = mPool.get(1);
+        mPool.release(b1);
+        mPool.get(3);
+        mStats.refresh();
+        Assert.assertEquals(2, mStats.mFreeBytes);
+        Assert.assertEquals(4, mStats.mUsedBytes);
+
+        // trim the pool and check
+        mPool.trimToNothing();
+        mStats.refresh();
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(4, mStats.mUsedBytes);
+    }
+
+    // test out trimToSize functionality
+    @Test
+    public void testTrimToSize() throws Exception {
+        mPool = new TestPool(100, 100, makeBucketSizeArray(2, 2, 4, 2, 6, 2));
+        mStats.setPool(mPool);
+
+        // allocate and release multiple buffers
+        byte[] b1;
+        mPool.get(2);
+        b1 = mPool.get(2);
+        mPool.release(b1);
+        b1 = mPool.get(6);
+        mPool.release(b1);
+        b1 = mPool.get(4);
+        mPool.release(b1);
+
+        mStats.refresh();
+        Assert.assertEquals(12, mStats.mFreeBytes);
+        Assert.assertEquals(2, mStats.mUsedBytes);
+
+        // perform a dummy trim - nothing should happen
+        mPool.trimToSize(100);
+        mStats.refresh();
+        Assert.assertEquals(12, mStats.mFreeBytes);
+        Assert.assertEquals(2, mStats.mUsedBytes);
+
+        // now perform the real trim
+        mPool.trimToSize(8);
+        mStats.refresh();
+        Assert.assertEquals(6, mStats.mFreeBytes);
+        Assert.assertEquals(2, mStats.mUsedBytes);
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        2, new IntPair(1, 0),
+                        4, new IntPair(0, 0),
+                        6, new IntPair(0, 1)),
+                mStats.mBucketStats);
+
+        // perform another trim
+        mPool.trimToSize(1);
+        mStats.refresh();
+        Assert.assertEquals(0, mStats.mFreeBytes);
+        Assert.assertEquals(2, mStats.mUsedBytes);
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        2, new IntPair(1, 0),
+                        4, new IntPair(0, 0),
+                        6, new IntPair(0, 0)),
+                mStats.mBucketStats);
+    }
+
+    @Test
+    public void test_canAllocate() throws Exception {
+        TestPool pool = new TestPool(4, 8);
+
+        pool.get(4);
+        Assert.assertFalse(pool.isMaxSizeSoftCapExceeded());
+        Assert.assertTrue(pool.canAllocate(2));
+        pool.get(2);
+        Assert.assertTrue(pool.isMaxSizeSoftCapExceeded());
+        Assert.assertTrue(pool.canAllocate(2));
+        Assert.assertFalse(pool.canAllocate(4));
+    }
+
+    /**
+     * A simple test pool that allocates byte arrays, and always allocates buffers of double
+     * the size requested
+     */
+    public static class TestPool extends BasePool<byte[]> {
+        public boolean mIsReusable;
+
+        public TestPool(int maxPoolSizeSoftCap, int maxPoolSizeHardCap) {
+            this(maxPoolSizeSoftCap, maxPoolSizeHardCap, null);
+        }
+
+        public TestPool(
+                int maxPoolSizeSoftCap,
+                int maxPoolSizeHardCap,
+                SparseIntArray bucketSizes) {
+            super(
+                    mock(MemoryTrimmableRegistry.class),
+                    new PoolParams(maxPoolSizeSoftCap, maxPoolSizeHardCap, bucketSizes),
+                    mock(PoolStatsTracker.class));
+            mIsReusable = true;
+            initialize();
+        }
+
+        @Override
+        protected byte[] alloc(int bucketedSize) {
+            return new byte[bucketedSize];
+        }
+
+        @Override
+        protected void free(byte[] value) {
+        }
+
+        @Override
+        protected boolean isReusable(byte[] value) {
+            return mIsReusable;
+        }
+
+        /**
+         * Allocate the smallest even number than is greater than or equal to the requested size
+         *
+         * @param requestSize the logical request size
+         * @return the slightly higher size
+         */
+        @Override
+        protected int getBucketedSize(int requestSize) {
+            if (requestSize <= 0) {
+                throw new InvalidSizeException(requestSize);
+            }
+
+            return (requestSize % 2 == 0) ? requestSize : requestSize + 1;
+        }
+
+        @Override
+        protected int getBucketedSizeForValue(byte[] value) {
+            return value.length;
+        }
+
+        @Override
+        protected int getSizeInBytes(int bucketedSize) {
+            return bucketedSize;
+        }
     }
-  }
 
-  private static SparseIntArray makeBucketSizeArray(int... params) {
-    Preconditions.checkArgument(params.length % 2 == 0);
-    final SparseIntArray bucketSizes = new SparseIntArray();
-    for (int i = 0; i < params.length; i += 2) {
-      bucketSizes.append(params[i], params[i + 1]);
+    private static SparseIntArray makeBucketSizeArray(int... params) {
+        Preconditions.checkArgument(params.length % 2 == 0);
+        final SparseIntArray bucketSizes = new SparseIntArray();
+        for (int i = 0; i < params.length; i += 2) {
+            bucketSizes.append(params[i], params[i + 1]);
+        }
+        return bucketSizes;
     }
-    return bucketSizes;
-  }
 }
 
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/GenericByteArrayPoolTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/GenericByteArrayPoolTest.java
index bde6390cb..152b6f271 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/GenericByteArrayPoolTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/GenericByteArrayPoolTest.java
@@ -26,74 +26,74 @@
  */
 @RunWith(WithTestDefaultsRunner.class)
 public class GenericByteArrayPoolTest {
-  private GenericByteArrayPool mPool;
+    private GenericByteArrayPool mPool;
 
-  @Before
-  public void setup() {
-    final SparseIntArray bucketSizes = new SparseIntArray();
-    bucketSizes.put(32, 2);
-    bucketSizes.put(64, 1);
-    bucketSizes.put(128, 1);
-    mPool = new GenericByteArrayPool(
-        mock(MemoryTrimmableRegistry.class),
-        new PoolParams(128, bucketSizes),
-        mock(PoolStatsTracker.class));
-  }
+    @Before
+    public void setup() {
+        final SparseIntArray bucketSizes = new SparseIntArray();
+        bucketSizes.put(32, 2);
+        bucketSizes.put(64, 1);
+        bucketSizes.put(128, 1);
+        mPool = new GenericByteArrayPool(
+                mock(MemoryTrimmableRegistry.class),
+                new PoolParams(128, bucketSizes),
+                mock(PoolStatsTracker.class));
+    }
 
-  // Test out the alloc method
-  @Test
-  public void testAlloc() throws Exception {
-    Assert.assertEquals(1, mPool.alloc(1).length);
-    Assert.assertEquals(33, mPool.alloc(33).length);
-    Assert.assertEquals(32, mPool.alloc(32).length);
-  }
+    // Test out the alloc method
+    @Test
+    public void testAlloc() throws Exception {
+        Assert.assertEquals(1, mPool.alloc(1).length);
+        Assert.assertEquals(33, mPool.alloc(33).length);
+        Assert.assertEquals(32, mPool.alloc(32).length);
+    }
 
-  @Test
-  public void testFree() throws Exception {
-  }
+    @Test
+    public void testFree() throws Exception {
+    }
 
-  // tests out the getBucketedSize method
-  @Test
-  public void testGetBucketedSize() throws Exception {
-    Assert.assertEquals(32, mPool.getBucketedSize(1));
-    Assert.assertEquals(32, mPool.getBucketedSize(32));
-    Assert.assertEquals(64, mPool.getBucketedSize(33));
-    Assert.assertEquals(64, mPool.getBucketedSize(64));
-    Assert.assertEquals(128, mPool.getBucketedSize(69));
+    // tests out the getBucketedSize method
+    @Test
+    public void testGetBucketedSize() throws Exception {
+        Assert.assertEquals(32, mPool.getBucketedSize(1));
+        Assert.assertEquals(32, mPool.getBucketedSize(32));
+        Assert.assertEquals(64, mPool.getBucketedSize(33));
+        Assert.assertEquals(64, mPool.getBucketedSize(64));
+        Assert.assertEquals(128, mPool.getBucketedSize(69));
 
-    // value larger than max bucket
-    Assert.assertEquals(129, mPool.getBucketedSize(129));
+        // value larger than max bucket
+        Assert.assertEquals(129, mPool.getBucketedSize(129));
 
-    int[] invalidSizes = new int[] {-1, 0};
-    for (int size: invalidSizes) {
-      try {
-        mPool.getBucketedSize(size);
-        Assert.fail();
-      } catch (BasePool.InvalidSizeException e) {
-        // do nothing
-      }
+        int[] invalidSizes = new int[]{-1, 0};
+        for (int size : invalidSizes) {
+            try {
+                mPool.getBucketedSize(size);
+                Assert.fail();
+            } catch (BasePool.InvalidSizeException e) {
+                // do nothing
+            }
+        }
     }
-  }
 
-  // tests out the getBucketedSizeForValue method
-  @Test
-  public void testGetBucketedSizeForValue() throws Exception {
-    Assert.assertEquals(32, mPool.getBucketedSizeForValue(new byte[32]));
-    Assert.assertEquals(64, mPool.getBucketedSizeForValue(new byte[64]));
-    Assert.assertEquals(128, mPool.getBucketedSizeForValue(new byte[128]));
+    // tests out the getBucketedSizeForValue method
+    @Test
+    public void testGetBucketedSizeForValue() throws Exception {
+        Assert.assertEquals(32, mPool.getBucketedSizeForValue(new byte[32]));
+        Assert.assertEquals(64, mPool.getBucketedSizeForValue(new byte[64]));
+        Assert.assertEquals(128, mPool.getBucketedSizeForValue(new byte[128]));
 
-    // test with non-bucket values
-    Assert.assertEquals(1, mPool.getBucketedSizeForValue(new byte[1]));
-    Assert.assertEquals(129, mPool.getBucketedSizeForValue(new byte[129]));
-    Assert.assertEquals(31, mPool.getBucketedSizeForValue(new byte[31]));
-  }
+        // test with non-bucket values
+        Assert.assertEquals(1, mPool.getBucketedSizeForValue(new byte[1]));
+        Assert.assertEquals(129, mPool.getBucketedSizeForValue(new byte[129]));
+        Assert.assertEquals(31, mPool.getBucketedSizeForValue(new byte[31]));
+    }
 
-  @Test
-  public void testGetSizeInBytes() throws Exception {
-    Assert.assertEquals(1, mPool.getSizeInBytes(1));
-    Assert.assertEquals(32, mPool.getSizeInBytes(32));
-    Assert.assertEquals(33, mPool.getSizeInBytes(33));
-    Assert.assertEquals(64, mPool.getSizeInBytes(64));
-    Assert.assertEquals(69, mPool.getSizeInBytes(69));
-  }
+    @Test
+    public void testGetSizeInBytes() throws Exception {
+        Assert.assertEquals(1, mPool.getSizeInBytes(1));
+        Assert.assertEquals(32, mPool.getSizeInBytes(32));
+        Assert.assertEquals(33, mPool.getSizeInBytes(33));
+        Assert.assertEquals(64, mPool.getSizeInBytes(64));
+        Assert.assertEquals(69, mPool.getSizeInBytes(69));
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/IntPair.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/IntPair.java
index c6277b966..56851717c 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/IntPair.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/IntPair.java
@@ -15,30 +15,30 @@
  * Surprise! A pair of integers
  */
 public class IntPair {
-  public final int a;
-  public final int b;
+    public final int a;
+    public final int b;
 
-  public IntPair(int a, int b) {
-    this.a = a;
-    this.b = b;
-  }
+    public IntPair(int a, int b) {
+        this.a = a;
+        this.b = b;
+    }
 
-  @Override
-  public int hashCode() {
-    return Objects.hashCode(a, b);
-  }
+    @Override
+    public int hashCode() {
+        return Objects.hashCode(a, b);
+    }
 
-  @Override
-  public boolean equals(Object other) {
-    if (other instanceof IntPair) {
-      IntPair that = (IntPair)other;
-      return this.a == that.a && this.b == that.b;
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof IntPair) {
+            IntPair that = (IntPair) other;
+            return this.a == that.a && this.b == that.b;
+        }
+        return false;
     }
-    return false;
-  }
 
-  @Override
-  public String toString() {
-    return "[" + a + ", " + b + "]";
-  }
+    @Override
+    public String toString() {
+        return "[" + a + ", " + b + "]";
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativeMemoryChunkPoolTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativeMemoryChunkPoolTest.java
index 12e9682d6..c46150feb 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativeMemoryChunkPoolTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativeMemoryChunkPoolTest.java
@@ -25,101 +25,101 @@
  */
 @RunWith(WithTestDefaultsRunner.class)
 public class NativeMemoryChunkPoolTest {
-  private NativeMemoryChunkPool mPool;
+    private NativeMemoryChunkPool mPool;
 
-  @Before
-  public void setup() {
-    final SparseIntArray bucketSizes = new SparseIntArray();
-    bucketSizes.put(32, 2);
-    bucketSizes.put(64, 1);
-    bucketSizes.put(128, 1);
-    mPool = new FakeNativeMemoryChunkPool(
-        new PoolParams(128, bucketSizes));
-  }
+    @Before
+    public void setup() {
+        final SparseIntArray bucketSizes = new SparseIntArray();
+        bucketSizes.put(32, 2);
+        bucketSizes.put(64, 1);
+        bucketSizes.put(128, 1);
+        mPool = new FakeNativeMemoryChunkPool(
+                new PoolParams(128, bucketSizes));
+    }
 
-  // Test out the alloc method
-  @Test
-  public void testAlloc() throws Exception {
-    NativeMemoryChunk c = mPool.alloc(1);
-    Assert.assertNotNull(c);
-    Assert.assertEquals(1, c.getSize());
-    Assert.assertEquals(1, mPool.alloc(1).getSize());
-    Assert.assertEquals(33, mPool.alloc(33).getSize());
-    Assert.assertEquals(32, mPool.alloc(32).getSize());
-  }
+    // Test out the alloc method
+    @Test
+    public void testAlloc() throws Exception {
+        NativeMemoryChunk c = mPool.alloc(1);
+        Assert.assertNotNull(c);
+        Assert.assertEquals(1, c.getSize());
+        Assert.assertEquals(1, mPool.alloc(1).getSize());
+        Assert.assertEquals(33, mPool.alloc(33).getSize());
+        Assert.assertEquals(32, mPool.alloc(32).getSize());
+    }
 
-  @Test
-  public void testFree() throws Exception {
-    NativeMemoryChunk c = mPool.alloc(1);
-    Assert.assertFalse(c.isClosed());
-    mPool.free(c);
-    Assert.assertTrue(c.isClosed());
-    mPool.free(c);
-    Assert.assertTrue(c.isClosed());
-  }
+    @Test
+    public void testFree() throws Exception {
+        NativeMemoryChunk c = mPool.alloc(1);
+        Assert.assertFalse(c.isClosed());
+        mPool.free(c);
+        Assert.assertTrue(c.isClosed());
+        mPool.free(c);
+        Assert.assertTrue(c.isClosed());
+    }
 
-  // tests out the getBucketedSize method
-  @Test
-  public void testGetBucketedSize() throws Exception {
-    Assert.assertEquals(32, mPool.getBucketedSize(1));
-    Assert.assertEquals(32, mPool.getBucketedSize(32));
-    Assert.assertEquals(64, mPool.getBucketedSize(33));
-    Assert.assertEquals(64, mPool.getBucketedSize(64));
-    Assert.assertEquals(128, mPool.getBucketedSize(69));
+    // tests out the getBucketedSize method
+    @Test
+    public void testGetBucketedSize() throws Exception {
+        Assert.assertEquals(32, mPool.getBucketedSize(1));
+        Assert.assertEquals(32, mPool.getBucketedSize(32));
+        Assert.assertEquals(64, mPool.getBucketedSize(33));
+        Assert.assertEquals(64, mPool.getBucketedSize(64));
+        Assert.assertEquals(128, mPool.getBucketedSize(69));
 
-    // value larger than max bucket
-    Assert.assertEquals(129, mPool.getBucketedSize(129));
+        // value larger than max bucket
+        Assert.assertEquals(129, mPool.getBucketedSize(129));
 
-    int[] invalidSizes = new int[] {-1, 0};
-    for (int size: invalidSizes) {
-      try {
-        mPool.getBucketedSize(size);
-        Assert.fail();
-      } catch (BasePool.InvalidSizeException e) {
-        // do nothing
-      }
+        int[] invalidSizes = new int[]{-1, 0};
+        for (int size : invalidSizes) {
+            try {
+                mPool.getBucketedSize(size);
+                Assert.fail();
+            } catch (BasePool.InvalidSizeException e) {
+                // do nothing
+            }
+        }
     }
-  }
 
-  // tests out the getBucketedSizeForValue method
-  @Test
-  public void testGetBucketedSizeForValue() throws Exception {
-    Assert.assertEquals(
-        32,
-        mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(32)));
-    Assert.assertEquals(
-        64,
-        mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(64)));
-    Assert.assertEquals(
-        128,
-        mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(128)));
+    // tests out the getBucketedSizeForValue method
+    @Test
+    public void testGetBucketedSizeForValue() throws Exception {
+        Assert.assertEquals(
+                32,
+                mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(32)));
+        Assert.assertEquals(
+                64,
+                mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(64)));
+        Assert.assertEquals(
+                128,
+                mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(128)));
 
-    // test with non-bucket values
-    Assert.assertEquals(
-        1,
-        mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(1)));
-    Assert.assertEquals(
-        129,
-        mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(129)));
-    Assert.assertEquals(
-        31,
-        mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(31)));
-  }
+        // test with non-bucket values
+        Assert.assertEquals(
+                1,
+                mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(1)));
+        Assert.assertEquals(
+                129,
+                mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(129)));
+        Assert.assertEquals(
+                31,
+                mPool.getBucketedSizeForValue(new FakeNativeMemoryChunk(31)));
+    }
 
-  @Test
-  public void testGetSizeInBytes() throws Exception {
-    Assert.assertEquals(1, mPool.getSizeInBytes(1));
-    Assert.assertEquals(32, mPool.getSizeInBytes(32));
-    Assert.assertEquals(33, mPool.getSizeInBytes(33));
-    Assert.assertEquals(64, mPool.getSizeInBytes(64));
-    Assert.assertEquals(69, mPool.getSizeInBytes(69));
-  }
+    @Test
+    public void testGetSizeInBytes() throws Exception {
+        Assert.assertEquals(1, mPool.getSizeInBytes(1));
+        Assert.assertEquals(32, mPool.getSizeInBytes(32));
+        Assert.assertEquals(33, mPool.getSizeInBytes(33));
+        Assert.assertEquals(64, mPool.getSizeInBytes(64));
+        Assert.assertEquals(69, mPool.getSizeInBytes(69));
+    }
 
-  @Test
-  public void testIsReusable() throws Exception {
-    NativeMemoryChunk chunk = mPool.get(1);
-    Assert.assertTrue(mPool.isReusable(chunk));
-    chunk.close();
-    Assert.assertFalse(mPool.isReusable(chunk));
-  }
+    @Test
+    public void testIsReusable() throws Exception {
+        NativeMemoryChunk chunk = mPool.get(1);
+        Assert.assertTrue(mPool.isReusable(chunk));
+        chunk.close();
+        Assert.assertFalse(mPool.isReusable(chunk));
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferFactoryTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferFactoryTest.java
index 6cb0f455a..fe6846a0e 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferFactoryTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferFactoryTest.java
@@ -15,6 +15,7 @@
 import com.facebook.testing.robolectric.v2.WithTestDefaultsRunner;
 
 import com.google.common.collect.ImmutableMap;
+
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
@@ -28,122 +29,122 @@
  */
 @RunWith(WithTestDefaultsRunner.class)
 public class NativePooledByteBufferFactoryTest {
-  private NativeMemoryChunkPool mPool;
-  private NativePooledByteBufferFactory mFactory;
-  private PoolStats mStats;
-  PooledByteStreams mPooledByteStreams;
-  private byte[] mData;
-
-  @Before
-  public void setup() {
-    mData = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
-    mPool = new FakeNativeMemoryChunkPool();
-    mStats = new PoolStats(mPool);
-
-    ByteArrayPool byteArrayPool = mock(ByteArrayPool.class);
-    byte[] pooledByteArray = new byte[8];
-    when(byteArrayPool.get(8)).thenReturn(pooledByteArray);
-    mPooledByteStreams = new PooledByteStreams(byteArrayPool, 8);
-
-    mFactory = new NativePooledByteBufferFactory(mPool, mPooledByteStreams);
-  }
-
-  // assert that the first 'length' bytes of expected are the same as those in 'actual'
-  private void assertArrayEquals(byte[] expected, byte[] actual, int length) {
-    Assert.assertTrue(expected.length >= length);
-    Assert.assertTrue(actual.length >= length);
-    for (int i = 0; i < length; i++) {
-      Assert.assertEquals(expected[i], actual[i], i);
+    private NativeMemoryChunkPool mPool;
+    private NativePooledByteBufferFactory mFactory;
+    private PoolStats mStats;
+    PooledByteStreams mPooledByteStreams;
+    private byte[] mData;
+
+    @Before
+    public void setup() {
+        mData = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
+        mPool = new FakeNativeMemoryChunkPool();
+        mStats = new PoolStats(mPool);
+
+        ByteArrayPool byteArrayPool = mock(ByteArrayPool.class);
+        byte[] pooledByteArray = new byte[8];
+        when(byteArrayPool.get(8)).thenReturn(pooledByteArray);
+        mPooledByteStreams = new PooledByteStreams(byteArrayPool, 8);
+
+        mFactory = new NativePooledByteBufferFactory(mPool, mPooledByteStreams);
+    }
+
+    // assert that the first 'length' bytes of expected are the same as those in 'actual'
+    private void assertArrayEquals(byte[] expected, byte[] actual, int length) {
+        Assert.assertTrue(expected.length >= length);
+        Assert.assertTrue(actual.length >= length);
+        for (int i = 0; i < length; i++) {
+            Assert.assertEquals(expected[i], actual[i], i);
+        }
+    }
+
+    private byte[] getBytes(NativePooledByteBuffer bb) {
+        byte[] bytes = new byte[bb.size()];
+        bb.mBufRef.get().read(0, bytes, 0, bytes.length);
+        return bytes;
+    }
+
+    @Test
+    public void testNewByteBuf_1() throws Exception {
+        NativePooledByteBuffer sb1 = mFactory.newByteBuffer(new ByteArrayInputStream(mData));
+        Assert.assertEquals(16, sb1.mBufRef.get().getSize());
+        assertArrayEquals(mData, getBytes(sb1), mData.length);
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(0, 0),
+                        16, new IntPair(1, 0),
+                        8, new IntPair(0, 1),
+                        4, new IntPair(0, 1)),
+                mStats.mBucketStats);
+    }
+
+    @Test
+    public void testNewByteBuf_2() throws Exception {
+        NativePooledByteBuffer sb2 = mFactory.newByteBuffer(new ByteArrayInputStream(mData), 8);
+        Assert.assertEquals(16, sb2.mBufRef.get().getSize());
+        assertArrayEquals(mData, getBytes(sb2), mData.length);
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(0, 0),
+                        16, new IntPair(1, 0),
+                        8, new IntPair(0, 1),
+                        4, new IntPair(0, 0)),
+                mStats.mBucketStats);
+    }
+
+    @Test
+    public void testNewByteBuf_3() throws Exception {
+        NativePooledByteBuffer sb3 = mFactory.newByteBuffer(new ByteArrayInputStream(mData), 16);
+        Assert.assertEquals(16, sb3.mBufRef.get().getSize());
+        assertArrayEquals(mData, getBytes(sb3), mData.length);
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(0, 0),
+                        16, new IntPair(1, 0),
+                        8, new IntPair(0, 0),
+                        4, new IntPair(0, 0)),
+                mStats.mBucketStats);
+    }
+
+    @Test
+    public void testNewByteBuf_4() throws Exception {
+        NativePooledByteBuffer sb4 = mFactory.newByteBuffer(new ByteArrayInputStream(mData), 32);
+        Assert.assertEquals(32, sb4.mBufRef.get().getSize());
+        assertArrayEquals(mData, getBytes(sb4), mData.length);
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(1, 0),
+                        16, new IntPair(0, 0),
+                        8, new IntPair(0, 0),
+                        4, new IntPair(0, 0)),
+                mStats.mBucketStats);
+    }
+
+    @Test
+    public void testNewByteBuf_5() {
+        NativePooledByteBuffer sb5 = mFactory.newByteBuffer(5);
+        Assert.assertEquals(8, sb5.mBufRef.get().getSize());
+        Assert.assertEquals(1, sb5.mBufRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(0, 0),
+                        16, new IntPair(0, 0),
+                        8, new IntPair(1, 0),
+                        4, new IntPair(0, 0)),
+                mStats.mBucketStats);
+        sb5.close();
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(0, 0),
+                        16, new IntPair(0, 0),
+                        8, new IntPair(0, 1),
+                        4, new IntPair(0, 0)),
+                mStats.mBucketStats);
     }
-  }
-
-  private byte[] getBytes(NativePooledByteBuffer bb) {
-    byte[] bytes = new byte[bb.size()];
-    bb.mBufRef.get().read(0, bytes, 0, bytes.length);
-    return bytes;
-  }
-
-  @Test
-  public void testNewByteBuf_1() throws Exception {
-    NativePooledByteBuffer sb1 = mFactory.newByteBuffer(new ByteArrayInputStream(mData));
-    Assert.assertEquals(16, sb1.mBufRef.get().getSize());
-    assertArrayEquals(mData, getBytes(sb1), mData.length);
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(0, 0),
-            16, new IntPair(1, 0),
-            8, new IntPair(0, 1),
-            4, new IntPair(0, 1)),
-        mStats.mBucketStats);
-  }
-
-  @Test
-  public void testNewByteBuf_2() throws Exception {
-    NativePooledByteBuffer sb2 = mFactory.newByteBuffer(new ByteArrayInputStream(mData), 8);
-    Assert.assertEquals(16, sb2.mBufRef.get().getSize());
-    assertArrayEquals(mData, getBytes(sb2), mData.length);
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(0, 0),
-            16, new IntPair(1, 0),
-            8, new IntPair(0, 1),
-            4, new IntPair(0, 0)),
-        mStats.mBucketStats);
-  }
-
-  @Test
-  public void testNewByteBuf_3() throws Exception {
-    NativePooledByteBuffer sb3 = mFactory.newByteBuffer(new ByteArrayInputStream(mData), 16);
-    Assert.assertEquals(16, sb3.mBufRef.get().getSize());
-    assertArrayEquals(mData, getBytes(sb3), mData.length);
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(0, 0),
-            16, new IntPair(1, 0),
-            8, new IntPair(0, 0),
-            4, new IntPair(0, 0)),
-        mStats.mBucketStats);
-  }
-
-  @Test
-  public void testNewByteBuf_4() throws Exception {
-    NativePooledByteBuffer sb4 = mFactory.newByteBuffer(new ByteArrayInputStream(mData), 32);
-    Assert.assertEquals(32, sb4.mBufRef.get().getSize());
-    assertArrayEquals(mData, getBytes(sb4), mData.length);
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(1, 0),
-            16, new IntPair(0, 0),
-            8, new IntPair(0, 0),
-            4, new IntPair(0, 0)),
-        mStats.mBucketStats);
-  }
-
-  @Test
-  public void testNewByteBuf_5() {
-    NativePooledByteBuffer sb5 = mFactory.newByteBuffer(5);
-    Assert.assertEquals(8, sb5.mBufRef.get().getSize());
-    Assert.assertEquals(1, sb5.mBufRef.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(0, 0),
-            16, new IntPair(0, 0),
-            8, new IntPair(1, 0),
-            4, new IntPair(0, 0)),
-        mStats.mBucketStats);
-    sb5.close();
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(0, 0),
-            16, new IntPair(0, 0),
-            8, new IntPair(0, 1),
-            4, new IntPair(0, 0)),
-        mStats.mBucketStats);
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferOutputStreamTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferOutputStreamTest.java
index ef70ff3d7..6d440096f 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferOutputStreamTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferOutputStreamTest.java
@@ -16,6 +16,7 @@
 import com.facebook.testing.robolectric.v2.WithTestDefaultsRunner;
 
 import com.google.common.collect.ImmutableMap;
+
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
@@ -26,143 +27,143 @@
  */
 @RunWith(WithTestDefaultsRunner.class)
 public class NativePooledByteBufferOutputStreamTest {
-  private NativeMemoryChunkPool mPool;
-  private byte[] mData;
-  private PoolStats<byte[]> mStats;
-
-  @Before
-  public void setup() {
-    mPool = new FakeNativeMemoryChunkPool();
-    mStats = new PoolStats(mPool);
-    mData = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
-  }
-
-  // write out the contents of data into the output stream
-  private NativePooledByteBuffer doWrite(NativePooledByteBufferOutputStream os, byte[] data)
-      throws Exception {
-    for (int i = 0; i < data.length; i++) {
-      os.write(data, i, 1);
+    private NativeMemoryChunkPool mPool;
+    private byte[] mData;
+    private PoolStats<byte[]> mStats;
+
+    @Before
+    public void setup() {
+        mPool = new FakeNativeMemoryChunkPool();
+        mStats = new PoolStats(mPool);
+        mData = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
+    }
+
+    // write out the contents of data into the output stream
+    private NativePooledByteBuffer doWrite(NativePooledByteBufferOutputStream os, byte[] data)
+            throws Exception {
+        for (int i = 0; i < data.length; i++) {
+            os.write(data, i, 1);
+        }
+        return os.toByteBuffer();
+    }
+
+    // assert that the first 'length' bytes of expected are the same as those in 'actual'
+    private void assertArrayEquals(byte[] expected, byte[] actual, int length) {
+        Assert.assertTrue(expected.length >= length);
+        Assert.assertTrue(actual.length >= length);
+        for (int i = 0; i < length; i++) {
+            Assert.assertEquals(expected[i], actual[i]);
+        }
     }
-    return os.toByteBuffer();
-  }
-
-  // assert that the first 'length' bytes of expected are the same as those in 'actual'
-  private void assertArrayEquals(byte[] expected, byte[] actual, int length) {
-    Assert.assertTrue(expected.length >= length);
-    Assert.assertTrue(actual.length >= length);
-    for (int i = 0; i < length; i++) {
-      Assert.assertEquals(expected[i], actual[i]);
+
+    private byte[] getBytes(NativePooledByteBuffer bb) {
+        byte[] bytes = new byte[bb.size()];
+        bb.mBufRef.get().read(0, bytes, 0, bytes.length);
+        return bytes;
+    }
+
+    @Test
+    public void testBasic_1() throws Exception {
+        NativePooledByteBufferOutputStream os1 = new NativePooledByteBufferOutputStream(mPool);
+        NativePooledByteBuffer sb1 = doWrite(os1, mData);
+        Assert.assertEquals(16, sb1.mBufRef.get().getSize());
+        assertArrayEquals(mData, getBytes(sb1), mData.length);
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(0, 0),
+                        16, new IntPair(1, 0),
+                        8, new IntPair(0, 1),
+                        4, new IntPair(0, 1)),
+                mStats.mBucketStats);
+    }
+
+    @Test
+    public void testBasic_2() throws Exception {
+        NativePooledByteBufferOutputStream os2 = new NativePooledByteBufferOutputStream(mPool, 8);
+        NativePooledByteBuffer sb2 = doWrite(os2, mData);
+        Assert.assertEquals(16, sb2.mBufRef.get().getSize());
+        assertArrayEquals(mData, getBytes(sb2), mData.length);
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(0, 0),
+                        16, new IntPair(1, 0),
+                        8, new IntPair(0, 1),
+                        4, new IntPair(0, 0)),
+                mStats.mBucketStats);
     }
-  }
-
-  private byte[] getBytes(NativePooledByteBuffer bb) {
-    byte[] bytes = new byte[bb.size()];
-    bb.mBufRef.get().read(0, bytes, 0, bytes.length);
-    return bytes;
-  }
-
-  @Test
-  public void testBasic_1() throws Exception {
-    NativePooledByteBufferOutputStream os1 = new NativePooledByteBufferOutputStream(mPool);
-    NativePooledByteBuffer sb1 = doWrite(os1, mData);
-    Assert.assertEquals(16, sb1.mBufRef.get().getSize());
-    assertArrayEquals(mData, getBytes(sb1), mData.length);
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(0, 0),
-            16, new IntPair(1, 0),
-            8, new IntPair(0, 1),
-            4, new IntPair(0, 1)),
-        mStats.mBucketStats);
-  }
-
-  @Test
-  public void testBasic_2() throws Exception {
-    NativePooledByteBufferOutputStream os2 = new NativePooledByteBufferOutputStream(mPool, 8);
-    NativePooledByteBuffer sb2 = doWrite(os2, mData);
-    Assert.assertEquals(16, sb2.mBufRef.get().getSize());
-    assertArrayEquals(mData, getBytes(sb2), mData.length);
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(0, 0),
-            16, new IntPair(1, 0),
-            8, new IntPair(0, 1),
-            4, new IntPair(0, 0)),
-        mStats.mBucketStats);
-  }
-
-  @Test
-  public void testBasic_3() throws Exception {
-    NativePooledByteBufferOutputStream os3 = new NativePooledByteBufferOutputStream(mPool, 16);
-    NativePooledByteBuffer sb3 = doWrite(os3, mData);
-    Assert.assertEquals(16, sb3.mBufRef.get().getSize());
-    assertArrayEquals(mData, getBytes(sb3), mData.length);
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(0, 0),
-            16, new IntPair(1, 0),
-            8, new IntPair(0, 0),
-            4, new IntPair(0, 0)),
-        mStats.mBucketStats);
-  }
-
-  @Test
-  public void testBasic_4() throws Exception {
-    NativePooledByteBufferOutputStream os4 = new NativePooledByteBufferOutputStream(mPool, 32);
-    NativePooledByteBuffer sb4 = doWrite(os4, mData);
-    Assert.assertEquals(32, sb4.mBufRef.get().getSize());
-    assertArrayEquals(mData, getBytes(sb4), mData.length);
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(1, 0),
-            16, new IntPair(0, 0),
-            8, new IntPair(0, 0),
-            4, new IntPair(0, 0)),
-        mStats.mBucketStats);
-  }
-
-  @Test
-  public void testClose() throws Exception {
-    NativePooledByteBufferOutputStream os = new NativePooledByteBufferOutputStream(mPool);
-    os.close();
-    mStats.refresh();
-    Assert.assertEquals(
-        ImmutableMap.of(
-            32, new IntPair(0, 0),
-            16, new IntPair(0, 0),
-            8, new IntPair(0, 0),
-            4, new IntPair(0, 1)),
-        mStats.mBucketStats);
-  }
-
-  @Test
-  public void testToByteBufException() throws Exception {
-    NativePooledByteBufferOutputStream os1 = new NativePooledByteBufferOutputStream(mPool);
-    os1.close();
-    try {
-      os1.toByteBuffer();
-      Assert.fail();
-    } catch (Exception e) {
-      // do nothing
+
+    @Test
+    public void testBasic_3() throws Exception {
+        NativePooledByteBufferOutputStream os3 = new NativePooledByteBufferOutputStream(mPool, 16);
+        NativePooledByteBuffer sb3 = doWrite(os3, mData);
+        Assert.assertEquals(16, sb3.mBufRef.get().getSize());
+        assertArrayEquals(mData, getBytes(sb3), mData.length);
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(0, 0),
+                        16, new IntPair(1, 0),
+                        8, new IntPair(0, 0),
+                        4, new IntPair(0, 0)),
+                mStats.mBucketStats);
+    }
+
+    @Test
+    public void testBasic_4() throws Exception {
+        NativePooledByteBufferOutputStream os4 = new NativePooledByteBufferOutputStream(mPool, 32);
+        NativePooledByteBuffer sb4 = doWrite(os4, mData);
+        Assert.assertEquals(32, sb4.mBufRef.get().getSize());
+        assertArrayEquals(mData, getBytes(sb4), mData.length);
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(1, 0),
+                        16, new IntPair(0, 0),
+                        8, new IntPair(0, 0),
+                        4, new IntPair(0, 0)),
+                mStats.mBucketStats);
+    }
+
+    @Test
+    public void testClose() throws Exception {
+        NativePooledByteBufferOutputStream os = new NativePooledByteBufferOutputStream(mPool);
+        os.close();
+        mStats.refresh();
+        Assert.assertEquals(
+                ImmutableMap.of(
+                        32, new IntPair(0, 0),
+                        16, new IntPair(0, 0),
+                        8, new IntPair(0, 0),
+                        4, new IntPair(0, 1)),
+                mStats.mBucketStats);
+    }
+
+    @Test
+    public void testToByteBufException() throws Exception {
+        NativePooledByteBufferOutputStream os1 = new NativePooledByteBufferOutputStream(mPool);
+        os1.close();
+        try {
+            os1.toByteBuffer();
+            Assert.fail();
+        } catch (Exception e) {
+            // do nothing
+        }
+    }
+
+    @Test
+    public void testWriteAfterToByteBuf() throws Exception {
+        NativePooledByteBufferOutputStream os1 = new NativePooledByteBufferOutputStream(mPool);
+        NativePooledByteBuffer buf1 = doWrite(os1, Arrays.copyOf(mData, 9));
+        NativePooledByteBuffer buf2 = doWrite(os1, Arrays.copyOf(mData, 3));
+        Assert.assertEquals(12, buf2.size());
+
+        final CloseableReference<NativeMemoryChunk> chunk = buf1.mBufRef;
+        Assert.assertEquals(3, chunk.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
+        os1.close();
+        buf1.close();
+        buf2.close();
+        Assert.assertEquals(0, chunk.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
     }
-  }
-
-  @Test
-  public void testWriteAfterToByteBuf() throws Exception {
-    NativePooledByteBufferOutputStream os1 = new NativePooledByteBufferOutputStream(mPool);
-    NativePooledByteBuffer buf1 = doWrite(os1, Arrays.copyOf(mData, 9));
-    NativePooledByteBuffer buf2 = doWrite(os1, Arrays.copyOf(mData, 3));
-    Assert.assertEquals(12, buf2.size());
-
-    final CloseableReference<NativeMemoryChunk> chunk = buf1.mBufRef;
-    Assert.assertEquals(3, chunk.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-    os1.close();
-    buf1.close();
-    buf2.close();
-    Assert.assertEquals(0, chunk.getUnderlyingReferenceTestOnly().getRefCountTestOnly());
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferTest.java
index f0857be9f..58017fab6 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/NativePooledByteBufferTest.java
@@ -29,85 +29,86 @@
  */
 @RunWith(WithTestDefaultsRunner.class)
 public class NativePooledByteBufferTest {
-  private static final byte[] BYTES = new byte[] {1, 4, 5, 0, 100, 34, 0, 1, -1, -1};
-  private static final int BUFFER_LENGTH = BYTES.length - 2;
-
-  @Mock public NativeMemoryChunkPool mPool;
-  private NativeMemoryChunk mChunk;
-  private NativePooledByteBuffer mPooledByteBuffer;
-
-  @Before
-  public void setUp() {
-    mChunk = new FakeNativeMemoryChunk(BYTES.length);
-    mChunk.write(0, BYTES, 0, BYTES.length);
-    mPool = mock(NativeMemoryChunkPool.class);
-    CloseableReference<NativeMemoryChunk> poolRef = CloseableReference.of(mChunk, mPool);
-    mPooledByteBuffer = new NativePooledByteBuffer(
-        poolRef,
-        BUFFER_LENGTH);
-    poolRef.close();
-  }
-
-  @Test
-  public void testBasic() throws Exception {
-    assertFalse(mPooledByteBuffer.isClosed());
-    assertSame(mChunk, mPooledByteBuffer.mBufRef.get());
-    assertEquals(BUFFER_LENGTH, mPooledByteBuffer.size());
-  }
-
-  @Test
-  public void testSimpleRead() {
-    for (int i = 0; i < 100; ++i) {
-      final int offset = i % BUFFER_LENGTH;
-      assertEquals(BYTES[offset], mPooledByteBuffer.read(offset));
+    private static final byte[] BYTES = new byte[]{1, 4, 5, 0, 100, 34, 0, 1, -1, -1};
+    private static final int BUFFER_LENGTH = BYTES.length - 2;
+
+    @Mock
+    public NativeMemoryChunkPool mPool;
+    private NativeMemoryChunk mChunk;
+    private NativePooledByteBuffer mPooledByteBuffer;
+
+    @Before
+    public void setUp() {
+        mChunk = new FakeNativeMemoryChunk(BYTES.length);
+        mChunk.write(0, BYTES, 0, BYTES.length);
+        mPool = mock(NativeMemoryChunkPool.class);
+        CloseableReference<NativeMemoryChunk> poolRef = CloseableReference.of(mChunk, mPool);
+        mPooledByteBuffer = new NativePooledByteBuffer(
+                poolRef,
+                BUFFER_LENGTH);
+        poolRef.close();
     }
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testSimpleReadOutOfBounds() {
-    mPooledByteBuffer.read(BUFFER_LENGTH);
-  }
-
-  @Test
-  public void testRangeRead() {
-    byte[] readBuf = new byte[BUFFER_LENGTH];
-    mPooledByteBuffer.read(1, readBuf, 1, BUFFER_LENGTH - 2);
-    assertEquals(0, readBuf[0]);
-    assertEquals(0, readBuf[BUFFER_LENGTH - 1]);
-    for (int i = 1; i < BUFFER_LENGTH - 1; ++i) {
-      assertEquals(BYTES[i], readBuf[i]);
+
+    @Test
+    public void testBasic() throws Exception {
+        assertFalse(mPooledByteBuffer.isClosed());
+        assertSame(mChunk, mPooledByteBuffer.mBufRef.get());
+        assertEquals(BUFFER_LENGTH, mPooledByteBuffer.size());
+    }
+
+    @Test
+    public void testSimpleRead() {
+        for (int i = 0; i < 100; ++i) {
+            final int offset = i % BUFFER_LENGTH;
+            assertEquals(BYTES[offset], mPooledByteBuffer.read(offset));
+        }
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testSimpleReadOutOfBounds() {
+        mPooledByteBuffer.read(BUFFER_LENGTH);
+    }
+
+    @Test
+    public void testRangeRead() {
+        byte[] readBuf = new byte[BUFFER_LENGTH];
+        mPooledByteBuffer.read(1, readBuf, 1, BUFFER_LENGTH - 2);
+        assertEquals(0, readBuf[0]);
+        assertEquals(0, readBuf[BUFFER_LENGTH - 1]);
+        for (int i = 1; i < BUFFER_LENGTH - 1; ++i) {
+            assertEquals(BYTES[i], readBuf[i]);
+        }
     }
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testRangeReadOutOfBounds() {
-    byte[] readBuf = new byte[BUFFER_LENGTH];
-    mPooledByteBuffer.read(1, readBuf, 0, BUFFER_LENGTH);
-  }
-
-  @Test
-  public void testReadFromStream() throws Exception {
-    InputStream is = new PooledByteBufferInputStream(mPooledByteBuffer);
-    byte[] tmp = new byte[BUFFER_LENGTH + 1];
-    int bytesRead = is.read(tmp, 0, tmp.length);
-    assertEquals(BUFFER_LENGTH, bytesRead);
-    for (int i = 0; i < BUFFER_LENGTH; i++) {
-      assertEquals(BYTES[i], tmp[i]);
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testRangeReadOutOfBounds() {
+        byte[] readBuf = new byte[BUFFER_LENGTH];
+        mPooledByteBuffer.read(1, readBuf, 0, BUFFER_LENGTH);
+    }
+
+    @Test
+    public void testReadFromStream() throws Exception {
+        InputStream is = new PooledByteBufferInputStream(mPooledByteBuffer);
+        byte[] tmp = new byte[BUFFER_LENGTH + 1];
+        int bytesRead = is.read(tmp, 0, tmp.length);
+        assertEquals(BUFFER_LENGTH, bytesRead);
+        for (int i = 0; i < BUFFER_LENGTH; i++) {
+            assertEquals(BYTES[i], tmp[i]);
+        }
+        assertEquals(-1, is.read());
+    }
+
+    @Test
+    public void testClose() {
+        mPooledByteBuffer.close();
+        assertTrue(mPooledByteBuffer.isClosed());
+        assertNull(mPooledByteBuffer.mBufRef);
+        verify(mPool).release(mChunk);
+    }
+
+    @Test(expected = PooledByteBuffer.ClosedException.class)
+    public void testGettingSizeAfterClose() {
+        mPooledByteBuffer.close();
+        mPooledByteBuffer.size();
     }
-    assertEquals(-1, is.read());
-  }
-
-  @Test
-  public void testClose() {
-    mPooledByteBuffer.close();
-    assertTrue(mPooledByteBuffer.isClosed());
-    assertNull(mPooledByteBuffer.mBufRef);
-    verify(mPool).release(mChunk);
-  }
-
-  @Test(expected = PooledByteBuffer.ClosedException.class)
-  public void testGettingSizeAfterClose() {
-    mPooledByteBuffer.close();
-    mPooledByteBuffer.size();
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PoolStats.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PoolStats.java
index dc910eb0b..c22212b1f 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PoolStats.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PoolStats.java
@@ -15,47 +15,47 @@
 
 /**
  * Helper class to get pool stats
-*/
+ */
 public class PoolStats<V> {
-  public BasePool<V> mPool;
-
-  public int mUsedBytes;
-  public int mUsedCount;
-  public int mFreeBytes;
-  public int mFreeCount;
-
-  Map<Integer, IntPair> mBucketStats;
-
-  public PoolStats(BasePool<V> pool) {
-    mPool = pool;
-    mBucketStats = Maps.newHashMap();
-  }
-
-  public void setPool(BasePool<V> pool) {
-    mPool = pool;
-  }
-
-  /**
-   * Refresh all pool stats
-   */
-  public void refresh() {
-    refreshBasic();
-    refreshBucketStats();
-  }
-
-  public void refreshBasic() {
-    mUsedBytes = mPool.mUsed.mNumBytes;
-    mUsedCount = mPool.mUsed.mCount;
-    mFreeBytes = mPool.mFree.mNumBytes;
-    mFreeCount = mPool.mFree.mCount;
-  }
-
-  public void refreshBucketStats() {
-    mBucketStats.clear();
-    for (int i = 0; i < mPool.mBuckets.size(); ++i) {
-      final int bucketedSize = mPool.mBuckets.keyAt(i);
-      final Bucket<V> bucket = mPool.mBuckets.valueAt(i);
-      mBucketStats.put(bucketedSize, new IntPair(bucket.mInUseLength, bucket.mFreeList.size()));
+    public BasePool<V> mPool;
+
+    public int mUsedBytes;
+    public int mUsedCount;
+    public int mFreeBytes;
+    public int mFreeCount;
+
+    Map<Integer, IntPair> mBucketStats;
+
+    public PoolStats(BasePool<V> pool) {
+        mPool = pool;
+        mBucketStats = Maps.newHashMap();
+    }
+
+    public void setPool(BasePool<V> pool) {
+        mPool = pool;
+    }
+
+    /**
+     * Refresh all pool stats
+     */
+    public void refresh() {
+        refreshBasic();
+        refreshBucketStats();
+    }
+
+    public void refreshBasic() {
+        mUsedBytes = mPool.mUsed.mNumBytes;
+        mUsedCount = mPool.mUsed.mCount;
+        mFreeBytes = mPool.mFree.mNumBytes;
+        mFreeCount = mPool.mFree.mCount;
+    }
+
+    public void refreshBucketStats() {
+        mBucketStats.clear();
+        for (int i = 0; i < mPool.mBuckets.size(); ++i) {
+            final int bucketedSize = mPool.mBuckets.keyAt(i);
+            final Bucket<V> bucket = mPool.mBuckets.valueAt(i);
+            mBucketStats.put(bucketedSize, new IntPair(bucket.mInUseLength, bucket.mFreeList.size()));
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStreamTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStreamTest.java
index b6bed7aa6..f5d5b8e54 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStreamTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteArrayBufferedInputStreamTest.java
@@ -29,144 +29,144 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class PooledByteArrayBufferedInputStreamTest {
 
-  private ResourceReleaser mResourceReleaser;
-  private byte[] mBuffer;
-  private PooledByteArrayBufferedInputStream mPooledByteArrayBufferedInputStream;
-
-  @Before
-  public void setUp() {
-    mResourceReleaser = mock(ResourceReleaser.class);
-    final byte[] bytes = new byte[256];
-    for (int i = 0; i < 256; ++i) {
-      bytes[i] = (byte) i;
+    private ResourceReleaser mResourceReleaser;
+    private byte[] mBuffer;
+    private PooledByteArrayBufferedInputStream mPooledByteArrayBufferedInputStream;
+
+    @Before
+    public void setUp() {
+        mResourceReleaser = mock(ResourceReleaser.class);
+        final byte[] bytes = new byte[256];
+        for (int i = 0; i < 256; ++i) {
+            bytes[i] = (byte) i;
+        }
+        InputStream unbufferedStream = new ByteArrayInputStream(bytes);
+        mBuffer = new byte[10];
+        mPooledByteArrayBufferedInputStream = new PooledByteArrayBufferedInputStream(
+                unbufferedStream,
+                mBuffer,
+                mResourceReleaser);
     }
-    InputStream unbufferedStream = new ByteArrayInputStream(bytes);
-    mBuffer = new byte[10];
-    mPooledByteArrayBufferedInputStream = new PooledByteArrayBufferedInputStream(
-        unbufferedStream,
-        mBuffer,
-        mResourceReleaser);
-  }
-
-  @Test
-  public void testSingleByteRead() throws IOException {
-    for (int i = 0; i < 256; ++i) {
-      assertEquals(i, mPooledByteArrayBufferedInputStream.read());
+
+    @Test
+    public void testSingleByteRead() throws IOException {
+        for (int i = 0; i < 256; ++i) {
+            assertEquals(i, mPooledByteArrayBufferedInputStream.read());
+        }
+        assertEquals(-1, mPooledByteArrayBufferedInputStream.read());
+    }
+
+    @Test
+    public void testReleaseOnClose() throws IOException {
+        mPooledByteArrayBufferedInputStream.close();
+        verify(mResourceReleaser).release(mBuffer);
+        mPooledByteArrayBufferedInputStream.close();
+        // we do not expect second close to release resource again,
+        // the one checked bellow is the one that happened when close was called for the first time
+        verify(mResourceReleaser).release(any(byte[].class));
     }
-    assertEquals(-1, mPooledByteArrayBufferedInputStream.read());
-  }
-
-  @Test
-  public void testReleaseOnClose() throws IOException {
-    mPooledByteArrayBufferedInputStream.close();
-    verify(mResourceReleaser).release(mBuffer);
-    mPooledByteArrayBufferedInputStream.close();
-    // we do not expect second close to release resource again,
-    // the one checked bellow is the one that happened when close was called for the first time
-    verify(mResourceReleaser).release(any(byte[].class));
-  }
-
-  @Test
-  public void testSkip() throws IOException {
-    // buffer some data
-    mPooledByteArrayBufferedInputStream.read();
-    assertEquals(99, mPooledByteArrayBufferedInputStream.skip(99));
-    assertEquals(100, mPooledByteArrayBufferedInputStream.read());
-  }
-
-  @Test
-  public void testSkip2() throws IOException {
-    int i = 0;
-    while (i < 256) {
-      assertEquals(i, mPooledByteArrayBufferedInputStream.read());
-      i += mPooledByteArrayBufferedInputStream.skip(7) + 1;
+
+    @Test
+    public void testSkip() throws IOException {
+        // buffer some data
+        mPooledByteArrayBufferedInputStream.read();
+        assertEquals(99, mPooledByteArrayBufferedInputStream.skip(99));
+        assertEquals(100, mPooledByteArrayBufferedInputStream.read());
+    }
+
+    @Test
+    public void testSkip2() throws IOException {
+        int i = 0;
+        while (i < 256) {
+            assertEquals(i, mPooledByteArrayBufferedInputStream.read());
+            i += mPooledByteArrayBufferedInputStream.skip(7) + 1;
+        }
     }
-  }
-
-  @Test
-  public void testMark() {
-    assertFalse(mPooledByteArrayBufferedInputStream.markSupported());
-  }
-
-  @Test
-  public void testReadWithByteArray() throws IOException {
-    byte[] readBuffer = new byte[5];
-    assertEquals(5, mPooledByteArrayBufferedInputStream.read(readBuffer));
-    assertFilledWithConsecutiveBytes(readBuffer, 0, 5, 0);
-  }
-
-  @Test
-  public void testNonFullRead() throws IOException {
-    byte[] readBuffer = new byte[200];
-    assertEquals(10, mPooledByteArrayBufferedInputStream.read(readBuffer));
-    assertFilledWithConsecutiveBytes(readBuffer, 0, 10, 0);
-    assertFilledWithZeros(readBuffer, 10, 200);
-  }
-
-  @Test
-  public void testNonFullReadWithOffset() throws IOException {
-    byte[] readBuffer = new byte[200];
-    assertEquals(10, mPooledByteArrayBufferedInputStream.read(readBuffer, 45, 75));
-    assertFilledWithZeros(readBuffer, 0, 45);
-    assertFilledWithConsecutiveBytes(readBuffer, 45, 55, 0);
-    assertFilledWithZeros(readBuffer, 55, 200);
-  }
-
-  @Test
- public void testReadsCombined() throws IOException {
-    byte[] readBuffer = new byte[5];
-    int i = 0;
-    while (i <= 245) {
-      assertEquals(i, mPooledByteArrayBufferedInputStream.read());
-
-      assertEquals(5, mPooledByteArrayBufferedInputStream.read(readBuffer));
-      assertFilledWithConsecutiveBytes(readBuffer, 0, readBuffer.length, i + 1);
-
-      assertEquals(3, mPooledByteArrayBufferedInputStream.read(readBuffer, 1, 3));
-      assertEquals((byte) (i + 1), readBuffer[0]);
-      assertFilledWithConsecutiveBytes(readBuffer, 1, 4, i + 6);
-      assertEquals((byte) (i + 5), readBuffer[4]);
-
-      assertEquals(2, mPooledByteArrayBufferedInputStream.skip(2));
-
-      i += 11;
+
+    @Test
+    public void testMark() {
+        assertFalse(mPooledByteArrayBufferedInputStream.markSupported());
+    }
+
+    @Test
+    public void testReadWithByteArray() throws IOException {
+        byte[] readBuffer = new byte[5];
+        assertEquals(5, mPooledByteArrayBufferedInputStream.read(readBuffer));
+        assertFilledWithConsecutiveBytes(readBuffer, 0, 5, 0);
+    }
+
+    @Test
+    public void testNonFullRead() throws IOException {
+        byte[] readBuffer = new byte[200];
+        assertEquals(10, mPooledByteArrayBufferedInputStream.read(readBuffer));
+        assertFilledWithConsecutiveBytes(readBuffer, 0, 10, 0);
+        assertFilledWithZeros(readBuffer, 10, 200);
     }
 
-    assertEquals(256 - i, mPooledByteArrayBufferedInputStream.available());
-  }
-
-  /**
-   * Given byte array, asserts that bytes in [startOffset, endOffset) range are all zeroed;
-   *
-   * @param byteArray
-   * @param startOffset
-   * @param endOffset
-   */
-  private static void assertFilledWithZeros(
-      final byte[] byteArray,
-      final int startOffset,
-      final int endOffset) {
-    for (int i = startOffset; i < endOffset; ++i) {
-      assertEquals(0, byteArray[i]);
+    @Test
+    public void testNonFullReadWithOffset() throws IOException {
+        byte[] readBuffer = new byte[200];
+        assertEquals(10, mPooledByteArrayBufferedInputStream.read(readBuffer, 45, 75));
+        assertFilledWithZeros(readBuffer, 0, 45);
+        assertFilledWithConsecutiveBytes(readBuffer, 45, 55, 0);
+        assertFilledWithZeros(readBuffer, 55, 200);
     }
-  }
-
-  /**
-   * Given byte array, asserts that each byte in (startOffset, endOffset) range has value equal
-   * to value of previous byte plus one (mod 255) and byteArray[startOffset] is equal to firstByte.
-   *
-   * @param byteArray
-   * @param startOffset
-   * @param endOffset
-   * @param firstByte
-   */
-  private static void assertFilledWithConsecutiveBytes(
-      final byte[] byteArray,
-      final int startOffset,
-      final int endOffset,
-      int firstByte) {
-    for (int i = startOffset; i < endOffset; ++i) {
-      assertEquals((byte) firstByte++, byteArray[i]);
+
+    @Test
+    public void testReadsCombined() throws IOException {
+        byte[] readBuffer = new byte[5];
+        int i = 0;
+        while (i <= 245) {
+            assertEquals(i, mPooledByteArrayBufferedInputStream.read());
+
+            assertEquals(5, mPooledByteArrayBufferedInputStream.read(readBuffer));
+            assertFilledWithConsecutiveBytes(readBuffer, 0, readBuffer.length, i + 1);
+
+            assertEquals(3, mPooledByteArrayBufferedInputStream.read(readBuffer, 1, 3));
+            assertEquals((byte) (i + 1), readBuffer[0]);
+            assertFilledWithConsecutiveBytes(readBuffer, 1, 4, i + 6);
+            assertEquals((byte) (i + 5), readBuffer[4]);
+
+            assertEquals(2, mPooledByteArrayBufferedInputStream.skip(2));
+
+            i += 11;
+        }
+
+        assertEquals(256 - i, mPooledByteArrayBufferedInputStream.available());
+    }
+
+    /**
+     * Given byte array, asserts that bytes in [startOffset, endOffset) range are all zeroed;
+     *
+     * @param byteArray
+     * @param startOffset
+     * @param endOffset
+     */
+    private static void assertFilledWithZeros(
+            final byte[] byteArray,
+            final int startOffset,
+            final int endOffset) {
+        for (int i = startOffset; i < endOffset; ++i) {
+            assertEquals(0, byteArray[i]);
+        }
+    }
+
+    /**
+     * Given byte array, asserts that each byte in (startOffset, endOffset) range has value equal
+     * to value of previous byte plus one (mod 255) and byteArray[startOffset] is equal to firstByte.
+     *
+     * @param byteArray
+     * @param startOffset
+     * @param endOffset
+     * @param firstByte
+     */
+    private static void assertFilledWithConsecutiveBytes(
+            final byte[] byteArray,
+            final int startOffset,
+            final int endOffset,
+            int firstByte) {
+        for (int i = startOffset; i < endOffset; ++i) {
+            assertEquals((byte) firstByte++, byteArray[i]);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStreamTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStreamTest.java
index 4d59e952d..8ec93dd0c 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStreamTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteBufferInputStreamTest.java
@@ -23,138 +23,138 @@
  */
 @RunWith(WithTestDefaultsRunner.class)
 public class PooledByteBufferInputStreamTest {
-  private static final byte[] BYTES = new byte[] {1, 123, -20, 3, 6, 23, 1};
-  private PooledByteBufferInputStream mStream;
-
-  @Before
-  public void setup() {
-    PooledByteBuffer buffer = new TrivialPooledByteBuffer(BYTES);
-    mStream = new PooledByteBufferInputStream(buffer);
-  }
-
-  @Test
-  public void testBasic() {
-    assertEquals(0, mStream.mOffset);
-    assertEquals(0, mStream.mMark);
-    assertEquals(BYTES.length, mStream.available());
-    assertTrue(mStream.markSupported());
-  }
-
-  @Test
-  public void testMark() {
-    mStream.skip(2);
-    mStream.mark(0);
-    assertEquals(2, mStream.mMark);
-    mStream.read();
-    assertEquals(2, mStream.mMark);
-    mStream.mark(0);
-    assertEquals(3, mStream.mMark);
-  }
-
-  @Test
-  public void testReset() {
-    mStream.skip(2);
-    mStream.reset();
-    assertEquals(0, mStream.mOffset);
-  }
-
-  @Test
-  public void testAvailable() {
-    assertEquals(BYTES.length, mStream.available());
-    mStream.skip(3);
-    assertEquals(BYTES.length - 3, mStream.available());
-    mStream.skip(BYTES.length);
-    assertEquals(0, mStream.available());
-  }
-
-  @Test
-  public void testSkip() {
-    assertEquals(2, mStream.skip(2));
-    assertEquals(2, mStream.mOffset);
-
-    assertEquals(3, mStream.skip(3));
-    assertEquals(5, mStream.mOffset);
-
-    assertEquals(BYTES.length - 5, mStream.skip(BYTES.length));
-    assertEquals(0, mStream.skip(BYTES.length));
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testSkipNegative() {
-    mStream.skip(-4);
-  }
-
-  @Test(expected = ArrayIndexOutOfBoundsException.class)
-  public void testReadWithErrors() {
-    mStream.read(new byte[64], 10, 55);
-  }
-
-  @Test
-  public void testRead_SingleByte() {
-    for (int i = 0; i < BYTES.length; ++i) {
-      assertEquals(((int) BYTES[i]) & 0xFF, mStream.read());
+    private static final byte[] BYTES = new byte[]{1, 123, -20, 3, 6, 23, 1};
+    private PooledByteBufferInputStream mStream;
+
+    @Before
+    public void setup() {
+        PooledByteBuffer buffer = new TrivialPooledByteBuffer(BYTES);
+        mStream = new PooledByteBufferInputStream(buffer);
+    }
+
+    @Test
+    public void testBasic() {
+        assertEquals(0, mStream.mOffset);
+        assertEquals(0, mStream.mMark);
+        assertEquals(BYTES.length, mStream.available());
+        assertTrue(mStream.markSupported());
+    }
+
+    @Test
+    public void testMark() {
+        mStream.skip(2);
+        mStream.mark(0);
+        assertEquals(2, mStream.mMark);
+        mStream.read();
+        assertEquals(2, mStream.mMark);
+        mStream.mark(0);
+        assertEquals(3, mStream.mMark);
+    }
+
+    @Test
+    public void testReset() {
+        mStream.skip(2);
+        mStream.reset();
+        assertEquals(0, mStream.mOffset);
     }
-    assertEquals(-1, mStream.read());
-  }
 
-  @Test
-  public void testRead_ToByteArray() {
-    byte[] buf = new byte[64];
+    @Test
+    public void testAvailable() {
+        assertEquals(BYTES.length, mStream.available());
+        mStream.skip(3);
+        assertEquals(BYTES.length - 3, mStream.available());
+        mStream.skip(BYTES.length);
+        assertEquals(0, mStream.available());
+    }
 
-    assertEquals(0, mStream.read(buf, 0, 0));
-    assertEquals(0, mStream.mOffset);
+    @Test
+    public void testSkip() {
+        assertEquals(2, mStream.skip(2));
+        assertEquals(2, mStream.mOffset);
+
+        assertEquals(3, mStream.skip(3));
+        assertEquals(5, mStream.mOffset);
+
+        assertEquals(BYTES.length - 5, mStream.skip(BYTES.length));
+        assertEquals(0, mStream.skip(BYTES.length));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testSkipNegative() {
+        mStream.skip(-4);
+    }
+
+    @Test(expected = ArrayIndexOutOfBoundsException.class)
+    public void testReadWithErrors() {
+        mStream.read(new byte[64], 10, 55);
+    }
+
+    @Test
+    public void testRead_SingleByte() {
+        for (int i = 0; i < BYTES.length; ++i) {
+            assertEquals(((int) BYTES[i]) & 0xFF, mStream.read());
+        }
+        assertEquals(-1, mStream.read());
+    }
+
+    @Test
+    public void testRead_ToByteArray() {
+        byte[] buf = new byte[64];
+
+        assertEquals(0, mStream.read(buf, 0, 0));
+        assertEquals(0, mStream.mOffset);
+
+        assertEquals(3, mStream.read(buf, 0, 3));
+        assertEquals(3, mStream.mOffset);
+        assertArrayEquals(BYTES, buf, 3);
+        for (int i = 3; i < buf.length; ++i) {
+            assertEquals(0, buf[i]);
+        }
+
+        int available = BYTES.length - mStream.mOffset;
+        assertEquals(available, mStream.read(buf, 3, available + 1));
+        assertEquals(BYTES.length, mStream.mOffset);
+        assertArrayEquals(BYTES, buf, available);
+
+        assertEquals(-1, mStream.read(buf, 0, 1));
+        assertEquals(BYTES.length, mStream.mOffset);
+    }
+
+    @Test
+    public void testRead_ToByteArray2() {
+        byte[] buf = new byte[BYTES.length + 10];
+        assertEquals(BYTES.length, mStream.read(buf));
+        assertArrayEquals(BYTES, buf, BYTES.length);
+    }
+
+    @Test
+    public void testRead_ToByteArray3() {
+        byte[] buf = new byte[BYTES.length - 1];
+        assertEquals(buf.length, mStream.read(buf));
+        assertEquals(buf.length, mStream.mOffset);
+        assertArrayEquals(BYTES, buf, buf.length);
+    }
+
+    @Test
+    public void testCreateEmptyStream() throws Exception {
+        PooledByteBufferInputStream is = new PooledByteBufferInputStream(
+                new TrivialPooledByteBuffer(new byte[]{}));
+        assertEquals(-1, is.read());
+    }
 
-    assertEquals(3, mStream.read(buf, 0, 3));
-    assertEquals(3, mStream.mOffset);
-    assertArrayEquals(BYTES, buf, 3);
-    for (int i = 3; i < buf.length; ++i) {
-      assertEquals(0, buf[i]);
+    @Test(expected = IllegalArgumentException.class)
+    public void testCreatingStreamAfterClose() {
+        PooledByteBuffer buffer = new TrivialPooledByteBuffer(new byte[]{});
+        buffer.close();
+        new PooledByteBufferInputStream(buffer);
     }
 
-    int available = BYTES.length - mStream.mOffset;
-    assertEquals(available, mStream.read(buf, 3, available + 1));
-    assertEquals(BYTES.length, mStream.mOffset);
-    assertArrayEquals(BYTES, buf, available);
-
-    assertEquals(-1, mStream.read(buf, 0, 1));
-    assertEquals(BYTES.length, mStream.mOffset);
-  }
-
-  @Test
-  public void testRead_ToByteArray2() {
-    byte[] buf = new byte[BYTES.length + 10];
-    assertEquals(BYTES.length, mStream.read(buf));
-    assertArrayEquals(BYTES, buf, BYTES.length);
-  }
-
-  @Test
-  public void testRead_ToByteArray3() {
-    byte[] buf = new byte[BYTES.length -1];
-    assertEquals(buf.length, mStream.read(buf));
-    assertEquals(buf.length, mStream.mOffset);
-    assertArrayEquals(BYTES, buf, buf.length);
-  }
-
-  @Test
-  public void testCreateEmptyStream() throws Exception {
-    PooledByteBufferInputStream is = new PooledByteBufferInputStream(
-        new TrivialPooledByteBuffer(new byte[] {}));
-    assertEquals(-1, is.read());
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testCreatingStreamAfterClose() {
-    PooledByteBuffer buffer = new TrivialPooledByteBuffer(new byte[] {});
-    buffer.close();
-    new PooledByteBufferInputStream(buffer);
-  }
-
-  // assert that the first 'length' bytes of expected are the same as those in 'actual'
-  private static void assertArrayEquals(byte[] expected, byte[] actual, int length) {
-    assertTrue(expected.length >= length);
-    assertTrue(actual.length >= length);
-    for (int i = 0; i < length; i++) {
-      assertEquals(expected[i], actual[i]);
+    // assert that the first 'length' bytes of expected are the same as those in 'actual'
+    private static void assertArrayEquals(byte[] expected, byte[] actual, int length) {
+        assertTrue(expected.length >= length);
+        assertTrue(actual.length >= length);
+        for (int i = 0; i < length; i++) {
+            assertEquals(expected[i], actual[i]);
+        }
     }
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteStreamsTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteStreamsTest.java
index d3f1e61fe..c9be37e0e 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteStreamsTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/PooledByteStreamsTest.java
@@ -29,84 +29,84 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(WithTestDefaultsRunner.class)
-public class PooledByteStreamsTest  {
-  private static final int POOLED_ARRAY_SIZE = 4;
-
-  private ByteArrayPool mByteArrayPool;
-  private byte[] mPooledArray;
-
-  private byte[] mData;
-  private InputStream mIs;
-  private ByteArrayOutputStream mOs;
-
-  private PooledByteStreams mPooledByteStreams;
-
-  @Before
-  public void setUp() {
-    mByteArrayPool = mock(ByteArrayPool.class);
-    mData = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 115};
-    mIs = new ByteArrayInputStream(mData);
-    mOs = new ByteArrayOutputStream();
-
-    mPooledArray = new byte[4];
-    mPooledByteStreams = new PooledByteStreams(mByteArrayPool, POOLED_ARRAY_SIZE);
-    when(mByteArrayPool.get(POOLED_ARRAY_SIZE)).thenReturn(mPooledArray);
-  }
-
-  @Test
-  public void testUsesPool() throws IOException {
-    mPooledByteStreams.copy(mIs, mOs);
-    verify(mByteArrayPool).get(POOLED_ARRAY_SIZE);
-    verify(mByteArrayPool).release(mPooledArray);
-  }
-
-  @Test
-  public void testReleasesOnException() throws IOException {
-    try {
-      mPooledByteStreams.copy(
-          mIs,
-          new OutputStream() {
-            @Override
-            public void write(int oneByte) throws IOException {
-              throw new IOException();
-            }
-          });
-      fail();
-    } catch (IOException ioe) {
-      // expected
+public class PooledByteStreamsTest {
+    private static final int POOLED_ARRAY_SIZE = 4;
+
+    private ByteArrayPool mByteArrayPool;
+    private byte[] mPooledArray;
+
+    private byte[] mData;
+    private InputStream mIs;
+    private ByteArrayOutputStream mOs;
+
+    private PooledByteStreams mPooledByteStreams;
+
+    @Before
+    public void setUp() {
+        mByteArrayPool = mock(ByteArrayPool.class);
+        mData = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 115};
+        mIs = new ByteArrayInputStream(mData);
+        mOs = new ByteArrayOutputStream();
+
+        mPooledArray = new byte[4];
+        mPooledByteStreams = new PooledByteStreams(mByteArrayPool, POOLED_ARRAY_SIZE);
+        when(mByteArrayPool.get(POOLED_ARRAY_SIZE)).thenReturn(mPooledArray);
     }
 
-    verify(mByteArrayPool).release(mPooledArray);
-  }
-
-  @Test
-  public void testCopiesData() throws IOException {
-    mPooledByteStreams.copy(mIs, mOs);
-    assertArrayEquals(mData, mOs.toByteArray());
-  }
-
-  @Test
-  public void testReleasesOnExceptionWithSize() throws IOException {
-    try {
-      mPooledByteStreams.copy(
-          mIs,
-          new OutputStream() {
-            @Override
-            public void write(int oneByte) throws IOException {
-              throw new IOException();
-            }
-          }, 3);
-      fail();
-    } catch (IOException ioe) {
-      // expected
+    @Test
+    public void testUsesPool() throws IOException {
+        mPooledByteStreams.copy(mIs, mOs);
+        verify(mByteArrayPool).get(POOLED_ARRAY_SIZE);
+        verify(mByteArrayPool).release(mPooledArray);
     }
 
-    verify(mByteArrayPool).release(mPooledArray);
-  }
+    @Test
+    public void testReleasesOnException() throws IOException {
+        try {
+            mPooledByteStreams.copy(
+                    mIs,
+                    new OutputStream() {
+                        @Override
+                        public void write(int oneByte) throws IOException {
+                            throw new IOException();
+                        }
+                    });
+            fail();
+        } catch (IOException ioe) {
+            // expected
+        }
+
+        verify(mByteArrayPool).release(mPooledArray);
+    }
 
-  @Test
-  public void testCopiesDataWithSize() throws IOException {
-    mPooledByteStreams.copy(mIs, mOs, 3);
-    assertArrayEquals(Arrays.copyOf(mData, 3), mOs.toByteArray());
-  }
+    @Test
+    public void testCopiesData() throws IOException {
+        mPooledByteStreams.copy(mIs, mOs);
+        assertArrayEquals(mData, mOs.toByteArray());
+    }
+
+    @Test
+    public void testReleasesOnExceptionWithSize() throws IOException {
+        try {
+            mPooledByteStreams.copy(
+                    mIs,
+                    new OutputStream() {
+                        @Override
+                        public void write(int oneByte) throws IOException {
+                            throw new IOException();
+                        }
+                    }, 3);
+            fail();
+        } catch (IOException ioe) {
+            // expected
+        }
+
+        verify(mByteArrayPool).release(mPooledArray);
+    }
+
+    @Test
+    public void testCopiesDataWithSize() throws IOException {
+        mPooledByteStreams.copy(mIs, mOs, 3);
+        assertArrayEquals(Arrays.copyOf(mData, 3), mOs.toByteArray());
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/SharedByteArrayTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/SharedByteArrayTest.java
index f614d43c0..c36e33454 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/SharedByteArrayTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/memory/SharedByteArrayTest.java
@@ -27,88 +27,88 @@
 @RunWith(WithTestDefaultsRunner.class)
 public class SharedByteArrayTest {
 
-  private SharedByteArray mArray;
-
-  @Before
-  public void setup() {
-    mArray = new SharedByteArray(
-        mock(MemoryTrimmableRegistry.class),
-        new PoolParams(
-            Integer.MAX_VALUE,
-            Integer.MAX_VALUE,
-            null,
-            4,
-            16));
-  }
-
-  @Test
-  public void testBasic() throws Exception {
-    assertEquals(4, mArray.mMinByteArraySize);
-    assertEquals(16, mArray.mMaxByteArraySize);
-    assertNull(mArray.mByteArraySoftRef.get());
-    assertEquals(1, mArray.mSemaphore.availablePermits());
-  }
-
-  @Test
-  public void testGet() throws Exception {
-    CloseableReference<byte[]> arrayRef = mArray.get(1);
-    assertSame(mArray.mByteArraySoftRef.get(), arrayRef.get());
-    assertEquals(4, arrayRef.get().length);
-    assertEquals(0, mArray.mSemaphore.availablePermits());
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testGetTooBigArray() {
-    mArray.get(32);
-  }
-
-  @Test
-  public void testRelease() throws Exception {
-    mArray.get(4).close();
-    assertEquals(1, mArray.mSemaphore.availablePermits());
-  }
-
-  @Test
-  public void testGet_Realloc() {
-    CloseableReference<byte[]> arrayRef = mArray.get(1);
-    final byte[] smallArray = arrayRef.get();
-    arrayRef.close();
-
-    arrayRef = mArray.get(7);
-    assertEquals(8, arrayRef.get().length);
-    assertSame(mArray.mByteArraySoftRef.get(), arrayRef.get());
-    assertNotSame(smallArray, arrayRef.get());
-  }
-
-  @Test
-  public void testTrim() {
-    mArray.get(7).close();
-    assertEquals(8, mArray.mByteArraySoftRef.get().length);
-
-    // now trim, and verify again
-    mArray.trim(MemoryTrimType.OnCloseToDalvikHeapLimit);
-    assertNull(mArray.mByteArraySoftRef.get());
-    assertEquals(1, mArray.mSemaphore.availablePermits());
-  }
-
-  @Test
-  public void testTrimUnsuccessful() {
-    CloseableReference<byte[]> arrayRef = mArray.get(7);
-    mArray.trim(MemoryTrimType.OnCloseToDalvikHeapLimit);
-    assertSame(arrayRef.get(), mArray.mByteArraySoftRef.get());
-    assertEquals(0, mArray.mSemaphore.availablePermits());
-  }
-
-  @Test
-  public void testGetBucketedSize() throws Exception {
-    assertEquals(4, mArray.getBucketedSize(1));
-    assertEquals(4, mArray.getBucketedSize(2));
-    assertEquals(4, mArray.getBucketedSize(3));
-    assertEquals(4, mArray.getBucketedSize(4));
-    assertEquals(8, mArray.getBucketedSize(5));
-    assertEquals(8, mArray.getBucketedSize(6));
-    assertEquals(8, mArray.getBucketedSize(7));
-    assertEquals(8, mArray.getBucketedSize(8));
-    assertEquals(16, mArray.getBucketedSize(9));
-  }
+    private SharedByteArray mArray;
+
+    @Before
+    public void setup() {
+        mArray = new SharedByteArray(
+                mock(MemoryTrimmableRegistry.class),
+                new PoolParams(
+                        Integer.MAX_VALUE,
+                        Integer.MAX_VALUE,
+                        null,
+                        4,
+                        16));
+    }
+
+    @Test
+    public void testBasic() throws Exception {
+        assertEquals(4, mArray.mMinByteArraySize);
+        assertEquals(16, mArray.mMaxByteArraySize);
+        assertNull(mArray.mByteArraySoftRef.get());
+        assertEquals(1, mArray.mSemaphore.availablePermits());
+    }
+
+    @Test
+    public void testGet() throws Exception {
+        CloseableReference<byte[]> arrayRef = mArray.get(1);
+        assertSame(mArray.mByteArraySoftRef.get(), arrayRef.get());
+        assertEquals(4, arrayRef.get().length);
+        assertEquals(0, mArray.mSemaphore.availablePermits());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testGetTooBigArray() {
+        mArray.get(32);
+    }
+
+    @Test
+    public void testRelease() throws Exception {
+        mArray.get(4).close();
+        assertEquals(1, mArray.mSemaphore.availablePermits());
+    }
+
+    @Test
+    public void testGet_Realloc() {
+        CloseableReference<byte[]> arrayRef = mArray.get(1);
+        final byte[] smallArray = arrayRef.get();
+        arrayRef.close();
+
+        arrayRef = mArray.get(7);
+        assertEquals(8, arrayRef.get().length);
+        assertSame(mArray.mByteArraySoftRef.get(), arrayRef.get());
+        assertNotSame(smallArray, arrayRef.get());
+    }
+
+    @Test
+    public void testTrim() {
+        mArray.get(7).close();
+        assertEquals(8, mArray.mByteArraySoftRef.get().length);
+
+        // now trim, and verify again
+        mArray.trim(MemoryTrimType.OnCloseToDalvikHeapLimit);
+        assertNull(mArray.mByteArraySoftRef.get());
+        assertEquals(1, mArray.mSemaphore.availablePermits());
+    }
+
+    @Test
+    public void testTrimUnsuccessful() {
+        CloseableReference<byte[]> arrayRef = mArray.get(7);
+        mArray.trim(MemoryTrimType.OnCloseToDalvikHeapLimit);
+        assertSame(arrayRef.get(), mArray.mByteArraySoftRef.get());
+        assertEquals(0, mArray.mSemaphore.availablePermits());
+    }
+
+    @Test
+    public void testGetBucketedSize() throws Exception {
+        assertEquals(4, mArray.getBucketedSize(1));
+        assertEquals(4, mArray.getBucketedSize(2));
+        assertEquals(4, mArray.getBucketedSize(3));
+        assertEquals(4, mArray.getBucketedSize(4));
+        assertEquals(8, mArray.getBucketedSize(5));
+        assertEquals(8, mArray.getBucketedSize(6));
+        assertEquals(8, mArray.getBucketedSize(7));
+        assertEquals(8, mArray.getBucketedSize(8));
+        assertEquals(16, mArray.getBucketedSize(9));
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/FakeNativeMemoryChunk.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/FakeNativeMemoryChunk.java
index 84a47c317..039b544a8 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/FakeNativeMemoryChunk.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/FakeNativeMemoryChunk.java
@@ -17,51 +17,51 @@
  * public interface
  */
 public class FakeNativeMemoryChunk extends NativeMemoryChunk {
-  private byte[] mBuf;
+    private byte[] mBuf;
 
-  public FakeNativeMemoryChunk(int bufSize) {
-    super();
-    mBuf = new byte[bufSize];
-  }
+    public FakeNativeMemoryChunk(int bufSize) {
+        super();
+        mBuf = new byte[bufSize];
+    }
 
-  @Override
-  public void close() {
-    mBuf = null;
-  }
+    @Override
+    public void close() {
+        mBuf = null;
+    }
 
-  @Override
-  public boolean isClosed() {
-    return mBuf == null;
-  }
+    @Override
+    public boolean isClosed() {
+        return mBuf == null;
+    }
 
-  @Override
-  public int getSize() {
-    return mBuf.length;
-  }
+    @Override
+    public int getSize() {
+        return mBuf.length;
+    }
 
-  @Override
-  public int write(int nativeMemoryOffset, byte[] byteArray, int byteArrayOffset, int count) {
-    int numToWrite = Math.min(count, mBuf.length - nativeMemoryOffset);
-    System.arraycopy(byteArray, byteArrayOffset, mBuf, nativeMemoryOffset, numToWrite);
-    return numToWrite;
-  }
+    @Override
+    public int write(int nativeMemoryOffset, byte[] byteArray, int byteArrayOffset, int count) {
+        int numToWrite = Math.min(count, mBuf.length - nativeMemoryOffset);
+        System.arraycopy(byteArray, byteArrayOffset, mBuf, nativeMemoryOffset, numToWrite);
+        return numToWrite;
+    }
 
-  @Override
-  public byte read(int nativeMemoryOffset) {
-    return mBuf[nativeMemoryOffset];
-  }
+    @Override
+    public byte read(int nativeMemoryOffset) {
+        return mBuf[nativeMemoryOffset];
+    }
 
-  @Override
-  public int read(int nativeMemoryOffset, byte[] byteArray, int byteArrayOffset, int count) {
-    int numToRead = Math.min(count, mBuf.length - nativeMemoryOffset);
-    System.arraycopy(mBuf, nativeMemoryOffset, byteArray, byteArrayOffset, numToRead);
-    return numToRead;
-  }
+    @Override
+    public int read(int nativeMemoryOffset, byte[] byteArray, int byteArrayOffset, int count) {
+        int numToRead = Math.min(count, mBuf.length - nativeMemoryOffset);
+        System.arraycopy(mBuf, nativeMemoryOffset, byteArray, byteArrayOffset, numToRead);
+        return numToRead;
+    }
 
-  @Override
-  public void copy(int offset, NativeMemoryChunk other, int otherOffset, int count) {
-    FakeNativeMemoryChunk that = (FakeNativeMemoryChunk)other;
-    int numToCopy = Math.min(count, mBuf.length - offset);
-    System.arraycopy(mBuf, offset, that.mBuf, otherOffset, numToCopy);
-  }
+    @Override
+    public void copy(int offset, NativeMemoryChunk other, int otherOffset, int count) {
+        FakeNativeMemoryChunk that = (FakeNativeMemoryChunk) other;
+        int numToCopy = Math.min(count, mBuf.length - offset);
+        System.arraycopy(mBuf, offset, that.mBuf, otherOffset, numToCopy);
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/FakeNativeMemoryChunkPool.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/FakeNativeMemoryChunkPool.java
index aed0a1807..ebc93fb3f 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/FakeNativeMemoryChunkPool.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/FakeNativeMemoryChunkPool.java
@@ -23,28 +23,28 @@
  * A 'fake' {@link NativeMemoryChunkPool} instance as a test helper
  */
 public class FakeNativeMemoryChunkPool extends NativeMemoryChunkPool {
-  public FakeNativeMemoryChunkPool() {
-    this(new PoolParams(128, getBucketSizes()));
-  }
-
-  public FakeNativeMemoryChunkPool(PoolParams poolParams) {
-    super(
-        mock(MemoryTrimmableRegistry.class),
-        poolParams,
-        mock(PoolStatsTracker.class));
-  }
-
-  @Override
-  protected NativeMemoryChunk alloc(int bucketedSize) {
-    return new FakeNativeMemoryChunk(bucketedSize);
-  }
-
-  private static SparseIntArray getBucketSizes() {
-    final SparseIntArray bucketSizes = new SparseIntArray();
-    bucketSizes.put(4, 10);
-    bucketSizes.put(8, 10);
-    bucketSizes.put(16, 10);
-    bucketSizes.put(32, 10);
-    return bucketSizes;
-  }
+    public FakeNativeMemoryChunkPool() {
+        this(new PoolParams(128, getBucketSizes()));
+    }
+
+    public FakeNativeMemoryChunkPool(PoolParams poolParams) {
+        super(
+                mock(MemoryTrimmableRegistry.class),
+                poolParams,
+                mock(PoolStatsTracker.class));
+    }
+
+    @Override
+    protected NativeMemoryChunk alloc(int bucketedSize) {
+        return new FakeNativeMemoryChunk(bucketedSize);
+    }
+
+    private static SparseIntArray getBucketSizes() {
+        final SparseIntArray bucketSizes = new SparseIntArray();
+        bucketSizes.put(4, 10);
+        bucketSizes.put(8, 10);
+        bucketSizes.put(16, 10);
+        bucketSizes.put(32, 10);
+        return bucketSizes;
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/MockBitmapFactory.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/MockBitmapFactory.java
index 1027a7d4e..764d15349 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/MockBitmapFactory.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/MockBitmapFactory.java
@@ -20,39 +20,39 @@
  * Helper class for creating bitmap mocks in tests.
  */
 public class MockBitmapFactory {
-  public static int DEFAULT_BITMAP_WIDTH = 3;
-  public static int DEFAULT_BITMAP_HEIGHT = 4;
-  public static int DEFAULT_BITMAP_PIXELS = DEFAULT_BITMAP_WIDTH * DEFAULT_BITMAP_HEIGHT;
-  public static int DEFAULT_BITMAP_SIZE = bitmapSize(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT);
-
-  public static Bitmap create() {
-    return create(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT);
-  }
-
-  public static Bitmap create(int width, int height) {
-    return create(width, height, Bitmaps.BITMAP_CONFIG);
-  }
-
-  public static Bitmap createForSize(int size) {
-    Preconditions.checkArgument(size % Bitmaps.BYTES_PER_PIXEL == 0);
-    return create(1, size / Bitmaps.BYTES_PER_PIXEL, Bitmaps.BITMAP_CONFIG);
-  }
-
-  public static Bitmap create(int width, int height, Bitmap.Config config) {
-    Preconditions.checkArgument(width > 0);
-    Preconditions.checkArgument(height > 0);
-    Preconditions.checkNotNull(config);
-    Bitmap bitmap = mock(Bitmap.class);
-    when(bitmap.getWidth()).thenReturn(width);
-    when(bitmap.getHeight()).thenReturn(height);
-    when(bitmap.getConfig()).thenReturn(config);
-    when(bitmap.isMutable()).thenReturn(true);
-    when(bitmap.getRowBytes()).thenReturn(width * Bitmaps.BYTES_PER_PIXEL);
-    when(bitmap.getByteCount()).thenReturn(bitmapSize(width, height));
-    return bitmap;
-  }
-
-  public static int bitmapSize(int width, int height) {
-    return width * height * Bitmaps.BYTES_PER_PIXEL;
-  }
+    public static int DEFAULT_BITMAP_WIDTH = 3;
+    public static int DEFAULT_BITMAP_HEIGHT = 4;
+    public static int DEFAULT_BITMAP_PIXELS = DEFAULT_BITMAP_WIDTH * DEFAULT_BITMAP_HEIGHT;
+    public static int DEFAULT_BITMAP_SIZE = bitmapSize(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT);
+
+    public static Bitmap create() {
+        return create(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT);
+    }
+
+    public static Bitmap create(int width, int height) {
+        return create(width, height, Bitmaps.BITMAP_CONFIG);
+    }
+
+    public static Bitmap createForSize(int size) {
+        Preconditions.checkArgument(size % Bitmaps.BYTES_PER_PIXEL == 0);
+        return create(1, size / Bitmaps.BYTES_PER_PIXEL, Bitmaps.BITMAP_CONFIG);
+    }
+
+    public static Bitmap create(int width, int height, Bitmap.Config config) {
+        Preconditions.checkArgument(width > 0);
+        Preconditions.checkArgument(height > 0);
+        Preconditions.checkNotNull(config);
+        Bitmap bitmap = mock(Bitmap.class);
+        when(bitmap.getWidth()).thenReturn(width);
+        when(bitmap.getHeight()).thenReturn(height);
+        when(bitmap.getConfig()).thenReturn(config);
+        when(bitmap.isMutable()).thenReturn(true);
+        when(bitmap.getRowBytes()).thenReturn(width * Bitmaps.BYTES_PER_PIXEL);
+        when(bitmap.getByteCount()).thenReturn(bitmapSize(width, height));
+        return bitmap;
+    }
+
+    public static int bitmapSize(int width, int height) {
+        return width * height * Bitmaps.BYTES_PER_PIXEL;
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TrivialPooledByteBuffer.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TrivialPooledByteBuffer.java
index af8f769e6..85d6a92d9 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TrivialPooledByteBuffer.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/testing/TrivialPooledByteBuffer.java
@@ -10,45 +10,45 @@
  * A trivial implementation of {@link PooledByteBuffer}
  */
 public class TrivialPooledByteBuffer implements PooledByteBuffer {
-  private byte[] mBuf;
-  private long mNativePtr;
-
-  public TrivialPooledByteBuffer(byte[] buf) {
-    this(buf, 0L);
-  }
-
-  public TrivialPooledByteBuffer(byte[] buf, long nativePtr) {
-    mBuf = buf;
-    mNativePtr = nativePtr;
-  }
-
-  @Override
-  public int size() {
-    return isClosed() ? -1 : mBuf.length;
-  }
-
-  @Override
-  public byte read(int offset) {
-    return mBuf[offset];
-  }
-
-  @Override
-  public void read(int offset, byte[] buffer, int bufferOffset, int length) {
-    System.arraycopy(mBuf, offset, buffer, bufferOffset, length);
-  }
-
-  @Override
-  public long getNativePtr() {
-    return mNativePtr;
-  }
-
-  @Override
-  public boolean isClosed() {
-    return mBuf == null;
-  }
-
-  @Override
-  public void close() {
-    mBuf = null;
-  }
+    private byte[] mBuf;
+    private long mNativePtr;
+
+    public TrivialPooledByteBuffer(byte[] buf) {
+        this(buf, 0L);
+    }
+
+    public TrivialPooledByteBuffer(byte[] buf, long nativePtr) {
+        mBuf = buf;
+        mNativePtr = nativePtr;
+    }
+
+    @Override
+    public int size() {
+        return isClosed() ? -1 : mBuf.length;
+    }
+
+    @Override
+    public byte read(int offset) {
+        return mBuf[offset];
+    }
+
+    @Override
+    public void read(int offset, byte[] buffer, int bufferOffset, int length) {
+        System.arraycopy(mBuf, offset, buffer, bufferOffset, length);
+    }
+
+    @Override
+    public long getNativePtr() {
+        return mNativePtr;
+    }
+
+    @Override
+    public boolean isClosed() {
+        return mBuf == null;
+    }
+
+    @Override
+    public void close() {
+        mBuf = null;
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imageutils/JfifTestUtils.java b/imagepipeline/src/test/java/com/facebook/imageutils/JfifTestUtils.java
index 4abbd47c3..08dc9f56f 100644
--- a/imagepipeline/src/test/java/com/facebook/imageutils/JfifTestUtils.java
+++ b/imagepipeline/src/test/java/com/facebook/imageutils/JfifTestUtils.java
@@ -19,109 +19,109 @@
  */
 public class JfifTestUtils {
 
-  // Markers
-  public static final String SOI = "FFD8";
-  public static final String DQT_MARKER = "FFDB";
-  public static final String DHT_MARKER = "FFC4";
-  public static final String DRI_MARKER = "FFDD";
-  public static final String SOF_MARKER = "FFC0";
-  public static final String SOS_MARKER = "FFDA";
-  public static final String EOI = "FFD9";
-  public static final String APP0_MARKER = "FFE0";
-  public static final String APP1_MARKER = "FFE1";
-  public static final String APP2_MARKER = "FFE2";
-
-  // Test blocks
-  public static final String DQT = DQT_MARKER + "0004 0000"; // content length 4
-  public static final String DHT = DHT_MARKER + "0006 0000 0000"; // content length 6
-  public static final String DRI = DRI_MARKER + "0004 0000"; // content length 4, optional
-  public static final String SOF = SOF_MARKER + "0006 0000 0000"; // content length 6
-  public static final String SOS = SOS_MARKER + "0004 0000"; // content length 4
-  public static final String APP0 = APP0_MARKER + "0004 0000"; // content length 4, optional
-  public static final String APP2 = APP2_MARKER + "0004 0000"; // content length 4, optional
-
-  // APP1 related headers and magic number.
-  public static final String APP1_EXIF_MAGIC = "4578 6966 0000";
-  public static final String TIFF_HEADER_LE = "4949 2A00 0800 0000";
-  public static final String TIFF_HEADER_BE = "4D4D 002A 0000 0008";
-  // IFD related content constant definition
-  public static final int IFD_ENTRY_ORI_TAG = 0x0112;
-  public static final int IFD_ENTRY_TAG_1 = 0x011A;
-  public static final int IFD_ENTRY_TAG_2 = 0x011B;
-  public static final int IFD_ENTRY_TAG_3 = 0x011C;
-  public static final int TYPE_SHORT = 3;
-
-  public static int numBytes(String data) {
-    return data.replaceAll(" ", "").length() / 2;
-  }
-
-  public static byte[] hexStringToByteArray(String s) {
-    String noSpaceString = s.replaceAll(" ", "");
-    byte[] data = Hex.decodeHex(noSpaceString);
-    return data;
-  }
-
-  public static String encodeInt2HexString(int value, int length, boolean littleEndian) {
-    StringBuffer sb = new StringBuffer();
-    for (int i = 0; i < length; i++) {
-      int oneByte = value & 0xFF;
-      if (littleEndian) {
-        sb.append(Hex.byte2Hex(oneByte));
-      } else {
-        sb.insert(0, Hex.byte2Hex(oneByte));
-      }
-      value = value >> 8;
+    // Markers
+    public static final String SOI = "FFD8";
+    public static final String DQT_MARKER = "FFDB";
+    public static final String DHT_MARKER = "FFC4";
+    public static final String DRI_MARKER = "FFDD";
+    public static final String SOF_MARKER = "FFC0";
+    public static final String SOS_MARKER = "FFDA";
+    public static final String EOI = "FFD9";
+    public static final String APP0_MARKER = "FFE0";
+    public static final String APP1_MARKER = "FFE1";
+    public static final String APP2_MARKER = "FFE2";
+
+    // Test blocks
+    public static final String DQT = DQT_MARKER + "0004 0000"; // content length 4
+    public static final String DHT = DHT_MARKER + "0006 0000 0000"; // content length 6
+    public static final String DRI = DRI_MARKER + "0004 0000"; // content length 4, optional
+    public static final String SOF = SOF_MARKER + "0006 0000 0000"; // content length 6
+    public static final String SOS = SOS_MARKER + "0004 0000"; // content length 4
+    public static final String APP0 = APP0_MARKER + "0004 0000"; // content length 4, optional
+    public static final String APP2 = APP2_MARKER + "0004 0000"; // content length 4, optional
+
+    // APP1 related headers and magic number.
+    public static final String APP1_EXIF_MAGIC = "4578 6966 0000";
+    public static final String TIFF_HEADER_LE = "4949 2A00 0800 0000";
+    public static final String TIFF_HEADER_BE = "4D4D 002A 0000 0008";
+    // IFD related content constant definition
+    public static final int IFD_ENTRY_ORI_TAG = 0x0112;
+    public static final int IFD_ENTRY_TAG_1 = 0x011A;
+    public static final int IFD_ENTRY_TAG_2 = 0x011B;
+    public static final int IFD_ENTRY_TAG_3 = 0x011C;
+    public static final int TYPE_SHORT = 3;
+
+    public static int numBytes(String data) {
+        return data.replaceAll(" ", "").length() / 2;
     }
-    return sb.toString();
-  }
-
-  public static String makeSOFSection(int length, int bitDepth, int width, int height) {
-    return SOF_MARKER + encodeInt2HexString(length, 2, false) +
-        encodeInt2HexString(bitDepth, 1, false) +
-        encodeInt2HexString(height, 2, false) +
-        encodeInt2HexString(width, 2, false) +
-        encodeInt2HexString(0, length - 7, false);
-  }
-
-  public static String makeOrientationEntry(int orientation, boolean isLittleEnd) {
-    return makeIfdEntry(
-        IFD_ENTRY_ORI_TAG, TYPE_SHORT, 1, orientation, 2, isLittleEnd);
-  }
-
-  public static String makeIfdEntry(
-      int tag,
-      int type,
-      int count,
-      int value,
-      int valueNumBytes,
-      boolean littleEndian) {
-    return encodeInt2HexString(tag, 2, littleEndian) +
-        encodeInt2HexString(type, 2, littleEndian) +
-        encodeInt2HexString(count, 4, littleEndian) +
-        encodeInt2HexString(value, valueNumBytes, littleEndian) +
-        encodeInt2HexString(0, 4 - valueNumBytes, littleEndian);
-  }
-
-  public static String makeIfd(String[] IfdEntries, int nextEntryOffset, boolean littleEndian) {
-    String ret = encodeInt2HexString(IfdEntries.length, 2, littleEndian);
-    for (int i = 0; i < IfdEntries.length; i++) {
-      ret += IfdEntries[i];
+
+    public static byte[] hexStringToByteArray(String s) {
+        String noSpaceString = s.replaceAll(" ", "");
+        byte[] data = Hex.decodeHex(noSpaceString);
+        return data;
+    }
+
+    public static String encodeInt2HexString(int value, int length, boolean littleEndian) {
+        StringBuffer sb = new StringBuffer();
+        for (int i = 0; i < length; i++) {
+            int oneByte = value & 0xFF;
+            if (littleEndian) {
+                sb.append(Hex.byte2Hex(oneByte));
+            } else {
+                sb.insert(0, Hex.byte2Hex(oneByte));
+            }
+            value = value >> 8;
+        }
+        return sb.toString();
+    }
+
+    public static String makeSOFSection(int length, int bitDepth, int width, int height) {
+        return SOF_MARKER + encodeInt2HexString(length, 2, false) +
+                encodeInt2HexString(bitDepth, 1, false) +
+                encodeInt2HexString(height, 2, false) +
+                encodeInt2HexString(width, 2, false) +
+                encodeInt2HexString(0, length - 7, false);
+    }
+
+    public static String makeOrientationEntry(int orientation, boolean isLittleEnd) {
+        return makeIfdEntry(
+                IFD_ENTRY_ORI_TAG, TYPE_SHORT, 1, orientation, 2, isLittleEnd);
+    }
+
+    public static String makeIfdEntry(
+            int tag,
+            int type,
+            int count,
+            int value,
+            int valueNumBytes,
+            boolean littleEndian) {
+        return encodeInt2HexString(tag, 2, littleEndian) +
+                encodeInt2HexString(type, 2, littleEndian) +
+                encodeInt2HexString(count, 4, littleEndian) +
+                encodeInt2HexString(value, valueNumBytes, littleEndian) +
+                encodeInt2HexString(0, 4 - valueNumBytes, littleEndian);
+    }
+
+    public static String makeIfd(String[] IfdEntries, int nextEntryOffset, boolean littleEndian) {
+        String ret = encodeInt2HexString(IfdEntries.length, 2, littleEndian);
+        for (int i = 0; i < IfdEntries.length; i++) {
+            ret += IfdEntries[i];
+        }
+        ret += encodeInt2HexString(nextEntryOffset, 4, littleEndian);
+        return ret;
+    }
+
+    public static String makeTiff(String ifd, boolean littleEndian) {
+        String ret = littleEndian ? TIFF_HEADER_LE : TIFF_HEADER_BE;
+        return ret + ifd;
+    }
+
+    public static String makeAPP1_EXIF(String tiff) {
+        String app1Length = encodeInt2HexString(numBytes(tiff) + 8, 2, false);
+        return APP1_MARKER + app1Length + APP1_EXIF_MAGIC + tiff;
+    }
+
+    public static String makeTestImageWithAPP1(String APP1) {
+        return SOI + APP0 + APP1 + DQT + DHT + SOF + SOS + EOI;
     }
-    ret += encodeInt2HexString(nextEntryOffset, 4, littleEndian);
-    return ret;
-  }
-
-  public static String makeTiff(String ifd, boolean littleEndian) {
-    String ret = littleEndian ? TIFF_HEADER_LE : TIFF_HEADER_BE;
-    return ret + ifd;
-  }
-
-  public static String makeAPP1_EXIF(String tiff) {
-    String app1Length = encodeInt2HexString(numBytes(tiff) + 8, 2, false);
-    return APP1_MARKER + app1Length + APP1_EXIF_MAGIC + tiff;
-  }
-
-  public static String makeTestImageWithAPP1(String APP1) {
-    return SOI + APP0 + APP1 + DQT + DHT + SOF + SOS + EOI;
-  }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imageutils/JfifTestUtilsTest.java b/imagepipeline/src/test/java/com/facebook/imageutils/JfifTestUtilsTest.java
index a4857d2af..86a28607b 100644
--- a/imagepipeline/src/test/java/com/facebook/imageutils/JfifTestUtilsTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imageutils/JfifTestUtilsTest.java
@@ -21,127 +21,127 @@
 /**
  * Tests {@link JfifTestUtils}
  */
-@Config(manifest=Config.NONE)
+@Config(manifest = Config.NONE)
 @RunWith(WithTestDefaultsRunner.class)
 public class JfifTestUtilsTest {
 
-  private String mTestStr = "0123456789";
-
-  @Test
-  public void testMakeSOFSection() {
-    assertEquals("FFC0000A0300FF0136000000", JfifTestUtils.makeSOFSection(
-        10, // length
-        3,  // bit depth
-        310,  // width
-        255));  // height
-
-    assertEquals("FFC0001401013600FF00000000000000000000000000", JfifTestUtils.makeSOFSection(
-        20, // length
-        1,  // bit depth
-        255,  // width
-        310));  // height
-  }
-
-  @Test
-  public void testNumBytes() {
-    assertEquals(1, JfifTestUtils.numBytes("    3F        "));
-    assertEquals(4, JfifTestUtils.numBytes("1A 2B 3C 4D"));
-    assertEquals(6, JfifTestUtils.numBytes("1A2B 3C4D5E6F"));
-  }
-
-  @Test
-  public void testHexStringToByteArray() {
-    assertArrayEquals(new byte[]{0x3F}, JfifTestUtils.hexStringToByteArray("    3F        "));
-    assertArrayEquals(new byte[]{0x1A, 0x2B, 0x3C, 0x4D},
-        JfifTestUtils.hexStringToByteArray("1A 2B 3C 4D"));
-    assertArrayEquals(
-        new byte[]{0x1A, 0x2B, 0x3C, 0x4D, 0x5E, 0x6F},
-        JfifTestUtils.hexStringToByteArray("1A2B 3C4D5E6F"));
-  }
-
-  @Test
-  public void testEncodeInt2HexString() {
-    assertEquals("5B6FF432", JfifTestUtils.encodeInt2HexString(1534063666, 4, false));
-    assertEquals("6FF4", JfifTestUtils.encodeInt2HexString(28660, 2, false));
-    assertEquals("B6", JfifTestUtils.encodeInt2HexString(182, 1, false));
-    assertEquals("32F46F5B", JfifTestUtils.encodeInt2HexString(1534063666, 4, true));
-    assertEquals("F46F", JfifTestUtils.encodeInt2HexString(28660, 2, true));
-    assertEquals("B6", JfifTestUtils.encodeInt2HexString(182, 1, true));
-  }
-
-  @Test
-  public void testMakeOrientationEntry() {
-    assertEquals("011200030000000100050000", JfifTestUtils.makeOrientationEntry(5, false));
-    assertEquals("120103000100000005000000", JfifTestUtils.makeOrientationEntry(5, true));
-  }
-
-  @Test
-  public void testMakeIfdEntry() {
-    assertEquals("011200030000000100060000", JfifTestUtils.makeIfdEntry(
-        IFD_ENTRY_ORI_TAG,
-        TYPE_SHORT,
-        1,
-        6,
-        2,
-        false));
-    assertEquals("120103000200000003000000", JfifTestUtils.makeIfdEntry(
-        IFD_ENTRY_ORI_TAG,
-        TYPE_SHORT,
-        2,
-        3,
-        2,
-        true));
-  }
-
-  @Test
-  public void testMakeIfd() {
-    // Test big endian
-    String IFD_ENTRY_1 = JfifTestUtils.makeIfdEntry(
-        IFD_ENTRY_TAG_1, TYPE_SHORT, 1, 255, 2, false);
-    String IFD_ENTRY_2 = JfifTestUtils.makeIfdEntry(
-        IFD_ENTRY_TAG_2, TYPE_SHORT, 1, 255, 2, false);
-    String IFD_ENTRY_3 = JfifTestUtils.makeIfdEntry(
-        IFD_ENTRY_TAG_3, TYPE_SHORT, 1, 255, 2, false);
-    assertEquals(
-        "0003" +
-            "011A00030000000100FF0000" +
-            "011B00030000000100FF0000" +
-            "011C00030000000100FF0000" +
-            "00000008",
-        JfifTestUtils.makeIfd(new String[]{IFD_ENTRY_1, IFD_ENTRY_2, IFD_ENTRY_3}, 8, false));
-
-    // Test little endian
-    IFD_ENTRY_1 = JfifTestUtils.makeIfdEntry(
-        IFD_ENTRY_TAG_1, TYPE_SHORT, 1, 255, 2, true);
-    IFD_ENTRY_2 = JfifTestUtils.makeIfdEntry(
-        IFD_ENTRY_TAG_2, TYPE_SHORT, 1, 255, 2, true);
-    IFD_ENTRY_3 = JfifTestUtils.makeIfdEntry(
-        IFD_ENTRY_TAG_3, TYPE_SHORT, 1, 255, 2, true);
-    assertEquals(
-        "0300" +
-            "1A01030001000000FF000000" +
-            "1B01030001000000FF000000" +
-            "1C01030001000000FF000000" +
-            "09000000",
-        JfifTestUtils.makeIfd(new String[]{IFD_ENTRY_1, IFD_ENTRY_2, IFD_ENTRY_3}, 9, true));
-  }
-
-  @Test
-  public void testMakeTiff() {
-    assertEquals(TIFF_HEADER_BE + mTestStr, JfifTestUtils.makeTiff(mTestStr, false));
-    assertEquals(TIFF_HEADER_LE + mTestStr, JfifTestUtils.makeTiff(mTestStr, true));
-  }
-
-  @Test
-  public void testMakeAPP1_EXIF() {
-    assertEquals(APP1_MARKER + "000D" + APP1_EXIF_MAGIC + mTestStr,
-        JfifTestUtils.makeAPP1_EXIF(mTestStr));
-  }
-
-  @Test
-  public void testMakeTestImageWithAPP1() {
-    assertEquals(SOI + APP0 + mTestStr + DQT +
-        DHT + SOF + SOS + EOI,
-        JfifTestUtils.makeTestImageWithAPP1(mTestStr));
-  }
+    private String mTestStr = "0123456789";
+
+    @Test
+    public void testMakeSOFSection() {
+        assertEquals("FFC0000A0300FF0136000000", JfifTestUtils.makeSOFSection(
+                10, // length
+                3,  // bit depth
+                310,  // width
+                255));  // height
+
+        assertEquals("FFC0001401013600FF00000000000000000000000000", JfifTestUtils.makeSOFSection(
+                20, // length
+                1,  // bit depth
+                255,  // width
+                310));  // height
+    }
+
+    @Test
+    public void testNumBytes() {
+        assertEquals(1, JfifTestUtils.numBytes("    3F        "));
+        assertEquals(4, JfifTestUtils.numBytes("1A 2B 3C 4D"));
+        assertEquals(6, JfifTestUtils.numBytes("1A2B 3C4D5E6F"));
+    }
+
+    @Test
+    public void testHexStringToByteArray() {
+        assertArrayEquals(new byte[]{0x3F}, JfifTestUtils.hexStringToByteArray("    3F        "));
+        assertArrayEquals(new byte[]{0x1A, 0x2B, 0x3C, 0x4D},
+                JfifTestUtils.hexStringToByteArray("1A 2B 3C 4D"));
+        assertArrayEquals(
+                new byte[]{0x1A, 0x2B, 0x3C, 0x4D, 0x5E, 0x6F},
+                JfifTestUtils.hexStringToByteArray("1A2B 3C4D5E6F"));
+    }
+
+    @Test
+    public void testEncodeInt2HexString() {
+        assertEquals("5B6FF432", JfifTestUtils.encodeInt2HexString(1534063666, 4, false));
+        assertEquals("6FF4", JfifTestUtils.encodeInt2HexString(28660, 2, false));
+        assertEquals("B6", JfifTestUtils.encodeInt2HexString(182, 1, false));
+        assertEquals("32F46F5B", JfifTestUtils.encodeInt2HexString(1534063666, 4, true));
+        assertEquals("F46F", JfifTestUtils.encodeInt2HexString(28660, 2, true));
+        assertEquals("B6", JfifTestUtils.encodeInt2HexString(182, 1, true));
+    }
+
+    @Test
+    public void testMakeOrientationEntry() {
+        assertEquals("011200030000000100050000", JfifTestUtils.makeOrientationEntry(5, false));
+        assertEquals("120103000100000005000000", JfifTestUtils.makeOrientationEntry(5, true));
+    }
+
+    @Test
+    public void testMakeIfdEntry() {
+        assertEquals("011200030000000100060000", JfifTestUtils.makeIfdEntry(
+                IFD_ENTRY_ORI_TAG,
+                TYPE_SHORT,
+                1,
+                6,
+                2,
+                false));
+        assertEquals("120103000200000003000000", JfifTestUtils.makeIfdEntry(
+                IFD_ENTRY_ORI_TAG,
+                TYPE_SHORT,
+                2,
+                3,
+                2,
+                true));
+    }
+
+    @Test
+    public void testMakeIfd() {
+        // Test big endian
+        String IFD_ENTRY_1 = JfifTestUtils.makeIfdEntry(
+                IFD_ENTRY_TAG_1, TYPE_SHORT, 1, 255, 2, false);
+        String IFD_ENTRY_2 = JfifTestUtils.makeIfdEntry(
+                IFD_ENTRY_TAG_2, TYPE_SHORT, 1, 255, 2, false);
+        String IFD_ENTRY_3 = JfifTestUtils.makeIfdEntry(
+                IFD_ENTRY_TAG_3, TYPE_SHORT, 1, 255, 2, false);
+        assertEquals(
+                "0003" +
+                        "011A00030000000100FF0000" +
+                        "011B00030000000100FF0000" +
+                        "011C00030000000100FF0000" +
+                        "00000008",
+                JfifTestUtils.makeIfd(new String[]{IFD_ENTRY_1, IFD_ENTRY_2, IFD_ENTRY_3}, 8, false));
+
+        // Test little endian
+        IFD_ENTRY_1 = JfifTestUtils.makeIfdEntry(
+                IFD_ENTRY_TAG_1, TYPE_SHORT, 1, 255, 2, true);
+        IFD_ENTRY_2 = JfifTestUtils.makeIfdEntry(
+                IFD_ENTRY_TAG_2, TYPE_SHORT, 1, 255, 2, true);
+        IFD_ENTRY_3 = JfifTestUtils.makeIfdEntry(
+                IFD_ENTRY_TAG_3, TYPE_SHORT, 1, 255, 2, true);
+        assertEquals(
+                "0300" +
+                        "1A01030001000000FF000000" +
+                        "1B01030001000000FF000000" +
+                        "1C01030001000000FF000000" +
+                        "09000000",
+                JfifTestUtils.makeIfd(new String[]{IFD_ENTRY_1, IFD_ENTRY_2, IFD_ENTRY_3}, 9, true));
+    }
+
+    @Test
+    public void testMakeTiff() {
+        assertEquals(TIFF_HEADER_BE + mTestStr, JfifTestUtils.makeTiff(mTestStr, false));
+        assertEquals(TIFF_HEADER_LE + mTestStr, JfifTestUtils.makeTiff(mTestStr, true));
+    }
+
+    @Test
+    public void testMakeAPP1_EXIF() {
+        assertEquals(APP1_MARKER + "000D" + APP1_EXIF_MAGIC + mTestStr,
+                JfifTestUtils.makeAPP1_EXIF(mTestStr));
+    }
+
+    @Test
+    public void testMakeTestImageWithAPP1() {
+        assertEquals(SOI + APP0 + mTestStr + DQT +
+                        DHT + SOF + SOS + EOI,
+                JfifTestUtils.makeTestImageWithAPP1(mTestStr));
+    }
 }
diff --git a/imagepipeline/src/test/java/com/facebook/imageutils/JfifUtilTest.java b/imagepipeline/src/test/java/com/facebook/imageutils/JfifUtilTest.java
index a37d72a69..be4fc9f86 100644
--- a/imagepipeline/src/test/java/com/facebook/imageutils/JfifUtilTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imageutils/JfifUtilTest.java
@@ -23,138 +23,139 @@
 /**
  * Tests {@link JfifUtil}
  */
-@Config(manifest=Config.NONE)
+@Config(manifest = Config.NONE)
 @RunWith(WithTestDefaultsRunner.class)
 public class JfifUtilTest {
 
-  // Test cases without APP1 block
-  final String NO_ORI_IMAGE_1 = SOI + APP0 + APP2 + DQT + DHT + DRI + SOF + SOS + EOI;
-  final String NO_ORI_IMAGE_2 = SOI + DQT + DHT + SOF + SOS + EOI;
-
-  @Test
-  public void testGetOrientation_NoAPP1() {
-    assertEquals(0, JfifUtil.getOrientation(hexStringToByteArray(NO_ORI_IMAGE_1)));
-    assertEquals(0, JfifUtil.getOrientation(hexStringToByteArray(NO_ORI_IMAGE_2)));
-  }
-
-  @Test
-  public void testGetOrientation_BigEndian() {
-    testGetOrientation_WithEndian(false);
-  }
-  @Test
-  public void testGetOrientation_LittleEndian() {
-    testGetOrientation_WithEndian(true);
-  }
-
-  private void testGetOrientation_WithEndian(boolean littleEnd) {
-    final String IFD_ENTRY_1 = makeIfdEntry(IFD_ENTRY_TAG_1, TYPE_SHORT, 1, 255, 2, littleEnd);
-    final String IFD_ENTRY_2 = makeIfdEntry(IFD_ENTRY_TAG_2, TYPE_SHORT, 1, 255, 2, littleEnd);
-    final String IFD_ENTRY_3 = makeIfdEntry(IFD_ENTRY_TAG_3, TYPE_SHORT, 1, 255, 2, littleEnd);
-    final String TIFF_IFD_0 =
-        makeIfd(new String[]{IFD_ENTRY_1, IFD_ENTRY_2, IFD_ENTRY_3}, 0, littleEnd);
-    final String TIFF_IFD_1 =
-        makeIfd(
-            new String[]{makeOrientationEntry(1, littleEnd), IFD_ENTRY_1, IFD_ENTRY_2},
-            0,
-            littleEnd);
-    final String TIFF_IFD_3 =
-        makeIfd(
-            new String[]{makeOrientationEntry(3, littleEnd), IFD_ENTRY_1, IFD_ENTRY_2},
-            0,
-            littleEnd);
-    final String TIFF_IFD_6A =
-        makeIfd(
-            new String[]{makeOrientationEntry(6, littleEnd), IFD_ENTRY_1, IFD_ENTRY_2},
-            0,
-            littleEnd);
-    final String TIFF_IFD_6B =
-        makeIfd(
-            new String[]{IFD_ENTRY_1, makeOrientationEntry(6, littleEnd), IFD_ENTRY_2},
-            0,
-            littleEnd);
-    final String TIFF_IFD_6C =
-        makeIfd(
-            new String[]{IFD_ENTRY_1, IFD_ENTRY_2, makeOrientationEntry(6, littleEnd)},
-            0,
-            littleEnd);
-    final String TIFF_IFD_8 =
-        makeIfd(
-            new String[]{makeOrientationEntry(8, littleEnd), IFD_ENTRY_1, IFD_ENTRY_2},
-            0,
-            littleEnd);
-
-    final String APP1_0 = makeAPP1_EXIF(makeTiff(TIFF_IFD_0, littleEnd));
-    final String APP1_1 = makeAPP1_EXIF(makeTiff(TIFF_IFD_1, littleEnd));
-    final String APP1_3 = makeAPP1_EXIF(makeTiff(TIFF_IFD_3, littleEnd));
-    final String APP1_6A = makeAPP1_EXIF(makeTiff(TIFF_IFD_6A, littleEnd));
-    final String APP1_6B = makeAPP1_EXIF(makeTiff(TIFF_IFD_6B, littleEnd));
-    final String APP1_6C = makeAPP1_EXIF(makeTiff(TIFF_IFD_6C, littleEnd));
-    final String APP1_8 = makeAPP1_EXIF(makeTiff(TIFF_IFD_8, littleEnd));
-
-    assertEquals(0, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_0))));
-    assertEquals(1, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_1))));
-    assertEquals(3, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_3))));
-    assertEquals(6, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_6A))));
-    assertEquals(6, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_6B))));
-    assertEquals(6, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_6C))));
-    assertEquals(8, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_8))));
-
-    testGetOrientation_VariousAPP1Location(APP1_3, 3);
-  }
-
-  private void testGetOrientation_VariousAPP1Location(String APP1, int expectOri) {
-    final String IMAGE_WITH_STRUCT_1 = SOI + APP1 + DQT + DHT + SOF + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_2 = SOI + DQT + APP1 + DHT + SOF + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_3 = SOI + DQT + DHT + APP1 + DRI + SOF + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_4 = SOI + DQT + DHT + DRI + APP1 + SOF + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_5 = SOI + DQT + DHT + DRI + SOF + APP1 + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_6 = SOI + DQT + DHT + SOF + APP1 + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_7 = SOI + APP0 + APP2 + APP1 + DQT + DHT + DRI + SOF + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_8 = SOI + APP0 + APP1 + APP2 + DQT + DHT + DRI + SOF + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_9 = SOI + APP1 + APP2 + DQT + DHT + DRI + SOF + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_10 = SOI + APP1 + SOS + EOI;
-    assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_1)));
-    assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_2)));
-    assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_3)));
-    assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_4)));
-    assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_5)));
-    assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_6)));
-    assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_7)));
-    assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_8)));
-    assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_9)));
-    assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_10)));
-  }
-
-  @Test
-  public void testGetDimensions_VariousSOFWidthHeight() {
-    testGetDimensions_VariousSOFLocation(0, 0);
-    testGetDimensions_VariousSOFLocation(300, 400);
-    testGetDimensions_VariousSOFLocation(400, 300);
-    testGetDimensions_VariousSOFLocation(10, 4000);
-    testGetDimensions_VariousSOFLocation(4000, 10);
-  }
-
-  private void testGetDimensions_VariousSOFLocation(int width, int height) {
-    String testSOF1 = makeSOFSection(20, 3, width, height);
-    String testSOF2 = makeSOFSection(10, 1, width, height);
-    Rect expectRect = new Rect(0, 0, width, height);
-    final String IMAGE_WITH_STRUCT_1 = SOI + APP0 + DQT + DHT + DRI + testSOF1 + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_2 = SOI + APP0 + DQT + DHT + testSOF1 + DRI + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_3 = SOI + APP0 + DQT + testSOF1 + DHT + DRI + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_4 = SOI + APP0 + testSOF2 + DQT + DHT + DRI + SOS + EOI;
-    final String IMAGE_WITH_STRUCT_5 = SOI + testSOF2 + APP0 + DQT + DHT + DRI + SOS + EOI;
-    assertEquals(expectRect, JfifUtil.getDimensions(hexStringToByteArray(IMAGE_WITH_STRUCT_1)));
-    assertEquals(expectRect, JfifUtil.getDimensions(hexStringToByteArray(IMAGE_WITH_STRUCT_2)));
-    assertEquals(expectRect, JfifUtil.getDimensions(hexStringToByteArray(IMAGE_WITH_STRUCT_3)));
-    assertEquals(expectRect, JfifUtil.getDimensions(hexStringToByteArray(IMAGE_WITH_STRUCT_4)));
-    assertEquals(expectRect, JfifUtil.getDimensions(hexStringToByteArray(IMAGE_WITH_STRUCT_5)));
-  }
-
-  @Test
-  public void testGetDimensions_NoSOF() {
-    final String NO_SOF_IMAGE_1 = SOI + APP0 + APP2 + DQT + DHT + DRI + SOS + EOI;
-    final String NO_SOF_IMAGE_2 = SOI + DQT + DHT + SOS + EOI;
-    assertEquals(null, JfifUtil.getDimensions(hexStringToByteArray(NO_SOF_IMAGE_1)));
-    assertEquals(null, JfifUtil.getDimensions(hexStringToByteArray(NO_SOF_IMAGE_2)));
-  }
+    // Test cases without APP1 block
+    final String NO_ORI_IMAGE_1 = SOI + APP0 + APP2 + DQT + DHT + DRI + SOF + SOS + EOI;
+    final String NO_ORI_IMAGE_2 = SOI + DQT + DHT + SOF + SOS + EOI;
+
+    @Test
+    public void testGetOrientation_NoAPP1() {
+        assertEquals(0, JfifUtil.getOrientation(hexStringToByteArray(NO_ORI_IMAGE_1)));
+        assertEquals(0, JfifUtil.getOrientation(hexStringToByteArray(NO_ORI_IMAGE_2)));
+    }
+
+    @Test
+    public void testGetOrientation_BigEndian() {
+        testGetOrientation_WithEndian(false);
+    }
+
+    @Test
+    public void testGetOrientation_LittleEndian() {
+        testGetOrientation_WithEndian(true);
+    }
+
+    private void testGetOrientation_WithEndian(boolean littleEnd) {
+        final String IFD_ENTRY_1 = makeIfdEntry(IFD_ENTRY_TAG_1, TYPE_SHORT, 1, 255, 2, littleEnd);
+        final String IFD_ENTRY_2 = makeIfdEntry(IFD_ENTRY_TAG_2, TYPE_SHORT, 1, 255, 2, littleEnd);
+        final String IFD_ENTRY_3 = makeIfdEntry(IFD_ENTRY_TAG_3, TYPE_SHORT, 1, 255, 2, littleEnd);
+        final String TIFF_IFD_0 =
+                makeIfd(new String[]{IFD_ENTRY_1, IFD_ENTRY_2, IFD_ENTRY_3}, 0, littleEnd);
+        final String TIFF_IFD_1 =
+                makeIfd(
+                        new String[]{makeOrientationEntry(1, littleEnd), IFD_ENTRY_1, IFD_ENTRY_2},
+                        0,
+                        littleEnd);
+        final String TIFF_IFD_3 =
+                makeIfd(
+                        new String[]{makeOrientationEntry(3, littleEnd), IFD_ENTRY_1, IFD_ENTRY_2},
+                        0,
+                        littleEnd);
+        final String TIFF_IFD_6A =
+                makeIfd(
+                        new String[]{makeOrientationEntry(6, littleEnd), IFD_ENTRY_1, IFD_ENTRY_2},
+                        0,
+                        littleEnd);
+        final String TIFF_IFD_6B =
+                makeIfd(
+                        new String[]{IFD_ENTRY_1, makeOrientationEntry(6, littleEnd), IFD_ENTRY_2},
+                        0,
+                        littleEnd);
+        final String TIFF_IFD_6C =
+                makeIfd(
+                        new String[]{IFD_ENTRY_1, IFD_ENTRY_2, makeOrientationEntry(6, littleEnd)},
+                        0,
+                        littleEnd);
+        final String TIFF_IFD_8 =
+                makeIfd(
+                        new String[]{makeOrientationEntry(8, littleEnd), IFD_ENTRY_1, IFD_ENTRY_2},
+                        0,
+                        littleEnd);
+
+        final String APP1_0 = makeAPP1_EXIF(makeTiff(TIFF_IFD_0, littleEnd));
+        final String APP1_1 = makeAPP1_EXIF(makeTiff(TIFF_IFD_1, littleEnd));
+        final String APP1_3 = makeAPP1_EXIF(makeTiff(TIFF_IFD_3, littleEnd));
+        final String APP1_6A = makeAPP1_EXIF(makeTiff(TIFF_IFD_6A, littleEnd));
+        final String APP1_6B = makeAPP1_EXIF(makeTiff(TIFF_IFD_6B, littleEnd));
+        final String APP1_6C = makeAPP1_EXIF(makeTiff(TIFF_IFD_6C, littleEnd));
+        final String APP1_8 = makeAPP1_EXIF(makeTiff(TIFF_IFD_8, littleEnd));
+
+        assertEquals(0, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_0))));
+        assertEquals(1, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_1))));
+        assertEquals(3, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_3))));
+        assertEquals(6, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_6A))));
+        assertEquals(6, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_6B))));
+        assertEquals(6, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_6C))));
+        assertEquals(8, JfifUtil.getOrientation(hexStringToByteArray(makeTestImageWithAPP1(APP1_8))));
+
+        testGetOrientation_VariousAPP1Location(APP1_3, 3);
+    }
+
+    private void testGetOrientation_VariousAPP1Location(String APP1, int expectOri) {
+        final String IMAGE_WITH_STRUCT_1 = SOI + APP1 + DQT + DHT + SOF + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_2 = SOI + DQT + APP1 + DHT + SOF + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_3 = SOI + DQT + DHT + APP1 + DRI + SOF + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_4 = SOI + DQT + DHT + DRI + APP1 + SOF + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_5 = SOI + DQT + DHT + DRI + SOF + APP1 + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_6 = SOI + DQT + DHT + SOF + APP1 + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_7 = SOI + APP0 + APP2 + APP1 + DQT + DHT + DRI + SOF + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_8 = SOI + APP0 + APP1 + APP2 + DQT + DHT + DRI + SOF + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_9 = SOI + APP1 + APP2 + DQT + DHT + DRI + SOF + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_10 = SOI + APP1 + SOS + EOI;
+        assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_1)));
+        assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_2)));
+        assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_3)));
+        assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_4)));
+        assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_5)));
+        assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_6)));
+        assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_7)));
+        assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_8)));
+        assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_9)));
+        assertEquals(expectOri, JfifUtil.getOrientation(hexStringToByteArray(IMAGE_WITH_STRUCT_10)));
+    }
+
+    @Test
+    public void testGetDimensions_VariousSOFWidthHeight() {
+        testGetDimensions_VariousSOFLocation(0, 0);
+        testGetDimensions_VariousSOFLocation(300, 400);
+        testGetDimensions_VariousSOFLocation(400, 300);
+        testGetDimensions_VariousSOFLocation(10, 4000);
+        testGetDimensions_VariousSOFLocation(4000, 10);
+    }
+
+    private void testGetDimensions_VariousSOFLocation(int width, int height) {
+        String testSOF1 = makeSOFSection(20, 3, width, height);
+        String testSOF2 = makeSOFSection(10, 1, width, height);
+        Rect expectRect = new Rect(0, 0, width, height);
+        final String IMAGE_WITH_STRUCT_1 = SOI + APP0 + DQT + DHT + DRI + testSOF1 + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_2 = SOI + APP0 + DQT + DHT + testSOF1 + DRI + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_3 = SOI + APP0 + DQT + testSOF1 + DHT + DRI + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_4 = SOI + APP0 + testSOF2 + DQT + DHT + DRI + SOS + EOI;
+        final String IMAGE_WITH_STRUCT_5 = SOI + testSOF2 + APP0 + DQT + DHT + DRI + SOS + EOI;
+        assertEquals(expectRect, JfifUtil.getDimensions(hexStringToByteArray(IMAGE_WITH_STRUCT_1)));
+        assertEquals(expectRect, JfifUtil.getDimensions(hexStringToByteArray(IMAGE_WITH_STRUCT_2)));
+        assertEquals(expectRect, JfifUtil.getDimensions(hexStringToByteArray(IMAGE_WITH_STRUCT_3)));
+        assertEquals(expectRect, JfifUtil.getDimensions(hexStringToByteArray(IMAGE_WITH_STRUCT_4)));
+        assertEquals(expectRect, JfifUtil.getDimensions(hexStringToByteArray(IMAGE_WITH_STRUCT_5)));
+    }
+
+    @Test
+    public void testGetDimensions_NoSOF() {
+        final String NO_SOF_IMAGE_1 = SOI + APP0 + APP2 + DQT + DHT + DRI + SOS + EOI;
+        final String NO_SOF_IMAGE_2 = SOI + DQT + DHT + SOS + EOI;
+        assertEquals(null, JfifUtil.getDimensions(hexStringToByteArray(NO_SOF_IMAGE_1)));
+        assertEquals(null, JfifUtil.getDimensions(hexStringToByteArray(NO_SOF_IMAGE_2)));
+    }
 }
diff --git a/sample/src/androidTest/java/com/facebook/fresco/sample/test/ScrollTest.java b/sample/src/androidTest/java/com/facebook/fresco/sample/test/ScrollTest.java
index 8655268ac..26a7ccb32 100644
--- a/sample/src/androidTest/java/com/facebook/fresco/sample/test/ScrollTest.java
+++ b/sample/src/androidTest/java/com/facebook/fresco/sample/test/ScrollTest.java
@@ -31,161 +31,161 @@
  * app by scrolling down SCROLLS times.
  */
 public class ScrollTest extends ActivityInstrumentationTestCase2<MainActivity> {
-  private static final int SCROLLS = 30;
-  private static final int SCROLL_TIME_MS = 1000;
-  private static final int BEFORE_SCROLL_TIME_MS = 500;
-  private static final int WAIT_FOR_IMAGES_INTERCHECK_MS = 1000;
-  private static final int WAIT_BEFORE_TEST_END_MS = 5000;
-
-  private MainActivity mActivity;
-  private ListView mImageList;
-  private Spinner mLoaderSelect;
-
-  public ScrollTest() {
-    super(MainActivity.class);
-  }
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    mActivity = getActivity();
-    mImageList = (ListView) mActivity.findViewById(R.id.image_list);
-    mLoaderSelect = (Spinner) mActivity.findViewById(R.id.loader_select);
-    FLog.setMinimumLoggingLevel(FLog.INFO);
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    super.tearDown();
-  }
-
-  public void testFresco() throws Exception {
-    runScenario(MainActivity.FRESCO_INDEX, true);
-  }
-
-  public void testFrescoOkhttp() throws Exception {
-    runScenario(MainActivity.FRESCO_OKHTTP_INDEX, true);
-  }
-
-  public void testGlide() throws Exception {
-    runScenario(MainActivity.GLIDE_INDEX, false);
-  }
-
-  public void testPicasso() throws Exception {
-    runScenario(MainActivity.PICASSO_INDEX, false);
-  }
-
-  public void testUil() throws Exception {
-    runScenario(MainActivity.UIL_INDEX, false);
-  }
-
-  public void testVolley() throws Exception {
-    runScenario(MainActivity.VOLLEY_INDEX, false);
-  }
-
-  public void testDraweeVolley() throws Exception {
-    runScenario(MainActivity.VOLLEY_INDEX, true);
-  }
-
-  /**
-   * Runs the test for given library.
-   */
-  private void runScenario(int libraryIndex, boolean useDrawee) throws Exception {
-    disableAnimatedImages();
-    setUseDrawee(useDrawee);
-    selectFramework(libraryIndex);
-    TouchUtils.tapView(this, mImageList);
-    waitForImages();
-    scrollMultipleTimes(SCROLLS);
-    Thread.sleep(WAIT_BEFORE_TEST_END_MS);
-  }
-
-  /**
-   * Disables animated images in list view.
-   */
-  private void disableAnimatedImages() {
-    getInstrumentation().runOnMainSync(
-        new Runnable() {
-          @Override
-          public void run() {
-            mActivity.setAllowAnimations(false);
-          }
-        });
-  }
-
-  /**
-   * Disables or enables Drawee.
-   */
-  private void setUseDrawee(final boolean useDrawee) {
-    getInstrumentation().runOnMainSync(
-        new Runnable() {
-          @Override
-          public void run() {
-            mActivity.setUseDrawee(useDrawee);
-          }
-        });
-  }
-
-  /**
-   * Selects give library in the select component.
-   */
-  private void selectFramework(final int libraryIndex) {
-    getInstrumentation().runOnMainSync(
-        new Runnable() {
-          @Override
-          public void run() {
-            mLoaderSelect.setSelection(libraryIndex, true);
-          }
-        });
-  }
-
-  /**
-   * Waits until the list view is populated with content, that is
-   * until list of images is downloaded.
-   */
-  private void waitForImages() throws Exception {
-    final AtomicBoolean mImagesLoaded = new AtomicBoolean();
-    while (!mImagesLoaded.get()) {
-      Thread.sleep(WAIT_FOR_IMAGES_INTERCHECK_MS);
-      getInstrumentation().runOnMainSync(
-          new Runnable() {
-            @Override
-            public void run() {
-              mImagesLoaded.set(mImageList.getAdapter().getCount() > 0);
-            }
-          });
-    }
-  }
-
-  /**
-   * Scrolls the list view given number of times.
-   */
-  private void scrollMultipleTimes(int times) throws Exception {
-    final int height = getDisplayHeight();
-    for (int i = 0; i < times; ++i) {
-      Thread.sleep(BEFORE_SCROLL_TIME_MS);
-      getInstrumentation().runOnMainSync(
-          new Runnable() {
-            @Override
-            public void run() {
-              mImageList.smoothScrollBy(height / 2, SCROLL_TIME_MS);
-            }
-          });
-      Thread.sleep(SCROLL_TIME_MS);
-    }
-  }
-
-  /**
-   * Determines display's height.
-   */
-  private int getDisplayHeight() {
-    Display display = mActivity.getWindowManager().getDefaultDisplay();
-    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB_MR2) {
-      return display.getHeight();
-    } else {
-      final Point size = new Point();
-      display.getSize(size);
-      return size.y;
-    }
-  }
+    private static final int SCROLLS = 30;
+    private static final int SCROLL_TIME_MS = 1000;
+    private static final int BEFORE_SCROLL_TIME_MS = 500;
+    private static final int WAIT_FOR_IMAGES_INTERCHECK_MS = 1000;
+    private static final int WAIT_BEFORE_TEST_END_MS = 5000;
+
+    private MainActivity mActivity;
+    private ListView mImageList;
+    private Spinner mLoaderSelect;
+
+    public ScrollTest() {
+        super(MainActivity.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        mActivity = getActivity();
+        mImageList = (ListView) mActivity.findViewById(R.id.image_list);
+        mLoaderSelect = (Spinner) mActivity.findViewById(R.id.loader_select);
+        FLog.setMinimumLoggingLevel(FLog.INFO);
+    }
+
+    @Override
+    public void tearDown() throws Exception {
+        super.tearDown();
+    }
+
+    public void testFresco() throws Exception {
+        runScenario(MainActivity.FRESCO_INDEX, true);
+    }
+
+    public void testFrescoOkhttp() throws Exception {
+        runScenario(MainActivity.FRESCO_OKHTTP_INDEX, true);
+    }
+
+    public void testGlide() throws Exception {
+        runScenario(MainActivity.GLIDE_INDEX, false);
+    }
+
+    public void testPicasso() throws Exception {
+        runScenario(MainActivity.PICASSO_INDEX, false);
+    }
+
+    public void testUil() throws Exception {
+        runScenario(MainActivity.UIL_INDEX, false);
+    }
+
+    public void testVolley() throws Exception {
+        runScenario(MainActivity.VOLLEY_INDEX, false);
+    }
+
+    public void testDraweeVolley() throws Exception {
+        runScenario(MainActivity.VOLLEY_INDEX, true);
+    }
+
+    /**
+     * Runs the test for given library.
+     */
+    private void runScenario(int libraryIndex, boolean useDrawee) throws Exception {
+        disableAnimatedImages();
+        setUseDrawee(useDrawee);
+        selectFramework(libraryIndex);
+        TouchUtils.tapView(this, mImageList);
+        waitForImages();
+        scrollMultipleTimes(SCROLLS);
+        Thread.sleep(WAIT_BEFORE_TEST_END_MS);
+    }
+
+    /**
+     * Disables animated images in list view.
+     */
+    private void disableAnimatedImages() {
+        getInstrumentation().runOnMainSync(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        mActivity.setAllowAnimations(false);
+                    }
+                });
+    }
+
+    /**
+     * Disables or enables Drawee.
+     */
+    private void setUseDrawee(final boolean useDrawee) {
+        getInstrumentation().runOnMainSync(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        mActivity.setUseDrawee(useDrawee);
+                    }
+                });
+    }
+
+    /**
+     * Selects give library in the select component.
+     */
+    private void selectFramework(final int libraryIndex) {
+        getInstrumentation().runOnMainSync(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        mLoaderSelect.setSelection(libraryIndex, true);
+                    }
+                });
+    }
+
+    /**
+     * Waits until the list view is populated with content, that is
+     * until list of images is downloaded.
+     */
+    private void waitForImages() throws Exception {
+        final AtomicBoolean mImagesLoaded = new AtomicBoolean();
+        while (!mImagesLoaded.get()) {
+            Thread.sleep(WAIT_FOR_IMAGES_INTERCHECK_MS);
+            getInstrumentation().runOnMainSync(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            mImagesLoaded.set(mImageList.getAdapter().getCount() > 0);
+                        }
+                    });
+        }
+    }
+
+    /**
+     * Scrolls the list view given number of times.
+     */
+    private void scrollMultipleTimes(int times) throws Exception {
+        final int height = getDisplayHeight();
+        for (int i = 0; i < times; ++i) {
+            Thread.sleep(BEFORE_SCROLL_TIME_MS);
+            getInstrumentation().runOnMainSync(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            mImageList.smoothScrollBy(height / 2, SCROLL_TIME_MS);
+                        }
+                    });
+            Thread.sleep(SCROLL_TIME_MS);
+        }
+    }
+
+    /**
+     * Determines display's height.
+     */
+    private int getDisplayHeight() {
+        Display display = mActivity.getWindowManager().getDefaultDisplay();
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB_MR2) {
+            return display.getHeight();
+        } else {
+            final Point size = new Point();
+            display.getSize(size);
+            return size.y;
+        }
+    }
 }
diff --git a/sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
index 27f87f101..9983e8dde 100644
--- a/sample/src/main/AndroidManifest.xml
+++ b/sample/src/main/AndroidManifest.xml
@@ -1,22 +1,21 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.facebook.fresco.sample" >
+    package="com.facebook.fresco.sample">
 
     <uses-permission android:name="android.permission.INTERNET" />
 
     <uses-sdk
         android:minSdkVersion="9"
-        android:targetSdkVersion="21"
-        />
+        android:targetSdkVersion="21" />
 
     <application
         android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
-        android:theme="@style/AppTheme" >
+        android:theme="@style/AppTheme">
         <activity
             android:name=".MainActivity"
-            android:label="@string/app_name" >
+            android:label="@string/app_name">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
 
diff --git a/sample/src/main/java/com/facebook/fresco/sample/Drawables.java b/sample/src/main/java/com/facebook/fresco/sample/Drawables.java
index 415d63681..e8a48f0ff 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/Drawables.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/Drawables.java
@@ -17,23 +17,23 @@
 
 /**
  * Holds static drawables used in the sample app.
- *
+ * <p>
  * <p> Using static set of drawables allows us to easily determine state of image request
  * by simply looking what kind of drawable is passed to image view.
  */
 public class Drawables {
-  public static void init(final Resources resources) {
-    if (sPlaceholderDrawable == null) {
-      sPlaceholderDrawable = resources.getDrawable(R.color.placeholder);
-    }
-    if (sErrorDrawable == null) {
-      sErrorDrawable = resources.getDrawable(R.color.error);
+    public static void init(final Resources resources) {
+        if (sPlaceholderDrawable == null) {
+            sPlaceholderDrawable = resources.getDrawable(R.color.placeholder);
+        }
+        if (sErrorDrawable == null) {
+            sErrorDrawable = resources.getDrawable(R.color.error);
+        }
     }
-  }
 
-  public static Drawable sPlaceholderDrawable;
-  public static Drawable sErrorDrawable;
+    public static Drawable sPlaceholderDrawable;
+    public static Drawable sErrorDrawable;
 
-  private Drawables() {
-  }
+    private Drawables() {
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/MainActivity.java b/sample/src/main/java/com/facebook/fresco/sample/MainActivity.java
index 8123b99d6..9a9c3bf66 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/MainActivity.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/MainActivity.java
@@ -46,273 +46,274 @@
 
 public class MainActivity extends ActionBarActivity {
 
-  private static final String TAG = "FrescoSample";
-
-  // These need to be in sync with {@link R.array.image_loaders}
-  public static final int FRESCO_INDEX = 1;
-  public static final int FRESCO_OKHTTP_INDEX = 2;
-  public static final int GLIDE_INDEX = 3;
-  public static final int PICASSO_INDEX = 4;
-  public static final int UIL_INDEX = 5;
-  public static final int VOLLEY_INDEX = 6;
-
-  private static final long STATS_CLOCK_INTERVAL_MS = 1000;
-  private static final int DEFAULT_MESSAGE_SIZE = 1024;
-  private static final int BYTES_IN_MEGABYTE = 1024 * 1024;
-
-  private static final String EXTRA_ALLOW_ANIMATIONS = "allow_animations";
-  private static final String EXTRA_USE_DRAWEE = "use_drawee";
-  private static final String EXTRA_CURRENT_ADAPTER_INDEX = "current_adapter_index";
-
-  private Handler mHandler;
-  private Runnable mStatsClockTickRunnable;
-
-  private TextView mStatsDisplay;
-  private Spinner mLoaderSelect;
-  private ListView mImageList;
-
-  private boolean mUseDrawee;
-  private boolean mAllowAnimations;
-  private int mCurrentAdapterIndex;
-
-  private ImageListAdapter mCurrentAdapter;
-  private PerfListener mPerfListener;
-
-  private List<String> mImageUrls;
-
-  @Override
-  protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.activity_main);
-    FLog.setMinimumLoggingLevel(FLog.WARN);
-    Drawables.init(getResources());
-
-    mAllowAnimations = true;
-    mUseDrawee = true;
-    mCurrentAdapterIndex = 0;
-    if (savedInstanceState != null) {
-      mAllowAnimations = savedInstanceState.getBoolean(EXTRA_ALLOW_ANIMATIONS);
-      mUseDrawee = savedInstanceState.getBoolean(EXTRA_USE_DRAWEE);
-      mCurrentAdapterIndex = savedInstanceState.getInt(EXTRA_CURRENT_ADAPTER_INDEX);
+    private static final String TAG = "FrescoSample";
+
+    // These need to be in sync with {@link R.array.image_loaders}
+    public static final int FRESCO_INDEX = 1;
+    public static final int FRESCO_OKHTTP_INDEX = 2;
+    public static final int GLIDE_INDEX = 3;
+    public static final int PICASSO_INDEX = 4;
+    public static final int UIL_INDEX = 5;
+    public static final int VOLLEY_INDEX = 6;
+
+    private static final long STATS_CLOCK_INTERVAL_MS = 1000;
+    private static final int DEFAULT_MESSAGE_SIZE = 1024;
+    private static final int BYTES_IN_MEGABYTE = 1024 * 1024;
+
+    private static final String EXTRA_ALLOW_ANIMATIONS = "allow_animations";
+    private static final String EXTRA_USE_DRAWEE = "use_drawee";
+    private static final String EXTRA_CURRENT_ADAPTER_INDEX = "current_adapter_index";
+
+    private Handler mHandler;
+    private Runnable mStatsClockTickRunnable;
+
+    private TextView mStatsDisplay;
+    private Spinner mLoaderSelect;
+    private ListView mImageList;
+
+    private boolean mUseDrawee;
+    private boolean mAllowAnimations;
+    private int mCurrentAdapterIndex;
+
+    private ImageListAdapter mCurrentAdapter;
+    private PerfListener mPerfListener;
+
+    private List<String> mImageUrls;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        FLog.setMinimumLoggingLevel(FLog.WARN);
+        Drawables.init(getResources());
+
+        mAllowAnimations = true;
+        mUseDrawee = true;
+        mCurrentAdapterIndex = 0;
+        if (savedInstanceState != null) {
+            mAllowAnimations = savedInstanceState.getBoolean(EXTRA_ALLOW_ANIMATIONS);
+            mUseDrawee = savedInstanceState.getBoolean(EXTRA_USE_DRAWEE);
+            mCurrentAdapterIndex = savedInstanceState.getInt(EXTRA_CURRENT_ADAPTER_INDEX);
+        }
+
+        mHandler = new Handler(Looper.getMainLooper());
+        mStatsClockTickRunnable = new Runnable() {
+            @Override
+            public void run() {
+                updateStats();
+                scheduleNextStatsClockTick();
+            }
+        };
+
+        mCurrentAdapter = null;
+        mPerfListener = new PerfListener();
+
+        mStatsDisplay = (TextView) findViewById(R.id.stats_display);
+        mImageList = (ListView) findViewById(R.id.image_list);
+        mLoaderSelect = (Spinner) findViewById(R.id.loader_select);
+        mLoaderSelect.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+            @Override
+            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+                setAdapter(position);
+            }
+
+            @Override
+            public void onNothingSelected(AdapterView<?> parent) {
+            }
+        });
+        mLoaderSelect.setSelection(mCurrentAdapterIndex);
     }
 
-    mHandler = new Handler(Looper.getMainLooper());
-    mStatsClockTickRunnable = new Runnable() {
-        @Override
-        public void run() {
-          updateStats();
-          scheduleNextStatsClockTick();
-        }
-      };
-
-    mCurrentAdapter = null;
-    mPerfListener = new PerfListener();
-
-    mStatsDisplay = (TextView) findViewById(R.id.stats_display);
-    mImageList = (ListView) findViewById(R.id.image_list);
-    mLoaderSelect = (Spinner) findViewById(R.id.loader_select);
-    mLoaderSelect.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
-      @Override
-      public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
-        setAdapter(position);
-      }
-      @Override
-      public void onNothingSelected(AdapterView<?> parent) {
-      }
-    });
-    mLoaderSelect.setSelection(mCurrentAdapterIndex);
-  }
-
-  @Override
-  protected void onSaveInstanceState(Bundle outState) {
-    super.onSaveInstanceState(outState);
-    outState.putBoolean(EXTRA_ALLOW_ANIMATIONS, mAllowAnimations);
-    outState.putBoolean(EXTRA_USE_DRAWEE, mUseDrawee);
-    outState.putInt(EXTRA_CURRENT_ADAPTER_INDEX, mCurrentAdapterIndex);
-  }
-
-  @Override
-  public boolean onCreateOptionsMenu(Menu menu) {
-    getMenuInflater().inflate(R.menu.menu_main, menu);
-    return true;
-  }
-
-  @Override
-  public boolean onPrepareOptionsMenu(Menu menu) {
-    menu.findItem(R.id.allow_animations).setChecked(mAllowAnimations);
-    menu.findItem(R.id.use_drawee).setChecked(mUseDrawee);
-    return super.onPrepareOptionsMenu(menu);
-  }
-
-  @Override
-  public boolean onOptionsItemSelected(MenuItem item) {
-    int id = item.getItemId();
-
-    if (id == R.id.allow_animations) {
-      setAllowAnimations(!item.isChecked());
-      return true;
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putBoolean(EXTRA_ALLOW_ANIMATIONS, mAllowAnimations);
+        outState.putBoolean(EXTRA_USE_DRAWEE, mUseDrawee);
+        outState.putInt(EXTRA_CURRENT_ADAPTER_INDEX, mCurrentAdapterIndex);
     }
 
-    if (id == R.id.use_drawee) {
-      setUseDrawee(!item.isChecked());
-      return true;
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        getMenuInflater().inflate(R.menu.menu_main, menu);
+        return true;
     }
 
-    return super.onOptionsItemSelected(item);
-  }
-
-  @Override
-  protected void onStart() {
-    super.onStart();
-    updateStats();
-    scheduleNextStatsClockTick();
-  }
-
-  protected void onStop() {
-    super.onStop();
-    cancelNextStatsClockTick();
-  }
-
-  @VisibleForTesting
-  public void setAllowAnimations(boolean allowAnimations) {
-    mAllowAnimations = allowAnimations;
-    supportInvalidateOptionsMenu();
-    updateAdapter(null);
-    reloadUrls();
-  }
-
-  @VisibleForTesting
-  public void setUseDrawee(boolean useDrawee) {
-    mUseDrawee = useDrawee;
-    supportInvalidateOptionsMenu();
-    setAdapter(mCurrentAdapterIndex);
-  }
-
-  private void setAdapter(int index) {
-    FLog.w(TAG, "onImageLoaderSelect: %d", index);
-    if (mCurrentAdapter != null) {
-      mCurrentAdapter.shutDown();
-      mCurrentAdapter = null;
-      System.gc();
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        menu.findItem(R.id.allow_animations).setChecked(mAllowAnimations);
+        menu.findItem(R.id.use_drawee).setChecked(mUseDrawee);
+        return super.onPrepareOptionsMenu(menu);
     }
 
-    mCurrentAdapterIndex = index;
-    mPerfListener = new PerfListener();
-    switch (index) {
-      case FRESCO_INDEX:
-      case FRESCO_OKHTTP_INDEX:
-        mCurrentAdapter = new FrescoAdapter(
-                this,
-                R.id.image_list,
-                mPerfListener,
-                index == FRESCO_INDEX ?
-                    ImagePipelineConfigFactory.getImagePipelineConfig(this) :
-                    ImagePipelineConfigFactory.getOkHttpImagePipelineConfig(this));
-        break;
-      case GLIDE_INDEX:
-        mCurrentAdapter = new GlideAdapter(this, R.id.image_list, mPerfListener);
-        break;
-      case PICASSO_INDEX:
-        mCurrentAdapter = new PicassoAdapter(this, R.id.image_list, mPerfListener);
-        break;
-      case UIL_INDEX:
-        mCurrentAdapter = new UilAdapter(this, R.id.image_list, mPerfListener);
-        break;
-      case VOLLEY_INDEX:
-        mCurrentAdapter = mUseDrawee ?
-            new VolleyDraweeAdapter(this, R.id.image_list, mPerfListener) :
-            new VolleyAdapter(this, R.id.image_list, mPerfListener);
-        break;
-      default:
-        mCurrentAdapter = null;
-        return;
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        int id = item.getItemId();
+
+        if (id == R.id.allow_animations) {
+            setAllowAnimations(!item.isChecked());
+            return true;
+        }
+
+        if (id == R.id.use_drawee) {
+            setUseDrawee(!item.isChecked());
+            return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        updateStats();
+        scheduleNextStatsClockTick();
     }
 
-    mImageList.setAdapter(mCurrentAdapter);
+    protected void onStop() {
+        super.onStop();
+        cancelNextStatsClockTick();
+    }
 
-    if (mImageUrls != null && !mImageUrls.isEmpty()) {
-      updateAdapter(mImageUrls);
-    } else {
-      reloadUrls();
+    @VisibleForTesting
+    public void setAllowAnimations(boolean allowAnimations) {
+        mAllowAnimations = allowAnimations;
+        supportInvalidateOptionsMenu();
+        updateAdapter(null);
+        reloadUrls();
     }
 
-    updateStats();
-  }
-
-  private void scheduleNextStatsClockTick() {
-    mHandler.postDelayed(mStatsClockTickRunnable, STATS_CLOCK_INTERVAL_MS);
-  }
-
-  private void cancelNextStatsClockTick() {
-    mHandler.removeCallbacks(mStatsClockTickRunnable);
-  }
-
-  private void reloadUrls() {
-    String url = "https://api.imgur.com/3/gallery/hot/viral/0.json";
-    ImageUrlsRequestBuilder builder = new ImageUrlsRequestBuilder(url)
-        .addImageFormat(
-            ImageFormat.JPEG,
-            ImageSize.LARGE_THUMBNAIL)
-        .addImageFormat(
-            ImageFormat.PNG,
-            ImageSize.LARGE_THUMBNAIL);
-    if (mAllowAnimations) {
-      builder.addImageFormat(
-          ImageFormat.GIF,
-          ImageSize.ORIGINAL_IMAGE);
+    @VisibleForTesting
+    public void setUseDrawee(boolean useDrawee) {
+        mUseDrawee = useDrawee;
+        supportInvalidateOptionsMenu();
+        setAdapter(mCurrentAdapterIndex);
     }
-    ImageUrlsFetcher.getImageUrls(
-        builder.build(),
-        new ImageUrlsFetcher.Callback() {
-          @Override
-          public void onFinish(List<String> result) {
-            mImageUrls = result;
+
+    private void setAdapter(int index) {
+        FLog.w(TAG, "onImageLoaderSelect: %d", index);
+        if (mCurrentAdapter != null) {
+            mCurrentAdapter.shutDown();
+            mCurrentAdapter = null;
+            System.gc();
+        }
+
+        mCurrentAdapterIndex = index;
+        mPerfListener = new PerfListener();
+        switch (index) {
+            case FRESCO_INDEX:
+            case FRESCO_OKHTTP_INDEX:
+                mCurrentAdapter = new FrescoAdapter(
+                        this,
+                        R.id.image_list,
+                        mPerfListener,
+                        index == FRESCO_INDEX ?
+                                ImagePipelineConfigFactory.getImagePipelineConfig(this) :
+                                ImagePipelineConfigFactory.getOkHttpImagePipelineConfig(this));
+                break;
+            case GLIDE_INDEX:
+                mCurrentAdapter = new GlideAdapter(this, R.id.image_list, mPerfListener);
+                break;
+            case PICASSO_INDEX:
+                mCurrentAdapter = new PicassoAdapter(this, R.id.image_list, mPerfListener);
+                break;
+            case UIL_INDEX:
+                mCurrentAdapter = new UilAdapter(this, R.id.image_list, mPerfListener);
+                break;
+            case VOLLEY_INDEX:
+                mCurrentAdapter = mUseDrawee ?
+                        new VolleyDraweeAdapter(this, R.id.image_list, mPerfListener) :
+                        new VolleyAdapter(this, R.id.image_list, mPerfListener);
+                break;
+            default:
+                mCurrentAdapter = null;
+                return;
+        }
+
+        mImageList.setAdapter(mCurrentAdapter);
+
+        if (mImageUrls != null && !mImageUrls.isEmpty()) {
             updateAdapter(mImageUrls);
-          }
-        });
-  }
-
-  private void updateAdapter(List<String> urls) {
-    if (mCurrentAdapter != null) {
-      mCurrentAdapter.clear();
-      if (urls != null) {
-        for (String url : urls) {
-          mCurrentAdapter.add(url);
+        } else {
+            reloadUrls();
         }
-      }
-      mCurrentAdapter.notifyDataSetChanged();
+
+        updateStats();
+    }
+
+    private void scheduleNextStatsClockTick() {
+        mHandler.postDelayed(mStatsClockTickRunnable, STATS_CLOCK_INTERVAL_MS);
+    }
+
+    private void cancelNextStatsClockTick() {
+        mHandler.removeCallbacks(mStatsClockTickRunnable);
+    }
+
+    private void reloadUrls() {
+        String url = "https://api.imgur.com/3/gallery/hot/viral/0.json";
+        ImageUrlsRequestBuilder builder = new ImageUrlsRequestBuilder(url)
+                .addImageFormat(
+                        ImageFormat.JPEG,
+                        ImageSize.LARGE_THUMBNAIL)
+                .addImageFormat(
+                        ImageFormat.PNG,
+                        ImageSize.LARGE_THUMBNAIL);
+        if (mAllowAnimations) {
+            builder.addImageFormat(
+                    ImageFormat.GIF,
+                    ImageSize.ORIGINAL_IMAGE);
+        }
+        ImageUrlsFetcher.getImageUrls(
+                builder.build(),
+                new ImageUrlsFetcher.Callback() {
+                    @Override
+                    public void onFinish(List<String> result) {
+                        mImageUrls = result;
+                        updateAdapter(mImageUrls);
+                    }
+                });
+    }
+
+    private void updateAdapter(List<String> urls) {
+        if (mCurrentAdapter != null) {
+            mCurrentAdapter.clear();
+            if (urls != null) {
+                for (String url : urls) {
+                    mCurrentAdapter.add(url);
+                }
+            }
+            mCurrentAdapter.notifyDataSetChanged();
+        }
+    }
+
+    private void updateStats() {
+        final Runtime runtime = Runtime.getRuntime();
+        final long heapMemory = runtime.totalMemory() - runtime.freeMemory();
+        final StringBuilder sb = new StringBuilder(DEFAULT_MESSAGE_SIZE);
+        // When changing format of output below, make sure to sync "scripts/test_runner.py" as well.
+        appendSize(sb, "Java heap size:          ", heapMemory, "\n");
+        appendSize(sb, "Native heap size:        ", Debug.getNativeHeapSize(), "\n");
+        appendTime(sb, "Average photo wait time: ", mPerfListener.getAverageWaitTime(), "\n");
+        appendNumber(sb, "Outstanding requests:    ", mPerfListener.getOutstandingRequests(), "\n");
+        appendNumber(sb, "Cancelled requests:      ", mPerfListener.getCancelledRequests(), "\n");
+        final String message = sb.toString();
+        mStatsDisplay.setText(message);
+        FLog.i(TAG, message);
+    }
+
+    private static void appendSize(StringBuilder sb, String prefix, long bytes, String suffix) {
+        String value = String.format(Locale.getDefault(), "%.2f", (float) bytes / BYTES_IN_MEGABYTE);
+        appendValue(sb, prefix, value + " MB", suffix);
+    }
+
+    private static void appendTime(StringBuilder sb, String prefix, long timeMs, String suffix) {
+        appendValue(sb, prefix, timeMs + " ms", suffix);
+    }
+
+    private static void appendNumber(StringBuilder sb, String prefix, long number, String suffix) {
+        appendValue(sb, prefix, number + "", suffix);
+    }
+
+    private static void appendValue(StringBuilder sb, String prefix, String value, String suffix) {
+        sb.append(prefix).append(value).append(suffix);
     }
-  }
-
-  private void updateStats() {
-    final Runtime runtime = Runtime.getRuntime();
-    final long heapMemory = runtime.totalMemory() - runtime.freeMemory();
-    final StringBuilder sb = new StringBuilder(DEFAULT_MESSAGE_SIZE);
-    // When changing format of output below, make sure to sync "scripts/test_runner.py" as well.
-    appendSize(sb, "Java heap size:          ", heapMemory, "\n");
-    appendSize(sb, "Native heap size:        ", Debug.getNativeHeapSize(), "\n");
-    appendTime(sb, "Average photo wait time: ", mPerfListener.getAverageWaitTime(), "\n");
-    appendNumber(sb, "Outstanding requests:    ", mPerfListener.getOutstandingRequests(), "\n");
-    appendNumber(sb, "Cancelled requests:      ", mPerfListener.getCancelledRequests(), "\n");
-    final String message = sb.toString();
-    mStatsDisplay.setText(message);
-    FLog.i(TAG, message);
-  }
-
-  private static void appendSize(StringBuilder sb, String prefix, long bytes, String suffix) {
-    String value = String.format(Locale.getDefault(), "%.2f", (float) bytes / BYTES_IN_MEGABYTE);
-    appendValue(sb, prefix, value + " MB", suffix);
-  }
-
-  private static void appendTime(StringBuilder sb, String prefix, long timeMs, String suffix) {
-    appendValue(sb, prefix, timeMs + " ms", suffix);
-  }
-
-  private static void appendNumber(StringBuilder sb, String prefix, long number, String suffix) {
-    appendValue(sb, prefix, number + "", suffix);
-  }
-
-  private static void appendValue(StringBuilder sb, String prefix, String value, String suffix) {
-    sb.append(prefix).append(value).append(suffix);
-  }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/adapters/FrescoAdapter.java b/sample/src/main/java/com/facebook/fresco/sample/adapters/FrescoAdapter.java
index a29409fa9..a9083b597 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/adapters/FrescoAdapter.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/adapters/FrescoAdapter.java
@@ -29,51 +29,53 @@
 import com.facebook.imagepipeline.request.ImageRequest;
 import com.facebook.imagepipeline.request.ImageRequestBuilder;
 
-/** Populate the list view with images using the Fresco image pipeline. */
+/**
+ * Populate the list view with images using the Fresco image pipeline.
+ */
 public class FrescoAdapter extends ImageListAdapter<InstrumentedDraweeView> {
 
-  public FrescoAdapter(
-      Context context,
-      int resourceId,
-      PerfListener perfListener,
-      ImagePipelineConfig imagePipelineConfig) {
-    super(context, resourceId, perfListener);
-    Fresco.initialize(context, imagePipelineConfig);
-  }
+    public FrescoAdapter(
+            Context context,
+            int resourceId,
+            PerfListener perfListener,
+            ImagePipelineConfig imagePipelineConfig) {
+        super(context, resourceId, perfListener);
+        Fresco.initialize(context, imagePipelineConfig);
+    }
 
-  @Override
-  protected Class<InstrumentedDraweeView> getViewClass() {
-    return InstrumentedDraweeView.class;
-  }
+    @Override
+    protected Class<InstrumentedDraweeView> getViewClass() {
+        return InstrumentedDraweeView.class;
+    }
 
-  protected InstrumentedDraweeView createView() {
-    GenericDraweeHierarchy gdh = new GenericDraweeHierarchyBuilder(getContext().getResources())
-        .setPlaceholderImage(Drawables.sPlaceholderDrawable)
-        .setFailureImage(Drawables.sErrorDrawable)
-        .setRoundingParams(RoundingParams.asCircle())
-        .setProgressBarImage(new ProgressBarDrawable())
-        .build();
-    return new InstrumentedDraweeView(getContext(), gdh);
-  }
+    protected InstrumentedDraweeView createView() {
+        GenericDraweeHierarchy gdh = new GenericDraweeHierarchyBuilder(getContext().getResources())
+                .setPlaceholderImage(Drawables.sPlaceholderDrawable)
+                .setFailureImage(Drawables.sErrorDrawable)
+                .setRoundingParams(RoundingParams.asCircle())
+                .setProgressBarImage(new ProgressBarDrawable())
+                .build();
+        return new InstrumentedDraweeView(getContext(), gdh);
+    }
 
-  protected void bind(final InstrumentedDraweeView view, String uri) {
-    ImageRequest imageRequest =
-        ImageRequestBuilder.newBuilderWithSource(Uri.parse(uri))
-            .setResizeOptions(
-                new ResizeOptions(view.getLayoutParams().width, view.getLayoutParams().height))
-            .build();
-    DraweeController draweeController = Fresco.newDraweeControllerBuilder()
-        .setImageRequest(imageRequest)
-        .setOldController(view.getController())
-        .setControllerListener(view.getListener())
-        .setAutoPlayAnimations(true)
-        .build();
-    view.setController(draweeController);
-  }
+    protected void bind(final InstrumentedDraweeView view, String uri) {
+        ImageRequest imageRequest =
+                ImageRequestBuilder.newBuilderWithSource(Uri.parse(uri))
+                        .setResizeOptions(
+                                new ResizeOptions(view.getLayoutParams().width, view.getLayoutParams().height))
+                        .build();
+        DraweeController draweeController = Fresco.newDraweeControllerBuilder()
+                .setImageRequest(imageRequest)
+                .setOldController(view.getController())
+                .setControllerListener(view.getListener())
+                .setAutoPlayAnimations(true)
+                .build();
+        view.setController(draweeController);
+    }
 
-  @Override
-  public void shutDown() {
-    super.clear();
-    Fresco.shutDown();
-  }
+    @Override
+    public void shutDown() {
+        super.clear();
+        Fresco.shutDown();
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/adapters/GlideAdapter.java b/sample/src/main/java/com/facebook/fresco/sample/adapters/GlideAdapter.java
index 31126f5ca..6a0f01b63 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/adapters/GlideAdapter.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/adapters/GlideAdapter.java
@@ -19,39 +19,41 @@
 import com.facebook.fresco.sample.instrumentation.InstrumentedImageView;
 import com.facebook.fresco.sample.instrumentation.PerfListener;
 
-/** Populate the list view with images using the Glide library. */
+/**
+ * Populate the list view with images using the Glide library.
+ */
 public class GlideAdapter extends ImageListAdapter<InstrumentedImageView> {
 
-  private final Context mContext;
-
-  public GlideAdapter(Context context, int resourceId, PerfListener perfListener) {
-    super(context, resourceId, perfListener);
-    mContext = context;
-  }
-
-  @Override
-  protected Class<InstrumentedImageView> getViewClass() {
-    return InstrumentedImageView.class;
-  }
-
-  @Override
-  protected InstrumentedImageView createView() {
-    return new InstrumentedImageView(getContext());
-  }
-
-  @Override
-  protected void bind(InstrumentedImageView view, String uri) {
-    Glide.with(mContext)
-        .load(uri)
-        .placeholder(Drawables.sPlaceholderDrawable)
-        .error(Drawables.sErrorDrawable)
-        .crossFade()
-        .into(view);
-  }
-
-  @Override
-  public void shutDown() {
-    super.clear();
-    Glide.get(mContext).clearMemory();
-  }
+    private final Context mContext;
+
+    public GlideAdapter(Context context, int resourceId, PerfListener perfListener) {
+        super(context, resourceId, perfListener);
+        mContext = context;
+    }
+
+    @Override
+    protected Class<InstrumentedImageView> getViewClass() {
+        return InstrumentedImageView.class;
+    }
+
+    @Override
+    protected InstrumentedImageView createView() {
+        return new InstrumentedImageView(getContext());
+    }
+
+    @Override
+    protected void bind(InstrumentedImageView view, String uri) {
+        Glide.with(mContext)
+                .load(uri)
+                .placeholder(Drawables.sPlaceholderDrawable)
+                .error(Drawables.sErrorDrawable)
+                .crossFade()
+                .into(view);
+    }
+
+    @Override
+    public void shutDown() {
+        super.clear();
+        Glide.get(mContext).clearMemory();
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/adapters/ImageListAdapter.java b/sample/src/main/java/com/facebook/fresco/sample/adapters/ImageListAdapter.java
index 1534fc0f9..90decbedd 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/adapters/ImageListAdapter.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/adapters/ImageListAdapter.java
@@ -25,60 +25,68 @@
 
 /**
  * Base class for the list view adapter.
- *
+ * <p>
  * <p>Subclasses are responsible for downloading images in the correct image loader,
  * and creating Views that can host that loader's views.
- *
+ * <p>
  * <p>The {@link #clear()} method should also be overridden to also clear the
  * loader's memory cache.
  */
 public abstract class ImageListAdapter<V extends View & Instrumented>
-  extends ArrayAdapter<String> {
-
-  private final PerfListener mPerfListener;
-
-  public ImageListAdapter(Context context, int resource, PerfListener perfListener) {
-    super(context, resource);
-    mPerfListener = perfListener;
-  }
-
-  private int calcDesiredSize(int parentWidth, int parentHeight) {
-    int orientation = getContext().getResources().getConfiguration().orientation;
-    int desiredSize = (orientation == Configuration.ORIENTATION_LANDSCAPE) ?
-        parentHeight / 2 : parentHeight / 3;
-    return Math.min(desiredSize, parentWidth);
-  }
-
-  @Override
-  public View getView(int position, View convertView, ViewGroup parent) {
-    V view = getViewClass().isInstance(convertView) ? (V) convertView : createView();
-
-    int size = calcDesiredSize(parent.getWidth(), parent.getHeight());
-    updateViewLayoutParams(view, size, size);
-
-    String uri = getItem(position);
-    view.initInstrumentation(uri, mPerfListener);
-    bind(view, uri);
-    return view;
-  }
-
-  private static void updateViewLayoutParams(View view, int width, int height) {
-    ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
-    if (layoutParams == null || layoutParams.height != width || layoutParams.width != height) {
-      layoutParams = new AbsListView.LayoutParams(width, height);
-      view.setLayoutParams(layoutParams);
+        extends ArrayAdapter<String> {
+
+    private final PerfListener mPerfListener;
+
+    public ImageListAdapter(Context context, int resource, PerfListener perfListener) {
+        super(context, resource);
+        mPerfListener = perfListener;
     }
-  }
 
-  /** The View subclass used by this adapter's image loader. */
-  protected abstract Class<V> getViewClass();
+    private int calcDesiredSize(int parentWidth, int parentHeight) {
+        int orientation = getContext().getResources().getConfiguration().orientation;
+        int desiredSize = (orientation == Configuration.ORIENTATION_LANDSCAPE) ?
+                parentHeight / 2 : parentHeight / 3;
+        return Math.min(desiredSize, parentWidth);
+    }
 
-  /** Create a View instance of the correct type. */
-  protected abstract V createView();
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        V view = getViewClass().isInstance(convertView) ? (V) convertView : createView();
 
-  /** Load an image of the specified uri into the view, asynchronously. */
-  protected abstract void bind(V view, String uri);
+        int size = calcDesiredSize(parent.getWidth(), parent.getHeight());
+        updateViewLayoutParams(view, size, size);
+
+        String uri = getItem(position);
+        view.initInstrumentation(uri, mPerfListener);
+        bind(view, uri);
+        return view;
+    }
+
+    private static void updateViewLayoutParams(View view, int width, int height) {
+        ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
+        if (layoutParams == null || layoutParams.height != width || layoutParams.width != height) {
+            layoutParams = new AbsListView.LayoutParams(width, height);
+            view.setLayoutParams(layoutParams);
+        }
+    }
 
-  /** Releases any resources and tears down the adapter. */
-  public abstract void shutDown();
+    /**
+     * The View subclass used by this adapter's image loader.
+     */
+    protected abstract Class<V> getViewClass();
+
+    /**
+     * Create a View instance of the correct type.
+     */
+    protected abstract V createView();
+
+    /**
+     * Load an image of the specified uri into the view, asynchronously.
+     */
+    protected abstract void bind(V view, String uri);
+
+    /**
+     * Releases any resources and tears down the adapter.
+     */
+    public abstract void shutDown();
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/adapters/PicassoAdapter.java b/sample/src/main/java/com/facebook/fresco/sample/adapters/PicassoAdapter.java
index e9e46c7d5..520b3bf9a 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/adapters/PicassoAdapter.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/adapters/PicassoAdapter.java
@@ -21,41 +21,43 @@
 import com.facebook.fresco.sample.instrumentation.InstrumentedImageView;
 import com.facebook.fresco.sample.instrumentation.PerfListener;
 
-/** Populate the list view with images using the Picasso library. */
+/**
+ * Populate the list view with images using the Picasso library.
+ */
 public class PicassoAdapter extends ImageListAdapter<InstrumentedImageView> {
-  private final Picasso mPicasso;
-
-  public PicassoAdapter(Context context, int resourceId, PerfListener perfListener) {
-    super(context, resourceId, perfListener);
-    mPicasso = SamplePicassoFactory.getPicasso(context);
-  }
-
-  @Override
-  protected Class<InstrumentedImageView> getViewClass() {
-    return InstrumentedImageView.class;
-  }
-
-  @Override
-  protected InstrumentedImageView createView() {
-    return new InstrumentedImageView(getContext());
-  }
-
-  @Override
-  protected void bind(InstrumentedImageView view, String uri) {
-    mPicasso
-        .load(uri)
-        .placeholder(Drawables.sPlaceholderDrawable)
-        .error(Drawables.sErrorDrawable)
-        .fit()
-        .into(view);
-  }
-
-  @Override
-  public void shutDown() {
-    for (int i = 0; i < getCount(); i++) {
-      String uri = getItem(i);
-      mPicasso.invalidate(uri);
+    private final Picasso mPicasso;
+
+    public PicassoAdapter(Context context, int resourceId, PerfListener perfListener) {
+        super(context, resourceId, perfListener);
+        mPicasso = SamplePicassoFactory.getPicasso(context);
+    }
+
+    @Override
+    protected Class<InstrumentedImageView> getViewClass() {
+        return InstrumentedImageView.class;
+    }
+
+    @Override
+    protected InstrumentedImageView createView() {
+        return new InstrumentedImageView(getContext());
+    }
+
+    @Override
+    protected void bind(InstrumentedImageView view, String uri) {
+        mPicasso
+                .load(uri)
+                .placeholder(Drawables.sPlaceholderDrawable)
+                .error(Drawables.sErrorDrawable)
+                .fit()
+                .into(view);
+    }
+
+    @Override
+    public void shutDown() {
+        for (int i = 0; i < getCount(); i++) {
+            String uri = getItem(i);
+            mPicasso.invalidate(uri);
+        }
+        super.clear();
     }
-    super.clear();
-  }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/adapters/UilAdapter.java b/sample/src/main/java/com/facebook/fresco/sample/adapters/UilAdapter.java
index f8b53a24c..9adc8c4a3 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/adapters/UilAdapter.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/adapters/UilAdapter.java
@@ -19,34 +19,36 @@
 import com.facebook.fresco.sample.instrumentation.PerfListener;
 import com.nostra13.universalimageloader.core.ImageLoader;
 
-/** Populate the list view with images using the Universal Image Loader library. */
+/**
+ * Populate the list view with images using the Universal Image Loader library.
+ */
 public class UilAdapter extends ImageListAdapter<InstrumentedImageView> {
 
-  private final ImageLoader mImageLoader;
-
-  public UilAdapter(Context context, int resourceId, PerfListener perfListener) {
-    super(context, resourceId, perfListener);
-    mImageLoader = SampleUilFactory.getImageLoader(context);
-  }
-
-  @Override
-  protected Class<InstrumentedImageView> getViewClass() {
-    return InstrumentedImageView.class;
-  }
-
-  @Override
-  protected InstrumentedImageView createView() {
-    return new InstrumentedImageView(getContext());
-  }
-
-  @Override
-  protected void bind(InstrumentedImageView view, String uri) {
-    mImageLoader.displayImage(uri, view);
-  }
-
-  @Override
-  public void shutDown() {
-    super.clear();
-    mImageLoader.clearMemoryCache();
-  }
+    private final ImageLoader mImageLoader;
+
+    public UilAdapter(Context context, int resourceId, PerfListener perfListener) {
+        super(context, resourceId, perfListener);
+        mImageLoader = SampleUilFactory.getImageLoader(context);
+    }
+
+    @Override
+    protected Class<InstrumentedImageView> getViewClass() {
+        return InstrumentedImageView.class;
+    }
+
+    @Override
+    protected InstrumentedImageView createView() {
+        return new InstrumentedImageView(getContext());
+    }
+
+    @Override
+    protected void bind(InstrumentedImageView view, String uri) {
+        mImageLoader.displayImage(uri, view);
+    }
+
+    @Override
+    public void shutDown() {
+        super.clear();
+        mImageLoader.clearMemoryCache();
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/adapters/VolleyAdapter.java b/sample/src/main/java/com/facebook/fresco/sample/adapters/VolleyAdapter.java
index c6f8d687d..bdc801b46 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/adapters/VolleyAdapter.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/adapters/VolleyAdapter.java
@@ -21,35 +21,37 @@
 import com.facebook.fresco.sample.instrumentation.InstrumentedNetworkImageView;
 import com.facebook.fresco.sample.instrumentation.PerfListener;
 
-/** Populate the list view with images using the Volley library's ImageLoader. */
+/**
+ * Populate the list view with images using the Volley library's ImageLoader.
+ */
 public class VolleyAdapter extends ImageListAdapter<InstrumentedNetworkImageView> {
 
-  private final ImageLoader mImageLoader;
-
-  public VolleyAdapter(Context context, int resourceId, PerfListener perfListener) {
-    super(context, resourceId, perfListener);
-    mImageLoader = SampleVolleyFactory.getImageLoader(context);
-  }
-
-  @Override
-  protected Class<InstrumentedNetworkImageView> getViewClass() {
-    return InstrumentedNetworkImageView.class;
-  }
-
-  protected InstrumentedNetworkImageView createView() {
-    InstrumentedNetworkImageView view = new InstrumentedNetworkImageView(getContext());
-    view.setDefaultImageResId(R.color.placeholder);
-    view.setErrorImageResId(R.color.error);
-    return view;
-  }
-
-  protected void bind(InstrumentedNetworkImageView view, String uri) {
-    view.setImageUrl(uri, mImageLoader);
-  }
-
-  @Override
-  public void shutDown() {
-    super.clear();
-    SampleVolleyFactory.getMemoryCache().clear();
-  }
+    private final ImageLoader mImageLoader;
+
+    public VolleyAdapter(Context context, int resourceId, PerfListener perfListener) {
+        super(context, resourceId, perfListener);
+        mImageLoader = SampleVolleyFactory.getImageLoader(context);
+    }
+
+    @Override
+    protected Class<InstrumentedNetworkImageView> getViewClass() {
+        return InstrumentedNetworkImageView.class;
+    }
+
+    protected InstrumentedNetworkImageView createView() {
+        InstrumentedNetworkImageView view = new InstrumentedNetworkImageView(getContext());
+        view.setDefaultImageResId(R.color.placeholder);
+        view.setErrorImageResId(R.color.error);
+        return view;
+    }
+
+    protected void bind(InstrumentedNetworkImageView view, String uri) {
+        view.setImageUrl(uri, mImageLoader);
+    }
+
+    @Override
+    public void shutDown() {
+        super.clear();
+        SampleVolleyFactory.getMemoryCache().clear();
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/adapters/VolleyDraweeAdapter.java b/sample/src/main/java/com/facebook/fresco/sample/adapters/VolleyDraweeAdapter.java
index 8ca479fa1..1ec9fe478 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/adapters/VolleyDraweeAdapter.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/adapters/VolleyDraweeAdapter.java
@@ -25,43 +25,45 @@
 import com.facebook.fresco.sample.instrumentation.InstrumentedDraweeView;
 import com.facebook.fresco.sample.instrumentation.PerfListener;
 
-/** Populate the list view with images using Drawee backed by Volley. */
+/**
+ * Populate the list view with images using Drawee backed by Volley.
+ */
 public class VolleyDraweeAdapter extends ImageListAdapter<InstrumentedDraweeView> {
 
-  private VolleyDraweeControllerBuilderSupplier mVolleyDraweeControllerBuilderSupplier;
+    private VolleyDraweeControllerBuilderSupplier mVolleyDraweeControllerBuilderSupplier;
 
-  public VolleyDraweeAdapter(Context context, int resourceId, PerfListener perfListener) {
-    super(context, resourceId, perfListener);
-    mVolleyDraweeControllerBuilderSupplier = new VolleyDraweeControllerBuilderSupplier(
-        context,
-        SampleVolleyFactory.getImageLoader(context));
-    InstrumentedDraweeView.initialize(mVolleyDraweeControllerBuilderSupplier);
-  }
+    public VolleyDraweeAdapter(Context context, int resourceId, PerfListener perfListener) {
+        super(context, resourceId, perfListener);
+        mVolleyDraweeControllerBuilderSupplier = new VolleyDraweeControllerBuilderSupplier(
+                context,
+                SampleVolleyFactory.getImageLoader(context));
+        InstrumentedDraweeView.initialize(mVolleyDraweeControllerBuilderSupplier);
+    }
 
-  @Override
-  protected Class<InstrumentedDraweeView> getViewClass() {
-    return InstrumentedDraweeView.class;
-  }
+    @Override
+    protected Class<InstrumentedDraweeView> getViewClass() {
+        return InstrumentedDraweeView.class;
+    }
 
-  protected InstrumentedDraweeView createView() {
-    GenericDraweeHierarchy gdh = new GenericDraweeHierarchyBuilder(getContext().getResources())
-        .setPlaceholderImage(Drawables.sPlaceholderDrawable)
-        .setFailureImage(Drawables.sErrorDrawable)
-        .setRoundingParams(RoundingParams.asCircle())
-        .build();
-    InstrumentedDraweeView view = new InstrumentedDraweeView(getContext());
-    view.setHierarchy(gdh);
-    return view;
-  }
+    protected InstrumentedDraweeView createView() {
+        GenericDraweeHierarchy gdh = new GenericDraweeHierarchyBuilder(getContext().getResources())
+                .setPlaceholderImage(Drawables.sPlaceholderDrawable)
+                .setFailureImage(Drawables.sErrorDrawable)
+                .setRoundingParams(RoundingParams.asCircle())
+                .build();
+        InstrumentedDraweeView view = new InstrumentedDraweeView(getContext());
+        view.setHierarchy(gdh);
+        return view;
+    }
 
-  protected void bind(InstrumentedDraweeView view, String uri) {
-    view.setImageURI(Uri.parse(uri));
-  }
+    protected void bind(InstrumentedDraweeView view, String uri) {
+        view.setImageURI(Uri.parse(uri));
+    }
 
-  @Override
-  public void shutDown() {
-    super.clear();
-    InstrumentedDraweeView.shutDown();
-    SampleVolleyFactory.getMemoryCache().clear();
-  }
+    @Override
+    public void shutDown() {
+        super.clear();
+        InstrumentedDraweeView.shutDown();
+        SampleVolleyFactory.getMemoryCache().clear();
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/configs/ConfigConstants.java b/sample/src/main/java/com/facebook/fresco/sample/configs/ConfigConstants.java
index 274c30e43..a7b1b8655 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/configs/ConfigConstants.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/configs/ConfigConstants.java
@@ -15,8 +15,8 @@
 import com.facebook.common.util.ByteConstants;
 
 public class ConfigConstants {
-  private static final int MAX_HEAP_SIZE = (int) Runtime.getRuntime().maxMemory();
+    private static final int MAX_HEAP_SIZE = (int) Runtime.getRuntime().maxMemory();
 
-  public static final int MAX_DISK_CACHE_SIZE = 40 * ByteConstants.MB;
-  public static final int MAX_MEMORY_CACHE_SIZE = MAX_HEAP_SIZE / 4;
+    public static final int MAX_DISK_CACHE_SIZE = 40 * ByteConstants.MB;
+    public static final int MAX_MEMORY_CACHE_SIZE = MAX_HEAP_SIZE / 4;
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/configs/glide/SampleGlideModule.java b/sample/src/main/java/com/facebook/fresco/sample/configs/glide/SampleGlideModule.java
index 341722c86..cf307f2a2 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/configs/glide/SampleGlideModule.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/configs/glide/SampleGlideModule.java
@@ -27,21 +27,21 @@
  * {@link com.bumptech.glide.module.GlideModule} implementation for the sample app.
  */
 public class SampleGlideModule implements GlideModule {
-  @Override
-  public void applyOptions(final Context context, GlideBuilder builder) {
-    builder.setDiskCache(
-        new DiskCache.Factory() {
-          @Override
-          public DiskCache build() {
-            return DiskLruCacheWrapper.get(
-                Glide.getPhotoCacheDir(context),
-                ConfigConstants.MAX_DISK_CACHE_SIZE);
-          }
-        });
-    builder.setMemoryCache(new LruResourceCache(ConfigConstants.MAX_MEMORY_CACHE_SIZE));
-  }
+    @Override
+    public void applyOptions(final Context context, GlideBuilder builder) {
+        builder.setDiskCache(
+                new DiskCache.Factory() {
+                    @Override
+                    public DiskCache build() {
+                        return DiskLruCacheWrapper.get(
+                                Glide.getPhotoCacheDir(context),
+                                ConfigConstants.MAX_DISK_CACHE_SIZE);
+                    }
+                });
+        builder.setMemoryCache(new LruResourceCache(ConfigConstants.MAX_MEMORY_CACHE_SIZE));
+    }
 
-  @Override
-  public void registerComponents(Context context, Glide glide) {
-  }
+    @Override
+    public void registerComponents(Context context, Glide glide) {
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/configs/imagepipeline/ImagePipelineConfigFactory.java b/sample/src/main/java/com/facebook/fresco/sample/configs/imagepipeline/ImagePipelineConfigFactory.java
index 955f7d24b..98cad32fa 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/configs/imagepipeline/ImagePipelineConfigFactory.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/configs/imagepipeline/ImagePipelineConfigFactory.java
@@ -29,61 +29,61 @@
  * Creates ImagePipeline configuration for the sample app
  */
 public class ImagePipelineConfigFactory {
-  private static final String IMAGE_PIPELINE_CACHE_DIR = "imagepipeline_cache";
+    private static final String IMAGE_PIPELINE_CACHE_DIR = "imagepipeline_cache";
 
-  private static ImagePipelineConfig sImagePipelineConfig;
-  private static ImagePipelineConfig sOkHttpImagePipelineConfig;
+    private static ImagePipelineConfig sImagePipelineConfig;
+    private static ImagePipelineConfig sOkHttpImagePipelineConfig;
 
-  /**
-   * Creates config using android http stack as network backend.
-   */
-  public static ImagePipelineConfig getImagePipelineConfig(Context context) {
-    if (sImagePipelineConfig == null) {
-      ImagePipelineConfig.Builder configBuilder = ImagePipelineConfig.newBuilder(context);
-      configureCaches(configBuilder, context);
-      sImagePipelineConfig = configBuilder.build();
+    /**
+     * Creates config using android http stack as network backend.
+     */
+    public static ImagePipelineConfig getImagePipelineConfig(Context context) {
+        if (sImagePipelineConfig == null) {
+            ImagePipelineConfig.Builder configBuilder = ImagePipelineConfig.newBuilder(context);
+            configureCaches(configBuilder, context);
+            sImagePipelineConfig = configBuilder.build();
+        }
+        return sImagePipelineConfig;
     }
-    return sImagePipelineConfig;
-  }
 
-  /**
-   * Creates config using OkHttp as network backed.
-   */
-  public static ImagePipelineConfig getOkHttpImagePipelineConfig(Context context) {
-    if (sOkHttpImagePipelineConfig == null) {
-      OkHttpClient okHttpClient = new OkHttpClient();
-      ImagePipelineConfig.Builder configBuilder =
-        OkHttpImagePipelineConfigFactory.newBuilder(context, okHttpClient);
-      configureCaches(configBuilder, context);
-      sOkHttpImagePipelineConfig = configBuilder.build();
+    /**
+     * Creates config using OkHttp as network backed.
+     */
+    public static ImagePipelineConfig getOkHttpImagePipelineConfig(Context context) {
+        if (sOkHttpImagePipelineConfig == null) {
+            OkHttpClient okHttpClient = new OkHttpClient();
+            ImagePipelineConfig.Builder configBuilder =
+                    OkHttpImagePipelineConfigFactory.newBuilder(context, okHttpClient);
+            configureCaches(configBuilder, context);
+            sOkHttpImagePipelineConfig = configBuilder.build();
+        }
+        return sOkHttpImagePipelineConfig;
     }
-    return sOkHttpImagePipelineConfig;
-  }
 
-  /**
-   * Configures disk and memory cache not to exceed common limits
-   */
-  private static void configureCaches(
-      ImagePipelineConfig.Builder configBuilder,
-      Context context) {
-    final MemoryCacheParams bitmapCacheParams = new MemoryCacheParams(
-        ConfigConstants.MAX_MEMORY_CACHE_SIZE, // Max total size of elements in the cache
-        Integer.MAX_VALUE,                     // Max entries in the cache
-        ConfigConstants.MAX_MEMORY_CACHE_SIZE, // Max total size of elements in eviction queue
-        Integer.MAX_VALUE,                     // Max length of eviction queue
-        Integer.MAX_VALUE);                    // Max cache entry size
-    configBuilder
-        .setBitmapMemoryCacheParamsSupplier(
-            new Supplier<MemoryCacheParams>() {
-              public MemoryCacheParams get() {
-                return bitmapCacheParams;
-              }
-            })
-        .setMainDiskCacheConfig(
-            DiskCacheConfig.newBuilder()
-                .setBaseDirectoryPath(context.getApplicationContext().getCacheDir())
-                .setBaseDirectoryName(IMAGE_PIPELINE_CACHE_DIR)
-                .setMaxCacheSize(ConfigConstants.MAX_DISK_CACHE_SIZE)
-                .build());
-  }
+    /**
+     * Configures disk and memory cache not to exceed common limits
+     */
+    private static void configureCaches(
+            ImagePipelineConfig.Builder configBuilder,
+            Context context) {
+        final MemoryCacheParams bitmapCacheParams = new MemoryCacheParams(
+                ConfigConstants.MAX_MEMORY_CACHE_SIZE, // Max total size of elements in the cache
+                Integer.MAX_VALUE,                     // Max entries in the cache
+                ConfigConstants.MAX_MEMORY_CACHE_SIZE, // Max total size of elements in eviction queue
+                Integer.MAX_VALUE,                     // Max length of eviction queue
+                Integer.MAX_VALUE);                    // Max cache entry size
+        configBuilder
+                .setBitmapMemoryCacheParamsSupplier(
+                        new Supplier<MemoryCacheParams>() {
+                            public MemoryCacheParams get() {
+                                return bitmapCacheParams;
+                            }
+                        })
+                .setMainDiskCacheConfig(
+                        DiskCacheConfig.newBuilder()
+                                .setBaseDirectoryPath(context.getApplicationContext().getCacheDir())
+                                .setBaseDirectoryName(IMAGE_PIPELINE_CACHE_DIR)
+                                .setMaxCacheSize(ConfigConstants.MAX_DISK_CACHE_SIZE)
+                                .build());
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/configs/picasso/SamplePicassoFactory.java b/sample/src/main/java/com/facebook/fresco/sample/configs/picasso/SamplePicassoFactory.java
index ad46c8723..9ee97cd41 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/configs/picasso/SamplePicassoFactory.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/configs/picasso/SamplePicassoFactory.java
@@ -25,15 +25,15 @@
  */
 public class SamplePicassoFactory {
 
-  private static Picasso sPicasso;
+    private static Picasso sPicasso;
 
-  public static Picasso getPicasso(Context context) {
-    if (sPicasso == null) {
-        sPicasso = new Picasso.Builder(context)
-            .downloader(new OkHttpDownloader(context, ConfigConstants.MAX_DISK_CACHE_SIZE))
-            .memoryCache(new LruCache(ConfigConstants.MAX_MEMORY_CACHE_SIZE))
-            .build();
+    public static Picasso getPicasso(Context context) {
+        if (sPicasso == null) {
+            sPicasso = new Picasso.Builder(context)
+                    .downloader(new OkHttpDownloader(context, ConfigConstants.MAX_DISK_CACHE_SIZE))
+                    .memoryCache(new LruCache(ConfigConstants.MAX_MEMORY_CACHE_SIZE))
+                    .build();
+        }
+        return sPicasso;
     }
-    return sPicasso;
-  }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/configs/uil/SampleUilFactory.java b/sample/src/main/java/com/facebook/fresco/sample/configs/uil/SampleUilFactory.java
index 21abd3580..c136343c5 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/configs/uil/SampleUilFactory.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/configs/uil/SampleUilFactory.java
@@ -26,24 +26,24 @@
  * drawables.
  */
 public class SampleUilFactory {
-  private static ImageLoader sImageLoader;
+    private static ImageLoader sImageLoader;
 
-  public static ImageLoader getImageLoader(Context context) {
-    if (sImageLoader == null) {
-      DisplayImageOptions displayImageOptions = new DisplayImageOptions.Builder()
-          .showImageOnLoading(Drawables.sPlaceholderDrawable)
-          .showImageOnFail(Drawables.sErrorDrawable)
-          .cacheInMemory(true)
-          .cacheOnDisk(true)
-          .build();
-      ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(context)
-          .defaultDisplayImageOptions(displayImageOptions)
-          .diskCacheSize(ConfigConstants.MAX_DISK_CACHE_SIZE)
-          .memoryCacheSize(ConfigConstants.MAX_MEMORY_CACHE_SIZE)
-          .build();
-      sImageLoader = ImageLoader.getInstance();
-      sImageLoader.init(config);
+    public static ImageLoader getImageLoader(Context context) {
+        if (sImageLoader == null) {
+            DisplayImageOptions displayImageOptions = new DisplayImageOptions.Builder()
+                    .showImageOnLoading(Drawables.sPlaceholderDrawable)
+                    .showImageOnFail(Drawables.sErrorDrawable)
+                    .cacheInMemory(true)
+                    .cacheOnDisk(true)
+                    .build();
+            ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(context)
+                    .defaultDisplayImageOptions(displayImageOptions)
+                    .diskCacheSize(ConfigConstants.MAX_DISK_CACHE_SIZE)
+                    .memoryCacheSize(ConfigConstants.MAX_MEMORY_CACHE_SIZE)
+                    .build();
+            sImageLoader = ImageLoader.getInstance();
+            sImageLoader.init(config);
+        }
+        return sImageLoader;
     }
-    return sImageLoader;
-  }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/configs/volley/SampleVolleyFactory.java b/sample/src/main/java/com/facebook/fresco/sample/configs/volley/SampleVolleyFactory.java
index d0ee8e59e..608e01be4 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/configs/volley/SampleVolleyFactory.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/configs/volley/SampleVolleyFactory.java
@@ -27,35 +27,35 @@
  * Creates singletons of relevant volley classes
  */
 public class SampleVolleyFactory {
-  private static final String VOLLEY_CACHE_DIR = "volley";
-
-  private static ImageLoader sImageLoader;
-  private static RequestQueue sRequestQueue;
-  private static VolleyMemoryCache sMemoryCache;
-
-  public static RequestQueue getRequestQueue(Context context) {
-    if (sRequestQueue == null) {
-      File cacheDir = new File(context.getCacheDir(), VOLLEY_CACHE_DIR);
-      sRequestQueue = new RequestQueue(
-          new DiskBasedCache(cacheDir, ConfigConstants.MAX_DISK_CACHE_SIZE),
-          new BasicNetwork(new HurlStack()));
-      sRequestQueue.start();
+    private static final String VOLLEY_CACHE_DIR = "volley";
+
+    private static ImageLoader sImageLoader;
+    private static RequestQueue sRequestQueue;
+    private static VolleyMemoryCache sMemoryCache;
+
+    public static RequestQueue getRequestQueue(Context context) {
+        if (sRequestQueue == null) {
+            File cacheDir = new File(context.getCacheDir(), VOLLEY_CACHE_DIR);
+            sRequestQueue = new RequestQueue(
+                    new DiskBasedCache(cacheDir, ConfigConstants.MAX_DISK_CACHE_SIZE),
+                    new BasicNetwork(new HurlStack()));
+            sRequestQueue.start();
+        }
+        return sRequestQueue;
     }
-    return sRequestQueue;
-  }
 
 
-  public static VolleyMemoryCache getMemoryCache() {
-    if (sMemoryCache == null) {
-      sMemoryCache = new VolleyMemoryCache(ConfigConstants.MAX_MEMORY_CACHE_SIZE);
+    public static VolleyMemoryCache getMemoryCache() {
+        if (sMemoryCache == null) {
+            sMemoryCache = new VolleyMemoryCache(ConfigConstants.MAX_MEMORY_CACHE_SIZE);
+        }
+        return sMemoryCache;
     }
-    return sMemoryCache;
-  }
 
-  public static ImageLoader getImageLoader(Context context) {
-    if (sImageLoader == null) {
-      sImageLoader = new ImageLoader(getRequestQueue(context), getMemoryCache());
+    public static ImageLoader getImageLoader(Context context) {
+        if (sImageLoader == null) {
+            sImageLoader = new ImageLoader(getRequestQueue(context), getMemoryCache());
+        }
+        return sImageLoader;
     }
-    return sImageLoader;
-  }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/configs/volley/VolleyMemoryCache.java b/sample/src/main/java/com/facebook/fresco/sample/configs/volley/VolleyMemoryCache.java
index 6e0a5e1c8..4764df37d 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/configs/volley/VolleyMemoryCache.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/configs/volley/VolleyMemoryCache.java
@@ -21,27 +21,27 @@
  * Default bitmap memory cache for Volley.
  */
 public class VolleyMemoryCache implements ImageLoader.ImageCache {
-  private final LruCache<String, Bitmap> mLruCache;
-
-  public VolleyMemoryCache(int maxSize) {
-    mLruCache = new LruCache<String, Bitmap>(maxSize) {
-        protected int sizeOf(final String key, final Bitmap value) {
-          return value.getRowBytes() * value.getHeight();
-        }
-      };
-  }
-
-  @Override
-  public Bitmap getBitmap(String url) {
-    return mLruCache.get(url);
-  }
-
-  @Override
-  public void putBitmap(String url, Bitmap bitmap) {
-    mLruCache.put(url, bitmap);
-  }
-
-  public void clear() {
-    mLruCache.evictAll();
-  }
+    private final LruCache<String, Bitmap> mLruCache;
+
+    public VolleyMemoryCache(int maxSize) {
+        mLruCache = new LruCache<String, Bitmap>(maxSize) {
+            protected int sizeOf(final String key, final Bitmap value) {
+                return value.getRowBytes() * value.getHeight();
+            }
+        };
+    }
+
+    @Override
+    public Bitmap getBitmap(String url) {
+        return mLruCache.get(url);
+    }
+
+    @Override
+    public void putBitmap(String url, Bitmap bitmap) {
+        mLruCache.put(url, bitmap);
+    }
+
+    public void clear() {
+        mLruCache.evictAll();
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/Instrumentation.java b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/Instrumentation.java
index 4d14f820e..5f4bec173 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/Instrumentation.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/Instrumentation.java
@@ -23,109 +23,111 @@
 
 /**
  * Tracks state of image request.
- *
+ * <p>
  * <p/> Components that implement {@link Instrumented} interface can use this class to track their
  * requests.
  */
 public class Instrumentation {
-  private static final String TAG = "Instrumentation";
-
-  private static enum ImageRequestState {
-    NOT_STARTED,
-    STARTED,
-    SUCCESS,
-    FAILURE,
-    CANCELLATION,
-  }
-
-  private final Paint mPaint;
-  private final Rect mTextRect;
-  private final View mView;
-
-  private PerfListener mPerfListener;
-  private long mStartTime;
-  private String mTag;
-  private long mFinishTime;
-  private ImageRequestState mState;
-
-  public Instrumentation(View view) {
-    mPaint = new Paint();
-    mTextRect = new Rect();
-    mView = view;
-    mState = ImageRequestState.NOT_STARTED;
-  }
-
-  public void init(final String tag, final PerfListener perfListener) {
-    mTag = Preconditions.checkNotNull(tag);
-    mPerfListener = Preconditions.checkNotNull(perfListener);
-  }
-
-  public void onStart() {
-    Preconditions.checkNotNull(mTag);
-    Preconditions.checkNotNull(mPerfListener);
-    if (mState == ImageRequestState.STARTED) {
-      onCancellation();
+    private static final String TAG = "Instrumentation";
+
+    private static enum ImageRequestState {
+        NOT_STARTED,
+        STARTED,
+        SUCCESS,
+        FAILURE,
+        CANCELLATION,
+    }
+
+    private final Paint mPaint;
+    private final Rect mTextRect;
+    private final View mView;
+
+    private PerfListener mPerfListener;
+    private long mStartTime;
+    private String mTag;
+    private long mFinishTime;
+    private ImageRequestState mState;
+
+    public Instrumentation(View view) {
+        mPaint = new Paint();
+        mTextRect = new Rect();
+        mView = view;
+        mState = ImageRequestState.NOT_STARTED;
     }
-    mStartTime = System.currentTimeMillis();
-    mFinishTime = 0;
-    mPerfListener.reportStart();
-    mState = ImageRequestState.STARTED;
-    FLog.i(TAG, "Image [%s]: loading started...", mTag);
-  }
-
-  public void onSuccess() {
-    Preconditions.checkState(mState == ImageRequestState.STARTED);
-    mState = ImageRequestState.SUCCESS;
-    mFinishTime = System.currentTimeMillis();
-    final long elapsedTime = mFinishTime - mStartTime;
-    mPerfListener.reportSuccess(elapsedTime);
-    FLog.i(TAG, "Image [%s]: loaded after %d ms", mTag, elapsedTime);
-  }
-
-  public void onFailure() {
-    Preconditions.checkState(mState == ImageRequestState.STARTED);
-    mState = ImageRequestState.FAILURE;
-    mFinishTime = System.currentTimeMillis();
-    final long elapsedTime = mFinishTime - mStartTime;
-    mPerfListener.reportFailure(elapsedTime);
-    FLog.i(TAG, "Image [%s]: failed after %d ms", mTag, elapsedTime);
-  }
-
-  public void onCancellation() {
-    if (mState != ImageRequestState.STARTED) {
-      return;
+
+    public void init(final String tag, final PerfListener perfListener) {
+        mTag = Preconditions.checkNotNull(tag);
+        mPerfListener = Preconditions.checkNotNull(perfListener);
     }
-    mState = ImageRequestState.CANCELLATION;
-    mFinishTime = System.currentTimeMillis();
-    final long elapsedTime = mFinishTime - mStartTime;
-    mPerfListener.reportCancellation(elapsedTime);
-    FLog.i(TAG, "Image [%s]: cancelled after %d ms", mTag, elapsedTime);
-  }
-
-  /** Draws overlay with request state for easier visual inspection. */
-  public void onDraw(final Canvas canvas) {
-    mPaint.setColor(0xC0000000);
-    mTextRect.set(0, 0, mView.getWidth(), 35);
-    canvas.drawRect(mTextRect, mPaint);
-
-    mPaint.setColor(Color.WHITE);
-    canvas.drawText("[" + mTag + "]", 10, 15, mPaint);
-
-    String message = "Not started";
-    switch (mState) {
-      case STARTED:
-        message = "Loading...";
-        break;
-      case SUCCESS:
-        message = "Loaded after " + (mFinishTime - mStartTime) + "ms";
-        break;
-      case FAILURE:
-        message = "Failed after " + (mFinishTime - mStartTime) + "ms";
-        break;
-      case CANCELLATION:
-        message = "Cancelled after " + (mFinishTime - mStartTime) + "ms";
-        break;
+
+    public void onStart() {
+        Preconditions.checkNotNull(mTag);
+        Preconditions.checkNotNull(mPerfListener);
+        if (mState == ImageRequestState.STARTED) {
+            onCancellation();
+        }
+        mStartTime = System.currentTimeMillis();
+        mFinishTime = 0;
+        mPerfListener.reportStart();
+        mState = ImageRequestState.STARTED;
+        FLog.i(TAG, "Image [%s]: loading started...", mTag);
+    }
+
+    public void onSuccess() {
+        Preconditions.checkState(mState == ImageRequestState.STARTED);
+        mState = ImageRequestState.SUCCESS;
+        mFinishTime = System.currentTimeMillis();
+        final long elapsedTime = mFinishTime - mStartTime;
+        mPerfListener.reportSuccess(elapsedTime);
+        FLog.i(TAG, "Image [%s]: loaded after %d ms", mTag, elapsedTime);
+    }
+
+    public void onFailure() {
+        Preconditions.checkState(mState == ImageRequestState.STARTED);
+        mState = ImageRequestState.FAILURE;
+        mFinishTime = System.currentTimeMillis();
+        final long elapsedTime = mFinishTime - mStartTime;
+        mPerfListener.reportFailure(elapsedTime);
+        FLog.i(TAG, "Image [%s]: failed after %d ms", mTag, elapsedTime);
+    }
+
+    public void onCancellation() {
+        if (mState != ImageRequestState.STARTED) {
+            return;
+        }
+        mState = ImageRequestState.CANCELLATION;
+        mFinishTime = System.currentTimeMillis();
+        final long elapsedTime = mFinishTime - mStartTime;
+        mPerfListener.reportCancellation(elapsedTime);
+        FLog.i(TAG, "Image [%s]: cancelled after %d ms", mTag, elapsedTime);
+    }
+
+    /**
+     * Draws overlay with request state for easier visual inspection.
+     */
+    public void onDraw(final Canvas canvas) {
+        mPaint.setColor(0xC0000000);
+        mTextRect.set(0, 0, mView.getWidth(), 35);
+        canvas.drawRect(mTextRect, mPaint);
+
+        mPaint.setColor(Color.WHITE);
+        canvas.drawText("[" + mTag + "]", 10, 15, mPaint);
+
+        String message = "Not started";
+        switch (mState) {
+            case STARTED:
+                message = "Loading...";
+                break;
+            case SUCCESS:
+                message = "Loaded after " + (mFinishTime - mStartTime) + "ms";
+                break;
+            case FAILURE:
+                message = "Failed after " + (mFinishTime - mStartTime) + "ms";
+                break;
+            case CANCELLATION:
+                message = "Cancelled after " + (mFinishTime - mStartTime) + "ms";
+                break;
+        }
+        canvas.drawText(message, 10, 30, mPaint);
     }
-    canvas.drawText(message, 10, 30, mPaint);
-  }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/Instrumented.java b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/Instrumented.java
index e4095b16a..64fecf8a9 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/Instrumented.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/Instrumented.java
@@ -17,11 +17,11 @@
  */
 public interface Instrumented {
 
-  /**
-   * Forget what happened so far and start measuring once again.
-   *
-   * @param tag String used to identify the image request
-   * @param perfListener listener to be used to track the request state
-   */
-  void initInstrumentation(final String tag, PerfListener perfListener);
+    /**
+     * Forget what happened so far and start measuring once again.
+     *
+     * @param tag          String used to identify the image request
+     * @param perfListener listener to be used to track the request state
+     */
+    void initInstrumentation(final String tag, PerfListener perfListener);
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedDraweeView.java b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedDraweeView.java
index 00b3ff00e..d51a99bfa 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedDraweeView.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedDraweeView.java
@@ -32,79 +32,82 @@
  */
 public class InstrumentedDraweeView extends SimpleDraweeView implements Instrumented {
 
-  private Instrumentation mInstrumentation;
-  private ControllerListener<Object> mListener;
-
-  public InstrumentedDraweeView(Context context, GenericDraweeHierarchy hierarchy) {
-    super(context, hierarchy);
-    init();
-  }
-
-  public InstrumentedDraweeView(Context context) {
-    super(context);
-    init();
-  }
-
-  public InstrumentedDraweeView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-    init();
-  }
-
-  public InstrumentedDraweeView(Context context, AttributeSet attrs, int defStyle) {
-    super(context, attrs, defStyle);
-    init();
-  }
-
-  private void init() {
-    mInstrumentation = new Instrumentation(this);
-    mListener = new BaseControllerListener<Object>() {
-      @Override
-      public void onSubmit(String id, Object callerContext) {
-        mInstrumentation.onStart();
-      }
-      @Override
-      public void onFinalImageSet(
-        String id,
-        @Nullable Object imageInfo,
-        @Nullable Animatable animatable) {
-        mInstrumentation.onSuccess();
-      }
-      @Override
-      public void onFailure(String id, Throwable throwable) {
-        mInstrumentation.onFailure();
-      }
-      @Override
-      public void onRelease(String id) {
-        mInstrumentation.onCancellation();
-      }
-    };
-  }
-
-  @Override
-  public void initInstrumentation(String tag, PerfListener perfListener) {
-    mInstrumentation.init(tag, perfListener);
-  }
-
-  @Override
-  public void onDraw(final Canvas canvas) {
-    super.onDraw(canvas);
-    mInstrumentation.onDraw(canvas);
-  }
-
-  @Override
-  public void setImageURI(Uri uri, @Nullable Object callerContext) {
-    SimpleDraweeControllerBuilder controllerBuilder = getControllerBuilder()
-        .setUri(uri)
-        .setCallerContext(callerContext)
-        .setOldController(getController());
-    if (controllerBuilder instanceof AbstractDraweeControllerBuilder) {
-      ((AbstractDraweeControllerBuilder<?,?,?,?>) controllerBuilder)
-          .setControllerListener(mListener);
+    private Instrumentation mInstrumentation;
+    private ControllerListener<Object> mListener;
+
+    public InstrumentedDraweeView(Context context, GenericDraweeHierarchy hierarchy) {
+        super(context, hierarchy);
+        init();
+    }
+
+    public InstrumentedDraweeView(Context context) {
+        super(context);
+        init();
+    }
+
+    public InstrumentedDraweeView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
     }
-    setController(controllerBuilder.build());
-  }
 
-  public ControllerListener<Object> getListener() {
-    return mListener;
-  }
+    public InstrumentedDraweeView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init();
+    }
+
+    private void init() {
+        mInstrumentation = new Instrumentation(this);
+        mListener = new BaseControllerListener<Object>() {
+            @Override
+            public void onSubmit(String id, Object callerContext) {
+                mInstrumentation.onStart();
+            }
+
+            @Override
+            public void onFinalImageSet(
+                    String id,
+                    @Nullable Object imageInfo,
+                    @Nullable Animatable animatable) {
+                mInstrumentation.onSuccess();
+            }
+
+            @Override
+            public void onFailure(String id, Throwable throwable) {
+                mInstrumentation.onFailure();
+            }
+
+            @Override
+            public void onRelease(String id) {
+                mInstrumentation.onCancellation();
+            }
+        };
+    }
+
+    @Override
+    public void initInstrumentation(String tag, PerfListener perfListener) {
+        mInstrumentation.init(tag, perfListener);
+    }
+
+    @Override
+    public void onDraw(final Canvas canvas) {
+        super.onDraw(canvas);
+        mInstrumentation.onDraw(canvas);
+    }
+
+    @Override
+    public void setImageURI(Uri uri, @Nullable Object callerContext) {
+        SimpleDraweeControllerBuilder controllerBuilder = getControllerBuilder()
+                .setUri(uri)
+                .setCallerContext(callerContext)
+                .setOldController(getController());
+        if (controllerBuilder instanceof AbstractDraweeControllerBuilder) {
+            ((AbstractDraweeControllerBuilder<?, ?, ?, ?>) controllerBuilder)
+                    .setControllerListener(mListener);
+        }
+        setController(controllerBuilder.build());
+    }
+
+    public ControllerListener<Object> getListener() {
+        return mListener;
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedImageView.java b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedImageView.java
index 29253e675..9d5c2e90a 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedImageView.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedImageView.java
@@ -24,58 +24,58 @@
 /**
  * {@link ImageView} that notifies its instance of {@link Instrumentation} whenever an image request
  * lifecycle event happens.
- *
+ * <p>
  * <p> setImageResource and setImageURI methods are not expected to be used by any library,
  * UnsupportedOperationException is thrown if those are called
  */
 public class InstrumentedImageView extends ImageView implements Instrumented {
 
-  private final Instrumentation mInstrumentation;
+    private final Instrumentation mInstrumentation;
 
-  public InstrumentedImageView(final Context context) {
-    super(context);
-    mInstrumentation = new Instrumentation(this);
-  }
+    public InstrumentedImageView(final Context context) {
+        super(context);
+        mInstrumentation = new Instrumentation(this);
+    }
 
-  @Override
-  public void initInstrumentation(final String tag, PerfListener perfListener) {
-    mInstrumentation.init(tag, perfListener);
-    // we don't have a better estimate on when to call onStart, so do it here.
-    mInstrumentation.onStart();
-  }
+    @Override
+    public void initInstrumentation(final String tag, PerfListener perfListener) {
+        mInstrumentation.init(tag, perfListener);
+        // we don't have a better estimate on when to call onStart, so do it here.
+        mInstrumentation.onStart();
+    }
 
-  @Override
-  public void onDraw(final Canvas canvas) {
-    super.onDraw(canvas);
-    mInstrumentation.onDraw(canvas);
-  }
+    @Override
+    public void onDraw(final Canvas canvas) {
+        super.onDraw(canvas);
+        mInstrumentation.onDraw(canvas);
+    }
 
-  @Override
-  public void setImageDrawable(final Drawable drawable) {
-    Preconditions.checkNotNull(drawable);
-    if (drawable == Drawables.sPlaceholderDrawable) {
-      // ignore
-    } else if (drawable == Drawables.sErrorDrawable) {
-      mInstrumentation.onFailure();
-    } else {
-      mInstrumentation.onSuccess();
+    @Override
+    public void setImageDrawable(final Drawable drawable) {
+        Preconditions.checkNotNull(drawable);
+        if (drawable == Drawables.sPlaceholderDrawable) {
+            // ignore
+        } else if (drawable == Drawables.sErrorDrawable) {
+            mInstrumentation.onFailure();
+        } else {
+            mInstrumentation.onSuccess();
+        }
+        super.setImageDrawable(drawable);
     }
-    super.setImageDrawable(drawable);
-  }
 
-  /**
-   * Throws UnsupportedOperationException
-   */
-  @Override
-  public void setImageResource(int resourceId) {
-    throw new UnsupportedOperationException();
-  }
+    /**
+     * Throws UnsupportedOperationException
+     */
+    @Override
+    public void setImageResource(int resourceId) {
+        throw new UnsupportedOperationException();
+    }
 
-  /**
-   * Throws UnsupportedOperationException
-   */
-  @Override
-  public void setImageURI(Uri uri) {
-    throw new UnsupportedOperationException();
-  }
+    /**
+     * Throws UnsupportedOperationException
+     */
+    @Override
+    public void setImageURI(Uri uri) {
+        throw new UnsupportedOperationException();
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedNetworkImageView.java b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedNetworkImageView.java
index 0e89f372f..dc8f92d18 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedNetworkImageView.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/InstrumentedNetworkImageView.java
@@ -26,45 +26,45 @@
  */
 public class InstrumentedNetworkImageView extends NetworkImageView implements Instrumented {
 
-  private final Instrumentation mInstrumentation;
+    private final Instrumentation mInstrumentation;
 
-  public InstrumentedNetworkImageView(final Context context) {
-    super(context);
-    mInstrumentation = new Instrumentation(this);
-  }
+    public InstrumentedNetworkImageView(final Context context) {
+        super(context);
+        mInstrumentation = new Instrumentation(this);
+    }
 
-  @Override
-  public void initInstrumentation(final String tag, final PerfListener perfListener) {
-    mInstrumentation.init(tag, perfListener);
-    // we don't have a better estimate on when to call onStart, so do it here.
-    mInstrumentation.onStart();
-  }
+    @Override
+    public void initInstrumentation(final String tag, final PerfListener perfListener) {
+        mInstrumentation.init(tag, perfListener);
+        // we don't have a better estimate on when to call onStart, so do it here.
+        mInstrumentation.onStart();
+    }
 
-  @Override
-  public void onDraw(final Canvas canvas) {
-    super.onDraw(canvas);
-    mInstrumentation.onDraw(canvas);
-  }
+    @Override
+    public void onDraw(final Canvas canvas) {
+        super.onDraw(canvas);
+        mInstrumentation.onDraw(canvas);
+    }
 
-  @Override
-  public void setImageBitmap(final Bitmap bm) {
-    // bm == null in couple of situations like
-    // - detaching from window
-    // - cleaning up previous request
-    if (bm != null) {
-      mInstrumentation.onSuccess();
+    @Override
+    public void setImageBitmap(final Bitmap bm) {
+        // bm == null in couple of situations like
+        // - detaching from window
+        // - cleaning up previous request
+        if (bm != null) {
+            mInstrumentation.onSuccess();
+        }
+        super.setImageBitmap(bm);
     }
-    super.setImageBitmap(bm);
-  }
 
-  public void setImageResource(int resourceId) {
-    if (resourceId == R.color.placeholder) {
-      // ignore
-    } else if (resourceId == R.color.error) {
-      mInstrumentation.onFailure();
-    } else {
-      throw new IllegalArgumentException("Unrecognized resourceId");
+    public void setImageResource(int resourceId) {
+        if (resourceId == R.color.placeholder) {
+            // ignore
+        } else if (resourceId == R.color.error) {
+            mInstrumentation.onFailure();
+        } else {
+            throw new IllegalArgumentException("Unrecognized resourceId");
+        }
+        super.setImageResource(resourceId);
     }
-    super.setImageResource(resourceId);
-  }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/PerfListener.java b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/PerfListener.java
index 770ad85c9..01ddfd854 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/instrumentation/PerfListener.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/instrumentation/PerfListener.java
@@ -16,79 +16,79 @@
  * Collects wait times and holds image loading stats.
  */
 public class PerfListener {
-  private long mSumOfWaitTime;
-  private long mStartedRequests;
-  private long mSuccessfulRequests;
-  private long mCancelledRequests;
-  private long mFailedRequests;
+    private long mSumOfWaitTime;
+    private long mStartedRequests;
+    private long mSuccessfulRequests;
+    private long mCancelledRequests;
+    private long mFailedRequests;
 
-  public PerfListener() {
-    mSumOfWaitTime = 0;
-    mStartedRequests = 0;
-    mSuccessfulRequests = 0;
-    mCancelledRequests = 0;
-    mFailedRequests = 0;
-  }
+    public PerfListener() {
+        mSumOfWaitTime = 0;
+        mStartedRequests = 0;
+        mSuccessfulRequests = 0;
+        mCancelledRequests = 0;
+        mFailedRequests = 0;
+    }
 
-  /**
-   * Called whenever image request finishes successfully, that is whenever final image is set.
-   */
-  public void reportSuccess(long waitTime) {
-    mSumOfWaitTime += waitTime;
-    mSuccessfulRequests++;
-  }
+    /**
+     * Called whenever image request finishes successfully, that is whenever final image is set.
+     */
+    public void reportSuccess(long waitTime) {
+        mSumOfWaitTime += waitTime;
+        mSuccessfulRequests++;
+    }
 
-  /**
-   * Called whenever image request fails, that is whenever failure drawable is set.
-   */
-  public void reportFailure(long waitTime) {
-    mSumOfWaitTime += waitTime;
-    mFailedRequests++;
-  }
+    /**
+     * Called whenever image request fails, that is whenever failure drawable is set.
+     */
+    public void reportFailure(long waitTime) {
+        mSumOfWaitTime += waitTime;
+        mFailedRequests++;
+    }
 
-  /**
-   * Called whenever image request is cancelled, that is whenever image view is reused without
-   * setting final image first
-   */
-  public void reportCancellation(long waitTime) {
-    mSumOfWaitTime += waitTime;
-    mCancelledRequests++;
-  }
+    /**
+     * Called whenever image request is cancelled, that is whenever image view is reused without
+     * setting final image first
+     */
+    public void reportCancellation(long waitTime) {
+        mSumOfWaitTime += waitTime;
+        mCancelledRequests++;
+    }
 
-  /**
-   * Called whenver new request is started.
-   */
-  public void reportStart() {
-    mStartedRequests++;
-  }
+    /**
+     * Called whenver new request is started.
+     */
+    public void reportStart() {
+        mStartedRequests++;
+    }
 
-  /**
-   * @return average wait time, that is sum of reported wait times divided by number of completed
-   *   requests
-   */
-  public long getAverageWaitTime() {
-    final long completedRequests = getCompletedRequests();
-    return completedRequests > 0 ? mSumOfWaitTime / completedRequests : 0;
-  }
+    /**
+     * @return average wait time, that is sum of reported wait times divided by number of completed
+     * requests
+     */
+    public long getAverageWaitTime() {
+        final long completedRequests = getCompletedRequests();
+        return completedRequests > 0 ? mSumOfWaitTime / completedRequests : 0;
+    }
 
-  /**
-   * @return difference between number of started requests and number of completed requests
-   */
-  public long getOutstandingRequests() {
-    return mStartedRequests - getCompletedRequests();
-  }
+    /**
+     * @return difference between number of started requests and number of completed requests
+     */
+    public long getOutstandingRequests() {
+        return mStartedRequests - getCompletedRequests();
+    }
 
-  /**
-   * @return number of cancelled requests
-   */
-  public long getCancelledRequests() {
-    return mCancelledRequests;
-  }
+    /**
+     * @return number of cancelled requests
+     */
+    public long getCancelledRequests() {
+        return mCancelledRequests;
+    }
 
-  /**
-   * @return number of completed requests, either by seting final image, failure or cancellation
-   */
-  public long getCompletedRequests() {
-    return mSuccessfulRequests + mCancelledRequests + mFailedRequests;
-  }
+    /**
+     * @return number of completed requests, either by seting final image, failure or cancellation
+     */
+    public long getCompletedRequests() {
+        return mSuccessfulRequests + mCancelledRequests + mFailedRequests;
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageFormat.java b/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageFormat.java
index 4ad0d57f9..a7eeaf400 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageFormat.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageFormat.java
@@ -16,24 +16,24 @@
  * Formats of images we download from imgur.
  */
 public enum ImageFormat {
-  JPEG("image/jpeg"),
-  PNG("image/png"),
-  GIF("image/gif");
+    JPEG("image/jpeg"),
+    PNG("image/png"),
+    GIF("image/gif");
 
-  private static final ImageFormat[] VALUES = values();
+    private static final ImageFormat[] VALUES = values();
 
-  public final String mime;
+    public final String mime;
 
-  private ImageFormat(final String mime) {
-    this.mime = mime;
-  }
+    private ImageFormat(final String mime) {
+        this.mime = mime;
+    }
 
-  public static ImageFormat getImageFormatForMime(String mime) {
-    for (ImageFormat type : VALUES) {
-      if (type.mime.equals(mime)) {
-        return type;
-      }
+    public static ImageFormat getImageFormatForMime(String mime) {
+        for (ImageFormat type : VALUES) {
+            if (type.mime.equals(mime)) {
+                return type;
+            }
+        }
+        return null;
     }
-    return null;
-  }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageSize.java b/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageSize.java
index c4b27e9bd..a19e87bea 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageSize.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageSize.java
@@ -19,16 +19,17 @@
  * we should request "nice-imageb.jpeg".
  */
 public enum ImageSize {
-  ORIGINAL_IMAGE(""),
-  SMALL_SQUARE("s"),
-  BIG_SQUARE("b"),
-  SMALL_THUMBNAIL("t"),
-  MEDIUM_THUMBNAIL("m"),
-  LARGE_THUMBNAIL("l"),
-  HUGE_THUMBNAIL("h");
+    ORIGINAL_IMAGE(""),
+    SMALL_SQUARE("s"),
+    BIG_SQUARE("b"),
+    SMALL_THUMBNAIL("t"),
+    MEDIUM_THUMBNAIL("m"),
+    LARGE_THUMBNAIL("l"),
+    HUGE_THUMBNAIL("h");
 
-  public final String suffix;
-  private ImageSize(final String suffix) {
-    this.suffix = suffix;
-  }
+    public final String suffix;
+
+    private ImageSize(final String suffix) {
+        this.suffix = suffix;
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsFetcher.java b/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsFetcher.java
index 4a64a8f46..e4b08827d 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsFetcher.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsFetcher.java
@@ -40,116 +40,119 @@
  */
 public class ImageUrlsFetcher {
 
-  /**
-   * Imgur license key for use by the Fresco project.
-   *
-   * The rest of this class may be used freely according to the licence file, with the sole
-   * exception of this variable. Any fork of this code or use in any other application,
-   * whether open- or closed-source, must use a different client ID obtained from Imgur.
-   * See the <a href="https://api.imgur.com/#register">Imgur API documentation</a>.
-   */
-  private static final String IMGUR_CLIENT_ID = "Client-ID ccc6ca6a65ecdd8";
-
-  private static final String TAG = "FrescoSample";
-
-  public interface Callback {
-    public void onFinish(List<String> results);
-  }
-
-  public static void getImageUrls(final ImageUrlsRequest request, final Callback callback) {
-    new AsyncTask<Void, Void, List<String>>() {
-      @Override
-      protected List<String> doInBackground(Void... params) {
-        return getImageUrls(request);
-      }
-      @Override
-      protected void onPostExecute(List<String> result) {
-        callback.onFinish(result);
-      }
-    }.execute();
-  }
-
-  private static List<String> getImageUrls(ImageUrlsRequest request) {
-    List<String> urls = new ArrayList<String>();
-    try {
-      String rawJson = downloadContentAsString(request.getEndpointUrl());
-      if (rawJson == null) {
-        return urls;
-      }
-      JSONObject json = new JSONObject(rawJson);
-      JSONArray data = json.getJSONArray("data");
-      for (int i = 0; i < data.length(); i++) {
-        JSONObject item = data.getJSONObject(i);
-        if (!item.has("type")) {
-          continue;
-        }
-        ImageFormat imageFormat = ImageFormat.getImageFormatForMime(item.getString("type"));
-        ImageSize imageSize = request.getImageSize(imageFormat);
-        if (imageSize != null) {
-          urls.add(getThumbnailLink(item, imageSize));
-        }
-      }
-    } catch (Exception e) {
-      FLog.e(TAG, "Exception fetching album", e);
+    /**
+     * Imgur license key for use by the Fresco project.
+     * <p>
+     * The rest of this class may be used freely according to the licence file, with the sole
+     * exception of this variable. Any fork of this code or use in any other application,
+     * whether open- or closed-source, must use a different client ID obtained from Imgur.
+     * See the <a href="https://api.imgur.com/#register">Imgur API documentation</a>.
+     */
+    private static final String IMGUR_CLIENT_ID = "Client-ID ccc6ca6a65ecdd8";
+
+    private static final String TAG = "FrescoSample";
+
+    public interface Callback {
+        public void onFinish(List<String> results);
     }
-    return urls;
-  }
-
-  @Nullable
-  private static String downloadContentAsString(String urlString) throws IOException {
-    InputStream is = null;
-    try {
-      URL url = new URL(urlString);
-      HttpURLConnection conn = (HttpURLConnection) url.openConnection();
-      conn.setRequestProperty("Authorization", IMGUR_CLIENT_ID);
-      conn.setReadTimeout(10000 /* milliseconds */);
-      conn.setConnectTimeout(15000 /* milliseconds */);
-      conn.setRequestMethod("GET");
-      conn.setDoInput(true);
-      // Starts the query
-      conn.connect();
-      int response = conn.getResponseCode();
-      if (response != HttpStatus.SC_OK) {
-        FLog.e(TAG, "Album request returned %s", response);
-        return null;
-      }
-      is = conn.getInputStream();
-      return readAsString(is);
-    } finally {
-      if (is != null) {
-        is.close();
-      }
+
+    public static void getImageUrls(final ImageUrlsRequest request, final Callback callback) {
+        new AsyncTask<Void, Void, List<String>>() {
+            @Override
+            protected List<String> doInBackground(Void... params) {
+                return getImageUrls(request);
+            }
+
+            @Override
+            protected void onPostExecute(List<String> result) {
+                callback.onFinish(result);
+            }
+        }.execute();
     }
-  }
-
-  /** Reads an InputStream and converts it to a String. */
-  private static String readAsString(InputStream stream) throws IOException {
-    StringWriter writer = new StringWriter();
-    Reader reader = new BufferedReader(new InputStreamReader(stream, "UTF-8"));
-    while (true) {
-      int c = reader.read();
-      if (c < 0) {
-        break;
-      }
-      writer.write(c);
+
+    private static List<String> getImageUrls(ImageUrlsRequest request) {
+        List<String> urls = new ArrayList<String>();
+        try {
+            String rawJson = downloadContentAsString(request.getEndpointUrl());
+            if (rawJson == null) {
+                return urls;
+            }
+            JSONObject json = new JSONObject(rawJson);
+            JSONArray data = json.getJSONArray("data");
+            for (int i = 0; i < data.length(); i++) {
+                JSONObject item = data.getJSONObject(i);
+                if (!item.has("type")) {
+                    continue;
+                }
+                ImageFormat imageFormat = ImageFormat.getImageFormatForMime(item.getString("type"));
+                ImageSize imageSize = request.getImageSize(imageFormat);
+                if (imageSize != null) {
+                    urls.add(getThumbnailLink(item, imageSize));
+                }
+            }
+        } catch (Exception e) {
+            FLog.e(TAG, "Exception fetching album", e);
+        }
+        return urls;
     }
-    return writer.toString();
-  }
-
-  private static String getThumbnailLink(
-      final JSONObject json,
-      final ImageSize imageSize) throws JSONException {
-    Preconditions.checkNotNull(imageSize);
-    final String originalUrl = json.getString("link");
-    if (imageSize == ImageSize.ORIGINAL_IMAGE) {
-      return originalUrl;
+
+    @Nullable
+    private static String downloadContentAsString(String urlString) throws IOException {
+        InputStream is = null;
+        try {
+            URL url = new URL(urlString);
+            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+            conn.setRequestProperty("Authorization", IMGUR_CLIENT_ID);
+            conn.setReadTimeout(10000 /* milliseconds */);
+            conn.setConnectTimeout(15000 /* milliseconds */);
+            conn.setRequestMethod("GET");
+            conn.setDoInput(true);
+            // Starts the query
+            conn.connect();
+            int response = conn.getResponseCode();
+            if (response != HttpStatus.SC_OK) {
+                FLog.e(TAG, "Album request returned %s", response);
+                return null;
+            }
+            is = conn.getInputStream();
+            return readAsString(is);
+        } finally {
+            if (is != null) {
+                is.close();
+            }
+        }
+    }
+
+    /**
+     * Reads an InputStream and converts it to a String.
+     */
+    private static String readAsString(InputStream stream) throws IOException {
+        StringWriter writer = new StringWriter();
+        Reader reader = new BufferedReader(new InputStreamReader(stream, "UTF-8"));
+        while (true) {
+            int c = reader.read();
+            if (c < 0) {
+                break;
+            }
+            writer.write(c);
+        }
+        return writer.toString();
     }
 
-    final int dotPos = originalUrl.lastIndexOf('.');
-    final StringBuilder linkBuilder = new StringBuilder(originalUrl.length() + 1);
-    return linkBuilder
-      .append(originalUrl)
-      .insert(dotPos, imageSize.suffix)
-      .toString();
-  }
+    private static String getThumbnailLink(
+            final JSONObject json,
+            final ImageSize imageSize) throws JSONException {
+        Preconditions.checkNotNull(imageSize);
+        final String originalUrl = json.getString("link");
+        if (imageSize == ImageSize.ORIGINAL_IMAGE) {
+            return originalUrl;
+        }
+
+        final int dotPos = originalUrl.lastIndexOf('.');
+        final StringBuilder linkBuilder = new StringBuilder(originalUrl.length() + 1);
+        return linkBuilder
+                .append(originalUrl)
+                .insert(dotPos, imageSize.suffix)
+                .toString();
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsRequest.java b/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsRequest.java
index 9af542dfa..9f964d2ff 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsRequest.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsRequest.java
@@ -21,19 +21,19 @@
  * resizing options.
  */
 public class ImageUrlsRequest {
-  final private String mEndpointUrl;
-  Map<ImageFormat, ImageSize> mRequestedImageFormats;
+    final private String mEndpointUrl;
+    Map<ImageFormat, ImageSize> mRequestedImageFormats;
 
-  ImageUrlsRequest(final String endpointUrl, Map<ImageFormat, ImageSize> requestedTypes) {
-    mEndpointUrl = Preconditions.checkNotNull(endpointUrl);
-    mRequestedImageFormats = Preconditions.checkNotNull(requestedTypes);
-  }
+    ImageUrlsRequest(final String endpointUrl, Map<ImageFormat, ImageSize> requestedTypes) {
+        mEndpointUrl = Preconditions.checkNotNull(endpointUrl);
+        mRequestedImageFormats = Preconditions.checkNotNull(requestedTypes);
+    }
 
-  public String getEndpointUrl() {
-    return mEndpointUrl;
-  }
+    public String getEndpointUrl() {
+        return mEndpointUrl;
+    }
 
-  public ImageSize getImageSize(ImageFormat imageFormat) {
-    return mRequestedImageFormats.get(imageFormat);
-  }
+    public ImageSize getImageSize(ImageFormat imageFormat) {
+        return mRequestedImageFormats.get(imageFormat);
+    }
 }
diff --git a/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsRequestBuilder.java b/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsRequestBuilder.java
index 940389ad6..6b82732f8 100644
--- a/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsRequestBuilder.java
+++ b/sample/src/main/java/com/facebook/fresco/sample/urlsfetcher/ImageUrlsRequestBuilder.java
@@ -19,30 +19,30 @@
 
 /**
  * Builds ImageUrlsRequest.
- *
+ * <p>
  * <p> Use addImageFormat to specify what image types you are interested in
  */
 public class ImageUrlsRequestBuilder {
-  final private String mEndpointUrl;
-  Map<ImageFormat, ImageSize> mRequestedImageFormats;
+    final private String mEndpointUrl;
+    Map<ImageFormat, ImageSize> mRequestedImageFormats;
 
-  public ImageUrlsRequestBuilder(final String endpointUrl) {
-    mEndpointUrl = Preconditions.checkNotNull(endpointUrl);
-    mRequestedImageFormats = Maps.newHashMap();
-  }
+    public ImageUrlsRequestBuilder(final String endpointUrl) {
+        mEndpointUrl = Preconditions.checkNotNull(endpointUrl);
+        mRequestedImageFormats = Maps.newHashMap();
+    }
 
-  /**
-   * Adds imageFormat to the set of image formats you want to download. imageSize specify
-   * server-side resize options.
-   */
-  public ImageUrlsRequestBuilder addImageFormat(ImageFormat imageFormat, ImageSize imageSize) {
-    mRequestedImageFormats.put(imageFormat, imageSize);
-    return this;
-  }
+    /**
+     * Adds imageFormat to the set of image formats you want to download. imageSize specify
+     * server-side resize options.
+     */
+    public ImageUrlsRequestBuilder addImageFormat(ImageFormat imageFormat, ImageSize imageSize) {
+        mRequestedImageFormats.put(imageFormat, imageSize);
+        return this;
+    }
 
-  public ImageUrlsRequest build() {
-    ImageUrlsRequest request = new ImageUrlsRequest(mEndpointUrl, mRequestedImageFormats);
-    mRequestedImageFormats = null;
-    return request;
-  }
+    public ImageUrlsRequest build() {
+        ImageUrlsRequest request = new ImageUrlsRequest(mEndpointUrl, mRequestedImageFormats);
+        mRequestedImageFormats = null;
+        return request;
+    }
 }
diff --git a/sample/src/main/res/layout/activity_main.xml b/sample/src/main/res/layout/activity_main.xml
index 235992435..6aabba256 100644
--- a/sample/src/main/res/layout/activity_main.xml
+++ b/sample/src/main/res/layout/activity_main.xml
@@ -1,5 +1,4 @@
-<LinearLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
@@ -10,25 +9,23 @@
     tools:context=".MainActivity"
     android:orientation="vertical">
 
-  <TextView
-      android:id="@+id/stats_display"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      android:typeface="monospace"/>
+    <TextView
+        android:id="@+id/stats_display"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:typeface="monospace" />
 
-  <Spinner
-      android:id="@+id/loader_select"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      android:entries="@array/image_loaders"
-      android:prompt="@string/select_image_loader"
-      />
+    <Spinner
+        android:id="@+id/loader_select"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:entries="@array/image_loaders"
+        android:prompt="@string/select_image_loader" />
 
-  <ListView
-      android:id="@+id/image_list"
-      android:layout_width="wrap_content"
-      android:layout_height="0dp"
-      android:layout_weight="1"
-      />
+    <ListView
+        android:id="@+id/image_list"
+        android:layout_width="wrap_content"
+        android:layout_height="0dp"
+        android:layout_weight="1" />
 
 </LinearLayout>
diff --git a/sample/src/main/res/menu/menu_main.xml b/sample/src/main/res/menu/menu_main.xml
index 7a05cafb2..508cb1df4 100644
--- a/sample/src/main/res/menu/menu_main.xml
+++ b/sample/src/main/res/menu/menu_main.xml
@@ -1,18 +1,17 @@
 <menu xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools" tools:context=".MainActivity">
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context=".MainActivity">
 
     <item
         android:id="@+id/allow_animations"
         android:checkable="true"
         android:title="Allow animations"
-        app:showAsAction="never"
-        />
+        app:showAsAction="never" />
 
     <item
         android:id="@+id/use_drawee"
         android:checkable="true"
         android:title="Use Drawee"
-        app:showAsAction="never"
-        />
+        app:showAsAction="never" />
 </menu>
diff --git a/sample/src/main/res/values/colors.xml b/sample/src/main/res/values/colors.xml
index 8ec406dac..c2c74b74c 100644
--- a/sample/src/main/res/values/colors.xml
+++ b/sample/src/main/res/values/colors.xml
@@ -1,4 +1,4 @@
 <resources>
-  <color name="placeholder">#e1e4eb</color>
-  <color name="error">#ff9999</color>
+    <color name="placeholder">#e1e4eb</color>
+    <color name="error">#ff9999</color>
 </resources>
diff --git a/sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
index af90fc947..fafd0b46a 100644
--- a/sample/src/main/res/values/strings.xml
+++ b/sample/src/main/res/values/strings.xml
@@ -6,12 +6,12 @@
 
     <!-- If you change the order of the elements, update the indices in the MainActivity.java -->
     <string-array name="image_loaders">
-      <item>None</item>
-      <item>Fresco</item>
-      <item>Fresco + OkHttp</item>
-      <item>Glide</item>
-      <item>Picasso</item>
-      <item>Universal Image Loader</item>
-      <item>Volley</item>
+        <item>None</item>
+        <item>Fresco</item>
+        <item>Fresco + OkHttp</item>
+        <item>Glide</item>
+        <item>Picasso</item>
+        <item>Universal Image Loader</item>
+        <item>Volley</item>
     </string-array>
 </resources>
