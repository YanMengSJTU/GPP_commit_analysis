diff --git a/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java b/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java
index c92cf0288..1f4d3761e 100644
--- a/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java
+++ b/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java
@@ -21,6 +21,7 @@
 import com.facebook.common.internal.Objects;
 import com.facebook.common.internal.Preconditions;
 import com.facebook.common.logging.FLog;
+import com.facebook.common.references.CloseableReference;
 import com.facebook.drawee.components.DeferredReleaser;
 import com.facebook.drawee.components.DraweeEventTracker;
 import com.facebook.drawee.components.RetryManager;
@@ -95,6 +96,7 @@
   private @Nullable DataSource<T> mDataSource;
   private @Nullable T mFetchedImage;
   private @Nullable Drawable mDrawable;
+  private @Nullable Throwable mInitTrace;
 
   public AbstractDraweeController(
       DeferredReleaser deferredReleaser,
@@ -119,6 +121,9 @@ protected void initialize(String id, Object callerContext) {
 
   private void init(String id, Object callerContext, boolean justConstructed) {
     mEventTracker.recordEvent(Event.ON_INIT_CONTROLLER);
+    if (CloseableReference.isUnclosedTrackingEnabled()) {
+      mInitTrace = new Throwable();
+    }
     // cancel deferred release
     if (!justConstructed && mDeferredReleaser != null) {
       mDeferredReleaser.cancelDeferredRelease(this);
@@ -465,6 +470,9 @@ public void onNewResultImpl(DataSource<T> dataSource) {
             boolean isFinished = dataSource.isFinished();
             float progress = dataSource.getProgress();
             T image = dataSource.getResult();
+            if (mInitTrace != null && image instanceof CloseableReference) {
+              ((CloseableReference) image).setUnclosedRelevantTrance(mInitTrace);
+            }
             if (image != null) {
               onNewResultInternal(id, dataSource, image, progress, isFinished, wasImmediate);
             } else if (isFinished) {
diff --git a/fbcore/src/main/java/com/facebook/common/references/CloseableReference.java b/fbcore/src/main/java/com/facebook/common/references/CloseableReference.java
index e4f979bf7..73b12c822 100644
--- a/fbcore/src/main/java/com/facebook/common/references/CloseableReference.java
+++ b/fbcore/src/main/java/com/facebook/common/references/CloseableReference.java
@@ -79,8 +79,7 @@ public void release(Closeable value) {
       };
 
   private static volatile @Nullable UnclosedReferenceListener sUnclosedReferenceListener;
-  private final @Nullable Throwable mObtainedTrace;
-  private @Nullable Throwable mClonedTrace;
+  private @Nullable Throwable mRelevantTrace;
 
   @GuardedBy("this")
   private boolean mIsClosed = false;
@@ -94,13 +93,13 @@ public void release(Closeable value) {
   private CloseableReference(SharedReference<T> sharedReference) {
     mSharedReference = Preconditions.checkNotNull(sharedReference);
     sharedReference.addReference();
-    mObtainedTrace = getTraceOrNull();
+    mRelevantTrace = getTraceOrNull();
   }
 
   private CloseableReference(T t, ResourceReleaser<T> resourceReleaser) {
     // Ref-count pre-set to 1
     mSharedReference = new SharedReference<T>(t, resourceReleaser);
-    mObtainedTrace = getTraceOrNull();
+    mRelevantTrace = getTraceOrNull();
   }
 
   /**
@@ -165,13 +164,13 @@ public synchronized T get() {
    */
   @Override
   public synchronized CloseableReference<T> clone() {
-    mClonedTrace = getTraceOrNull();
+    mRelevantTrace = getTraceOrNull();
     Preconditions.checkState(isValid());
     return new CloseableReference<T>(mSharedReference);
   }
 
   public synchronized CloseableReference<T> cloneOrNull() {
-    mClonedTrace = getTraceOrNull();
+    mRelevantTrace = getTraceOrNull();
     return isValid() ? new CloseableReference<T>(mSharedReference) : null;
   }
 
@@ -196,8 +195,7 @@ protected void finalize() throws Throwable {
 
       UnclosedReferenceListener listener = sUnclosedReferenceListener;
       if (listener != null) {
-        Throwable cause = mClonedTrace != null ? mClonedTrace : mObtainedTrace;
-        listener.onUnclosedReferenceFinalized(this, cause);
+        listener.onUnclosedReferenceFinalized(this, mRelevantTrace);
       } else {
         FLog.w(
             TAG,
@@ -213,6 +211,26 @@ protected void finalize() throws Throwable {
     }
   }
 
+  /**
+   * Returns whether CloseableReference instances are currently gathering obtain/clone traces for
+   * the purpose of unclosed reference tracking.
+   *
+   * @see #setUnclosedReferenceListener(UnclosedReferenceListener)
+   */
+  public static boolean isUnclosedTrackingEnabled() {
+    return sUnclosedReferenceListener != null;
+  }
+
+  /**
+   * If the obtained/cloned trace is not valuable in some instances, you can set a more relevant
+   * trace here, for the purpose of unclosed reference tracking.
+   *
+   * @see #setUnclosedReferenceListener(UnclosedReferenceListener)
+   */
+  public void setUnclosedRelevantTrance(Throwable relevantTrance) {
+    mRelevantTrace = relevantTrance;
+  }
+
   /**
    * A test-only method to get the underlying references.
    *
@@ -293,6 +311,10 @@ public static void closeSafely(@Nullable Iterable<? extends CloseableReference<?
     }
   }
 
+  /**
+   * Set a listener to be notified when a CloseableReference is finalized by GC without it being
+   * explicitly closed beforehand.
+   */
   public static void setUnclosedReferenceListener(
       UnclosedReferenceListener unclosedReferenceListener) {
     sUnclosedReferenceListener = unclosedReferenceListener;
