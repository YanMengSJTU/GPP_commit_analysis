diff --git a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/DefaultDrawableFactory.java b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/DefaultDrawableFactory.java
index e32b6f584..ef7037b5a 100644
--- a/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/DefaultDrawableFactory.java
+++ b/drawee-backends/drawee-pipeline/src/main/java/com/facebook/drawee/backends/pipeline/DefaultDrawableFactory.java
@@ -13,6 +13,7 @@
 import android.media.ExifInterface;
 import com.facebook.drawee.drawable.OrientedDrawable;
 import com.facebook.imagepipeline.drawable.DrawableFactory;
+import com.facebook.imagepipeline.image.CloseableDrawable;
 import com.facebook.imagepipeline.image.CloseableImage;
 import com.facebook.imagepipeline.image.CloseableStaticBitmap;
 import com.facebook.imagepipeline.image.EncodedImage;
@@ -54,6 +55,9 @@ public Drawable createDrawable(CloseableImage closeableImage) {
               closeableStaticBitmap.getRotationAngle(),
               closeableStaticBitmap.getExifOrientation());
         }
+      } else if (closeableImage instanceof CloseableDrawable) {
+        CloseableDrawable closeableDrawable = (CloseableDrawable)closeableImage;
+        return closeableDrawable.getUnderlyingDrawable();
       } else if (mAnimatedDrawableFactory != null
           && mAnimatedDrawableFactory.supportsImageType(closeableImage)) {
         return mAnimatedDrawableFactory.createDrawable(closeableImage);
diff --git a/fbcore/src/main/java/com/facebook/common/util/UriUtil.java b/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
index 5e2617740..fa50d5635 100644
--- a/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
+++ b/fbcore/src/main/java/com/facebook/common/util/UriUtil.java
@@ -8,12 +8,17 @@
 package com.facebook.common.util;
 
 import android.content.ContentResolver;
+import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
 import android.provider.ContactsContract;
 import android.provider.MediaStore;
+import android.text.TextUtils;
+
 import java.io.File;
 import java.net.URL;
+import java.util.List;
+
 import javax.annotation.Nullable;
 
 public class UriUtil {
@@ -54,6 +59,14 @@
    */
   public static final String QUALIFIED_RESOURCE_SCHEME = ContentResolver.SCHEME_ANDROID_RESOURCE;
 
+  // android.resource://<package_name>/<type>/<name>.
+  private static final int NAME_URI_PATH_SEGMENTS = 2;
+  private static final int TYPE_PATH_SEGMENT_INDEX = 0;
+  private static final int NAME_PATH_SEGMENT_INDEX = 1;
+  // android.resource://<package_name>/<resource_id>
+  private static final int ID_PATH_SEGMENTS = 1;
+  private static final int RESOURCE_ID_SEGMENT_INDEX = 0;
+
   /**
    * Data scheme for URIs
    */
@@ -266,4 +279,38 @@ public static Uri getUriForQualifiedResource(String packageName, int resourceId)
         .path(String.valueOf(resourceId))
         .build();
   }
+
+  /**
+   * Returns a Resource Id for the given image uri
+   *
+   * @param context
+   * @param source the source Uri
+   * @return the resource id
+   */
+  public static int getResourceIdFromUri(Context context, Uri source) {
+    List<String> segments = source.getPathSegments();
+    Integer result = null;
+    if (segments.size() == NAME_URI_PATH_SEGMENTS) {
+      String packageName = source.getAuthority();
+      if (TextUtils.isEmpty(packageName)) {
+        packageName = context.getPackageName();
+      }
+      String typeName = segments.get(TYPE_PATH_SEGMENT_INDEX);
+      String resourceName = segments.get(NAME_PATH_SEGMENT_INDEX);
+      result = context.getResources().getIdentifier(resourceName, typeName, packageName);
+    } else if (segments.size() == ID_PATH_SEGMENTS) {
+      try {
+        result = Integer.valueOf(segments.get(RESOURCE_ID_SEGMENT_INDEX));
+      } catch (NumberFormatException e) {
+        // Ignored.
+      }
+    }
+
+    if (result == null) {
+      throw new IllegalArgumentException("Unrecognized Uri format: " + source);
+    } else if (result <= 0) {
+      throw new IllegalArgumentException("Failed to obtain resource id for: " + source);
+    }
+    return result;
+  }
 }
diff --git a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/drawable/SimpleDrawableReleaser.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/drawable/SimpleDrawableReleaser.java
new file mode 100644
index 000000000..3b4c87e24
--- /dev/null
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/drawable/SimpleDrawableReleaser.java
@@ -0,0 +1,32 @@
+package com.facebook.imagepipeline.drawable;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+
+import com.facebook.common.references.ResourceReleaser;
+
+/**
+ * A releaser that just recycles (frees) drawable bitmap memory immediately.
+ */
+public class SimpleDrawableReleaser implements ResourceReleaser<Drawable> {
+
+    private static SimpleDrawableReleaser sInstance;
+
+    public static SimpleDrawableReleaser getInstance() {
+        if (sInstance == null) {
+            sInstance = new SimpleDrawableReleaser();
+        }
+        return sInstance;
+    }
+
+    @Override
+    public void release(Drawable value) {
+        if (value instanceof BitmapDrawable) {
+            Bitmap bitmap = ((BitmapDrawable)value).getBitmap();
+            if (bitmap != null) {
+                bitmap.recycle();
+            }
+        }
+    }
+}
diff --git a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/CloseableDrawable.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/CloseableDrawable.java
new file mode 100644
index 000000000..3510501f6
--- /dev/null
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/CloseableDrawable.java
@@ -0,0 +1,84 @@
+package com.facebook.imagepipeline.image;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+
+import com.facebook.common.internal.Preconditions;
+import com.facebook.common.references.CloseableReference;
+import com.facebook.common.references.ResourceReleaser;
+import com.facebook.imageutils.BitmapUtil;
+
+import javax.annotation.concurrent.GuardedBy;
+import javax.annotation.concurrent.ThreadSafe;
+
+/**
+ * {@link CloseableImage} that wraps a drawable.
+ */
+@ThreadSafe
+public class CloseableDrawable extends CloseableImage {
+
+    @GuardedBy("this")
+    private CloseableReference<Drawable> mDrawableReference;
+
+    private Drawable mDrawable;
+
+    public CloseableDrawable(Drawable drawable, ResourceReleaser<Drawable> resourceReleaser) {
+        mDrawable = drawable;
+        mDrawableReference = CloseableReference.of(
+                mDrawable,
+                Preconditions.checkNotNull(resourceReleaser));
+    }
+
+    /**
+     * Gets the underlying drawable.
+     * Note: some Android drawable resources like xml, vector drawable, adaptive icon can be only decoded
+     * to drawable not bitmap
+     * @return the underlying drawable
+     */
+    public Drawable getUnderlyingDrawable() {
+        return mDrawable;
+    }
+
+    @Override
+    public int getSizeInBytes() {
+
+        if (mDrawable instanceof BitmapDrawable) {
+            Bitmap bitmap = ((BitmapDrawable)mDrawable).getBitmap();
+            return BitmapUtil.getSizeInBytes(bitmap);
+        }
+        // 4 bytes per pixel for ARGB_8888 Bitmaps is something of a reasonable approximation. If
+        // there are no intrinsic bounds, we can fall back just to 1.
+        return Math.max(1, getWidth() * getHeight() * 4);
+    }
+
+    @Override
+    public void close() {
+        CloseableReference<Drawable> reference = detachDrawableReference();
+        if (reference != null) {
+            reference.close();
+        }
+    }
+
+    private synchronized CloseableReference<Drawable> detachDrawableReference() {
+        CloseableReference<Drawable> reference = mDrawableReference;
+        mDrawableReference = null;
+        mDrawable = null;
+        return reference;
+    }
+
+    @Override
+    public boolean isClosed() {
+        return mDrawableReference == null;
+    }
+
+    @Override
+    public int getWidth() {
+        return mDrawable == null ? 0 : Math.max(0, mDrawable.getIntrinsicWidth());
+    }
+
+    @Override
+    public int getHeight() {
+        return mDrawable == null ? 0 : Math.max(0, mDrawable.getIntrinsicHeight());
+    }
+}
diff --git a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java
index 44a533c49..758a0ee9c 100644
--- a/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java
+++ b/imagepipeline-base/src/main/java/com/facebook/imagepipeline/image/EncodedImage.java
@@ -9,6 +9,7 @@
 
 import android.graphics.ColorSpace;
 import android.media.ExifInterface;
+import android.net.Uri;
 import android.util.Pair;
 import com.facebook.common.internal.Preconditions;
 import com.facebook.common.internal.Supplier;
@@ -67,6 +68,7 @@
   private int mStreamSize = UNKNOWN_STREAM_SIZE;
   private @Nullable BytesRange mBytesRange;
   private @Nullable ColorSpace mColorSpace;
+  private @Nullable Uri mUri;
 
   public EncodedImage(CloseableReference<PooledByteBuffer> pooledByteBufferRef) {
     Preconditions.checkArgument(CloseableReference.isValid(pooledByteBufferRef));
@@ -161,6 +163,13 @@ public InputStream getInputStream() {
     return null;
   }
 
+  /**
+   * Sets the image uri to decode
+   */
+  public void setImageUri(Uri uri) {
+    this.mUri = uri;
+  }
+
   /**
    * Sets the image format
    */
@@ -212,6 +221,13 @@ public void setBytesRange(@Nullable BytesRange bytesRange) {
     mBytesRange = bytesRange;
   }
 
+  /**
+   * Returns the image uri if set
+   */
+  public Uri getImageUri() {
+    return mUri;
+  }
+
   /**
    * Returns the image format if known, otherwise ImageFormat.UNKNOWN.
    */
diff --git a/imagepipeline/build.gradle b/imagepipeline/build.gradle
index a9082f407..3e76b1578 100644
--- a/imagepipeline/build.gradle
+++ b/imagepipeline/build.gradle
@@ -7,6 +7,7 @@ version = VERSION_NAME
 dependencies {
     compileOnly "com.android.support:support-annotations:${SUPPORT_LIB_VERSION}"
     compileOnly "com.android.support:support-core-utils:${SUPPORT_LIB_VERSION}"
+    compileOnly "com.android.support:appcompat-v7:${SUPPORT_LIB_VERSION}"
     compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
     compileOnly "com.facebook.infer.annotation:infer-annotation:${INFER_ANNOTATION_VERSION}"
     compileOnly "javax.annotation:javax.annotation-api:${ANNOTATION_API_VERSION}"
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
index 5f65e6428..94619f4fc 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
@@ -36,6 +36,7 @@
 import com.facebook.imagepipeline.cache.InstrumentedMemoryCache;
 import com.facebook.imagepipeline.decoder.DefaultImageDecoder;
 import com.facebook.imagepipeline.decoder.ImageDecoder;
+import com.facebook.imagepipeline.decoder.ResourceDrawableDecoder;
 import com.facebook.imagepipeline.drawable.DrawableFactory;
 import com.facebook.imagepipeline.image.CloseableImage;
 import com.facebook.imagepipeline.memory.PoolFactory;
@@ -210,15 +211,19 @@ private ImageDecoder getImageDecoder() {
           webPDecoder = animatedFactory.getWebPDecoder(mConfig.getBitmapConfig());
         }
 
+        ImageDecoder resourceDecoder = new ResourceDrawableDecoder(mConfig.getContext());
+
         if (mConfig.getImageDecoderConfig() == null) {
           mImageDecoder = new DefaultImageDecoder(
               gifDecoder,
               webPDecoder,
+              resourceDecoder,
               getPlatformDecoder());
         } else {
           mImageDecoder = new DefaultImageDecoder(
               gifDecoder,
               webPDecoder,
+              resourceDecoder,
               getPlatformDecoder(),
               mConfig.getImageDecoderConfig().getCustomImageDecoders());
           // Add custom image formats if needed
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DefaultImageDecoder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DefaultImageDecoder.java
index 79035febd..87cff2e83 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DefaultImageDecoder.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DefaultImageDecoder.java
@@ -8,7 +8,10 @@
 package com.facebook.imagepipeline.decoder;
 
 import android.graphics.Bitmap;
+import android.net.Uri;
+
 import com.facebook.common.references.CloseableReference;
+import com.facebook.common.util.UriUtil;
 import com.facebook.imageformat.DefaultImageFormats;
 import com.facebook.imageformat.ImageFormat;
 import com.facebook.imageformat.ImageFormatChecker;
@@ -41,6 +44,7 @@
 
   private final ImageDecoder mAnimatedGifDecoder;
   private final ImageDecoder mAnimatedWebPDecoder;
+  private final ImageDecoder mResourceDrawableDecoder;
   private final PlatformDecoder mPlatformDecoder;
 
   private final ImageDecoder mDefaultDecoder =
@@ -59,6 +63,13 @@ public CloseableImage decode(
           } else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) {
             return decodeAnimatedWebp(encodedImage, length, qualityInfo, options);
           } else if (imageFormat == ImageFormat.UNKNOWN) {
+            // When we get here, if image format is unknown and uri is local android resource
+            // it might be an xml file or resources in other app. We cannot distinguish xml file type
+            // though file header magic number, so just delegate it to ResourceDrawableDecoder as a fallback
+            Uri uri = encodedImage.getImageUri();
+            if (UriUtil.isLocalResourceUri(uri) || UriUtil.isQualifiedResourceUri(uri)) {
+              return decodeResourceDrawable(encodedImage, length, qualityInfo, options);
+            }
             throw new DecodeException("unknown image format", encodedImage);
           }
           return decodeStaticImage(encodedImage, options);
@@ -71,17 +82,20 @@ public CloseableImage decode(
   public DefaultImageDecoder(
       final ImageDecoder animatedGifDecoder,
       final ImageDecoder animatedWebPDecoder,
+      final ImageDecoder resourceDrawableDecoder,
       final PlatformDecoder platformDecoder) {
-    this(animatedGifDecoder, animatedWebPDecoder, platformDecoder, null);
+    this(animatedGifDecoder, animatedWebPDecoder, resourceDrawableDecoder, platformDecoder, null);
   }
 
   public DefaultImageDecoder(
       final ImageDecoder animatedGifDecoder,
       final ImageDecoder animatedWebPDecoder,
+      final ImageDecoder resourceDrawableDecoder,
       final PlatformDecoder platformDecoder,
       @Nullable Map<ImageFormat, ImageDecoder> customDecoders) {
     mAnimatedGifDecoder = animatedGifDecoder;
     mAnimatedWebPDecoder = animatedWebPDecoder;
+    mResourceDrawableDecoder = resourceDrawableDecoder;
     mPlatformDecoder = platformDecoder;
     mCustomDecoders = customDecoders;
   }
@@ -200,4 +214,21 @@ public CloseableImage decodeAnimatedWebp(
       final ImageDecodeOptions options) {
     return mAnimatedWebPDecoder.decode(encodedImage, length, qualityInfo, options);
   }
+
+  /**
+   * Decode an android resource id into a CloseableImage.
+   *
+   * <p> The image is decoded into a drawable
+   *
+   * @param encodedImage input image (encoded bytes plus meta data)
+   * @param options
+   * @return a {@link CloseableImage}
+   */
+  public CloseableImage decodeResourceDrawable(
+          final EncodedImage encodedImage,
+          final int length,
+          final QualityInfo qualityInfo,
+          final ImageDecodeOptions options) {
+    return mResourceDrawableDecoder.decode(encodedImage, length, qualityInfo, options);
+  }
 }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DrawableDecoderCompat.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DrawableDecoderCompat.java
new file mode 100644
index 000000000..7ab5e0b90
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/DrawableDecoderCompat.java
@@ -0,0 +1,77 @@
+package com.facebook.imagepipeline.decoder;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.Nullable;
+import android.support.v4.content.ContextCompat;
+import android.support.v4.content.res.ResourcesCompat;
+import android.support.v7.content.res.AppCompatResources;
+import android.support.v7.view.ContextThemeWrapper;
+
+/**
+ * Handles decoding Drawables with the v7 support library if present and falling back to the v4
+ * support library otherwise.
+ */
+public final class DrawableDecoderCompat {
+    private static volatile boolean shouldCallAppCompatResources = true;
+    private DrawableDecoderCompat() {
+        // Utility class.
+    }
+
+    /**
+     * See {@code getDrawable(Context, int, Theme)}.
+     */
+    public static Drawable getDrawable(
+            Context ourContext, Context targetContext, @DrawableRes int id) {
+        return getDrawable(ourContext, targetContext, id, /*theme=*/ null);
+    }
+
+    /**
+     * Loads a Drawable using {@link AppCompatResources} if available and {@link ResourcesCompat}
+     * otherwise, depending on whether or not the v7 support library is included in the application.
+     *
+     * @param theme Used instead of the {@link Resources.Theme} returned from the given {@link Context} if
+     * non-null when loading the {@link Drawable}.
+     */
+    public static Drawable getDrawable(
+            Context ourContext, @DrawableRes int id, @Nullable Resources.Theme theme) {
+        return getDrawable(ourContext, ourContext, id, theme);
+    }
+
+    private static Drawable getDrawable(
+            Context ourContext, Context targetContext, @DrawableRes int id, @Nullable Resources.Theme theme) {
+        try {
+            // Race conditions may cause us to attempt to load using v7 more than once. That's ok since
+            // this check is a modest optimization and the output will be correct anyway.
+            if (shouldCallAppCompatResources) {
+                return loadDrawableV7(targetContext, id, theme);
+            }
+        } catch (NoClassDefFoundError error) {
+            shouldCallAppCompatResources = false;
+        } catch (IllegalStateException e) {
+            if (ourContext.getPackageName().equals(targetContext.getPackageName())) {
+                throw e;
+            }
+            return ContextCompat.getDrawable(targetContext, id);
+        } catch (Resources.NotFoundException e) {
+            // Ignored, this can be thrown when drawable compat attempts to decode a canary resource. If
+            // that decode attempt fails, we still want to try with the v4 ResourcesCompat below.
+        }
+
+        return loadDrawableV4(targetContext, id, theme != null ? theme : targetContext.getTheme());
+    }
+
+    private static Drawable loadDrawableV7(Context context, @DrawableRes int id,
+                                           @Nullable Resources.Theme theme) {
+        Context resourceContext = theme != null ? new ContextThemeWrapper(context, theme) : context;
+        return AppCompatResources.getDrawable(resourceContext, id);
+    }
+
+    private static Drawable loadDrawableV4(
+            Context context, @DrawableRes int id, @Nullable Resources.Theme theme) {
+        Resources resources = context.getResources();
+        return ResourcesCompat.getDrawable(resources, id, theme);
+    }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ResourceDrawableDecoder.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ResourceDrawableDecoder.java
new file mode 100644
index 000000000..1a87c2879
--- /dev/null
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/decoder/ResourceDrawableDecoder.java
@@ -0,0 +1,59 @@
+package com.facebook.imagepipeline.decoder;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+
+import com.facebook.common.util.UriUtil;
+import com.facebook.imagepipeline.common.ImageDecodeOptions;
+import com.facebook.imagepipeline.drawable.SimpleDrawableReleaser;
+import com.facebook.imagepipeline.image.CloseableDrawable;
+import com.facebook.imagepipeline.image.CloseableImage;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.image.QualityInfo;
+
+
+
+/**
+ * Decodes images to {@link Drawable}
+ *
+ */
+public class ResourceDrawableDecoder implements ImageDecoder {
+
+    private final Context context;
+
+    public ResourceDrawableDecoder(Context context) {
+        this.context = context.getApplicationContext();
+    }
+
+    @Override
+    public CloseableImage decode(EncodedImage encodedImage, int length, QualityInfo qualityInfo, ImageDecodeOptions options) {
+        Uri uri = encodedImage.getImageUri();
+        if (uri == null) {
+            throw new IllegalArgumentException("Uri is null");
+        }
+
+        @DrawableRes int resId = UriUtil.getResourceIdFromUri(context, uri);
+        String pkgName = uri.getAuthority();
+        Context targetContext = (TextUtils.isEmpty(pkgName) || TextUtils.equals(pkgName, context.getPackageName()))
+                ? context : getContextForPackage(uri, pkgName);
+        // We can't get a theme from another application.
+        Drawable drawable = DrawableDecoderCompat.getDrawable(context, targetContext, resId);
+        return new CloseableDrawable(drawable, SimpleDrawableReleaser.getInstance());
+    }
+
+
+    @NonNull
+    private Context getContextForPackage(Uri source, String packageName) {
+        try {
+            return context.createPackageContext(packageName, /*flags=*/ 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            throw new IllegalArgumentException(
+                    "Failed to obtain context or unrecognized Uri format for: " + source, e);
+        }
+    }
+}
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java
index e0243425c..2717f5f42 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.java
@@ -146,8 +146,9 @@ public ProgressiveDecoder(
             @Override
             public void run(EncodedImage encodedImage, @Status int status) {
               if (encodedImage != null) {
+                ImageRequest request = producerContext.getImageRequest();
+                encodedImage.setImageUri(request.getSourceUri());
                 if (mDownsampleEnabled || !statusHasFlag(status, Consumer.IS_RESIZING_DONE)) {
-                  ImageRequest request = producerContext.getImageRequest();
                   if (mDownsampleEnabledForNetwork
                       || !UriUtil.isNetworkUri(request.getSourceUri())) {
                     encodedImage.setSampleSize(
