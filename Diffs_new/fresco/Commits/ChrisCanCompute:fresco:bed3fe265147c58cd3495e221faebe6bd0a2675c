diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
index 406c7a907..5fb193fa7 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
@@ -187,6 +187,11 @@ public EncodedImage call()
                   try {
                     result = new EncodedImage(ref);
                     result.setEncodedCacheKey(key);
+                  } catch (Exception e) {
+                    // Remove the cached data if it cannot be used to create an encoded image.
+                    CloseableReference.closeSafely(ref);
+                    remove(key);
+                    throw e;
                   } finally {
                     CloseableReference.closeSafely(ref);
                   }
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java
index 3e8a18fb2..e838e1247 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java
@@ -18,6 +18,8 @@
 import com.facebook.imagepipeline.request.ImageRequest;
 import com.facebook.cache.common.CacheKey;
 
+import com.android.internal.util.Predicate;
+
 /**
  * Memory cache producer for the encoded memory cache.
  */
@@ -93,11 +95,25 @@ public void produceResults(
               ? ImmutableMap.of(EXTRA_CACHED_VALUE_FOUND, "false")
               : null);
       mInputProducer.produceResults(consumerOfInputProducer, producerContext);
+    } catch (Exception e) {
+      // Remove the cached data if it cannot be used to create an encoded image.
+      CloseableReference.closeSafely(cachedReference);
+      mMemoryCache.removeAll(predicateForKey(cacheKey));
+      throw e;
     } finally {
       CloseableReference.closeSafely(cachedReference);
     }
   }
 
+  private Predicate<CacheKey> predicateForKey(final CacheKey comparisonKey) {
+    return new Predicate<CacheKey>() {
+      @Override
+      public boolean apply(CacheKey key) {
+        return key.equals(comparisonKey);
+      }
+    };
+  }
+
   private static class EncodedMemoryCacheConsumer
       extends DelegatingConsumer<EncodedImage, EncodedImage> {
 
