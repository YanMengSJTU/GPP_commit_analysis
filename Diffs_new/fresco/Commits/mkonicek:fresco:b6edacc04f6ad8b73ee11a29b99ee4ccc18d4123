diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java
index 00e7190eb..f72279094 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedBitmapDrawable.java
@@ -31,11 +31,13 @@
 import com.facebook.common.internal.VisibleForTesting;
 
 /**
-* A drawable that can have rounded corners.
+ * Uses BitmapShader to draw the bitmap with rounded corners.
+ * Used when {@code RoundingParams.RoundingMethod.BITMAP_ONLY} is set.
 */
 public class RoundedBitmapDrawable extends BitmapDrawable
     implements TransformAwareDrawable, Rounded {
   private boolean mIsCircle = false;
+  /** True if at least one corner has a non-zero radius. */
   private boolean mRadiiNonZero = false;
   private final float[] mCornerRadii = new float[8];
   @VisibleForTesting final float[] mBorderRadii = new float[8];
@@ -52,6 +54,7 @@
   @VisibleForTesting final Matrix mPrevParentTransform = new Matrix();
   @VisibleForTesting final Matrix mInverseParentTransform = new Matrix();
 
+  /** Final computed transform used to draw the bitmap. */
   @VisibleForTesting final Matrix mTransform = new Matrix();
   private float mBorderWidth = 0;
   private int mBorderColor = Color.TRANSPARENT;
@@ -235,11 +238,26 @@ public void draw(Canvas canvas) {
     updatePaint();
     int saveCount = canvas.save();
     canvas.concat(mInverseParentTransform);
-    canvas.drawPath(mPath, mPaint);
+    if (isCircle()) {
+      // Simplified drawing in the special case
+      canvas.drawCircle(
+          mRootBounds.centerX(),
+          mRootBounds.centerY(),
+          Math.min(mRootBounds.width(), mRootBounds.height())/2,
+          mPaint);
+    } else {
+      canvas.drawPath(mPath, mPaint);
+    }
     if (mBorderWidth > 0) {
-      mBorderPaint.setStrokeWidth(mBorderWidth);
-      mBorderPaint.setColor(DrawableUtils.multiplyColorAlpha(mBorderColor, mPaint.getAlpha()));
-      canvas.drawPath(mBorderPath, mBorderPaint);
+        mBorderPaint.setStrokeWidth(mBorderWidth);
+        mBorderPaint.setColor(DrawableUtils.multiplyColorAlpha(mBorderColor, mPaint.getAlpha()));
+      if (isCircle()) {
+        // Simplified drawing in the special case
+        float radius = Math.min(mRootBounds.width(), mRootBounds.height())/2;
+        canvas.drawCircle(mRootBounds.centerX(), mRootBounds.centerY(), radius, mBorderPaint);
+      } else {
+        canvas.drawPath(mBorderPath, mBorderPaint);
+      }
     }
     canvas.restoreToCount(saveCount);
   }
@@ -270,7 +288,10 @@ private void updateTransform() {
       mIsShaderTransformDirty = true;
       mParentTransform.invert(mInverseParentTransform);
       mTransform.set(mParentTransform);
-      mTransform.preConcat(mBoundsTransform);
+      if (!mBoundsTransform.isIdentity()) {
+        // Identity for example when center_crop scaling is used and isCircle() is true.
+        mTransform.preConcat(mBoundsTransform);
+      }
       mPrevParentTransform.set(mParentTransform);
       mPrevBoundsTransform.set(mBoundsTransform);
     }
@@ -283,37 +304,32 @@ private void updateTransform() {
 
   private void updatePath() {
     if (mIsPathDirty) {
-      mBorderPath.reset();
       mRootBounds.inset(mBorderWidth/2, mBorderWidth/2);
-      if (mIsCircle) {
-        float radius = Math.min(mRootBounds.width(), mRootBounds.height())/2;
-        mBorderPath.addCircle(
-            mRootBounds.centerX(), mRootBounds.centerY(), radius, Path.Direction.CW);
-      } else {
-        for (int i = 0; i < mBorderRadii.length; i++) {
-          mBorderRadii[i] = mCornerRadii[i] + mPadding - mBorderWidth/2;
-        }
-        mBorderPath.addRoundRect(mRootBounds, mBorderRadii, Path.Direction.CW);
+      if (isCircle()) {
+        // Everything below is for the complex case.
+        // Circle is a special case, drawn using canvas.drawCircle().
+        return;
       }
-      mRootBounds.inset(-mBorderWidth/2, -mBorderWidth/2);
 
+      // Update border path
+      mBorderPath.reset();
+      for (int i = 0; i < mBorderRadii.length; i++) {
+        mBorderRadii[i] = mCornerRadii[i] + mPadding - mBorderWidth/2;
+      }
+      mBorderPath.addRoundRect(mRootBounds, mBorderRadii, Path.Direction.CW);
+
+      // Update path
+      mRootBounds.inset(-mBorderWidth/2, -mBorderWidth/2);
       mPath.reset();
       mRootBounds.inset(mPadding, mPadding);
-      if (mIsCircle) {
-        mPath.addCircle(
-            mRootBounds.centerX(),
-            mRootBounds.centerY(),
-            Math.min(mRootBounds.width(), mRootBounds.height())/2,
-            Path.Direction.CW);
-      } else {
-        mPath.addRoundRect(mRootBounds, mCornerRadii, Path.Direction.CW);
-      }
+      mPath.addRoundRect(mRootBounds, mCornerRadii, Path.Direction.CW);
       mRootBounds.inset(-(mPadding), -(mPadding));
       mPath.setFillType(Path.FillType.WINDING);
       mIsPathDirty = false;
     }
   }
 
+
   private void updatePaint() {
     Bitmap bitmap = getBitmap();
     if (mLastBitmap == null || mLastBitmap.get() != bitmap) {
@@ -322,7 +338,10 @@ private void updatePaint() {
       mIsShaderTransformDirty = true;
     }
     if (mIsShaderTransformDirty) {
-      mPaint.getShader().setLocalMatrix(mTransform);
+      // Draw the bitmap at the correct scale
+      if (!mTransform.isIdentity()) {
+        mPaint.getShader().setLocalMatrix(mTransform);
+      }
       mIsShaderTransformDirty = false;
     }
   }
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedColorDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedColorDrawable.java
index 24a20e770..c038d8325 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedColorDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedColorDrawable.java
@@ -24,6 +24,11 @@
 import com.facebook.common.internal.Preconditions;
 import com.facebook.common.internal.VisibleForTesting;
 
+/**
+ * Draws rounded corners of solid color. Does not draw a bitmap.
+ * Used as a helper for {@link RoundedCornersDrawable}
+ * when {@code RoundingParams.RoundingMethod.OVERLAY_COLOR} is set.
+ */
 public class RoundedColorDrawable extends Drawable implements Rounded {
   private final float[] mRadii = new float[8];
   @VisibleForTesting final float[] mBorderRadii = new float[8];
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedCornersDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedCornersDrawable.java
index e63d6ec30..1fec4981c 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/RoundedCornersDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/RoundedCornersDrawable.java
@@ -23,14 +23,16 @@
 import java.util.Arrays;
 
 /**
- * Drawable that draws underlying drawable with rounded corners.
+ * Draws the underlying drawable plus rounded corners of solid color
+ * on top of it (using {@link RoundedColorDrawable}).
+ * Used when {@code RoundingParams.RoundingMethod.OVERLAY_COLOR} is set.
  */
 public class RoundedCornersDrawable extends ForwardingDrawable implements Rounded {
 
   public enum Type {
     /**
-     * Draws rounded corners on top of the underlying drawable by overlaying a solid color which
-     * is specified by {@code setOverlayColor}. This option should only be used when the
+     * Draws rounded corners on top of the underlying drawable by overlaying a solid color path
+     * which is specified by {@code setOverlayColor}. This option should only be used when the
      * background beneath the underlying drawable is static and of the same solid color.
      */
     OVERLAY_COLOR,
diff --git a/samples/showcase/src/main/res/layout/fragment_drawee_rounded_corners.xml b/samples/showcase/src/main/res/layout/fragment_drawee_rounded_corners.xml
index 39c44c4dd..9c7213cef 100644
--- a/samples/showcase/src/main/res/layout/fragment_drawee_rounded_corners.xml
+++ b/samples/showcase/src/main/res/layout/fragment_drawee_rounded_corners.xml
@@ -17,7 +17,6 @@
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:orientation="vertical"
-        android:background="@drawable/bg_tiled"
         >
       <TextView
           android:layout_width="match_parent"
