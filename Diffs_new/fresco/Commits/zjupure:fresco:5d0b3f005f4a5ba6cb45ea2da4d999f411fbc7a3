diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java
index 36167b59a..1876f8b00 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducer.java
@@ -131,7 +131,7 @@ public void onNewResultImpl(EncodedImage newResult, @Status int status) {
         if (isNotLast(status)
             || newResult == null
             || statusHasAnyFlag(status, DO_NOT_CACHE_ENCODED | IS_PARTIAL_RESULT)
-                || newResult.getImageFormat() == ImageFormat.UNKNOWN) {
+            || newResult.getImageFormat() == ImageFormat.UNKNOWN) {
           getConsumer().onNewResult(newResult, status);
           return;
         }
diff --git a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducerTest.java b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducerTest.java
index 9d9a8ce27..c817cc6f3 100644
--- a/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducerTest.java
+++ b/imagepipeline/src/test/java/com/facebook/imagepipeline/producers/EncodedMemoryCacheProducerTest.java
@@ -17,6 +17,7 @@
 import com.facebook.common.internal.ImmutableMap;
 import com.facebook.common.memory.PooledByteBuffer;
 import com.facebook.common.references.CloseableReference;
+import com.facebook.imageformat.ImageFormat;
 import com.facebook.imagepipeline.cache.CacheKeyFactory;
 import com.facebook.imagepipeline.cache.MemoryCache;
 import com.facebook.imagepipeline.image.EncodedImage;
@@ -62,6 +63,7 @@
   private CloseableReference<PooledByteBuffer> mIntermediateImageReference;
   private CloseableReference<PooledByteBuffer> mFinalImageReferenceClone;
   private EncodedImage mFinalEncodedImage;
+  private EncodedImage mFinalEncodedImageFormatUnknown;
   private EncodedImage mIntermediateEncodedImage;
   private EncodedImage mFinalEncodedImageClone;
   private EncodedMemoryCacheProducer mEncodedMemoryCacheProducer;
@@ -78,6 +80,11 @@ public void setUp() {
     mIntermediateImageReference = CloseableReference.of(mPooledByteBuffer2);
     mFinalImageReferenceClone = mFinalImageReference.clone();
     mFinalEncodedImage = new EncodedImage(mFinalImageReference);
+    mFinalEncodedImage.setImageFormat(new ImageFormat("jpeg", null));
+    mFinalEncodedImage.setWidth(100);
+    mFinalEncodedImage.setHeight(100);
+
+    mFinalEncodedImageFormatUnknown = new EncodedImage(mFinalImageReference);
     mIntermediateEncodedImage = new EncodedImage(mIntermediateImageReference);
     mFinalEncodedImageClone = new EncodedImage(mFinalImageReferenceClone);
     List<CacheKey> list = new ArrayList<>();
@@ -161,16 +168,33 @@ public void testEncodedMemoryCacheGetNotFoundInputProducerSuccessButResultIsPart
     testInputProducerSuccessButResultNotCacheableDueToStatusFlags(Consumer.IS_PARTIAL_RESULT);
   }
 
+  @Test
+  public void testEncodedMemoryCacheGetNotFoundInputProducerSuccessButResultIsUnknownFormat() {
+    setupEncodedMemoryCacheGetNotFound();
+    setupInputProducerStreamingSuccessFormatUnknown();
+    mEncodedMemoryCacheProducer.produceResults(mConsumer, mProducerContext);
+    verify(mMemoryCache, never()).cache(any(CacheKey.class), any(CloseableReference.class));
+    verify(mConsumer).onNewResult(mIntermediateEncodedImage, Consumer.NO_FLAGS);
+    verify(mConsumer).onNewResult(mFinalEncodedImageFormatUnknown, Consumer.IS_LAST);
+    Assert.assertTrue(EncodedImage.isValid(mFinalEncodedImageClone));
+    verify(mProducerListener).onProducerStart(mRequestId, PRODUCER_NAME);
+    Map<String, String> extraMap =
+            ImmutableMap.of(EncodedMemoryCacheProducer.EXTRA_CACHED_VALUE_FOUND, "false");
+    verify(mProducerListener).onProducerFinishWithSuccess(mRequestId, PRODUCER_NAME, extraMap);
+    verify(mProducerListener, never())
+            .onUltimateProducerReached(anyString(), anyString(), anyBoolean());
+  }
+
   private void testInputProducerSuccessButResultNotCacheableDueToStatusFlags(
       final @Consumer.Status int statusFlags) {
-    setupInputProducerStreamingSuccessWithStatusFlags(statusFlags);
+    setupInputProducerStreamingSuccessWithStatusFlags(statusFlags, mFinalEncodedImageFormatUnknown);
     mEncodedMemoryCacheProducer.produceResults(mConsumer, mProducerContext);
 
     verify(mMemoryCache, never()).cache(any(CacheKey.class), any(CloseableReference.class));
     verify(mConsumer)
         .onNewResult(mIntermediateEncodedImage, statusFlags);
     verify(mConsumer)
-        .onNewResult(mFinalEncodedImage, Consumer.IS_LAST | statusFlags);
+        .onNewResult(mFinalEncodedImageFormatUnknown, Consumer.IS_LAST | statusFlags);
     Assert.assertTrue(EncodedImage.isValid(mFinalEncodedImageClone));
     verify(mProducerListener).onProducerStart(mRequestId, PRODUCER_NAME);
     Map<String, String> extraMap =
@@ -231,13 +255,18 @@ private void setupEncodedMemoryCacheGetNotFound() {
     when(mMemoryCache.get(eq(mCacheKey))).thenReturn(null);
   }
 
+  private void setupInputProducerStreamingSuccessFormatUnknown() {
+    setupInputProducerStreamingSuccessWithStatusFlags(0, mFinalEncodedImageFormatUnknown);
+  }
+
   private void setupInputProducerStreamingSuccess() {
-    setupInputProducerStreamingSuccessWithStatusFlags(0);
+    setupInputProducerStreamingSuccessWithStatusFlags(0, mFinalEncodedImage);
   }
 
-  private void setupInputProducerStreamingSuccessWithStatusFlags(@Consumer.Status int statusFlags) {
+  private void setupInputProducerStreamingSuccessWithStatusFlags(
+          @Consumer.Status int statusFlags, EncodedImage finalEncodedImage) {
     doAnswer(new ProduceResultsNewResultAnswer(
-            Arrays.asList(mIntermediateEncodedImage, mFinalEncodedImage), statusFlags))
+            Arrays.asList(mIntermediateEncodedImage, finalEncodedImage), statusFlags))
         .when(mInputProducer).produceResults(any(Consumer.class), eq(mProducerContext));
   }
 
