diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
index a13c101b7..aa1bf721f 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/cache/BufferedDiskCache.java
@@ -9,14 +9,10 @@
 
 package com.facebook.imagepipeline.cache;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
-
+import com.facebook.binaryresource.BinaryResource;
+import com.facebook.cache.common.CacheKey;
+import com.facebook.cache.common.WriterCallback;
+import com.facebook.cache.disk.FileCache;
 import com.facebook.common.internal.Preconditions;
 import com.facebook.common.logging.FLog;
 import com.facebook.common.references.CloseableReference;
@@ -24,10 +20,14 @@
 import com.facebook.imagepipeline.memory.PooledByteBuffer;
 import com.facebook.imagepipeline.memory.PooledByteBufferFactory;
 import com.facebook.imagepipeline.memory.PooledByteStreams;
-import com.facebook.binaryresource.BinaryResource;
-import com.facebook.cache.common.CacheKey;
-import com.facebook.cache.common.WriterCallback;
-import com.facebook.cache.disk.FileCache;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import bolts.Task;
 
@@ -124,6 +124,32 @@ public Boolean call() throws Exception {
     }
   }
 
+  /**
+   * Performs disk cache check synchronously.
+   * @param key
+   * @return true if the key is found in disk cache else false
+   */
+  public boolean syncDiskCheck(final CacheKey key){
+    if(containsSync(key)){
+      return true;
+    }
+    EncodedImage result = mStagingArea.get(key);
+    if (result != null) {
+      result.close();
+      FLog.v(TAG, "Found image for %s in staging area", key.toString());
+      mImageCacheStatsTracker.onStagingAreaHit();
+      return true;
+    } else {
+      FLog.v(TAG, "Did not find image for %s in staging area", key.toString());
+      mImageCacheStatsTracker.onStagingAreaMiss();
+      try {
+        return mFileCache.hasKey(key);
+      } catch (Exception exception) {
+        return false;
+      }
+    }
+  }
+
   /**
    * Performs key-value look up in disk cache. If value is not found in disk cache staging area
    * then disk cache read is scheduled on background thread. Any error manifests itself as
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
index 148502048..efc671061 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipeline.java
@@ -9,15 +9,9 @@
 
 package com.facebook.imagepipeline.core;
 
-import javax.annotation.concurrent.ThreadSafe;
-
-import java.lang.Exception;
-import java.util.Set;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.atomic.AtomicLong;
-
 import android.net.Uri;
 
+import com.android.internal.util.Predicate;
 import com.facebook.cache.common.CacheKey;
 import com.facebook.common.internal.Objects;
 import com.facebook.common.internal.Preconditions;
@@ -28,26 +22,29 @@
 import com.facebook.datasource.DataSources;
 import com.facebook.datasource.SimpleDataSource;
 import com.facebook.imagepipeline.cache.BufferedDiskCache;
-import com.facebook.imagepipeline.cache.MemoryCache;
 import com.facebook.imagepipeline.cache.CacheKeyFactory;
+import com.facebook.imagepipeline.cache.MemoryCache;
 import com.facebook.imagepipeline.common.Priority;
 import com.facebook.imagepipeline.datasource.CloseableProducerToDataSourceAdapter;
 import com.facebook.imagepipeline.datasource.ProducerToDataSourceAdapter;
 import com.facebook.imagepipeline.image.CloseableImage;
+import com.facebook.imagepipeline.listener.ForwardingRequestListener;
+import com.facebook.imagepipeline.listener.RequestListener;
 import com.facebook.imagepipeline.memory.PooledByteBuffer;
 import com.facebook.imagepipeline.producers.Producer;
 import com.facebook.imagepipeline.producers.SettableProducerContext;
-import com.facebook.imagepipeline.listener.ForwardingRequestListener;
+import com.facebook.imagepipeline.producers.ThreadHandoffProducerQueue;
 import com.facebook.imagepipeline.request.ImageRequest;
-import com.facebook.imagepipeline.listener.RequestListener;
+import com.facebook.imagepipeline.request.ImageRequestBuilder;
 
-import bolts.Continuation;
-import com.android.internal.util.Predicate;
+import java.util.Set;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.atomic.AtomicLong;
 
-import com.facebook.imagepipeline.request.ImageRequestBuilder;
+import javax.annotation.concurrent.ThreadSafe;
 
+import bolts.Continuation;
 import bolts.Task;
-import com.facebook.imagepipeline.producers.ThreadHandoffProducerQueue;
 
 /**
  * The entry point for the image pipeline.
@@ -255,10 +252,10 @@ public String toString() {
       Producer<Void> producerSequence =
           mProducerSequenceFactory.getDecodedImagePrefetchProducerSequence(imageRequest);
       return submitPrefetchRequest(
-          producerSequence,
-          imageRequest,
-          ImageRequest.RequestLevel.FULL_FETCH,
-          callerContext);
+              producerSequence,
+              imageRequest,
+              ImageRequest.RequestLevel.FULL_FETCH,
+              callerContext);
     } catch (Exception exception) {
       return DataSources.immediateFailedDataSource(exception);
     }
@@ -279,10 +276,10 @@ public String toString() {
       Producer<Void> producerSequence =
           mProducerSequenceFactory.getEncodedImagePrefetchProducerSequence(imageRequest);
       return submitPrefetchRequest(
-          producerSequence,
-          imageRequest,
-          ImageRequest.RequestLevel.FULL_FETCH,
-          callerContext);
+              producerSequence,
+              imageRequest,
+              ImageRequest.RequestLevel.FULL_FETCH,
+              callerContext);
     } catch (Exception exception) {
       return DataSources.immediateFailedDataSource(exception);
     }
@@ -389,6 +386,27 @@ public boolean isInBitmapMemoryCache(final ImageRequest imageRequest) {
     }
   }
 
+  /**
+   *
+   * @param uri the uri for the image to be looked up.
+   * @return true if the image was found in the disk cache, false otherwise.
+   */
+  public boolean isInDiskCacheSync(final Uri uri) {
+    return isInDiskCacheSync(ImageRequest.fromUri(uri));
+  }
+
+  /**
+   * Performs disk cache check synchronously. It is not recommended to use this
+   * unless u know what exactly you are doing. Disk cache check is a costly operation,
+   * doing this on UI thread will block the thread until it gets the response.
+   * @param imageRequest the imageRequest for the image to be looked up.
+   * @return true if the image was found in the disk cache, false otherwise.
+   */
+  public boolean isInDiskCacheSync(final ImageRequest imageRequest) {
+    final CacheKey cacheKey = mCacheKeyFactory.getEncodedCacheKey(imageRequest);
+    return mMainBufferedDiskCache.syncDiskCheck(cacheKey);
+  }
+
   /**
    * Returns whether the image is stored in the disk cache.
    *
@@ -424,13 +442,13 @@ public boolean isInBitmapMemoryCache(final ImageRequest imageRequest) {
               }
             })
         .continueWith(
-            new Continuation<Boolean, Void>() {
-              @Override
-              public Void then(Task<Boolean> task) throws Exception {
-                dataSource.setResult(!task.isCancelled() && !task.isFaulted() && task.getResult());
-                return null;
-              }
-            });
+                new Continuation<Boolean, Void>() {
+                    @Override
+                    public Void then(Task<Boolean> task) throws Exception {
+                        dataSource.setResult(!task.isCancelled() && !task.isFaulted() && task.getResult());
+                        return null;
+                    }
+                });
     return dataSource;
   }
 
