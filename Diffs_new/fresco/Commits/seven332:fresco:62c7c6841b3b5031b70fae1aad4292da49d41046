diff --git a/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java b/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java
index 563921f35..85db4bdc3 100644
--- a/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java
+++ b/drawee/src/main/java/com/facebook/drawee/controller/AbstractDraweeController.java
@@ -627,6 +627,11 @@ private void logMessageAndFailure(String messageAndMethod, Throwable throwable)
     }
   }
 
+  @Override
+  public @Nullable Drawable getDrawable() {
+    return mDrawable;
+  }
+
   @Override
   public @Nullable Animatable getAnimatable() {
     return (mDrawable instanceof Animatable) ? (Animatable) mDrawable : null;
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java b/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java
index 0ef98372a..c2c75bff1 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/ScaleTypeDrawable.java
@@ -163,6 +163,17 @@ private void configureBoundsIfUnderlyingChanged() {
     int underlyingWidth = mUnderlyingWidth = underlyingDrawable.getIntrinsicWidth();
     int underlyingHeight = mUnderlyingHeight = underlyingDrawable.getIntrinsicHeight();
 
+    // If the active drawable is scaled, let it scale itself
+    Scaled scaled = getActiveScaled(underlyingDrawable);
+    if (scaled != null) {
+      scaled.setScaleType(mScaleType);
+      scaled.setFocusPoint(mFocusPoint);
+      underlyingDrawable.setBounds(bounds);
+      scaled.applyScaleType();
+      mDrawMatrix = null;
+      return;
+    }
+
     // If the drawable has no intrinsic size, we just fill our entire view.
     if (underlyingWidth <= 0 || underlyingHeight <= 0) {
       underlyingDrawable.setBounds(bounds);
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/Scaled.java b/drawee/src/main/java/com/facebook/drawee/drawable/Scaled.java
new file mode 100644
index 000000000..93c719495
--- /dev/null
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/Scaled.java
@@ -0,0 +1,16 @@
+package com.facebook.drawee.drawable;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import android.graphics.PointF;
+
+public interface Scaled {
+
+  void setScaleType(ScalingUtils.ScaleType scaleType);
+
+  void setFocusPoint(PointF focusPoint);
+
+  void applyScaleType();
+}
diff --git a/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java b/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java
index b362469da..ae9d23fc1 100644
--- a/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java
+++ b/drawee/src/main/java/com/facebook/drawee/drawable/ScalingUtils.java
@@ -130,6 +130,30 @@ public static ScaleTypeDrawable getActiveScaleTypeDrawable(Drawable drawable) {
     return null;
   }
 
+  @Nullable
+  public static Scaled getActiveScaled(Drawable drawable) {
+    if (drawable == null) {
+      return null;
+    } else if (drawable instanceof Scaled) {
+      return (Scaled) drawable;
+    } else if (drawable instanceof DrawableParent) {
+      final Drawable childDrawable = ((DrawableParent) drawable).getDrawable();
+      return getActiveScaled(childDrawable);
+    } else if (drawable instanceof ArrayDrawable) {
+      final ArrayDrawable fadeDrawable = (ArrayDrawable) drawable;
+      final int numLayers = fadeDrawable.getNumberOfLayers();
+
+      for (int i = 0; i < numLayers; i++) {
+        final Drawable childDrawable = fadeDrawable.getDrawable(i);
+        final Scaled result = getActiveScaled(childDrawable);
+        if (result != null) {
+          return result;
+        }
+      }
+    }
+    return null;
+  }
+
   /**
    * A convenience base class that has some common logic.
    */
diff --git a/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeController.java b/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeController.java
index 68dc0ae05..7e5f388a0 100644
--- a/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeController.java
+++ b/drawee/src/main/java/com/facebook/drawee/interfaces/DraweeController.java
@@ -12,6 +12,7 @@
 import javax.annotation.Nullable;
 
 import android.graphics.drawable.Animatable;
+import android.graphics.drawable.Drawable;
 import android.view.MotionEvent;
 
 /**
@@ -52,6 +53,11 @@
    */
   boolean onTouchEvent(MotionEvent event);
 
+  /**
+   * Gets the drawable.
+   */
+  Drawable getDrawable();
+
   /**
    * For an animated image, returns an Animatable that lets clients control the animation.
    * @return animatable, or null if the image is not animated or not loaded yet
diff --git a/fresco-large/.gitignore b/fresco-large/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/fresco-large/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/fresco-large/build.gradle b/fresco-large/build.gradle
new file mode 100644
index 000000000..e816b034d
--- /dev/null
+++ b/fresco-large/build.gradle
@@ -0,0 +1,27 @@
+apply plugin: 'com.android.library'
+apply plugin: 'maven'
+
+project.group = GROUP
+
+dependencies {
+    provided "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    compile project(':drawee-backends:drawee-pipeline')
+
+    testCompile 'junit:junit:4.12'
+}
+
+apply from: rootProject.file('release.gradle')
+
+android {
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+    lintOptions {
+        abortOnError false
+    }
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+artifacts.add('archives', sourcesJar)
diff --git a/fresco-large/gradle.properties b/fresco-large/gradle.properties
new file mode 100644
index 000000000..4cfa9ebfa
--- /dev/null
+++ b/fresco-large/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=FrescoLarge
+POM_DESCRIPTION=Adds support for large images
+POM_ARTIFACT_ID=fresco-large
+POM_PACKAGING=aar
diff --git a/fresco-large/src/main/AndroidManifest.xml b/fresco-large/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..3fd61d17b
--- /dev/null
+++ b/fresco-large/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.hippo.fresco.large"
+    >
+
+  <uses-sdk
+      android:minSdkVersion="11"
+      android:targetSdkVersion="21"
+      />
+</manifest>
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/CloseableLargeImage.java b/fresco-large/src/main/java/com/hippo/fresco/large/CloseableLargeImage.java
new file mode 100644
index 000000000..167255308
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/CloseableLargeImage.java
@@ -0,0 +1,66 @@
+package com.hippo.fresco.large;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nullable;
+
+import com.facebook.common.references.CloseableReference;
+import com.facebook.imagepipeline.image.CloseableImage;
+
+import com.hippo.fresco.large.decoder.ImageRegionDecoder;
+
+public class CloseableLargeImage extends CloseableImage {
+
+  private CloseableReference<ImageRegionDecoder> decoderReference;
+  private final int length;
+  private final int width;
+  private final int height;
+
+  public CloseableLargeImage(ImageRegionDecoder decoder, int length) {
+    this.decoderReference = CloseableReference.of(decoder);
+    this.length = length >= 0 ? length : 0;
+    this.width = decoder.getWidth();
+    this.height = decoder.getHeight();
+  }
+
+  @Nullable
+  public synchronized CloseableReference<ImageRegionDecoder> getDecoder() {
+    return decoderReference.cloneOrNull();
+  }
+
+  @Override
+  public int getWidth() {
+    return width;
+  }
+
+  @Override
+  public int getHeight() {
+    return height;
+  }
+
+  @Override
+  public int getSizeInBytes() {
+    return length;
+  }
+
+  @Override
+  public void close() {
+    CloseableReference<ImageRegionDecoder> reference = detachDecoderReference();
+    if (reference != null) {
+      reference.close();
+    }
+  }
+
+  private synchronized CloseableReference<ImageRegionDecoder> detachDecoderReference() {
+    CloseableReference<ImageRegionDecoder> reference = decoderReference;
+    decoderReference = null;
+    return reference;
+  }
+
+  @Override
+  public synchronized boolean isClosed() {
+    return decoderReference == null;
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/FrescoLarge.java b/fresco-large/src/main/java/com/hippo/fresco/large/FrescoLarge.java
new file mode 100644
index 000000000..63d6b6486
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/FrescoLarge.java
@@ -0,0 +1,66 @@
+package com.hippo.fresco.large;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nonnull;
+
+import java.util.Map;
+import java.util.Set;
+
+import com.facebook.common.logging.FLog;
+import com.facebook.drawee.backends.pipeline.DraweeConfig;
+import com.facebook.imageformat.ImageFormat;
+import com.facebook.imagepipeline.decoder.ImageDecoderConfig;
+
+import com.hippo.fresco.large.decoder.ImageRegionDecoderFactory;
+import com.hippo.fresco.large.drawable.LargeDrawableFactory;
+
+public final class FrescoLarge {
+  private FrescoLarge() {}
+
+  private static final Class<?> TAG = FrescoLarge.class;
+
+  public static void config(@Nonnull ImageDecoderConfig.Builder decoderConfigBuilder,
+      @Nonnull DraweeConfig.Builder draweeConfigBuilder, @Nonnull FrescoLargeConfig config) {
+    Set<ImageFormat> imageFormatSet = config.getImageFormatSet();
+    if (imageFormatSet == null || imageFormatSet.isEmpty()) {
+      FLog.w(TAG, "No ImageFormat");
+      return;
+    }
+
+    Map<ImageFormat, ImageRegionDecoderFactory> regionDecoderFactoryMap =
+        config.getImageRegionDecoderFactoryMap();
+    if (regionDecoderFactoryMap == null || regionDecoderFactoryMap.isEmpty()) {
+      FLog.w(TAG, "No ImageRegionDecoderFactory");
+      return;
+    }
+
+    LargeDrawableFactory factory = config.getLargeDrawableFactory();
+    if (factory == null) {
+      FLog.w(TAG, "No LargeDrawableFactory");
+      return;
+    }
+
+    Map<ImageFormat, ImageFormat.FormatChecker> imageFormatCheckerMap =
+        config.getImageFormatCheckerMap();
+    if (imageFormatCheckerMap != null) {
+      for (Map.Entry<ImageFormat, ImageFormat.FormatChecker> entry :
+          config.getImageFormatCheckerMap().entrySet()) {
+        // Apply image format checker.
+        // Pass null for ImageDecoder, it should be override by LargeImageDecoder
+        decoderConfigBuilder.addDecodingCapability(entry.getKey(), entry.getValue(), null);
+      }
+    }
+
+    LargeImageDecoder largeImageDecoder = new LargeImageDecoder(config.getImageSizeDecoderMap(),
+        config.getImageRegionDecoderFactoryMap(), config.getImageDecoderMap(),
+        config.getThresholdWidth(), config.getThresholdHeight());
+    for (ImageFormat imageFormat : config.getImageFormatSet()) {
+      decoderConfigBuilder.overrideDecoder(imageFormat, largeImageDecoder);
+    }
+
+    draweeConfigBuilder.addCustomDrawableFactory(config.getLargeDrawableFactory());
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/FrescoLargeConfig.java b/fresco-large/src/main/java/com/hippo/fresco/large/FrescoLargeConfig.java
new file mode 100644
index 000000000..cf6a3f5ab
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/FrescoLargeConfig.java
@@ -0,0 +1,153 @@
+package com.hippo.fresco.large;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import com.facebook.imageformat.ImageFormat;
+import com.facebook.imagepipeline.decoder.ImageDecoder;
+
+import com.hippo.fresco.large.decoder.ImageRegionDecoderFactory;
+import com.hippo.fresco.large.decoder.ImageSizeDecoder;
+import com.hippo.fresco.large.drawable.LargeDrawableFactory;
+import com.hippo.fresco.large.drawable.SubsamplingDrawableFactory;
+
+public class FrescoLargeConfig {
+
+  private final Set<ImageFormat> imageFormatSet;
+  private final Map<ImageFormat, ImageFormat.FormatChecker> formatCheckerMap;
+  private final Map<ImageFormat, ImageSizeDecoder> sizeDecoderMap;
+  private final Map<ImageFormat, ImageRegionDecoderFactory> regionDecoderFactoryMap;
+  private final Map<ImageFormat, ImageDecoder> imageDecoderMap;
+  private LargeDrawableFactory largeDrawableFactory;
+  private final int thresholdWidth;
+  private final int thresholdHeight;
+
+  public FrescoLargeConfig(Builder builder) {
+    imageFormatSet = builder.imageFormatSet;
+    formatCheckerMap = builder.formatCheckerMap;
+    sizeDecoderMap = builder.sizeDecoderMap;
+    regionDecoderFactoryMap = builder.regionDecoderFactoryMap;
+    imageDecoderMap = builder.imageDecoderMap;
+    largeDrawableFactory = builder.largeDrawableFactory;
+    thresholdWidth = builder.thresholdWidth;
+    thresholdHeight = builder.thresholdHeight;
+  }
+
+  public Set<ImageFormat> getImageFormatSet() {
+    return imageFormatSet;
+  }
+
+  public Map<ImageFormat, ImageFormat.FormatChecker> getImageFormatCheckerMap() {
+    return formatCheckerMap;
+  }
+
+  public Map<ImageFormat, ImageSizeDecoder> getImageSizeDecoderMap() {
+    return sizeDecoderMap;
+  }
+
+  public Map<ImageFormat, ImageRegionDecoderFactory> getImageRegionDecoderFactoryMap() {
+    return regionDecoderFactoryMap;
+  }
+
+  public Map<ImageFormat, ImageDecoder> getImageDecoderMap() {
+    return imageDecoderMap;
+  }
+
+  public LargeDrawableFactory getLargeDrawableFactory() {
+    if (largeDrawableFactory == null) {
+      largeDrawableFactory = new SubsamplingDrawableFactory();
+    }
+    return largeDrawableFactory;
+  }
+
+  public int getThresholdWidth() {
+    return thresholdWidth;
+  }
+
+  public int getThresholdHeight() {
+    return thresholdHeight;
+  }
+
+  public static Builder newBuilder() {
+    return new Builder();
+  }
+
+  public static class Builder {
+    private Set<ImageFormat> imageFormatSet;
+    private Map<ImageFormat, ImageFormat.FormatChecker> formatCheckerMap;
+    private Map<ImageFormat, ImageSizeDecoder> sizeDecoderMap;
+    private Map<ImageFormat, ImageRegionDecoderFactory> regionDecoderFactoryMap;
+    private Map<ImageFormat, ImageDecoder> imageDecoderMap;
+    private LargeDrawableFactory largeDrawableFactory;
+    private int thresholdWidth;
+    private int thresholdHeight;
+
+    public FrescoLargeConfig.Builder addDecoder(@Nonnull ImageFormat imageFormat,
+        @Nonnull ImageRegionDecoderFactory imageRegionDecoderFactory) {
+      return addDecoder(imageFormat, null, null, imageRegionDecoderFactory, null);
+    }
+
+    public FrescoLargeConfig.Builder addDecoder(@Nonnull ImageFormat imageFormat,
+        @Nullable ImageFormat.FormatChecker imageFormatChecker,
+        @Nullable ImageSizeDecoder imageSizeDecoder,
+        @Nonnull ImageRegionDecoderFactory imageRegionDecoderFactory,
+        @Nullable ImageDecoder imageDecoder) {
+      if (imageFormatSet == null) {
+        imageFormatSet = new HashSet<>();
+      }
+      imageFormatSet.add(imageFormat);
+
+      if (imageFormatChecker != null) {
+        if (formatCheckerMap == null) {
+          formatCheckerMap = new HashMap<>();
+        }
+        formatCheckerMap.put(imageFormat, imageFormatChecker);
+      }
+
+      if (imageSizeDecoder != null) {
+        if (sizeDecoderMap == null) {
+          sizeDecoderMap = new HashMap<>();
+        }
+        sizeDecoderMap.put(imageFormat, imageSizeDecoder);
+      }
+
+      if (regionDecoderFactoryMap == null) {
+        regionDecoderFactoryMap = new HashMap<>();
+      }
+      regionDecoderFactoryMap.put(imageFormat, imageRegionDecoderFactory);
+
+      if (imageDecoder != null) {
+        if (imageDecoderMap == null) {
+          imageDecoderMap = new HashMap<>();
+        }
+        imageDecoderMap.put(imageFormat, imageDecoder);
+      }
+
+      return this;
+    }
+
+    public FrescoLargeConfig.Builder setLargeDrawableFactory(LargeDrawableFactory factory) {
+      largeDrawableFactory = factory;
+      return this;
+    }
+
+    public FrescoLargeConfig.Builder setThresholdSize(int width, int height) {
+      thresholdWidth = width;
+      thresholdHeight = height;
+      return this;
+    }
+
+    public FrescoLargeConfig build() {
+      return new FrescoLargeConfig(this);
+    }
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/LargeDraweeView.java b/fresco-large/src/main/java/com/hippo/fresco/large/LargeDraweeView.java
new file mode 100644
index 000000000..cdab022a4
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/LargeDraweeView.java
@@ -0,0 +1,115 @@
+package com.hippo.fresco.large;
+
+/*
+ * Created by Hippo on 5/31/2017.
+ */
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+
+import com.facebook.drawee.generic.GenericDraweeHierarchy;
+import com.facebook.drawee.interfaces.DraweeController;
+import com.facebook.drawee.view.SimpleDraweeView;
+
+import com.hippo.fresco.large.drawable.SubsamplingDrawable;
+import com.hippo.fresco.large.gesture.GestureRecognizer;
+
+public class LargeDraweeView extends SimpleDraweeView implements GestureRecognizer.Listener {
+
+  private GestureRecognizer gestureRecognizer;
+
+  public LargeDraweeView(Context context, GenericDraweeHierarchy hierarchy) {
+    super(context, hierarchy);
+    init(context);
+  }
+
+  public LargeDraweeView(Context context) {
+    super(context);
+    init(context);
+  }
+
+  public LargeDraweeView(Context context, AttributeSet attrs) {
+    super(context, attrs);
+    init(context);
+  }
+
+  public LargeDraweeView(Context context, AttributeSet attrs, int defStyle) {
+    super(context, attrs, defStyle);
+    init(context);
+  }
+
+  public LargeDraweeView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
+    super(context, attrs, defStyleAttr, defStyleRes);
+    init(context);
+  }
+
+  private void init(Context context) {
+    gestureRecognizer = new GestureRecognizer(context, this);
+    gestureRecognizer.setIsDoubleTapEnabled(false);
+    gestureRecognizer.setIsLongPressEnabled(false);
+  }
+
+  @Override
+  public boolean onTouchEvent(MotionEvent event) {
+    super.onTouchEvent(event);
+    gestureRecognizer.onTouchEvent(event);
+    return true;
+  }
+
+  private SubsamplingDrawable getSubsamplingDrawable() {
+    DraweeController controller = getController();
+    if (controller != null) {
+      Drawable drawable = controller.getDrawable();
+      if (drawable instanceof SubsamplingDrawable) {
+        return (SubsamplingDrawable) drawable;
+      }
+    }
+    return null;
+  }
+
+  @Override
+  public void onSingleTap(float x, float y) {
+
+  }
+
+  @Override
+  public void onDoubleTap(float x, float y) {
+
+  }
+
+  @Override
+  public void onLongPress(float x, float y) {
+
+  }
+
+  @Override
+  public void onScroll(float dx, float dy, float totalX, float totalY, float x, float y) {
+    SubsamplingDrawable drawable = getSubsamplingDrawable();
+    if (drawable != null) {
+      drawable.translate(dx, dy);
+    }
+  }
+
+  @Override
+  public void onFling(float velocityX, float velocityY) {
+
+  }
+
+  @Override
+  public void onScale(float factor, float x, float y) {
+    SubsamplingDrawable drawable = getSubsamplingDrawable();
+    if (drawable != null) {
+      drawable.scale(factor, factor, x, y);
+    }
+  }
+
+  @Override
+  public void onRotate(float angle, float x, float y) {
+    SubsamplingDrawable drawable = getSubsamplingDrawable();
+    if (drawable != null) {
+      drawable.rotate(angle, x, y);
+    }
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/LargeImageDecoder.java b/fresco-large/src/main/java/com/hippo/fresco/large/LargeImageDecoder.java
new file mode 100644
index 000000000..42147165b
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/LargeImageDecoder.java
@@ -0,0 +1,124 @@
+package com.hippo.fresco.large;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nullable;
+
+import java.util.Map;
+
+import android.util.Pair;
+
+import com.facebook.drawee.backends.pipeline.Fresco;
+import com.facebook.imageformat.DefaultImageFormats;
+import com.facebook.imageformat.ImageFormat;
+import com.facebook.imagepipeline.common.ImageDecodeOptions;
+import com.facebook.imagepipeline.decoder.DefaultImageDecoder;
+import com.facebook.imagepipeline.decoder.ImageDecoder;
+import com.facebook.imagepipeline.image.CloseableImage;
+import com.facebook.imagepipeline.image.EncodedImage;
+import com.facebook.imagepipeline.image.QualityInfo;
+
+import com.hippo.fresco.large.decoder.DefaultImageSizeDecoder;
+import com.hippo.fresco.large.decoder.ImageRegionDecoder;
+import com.hippo.fresco.large.decoder.ImageRegionDecoderFactory;
+import com.hippo.fresco.large.decoder.ImageSizeDecoder;
+
+class LargeImageDecoder implements ImageDecoder {
+
+  private boolean hasDefaultImageDecoder;
+  @Nullable
+  private DefaultImageDecoder defaultImageDecoder;
+
+  private final ImageSizeDecoder defaultSizeDecoder;
+
+  @Nullable
+  private final Map<ImageFormat, ImageSizeDecoder> sizeDecoderMap;
+  private final Map<ImageFormat, ImageRegionDecoderFactory> regionDecoderFactoryMap;
+  @Nullable
+  private final Map<ImageFormat, ImageDecoder> imageDecoderMap;
+  private final int thresholdWidth;
+  private final int thresholdHeight;
+
+  public LargeImageDecoder(
+      Map<ImageFormat, ImageSizeDecoder> sizeDecoderMap,
+      Map<ImageFormat, ImageRegionDecoderFactory> regionDecoderFactoryMap,
+      Map<ImageFormat, ImageDecoder> imageDecoderMap,
+      int thresholdWidth,
+      int thresholdHeight) {
+    this.sizeDecoderMap = sizeDecoderMap;
+    this.regionDecoderFactoryMap = regionDecoderFactoryMap;
+    this.imageDecoderMap = imageDecoderMap;
+    this.thresholdWidth = thresholdWidth;
+    this.thresholdHeight = thresholdHeight;
+
+    defaultSizeDecoder = new DefaultImageSizeDecoder();
+  }
+
+  private DefaultImageDecoder getDefaultImageDecoder() {
+    if (!hasDefaultImageDecoder) {
+      hasDefaultImageDecoder = true;
+      ImageDecoder decoder = Fresco.getImagePipelineFactory().getImageDecoder();
+      if (decoder instanceof DefaultImageDecoder) {
+        defaultImageDecoder = (DefaultImageDecoder) decoder;
+      }
+    }
+    return defaultImageDecoder;
+  }
+
+  private boolean isLargeEnough(int width, int height) {
+    return width > thresholdWidth || height > thresholdHeight;
+  }
+
+  @Override
+  public CloseableImage decode(EncodedImage encodedImage, int length, QualityInfo qualityInfo,
+      ImageDecodeOptions options) {
+    ImageFormat imageFormat = encodedImage.getImageFormat();
+
+    // Only support full quality
+    if (qualityInfo.isOfFullQuality()) {
+      // Get image size decoder
+      ImageSizeDecoder sizeDecoder = null;
+      if (sizeDecoderMap != null) {
+        sizeDecoder = sizeDecoderMap.get(imageFormat);
+      }
+      if (sizeDecoder == null) {
+        sizeDecoder = this.defaultSizeDecoder;
+      }
+
+      Pair<Integer, Integer> size = sizeDecoder.decode(encodedImage);
+      if (size != null && isLargeEnough(size.first, size.second)) {
+        ImageRegionDecoderFactory factory = regionDecoderFactoryMap.get(imageFormat);
+        if (factory != null) {
+          ImageRegionDecoder decoder =
+              factory.createImageRegionDecoder(encodedImage, options);
+          if (decoder != null) {
+            return new CloseableLargeImage(decoder, encodedImage.getSize());
+          }
+        }
+      }
+    }
+
+    if (imageDecoderMap != null) {
+      ImageDecoder imageDecoder = imageDecoderMap.get(imageFormat);
+      if (imageDecoder != null) {
+        return imageDecoder.decode(encodedImage, length, qualityInfo, options);
+      }
+    }
+
+    DefaultImageDecoder defaultImageDecoder = getDefaultImageDecoder();
+    if (defaultImageDecoder != null) {
+      if (imageFormat == DefaultImageFormats.JPEG) {
+        return defaultImageDecoder.decodeJpeg(encodedImage, length, qualityInfo, options);
+      } else if (imageFormat == DefaultImageFormats.GIF) {
+        return defaultImageDecoder.decodeGif(encodedImage, options);
+      } else if (imageFormat == DefaultImageFormats.WEBP_ANIMATED) {
+        return defaultImageDecoder.decodeAnimatedWebp(encodedImage, options);
+      }
+      return defaultImageDecoder.decodeStaticImage(encodedImage, options);
+    }
+
+    return null;
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/decoder/DefaultImageSizeDecoder.java b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/DefaultImageSizeDecoder.java
new file mode 100644
index 000000000..d1c1bd404
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/DefaultImageSizeDecoder.java
@@ -0,0 +1,29 @@
+package com.hippo.fresco.large.decoder;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nullable;
+
+import android.util.Pair;
+
+import com.facebook.imagepipeline.image.EncodedImage;
+
+public class DefaultImageSizeDecoder implements ImageSizeDecoder {
+
+  @Nullable
+  @Override
+  public Pair<Integer, Integer> decode(EncodedImage encodedImage) {
+    encodedImage.parseMetaData();
+
+    int width = encodedImage.getWidth();
+    int height = encodedImage.getHeight();
+
+    if (width >= 0 && height >= 0) {
+      return new Pair<>(width, height);
+    } else {
+      return null;
+    }
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageRegionDecoder.java b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageRegionDecoder.java
new file mode 100644
index 000000000..b667bec44
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageRegionDecoder.java
@@ -0,0 +1,25 @@
+package com.hippo.fresco.large.decoder;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nullable;
+
+import java.io.Closeable;
+
+import android.graphics.Bitmap;
+import android.graphics.Rect;
+
+public interface ImageRegionDecoder extends Closeable {
+
+  int getWidth();
+
+  int getHeight();
+
+  @Nullable
+  Bitmap decode(Rect rect, int sample);
+
+  @Override
+  void close();
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageRegionDecoderFactory.java b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageRegionDecoderFactory.java
new file mode 100644
index 000000000..35ac1b667
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageRegionDecoderFactory.java
@@ -0,0 +1,17 @@
+package com.hippo.fresco.large.decoder;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nullable;
+
+import com.facebook.imagepipeline.common.ImageDecodeOptions;
+import com.facebook.imagepipeline.image.EncodedImage;
+
+public interface ImageRegionDecoderFactory {
+
+  @Nullable
+  ImageRegionDecoder createImageRegionDecoder(EncodedImage encodedImage,
+      ImageDecodeOptions options);
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageSizeDecoder.java b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageSizeDecoder.java
new file mode 100644
index 000000000..deccbcec7
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/ImageSizeDecoder.java
@@ -0,0 +1,17 @@
+package com.hippo.fresco.large.decoder;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nullable;
+
+import android.util.Pair;
+
+import com.facebook.imagepipeline.image.EncodedImage;
+
+public interface ImageSizeDecoder {
+
+  @Nullable
+  Pair<Integer, Integer> decode(EncodedImage encodedImage);
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/decoder/SkiaImageRegionDecoder.java b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/SkiaImageRegionDecoder.java
new file mode 100644
index 000000000..4c02bd78d
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/SkiaImageRegionDecoder.java
@@ -0,0 +1,44 @@
+package com.hippo.fresco.large.decoder;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nullable;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Rect;
+
+public class SkiaImageRegionDecoder implements ImageRegionDecoder {
+
+  private BitmapRegionDecoder decoder;
+
+  public SkiaImageRegionDecoder(BitmapRegionDecoder decoder) {
+    this.decoder = decoder;
+  }
+
+  @Override
+  public int getWidth() {
+    return decoder.getWidth();
+  }
+
+  @Override
+  public int getHeight() {
+    return decoder.getHeight();
+  }
+
+  @Nullable
+  @Override
+  public Bitmap decode(Rect rect, int sample) {
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inSampleSize = sample;
+    return decoder.decodeRegion(rect, options);
+  }
+
+  @Override
+  public void close() {
+    decoder.recycle();
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/decoder/SkiaImageRegionDecoderFactory.java b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/SkiaImageRegionDecoderFactory.java
new file mode 100644
index 000000000..a024baf50
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/decoder/SkiaImageRegionDecoderFactory.java
@@ -0,0 +1,36 @@
+package com.hippo.fresco.large.decoder;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nullable;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import android.graphics.BitmapRegionDecoder;
+
+import com.facebook.imagepipeline.common.ImageDecodeOptions;
+import com.facebook.imagepipeline.image.EncodedImage;
+
+public class SkiaImageRegionDecoderFactory implements ImageRegionDecoderFactory {
+
+  @Nullable
+  @Override
+  public ImageRegionDecoder createImageRegionDecoder(EncodedImage encodedImage,
+      ImageDecodeOptions options) {
+    InputStream is = encodedImage.getInputStream();
+    if (is != null) {
+      try {
+        BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(is, false);
+        if (decoder != null) {
+          return new SkiaImageRegionDecoder(decoder);
+        }
+      } catch (IOException e) {
+        // Ignore
+      }
+    }
+    return null;
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/drawable/LargeDrawableFactory.java b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/LargeDrawableFactory.java
new file mode 100644
index 000000000..3be1f23d6
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/LargeDrawableFactory.java
@@ -0,0 +1,30 @@
+package com.hippo.fresco.large.drawable;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nullable;
+
+import android.graphics.drawable.Drawable;
+
+import com.facebook.drawee.backends.pipeline.DrawableFactory;
+import com.facebook.imagepipeline.image.CloseableImage;
+
+import com.hippo.fresco.large.CloseableLargeImage;
+
+public abstract class LargeDrawableFactory implements DrawableFactory {
+
+  @Override
+  public final boolean supportsImageType(CloseableImage image) {
+    return image instanceof CloseableLargeImage;
+  }
+
+  @Nullable
+  @Override
+  public final Drawable createDrawable(CloseableImage image) {
+    return createLargeDrawable((CloseableLargeImage) image);
+  }
+
+  public abstract Drawable createLargeDrawable(CloseableLargeImage image);
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/drawable/SubsamplingDrawable.java b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/SubsamplingDrawable.java
new file mode 100644
index 000000000..2c2e92fbf
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/SubsamplingDrawable.java
@@ -0,0 +1,621 @@
+package com.hippo.fresco.large.drawable;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import javax.annotation.Nonnull;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Executor;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.PointF;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.os.AsyncTask;
+import android.util.Log;
+import android.util.SparseArray;
+
+import com.facebook.common.references.CloseableReference;
+import com.facebook.drawable.base.DrawableWithCaches;
+import com.facebook.drawee.drawable.Scaled;
+import com.facebook.drawee.drawable.ScalingUtils;
+
+import com.hippo.fresco.large.decoder.ImageRegionDecoder;
+
+public class SubsamplingDrawable extends Drawable implements Scaled, DrawableWithCaches {
+
+  private static final boolean DEBUG = false;
+
+  private static final int MAX_TILE_SIZE = 512;
+  private static final int FULL_SIZE = MAX_TILE_SIZE * 2;
+
+  private ImageRegionDecoder decoder;
+  private DecoderReleaser releaser;
+  private Executor executor;
+
+  private final int width;
+  private final int height;
+  private final Paint paint = new Paint(Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG);
+
+  private ScalingUtils.ScaleType scaleType = ScalingUtils.ScaleType.FIT_CENTER;
+  private PointF focusPoint;
+
+  private final Matrix matrix = new Matrix();
+  private final float[] matrixValue = new float[9];
+  private boolean matrixValueDirty = true;
+  private final Matrix invertedMatrix = new Matrix();
+  private boolean invertedMatrixDirty = true;
+  private final Matrix tempMatrix = new Matrix();
+
+  private int windowWidth;
+  private int windowHeight;
+  private int windowOffsetX;
+  private int windowOffsetY;
+
+  // The visible rect of the image
+  private RectF visibleRectF = new RectF();
+  private Rect visibleRect = new Rect();
+
+  // Sample for current rendered image
+  private int currentSample;
+  // Sample for image fill windows
+  private int fullSample;
+  // Whether draw full sample tiles
+  private boolean drawFullSampleTiles;
+  private final SparseArray<List<Tile>> tilesMap = new SparseArray<>();
+
+  // Full sample tiles count
+  private int fullSampleSize;
+  // Decoded full sample tiles count
+  private int fullSampleDecoderSize;
+
+  private float[] debugPoints;
+  private float[] debugLines;
+  private Paint debugPaint;
+
+  public SubsamplingDrawable(CloseableReference<ImageRegionDecoder> decoderReference,
+      Executor executor) {
+    this.decoder = decoderReference.get();
+    this.executor = executor;
+
+    releaser = new DecoderReleaser(decoderReference);
+    releaser.obtain();
+
+    width = decoder.getWidth();
+    height = decoder.getHeight();
+
+    setUpFullTiles();
+
+    if (DEBUG) {
+      debugPoints = new float[8];
+      debugLines = new float[16];
+      debugPaint = new Paint();
+      debugPaint.setStyle(Paint.Style.STROKE);
+      debugPaint.setStrokeWidth(3);
+      debugPaint.setColor(Color.RED);
+    }
+  }
+
+  private void setUpFullTiles() {
+    // Get the sample to fill window
+    int fullSample = calculateSample(width / FULL_SIZE, height / FULL_SIZE);
+    this.fullSample = fullSample;
+
+    // Get the tile list to fill window
+    List<Tile> fullTileList = createTileList(fullSample);
+    tilesMap.put(fullSample, fullTileList);
+
+    fullSampleDecoderSize = 0;
+    fullSampleSize = fullTileList.size();
+
+    // Ensure the fill-window tiles list loaded
+    for (Tile tile : fullTileList) {
+      tile.load();
+    }
+  }
+
+  public void translate(float dx, float dy) {
+    matrix.postTranslate(dx, dy);
+    matrixValueDirty = true;
+    invertedMatrixDirty = true;
+    invalidateSelf();
+  }
+
+  public void scale(float sx, float sy, float px, float py) {
+    matrix.postScale(sx, sy, px, py);
+    matrixValueDirty = true;
+    invertedMatrixDirty = true;
+    invalidateSelf();
+  }
+
+  public void rotate(float degrees, float px, float py) {
+    matrix.postRotate(degrees, px, py);
+    matrixValueDirty = true;
+    invertedMatrixDirty = true;
+    invalidateSelf();
+  }
+
+  @Override
+  public void setScaleType(ScalingUtils.ScaleType scaleType) {
+    this.scaleType = scaleType;
+  }
+
+  @Override
+  public void setFocusPoint(PointF focusPoint) {
+    this.focusPoint = focusPoint;
+  }
+
+  @Override
+  public void applyScaleType() {
+    scaleType.getTransform(
+        matrix,
+        getBounds(),
+        width,
+        height,
+        (focusPoint != null) ? focusPoint.x : 0.5f,
+        (focusPoint != null) ? focusPoint.y : 0.5f);
+    invalidateSelf();
+  }
+
+  @Override
+  protected void onBoundsChange(Rect bounds) {
+    windowWidth = bounds.width();
+    windowHeight = bounds.height();
+    windowOffsetX = bounds.left;
+    windowOffsetY = bounds.top;
+  }
+
+  private static int calculateSample(int scaleX, int scaleY) {
+    return calculateSample(Math.max(scaleX, scaleY));
+  }
+
+  private static int calculateSample(int scale) {
+    int sample = Math.max(1, scale);
+    return prevPow2(sample);
+  }
+
+  private void gc() {
+    for (int i = 0, len = tilesMap.size(); i < len; i++) {
+      final int sample = tilesMap.keyAt(i);
+      final List<Tile> list = tilesMap.valueAt(i);
+      if (list == null) {
+        continue;
+      }
+
+      if (sample == fullSample) {
+        // Always keep it
+      } else if (sample == currentSample) {
+        // Only recycle invisible tiles for current sample
+        for (Tile tile : list) {
+          if (!tile.isVisible()) {
+            tile.recycle();
+          }
+        }
+      } else {
+        // Recycle all tiles for all the other samples
+        for (Tile tile : list) {
+          tile.recycle();
+        }
+      }
+    }
+  }
+
+  // Creates a tile list for the sample, the rect of each tile is filled
+  private List<Tile> createTileList(int sample) {
+    int step = MAX_TILE_SIZE * sample;
+    List<Tile> list = new ArrayList<>(ceilDiv(width, step) * ceilDiv(height, step));
+
+    for (int y = 0; y < height; y += step) {
+      for (int x = 0; x < width; x += step) {
+        int w = Math.min(step, width - x);
+        int h = Math.min(step, height - y);
+        Rect rect = new Rect(x, y, x + w, y + h);
+        Tile tile = new Tile(sample, rect);
+        list.add(tile);
+      }
+    }
+
+    return list;
+  }
+
+  private float[] getMatrixValue() {
+    if (matrixValueDirty) {
+      matrixValueDirty = false;
+      matrix.getValues(matrixValue);
+    }
+    return matrixValue;
+  }
+
+  private Matrix getInvertedMatrix() {
+    if (invertedMatrixDirty) {
+      invertedMatrixDirty = false;
+      matrix.invert(invertedMatrix);
+    }
+    return invertedMatrix;
+  }
+
+  private static int getMatrixScale(float[] matrix) {
+    return (int) Math.round(1 / Math.sqrt(matrix[Matrix.MSCALE_X] * matrix[Matrix.MSCALE_X] +
+        matrix[Matrix.MSKEW_X] * matrix[Matrix.MSKEW_X]));
+  }
+
+  private int getCurrentSample() {
+    float[] matrixValue = getMatrixValue();
+    int scale = getMatrixScale(matrixValue);
+    currentSample = calculateSample(scale);
+    // Current sample can't be bigger than full sample
+    currentSample = Math.min(currentSample, fullSample);
+    return currentSample;
+  }
+
+  private Rect getVisibleRect() {
+    visibleRectF.set(windowOffsetX, windowOffsetY,
+        windowOffsetX + windowWidth, windowOffsetY + windowHeight);
+    Matrix matrix = getInvertedMatrix();
+    matrix.mapRect(visibleRectF);
+
+    visibleRectF.roundOut(visibleRect);
+    if (!visibleRect.intersect(0, 0, width, height)) {
+      visibleRect.setEmpty();
+    }
+    return visibleRect;
+  }
+
+  // Gets the tile which is in full sample and contains this tile
+  private Tile getTheFullSampleTile(Tile tile) {
+    if (tile.sample == fullSample) {
+      return tile;
+    }
+
+    for (Tile fullSampleTile : tilesMap.get(fullSample)) {
+      if (fullSampleTile.contains(tile)) {
+        return fullSampleTile;
+      }
+    }
+
+    throw new RuntimeException("getTheFullSampleTile() should always returns a tile.");
+  }
+
+  private void drawTiles(Canvas canvas) {
+    // Get current sample
+    int currentSample = getCurrentSample();
+
+    // Get tile list for current sample
+    List<Tile> currentTileList = tilesMap.get(currentSample);
+    if (currentTileList == null) {
+      currentTileList = createTileList(currentSample);
+      tilesMap.put(currentSample, currentTileList);
+    }
+
+    // Get visible rect in the image
+    Rect visibleRect = getVisibleRect();
+
+    if (currentSample == fullSample) {
+      // Current sample is full sample
+      // No need to use the full sample tile to fill unloaded current sample tile
+      drawFullSampleTiles = false;
+
+      for (Tile tile : currentTileList) {
+        if (tile.updateVisibility(visibleRect)) {
+          tile.load();
+          tile.draw(canvas, paint, matrix, tempMatrix);
+        }
+      }
+    } else {
+      // Current sample is not full sample
+      // Use the full sample tile to fill unloaded current sample tile
+      drawFullSampleTiles = true;
+
+      // Reset visibility of all tiles in full sample tiles
+      List<Tile> fullTileList = tilesMap.get(fullSample);
+      for (Tile tile : fullTileList) {
+        tile.setVisibility(false);
+      }
+
+      for (Tile tile : currentTileList) {
+        if (tile.updateVisibility(visibleRect) && !tile.isLoaded()) {
+          tile.load();
+          // The tile doesn't have a bitmap, try to draw a bitmap in full sample tile
+          Tile fullSampleTile = getTheFullSampleTile(tile);
+          // Use the visible to mark drew tile to avoid draw it twice
+          if (!fullSampleTile.isVisible()) {
+            fullSampleTile.setVisibility(true);
+            fullSampleTile.draw(canvas, paint, matrix, tempMatrix);
+          }
+        }
+      }
+
+      for (Tile tile : currentTileList) {
+        if (tile.isVisible()) {
+          tile.draw(canvas, paint, matrix, tempMatrix);
+        }
+      }
+    }
+
+    gc();
+  }
+
+  @Override
+  public void draw(@Nonnull Canvas canvas) {
+    if (windowWidth > 0 && windowHeight > 0 && fullSampleSize == fullSampleDecoderSize) {
+      drawTiles(canvas);
+    }
+  }
+
+  @Override
+  public int getIntrinsicWidth() {
+    return width;
+  }
+
+  @Override
+  public int getIntrinsicHeight() {
+    return height;
+  }
+
+  @Override
+  public void setAlpha(int alpha) {
+    paint.setAlpha(alpha);
+  }
+
+  @Override
+  public void setColorFilter(ColorFilter colorFilter) {
+    paint.setColorFilter(colorFilter);
+  }
+
+  @Override
+  public int getOpacity() {
+    // Always return PixelFormat.TRANSLUCENT
+    return PixelFormat.TRANSLUCENT;
+  }
+
+  @Override
+  public void dropCaches() {
+    close();
+  }
+
+  public void close() {
+    releaser.release();
+
+    for (int i = 0, len = tilesMap.size(); i < len; i++) {
+      final List<Tile> list = tilesMap.valueAt(i);
+      if (list == null) {
+        continue;
+      }
+
+      // Close all tiles
+      for (Tile tile : list) {
+        tile.close();
+      }
+    }
+  }
+
+  private static class DecoderReleaser {
+
+    private CloseableReference<ImageRegionDecoder> decoderReference;
+    private int reference;
+
+    private DecoderReleaser(CloseableReference<ImageRegionDecoder> decoderReference) {
+      this.decoderReference = decoderReference;
+    }
+
+    private void obtain() {
+      ++reference;
+    }
+
+    private void release() {
+      if (--reference == 0) {
+        decoderReference.close();
+      }
+    }
+  }
+
+  private class Tile {
+    public int sample;
+    public Rect rect;
+    public Bitmap bitmap;
+    // The task to decode image
+    private LoadingTask task;
+    //
+    private boolean visible;
+    // True if can't decode the source
+    // Check this flag to avoid infinity loading
+    private boolean failed;
+
+    public Tile(int sample, Rect rect) {
+      this.sample = sample;
+      this.rect = rect;
+
+      releaser.obtain();
+    }
+
+    /**
+     * Returns {@code true} if the rect contain that rect.
+     */
+    public boolean contains(Tile tile) {
+      return rect.contains(tile.rect);
+    }
+
+    /**
+     * Update the visibility according to the visible rect in the image.
+     * Returns {@code true} if it's visible.
+     */
+    public boolean updateVisibility(Rect visibleRect) {
+      visible = Rect.intersects(visibleRect, rect);
+      return visible;
+    }
+
+    /**
+     * Set the visibility.
+     */
+    public boolean setVisibility(boolean visible) {
+      this.visible = visible;
+      return visible;
+    }
+
+    /**
+     * Returns {@code true} if it's visible.
+     */
+    public boolean isVisible() {
+      return visible;
+    }
+
+    /**
+     * Starts a task to decode the image.
+     */
+    public void load() {
+      if (bitmap == null && task == null && !failed && releaser != null) {
+        task = new LoadingTask();
+        task.executeOnExecutor(executor);
+      }
+    }
+
+    /**
+     * Returns {@code true} if the tile has a bitmap.
+     */
+    public boolean isLoaded() {
+      return bitmap != null;
+    }
+
+    /**
+     * Draws the tile.
+     */
+    public void draw(Canvas canvas, Paint paint, Matrix matrix, Matrix temp) {
+      if (bitmap != null) {
+        temp.set(matrix);
+        temp.preTranslate(rect.left, rect.top);
+        temp.preScale(sample, sample);
+        canvas.drawBitmap(bitmap, temp, paint);
+
+        if (DEBUG) {
+          debugPoints[0] = rect.left;
+          debugPoints[1] = rect.top;
+          debugPoints[2] = rect.right;
+          debugPoints[3] = rect.top;
+          debugPoints[4] = rect.right;
+          debugPoints[5] = rect.bottom;
+          debugPoints[6] = rect.left;
+          debugPoints[7] = rect.bottom;
+
+          matrix.mapPoints(debugPoints);
+
+          debugLines[0] = debugPoints[0];
+          debugLines[1] = debugPoints[1];
+          debugLines[2] = debugPoints[2];
+          debugLines[3] = debugPoints[3];
+
+          debugLines[4] = debugPoints[2];
+          debugLines[5] = debugPoints[3];
+          debugLines[6] = debugPoints[4];
+          debugLines[7] = debugPoints[5];
+
+          debugLines[8] = debugPoints[4];
+          debugLines[9] = debugPoints[5];
+          debugLines[10] = debugPoints[6];
+          debugLines[11] = debugPoints[7];
+
+          debugLines[12] = debugPoints[6];
+          debugLines[13] = debugPoints[7];
+          debugLines[14] = debugPoints[0];
+          debugLines[15] = debugPoints[1];
+
+          canvas.drawLines(debugLines, debugPaint);
+        }
+      }
+    }
+
+    /**
+     * Cancels loading task, recycles the bitmap.
+     */
+    public void recycle() {
+      if (task != null) {
+        task.cancel(false);
+        task = null;
+      }
+      if (bitmap != null) {
+        bitmap.recycle();
+        bitmap = null;
+      }
+    }
+
+    /**
+     * Calls {@link #recycle()}. {@link #load()} will not work anymore.
+     */
+    public void close() {
+      recycle();
+      releaser.release();
+    }
+
+    private void onLoaded(Bitmap bitmap) {
+      this.bitmap = bitmap;
+      this.task = null;
+      this.failed = bitmap == null;
+
+      if (sample == fullSample) {
+        ++fullSampleDecoderSize;
+        if (fullSampleSize == fullSampleDecoderSize) {
+          // All full sample tiles is loaded
+          invalidateSelf();
+        }
+      }
+
+      if (bitmap != null && visible &&
+          (sample == currentSample || (sample == fullSample && drawFullSampleTiles))) {
+        invalidateSelf();
+      }
+    }
+
+    private class LoadingTask extends AsyncTask<Void, Void, Bitmap> {
+      @Override
+      protected void onPreExecute() {
+        releaser.obtain();
+      }
+
+      @Override
+      protected Bitmap doInBackground(Void... params) {
+        if (!isCancelled()) {
+          return decoder.decode(rect, sample);
+        } else {
+          return null;
+        }
+      }
+
+      @Override
+      protected void onPostExecute(Bitmap bitmap) {
+        releaser.release();
+        onLoaded(bitmap);
+      }
+
+      @Override
+      protected void onCancelled(Bitmap bitmap) {
+        releaser.release();
+        // The cleanup task is done in recycle(), just recycle the bitmap
+        if (bitmap != null) {
+          bitmap.recycle();
+        }
+      }
+    }
+  }
+
+  private static int ceilDiv(int a, int b) {
+    return (a + b - 1) / b;
+  }
+
+  private static int prevPow2(int n) {
+    n |= n >> 1;
+    n |= n >> 2;
+    n |= n >> 4;
+    n |= n >> 8;
+    n |= n >> 16;
+    return n - (n >> 1);
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/drawable/SubsamplingDrawableFactory.java b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/SubsamplingDrawableFactory.java
new file mode 100644
index 000000000..b3a774a76
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/SubsamplingDrawableFactory.java
@@ -0,0 +1,20 @@
+package com.hippo.fresco.large.drawable;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import android.graphics.drawable.Drawable;
+
+import com.facebook.drawee.backends.pipeline.Fresco;
+
+import com.hippo.fresco.large.CloseableLargeImage;
+
+public class SubsamplingDrawableFactory extends LargeDrawableFactory {
+
+  @Override
+  public Drawable createLargeDrawable(CloseableLargeImage image) {
+    return new SubsamplingDrawable(image.getDecoder(),
+        Fresco.getImagePipelineFactory().getConfig().getExecutorSupplier().forDecode());
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/gesture/GestureRecognizer.java b/fresco-large/src/main/java/com/hippo/fresco/large/gesture/GestureRecognizer.java
new file mode 100644
index 000000000..a8c795313
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/gesture/GestureRecognizer.java
@@ -0,0 +1,268 @@
+/*
+ * Copyright 2017 Hippo Seven
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.hippo.fresco.large.gesture;
+
+/*
+ * Created by Hippo on 5/26/2017.
+ */
+
+import android.content.Context;
+import android.view.GestureDetector;
+import android.view.MotionEvent;
+import android.view.ScaleGestureDetector;
+
+public class GestureRecognizer implements GestureDetector.OnGestureListener,
+    GestureDetector.OnDoubleTapListener,
+    ScaleGestureDetector.OnScaleGestureListener,
+    RotationGestureDetector.OnRotateGestureListener {
+
+  private static final float SCALE_SLOP = 0.015f;
+  private static final float ROTATE_SLOP = 0.5f;
+
+  private Listener listener;
+
+  private GestureDetector gestureDetector;
+  private ScaleGestureDetector scaleGestureDetector;
+  private RotationGestureDetector rotationGestureDetector;
+
+  private boolean isDoubleTapEnabled = true;
+  private boolean isLongPressEnabled = true;
+  private boolean isScaleEnabled = true;
+  private boolean isRotateEnabled = true;
+
+  private boolean isScaling;
+  private boolean isRotating;
+
+  private float scaling;
+  private float rotating;
+
+  public GestureRecognizer(Context context, Listener listener) {
+    this.listener = listener;
+
+    gestureDetector = new GestureDetector(context, this);
+    scaleGestureDetector = new ScaleGestureDetector(context, this);
+    rotationGestureDetector = new RotationGestureDetector(this);
+  }
+
+  public void setIsDoubleTapEnabled(boolean isDoubleTapEnabled) {
+    if (this.isDoubleTapEnabled != isDoubleTapEnabled) {
+      this.isDoubleTapEnabled = isDoubleTapEnabled;
+      if (isDoubleTapEnabled) {
+        gestureDetector.setOnDoubleTapListener(this);
+      } else {
+        gestureDetector.setOnDoubleTapListener(null);
+      }
+    }
+  }
+
+  public boolean isDoubleTapEnabled() {
+    return isDoubleTapEnabled;
+  }
+
+  public void setIsLongPressEnabled(boolean isLongPressEnabled) {
+    if (this.isLongPressEnabled != isLongPressEnabled) {
+      this.isLongPressEnabled = isLongPressEnabled;
+      gestureDetector.setIsLongpressEnabled(isLongPressEnabled);
+    }
+  }
+
+  public boolean isLongPressEnabled() {
+    return isLongPressEnabled;
+  }
+
+  public void setIsScaleEnabled(boolean isScaleEnabled) {
+    this.isScaleEnabled = isScaleEnabled;
+  }
+
+  public boolean isScaleEnabled() {
+    return isScaleEnabled;
+  }
+
+  public void setIsRotateEnabled(boolean isRotateEnabled) {
+    this.isRotateEnabled = isRotateEnabled;
+  }
+
+  public boolean isRotateEnabled() {
+    return isRotateEnabled;
+  }
+
+  public boolean onTouchEvent(MotionEvent event) {
+    gestureDetector.onTouchEvent(event);
+    scaleGestureDetector.onTouchEvent(event);
+    rotationGestureDetector.onTouchEvent(event);
+    return true;
+  }
+
+  @Override
+  public boolean onDown(MotionEvent e) {
+    return true;
+  }
+
+  @Override
+  public void onShowPress(MotionEvent e) {}
+
+  @Override
+  public boolean onSingleTapUp(MotionEvent e) {
+    if (!isDoubleTapEnabled) {
+      listener.onSingleTap(e.getX(), e.getY());
+    }
+    return true;
+  }
+
+  @Override
+  public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
+    if (!isScaling && !isRotating) {
+      listener.onScroll(-distanceX, -distanceY,
+          e2.getX() - e1.getX(), e2.getY() - e1.getY(),
+          e2.getX(), e2.getY());
+    }
+    return true;
+  }
+
+  @Override
+  public void onLongPress(MotionEvent e) {
+    listener.onLongPress(e.getX(), e.getY());
+  }
+
+  @Override
+  public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
+    listener.onFling(velocityX, velocityY);
+    return true;
+  }
+
+  @Override
+  public boolean onSingleTapConfirmed(MotionEvent e) {
+    if (isDoubleTapEnabled) {
+      listener.onSingleTap(e.getX(), e.getY());
+    }
+    return true;
+  }
+
+  @Override
+  public boolean onDoubleTap(MotionEvent e) {
+    listener.onDoubleTap(e.getX(), e.getY());
+    return true;
+  }
+
+  @Override
+  public boolean onDoubleTapEvent(MotionEvent e) {
+    return true;
+  }
+
+  ///////////////////////////////////////////////////////////////////////////
+  // Scale
+  ///////////////////////////////////////////////////////////////////////////
+
+  @Override
+  public boolean onScale(ScaleGestureDetector detector) {
+    scaling = detector.getScaleFactor();
+    if (scaling < 1.0f) {
+      scaling = 1.0f / scaling;
+    }
+    scaling -= 1.0f;
+
+    if (isRotating) {
+      if (rotating < ROTATE_SLOP && scaling > SCALE_SLOP) {
+        // Switch from rotating to scaling
+        isRotating = false;
+        isScaling = true;
+      }
+    } else if (!isScaling) {
+      isScaling = true;
+    }
+
+    if (isScaling) {
+      listener.onScale(detector.getScaleFactor(), detector.getFocusX(), detector.getFocusY());
+    }
+
+    return true;
+  }
+
+  @Override
+  public boolean onScaleBegin(ScaleGestureDetector detector) {
+    if (isScaleEnabled) {
+      if (!isRotating) {
+        isScaling = true;
+      }
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public void onScaleEnd(ScaleGestureDetector detector) {
+    isScaling = false;
+  }
+
+  ///////////////////////////////////////////////////////////////////////////
+  // Rotation
+  ///////////////////////////////////////////////////////////////////////////
+
+  @Override
+  public void onRotate(float angle, float x, float y) {
+    rotating = Math.abs(angle);
+
+    if (isScaling) {
+      if (scaling < SCALE_SLOP && rotating > ROTATE_SLOP) {
+        // Switch from scaling to rotating
+        isScaling = false;
+        isRotating = true;
+      }
+    } else if (!isRotating) {
+      isRotating = true;
+    }
+
+    if (isRotating) {
+      listener.onRotate(angle, x, y);
+    }
+  }
+
+  @Override
+  public boolean onRotateBegin() {
+    if (isRotateEnabled) {
+      if (!isScaling) {
+        isRotating = true;
+      }
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public void onRotateEnd() {
+    isRotating = false;
+  }
+
+  public interface Listener {
+
+    void onSingleTap(float x, float y);
+
+    void onDoubleTap(float x, float y);
+
+    void onLongPress(float x, float y);
+
+    void onScroll(float dx, float dy, float totalX, float totalY, float x, float y);
+
+    void onFling(float velocityX, float velocityY);
+
+    void onScale(float factor, float x, float y);
+
+    void onRotate(float angle, float x, float y);
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/gesture/RotationGestureDetector.java b/fresco-large/src/main/java/com/hippo/fresco/large/gesture/RotationGestureDetector.java
new file mode 100644
index 000000000..7fafb890b
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/gesture/RotationGestureDetector.java
@@ -0,0 +1,257 @@
+/*
+ * Copyright 2017 Hippo Seven
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.hippo.fresco.large.gesture;
+
+/*
+ * Created by Hippo on 5/26/2017.
+ */
+
+import android.view.MotionEvent;
+
+/**
+ * Detects rotating transformation gestures using the supplied {@link MotionEvent}s.
+ * The {@link OnRotateGestureListener} callback will notify users when a particular
+ * gesture event has occurred.
+ *
+ * This class should only be used with {@link MotionEvent}s reported via touch.
+ *
+ * To use this class:
+ * <ul>
+ *  <li>Create an instance of the {@code RotationGestureDetector} for your
+ *      {@link android.view.View View}
+ *  <li>In the {@link android.view.View#onTouchEvent(MotionEvent) View#onTouchEvent(MotionEvent)}
+ *      method ensure you call {@link #onTouchEvent(MotionEvent)}. The methods defined in your
+ *      callback will be executed when the events occur.
+ * </ul>
+ */
+public class RotationGestureDetector {
+
+  private static final int INVALID_POINTER_ID = -1;
+
+  private static final float ROTATION_SLOP = 2.0f;
+
+  private int id1 = INVALID_POINTER_ID;
+  private int id2 = INVALID_POINTER_ID;
+  private boolean forceBlock;
+  private boolean rotated;
+  private float lastX1, lastY1;
+  private float lastX2, lastY2;
+  private float lastAngle = Float.NaN;
+
+  private final OnRotateGestureListener listener;
+
+  public RotationGestureDetector(OnRotateGestureListener listener) {
+    this.listener = listener;
+  }
+
+  /**
+   * Accepts MotionEvents and dispatches events to a {@link OnRotateGestureListener}
+   * when appropriate.
+   *
+   * <p>Applications should pass a complete and consistent event stream to this method.
+   * A complete and consistent event stream involves all MotionEvents from the initial
+   * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
+   *
+   * @param event The event to process
+   * @return true if the event was processed and the detector wants to receive the
+   *         rest of the MotionEvents in this event stream.
+   */
+  public boolean onTouchEvent(MotionEvent event) {
+    switch (event.getActionMasked()) {
+      case MotionEvent.ACTION_DOWN: {
+        id1 = event.getPointerId(event.getActionIndex());
+        id2 = INVALID_POINTER_ID;
+        lastAngle = Float.NaN;
+        rotated = false;
+        forceBlock = false;
+        break;
+      }
+      case MotionEvent.ACTION_POINTER_DOWN: {
+        int id = event.getPointerId(event.getActionIndex());
+        if (id1 == INVALID_POINTER_ID) {
+          id1 = id;
+        } else if (id2 == INVALID_POINTER_ID) {
+          id2 = id;
+        } else {
+          // Another pointer, ignore
+          break;
+        }
+
+        if (id1 == INVALID_POINTER_ID || id2 == INVALID_POINTER_ID) {
+          // Two pointer has not been caught
+          break;
+        }
+
+        lastX1 = event.getX(event.findPointerIndex(id1));
+        lastY1 = event.getY(event.findPointerIndex(id1));
+        lastX2 = event.getX(event.findPointerIndex(id2));
+        lastY2 = event.getY(event.findPointerIndex(id2));
+        lastAngle = Float.NaN;
+        rotated = false;
+        break;
+      }
+      case MotionEvent.ACTION_MOVE: {
+        if (forceBlock) {
+          // listener.onRotateBegin() returns false
+          break;
+        }
+        if (id1 == INVALID_POINTER_ID || id2 == INVALID_POINTER_ID) {
+          // Two pointer has not been caught
+          break;
+        }
+        int id = event.getPointerId(event.getActionIndex());
+        if (id != id1 && id != id2) {
+          // The pointer isn't one of the two pointers
+          break;
+        }
+
+        // Get last angle
+        if (Float.isNaN(lastAngle)) {
+          lastAngle = (float) Math.atan2(lastY1 - lastY2, lastX1 - lastX2);
+        }
+
+        // Get current angle
+        float x1 = event.getX(event.findPointerIndex(id1));
+        float y1 = event.getY(event.findPointerIndex(id1));
+        float x2 = event.getX(event.findPointerIndex(id2));
+        float y2 = event.getY(event.findPointerIndex(id2));
+        float angle = (float) Math.atan2(y1 - y2, x1 - x2);
+
+        // Get rotation angle
+        float rotation = ((float) Math.toDegrees(lastAngle - angle)) % 360.0f;
+        if (rotation < -180.f) {
+          rotation += 360.0f;
+        }
+        if (rotation > 180.f) {
+          rotation -= 360.0f;
+        }
+
+        // Check whether rotated
+        boolean beginRotating = false;
+        if (!rotated) {
+          rotated = (Math.abs(rotation) > ROTATION_SLOP) &&
+              !(forceBlock = !listener.onRotateBegin());
+          if (rotated) {
+            beginRotating = true;
+          } else {
+            break;
+          }
+        }
+
+        if (!beginRotating) {
+          // Get intersection of two lines
+          float denominator = (lastX1 - lastX2) * (y1 - y2) - (lastY1 - lastY2) * (x1 - x2);
+          if (denominator == 0.0f) {
+            // Two lines are parallel or coincident
+            break;
+          }
+          float x = ((lastX1 * lastY2 - lastY1 * lastX2) * (x1 - x2) - (lastX1 - lastX2) * (
+              x1 * y2 - y1 * x2)) / denominator;
+          float y = ((lastX1 * lastY2 - lastY1 * lastX2) * (y1 - y2) - (lastY1 - lastY2) * (
+              x1 * y2 - y1 * x2)) / denominator;
+
+          // Callback
+          listener.onRotate(-rotation, x, y);
+        }
+
+        // Update lastX, lastY, lastAngle
+        lastX1 = x1;
+        lastY1 = y1;
+        lastX2 = x2;
+        lastY2 = y2;
+        lastAngle = angle;
+        break;
+      }
+      case MotionEvent.ACTION_POINTER_UP: {
+        int id = event.getPointerId(event.getActionIndex());
+        if (id1 == id) {
+          if (rotated) {
+            // Callback
+            listener.onRotateEnd();
+          }
+
+          id1 = INVALID_POINTER_ID;
+          lastAngle = Float.NaN;
+          rotated = false;
+        } else if (id2 == id) {
+          if (rotated) {
+            // Callback
+            listener.onRotateEnd();
+          }
+
+          id2 = INVALID_POINTER_ID;
+          lastAngle = Float.NaN;
+          rotated = false;
+        }
+        break;
+      }
+      case MotionEvent.ACTION_UP:
+      case MotionEvent.ACTION_CANCEL: {
+        if (rotated) {
+          // Callback
+          listener.onRotateEnd();
+        }
+
+        id1 = INVALID_POINTER_ID;
+        id2 = INVALID_POINTER_ID;
+        lastAngle = Float.NaN;
+        rotated = false;
+        forceBlock = false;
+        break;
+      }
+    }
+
+    return rotated;
+  }
+
+  /**
+   * The listener for receiving notifications when gestures occur.
+   * If you want to listen for all the different gestures then implement
+   * this interface.
+   *
+   * An application will receive events in the following order:
+   * <ul>
+   *  <li>One {@link OnRotateGestureListener#onRotateBegin()}
+   *  <li>Zero or more {@link OnRotateGestureListener#onRotate(float, float, float)}
+   *  <li>One {@link OnRotateGestureListener#onRotateEnd()}
+   * </ul>
+   */
+  public interface OnRotateGestureListener {
+
+    /**
+     * Responds to rotating events for a gesture in progress.
+     *
+     * @param angle the rotating angle, clockwise
+     * @param x x of the anchor point
+     * @param y y of the anchor point
+     */
+    void onRotate(float angle, float x, float y);
+
+    /**
+     * Responds to the beginning of a rotating gesture.
+     *
+     * @return Whether or not the detector should continue recognizing
+     *         this gesture.
+     */
+    boolean onRotateBegin();
+
+    /**
+     * Responds to the end of a rotating gesture.
+     */
+    void onRotateEnd();
+  }
+}
diff --git a/fresco-large/src/test/java/com/hippo/fresco/large/ExampleUnitTest.java b/fresco-large/src/test/java/com/hippo/fresco/large/ExampleUnitTest.java
new file mode 100644
index 000000000..ce8a3235e
--- /dev/null
+++ b/fresco-large/src/test/java/com/hippo/fresco/large/ExampleUnitTest.java
@@ -0,0 +1,18 @@
+package com.hippo.fresco.large;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+
+  @Test
+  public void addition_isCorrect() throws Exception {
+    assertEquals(4, 2 + 2);
+  }
+}
\ No newline at end of file
diff --git a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
index c3e3361bb..b3aeb8eaa 100644
--- a/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
+++ b/imagepipeline/src/main/java/com/facebook/imagepipeline/core/ImagePipelineFactory.java
@@ -125,6 +125,10 @@ public ImagePipelineFactory(ImagePipelineConfig config) {
         config.getExecutorSupplier().forLightweightBackgroundTasks());
   }
 
+  public ImagePipelineConfig getConfig() {
+    return mConfig;
+  }
+
   public AnimatedFactory getAnimatedFactory() {
     if (mAnimatedFactory == null) {
       mAnimatedFactory = AnimatedFactoryProvider.getAnimatedFactory(
@@ -178,7 +182,7 @@ public AnimatedFactory getAnimatedFactory() {
     return mEncodedMemoryCache;
   }
 
-  private ImageDecoder getImageDecoder() {
+  public ImageDecoder getImageDecoder() {
     if (mImageDecoder == null) {
       if (mConfig.getImageDecoder() != null) {
         mImageDecoder = mConfig.getImageDecoder();
diff --git a/samples/large/.gitignore b/samples/large/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/samples/large/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/samples/large/build.gradle b/samples/large/build.gradle
new file mode 100644
index 000000000..5b8ce93c5
--- /dev/null
+++ b/samples/large/build.gradle
@@ -0,0 +1,23 @@
+apply plugin: 'com.android.application'
+
+android {
+    buildToolsVersion rootProject.ext.buildToolsVersion
+    compileSdkVersion rootProject.ext.compileSdkVersion
+
+    defaultConfig {
+        applicationId "com.hippo.fresco.large.demo"
+        minSdkVersion 11
+        targetSdkVersion rootProject.ext.targetSdkVersion
+        versionCode 1
+        versionName "${VERSION_NAME}"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+}
+
+dependencies {
+    compile 'com.android.support:appcompat-v7:25.3.1'
+    compile project(':fresco-large')
+
+    testCompile 'junit:junit:4.12'
+}
diff --git a/samples/large/src/main/AndroidManifest.xml b/samples/large/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..f6d975363
--- /dev/null
+++ b/samples/large/src/main/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.hippo.fresco.large.demo">
+
+  <application
+      android:name=".DemoApp"
+      android:allowBackup="true"
+      android:icon="@mipmap/ic_launcher"
+      android:label="@string/app_name"
+      android:roundIcon="@mipmap/ic_launcher_round"
+      android:supportsRtl="true"
+      android:theme="@style/AppTheme">
+    <activity android:name=".MainActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN" />
+
+        <category android:name="android.intent.category.LAUNCHER" />
+      </intent-filter>
+    </activity>
+  </application>
+
+</manifest>
\ No newline at end of file
diff --git a/samples/large/src/main/java/com/hippo/fresco/large/demo/DemoApp.java b/samples/large/src/main/java/com/hippo/fresco/large/demo/DemoApp.java
new file mode 100644
index 000000000..86bad5f42
--- /dev/null
+++ b/samples/large/src/main/java/com/hippo/fresco/large/demo/DemoApp.java
@@ -0,0 +1,43 @@
+package com.hippo.fresco.large.demo;
+
+/*
+ * Created by Hippo on 5/30/2017.
+ */
+
+import android.app.Application;
+
+import com.facebook.drawee.backends.pipeline.DraweeConfig;
+import com.facebook.drawee.backends.pipeline.Fresco;
+import com.facebook.imageformat.DefaultImageFormats;
+import com.facebook.imagepipeline.core.ImagePipelineConfig;
+import com.facebook.imagepipeline.decoder.ImageDecoderConfig;
+
+import com.hippo.fresco.large.FrescoLarge;
+import com.hippo.fresco.large.FrescoLargeConfig;
+import com.hippo.fresco.large.decoder.ImageRegionDecoderFactory;
+import com.hippo.fresco.large.decoder.SkiaImageRegionDecoderFactory;
+
+public class DemoApp extends Application {
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+
+    FrescoLargeConfig.Builder builder = FrescoLargeConfig.newBuilder();
+    builder.setThresholdSize(1024, 1024);
+    ImageRegionDecoderFactory decoderFactory = new SkiaImageRegionDecoderFactory();
+    builder.addDecoder(DefaultImageFormats.JPEG, decoderFactory);
+    builder.addDecoder(DefaultImageFormats.PNG, decoderFactory);
+
+    ImageDecoderConfig.Builder decoderConfigBuilder = ImageDecoderConfig.newBuilder();
+    DraweeConfig.Builder draweeConfigBuilder = DraweeConfig.newBuilder();
+    FrescoLarge.config(decoderConfigBuilder, draweeConfigBuilder, builder.build());
+
+    ImagePipelineConfig imagePipelineConfig = ImagePipelineConfig
+        .newBuilder(this)
+        .setImageDecoderConfig(decoderConfigBuilder.build())
+        .build();
+
+    Fresco.initialize(this, imagePipelineConfig, draweeConfigBuilder.build());
+  }
+}
diff --git a/samples/large/src/main/java/com/hippo/fresco/large/demo/MainActivity.java b/samples/large/src/main/java/com/hippo/fresco/large/demo/MainActivity.java
new file mode 100644
index 000000000..a5df9562d
--- /dev/null
+++ b/samples/large/src/main/java/com/hippo/fresco/large/demo/MainActivity.java
@@ -0,0 +1,18 @@
+package com.hippo.fresco.large.demo;
+
+import android.support.v7.app.AppCompatActivity;
+import android.os.Bundle;
+
+import com.facebook.drawee.view.SimpleDraweeView;
+
+public class MainActivity extends AppCompatActivity {
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+
+    SimpleDraweeView image = (SimpleDraweeView) findViewById(R.id.image);
+    image.setImageURI("res:///" + R.raw.jpeg_large);
+  }
+}
diff --git a/samples/large/src/main/res/layout/activity_main.xml b/samples/large/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..5f4ce6d8b
--- /dev/null
+++ b/samples/large/src/main/res/layout/activity_main.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<com.hippo.fresco.large.LargeDraweeView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/image"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+</com.hippo.fresco.large.LargeDraweeView>
diff --git a/samples/large/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/large/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..cde69bccc
Binary files /dev/null and b/samples/large/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/large/src/main/res/mipmap-hdpi/ic_launcher_round.png b/samples/large/src/main/res/mipmap-hdpi/ic_launcher_round.png
new file mode 100644
index 000000000..9a078e3e1
Binary files /dev/null and b/samples/large/src/main/res/mipmap-hdpi/ic_launcher_round.png differ
diff --git a/samples/large/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/large/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..c133a0cbd
Binary files /dev/null and b/samples/large/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/large/src/main/res/mipmap-mdpi/ic_launcher_round.png b/samples/large/src/main/res/mipmap-mdpi/ic_launcher_round.png
new file mode 100644
index 000000000..efc028a63
Binary files /dev/null and b/samples/large/src/main/res/mipmap-mdpi/ic_launcher_round.png differ
diff --git a/samples/large/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/large/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..bfa42f0e7
Binary files /dev/null and b/samples/large/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/large/src/main/res/mipmap-xhdpi/ic_launcher_round.png b/samples/large/src/main/res/mipmap-xhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..3af2608a4
Binary files /dev/null and b/samples/large/src/main/res/mipmap-xhdpi/ic_launcher_round.png differ
diff --git a/samples/large/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/large/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..324e72cdd
Binary files /dev/null and b/samples/large/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/large/src/main/res/mipmap-xxhdpi/ic_launcher_round.png b/samples/large/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..9bec2e623
Binary files /dev/null and b/samples/large/src/main/res/mipmap-xxhdpi/ic_launcher_round.png differ
diff --git a/samples/large/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/samples/large/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 000000000..aee44e138
Binary files /dev/null and b/samples/large/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/samples/large/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png b/samples/large/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..34947cd6b
Binary files /dev/null and b/samples/large/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png differ
diff --git a/samples/large/src/main/res/raw/jpeg_large.jpg b/samples/large/src/main/res/raw/jpeg_large.jpg
new file mode 100644
index 000000000..bb0bf4079
Binary files /dev/null and b/samples/large/src/main/res/raw/jpeg_large.jpg differ
diff --git a/samples/large/src/main/res/values/colors.xml b/samples/large/src/main/res/values/colors.xml
new file mode 100644
index 000000000..5a077b3a7
--- /dev/null
+++ b/samples/large/src/main/res/values/colors.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <color name="colorPrimary">#3F51B5</color>
+  <color name="colorPrimaryDark">#303F9F</color>
+  <color name="colorAccent">#FF4081</color>
+</resources>
diff --git a/samples/large/src/main/res/values/strings.xml b/samples/large/src/main/res/values/strings.xml
new file mode 100644
index 000000000..6a5195c8f
--- /dev/null
+++ b/samples/large/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+  <string name="app_name">Large Demo</string>
+</resources>
diff --git a/samples/large/src/main/res/values/styles.xml b/samples/large/src/main/res/values/styles.xml
new file mode 100644
index 000000000..ec45c627c
--- /dev/null
+++ b/samples/large/src/main/res/values/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+  <!-- Base application theme. -->
+  <style name="AppTheme" parent="Theme.AppCompat.Light">
+    <!-- Customize your theme here. -->
+    <item name="colorPrimary">@color/colorPrimary</item>
+    <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+    <item name="colorAccent">@color/colorAccent</item>
+  </style>
+
+</resources>
diff --git a/samples/large/src/test/java/com/hippo/fresco/large/demo/ExampleUnitTest.java b/samples/large/src/test/java/com/hippo/fresco/large/demo/ExampleUnitTest.java
new file mode 100644
index 000000000..2e7c1b646
--- /dev/null
+++ b/samples/large/src/test/java/com/hippo/fresco/large/demo/ExampleUnitTest.java
@@ -0,0 +1,18 @@
+package com.hippo.fresco.large.demo;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+
+  @Test
+  public void addition_isCorrect() throws Exception {
+    assertEquals(4, 2 + 2);
+  }
+}
\ No newline at end of file
diff --git a/settings.gradle b/settings.gradle
index b7cfd2859..76bd7efe4 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -3,6 +3,7 @@ include ':drawee-backends:drawee-pipeline'
 include ':drawee-backends:drawee-volley'
 include ':drawee-span'
 include ':fbcore'
+include ':fresco-large'
 include ':imagepipeline'
 include ':samples:animation'
 include ':samples:animation2'
@@ -31,3 +32,4 @@ include ':animated-webp'
 include ':animated-gif'
 include ':samples:scrollperf'
 include ':samples:showcase'
+include ':samples:large'
