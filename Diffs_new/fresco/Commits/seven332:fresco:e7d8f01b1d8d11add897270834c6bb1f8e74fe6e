diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/LargeDrawableFactory.java b/fresco-large/src/main/java/com/hippo/fresco/large/LargeDrawableFactory.java
index 3f321cf41..4b1c48f67 100644
--- a/fresco-large/src/main/java/com/hippo/fresco/large/LargeDrawableFactory.java
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/LargeDrawableFactory.java
@@ -92,7 +92,7 @@ public final Drawable createDrawable(CloseableImage image) {
     }
 
     if (drawable instanceof Transformed) {
-      drawable = new StandardizedTransformedDrawable(drawable);
+      drawable = new StandardizedTransformedDrawable(context, drawable);
     }
 
     return drawable;
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/LargeDraweeView.java b/fresco-large/src/main/java/com/hippo/fresco/large/LargeDraweeView.java
index b1cbe74f0..5a73315ff 100644
--- a/fresco-large/src/main/java/com/hippo/fresco/large/LargeDraweeView.java
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/LargeDraweeView.java
@@ -72,7 +72,7 @@ public LargeDraweeView(Context context, AttributeSet attrs, int defStyleAttr, in
 
   private void init(Context context) {
     gestureRecognizer = new GestureRecognizer(context, this);
-    gestureRecognizer.setIsDoubleTapEnabled(false);
+    gestureRecognizer.setIsDoubleTapEnabled(true);
     gestureRecognizer.setIsLongPressEnabled(false);
   }
 
@@ -141,20 +141,35 @@ public boolean onTouchEvent(MotionEvent event) {
   }
 
   @Override
-  public void onSingleTap(float x, float y) {
-
+  public void onDown(int count, float x, float y) {
+    if (transform != null) {
+      transform.cancelAnimator();
+    }
   }
 
   @Override
-  public void onDoubleTap(float x, float y) {
-
+  public void onUp(int count, float x, float y) {
+    if (count == 0 && transform != null) {
+      transform.rotateToNextAngle(x, y);
+    }
   }
 
   @Override
-  public void onLongPress(float x, float y) {
+  public void onCancel() {}
 
+  @Override
+  public void onSingleTap(float x, float y) {}
+
+  @Override
+  public void onDoubleTap(float x, float y) {
+    if (transform != null) {
+      transform.scaleToNextLevel(x, y);
+    }
   }
 
+  @Override
+  public void onLongPress(float x, float y) {}
+
   @Override
   public void onScroll(float dx, float dy, float totalX, float totalY, float x, float y) {
     if (transform != null) {
@@ -166,24 +181,24 @@ public void onScroll(float dx, float dy, float totalX, float totalY, float x, fl
 
   @Override
   public void onFling(float velocityX, float velocityY) {
-
+    if (transform != null) {
+      transform.fling(velocityX, velocityY);
+    }
   }
 
   @Override
   public void onScale(float factor, float x, float y) {
     if (transform != null) {
-      if (transform.scale(factor, x, y)) {
-        requestDisallowInterceptTouchEvent();
-      }
+      transform.scale(factor, x, y);
+      requestDisallowInterceptTouchEvent();
     }
   }
 
   @Override
   public void onRotate(float angle, float x, float y) {
     if (transform != null) {
-      if (transform.rotate(angle, x, y)) {
-        requestDisallowInterceptTouchEvent();
-      }
+      transform.rotate(angle, x, y);
+      requestDisallowInterceptTouchEvent();
     }
   }
 
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/drawable/Fling.java b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/Fling.java
new file mode 100644
index 000000000..393defdc3
--- /dev/null
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/Fling.java
@@ -0,0 +1,125 @@
+package com.hippo.fresco.large.drawable;
+
+/*
+ * Created by Hippo on 6/3/2017.
+ */
+
+import android.animation.ValueAnimator;
+import android.content.Context;
+import android.hardware.SensorManager;
+import android.view.ViewConfiguration;
+import android.view.animation.Interpolator;
+
+class Fling extends ValueAnimator {
+
+  private static final float DECELERATION_RATE = (float) (Math.log(0.78) / Math.log(0.9));
+  private static final float INFLEXION = 0.35f; // Tension lines cross at (INFLEXION, 1)
+  private static final float START_TENSION = 0.5f;
+  private static final float END_TENSION = 1.0f;
+  private static final float P1 = START_TENSION * INFLEXION;
+  private static final float P2 = 1.0f - END_TENSION * (1.0f - INFLEXION);
+  private static final float FLING_FRICTION = ViewConfiguration.getScrollFriction();
+
+  private static final int NB_SAMPLES = 100;
+  private static final float[] SPLINE_POSITION = new float[NB_SAMPLES + 1];
+  private static final float[] SPLINE_TIME = new float[NB_SAMPLES + 1];
+
+  private final float mPhysicalCoeff;
+
+  static {
+    float x_min = 0.0f;
+    float y_min = 0.0f;
+    for (int i = 0; i < NB_SAMPLES; i++) {
+      final float alpha = (float) i / NB_SAMPLES;
+
+      float x_max = 1.0f;
+      float x, tx, coef;
+      while (true) {
+        x = x_min + (x_max - x_min) / 2.0f;
+        coef = 3.0f * x * (1.0f - x);
+        tx = coef * ((1.0f - x) * P1 + x * P2) + x * x * x;
+        if (Math.abs(tx - alpha) < 1E-5) break;
+        if (tx > alpha) x_max = x;
+        else x_min = x;
+      }
+      SPLINE_POSITION[i] = coef * ((1.0f - x) * START_TENSION + x) + x * x * x;
+
+      float y_max = 1.0f;
+      float y, dy;
+      while (true) {
+        y = y_min + (y_max - y_min) / 2.0f;
+        coef = 3.0f * y * (1.0f - y);
+        dy = coef * ((1.0f - y) * START_TENSION + y) + y * y * y;
+        if (Math.abs(dy - alpha) < 1E-5) break;
+        if (dy > alpha) y_max = y;
+        else y_min = y;
+      }
+      SPLINE_TIME[i] = coef * ((1.0f - y) * P1 + y * P2) + y * y * y;
+    }
+    SPLINE_POSITION[NB_SAMPLES] = SPLINE_TIME[NB_SAMPLES] = 1.0f;
+  }
+
+  private static final Interpolator FLING_INTERPOLATOR = new Interpolator() {
+    @Override
+    public float getInterpolation(float input) {
+      final int index = (int) (NB_SAMPLES * input);
+      float distanceCoef = 1.f;
+      float velocityCoef;
+      if (index < NB_SAMPLES) {
+        final float t_inf = (float) index / NB_SAMPLES;
+        final float t_sup = (float) (index + 1) / NB_SAMPLES;
+        final float d_inf = SPLINE_POSITION[index];
+        final float d_sup = SPLINE_POSITION[index + 1];
+        velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
+        distanceCoef = d_inf + (input - t_inf) * velocityCoef;
+      }
+      return distanceCoef;
+    }
+  };
+
+  public Fling(Context context) {
+    final float ppi = context.getResources().getDisplayMetrics().density * 160.0f;
+    mPhysicalCoeff = SensorManager.GRAVITY_EARTH // g (m/s^2)
+        * 39.37f // inch/meter
+        * ppi
+        * 0.84f; // look and feel tuning
+    setInterpolator(FLING_INTERPOLATOR);
+  }
+
+  private double getSplineDeceleration(int velocity) {
+    return Math.log(INFLEXION * Math.abs(velocity) / (FLING_FRICTION * mPhysicalCoeff));
+  }
+
+  /* Returns the duration, expressed in milliseconds */
+  protected int getSplineFlingDuration(int velocity) {
+    final double l = getSplineDeceleration(velocity);
+    final double decelMinusOne = DECELERATION_RATE - 1.0;
+    return (int) (1000.0 * Math.exp(l / decelMinusOne));
+  }
+
+  protected double getSplineFlingDistance(int velocity) {
+    final double l = getSplineDeceleration(velocity);
+    final double decelMinusOne = DECELERATION_RATE - 1.0;
+    return FLING_FRICTION * mPhysicalCoeff * Math.exp(DECELERATION_RATE / decelMinusOne * l);
+  }
+
+  /**
+   *  Modifies mDuration to the duration it takes to get from start to newFinal using the
+   *  spline interpolation. The previous duration was needed to get to oldFinal.
+   **/
+  protected int adjustDuration(int start, int oldFinal, int newFinal, int duration) {
+    final int oldDistance = oldFinal - start;
+    final int newDistance = newFinal - start;
+    final float x = Math.abs((float) newDistance / oldDistance);
+    final int index = (int) (NB_SAMPLES * x);
+    if (index < NB_SAMPLES) {
+      final float x_inf = (float) index / NB_SAMPLES;
+      final float x_sup = (float) (index + 1) / NB_SAMPLES;
+      final float t_inf = SPLINE_TIME[index];
+      final float t_sup = SPLINE_TIME[index + 1];
+      final float timeCoef = t_inf + (x - x_inf) / (x_sup - x_inf) * (t_sup - t_inf);
+      duration *= timeCoef;
+    }
+    return duration;
+  }
+}
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/drawable/StandardizedTransformedDrawable.java b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/StandardizedTransformedDrawable.java
index 6f1a4ce02..779396497 100644
--- a/fresco-large/src/main/java/com/hippo/fresco/large/drawable/StandardizedTransformedDrawable.java
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/drawable/StandardizedTransformedDrawable.java
@@ -8,16 +8,32 @@
 import java.util.Arrays;
 import java.util.List;
 
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.ValueAnimator;
+import android.content.Context;
 import android.graphics.Matrix;
 import android.graphics.Rect;
 import android.graphics.RectF;
 import android.graphics.drawable.Drawable;
+import android.util.SparseArray;
 
+import com.facebook.drawable.base.DrawableWithCaches;
 import com.facebook.drawee.drawable.ForwardingDrawable;
 
-public class StandardizedTransformedDrawable extends ForwardingDrawable {
+public class StandardizedTransformedDrawable extends ForwardingDrawable
+    implements DrawableWithCaches {
+
+  private static final long DURATION = 200L;
+
+  private static final int ANIMATOR_TRANSLATE = 0;
+  private static final int ANIMATOR_SCALE = 1;
+  private static final int ANIMATOR_ROTATE = 2;
+
+  private Context context;
 
   private RectF rect = new RectF();
+  private Matrix matrix = new Matrix();
   private float[] matrixValue = new float[9];
 
   private float widthScale;
@@ -27,8 +43,19 @@
   private float maxScale;
   private float[] scaleLevels;
 
-  public StandardizedTransformedDrawable(Drawable drawable) {
+  private final SparseArray<Animator> animators = new SparseArray<>();
+
+  public StandardizedTransformedDrawable(Context context, Drawable drawable) {
     super(drawable);
+    this.context = context;
+  }
+
+  @Override
+  public void dropCaches() {
+    Drawable drawable = getCurrent();
+    if (drawable instanceof DrawableWithCaches) {
+      ((DrawableWithCaches) drawable).dropCaches();
+    }
   }
 
   @Override
@@ -38,9 +65,12 @@ protected void onBoundsChange(Rect bounds) {
   }
 
   private void updateScales() {
-    Transformed transformed = (Transformed) getDrawable();
     rect.set(0, 0, getIntrinsicWidth(), getIntrinsicHeight());
-    transformed.getMatrix().mapRect(rect);
+    Transformed transformed = (Transformed) getDrawable();
+    float scale = getScale(transformed.getMatrix());
+    matrix.set(transformed.getMatrix());
+    matrix.postScale(1 / scale, 1 / scale);
+    matrix.mapRect(rect);
 
     widthScale = (float) getBounds().width() / rect.width();
     heightScale = (float) getBounds().height() / rect.height();
@@ -70,6 +100,37 @@ private void updateScales() {
     return result;
   }
 
+  public void cancelAnimator() {
+    int size = animators.size();
+    if (size != 0) {
+      Animator[] copy = new Animator[size];
+      for (int i = 0; i < size; ++i) {
+        copy[i] = animators.valueAt(i);
+      }
+      for (Animator animator : copy) {
+        animator.cancel();
+      }
+      animators.clear();
+    }
+  }
+
+  private void startAnimator(Animator animator, final int type) {
+    animator.addListener(new AnimatorListenerAdapter() {
+      @Override
+      public void onAnimationEnd(Animator animation) {
+        animators.remove(type);
+      }
+    });
+
+    Animator oldAnimator = animators.get(type);
+    if (oldAnimator != null) {
+      oldAnimator.cancel();
+    }
+    animators.put(type, animator);
+
+    animator.start();
+  }
+
   public boolean translate(float dx, float dy) {
     Transformed transformed = (Transformed) getDrawable();
 
@@ -136,7 +197,7 @@ private void fixPosition() {
     }
   }
 
-  public boolean scale(float factor, float x, float y) {
+  public void scale(float factor, float x, float y) {
     Transformed transformed = (Transformed) getDrawable();
 
     final float scale = getScale(transformed.getMatrix());
@@ -152,26 +213,158 @@ public boolean scale(float factor, float x, float y) {
       transformed.scale(factor, factor, x, y);
       fixPosition();
     }
-
-    // Always return true
-    return true;
   }
 
-  public boolean rotate(float angle, float x, float y) {
+  public void rotate(float angle, float x, float y) {
     Transformed transformed = (Transformed) getDrawable();
 
     transformed.rotate(angle, x, y);
     fixPosition();
     updateScales();
+  }
+
+  public void rotateToNextAngle(final float x, final float y) {
+    Transformed transformed = (Transformed) getDrawable();
 
-    // Always return true
-    return true;
+    float angle = getAngleToRect(transformed.getMatrix());
+    ValueAnimator rotateAnimator = ValueAnimator.ofFloat(0.0f, angle);
+    rotateAnimator.setDuration(DURATION);
+    rotateAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+      private float previousAngle = 0.0f;
+      @Override
+      public void onAnimationUpdate(ValueAnimator animation) {
+        float angle = (float) animation.getAnimatedValue();
+        rotate(angle - previousAngle, x, y);
+        previousAngle = angle;
+      }
+    });
+    startAnimator(rotateAnimator, ANIMATOR_ROTATE);
+  }
+
+  private float getNextScale(float currentScale) {
+    float result = Float.NaN;
+
+    for (float scale : scaleLevels) {
+      if (!eq(currentScale, scale) && scale > currentScale) {
+        result = scale;
+        break;
+      }
+    }
+
+    if (Float.isNaN(result)) {
+      result = scaleLevels[0];
+    }
+
+    return result;
+  }
+
+  public void scaleToNextLevel(final float x, final float y) {
+    Transformed transformed = (Transformed) getDrawable();
+
+    final float currentScale = getScale(transformed.getMatrix());
+    final float nextScale = getNextScale(currentScale);
+
+    ValueAnimator scaleAnimator = ValueAnimator.ofFloat(currentScale, nextScale);
+    scaleAnimator.setDuration(DURATION);
+    scaleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+      private float previousScale = currentScale;
+      @Override
+      public void onAnimationUpdate(ValueAnimator animation) {
+        float scale = (float) animation.getAnimatedValue();
+        scale(scale / previousScale, x, y);
+        previousScale = scale;
+      }
+    });
+    startAnimator(scaleAnimator, ANIMATOR_SCALE);
+  }
+
+  public void fling(float velocityX, float velocityY) {
+    Transformed transformed = (Transformed) getDrawable();
+
+    rect.set(0, 0, getIntrinsicWidth(), getIntrinsicHeight());
+    transformed.getMatrix().mapRect(rect);
+
+    Fling fling = new Fling(context);
+    float dx =
+        (float) (fling.getSplineFlingDistance((int) velocityX) * Math.signum(velocityX));
+    float dy =
+        (float) (fling.getSplineFlingDistance((int) velocityY) * Math.signum(velocityY));
+    int durationX = fling.getSplineFlingDuration((int) velocityX);
+    int durationY = fling.getSplineFlingDuration((int) velocityY);
+
+    int windowWidth = getBounds().width();
+    int windowHeight = getBounds().height();
+    // Fix dx and durationX
+    if (rect.width() < windowWidth) {
+      dx = 0.0f;
+      durationX = 0;
+    } else if (dx > -rect.left) {
+      durationX = fling.adjustDuration(0, (int) dx, (int) -rect.left, durationX);
+      dx = -rect.left;
+    } else if (dx < windowWidth - rect.right) {
+      durationX = fling.adjustDuration(0, (int) dx, (int) (windowWidth - rect.right), durationX);
+      dx = windowWidth - rect.right;
+    }
+    // Fix dy and durationY
+    if (rect.height() < windowHeight) {
+      dy = 0.0f;
+      durationY = 0;
+    } else if (dy > -rect.top) {
+      durationY = fling.adjustDuration(0, (int) dy, (int) -rect.top, durationY);
+      dy = -rect.top;
+    } else if (dy < windowHeight - rect.bottom) {
+      durationY = fling.adjustDuration(0, (int) dy, (int) (windowHeight - rect.bottom), durationY);
+      dy = windowHeight - rect.bottom;
+    }
+
+    final float finalDX = dx;
+    final float finalDY = dy;
+    final int finalDuration = Math.max(durationX, durationY);
+    if (finalDuration == 0 || (eq(finalDX, 0.0f) && eq(finalDY, 0.0f))) {
+      // Can't scroll
+      return;
+    }
+
+    fling.setDuration(finalDuration);
+    fling.setFloatValues(0.0f, 1.0f);
+    fling.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+      float previousDX = 0.0f;
+      float previousDY = 0.0f;
+      @Override
+      public void onAnimationUpdate(ValueAnimator animation) {
+        float factor = (float) animation.getAnimatedValue();
+        float dx = factor * finalDX;
+        float dy = factor * finalDY;
+        translate(dx - previousDX, dy - previousDY);
+        previousDX = dx;
+        previousDY = dy;
+      }
+    });
+    startAnimator(fling, ANIMATOR_TRANSLATE);
   }
 
   private float getScale(Matrix matrix) {
     matrix.getValues(matrixValue);
-    return (float) Math.sqrt(matrixValue[Matrix.MSCALE_X] * matrixValue[Matrix.MSCALE_X] +
-        matrixValue[Matrix.MSKEW_X] * matrixValue[Matrix.MSKEW_X]);
+    float x = matrixValue[Matrix.MSCALE_X];
+    float y = matrixValue[Matrix.MSKEW_X];
+    return (float) Math.sqrt(x * x + y * y);
+  }
+
+  private float getAngleToRect(Matrix matrix) {
+    matrix.getValues(matrixValue);
+    float x = matrixValue[Matrix.MSCALE_X];
+    float y = matrixValue[Matrix.MSKEW_X];
+    float angle = (float) Math.toDegrees(Math.atan(- y / x));
+    if (Float.isNaN(angle)) {
+      angle = 90.0f;
+    } else if (angle < 0.0f) {
+      angle += 90.0f;
+    }
+    if (angle < 45.0f) {
+      return -angle;
+    } else {
+      return 90.0f - angle;
+    }
   }
 
   // Greater than or equal
diff --git a/fresco-large/src/main/java/com/hippo/fresco/large/gesture/GestureRecognizer.java b/fresco-large/src/main/java/com/hippo/fresco/large/gesture/GestureRecognizer.java
index a8c795313..ea6c3479d 100644
--- a/fresco-large/src/main/java/com/hippo/fresco/large/gesture/GestureRecognizer.java
+++ b/fresco-large/src/main/java/com/hippo/fresco/large/gesture/GestureRecognizer.java
@@ -101,6 +101,20 @@ public boolean isRotateEnabled() {
   }
 
   public boolean onTouchEvent(MotionEvent event) {
+    switch (event.getActionMasked()) {
+      case MotionEvent.ACTION_DOWN:
+      case MotionEvent.ACTION_POINTER_DOWN:
+        listener.onDown(event.getPointerCount() - 1, event.getX(), event.getY());
+        break;
+      case MotionEvent.ACTION_UP:
+      case MotionEvent.ACTION_POINTER_UP:
+        listener.onUp(event.getPointerCount() - 1, event.getX(), event.getY());
+        break;
+      case MotionEvent.ACTION_CANCEL:
+        listener.onCancel();
+        break;
+    }
+
     gestureDetector.onTouchEvent(event);
     scaleGestureDetector.onTouchEvent(event);
     rotationGestureDetector.onTouchEvent(event);
@@ -251,6 +265,12 @@ public void onRotateEnd() {
 
   public interface Listener {
 
+    void onDown(int count, float x, float y);
+
+    void onUp(int count, float x, float y);
+
+    void onCancel();
+
     void onSingleTap(float x, float y);
 
     void onDoubleTap(float x, float y);
