diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 411ed7bd..86d08272 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -21,12 +21,14 @@
 import android.database.sqlite.SQLiteDatabase;
 
 import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.PrimaryKey;
 import com.activeandroid.content.ContentProvider;
 import com.activeandroid.query.Delete;
 import com.activeandroid.query.Select;
 import com.activeandroid.serializer.TypeSerializer;
 import com.activeandroid.util.Log;
 import com.activeandroid.util.ReflectionUtils;
+import com.activeandroid.util.SQLiteUtils;
 
 import java.lang.reflect.Field;
 import java.util.List;
@@ -146,17 +148,33 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 			}
 		}
 
-		if (mId == null) {
-			mId = db.insert(mTableInfo.getTableName(), null, values);
-		}
-		else {
-			db.update(mTableInfo.getTableName(), values, "Id=" + mId, null);
+        if(!exists()){
+		    long mId = db.insert(mTableInfo.getTableName(), null, values);
+
+            for(Field field : mTableInfo.getPrimaryKeys()){
+                if(field.isAnnotationPresent(PrimaryKey.class) &&
+                        field.getAnnotation(PrimaryKey.class).type().equals(PrimaryKey.Type.AUTO_INCREMENT)){
+                    field.setAccessible(true);
+                    try {
+                        field.set(this, mId);
+                    } catch (Throwable e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+            }
+        } else {
+			db.update(mTableInfo.getTableName(), values, SQLiteUtils.getWhereStatement(this, mTableInfo), null);
 		}
 
 		Cache.getContext().getContentResolver()
 				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
 	}
 
+    public boolean exists(){
+        Model model = new Select().from(getClass()).where(SQLiteUtils.getWhereStatement(this, mTableInfo)).executeSingle();
+        return model!=null;
+    }
+
 	// Convenience methods
 
 	public static void delete(Class<? extends Model> type, long id) {
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/TableInfo.java
index 6e05cecf..7ecf9f28 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/src/com/activeandroid/TableInfo.java
@@ -21,11 +21,15 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 
 import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.ForeignKey;
+import com.activeandroid.annotation.PrimaryKey;
 import com.activeandroid.annotation.Table;
+import com.activeandroid.exception.PrimaryKeyNotFoundException;
 import com.activeandroid.util.Log;
 import com.activeandroid.util.ReflectionUtils;
 
@@ -38,6 +42,8 @@
 	private String mTableName;
 
 	private Map<Field, String> mColumnNames = new HashMap<Field, String>();
+    private LinkedList<Field> mPrimaryKeys;
+    private LinkedList<Field> mForeignKeys = new LinkedList<Field>();
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
@@ -74,7 +80,20 @@ public TableInfo(Class<? extends Model> type) {
                 }
 				mColumnNames.put(field, fieldName);
 			}
+
+            if(field.isAnnotationPresent(PrimaryKey.class) &&
+                    field.getAnnotation(PrimaryKey.class).type().equals(PrimaryKey.Type.DEFAULT)){
+                mPrimaryKeys.add(field);
+            }
+
+            if(field.isAnnotationPresent(ForeignKey.class)){
+                mForeignKeys.add(field);
+            }
 		}
+
+        if(mPrimaryKeys.isEmpty()){
+            throw new PrimaryKeyNotFoundException("Table: " + mTableName + " must define a primary key");
+        }
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -116,4 +135,12 @@ else if (type.getSuperclass() != null) {
 
 		return null;
 	}
+
+    public LinkedList<Field> getForeignKeys() {
+        return mForeignKeys;
+    }
+
+    public LinkedList<Field> getPrimaryKeys() {
+        return mPrimaryKeys;
+    }
 }
diff --git a/src/com/activeandroid/annotation/ForeignKey.java b/src/com/activeandroid/annotation/ForeignKey.java
new file mode 100644
index 00000000..7bff674b
--- /dev/null
+++ b/src/com/activeandroid/annotation/ForeignKey.java
@@ -0,0 +1,18 @@
+package com.activeandroid.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Created by andrewgrosner
+ * Date: 12/12/13
+ * Contributors:
+ * Description:
+ */
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ForeignKey {
+    String value();
+}
diff --git a/src/com/activeandroid/annotation/PrimaryKey.java b/src/com/activeandroid/annotation/PrimaryKey.java
new file mode 100644
index 00000000..52a0e6d2
--- /dev/null
+++ b/src/com/activeandroid/annotation/PrimaryKey.java
@@ -0,0 +1,23 @@
+package com.activeandroid.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Created by andrewgrosner
+ * Date: 12/12/13
+ * Contributors:
+ * Description: Marks a field as a primary key
+ */
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface PrimaryKey {
+    public enum Type{
+        AUTO_INCREMENT,
+        DEFAULT;
+    }
+
+    public Type type() default Type.DEFAULT;
+}
diff --git a/src/com/activeandroid/exception/PrimaryKeyNotFoundException.java b/src/com/activeandroid/exception/PrimaryKeyNotFoundException.java
new file mode 100644
index 00000000..e8d6d058
--- /dev/null
+++ b/src/com/activeandroid/exception/PrimaryKeyNotFoundException.java
@@ -0,0 +1,13 @@
+package com.activeandroid.exception;
+
+/**
+ * Created by andrewgrosner
+ * Date: 12/12/13
+ * Contributors:
+ * Description:
+ */
+public class PrimaryKeyNotFoundException extends RuntimeException {
+    public PrimaryKeyNotFoundException(String s) {
+        super(s);
+    }
+}
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index b9ba32b9..0ca41cff 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -17,6 +17,7 @@
  */
 
 import android.database.Cursor;
+import android.database.DatabaseUtils;
 import android.os.Build;
 import android.text.TextUtils;
 
@@ -24,6 +25,8 @@
 import com.activeandroid.Model;
 import com.activeandroid.TableInfo;
 import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.ForeignKey;
+import com.activeandroid.annotation.PrimaryKey;
 import com.activeandroid.serializer.TypeSerializer;
 
 import java.lang.reflect.Constructor;
@@ -118,6 +121,34 @@ public static String createTableDefinition(TableInfo tableInfo) {
 			}
 		}
 
+        List<Field> primaryColumns = tableInfo.getPrimaryKeys();
+        List<Field> foreignColumns = tableInfo.getForeignKeys();
+        if(!primaryColumns.isEmpty()){
+            StringBuilder builder = new StringBuilder("PRIMARY KEY(");
+
+
+            for(int i  =0 ; i< primaryColumns.size(); i++){
+                builder.append(tableInfo.getColumnName(primaryColumns.get(i)));
+                if(i< primaryColumns.size()-1){
+                    builder.append(", ");
+                }
+            }
+
+            builder.append(")");
+
+            definitions.add(builder.toString());
+        }
+
+        for(int i = 0; i < foreignColumns.size(); i++){
+            final Field column = foreignColumns.get(i);
+            ForeignKey foreignKey = column.getAnnotation(ForeignKey.class);
+            StringBuilder forDef = new StringBuilder("FOREIGN KEY(");
+            forDef.append(tableInfo.getColumnName(column)).append(") REFERENCES ").append(foreignKey.value());
+
+            definitions.add(forDef.toString());
+        }
+
+
 		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
 				TextUtils.join(", ", definitions));
 	}
@@ -158,8 +189,11 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 				definition.append(")");
 			}
 
-			if (name.equals("Id")) {
-				definition.append(" PRIMARY KEY AUTOINCREMENT");
+			if (field.isAnnotationPresent(PrimaryKey.class)) {
+                PrimaryKey primaryKey = field.getAnnotation(PrimaryKey.class);
+                if(primaryKey.type().equals(PrimaryKey.Type.AUTO_INCREMENT)){
+				    definition.append(" PRIMARY KEY AUTOINCREMENT");
+                }
 			}
 
 			if (column.notNull()) {
@@ -171,16 +205,6 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 				definition.append(" UNIQUE ON CONFLICT ");
 				definition.append(column.onUniqueConflict().toString());
 			}
-
-			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
-				definition.append(" REFERENCES ");
-				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
-				definition.append("(Id)");
-				definition.append(" ON DELETE ");
-				definition.append(column.onDelete().toString().replace("_", " "));
-				definition.append(" ON UPDATE ");
-				definition.append(column.onUpdate().toString().replace("_", " "));
-			}
 		}
 		else {
 			Log.e("No type mapping for: " + type.toString());
@@ -216,4 +240,48 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 
 		return entities;
 	}
+
+    public static String getWhereStatement(Model model, TableInfo tableInfo){
+        List<Field> fields = new ArrayList<Field>();
+        ArrayList<Field> primaryColumn = new ArrayList<Field>();
+        fields = ReflectionUtils.getAllFields(fields, model.getClass());
+
+        for(Field field : fields){
+            if(field.isAnnotationPresent(PrimaryKey.class)){
+                primaryColumn.add(field);
+            }
+        }
+
+        final StringBuilder where = new StringBuilder();
+        for(int i = 0 ; i < primaryColumn.size(); i++){
+            final Field field = primaryColumn.get(i);
+            where.append(tableInfo.getColumnName(field));
+            where.append("=?");
+
+            if(i < primaryColumn.size()-1){
+                where.append(" AND ");
+            }
+        }
+
+        String sql = where.toString();
+
+        for(int i = 0; i < primaryColumn.size(); i++){
+            final Field field = primaryColumn.get(i);
+            field.setAccessible(true);
+            try {
+                Object object = field.get(model);
+                if(object instanceof Number){
+                    sql = sql.replaceFirst("\\?", object.toString());
+                } else {
+                    String escaped = DatabaseUtils.sqlEscapeString(object.toString());
+
+                    sql = sql.replaceFirst("\\?", escaped);
+                }
+            } catch (Throwable e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return sql;
+    }
+
 }
