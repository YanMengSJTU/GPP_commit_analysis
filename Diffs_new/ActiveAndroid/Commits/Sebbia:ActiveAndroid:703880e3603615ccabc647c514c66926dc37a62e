diff --git a/src/com/activeandroid/sebbia/Cache.java b/src/com/activeandroid/sebbia/Cache.java
index 5cc662b1..b97d88a4 100644
--- a/src/com/activeandroid/sebbia/Cache.java
+++ b/src/com/activeandroid/sebbia/Cache.java
@@ -24,6 +24,7 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.support.v4.util.LruCache;
 
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
 import com.activeandroid.sebbia.internal.EmptyModelFiller;
 import com.activeandroid.sebbia.internal.ModelFiller;
 import com.activeandroid.sebbia.serializer.TypeSerializer;
@@ -177,7 +178,8 @@ private static void initializeModelFillers() {
 		for (TableInfo tableInfo : sModelInfo.getTableInfos()) {
 			try {
 				Class<? extends Model> type = tableInfo.getType(); 
-				sFillers.put(type, instantiateFiller(type));
+				if (type.getAnnotation(DoNotGenerate.class) == null)
+					sFillers.put(type, instantiateFiller(type));
 			} catch (IllegalAccessException e) {
 				throw new RuntimeException(e);
 			} catch (InstantiationException e) {
diff --git a/src/com/activeandroid/sebbia/Model.java b/src/com/activeandroid/sebbia/Model.java
index 5d27b404..0b7617cc 100644
--- a/src/com/activeandroid/sebbia/Model.java
+++ b/src/com/activeandroid/sebbia/Model.java
@@ -43,33 +43,34 @@
 	/** Prime number used for hashcode() implementation. */
 	private static final int HASH_PRIME = 739;
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	private Long mId = null;
 
 	private final TableInfo mTableInfo;
 	private final String idName;
-	//////////////////////////////////////////////////////////////////////////////////////
+
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	public Model() {
 		mTableInfo = Cache.getTableInfo(getClass());
 		idName = mTableInfo.getIdName();
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	public final Long getId() {
 		return mId;
 	}
 
 	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), idName+"=?", new String[] { getId().toString() });
+		Cache.openDatabase().delete(mTableInfo.getTableName(), idName + "=?", new String[] { getId().toString() });
 		Cache.removeEntity(this);
 
 		Cache.getContext().getContentResolver()
@@ -85,7 +86,7 @@ public final Long save() {
 			mId = db.insert(mTableInfo.getTableName(), null, values);
 		}
 		else {
-			db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
+			db.update(mTableInfo.getTableName(), values, idName + "=" + mId, null);
 		}
 
 		Cache.getContext().getContentResolver()
@@ -97,58 +98,61 @@ public final Long save() {
 
 	public static void delete(Class<? extends Model> type, long id) {
 		TableInfo tableInfo = Cache.getTableInfo(type);
-		new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
+		new Delete().from(type).where(tableInfo.getIdName() + "=?", id).execute();
 	}
 
 	public static <T extends Model> T load(Class<T> type, long id) {
 		TableInfo tableInfo = Cache.getTableInfo(type);
-		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
+		return (T) new Select().from(type).where(tableInfo.getIdName() + "=?", id).executeSingle();
 	}
-	
+
 	public static void saveMultiple(List<? extends Model> entities) {
 		final SQLiteDatabase db = Cache.openDatabase();
 		final ContentValues values = new ContentValues();
 		for (Model entity : entities) {
 			values.clear();
-			if (entity.mId == null && (entity instanceof ManyToManyRelation<?, ?> || entity instanceof OneToManyRelation<?, ?>)) {
-				entity.fillContentValuesReflective(values);
-				db.insert(entity.mTableInfo.getTableName(), null, values);
-			} else if (entity.mId == null) {
+			if (entity.mId == null) {
 				ModelFiller filler = Cache.getFiller(entity.getClass());
-				SQLiteStatement statement = entity.mTableInfo.getInsertOrReplaceStatement();
-				statement.clearBindings();
-				filler.bindStatement(entity, statement, entity.mTableInfo.getColumnIndexes());
-				entity.mId = statement.executeInsert();
+				if (filler != null) {
+					SQLiteStatement statement = entity.mTableInfo.getInsertOrReplaceStatement();
+					statement.clearBindings();
+					filler.bindStatement(entity, statement, entity.mTableInfo.getColumnIndexes());
+					entity.mId = statement.executeInsert();
+				} else {
+					entity.fillContentValuesReflective(values);
+					entity.mId = db.insert(entity.mTableInfo.getTableName(), null, values);
+				}
 			} else {
 				fillContentValues(entity, values);
 				db.update(entity.mTableInfo.getTableName(), values, "Id=" + entity.mId, null);
 			}
 		}
 	}
+
 	// Model population
 
 	public final void loadFromCursor(Cursor cursor) {
 		ModelFiller filler = Cache.getFiller(mTableInfo.getType());
-		if (filler != null) {			
+		if (filler != null) {
 			loadFromCursorWithFiller(cursor, filler);
 		} else {
 			loadFromCursorReflective(cursor);
 		}
 	}
-	
+
 	private static void fillContentValues(Model entity, ContentValues values) {
 		if (entity instanceof ManyToManyRelation<?, ?> || entity instanceof OneToManyRelation<?, ?>) {
 			entity.fillContentValuesReflective(values);
 			return;
 		}
-		
+
 		ModelFiller filler = Cache.getFiller(entity.mTableInfo.getType());
 		if (filler != null)
 			filler.fillContentValues(entity, values);
 		else
 			entity.fillContentValuesReflective(values);
 	}
-	
+
 	private void fillContentValuesReflective(final ContentValues values) {
 		for (Field field : mTableInfo.getFields()) {
 			final String fieldName = mTableInfo.getColumnName(field);
@@ -167,7 +171,8 @@ private void fillContentValuesReflective(final ContentValues values) {
 						// set new object type
 						if (value != null) {
 							fieldType = value.getClass();
-							// check that the serializer returned what it promised
+							// check that the serializer returned what it
+							// promised
 							if (!fieldType.equals(typeSerializer.getSerializedType())) {
 								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
 										typeSerializer.getSerializedType(), fieldType));
@@ -176,7 +181,8 @@ private void fillContentValuesReflective(final ContentValues values) {
 					}
 				}
 
-				// TODO: Find a smarter way to do this? This if block is necessary because we
+				// TODO: Find a smarter way to do this? This if block is
+				// necessary because we
 				// can't know the type until runtime.
 				if (value == null) {
 					values.putNull(fieldName);
@@ -217,17 +223,14 @@ else if (ReflectionUtils.isModel(fieldType)) {
 				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 					values.put(fieldName, ((Enum<?>) value).name());
 				}
-			}
-			catch (IllegalArgumentException e) {
+			} catch (IllegalArgumentException e) {
 				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
+			} catch (IllegalAccessException e) {
 				Log.e(e.getClass().getName(), e);
 			}
 		}
 	}
 
-	
 	private void loadFromCursorWithFiller(Cursor cursor, ModelFiller filler) {
 		int columnIndex = cursor.getColumnIndex(idName);
 		if (cursor.isNull(columnIndex) == false)
@@ -235,14 +238,15 @@ private void loadFromCursorWithFiller(Cursor cursor, ModelFiller filler) {
 		else
 			mId = null;
 		filler.loadFromCursor(this, cursor);
-	}	
-	
+	}
+
 	private void loadFromCursorReflective(Cursor cursor) {
 		/**
-         * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-         * when the cursor have multiple columns with same name obtained from join tables.
-         */
-        List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+		 * Obtain the columns ordered to fix issue #106
+		 * (https://github.com/pardom/ActiveAndroid/issues/106) when the cursor
+		 * have multiple columns with same name obtained from join tables.
+		 */
+		List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
 		for (Field field : mTableInfo.getFields()) {
 			final String fieldName = mTableInfo.getColumnName(field);
 			Class<?> fieldType = field.getType();
@@ -268,11 +272,11 @@ private void loadFromCursorReflective(Cursor cursor) {
 				} else {
 					value = ModelHelper.getValueFromCursor(cursor, fieldType, columnIndex);
 				}
-				
+
 				if (value == null) {
 					if (ReflectionUtils.isModel(fieldType)) {
 						value = ModelHelper.getModel(cursor, fieldType, columnIndex);
-					} 
+					}
 					else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 						@SuppressWarnings("rawtypes")
 						final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
@@ -288,14 +292,11 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 				if (value != null) {
 					field.set(this, value);
 				}
-			}
-			catch (IllegalArgumentException e) {
+			} catch (IllegalArgumentException e) {
 				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
+			} catch (IllegalAccessException e) {
 				Log.e(e.getClass().getName(), e);
-			}
-			catch (SecurityException e) {
+			} catch (SecurityException e) {
 				Log.e(e.getClass().getName(), e);
 			}
 		}
@@ -304,23 +305,22 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 			Cache.addEntity(this);
 		}
 	}
-	
-	
-	//////////////////////////////////////////////////////////////////////////////////////
+
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
 		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
 	}
-	
+
 	protected String getIdName() {
 		return idName;
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	@Override
 	public String toString() {
@@ -332,8 +332,8 @@ public boolean equals(Object obj) {
 		if (obj instanceof Model && this.mId != null) {
 			final Model other = (Model) obj;
 
-			return this.mId.equals(other.mId)							
-							&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
+			return this.mId.equals(other.mId)
+					&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
 		} else {
 			return this == obj;
 		}
@@ -342,8 +342,14 @@ public boolean equals(Object obj) {
 	@Override
 	public int hashCode() {
 		int hash = HASH_PRIME;
-		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); //if id is null, use Object.hashCode()
+		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); // if
+																				// id
+																				// is
+																				// null,
+																				// use
+																				// Object.hashCode()
 		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
-		return hash; //To change body of generated methods, choose Tools | Templates.
+		return hash; // To change body of generated methods, choose Tools |
+						// Templates.
 	}
 }
diff --git a/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java b/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java
new file mode 100644
index 00000000..c97b3fa4
--- /dev/null
+++ b/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java
@@ -0,0 +1,10 @@
+package com.activeandroid.sebbia.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface DoNotGenerate { }
diff --git a/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java b/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
index 44dfbfd9..d87cae2a 100644
--- a/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
+++ b/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
@@ -23,6 +23,7 @@
 
 import com.activeandroid.sebbia.Model;
 import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
 
 public final class AnnotationProcessor extends AbstractProcessor {
 
@@ -66,17 +67,19 @@ private void parseColumns() {
 			}
 			VariableElement columnElement = (VariableElement) element;
 
-			if (checkColumnModifiers(columnElement) == false)
-				continue;
-
 			TypeElement tableElement = null;
-			if (element.getEnclosingElement() instanceof TypeElement)
+			if (element.getEnclosingElement() instanceof TypeElement) {
 				tableElement = (TypeElement) element.getEnclosingElement();
-			else
+			} else {
 				error("@Column annotation located not inside of class", element);
-
+				continue;
+			}
+				
 			if (checkTableModifiers(tableElement) == false)
 				continue;
+			
+			if (checkColumnModifiers(columnElement) == false)
+				continue;
 
 			Set<VariableElement> columnsElements = tables.get(tableElement);
 			if (columnsElements == null) {
@@ -379,6 +382,9 @@ private boolean checkTableModifiers(TypeElement table) {
 			error("Only classes can be marked with @Table annotation", table);
 			return false;
 		}
+		
+		if (table.getAnnotation(DoNotGenerate.class) != null)
+			return false;
 
 		return true;
 	}
diff --git a/src/com/activeandroid/sebbia/model/ManyToManyRelation.java b/src/com/activeandroid/sebbia/model/ManyToManyRelation.java
index e1864b68..469192bb 100644
--- a/src/com/activeandroid/sebbia/model/ManyToManyRelation.java
+++ b/src/com/activeandroid/sebbia/model/ManyToManyRelation.java
@@ -7,10 +7,12 @@
 import com.activeandroid.sebbia.Model;
 import com.activeandroid.sebbia.TableInfo;
 import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
 import com.activeandroid.sebbia.query.Delete;
 import com.activeandroid.sebbia.util.Log;
 import com.activeandroid.sebbia.util.SQLiteUtils;
 
+@DoNotGenerate
 public abstract class ManyToManyRelation<T1 extends Model, T2 extends Model> extends Model {
 
 	@Column (name = "entity1")
diff --git a/src/com/activeandroid/sebbia/model/OneToManyRelation.java b/src/com/activeandroid/sebbia/model/OneToManyRelation.java
index fd1d6a92..79bd2367 100644
--- a/src/com/activeandroid/sebbia/model/OneToManyRelation.java
+++ b/src/com/activeandroid/sebbia/model/OneToManyRelation.java
@@ -9,9 +9,11 @@
 import com.activeandroid.sebbia.Model;
 import com.activeandroid.sebbia.TableInfo;
 import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
 import com.activeandroid.sebbia.query.Delete;
 import com.activeandroid.sebbia.util.Log;
 
+@DoNotGenerate
 public abstract class OneToManyRelation<T1 extends Model, T2 extends Model> extends Model {
 
 	@Column (name = "entity1")
diff --git a/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java b/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java
new file mode 100644
index 00000000..1606e86a
--- /dev/null
+++ b/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java
@@ -0,0 +1,39 @@
+package com.activeandroid.test.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
+import com.activeandroid.sebbia.query.Select;
+
+public class DoNotGenerateTest extends ModelTestCase {
+	
+	@DoNotGenerate
+	public static class DoNotGenerateModel extends Model {
+		
+		@Column(name = "value")
+		private String value;
+	}
+
+	public void testNoGenerate() {
+		List<DoNotGenerateModel> impls = new ArrayList<DoNotGenerateModel>();
+		for (int i = 0; i < 100; ++i) {
+			DoNotGenerateModel model = new DoNotGenerateModel();
+			model.value = Integer.toString(i);
+			impls.add(model);
+		}
+		
+		Model.saveMultiple(impls);
+		
+		impls = new Select().from(DoNotGenerateModel.class).execute();
+		assertEquals(100, impls.size());
+		for (int i = 0; i < impls.size(); ++i) {
+			DoNotGenerateModel impl = impls.get(i);
+			assertNotNull(impl);
+			assertNotNull(impl.value);
+			assertTrue(impl.value.equalsIgnoreCase(Integer.toString(i)));
+		}
+	}
+}
