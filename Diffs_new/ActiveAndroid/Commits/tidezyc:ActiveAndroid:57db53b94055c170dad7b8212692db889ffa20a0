diff --git a/src/com/activeandroid/query/From.java b/src/com/activeandroid/query/From.java
index ab3837a9..6e49fd83 100644
--- a/src/com/activeandroid/query/From.java
+++ b/src/com/activeandroid/query/From.java
@@ -29,63 +29,63 @@
 import java.util.List;
 
 public final class From implements Sqlable {
-	private Sqlable mQueryBase;
-
-	private Class<? extends Model> mType;
-	private String mAlias;
-	private List<Join> mJoins;
-	private final StringBuilder mWhere = new StringBuilder();
-	private String mGroupBy;
-	private String mHaving;
-	private String mOrderBy;
-	private String mLimit;
-	private String mOffset;
-
-	private List<Object> mArguments;
-
-	public From(Class<? extends Model> table, Sqlable queryBase) {
-		mType = table;
-		mJoins = new ArrayList<Join>();
-		mQueryBase = queryBase;
-
-		mJoins = new ArrayList<Join>();
-		mArguments = new ArrayList<Object>();
-	}
-
-	public From as(String alias) {
-		mAlias = alias;
-		return this;
-	}
-
-	public Join join(Class<? extends Model> table) {
-		Join join = new Join(this, table, null);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join leftJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.LEFT);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join outerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.OUTER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join innerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.INNER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join crossJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.CROSS);
-		mJoins.add(join);
-		return join;
-	}
+    private Sqlable mQueryBase;
+
+    private Class<? extends Model> mType;
+    private String mAlias;
+    private List<Join> mJoins;
+    private final StringBuilder mWhere = new StringBuilder();
+    private String mGroupBy;
+    private String mHaving;
+    private String mOrderBy;
+    private String mLimit;
+    private String mOffset;
+
+    private List<Object> mArguments;
+
+    public From(Class<? extends Model> table, Sqlable queryBase) {
+        mType = table;
+        mJoins = new ArrayList<Join>();
+        mQueryBase = queryBase;
+
+        mJoins = new ArrayList<Join>();
+        mArguments = new ArrayList<Object>();
+    }
+
+    public From as(String alias) {
+        mAlias = alias;
+        return this;
+    }
+
+    public Join join(Class<? extends Model> table) {
+        Join join = new Join(this, table, null);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join leftJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.LEFT);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join outerJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.OUTER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join innerJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.INNER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join crossJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.CROSS);
+        mJoins.add(join);
+        return join;
+    }
 
     public From where(String clause) {
         // Chain conditions if a previous condition exists.
@@ -121,48 +121,48 @@ public From or(String clause, Object... args) {
         or(clause).addArguments(args);
         return this;
     }
-    
-	public From groupBy(String groupBy) {
-		mGroupBy = groupBy;
-		return this;
-	}
-
-	public From having(String having) {
-		mHaving = having;
-		return this;
-	}
-
-	public From orderBy(String orderBy) {
-		mOrderBy = orderBy;
-		return this;
-	}
-
-	public From limit(int limit) {
-		return limit(String.valueOf(limit));
-	}
-
-	public From limit(String limit) {
-		mLimit = limit;
-		return this;
-	}
-
-	public From offset(int offset) {
-		return offset(String.valueOf(offset));
-	}
-
-	public From offset(String offset) {
-		mOffset = offset;
-		return this;
-	}
-
-	void addArguments(Object[] args) {
-        for(Object arg : args) {
+
+    public From groupBy(String groupBy) {
+        mGroupBy = groupBy;
+        return this;
+    }
+
+    public From having(String having) {
+        mHaving = having;
+        return this;
+    }
+
+    public From orderBy(String orderBy) {
+        mOrderBy = orderBy;
+        return this;
+    }
+
+    public From limit(int limit) {
+        return limit(String.valueOf(limit));
+    }
+
+    public From limit(String limit) {
+        mLimit = limit;
+        return this;
+    }
+
+    public From offset(int offset) {
+        return offset(String.valueOf(offset));
+    }
+
+    public From offset(String offset) {
+        mOffset = offset;
+        return this;
+    }
+
+    void addArguments(Object[] args) {
+        for (Object arg : args) {
             if (arg.getClass() == boolean.class || arg.getClass() == Boolean.class) {
                 arg = (arg.equals(true) ? 1 : 0);
             }
             mArguments.add(arg);
         }
-	}
+    }
 
     private void addFrom(final StringBuilder sql) {
         sql.append("FROM ");
@@ -293,33 +293,39 @@ public String toCountSql() {
         return sqlString(sql);
     }
 
-	public <T extends Model> List<T> execute() {
-		if (mQueryBase instanceof Select) {
-			return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
-			
-		} else {
-			SQLiteUtils.execSql(toSql(), getArguments());
-			Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mType, null), null);
-			return null;
-			
-		}
-	}
-
-	public <T extends Model> T executeSingle() {
-		if (mQueryBase instanceof Select) {
-			limit(1);
-			return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
-			
-		} else {
-			limit(1);
-			SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments()).delete();
-			return null;
-			
-		}
-	}
-	
+    public <T extends Model> List<T> execute() {
+        try {
+            if (mQueryBase instanceof Select) {
+                return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
+
+            } else {
+                SQLiteUtils.execSql(toSql(), getArguments());
+                Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mType, null), null);
+                return null;
+
+            }
+        } catch (Throwable e) {
+            Log.e("execute sql error", e);
+        }
+        return null;
+    }
+
+    public <T extends Model> T executeSingle() {
+        if (mQueryBase instanceof Select) {
+            limit(1);
+            return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
+
+        } else {
+            limit(1);
+            SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments()).delete();
+            return null;
+
+        }
+    }
+
     /**
      * Gets a value indicating whether the query returns any rows.
+     *
      * @return <code>true</code> if the query returns at least one row; otherwise, <code>false</code>.
      */
     public boolean exists() {
@@ -333,14 +339,14 @@ public int count() {
         return SQLiteUtils.intQuery(toCountSql(), getArguments());
     }
 
-	public String[] getArguments() {
-		final int size = mArguments.size();
-		final String[] args = new String[size];
+    public String[] getArguments() {
+        final int size = mArguments.size();
+        final String[] args = new String[size];
 
-		for (int i = 0; i < size; i++) {
-			args[i] = mArguments.get(i).toString();
-		}
+        for (int i = 0; i < size; i++) {
+            args[i] = mArguments.get(i).toString();
+        }
 
-		return args;
-	}
+        return args;
+    }
 }
