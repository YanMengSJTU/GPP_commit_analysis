diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 9fe01919..e8d2f920 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -29,6 +29,7 @@
 import com.activeandroid.util.SQLiteUtils;
 
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -106,47 +107,7 @@ public final Long save() {
 					}
 				}
 
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (value == null) {
-					values.putNull(fieldName);
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					values.put(fieldName, (Byte) value);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					values.put(fieldName, (Short) value);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					values.put(fieldName, (Integer) value);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					values.put(fieldName, (Long) value);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					values.put(fieldName, (Float) value);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					values.put(fieldName, (Double) value);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					values.put(fieldName, (Boolean) value);
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(String.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					values.put(fieldName, (byte[]) value);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					values.put(fieldName, ((Model) value).getId());
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					values.put(fieldName, ((Enum<?>) value).name());
-				}
+				SQLiteUtils.put(values, fieldType, fieldName, value);
 			}
 			catch (IllegalArgumentException e) {
 				Log.e(e.getClass().getName(), e);
@@ -154,6 +115,9 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 			catch (IllegalAccessException e) {
 				Log.e(e.getClass().getName(), e);
 			}
+            catch (InvocationTargetException e) {
+                Log.e(e.getClass().getName(), e);
+            }
 		}
 
 		if (mId == null) {
@@ -249,65 +213,16 @@ public final void loadFromCursor(Cursor cursor) {
 				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
 				Object value = null;
 
-				if (typeSerializer != null) {
-					fieldType = typeSerializer.getSerializedType();
-				}
+				if (!columnIsNull) {
+	                if (typeSerializer != null) {
+	                    fieldType = typeSerializer.getSerializedType();
+	                }
 
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (columnIsNull) {
-					field = null;
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					value = cursor.getLong(columnIndex);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					value = cursor.getFloat(columnIndex);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					value = cursor.getDouble(columnIndex);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					value = cursor.getInt(columnIndex) != 0;
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					value = cursor.getString(columnIndex).charAt(0);
-				}
-				else if (fieldType.equals(String.class)) {
-					value = cursor.getString(columnIndex);
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					value = cursor.getBlob(columnIndex);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					final long entityId = cursor.getLong(columnIndex);
-					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
-
-					Model entity = Cache.getEntity(entityType, entityId);
-					if (entity == null) {
-						entity = new Select().from(entityType).where(Cache.getTableInfo(entityType).getIdName()+"=?", entityId).executeSingle();
-					}
-
-					value = entity;
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					@SuppressWarnings("rawtypes")
-					final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-					value = Enum.valueOf(enumType, cursor.getString(columnIndex));
-				}
-
-				// Use a deserializer if one is available
-				if (typeSerializer != null && !columnIsNull) {
-					value = typeSerializer.deserialize(value);
+				    value = SQLiteUtils.get(cursor, fieldType, columnIndex);
+				    // Use a deserializer if one is available
+	                if (typeSerializer != null) {
+	                    value = typeSerializer.deserialize(value);
+	                }
 				}
 
 				// Set the field value
@@ -324,6 +239,9 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 			catch (SecurityException e) {
 				Log.e(e.getClass().getName(), e);
 			}
+            catch (InvocationTargetException e) {
+                Log.e(e.getClass().getName(), e);
+            }
 		}
 
 		if (mId != null) {
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index e6127743..7103280e 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -16,6 +16,13 @@
  * limitations under the License.
  */
 
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.*;
+
+import android.content.ContentValues;
 import android.database.Cursor;
 import android.os.Build;
 import android.text.TextUtils;
@@ -25,21 +32,25 @@
 import com.activeandroid.TableInfo;
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.Column.ConflictAction;
+import com.activeandroid.query.Select;
 import com.activeandroid.serializer.TypeSerializer;
 
-import java.lang.Long;
-import java.lang.String;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.util.Arrays;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
 public final class SQLiteUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
+    private static final class TypeInfo {
+        final SQLiteType type;
+        final Class<?> putClass;
+        final String cursorGetMethodName;
+        Method contentValuesPutMethod;
+        Method cursorGetMethod;
+        
+        public TypeInfo(SQLiteType type, Class<?> putClass, String cursorGetMethodName) {
+            this.type = type;
+            this.putClass = putClass;
+            this.cursorGetMethodName = cursorGetMethodName;
+        }
+    }
+    
+    //////////////////////////////////////////////////////////////////////////////////////
 	// ENUMERATIONS
 	//////////////////////////////////////////////////////////////////////////////////////
 
@@ -58,27 +69,39 @@
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
+	private static final HashMap<Class<?>, TypeInfo> TYPE_MAP = new HashMap<Class<?>, TypeInfo>() {
 		{
-			put(byte.class, SQLiteType.INTEGER);
-			put(short.class, SQLiteType.INTEGER);
-			put(int.class, SQLiteType.INTEGER);
-			put(long.class, SQLiteType.INTEGER);
-			put(float.class, SQLiteType.REAL);
-			put(double.class, SQLiteType.REAL);
-			put(boolean.class, SQLiteType.INTEGER);
-			put(char.class, SQLiteType.TEXT);
-			put(byte[].class, SQLiteType.BLOB);
-			put(Byte.class, SQLiteType.INTEGER);
-			put(Short.class, SQLiteType.INTEGER);
-			put(Integer.class, SQLiteType.INTEGER);
-			put(Long.class, SQLiteType.INTEGER);
-			put(Float.class, SQLiteType.REAL);
-			put(Double.class, SQLiteType.REAL);
-			put(Boolean.class, SQLiteType.INTEGER);
-			put(Character.class, SQLiteType.TEXT);
-			put(String.class, SQLiteType.TEXT);
-			put(Byte[].class, SQLiteType.BLOB);
+			put(byte.class, new TypeInfo(SQLiteType.INTEGER, Byte.class, "getInt"));
+			put(short.class, new TypeInfo(SQLiteType.INTEGER, Short.class, "getInt"));
+			put(int.class, new TypeInfo(SQLiteType.INTEGER, Integer.class, "getInt"));
+			put(long.class, new TypeInfo(SQLiteType.INTEGER, Long.class, "getLong"));
+			put(float.class, new TypeInfo(SQLiteType.REAL, Float.class, "getFloat"));
+			put(double.class, new TypeInfo(SQLiteType.REAL, Double.class, "getDouble"));
+			put(boolean.class, new TypeInfo(SQLiteType.INTEGER, Boolean.class, "getInt"));
+			put(char.class, new TypeInfo(SQLiteType.TEXT, String.class, "getString"));
+			put(byte[].class, new TypeInfo(SQLiteType.BLOB, byte[].class, "getBlob"));
+			put(Byte.class, new TypeInfo(SQLiteType.INTEGER, Byte.class, "getInt"));
+			put(Short.class, new TypeInfo(SQLiteType.INTEGER, Short.class, "getInt"));
+			put(Integer.class, new TypeInfo(SQLiteType.INTEGER, Integer.class, "getInt"));
+			put(Long.class, new TypeInfo(SQLiteType.INTEGER, Long.class, "getLong"));
+			put(Float.class, new TypeInfo(SQLiteType.REAL, Float.class, "getFloat"));
+			put(Double.class, new TypeInfo(SQLiteType.REAL, Double.class, "getDouble"));
+			put(Boolean.class, new TypeInfo(SQLiteType.INTEGER, Boolean.class, "getInt"));
+			put(Character.class, new TypeInfo(SQLiteType.TEXT, String.class, "getString"));
+			put(String.class, new TypeInfo(SQLiteType.TEXT, String.class, "getString"));
+			put(Byte[].class, new TypeInfo(SQLiteType.BLOB, byte[].class, "getBlob"));
+			
+			
+			for (Map.Entry<Class<?>, TypeInfo> e : entrySet()) {
+			    TypeInfo t = e.getValue();
+			    try {
+			        t.cursorGetMethod = Cursor.class.getMethod(t.cursorGetMethodName, Integer.class);
+			        t.contentValuesPutMethod = ContentValues.class.getMethod("put", String.class, t.putClass);
+			    }
+			    catch (NoSuchMethodException ex) {
+			        throw new RuntimeException(ex);
+			    }
+			}
 		}
 	};
 
@@ -94,6 +117,64 @@
 	// PUBLIC METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
+	public static void put(ContentValues values, Class<?> fieldType, String fieldName, Object value) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
+	    if (value == null) {
+            values.putNull(fieldName);
+        }
+        else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+            values.put(fieldName, value.toString());
+        }
+        else {
+            TypeInfo typeInfo = TYPE_MAP.get(fieldType);
+            if (typeInfo != null) {
+                typeInfo.contentValuesPutMethod.invoke(values, fieldName, typeInfo.putClass.cast(value));
+            }
+            else if (ReflectionUtils.isModel(fieldType)) {
+                values.put(fieldName, ((Model) value).getId());
+            }
+            else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                values.put(fieldName, ((Enum<?>) value).name());
+            }   
+        }
+	}
+	
+	public static Object get(Cursor cursor, Class<?> fieldType, int columnIndex) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
+	    if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+	        return cursor.getInt(columnIndex) != 0;
+	    }
+	    
+	    if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+            return cursor.getString(columnIndex).charAt(0);
+        }
+	    
+	    TypeInfo typeInfo = TYPE_MAP.get(fieldType);
+	    if (typeInfo != null)
+	        return typeInfo.cursorGetMethod.invoke(cursor, columnIndex);
+	    
+        if (ReflectionUtils.isModel(fieldType)) {
+            final long entityId = cursor.getLong(columnIndex);
+            @SuppressWarnings("unchecked")
+            final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
+
+            Model entity = Cache.getEntity(entityType, entityId);
+            if (entity == null) {
+                entity = new Select().from(entityType).where(Cache.getTableInfo(entityType).getIdName()+"=?", entityId).executeSingle();
+            }
+
+            return entity;
+        }
+        
+        if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+            @SuppressWarnings({"rawtypes", "unchecked"})
+            final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+            @SuppressWarnings("unchecked")
+            Object o = Enum.valueOf(enumType, cursor.getString(columnIndex));
+            return o;
+        }
+	    
+	    return null;
+	}
+	
 	public static void execSql(String sql) {
 		Cache.openDatabase().execSQL(sql);
 	}
