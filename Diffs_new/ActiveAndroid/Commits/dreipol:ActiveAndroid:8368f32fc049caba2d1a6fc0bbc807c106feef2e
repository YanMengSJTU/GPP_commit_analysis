diff --git a/README.md b/README.md
index 2e7c9e4d..7ba14fba 100644
--- a/README.md
+++ b/README.md
@@ -5,26 +5,6 @@ ActiveAndroid is an active record style ORM ([object relational mapper](http://e
 
 ActiveAndroid does so much more than this though. Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration.
 
-## Download
-
-Grab via Maven:
-```xml
-<dependency>
-  <groupId>com.michaelpardo</groupId>
-  <artifactId>activeandroid</artifactId>
-  <version>3.1.0-SNAPSHOT</version>
-</dependency>
-```
-or Gradle:
-```groovy
-repositories {
-    mavenCentral()
-    maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
-}
-
-compile 'com.michaelpardo:activeandroid:3.1.0-SNAPSHOT'
-```
-
 ## Documentation
 
 * [Getting started](http://github.com/pardom/ActiveAndroid/wiki/Getting-started)
diff --git a/build.gradle b/build.gradle
index 5594e43b..8e6986f2 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,8 +1,9 @@
 apply plugin: 'java'
-apply from: 'gradle-mvn-push.gradle'
 
-targetCompatibility = '1.6'
-sourceCompatibility = '1.6'
+sourceCompatibility = 1.6
+
+jar.baseName = 'activeandroid'
+archivesBaseName = 'activeandroid'
 
 sourceSets {
 	main {
@@ -15,3 +16,12 @@ sourceSets {
 dependencies {
 	compile fileTree(dir: 'libs', include: '*.jar')
 }
+
+task sourcesJar(type: Jar) {
+    classifier = 'sources'
+    from sourceSets.main.allSource
+}
+
+artifacts {
+    archives sourcesJar
+}
\ No newline at end of file
diff --git a/src/com/activeandroid/Computed.java b/src/com/activeandroid/Computed.java
new file mode 100644
index 00000000..fba81c55
--- /dev/null
+++ b/src/com/activeandroid/Computed.java
@@ -0,0 +1,15 @@
+package com.activeandroid;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Created by melbic on 16/09/14.
+ */
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Computed {
+    public String name() default "";
+}
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 2dbb0492..a4f3a8cb 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -81,7 +81,7 @@ public final Long save() {
         final SQLiteDatabase db = Cache.openDatabase();
         final ContentValues values = new ContentValues();
 
-        for (Field field : mTableInfo.getFields()) {
+        for (Field field : mTableInfo.getColumnFields()) {
             final String fieldName = mTableInfo.getColumnName(field);
             Class<?> fieldType = field.getType();
 
@@ -196,8 +196,8 @@ public final void loadFromCursor(Cursor cursor) {
          * when the cursor have multiple columns with same name obtained from join tables.
          */
         List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-        for (Field field : mTableInfo.getFields()) {
-            final String fieldName = mTableInfo.getColumnName(field);
+        for (Field field : mTableInfo.getAllFields()) {
+            final String fieldName = mTableInfo.getDatabaseName(field);
             Class<?> fieldType = field.getType();
             final int columnIndex = columnsOrdered.indexOf(fieldName);
 
@@ -326,7 +326,7 @@ public int hashCode() {
      * @throws IllegalUniqueIdentifierException
      * @throws ModelUpdateException
      */
-    public static <T extends Model> T createOrUpdate(T object) throws IllegalUniqueIdentifierException, ModelUpdateException {
+    public static <T extends Model> ModelSaveResult<T> createOrUpdate(T object) throws IllegalUniqueIdentifierException, ModelUpdateException {
         Class<? extends Model> objectClass = object.getClass();
         TableInfo info = Cache.getTableInfo(objectClass);
         String uniqueIdentifier = info.getUniqueIdentifier();
@@ -343,16 +343,18 @@ public int hashCode() {
             throw new IllegalUniqueIdentifierException("Couldn't get the specified unique identifier", e);
         }
         List<Model> modelsToBeDeleted = new ArrayList<Model>();
-        if (entity != null) {
+        boolean isNew = entity == null;
+        if (!isNew) {
             modelsToBeDeleted = entity.updateWith(object);
         } else {
             entity = object;
         }
+        ModelSaveResult<T> result = new ModelSaveResult<T>(entity, isNew);
         entity.save();
         for (Model m : modelsToBeDeleted) {
             m.delete();
         }
-        return entity;
+        return result;
     }
 
     /**
@@ -369,7 +371,7 @@ public int hashCode() {
         ArrayList<Model> entitiesToBeDeleted = new ArrayList<Model>();
         if (myClass.isAssignableFrom(otherClass)) {
             fieldloop:
-            for (Field field : Cache.getTableInfo(myClass).getFields()) {
+            for (Field field : Cache.getTableInfo(myClass).getColumnFields()) {
                 field.setAccessible(true);
                 try {
                     Object newValue = field.get(other);
@@ -386,7 +388,7 @@ public int hashCode() {
                             break;
                         case UPDATE:
                             if (ModelUtils.isForeignKey(field)) {
-                                newValue = Model.createOrUpdate((Model) newValue);
+                                newValue = Model.createOrUpdate((Model) newValue).getEntity();
                             }
                             break;
 
@@ -394,6 +396,8 @@ public int hashCode() {
                     field.set(this, newValue);
                 } catch (IllegalAccessException e) {
                     throw new ModelUpdateException("The update of field: " + field.getName() + "was not possible.", e);
+                } catch (IllegalArgumentException e) {
+                    throw new ModelUpdateException("The update of field: " + field.getName() + "was not possible.", e);
                 }
             }
         }
diff --git a/src/com/activeandroid/ModelSaveResult.java b/src/com/activeandroid/ModelSaveResult.java
new file mode 100644
index 00000000..3c753e85
--- /dev/null
+++ b/src/com/activeandroid/ModelSaveResult.java
@@ -0,0 +1,25 @@
+package com.activeandroid;
+
+/**
+ * Created by melbic on 20/10/14.
+ */
+public class ModelSaveResult<T extends Model> {
+    private T mEntity;
+    private boolean mIsNew;
+
+    public ModelSaveResult(T entity, boolean isNew) {
+
+        mEntity = entity;
+        mIsNew = isNew;
+    }
+
+    public T getEntity() {
+        return mEntity;
+    }
+
+    public boolean isNew() {
+        return mIsNew;
+    }
+
+
+}
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/TableInfo.java
index 36fa30cd..bedd2107 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/src/com/activeandroid/TableInfo.java
@@ -19,6 +19,7 @@
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -46,6 +47,7 @@
 
     private String mUniqueIdentifier = Table.DEFAULT_ID_NAME;
     private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
+    private Map<Field, String> mComputedNames = new LinkedHashMap<Field, String>();
 
     //////////////////////////////////////////////////////////////////////////////////////
     // CONSTRUCTORS
@@ -91,6 +93,13 @@ public TableInfo(Class<? extends Model> type) {
                 }
 
                 mColumnNames.put(field, columnName);
+            } else if (field.isAnnotationPresent(Computed.class)) {
+                final Computed columnAnnotation = field.getAnnotation(Computed.class);
+                String name = columnAnnotation.name();
+                if (TextUtils.isEmpty(name)) {
+                    name = namingStrategy.translateName(field);
+                }
+                mComputedNames.put(field, name);
             }
         }
 
@@ -112,14 +121,35 @@ public String getIdName() {
         return mIdName;
     }
 
+    @Deprecated
     public Collection<Field> getFields() {
+        return getColumnFields();
+    }
+
+    public Collection<Field> getColumnFields() {
         return mColumnNames.keySet();
     }
 
+    /**
+     * @return Fields used as columns (@Column) and fields which can be computed (@Computed)
+     */
+    public Collection<Field> getAllFields() {
+        HashSet<Field> fields = new HashSet<Field>(mColumnNames.keySet());
+        fields.addAll(mComputedNames.keySet());
+        return fields;
+    }
+
     public String getColumnName(Field field) {
         return mColumnNames.get(field);
     }
 
+    public String getDatabaseName(Field field) {
+        String name = mColumnNames.get(field);
+        if (name == null) {
+            name = mComputedNames.get(field);
+        }
+        return name;
+    }
 
     private Field getIdField(Class<?> type) {
         if (type.equals(Model.class)) {
diff --git a/src/com/activeandroid/util/ReflectionUtils.java b/src/com/activeandroid/util/ReflectionUtils.java
index 32e995cc..1f4035f2 100644
--- a/src/com/activeandroid/util/ReflectionUtils.java
+++ b/src/com/activeandroid/util/ReflectionUtils.java
@@ -28,6 +28,7 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 
+import com.activeandroid.Computed;
 import com.activeandroid.Model;
 import com.activeandroid.annotation.Column;
 import com.activeandroid.serializer.TypeSerializer;
@@ -78,7 +79,7 @@ public int compare(Field field1, Field field2) {
 				}
 			});
 			for (Field field : fields) {
-				if (field.isAnnotationPresent(Column.class)) {
+				if (field.isAnnotationPresent(Column.class) || field.isAnnotationPresent(Computed.class)){
 					declaredColumnFields.add(field);
 				}
 			}
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index ddf47708..f45a5cb5 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -118,6 +118,14 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
         return number;
 	}
 
+    public static long longQuery(final String sql, final String[] selectionArgs) {
+        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+        final long number = processLongCursor(cursor);
+        cursor.close();
+
+        return number;
+    }
+
 	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
 		List<T> entities = rawQuery(type, sql, selectionArgs);
 
@@ -135,7 +143,7 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
 		sUniqueGroupMap = new HashMap<String, List<String>>();
 		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
 
-		for (Field field : tableInfo.getFields()) {
+		for (Field field : tableInfo.getColumnFields()) {
 			createUniqueColumnDefinition(tableInfo, field);
 		}
 
@@ -190,7 +198,7 @@ public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field
 		final ArrayList<String> definitions = new ArrayList<String>();
 		sIndexGroupMap = new HashMap<String, List<String>>();
 
-		for (Field field : tableInfo.getFields()) {
+		for (Field field : tableInfo.getColumnFields()) {
 			createIndexColumnDefinition(tableInfo, field);
 		}
 
@@ -239,7 +247,7 @@ public static void createIndexColumnDefinition(TableInfo tableInfo, Field field)
 	public static String createTableDefinition(TableInfo tableInfo) {
 		final ArrayList<String> definitions = new ArrayList<String>();
 
-		for (Field field : tableInfo.getFields()) {
+		for (Field field : tableInfo.getColumnFields()) {
 			String definition = createColumnDefinition(tableInfo, field);
 			if (!TextUtils.isEmpty(definition)) {
 				definitions.add(definition);
@@ -373,6 +381,13 @@ private static int processIntCursor(final Cursor cursor) {
         return 0;
     }
 
+    private static long processLongCursor(final Cursor cursor) {
+        if (cursor.moveToFirst()) {
+            return cursor.getLong(0);
+        }
+        return 0;
+    }
+
 	public static List<String> lexSqlScript(String sqlScript) {
 		ArrayList<String> sl = new ArrayList<String>();
 		boolean inString = false, quoteNext = false;
diff --git a/src/com/activeandroid/widget/ModelAdapter.java b/src/com/activeandroid/widget/ModelAdapter.java
index a3895763..70e59913 100644
--- a/src/com/activeandroid/widget/ModelAdapter.java
+++ b/src/com/activeandroid/widget/ModelAdapter.java
@@ -27,8 +27,8 @@ public ModelAdapter(Context context, int resource, int textViewResourceId, List<
 
 	/**
 	 * Clears the adapter and, if data != null, fills if with new Items.
-	 *
-	 * @param collection A Collection&lt;? extends T&gt; which members get added to the adapter.
+	 * 
+	 * @param collection A Collection<? extends T> which members get added to the adapter.
 	 */
 	public void setData(Collection<? extends T> collection) {
 		clear();
@@ -54,4 +54,4 @@ public long getItemId(int position) {
 			return -1;
 		}
 	}
-}
+}
\ No newline at end of file
diff --git a/tests/src/com/activeandroid/test/ModelTest.java b/tests/src/com/activeandroid/test/ModelTest.java
index e66690d8..a4725041 100644
--- a/tests/src/com/activeandroid/test/ModelTest.java
+++ b/tests/src/com/activeandroid/test/ModelTest.java
@@ -139,7 +139,7 @@ public void testHashCodeDifferentRows() {
     public void testColumnNamesDefaulToFieldNames() {
         TableInfo tableInfo = Cache.getTableInfo(MockModel.class);
 
-        for ( Field field : tableInfo.getFields() ) {
+        for ( Field field : tableInfo.getColumnFields() ) {
             // Id column is a special case, we'll ignore that one.
             if ( field.getName().equals("mId") ) continue;
 
