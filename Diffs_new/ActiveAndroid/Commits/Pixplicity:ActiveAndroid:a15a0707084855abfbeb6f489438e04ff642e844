diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
index 6495e379..68c88f57 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -16,8 +16,6 @@
  * limitations under the License.
  */
 
-import java.util.Collection;
-
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.support.v4.util.LruCache;
@@ -25,6 +23,8 @@
 import com.activeandroid.serializer.TypeSerializer;
 import com.activeandroid.util.Log;
 
+import java.util.Collection;
+
 public final class Cache {
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC CONSTANTS
@@ -153,6 +153,10 @@ public static synchronized TypeSerializer getParserForType(Class<?> type) {
 	}
 
 	public static synchronized String getTableName(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type).getTableName();
+		TableInfo tableInfo = sModelInfo.getTableInfo(type);
+		if (tableInfo == null) {
+			throw new NullPointerException("No table info for " + type + "; have you added the model to your manifest?");
+		}
+		return tableInfo.getTableName();
 	}
 }
diff --git a/src/com/activeandroid/ModelInfo.java b/src/com/activeandroid/ModelInfo.java
index fb8ccc0a..79d74114 100644
--- a/src/com/activeandroid/ModelInfo.java
+++ b/src/com/activeandroid/ModelInfo.java
@@ -16,6 +16,16 @@
  * limitations under the License.
  */
 
+import android.content.Context;
+
+import com.activeandroid.serializer.CalendarSerializer;
+import com.activeandroid.serializer.FileSerializer;
+import com.activeandroid.serializer.SqlDateSerializer;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.serializer.UtilDateSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
+
 import java.io.File;
 import java.io.IOException;
 import java.net.URL;
@@ -27,186 +37,169 @@
 import java.util.List;
 import java.util.Map;
 
-import android.content.Context;
-
-import com.activeandroid.serializer.CalendarSerializer;
-import com.activeandroid.serializer.SqlDateSerializer;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.serializer.UtilDateSerializer;
-import com.activeandroid.serializer.FileSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
 import dalvik.system.DexFile;
 
 final class ModelInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Map<Class<? extends Model>, TableInfo> mTableInfos = new HashMap<Class<? extends Model>, TableInfo>();
-	private Map<Class<?>, TypeSerializer> mTypeSerializers = new HashMap<Class<?>, TypeSerializer>() {
-		{
-			put(Calendar.class, new CalendarSerializer());
-			put(java.sql.Date.class, new SqlDateSerializer());
-			put(java.util.Date.class, new UtilDateSerializer());
-			put(java.io.File.class, new FileSerializer());
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public ModelInfo(Configuration configuration) {
-		if (!loadModelFromMetaData(configuration)) {
-			try {
-				scanForModel(configuration.getContext());
-			}
-			catch (IOException e) {
-				Log.e("Couldn't open source path.", e);
-			}
-		}
-
-		Log.i("ModelInfo loaded.");
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Collection<TableInfo> getTableInfos() {
-		return mTableInfos.values();
-	}
-
-	public TableInfo getTableInfo(Class<? extends Model> type) {
-		return mTableInfos.get(type);
-	}
-
-	public TypeSerializer getTypeSerializer(Class<?> type) {
-		return mTypeSerializers.get(type);
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private boolean loadModelFromMetaData(Configuration configuration) {
-		if (!configuration.isValid()) {
-			return false;
-		}
-
-		final List<Class<? extends Model>> models = configuration.getModelClasses();
-		if (models != null) {
-			for (Class<? extends Model> model : models) {
-				mTableInfos.put(model, new TableInfo(model));
-			}
-		}
-
-		final List<Class<? extends TypeSerializer>> typeSerializers = configuration.getTypeSerializers();
-		if (typeSerializers != null) {
-			for (Class<? extends TypeSerializer> typeSerializer : typeSerializers) {
-				try {
-					TypeSerializer instance = typeSerializer.newInstance();
-					mTypeSerializers.put(instance.getDeserializedType(), instance);
-				}
-				catch (InstantiationException e) {
-					Log.e("Couldn't instantiate TypeSerializer.", e);
-				}
-				catch (IllegalAccessException e) {
-					Log.e("IllegalAccessException", e);
-				}
-			}
-		}
-
-		return true;
-	}
-
-	private void scanForModel(Context context) throws IOException {
-		String packageName = context.getPackageName();
-		String sourcePath = context.getApplicationInfo().sourceDir;
-		List<String> paths = new ArrayList<String>();
-
-		if (sourcePath != null && !(new File(sourcePath).isDirectory())) {
-			DexFile dexfile = new DexFile(sourcePath);
-			Enumeration<String> entries = dexfile.entries();
-
-			while (entries.hasMoreElements()) {
-				paths.add(entries.nextElement());
-			}
-		}
-		// Robolectric fallback
-		else {
-			ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-			Enumeration<URL> resources = classLoader.getResources("");
-
-			while (resources.hasMoreElements()) {
-				String path = resources.nextElement().getFile();
-				if (path.contains("bin") || path.contains("classes")) {
-					paths.add(path);
-				}
-			}
-		}
-
-		for (String path : paths) {
-			File file = new File(path);
-			scanForModelClasses(file, packageName, context.getClassLoader());
-		}
-	}
-
-	private void scanForModelClasses(File path, String packageName, ClassLoader classLoader) {
-		if (path.isDirectory()) {
-			for (File file : path.listFiles()) {
-				scanForModelClasses(file, packageName, classLoader);
-			}
-		}
-		else {
-			String className = path.getName();
-
-			// Robolectric fallback
-			if (!path.getPath().equals(className)) {
-				className = path.getPath();
-
-				if (className.endsWith(".class")) {
-					className = className.substring(0, className.length() - 6);
-				}
-				else {
-					return;
-				}
-
-				className = className.replace(System.getProperty("file.separator"), ".");
-
-				int packageNameIndex = className.lastIndexOf(packageName);
-				if (packageNameIndex < 0) {
-					return;
-				}
-
-				className = className.substring(packageNameIndex);
-			}
-
-			try {
-				Class<?> discoveredClass = Class.forName(className, false, classLoader);
-				if (ReflectionUtils.isModel(discoveredClass)) {
-					@SuppressWarnings("unchecked")
-					Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
-					mTableInfos.put(modelClass, new TableInfo(modelClass));
-				}
-				else if (ReflectionUtils.isTypeSerializer(discoveredClass)) {
-					TypeSerializer instance = (TypeSerializer) discoveredClass.newInstance();
-					mTypeSerializers.put(instance.getDeserializedType(), instance);
-				}
-			}
-			catch (ClassNotFoundException e) {
-				Log.e("Couldn't create class.", e);
-			}
-			catch (InstantiationException e) {
-				Log.e("Couldn't instantiate TypeSerializer.", e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e("IllegalAccessException", e);
-			}
-            catch (IncompatibleClassChangeError e) {
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Map<Class<? extends Model>, TableInfo> mTableInfos = new HashMap<Class<? extends Model>, TableInfo>();
+    private Map<Class<?>, TypeSerializer> mTypeSerializers = new HashMap<Class<?>, TypeSerializer>() {
+        {
+            put(Calendar.class, new CalendarSerializer());
+            put(java.sql.Date.class, new SqlDateSerializer());
+            put(java.util.Date.class, new UtilDateSerializer());
+            put(java.io.File.class, new FileSerializer());
+        }
+    };
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public ModelInfo(Configuration configuration) {
+        if (!loadModelFromMetaData(configuration)) {
+            try {
+                scanForModel(configuration.getContext());
+            } catch (IOException e) {
+                Log.e("Couldn't open source path.", e);
+            }
+        }
+
+        Log.i("ModelInfo loaded.");
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Collection<TableInfo> getTableInfos() {
+        return mTableInfos.values();
+    }
+
+    public TableInfo getTableInfo(Class<? extends Model> type) {
+        return mTableInfos.get(type);
+    }
+
+    public TypeSerializer getTypeSerializer(Class<?> type) {
+        return mTypeSerializers.get(type);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private boolean loadModelFromMetaData(Configuration configuration) {
+        if (!configuration.isValid()) {
+            return false;
+        }
+
+        final List<Class<? extends Model>> models = configuration.getModelClasses();
+        if (models != null) {
+            for (Class<? extends Model> model : models) {
+                mTableInfos.put(model, new TableInfo(model));
+            }
+        }
+
+        final List<Class<? extends TypeSerializer>> typeSerializers = configuration.getTypeSerializers();
+        if (typeSerializers != null) {
+            for (Class<? extends TypeSerializer> typeSerializer : typeSerializers) {
+                try {
+                    TypeSerializer instance = typeSerializer.newInstance();
+                    mTypeSerializers.put(instance.getDeserializedType(), instance);
+                } catch (InstantiationException e) {
+                    Log.e("Couldn't instantiate TypeSerializer.", e);
+                } catch (IllegalAccessException e) {
+                    Log.e("IllegalAccessException", e);
+                } catch (IncompatibleClassChangeError e) {
+                    Log.e("IncompatibleClassChangeError", e);
+                }
+            }
+        }
+
+        return true;
+    }
+
+    private void scanForModel(Context context) throws IOException {
+        String packageName = context.getPackageName();
+        String sourcePath = context.getApplicationInfo().sourceDir;
+        List<String> paths = new ArrayList<String>();
+
+        if (sourcePath != null && !(new File(sourcePath).isDirectory())) {
+            DexFile dexfile = new DexFile(sourcePath);
+            Enumeration<String> entries = dexfile.entries();
+
+            while (entries.hasMoreElements()) {
+                paths.add(entries.nextElement());
+            }
+        }
+        // Robolectric fallback
+        else {
+            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+            Enumeration<URL> resources = classLoader.getResources("");
+
+            while (resources.hasMoreElements()) {
+                String path = resources.nextElement().getFile();
+                if (path.contains("bin") || path.contains("classes")) {
+                    paths.add(path);
+                }
+            }
+        }
+
+        for (String path : paths) {
+            File file = new File(path);
+            scanForModelClasses(file, packageName, context.getClassLoader());
+        }
+    }
+
+    private void scanForModelClasses(File path, String packageName, ClassLoader classLoader) {
+        if (path.isDirectory()) {
+            for (File file : path.listFiles()) {
+                scanForModelClasses(file, packageName, classLoader);
+            }
+        } else {
+            String className = path.getName();
+
+            // Robolectric fallback
+            if (!path.getPath().equals(className)) {
+                className = path.getPath();
+
+                if (className.endsWith(".class")) {
+                    className = className.substring(0, className.length() - 6);
+                } else {
+                    return;
+                }
+
+                className = className.replace(System.getProperty("file.separator"), ".");
+
+                int packageNameIndex = className.lastIndexOf(packageName);
+                if (packageNameIndex < 0) {
+                    return;
+                }
+
+                className = className.substring(packageNameIndex);
+            }
+
+            try {
+                Class<?> discoveredClass = Class.forName(className, false, classLoader);
+                if (ReflectionUtils.isModel(discoveredClass)) {
+                    @SuppressWarnings("unchecked")
+                    Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
+                    mTableInfos.put(modelClass, new TableInfo(modelClass));
+                } else if (ReflectionUtils.isTypeSerializer(discoveredClass)) {
+                    TypeSerializer instance = (TypeSerializer) discoveredClass.newInstance();
+                    mTypeSerializers.put(instance.getDeserializedType(), instance);
+                }
+            } catch (ClassNotFoundException e) {
+                Log.e("Couldn't create class.", e);
+            } catch (InstantiationException e) {
+                Log.e("Couldn't instantiate TypeSerializer.", e);
+            } catch (IllegalAccessException e) {
+                Log.e("IllegalAccessException", e);
+            } catch (IncompatibleClassChangeError e) {
                 Log.e("IncompatibleClassChangeError", e);
             }
-		}
-	}
+        }
+    }
 }
diff --git a/src/com/activeandroid/content/ContentProvider.java b/src/com/activeandroid/content/ContentProvider.java
index b4a841d6..a0073eeb 100644
--- a/src/com/activeandroid/content/ContentProvider.java
+++ b/src/com/activeandroid/content/ContentProvider.java
@@ -1,8 +1,5 @@
 package com.activeandroid.content;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import android.content.ContentValues;
 import android.content.UriMatcher;
 import android.database.Cursor;
@@ -15,6 +12,10 @@
 import com.activeandroid.Model;
 import com.activeandroid.TableInfo;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
 public class ContentProvider extends android.content.ContentProvider {
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE CONSTANTS
@@ -47,11 +48,11 @@ public boolean onCreate() {
 			final int itemKey = (i * 2) + 2;
 
 			// content://<authority>/<table>
-			URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase(), tableKey);
+			URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase(Locale.ENGLISH), tableKey);
 			TYPE_CODES.put(tableKey, tableInfo.getType());
 
 			// content://<authority>/<table>/<id>
-			URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase() + "/#", itemKey);
+			URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase(Locale.ENGLISH) + "/#", itemKey);
 			TYPE_CODES.put(itemKey, tableInfo.getType());
 		}
 
@@ -93,6 +94,9 @@ public String getType(Uri uri) {
 	@Override
 	public Uri insert(Uri uri, ContentValues values) {
 		final Class<? extends Model> type = getModelType(uri);
+		if (type == null) {
+			throw new NullPointerException("Uri " + uri + " did not resolve to a model; have you added the model to your manifest?");
+		}
 		final Long id = Cache.openDatabase().insert(Cache.getTableName(type), null, values);
 
 		if (id != null && id > 0) {
@@ -108,6 +112,9 @@ public Uri insert(Uri uri, ContentValues values) {
 	@Override
 	public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
 		final Class<? extends Model> type = getModelType(uri);
+		if (type == null) {
+			throw new NullPointerException("Uri " + uri + " did not resolve to a model; have you added the model to your manifest?");
+		}
 		final int count = Cache.openDatabase().update(Cache.getTableName(type), values, selection, selectionArgs);
 
 		notifyChange(uri);
@@ -118,6 +125,9 @@ public int update(Uri uri, ContentValues values, String selection, String[] sele
 	@Override
 	public int delete(Uri uri, String selection, String[] selectionArgs) {
 		final Class<? extends Model> type = getModelType(uri);
+		if (type == null) {
+			throw new NullPointerException("Uri " + uri + " did not resolve to a model; have you added the model to your manifest?");
+		}
 		final int count = Cache.openDatabase().delete(Cache.getTableName(type), selection, selectionArgs);
 
 		notifyChange(uri);
@@ -128,6 +138,9 @@ public int delete(Uri uri, String selection, String[] selectionArgs) {
 	@Override
 	public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
 		final Class<? extends Model> type = getModelType(uri);
+		if (type == null) {
+			throw new NullPointerException("Uri " + uri + " did not resolve to a model; have you added the model to your manifest?");
+		}
 		final Cursor cursor = Cache.openDatabase().query(
 				Cache.getTableName(type),
 				projection,
@@ -151,7 +164,7 @@ public static Uri createUri(Class<? extends Model> type, Long id) {
 		uri.append("content://");
 		uri.append(sAuthority);
 		uri.append("/");
-		uri.append(Cache.getTableName(type).toLowerCase());
+		uri.append(Cache.getTableName(type).toLowerCase(Locale.ENGLISH));
 
 		if (id != null) {
 			uri.append("/");
