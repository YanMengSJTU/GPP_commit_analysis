diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index 792d2286..1672cacb 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -16,10 +16,6 @@
  * limitations under the License.
  */
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.util.*;
-
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.os.Build;
@@ -29,10 +25,16 @@
 import com.activeandroid.Model;
 import com.activeandroid.TableInfo;
 import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Column.ConflictAction;
+import com.activeandroid.annotation.Index;
 import com.activeandroid.query.Select;
 import com.activeandroid.serializer.TypeSerializer;
 
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
 public final class SQLiteUtils {
     private static final int TYPE_BYTE = 0;
     private static final int TYPE_SHORT = 1;
@@ -98,14 +100,6 @@ public TypeInfo(SQLiteType type, int typeFlag) {
         }
     };
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static HashMap<String, List<String>> sIndexGroupMap;
-	private static HashMap<String, List<String>> sUniqueGroupMap;
-	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
-
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -244,110 +238,69 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
 
 	// Database creation
 
-	public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
+	public static List<String> createUniqueDefinitions(TableInfo tableInfo) {
 		final ArrayList<String> definitions = new ArrayList<String>();
-		sUniqueGroupMap = new HashMap<String, List<String>>();
-		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
-
-		for (Field field : tableInfo.getFields()) {
-			createUniqueColumnDefinition(tableInfo, field);
-		}
-
-		if (sUniqueGroupMap.isEmpty()) {
-			return definitions;
-		}
-
-		Set<String> keySet = sUniqueGroupMap.keySet();
-		for (String key : keySet) {
-			List<String> group = sUniqueGroupMap.get(key);
-			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
+        final String tableName = tableInfo.getTableName();
+
+        for (Field field : tableInfo.getFields()){
+            Column column = field.getAnnotation(Column.class);
+            if (!column.unique() || field.getName().equals("mId"))
+                continue;
+            String columnName = tableInfo.getColumnName(field);
+            definitions.add(
+                String.format("CONSTRAINT unique_%s_%s UNIQUE (%s) ON CONFLICT %s",
+                              tableName, columnName,
+                              columnName,
+                              column.onUniqueConflict().toString()));
+        }
 
-			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
-					TextUtils.join(", ", group), conflictAction.toString()));
-		}
+        final Index[] indexes = tableInfo.getIndexes();
+        int indexIndex = 0;
+        for (Index index : indexes) {
+            if (!index.unique())
+                continue;
+            String indexName = TextUtils.isEmpty(index.name()) ? String.valueOf(indexIndex) : index.name();
+            definitions.add(
+                String.format("CONSTRAINT unique_%s_%s UNIQUE (%s) ON CONFLICT %s",
+                              tableName, indexName,
+                              TextUtils.join(", ", index.columns()),
+                              index.onUniqueConflict().toString()));
+            indexIndex++;
+        }
 
 		return definitions;
 	}
 
-	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
-
-        if (field.getName().equals("mId")) {
-            return;
+	public static List<String> createIndexDefinitions(TableInfo tableInfo) {
+        final ArrayList<String> definitions = new ArrayList<String>();
+        final String tableName = tableInfo.getTableName();
+
+        for (Field field : tableInfo.getFields()){
+            Column column = field.getAnnotation(Column.class);
+            if (!column.index() || field.getName().equals("mId"))
+                continue;
+            String columnName = tableInfo.getColumnName(field);
+            definitions.add(String.format("CREATE INDEX IF NOT EXISTS index_%s_%s on %s(%s);",
+                                          tableInfo.getTableName(), columnName,
+                                          tableName,
+                                          columnName));
         }
 
-		String[] groups = column.uniqueGroups();
-		ConflictAction[] conflictActions = column.onUniqueConflicts();
-		if (groups.length != conflictActions.length)
-			return;
-
-		for (int i = 0; i < groups.length; i++) {
-			String group = groups[i];
-			ConflictAction conflictAction = conflictActions[i];
-
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sUniqueGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-			list.add(name);
-
-			sUniqueGroupMap.put(group, list);
-			sOnUniqueConflictsMap.put(group, conflictAction);
-		}
-	}
-
-	public static String[] createIndexDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sIndexGroupMap = new HashMap<String, List<String>>();
-
-		for (Field field : tableInfo.getFields()) {
-			createIndexColumnDefinition(tableInfo, field);
-		}
-
-		if (sIndexGroupMap.isEmpty()) {
-			return new String[0];
-		}
-
-		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
-			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
-					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
-					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
-		}
-
-		return definitions.toArray(new String[definitions.size()]);
-	}
-
-	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
-
-        if (field.getName().equals("mId")) {
-            return;
+        final Index[] indexes = tableInfo.getIndexes();
+        int indexIndex = 0;
+        for (Index index : indexes){
+            // create unique constraints in table def instead.
+            if (index.unique())
+                continue;
+            String indexName = TextUtils.isEmpty(index.name()) ? String.valueOf(indexIndex) : index.name();
+            definitions.add(String.format("CREATE INDEX IF NOT EXISTS index_%s_%s on %s(%s);",
+                                          tableInfo.getTableName(), indexName,
+                                          tableName,
+                                          TextUtils.join(", ", index.columns())));
+            indexIndex++;
         }
 
-		if (column.index()) {
-			List<String> list = new ArrayList<String>();
-			list.add(name);
-			sIndexGroupMap.put(name, list);
-		}
-
-		String[] groups = column.indexGroups();
-		for (String group : groups) {
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sIndexGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-
-			list.add(name);
-			sIndexGroupMap.put(group, list);
-		}
+        return definitions;
 	}
 
 	public static String createTableDefinition(TableInfo tableInfo) {
@@ -360,10 +313,13 @@ public static String createTableDefinition(TableInfo tableInfo) {
 			}
 		}
 
-		definitions.addAll(createUniqueDefinition(tableInfo));
+		definitions.addAll(createUniqueDefinitions(tableInfo));
 
-		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
-				TextUtils.join(", ", definitions));
+		return String.format(
+            "CREATE TABLE IF NOT EXISTS %s (\n%s);",
+            tableInfo.getTableName(),
+            TextUtils.join(",\n", definitions)
+        );
 	}
 
 	@SuppressWarnings("unchecked")
@@ -421,7 +377,7 @@ else if (Enum.class.isAssignableFrom(type)){
 			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
 				definition.append(" REFERENCES ");
 				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
-				definition.append("("+tableInfo.getIdName()+")");
+				definition.append("(").append(tableInfo.getIdName()).append(")");
 				definition.append(" ON DELETE ");
 				definition.append(column.onDelete().toString().replace("_", " "));
 				definition.append(" ON UPDATE ");
