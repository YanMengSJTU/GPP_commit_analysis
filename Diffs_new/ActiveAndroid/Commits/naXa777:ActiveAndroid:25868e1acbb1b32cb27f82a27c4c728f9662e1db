diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
index c8b8e729..c86f8ee5 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -45,13 +45,6 @@
 
 	private static boolean sIsInitialized = false;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Cache() {
-	}
-
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 3226a5ba..c6578438 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -20,7 +20,6 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 
-import com.activeandroid.annotation.Column;
 import com.activeandroid.content.ContentProvider;
 import com.activeandroid.query.Delete;
 import com.activeandroid.query.Select;
@@ -29,29 +28,35 @@
 import com.activeandroid.util.ReflectionUtils;
 
 import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 @SuppressWarnings("unchecked")
 public abstract class Model {
+
+    /** Prime number used for hashcode() implementation. */
+    private static final int HASH_PRIME = 739;
+
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	@Column(name = "Id")
-	public Long id = null;
+	protected Long id = null;
 
     // This is the ID, that is currently stored in the database. By keeping the id redundant,
     // it is possible to change the Id of an entity.
     private Long mPersistedId = null;
 
-	private TableInfo mTableInfo;
-
+	private final TableInfo mTableInfo;
+    private final String idName;
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	public Model() {
 		mTableInfo = Cache.getTableInfo(getClass());
+        idName = mTableInfo.getIdName();
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -67,14 +72,14 @@ public final Long getPersistedId() {
     }
 
 	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), "Id=?", new String[]{mPersistedId.toString()});
+        Cache.openDatabase().delete(mTableInfo.getTableName(), idName+"=?", new String[] { getId().toString() });
 		Cache.removeEntity(this);
 
 		Cache.getContext().getContentResolver()
 				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mPersistedId), null);
 	}
 
-	public final void save() {
+    public final Long save() {
 		final SQLiteDatabase db = Cache.openDatabase();
 		final ContentValues values = new ContentValues();
 
@@ -140,7 +145,7 @@ else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
 					values.put(fieldName, (byte[]) value);
 				}
 				else if (ReflectionUtils.isModel(fieldType)) {
-					values.put(fieldName, ((Model) value).mPersistedId);
+					values.put(fieldName, ((Model) value).getPersistedId());
 				}
 				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 					values.put(fieldName, ((Enum<?>) value).name());
@@ -159,7 +164,7 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
             id = mPersistedId;
 		}
 		else {
-			db.update(mTableInfo.getTableName(), values, "Id=" + mPersistedId, null);
+			db.update(mTableInfo.getTableName(), values, idName+"=" + mPersistedId, null);
 
             // The Id may has been updated, so we need to update mPersistedId and the Cache, as
             // it stores Entities with their corresponding Ids.
@@ -169,25 +174,33 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 
 		Cache.getContext().getContentResolver()
 				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mPersistedId), null);
+        return id;
 	}
 
 	// Convenience methods
 
 	public static void delete(Class<? extends Model> type, long id) {
-		new Delete().from(type).where("Id=?", id).execute();
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
 	}
 
 	public static <T extends Model> T load(Class<T> type, long id) {
-		return (T) new Select().from(type).where("Id=?", id).executeSingle();
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
 	}
 
 	// Model population
 
 	public final void loadFromCursor(Cursor cursor) {
+        /**
+         * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+         * when the cursor have multiple columns with same name obtained from join tables.
+         */
+        List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
 		for (Field field : mTableInfo.getFields()) {
 			final String fieldName = mTableInfo.getColumnName(field);
 			Class<?> fieldType = field.getType();
-			final int columnIndex = cursor.getColumnIndex(fieldName);
+            final int columnIndex = columnsOrdered.indexOf(fieldName);
 
 			if (columnIndex < 0) {
 				continue;
@@ -245,7 +258,7 @@ else if (ReflectionUtils.isModel(fieldType)) {
 
 					Model entity = Cache.getEntity(entityType, entityId);
 					if (entity == null) {
-						entity = new Select().from(entityType).where("Id=?", entityId).executeSingle();
+                        entity = new Select().from(entityType).where(idName+"=?", entityId).executeSingle();
 					}
 
 					value = entity;
@@ -288,23 +301,35 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
-		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", mPersistedId).execute();
+		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getPersistedId()).execute();
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
+	// OVERRIDDEN METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	@Override
 	public String toString() {
-		return mTableInfo.getTableName() + "@" + id;
+        return mTableInfo.getTableName() + "@" + getId();
 	}
 
 	@Override
 	public boolean equals(Object obj) {
-		final Model other = (Model) obj;
+        if (obj instanceof Model && this.id != null) {
+		    final Model other = (Model) obj;
+
+		    return this.id.equals(other.id)
+                    && this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName());
+        } else {
+            return this == obj;
+	    }
+    }
 
-		return id != null && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()))
-				&& (id.equals(other.id));
-	}
+    @Override
+    public int hashCode() {
+        int hash = HASH_PRIME;
+        hash += HASH_PRIME * (id == null ? super.hashCode() : id.hashCode()); //if id is null, use Object.hashCode()
+        hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
+        return hash;
+    }
 }
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/TableInfo.java
index aa5324cd..26d3675d 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/src/com/activeandroid/TableInfo.java
@@ -20,13 +20,18 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.HashMap;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 
+import android.text.TextUtils;
+import android.util.Log;
+
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.Table;
-import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
 
 public final class TableInfo {
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -35,8 +40,9 @@
 
 	private Class<? extends Model> mType;
 	private String mTableName;
+    private String mIdName = Table.DEFAULT_ID_NAME;
 
-	private Map<Field, String> mColumnNames = new HashMap<Field, String>();
+    private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
@@ -46,24 +52,36 @@ public TableInfo(Class<? extends Model> type) {
 		mType = type;
 
 		final Table tableAnnotation = type.getAnnotation(Table.class);
+
 		if (tableAnnotation != null) {
 			mTableName = tableAnnotation.name();
+            mIdName = tableAnnotation.id();
 		}
 		else {
 			mTableName = type.getSimpleName();
 		}
 
-		List<Field> fields = new ArrayList<Field>(Arrays.asList(type.getDeclaredFields()));
-		fields.add(getIdField(type));
+        // Manually add the id column since it is not declared like the other columns.
+        Field idField = getIdField(type);
+        mColumnNames.put(idField, mIdName);
+
+        List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
+        Collections.reverse(fields);
 
 		for (Field field : fields) {
 			if (field.isAnnotationPresent(Column.class)) {
 				final Column columnAnnotation = field.getAnnotation(Column.class);
-				mColumnNames.put(field, columnAnnotation.name());
+                String columnName = columnAnnotation.name();
+                if (TextUtils.isEmpty(columnName)) {
+                    columnName = field.getName();
 			}
+
+                mColumnNames.put(field, columnName);
 		}
 	}
 
+    }
+
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -76,6 +94,10 @@ public String getTableName() {
 		return mTableName;
 	}
 
+    public String getIdName() {
+        return mIdName;
+    }
+
 	public Collection<Field> getFields() {
 		return mColumnNames.keySet();
 	}
@@ -94,7 +116,7 @@ private Field getIdField(Class<?> type) {
 				return type.getDeclaredField("id");
 			}
 			catch (NoSuchFieldException e) {
-				Log.e("Impossible!", e);
+                Log.e("Impossible!", e.toString());
 			}
 		}
 		else if (type.getSuperclass() != null) {
@@ -103,4 +125,5 @@ else if (type.getSuperclass() != null) {
 
 		return null;
 	}
+
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/widget/ModelAdapter.java b/src/com/activeandroid/widget/ModelAdapter.java
index f1ca89f3..a3895763 100644
--- a/src/com/activeandroid/widget/ModelAdapter.java
+++ b/src/com/activeandroid/widget/ModelAdapter.java
@@ -48,7 +48,7 @@ public long getItemId(int position) {
 		T item = getItem(position);
 
 		if (item != null) {
-			return item.id;
+			return item.getId();
 		}
 		else {
 			return -1;
