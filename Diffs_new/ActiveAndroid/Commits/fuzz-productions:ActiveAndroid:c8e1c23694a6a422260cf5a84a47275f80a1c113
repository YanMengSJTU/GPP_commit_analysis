diff --git a/README.md b/README.md
index 05a73e44..7ba14fba 100644
--- a/README.md
+++ b/README.md
@@ -1,23 +1,21 @@
 [![Build Status](https://travis-ci.org/pardom/ActiveAndroid.png?branch=master)](https://travis-ci.org/pardom/ActiveAndroid) [![Stories in Ready](https://badge.waffle.io/pardom/ActiveAndroid.png)](http://waffle.io/pardom/ActiveAndroid)  
-# ActiveAndroid On Steroids
+# ActiveAndroid
 
-ActiveAndroid On Steroids (a fork of ActiveAndroid) is an active record style ORM ([object relational mapper](http://en.wikipedia.org/wiki/Object-relational_mapping)). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like _save()_ and _delete()_.
+ActiveAndroid is an active record style ORM ([object relational mapper](http://en.wikipedia.org/wiki/Object-relational_mapping)). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like _save()_ and _delete()_.
 
-ActiveAndroid does so much more than this though (and now even more). Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration. 
-
-_ActiveAndroid On Steroids provides you with a completely thread-safe, priority-based DBRequestQueue, code-crushing DBManagers, and some other surprises "Sprinkled" in._
+ActiveAndroid does so much more than this though. Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration.
 
 ## Documentation
 
-* [Getting started](http://github.com/agrosner/ActiveAndroid/wiki/Getting-started)
-* [Creating your database IModel](http://github.com/agrosner/ActiveAndroid/wiki/Creating-your-database-Model)
-* [Saving to the database](http://github.com/agrosner/ActiveAndroid/wiki/Saving-to-the-database)
-* [Querying the database](http://github.com/agrosner/ActiveAndroid/wiki/Querying-the-database)
-* [DB Managers] (http://github.com/agrosner/ActiveAndroid/wiki/DB-Managers)
-* [Type serializers](http://github.com/agrosner/ActiveAndroid/wiki/Type-serializers)
-* [Using the content provider](http://github.com/agrosner/ActiveAndroid/wiki/Using-the-content-provider)
-* [Schema migrations](http://github.com/agrosner/ActiveAndroid/wiki/Schema-migrations)
-* [Pre-populated-databases](http://github.com/agrosner/ActiveAndroid/wiki/Pre-populated-databases)
+* [Getting started](http://github.com/pardom/ActiveAndroid/wiki/Getting-started)
+* [Creating your database model](http://github.com/pardom/ActiveAndroid/wiki/Creating-your-database-model)
+* [Saving to the database](http://github.com/pardom/ActiveAndroid/wiki/Saving-to-the-database)
+* [Querying the database](http://github.com/pardom/ActiveAndroid/wiki/Querying-the-database)
+* [Type serializers](http://github.com/pardom/ActiveAndroid/wiki/Type-serializers)
+* [Using the content provider](http://github.com/pardom/ActiveAndroid/wiki/Using-the-content-provider)
+* [Schema migrations](http://github.com/pardom/ActiveAndroid/wiki/Schema-migrations)
+* [Pre-populated-databases](http://github.com/pardom/ActiveAndroid/wiki/Pre-populated-databases)
+* [Running the Test Suite](https://github.com/pardom/ActiveAndroid/wiki/Running-the-Test-Suite)
 
 ## License
 
@@ -39,16 +37,13 @@ _ActiveAndroid On Steroids provides you with a completely thread-safe, priority-
 
 ## Contributing
 
-Please fork this repository and contribute back using [pull requests](http://github.com/agrosner/ActiveAndroid/pulls).
-
-Any requests will be happily looked at and contributors will be recognized here:
+Please fork this repository and contribute back using [pull requests](http://github.com/pardom/ActiveAndroid/pulls).
 
-_Be the first!_
+Any contributions, large or small, major features, bug fixes, unit tests are welcomed and appreciated but will be thoroughly reviewed and discussed.
 
-## Original Author
+You can run the test suite by following the instructions on the [Running the Test Suite](https://github.com/pardom/ActiveAndroid/wiki/Running-the-Test-Suite) Wiki page.
 
-Michael Pardo | www.michaelpardo.com | www.activeandroid.com
 
-## ActiveAndroid On Steroids Author
+## Author
 
-Andrew Grosner | andrew@fuzzproductions.com
+Michael Pardo | www.michaelpardo.com | www.activeandroid.com
diff --git a/build.xml b/build.xml
deleted file mode 100644
index b2b7bfa6..00000000
--- a/build.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0"?>
-<project name="ActiveAndroid" default="dist" basedir=".">
-
-	<property name="dist.dir"  value="dist" />
-    <property name="src.dir"   value="src" />
-	<property name="build.dir" value="bin" />
-	<property name="lib.dir"   value="libs"/>
-	
-	<target name="dist" depends="clean, package" />
-
-	<target name="clean">
-		<delete dir="${build.dir}" />
-		<delete dir="${dist.dir}" />
-	</target>
-
-	<target name="init">
-		<mkdir dir="${build.dir}"/>
-		<mkdir dir="${dist.dir}" />
-	</target>
-
-	<path id="classpath">
-        <fileset dir="${lib.dir}" includes="**/*.jar"/>
-    </path>
-    
-	<target name="compile">
-    	<javac srcdir="${src.dir}" destdir="${build.dir}" source="1.5" target="1.5" classpathref="classpath" debug="off" />
-	</target>
-		
-	<target name="package" depends="init, compile">
-		<jar destfile="${dist.dir}/ActiveAndroid.jar" basedir="${build.dir}"/>
-	</target>
-</project>
diff --git a/pom-child.xml b/pom-child.xml
deleted file mode 100644
index 96ded224..00000000
--- a/pom-child.xml
+++ /dev/null
@@ -1,93 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-
-    <IModelVersion>4.0.0</IModelVersion>
-    <groupId>com.activeandroid</groupId>
-    <artifactId>activeandroid</artifactId>
-    <version>3.1-SNAPSHOT</version>
-    <packaging>jar</packaging>
-    <name>ActiveAndroid</name>
-
-    <licenses>
-        <license>
-            <name>The Apache Software License, Version 2.0</name>
-            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-            <distribution>repo</distribution>
-        </license>
-    </licenses>
-
-  <parent>
-    <groupId>com.activeandroid</groupId>
-    <artifactId>activeandroid-parent</artifactId>
-    <version>3.1-SNAPSHOT</version>
-    <relativePath>./pom.xml</relativePath>
-  </parent>
-
-    <scm>
-        <connection>scm:git:git@github.com:pardom/ActiveAndroid.git</connection>
-        <developerConnection>scm:git:git@github.com:pardom/ActiveAndroid.git</developerConnection>
-        <url>git@github.com:pardom/ActiveAndroid.git</url>
-    </scm>
-
-    <properties>
-        <java.version>1.6</java.version>
-        <platform.sdk>16</platform.sdk>
-        <platform.version>4.1.1.4</platform.version>
-        <platform.support-version>r7</platform.support-version>
-    </properties>
-
-    <dependencies>
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>android</artifactId>
-            <version>${platform.version}</version>
-            <scope>provided</scope>
-        </dependency>
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>android-test</artifactId>
-            <version>${platform.version}</version>
-            <scope>provided</scope>
-        </dependency>
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>support-v4</artifactId>
-            <version>${platform.support-version}</version>
-        </dependency>
-    </dependencies>
-
-    <build>
-        <sourceDirectory>src</sourceDirectory>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.14.1</version>
-            </plugin>
-            <plugin>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
-                <configuration>
-                    <source>${java.version}</source>
-                    <target>${java.version}</target>
-                </configuration>
-            </plugin>
-            <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-                <artifactId>android-maven-plugin</artifactId>
-                <version>3.6.0</version>
-                <configuration>
-                    <sdk>
-                        <path>${env.ANDROID_HOME}</path>
-                        <platform>${platform.sdk}</platform>
-                    </sdk>
-                </configuration>
-                <extensions>true</extensions>
-            </plugin>
-        </plugins>
-    </build>
-
-</project>
diff --git a/pom.xml b/pom.xml
deleted file mode 100644
index 151b1cff..00000000
--- a/pom.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <IModelVersion>4.0.0</IModelVersion>
-  <groupId>com.activeandroid</groupId>
-  <artifactId>activeandroid-parent</artifactId>
-  <version>3.1-SNAPSHOT</version>
-  <packaging>pom</packaging>
-  <name>ActiveAndroid - Parent</name>
-
-  <modules>
-    <module>pom-child.xml</module>
-    <module>tests</module>
-  </modules>
-
-    <properties>
-        <java.version>1.6</java.version>
-        <platform.sdk>16</platform.sdk>
-        <platform.version>4.1.1.4</platform.version>
-        <platform.support-version>r7</platform.support-version>
-    </properties>
-
-  <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-          <artifactId>android-maven-plugin</artifactId>
-          <version>3.6.0</version>
-        </plugin>
-        <plugin>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.1</version>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-  </build>
-</project>
diff --git a/src/main/java/com/activeandroid/Cache.java b/src/main/java/com/activeandroid/Cache.java
index c0c294a7..f8ca5103 100644
--- a/src/main/java/com/activeandroid/Cache.java
+++ b/src/main/java/com/activeandroid/Cache.java
@@ -16,8 +16,6 @@
  * limitations under the License.
  */
 
-import java.util.Collection;
-
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.support.v4.util.LruCache;
@@ -25,6 +23,8 @@
 import com.activeandroid.serializer.TypeSerializer;
 import com.activeandroid.util.AALog;
 
+import java.util.Collection;
+
 public final class Cache {
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC CONSTANTS
@@ -45,6 +45,12 @@
 
 	private static boolean sIsInitialized = false;
 
+
+    /**
+     * boolean to tell us whether a migration has successfully been executed
+     */
+    private static boolean migrationExecuted;
+
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -52,6 +58,15 @@
 	private Cache() {
 	}
 
+
+    public static boolean hasMigrationExecuted() {
+        return migrationExecuted;
+    }
+
+    public static void setMigrationExecuted(boolean executed) {
+        migrationExecuted = executed;
+    }
+
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/main/java/com/activeandroid/DatabaseHelper.java b/src/main/java/com/activeandroid/DatabaseHelper.java
index af1102c4..2d8fa59c 100644
--- a/src/main/java/com/activeandroid/DatabaseHelper.java
+++ b/src/main/java/com/activeandroid/DatabaseHelper.java
@@ -16,6 +16,15 @@
  * limitations under the License.
  */
 
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteOpenHelper;
+
+import com.activeandroid.util.AALog;
+import com.activeandroid.util.NaturalOrderComparator;
+import com.activeandroid.util.SQLiteUtils;
+
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileOutputStream;
@@ -27,161 +36,155 @@
 import java.util.Collections;
 import java.util.List;
 
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-
-import com.activeandroid.util.AALog;
-import com.activeandroid.util.NaturalOrderComparator;
-import com.activeandroid.util.SQLiteUtils;
-
 public final class DatabaseHelper extends SQLiteOpenHelper {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public final static String MIGRATION_PATH = "migrations";
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public DatabaseHelper(Configuration configuration) {
-		super(configuration.getContext(), configuration.getDatabaseName(), null, configuration.getDatabaseVersion());
-		copyAttachedDatabase(configuration.getContext(), configuration.getDatabaseName());
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public void onOpen(SQLiteDatabase db) {
-		executePragmas(db);
-	};
-
-	@Override
-	public void onCreate(SQLiteDatabase db) {
-		executePragmas(db);
-		executeCreate(db);
-		executeMigrations(db, -1, db.getVersion());
-	}
-
-	@Override
-	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-		executePragmas(db);
-		executeCreate(db);
-		executeMigrations(db, oldVersion, newVersion);
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public void copyAttachedDatabase(Context context, String databaseName) {
-		final File dbPath = context.getDatabasePath(databaseName);
-
-		// If the database already exists, return
-		if (dbPath.exists()) {
-			return;
-		}
-
-		// Make sure we have a path to the file
-		dbPath.getParentFile().mkdirs();
-
-		// Try to copy database file
-		try {
-			final InputStream inputStream = context.getAssets().open(databaseName);
-			final OutputStream output = new FileOutputStream(dbPath);
-
-			byte[] buffer = new byte[1024];
-			int length;
-
-			while ((length = inputStream.read(buffer)) > 0) {
-				output.write(buffer, 0, length);
-			}
-
-			output.flush();
-			output.close();
-			inputStream.close();
-		}
-		catch (IOException e) {
-			AALog.e("Failed to open file", e);
-		}
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private void executePragmas(SQLiteDatabase db) {
-		if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
-			db.execSQL("PRAGMA foreign_keys=ON;");
-			AALog.i("Foreign Keys supported. Enabling foreign key features.");
-		}
-	}
-
-	private void executeCreate(SQLiteDatabase db) {
-		db.beginTransaction();
-		try {
-			for (TableInfo tableInfo : Cache.getTableInfos()) {
-				db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
-			}
-			db.setTransactionSuccessful();
-		}
-		finally {
-			db.endTransaction();
-		}
-	}
-
-	private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
-		boolean migrationExecuted = false;
-		try {
-			final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
-			Collections.sort(files, new NaturalOrderComparator());
-
-			db.beginTransaction();
-			try {
-				for (String file : files) {
-					try {
-						final int version = Integer.valueOf(file.replace(".sql", ""));
-
-						if (version > oldVersion && version <= newVersion) {
-							executeSqlScript(db, file);
-							migrationExecuted = true;
-
-							AALog.i(file + " executed succesfully.");
-						}
-					}
-					catch (NumberFormatException e) {
-						AALog.w("Skipping invalidly named file: " + file, e);
-					}
-				}
-				db.setTransactionSuccessful();
-			}
-			finally {
-				db.endTransaction();
-			}
-		}
-		catch (IOException e) {
-			AALog.e("Failed to execute migrations.", e);
-		}
-
-		return migrationExecuted;
-	}
-
-	private void executeSqlScript(SQLiteDatabase db, String file) {
-		try {
-			final InputStream input = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
-			final BufferedReader reader = new BufferedReader(new InputStreamReader(input));
-			String line = null;
-
-			while ((line = reader.readLine()) != null) {
-				db.execSQL(line.replace(";", ""));
-			}
-		}
-		catch (IOException e) {
-			AALog.e("Failed to execute " + file, e);
-		}
-	}
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public final static String MIGRATION_PATH = "migrations";
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public DatabaseHelper(Configuration configuration) {
+        super(configuration.getContext(), configuration.getDatabaseName(), null, configuration.getDatabaseVersion());
+        copyAttachedDatabase(configuration.getContext(), configuration.getDatabaseName());
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public void onOpen(SQLiteDatabase db) {
+        executePragmas(db);
+    }
+
+    ;
+
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        executePragmas(db);
+        executeCreate(db);
+        executeMigrations(db, -1, db.getVersion());
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        executePragmas(db);
+        executeCreate(db);
+        boolean migrationSuccess = executeMigrations(db, oldVersion, newVersion);
+        Cache.setMigrationExecuted(migrationSuccess);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public void copyAttachedDatabase(Context context, String databaseName) {
+        final File dbPath = context.getDatabasePath(databaseName);
+
+        // If the database already exists, return
+        if (dbPath.exists()) {
+            return;
+        }
+
+        // Make sure we have a path to the file
+        dbPath.getParentFile().mkdirs();
+
+        // Try to copy database file
+        try {
+            final InputStream inputStream = context.getAssets().open(databaseName);
+            final OutputStream output = new FileOutputStream(dbPath);
+
+            byte[] buffer = new byte[1024];
+            int length;
+
+            while ((length = inputStream.read(buffer)) > 0) {
+                output.write(buffer, 0, length);
+            }
+
+            output.flush();
+            output.close();
+            inputStream.close();
+        } catch (IOException e) {
+            AALog.e("Failed to open file", e);
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private void executePragmas(SQLiteDatabase db) {
+        if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
+            db.execSQL("PRAGMA foreign_keys=ON;");
+            AALog.i("Foreign Keys supported. Enabling foreign key features.");
+        }
+    }
+
+    private void executeCreate(SQLiteDatabase db) {
+        db.beginTransaction();
+        try {
+            for (TableInfo tableInfo : Cache.getTableInfos()) {
+                db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
+            }
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
+        boolean migrationExecuted = false;
+        try {
+            final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
+            Collections.sort(files, new NaturalOrderComparator());
+
+            db.beginTransaction();
+            try {
+                for (String file : files) {
+                    try {
+                        final int version = Integer.valueOf(file.replace(".sql", ""));
+
+                        if (version > oldVersion && version <= newVersion) {
+                            executeSqlScript(db, file);
+                            migrationExecuted = true;
+
+                            AALog.i(file + " executed succesfully.");
+                        }
+                    } catch (NumberFormatException e) {
+                        AALog.w("Skipping invalidly named file: " + file, e);
+                    }
+                }
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+        } catch (IOException e) {
+            AALog.e("Failed to execute migrations.", e);
+        }
+
+        return migrationExecuted;
+    }
+
+    private void executeSqlScript(SQLiteDatabase db, String file) {
+        try {
+            final InputStream input = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
+            final BufferedReader reader = new BufferedReader(new InputStreamReader(input));
+            String line = null;
+
+            while ((line = reader.readLine()) != null) {
+                try {
+                    db.execSQL(line.replace(";", ""));
+                } catch (SQLiteException ignored) {
+                    AALog.e("Failed to execute " + file, ignored);
+                }
+
+            }
+        } catch (IOException e) {
+            AALog.e("Failed to execute " + file, e);
+        }
+    }
 }
diff --git a/src/main/java/com/activeandroid/Model.java b/src/main/java/com/activeandroid/Model.java
index d9193e6b..d6d479db 100644
--- a/src/main/java/com/activeandroid/Model.java
+++ b/src/main/java/com/activeandroid/Model.java
@@ -35,15 +35,26 @@
 
 @SuppressWarnings("unchecked")
 public abstract class Model implements IModel{
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE MEMBERS
+	//////////////////////////////////////////////////////////////////////////////////////
 
 	private TableInfo mTableInfo;
 
+	//////////////////////////////////////////////////////////////////////////////////////
+	// CONSTRUCTORS
+	//////////////////////////////////////////////////////////////////////////////////////
+
 	public Model() {
 		mTableInfo = Cache.getTableInfo(getClass());
 	}
 
     private long mId;
 
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
     /**
      * Use This method to return the values of your primary key, must be separated by comma delimiter in order of declaration
      * Also each object thats instance of {@link java.lang.Number} must be DataBaseUtils.sqlEscapeString(object.toString)
@@ -51,42 +62,277 @@ public Model() {
      */
 	public abstract String getId();
 
-    @Override
 	public final void delete() {
-		SQLiteUtils.delete(this);
+		Cache.openDatabase().delete(mTableInfo.getTableName(), SQLiteUtils.getWhereStatement(this, mTableInfo), null);
+		Cache.removeEntity(this);
+
+		Cache.getContext().getContentResolver()
+				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), getId()), null);
 	}
 
-    @Override
 	public final void save() {
-        SQLiteUtils.save(this);
+		final SQLiteDatabase db = Cache.openDatabase();
+		final ContentValues values = new ContentValues();
+
+		for (Field field : mTableInfo.getFields()) {
+			String fieldName = mTableInfo.getColumnName(field);
+			Class<?> fieldType = field.getType();
+
+			field.setAccessible(true);
+
+			try {
+				Object value = field.get(this);
+
+				if (value != null) {
+					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+					if (typeSerializer != null) {
+						// serialize data
+						value = typeSerializer.serialize(value);
+						// set new object type
+						if (value != null) {
+							fieldType = value.getClass();
+							// check that the serializer returned what it promised
+							if (!fieldType.equals(typeSerializer.getSerializedType())) {
+								AALog.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                        typeSerializer.getSerializedType(), fieldType));
+							}
+						}
+					}
+				}
+
+				// TODO: Find a smarter way to do this? This if block is necessary because we
+				// can't know the type until runtime.
+				if (value == null) {
+					values.putNull(fieldName);
+				}
+				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+					values.put(fieldName, (Byte) value);
+				}
+				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+					values.put(fieldName, (Short) value);
+				}
+				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+					values.put(fieldName, (Integer) value);
+				}
+				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+					values.put(fieldName, (Long) value);
+				}
+				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+					values.put(fieldName, (Float) value);
+				}
+				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+					values.put(fieldName, (Double) value);
+				}
+				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+					values.put(fieldName, (Boolean) value);
+				}
+				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+					values.put(fieldName, value.toString());
+				}
+				else if (fieldType.equals(String.class)) {
+					values.put(fieldName, value.toString());
+				}
+				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+					values.put(fieldName, (byte[]) value);
+				}
+				else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
+                    ForeignKey key = field.getAnnotation(ForeignKey.class);
+                    if(!key.name().equals("")){
+                        fieldName = field.getAnnotation(ForeignKey.class).name();
+                    }
+					values.put(fieldName, ((Model) value).getId());
+				}
+				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+					values.put(fieldName, ((Enum<?>) value).name());
+				}
+			}
+			catch (IllegalArgumentException e) {
+				AALog.e(e.getClass().getName(), e);
+			}
+			catch (IllegalAccessException e) {
+				AALog.e(e.getClass().getName(), e);
+			}
+		}
+
+        if(!exists()){
+		     mId = db.insert(mTableInfo.getTableName(), null, values);
+
+            for(Field field : mTableInfo.getPrimaryKeys()){
+                if(field.isAnnotationPresent(PrimaryKey.class) &&
+                        field.getAnnotation(PrimaryKey.class).type().equals(PrimaryKey.Type.AUTO_INCREMENT)){
+                    field.setAccessible(true);
+                    try {
+                        field.set(this, mId);
+                    } catch (Throwable e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+            }
+        } else {
+			mId = db.update(mTableInfo.getTableName(), values, SQLiteUtils.getWhereStatement(this, mTableInfo), null);
+		}
+
+		Cache.getContext().getContentResolver()
+				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), getId()), null);
 	}
 
-    @Override
     public boolean exists(){
-        return SQLiteUtils.exists(this);
+        Model model = new Select().from(getClass()).where(SQLiteUtils.getWhereStatement(this, mTableInfo)).executeSingle();
+        return model!=null;
     }
 
     public void update(){
 
     }
 
-    @Override
+    /**
+     * Checks to see if object exists, if so, deletes it then updates itself
+     */
+    public <OBJECT_CLASS extends Model> void saveById(){
+        if(exists()){
+            delete();
+        }
+        save();
+    }
+
+	// Convenience methods
+
+	public static void delete(Class<? extends Model> type, long id) {
+		new Delete().from(type).where("Id=?", id).execute();
+	}
+
+	public static <T extends Model> T load(Class<T> type, long id) {
+		return new Select().from(type).where("Id=?", id).executeSingle();
+	}
+
+	// Model population
+
 	public final void loadFromCursor(Cursor cursor) {
-        SQLiteUtils.loadFromCursor(cursor, this);
+		for (Field field : mTableInfo.getFields()) {
+			final String fieldName = mTableInfo.getColumnName(field);
+			Class<?> fieldType = field.getType();
+			final int columnIndex = cursor.getColumnIndex(fieldName);
+
+			if (columnIndex < 0) {
+				continue;
+			}
+
+			field.setAccessible(true);
+
+			try {
+				boolean columnIsNull = cursor.isNull(columnIndex);
+				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+				Object value = null;
+
+				if (typeSerializer != null) {
+					fieldType = typeSerializer.getSerializedType();
+				}
+
+				// TODO: Find a smarter way to do this? This if block is necessary because we
+				// can't know the type until runtime.
+				if (columnIsNull) {
+					field = null;
+				}
+				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+					value = cursor.getInt(columnIndex);
+				}
+				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+					value = cursor.getInt(columnIndex);
+				}
+				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+					value = cursor.getInt(columnIndex);
+				}
+				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+					value = cursor.getLong(columnIndex);
+				}
+				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+					value = cursor.getFloat(columnIndex);
+				}
+				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+					value = cursor.getDouble(columnIndex);
+				}
+				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+					value = cursor.getInt(columnIndex) != 0;
+				}
+				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+					value = cursor.getString(columnIndex).charAt(0);
+				}
+				else if (fieldType.equals(String.class)) {
+					value = cursor.getString(columnIndex);
+				}
+				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+					value = cursor.getBlob(columnIndex);
+				}
+				else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
+					final String entityId = cursor.getString(columnIndex);
+					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
+
+					IModel entity = Cache.getEntity(entityType, entityId);
+					if (entity == null) {
+						entity = new Select().from(entityType).where(SQLiteUtils.getWhereFromEntityId(entityType, entityId)).executeSingle();
+					}
+
+					value = entity;
+				}
+				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+					@SuppressWarnings("rawtypes")
+					final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+					value = Enum.valueOf(enumType, cursor.getString(columnIndex));
+				}
+
+				// Use a deserializer if one is available
+				if (typeSerializer != null && !columnIsNull) {
+					value = typeSerializer.deserialize(value);
+				}
+
+				// Set the field name
+				if (value != null) {
+					field.set(this, value);
+				}
+			}
+			catch (IllegalArgumentException e) {
+				AALog.e(e.getClass().getName(), e);
+			}
+			catch (IllegalAccessException e) {
+				AALog.e(e.getClass().getName(), e);
+			}
+			catch (SecurityException e) {
+				AALog.e(e.getClass().getName(), e);
+			}
+		}
+
+		if (getId() != null) {
+			Cache.addEntity(this);
+		}
 	}
 
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PROTECTED METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+    protected final <T extends Model> List<T> getManyFromField(Class<T> type,Object field, String foreignKey){
+        return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", field).execute();
+    }
+
+    protected final <T extends Model> List<T> getManyFromFieldWithSort(Class<T> type,Object field, String foreignKey, String sort){
+        return new Select().from(type).orderBy(sort).where(Cache.getTableName(type) + "." + foreignKey + "=?", field).execute();
+    }
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// OVERRIDEN METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
 	@Override
 	public String toString() {
 		return mTableInfo!=null? mTableInfo.getTableName() + "@" + getId() : "No Table for: " + getClass() + "@" + getId();
 	}
 
-    @Override
     public long getRowId(){
         return mId;
     }
 
     @Override
     public void setRowId(long id) {
-        this.mId = id;
+        mId = id;
     }
 }
diff --git a/src/main/java/com/activeandroid/app/AAApplication.java b/src/main/java/com/activeandroid/app/AAApplication.java
index d4a0b759..1a2a6d7e 100644
--- a/src/main/java/com/activeandroid/app/AAApplication.java
+++ b/src/main/java/com/activeandroid/app/AAApplication.java
@@ -17,33 +17,42 @@
  */
 
 import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Cache;
 import com.activeandroid.manager.DBManagerRuntime;
-import com.activeandroid.runtime.DBRequestQueue;
 
 public class AAApplication extends android.app.Application {
 
     private static boolean mDebug = false;
 
-	@Override
-	public void onCreate() {
-		super.onCreate();
-		ActiveAndroid.initialize(this);
-
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        ActiveAndroid.initialize(this);
         DBManagerRuntime.restartManagers();
-	}
+        if(Cache.hasMigrationExecuted()) {
+            onMigrationSuccessful();
+        }
+    }
 
-    public static void setDebugLogEnabled(boolean enabled){
+    public static void setDebugLogEnabled(boolean enabled) {
         mDebug = enabled;
     }
 
-    public static boolean isDebugEnabled(){
+    public static boolean isDebugEnabled() {
         return mDebug;
     }
-	
-	@Override
-	public void onTerminate() {
-		super.onTerminate();
 
-		ActiveAndroid.dispose();
-	}
+    @Override
+    public void onTerminate() {
+        super.onTerminate();
+
+        ActiveAndroid.dispose();
+    }
+
+    /**
+     * override this method to perform any special operations when a migration takes place
+     */
+    protected void onMigrationSuccessful() {
+
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/query/From.java b/src/main/java/com/activeandroid/query/From.java
index 88567611..beb7ec6a 100644
--- a/src/main/java/com/activeandroid/query/From.java
+++ b/src/main/java/com/activeandroid/query/From.java
@@ -227,7 +227,8 @@ public long executeCount(){
 
     /**
      * Returns the DB Cursor from the SQL statement
-     * @return
+     * @return {@link android.database.Cursor} Note that the cursor is positioned before the first entry,
+     * so you must call {@link android.database.Cursor#moveToNext()} to use the cursor
      */
     public Cursor getCursor(){
         return Cache.openDatabase().rawQuery(toSql(), getArguments());
