diff --git a/src/com/activeandroid/query/From.java b/src/com/activeandroid/query/From.java
old mode 100644
new mode 100755
index 32d6e8b9..accc1517
--- a/src/com/activeandroid/query/From.java
+++ b/src/com/activeandroid/query/From.java
@@ -16,6 +16,8 @@
  * limitations under the License.
  */
 
+import android.database.sqlite.SQLiteConstraintException;
+import android.os.Handler;
 import android.text.TextUtils;
 
 import com.activeandroid.Cache;
@@ -26,66 +28,67 @@
 import com.activeandroid.util.SQLiteUtils;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 public final class From implements Sqlable {
-	private Sqlable mQueryBase;
-
-	private Class<? extends Model> mType;
-	private String mAlias;
-	private List<Join> mJoins;
-	private String mWhere;
-	private String mGroupBy;
-	private String mHaving;
-	private String mOrderBy;
-	private String mLimit;
-	private String mOffset;
-
-	private List<Object> mArguments;
-
-	public From(Class<? extends Model> table, Sqlable queryBase) {
-		mType = table;
-		mJoins = new ArrayList<Join>();
-		mQueryBase = queryBase;
-
-		mJoins = new ArrayList<Join>();
-		mArguments = new ArrayList<Object>();
-	}
-
-	public From as(String alias) {
-		mAlias = alias;
-		return this;
-	}
-
-	public Join join(Class<? extends Model> table) {
-		Join join = new Join(this, table, null);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join leftJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.LEFT);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join outerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.OUTER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join innerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.INNER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join crossJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.CROSS);
-		mJoins.add(join);
-		return join;
-	}
+    private Sqlable mQueryBase;
+
+    private Class<? extends Model> mType;
+    private String mAlias;
+    private List<Join> mJoins;
+    private String mWhere;
+    private String mGroupBy;
+    private String mHaving;
+    private String mOrderBy;
+    private String mLimit;
+    private String mOffset;
+
+    private List<Object> mArguments;
+
+    public From(Class<? extends Model> table, Sqlable queryBase) {
+        mType = table;
+        mJoins = new ArrayList<Join>();
+        mQueryBase = queryBase;
+
+        mJoins = new ArrayList<Join>();
+        mArguments = new ArrayList<Object>();
+    }
+
+    public From as(String alias) {
+        mAlias = alias;
+        return this;
+    }
+
+    public Join join(Class<? extends Model> table) {
+        Join join = new Join(this, table, null);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join leftJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.LEFT);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join outerJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.OUTER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join innerJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.INNER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join crossJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.CROSS);
+        mJoins.add(join);
+        return join;
+    }
 
     public From where(String where) {
         if (mWhere != null) {                                   // Chain conditions if a previous
@@ -100,152 +103,185 @@ public From where(String where) {
     public From where(String where, Object... args) {
         if (mWhere != null) {                                    // Chain conditions if a previous
             mWhere = mWhere + " AND " + where;                   // condition exists.
-        }
-        else {
+            mArguments.addAll(Arrays.asList(args));
+
+        } else {
             mWhere = where;
+            mArguments.addAll(Arrays.asList(args));
         }
 
-        addArguments(args);
+        return this;
+    }
+
+    public From groupBy(String groupBy) {
+        mGroupBy = groupBy;
+        return this;
+    }
+
+    public From having(String having) {
+        mHaving = having;
+        return this;
+    }
 
+    public From orderBy(String orderBy) {
+        mOrderBy = orderBy;
         return this;
     }
 
-	public From groupBy(String groupBy) {
-		mGroupBy = groupBy;
-		return this;
-	}
-
-	public From having(String having) {
-		mHaving = having;
-		return this;
-	}
-
-	public From orderBy(String orderBy) {
-		mOrderBy = orderBy;
-		return this;
-	}
-
-	public From limit(int limit) {
-		return limit(String.valueOf(limit));
-	}
-
-	public From limit(String limit) {
-		mLimit = limit;
-		return this;
-	}
-
-	public From offset(int offset) {
-		return offset(String.valueOf(offset));
-	}
-
-	public From offset(String offset) {
-		mOffset = offset;
-		return this;
-	}
-
-	void addArguments(Object[] args) {
-        for( Object arg : args ) {
-            if (arg.getClass() == boolean.class || arg.getClass() == Boolean.class)
-                arg = ( arg.equals(true) ? 1 : 0 );
-
-            mArguments.add(arg);
-        }
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-		sql.append(mQueryBase.toSql());
-		sql.append("FROM ");
-		sql.append(Cache.getTableName(mType)).append(" ");
-
-		if (mAlias != null) {
-			sql.append("AS ");
-			sql.append(mAlias);
-			sql.append(" ");
-		}
-
-		for (Join join : mJoins) {
-			sql.append(join.toSql());
-		}
-
-		if (mWhere != null) {
-			sql.append("WHERE ");
-			sql.append(mWhere);
-			sql.append(" ");
-		}
-
-		if (mGroupBy != null) {
-			sql.append("GROUP BY ");
-			sql.append(mGroupBy);
-			sql.append(" ");
-		}
-
-		if (mHaving != null) {
-			sql.append("HAVING ");
-			sql.append(mHaving);
-			sql.append(" ");
-		}
-
-		if (mOrderBy != null) {
-			sql.append("ORDER BY ");
-			sql.append(mOrderBy);
-			sql.append(" ");
-		}
-
-		if (mLimit != null) {
-			sql.append("LIMIT ");
-			sql.append(mLimit);
-			sql.append(" ");
-		}
-
-		if (mOffset != null) {
-			sql.append("OFFSET ");
-			sql.append(mOffset);
-			sql.append(" ");
-		}
-
-		// Don't wast time building the string
-		// unless we're going to log it.
-		if (Log.isEnabled()) {
-			Log.v(sql.toString() + " " + TextUtils.join(",", getArguments()));
-		}
-
-		return sql.toString().trim();
-	}
-
-	public <T extends Model> List<T> execute() {
-		if (mQueryBase instanceof Select) {
-			return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
-		}
-		else {
-			SQLiteUtils.execSql(toSql(), getArguments());
-			Cache.getContext().getContentResolver().notifyChange(ContentProvider
-					.createUri(mType, null), null);
-			return null;
-		}
-	}
-
-	public <T extends Model> T executeSingle() {
-		if (mQueryBase instanceof Select) {
-			limit(1);
-			return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
-		}
-		else {
-			limit(1);
-			SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments()).delete();
-			return null;
-		}
-	}
-
-	public String[] getArguments() {
-		final int size = mArguments.size();
-		final String[] args = new String[size];
-
-		for (int i = 0; i < size; i++) {
-			args[i] = mArguments.get(i).toString();
-		}
-
-		return args;
-	}
+    public From limit(int limit) {
+        return limit(String.valueOf(limit));
+    }
+
+    public From limit(String limit) {
+        mLimit = limit;
+        return this;
+    }
+
+    public From offset(int offset) {
+        return offset(String.valueOf(offset));
+    }
+
+    public From offset(String offset) {
+        mOffset = offset;
+        return this;
+    }
+
+    void addArguments(Object[] args) {
+        mArguments.addAll(Arrays.asList(args));
+    }
+
+    @Override
+    public String toSql() {
+        StringBuilder sql = new StringBuilder();
+        sql.append(mQueryBase.toSql());
+        sql.append("FROM ");
+        sql.append(Cache.getTableName(mType)).append(" ");
+
+        if (mAlias != null) {
+            sql.append("AS ");
+            sql.append(mAlias);
+            sql.append(" ");
+        }
+
+        for (Join join : mJoins) {
+            sql.append(join.toSql());
+        }
+
+        if (mWhere != null) {
+            sql.append("WHERE ");
+            sql.append(mWhere);
+            sql.append(" ");
+        }
+
+        if (mGroupBy != null) {
+            sql.append("GROUP BY ");
+            sql.append(mGroupBy);
+            sql.append(" ");
+        }
+
+        if (mHaving != null) {
+            sql.append("HAVING ");
+            sql.append(mHaving);
+            sql.append(" ");
+        }
+
+        if (mOrderBy != null) {
+            sql.append("ORDER BY ");
+            sql.append(mOrderBy);
+            sql.append(" ");
+        }
+
+        if (mLimit != null) {
+            sql.append("LIMIT ");
+            sql.append(mLimit);
+            sql.append(" ");
+        }
+
+        if (mOffset != null) {
+            sql.append("OFFSET ");
+            sql.append(mOffset);
+            sql.append(" ");
+        }
+
+        // Don't wast time building the string
+        // unless we're going to log it.
+        if (Log.isEnabled()) {
+            Log.v(sql.toString() + " " + TextUtils.join(",", getArguments()));
+        }
+
+        return sql.toString().trim();
+    }
+
+    public void executeSingleAsynchronously(final SingleQueryListener listener) {
+        if (listener != null) {
+            final Handler handler = new Handler();
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    final Model object = executeSingle();
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            listener.onQuerySuccess(object);
+                        }
+                    });
+                }
+            }).start();
+        }
+    }
+
+    public void executeAsynchronously(final QueryListener listener) {
+        if (listener != null) {
+            final Handler handler = new Handler();
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    final List<? extends Model> list = execute();
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            listener.onQuerySuccess(list);
+                        }
+                    });
+                }
+            }).start();
+        }
+    }
+
+    public <T extends Model> List<T> execute() {
+        if (mQueryBase instanceof Select) {
+            return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
+        } else {
+            try {
+                SQLiteUtils.execSql(toSql(), getArguments());
+                Cache.getContext().getContentResolver().notifyChange(ContentProvider
+                        .createUri(mType, null), null);
+            } catch (SQLiteConstraintException e) {
+                Log.e("Error", "" + toSql(), e);
+            }
+            return null;
+        }
+    }
+
+    public <T extends Model> T executeSingle() {
+        if (mQueryBase instanceof Select) {
+            limit(1);
+            return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
+        } else {
+            limit(1);
+            SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments()).delete();
+            return null;
+        }
+    }
+
+    public String[] getArguments() {
+        final int size = mArguments.size();
+        final String[] args = new String[size];
+
+        for (int i = 0; i < size; i++) {
+            args[i] = mArguments.get(i).toString();
+        }
+
+        return args;
+    }
 }
diff --git a/src/com/activeandroid/query/QueryListener.java b/src/com/activeandroid/query/QueryListener.java
new file mode 100644
index 00000000..532287cf
--- /dev/null
+++ b/src/com/activeandroid/query/QueryListener.java
@@ -0,0 +1,13 @@
+package com.activeandroid.query;
+
+import com.activeandroid.Model;
+
+import java.util.List;
+
+/**
+ * Created by aduhem on 15/04/2014.
+ */
+public interface QueryListener {
+
+    public void onQuerySuccess(List<? extends Model> objects);
+}
diff --git a/src/com/activeandroid/query/SingleQueryListener.java b/src/com/activeandroid/query/SingleQueryListener.java
new file mode 100644
index 00000000..b2f34ba8
--- /dev/null
+++ b/src/com/activeandroid/query/SingleQueryListener.java
@@ -0,0 +1,11 @@
+package com.activeandroid.query;
+
+import com.activeandroid.Model;
+
+/**
+ * Created by aduhem on 18/04/2014.
+ */
+public interface SingleQueryListener {
+
+    public void onQuerySuccess(Model object);
+}
