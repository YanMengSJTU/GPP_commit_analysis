diff --git a/README.md b/README.md
index a8975d91..569a9478 100644
--- a/README.md
+++ b/README.md
@@ -10,7 +10,7 @@ _ActiveAndroid On Steroids provides you with a completely thread-safe, priority-
 ## Documentation
 
 * [Getting started](http://github.com/agrosner/ActiveAndroid/wiki/Getting-started)
-* [Creating your database model](http://github.com/agrosner/ActiveAndroid/wiki/Creating-your-database-model)
+* [Creating your database IModel](http://github.com/agrosner/ActiveAndroid/wiki/Creating-your-database-IModel)
 * [Saving to the database](http://github.com/agrosner/ActiveAndroid/wiki/Saving-to-the-database)
 * [Querying the database](http://github.com/agrosner/ActiveAndroid/wiki/Querying-the-database)
 * [DB Managers] (http://github.com/agrosner/ActiveAndroid/wiki/DB-Managers)
diff --git a/pom-child.xml b/pom-child.xml
index 3d2a3631..96ded224 100644
--- a/pom-child.xml
+++ b/pom-child.xml
@@ -4,7 +4,7 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
 
-    <modelVersion>4.0.0</modelVersion>
+    <IModelVersion>4.0.0</IModelVersion>
     <groupId>com.activeandroid</groupId>
     <artifactId>activeandroid</artifactId>
     <version>3.1-SNAPSHOT</version>
diff --git a/pom.xml b/pom.xml
index 500809c4..151b1cff 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
+  <IModelVersion>4.0.0</IModelVersion>
   <groupId>com.activeandroid</groupId>
   <artifactId>activeandroid-parent</artifactId>
   <version>3.1-SNAPSHOT</version>
diff --git a/src/main/java/com/activeandroid/Cache.java b/src/main/java/com/activeandroid/Cache.java
index e6d8b5c6..c0c294a7 100644
--- a/src/main/java/com/activeandroid/Cache.java
+++ b/src/main/java/com/activeandroid/Cache.java
@@ -38,10 +38,10 @@
 
 	private static Context sContext;
 
-	private static ModelInfo sModelInfo;
+	private static ModelInfo sIModelInfo;
 	private static DatabaseHelper sDatabaseHelper;
 
-	private static LruCache<String, Model> sEntities;
+	private static LruCache<String, IModel> sEntities;
 
 	private static boolean sIsInitialized = false;
 
@@ -63,14 +63,14 @@ public static synchronized void initialize(Configuration configuration) {
 		}
 
 		sContext = configuration.getContext();
-		sModelInfo = new ModelInfo(configuration);
+		sIModelInfo = new ModelInfo(configuration);
 		sDatabaseHelper = new DatabaseHelper(configuration);
 
 		// TODO: It would be nice to override sizeOf here and calculate the memory
 		// actually used, however at this point it seems like the reflection
 		// required would be too costly to be of any benefit. We'll just set a max
 		// object size instead.
-		sEntities = new LruCache<String, Model>(configuration.getCacheSize());
+		sEntities = new LruCache<String, IModel>(configuration.getCacheSize());
 
 		openDatabase();
 
@@ -88,7 +88,7 @@ public static synchronized void dispose() {
 		closeDatabase();
 
 		sEntities = null;
-		sModelInfo = null;
+		sIModelInfo = null;
 		sDatabaseHelper = null;
 
 		sIsInitialized = false;
@@ -114,41 +114,41 @@ public static Context getContext() {
 
 	// Entity cache
 
-	public static String getIdentifier(Class<? extends Model> type, String entityId) {
+	public static String getIdentifier(Class<? extends IModel> type, String entityId) {
 		return getTableName(type) + "@" + entityId;
 	}
 
-	public static String getIdentifier(Model entity) {
+	public static String getIdentifier(IModel entity) {
 		return getIdentifier(entity.getClass(), entity.getId());
 	}
 
-	public static synchronized void addEntity(Model entity) {
+	public static synchronized void addEntity(IModel entity) {
 		sEntities.put(getIdentifier(entity), entity);
 	}
 
-	public static synchronized Model getEntity(Class<? extends Model> type, String entityId) {
+	public static synchronized IModel getEntity(Class<? extends IModel> type, String entityId) {
 		return sEntities.get(getIdentifier(type, entityId));
 	}
 
-	public static synchronized void removeEntity(Model entity) {
+	public static synchronized void removeEntity(IModel entity) {
 		sEntities.remove(getIdentifier(entity));
 	}
 
-	// Model cache
+	// IModel cache
 
 	public static synchronized Collection<TableInfo> getTableInfos() {
-		return sModelInfo.getTableInfos();
+		return sIModelInfo.getTableInfos();
 	}
 
-	public static synchronized TableInfo getTableInfo(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type);
+	public static synchronized TableInfo getTableInfo(Class<? extends IModel> type) {
+		return sIModelInfo.getTableInfo(type);
 	}
 
 	public static synchronized TypeSerializer getParserForType(Class<?> type) {
-		return sModelInfo.getTypeSerializer(type);
+		return sIModelInfo.getTypeSerializer(type);
 	}
 
-	public static synchronized String getTableName(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type).getTableName();
+	public static synchronized String getTableName(Class<? extends IModel> type) {
+		return sIModelInfo.getTableInfo(type).getTableName();
 	}
 }
diff --git a/src/main/java/com/activeandroid/Configuration.java b/src/main/java/com/activeandroid/Configuration.java
index 4f1ad20a..3b371557 100644
--- a/src/main/java/com/activeandroid/Configuration.java
+++ b/src/main/java/com/activeandroid/Configuration.java
@@ -34,7 +34,7 @@
 	private Context mContext;
 	private String mDatabaseName;
 	private int mDatabaseVersion;
-	private List<Class<? extends Model>> mModelClasses;
+	private List<Class<? extends IModel>> mModelClasses;
 	private List<Class<? extends TypeSerializer>> mTypeSerializers;
 	private int mCacheSize;
 
@@ -62,7 +62,7 @@ public int getDatabaseVersion() {
 		return mDatabaseVersion;
 	}
 
-	public List<Class<? extends Model>> getModelClasses() {
+	public List<Class<? extends IModel>> getModelClasses() {
 		return mModelClasses;
 	}
 
@@ -104,7 +104,7 @@ public boolean isValid() {
 		private Integer mCacheSize;
 		private String mDatabaseName;
 		private Integer mDatabaseVersion;
-		private List<Class<? extends Model>> mModelClasses;
+		private List<Class<? extends IModel>> mModelClasses;
 		private List<Class<? extends TypeSerializer>> mTypeSerializers;
 
 		//////////////////////////////////////////////////////////////////////////////////////
@@ -135,25 +135,25 @@ public Builder setDatabaseVersion(int databaseVersion) {
 			return this;
 		}
 
-		public Builder addModelClass(Class<? extends Model> modelClass) {
+		public Builder addModelClass(Class<? extends IModel> modelClass) {
 			if (mModelClasses == null) {
-				mModelClasses = new ArrayList<Class<? extends Model>>();
+				mModelClasses = new ArrayList<Class<? extends IModel>>();
 			}
 
 			mModelClasses.add(modelClass);
 			return this;
 		}
 
-		public Builder addModelClasses(Class<? extends Model>... modelClasses) {
+		public Builder addModelClasses(Class<? extends IModel>... modelClasses) {
 			if (mModelClasses == null) {
-				mModelClasses = new ArrayList<Class<? extends Model>>();
+				mModelClasses = new ArrayList<Class<? extends IModel>>();
 			}
 
 			mModelClasses.addAll(Arrays.asList(modelClasses));
 			return this;
 		}
 
-		public Builder setModelClasses(Class<? extends Model>... modelClasses) {
+		public Builder setModelClasses(Class<? extends IModel>... modelClasses) {
 			mModelClasses = Arrays.asList(modelClasses);
 			return this;
 		}
@@ -250,8 +250,8 @@ private int getMetaDataDatabaseVersionOrDefault() {
 			return aaVersion;
 		}
 
-		private List<Class<? extends Model>> loadModelList(String[] models) {
-			final List<Class<? extends Model>> modelClasses = new ArrayList<Class<? extends Model>>();
+		private List<Class<? extends IModel>> loadModelList(String[] models) {
+			final List<Class<? extends IModel>> modelClasses = new ArrayList<Class<? extends IModel>>();
 			final ClassLoader classLoader = mContext.getClass().getClassLoader();
 			for (String model : models) {
 				model = ensurePackageInName(model);
diff --git a/src/main/java/com/activeandroid/IModel.java b/src/main/java/com/activeandroid/IModel.java
new file mode 100644
index 00000000..7814a159
--- /dev/null
+++ b/src/main/java/com/activeandroid/IModel.java
@@ -0,0 +1,42 @@
+package com.activeandroid;
+
+import android.database.Cursor;
+
+/**
+ * Author: andrewgrosner
+ * Date: 6/16/14
+ * Contributors: { }
+ * Description: Describes the base interface for all DB classes
+ */
+public interface IModel {
+
+    public void save();
+
+    public void delete();
+
+    /**
+     * if the object exists in the DB
+     * @return
+     */
+    public boolean exists();
+
+    /**
+     * Load the model from the cursor
+     * @param cursor
+     */
+    public void loadFromCursor(Cursor cursor);
+
+    /**
+     * Set the id returned by the DB
+     * @param id
+     */
+    public void setRowId(long id);
+
+    public long getRowId();
+
+    /**
+     * Return the ID of this class specified by "(" and comma separated primary key fields
+     * @return
+     */
+    public String getId();
+}
diff --git a/src/main/java/com/activeandroid/Model.java b/src/main/java/com/activeandroid/Model.java
index 2f6663e9..d9193e6b 100644
--- a/src/main/java/com/activeandroid/Model.java
+++ b/src/main/java/com/activeandroid/Model.java
@@ -34,27 +34,16 @@
 import java.util.List;
 
 @SuppressWarnings("unchecked")
-public abstract class Model {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+public abstract class Model implements IModel{
 
 	private TableInfo mTableInfo;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	public Model() {
 		mTableInfo = Cache.getTableInfo(getClass());
 	}
 
     private long mId;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
     /**
      * Use This method to return the values of your primary key, must be separated by comma delimiter in order of declaration
      * Also each object thats instance of {@link java.lang.Number} must be DataBaseUtils.sqlEscapeString(object.toString)
@@ -62,272 +51,42 @@ public Model() {
      */
 	public abstract String getId();
 
+    @Override
 	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), SQLiteUtils.getWhereStatement(this, mTableInfo), null);
-		Cache.removeEntity(this);
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), getId()), null);
+		SQLiteUtils.delete(this);
 	}
 
+    @Override
 	public final void save() {
-		final SQLiteDatabase db = Cache.openDatabase();
-		final ContentValues values = new ContentValues();
-
-		for (Field field : mTableInfo.getFields()) {
-			String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-
-			field.setAccessible(true);
-
-			try {
-				Object value = field.get(this);
-
-				if (value != null) {
-					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-					if (typeSerializer != null) {
-						// serialize data
-						value = typeSerializer.serialize(value);
-						// set new object type
-						if (value != null) {
-							fieldType = value.getClass();
-							// check that the serializer returned what it promised
-							if (!fieldType.equals(typeSerializer.getSerializedType())) {
-								AALog.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-                                        typeSerializer.getSerializedType(), fieldType));
-							}
-						}
-					}
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (value == null) {
-					values.putNull(fieldName);
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					values.put(fieldName, (Byte) value);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					values.put(fieldName, (Short) value);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					values.put(fieldName, (Integer) value);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					values.put(fieldName, (Long) value);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					values.put(fieldName, (Float) value);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					values.put(fieldName, (Double) value);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					values.put(fieldName, (Boolean) value);
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(String.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					values.put(fieldName, (byte[]) value);
-				}
-				else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
-                    ForeignKey key = field.getAnnotation(ForeignKey.class);
-                    if(!key.name().equals("")){
-                        fieldName = field.getAnnotation(ForeignKey.class).name();
-                    }
-					values.put(fieldName, ((Model) value).getId());
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					values.put(fieldName, ((Enum<?>) value).name());
-				}
-			}
-			catch (IllegalArgumentException e) {
-				AALog.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				AALog.e(e.getClass().getName(), e);
-			}
-		}
-
-        if(!exists()){
-		     mId = db.insert(mTableInfo.getTableName(), null, values);
-
-            for(Field field : mTableInfo.getPrimaryKeys()){
-                if(field.isAnnotationPresent(PrimaryKey.class) &&
-                        field.getAnnotation(PrimaryKey.class).type().equals(PrimaryKey.Type.AUTO_INCREMENT)){
-                    field.setAccessible(true);
-                    try {
-                        field.set(this, mId);
-                    } catch (Throwable e) {
-                        throw new RuntimeException(e);
-                    }
-                }
-            }
-        } else {
-			mId = db.update(mTableInfo.getTableName(), values, SQLiteUtils.getWhereStatement(this, mTableInfo), null);
-		}
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), getId()), null);
+        SQLiteUtils.save(this);
 	}
 
+    @Override
     public boolean exists(){
-        Model model = new Select().from(getClass()).where(SQLiteUtils.getWhereStatement(this, mTableInfo)).executeSingle();
-        return model!=null;
+        return SQLiteUtils.exists(this);
     }
 
     public void update(){
 
     }
 
-    /**
-     * Checks to see if object exists, if so, deletes it then updates itself
-     */
-    public <OBJECT_CLASS extends Model> void saveById(){
-        if(exists()){
-            delete();
-        }
-        save();
-    }
-
-	// Convenience methods
-
-	public static void delete(Class<? extends Model> type, long id) {
-		new Delete().from(type).where("Id=?", id).execute();
-	}
-
-	public static <T extends Model> T load(Class<T> type, long id) {
-		return new Select().from(type).where("Id=?", id).executeSingle();
-	}
-
-	// Model population
-
+    @Override
 	public final void loadFromCursor(Cursor cursor) {
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-			final int columnIndex = cursor.getColumnIndex(fieldName);
-
-			if (columnIndex < 0) {
-				continue;
-			}
-
-			field.setAccessible(true);
-
-			try {
-				boolean columnIsNull = cursor.isNull(columnIndex);
-				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-				Object value = null;
-
-				if (typeSerializer != null) {
-					fieldType = typeSerializer.getSerializedType();
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (columnIsNull) {
-					field = null;
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					value = cursor.getLong(columnIndex);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					value = cursor.getFloat(columnIndex);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					value = cursor.getDouble(columnIndex);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					value = cursor.getInt(columnIndex) != 0;
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					value = cursor.getString(columnIndex).charAt(0);
-				}
-				else if (fieldType.equals(String.class)) {
-					value = cursor.getString(columnIndex);
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					value = cursor.getBlob(columnIndex);
-				}
-				else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
-					final String entityId = cursor.getString(columnIndex);
-					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
-
-					Model entity = Cache.getEntity(entityType, entityId);
-					if (entity == null) {
-						entity = new Select().from(entityType).where(SQLiteUtils.getWhereFromEntityId(entityType, entityId)).executeSingle();
-					}
-
-					value = entity;
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					@SuppressWarnings("rawtypes")
-					final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-					value = Enum.valueOf(enumType, cursor.getString(columnIndex));
-				}
-
-				// Use a deserializer if one is available
-				if (typeSerializer != null && !columnIsNull) {
-					value = typeSerializer.deserialize(value);
-				}
-
-				// Set the field name
-				if (value != null) {
-					field.set(this, value);
-				}
-			}
-			catch (IllegalArgumentException e) {
-				AALog.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				AALog.e(e.getClass().getName(), e);
-			}
-			catch (SecurityException e) {
-				AALog.e(e.getClass().getName(), e);
-			}
-		}
-
-		if (getId() != null) {
-			Cache.addEntity(this);
-		}
+        SQLiteUtils.loadFromCursor(cursor, this);
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-    protected final <T extends Model> List<T> getManyFromField(Class<T> type,Object field, String foreignKey){
-        return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", field).execute();
-    }
-
-    protected final <T extends Model> List<T> getManyFromFieldWithSort(Class<T> type,Object field, String foreignKey, String sort){
-        return new Select().from(type).orderBy(sort).where(Cache.getTableName(type) + "." + foreignKey + "=?", field).execute();
-    }
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	@Override
 	public String toString() {
 		return mTableInfo!=null? mTableInfo.getTableName() + "@" + getId() : "No Table for: " + getClass() + "@" + getId();
 	}
 
+    @Override
     public long getRowId(){
         return mId;
     }
+
+    @Override
+    public void setRowId(long id) {
+        this.mId = id;
+    }
 }
diff --git a/src/main/java/com/activeandroid/ModelInfo.java b/src/main/java/com/activeandroid/ModelInfo.java
index 67cf4d4c..919572ac 100644
--- a/src/main/java/com/activeandroid/ModelInfo.java
+++ b/src/main/java/com/activeandroid/ModelInfo.java
@@ -43,7 +43,7 @@
 	// PRIVATE METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	private Map<Class<? extends Model>, TableInfo> mTableInfos = new HashMap<Class<? extends Model>, TableInfo>();
+	private Map<Class<? extends IModel>, TableInfo> mTableInfos = new HashMap<Class<? extends IModel>, TableInfo>();
 	private Map<Class<?>, TypeSerializer> mTypeSerializers = new HashMap<Class<?>, TypeSerializer>() {
 		{
 			put(Calendar.class, new CalendarSerializer());
@@ -77,7 +77,7 @@ public ModelInfo(Configuration configuration) {
 		return mTableInfos.values();
 	}
 
-	public TableInfo getTableInfo(Class<? extends Model> type) {
+	public TableInfo getTableInfo(Class<? extends IModel> type) {
 		return mTableInfos.get(type);
 	}
 
@@ -94,10 +94,10 @@ private boolean loadModelFromMetaData(Configuration configuration) {
 			return false;
 		}
 
-		final List<Class<? extends Model>> models = configuration.getModelClasses();
+		final List<Class<? extends IModel>> models = configuration.getModelClasses();
 		if (models != null) {
-			for (Class<? extends Model> model : models) {
-				mTableInfos.put(model, new TableInfo(model));
+			for (Class<? extends IModel> IModel : models) {
+				mTableInfos.put(IModel, new TableInfo(IModel));
 			}
 		}
 
@@ -186,7 +186,7 @@ private void scanForModelClasses(File path, String packageName, ClassLoader clas
 				Class<?> discoveredClass = Class.forName(className, false, classLoader);
 				if (ReflectionUtils.isModel(discoveredClass) && !discoveredClass.isAnnotationPresent(Ignore.class)) {
 					@SuppressWarnings("unchecked")
-					Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
+					Class<? extends IModel> modelClass = (Class<? extends IModel>) discoveredClass;
 					mTableInfos.put(modelClass, new TableInfo(modelClass));
 				}
 				else if (ReflectionUtils.isTypeSerializer(discoveredClass) && !discoveredClass.isAnnotationPresent(Ignore.class)) {
diff --git a/src/main/java/com/activeandroid/TableInfo.java b/src/main/java/com/activeandroid/TableInfo.java
index dc0f94a2..d87fd2e2 100644
--- a/src/main/java/com/activeandroid/TableInfo.java
+++ b/src/main/java/com/activeandroid/TableInfo.java
@@ -37,7 +37,7 @@
 	// PRIVATE MEMBERS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	private Class<? extends Model> mType;
+	private Class<? extends IModel> mType;
 	private String mTableName;
 
 	private Map<Field, String> mColumnNames = new HashMap<Field, String>();
@@ -48,7 +48,7 @@
 	// CONSTRUCTORS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	public TableInfo(Class<? extends Model> type) {
+	public TableInfo(Class<? extends IModel> type) {
 		mType = type;
 
 		final Table tableAnnotation = type.getAnnotation(Table.class);
@@ -98,7 +98,7 @@ public TableInfo(Class<? extends Model> type) {
 	// PUBLIC METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	public Class<? extends Model> getType() {
+	public Class<? extends IModel> getType() {
 		return mType;
 	}
 
@@ -119,7 +119,7 @@ public String getColumnName(Field field) {
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	private Field getIdField(Class<?> type) {
-		if (type.equals(Model.class)) {
+		if (type.equals(IModel.class)) {
 			try {
 				return type.getDeclaredField("mId");
 			}
diff --git a/src/main/java/com/activeandroid/content/ContentProvider.java b/src/main/java/com/activeandroid/content/ContentProvider.java
index 1299d65a..f8f2cfb6 100644
--- a/src/main/java/com/activeandroid/content/ContentProvider.java
+++ b/src/main/java/com/activeandroid/content/ContentProvider.java
@@ -12,7 +12,7 @@
 import com.activeandroid.ActiveAndroid;
 import com.activeandroid.Cache;
 import com.activeandroid.Configuration;
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 import com.activeandroid.TableInfo;
 
 public class ContentProvider extends android.content.ContentProvider {
@@ -21,7 +21,7 @@
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
-	private static final SparseArray<Class<? extends Model>> TYPE_CODES = new SparseArray<Class<? extends Model>>();
+	private static final SparseArray<Class<? extends IModel>> TYPE_CODES = new SparseArray<Class<? extends IModel>>();
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
@@ -67,7 +67,7 @@ public String getType(Uri uri) {
 			return cachedMimeType;
 		}
 
-		final Class<? extends Model> type = getModelType(uri);
+		final Class<? extends IModel> type = getModelType(uri);
 		final boolean single = ((match % 2) == 0);
 
 		StringBuilder mimeType = new StringBuilder();
@@ -92,7 +92,7 @@ public String getType(Uri uri) {
 
 	@Override
 	public Uri insert(Uri uri, ContentValues values) {
-		final Class<? extends Model> type = getModelType(uri);
+		final Class<? extends IModel> type = getModelType(uri);
 		final Long id = Cache.openDatabase().insert(Cache.getTableName(type), null, values);
 
 		if (id != null && id > 0) {
@@ -107,7 +107,7 @@ public Uri insert(Uri uri, ContentValues values) {
 
 	@Override
 	public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-		final Class<? extends Model> type = getModelType(uri);
+		final Class<? extends IModel> type = getModelType(uri);
 		final int count = Cache.openDatabase().update(Cache.getTableName(type), values, selection, selectionArgs);
 
 		notifyChange(uri);
@@ -117,7 +117,7 @@ public int update(Uri uri, ContentValues values, String selection, String[] sele
 
 	@Override
 	public int delete(Uri uri, String selection, String[] selectionArgs) {
-		final Class<? extends Model> type = getModelType(uri);
+		final Class<? extends IModel> type = getModelType(uri);
 		final int count = Cache.openDatabase().delete(Cache.getTableName(type), selection, selectionArgs);
 
 		notifyChange(uri);
@@ -127,7 +127,7 @@ public int delete(Uri uri, String selection, String[] selectionArgs) {
 
 	@Override
 	public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
-		final Class<? extends Model> type = getModelType(uri);
+		final Class<? extends IModel> type = getModelType(uri);
 		final Cursor cursor = Cache.openDatabase().query(
 				Cache.getTableName(type),
 				projection,
@@ -146,7 +146,7 @@ public Cursor query(Uri uri, String[] projection, String selection, String[] sel
 	// PUBLIC METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	public static Uri createUri(Class<? extends Model> type, String id) {
+	public static Uri createUri(Class<? extends IModel> type, String id) {
 		final StringBuilder uri = new StringBuilder();
 		uri.append("content://");
 		uri.append(sAuthority);
@@ -177,7 +177,7 @@ protected Configuration getConfiguration() {
 	// PRIVATE METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	private Class<? extends Model> getModelType(Uri uri) {
+	private Class<? extends IModel> getModelType(Uri uri) {
 		final int code = URI_MATCHER.match(uri);
 		if (code != UriMatcher.NO_MATCH) {
 			return TYPE_CODES.get(code);
diff --git a/src/main/java/com/activeandroid/interfaces/ObjectRequester.java b/src/main/java/com/activeandroid/interfaces/ObjectRequester.java
index 111913e6..36916c89 100644
--- a/src/main/java/com/activeandroid/interfaces/ObjectRequester.java
+++ b/src/main/java/com/activeandroid/interfaces/ObjectRequester.java
@@ -1,6 +1,6 @@
 package com.activeandroid.interfaces;
 
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 
 /**
 * Created by andrewgrosner
@@ -8,7 +8,7 @@
 * Contributors:
 * Description:
 */
-public interface ObjectRequester<OBJECT_CLASS extends Model>{
+public interface ObjectRequester<OBJECT_CLASS extends IModel>{
     /**
      * Implement this method to perform a request if the object does not exist in the DB
      * @param objectReceiver
diff --git a/src/main/java/com/activeandroid/manager/DBManager.java b/src/main/java/com/activeandroid/manager/DBManager.java
index 1c525112..54b47c55 100644
--- a/src/main/java/com/activeandroid/manager/DBManager.java
+++ b/src/main/java/com/activeandroid/manager/DBManager.java
@@ -1,6 +1,6 @@
 package com.activeandroid.manager;
 
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 import com.activeandroid.interfaces.CollectionReceiver;
 import com.activeandroid.interfaces.ObjectReceiver;
 import com.activeandroid.runtime.DBRequest;
@@ -17,7 +17,7 @@
  *
  * @param <OBJECT_CLASS> - the class of objects that represent a Model from the DB
  */
-public abstract class DBManager<OBJECT_CLASS extends Model> extends SingleDBManager{
+public abstract class DBManager<OBJECT_CLASS extends IModel> extends SingleDBManager{
 
     protected Class<OBJECT_CLASS> mObjectClass;
 
diff --git a/src/main/java/com/activeandroid/manager/DBManagerCache.java b/src/main/java/com/activeandroid/manager/DBManagerCache.java
index f20a0dce..219ed2ac 100644
--- a/src/main/java/com/activeandroid/manager/DBManagerCache.java
+++ b/src/main/java/com/activeandroid/manager/DBManagerCache.java
@@ -1,6 +1,6 @@
 package com.activeandroid.manager;
 
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
@@ -87,7 +87,7 @@ public static Object invokeGetMethod(Object inObject, int index){
         }
     }
 
-    public static <OBJECT_CLASS extends Model> OBJECT_CLASS constructNewInstance(Object inObject, Class<OBJECT_CLASS> objectClass){
+    public static <OBJECT_CLASS extends IModel> OBJECT_CLASS constructNewInstance(Object inObject, Class<OBJECT_CLASS> objectClass){
         Constructor<OBJECT_CLASS> constructor = mConstructorMap.get(objectClass);
         if(constructor==null){
             try {
diff --git a/src/main/java/com/activeandroid/manager/SingleDBManager.java b/src/main/java/com/activeandroid/manager/SingleDBManager.java
index 790a8c0a..6d99e2d4 100644
--- a/src/main/java/com/activeandroid/manager/SingleDBManager.java
+++ b/src/main/java/com/activeandroid/manager/SingleDBManager.java
@@ -5,7 +5,7 @@
 
 import com.activeandroid.ActiveAndroid;
 import com.activeandroid.Cache;
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 import com.activeandroid.exception.DBManagerNotOnMainException;
 import com.activeandroid.interfaces.ObjectRequester;
 import com.activeandroid.query.Delete;
@@ -131,7 +131,7 @@ protected synchronized void processOnForeground(Runnable runnable){
         mRequestHandler.post(runnable);
     }
 
-    public <OBJECT_CLASS extends Model> OBJECT_CLASS getObject(Class<OBJECT_CLASS> obClazz, Object object){
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObject(Class<OBJECT_CLASS> obClazz, Object object){
        return DBManagerCache.constructNewInstance(object, obClazz);
     }
 
@@ -139,7 +139,7 @@ protected synchronized void processOnForeground(Runnable runnable){
      * Adds an object to the manager's database
      * @param inObject - object of the class defined by the manager
      */
-    public <OBJECT_CLASS extends Model> OBJECT_CLASS add(OBJECT_CLASS inObject){
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS add(OBJECT_CLASS inObject){
         inObject.save();
         return inObject;
     }
@@ -148,7 +148,7 @@ protected synchronized void processOnForeground(Runnable runnable){
      * Adds a json object to this class, however its advised you ensure that the jsonobject being passed is what you want, since there's no type checking
      * @param object
      */
-    public <OBJECT_CLASS extends Model> OBJECT_CLASS add(Class<OBJECT_CLASS> obClazz, Object object){
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS add(Class<OBJECT_CLASS> obClazz, Object object){
         try {
             return add(getObject(obClazz,object));
         } catch (Throwable e) {
@@ -161,7 +161,7 @@ protected synchronized void processOnForeground(Runnable runnable){
      * Adds an object to the DB in the BG
      * @param jsonObject
      */
-    public <OBJECT_CLASS extends Model> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject, final ObjectReceiver<OBJECT_CLASS> objectReceiver){
+    public <OBJECT_CLASS extends IModel> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject, final ObjectReceiver<OBJECT_CLASS> objectReceiver){
         OBJECT_CLASS object = getObject(obClazz, jsonObject);
         if(objectReceiver!=null){
             objectReceiver.onObjectReceived(object);
@@ -170,12 +170,12 @@ protected synchronized void processOnForeground(Runnable runnable){
 
     }
 
-    public <OBJECT_CLASS extends Model> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject){
+    public <OBJECT_CLASS extends IModel> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject){
         addInBackground(obClazz, jsonObject,null);
     }
 
 
-    public <OBJECT_CLASS extends Model> void addInBackground(final OBJECT_CLASS object){
+    public <OBJECT_CLASS extends IModel> void addInBackground(final OBJECT_CLASS object){
         getSaveQueue().add(object);
     }
 
@@ -183,7 +183,7 @@ protected synchronized void processOnForeground(Runnable runnable){
      * Adds all objects to the DB
      * @param objects
      */
-    public <OBJECT_CLASS extends Model, COLLECTION_CLASS extends Collection<OBJECT_CLASS>> void addAll(COLLECTION_CLASS objects){
+    public <OBJECT_CLASS extends IModel, COLLECTION_CLASS extends Collection<OBJECT_CLASS>> void addAll(COLLECTION_CLASS objects){
         ActiveAndroid.beginTransaction();
         try{
             for(OBJECT_CLASS object: objects){
@@ -199,7 +199,7 @@ protected synchronized void processOnForeground(Runnable runnable){
      * Adds all objects from the passed object (if it has collection-like methods), may NOT be type-safe so be careful with this
      * @param array
      */
-    public <OBJECT_CLASS extends Model> void addAll(Class<OBJECT_CLASS> obClazz, Object array){
+    public <OBJECT_CLASS extends IModel> void addAll(Class<OBJECT_CLASS> obClazz, Object array){
         ActiveAndroid.beginTransaction();
         try{
             int count = DBManagerCache.invokeGetSizeMethod(array);
@@ -217,12 +217,12 @@ protected synchronized void processOnForeground(Runnable runnable){
 
     }
 
-    public <OBJECT_CLASS extends Model> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array) {
+    public <OBJECT_CLASS extends IModel> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array) {
         addAllInBackground(obClazz, array, null);
     }
 
 
-    public <OBJECT_CLASS extends Model> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array, final CollectionReceiver<OBJECT_CLASS> collectionReceiver){
+    public <OBJECT_CLASS extends IModel> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array, final CollectionReceiver<OBJECT_CLASS> collectionReceiver){
         processOnBackground(new DBRequest() {
             @Override
             public void run() {
@@ -248,7 +248,7 @@ public void run() {
 
     }
 
-    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends Model> void addAllInBackground(final COLLECTION_CLASS collection){
+    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void addAllInBackground(final COLLECTION_CLASS collection){
        getSaveQueue().addAll(collection);
     }
 
@@ -257,7 +257,7 @@ public void run() {
      * Its recommended not to call this method in the foreground thread
      * @return
      */
-    public <OBJECT_CLASS extends Model> List<OBJECT_CLASS> getAll(final Class<OBJECT_CLASS> obClazz){
+    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAll(final Class<OBJECT_CLASS> obClazz){
         return new Select().from(obClazz).execute();
     }
 
@@ -267,7 +267,7 @@ public void run() {
      * @param sort - valid SQLLite syntax for sort e.g. name ASC
      * @return
      */
-    public <OBJECT_CLASS extends Model> List<OBJECT_CLASS> getAllWithSort(Class<OBJECT_CLASS> obClazz, String sort){
+    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithSort(Class<OBJECT_CLASS> obClazz, String sort){
         return new Select().from(obClazz).orderBy(sort).execute();
     }
 
@@ -275,7 +275,7 @@ public void run() {
      * Fetches objects from this DB on the BG
      * @param receiver - function to call when finished that passes the list of objects that was found
      */
-    public <OBJECT_CLASS extends Model> void fetchAll(final Class<OBJECT_CLASS> obClazz, final CollectionReceiver<OBJECT_CLASS> receiver){
+    public <OBJECT_CLASS extends IModel> void fetchAll(final Class<OBJECT_CLASS> obClazz, final CollectionReceiver<OBJECT_CLASS> receiver){
         processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
             @Override
             public void run() {
@@ -295,7 +295,7 @@ public void run() {
      * @param sort - valid SQLLite syntax for sort e.g. name ASC
      * @param receiver - function to call when finished that passes the list of objects that was found
      */
-    public <OBJECT_CLASS extends Model> void fetchAllWithSort(final Class<OBJECT_CLASS> obClazz, final String sort, final CollectionReceiver<OBJECT_CLASS> receiver){
+    public <OBJECT_CLASS extends IModel> void fetchAllWithSort(final Class<OBJECT_CLASS> obClazz, final String sort, final CollectionReceiver<OBJECT_CLASS> receiver){
         processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
             @Override
             public void run() {
@@ -310,7 +310,7 @@ public void run() {
         });
     };
 
-    public <OBJECT_CLASS extends Model> void fetchAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, final Object value, final String column, final CollectionReceiver<OBJECT_CLASS> receiver){
+    public <OBJECT_CLASS extends IModel> void fetchAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, final Object value, final String column, final CollectionReceiver<OBJECT_CLASS> receiver){
         processOnBackground(new DBRequest(DBRequestInfo.create("fetch" , DBRequest.PRIORITY_UI)) {
             @Override
             public void run() {
@@ -329,7 +329,7 @@ public void run() {
      * This will get the where statement for this object, the amount of ids passed must match the primary key column size
      * @return
      */
-    public <OBJECT_CLASS extends Model> OBJECT_CLASS getObjectById(final Class<OBJECT_CLASS> obClazz, Object...ids){
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObjectById(final Class<OBJECT_CLASS> obClazz, Object...ids){
         return new Select().from(obClazz).where(SQLiteUtils.getWhereStatement(obClazz, Cache.getTableInfo(obClazz)), ids).executeSingle();
     }
 
@@ -340,7 +340,7 @@ public void run() {
      * @param uid
      * @return
      */
-    public <OBJECT_CLASS extends Model> OBJECT_CLASS getObjectByColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object uid){
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObjectByColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object uid){
         return new Select().from(obClazz).where(column+" =?", uid).executeSingle();
     }
 
@@ -350,7 +350,7 @@ public void run() {
      * @param value
      * @return
      */
-    public <OBJECT_CLASS extends Model> List<OBJECT_CLASS> getAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object value){
+    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object value){
         return new Select().from(obClazz).where(column + "= ?", value).execute();
     }
 
@@ -361,7 +361,7 @@ public void run() {
      * @param <OBJECT_CLASS>
      * @return
      */
-    public <OBJECT_CLASS extends Model> List<OBJECT_CLASS> getAllWithGroupby(final Class<OBJECT_CLASS> obClazz, String groupBy){
+    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithGroupby(final Class<OBJECT_CLASS> obClazz, String groupBy){
         return new Select().from(obClazz).groupBy(groupBy).execute();
     }
 
@@ -369,7 +369,7 @@ public void run() {
      * Returns the count of rows from this DB manager's DB
      * @return
      */
-    public long getCount(final Class<? extends Model> obClazz){
+    public long getCount(final Class<? extends IModel> obClazz){
         return DatabaseUtils.queryNumEntries(Cache.openDatabase(), Cache.getTableName(obClazz));
     }
 
@@ -377,7 +377,7 @@ public long getCount(final Class<? extends Model> obClazz){
      * Fetches the count on the DB thread and returns it on the handler
      * @param objectReceiver
      */
-    public <OBJECT_CLASS extends Model> void fetchCount(final Class<OBJECT_CLASS> obclazz, final ObjectReceiver<Long> objectReceiver){
+    public <OBJECT_CLASS extends IModel> void fetchCount(final Class<OBJECT_CLASS> obclazz, final ObjectReceiver<Long> objectReceiver){
         processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
             @Override
             public void run() {
@@ -398,7 +398,7 @@ public void run() {
      * @param uid
      * @return true if the object exists in the DB, otherwise its on a BG thread
      */
-    public <OBJECT_CLASS extends Model> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectRequester<OBJECT_CLASS> requester,  final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
+    public <OBJECT_CLASS extends IModel> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectRequester<OBJECT_CLASS> requester,  final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
         OBJECT_CLASS object = getObjectById(obClazz, uid);
         if(object==null&&requester!=null){
             processOnForeground(new Runnable() {
@@ -420,7 +420,7 @@ public void run() {
      * @param uid
      * @return true if the object exists in the DB, otherwise its on a BG thread
      */
-    public <OBJECT_CLASS extends Model> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
+    public <OBJECT_CLASS extends IModel> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
        return fetchObject(obClazz, null, objectReceiver, uid);
     }
 
@@ -430,7 +430,7 @@ public void run() {
      * @param obClazz
      * @param <OBJECT_CLASS>
      */
-    public <OBJECT_CLASS extends Model> void deleteAll(Class<OBJECT_CLASS> obClazz){
+    public <OBJECT_CLASS extends IModel> void deleteAll(Class<OBJECT_CLASS> obClazz){
         new Delete().from(obClazz).execute();
     }
 
@@ -438,7 +438,7 @@ public void run() {
      * Deletes objects from the db
      * @param <OBJECT_CLASS>
      */
-    public<OBJECT_CLASS extends Model> void deleteAll(OBJECT_CLASS...objects) {
+    public<OBJECT_CLASS extends IModel> void deleteAll(OBJECT_CLASS...objects) {
         ActiveAndroid.beginTransaction();
         try{
             for(OBJECT_CLASS object: objects){
@@ -452,9 +452,9 @@ public void run() {
 
     /**
      * Deletes all objects from the collection specified
-     * @param objects - the list of model objects you wish to delete
+     * @param objects - the list of IModel objects you wish to delete
      */
-    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends Model> void deleteAll(COLLECTION_CLASS objects) {
+    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void deleteAll(COLLECTION_CLASS objects) {
         ActiveAndroid.beginTransaction();
         try{
             for(OBJECT_CLASS object: objects){
@@ -473,7 +473,7 @@ public void run() {
      * @param objects
      * @param <OBJECT_CLASS>
      */
-    public<LIST_CLASS extends List<OBJECT_CLASS>, OBJECT_CLASS extends Model> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final LIST_CLASS objects) {
+    public<LIST_CLASS extends List<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final LIST_CLASS objects) {
         processOnBackground(new DBRequest(dbRequestInfo) {
             @Override
             public void run() {
@@ -492,7 +492,7 @@ public void run() {
      * @param objects
      * @param <OBJECT_CLASS>
      */
-    public<OBJECT_CLASS extends Model> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final OBJECT_CLASS...objects) {
+    public<OBJECT_CLASS extends IModel> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final OBJECT_CLASS...objects) {
         processOnBackground(new DBRequest(dbRequestInfo) {
             @Override
             public void run() {
diff --git a/src/main/java/com/activeandroid/query/Delete.java b/src/main/java/com/activeandroid/query/Delete.java
index 6d19dced..46313ef4 100644
--- a/src/main/java/com/activeandroid/query/Delete.java
+++ b/src/main/java/com/activeandroid/query/Delete.java
@@ -16,13 +16,13 @@
  * limitations under the License.
  */
 
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 
 public final class Delete implements Sqlable {
 	public Delete() {
 	}
 
-	public From from(Class<? extends Model> table) {
+	public From from(Class<? extends IModel> table) {
 		return new From(table, this);
 	}
 
diff --git a/src/main/java/com/activeandroid/query/From.java b/src/main/java/com/activeandroid/query/From.java
index a410a1b7..88567611 100644
--- a/src/main/java/com/activeandroid/query/From.java
+++ b/src/main/java/com/activeandroid/query/From.java
@@ -20,7 +20,7 @@
 import android.database.DatabaseUtils;
 import android.text.TextUtils;
 import com.activeandroid.Cache;
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 import com.activeandroid.query.Join.JoinType;
 import com.activeandroid.util.AALog;
 import com.activeandroid.util.SQLiteUtils;
@@ -32,7 +32,7 @@
 public final class From implements Sqlable {
 	private Sqlable mQueryBase;
 
-	private Class<? extends Model> mType;
+	private Class<? extends IModel> mType;
 	private String mAlias;
 	private List<Join> mJoins;
 	private String mWhere;
@@ -44,7 +44,7 @@
 
 	private List<Object> mArguments;
 
-	public From(Class<? extends Model> table, Sqlable queryBase) {
+	public From(Class<? extends IModel> table, Sqlable queryBase) {
 		mType = table;
 		mJoins = new ArrayList<Join>();
 		mQueryBase = queryBase;
@@ -58,31 +58,31 @@ public From as(String alias) {
 		return this;
 	}
 
-	public Join join(Class<? extends Model> table) {
+	public Join join(Class<? extends IModel> table) {
 		Join join = new Join(this, table, null);
 		mJoins.add(join);
 		return join;
 	}
 
-	public Join leftJoin(Class<? extends Model> table) {
+	public Join leftJoin(Class<? extends IModel> table) {
 		Join join = new Join(this, table, JoinType.LEFT);
 		mJoins.add(join);
 		return join;
 	}
 
-	public Join outerJoin(Class<? extends Model> table) {
+	public Join outerJoin(Class<? extends IModel> table) {
 		Join join = new Join(this, table, JoinType.OUTER);
 		mJoins.add(join);
 		return join;
 	}
 
-	public Join innerJoin(Class<? extends Model> table) {
+	public Join innerJoin(Class<? extends IModel> table) {
 		Join join = new Join(this, table, JoinType.INNER);
 		mJoins.add(join);
 		return join;
 	}
 
-	public Join crossJoin(Class<? extends Model> table) {
+	public Join crossJoin(Class<? extends IModel> table) {
 		Join join = new Join(this, table, JoinType.CROSS);
 		mJoins.add(join);
 		return join;
@@ -215,7 +215,7 @@ public long executeCount(){
         }
     }
 
-	public <T extends Model> List<T> execute() {
+	public <T extends IModel> List<T> execute() {
 		if (mQueryBase instanceof Select) {
 			return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
 		}
@@ -233,7 +233,7 @@ public Cursor getCursor(){
         return Cache.openDatabase().rawQuery(toSql(), getArguments());
     }
 
-	public <T extends Model> T executeSingle() {
+	public <T extends IModel> T executeSingle() {
 		if (mQueryBase instanceof Select) {
 			limit(1);
 			return SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
diff --git a/src/main/java/com/activeandroid/query/Join.java b/src/main/java/com/activeandroid/query/Join.java
index 13cdba3b..2d5b8419 100644
--- a/src/main/java/com/activeandroid/query/Join.java
+++ b/src/main/java/com/activeandroid/query/Join.java
@@ -19,7 +19,7 @@
 import android.text.TextUtils;
 
 import com.activeandroid.Cache;
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 
 public final class Join implements Sqlable {
 	static enum JoinType {
@@ -27,13 +27,13 @@
 	}
 
 	private From mFrom;
-	private Class<? extends Model> mType;
+	private Class<? extends IModel> mType;
 	private String mAlias;
 	private JoinType mJoinType;
 	private String mOn;
 	private String[] mUsing;
 
-	Join(From from, Class<? extends Model> table, JoinType joinType) {
+	Join(From from, Class<? extends IModel> table, JoinType joinType) {
 		mFrom = from;
 		mType = table;
 		mJoinType = joinType;
diff --git a/src/main/java/com/activeandroid/query/Select.java b/src/main/java/com/activeandroid/query/Select.java
index e3de2708..f12d79eb 100644
--- a/src/main/java/com/activeandroid/query/Select.java
+++ b/src/main/java/com/activeandroid/query/Select.java
@@ -18,7 +18,7 @@
 
 import android.text.TextUtils;
 
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 
 public final class Select implements Sqlable {
 	private String[] mColumns;
@@ -64,7 +64,7 @@ public Select count(){
         return this;
     }
 
-	public From from(Class<? extends Model> table) {
+	public From from(Class<? extends IModel> table) {
 		return new From(table, this);
 	}
 
diff --git a/src/main/java/com/activeandroid/query/Update.java b/src/main/java/com/activeandroid/query/Update.java
index 336c4821..509db5b4 100644
--- a/src/main/java/com/activeandroid/query/Update.java
+++ b/src/main/java/com/activeandroid/query/Update.java
@@ -17,12 +17,12 @@
  */
 
 import com.activeandroid.Cache;
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 
 public final class Update implements Sqlable {
-	private Class<? extends Model> mType;
+	private Class<? extends IModel> mType;
 
-	public Update(Class<? extends Model> table) {
+	public Update(Class<? extends IModel> table) {
 		mType = table;
 	}
 
@@ -34,7 +34,7 @@ public Set set(String set, Object... args) {
 		return new Set(this, set, args);
 	}
 
-	Class<? extends Model> getType() {
+	Class<? extends IModel> getType() {
 		return mType;
 	}
 
diff --git a/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java b/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java
index c95c9751..1fb2d5ba 100644
--- a/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java
+++ b/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java
@@ -3,7 +3,7 @@
 import android.os.Looper;
 
 import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 import com.activeandroid.manager.SingleDBManager;
 import com.activeandroid.util.AALog;
 
@@ -38,12 +38,12 @@ public static void disposeSharedQueue(){
         mBatchSaveQueue = null;
     }
 
-    private final ArrayList<Model> mModels;
+    private final ArrayList<IModel> mModels;
 
     public DBBatchSaveQueue(){
         super("DBBatchSaveQueue");
 
-        mModels = new ArrayList<Model>();
+        mModels = new ArrayList<IModel>();
     }
 
     @Override
@@ -52,9 +52,9 @@ public void run() {
         Looper.prepare();
         android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
         while (true){
-            final ArrayList<Model> tmpModels;
+            final ArrayList<IModel> tmpModels;
             synchronized (mModels){
-                tmpModels = new ArrayList<Model>(mModels);
+                tmpModels = new ArrayList<IModel>(mModels);
                 mModels.clear();
             }
             if(tmpModels.size()>0) {
@@ -66,8 +66,8 @@ public void run() {
                         ActiveAndroid.beginTransaction();
                         try {
                             AALog.d("DBBatchSaveQueue", "Executing batch save of: " + tmpModels.size() + " on :" + Thread.currentThread().getName());
-                            for (Model model: tmpModels) {
-                                model.save();
+                            for (IModel IModel: tmpModels) {
+                                IModel.save();
                             }
                             ActiveAndroid.setTransactionSuccessful();
                         } catch (Throwable e) {
@@ -93,9 +93,9 @@ public void run() {
         }
     }
 
-    public void add(final Model model){
+    public void add(final IModel IModel){
         synchronized (mModels){
-            mModels.add(model);
+            mModels.add(IModel);
 
             if(mModels.size()>sMODEL_SAVE_SIZE){
                 interrupt();
@@ -103,7 +103,7 @@ public void add(final Model model){
         }
     }
 
-    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends Model> void addAll(final COLLECTION_CLASS list){
+    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void addAll(final COLLECTION_CLASS list){
         synchronized (mModels){
             mModels.addAll(list);
 
@@ -113,9 +113,9 @@ public void add(final Model model){
         }
     }
 
-    public void remove(final Model model){
+    public void remove(final IModel IModel){
         synchronized (mModels){
-            mModels.remove(model);
+            mModels.remove(IModel);
         }
     }
 
diff --git a/src/main/java/com/activeandroid/util/ReflectionUtils.java b/src/main/java/com/activeandroid/util/ReflectionUtils.java
index a2ba4d05..c6a1889e 100644
--- a/src/main/java/com/activeandroid/util/ReflectionUtils.java
+++ b/src/main/java/com/activeandroid/util/ReflectionUtils.java
@@ -20,7 +20,7 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 import com.activeandroid.serializer.TypeSerializer;
 
 import java.lang.reflect.Field;
@@ -33,7 +33,7 @@
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	public static boolean isModel(Class<?> type) {
-		return isSubclassOf(type, Model.class);
+		return isSubclassOf(type, IModel.class);
 	}
 
 	public static boolean isTypeSerializer(Class<?> type) {
@@ -79,7 +79,7 @@ public static boolean isSubclassOf(Class<?> type, Class<?> superClass) {
         for (Field field : inClass.getDeclaredFields()) {
             outFields.add(field);
         }
-        if (inClass.getSuperclass() != null && !inClass.getSuperclass().equals(Model.class)) {
+        if (inClass.getSuperclass() != null && !inClass.getSuperclass().equals(IModel.class)) {
             outFields = getAllFields(outFields, inClass.getSuperclass());
         }
         return outFields;
diff --git a/src/main/java/com/activeandroid/util/SQLiteUtils.java b/src/main/java/com/activeandroid/util/SQLiteUtils.java
index 447f560f..38ecdd3d 100644
--- a/src/main/java/com/activeandroid/util/SQLiteUtils.java
+++ b/src/main/java/com/activeandroid/util/SQLiteUtils.java
@@ -16,18 +16,22 @@
  * limitations under the License.
  */
 
+import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
 import android.os.Build;
 import android.text.TextUtils;
 
 import com.activeandroid.Cache;
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 import com.activeandroid.TableInfo;
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.ForeignKey;
 import com.activeandroid.annotation.PrimaryKey;
+import com.activeandroid.content.ContentProvider;
 import com.activeandroid.exception.PrimaryKeyCannotBeNullException;
+import com.activeandroid.query.Select;
 import com.activeandroid.serializer.TypeSerializer;
 
 import java.lang.reflect.Constructor;
@@ -92,7 +96,7 @@ public static void execSql(String sql, Object[] bindArgs) {
 		Cache.openDatabase().execSQL(sql, bindArgs);
 	}
 
-	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
+	public static <T extends IModel> List<T> rawQuery(Class<? extends IModel> type, String sql, String[] selectionArgs) {
 		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
 		List<T> entities = processCursor(type, cursor);
 		cursor.close();
@@ -100,7 +104,7 @@ public static void execSql(String sql, Object[] bindArgs) {
 		return entities;
 	}
 
-	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
+	public static <T extends IModel> T rawQuerySingle(Class<? extends IModel> type, String sql, String[] selectionArgs) {
 		List<T> entities = rawQuery(type, sql, selectionArgs);
 
 		if (entities.size() > 0) {
@@ -153,7 +157,7 @@ public static String createTableDefinition(TableInfo tableInfo) {
 
             StringBuilder forDef = new StringBuilder("FOREIGN KEY(");
             forDef.append(tableInfo.getColumnName(column)).append(") REFERENCES ")
-                    .append(Cache.getTableName((Class<? extends Model>) column.getType()))
+                    .append(Cache.getTableName((Class<? extends IModel>) column.getType()))
                     .append("(").append(foreignKey.foreignColumn()).append(")");
 
             definitions.add(forDef.toString());
@@ -225,7 +229,7 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 	}
 
 	@SuppressWarnings("unchecked")
-	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
+	public static <T extends IModel> List<T> processCursor(Class<? extends IModel> type, Cursor cursor) {
 		final List<T> entities = new ArrayList<T>();
 
 		try {
@@ -236,7 +240,7 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 
 			if (cursor.moveToFirst()) {
 				do {
-					Model entity = (T) entityConstructor.newInstance();
+					IModel entity = (T) entityConstructor.newInstance();
 					entity.loadFromCursor(cursor);
 					entities.add((T) entity);
 				}
@@ -258,7 +262,7 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
      * @param tableInfo
      * @return
      */
-    public static String getWhereStatement(Class<? extends Model> modelClass, TableInfo tableInfo){
+    public static String getWhereStatement(Class<? extends IModel> modelClass, TableInfo tableInfo){
         List<Field> fields = new ArrayList<Field>();
         ArrayList<Field> primaryColumn = new ArrayList<Field>();
         fields = ReflectionUtils.getAllFields(fields, modelClass);
@@ -287,14 +291,14 @@ public static String getWhereStatement(Class<? extends Model> modelClass, TableI
 
     /**
      * Returns the where statement with primary keys and values filled in
-     * @param model
+     * @param IModel
      * @param tableInfo
      * @return
      */
-    public static String getWhereStatement(Model model, TableInfo tableInfo){
+    public static String getWhereStatement(IModel IModel, TableInfo tableInfo){
         List<Field> fields = new ArrayList<Field>();
         ArrayList<Field> primaryColumn = new ArrayList<Field>();
-        fields = ReflectionUtils.getAllFields(fields, model.getClass());
+        fields = ReflectionUtils.getAllFields(fields, IModel.getClass());
 
         for(Field field : fields){
             if(field.isAnnotationPresent(PrimaryKey.class)){
@@ -319,7 +323,7 @@ public static String getWhereStatement(Model model, TableInfo tableInfo){
             final Field field = primaryColumn.get(i);
             field.setAccessible(true);
             try {
-                Object object = field.get(model);
+                Object object = field.get(IModel);
                 if(object==null){
                     throw new PrimaryKeyCannotBeNullException("The primary key: " + field.getName() + "from " + tableInfo.getTableName() + " cannot be null.");
                 } else if(object instanceof Number){
@@ -336,12 +340,12 @@ public static String getWhereStatement(Model model, TableInfo tableInfo){
         return sql;
     }
 
-    public static String getWhereFromEntityId(Class<? extends Model> model, String entityId){
+    public static String getWhereFromEntityId(Class<? extends IModel> IModel, String entityId){
         String[] primaries = entityId.split(",");
-        String whereString = getWhereStatement(model, Cache.getTableInfo(model));
+        String whereString = getWhereStatement(IModel, Cache.getTableInfo(IModel));
 
         List<Field> fields = new ArrayList<Field>();
-        fields = ReflectionUtils.getAllFields(fields, model);
+        fields = ReflectionUtils.getAllFields(fields, IModel);
 
         ArrayList<Field> primaryColumn = new ArrayList<Field>();
         for(Field field : fields){
@@ -368,4 +372,225 @@ public static String getWhereFromEntityId(Class<? extends Model> model, String e
         return whereString;
     }
 
+    public static void delete(IModel IModel){
+        TableInfo tableInfo = Cache.getTableInfo(IModel.getClass());
+        Cache.openDatabase().delete(tableInfo.getTableName(), SQLiteUtils.getWhereStatement(IModel, tableInfo), null);
+        Cache.removeEntity(IModel);
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(tableInfo.getType(), IModel.getId()), null);
+    }
+
+    public static void save(IModel IModel){
+        TableInfo tableInfo = Cache.getTableInfo(IModel.getClass());
+        final SQLiteDatabase db = Cache.openDatabase();
+        final ContentValues values = new ContentValues();
+
+        for (Field field : tableInfo.getFields()) {
+            String fieldName = tableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+
+            field.setAccessible(true);
+
+            try {
+                Object value = field.get(IModel);
+
+                if (value != null) {
+                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                    if (typeSerializer != null) {
+                        // serialize data
+                        value = typeSerializer.serialize(value);
+                        // set new object type
+                        if (value != null) {
+                            fieldType = value.getClass();
+                            // check that the serializer returned what it promised
+                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
+                                AALog.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                        typeSerializer.getSerializedType(), fieldType));
+                            }
+                        }
+                    }
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (value == null) {
+                    values.putNull(fieldName);
+                }
+                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    values.put(fieldName, (Byte) value);
+                }
+                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    values.put(fieldName, (Short) value);
+                }
+                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    values.put(fieldName, (Integer) value);
+                }
+                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    values.put(fieldName, (Long) value);
+                }
+                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    values.put(fieldName, (Float) value);
+                }
+                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    values.put(fieldName, (Double) value);
+                }
+                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    values.put(fieldName, (Boolean) value);
+                }
+                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    values.put(fieldName, value.toString());
+                }
+                else if (fieldType.equals(String.class)) {
+                    values.put(fieldName, value.toString());
+                }
+                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    values.put(fieldName, (byte[]) value);
+                }
+                else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
+                    ForeignKey key = field.getAnnotation(ForeignKey.class);
+                    if(!key.name().equals("")){
+                        fieldName = field.getAnnotation(ForeignKey.class).name();
+                    }
+                    values.put(fieldName, ((IModel) value).getId());
+                }
+                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    values.put(fieldName, ((Enum<?>) value).name());
+                }
+            }
+            catch (IllegalArgumentException e) {
+                AALog.e(e.getClass().getName(), e);
+            }
+            catch (IllegalAccessException e) {
+                AALog.e(e.getClass().getName(), e);
+            }
+        }
+
+        if(!IModel.exists()){
+            IModel.setRowId(db.insert(tableInfo.getTableName(), null, values));
+
+            for(Field field : tableInfo.getPrimaryKeys()){
+                if(field.isAnnotationPresent(PrimaryKey.class) &&
+                        field.getAnnotation(PrimaryKey.class).type().equals(PrimaryKey.Type.AUTO_INCREMENT)){
+                    field.setAccessible(true);
+                    try {
+                        field.set(IModel, IModel.getId());
+                    } catch (Throwable e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+            }
+        } else {
+            IModel.setRowId(db.update(tableInfo.getTableName(), values, SQLiteUtils.getWhereStatement(IModel, tableInfo), null));
+        }
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(tableInfo.getType(), IModel.getId()), null);
+    }
+
+    public static void loadFromCursor(Cursor cursor, IModel IModel){
+        TableInfo tableInfo = Cache.getTableInfo(IModel.getClass());
+        for (Field field : tableInfo.getFields()) {
+            final String fieldName = tableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+            final int columnIndex = cursor.getColumnIndex(fieldName);
+
+            if (columnIndex < 0) {
+                continue;
+            }
+
+            field.setAccessible(true);
+
+            try {
+                boolean columnIsNull = cursor.isNull(columnIndex);
+                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                Object value = null;
+
+                if (typeSerializer != null) {
+                    fieldType = typeSerializer.getSerializedType();
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (columnIsNull) {
+                    field = null;
+                }
+                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    value = cursor.getLong(columnIndex);
+                }
+                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    value = cursor.getFloat(columnIndex);
+                }
+                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    value = cursor.getDouble(columnIndex);
+                }
+                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    value = cursor.getInt(columnIndex) != 0;
+                }
+                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    value = cursor.getString(columnIndex).charAt(0);
+                }
+                else if (fieldType.equals(String.class)) {
+                    value = cursor.getString(columnIndex);
+                }
+                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    value = cursor.getBlob(columnIndex);
+                }
+                else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
+                    final String entityId = cursor.getString(columnIndex);
+                    final Class<? extends IModel> entityType = (Class<? extends IModel>) fieldType;
+
+                    IModel entity = Cache.getEntity(entityType, entityId);
+                    if (entity == null) {
+                        entity = new Select().from(entityType).where(SQLiteUtils.getWhereFromEntityId(entityType, entityId)).executeSingle();
+                    }
+
+                    value = entity;
+                }
+                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    @SuppressWarnings("rawtypes")
+                    final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+                    value = Enum.valueOf(enumType, cursor.getString(columnIndex));
+                }
+
+                // Use a deserializer if one is available
+                if (typeSerializer != null && !columnIsNull) {
+                    value = typeSerializer.deserialize(value);
+                }
+
+                // Set the field name
+                if (value != null) {
+                    field.set(IModel, value);
+                }
+            }
+            catch (IllegalArgumentException e) {
+                AALog.e(e.getClass().getName(), e);
+            }
+            catch (IllegalAccessException e) {
+                AALog.e(e.getClass().getName(), e);
+            }
+            catch (SecurityException e) {
+                AALog.e(e.getClass().getName(), e);
+            }
+        }
+
+        if (IModel.getId() != null) {
+            Cache.addEntity(IModel);
+        }
+    }
+
+    public static boolean exists(IModel model){
+        IModel model = new Select().from(getClass()).where(SQLiteUtils.getWhereStatement(model, Cache.getTableInfo(model.getClass()))).executeSingle();
+        return model!=null;
+    }
+
 }
diff --git a/src/main/java/com/activeandroid/widget/AbstractManagerAdapter.java b/src/main/java/com/activeandroid/widget/AbstractManagerAdapter.java
index dd9fca2d..9636417b 100644
--- a/src/main/java/com/activeandroid/widget/AbstractManagerAdapter.java
+++ b/src/main/java/com/activeandroid/widget/AbstractManagerAdapter.java
@@ -3,7 +3,7 @@
 import android.widget.BaseAdapter;
 
 import com.activeandroid.manager.DBManager;
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 import com.activeandroid.interfaces.CollectionReceiver;
 
 import java.util.List;
@@ -14,7 +14,7 @@
  * Contributors:
  * Description: Provides simple, type-safe implementation in an adapter, fetching objects from the DBManager
  */
-public abstract class AbstractManagerAdapter<OBJECT_CLASS extends Model> extends BaseAdapter {
+public abstract class AbstractManagerAdapter<OBJECT_CLASS extends IModel> extends BaseAdapter {
 
     protected List<OBJECT_CLASS> mObjects;
 
diff --git a/src/main/java/com/activeandroid/widget/ModelAdapter.java b/src/main/java/com/activeandroid/widget/ModelAdapter.java
index 72363b1a..86732533 100644
--- a/src/main/java/com/activeandroid/widget/ModelAdapter.java
+++ b/src/main/java/com/activeandroid/widget/ModelAdapter.java
@@ -6,9 +6,9 @@
 import android.content.Context;
 import android.widget.ArrayAdapter;
 
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 
-public class ModelAdapter<T extends Model> extends ArrayAdapter<T> {
+public class ModelAdapter<T extends IModel> extends ArrayAdapter<T> {
 	public ModelAdapter(Context context, int textViewResourceId) {
 		super(context, textViewResourceId);
 	}
diff --git a/tests/src/com/activeandroid/test/MockModel.java b/tests/src/com/activeandroid/test/MockModel.java
index 718e945b..a6638043 100644
--- a/tests/src/com/activeandroid/test/MockModel.java
+++ b/tests/src/com/activeandroid/test/MockModel.java
@@ -16,9 +16,9 @@
  * limitations under the License.
  */
 
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 import com.activeandroid.annotation.Table;
 
 @Table(name = "MockModel")
-public class MockModel extends Model {
+public class MockModel extends IModel {
 }
diff --git a/tests/src/com/activeandroid/test/query/FromTest.java b/tests/src/com/activeandroid/test/query/FromTest.java
index 7340e091..30523294 100644
--- a/tests/src/com/activeandroid/test/query/FromTest.java
+++ b/tests/src/com/activeandroid/test/query/FromTest.java
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.Model;
+import com.activeandroid.IModel;
 import com.activeandroid.annotation.Table;
 import com.activeandroid.query.From;
 import com.activeandroid.query.Select;
@@ -157,10 +157,10 @@ private From from() {
 	}
 	
 	@Table(name = "JoinModel")
-	private static class JoinModel extends Model {
+	private static class JoinModel extends IModel {
 	}
 	
 	@Table(name = "JoinModel2")
-	private static class JoinModel2 extends Model {
+	private static class JoinModel2 extends IModel {
 	}
 }
