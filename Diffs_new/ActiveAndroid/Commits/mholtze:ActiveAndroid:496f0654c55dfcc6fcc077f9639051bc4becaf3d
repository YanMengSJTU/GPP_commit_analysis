diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
index 6495e379..4ad4b62f 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -155,4 +155,16 @@ public static synchronized TypeSerializer getParserForType(Class<?> type) {
 	public static synchronized String getTableName(Class<? extends Model> type) {
 		return sModelInfo.getTableInfo(type).getTableName();
 	}
+
+    public static synchronized Collection<FullTextTableInfo> getFullTextInfos() {
+        return sModelInfo.getFullTextInfos();
+    }
+
+    public static synchronized FullTextTableInfo getFullTextInfo(Class<? extends FullTextModel> type) {
+        return sModelInfo.getFullTextInfo(type);
+    }
+
+    public static synchronized String getFullTextTableName(Class<? extends FullTextModel> type) {
+        return sModelInfo.getFullTextInfo(type).getTableName();
+    }
 }
diff --git a/src/com/activeandroid/Configuration.java b/src/com/activeandroid/Configuration.java
index b197d223..6b5ca2f4 100644
--- a/src/com/activeandroid/Configuration.java
+++ b/src/com/activeandroid/Configuration.java
@@ -41,6 +41,7 @@
 	private String mSqlParser;
 	private List<Class<? extends Model>> mModelClasses;
 	private List<Class<? extends TypeSerializer>> mTypeSerializers;
+    private List<Class<? extends FullTextModel>> mFullTextClasses;
 	private int mCacheSize;
 
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -79,6 +80,10 @@ public String getSqlParser() {
 		return mTypeSerializers;
 	}
 
+    public List<Class<? extends FullTextModel>> getFullTextClasses() {
+        return mFullTextClasses;
+    }
+
 	public int getCacheSize() {
 		return mCacheSize;
 	}
@@ -99,6 +104,7 @@ public boolean isValid() {
 		private static final String AA_DB_NAME = "AA_DB_NAME";
 		private static final String AA_DB_VERSION = "AA_DB_VERSION";
 		private final static String AA_MODELS = "AA_MODELS";
+        private final static String AA_FTS_MODELS = "AA_FTS_MODELS";
 		private final static String AA_SERIALIZERS = "AA_SERIALIZERS";
 		private final static String AA_SQL_PARSER = "AA_SQL_PARSER";
 
@@ -118,6 +124,7 @@ public boolean isValid() {
 		private String mSqlParser;
 		private List<Class<? extends Model>> mModelClasses;
 		private List<Class<? extends TypeSerializer>> mTypeSerializers;
+        private List<Class<? extends FullTextModel>> mFullTextClasses;
 
 		//////////////////////////////////////////////////////////////////////////////////////
 		// CONSTRUCTORS
@@ -198,6 +205,29 @@ public Builder setTypeSerializers(Class<? extends TypeSerializer>... typeSeriali
 			return this;
 		}
 
+        public Builder addFullTextClass(Class<? extends FullTextModel> modelClass) {
+            if (mFullTextClasses == null) {
+                mFullTextClasses = new ArrayList<Class<? extends FullTextModel>>();
+            }
+
+            mFullTextClasses.add(modelClass);
+            return this;
+        }
+
+        public Builder addFullTextClasses(Class<? extends FullTextModel>... modelClasses) {
+            if (mFullTextClasses == null) {
+                mFullTextClasses = new ArrayList<Class<? extends FullTextModel>>();
+            }
+
+            mFullTextClasses.addAll(Arrays.asList(modelClasses));
+            return this;
+        }
+
+        public Builder setFullTextClasses(Class<? extends FullTextModel>... modelClasses) {
+            mFullTextClasses = Arrays.asList(modelClasses);
+            return this;
+        }
+
 		public Configuration create() {
 			Configuration configuration = new Configuration(mContext);
 			configuration.mCacheSize = mCacheSize;
@@ -243,6 +273,16 @@ public Configuration create() {
 				}
 			}
 
+            // Get full text model classes from meta-data
+            if (mFullTextClasses != null) {
+                configuration.mFullTextClasses = mFullTextClasses;
+            } else {
+                final String modelList = ReflectionUtils.getMetaData(mContext, AA_FTS_MODELS);
+                if (modelList != null) {
+                    configuration.mFullTextClasses = loadFullTextList(modelList.split(","));
+                }
+            }
+
 			return configuration;
 		}
 
@@ -314,5 +354,23 @@ private String getMetaDataSqlParserOrDefault() {
 			return typeSerializers;
 		}
 
+        private List<Class<? extends FullTextModel>> loadFullTextList(String[] models) {
+            final List<Class<? extends FullTextModel>> modelClasses = new ArrayList<Class<? extends FullTextModel>>();
+            final ClassLoader classLoader = mContext.getClass().getClassLoader();
+            for (String model : models) {
+                try {
+                    Class modelClass = Class.forName(model.trim(), false, classLoader);
+                    if (ReflectionUtils.isModel(modelClass)) {
+                        modelClasses.add(modelClass);
+                    }
+                }
+                catch (ClassNotFoundException e) {
+                    Log.e("Couldn't create class.", e);
+                }
+            }
+
+            return modelClasses;
+        }
+
 	}
 }
diff --git a/src/com/activeandroid/FullTextModel.java b/src/com/activeandroid/FullTextModel.java
new file mode 100644
index 00000000..6053761b
--- /dev/null
+++ b/src/com/activeandroid/FullTextModel.java
@@ -0,0 +1,135 @@
+package com.activeandroid;
+
+import android.content.ContentValues;
+import android.database.sqlite.SQLiteDatabase;
+
+import com.activeandroid.content.ContentProvider;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
+
+import java.lang.reflect.Field;
+
+public abstract class FullTextModel<M extends Model> {
+    /** Prime number used for hashcode() implementation. */
+    private static final int HASH_PRIME = 739;
+
+    private final FullTextTableInfo mTableInfo;
+    private M model;
+
+    protected FullTextModel(M model) {
+        mTableInfo = Cache.getFullTextInfo(getClass());
+        this.model = model;
+    }
+
+    public final M getModel() {
+        return model;
+    }
+
+    public final Long getId() {
+        return model != null ? model.getId() : null;
+    }
+
+    /**
+     * Template method called at beginning of save mainly used to update text search
+     * members based on reference model.
+     */
+    protected void beforeSave() {
+
+    }
+
+    public Long save() {
+        beforeSave();
+
+        final SQLiteDatabase db = Cache.openDatabase();
+        final ContentValues values = new ContentValues();
+        final Long docId = getId();
+
+        for (Field field : mTableInfo.getFields()) {
+            final String fieldName = mTableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+
+            field.setAccessible(true);
+
+            try {
+                Object value = field.get(this);
+
+                if (value != null) {
+                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                    if (typeSerializer != null) {
+                        // serialize data
+                        value = typeSerializer.serialize(value);
+                        // set new object type
+                        if (value != null) {
+                            fieldType = value.getClass();
+                            // check that the serializer returned what it promised
+                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
+                                Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                        typeSerializer.getSerializedType(), fieldType));
+                            }
+                        }
+                    }
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (value == null) {
+                    values.putNull(fieldName);
+                }
+                else if (fieldType.equals(String.class)) {
+                    values.put(fieldName, value.toString());
+                }
+                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    values.put(fieldName, ((Enum<?>) value).name());
+                }
+                else {
+                    values.put(fieldName, value.toString());
+                }
+            }
+            catch (IllegalArgumentException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+            catch (IllegalAccessException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+
+        values.put("docid", model.getId());
+        db.replace(mTableInfo.getTableName(), null, values);
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createFullTextUri(mTableInfo.getType(), docId), null);
+
+        return docId;
+    }
+
+    @Override
+    public String toString() {
+        return mTableInfo.getTableName() + "@" + getId();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        final Long docId = getId();
+        if (obj instanceof FullTextModel && docId != null) {
+            final FullTextModel other = (FullTextModel) obj;
+
+            return docId.equals(other.getId())
+                    && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
+        } else {
+            return this == obj;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        final Long docId = getId();
+        int hash = HASH_PRIME;
+        hash += HASH_PRIME * (docId == null ? super.hashCode() : docId.hashCode()); //if id is null, use Object.hashCode()
+        hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
+        return hash; //To change body of generated methods, choose Tools | Templates.
+    }
+
+    // TODO: static search methods
+}
+
diff --git a/src/com/activeandroid/FullTextTableInfo.java b/src/com/activeandroid/FullTextTableInfo.java
new file mode 100644
index 00000000..f8c97b9a
--- /dev/null
+++ b/src/com/activeandroid/FullTextTableInfo.java
@@ -0,0 +1,107 @@
+package com.activeandroid;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.activeandroid.annotation.FullTextColumn;
+import com.activeandroid.annotation.FullTextTable;
+import com.activeandroid.util.ReflectionUtils;
+
+import java.lang.reflect.Field;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+public class FullTextTableInfo {
+    public static final String ID_NAME = "docid";
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Class<? extends FullTextModel> mType;
+    private String mTableName;
+    private String mIdName = ID_NAME;
+
+    private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public FullTextTableInfo(Class<? extends FullTextModel> type) {
+        mType = type;
+
+        final FullTextTable tableAnnotation = type.getAnnotation(FullTextTable.class);
+
+        if (tableAnnotation != null) {
+            mTableName = tableAnnotation.name();
+        }
+        else {
+            mTableName = type.getSimpleName();
+        }
+
+        // Manually add the id column since it is not declared like the other columns.
+        Field idField = getIdField(type);
+        mColumnNames.put(idField, mIdName);
+
+        List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
+        Collections.reverse(fields);
+
+        for (Field field : fields) {
+            if (field.isAnnotationPresent(FullTextColumn.class)) {
+                final FullTextColumn columnAnnotation = field.getAnnotation(FullTextColumn.class);
+                String columnName = columnAnnotation.name();
+                if (TextUtils.isEmpty(columnName)) {
+                    columnName = field.getName();
+                }
+
+                mColumnNames.put(field, columnName);
+            }
+        }
+
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Class<? extends FullTextModel> getType() {
+        return mType;
+    }
+
+    public String getTableName() {
+        return mTableName;
+    }
+
+    public String getIdName() {
+        return mIdName;
+    }
+
+    public Collection<Field> getFields() {
+        return mColumnNames.keySet();
+    }
+
+    public String getColumnName(Field field) {
+        return mColumnNames.get(field);
+    }
+
+    private Field getIdField(Class<?> type) {
+        if (type.equals(FullTextModel.class)) {
+            try {
+                return type.getDeclaredField("docId");
+            }
+            catch (NoSuchFieldException e) {
+                Log.e("Impossible!", e.toString());
+            }
+        }
+        else if (type.getSuperclass() != null) {
+            return getIdField(type.getSuperclass());
+        }
+
+        return null;
+    }
+}
diff --git a/src/com/activeandroid/ModelInfo.java b/src/com/activeandroid/ModelInfo.java
index 09e79117..e9b85596 100644
--- a/src/com/activeandroid/ModelInfo.java
+++ b/src/com/activeandroid/ModelInfo.java
@@ -52,6 +52,7 @@
 			put(java.io.File.class, new FileSerializer());
 		}
 	};
+    private Map<Class<? extends FullTextModel>, FullTextTableInfo> mFullTextInfos = new HashMap<Class<? extends FullTextModel>, FullTextTableInfo>();
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
@@ -86,6 +87,14 @@ public TypeSerializer getTypeSerializer(Class<?> type) {
 		return mTypeSerializers.get(type);
 	}
 
+    public Collection<FullTextTableInfo> getFullTextInfos() {
+        return mFullTextInfos.values();
+    }
+
+    public FullTextTableInfo getFullTextInfo(Class<? extends FullTextModel> type) {
+        return mFullTextInfos.get(type);
+    }
+
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -118,6 +127,13 @@ private boolean loadModelFromMetaData(Configuration configuration) {
 			}
 		}
 
+        final List<Class<? extends FullTextModel>> fullTextModels = configuration.getFullTextClasses();
+        if (fullTextModels != null) {
+            for (Class<? extends FullTextModel> model : fullTextModels) {
+                mFullTextInfos.put(model, new FullTextTableInfo(model));
+            }
+        }
+
 		return true;
 	}
 
@@ -194,6 +210,11 @@ else if (ReflectionUtils.isTypeSerializer(discoveredClass)) {
 					TypeSerializer instance = (TypeSerializer) discoveredClass.newInstance();
 					mTypeSerializers.put(instance.getDeserializedType(), instance);
 				}
+                else if (ReflectionUtils.isTypeFullText(discoveredClass)) {
+                    @SuppressWarnings("unchecked")
+                    Class<? extends FullTextModel> modelClass = (Class<? extends FullTextModel>) discoveredClass;
+                    mFullTextInfos.put(modelClass, new FullTextTableInfo(modelClass));
+                }
 			}
 			catch (ClassNotFoundException e) {
 				Log.e("Couldn't create class.", e);
diff --git a/src/com/activeandroid/annotation/FullTextColumn.java b/src/com/activeandroid/annotation/FullTextColumn.java
new file mode 100644
index 00000000..389d0a8a
--- /dev/null
+++ b/src/com/activeandroid/annotation/FullTextColumn.java
@@ -0,0 +1,12 @@
+package com.activeandroid.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface FullTextColumn {
+    public String name() default "";
+}
diff --git a/src/com/activeandroid/annotation/FullTextTable.java b/src/com/activeandroid/annotation/FullTextTable.java
new file mode 100644
index 00000000..168d0cc4
--- /dev/null
+++ b/src/com/activeandroid/annotation/FullTextTable.java
@@ -0,0 +1,12 @@
+package com.activeandroid.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface FullTextTable {
+    public String name();
+}
diff --git a/src/com/activeandroid/content/ContentProvider.java b/src/com/activeandroid/content/ContentProvider.java
index b4a841d6..b34db9de 100644
--- a/src/com/activeandroid/content/ContentProvider.java
+++ b/src/com/activeandroid/content/ContentProvider.java
@@ -12,6 +12,7 @@
 import com.activeandroid.ActiveAndroid;
 import com.activeandroid.Cache;
 import com.activeandroid.Configuration;
+import com.activeandroid.FullTextModel;
 import com.activeandroid.Model;
 import com.activeandroid.TableInfo;
 
@@ -161,6 +162,21 @@ public static Uri createUri(Class<? extends Model> type, Long id) {
 		return Uri.parse(uri.toString());
 	}
 
+    public static Uri createFullTextUri(Class<? extends FullTextModel> type, Long id) {
+        final StringBuilder uri = new StringBuilder();
+        uri.append("content://");
+        uri.append(sAuthority);
+        uri.append("/");
+        uri.append(Cache.getFullTextTableName(type).toLowerCase());
+
+        if (id != null) {
+            uri.append("/");
+            uri.append(id.toString());
+        }
+
+        return Uri.parse(uri.toString());
+    }
+
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PROTECTED METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/util/ReflectionUtils.java b/src/com/activeandroid/util/ReflectionUtils.java
index 32e995cc..461f9bb0 100644
--- a/src/com/activeandroid/util/ReflectionUtils.java
+++ b/src/com/activeandroid/util/ReflectionUtils.java
@@ -28,6 +28,7 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 
+import com.activeandroid.FullTextModel;
 import com.activeandroid.Model;
 import com.activeandroid.annotation.Column;
 import com.activeandroid.serializer.TypeSerializer;
@@ -45,6 +46,10 @@ public static boolean isTypeSerializer(Class<?> type) {
 		return isSubclassOf(type, TypeSerializer.class);
 	}
 
+    public static boolean isTypeFullText(Class<?> type) {
+        return isSubclassOf(type, FullTextModel.class);
+    }
+
 	// Meta-data
 
 	@SuppressWarnings("unchecked")
