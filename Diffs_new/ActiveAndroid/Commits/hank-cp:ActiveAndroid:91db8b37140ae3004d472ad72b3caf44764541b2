diff --git a/libs/android.jar b/libs/android.jar
deleted file mode 100644
index 4274d2b0..00000000
Binary files a/libs/android.jar and /dev/null differ
diff --git a/src/com/activeandroid/ActiveAndroid.java b/src/com/activeandroid/ActiveAndroid.java
index 7bf2578c..fd73ec25 100644
--- a/src/com/activeandroid/ActiveAndroid.java
+++ b/src/com/activeandroid/ActiveAndroid.java
@@ -22,56 +22,60 @@
 import com.activeandroid.util.Log;
 
 public final class ActiveAndroid {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public synchronized static void initialize(Application application) {
-		initialize(application, false);
-	}
-
-	public synchronized static void initialize(Application application, boolean loggingEnabled) {
-		setLoggingEnabled(loggingEnabled);
-		Cache.initialize(application);
-	}
-
-	public static void clearCache() {
-		Cache.clear();
-	}
-
-	public static void dispose() {
-		Cache.dispose();
-	}
-
-	public static void setLoggingEnabled(boolean enabled) {
-		Log.setEnabled(enabled);
-	}
-
-	public synchronized static SQLiteDatabase getDatabase() {
-		return Cache.openDatabase();
-	}
-
-	public static void beginTransaction() {
-		Cache.openDatabase().beginTransaction();
-	}
-
-	public static void endTransaction() {
-		Cache.openDatabase().endTransaction();
-	}
-
-	public static void setTransactionSuccessful() {
-		Cache.openDatabase().setTransactionSuccessful();
-	}
-
-	public static boolean inTransaction() {
-		return Cache.openDatabase().inTransaction();
-	}
-
-	public static void execSQL(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSQL(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public synchronized static void initialize(Application application) {
+        initialize(application, false);
+    }
+
+    public synchronized static void initialize(Application application, boolean loggingEnabled) {
+        setLoggingEnabled(loggingEnabled);
+        Cache.initialize(application);
+    }
+
+    public synchronized static void registerDbMetaData(Application application, DbMetaData metaData) {
+        Cache.initialize(application, metaData);
+    }
+
+    public static void clearCache() {
+        Cache.clearCache();
+    }
+
+    public static void dispose() {
+        Cache.dispose();
+    }
+
+    public static void setLoggingEnabled(boolean enabled) {
+        Log.setEnabled(enabled);
+    }
+
+    public synchronized static SQLiteDatabase getDatabase(Class<?> type) {
+        return Cache.openDatabase(type);
+    }
+
+    public static void beginTransaction(Class<?> type) {
+        Cache.openDatabase(type).beginTransaction();
+    }
+
+    public static void endTransaction(Class<?> type) {
+        Cache.openDatabase(type).endTransaction();
+    }
+
+    public static void setTransactionSuccessful(Class<?> type) {
+        Cache.openDatabase(type).setTransactionSuccessful();
+    }
+
+    public static boolean inTransaction(Class<?> type) {
+        return Cache.openDatabase(type).inTransaction();
+    }
+
+    public static void execSQL(Class<?> type, String sql) {
+        Cache.openDatabase(type).execSQL(sql);
+    }
+
+    public static void execSQL(Class<?> type, String sql, Object[] bindArgs) {
+        Cache.openDatabase(type).execSQL(sql, bindArgs);
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
index b9061d12..babc8849 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -16,8 +16,10 @@
  * limitations under the License.
  */
 
+import java.lang.ref.SoftReference;
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.Hashtable;
 import java.util.Set;
 
 import android.app.Application;
@@ -26,122 +28,155 @@
 
 import com.activeandroid.serializer.TypeSerializer;
 import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
 
 public final class Cache {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private static Context sContext;
+    private static Context sContext;
 
-	private static ModelInfo sModelInfo;
-	private static DatabaseHelper sDatabaseHelper;
+    private static ModelInfo sModelInfo;
 
-	private static Set<Model> sEntities;
+    private static Set<SoftReference<Model>> sEntities;
 
-	private static boolean sIsInitialized = false;
+    private static Hashtable<Class<? extends DbMetaData>, DatabaseHelper> sDatabaseHelper;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private Cache() {
-	}
+    private Cache() {
+    }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public static synchronized void initialize(Application application) {
-		if (sIsInitialized) {
-			Log.v("ActiveAndroid already initialized.");
-			return;
-		}
+    public static synchronized void initialize(Application application) {
+        initialize(application, null);
+    }
 
-		sContext = application;
+    public static synchronized void initialize(Application application, DbMetaData metaData) {
+        DbMetaData meta = metaData;
+        if (meta == null) meta = DefaultMetaData.getInstanse(application);
 
-		sModelInfo = new ModelInfo(application);
-		sDatabaseHelper = new DatabaseHelper(sContext);
+        // initialize static variables
+        if (sContext == null) sContext = application;
+        if (sModelInfo == null) sModelInfo = new ModelInfo(application);
+        if (sDatabaseHelper == null)
+            sDatabaseHelper = new Hashtable<Class<? extends DbMetaData>, DatabaseHelper>();
+        if (sEntities == null)
+            sEntities = new HashSet<SoftReference<Model>>();
 
-		sEntities = new HashSet<Model>();
+        // if database
+        if (sDatabaseHelper.get(meta.getClass()) != null && !meta.isResettable()) {
+            Log.v("ActiveAndroid already initialized.");
+            return;
 
-		openDatabase();
+        } else if (sDatabaseHelper.get(meta.getClass()) != null) {
+            Log.v("ActiveAndroid "+meta.getClass().getSimpleName()+" already initialized. Reset by new meta data");
+            closeDatabase(meta.getClass());
+        }
 
-		sIsInitialized = true;
+        // initialize DatabaseHelper
+        sDatabaseHelper.put(meta.getClass(), new DatabaseHelper(sContext, meta));
 
-		Log.v("ActiveAndroid initialized succesfully.");
-	}
+        openDatabase(meta.getClass());
 
-	public static synchronized void clear() {
-		sEntities = new HashSet<Model>();
-		Log.v("Cache cleared.");
-	}
+        Log.v("ActiveAndroid "+ meta.getClass().getSimpleName()+" initialized succesfully.");
+    }
 
-	public static synchronized void dispose() {
-		closeDatabase();
-		
-		sEntities = null;
-		sModelInfo = null;
-		sDatabaseHelper = null;
+    public static synchronized void clearCache() {
+        sEntities.clear();
+        Log.v("Cache cleared.");
+    }
 
-		sIsInitialized = false;
+    public static synchronized void dispose() {
+        closeAllDatabase();
 
-		Log.v("ActiveAndroid disposed. Call initialize to use library.");
-	}
+        sEntities = null;
+        sModelInfo = null;
+        sDatabaseHelper = null;
 
-	// Database access
+        Log.v("ActiveAndroid disposed. Call initialize to use library.");
+    }
 
-	public static synchronized SQLiteDatabase openDatabase() {
-		return sDatabaseHelper.getWritableDatabase();
-	}
+    // Database access
 
-	public static synchronized void closeDatabase() {
-		sDatabaseHelper.close();
-	}
+    public static synchronized SQLiteDatabase openDatabase(Class<?> type) {
+        Class<? extends DbMetaData> metaDataType = ReflectionUtils.getDbMetaDataClass(type);
+        DatabaseHelper databaseHelper = sDatabaseHelper.get(metaDataType);
+        if (databaseHelper != null) return databaseHelper.getWritableDatabase();
+        throw new IllegalArgumentException("db meta" + metaDataType.getClass().getSimpleName() +" not found!");
+    }
 
-	// Context access
+    public static synchronized void closeDatabase(Class<?> type) {
+        Class<? extends DbMetaData> metaDataType = ReflectionUtils.getDbMetaDataClass(type);
+        DatabaseHelper databaseHelper = sDatabaseHelper.get(metaDataType);
+        if (databaseHelper != null) databaseHelper.close();
+    }
 
-	public static Context getContext() {
-		return sContext;
-	}
+    public static synchronized void closeAllDatabase() {
+        for (DatabaseHelper databaseHelper : sDatabaseHelper.values()) {
+            databaseHelper.close();
+        }
+    }
 
-	// Entity cache
+    // Context access
 
-	public static synchronized void addEntity(Model entity) {
-		sEntities.add(entity);
-	}
+    public static Context getContext() {
+        return sContext;
+    }
 
-	public static synchronized Model getEntity(Class<? extends Model> type, long id) {
-		for (Model entity : sEntities) {
-			if (entity != null && entity.getClass() != null && entity.getClass() == type && entity.getId() != null
-					&& entity.getId() == id) {
+    // Entity cache
 
-				return entity;
-			}
-		}
+    public static synchronized void addEntity(Model entity) {
+        sEntities.add(new SoftReference<Model>(entity));
+    }
 
-		return null;
-	}
-
-	public static synchronized void removeEntity(Model entity) {
-		sEntities.remove(entity);
-	}
-
-	// Model cache
-
-	public static synchronized Collection<TableInfo> getTableInfos() {
-		return sModelInfo.getTableInfos();
-	}
-
-	public static synchronized TableInfo getTableInfo(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type);
-	}
-
-	public static synchronized TypeSerializer getParserForType(Class<?> type) {
-		return sModelInfo.getTypeSerializer(type);
-	}
-
-	public static synchronized String getTableName(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type).getTableName();
-	}
+    public static synchronized Model getEntity(Class<? extends Model> type, long id) {
+        for (SoftReference<Model> ref: sEntities) {
+            Model entity = ref.get();
+            if (entity != null && entity.getClass() != null && entity.getClass() == type && entity.getId() != null
+                    && entity.getId() == id) {
+
+                return entity;
+            }
+        }
+
+        return null;
+    }
+
+    public static synchronized void removeEntity(Model entity) {
+        SoftReference<Model> removedRef = null;
+        for (SoftReference<Model> ref: sEntities) {
+            Model model = ref.get();
+            if (entity == model) {
+                removedRef = ref;
+                break;
+            }
+        }
+
+        if (removedRef != null) sEntities.remove(removedRef);
+    }
+
+    // Model cache
+
+    public static synchronized Collection<TableInfo> getTableInfos() {
+        return sModelInfo.getTableInfos();
+    }
+
+    public static synchronized TableInfo getTableInfo(Class<? extends Model> type) {
+        return sModelInfo.getTableInfo(type);
+    }
+
+    public static synchronized TypeSerializer getParserForType(Class<?> type) {
+        return sModelInfo.getTypeSerializer(type);
+    }
+
+    public static synchronized String getTableName(Class<? extends Model> type) {
+        return sModelInfo.getTableInfo(type).getTableName();
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/DatabaseHelper.java b/src/com/activeandroid/DatabaseHelper.java
index 1941da1a..952d215b 100644
--- a/src/com/activeandroid/DatabaseHelper.java
+++ b/src/com/activeandroid/DatabaseHelper.java
@@ -33,173 +33,146 @@
 
 import com.activeandroid.util.Log;
 import com.activeandroid.util.NaturalOrderComparator;
-import com.activeandroid.util.ReflectionUtils;
 import com.activeandroid.util.SQLiteUtils;
 
 public final class DatabaseHelper extends SQLiteOpenHelper {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private final static String AA_DB_NAME = "AA_DB_NAME";
-	private final static String AA_DB_VERSION = "AA_DB_VERSION";
-
-	private final static String MIGRATION_PATH = "migrations";
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public DatabaseHelper(Context context) {
-		super(context, getDbName(context), null, getDbVersion(context));
-		copyAttachedDatabase(context);
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public void onCreate(SQLiteDatabase db) {
-		if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
-			db.execSQL("PRAGMA foreign_keys=ON;");
-			Log.i("Foreign Keys supported. Enabling foreign key features.");
-		}
-
-		db.beginTransaction();
-
-		for (TableInfo tableInfo : Cache.getTableInfos()) {
-			db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
-		}
-
-		db.setTransactionSuccessful();
-		db.endTransaction();
-
-		executeMigrations(db, -1, db.getVersion());
-	}
-
-	@Override
-	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-		if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
-			db.execSQL("PRAGMA foreign_keys=ON;");
-			Log.i("Foreign Keys supported. Enabling foreign key features.");
-		}
-
-		if (!executeMigrations(db, oldVersion, newVersion)) {
-			Log.i("No migrations found. Calling onCreate.");
-			onCreate(db);
-		}
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public void copyAttachedDatabase(Context context) {
-		String dbName = getDbName(context);
-		final File dbPath = context.getDatabasePath(dbName);
-
-		// If the database already exists, return
-		if (dbPath.exists()) {
-			return;
-		}
-
-		// Make sure we have a path to the file
-		dbPath.getParentFile().mkdirs();
-
-		// Try to copy database file
-		try {
-			final InputStream inputStream = context.getAssets().open(dbName);
-			final OutputStream output = new FileOutputStream(dbPath);
-
-			byte[] buffer = new byte[1024];
-			int length;
-
-			while ((length = inputStream.read(buffer)) > 0) {
-				output.write(buffer, 0, length);
-			}
-
-			output.flush();
-			output.close();
-			inputStream.close();
-		}
-		catch (IOException e) {
-			Log.e("Failed to open file", e);
-		}
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
-		boolean migrationExecuted = false;
-		try {
-			final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
-			Collections.sort(files, new NaturalOrderComparator());
-
-			db.beginTransaction();
-
-			for (String file : files) {
-				try {
-					final int version = Integer.valueOf(file.replace(".sql", ""));
-
-					if (version > oldVersion && version <= newVersion) {
-						executeSqlScript(db, file);
-						migrationExecuted = true;
-
-						Log.i(file + " executed succesfully.");
-					}
-				}
-				catch (NumberFormatException e) {
-					Log.w("Skipping invalidly named file: " + file, e);
-				}
-			}
-
-			db.setTransactionSuccessful();
-			db.endTransaction();
-		}
-		catch (IOException e) {
-			Log.e("Failed to execute migrations.", e);
-		}
-
-		return migrationExecuted;
-	}
-
-	private void executeSqlScript(SQLiteDatabase db, String file) {
-		try {
-			final InputStream input = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
-			final BufferedReader reader = new BufferedReader(new InputStreamReader(input));
-			String line = null;
-
-			while ((line = reader.readLine()) != null) {
-				db.execSQL(line.replace(";", ""));
-			}
-		}
-		catch (IOException e) {
-			Log.e("Failed to execute " + file, e);
-		}
-	}
-
-	// Meta-data methods
-
-	private static String getDbName(Context context) {
-		String aaName = ReflectionUtils.getMetaData(context, AA_DB_NAME);
-
-		if (aaName == null) {
-			aaName = "Application.db";
-		}
-
-		return aaName;
-	}
-
-	private static int getDbVersion(Context context) {
-		Integer aaVersion = ReflectionUtils.getMetaData(context, AA_DB_VERSION);
-
-		if (aaVersion == null || aaVersion == 0) {
-			aaVersion = 1;
-		}
-
-		return aaVersion;
-	}
+
+    private DbMetaData mDbMetaData;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public DatabaseHelper(Context context, DbMetaData metaData) {
+        super(context, metaData.getDatabaseName(), null, metaData.getDatabaseVersion());
+        mDbMetaData = metaData;
+        copyAttachedDatabase(context);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
+            db.execSQL("PRAGMA foreign_keys=ON;");
+            Log.i("Foreign Keys supported. Enabling foreign key features.");
+        }
+
+        db.beginTransaction();
+
+        for (TableInfo tableInfo : Cache.getTableInfos()) {
+            db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
+        }
+
+        db.setTransactionSuccessful();
+        db.endTransaction();
+
+        executeMigrations(db, -1, db.getVersion());
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
+            db.execSQL("PRAGMA foreign_keys=ON;");
+            Log.i("Foreign Keys supported. Enabling foreign key features.");
+        }
+
+        if (!executeMigrations(db, oldVersion, newVersion)) {
+            Log.i("No migrations found. Calling onCreate.");
+            onCreate(db);
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public void copyAttachedDatabase(Context context) {
+        String dbName = mDbMetaData.getDatabaseName();
+        final File dbPath = context.getDatabasePath(dbName);
+
+        // If the database already exists, return
+        if (dbPath.exists()) {
+            return;
+        }
+
+        // Make sure we have a path to the file
+        dbPath.getParentFile().mkdirs();
+
+        // Try to copy database file
+        try {
+            final InputStream inputStream = context.getAssets().open(dbName);
+            final OutputStream output = new FileOutputStream(dbPath);
+
+            byte[] buffer = new byte[1024];
+            int length;
+
+            while ((length = inputStream.read(buffer)) > 0) {
+                output.write(buffer, 0, length);
+            }
+
+            output.flush();
+            output.close();
+            inputStream.close();
+        }
+        catch (IOException e) {
+            Log.e("Failed to open file", e);
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
+        boolean migrationExecuted = false;
+        try {
+            final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(mDbMetaData.getMigrationPath()));
+            Collections.sort(files, new NaturalOrderComparator());
+
+            db.beginTransaction();
+
+            for (String file : files) {
+                try {
+                    final int version = Integer.valueOf(file.replace(".sql", ""));
+
+                    if (version > oldVersion && version <= newVersion) {
+                        executeSqlScript(db, file);
+                        migrationExecuted = true;
+
+                        Log.i(file + " executed succesfully.");
+                    }
+                }
+                catch (NumberFormatException e) {
+                    Log.w("Skipping invalidly named file: " + file, e);
+                }
+            }
+
+            db.setTransactionSuccessful();
+            db.endTransaction();
+        }
+        catch (IOException e) {
+            Log.e("Failed to execute migrations.", e);
+        }
+
+        return migrationExecuted;
+    }
+
+    private void executeSqlScript(SQLiteDatabase db, String file) {
+        try {
+            final InputStream input = Cache.getContext().getAssets().open(mDbMetaData.getMigrationPath() + "/" + file);
+            final BufferedReader reader = new BufferedReader(new InputStreamReader(input));
+            String line = null;
+
+            while ((line = reader.readLine()) != null) {
+                db.execSQL(line.replace(";", ""));
+            }
+        }
+        catch (IOException e) {
+            Log.e("Failed to execute " + file, e);
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/DbMetaData.java b/src/com/activeandroid/DbMetaData.java
new file mode 100644
index 00000000..f734c64d
--- /dev/null
+++ b/src/com/activeandroid/DbMetaData.java
@@ -0,0 +1,12 @@
+package com.activeandroid;
+
+public abstract class DbMetaData {
+
+    public abstract int getDatabaseVersion();
+
+    public abstract String getDatabaseName();
+
+    public abstract String getMigrationPath();
+
+    public boolean isResettable() { return false; }
+}
diff --git a/src/com/activeandroid/DefaultMetaData.java b/src/com/activeandroid/DefaultMetaData.java
new file mode 100644
index 00000000..4d19f8e3
--- /dev/null
+++ b/src/com/activeandroid/DefaultMetaData.java
@@ -0,0 +1,69 @@
+package com.activeandroid;
+
+import android.content.Context;
+
+import com.activeandroid.util.ReflectionUtils;
+
+public class DefaultMetaData extends DbMetaData {
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private final static String AA_DB_NAME = "AA_DB_NAME";
+    private final static String AA_DB_VERSION = "AA_DB_VERSION";
+
+    private final static String MIGRATION_PATH = "migrations";
+
+    private Context mContext;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // SINGLETON
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private static DefaultMetaData sInstance;
+
+    public synchronized static DefaultMetaData getInstanse(Context context) {
+        if (sInstance == null) {
+            sInstance = new DefaultMetaData(context);
+        }
+        return sInstance;
+    }
+
+    // hide constructor
+    private DefaultMetaData(Context context) {
+        mContext = context;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public int getDatabaseVersion() {
+        Integer aaVersion = ReflectionUtils.getMetaData(mContext, AA_DB_VERSION);
+
+        if (aaVersion == null || aaVersion == 0) {
+            aaVersion = 1;
+        }
+
+        return aaVersion;
+    }
+
+    @Override
+    public String getDatabaseName() {
+        String aaName = ReflectionUtils.getMetaData(mContext, AA_DB_NAME);
+
+        if (aaName == null) {
+            aaName = "Application.db";
+        }
+
+        return aaName;
+    }
+
+    @Override
+    public String getMigrationPath() {
+        return MIGRATION_PATH;
+    }
+
+}
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index e06169f8..a60cb07b 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -32,241 +32,242 @@
 
 @SuppressWarnings("unchecked")
 public abstract class Model {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Column(name = "Id")
-	private Long mId = null;
-
-	private TableInfo mTableInfo;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Model() {
-		mTableInfo = Cache.getTableInfo(getClass());
-		Cache.addEntity(this);
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public final Long getId() {
-		return mId;
-	}
-
-	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), "Id=?", new String[] { getId().toString() });
-		Cache.removeEntity(this);
-	}
-
-	public final void save() {
-		final SQLiteDatabase db = Cache.openDatabase();
-		final ContentValues values = new ContentValues();
-
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-
-			field.setAccessible(true);
-
-			try {
-				Object value = field.get(this);
-
-				if (value != null) {
-					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-					if (typeSerializer != null) {
-						// serialize data
-						value = typeSerializer.serialize(value);
-						// set new object type
-						if (value != null) {
-							fieldType = value.getClass();
-							// check that the serializer returned what it promised
-							if (!fieldType.equals(typeSerializer.getSerializedType())) {
-								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-										typeSerializer.getSerializedType(), fieldType));
-							}
-						}
-					}
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (value == null) {
-					values.putNull(fieldName);
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					values.put(fieldName, (Byte) value);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					values.put(fieldName, (Short) value);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					values.put(fieldName, (Integer) value);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					values.put(fieldName, (Long) value);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					values.put(fieldName, (Float) value);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					values.put(fieldName, (Double) value);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					values.put(fieldName, (Boolean) value);
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(String.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					values.put(fieldName, (byte[]) value);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					values.put(fieldName, ((Model) value).getId());
-				}
-			}
-			catch (IllegalArgumentException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-		}
-
-		if (mId == null) {
-			mId = db.insert(mTableInfo.getTableName(), null, values);
-		}
-		else {
-			db.update(mTableInfo.getTableName(), values, "Id=" + mId, null);
-		}
-	}
-
-	// Convenience methods
-
-	public static void delete(Class<? extends Model> type, long id) {
-		new Delete().from(type).where("Id=?", id).execute();
-	}
-
-	public static <T extends Model> T load(Class<? extends Model> type, long id) {
-		return new Select().from(type).where("Id=?", id).executeSingle();
-	}
-
-	// Model population
-
-	public final void loadFromCursor(Class<? extends Model> type, Cursor cursor) {
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-			final int columnIndex = cursor.getColumnIndex(fieldName);
-
-			if (columnIndex < 0) {
-				continue;
-			}
-
-			field.setAccessible(true);
-
-			try {
-				boolean columnIsNull = cursor.isNull(columnIndex);
-				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-				Object value = null;
-
-				if (typeSerializer != null) {
-				  fieldType = typeSerializer.getSerializedType();
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (columnIsNull) {
-					field = null;
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					value = cursor.getLong(columnIndex);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					value = cursor.getFloat(columnIndex);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					value = cursor.getDouble(columnIndex);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					value = cursor.getInt(columnIndex) != 0;
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					value = cursor.getString(columnIndex).charAt(0);
-				}
-				else if (fieldType.equals(String.class)) {
-					value = cursor.getString(columnIndex);
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					value = cursor.getBlob(columnIndex);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					final long entityId = cursor.getLong(columnIndex);
-					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
-
-					Model entity = Cache.getEntity(entityType, entityId);
-					if (entity == null) {
-						entity = new Select().from(entityType).where("Id=?", entityId).executeSingle();
-					}
-
-					value = entity;
-				}
-
-				// Use a deserializer if one is available
-				if (typeSerializer != null && !columnIsNull) {
-					value = typeSerializer.deserialize(value);
-				}
-
-				// Set the field value
-				if (value != null) {
-					field.set(this, value);
-				}
-			}
-			catch (IllegalArgumentException e) {
-				Log.e(e.getMessage());
-			}
-			catch (IllegalAccessException e) {
-				Log.e(e.getMessage());
-			}
-			catch (SecurityException e) {
-				Log.e(e.getMessage());
-			}
-		}
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	protected final <E extends Model> List<E> getMany(Class<? extends Model> type, String foreignKey) {
-		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public boolean equals(Object obj) {
-		final Model other = (Model) obj;
-
-		return this.mId != null && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()))
-				&& (this.mId.equals(other.mId));
-	}
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Column(name = "Id")
+    private Long mId = null;
+
+    private TableInfo mTableInfo;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Model() {
+        mTableInfo = Cache.getTableInfo(getClass());
+        Cache.addEntity(this);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public final Long getId() {
+        return mId;
+    }
+
+    public final void delete() {
+        Cache.openDatabase(ReflectionUtils.getDbMetaDataClass(getClass())).delete(
+                mTableInfo.getTableName(), "Id=?", new String[] { getId().toString() });
+        Cache.removeEntity(this);
+    }
+
+    public final void save() {
+        final SQLiteDatabase db = Cache.openDatabase(ReflectionUtils.getDbMetaDataClass(getClass()));
+        final ContentValues values = new ContentValues();
+
+        for (Field field : mTableInfo.getFields()) {
+            final String fieldName = mTableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+
+            field.setAccessible(true);
+
+            try {
+                Object value = field.get(this);
+
+                if (value != null) {
+                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                    if (typeSerializer != null) {
+                        // serialize data
+                        value = typeSerializer.serialize(value);
+                        // set new object type
+                        if (value != null) {
+                            fieldType = value.getClass();
+                            // check that the serializer returned what it promised
+                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
+                                Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                        typeSerializer.getSerializedType(), fieldType));
+                            }
+                        }
+                    }
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (value == null) {
+                    values.putNull(fieldName);
+                }
+                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    values.put(fieldName, (Byte) value);
+                }
+                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    values.put(fieldName, (Short) value);
+                }
+                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    values.put(fieldName, (Integer) value);
+                }
+                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    values.put(fieldName, (Long) value);
+                }
+                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    values.put(fieldName, (Float) value);
+                }
+                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    values.put(fieldName, (Double) value);
+                }
+                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    values.put(fieldName, (Boolean) value);
+                }
+                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    values.put(fieldName, value.toString());
+                }
+                else if (fieldType.equals(String.class)) {
+                    values.put(fieldName, value.toString());
+                }
+                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    values.put(fieldName, (byte[]) value);
+                }
+                else if (ReflectionUtils.isModel(fieldType)) {
+                    values.put(fieldName, ((Model) value).getId());
+                }
+            }
+            catch (IllegalArgumentException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+            catch (IllegalAccessException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+
+        if (mId == null) {
+            mId = db.insert(mTableInfo.getTableName(), null, values);
+        }
+        else {
+            db.update(mTableInfo.getTableName(), values, "Id=" + mId, null);
+        }
+    }
+
+    // Convenience methods
+
+    public static void delete(Class<? extends Model> type, long id) {
+        new Delete().from(type).where("Id=?", id).execute();
+    }
+
+    public static <T extends Model> T load(Class<? extends Model> type, long id) {
+        return new Select().from(type).where("Id=?", id).executeSingle();
+    }
+
+    // Model population
+
+    public final void loadFromCursor(Class<? extends Model> type, Cursor cursor) {
+        for (Field field : mTableInfo.getFields()) {
+            final String fieldName = mTableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+            final int columnIndex = cursor.getColumnIndex(fieldName);
+
+            if (columnIndex < 0) {
+                continue;
+            }
+
+            field.setAccessible(true);
+
+            try {
+                boolean columnIsNull = cursor.isNull(columnIndex);
+                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                Object value = null;
+
+                if (typeSerializer != null) {
+                  fieldType = typeSerializer.getSerializedType();
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (columnIsNull) {
+                    field = null;
+                }
+                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    value = cursor.getLong(columnIndex);
+                }
+                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    value = cursor.getFloat(columnIndex);
+                }
+                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    value = cursor.getDouble(columnIndex);
+                }
+                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    value = cursor.getInt(columnIndex) != 0;
+                }
+                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    value = cursor.getString(columnIndex).charAt(0);
+                }
+                else if (fieldType.equals(String.class)) {
+                    value = cursor.getString(columnIndex);
+                }
+                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    value = cursor.getBlob(columnIndex);
+                }
+                else if (ReflectionUtils.isModel(fieldType)) {
+                    final long entityId = cursor.getLong(columnIndex);
+                    final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
+
+                    Model entity = Cache.getEntity(entityType, entityId);
+                    if (entity == null) {
+                        entity = new Select().from(entityType).where("Id=?", entityId).executeSingle();
+                    }
+
+                    value = entity;
+                }
+
+                // Use a deserializer if one is available
+                if (typeSerializer != null && !columnIsNull) {
+                    value = typeSerializer.deserialize(value);
+                }
+
+                // Set the field value
+                if (value != null) {
+                    field.set(this, value);
+                }
+            }
+            catch (IllegalArgumentException e) {
+                Log.e(e.getMessage());
+            }
+            catch (IllegalAccessException e) {
+                Log.e(e.getMessage());
+            }
+            catch (SecurityException e) {
+                Log.e(e.getMessage());
+            }
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PROTECTED METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    protected final <E extends Model> List<E> getMany(Class<? extends Model> type, String foreignKey) {
+        return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public boolean equals(Object obj) {
+        final Model other = (Model) obj;
+
+        return this.mId != null && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()))
+                && (this.mId.equals(other.mId));
+    }
 }
diff --git a/src/com/activeandroid/annotation/DatabaseMetaData.java b/src/com/activeandroid/annotation/DatabaseMetaData.java
new file mode 100644
index 00000000..c724f6eb
--- /dev/null
+++ b/src/com/activeandroid/annotation/DatabaseMetaData.java
@@ -0,0 +1,30 @@
+package com.activeandroid.annotation;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import com.activeandroid.DbMetaData;
+
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface DatabaseMetaData {
+    public Class<? extends DbMetaData> metadataClass();
+}
diff --git a/src/com/activeandroid/content/ContentProvider.java b/src/com/activeandroid/content/ContentProvider.java
index 12433286..5a7eb032 100644
--- a/src/com/activeandroid/content/ContentProvider.java
+++ b/src/com/activeandroid/content/ContentProvider.java
@@ -1,121 +1,128 @@
 package com.activeandroid.content;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
+import java.util.Locale;
 
+import android.annotation.SuppressLint;
 import android.app.Application;
 import android.content.ContentValues;
 import android.content.UriMatcher;
 import android.database.Cursor;
 import android.net.Uri;
+import android.util.SparseArray;
 
 import com.activeandroid.ActiveAndroid;
 import com.activeandroid.Cache;
 import com.activeandroid.Model;
 import com.activeandroid.TableInfo;
+import com.activeandroid.util.ReflectionUtils;
 
+@SuppressLint("DefaultLocale")
 public class ContentProvider extends android.content.ContentProvider {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
-	private static final Map<Integer, Class<? extends Model>> TYPE_CODES = new HashMap<Integer, Class<? extends Model>>();
+    private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
+    private static final SparseArray<Class<? extends Model>> TYPE_CODES = new SparseArray<Class<? extends Model>>();
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private final String mAuthority = getContext().getPackageName();
+    private final String mAuthority = getContext().getPackageName();
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	@Override
-	public boolean onCreate() {
-		ActiveAndroid.initialize((Application) getContext().getApplicationContext());
+    @Override
+    public boolean onCreate() {
+        ActiveAndroid.initialize((Application) getContext().getApplicationContext());
 
-		List<TableInfo> tableInfos = new ArrayList<TableInfo>(Cache.getTableInfos());
-		for (int i = 0; i < tableInfos.size(); i++) {
-			TableInfo tableInfo = tableInfos.get(i);
+        List<TableInfo> tableInfos = new ArrayList<TableInfo>(Cache.getTableInfos());
+        for (int i = 0; i < tableInfos.size(); i++) {
+            TableInfo tableInfo = tableInfos.get(i);
 
-			URI_MATCHER.addURI(mAuthority, tableInfo.getTableName().toLowerCase(), i);
-			TYPE_CODES.put(i, tableInfo.getType());
-		}
+            URI_MATCHER.addURI(mAuthority, tableInfo.getTableName().toLowerCase(Locale.getDefault()), i);
+            TYPE_CODES.put(i, tableInfo.getType());
+        }
 
-		return true;
-	}
+        return true;
+    }
 
-	@Override
-	public String getType(Uri uri) {
-		return null;
-	}
+    @Override
+    public String getType(Uri uri) {
+        return null;
+    }
 
-	// SQLite methods
+    // SQLite methods
 
-	@Override
-	public Uri insert(Uri uri, ContentValues values) {
-		Class<? extends Model> type = getModelType(uri);
-		Long id = Cache.openDatabase().insert(Cache.getTableName(type), null, values);
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        Class<? extends Model> type = getModelType(uri);
+        Long id = Cache.openDatabase(ReflectionUtils.getDbMetaDataClass(type)).insert(
+                Cache.getTableName(type), null, values);
 
-		if (id != null && id > 0) {
-			Uri retUri = createUri(type, id);
-			notifyChange(retUri);
+        if (id != null && id > 0) {
+            Uri retUri = createUri(type, id);
+            notifyChange(retUri);
 
-			return retUri;
-		}
+            return retUri;
+        }
 
-		return null;
-	}
+        return null;
+    }
 
-	@Override
-	public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-		Class<? extends Model> type = getModelType(uri);
-		int count = Cache.openDatabase().update(Cache.getTableName(type), values, selection, selectionArgs);
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        Class<? extends Model> type = getModelType(uri);
+        int count = Cache.openDatabase(ReflectionUtils.getDbMetaDataClass(type)).update(
+                Cache.getTableName(type), values, selection, selectionArgs);
 
-		notifyChange(uri);
+        notifyChange(uri);
 
-		return count;
-	}
+        return count;
+    }
 
-	@Override
-	public int delete(Uri uri, String selection, String[] selectionArgs) {
-		Class<? extends Model> type = getModelType(uri);
-		int count = Cache.openDatabase().delete(Cache.getTableName(type), selection, selectionArgs);
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        Class<? extends Model> type = getModelType(uri);
+        int count = Cache.openDatabase(ReflectionUtils.getDbMetaDataClass(type)).delete(
+                Cache.getTableName(type), selection, selectionArgs);
 
-		notifyChange(uri);
+        notifyChange(uri);
 
-		return count;
-	}
+        return count;
+    }
 
-	@Override
-	public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
-		Class<? extends Model> type = getModelType(uri);
-		return Cache.openDatabase().query(Cache.getTableName(type), projection, selection, selectionArgs, null, null,
-				sortOrder);
-	}
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+        Class<? extends Model> type = getModelType(uri);
+        return Cache.openDatabase(ReflectionUtils.getDbMetaDataClass(type)).query(
+                Cache.getTableName(type), projection, selection, selectionArgs, null, null,
+                sortOrder);
+    }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private Class<? extends Model> getModelType(Uri uri) {
-		int code = URI_MATCHER.match(uri);
-		if (code != UriMatcher.NO_MATCH) {
-			return TYPE_CODES.get(code);
-		}
+    private Class<? extends Model> getModelType(Uri uri) {
+        int code = URI_MATCHER.match(uri);
+        if (code != UriMatcher.NO_MATCH) {
+            return TYPE_CODES.get(code);
+        }
 
-		return null;
-	}
+        return null;
+    }
 
-	private Uri createUri(Class<? extends Model> type, Long id) {
-		return Uri.parse("content://" + mAuthority + "/" + Cache.getTableName(type).toLowerCase() + "/" + id);
-	}
+    private Uri createUri(Class<? extends Model> type, Long id) {
+        return Uri.parse("content://" + mAuthority + "/" + Cache.getTableName(type).toLowerCase() + "/" + id);
+    }
 
-	private void notifyChange(Uri uri) {
-		getContext().getContentResolver().notifyChange(uri, null);
-	}
+    private void notifyChange(Uri uri) {
+        getContext().getContentResolver().notifyChange(uri, null);
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/query/From.java b/src/com/activeandroid/query/From.java
index 4da87d92..cb78956a 100644
--- a/src/com/activeandroid/query/From.java
+++ b/src/com/activeandroid/query/From.java
@@ -26,187 +26,187 @@
 import com.activeandroid.util.SQLiteUtils;
 
 public final class From implements Sqlable {
-	private Sqlable mQueryBase;
-
-	private Class<? extends Model> mType;
-	private String mAlias;
-	private List<Join> mJoins;
-	private String mWhere;
-	private String mGroupBy;
-	private String mHaving;
-	private String mOrderBy;
-	private String mLimit;
-	private String mOffset;
-
-	private List<Object> mArguments;
-
-	public From(Class<? extends Model> table, Sqlable queryBase) {
-		mType = table;
-		mJoins = new ArrayList<Join>();
-		mQueryBase = queryBase;
-
-		mJoins = new ArrayList<Join>();
-		mArguments = new ArrayList<Object>();
-	}
-
-	public From as(String alias) {
-		mAlias = alias;
-		return this;
-	}
-
-	public Join join(Class<? extends Model> table) {
-		Join join = new Join(this, table, null);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join leftJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.LEFT);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join outerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.OUTER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join innerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.INNER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join crossJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.CROSS);
-		mJoins.add(join);
-		return join;
-	}
-
-	public From where(String where) {
-		mWhere = where;
-		mArguments.clear();
-
-		return this;
-	}
-
-	public From where(String where, Object... args) {
-		mWhere = where;
-		mArguments.clear();
-		mArguments.addAll(Arrays.asList(args));
-
-		return this;
-	}
-
-	public From groupBy(String groupBy) {
-		mGroupBy = groupBy;
-		return this;
-	}
-
-	public From having(String having) {
-		mHaving = having;
-		return this;
-	}
-
-	public From orderBy(String orderBy) {
-		mOrderBy = orderBy;
-		return this;
-	}
-
-	public From limit(int limit) {
-		return limit(String.valueOf(limit));
-	}
-
-	public From limit(String limit) {
-		mLimit = limit;
-		return this;
-	}
-
-	public From offset(int offset) {
-		return offset(String.valueOf(offset));
-	}
-
-	public From offset(String offset) {
-		mOffset = offset;
-		return this;
-	}
-
-	void addArguments(Object[] args) {
-		mArguments.addAll(Arrays.asList(args));
-	}
-
-	@Override
-	public String toSql() {
-		String sql = "";
-
-		sql += mQueryBase.toSql();
-		sql += "FROM " + Cache.getTableName(mType) + " ";
-
-		if (mAlias != null) {
-			sql += "AS " + mAlias + " ";
-		}
-
-		for (Join join : mJoins) {
-			sql += join.toSql();
-		}
-
-		if (mWhere != null) {
-			sql += "WHERE " + mWhere + " ";
-		}
-
-		if (mGroupBy != null) {
-			sql += "GROUP BY " + mGroupBy + " ";
-		}
-
-		if (mHaving != null) {
-			sql += "HAVING " + mHaving + " ";
-		}
-
-		if (mOrderBy != null) {
-			sql += "ORDER BY " + mOrderBy + " ";
-		}
-
-		if (mLimit != null) {
-			sql += "LIMIT " + mLimit + " ";
-		}
-
-		if (mOffset != null) {
-			sql += "OFFSET " + mOffset + " ";
-		}
-
-		return sql.trim();
-	}
-
-	public <T extends Model> List<T> execute() {
-		if (mQueryBase instanceof Select) {
-			return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
-		}
-		else {
-			SQLiteUtils.execSql(toSql(), getArguments());
-			return null;
-		}
-	}
-
-	public <T extends Model> T executeSingle() {
-		if (mQueryBase instanceof Select) {
-			limit(1);
-			return SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
-		}
-		else {
-			SQLiteUtils.execSql(toSql(), getArguments());
-			return null;
-		}
-	}
-
-	public String[] getArguments() {
-		final int size = mArguments.size();
-		final String[] args = new String[size];
-
-		for (int i = 0; i < size; i++) {
-			args[i] = mArguments.get(i).toString();
-		}
-
-		return args;
-	}
+    private Sqlable mQueryBase;
+
+    private Class<? extends Model> mType;
+    private String mAlias;
+    private List<Join> mJoins;
+    private String mWhere;
+    private String mGroupBy;
+    private String mHaving;
+    private String mOrderBy;
+    private String mLimit;
+    private String mOffset;
+
+    private List<Object> mArguments;
+
+    public From(Class<? extends Model> table, Sqlable queryBase) {
+        mType = table;
+        mJoins = new ArrayList<Join>();
+        mQueryBase = queryBase;
+
+        mJoins = new ArrayList<Join>();
+        mArguments = new ArrayList<Object>();
+    }
+
+    public From as(String alias) {
+        mAlias = alias;
+        return this;
+    }
+
+    public Join join(Class<? extends Model> table) {
+        Join join = new Join(this, table, null);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join leftJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.LEFT);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join outerJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.OUTER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join innerJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.INNER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join crossJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.CROSS);
+        mJoins.add(join);
+        return join;
+    }
+
+    public From where(String where) {
+        mWhere = where;
+        mArguments.clear();
+
+        return this;
+    }
+
+    public From where(String where, Object... args) {
+        mWhere = where;
+        mArguments.clear();
+        mArguments.addAll(Arrays.asList(args));
+
+        return this;
+    }
+
+    public From groupBy(String groupBy) {
+        mGroupBy = groupBy;
+        return this;
+    }
+
+    public From having(String having) {
+        mHaving = having;
+        return this;
+    }
+
+    public From orderBy(String orderBy) {
+        mOrderBy = orderBy;
+        return this;
+    }
+
+    public From limit(int limit) {
+        return limit(String.valueOf(limit));
+    }
+
+    public From limit(String limit) {
+        mLimit = limit;
+        return this;
+    }
+
+    public From offset(int offset) {
+        return offset(String.valueOf(offset));
+    }
+
+    public From offset(String offset) {
+        mOffset = offset;
+        return this;
+    }
+
+    void addArguments(Object[] args) {
+        mArguments.addAll(Arrays.asList(args));
+    }
+
+    @Override
+    public String toSql() {
+        String sql = "";
+
+        sql += mQueryBase.toSql();
+        sql += "FROM " + Cache.getTableName(mType) + " ";
+
+        if (mAlias != null) {
+            sql += "AS " + mAlias + " ";
+        }
+
+        for (Join join : mJoins) {
+            sql += join.toSql();
+        }
+
+        if (mWhere != null) {
+            sql += "WHERE " + mWhere + " ";
+        }
+
+        if (mGroupBy != null) {
+            sql += "GROUP BY " + mGroupBy + " ";
+        }
+
+        if (mHaving != null) {
+            sql += "HAVING " + mHaving + " ";
+        }
+
+        if (mOrderBy != null) {
+            sql += "ORDER BY " + mOrderBy + " ";
+        }
+
+        if (mLimit != null) {
+            sql += "LIMIT " + mLimit + " ";
+        }
+
+        if (mOffset != null) {
+            sql += "OFFSET " + mOffset + " ";
+        }
+
+        return sql.trim();
+    }
+
+    public <T extends Model> List<T> execute() {
+        if (mQueryBase instanceof Select) {
+            return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
+        }
+        else {
+            SQLiteUtils.execSql(mType, toSql(), getArguments());
+            return null;
+        }
+    }
+
+    public <T extends Model> T executeSingle() {
+        if (mQueryBase instanceof Select) {
+            limit(1);
+            return SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
+        }
+        else {
+            SQLiteUtils.execSql(mType, toSql(), getArguments());
+            return null;
+        }
+    }
+
+    public String[] getArguments() {
+        final int size = mArguments.size();
+        final String[] args = new String[size];
+
+        for (int i = 0; i < size; i++) {
+            args[i] = mArguments.get(i).toString();
+        }
+
+        return args;
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/query/Set.java b/src/com/activeandroid/query/Set.java
index 7bcbb5f8..5056b674 100644
--- a/src/com/activeandroid/query/Set.java
+++ b/src/com/activeandroid/query/Set.java
@@ -23,78 +23,78 @@
 import com.activeandroid.util.SQLiteUtils;
 
 public final class Set implements Sqlable {
-	private Update mUpdate;
+    private Update mUpdate;
 
-	private String mSet;
-	private String mWhere;
+    private String mSet;
+    private String mWhere;
 
-	private List<Object> mSetArguments;
-	private List<Object> mWhereArguments;
+    private List<Object> mSetArguments;
+    private List<Object> mWhereArguments;
 
-	public Set(Update queryBase, String set) {
-		mUpdate = queryBase;
-		mSet = set;
+    public Set(Update queryBase, String set) {
+        mUpdate = queryBase;
+        mSet = set;
 
-		mSetArguments = new ArrayList<Object>();
-		mWhereArguments = new ArrayList<Object>();
-	}
+        mSetArguments = new ArrayList<Object>();
+        mWhereArguments = new ArrayList<Object>();
+    }
 
-	public Set(Update queryBase, String set, Object... args) {
-		mUpdate = queryBase;
-		mSet = set;
+    public Set(Update queryBase, String set, Object... args) {
+        mUpdate = queryBase;
+        mSet = set;
 
-		mSetArguments = new ArrayList<Object>();
-		mWhereArguments = new ArrayList<Object>();
+        mSetArguments = new ArrayList<Object>();
+        mWhereArguments = new ArrayList<Object>();
 
-		mSetArguments.addAll(Arrays.asList(args));
-	}
+        mSetArguments.addAll(Arrays.asList(args));
+    }
 
-	public Set where(String where) {
-		mWhere = where;
-		mWhereArguments.clear();
+    public Set where(String where) {
+        mWhere = where;
+        mWhereArguments.clear();
 
-		return this;
-	}
+        return this;
+    }
 
-	public Set where(String where, Object... args) {
-		mWhere = where;
-		mWhereArguments.clear();
-		mWhereArguments.addAll(Arrays.asList(args));
+    public Set where(String where, Object... args) {
+        mWhere = where;
+        mWhereArguments.clear();
+        mWhereArguments.addAll(Arrays.asList(args));
 
-		return this;
-	}
+        return this;
+    }
 
-	@Override
-	public String toSql() {
-		String sql = "";
+    @Override
+    public String toSql() {
+        String sql = "";
 
-		sql += mUpdate.toSql();
-		sql += "SET " + mSet + " ";
-		
-		if (mWhere != null) {
-			sql += "WHERE " + mWhere + " ";
-		}
+        sql += mUpdate.toSql();
+        sql += "SET " + mSet + " ";
 
-		return sql;
-	}
+        if (mWhere != null) {
+            sql += "WHERE " + mWhere + " ";
+        }
 
-	public void execute() {
-		SQLiteUtils.execSql(toSql(), getArguments());
-	}
+        return sql;
+    }
 
-	public String[] getArguments() {
-		final int setSize = mSetArguments.size();
-		final int whereSize = mWhereArguments.size();
-		final String[] args = new String[setSize + whereSize];
+    public void execute() {
+        SQLiteUtils.execSql(mUpdate.getType(), toSql(), getArguments());
+    }
 
-		for (int i = 0; i < setSize; i++) {
-			args[i] = mSetArguments.get(i).toString();
-		}
+    public String[] getArguments() {
+        final int setSize = mSetArguments.size();
+        final int whereSize = mWhereArguments.size();
+        final String[] args = new String[setSize + whereSize];
 
-		for (int i = 0; i < whereSize; i++) {
-			args[i] = mWhereArguments.get(i).toString();
-		}
+        for (int i = 0; i < setSize; i++) {
+            args[i] = mSetArguments.get(i).toString();
+        }
 
-		return args;
-	}
+        for (int i = 0; i < whereSize; i++) {
+            args[i] = mWhereArguments.get(i).toString();
+        }
+
+        return args;
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/util/ReflectionUtils.java b/src/com/activeandroid/util/ReflectionUtils.java
index 2728ddd3..30b4ea16 100644
--- a/src/com/activeandroid/util/ReflectionUtils.java
+++ b/src/com/activeandroid/util/ReflectionUtils.java
@@ -20,54 +20,80 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 
+import com.activeandroid.DbMetaData;
+import com.activeandroid.DefaultMetaData;
 import com.activeandroid.Model;
+import com.activeandroid.annotation.DatabaseMetaData;
 import com.activeandroid.serializer.TypeSerializer;
 
 public final class ReflectionUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static boolean isModel(Class<?> type) {
-		return isSubclassOf(type, Model.class);
-	}
-
-	public static boolean isTypeSerializer(Class<?> type) {
-		return isSubclassOf(type, TypeSerializer.class);
-	}
-
-	// Meta-data
-
-	@SuppressWarnings("unchecked")
-	public static <T> T getMetaData(Context context, String name) {
-		try {
-			final ApplicationInfo ai = context.getPackageManager().getApplicationInfo(context.getPackageName(),
-					PackageManager.GET_META_DATA);
-
-			if (ai.metaData != null) {
-				return (T) ai.metaData.get(name);
-			}
-		}
-		catch (Exception e) {
-			Log.w("Couldn't find meta-data: " + name);
-		}
-
-		return null;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static boolean isSubclassOf(Class<?> type, Class<?> superClass) {
-		if (type.getSuperclass() != null) {
-			if (type.getSuperclass().equals(superClass)) {
-				return true;
-			}
-
-			return isSubclassOf(type.getSuperclass(), superClass);
-		}
-
-		return false;
-	}
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static boolean isModel(Class<?> type) {
+        return isSubclassOf(type, Model.class);
+    }
+
+    public static boolean isTypeSerializer(Class<?> type) {
+        return isSubclassOf(type, TypeSerializer.class);
+    }
+
+    public static boolean isDbMetaData(Class<?> type) {
+        return isSubclassOf(type, DbMetaData.class);
+    }
+
+    // Meta-data
+
+    @SuppressWarnings("unchecked")
+    public static <T> T getMetaData(Context context, String name) {
+        try {
+            final ApplicationInfo ai = context.getPackageManager().getApplicationInfo(context.getPackageName(),
+                    PackageManager.GET_META_DATA);
+
+            if (ai.metaData != null) {
+                return (T) ai.metaData.get(name);
+            }
+        }
+        catch (Exception e) {
+            Log.w("Couldn't find meta-data: " + name);
+        }
+
+        return null;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static Class<? extends DbMetaData> getDbMetaDataClass(Class<?> type) {
+        // type is DbMetaData, return self
+        if (ReflectionUtils.isDbMetaData(type)) {
+            return (Class<? extends DbMetaData>) type;
+
+        // is Model, return from annotation, default is DefaultMetaData
+        } else if (ReflectionUtils.isModel(type)) {
+            final DatabaseMetaData metaDataAnnotation = type.getAnnotation(DatabaseMetaData.class);
+            return (metaDataAnnotation != null && metaDataAnnotation.metadataClass() != null)
+                    ? metaDataAnnotation.metadataClass()
+                    : DefaultMetaData.class;
+
+        // none of above, throw an exception.
+        } else {
+            throw new IllegalArgumentException("Unable to open database for unknow type "+type.getClass().getSimpleName());
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static boolean isSubclassOf(Class<?> type, Class<?> superClass) {
+        if (type.getSuperclass() != null) {
+            if (type.getSuperclass().equals(superClass)) {
+                return true;
+            }
+
+            return isSubclassOf(type.getSuperclass(), superClass);
+        }
+
+        return false;
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index 7351d5d6..866b850e 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -33,166 +33,166 @@
 import com.activeandroid.serializer.TypeSerializer;
 
 public final class SQLiteUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// ENUMERATIONS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public enum SQLiteType {
-		INTEGER, REAL, TEXT, BLOB
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONTSANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
-		{
-			put(byte.class, SQLiteType.INTEGER);
-			put(short.class, SQLiteType.INTEGER);
-			put(int.class, SQLiteType.INTEGER);
-			put(long.class, SQLiteType.INTEGER);
-			put(float.class, SQLiteType.REAL);
-			put(double.class, SQLiteType.REAL);
-			put(boolean.class, SQLiteType.INTEGER);
-			put(char.class, SQLiteType.TEXT);
-			put(byte[].class, SQLiteType.BLOB);
-			put(Byte.class, SQLiteType.INTEGER);
-			put(Short.class, SQLiteType.INTEGER);
-			put(Integer.class, SQLiteType.INTEGER);
-			put(Long.class, SQLiteType.INTEGER);
-			put(Float.class, SQLiteType.REAL);
-			put(Double.class, SQLiteType.REAL);
-			put(Boolean.class, SQLiteType.INTEGER);
-			put(Character.class, SQLiteType.TEXT);
-			put(String.class, SQLiteType.TEXT);
-			put(Byte[].class, SQLiteType.BLOB);
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void execSql(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSql(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-
-	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-		List<T> entities = processCursor(type, cursor);
-		cursor.close();
-
-		return entities;
-	}
-
-	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		List<T> entities = rawQuery(type, sql, selectionArgs);
-
-		if (entities.size() > 0) {
-			return entities.get(0);
-		}
-
-		return null;
-	}
-
-	// Database creation
-
-	public static String createTableDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-
-		for (Field field : tableInfo.getFields()) {
-			String definition = createColumnDefinition(tableInfo, field);
-			if (!TextUtils.isEmpty(definition)) {
-				definitions.add(definition);
-			}
-		}
-
-		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
-				TextUtils.join(", ", definitions));
-	}
-
-	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
-		String definition = null;
-
-		Class<?> type = field.getType();
-		final String name = tableInfo.getColumnName(field);
-		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-		final Column column = field.getAnnotation(Column.class);
-
-		if (typeSerializer != null) {
-			type = typeSerializer.getSerializedType();
-		}
-
-		if (TYPE_MAP.containsKey(type)) {
-			definition = name + " " + TYPE_MAP.get(type).toString();
-		}
-		else if (ReflectionUtils.isModel(type)) {
-			definition = name + " " + SQLiteType.INTEGER.toString();
-		}
-
-		if (definition != null) {
-			if (column.length() > -1) {
-				definition += "(" + column.length() + ")";
-			}
-
-			if (name.equals("Id")) {
-				definition += " PRIMARY KEY AUTOINCREMENT";
-			}
-
-			if (column.notNull()) {
-				definition += " NOT NULL ON CONFLICT " + column.onNullConflict().toString();
-			}
-
-			if (column.unique()) {
-				definition += " UNIQUE ON CONFLICT " + column.onUniqueConflict().toString();
-			}
-
-			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
-				definition += " REFERENCES " + tableInfo.getTableName() + "(Id)";
-				definition += " ON DELETE " + column.onDelete().toString().replace("_", " ");
-				definition += " ON UPDATE " + column.onUpdate().toString().replace("_", " ");
-			}
-		}
-		else {
-			Log.e("No type mapping for: " + type.toString());
-		}
-
-		return definition;
-	}
-
-	@SuppressWarnings("unchecked")
-	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
-		final List<T> entities = new ArrayList<T>();
-
-		try {
-			Constructor<?> entityConstructor = type.getConstructor();
-
-			if (cursor.moveToFirst()) {
-				do {
-					// TODO: Investigate entity cache leak
-					T entity = (T) entityConstructor.newInstance();
-					((Model) entity).loadFromCursor(type, cursor);
-					entities.add(entity);
-				}
-				while (cursor.moveToNext());
-			}
-
-		}
-		catch (Exception e) {
-			Log.e("Failed to process cursor.", e);
-		}
-
-		return entities;
-	}
+    //////////////////////////////////////////////////////////////////////////////////////
+    // ENUMERATIONS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public enum SQLiteType {
+        INTEGER, REAL, TEXT, BLOB
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE CONTSANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @SuppressWarnings("serial")
+    private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
+        {
+            put(byte.class, SQLiteType.INTEGER);
+            put(short.class, SQLiteType.INTEGER);
+            put(int.class, SQLiteType.INTEGER);
+            put(long.class, SQLiteType.INTEGER);
+            put(float.class, SQLiteType.REAL);
+            put(double.class, SQLiteType.REAL);
+            put(boolean.class, SQLiteType.INTEGER);
+            put(char.class, SQLiteType.TEXT);
+            put(byte[].class, SQLiteType.BLOB);
+            put(Byte.class, SQLiteType.INTEGER);
+            put(Short.class, SQLiteType.INTEGER);
+            put(Integer.class, SQLiteType.INTEGER);
+            put(Long.class, SQLiteType.INTEGER);
+            put(Float.class, SQLiteType.REAL);
+            put(Double.class, SQLiteType.REAL);
+            put(Boolean.class, SQLiteType.INTEGER);
+            put(Character.class, SQLiteType.TEXT);
+            put(String.class, SQLiteType.TEXT);
+            put(Byte[].class, SQLiteType.BLOB);
+        }
+    };
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static void execSql(Class<? extends Model> type, String sql) {
+        Cache.openDatabase(ReflectionUtils.getDbMetaDataClass(type)).execSQL(sql);
+    }
+
+    public static void execSql(Class<? extends Model> type, String sql, Object[] bindArgs) {
+        Cache.openDatabase(ReflectionUtils.getDbMetaDataClass(type)).execSQL(sql, bindArgs);
+    }
+
+    public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
+        Cursor cursor = Cache.openDatabase(ReflectionUtils.getDbMetaDataClass(type)).rawQuery(sql, selectionArgs);
+        List<T> entities = processCursor(type, cursor);
+        cursor.close();
+
+        return entities;
+    }
+
+    public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
+        List<T> entities = rawQuery(type, sql, selectionArgs);
+
+        if (entities.size() > 0) {
+            return entities.get(0);
+        }
+
+        return null;
+    }
+
+    // Database creation
+
+    public static String createTableDefinition(TableInfo tableInfo) {
+        final ArrayList<String> definitions = new ArrayList<String>();
+
+        for (Field field : tableInfo.getFields()) {
+            String definition = createColumnDefinition(tableInfo, field);
+            if (!TextUtils.isEmpty(definition)) {
+                definitions.add(definition);
+            }
+        }
+
+        return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
+                TextUtils.join(", ", definitions));
+    }
+
+    public static String createColumnDefinition(TableInfo tableInfo, Field field) {
+        String definition = null;
+
+        Class<?> type = field.getType();
+        final String name = tableInfo.getColumnName(field);
+        final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
+        final Column column = field.getAnnotation(Column.class);
+
+        if (typeSerializer != null) {
+            type = typeSerializer.getSerializedType();
+        }
+
+        if (TYPE_MAP.containsKey(type)) {
+            definition = name + " " + TYPE_MAP.get(type).toString();
+        }
+        else if (ReflectionUtils.isModel(type)) {
+            definition = name + " " + SQLiteType.INTEGER.toString();
+        }
+
+        if (definition != null) {
+            if (column.length() > -1) {
+                definition += "(" + column.length() + ")";
+            }
+
+            if (name.equals("Id")) {
+                definition += " PRIMARY KEY AUTOINCREMENT";
+            }
+
+            if (column.notNull()) {
+                definition += " NOT NULL ON CONFLICT " + column.onNullConflict().toString();
+            }
+
+            if (column.unique()) {
+                definition += " UNIQUE ON CONFLICT " + column.onUniqueConflict().toString();
+            }
+
+            if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
+                definition += " REFERENCES " + tableInfo.getTableName() + "(Id)";
+                definition += " ON DELETE " + column.onDelete().toString().replace("_", " ");
+                definition += " ON UPDATE " + column.onUpdate().toString().replace("_", " ");
+            }
+        }
+        else {
+            Log.e("No type mapping for: " + type.toString());
+        }
+
+        return definition;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
+        final List<T> entities = new ArrayList<T>();
+
+        try {
+            Constructor<?> entityConstructor = type.getConstructor();
+
+            if (cursor.moveToFirst()) {
+                do {
+                    // TODO: Investigate entity cache leak
+                    T entity = (T) entityConstructor.newInstance();
+                    ((Model) entity).loadFromCursor(type, cursor);
+                    entities.add(entity);
+                }
+                while (cursor.moveToNext());
+            }
+
+        }
+        catch (Exception e) {
+            Log.e("Failed to process cursor.", e);
+        }
+
+        return entities;
+    }
 }
\ No newline at end of file
diff --git a/tests/project.properties b/tests/project.properties
index a3ee5ab6..5ff58277 100644
--- a/tests/project.properties
+++ b/tests/project.properties
@@ -12,3 +12,4 @@
 
 # Project target.
 target=android-17
+android.library.reference.1=..
diff --git a/tests/src/com/activeandroid/test/multidb/Db2MetaData.java b/tests/src/com/activeandroid/test/multidb/Db2MetaData.java
new file mode 100644
index 00000000..dedeee92
--- /dev/null
+++ b/tests/src/com/activeandroid/test/multidb/Db2MetaData.java
@@ -0,0 +1,35 @@
+package com.activeandroid.test.multidb;
+
+import com.activeandroid.DbMetaData;
+
+public class Db2MetaData extends DbMetaData {
+
+    public Db2MetaData() {}
+
+    public Db2MetaData(String dbName) {
+        mDbName = dbName;
+    }
+
+    private String mDbName = "db2";
+
+    @Override
+    public int getDatabaseVersion() {
+        return 1;
+    }
+
+    @Override
+    public String getDatabaseName() {
+        return mDbName;
+    }
+
+    @Override
+    public String getMigrationPath() {
+        return "migration/db2";
+    }
+
+    @Override
+    public boolean isResettable() {
+        return true;
+    }
+
+}
diff --git a/tests/src/com/activeandroid/test/multidb/Db2MockModel.java b/tests/src/com/activeandroid/test/multidb/Db2MockModel.java
new file mode 100644
index 00000000..5a4fd6b6
--- /dev/null
+++ b/tests/src/com/activeandroid/test/multidb/Db2MockModel.java
@@ -0,0 +1,26 @@
+package com.activeandroid.test.multidb;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import com.activeandroid.Model;
+import com.activeandroid.annotation.DatabaseMetaData;
+import com.activeandroid.annotation.Table;
+
+@DatabaseMetaData(metadataClass=Db2MetaData.class)
+@Table(name = "MockModel")
+public class Db2MockModel extends Model {
+}
diff --git a/tests/src/com/activeandroid/test/multidb/Db2TestCase.java b/tests/src/com/activeandroid/test/multidb/Db2TestCase.java
new file mode 100644
index 00000000..68664452
--- /dev/null
+++ b/tests/src/com/activeandroid/test/multidb/Db2TestCase.java
@@ -0,0 +1,38 @@
+package com.activeandroid.test.multidb;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.DbMetaData;
+import com.activeandroid.DefaultMetaData;
+import com.activeandroid.test.ActiveAndroidTestCase;
+
+public class Db2TestCase extends ActiveAndroidTestCase {
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        DbMetaData meta = new Db2MetaData();
+        ActiveAndroid.registerDbMetaData(getApplication(), meta);
+    }
+
+    public void testRegisterDb2() {
+        assertNotNull(ActiveAndroid.getDatabase(Db2MetaData.class));
+        assertNotNull(ActiveAndroid.getDatabase(Db2MockModel.class));
+        assertSame(ActiveAndroid.getDatabase(Db2MockModel.class),
+                   ActiveAndroid.getDatabase(Db2MetaData.class));
+        assertNotSame(ActiveAndroid.getDatabase(Db2MockModel.class),
+                      ActiveAndroid.getDatabase(DefaultMetaData.class));
+        assertEquals("/data/data/com.activeandroid.test/databases/db2",
+                ActiveAndroid.getDatabase(Db2MockModel.class).getPath());
+    }
+
+    public void testResetDb2() {
+        DbMetaData meta = new Db2MetaData("db3");
+        ActiveAndroid.registerDbMetaData(getApplication(), meta);
+
+        SQLiteDatabase db = ActiveAndroid.getDatabase(Db2MetaData.class);
+        assertEquals("/data/data/com.activeandroid.test/databases/db3", db.getPath());
+    }
+
+}
