diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
index 6495e379..9ab275b4 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -26,133 +26,139 @@
 import com.activeandroid.util.Log;
 
 public final class Cache {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public static final int DEFAULT_CACHE_SIZE = 1024;
+    public static final int DEFAULT_CACHE_SIZE = 1024;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private static Context sContext;
+    private static Context sContext;
 
-	private static ModelInfo sModelInfo;
-	private static DatabaseHelper sDatabaseHelper;
+    private static ModelInfo sModelInfo;
+    private static DatabaseHelper sDatabaseHelper;
 
-	private static LruCache<String, Model> sEntities;
+    private static LruCache<String, Model> sEntities;
 
-	private static boolean sIsInitialized = false;
+    private static boolean sIsInitialized = false;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private Cache() {
-	}
+    private Cache() {
+    }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public static synchronized void initialize(Configuration configuration) {
-		if (sIsInitialized) {
-			Log.v("ActiveAndroid already initialized.");
-			return;
-		}
+    public static synchronized void initialize(Configuration configuration) {
+        if (sIsInitialized) {
+            Log.v("ActiveAndroid already initialized.");
+            return;
+        }
 
-		sContext = configuration.getContext();
-		sModelInfo = new ModelInfo(configuration);
-		sDatabaseHelper = new DatabaseHelper(configuration);
+        sContext = configuration.getContext();
+        sModelInfo = new ModelInfo(configuration);
+        sDatabaseHelper = new DatabaseHelper(configuration);
 
-		// TODO: It would be nice to override sizeOf here and calculate the memory
-		// actually used, however at this point it seems like the reflection
-		// required would be too costly to be of any benefit. We'll just set a max
-		// object size instead.
-		sEntities = new LruCache<String, Model>(configuration.getCacheSize());
+        // TODO: It would be nice to override sizeOf here and calculate the memory
+        // actually used, however at this point it seems like the reflection
+        // required would be too costly to be of any benefit. We'll just set a max
+        // object size instead.
+        sEntities = new LruCache<String, Model>(configuration.getCacheSize());
 
-		openDatabase();
+        openDatabase();
 
-		sIsInitialized = true;
+        sIsInitialized = true;
 
-		Log.v("ActiveAndroid initialized successfully.");
-	}
+        Log.v("ActiveAndroid initialized successfully.");
+    }
 
-	public static synchronized void clear() {
-		sEntities.evictAll();
-		Log.v("Cache cleared.");
-	}
+    public static synchronized void clear() {
+        sEntities.evictAll();
+        Log.v("Cache cleared.");
+    }
 
-	public static synchronized void dispose() {
-		closeDatabase();
+    public static synchronized void dispose() {
+        closeDatabase();
 
-		sEntities = null;
-		sModelInfo = null;
-		sDatabaseHelper = null;
+        sEntities = null;
+        sModelInfo = null;
+        sDatabaseHelper = null;
 
-		sIsInitialized = false;
+        sIsInitialized = false;
 
-		Log.v("ActiveAndroid disposed. Call initialize to use library.");
-	}
+        Log.v("ActiveAndroid disposed. Call initialize to use library.");
+    }
 
-	// Database access
-	
-	public static boolean isInitialized() {
-		return sIsInitialized;
-	}
+    // Database access
 
-	public static synchronized SQLiteDatabase openDatabase() {
-		return sDatabaseHelper.getWritableDatabase();
-	}
+    public static boolean isInitialized() {
+        return sIsInitialized;
+    }
 
-	public static synchronized void closeDatabase() {
-		sDatabaseHelper.close();
-	}
+    /**
+     * Gets a writeable instance of {@link SQLiteDatabase}.
+     * 
+     * @return Do not close the returned instance as it is shared between all
+     *         threads.
+     */
+    public static synchronized SQLiteDatabase openDatabase() {
+        return sDatabaseHelper.getWritableDatabase();
+    }
 
-	// Context access
+    public static synchronized void closeDatabase() {
+        sDatabaseHelper.close();
+    }
 
-	public static Context getContext() {
-		return sContext;
-	}
+    // Context access
 
-	// Entity cache
+    public static Context getContext() {
+        return sContext;
+    }
 
-	public static String getIdentifier(Class<? extends Model> type, Long id) {
-		return getTableName(type) + "@" + id;
-	}
+    // Entity cache
 
-	public static String getIdentifier(Model entity) {
-		return getIdentifier(entity.getClass(), entity.getId());
-	}
+    public static String getIdentifier(Class<? extends Model> type, Long id) {
+        return getTableName(type) + "@" + id;
+    }
 
-	public static synchronized void addEntity(Model entity) {
-		sEntities.put(getIdentifier(entity), entity);
-	}
+    public static String getIdentifier(Model entity) {
+        return getIdentifier(entity.getClass(), entity.getId());
+    }
 
-	public static synchronized Model getEntity(Class<? extends Model> type, long id) {
-		return sEntities.get(getIdentifier(type, id));
-	}
+    public static synchronized void addEntity(Model entity) {
+        sEntities.put(getIdentifier(entity), entity);
+    }
 
-	public static synchronized void removeEntity(Model entity) {
-		sEntities.remove(getIdentifier(entity));
-	}
+    public static synchronized Model getEntity(Class<? extends Model> type, long id) {
+        return sEntities.get(getIdentifier(type, id));
+    }
 
-	// Model cache
+    public static synchronized void removeEntity(Model entity) {
+        sEntities.remove(getIdentifier(entity));
+    }
 
-	public static synchronized Collection<TableInfo> getTableInfos() {
-		return sModelInfo.getTableInfos();
-	}
+    // Model cache
 
-	public static synchronized TableInfo getTableInfo(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type);
-	}
+    public static synchronized Collection<TableInfo> getTableInfos() {
+        return sModelInfo.getTableInfos();
+    }
 
-	public static synchronized TypeSerializer getParserForType(Class<?> type) {
-		return sModelInfo.getTypeSerializer(type);
-	}
+    public static synchronized TableInfo getTableInfo(Class<? extends Model> type) {
+        return sModelInfo.getTableInfo(type);
+    }
 
-	public static synchronized String getTableName(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type).getTableName();
-	}
+    public static synchronized TypeSerializer getParserForType(Class<?> type) {
+        return sModelInfo.getTypeSerializer(type);
+    }
+
+    public static synchronized String getTableName(Class<? extends Model> type) {
+        return sModelInfo.getTableInfo(type).getTableName();
+    }
 }
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 7d0cf643..caa3d8bd 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -16,12 +16,16 @@
  * limitations under the License.
  */
 
+import java.lang.reflect.Field;
+import java.util.List;
+
 import android.content.ContentValues;
 import android.database.Cursor;
-import android.database.SQLException;
+import android.database.sqlite.SQLiteConstraintException;
 import android.database.sqlite.SQLiteDatabase;
 import android.text.TextUtils;
 
+import com.activeandroid.annotation.Column;
 import com.activeandroid.content.ContentProvider;
 import com.activeandroid.query.Delete;
 import com.activeandroid.query.Select;
@@ -29,329 +33,311 @@
 import com.activeandroid.util.Log;
 import com.activeandroid.util.SQLiteUtils;
 
-import java.lang.reflect.Field;
-import java.util.List;
-
 @SuppressWarnings("unchecked")
 public abstract class Model {
 
-	/** Prime number used for hashcode() implementation. */
-	private static final int HASH_PRIME = 739;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Long mId = null;
-
-	private final TableInfo mTableInfo;
-	private final String idName;
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Model() {
-		mTableInfo = Cache.getTableInfo(getClass());
-		idName = mTableInfo.getIdName();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public final Long getId() {
-		return mId;
-	}
-
-	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), idName+"=?", new String[] { getId().toString() });
-		Cache.removeEntity(this);
-
-		Cache.getContext().getContentResolver()
-		.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-	}
-
-	private ContentValues createContentValues() {
-		// The exceptions should never happen, so we put the try-catch outside
-		// for better performance.
-		final ContentValues values = new ContentValues();
-
-		try {
-			for (Field field : mTableInfo.getFields()) {
-				final String fieldName = mTableInfo.getColumnName(field);
-				Class<?> fieldType = field.getType();
-				Object value = field.get(this);
-
-				if (value != null) {
-					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-					if (typeSerializer != null) {
-						// serialize data
-						value = typeSerializer.serialize(value);
-						// set new object type
-						if (value != null) {
-							fieldType = value.getClass();
-							// check that the serializer returned what it promised
-							if (!fieldType.equals(typeSerializer.getSerializedType())) {
-								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-										typeSerializer.getSerializedType(), fieldType));
-							}
-						}
-					}
-				}
-
-				SQLiteUtils.put(values, fieldType, fieldName, value);
-			}
-		}
-		catch (IllegalArgumentException e) {
-			Log.e(e.getClass().getName(), e);
-		}
-		catch (IllegalAccessException e) {
-			Log.e(e.getClass().getName(), e);
-		}
-
-		return values;
-	}
-
-	/**
-	 * Updates this model if it has an ID; else inserts it.
-	 * @return If inserting, returns the new ID or -1 on failure; else returns the existing ID.
-	 */
-	public final Long save() {
-		ContentValues values = createContentValues();
-		SQLiteDatabase db = null;
-
-		try {
-			db = Cache.openDatabase();
-			if (mId == null) {
-				long newID = db.insert(mTableInfo.getTableName(), null, values);
-				if (newID == -1L)
-					// returns -1 instead of null for backwards compatibility.
-					return -1L;
-				mId = newID;
-			}
-			else {
-				db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
-			}
-		}
-		finally {
-			if (db != null)
-				db.close();
-		}
-
-		Cache.getContext().getContentResolver()
-		.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-		return mId;
-	}
-
-	public final boolean upsert(long id) {
-		return upsert(id, null, null);
-	}
-
-	/**
-	 * Inserts or updates this object with a specified ID. If insertion fails,
-	 * due to for example, duplication of ID, this method will attempt to update
-	 * the existing row instead. Note that the entire operation is not atomic.
-	 * If either the insertion or updating succeeds, this object will be
-	 * assigned the specified ID. This object will not be modified in any way on
-	 * failure. This "upsert" operation is desirable over "REPLACE" in that it
-	 * doesn't result in deletion of an existing row, and thus does not trigger
-	 * deletion of foreign children that has "ON DELETE CASCADE".
-	 * 
-	 * @param id
-	 * @param updateWhere "where" clause to be used only when updating. Can be null.
-	 * @throws IllegalStateException
-	 *             if this object already has an ID.
-	 * @returns true on success; false on failure.
-	 */
-	public final boolean upsert(long id, String updateWhere, String[] updateWhereArgs) {
-		if (mId != null)
-			throw new IllegalStateException();
-
-		ContentValues values = createContentValues();
-		SQLiteDatabase db = null;
-
-		db = Cache.openDatabase();
-		values.put(idName, id);
-
-		try {
-			// use insertOrThrow to avoid logging to logcat.
-			long newID = db.insertOrThrow(mTableInfo.getTableName(), null,
-					values);
-			if (newID != -1) {
-				// should be same as id.
-				mId = newID;
-				db.close();
-			}
-		}
-		catch (SQLException ignored) {
-		}
-
-		if (mId == null) {
-			try {
-				// Don't update the ID so as to avoid triggering foreign
-				// keys ON UPDATE.
-				values.remove(idName);
-				if (updateWhere != null)
-					updateWhere = updateWhere.trim();
-                if (!TextUtils.isEmpty(updateWhere))
-					updateWhere = " and (" + updateWhere + ")";
-				int rows = db.update(mTableInfo.getTableName(), values, idName
-                        + "=" + id + updateWhere,
-						updateWhereArgs);
-				if (rows == 0) {
-					return false;
-				}
-				mId = id;
-			}
-			finally {
-				db.close();
-			}
-		}
-
-		Cache.getContext().getContentResolver()
-		.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-		return true;
-	}
-
-	// Convenience methods
-
-	public static void delete(Class<? extends Model> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
-	}
-
-	public static <T extends Model> T load(Class<T> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
-	}
-
-	/**
-	 * Deep copies a model instance. Only the model ID and the fields annotated
-	 * as {@link Column} will be copied over to the new instance.
-	 * WARNING: If the specified model is self-referential, this will cause an
-	 * infinite recursion.
-	 * @param model Model instance to copy. Must not be null.
-	 * @return The new model instance or null if an error occurs.
-	 */
-	public static <T extends Model> T clone(T model) {
-		final Class<T> cls = (Class<T>) model.getClass();
-		T newInstance = null;
-
-		try {
-			newInstance = cls.newInstance();
-
-			// copy fields from model to newInstance.
-			for (Field field : model.mTableInfo.getFields()) {
-				Object val = field.get(model);
-
-				if (val instanceof Model)
-					val = clone((Model)val);
-
-				field.set(newInstance, val);
-			}
-
-			newInstance.mId = model.mId;
-
-			return newInstance;
-		}
-		// These should not happen.
-		catch (IllegalAccessException e) {
-			// nothing
-		}
-		catch (InstantiationException e) {
-			// nothing
-		}
-
-		return null;
-	}
-
-	// Model population
-
-	public final void loadFromCursor(Cursor cursor) {
-		/**
-		 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-		 * when the cursor have multiple columns with same name obtained from join tables.
-		 */
-		String[] columnsOrdered = cursor.getColumnNames();
-		// The exceptions should never happen, so we put the try-catch outside
-		// for better performance.
-		try {
-			for (Field field : mTableInfo.getFields()) {
-				final String fieldName = mTableInfo.getColumnName(field);
-				Class<?> fieldType = field.getType();
-				final int columnIndex = SQLiteUtils.indexOfIgnoreCase(columnsOrdered, fieldName);
-
-				if (columnIndex < 0) {
-					continue;
-				}
-
-				boolean columnIsNull = cursor.isNull(columnIndex);
-				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-				Object value = null;
-
-				if (!columnIsNull) {
-					if (typeSerializer != null) {
-						Class<?> getType = typeSerializer.getSerializedType();
-						value = SQLiteUtils.get(cursor, getType, columnIndex);
-						value = typeSerializer.deserialize(value);
-					}
-					else
-						value = SQLiteUtils.get(cursor, fieldType, columnIndex);
-				}
-
-				// If the field accepts null and the value is indeed null, then
-				// set it to null.
-				if (value != null || !fieldType.isPrimitive()) {
-					field.set(this, value);
-				}
-			}
-
-			if (mId != null) {
-				Cache.addEntity(this);
-			}
-		}
-		catch (IllegalArgumentException e) {
-			Log.e(e.getClass().getName(), e);
-		}
-		catch (IllegalAccessException e) {
-			Log.e(e.getClass().getName(), e);
-		}
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
-		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public String toString() {
-		return mTableInfo.getTableName() + "@" + getId();
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (obj instanceof Model && this.mId != null) {
-			final Model other = (Model) obj;
-
-			return this.mId.equals(other.mId)
-					&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
-		} else {
-			return this == obj;
-		}
-	}
-
-	@Override
-	public int hashCode() {
-		int hash = HASH_PRIME;
-		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); //if id is null, use Object.hashCode()
-		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
-		return hash; //To change body of generated methods, choose Tools | Templates.
-	}
+    /** Prime number used for hashcode() implementation. */
+    private static final int HASH_PRIME = 739;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Long mId = null;
+
+    private final TableInfo mTableInfo;
+    private final String idName;
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Model() {
+        mTableInfo = Cache.getTableInfo(getClass());
+        idName = mTableInfo.getIdName();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public final Long getId() {
+        return mId;
+    }
+
+    public final void delete() {
+        Cache.openDatabase().delete(mTableInfo.getTableName(), idName+"=?", new String[] { getId().toString() });
+        Cache.removeEntity(this);
+
+        Cache.getContext().getContentResolver()
+        .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+    }
+
+    private ContentValues createContentValues() {
+        // The exceptions should never happen, so we put the try-catch outside
+        // for better performance.
+        final ContentValues values = new ContentValues();
+
+        try {
+            for (Field field : mTableInfo.getFields()) {
+                final String fieldName = mTableInfo.getColumnName(field);
+                Class<?> fieldType = field.getType();
+                Object value = field.get(this);
+
+                if (value != null) {
+                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                    if (typeSerializer != null) {
+                        // serialize data
+                        value = typeSerializer.serialize(value);
+                        // set new object type
+                        if (value != null) {
+                            fieldType = value.getClass();
+                            // check that the serializer returned what it promised
+                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
+                                Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                        typeSerializer.getSerializedType(), fieldType));
+                            }
+                        }
+                    }
+                }
+
+                SQLiteUtils.put(values, fieldType, fieldName, value);
+            }
+        }
+        catch (IllegalArgumentException e) {
+            Log.e(e.getClass().getName(), e);
+        }
+        catch (IllegalAccessException e) {
+            Log.e(e.getClass().getName(), e);
+        }
+
+        return values;
+    }
+
+    /**
+     * Updates this model if it has an ID; else inserts it.
+     * @return If inserting, returns the new ID or -1 on failure; else returns the existing ID.
+     */
+    public final long save() {
+        ContentValues values = createContentValues();
+        SQLiteDatabase db = Cache.openDatabase();
+
+        if (mId == null) {
+            long newID = db.insert(mTableInfo.getTableName(), null, values);
+            if (newID == -1L)
+                // returns -1 instead of null for backwards compatibility.
+                return -1L;
+            mId = newID;
+        }
+        else {
+            db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
+        }
+
+        Cache.getContext().getContentResolver()
+        .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+        return mId;
+    }
+
+    public final boolean upsert(long id) {
+        return upsert(id, null, null);
+    }
+
+    /**
+     * Inserts or updates this object with a specified ID. If insertion fails,
+     * due to for example, duplication of ID, this method will attempt to update
+     * the existing row instead. Note that the entire operation is not atomic.
+     * If either the insertion or updating succeeds, this object will be
+     * assigned the specified ID. This object will not be modified in any way on
+     * failure. This "upsert" operation is desirable over "REPLACE" in that it
+     * doesn't result in deletion of an existing row, and thus does not trigger
+     * deletion of foreign children that has "ON DELETE CASCADE".
+     * 
+     * @param id
+     * @param updateWhere "where" clause to be used only when updating. Can be null.
+     * @throws IllegalStateException
+     *             if this object already has an ID.
+     * @returns true on success; false on failure.
+     */
+    public final boolean upsert(long id, String updateWhere, String[] updateWhereArgs) {
+        if (mId != null)
+            throw new IllegalStateException();
+
+        ContentValues values = createContentValues();
+        values.put(idName, id);
+        SQLiteDatabase db = Cache.openDatabase();
+
+        try {
+            // use insertOrThrow to avoid logging to logcat.
+            long newID = db.insertOrThrow(mTableInfo.getTableName(), null,
+                    values);
+            if (newID != -1) {
+                // should be same as id.
+                mId = newID;
+            }
+        }
+        catch (SQLiteConstraintException ignored) {
+        }
+
+        if (mId == null) {
+            // Don't update the ID so as to avoid triggering foreign
+            // keys ON UPDATE.
+            values.remove(idName);
+            if (updateWhere != null)
+                updateWhere = updateWhere.trim();
+            if (!TextUtils.isEmpty(updateWhere))
+                updateWhere = " and (" + updateWhere + ")";
+            int rows = db.update(mTableInfo.getTableName(), values, idName
+                    + "=" + id + updateWhere, updateWhereArgs);
+            if (rows == 0)
+            {
+                return false;
+            }
+            mId = id;
+        }
+
+        Cache.getContext().getContentResolver()
+        .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+        return true;
+    }
+
+    // Convenience methods
+
+    public static void delete(Class<? extends Model> type, long id) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
+    }
+
+    public static <T extends Model> T load(Class<T> type, long id) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
+    }
+
+    /**
+     * Deep copies a model instance. Only the model ID and the fields annotated
+     * as {@link Column} will be copied over to the new instance.
+     * WARNING: If the specified model is self-referential, this will cause an
+     * infinite recursion.
+     * @param model Model instance to copy. Must not be null.
+     * @return The new model instance or null if an error occurs.
+     */
+    public static <T extends Model> T clone(T model) {
+        final Class<T> cls = (Class<T>) model.getClass();
+        T newInstance = null;
+
+        try {
+            newInstance = cls.newInstance();
+
+            // copy fields from model to newInstance.
+            for (Field field : model.mTableInfo.getFields()) {
+                Object val = field.get(model);
+
+                if (val instanceof Model)
+                    val = clone((Model)val);
+
+                field.set(newInstance, val);
+            }
+
+            newInstance.mId = model.mId;
+
+            return newInstance;
+        }
+        // These should not happen.
+        catch (IllegalAccessException e) {
+            // nothing
+        }
+        catch (InstantiationException e) {
+            // nothing
+        }
+
+        return null;
+    }
+
+    // Model population
+
+    public final void loadFromCursor(Cursor cursor) {
+        /**
+         * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+         * when the cursor have multiple columns with same name obtained from join tables.
+         */
+        String[] columnsOrdered = cursor.getColumnNames();
+        // The exceptions should never happen, so we put the try-catch outside
+        // for better performance.
+        try {
+            for (Field field : mTableInfo.getFields()) {
+                final String fieldName = mTableInfo.getColumnName(field);
+                Class<?> fieldType = field.getType();
+                final int columnIndex = SQLiteUtils.indexOfIgnoreCase(columnsOrdered, fieldName);
+
+                if (columnIndex < 0) {
+                    continue;
+                }
+
+                boolean columnIsNull = cursor.isNull(columnIndex);
+                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                Object value = null;
+
+                if (!columnIsNull) {
+                    if (typeSerializer != null) {
+                        Class<?> getType = typeSerializer.getSerializedType();
+                        value = SQLiteUtils.get(cursor, getType, columnIndex);
+                        value = typeSerializer.deserialize(value);
+                    }
+                    else
+                        value = SQLiteUtils.get(cursor, fieldType, columnIndex);
+                }
+
+                // If the field accepts null and the value is indeed null, then
+                // set it to null.
+                if (value != null || !fieldType.isPrimitive()) {
+                    field.set(this, value);
+                }
+            }
+
+            if (mId != null) {
+                Cache.addEntity(this);
+            }
+        }
+        catch (IllegalArgumentException e) {
+            Log.e(e.getClass().getName(), e);
+        }
+        catch (IllegalAccessException e) {
+            Log.e(e.getClass().getName(), e);
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PROTECTED METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
+        return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public String toString() {
+        return mTableInfo.getTableName() + "@" + getId();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof Model && this.mId != null) {
+            final Model other = (Model) obj;
+
+            return this.mId.equals(other.mId)
+                    && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
+        } else {
+            return this == obj;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = HASH_PRIME;
+        hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); //if id is null, use Object.hashCode()
+        hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
+        return hash; //To change body of generated methods, choose Tools | Templates.
+    }
 }
