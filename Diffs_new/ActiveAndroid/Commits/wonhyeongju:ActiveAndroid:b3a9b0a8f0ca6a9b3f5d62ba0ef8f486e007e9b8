diff --git a/src/com/activeandroid/DatabaseHelper.java b/src/com/activeandroid/DatabaseHelper.java
index 7158c5bb..e29ae55d 100644
--- a/src/com/activeandroid/DatabaseHelper.java
+++ b/src/com/activeandroid/DatabaseHelper.java
@@ -16,18 +16,8 @@
  * limitations under the License.
  */
 
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
 import android.content.Context;
+import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
 import android.text.TextUtils;
@@ -38,6 +28,18 @@
 import com.activeandroid.util.SQLiteUtils;
 import com.activeandroid.util.SqlParser;
 
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
 public final class DatabaseHelper extends SQLiteOpenHelper {
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC CONSTANTS
@@ -46,10 +48,10 @@
 	public final static String MIGRATION_PATH = "migrations";
 
 	//////////////////////////////////////////////////////////////////////////////////////
-    // PRIVATE FIELDS
-    //////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE FIELDS
+	//////////////////////////////////////////////////////////////////////////////////////
 
-    private final String mSqlParser;
+	private Configuration configuration;
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
@@ -58,7 +60,7 @@
 	public DatabaseHelper(Configuration configuration) {
 		super(configuration.getContext(), configuration.getDatabaseName(), null, configuration.getDatabaseVersion());
 		copyAttachedDatabase(configuration.getContext(), configuration.getDatabaseName());
-		mSqlParser = configuration.getSqlParser();
+		this.configuration = configuration;
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -68,7 +70,7 @@ public DatabaseHelper(Configuration configuration) {
 	@Override
 	public void onOpen(SQLiteDatabase db) {
 		executePragmas(db);
-	};
+	}
 
 	@Override
 	public void onCreate(SQLiteDatabase db) {
@@ -83,13 +85,55 @@ public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 		executePragmas(db);
 		executeCreate(db);
 		executeMigrations(db, oldVersion, newVersion);
+		mergeAttachedDatabase(db, configuration.getContext(), configuration.getDatabaseName());
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
+	// PRIVATE METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	public void copyAttachedDatabase(Context context, String databaseName) {
+	private void mergeAttachedDatabase(SQLiteDatabase db, Context context, String databaseName) {
+		// backup with existing tables
+		final File dbPath = context.getDatabasePath(databaseName);
+		String backupDbPath = IOUtils.exportDatabase(dbPath.getAbsolutePath());
+		if (backupDbPath == null) {
+			// db backup failed
+			return;
+		}
+		// overwrite db file from assets
+		writeAssetDbFile(context, databaseName, dbPath);
+		try {
+			// get table list from backup db
+			List<String> tables = new ArrayList<String>();
+			Cursor cursor = db.rawQuery("select name from sqlite_master WHERE type='table'", null);
+			if (cursor.moveToFirst()) {
+				while (!cursor.isAfterLast()) {
+					String tableName = cursor.getString(cursor.getColumnIndex("name"));
+					tables.add(tableName);
+					cursor.moveToNext();
+				}
+			}
+			cursor.close();
+			if (db.inTransaction() ) {
+				db.endTransaction();
+			}
+			// attach backup db
+			db.execSQL("attach database '" + backupDbPath + "' as old");
+			// run insert or replace with transaction
+			db.beginTransaction();
+			for (String table : tables) {
+				String sql = "create table if not exists " + table + " as select * from old." + table;
+				db.execSQL(sql);
+			}
+			db.setTransactionSuccessful();
+		} catch (Exception e) {
+			Log.e("Failed to attach db", e);
+		} finally {
+			db.endTransaction();
+		}
+	}
+
+	private void copyAttachedDatabase(Context context, String databaseName) {
 		final File dbPath = context.getDatabasePath(databaseName);
 
 		// If the database already exists, return
@@ -100,18 +144,19 @@ public void copyAttachedDatabase(Context context, String databaseName) {
 		// Make sure we have a path to the file
 		dbPath.getParentFile().mkdirs();
 
+		writeAssetDbFile(context, databaseName, dbPath);
+	}
+
+	private void writeAssetDbFile(Context context, String databaseName, File dbPath) {
 		// Try to copy database file
 		try {
 			final InputStream inputStream = context.getAssets().open(databaseName);
 			final OutputStream output = new FileOutputStream(dbPath);
-
 			byte[] buffer = new byte[8192];
 			int length;
-
 			while ((length = inputStream.read(buffer, 0, 8192)) > 0) {
 				output.write(buffer, 0, length);
 			}
-
 			output.flush();
 			output.close();
 			inputStream.close();
@@ -121,10 +166,6 @@ public void copyAttachedDatabase(Context context, String databaseName) {
 		}
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	private void executePragmas(SQLiteDatabase db) {
 		if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
 			db.execSQL("PRAGMA foreign_keys=ON;");
@@ -137,7 +178,6 @@ private void executeCreateIndex(SQLiteDatabase db) {
 		try {
 			for (TableInfo tableInfo : Cache.getTableInfos()) {
 				String[] definitions = SQLiteUtils.createIndexDefinition(tableInfo);
-
 				for (String definition : definitions) {
 					db.execSQL(definition);
 				}
@@ -200,58 +240,58 @@ private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVers
 
 	private void executeSqlScript(SQLiteDatabase db, String file) {
 
-	    InputStream stream = null;
+		InputStream stream = null;
 
 		try {
-		    stream = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
+			stream = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
 
-		    if (Configuration.SQL_PARSER_DELIMITED.equalsIgnoreCase(mSqlParser)) {
-		        executeDelimitedSqlScript(db, stream);
+			if (Configuration.SQL_PARSER_DELIMITED.equalsIgnoreCase(configuration.getSqlParser())) {
+				executeDelimitedSqlScript(db, stream);
 
-		    } else {
-		        executeLegacySqlScript(db, stream);
+			} else {
+				executeLegacySqlScript(db, stream);
 
-		    }
+			}
 
 		} catch (IOException e) {
 			Log.e("Failed to execute " + file, e);
 
 		} finally {
-		    IOUtils.closeQuietly(stream);
+			IOUtils.closeQuietly(stream);
 
 		}
 	}
 
 	private void executeDelimitedSqlScript(SQLiteDatabase db, InputStream stream) throws IOException {
 
-	    List<String> commands = SqlParser.parse(stream);
+		List<String> commands = SqlParser.parse(stream);
 
-	    for(String command : commands) {
-	        db.execSQL(command);
-	    }
+		for(String command : commands) {
+			db.execSQL(command);
+		}
 	}
 
 	private void executeLegacySqlScript(SQLiteDatabase db, InputStream stream) throws IOException {
 
-	    InputStreamReader reader = null;
-        BufferedReader buffer = null;
-
-        try {
-            reader = new InputStreamReader(stream);
-            buffer = new BufferedReader(reader);
-            String line = null;
+		InputStreamReader reader = null;
+		BufferedReader buffer = null;
 
-            while ((line = buffer.readLine()) != null) {
-                line = line.replace(";", "").trim();
-                if (!TextUtils.isEmpty(line)) {
-                    db.execSQL(line);
-                }
-            }
+		try {
+			reader = new InputStreamReader(stream);
+			buffer = new BufferedReader(reader);
+			String line = null;
+
+			while ((line = buffer.readLine()) != null) {
+				line = line.replace(";", "").trim();
+				if (!TextUtils.isEmpty(line)) {
+					db.execSQL(line);
+				}
+			}
 
-        } finally {
-            IOUtils.closeQuietly(buffer);
-            IOUtils.closeQuietly(reader);
+		} finally {
+			IOUtils.closeQuietly(buffer);
+			IOUtils.closeQuietly(reader);
 
-        }
+		}
 	}
 }
diff --git a/src/com/activeandroid/util/IOUtils.java b/src/com/activeandroid/util/IOUtils.java
index b3005f85..654dba3b 100644
--- a/src/com/activeandroid/util/IOUtils.java
+++ b/src/com/activeandroid/util/IOUtils.java
@@ -20,9 +20,11 @@
 import android.database.Cursor;
 
 import java.io.Closeable;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.io.IOException;
-
-import com.activeandroid.util.Log;
+import java.io.InputStream;
+import java.io.OutputStream;
 
 
 public class IOUtils {
@@ -68,4 +70,24 @@ public static void closeQuietly(final Cursor cursor) {
             Log.e("Couldn't close cursor.", e);
         }
     }
+
+    public static String exportDatabase(String originPath) {
+        try {
+            String backupPath = originPath + ".backup";
+            final InputStream inputStream = new FileInputStream(originPath);
+            final OutputStream output = new FileOutputStream(backupPath);
+            byte[] buffer = new byte[8192];
+            int length;
+            while ((length = inputStream.read(buffer, 0, 8192)) > 0) {
+                output.write(buffer, 0, length);
+            }
+            output.flush();
+            output.close();
+            inputStream.close();
+            return backupPath;
+        } catch (IOException e) {
+            Log.e("Failed to open file", e);
+            return null;
+        }
+    }
 }
