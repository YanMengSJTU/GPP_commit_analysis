diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
index 6495e379..34de3465 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -17,13 +17,18 @@
  */
 
 import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
 
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.support.v4.util.LruCache;
 
+import com.activeandroid.internal.EmptyModelFiller;
+import com.activeandroid.internal.ModelFiller;
 import com.activeandroid.serializer.TypeSerializer;
 import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
 
 public final class Cache {
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -44,6 +49,8 @@
 	private static LruCache<String, Model> sEntities;
 
 	private static boolean sIsInitialized = false;
+	
+	private static Map<Class<? extends Model>, ModelFiller> sFillers;
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
@@ -71,6 +78,8 @@ public static synchronized void initialize(Configuration configuration) {
 		// required would be too costly to be of any benefit. We'll just set a max
 		// object size instead.
 		sEntities = new LruCache<String, Model>(configuration.getCacheSize());
+		
+		initializeModelFillers();
 
 		openDatabase();
 
@@ -79,6 +88,7 @@ public static synchronized void initialize(Configuration configuration) {
 		Log.v("ActiveAndroid initialized successfully.");
 	}
 
+	
 	public static synchronized void clear() {
 		sEntities.evictAll();
 		Log.v("Cache cleared.");
@@ -155,4 +165,42 @@ public static synchronized TypeSerializer getParserForType(Class<?> type) {
 	public static synchronized String getTableName(Class<? extends Model> type) {
 		return sModelInfo.getTableInfo(type).getTableName();
 	}
+	
+	static ModelFiller getFiller(Class<? extends Model> type) {
+		return sFillers.get(type);
+	}
+	
+	private static void initializeModelFillers() {
+		sFillers = new HashMap<Class<? extends Model>, ModelFiller>();
+		for (TableInfo tableInfo : sModelInfo.getTableInfos()) {
+			try {
+				Class<? extends Model> type = tableInfo.getType(); 
+				sFillers.put(type, instantiateFiller(type));
+			} catch (IllegalAccessException e) {
+				throw new RuntimeException(e);
+			} catch (InstantiationException e) {
+				throw new RuntimeException(e);
+			}
+		}
+		
+		
+	}
+	
+	@SuppressWarnings("unchecked")
+	private static ModelFiller instantiateFiller(Class<? extends Model> type) throws IllegalAccessException, InstantiationException {
+		ModelFiller modelFiller = sFillers.get(type);
+		if (modelFiller == null) {
+			String fillerClassName = type.getName() + ModelFiller.SUFFIX;
+			try {
+				Class<? extends ModelFiller> fillerType = (Class<? extends ModelFiller>) Class.forName(fillerClassName);
+				modelFiller = fillerType.newInstance();
+			} catch (ClassNotFoundException e) {
+				modelFiller = new EmptyModelFiller();
+			}
+			if (type.getSuperclass() != null && ReflectionUtils.isModel(type.getSuperclass())) {
+				modelFiller.superModelFiller = instantiateFiller((Class<? extends Model>) type.getSuperclass());
+			}
+		}
+		return modelFiller;
+	}
 }
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 421426ea..7fada238 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -21,6 +21,8 @@
 import android.database.sqlite.SQLiteDatabase;
 
 import com.activeandroid.content.ContentProvider;
+import com.activeandroid.internal.ModelFiller;
+import com.activeandroid.internal.ModelHelper;
 import com.activeandroid.query.Delete;
 import com.activeandroid.query.Select;
 import com.activeandroid.serializer.TypeSerializer;
@@ -74,7 +76,50 @@ public final void delete() {
 	public final Long save() {
 		final SQLiteDatabase db = Cache.openDatabase();
 		final ContentValues values = new ContentValues();
+		
+		ModelFiller filler = Cache.getFiller(mTableInfo.getType()); 
+		if (filler != null) {
+			filler.fillContentValues(this, values);
+		} else {
+			fillContentValuesReflective(values);			
+		}
+
+		if (mId == null) {
+			mId = db.insert(mTableInfo.getTableName(), null, values);
+		}
+		else {
+			db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
+		}
 
+		Cache.getContext().getContentResolver()
+				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+		return mId;
+	}
+
+	// Convenience methods
+
+	public static void delete(Class<? extends Model> type, long id) {
+		TableInfo tableInfo = Cache.getTableInfo(type);
+		new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
+	}
+
+	public static <T extends Model> T load(Class<T> type, long id) {
+		TableInfo tableInfo = Cache.getTableInfo(type);
+		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
+	}
+
+	// Model population
+
+	public final void loadFromCursor(Cursor cursor) {
+		ModelFiller filler = Cache.getFiller(mTableInfo.getType());
+		if (filler != null) {			
+			loadFromCursorWithFiller(cursor, filler);
+		} else {
+			loadFromCursorReflective(cursor);
+		}
+	}
+	
+	private void fillContentValuesReflective(final ContentValues values) {
 		for (Field field : mTableInfo.getFields()) {
 			final String fieldName = mTableInfo.getColumnName(field);
 			Class<?> fieldType = field.getType();
@@ -150,35 +195,21 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 				Log.e(e.getClass().getName(), e);
 			}
 		}
-
-		if (mId == null) {
-			mId = db.insert(mTableInfo.getTableName(), null, values);
-		}
-		else {
-			db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
-		}
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-		return mId;
-	}
-
-	// Convenience methods
-
-	public static void delete(Class<? extends Model> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
-	}
-
-	public static <T extends Model> T load(Class<T> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
 	}
 
-	// Model population
-
-	public final void loadFromCursor(Cursor cursor) {
-        /**
+	
+	private void loadFromCursorWithFiller(Cursor cursor, ModelFiller filler) {
+		Log.i("Using filler");
+		int columnIndex = cursor.getColumnIndex(idName);
+		if (cursor.isNull(columnIndex) == false)
+			mId = cursor.getLong(columnIndex);
+		else
+			mId = null;
+		filler.loadFromCursor(this, cursor);
+	}	
+	
+	private void loadFromCursorReflective(Cursor cursor) {
+		/**
          * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
          * when the cursor have multiple columns with same name obtained from join tables.
          */
@@ -203,58 +234,22 @@ public final void loadFromCursor(Cursor cursor) {
 					fieldType = typeSerializer.getSerializedType();
 				}
 
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
 				if (columnIsNull) {
 					field = null;
+				} else {
+					value = ModelHelper.getValueFromCursor(cursor, fieldType, columnIndex);
 				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					value = cursor.getLong(columnIndex);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					value = cursor.getFloat(columnIndex);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					value = cursor.getDouble(columnIndex);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					value = cursor.getInt(columnIndex) != 0;
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					value = cursor.getString(columnIndex).charAt(0);
-				}
-				else if (fieldType.equals(String.class)) {
-					value = cursor.getString(columnIndex);
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					value = cursor.getBlob(columnIndex);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					final long entityId = cursor.getLong(columnIndex);
-					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
-
-					Model entity = Cache.getEntity(entityType, entityId);
-					if (entity == null) {
-						entity = new Select().from(entityType).where(idName+"=?", entityId).executeSingle();
+				
+				if (value == null) {
+					if (ReflectionUtils.isModel(fieldType)) {
+						value = ModelHelper.getModel(cursor, fieldType, columnIndex);
+					} 
+					else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+						@SuppressWarnings("rawtypes")
+						final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+						value = Enum.valueOf(enumType, cursor.getString(columnIndex));
 					}
-
-					value = entity;
 				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					@SuppressWarnings("rawtypes")
-					final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-					value = Enum.valueOf(enumType, cursor.getString(columnIndex));
-				}
-
 				// Use a deserializer if one is available
 				if (typeSerializer != null && !columnIsNull) {
 					value = typeSerializer.deserialize(value);
@@ -280,7 +275,8 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 			Cache.addEntity(this);
 		}
 	}
-
+	
+	
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PROTECTED METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -288,6 +284,10 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
 		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
 	}
+	
+	protected String getIdName() {
+		return idName;
+	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// OVERRIDEN METHODS
@@ -317,4 +317,5 @@ public int hashCode() {
 		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
 		return hash; //To change body of generated methods, choose Tools | Templates.
 	}
+
 }
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/TableInfo.java
index 32d1ecb3..e55b63ea 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/src/com/activeandroid/TableInfo.java
@@ -25,10 +25,10 @@
 import java.util.Map;
 
 import android.text.TextUtils;
-import android.util.Log;
 
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.Table;
+import com.activeandroid.util.Log;
 import com.activeandroid.util.ReflectionUtils;
 
 public final class TableInfo {
@@ -77,7 +77,6 @@ public TableInfo(Class<? extends Model> type) {
                 mColumnNames.put(field, columnName);
             }
         }
-
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -103,8 +102,7 @@ public String getIdName() {
 	public String getColumnName(Field field) {
 		return mColumnNames.get(field);
 	}
-
-
+	
     private Field getIdField(Class<?> type) {
         if (type.equals(Model.class)) {
             try {
diff --git a/src/com/activeandroid/internal/AnnotationProcessor.java b/src/com/activeandroid/internal/AnnotationProcessor.java
new file mode 100644
index 00000000..b3fa2b8b
--- /dev/null
+++ b/src/com/activeandroid/internal/AnnotationProcessor.java
@@ -0,0 +1,312 @@
+package com.activeandroid.internal;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic.Kind;
+import javax.tools.JavaFileObject;
+
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+
+public final class AnnotationProcessor extends AbstractProcessor {
+
+	private static final String MODEL = "model";
+	private static final String CURSOR = "cursor";
+	private static final String CONTENT_VALUES = "contentValues";
+	private static final String COLUMNS_ORDERED = "columnsOrdered";
+
+	private RoundEnvironment env;
+
+	@Override
+	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
+		this.env = env;
+		if (annotations.size() > 0) {
+			parseColumns();
+		}
+		return true;
+	}
+
+	@Override
+	public Set<String> getSupportedAnnotationTypes() {
+		Set<String> supportedTypes = new HashSet<String>();
+		supportedTypes.add(Column.class.getCanonicalName());
+		return supportedTypes;
+	}
+
+	@Override
+	public SourceVersion getSupportedSourceVersion() {
+		return SourceVersion.latestSupported();
+	}
+
+	private void parseColumns() {
+		Set<? extends Element> columns = env.getElementsAnnotatedWith(Column.class);
+		Map<TypeElement, Set<VariableElement>> tables = new HashMap<TypeElement, Set<VariableElement>>();
+		for (Element element : columns) {
+			if (element instanceof VariableElement == false || element.getKind() != ElementKind.FIELD) {
+				error("@Column annotation should be applied only to local variables", element);
+				continue;
+			}
+			VariableElement columnElement = (VariableElement) element;
+
+			if (checkColumnModifiers(columnElement) == false)
+				continue;
+
+			TypeElement tableElement = null;
+			if (element.getEnclosingElement() instanceof TypeElement)
+				tableElement = (TypeElement) element.getEnclosingElement();
+			else
+				error("@Column annotation located not inside of class", element);
+
+			if (checkTableModifiers(tableElement) == false)
+				continue;
+
+			Set<VariableElement> columnsElements = tables.get(tableElement);
+			if (columnsElements == null) {
+				columnsElements = new HashSet<VariableElement>();
+				tables.put(tableElement, columnsElements);
+			}
+
+			columnsElements.add(columnElement);
+
+		}
+
+		for (TypeElement table : tables.keySet()) {
+			generate(table, tables.get(table));
+		}
+	}
+
+	private void generate(TypeElement tableElement, Set<VariableElement> columns) {
+		String packageName = processingEnv.getElementUtils().getPackageOf(tableElement).getQualifiedName().toString();
+		String className = tableElement.getQualifiedName().toString();
+		String fillerClassName = getClassName(tableElement, packageName) + ModelFiller.SUFFIX;
+
+		try {
+			JavaFileObject jfo = processingEnv.getFiler().createSourceFile(packageName + "." + fillerClassName, tableElement);
+			Writer writer = jfo.openWriter();
+			writer.write("//Generated by ActiveAndroid. Do not modify\n");
+			writer.write("package " + packageName + ";\n\n");
+			writer.write("import java.util.ArrayList;\n");
+			writer.write("import java.util.Arrays;\n");
+			writer.write("import java.util.List;\n\n");
+
+			writer.write("import com.activeandroid.internal.ModelHelper;\n");
+			writer.write("import com.activeandroid.internal.ModelFiller;\n");
+			writer.write("\n");
+			writer.write("public class " + fillerClassName + " extends ModelFiller {\n\n");
+			writer.write("  public void loadFromCursor(com.activeandroid.Model genericModel, android.database.Cursor " + CURSOR + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.loadFromCursor(genericModel, " + CURSOR + ");\n");
+			writer.write("    List<String> " + COLUMNS_ORDERED + " = new ArrayList<String>(Arrays.asList(" + CURSOR + ".getColumnNames()));\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getLoadFromCursorCode(columns));
+			writer.write("  }\n\n");
+
+			writer.write("  ");
+			writer.write("public void fillContentValues(com.activeandroid.Model genericModel, android.content.ContentValues " + CONTENT_VALUES + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.fillContentValues(genericModel, " + CONTENT_VALUES + ");\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getFillContentValuesCode(columns));
+			writer.write("  }\n");
+
+			writer.write("}");
+			writer.flush();
+			writer.close();
+		} catch (IOException exception) {
+			processingEnv.getMessager().printMessage(Kind.ERROR, exception.getMessage());
+		}
+	}
+
+	private String getLoadFromCursorCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+
+			TypeMirror typeMirror = column.asType();
+			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
+			String type = typeMirror.toString() + ".class";
+			String getColumnIndex = COLUMNS_ORDERED + ".indexOf(\"" + fieldName + "\")";
+
+			if (notPrimitiveType) {
+				stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
+				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = (" + typeMirror.toString() + ") ModelHelper.getSerializable(cursor, " + type + ", " + getColumnIndex + ");\n");
+				stringBuilder.append("    } else {\n");
+				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = ");
+			} else {
+				stringBuilder.append("    " + MODEL + "." + column.getSimpleName() + " = ");
+			}
+
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append(CURSOR + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append(CURSOR + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append(CURSOR + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append(CURSOR + ".getLong(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append(CURSOR + ".getFloat(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append(CURSOR + ".getDouble(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append(CURSOR + ".getInt(" + getColumnIndex + ") != 0;\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append(CURSOR + ".getString(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append(CURSOR + ".getString(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append(CURSOR + ".getBlob(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Model.class))
+				stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getModel(cursor, " + type + ", " + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Enum.class))
+				stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getEnum(cursor, " + type + ", " + getColumnIndex + ");\n");
+			else
+				stringBuilder.append(" null;\n");
+			if (notPrimitiveType) {
+				stringBuilder.append("    }\n");
+			}
+		}
+		return stringBuilder.toString();
+	}
+
+	private String getFillContentValuesCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+			
+			TypeMirror typeMirror = column.asType();
+			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
+			String type = typeMirror.toString() + ".class";
+			String getValue = MODEL + "." + column.getSimpleName();
+			
+			if (notPrimitiveType) {
+				stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
+				stringBuilder.append("      ModelHelper.setSerializable(" + CONTENT_VALUES + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
+				stringBuilder.append("    } else {\n");
+				stringBuilder.append("      " + CONTENT_VALUES + ".");
+			} else {
+				stringBuilder.append("    " + CONTENT_VALUES + ".");
+			}
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Model.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".getId());\n");
+			else if (isTypeOf(typeMirror, Enum.class))
+				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".name());\n");
+			else
+				stringBuilder.append("putNull(\"" + fieldName + "\");\n");
+			if (notPrimitiveType) {
+				stringBuilder.append("    }\n");
+			}
+			
+		}
+		return stringBuilder.toString();
+	}
+
+	private boolean isTypeOf(TypeMirror typeMirror, Class<?> type) {
+		if (type.getName().equals(typeMirror.toString()))
+			return true;
+
+		if (typeMirror instanceof DeclaredType == false)
+			return false;
+
+		DeclaredType declaredType = (DeclaredType) typeMirror;
+		Element element = declaredType.asElement();
+		if (element instanceof TypeElement == false)
+			return false;
+
+		TypeElement typeElement = (TypeElement) element;
+		TypeMirror superType = typeElement.getSuperclass();
+		if (isTypeOf(superType, type))
+			return true;
+		return false;
+	}
+
+	private boolean checkTableModifiers(TypeElement table) {
+		if (table.getModifiers().contains(Modifier.PRIVATE)) {
+			error("Classes marked with @Table cannot be private", table);
+			return false;
+		}
+
+		if (table.getKind() != ElementKind.CLASS) {
+			error("Only classes can be marked with @Table annotation", table);
+			return false;
+		}
+
+		return true;
+	}
+
+	private boolean checkColumnModifiers(VariableElement column) {
+
+		if (column.getModifiers().contains(Modifier.PRIVATE)) {
+			error("Field marked with @Column cannot be private", column);
+			return false;
+		}
+
+		if (column.getModifiers().contains(Modifier.FINAL)) {
+			error("Field marked with @Column cannot be final", column);
+			return false;
+		}
+
+		if (column.getModifiers().contains(Modifier.STATIC)) {
+			error("Field marked with @Column cannot be static", column);
+			return false;
+		}
+
+		return true;
+	}
+
+	private void error(String message, Element element) {
+		processingEnv.getMessager().printMessage(Kind.ERROR, message, element);
+	}
+
+	private static String getClassName(TypeElement type, String packageName) {
+		int packageLen = packageName.length() + 1;
+		return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
+	}
+}
diff --git a/src/com/activeandroid/internal/EmptyModelFiller.java b/src/com/activeandroid/internal/EmptyModelFiller.java
new file mode 100644
index 00000000..98f65309
--- /dev/null
+++ b/src/com/activeandroid/internal/EmptyModelFiller.java
@@ -0,0 +1,22 @@
+package com.activeandroid.internal;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+
+import com.activeandroid.Model;
+
+public class EmptyModelFiller extends ModelFiller {
+
+	@Override
+	public void loadFromCursor(Model model, Cursor cursor) {
+		if (superModelFiller != null)
+			superModelFiller.loadFromCursor(model, cursor);
+	}
+
+	@Override
+	public void fillContentValues(Model model, ContentValues contentValues) {
+		if (superModelFiller != null)
+			superModelFiller.fillContentValues(model, contentValues);
+	}
+
+}
diff --git a/src/com/activeandroid/internal/ModelFiller.java b/src/com/activeandroid/internal/ModelFiller.java
new file mode 100644
index 00000000..67a80eb2
--- /dev/null
+++ b/src/com/activeandroid/internal/ModelFiller.java
@@ -0,0 +1,15 @@
+package com.activeandroid.internal;
+
+import com.activeandroid.Model;
+
+import android.database.Cursor;
+import android.content.ContentValues;
+
+
+public abstract class ModelFiller {
+	public static final String SUFFIX = "$$ActiveAndroidModelFiller";
+	public ModelFiller superModelFiller;
+	
+	public abstract void loadFromCursor(Model model, Cursor cursor);
+	public abstract void fillContentValues(Model model, ContentValues contentValues);
+}
diff --git a/src/com/activeandroid/internal/ModelHelper.java b/src/com/activeandroid/internal/ModelHelper.java
new file mode 100644
index 00000000..7b9e3f98
--- /dev/null
+++ b/src/com/activeandroid/internal/ModelHelper.java
@@ -0,0 +1,146 @@
+package com.activeandroid.internal;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.query.Select;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
+
+public class ModelHelper {
+	
+	public static boolean isSerializable(Class<?> fieldType) {
+		return Cache.getParserForType(fieldType) != null;
+	}
+	
+	public static Object getSerializable(Cursor cursor, Class<?> fieldType, int columnIndex) {
+		TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+		if (typeSerializer == null)
+			return null;
+		
+		if (cursor.isNull(columnIndex))
+			return null;
+		
+		fieldType = typeSerializer.getSerializedType();
+		Object value = getValueFromCursor(cursor, fieldType, columnIndex);
+		if (value != null) {
+			value = typeSerializer.deserialize(value);
+		}
+		return value;
+	}
+	
+	public static void setSerializable(ContentValues values, Class<?> fieldType, Object value, String fieldName) {
+		TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+		if (typeSerializer == null)
+			return;
+		value = typeSerializer.serialize(value);
+		if (value != null) {
+			fieldType = value.getClass();
+			// check that the serializer returned what it promised
+			if (!fieldType.equals(typeSerializer.getSerializedType())) {
+				Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+						typeSerializer.getSerializedType(), fieldType));
+			}
+		}
+		// TODO: Find a smarter way to do this? This if block is necessary because we
+		// can't know the type until runtime.
+		if (value == null) {
+			values.putNull(fieldName);
+		} else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+			values.put(fieldName, (Byte) value);
+		}
+		else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+			values.put(fieldName, (Short) value);
+		}
+		else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+			values.put(fieldName, (Integer) value);
+		}
+		else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+			values.put(fieldName, (Long) value);
+		}
+		else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+			values.put(fieldName, (Float) value);
+		}
+		else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+			values.put(fieldName, (Double) value);
+		}
+		else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+			values.put(fieldName, (Boolean) value);
+		}
+		else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+			values.put(fieldName, value.toString());
+		}
+		else if (fieldType.equals(String.class)) {
+			values.put(fieldName, value.toString());
+		}
+		else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+			values.put(fieldName, (byte[]) value);
+		}
+		else if (ReflectionUtils.isModel(fieldType)) {
+			values.put(fieldName, ((Model) value).getId());
+		}
+		else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+			values.put(fieldName, ((Enum<?>) value).name());
+		}
+	}
+	
+	@SuppressWarnings("unchecked")
+	public static Object getModel(Cursor cursor, Class<?> fieldType, int columnIndex) {
+		final long entityId = cursor.getLong(columnIndex);
+		final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
+
+		Model entity = Cache.getEntity(entityType, entityId);
+		if (entity == null) {
+			entity = new Select().from(entityType).where(Cache.getTableInfo(entityType).getIdName() + "=?", entityId).executeSingle();
+		}
+		return entity;
+	}
+	
+	@SuppressWarnings("unchecked")
+	public static Object getEnum(Cursor cursor, Class<?> fieldType, int columnIndex) {
+		@SuppressWarnings("rawtypes")
+		final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+		return Enum.valueOf(enumType, cursor.getString(columnIndex));
+	}
+	
+	public static Object getValueFromCursor(Cursor cursor, Class<?> fieldType, int columnIndex) {
+		// TODO: Find a smarter way to do this? This if block is necessary because we
+		// can't know the type until runtime.
+		Object value = null;
+		if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+			value = cursor.getInt(columnIndex);
+		}
+		else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+			value = cursor.getInt(columnIndex);
+		}
+		else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+			value = cursor.getInt(columnIndex);
+		}
+		else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+			value = cursor.getLong(columnIndex);
+		}
+		else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+			value = cursor.getFloat(columnIndex);
+		}
+		else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+			value = cursor.getDouble(columnIndex);
+		}
+		else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+			value = cursor.getInt(columnIndex) != 0;
+		}
+		else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+			value = cursor.getString(columnIndex).charAt(0);
+		}
+		else if (fieldType.equals(String.class)) {
+			value = cursor.getString(columnIndex);
+		}
+		else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+			value = cursor.getBlob(columnIndex);
+		}
+		return value;
+	}
+
+}
diff --git a/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
new file mode 100644
index 00000000..9a72e581
--- /dev/null
+++ b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -0,0 +1 @@
+com.activeandroid.internal.AnnotationProcessor
\ No newline at end of file
diff --git a/tests/.gitignore b/tests/.gitignore
index 6d0dc1c1..16883b17 100644
--- a/tests/.gitignore
+++ b/tests/.gitignore
@@ -32,3 +32,4 @@ proguard-project.txt
 #Other
 .DS_Store
 tmp
+/.apt_generated
diff --git a/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java b/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
index 3b5fab1f..5b31a2cb 100644
--- a/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
+++ b/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
@@ -30,10 +30,6 @@ protected void setUp() throws Exception {
 		createApplication();
 	}
 
-	protected void tearDown() throws Exception {
-		super.tearDown();
-	}
-
 	public static <T> void assertArrayEquals(T[] actual, T... expected) {
 		assertEquals(expected.length, actual.length);
 		
diff --git a/tests/src/com/activeandroid/test/CacheTest.java b/tests/src/com/activeandroid/test/CacheTest.java
index c8ca401a..1689585a 100644
--- a/tests/src/com/activeandroid/test/CacheTest.java
+++ b/tests/src/com/activeandroid/test/CacheTest.java
@@ -41,10 +41,10 @@ public void testGetTableInfos() {
     }
 
     @Table(name = "CacheTestModel")
-    private static class CacheTestModel extends Model {
+    static class CacheTestModel extends Model {
     }
 
     @Table(name = "CacheTestModel2")
-    private static class CacheTestModel2 extends Model {
+    static class CacheTestModel2 extends Model {
     }
 }
diff --git a/tests/src/com/activeandroid/test/ConfigurationTest.java b/tests/src/com/activeandroid/test/ConfigurationTest.java
index 12ca4a72..18684fd4 100644
--- a/tests/src/com/activeandroid/test/ConfigurationTest.java
+++ b/tests/src/com/activeandroid/test/ConfigurationTest.java
@@ -33,6 +33,6 @@ public void testCreateConfigurationWithMockModel() {
     }
 
     @Table(name = "ConfigurationTestModel")
-    private static class ConfigurationTestModel extends Model {
+    static class ConfigurationTestModel extends Model {
     }
 }
diff --git a/tests/src/com/activeandroid/test/ModelTest.java b/tests/src/com/activeandroid/test/ModelTest.java
index e66690d8..4205ba30 100644
--- a/tests/src/com/activeandroid/test/ModelTest.java
+++ b/tests/src/com/activeandroid/test/ModelTest.java
@@ -37,7 +37,7 @@
 
 	/**
 	 * Equals should be type-safe.
-	 */	
+	 */
 	public void testEqualsNonModel() {
 		MockModel model = new MockModel();
 
@@ -45,9 +45,15 @@ public void testEqualsNonModel() {
 		assertFalse(model.equals(null));
 	}
 
+	@Override
+	protected void tearDown() throws Exception {
+		super.tearDown();
+		getContext().deleteDatabase("Application.db");
+	}
+
 	/**
 	 * Equals should not be true for different model classes.
-	 */	
+	 */
 	public void testEqualsDifferentModel() {
 		Model model1 = new MockModel();
 		Model model2 = new AnotherMockModel();
@@ -56,21 +62,21 @@ public void testEqualsDifferentModel() {
 	}
 
 	/**
-	 * A new object does not have PK assigned yet,
-	 * therefore by default it is equal only to itself.
-	 */	
+	 * A new object does not have PK assigned yet, therefore by default it is
+	 * equal only to itself.
+	 */
 	public void testEqualsOnNew() {
 		MockModel model1 = new MockModel();
 		MockModel model2 = new MockModel();
 
 		assertFalse(model1.equals(model2));
 		assertFalse(model2.equals(model1));
-		assertTrue(model1.equals(model1));  //equal only to itself
+		assertTrue(model1.equals(model1)); // equal only to itself
 	}
 
 	/**
 	 * Two different rows in a table should not be equal (different ids).
-	 */	
+	 */
 	public void testEqualsDifferentRows() {
 		MockModel model1 = new MockModel();
 		MockModel model2 = new MockModel();
@@ -80,32 +86,33 @@ public void testEqualsDifferentRows() {
 		model2.save();
 		model3 = Model.load(MockModel.class, model1.getId());
 
-        // Not equal to each other.
+		// Not equal to each other.
 		assertFalse(model1.equals(model2));
 		assertFalse(model2.equals(model1));
 
-        // Equal to each other when loaded.
+		// Equal to each other when loaded.
 		assertTrue(model1.equals(model3));
 		assertTrue(model1.equals(model3));
 
-        // Loaded model is not equal to a different model.
+		// Loaded model is not equal to a different model.
 		assertFalse(model3.equals(model2));
 		assertFalse(model2.equals(model3));
 	}
 
 	/**
 	 * Tests hashcode for new instances.
-	 */	
+	 */
 	public void testHashCode() {
 		Set<Model> set = new HashSet<Model>();
 		Model m1 = new MockModel();
 		Model m2 = new MockModel();
 		Model m3 = new AnotherMockModel();
 
-		assertFalse(m1.hashCode() == m2.hashCode()); // hashes for unsaved models must not match
+		assertFalse(m1.hashCode() == m2.hashCode()); // hashes for unsaved
+														// models must not match
 		set.add(m1);
 		set.add(m2);
-		assertEquals(2, set.size()); //try in a set
+		assertEquals(2, set.size()); // try in a set
 
 		assertFalse(m1.hashCode() == m3.hashCode());
 		set.add(m3);
@@ -133,135 +140,132 @@ public void testHashCodeDifferentRows() {
 		assertEquals(2, set.size());
 	}
 
-    /**
-     * Column names should default to the field name.
-     */
-    public void testColumnNamesDefaulToFieldNames() {
-        TableInfo tableInfo = Cache.getTableInfo(MockModel.class);
+	/**
+	 * Column names should default to the field name.
+	 */
+	public void testColumnNamesDefaulToFieldNames() {
+		TableInfo tableInfo = Cache.getTableInfo(MockModel.class);
 
-        for ( Field field : tableInfo.getFields() ) {
-            // Id column is a special case, we'll ignore that one.
-            if ( field.getName().equals("mId") ) continue;
+		for (Field field : tableInfo.getFields()) {
+			// Id column is a special case, we'll ignore that one.
+			if (field.getName().equals("mId"))
+				continue;
 
-            assertEquals(field.getName(), tableInfo.getColumnName(field));
-        }
-    }
+			assertEquals(field.getName(), tableInfo.getColumnName(field));
+		}
+	}
 
-    /**
-     * Boolean should handle integer (0/1) and boolean (false/true) values.
-     */
-    public void testBooleanColumnType() {
-        MockModel mockModel = new MockModel();
-        mockModel.booleanField = false;
-        Long id = mockModel.save();
+	/**
+	 * Boolean should handle integer (0/1) and boolean (false/true) values.
+	 */
+	public void testBooleanColumnType() {
+		MockModel mockModel = new MockModel();
+		mockModel.booleanField = false;
+		Long id = mockModel.save();
 
-        boolean databaseBooleanValue = MockModel.load( MockModel.class, id ).booleanField;
+		boolean databaseBooleanValue = MockModel.load(MockModel.class, id).booleanField;
 
-        assertEquals( false, databaseBooleanValue );
+		assertEquals(false, databaseBooleanValue);
 
-        // Test passing both a integer and a boolean into the where conditional.
-        assertEquals(
-                mockModel,
-                new Select().from(MockModel.class).where("booleanField = ?", 0).executeSingle() );
+		// Test passing both a integer and a boolean into the where conditional.
+		assertEquals(mockModel, new Select().from(MockModel.class).where("booleanField = ?", 0).executeSingle());
 
-        assertEquals(
-                mockModel,
-                new Select().from(MockModel.class).where("booleanField = ?", false).executeSingle() );
+		assertEquals(mockModel, new Select().from(MockModel.class).where("booleanField = ?", false).executeSingle());
 
-        assertNull( new Select().from(MockModel.class).where("booleanField = ?", 1).executeSingle() );
+		assertNull(new Select().from(MockModel.class).where("booleanField = ?", 1).executeSingle());
 
-        assertNull( new Select().from(MockModel.class).where("booleanField = ?", true).executeSingle() );
-    }
+		assertNull(new Select().from(MockModel.class).where("booleanField = ?", true).executeSingle());
+	}
 
 	/**
-     * Test to check the join of two (or more) tables with some fields in common when not use a projection on select.
-     * Test the issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-     */
-    public void testJoinWithSameNames(){
-        //create a parent entity and store
-        ParentJoinMockModel parent = new ParentJoinMockModel();
-        parent.booleanField = true;
-        parent.dateField = new Date();
-        parent.doubleField = 2.0;
-        parent.intField = 1;
-        parent.save();
-
-        //the values to assign to child
-        Date dateValue = new Date();
-        double doubleValue = 30.0;
-        int intValue = 3;
-
-        //create two child entities, relate with parent and save
-        ChildMockModel child1 = new ChildMockModel();
-        child1.booleanField = false;
-        child1.dateField = dateValue;
-        child1.doubleField = doubleValue;
-        child1.intField = intValue;
-        child1.parent = parent;
-        child1.save();
-
-        ChildMockModel child2 = new ChildMockModel();
-        child2.booleanField = false;
-        child2.dateField = dateValue;
-        child2.doubleField = doubleValue;
-        child2.intField = intValue;
-        child2.parent = parent;
-        child2.save();
-
-        //Store the ids assigned to child entities when persists
-        List<Long> ids = new ArrayList<Long>();
-        ids.add(child1.getId());
-        ids.add(child2.getId());
-
-        //make the query with a join
-        List<ChildMockModel> result = new Select().from(ChildMockModel.class).
-                join(ParentJoinMockModel.class).on("ParentJoinMockModel.Id = ChildMockModel.parent").execute();
-
-        //check result
-        assertNotNull(result);
-        assertEquals(result.size(), 2);
-        for(ChildMockModel currentModel : result){
-            assertFalse(currentModel.booleanField);
-            assertEquals(currentModel.intField, intValue);
-            assertEquals(currentModel.doubleField, doubleValue);
-            assertTrue(ids.contains(currentModel.getId()));
-        }
-
-    }
+	 * Test to check the join of two (or more) tables with some fields in common
+	 * when not use a projection on select. Test the issue #106
+	 * (https://github.com/pardom/ActiveAndroid/issues/106)
+	 */
+	public void testJoinWithSameNames() {
+		// create a parent entity and store
+		ParentJoinMockModel parent = new ParentJoinMockModel();
+		parent.booleanField = true;
+		parent.dateField = new Date();
+		parent.doubleField = 2.0;
+		parent.intField = 1;
+		parent.save();
+
+		// the values to assign to child
+		Date dateValue = new Date();
+		double doubleValue = 30.0;
+		int intValue = 3;
+
+		// create two child entities, relate with parent and save
+		ChildMockModel child1 = new ChildMockModel();
+		child1.booleanField = false;
+		child1.dateField = dateValue;
+		child1.doubleField = doubleValue;
+		child1.intField = intValue;
+		child1.parent = parent;
+		child1.save();
+
+		ChildMockModel child2 = new ChildMockModel();
+		child2.booleanField = false;
+		child2.dateField = dateValue;
+		child2.doubleField = doubleValue;
+		child2.intField = intValue;
+		child2.parent = parent;
+		child2.save();
+
+		// Store the ids assigned to child entities when persists
+		List<Long> ids = new ArrayList<Long>();
+		ids.add(child1.getId());
+		ids.add(child2.getId());
+
+		// make the query with a join
+		List<ChildMockModel> result = new Select().from(ChildMockModel.class).join(ParentJoinMockModel.class).on("ParentJoinMockModel.Id = ChildMockModel.parent").execute();
+
+		// check result
+		assertNotNull(result);
+		assertEquals(2, result.size());
+		for (ChildMockModel currentModel : result) {
+			assertFalse(currentModel.booleanField);
+			assertEquals(currentModel.intField, intValue);
+			assertEquals(currentModel.doubleField, doubleValue);
+			assertTrue(ids.contains(currentModel.getId()));
+		}
+
+	}
 
 	/**
 	 * Mock model as we need 2 different model classes.
 	 */
 	@Table(name = "AnotherMockTable")
-	public static class AnotherMockModel extends Model {}
-
-    /**
-     * Mock model to test joins with same names.
-     * It's a copy from MockModel.
-     */
-    @Table(name = "ParentJoinMockModel")
-    public static class ParentJoinMockModel extends Model {
-        @Column
-        public Date dateField;
-
-        @Column
-        public double doubleField;
-
-        @Column
-        public int intField;
-
-        @Column
-        public boolean booleanField;
-    }
-
-    /**
-     * Mock model to test joins with same names.
-     * Extends from ParentJoinMockModel to have the same columns.
-     * Have a relationship with ParentJoinMockModel to make te join query.
-     */
-    @Table(name = "ChildMockModel")
-    public static class ChildMockModel extends ParentJoinMockModel {
-        @Column
-        ParentJoinMockModel parent;
-    }
+	public static class AnotherMockModel extends Model {
+	}
+
+	/**
+	 * Mock model to test joins with same names. It's a copy from MockModel.
+	 */
+	@Table(name = "ParentJoinMockModel")
+	public static class ParentJoinMockModel extends Model {
+		@Column
+		public Date dateField;
+
+		@Column
+		public double doubleField;
+
+		@Column
+		public int intField;
+
+		@Column
+		public boolean booleanField;
+	}
+
+	/**
+	 * Mock model to test joins with same names. Extends from
+	 * ParentJoinMockModel to have the same columns. Have a relationship with
+	 * ParentJoinMockModel to make te join query.
+	 */
+	@Table(name = "ChildMockModel")
+	public static class ChildMockModel extends ParentJoinMockModel {
+		@Column
+		ParentJoinMockModel parent;
+	}
 }
diff --git a/tests/src/com/activeandroid/test/query/FromTest.java b/tests/src/com/activeandroid/test/query/FromTest.java
index 8e500b0d..1305dd2b 100644
--- a/tests/src/com/activeandroid/test/query/FromTest.java
+++ b/tests/src/com/activeandroid/test/query/FromTest.java
@@ -228,10 +228,10 @@ private From from() {
 	}
 	
 	@Table(name = "JoinModel")
-	private static class JoinModel extends Model {
+	static class JoinModel extends Model {
 	}
 	
 	@Table(name = "JoinModel2")
-	private static class JoinModel2 extends Model {
+	static class JoinModel2 extends Model {
 	}
 }
