diff --git a/src/main/java/com/activeandroid/manager/DBManager.java b/src/main/java/com/activeandroid/manager/DBManager.java
index 54b47c55..39fb8e17 100644
--- a/src/main/java/com/activeandroid/manager/DBManager.java
+++ b/src/main/java/com/activeandroid/manager/DBManager.java
@@ -3,8 +3,6 @@
 import com.activeandroid.IModel;
 import com.activeandroid.interfaces.CollectionReceiver;
 import com.activeandroid.interfaces.ObjectReceiver;
-import com.activeandroid.runtime.DBRequest;
-import com.activeandroid.runtime.DBRequestInfo;
 
 import java.util.List;
 
@@ -17,7 +15,7 @@
  *
  * @param <OBJECT_CLASS> - the class of objects that represent a Model from the DB
  */
-public abstract class DBManager<OBJECT_CLASS extends IModel> extends SingleDBManager{
+public abstract class DBManager<OBJECT_CLASS extends IModel> extends SingleDBManager {
 
     protected Class<OBJECT_CLASS> mObjectClass;
 
@@ -26,6 +24,7 @@
      * Constructs a new instance while keeping an instance of the class for its objects.
      * <br>
      * Shares the same queue with the {@link com.activeandroid.manager.SingleDBManager}
+     *
      * @param mObjectClass
      */
     public DBManager(Class<OBJECT_CLASS> mObjectClass) {
@@ -35,52 +34,57 @@ public DBManager(Class<OBJECT_CLASS> mObjectClass) {
 
     /**
      * Constructs a new instance while keeping an instance of the class for its objects
+     *
      * @param classClass
      * @param hasOwnQueue - set this flag to true to create its own request queue
      *                    (useful for many DB operations, however each may use up a chunk  of memory)
      */
-    public DBManager(Class<OBJECT_CLASS> classClass, boolean hasOwnQueue){
+    public DBManager(Class<OBJECT_CLASS> classClass, boolean hasOwnQueue) {
         super(classClass.getSimpleName(), hasOwnQueue);
         mObjectClass = classClass;
     }
 
     /**
      * Override this method to have one instance of the manager accross the app
+     *
      * @return
      */
-    public static DBManager getSharedInstance(){
+    public static DBManager getSharedInstance() {
         throw new IllegalStateException("Cannot call the base implementation of this method");
     }
 
     /**
      * Adds a object to this class, however its advised you ensure that the object being passed is what you want, since there's no type checking
+     *
      * @param object
      */
-    public OBJECT_CLASS add(Object object){
+    public OBJECT_CLASS add(Object object) {
         return add(mObjectClass, object);
     }
 
     /**
      * Adds an object to the DB in the BG
+     *
      * @param jsonObject
      */
-    public void addInBackground(final Object jsonObject){
+    public void addInBackground(final Object jsonObject) {
         addInBackground(mObjectClass, jsonObject);
     }
 
-    public void addInBackground(final Object object, final ObjectReceiver<OBJECT_CLASS> objectReceiver){
+    public void addInBackground(final Object object, final ObjectReceiver<OBJECT_CLASS> objectReceiver) {
         addInBackground(mObjectClass, object, objectReceiver);
     }
 
     /**
      * Adds all objects from the passed array, may NOT be type-safe so be careful with this
+     *
      * @param array
      */
-    public void addAll(Object array){
+    public void addAll(Object array) {
         addAll(mObjectClass, array);
     }
 
-    public void addAllInBackground(final Object array){
+    public void addAllInBackground(final Object array) {
         addAllInBackground(mObjectClass, array);
     }
 
@@ -91,98 +95,120 @@ public void addAllInBackground(final Object array, final CollectionReceiver<OBJE
     /**
      * Retrieves a list of objects from the database without any threading
      * Its recommended not to call this method in the foreground thread
+     *
      * @return
      */
-    public List<OBJECT_CLASS> getAll(){
+    public List<OBJECT_CLASS> getAll() {
         return getAll(mObjectClass);
     }
 
-    public OBJECT_CLASS getObject(Object object){
+    public OBJECT_CLASS getObject(Object object) {
         return DBManagerCache.constructNewInstance(object, mObjectClass);
     }
 
     /**
      * Retrieves a list of objects from the database without any threading with the sort passed
      * Its recommended not to call this method in the foreground thread
+     *
      * @param sort - valid SQLLite syntax for sort e.g. name ASC
      * @return
      */
-    public List<OBJECT_CLASS> getAllWithSort(String sort){
+    public List<OBJECT_CLASS> getAllWithSort(String sort) {
         return getAllWithSort(mObjectClass, sort);
     }
 
     /**
      * Fetches objects from this DB on the BG
+     *
      * @param receiver - function to call when finished that passes the list of objects that was found
      */
-    public void fetchAll(final CollectionReceiver<OBJECT_CLASS> receiver){
+    public void fetchAll(final CollectionReceiver<OBJECT_CLASS> receiver) {
         fetchAll(mObjectClass, receiver);
     }
 
     /**
      * Fetches objects from this DB on the BG calling orderBy with the sort passed.
-     * @param sort - valid SQLLite syntax for sort e.g. name ASC
+     *
+     * @param sort     - valid SQLLite syntax for sort e.g. name ASC
      * @param receiver - function to call when finished that passes the list of objects that was found
      */
-    public void fetchAllWithSort(final String sort, final CollectionReceiver<OBJECT_CLASS> receiver){
+    public void fetchAllWithSort(final String sort, final CollectionReceiver<OBJECT_CLASS> receiver) {
         fetchAllWithSort(mObjectClass, sort, receiver);
-    };
+    }
+
+    ;
 
-    public void fetchAllWithColumnValue(final Object value, final String column, final CollectionReceiver<OBJECT_CLASS> receiver){
+    public void fetchAllWithColumnValue(final Object value, final String column, final CollectionReceiver<OBJECT_CLASS> receiver) {
         fetchAllWithColumnValue(mObjectClass, value, column, receiver);
     }
 
     /**
      * This will get the where statement for this object, the amount of ids passed must match the primary key column size
+     *
      * @return
      */
-    public OBJECT_CLASS getObjectById(Object...ids){
+    public OBJECT_CLASS getObjectById(Object... ids) {
         return getObjectById(mObjectClass, ids);
     }
 
+    /**
+     * If you have multiple primary keys, provide the column names of the primary keys and the values
+     * @param columnNames
+     * @param ids
+     * @return
+     */
+    public OBJECT_CLASS getObjectById(String[] columnNames, Object[] values) {
+        return getObjectById(mObjectClass, columnNames, values);
+    }
+
     /**
      * Returns a single object with the specified column name.
      * Useful for getting objects with a specific primary key
+     *
      * @param column
      * @param uid
      * @return
      */
-    public OBJECT_CLASS getObjectByColumnValue(String column, Object uid){
+    public OBJECT_CLASS getObjectByColumnValue(String column, Object uid) {
         return getObjectByColumnValue(mObjectClass, column, uid);
     }
 
     /**
      * Gets all in a table by a group by
+     *
      * @param groupBy
      * @return
      */
-    public List<OBJECT_CLASS> getAllWithGroupby(String groupBy){
+    public List<OBJECT_CLASS> getAllWithGroupby(String groupBy) {
         return getAllWithGroupby(mObjectClass, groupBy);
     }
 
     /**
      * Returns all objects with the specified column name
+     *
      * @param column
      * @param value
      * @return
      */
-    public List<OBJECT_CLASS> getAllWithColumnValue(String column, Object value){
+    public List<OBJECT_CLASS> getAllWithColumnValue(String column, Object value) {
         return getAllWithColumnValue(mObjectClass, column, value);
     }
 
     /**
      * Returns the count of rows from this DB manager's DB
+     *
      * @return
      */
-    public long getCount(){
+    public long getCount() {
         return getCount(mObjectClass);
     }
 
     /**
      * Fetches the count on the DB thread and returns it on the handler
+     *
      * @param objectReceiver
      */
-    public void fetchCount(final ObjectReceiver<Long> objectReceiver){
+    public void fetchCount(final ObjectReceiver<Long> objectReceiver) {
         fetchCount(mObjectClass, objectReceiver);
     }
 
@@ -193,9 +219,9 @@ public void fetchCount(final ObjectReceiver<Long> objectReceiver){
      * @param uid
      * @return true if the object exists in the DB, otherwise its on a BG thread
      */
-    public boolean fetchObject(final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
+    public boolean fetchObject(final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid) {
         OBJECT_CLASS object = getObjectById(uid);
-        if(object==null){
+        if (object == null) {
             processOnForeground(new Runnable() {
                 @Override
                 public void run() {
@@ -203,7 +229,7 @@ public void run() {
                 }
             });
             return false;
-        } else{
+        } else {
             objectReceiver.onObjectReceived(object);
             return true;
         }
@@ -211,6 +237,7 @@ public void run() {
 
     /**
      * Implement this method to perform a request if the object does not exist in the DB
+     *
      * @param objectReceiver
      * @param uid
      */
diff --git a/src/main/java/com/activeandroid/manager/SingleDBManager.java b/src/main/java/com/activeandroid/manager/SingleDBManager.java
index 5a9e9abb..c35aa9f4 100644
--- a/src/main/java/com/activeandroid/manager/SingleDBManager.java
+++ b/src/main/java/com/activeandroid/manager/SingleDBManager.java
@@ -17,6 +17,7 @@
 import com.activeandroid.runtime.DBRequest;
 import com.activeandroid.runtime.DBRequestInfo;
 import com.activeandroid.runtime.DBRequestQueue;
+import com.activeandroid.util.AALog;
 import com.activeandroid.util.SQLiteUtils;
 
 import java.util.ArrayList;
@@ -347,6 +348,23 @@ public void run() {
         return new Select().from(obClazz).where(SQLiteUtils.getWhereStatement(obClazz, Cache.getTableInfo(obClazz)), ids).executeSingle();
     }
 
+    /**
+     * Provide the column names and the values to get the objects
+     * @param obClazz
+     * @param columnNames
+     * @param values
+     * @param <OBJECT_CLASS>
+     * @return
+     */
+    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObjectById(final Class<OBJECT_CLASS> obClazz, String[] columnNames, Object[] values) {
+        if(columnNames.length != values.length) {
+            if(AALog.isEnabled()) {
+                throw new RuntimeException("Number of ColumnNames cannot be different from the number of ids passed!");
+            }
+        }
+        return new Select().from(obClazz).where(SQLiteUtils.getWhereStatement(obClazz, Cache.getTableInfo(obClazz), columnNames), values).executeSingle();
+    }
+
     /**
      * Returns a single object with the specified column name.
      * Useful for getting objects with a specific primary key
diff --git a/src/main/java/com/activeandroid/util/SQLiteUtils.java b/src/main/java/com/activeandroid/util/SQLiteUtils.java
index 250c2516..58dc1918 100644
--- a/src/main/java/com/activeandroid/util/SQLiteUtils.java
+++ b/src/main/java/com/activeandroid/util/SQLiteUtils.java
@@ -289,6 +289,39 @@ public static String getWhereStatement(Class<? extends IModel> modelClass, Table
         return sql;
     }
 
+    public static String getWhereStatement(Class<? extends IModel> modelClass, TableInfo tableInfo, String... primaryKeyColumnNames) {
+        List<Field> fields = new ArrayList<Field>();
+        List<String> primaryColumns = new ArrayList<String>();
+        fields = ReflectionUtils.getAllFields(fields, modelClass);
+
+        for(Field field : fields){
+            if(field.isAnnotationPresent(PrimaryKey.class)){
+                primaryColumns.add(tableInfo.getColumnName(field));
+            }
+        }
+
+        final StringBuilder where = new StringBuilder();
+        for(int i = 0 ; i < primaryKeyColumnNames.length; i++){
+            final String columnName = primaryKeyColumnNames[i];
+            if(primaryColumns.contains(columnName)) {
+                where.append(columnName);
+                where.append("=?");
+            } else {
+                if(AALog.isEnabled()) {
+                    throw new RuntimeException("Column " + columnName + " does not exist in table " + modelClass.getName());
+                }
+            }
+            if(i < primaryKeyColumnNames.length-1){
+                where.append(" AND ");
+            }
+        }
+
+        final String sql = where.toString();
+
+        return sql;
+    }
+
+
     /**
      * Returns the where statement with primary keys and values filled in
      * @param IModel
