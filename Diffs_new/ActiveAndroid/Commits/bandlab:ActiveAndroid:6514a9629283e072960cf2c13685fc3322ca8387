diff --git a/gradle.properties b/gradle.properties
index 424d885a..1dec7c9c 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
-VERSION_NAME=3.1.0-SNAPSHOT
-VERSION_CODE=1
+VERSION_NAME=3.1.1-bandlab
+VERSION_CODE=2
 GROUP=com.michaelpardo
 
 POM_DESCRIPTION=Active record style SQLite persistence for Android.
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 330a2c9f..9770061d 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Fri Nov 29 09:06:20 EST 2013
+#Thu Feb 26 10:43:00 SGT 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-bin.zip
+distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip
diff --git a/src/com/activeandroid/ActiveAndroid.java b/src/com/activeandroid/sebbia/ActiveAndroid.java
similarity index 96%
rename from src/com/activeandroid/ActiveAndroid.java
rename to src/com/activeandroid/sebbia/ActiveAndroid.java
index c58c8efd..902c33ba 100644
--- a/src/com/activeandroid/ActiveAndroid.java
+++ b/src/com/activeandroid/sebbia/ActiveAndroid.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.activeandroid.sebbia;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -19,7 +19,7 @@
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 
-import com.activeandroid.util.Log;
+import com.activeandroid.sebbia.util.Log;
 
 public final class ActiveAndroid {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/sebbia/Cache.java
similarity index 89%
rename from src/com/activeandroid/Cache.java
rename to src/com/activeandroid/sebbia/Cache.java
index 35c383fb..c4d93bb5 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/sebbia/Cache.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.activeandroid.sebbia;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -24,11 +24,12 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.support.v4.util.LruCache;
 
-import com.activeandroid.internal.EmptyModelFiller;
-import com.activeandroid.internal.ModelFiller;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
+import com.activeandroid.sebbia.internal.EmptyModelFiller;
+import com.activeandroid.sebbia.internal.ModelFiller;
+import com.activeandroid.sebbia.serializer.TypeSerializer;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.ReflectionUtils;
 
 public final class Cache {
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -177,7 +178,8 @@ private static void initializeModelFillers() {
 		for (TableInfo tableInfo : sModelInfo.getTableInfos()) {
 			try {
 				Class<? extends Model> type = tableInfo.getType(); 
-				sFillers.put(type, instantiateFiller(type));
+				if (!isDoNotGenerate(type))
+					sFillers.put(type, instantiateFiller(type));
 			} catch (IllegalAccessException e) {
 				throw new RuntimeException(e);
 			} catch (InstantiationException e) {
@@ -188,6 +190,14 @@ private static void initializeModelFillers() {
 		
 	}
 	
+	private static boolean isDoNotGenerate(Class<?> clazz) {
+		if (clazz.isAnnotationPresent(DoNotGenerate.class))
+			return true;
+		if (clazz.getSuperclass() != null)
+			return isDoNotGenerate(clazz.getSuperclass());
+		return false;
+	}
+	
 	@SuppressWarnings("unchecked")
 	private static ModelFiller instantiateFiller(Class<? extends Model> type) throws IllegalAccessException, InstantiationException {
 		ModelFiller modelFiller = sFillers.get(type);
diff --git a/src/com/activeandroid/Configuration.java b/src/com/activeandroid/sebbia/Configuration.java
similarity index 98%
rename from src/com/activeandroid/Configuration.java
rename to src/com/activeandroid/sebbia/Configuration.java
index b197d223..d6b000d1 100644
--- a/src/com/activeandroid/Configuration.java
+++ b/src/com/activeandroid/sebbia/Configuration.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.activeandroid.sebbia;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -22,9 +22,9 @@
 
 import android.content.Context;
 
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
+import com.activeandroid.sebbia.serializer.TypeSerializer;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.ReflectionUtils;
 
 public class Configuration {
 
diff --git a/src/com/activeandroid/DatabaseHelper.java b/src/com/activeandroid/sebbia/DatabaseHelper.java
similarity index 89%
rename from src/com/activeandroid/DatabaseHelper.java
rename to src/com/activeandroid/sebbia/DatabaseHelper.java
index cc3bebec..22c65ec0 100644
--- a/src/com/activeandroid/DatabaseHelper.java
+++ b/src/com/activeandroid/sebbia/DatabaseHelper.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.activeandroid.sebbia;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -32,12 +32,12 @@
 import android.database.sqlite.SQLiteOpenHelper;
 import android.text.TextUtils;
 
-import com.activeandroid.automigration.AutoMigration;
-import com.activeandroid.util.IOUtils;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.NaturalOrderComparator;
-import com.activeandroid.util.SQLiteUtils;
-import com.activeandroid.util.SqlParser;
+import com.activeandroid.sebbia.automigration.AutoMigration;
+import com.activeandroid.sebbia.util.IOUtils;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.NaturalOrderComparator;
+import com.activeandroid.sebbia.util.SQLiteUtils;
+import com.activeandroid.sebbia.util.SqlParser;
 
 public final class DatabaseHelper extends SQLiteOpenHelper {
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -83,8 +83,8 @@ public void onCreate(SQLiteDatabase db) {
 	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 		executePragmas(db);
 		executeCreate(db);
-		executeMigrations(db, oldVersion, newVersion);
-		if (db.needUpgrade(newVersion)) {
+		int latestVersion = executeMigrations(db, oldVersion, newVersion);
+		if (latestVersion < newVersion && db.needUpgrade(newVersion)) {
 			AutoMigration.migrate(db, newVersion);
 		}
 	}
@@ -166,8 +166,15 @@ private void executeCreate(SQLiteDatabase db) {
 		}
 	}
 
-	private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
-		boolean migrationExecuted = false;
+	/**
+	 * Performs migrations from assets/migrations 
+	 * @param db
+	 * @param oldVersion
+	 * @param newVersion
+	 * @return latest version of migration file or -1 if none was executed.
+	 */
+	private int executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
+		int latestVersion = -1;
 		try {
 			final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
 			Collections.sort(files, new NaturalOrderComparator());
@@ -180,7 +187,7 @@ private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVers
 
 						if (version > oldVersion && version <= newVersion) {
 							executeSqlScript(db, file);
-							migrationExecuted = true;
+							latestVersion = version;
 
 							Log.i(file + " executed succesfully.");
 						}
@@ -199,7 +206,7 @@ private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVers
 			Log.e("Failed to execute migrations.", e);
 		}
 
-		return migrationExecuted;
+		return latestVersion;
 	}
 
 	private void executeSqlScript(SQLiteDatabase db, String file) {
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/sebbia/Model.java
similarity index 66%
rename from src/com/activeandroid/Model.java
rename to src/com/activeandroid/sebbia/Model.java
index 276b10c9..37f78d0e 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/sebbia/Model.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.activeandroid.sebbia;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,25 +16,26 @@
  * limitations under the License.
  */
 
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import com.activeandroid.sebbia.content.ContentProvider;
+import com.activeandroid.sebbia.internal.ModelFiller;
+import com.activeandroid.sebbia.internal.ModelHelper;
+import com.activeandroid.sebbia.model.ManyToManyRelation;
+import com.activeandroid.sebbia.model.OneToManyRelation;
+import com.activeandroid.sebbia.query.Delete;
+import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.sebbia.serializer.TypeSerializer;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.ReflectionUtils;
 
-import com.activeandroid.content.ContentProvider;
-import com.activeandroid.internal.ModelFiller;
-import com.activeandroid.internal.ModelHelper;
-import com.activeandroid.model.ManyToManyRelation;
-import com.activeandroid.model.OneToManyRelation;
-import com.activeandroid.query.Delete;
-import com.activeandroid.query.Select;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 
 @SuppressWarnings("unchecked")
 public abstract class Model {
@@ -42,33 +43,34 @@
 	/** Prime number used for hashcode() implementation. */
 	private static final int HASH_PRIME = 739;
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	private Long mId = null;
 
 	private final TableInfo mTableInfo;
 	private final String idName;
-	//////////////////////////////////////////////////////////////////////////////////////
+
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	public Model() {
 		mTableInfo = Cache.getTableInfo(getClass());
 		idName = mTableInfo.getIdName();
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	public final Long getId() {
 		return mId;
 	}
 
 	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), idName+"=?", new String[] { getId().toString() });
+		Cache.openDatabase().delete(mTableInfo.getTableName(), idName + "=?", new String[] { getId().toString() });
 		Cache.removeEntity(this);
 
 		Cache.getContext().getContentResolver()
@@ -76,8 +78,8 @@ public final void delete() {
 	}
 
 	public final Long save() {
-		final SQLiteDatabase db = Cache.openDatabase();
-		
+		preSave();
+		SQLiteDatabase db = Cache.openDatabase();
 		ContentValues values = new ContentValues();
 		fillContentValues(this, values);
 
@@ -85,7 +87,7 @@ public final Long save() {
 			mId = db.insert(mTableInfo.getTableName(), null, values);
 		}
 		else {
-			db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
+			db.update(mTableInfo.getTableName(), values, idName + "=" + mId, null);
 		}
 
 		Cache.getContext().getContentResolver()
@@ -97,52 +99,70 @@ public final Long save() {
 
 	public static void delete(Class<? extends Model> type, long id) {
 		TableInfo tableInfo = Cache.getTableInfo(type);
-		new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
+		new Delete().from(type).where(tableInfo.getIdName() + "=?", id).execute();
 	}
 
 	public static <T extends Model> T load(Class<T> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
+		T model = (T) Cache.getEntity(type, id);
+		if (model == null) {
+			TableInfo tableInfo = Cache.getTableInfo(type);
+			model = new Select().from(type).where(tableInfo.getIdName() + "=?", id).executeSingle();
+		}
+		return model;
 	}
-	
+
 	public static void saveMultiple(List<? extends Model> entities) {
 		final SQLiteDatabase db = Cache.openDatabase();
 		final ContentValues values = new ContentValues();
 		for (Model entity : entities) {
 			values.clear();
-			fillContentValues(entity, values);
-
 			if (entity.mId == null) {
-				entity.mId = db.insertWithOnConflict(entity.mTableInfo.getTableName(), null, values, SQLiteDatabase.CONFLICT_REPLACE);
+				ModelFiller filler = Cache.getFiller(entity.getClass());
+				if (filler != null) {
+					synchronized (entity.getClass()) {
+						SQLiteStatement statement = entity.mTableInfo.getInsertOrReplaceStatement();
+						statement.clearBindings();
+						filler.bindStatement(entity, statement, entity.mTableInfo.getColumnIndexes());
+						entity.mId = statement.executeInsert();
+					}
+				} else {
+					entity.fillContentValuesReflective(values);
+					entity.mId = db.insert(entity.mTableInfo.getTableName(), null, values);
+				}
 			} else {
-				db.update(entity.mTableInfo.getTableName(), values, "Id=" + entity.mId, null);
-			}
+				fillContentValues(entity, values);
+                db.update(entity.mTableInfo.getTableName(), values, entity.mTableInfo.getIdName() + "=" + entity.mId, null);
+            }
 		}
 	}
+
 	// Model population
 
 	public final void loadFromCursor(Cursor cursor) {
 		ModelFiller filler = Cache.getFiller(mTableInfo.getType());
-		if (filler != null) {			
+		if (filler != null) {
 			loadFromCursorWithFiller(cursor, filler);
 		} else {
 			loadFromCursorReflective(cursor);
 		}
+		if (mId != null) {
+			Cache.addEntity(this);
+		}
 	}
-	
+
 	private static void fillContentValues(Model entity, ContentValues values) {
-		if (entity instanceof ManyToManyRelation<?, ?> || entity instanceof OneToManyRelation<?>) {
+		if (entity instanceof ManyToManyRelation<?, ?> || entity instanceof OneToManyRelation<?, ?>) {
 			entity.fillContentValuesReflective(values);
 			return;
 		}
-		
+
 		ModelFiller filler = Cache.getFiller(entity.mTableInfo.getType());
 		if (filler != null)
 			filler.fillContentValues(entity, values);
 		else
 			entity.fillContentValuesReflective(values);
 	}
-	
+
 	private void fillContentValuesReflective(final ContentValues values) {
 		for (Field field : mTableInfo.getFields()) {
 			final String fieldName = mTableInfo.getColumnName(field);
@@ -161,7 +181,8 @@ private void fillContentValuesReflective(final ContentValues values) {
 						// set new object type
 						if (value != null) {
 							fieldType = value.getClass();
-							// check that the serializer returned what it promised
+							// check that the serializer returned what it
+							// promised
 							if (!fieldType.equals(typeSerializer.getSerializedType())) {
 								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
 										typeSerializer.getSerializedType(), fieldType));
@@ -170,7 +191,8 @@ private void fillContentValuesReflective(final ContentValues values) {
 					}
 				}
 
-				// TODO: Find a smarter way to do this? This if block is necessary because we
+				// TODO: Find a smarter way to do this? This if block is
+				// necessary because we
 				// can't know the type until runtime.
 				if (value == null) {
 					values.putNull(fieldName);
@@ -211,32 +233,30 @@ else if (ReflectionUtils.isModel(fieldType)) {
 				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 					values.put(fieldName, ((Enum<?>) value).name());
 				}
-			}
-			catch (IllegalArgumentException e) {
+			} catch (IllegalArgumentException e) {
 				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
+			} catch (IllegalAccessException e) {
 				Log.e(e.getClass().getName(), e);
 			}
 		}
 	}
 
-	
 	private void loadFromCursorWithFiller(Cursor cursor, ModelFiller filler) {
 		int columnIndex = cursor.getColumnIndex(idName);
-		if (cursor.isNull(columnIndex) == false)
+		if (!cursor.isNull(columnIndex))
 			mId = cursor.getLong(columnIndex);
 		else
 			mId = null;
 		filler.loadFromCursor(this, cursor);
-	}	
-	
+	}
+
 	private void loadFromCursorReflective(Cursor cursor) {
 		/**
-         * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-         * when the cursor have multiple columns with same name obtained from join tables.
-         */
-        List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+		 * Obtain the columns ordered to fix issue #106
+		 * (https://github.com/pardom/ActiveAndroid/issues/106) when the cursor
+		 * have multiple columns with same name obtained from join tables.
+		 */
+		List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
 		for (Field field : mTableInfo.getFields()) {
 			final String fieldName = mTableInfo.getColumnName(field);
 			Class<?> fieldType = field.getType();
@@ -262,11 +282,11 @@ private void loadFromCursorReflective(Cursor cursor) {
 				} else {
 					value = ModelHelper.getValueFromCursor(cursor, fieldType, columnIndex);
 				}
-				
+
 				if (value == null) {
 					if (ReflectionUtils.isModel(fieldType)) {
 						value = ModelHelper.getModel(cursor, fieldType, columnIndex);
-					} 
+					}
 					else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 						@SuppressWarnings("rawtypes")
 						final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
@@ -279,42 +299,42 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 				}
 
 				// Set the field value
-				if (value != null) {
+				if (value != null && field != null) {
 					field.set(this, value);
 				}
-			}
-			catch (IllegalArgumentException e) {
+			} catch (IllegalArgumentException e) {
 				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
+			} catch (IllegalAccessException e) {
 				Log.e(e.getClass().getName(), e);
-			}
-			catch (SecurityException e) {
+			} catch (SecurityException e) {
 				Log.e(e.getClass().getName(), e);
 			}
 		}
-
-		if (mId != null) {
-			Cache.addEntity(this);
-		}
 	}
-	
-	
-	//////////////////////////////////////////////////////////////////////////////////////
+
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
 		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
 	}
-	
+
 	protected String getIdName() {
 		return idName;
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	protected void setModelId(long id) {
+		mId = id;
+	}
+
+	protected void preSave(){
+		//Override it to execute logic before save() method would be called
+	}
+
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	@Override
 	public String toString() {
@@ -326,8 +346,8 @@ public boolean equals(Object obj) {
 		if (obj instanceof Model && this.mId != null) {
 			final Model other = (Model) obj;
 
-			return this.mId.equals(other.mId)							
-							&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
+			return this.mId.equals(other.mId)
+					&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
 		} else {
 			return this == obj;
 		}
@@ -336,8 +356,14 @@ public boolean equals(Object obj) {
 	@Override
 	public int hashCode() {
 		int hash = HASH_PRIME;
-		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); //if id is null, use Object.hashCode()
+		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); // if
+																				// id
+																				// is
+																				// null,
+																				// use
+																				// Object.hashCode()
 		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
-		return hash; //To change body of generated methods, choose Tools | Templates.
+		return hash; // To change body of generated methods, choose Tools |
+						// Templates.
 	}
 }
diff --git a/src/com/activeandroid/ModelInfo.java b/src/com/activeandroid/sebbia/ModelInfo.java
similarity index 93%
rename from src/com/activeandroid/ModelInfo.java
rename to src/com/activeandroid/sebbia/ModelInfo.java
index f983cacf..a6743a6b 100644
--- a/src/com/activeandroid/ModelInfo.java
+++ b/src/com/activeandroid/sebbia/ModelInfo.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.activeandroid.sebbia;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -30,13 +30,13 @@
 
 import android.content.Context;
 
-import com.activeandroid.serializer.CalendarSerializer;
-import com.activeandroid.serializer.FileSerializer;
-import com.activeandroid.serializer.SqlDateSerializer;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.serializer.UtilDateSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
+import com.activeandroid.sebbia.serializer.CalendarSerializer;
+import com.activeandroid.sebbia.serializer.FileSerializer;
+import com.activeandroid.sebbia.serializer.SqlDateSerializer;
+import com.activeandroid.sebbia.serializer.TypeSerializer;
+import com.activeandroid.sebbia.serializer.UtilDateSerializer;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.ReflectionUtils;
 
 import dalvik.system.DexFile;
 
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/sebbia/TableInfo.java
similarity index 63%
rename from src/com/activeandroid/TableInfo.java
rename to src/com/activeandroid/sebbia/TableInfo.java
index e55b63ea..0274b35c 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/src/com/activeandroid/sebbia/TableInfo.java
@@ -1,122 +1,170 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.reflect.Field;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
-import android.text.TextUtils;
-
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
-
-public final class TableInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Class<? extends Model> mType;
-	private String mTableName;
-	private String mIdName = Table.DEFAULT_ID_NAME;
-
-	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public TableInfo(Class<? extends Model> type) {
-		mType = type;
-
-		final Table tableAnnotation = type.getAnnotation(Table.class);
-
-        if (tableAnnotation != null) {
-			mTableName = tableAnnotation.name();
-			mIdName = tableAnnotation.id();
-		}
-		else {
-			mTableName = type.getSimpleName();
-        }
-
-        // Manually add the id column since it is not declared like the other columns.
-        Field idField = getIdField(type);
-        mColumnNames.put(idField, mIdName);
-
-        List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
-        Collections.reverse(fields);
-
-        for (Field field : fields) {
-            if (field.isAnnotationPresent(Column.class)) {
-                final Column columnAnnotation = field.getAnnotation(Column.class);
-                String columnName = columnAnnotation.name();
-                if (TextUtils.isEmpty(columnName)) {
-                    columnName = field.getName();
-                }
-
-                mColumnNames.put(field, columnName);
-            }
-        }
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Class<? extends Model> getType() {
-		return mType;
-	}
-
-	public String getTableName() {
-		return mTableName;
-	}
-
-	public String getIdName() {
-		return mIdName;
-	}
-
-	public Collection<Field> getFields() {
-		return mColumnNames.keySet();
-	}
-
-	public String getColumnName(Field field) {
-		return mColumnNames.get(field);
-	}
-	
-    private Field getIdField(Class<?> type) {
-        if (type.equals(Model.class)) {
-            try {
-                return type.getDeclaredField("mId");
-            }
-            catch (NoSuchFieldException e) {
-                Log.e("Impossible!", e.toString());
-            }
-        }
-        else if (type.getSuperclass() != null) {
-            return getIdField(type.getSuperclass());
-        }
-
-        return null;
-    }
-
-}
+package com.activeandroid.sebbia;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+import android.text.TextUtils;
+
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.ReflectionUtils;
+import com.activeandroid.sebbia.util.SQLiteUtils;
+
+public final class TableInfo {
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE MEMBERS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private Class<? extends Model> mType;
+	private String mTableName;
+	private String mIdName = Table.DEFAULT_ID_NAME;
+
+	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
+	
+	private SQLiteStatement mInsertStatement;
+	private SQLiteStatement mInsertOrReplaceStatement;
+	private SQLiteStatement mUpdateStatement;
+	
+	private Map<String, Integer> mColumnIndexes;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// CONSTRUCTORS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public TableInfo(Class<? extends Model> type) {
+		mType = type;
+
+		final Table tableAnnotation = type.getAnnotation(Table.class);
+
+        if (tableAnnotation != null) {
+			mTableName = tableAnnotation.name();
+			mIdName = tableAnnotation.id();
+		}
+		else {
+			mTableName = type.getSimpleName();
+        }
+
+        // Manually add the id column since it is not declared like the other columns.
+        Field idField = getIdField(type);
+        mColumnNames.put(idField, mIdName);
+
+        List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
+        Collections.reverse(fields);
+
+        for (Field field : fields) {
+            if (field.isAnnotationPresent(Column.class)) {
+                final Column columnAnnotation = field.getAnnotation(Column.class);
+                String columnName = columnAnnotation.name();
+                if (TextUtils.isEmpty(columnName)) {
+                    columnName = field.getName();
+                }
+
+                mColumnNames.put(field, columnName);
+            }
+        }
+        
+        mColumnIndexes = new HashMap<String, Integer>(mColumnNames.size());
+        int index = 1;
+        for (String column : mColumnNames.values()) {
+        	mColumnIndexes.put(column, index++);
+        }
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public Class<? extends Model> getType() {
+		return mType;
+	}
+
+	public String getTableName() {
+		return mTableName;
+	}
+
+	public String getIdName() {
+		return mIdName;
+	}
+
+	public Collection<Field> getFields() {
+		return mColumnNames.keySet();
+	}
+	
+	public Collection<String> getColumnNames() {
+		return mColumnNames.values();
+	}
+
+	public String getColumnName(Field field) {
+		return mColumnNames.get(field);
+	}
+	
+	public SQLiteStatement getInsertStatement() {
+		if (mInsertStatement == null) {
+			SQLiteDatabase db = Cache.openDatabase(); 
+			mInsertStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT INTO ", this));
+		}
+		return mInsertStatement;
+	}
+	
+	public SQLiteStatement getUpdateStatement() {
+		if (mUpdateStatement == null) {
+			SQLiteDatabase db = Cache.openDatabase(); 
+			mUpdateStatement = db.compileStatement(SQLiteUtils.createUpdateStatement(this));
+		}
+		return mUpdateStatement;
+	}
+	
+	public SQLiteStatement getInsertOrReplaceStatement() {
+		if (mInsertOrReplaceStatement == null) {
+			SQLiteDatabase db = Cache.openDatabase(); 
+			mInsertOrReplaceStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT OR REPLACE INTO ", this));
+		}
+		return mInsertOrReplaceStatement;
+	}
+	
+    private Field getIdField(Class<?> type) {
+        if (type.equals(Model.class)) {
+            try {
+                return type.getDeclaredField("mId");
+            }
+            catch (NoSuchFieldException e) {
+                Log.e("Impossible!", e.toString());
+            }
+        }
+        else if (type.getSuperclass() != null) {
+            return getIdField(type.getSuperclass());
+        }
+
+        return null;
+    }
+    
+    public Map<String, Integer> getColumnIndexes() {
+		return mColumnIndexes;
+	}
+
+}
diff --git a/src/com/activeandroid/annotation/Column.java b/src/com/activeandroid/sebbia/annotation/Column.java
similarity index 98%
rename from src/com/activeandroid/annotation/Column.java
rename to src/com/activeandroid/sebbia/annotation/Column.java
index 5ecc8d69..52e46d49 100644
--- a/src/com/activeandroid/annotation/Column.java
+++ b/src/com/activeandroid/sebbia/annotation/Column.java
@@ -1,4 +1,4 @@
-package com.activeandroid.annotation;
+package com.activeandroid.sebbia.annotation;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java b/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java
new file mode 100644
index 00000000..c97b3fa4
--- /dev/null
+++ b/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java
@@ -0,0 +1,10 @@
+package com.activeandroid.sebbia.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface DoNotGenerate { }
diff --git a/src/com/activeandroid/annotation/Table.java b/src/com/activeandroid/sebbia/annotation/Table.java
similarity index 95%
rename from src/com/activeandroid/annotation/Table.java
rename to src/com/activeandroid/sebbia/annotation/Table.java
index 541dfbe9..38b22f8c 100644
--- a/src/com/activeandroid/annotation/Table.java
+++ b/src/com/activeandroid/sebbia/annotation/Table.java
@@ -1,4 +1,4 @@
-package com.activeandroid.annotation;
+package com.activeandroid.sebbia.annotation;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/app/Application.java b/src/com/activeandroid/sebbia/app/Application.java
similarity index 90%
rename from src/com/activeandroid/app/Application.java
rename to src/com/activeandroid/sebbia/app/Application.java
index 311c7c93..6b914f95 100644
--- a/src/com/activeandroid/app/Application.java
+++ b/src/com/activeandroid/sebbia/app/Application.java
@@ -1,4 +1,4 @@
-package com.activeandroid.app;
+package com.activeandroid.sebbia.app;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.ActiveAndroid;
+import com.activeandroid.sebbia.ActiveAndroid;
 
 public class Application extends android.app.Application {
 	@Override
diff --git a/src/com/activeandroid/automigration/AutoMigration.java b/src/com/activeandroid/sebbia/automigration/AutoMigration.java
similarity index 95%
rename from src/com/activeandroid/automigration/AutoMigration.java
rename to src/com/activeandroid/sebbia/automigration/AutoMigration.java
index b605dc82..603aa1f6 100644
--- a/src/com/activeandroid/automigration/AutoMigration.java
+++ b/src/com/activeandroid/sebbia/automigration/AutoMigration.java
@@ -1,4 +1,4 @@
-package com.activeandroid.automigration;
+package com.activeandroid.sebbia.automigration;
 
 import java.util.Random;
 
@@ -6,11 +6,11 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 
-import com.activeandroid.Cache;
-import com.activeandroid.TableInfo;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.SQLiteUtils;
-import com.activeandroid.util.SQLiteUtils.SQLiteType;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.SQLiteUtils;
+import com.activeandroid.sebbia.util.SQLiteUtils.SQLiteType;
 
 public class AutoMigration {
 	
diff --git a/src/com/activeandroid/automigration/SQLColumnInfo.java b/src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
similarity index 91%
rename from src/com/activeandroid/automigration/SQLColumnInfo.java
rename to src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
index 9f6441b4..1145ad9c 100644
--- a/src/com/activeandroid/automigration/SQLColumnInfo.java
+++ b/src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
@@ -1,9 +1,9 @@
-package com.activeandroid.automigration;
+package com.activeandroid.sebbia.automigration;
 
 import java.util.ArrayList;
 import java.util.Locale;
 
-import com.activeandroid.util.SQLiteUtils.SQLiteType;
+import com.activeandroid.sebbia.util.SQLiteUtils.SQLiteType;
 
 import android.text.TextUtils;
 
diff --git a/src/com/activeandroid/automigration/SQLTableInfo.java b/src/com/activeandroid/sebbia/automigration/SQLTableInfo.java
similarity index 78%
rename from src/com/activeandroid/automigration/SQLTableInfo.java
rename to src/com/activeandroid/sebbia/automigration/SQLTableInfo.java
index 39fccbac..4db3ab6f 100644
--- a/src/com/activeandroid/automigration/SQLTableInfo.java
+++ b/src/com/activeandroid/sebbia/automigration/SQLTableInfo.java
@@ -1,12 +1,17 @@
-package com.activeandroid.automigration;
+package com.activeandroid.sebbia.automigration;
+
+import android.text.TextUtils;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
-
-import android.text.TextUtils;
+import java.util.regex.Pattern;
 
 public final class SQLTableInfo {
+
+	private static final Pattern S_PLUS = Pattern.compile("\\s+");
+	private static final Pattern CREATE_TABLE = Pattern.compile("(?i)CREATE TABLE ");
+	private static final Pattern UNIQUE = Pattern.compile(", UNIQUE \\(.*\\) ON CONFLICT (ROLLBACK|ABORT|FAIL|IGNORE|REPLACE)");
 	
 	public static String constructSchema(String tableName, List<SQLColumnInfo> columns) {
 		String schema = "CREATE TABLE " + tableName + "(%s);";
@@ -29,14 +34,15 @@ public SQLTableInfo(String sqlSchema) {
 		if (TextUtils.isEmpty(sqlSchema))
 			throw new IllegalArgumentException("Cannot construct SqlTableInfo from empty sqlSchema");
 		
-		sqlSchema = sqlSchema.replaceAll("\\s+", " ");
-		this.mSchema = new String(sqlSchema);
+		sqlSchema = S_PLUS.matcher(sqlSchema).replaceAll(" ");
+		this.mSchema = sqlSchema;
 		
 		if (!sqlSchema.toUpperCase(Locale.US).startsWith("CREATE TABLE") || !sqlSchema.contains("(") || !sqlSchema.contains(")"))
 			throw new IllegalArgumentException("sqlSchema doesn't appears to be valid");
 		mColumns = new ArrayList<SQLColumnInfo>();
 		
-		sqlSchema = sqlSchema.replaceAll("(?i)CREATE TABLE ", "");
+		sqlSchema = CREATE_TABLE.matcher(sqlSchema).replaceAll("");
+		sqlSchema = UNIQUE.matcher(sqlSchema).replaceAll("");
 		mTableName = sqlSchema.substring(0, sqlSchema.indexOf('(')).replace("\"", "");
 		
 		String columnDefinitions = sqlSchema.substring(sqlSchema.indexOf('(') + 1, sqlSchema.lastIndexOf(')'));
diff --git a/src/com/activeandroid/automigration/TableDifference.java b/src/com/activeandroid/sebbia/automigration/TableDifference.java
similarity index 90%
rename from src/com/activeandroid/automigration/TableDifference.java
rename to src/com/activeandroid/sebbia/automigration/TableDifference.java
index d7356985..aaba59fd 100644
--- a/src/com/activeandroid/automigration/TableDifference.java
+++ b/src/com/activeandroid/sebbia/automigration/TableDifference.java
@@ -1,4 +1,4 @@
-package com.activeandroid.automigration;
+package com.activeandroid.sebbia.automigration;
 
 import java.lang.reflect.Field;
 import java.util.ArrayList;
@@ -6,9 +6,9 @@
 import java.util.List;
 import java.util.Map;
 
-import com.activeandroid.TableInfo;
-import com.activeandroid.automigration.AutoMigration.IncompatibleColumnTypesException;
-import com.activeandroid.util.SQLiteUtils;
+import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.sebbia.automigration.AutoMigration.IncompatibleColumnTypesException;
+import com.activeandroid.sebbia.util.SQLiteUtils;
 
 class TableDifference {
 	
diff --git a/src/com/activeandroid/content/ContentProvider.java b/src/com/activeandroid/sebbia/content/ContentProvider.java
similarity index 95%
rename from src/com/activeandroid/content/ContentProvider.java
rename to src/com/activeandroid/sebbia/content/ContentProvider.java
index b4a841d6..c49c30d7 100644
--- a/src/com/activeandroid/content/ContentProvider.java
+++ b/src/com/activeandroid/sebbia/content/ContentProvider.java
@@ -1,4 +1,4 @@
-package com.activeandroid.content;
+package com.activeandroid.sebbia.content;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -9,11 +9,11 @@
 import android.net.Uri;
 import android.util.SparseArray;
 
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Cache;
-import com.activeandroid.Configuration;
-import com.activeandroid.Model;
-import com.activeandroid.TableInfo;
+import com.activeandroid.sebbia.ActiveAndroid;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Configuration;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.TableInfo;
 
 public class ContentProvider extends android.content.ContentProvider {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/internal/AnnotationProcessor.java b/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
similarity index 51%
rename from src/com/activeandroid/internal/AnnotationProcessor.java
rename to src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
index d9b3dc3e..81969839 100644
--- a/src/com/activeandroid/internal/AnnotationProcessor.java
+++ b/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
@@ -1,316 +1,423 @@
-package com.activeandroid.internal;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.tools.Diagnostic.Kind;
-import javax.tools.JavaFileObject;
-
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Column;
-
-public final class AnnotationProcessor extends AbstractProcessor {
-
-	private static final String MODEL = "model";
-	private static final String CURSOR = "cursor";
-	private static final String CONTENT_VALUES = "contentValues";
-	private static final String COLUMNS_ORDERED = "columnsOrdered";
-
-	private RoundEnvironment env;
-
-	@Override
-	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
-		this.env = env;
-		if (annotations.size() > 0) {
-			parseColumns();
-		}
-		return true;
-	}
-
-	@Override
-	public Set<String> getSupportedAnnotationTypes() {
-		Set<String> supportedTypes = new HashSet<String>();
-		supportedTypes.add(Column.class.getCanonicalName());
-		return supportedTypes;
-	}
-
-	@Override
-	public SourceVersion getSupportedSourceVersion() {
-		return SourceVersion.latestSupported();
-	}
-
-	private void parseColumns() {
-		Set<? extends Element> columns = env.getElementsAnnotatedWith(Column.class);
-		Map<TypeElement, Set<VariableElement>> tables = new HashMap<TypeElement, Set<VariableElement>>();
-		for (Element element : columns) {
-			if (element instanceof VariableElement == false || element.getKind() != ElementKind.FIELD) {
-				error("@Column annotation should be applied only to local variables", element);
-				continue;
-			}
-			VariableElement columnElement = (VariableElement) element;
-
-			if (checkColumnModifiers(columnElement) == false)
-				continue;
-
-			TypeElement tableElement = null;
-			if (element.getEnclosingElement() instanceof TypeElement)
-				tableElement = (TypeElement) element.getEnclosingElement();
-			else
-				error("@Column annotation located not inside of class", element);
-
-			if (checkTableModifiers(tableElement) == false)
-				continue;
-
-			Set<VariableElement> columnsElements = tables.get(tableElement);
-			if (columnsElements == null) {
-				columnsElements = new HashSet<VariableElement>();
-				tables.put(tableElement, columnsElements);
-			}
-
-			columnsElements.add(columnElement);
-
-		}
-
-		for (TypeElement table : tables.keySet()) {
-			generate(table, tables.get(table));
-		}
-	}
-
-	private void generate(TypeElement tableElement, Set<VariableElement> columns) {
-		String packageName = processingEnv.getElementUtils().getPackageOf(tableElement).getQualifiedName().toString();
-		String className = tableElement.getQualifiedName().toString();
-		String fillerClassName = getClassName(tableElement, packageName) + ModelFiller.SUFFIX;
-
-		try {
-			JavaFileObject jfo = processingEnv.getFiler().createSourceFile(packageName + "." + fillerClassName, tableElement);
-			Writer writer = jfo.openWriter();
-			writer.write("//Generated by ActiveAndroid. Do not modify\n");
-			writer.write("package " + packageName + ";\n\n");
-			writer.write("import java.util.ArrayList;\n");
-			writer.write("import java.util.Arrays;\n");
-			writer.write("import java.util.List;\n\n");
-
-			writer.write("import com.activeandroid.internal.ModelHelper;\n");
-			writer.write("import com.activeandroid.internal.ModelFiller;\n");
-			writer.write("\n");
-			writer.write("public class " + fillerClassName + " extends ModelFiller {\n\n");
-			writer.write("  public void loadFromCursor(com.activeandroid.Model genericModel, android.database.Cursor " + CURSOR + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.loadFromCursor(genericModel, " + CURSOR + ");\n");
-			writer.write("    List<String> " + COLUMNS_ORDERED + " = new ArrayList<String>(Arrays.asList(" + CURSOR + ".getColumnNames()));\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getLoadFromCursorCode(columns));
-			writer.write("  }\n\n");
-
-			writer.write("  ");
-			writer.write("public void fillContentValues(com.activeandroid.Model genericModel, android.content.ContentValues " + CONTENT_VALUES + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.fillContentValues(genericModel, " + CONTENT_VALUES + ");\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getFillContentValuesCode(columns));
-			writer.write("  }\n");
-
-			writer.write("}");
-			writer.flush();
-			writer.close();
-		} catch (IOException exception) {
-			processingEnv.getMessager().printMessage(Kind.ERROR, exception.getMessage());
-		}
-	}
-
-	private String getLoadFromCursorCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-
-			TypeMirror typeMirror = column.asType();
-			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
-			String type = typeMirror.toString() + ".class";
-			String getColumnIndex = COLUMNS_ORDERED + ".indexOf(\"" + fieldName + "\")";
-
-			if (notPrimitiveType) {
-				stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
-				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = (" + typeMirror.toString() + ") ModelHelper.getSerializable(cursor, " + type + ", " + getColumnIndex + ");\n");
-				stringBuilder.append("    } else {\n");
-				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = ");
-			} else {
-				stringBuilder.append("    " + MODEL + "." + column.getSimpleName() + " = ");
-			}
-
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append(CURSOR + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append(CURSOR + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append(CURSOR + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append(CURSOR + ".getLong(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append(CURSOR + ".getFloat(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append(CURSOR + ".getDouble(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append(CURSOR + ".getInt(" + getColumnIndex + ") != 0;\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append(CURSOR + ".getString(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append(CURSOR + ".getString(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append(CURSOR + ".getBlob(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Model.class))
-				stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getModel(cursor, " + type + ", " + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Enum.class))
-				stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getEnum(cursor, " + type + ", " + getColumnIndex + ");\n");
-			else
-				stringBuilder.append(" null;\n");
-			if (notPrimitiveType) {
-				stringBuilder.append("    }\n");
-			}
-		}
-		return stringBuilder.toString();
-	}
-
-	private String getFillContentValuesCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-			
-			TypeMirror typeMirror = column.asType();
-			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
-			String type = typeMirror.toString() + ".class";
-			String getValue = MODEL + "." + column.getSimpleName();
-			
-			if (notPrimitiveType) {
-				stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
-				stringBuilder.append("      ModelHelper.setSerializable(" + CONTENT_VALUES + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
-				stringBuilder.append("    } else if (" + getValue + " != null) {\n");
-				stringBuilder.append("      " + CONTENT_VALUES + ".");
-			} else {
-				stringBuilder.append("    " + CONTENT_VALUES + ".");
-			}
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Model.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".getId());\n");
-			else if (isTypeOf(typeMirror, Enum.class))
-				stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".name());\n");
-			else
-				stringBuilder.append("putNull(\"" + fieldName + "\");\n");
-			if (notPrimitiveType) {
-				if (annotation.defaultValue() == null || annotation.defaultValue().isEmpty()) {
-					stringBuilder.append("    } else {\n");
-					stringBuilder.append("      " + CONTENT_VALUES + ".putNull(\"" + fieldName +  "\");\n");
-				}
-				stringBuilder.append("    }\n");
-			}
-			
-		}
-		return stringBuilder.toString();
-	}
-
-	private boolean isTypeOf(TypeMirror typeMirror, Class<?> type) {
-		if (type.getName().equals(typeMirror.toString()))
-			return true;
-
-		if (typeMirror instanceof DeclaredType == false)
-			return false;
-
-		DeclaredType declaredType = (DeclaredType) typeMirror;
-		Element element = declaredType.asElement();
-		if (element instanceof TypeElement == false)
-			return false;
-
-		TypeElement typeElement = (TypeElement) element;
-		TypeMirror superType = typeElement.getSuperclass();
-		if (isTypeOf(superType, type))
-			return true;
-		return false;
-	}
-
-	private boolean checkTableModifiers(TypeElement table) {
-		if (table.getModifiers().contains(Modifier.PRIVATE)) {
-			error("Classes marked with @Table cannot be private", table);
-			return false;
-		}
-
-		if (table.getKind() != ElementKind.CLASS) {
-			error("Only classes can be marked with @Table annotation", table);
-			return false;
-		}
-
-		return true;
-	}
-
-	private boolean checkColumnModifiers(VariableElement column) {
-
-		if (column.getModifiers().contains(Modifier.PRIVATE)) {
-			error("Field marked with @Column cannot be private", column);
-			return false;
-		}
-
-		if (column.getModifiers().contains(Modifier.FINAL)) {
-			error("Field marked with @Column cannot be final", column);
-			return false;
-		}
-
-		if (column.getModifiers().contains(Modifier.STATIC)) {
-			error("Field marked with @Column cannot be static", column);
-			return false;
-		}
-
-		return true;
-	}
-
-	private void error(String message, Element element) {
-		processingEnv.getMessager().printMessage(Kind.ERROR, message, element);
-	}
-
-	private static String getClassName(TypeElement type, String packageName) {
-		int packageLen = packageName.length() + 1;
-		return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
-	}
-}
+package com.activeandroid.sebbia.internal;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic.Kind;
+import javax.tools.JavaFileObject;
+
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
+
+public final class AnnotationProcessor extends AbstractProcessor {
+
+	private static final String MODEL = "model";
+	private static final String CURSOR = "cursor";
+	private static final String CONTENT_VALUES = "contentValues";
+	private static final String COLUMNS_ORDERED = "columnsOrdered";
+	private static final String STATEMENT = "statement";
+	private static final String COLUMNS = "columns";
+
+	private RoundEnvironment env;
+
+	@Override
+	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
+		this.env = env;
+		if (annotations.size() > 0) {
+			parseColumns();
+		}
+		return true;
+	}
+
+	@Override
+	public Set<String> getSupportedAnnotationTypes() {
+		Set<String> supportedTypes = new HashSet<String>();
+		supportedTypes.add(Column.class.getCanonicalName());
+		return supportedTypes;
+	}
+
+	@Override
+	public SourceVersion getSupportedSourceVersion() {
+		return SourceVersion.latestSupported();
+	}
+
+	private void parseColumns() {
+		Set<? extends Element> columns = env.getElementsAnnotatedWith(Column.class);
+		Map<TypeElement, Set<VariableElement>> tables = new HashMap<TypeElement, Set<VariableElement>>();
+		for (Element element : columns) {
+			if (element instanceof VariableElement == false || element.getKind() != ElementKind.FIELD) {
+				error("@Column annotation should be applied only to local variables", element);
+				continue;
+			}
+			VariableElement columnElement = (VariableElement) element;
+
+			TypeElement tableElement = null;
+			if (element.getEnclosingElement() instanceof TypeElement) {
+				tableElement = (TypeElement) element.getEnclosingElement();
+			} else {
+				error("@Column annotation located not inside of class", element);
+				continue;
+			}
+				
+			if (checkTableModifiers(tableElement) == false)
+				continue;
+			
+			if (checkColumnModifiers(columnElement) == false)
+				continue;
+
+			Set<VariableElement> columnsElements = tables.get(tableElement);
+			if (columnsElements == null) {
+				columnsElements = new HashSet<VariableElement>();
+				tables.put(tableElement, columnsElements);
+			}
+
+			columnsElements.add(columnElement);
+
+		}
+
+		for (TypeElement table : tables.keySet()) {
+			generate(table, tables.get(table));
+		}
+	}
+
+	private void generate(TypeElement tableElement, Set<VariableElement> columns) {
+		String packageName = processingEnv.getElementUtils().getPackageOf(tableElement).getQualifiedName().toString();
+		String className = tableElement.getQualifiedName().toString();
+		String fillerClassName = getClassName(tableElement, packageName) + ModelFiller.SUFFIX;
+
+		try {
+			JavaFileObject jfo = processingEnv.getFiler().createSourceFile(packageName + "." + fillerClassName, tableElement);
+			Writer writer = jfo.openWriter();
+			writer.write("//Generated by ActiveAndroid. Do not modify\n");
+			writer.write("package " + packageName + ";\n\n");
+			
+			writer.write("import android.database.sqlite.SQLiteStatement;\n");
+			writer.write("import java.util.ArrayList;\n");
+			writer.write("import java.util.Arrays;\n");
+			writer.write("import java.util.List;\n\n");
+			writer.write("import java.util.Map;\n\n");
+
+			writer.write("import com.activeandroid.sebbia.internal.ModelHelper;\n");
+			writer.write("import com.activeandroid.sebbia.internal.ModelFiller;\n");
+			writer.write("\n");
+			writer.write("public class " + fillerClassName + " extends ModelFiller {\n\n");
+			writer.write("  public void loadFromCursor(com.activeandroid.sebbia.Model genericModel, android.database.Cursor " + CURSOR + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.loadFromCursor(genericModel, " + CURSOR + ");\n");
+			writer.write("    List<String> " + COLUMNS_ORDERED + " = new ArrayList<String>(Arrays.asList(" + CURSOR + ".getColumnNames()));\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getLoadFromCursorCode(columns));
+			writer.write("  }\n\n");
+
+			
+			writer.write("  public void fillContentValues(com.activeandroid.sebbia.Model genericModel, android.content.ContentValues " + CONTENT_VALUES + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.fillContentValues(genericModel, " + CONTENT_VALUES + ");\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getFillContentValuesCode(columns));
+			writer.write("  }\n");
+			
+			writer.write("  public void bindStatement(com.activeandroid.sebbia.Model genericModel, SQLiteStatement " + STATEMENT + ", Map<String, Integer> " + COLUMNS + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.bindStatement(genericModel, " + STATEMENT + ", " + COLUMNS + ");\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getBindStatementCode(columns));
+			writer.write("  }\n");
+
+			writer.write("}");
+			writer.flush();
+			writer.close();
+		} catch (IOException exception) {
+			processingEnv.getMessager().printMessage(Kind.ERROR, exception.getMessage());
+		}
+	}
+
+	private String getLoadFromCursorCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+
+			TypeMirror typeMirror = column.asType();
+			String type = getClassString(typeMirror, typeMirror instanceof DeclaredType);
+			String getColumnIndex = COLUMNS_ORDERED + ".indexOf(\"" + fieldName + "\")";
+
+			String setValue = "    " + MODEL + "." + column.getSimpleName() + " = " + CURSOR;
+
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append("    " + MODEL + "." + column.getSimpleName() + " = (short) " + CURSOR + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append(setValue + ".getLong(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append(setValue + ".getFloat(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append(setValue + ".getDouble(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ") != 0;\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append(setValue + ".getBlob(" + getColumnIndex + ");\n");
+			else {
+				processingEnv.getMessager().printMessage(Kind.NOTE, "Guessing what type is at " + typeMirror.toString(), null);
+				stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
+				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = (" + typeMirror.toString() + ") ModelHelper.getSerializable(cursor, " + type + ", " + getColumnIndex + ");\n");
+				stringBuilder.append("    } else {\n");
+				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = ");
+				if (isTypeOf(typeMirror, Model.class))
+					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getModel(cursor, " + type + ", " + getColumnIndex + ");\n");
+				else if (isTypeOf(typeMirror, Enum.class))
+					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getEnum(cursor, " + type + ", " + getColumnIndex + ");\n");
+				else
+					stringBuilder.append(" null;\n");
+				
+				stringBuilder.append("    }\n");
+			}
+		}
+		return stringBuilder.toString();
+	}
+
+	private String getFillContentValuesCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+			
+			TypeMirror typeMirror = column.asType();
+			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
+			String type = getClassString(typeMirror, notPrimitiveType);
+			String getValue = MODEL + "." + column.getSimpleName();
+			
+			boolean hasDefault = annotation.defaultValue() != null && annotation.defaultValue().isEmpty() == false;
+			String emptySpace = "    ";
+			if (notPrimitiveType) {
+				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
+				emptySpace += "  ";
+ 			}
+			String putValue = emptySpace + CONTENT_VALUES + ".put(\"" + fieldName + "\", " + getValue;
+			
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append(putValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append(putValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append(putValue + ");\n");
+			else {
+				stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
+				stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + CONTENT_VALUES + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
+				stringBuilder.append(emptySpace + "} else {\n");
+				stringBuilder.append(emptySpace + "  " + CONTENT_VALUES + ".");
+				if (isTypeOf(typeMirror, Model.class))
+					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".getId());\n");
+				else if (isTypeOf(typeMirror, Enum.class))
+					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".name());\n");
+				else
+					stringBuilder.append("putNull(\"" + fieldName + "\");\n");
+				stringBuilder.append(emptySpace + "}\n");
+			}
+			if (notPrimitiveType) {
+				if (hasDefault == false) {
+					stringBuilder.append("    } else {\n");
+					stringBuilder.append("      " + CONTENT_VALUES + ".putNull(\"" + fieldName +  "\");\n");
+				}
+				stringBuilder.append("    }\n");
+			}
+		}
+		return stringBuilder.toString();
+	}
+	
+	private String getBindStatementCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+			
+			TypeMirror typeMirror = column.asType();
+			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
+			String type = getClassString(typeMirror, notPrimitiveType);
+			
+			String getValue = MODEL + "." + column.getSimpleName();
+			
+			String columnIndex = COLUMNS + ".get(\"" + fieldName + "\")"; 
+			String emptySpace = "    ";
+			
+			if (notPrimitiveType) {
+				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
+				emptySpace += "  ";
+ 			}
+			String bind = emptySpace + STATEMENT + ".bind";
+			
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + " ? 1 : 0);\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append(bind + "Blob(" + columnIndex + ", " + getValue + ");\n");
+			else {
+				boolean isModel = isTypeOf(typeMirror, Model.class);
+				boolean isEnum = isTypeOf(typeMirror, Enum.class);
+				if (isModel || isEnum) {
+					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
+					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
+					stringBuilder.append(emptySpace + "} else {\n");
+					stringBuilder.append(emptySpace + "  " + STATEMENT + ".bind");
+					if (isModel)
+						stringBuilder.append("Long(" + columnIndex + ", " + getValue + ".getId());\n");
+					else if (isEnum)
+						stringBuilder.append("String(" + columnIndex + ", " + getValue + ".name());\n");
+					stringBuilder.append(emptySpace + "}\n");
+				} else {
+					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + "))\n");
+					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");
+				}
+			}
+			if (notPrimitiveType)
+				stringBuilder.append("    }\n");
+		}
+		return stringBuilder.toString();
+	}
+
+	private String getClassString(TypeMirror typeMirror, boolean notPrimitiveType) {
+		String type = typeMirror.toString() + ".class";
+		if (notPrimitiveType) {
+			DeclaredType declaredType = (DeclaredType) typeMirror;
+			List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+			if (typeArguments != null && typeArguments.size() > 0)
+				type = ((TypeElement) declaredType.asElement()).getQualifiedName() + ".class";
+		}
+		return type;
+	}
+
+	private boolean isTypeOf(TypeMirror typeMirror, Class<?> type) {
+		if (type.getCanonicalName().equals(typeMirror.toString()))
+			return true;
+
+		if (typeMirror instanceof DeclaredType == false)
+			return false;
+
+		DeclaredType declaredType = (DeclaredType) typeMirror;
+		Element element = declaredType.asElement();
+		if (element instanceof TypeElement == false)
+			return false;
+
+		TypeElement typeElement = (TypeElement) element;
+		if (type == Enum.class)
+			return typeElement.getKind() == ElementKind.ENUM;
+		
+		TypeMirror superType = typeElement.getSuperclass();
+		if (isTypeOf(superType, type))
+			return true;
+		return false;
+	}
+
+	private boolean checkTableModifiers(TypeElement table) {
+		if (table.getModifiers().contains(Modifier.PRIVATE)) {
+			error("Classes marked with @Table cannot be private", table);
+			return false;
+		}
+
+		if (table.getKind() != ElementKind.CLASS) {
+			error("Only classes can be marked with @Table annotation", table);
+			return false;
+		}
+		
+		if (table.getAnnotation(DoNotGenerate.class) != null)
+			return false;
+
+		return true;
+	}
+
+	private boolean checkColumnModifiers(VariableElement column) {
+
+		if (column.getModifiers().contains(Modifier.PRIVATE)) {
+			error("Field marked with @Column cannot be private", column);
+			return false;
+		}
+
+		if (column.getModifiers().contains(Modifier.FINAL)) {
+			error("Field marked with @Column cannot be final", column);
+			return false;
+		}
+
+		if (column.getModifiers().contains(Modifier.STATIC)) {
+			error("Field marked with @Column cannot be static", column);
+			return false;
+		}
+
+		return true;
+	}
+
+	private void error(String message, Element element) {
+		processingEnv.getMessager().printMessage(Kind.ERROR, message, element);
+	}
+
+	private static String getClassName(TypeElement type, String packageName) {
+		int packageLen = packageName.length() + 1;
+		return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
+	}
+}
diff --git a/src/com/activeandroid/internal/EmptyModelFiller.java b/src/com/activeandroid/sebbia/internal/EmptyModelFiller.java
similarity index 56%
rename from src/com/activeandroid/internal/EmptyModelFiller.java
rename to src/com/activeandroid/sebbia/internal/EmptyModelFiller.java
index a355d1ca..695ac5a1 100644
--- a/src/com/activeandroid/internal/EmptyModelFiller.java
+++ b/src/com/activeandroid/sebbia/internal/EmptyModelFiller.java
@@ -1,9 +1,12 @@
-package com.activeandroid.internal;
+package com.activeandroid.sebbia.internal;
+
+import java.util.Map;
 
 import android.content.ContentValues;
 import android.database.Cursor;
+import android.database.sqlite.SQLiteStatement;
 
-import com.activeandroid.Model;
+import com.activeandroid.sebbia.Model;
 
 public class EmptyModelFiller extends ModelFiller {
 
@@ -18,4 +21,10 @@ public void fillContentValues(Model model, ContentValues contentValues) {
 		if (superModelFiller != null)
 			superModelFiller.fillContentValues(model, contentValues);
 	}
+
+	@Override
+	public void bindStatement(Model model, SQLiteStatement statement, Map<String, Integer> columns) {
+		if (superModelFiller != null)
+			superModelFiller.bindStatement(model, statement, columns);
+	}
 }
diff --git a/src/com/activeandroid/internal/ModelFiller.java b/src/com/activeandroid/sebbia/internal/ModelFiller.java
similarity index 58%
rename from src/com/activeandroid/internal/ModelFiller.java
rename to src/com/activeandroid/sebbia/internal/ModelFiller.java
index 67a80eb2..dd8af96b 100644
--- a/src/com/activeandroid/internal/ModelFiller.java
+++ b/src/com/activeandroid/sebbia/internal/ModelFiller.java
@@ -1,15 +1,20 @@
-package com.activeandroid.internal;
+package com.activeandroid.sebbia.internal;
 
-import com.activeandroid.Model;
+import java.util.Map;
 
-import android.database.Cursor;
 import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteStatement;
 
+import com.activeandroid.sebbia.Model;
 
 public abstract class ModelFiller {
 	public static final String SUFFIX = "$$ActiveAndroidModelFiller";
 	public ModelFiller superModelFiller;
-	
+
 	public abstract void loadFromCursor(Model model, Cursor cursor);
+
 	public abstract void fillContentValues(Model model, ContentValues contentValues);
+
+	public abstract void bindStatement(Model model, SQLiteStatement statement, Map<String, Integer> columns);
 }
diff --git a/src/com/activeandroid/internal/ModelHelper.java b/src/com/activeandroid/sebbia/internal/ModelHelper.java
similarity index 62%
rename from src/com/activeandroid/internal/ModelHelper.java
rename to src/com/activeandroid/sebbia/internal/ModelHelper.java
index 110f0be4..d6a719e6 100644
--- a/src/com/activeandroid/internal/ModelHelper.java
+++ b/src/com/activeandroid/sebbia/internal/ModelHelper.java
@@ -1,14 +1,18 @@
-package com.activeandroid.internal;
+package com.activeandroid.sebbia.internal;
+
+import java.util.Map;
 
 import android.content.ContentValues;
 import android.database.Cursor;
+import android.database.sqlite.SQLiteStatement;
+import android.text.TextUtils;
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
-import com.activeandroid.query.Select;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.sebbia.serializer.TypeSerializer;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.ReflectionUtils;
 
 public class ModelHelper {
 	
@@ -92,6 +96,69 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 		}
 	}
 	
+	public static void setSerializable(SQLiteStatement statement, Map<String, Integer> columns, Class<?> fieldType, Object value, String fieldName) {
+		if (value == null) {
+			return;
+		}
+		
+		TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+		if (typeSerializer == null)
+			return;
+		
+		int columnIndex = columns.get(fieldName);
+		value = typeSerializer.serialize(value);
+		if (value != null) {
+			fieldType = value.getClass();
+			// check that the serializer returned what it promised
+			if (!fieldType.equals(typeSerializer.getSerializedType())) {
+				Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+						typeSerializer.getSerializedType(), fieldType));
+			}
+		}
+		// TODO: Find a smarter way to do this? This if block is necessary because we
+		// can't know the type until runtime.
+		if (value == null) {
+			return;
+		}
+		
+		if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+			statement.bindLong(columnIndex, (Long) value);
+		}
+		else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+			statement.bindLong(columnIndex, (Long) value);
+		}
+		else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+			statement.bindLong(columnIndex, (Long) value);
+		}
+		else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+			statement.bindLong(columnIndex, (Long) value);
+		}
+		else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+			statement.bindDouble(columnIndex, (Double) value);
+		}
+		else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+			statement.bindDouble(columnIndex,  (Double) value);
+		}
+		else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+			statement.bindLong(columnIndex, ((Boolean) value) ? 1L : 0L);
+		}
+		else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+			statement.bindString(columnIndex, value.toString());
+		}
+		else if (fieldType.equals(String.class)) {
+			statement.bindString(columnIndex, (String) value);
+		}
+		else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+			statement.bindBlob(columnIndex, (byte[]) value);
+		}
+		else if (ReflectionUtils.isModel(fieldType)) {
+			statement.bindLong(columnIndex, ((Model) value).getId());
+		}
+		else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+			statement.bindString(columnIndex, ((Enum<?>) value).name());
+		}
+	}
+	
 	@SuppressWarnings("unchecked")
 	public static Object getModel(Cursor cursor, Class<?> fieldType, int columnIndex) {
 		final long entityId = cursor.getLong(columnIndex);
@@ -108,7 +175,10 @@ public static Object getModel(Cursor cursor, Class<?> fieldType, int columnIndex
 	public static Object getEnum(Cursor cursor, Class<?> fieldType, int columnIndex) {
 		@SuppressWarnings("rawtypes")
 		final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-		return Enum.valueOf(enumType, cursor.getString(columnIndex));
+		String enumName = cursor.getString(columnIndex);
+		if (!TextUtils.isEmpty(enumName))
+			return Enum.valueOf(enumType, cursor.getString(columnIndex));
+		return null;
 	}
 	
 	public static Object getValueFromCursor(Cursor cursor, Class<?> fieldType, int columnIndex) {
diff --git a/src/com/activeandroid/model/ManyToManyRelation.java b/src/com/activeandroid/sebbia/model/ManyToManyRelation.java
similarity index 93%
rename from src/com/activeandroid/model/ManyToManyRelation.java
rename to src/com/activeandroid/sebbia/model/ManyToManyRelation.java
index 97bf6b81..469192bb 100644
--- a/src/com/activeandroid/model/ManyToManyRelation.java
+++ b/src/com/activeandroid/sebbia/model/ManyToManyRelation.java
@@ -1,16 +1,18 @@
-package com.activeandroid.model;
+package com.activeandroid.sebbia.model;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
-import com.activeandroid.TableInfo;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.query.Delete;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.SQLiteUtils;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
+import com.activeandroid.sebbia.query.Delete;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.SQLiteUtils;
 
+@DoNotGenerate
 public abstract class ManyToManyRelation<T1 extends Model, T2 extends Model> extends Model {
 
 	@Column (name = "entity1")
diff --git a/src/com/activeandroid/model/OneToManyRelation.java b/src/com/activeandroid/sebbia/model/OneToManyRelation.java
similarity index 61%
rename from src/com/activeandroid/model/OneToManyRelation.java
rename to src/com/activeandroid/sebbia/model/OneToManyRelation.java
index 4a831edc..79bd2367 100644
--- a/src/com/activeandroid/model/OneToManyRelation.java
+++ b/src/com/activeandroid/sebbia/model/OneToManyRelation.java
@@ -1,18 +1,20 @@
-package com.activeandroid.model;
+package com.activeandroid.sebbia.model;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import android.database.Cursor;
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
-import com.activeandroid.TableInfo;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.query.Delete;
-import com.activeandroid.util.Log;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
+import com.activeandroid.sebbia.query.Delete;
+import com.activeandroid.sebbia.util.Log;
 
-public abstract class OneToManyRelation<T1 extends Model> extends Model {
+@DoNotGenerate
+public abstract class OneToManyRelation<T1 extends Model, T2 extends Model> extends Model {
 
 	@Column (name = "entity1")
 	private T1 entity1;
@@ -21,19 +23,19 @@
 	@Column (name = "entity2")
 	private Model entity2;
 
-	public static <T1 extends Model> void setRelations(Class<? extends OneToManyRelation<T1>> relation, T1 entity1, List<Model> entities2) {
+	public static <T1 extends Model, T2 extends Model> void setRelations(Class<? extends OneToManyRelation<T1, T2>> relation, T1 entity1, List<T2> entities2) {
 		if (entity1.getId() == null)
 			throw new IllegalArgumentException(entity1.getClass().getSimpleName() + " is not saved to database yet, aborting");
-		for (Model entity2 : entities2) {
+		for (T2 entity2 : entities2) {
 			if (entity2.getId() == null)
 				throw new IllegalArgumentException(entity2.getClass().getSimpleName() + " is not saved to database yet, aborting");
 		}
 
 		new Delete().from(relation).where("entity1 = ?", entity1.getId()).execute();
 		try {
-			ArrayList<OneToManyRelation<T1>> connections = new ArrayList<OneToManyRelation<T1>>();
-			for (Model entity2 : entities2) {
-				OneToManyRelation<T1> connection = relation.newInstance();
+			List<OneToManyRelation<T1, T2>> connections = new ArrayList<OneToManyRelation<T1, T2>>();
+			for (T2 entity2 : entities2) {
+				OneToManyRelation<T1, T2> connection = relation.newInstance();
 				connection.entity1 = entity1;
 				connection.entity2Type = entity2.getClass().getCanonicalName();
 				connection.entity2 = entity2;
@@ -46,20 +48,20 @@
 		}
 	}
 
-	public static <T1 extends Model> List<Model> getRelations(Class<? extends OneToManyRelation<T1>> relation, T1 entity) {
+	@SuppressWarnings("unchecked")
+	public static <T1 extends Model, T2 extends Model> List<T2> getRelations(Class<? extends OneToManyRelation<T1, T2>> relation, T1 entity) {
 		if (entity.getId() == null)
 			throw new IllegalArgumentException(entity.getClass().getSimpleName() + " is not saved to database yet, aborting");
 
 		TableInfo crossTableInfo = Cache.getTableInfo(relation);
 		Cursor cursor = Cache.openDatabase().rawQuery("SELECT entity2Type, entity2 FROM " + crossTableInfo.getTableName() + " WHERE entity1 = ?", new String[] {entity.getId().toString()});
-		final List<Model> entities = new ArrayList<Model>();
+		final List<T2> entities = new ArrayList<T2>();
 		try {
 			if (cursor.moveToFirst()) {
 				do {
 					String typeName = cursor.getString(0);
-					@SuppressWarnings("unchecked")
 					Class<? extends Model> entity2Class = (Class<? extends Model>) Class.forName(typeName);
-					entities.add(Model.load(entity2Class, cursor.getLong(1)));
+					entities.add((T2) Model.load(entity2Class, cursor.getLong(1)));
 				}
 				while (cursor.moveToNext());
 			}
diff --git a/src/com/activeandroid/query/Delete.java b/src/com/activeandroid/sebbia/query/Delete.java
similarity index 91%
rename from src/com/activeandroid/query/Delete.java
rename to src/com/activeandroid/sebbia/query/Delete.java
index 6d19dced..61fe2336 100644
--- a/src/com/activeandroid/query/Delete.java
+++ b/src/com/activeandroid/sebbia/query/Delete.java
@@ -1,4 +1,4 @@
-package com.activeandroid.query;
+package com.activeandroid.sebbia.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.Model;
+import com.activeandroid.sebbia.Model;
 
 public final class Delete implements Sqlable {
 	public Delete() {
diff --git a/src/com/activeandroid/query/From.java b/src/com/activeandroid/sebbia/query/From.java
similarity index 96%
rename from src/com/activeandroid/query/From.java
rename to src/com/activeandroid/sebbia/query/From.java
index ab3837a9..80289f65 100644
--- a/src/com/activeandroid/query/From.java
+++ b/src/com/activeandroid/sebbia/query/From.java
@@ -1,4 +1,4 @@
-package com.activeandroid.query;
+package com.activeandroid.sebbia.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -18,12 +18,12 @@
 
 import android.text.TextUtils;
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
-import com.activeandroid.content.ContentProvider;
-import com.activeandroid.query.Join.JoinType;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.SQLiteUtils;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.content.ContentProvider;
+import com.activeandroid.sebbia.query.Join.JoinType;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.SQLiteUtils;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/src/com/activeandroid/query/Join.java b/src/com/activeandroid/sebbia/query/Join.java
similarity index 94%
rename from src/com/activeandroid/query/Join.java
rename to src/com/activeandroid/sebbia/query/Join.java
index 13cdba3b..c818616a 100644
--- a/src/com/activeandroid/query/Join.java
+++ b/src/com/activeandroid/sebbia/query/Join.java
@@ -1,4 +1,4 @@
-package com.activeandroid.query;
+package com.activeandroid.sebbia.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -18,8 +18,8 @@
 
 import android.text.TextUtils;
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
 
 public final class Join implements Sqlable {
 	static enum JoinType {
diff --git a/src/com/activeandroid/query/Select.java b/src/com/activeandroid/sebbia/query/Select.java
similarity index 95%
rename from src/com/activeandroid/query/Select.java
rename to src/com/activeandroid/sebbia/query/Select.java
index 1d4c6488..43e216e1 100644
--- a/src/com/activeandroid/query/Select.java
+++ b/src/com/activeandroid/sebbia/query/Select.java
@@ -1,4 +1,4 @@
-package com.activeandroid.query;
+package com.activeandroid.sebbia.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -18,7 +18,7 @@
 
 import android.text.TextUtils;
 
-import com.activeandroid.Model;
+import com.activeandroid.sebbia.Model;
 
 public final class Select implements Sqlable {
 	private String[] mColumns;
diff --git a/src/com/activeandroid/query/Set.java b/src/com/activeandroid/sebbia/query/Set.java
similarity index 96%
rename from src/com/activeandroid/query/Set.java
rename to src/com/activeandroid/sebbia/query/Set.java
index 183d99f0..6c865f56 100644
--- a/src/com/activeandroid/query/Set.java
+++ b/src/com/activeandroid/sebbia/query/Set.java
@@ -1,4 +1,4 @@
-package com.activeandroid.query;
+package com.activeandroid.sebbia.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.util.SQLiteUtils;
+import com.activeandroid.sebbia.util.SQLiteUtils;
 
 import java.util.ArrayList;
 import java.util.Arrays;
diff --git a/src/com/activeandroid/query/Sqlable.java b/src/com/activeandroid/sebbia/query/Sqlable.java
similarity index 94%
rename from src/com/activeandroid/query/Sqlable.java
rename to src/com/activeandroid/sebbia/query/Sqlable.java
index 2c3f5d43..64c4cff5 100644
--- a/src/com/activeandroid/query/Sqlable.java
+++ b/src/com/activeandroid/sebbia/query/Sqlable.java
@@ -1,4 +1,4 @@
-package com.activeandroid.query;
+package com.activeandroid.sebbia.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/query/Update.java b/src/com/activeandroid/sebbia/query/Update.java
similarity index 90%
rename from src/com/activeandroid/query/Update.java
rename to src/com/activeandroid/sebbia/query/Update.java
index a69d2d8e..8eb2932a 100644
--- a/src/com/activeandroid/query/Update.java
+++ b/src/com/activeandroid/sebbia/query/Update.java
@@ -1,4 +1,4 @@
-package com.activeandroid.query;
+package com.activeandroid.sebbia.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,8 +16,8 @@
  * limitations under the License.
  */
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
 
 public final class Update implements Sqlable {
 	private Class<? extends Model> mType;
diff --git a/src/com/activeandroid/serializer/BigDecimalSerializer.java b/src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
similarity index 91%
rename from src/com/activeandroid/serializer/BigDecimalSerializer.java
rename to src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
index 333f900f..1b398742 100644
--- a/src/com/activeandroid/serializer/BigDecimalSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.serializer;
+package com.activeandroid.sebbia.serializer;
 
 import java.math.BigDecimal;
 
diff --git a/src/com/activeandroid/serializer/CalendarSerializer.java b/src/com/activeandroid/sebbia/serializer/CalendarSerializer.java
similarity index 95%
rename from src/com/activeandroid/serializer/CalendarSerializer.java
rename to src/com/activeandroid/sebbia/serializer/CalendarSerializer.java
index 55509bd0..6cd2068e 100644
--- a/src/com/activeandroid/serializer/CalendarSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/CalendarSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.serializer;
+package com.activeandroid.sebbia.serializer;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/serializer/FileSerializer.java b/src/com/activeandroid/sebbia/serializer/FileSerializer.java
similarity index 95%
rename from src/com/activeandroid/serializer/FileSerializer.java
rename to src/com/activeandroid/sebbia/serializer/FileSerializer.java
index 0aed072c..0d15a76d 100644
--- a/src/com/activeandroid/serializer/FileSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/FileSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.serializer;
+package com.activeandroid.sebbia.serializer;
 
 import java.io.File;
 
diff --git a/src/com/activeandroid/serializer/SqlDateSerializer.java b/src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
similarity index 95%
rename from src/com/activeandroid/serializer/SqlDateSerializer.java
rename to src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
index 530d1249..ad6a995b 100644
--- a/src/com/activeandroid/serializer/SqlDateSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.serializer;
+package com.activeandroid.sebbia.serializer;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/serializer/TypeSerializer.java b/src/com/activeandroid/sebbia/serializer/TypeSerializer.java
similarity index 94%
rename from src/com/activeandroid/serializer/TypeSerializer.java
rename to src/com/activeandroid/sebbia/serializer/TypeSerializer.java
index af0a21de..eb326146 100644
--- a/src/com/activeandroid/serializer/TypeSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/TypeSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.serializer;
+package com.activeandroid.sebbia.serializer;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/serializer/UUIDSerializer.java b/src/com/activeandroid/sebbia/serializer/UUIDSerializer.java
similarity index 90%
rename from src/com/activeandroid/serializer/UUIDSerializer.java
rename to src/com/activeandroid/sebbia/serializer/UUIDSerializer.java
index 94ba37ff..2942c130 100644
--- a/src/com/activeandroid/serializer/UUIDSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/UUIDSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.serializer;
+package com.activeandroid.sebbia.serializer;
 
 import java.util.UUID;
 
diff --git a/src/com/activeandroid/serializer/UtilDateSerializer.java b/src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
similarity index 95%
rename from src/com/activeandroid/serializer/UtilDateSerializer.java
rename to src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
index a82c7ef1..cf3a1423 100644
--- a/src/com/activeandroid/serializer/UtilDateSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.serializer;
+package com.activeandroid.sebbia.serializer;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/util/IOUtils.java b/src/com/activeandroid/sebbia/util/IOUtils.java
similarity index 95%
rename from src/com/activeandroid/util/IOUtils.java
rename to src/com/activeandroid/sebbia/util/IOUtils.java
index b3005f85..d4b059b8 100644
--- a/src/com/activeandroid/util/IOUtils.java
+++ b/src/com/activeandroid/sebbia/util/IOUtils.java
@@ -1,5 +1,5 @@
 
-package com.activeandroid.util;
+package com.activeandroid.sebbia.util;
 
 /*
  * Copyright (C) 2014 Markus Pfeiffer
@@ -22,7 +22,7 @@
 import java.io.Closeable;
 import java.io.IOException;
 
-import com.activeandroid.util.Log;
+import com.activeandroid.sebbia.util.Log;
 
 
 public class IOUtils {
diff --git a/src/com/activeandroid/util/Log.java b/src/com/activeandroid/sebbia/util/Log.java
similarity index 94%
rename from src/com/activeandroid/util/Log.java
rename to src/com/activeandroid/sebbia/util/Log.java
index 3c40a23f..c8f28af6 100644
--- a/src/com/activeandroid/util/Log.java
+++ b/src/com/activeandroid/sebbia/util/Log.java
@@ -1,4 +1,4 @@
-package com.activeandroid.util;
+package com.activeandroid.sebbia.util;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/util/NaturalOrderComparator.java b/src/com/activeandroid/sebbia/util/NaturalOrderComparator.java
similarity index 94%
rename from src/com/activeandroid/util/NaturalOrderComparator.java
rename to src/com/activeandroid/sebbia/util/NaturalOrderComparator.java
index 3e44af96..2fa9acf6 100644
--- a/src/com/activeandroid/util/NaturalOrderComparator.java
+++ b/src/com/activeandroid/sebbia/util/NaturalOrderComparator.java
@@ -1,4 +1,4 @@
-package com.activeandroid.util;
+package com.activeandroid.sebbia.util;
 
 /*
  NaturalOrderComparator.java -- Perform 'natural order' comparisons of strings in Java.
diff --git a/src/com/activeandroid/util/ReflectionUtils.java b/src/com/activeandroid/sebbia/util/ReflectionUtils.java
similarity index 94%
rename from src/com/activeandroid/util/ReflectionUtils.java
rename to src/com/activeandroid/sebbia/util/ReflectionUtils.java
index a5306856..18d64207 100644
--- a/src/com/activeandroid/util/ReflectionUtils.java
+++ b/src/com/activeandroid/sebbia/util/ReflectionUtils.java
@@ -1,4 +1,4 @@
-package com.activeandroid.util;
+package com.activeandroid.sebbia.util;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -27,9 +27,9 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.serializer.TypeSerializer;
 
 public final class ReflectionUtils {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/sebbia/util/SQLiteUtils.java
similarity index 84%
rename from src/com/activeandroid/util/SQLiteUtils.java
rename to src/com/activeandroid/sebbia/util/SQLiteUtils.java
index c4b54550..85570058 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/sebbia/util/SQLiteUtils.java
@@ -1,443 +1,488 @@
-package com.activeandroid.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import android.database.Cursor;
-import android.os.Build;
-import android.text.TextUtils;
-
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
-import com.activeandroid.TableInfo;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Column.ConflictAction;
-import com.activeandroid.serializer.TypeSerializer;
-
-public final class SQLiteUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// ENUMERATIONS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public enum SQLiteType {
-		INTEGER, REAL, TEXT, BLOB
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONTSANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
-		{
-			put(byte.class, SQLiteType.INTEGER);
-			put(short.class, SQLiteType.INTEGER);
-			put(int.class, SQLiteType.INTEGER);
-			put(long.class, SQLiteType.INTEGER);
-			put(float.class, SQLiteType.REAL);
-			put(double.class, SQLiteType.REAL);
-			put(boolean.class, SQLiteType.INTEGER);
-			put(char.class, SQLiteType.TEXT);
-			put(byte[].class, SQLiteType.BLOB);
-			put(Byte.class, SQLiteType.INTEGER);
-			put(Short.class, SQLiteType.INTEGER);
-			put(Integer.class, SQLiteType.INTEGER);
-			put(Long.class, SQLiteType.INTEGER);
-			put(Float.class, SQLiteType.REAL);
-			put(Double.class, SQLiteType.REAL);
-			put(Boolean.class, SQLiteType.INTEGER);
-			put(Character.class, SQLiteType.TEXT);
-			put(String.class, SQLiteType.TEXT);
-			put(Byte[].class, SQLiteType.BLOB);
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static HashMap<String, List<String>> sIndexGroupMap;
-	private static HashMap<String, List<String>> sUniqueGroupMap;
-	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void execSql(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSql(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-
-	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-		List<T> entities = processCursor(type, cursor);
-		cursor.close();
-
-		return entities;
-	}
-	  
-	public static int intQuery(final String sql, final String[] selectionArgs) {
-        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-        final int number = processIntCursor(cursor);
-        cursor.close();
-
-        return number;
-	}
-
-	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		List<T> entities = rawQuery(type, sql, selectionArgs);
-
-		if (entities.size() > 0) {
-			return entities.get(0);
-		}
-
-		return null;
-	}
-
-	// Database creation
-
-	public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sUniqueGroupMap = new HashMap<String, List<String>>();
-		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
-
-		for (Field field : tableInfo.getFields()) {
-			createUniqueColumnDefinition(tableInfo, field);
-		}
-
-		if (sUniqueGroupMap.isEmpty()) {
-			return definitions;
-		}
-
-		Set<String> keySet = sUniqueGroupMap.keySet();
-		for (String key : keySet) {
-			List<String> group = sUniqueGroupMap.get(key);
-			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
-
-			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
-					TextUtils.join(", ", group), conflictAction.toString()));
-		}
-
-		return definitions;
-	}
-
-	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
-
-        if (field.getName().equals("mId")) {
-            return;
-        }
-
-		String[] groups = column.uniqueGroups();
-		ConflictAction[] conflictActions = column.onUniqueConflicts();
-		if (groups.length != conflictActions.length)
-			return;
-
-		for (int i = 0; i < groups.length; i++) {
-			String group = groups[i];
-			ConflictAction conflictAction = conflictActions[i];
-
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sUniqueGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-			list.add(name);
-
-			sUniqueGroupMap.put(group, list);
-			sOnUniqueConflictsMap.put(group, conflictAction);
-		}
-	}
-
-	public static String[] createIndexDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sIndexGroupMap = new HashMap<String, List<String>>();
-
-		for (Field field : tableInfo.getFields()) {
-			createIndexColumnDefinition(tableInfo, field);
-		}
-
-		if (sIndexGroupMap.isEmpty()) {
-			return new String[0];
-		}
-
-		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
-			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
-					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
-					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
-		}
-
-		return definitions.toArray(new String[definitions.size()]);
-	}
-
-	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
-
-        if (field.getName().equals("mId")) {
-            return;
-        }
-
-		if (column.index()) {
-			List<String> list = new ArrayList<String>();
-			list.add(name);
-			sIndexGroupMap.put(name, list);
-		}
-
-		String[] groups = column.indexGroups();
-		for (String group : groups) {
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sIndexGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-
-			list.add(name);
-			sIndexGroupMap.put(group, list);
-		}
-	}
-
-	public static String createTableDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-
-		for (Field field : tableInfo.getFields()) {
-			String definition = createColumnDefinition(tableInfo, field);
-			if (!TextUtils.isEmpty(definition)) {
-				definitions.add(definition);
-			}
-		}
-
-		definitions.addAll(createUniqueDefinition(tableInfo));
-
-		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
-				TextUtils.join(", ", definitions));
-	}
-
-	@SuppressWarnings("unchecked")
-	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
-		StringBuilder definition = new StringBuilder();
-
-		Class<?> type = field.getType();
-		final String name = tableInfo.getColumnName(field);
-		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-		final Column column = field.getAnnotation(Column.class);
-
-		if (typeSerializer != null) {
-			type = typeSerializer.getSerializedType();
-		}
-		
-		SQLiteType sqLiteType = null;
-		if (TYPE_MAP.containsKey(type)) {
-			sqLiteType = TYPE_MAP.get(type);
-		}
-		else if (ReflectionUtils.isModel(type)) {
-			sqLiteType = SQLiteType.INTEGER;
-		}
-		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
-			sqLiteType = SQLiteType.TEXT;
-		}
-		
-		if (sqLiteType != null) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(sqLiteType.toString());
-		}
-
-		if (!TextUtils.isEmpty(definition)) {
-
-			if (name.equals(tableInfo.getIdName())) {
-				definition.append(" PRIMARY KEY AUTOINCREMENT");
-			}else if(column!=null){
-				if (column.length() > -1) {
-					definition.append("(");
-					definition.append(column.length());
-					definition.append(")");
-				}
-
-				if (column.notNull()) {
-					definition.append(" NOT NULL ON CONFLICT ");
-					definition.append(column.onNullConflict().toString());
-				}
-
-				if (column.unique()) {
-					definition.append(" UNIQUE ON CONFLICT ");
-					definition.append(column.onUniqueConflict().toString());
-				}
-				
-				if (!TextUtils.isEmpty(column.defaultValue())) {
-					String defaultValue = null;
-					switch (sqLiteType) {
-					case TEXT: case BLOB:
-						defaultValue = "\"" + column.defaultValue() + "\"";
-						break;
-
-					case INTEGER:
-						try {
-							if (type.equals(Boolean.class) || type.equals(boolean.class)) {
-								boolean value = Boolean.parseBoolean(column.defaultValue());
-								defaultValue = value ? "1" : "0";
-							} else {
-								Integer.parseInt(column.defaultValue());
-								defaultValue = column.defaultValue();
-							}
-						} catch (NumberFormatException e) {
-							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
-						}
-						break;
-						
-					case REAL:
-						try {
-							Double.parseDouble(column.defaultValue());
-							defaultValue = column.defaultValue();
-						} catch (NumberFormatException e) {
-							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
-						}
-						break;
-					}
-					
-					if (defaultValue != null) {
-						definition.append(" DEFAULT ");
-						definition.append(defaultValue);
-					}
-				}
-			}
-
-			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type) && Cache.getTableInfo((Class<? extends Model>) type) != null) {
-				definition.append(" REFERENCES ");
-				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
-				definition.append("("+tableInfo.getIdName()+")");
-				definition.append(" ON DELETE ");
-				definition.append(column.onDelete().toString().replace("_", " "));
-				definition.append(" ON UPDATE ");
-				definition.append(column.onUpdate().toString().replace("_", " "));
-			}
-		
-		}
-		else {
-			Log.e("No type mapping for: " + type.toString());
-		}
-
-		return definition.toString();
-	}
-
-	@SuppressWarnings("unchecked")
-	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		String idName = tableInfo.getIdName();
-		final List<T> entities = new ArrayList<T>();
-
-		try {
-			Constructor<?> entityConstructor = type.getConstructor();
-
-			if (cursor.moveToFirst()) {
-                /**
-                 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-                 * when the cursor have multiple columns with same name obtained from join tables.
-                 */
-                List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-				do {
-					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
-					if (entity == null) {
-						entity = (T) entityConstructor.newInstance();
-					}
-
-					entity.loadFromCursor(cursor);
-					entities.add((T) entity);
-				}
-				while (cursor.moveToNext());
-			}
-
-		}
-		catch (NoSuchMethodException e) {
-			throw new RuntimeException(
-                "Your model " + type.getName() + " does not define a default " +
-                "constructor. The default constructor is required for " +
-                "now in ActiveAndroid models, as the process to " +
-                "populate the ORM model is : " +
-                "1. instantiate default model " +
-                "2. populate fields"
-            );
-		}
-		catch (Exception e) {
-			Log.e("Failed to process cursor.", e);
-		}
-
-		return entities;
-	}
-
-	private static int processIntCursor(final Cursor cursor) {
-        if (cursor.moveToFirst()) {
-            return cursor.getInt(0);
-	    }
-        return 0;
-    }
-
-	public static List<String> lexSqlScript(String sqlScript) {
-		ArrayList<String> sl = new ArrayList<String>();
-		boolean inString = false, quoteNext = false;
-		StringBuilder b = new StringBuilder(100);
-
-		for (int i = 0; i < sqlScript.length(); i++) {
-			char c = sqlScript.charAt(i);
-
-			if (c == ';' && !inString && !quoteNext) {
-				sl.add(b.toString());
-				b = new StringBuilder(100);
-				inString = false;
-				quoteNext = false;
-				continue;
-			}
-
-			if (c == '\'' && !quoteNext) {
-				inString = !inString;
-			}
-
-			quoteNext = c == '\\' && !quoteNext;
-
-			b.append(c);
-		}
-
-		if (b.length() > 0) {
-			sl.add(b.toString());
-		}
-
-		return sl;
-	}
-}
+package com.activeandroid.sebbia.util;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import android.database.Cursor;
+import android.os.Build;
+import android.text.TextUtils;
+
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Column.ConflictAction;
+import com.activeandroid.sebbia.serializer.TypeSerializer;
+
+public final class SQLiteUtils {
+	//////////////////////////////////////////////////////////////////////////////////////
+	// ENUMERATIONS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public enum SQLiteType {
+		INTEGER, REAL, TEXT, BLOB
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC CONSTANTS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE CONTSANTS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	@SuppressWarnings("serial")
+	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
+		{
+			put(byte.class, SQLiteType.INTEGER);
+			put(short.class, SQLiteType.INTEGER);
+			put(int.class, SQLiteType.INTEGER);
+			put(long.class, SQLiteType.INTEGER);
+			put(float.class, SQLiteType.REAL);
+			put(double.class, SQLiteType.REAL);
+			put(boolean.class, SQLiteType.INTEGER);
+			put(char.class, SQLiteType.TEXT);
+			put(byte[].class, SQLiteType.BLOB);
+			put(Byte.class, SQLiteType.INTEGER);
+			put(Short.class, SQLiteType.INTEGER);
+			put(Integer.class, SQLiteType.INTEGER);
+			put(Long.class, SQLiteType.INTEGER);
+			put(Float.class, SQLiteType.REAL);
+			put(Double.class, SQLiteType.REAL);
+			put(Boolean.class, SQLiteType.INTEGER);
+			put(Character.class, SQLiteType.TEXT);
+			put(String.class, SQLiteType.TEXT);
+			put(Byte[].class, SQLiteType.BLOB);
+		}
+	};
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE MEMBERS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private static HashMap<String, List<String>> sIndexGroupMap;
+	private static HashMap<String, List<String>> sUniqueGroupMap;
+	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public static void execSql(String sql) {
+		Cache.openDatabase().execSQL(sql);
+	}
+
+	public static void execSql(String sql, Object[] bindArgs) {
+		Cache.openDatabase().execSQL(sql, bindArgs);
+	}
+
+	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
+		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+		List<T> entities = processCursor(type, cursor);
+		cursor.close();
+
+		return entities;
+	}
+	  
+	public static int intQuery(final String sql, final String[] selectionArgs) {
+        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+        final int number = processIntCursor(cursor);
+        cursor.close();
+
+        return number;
+	}
+
+	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
+		List<T> entities = rawQuery(type, sql, selectionArgs);
+
+		if (entities.size() > 0) {
+			return entities.get(0);
+		}
+
+		return null;
+	}
+
+	// Database creation
+
+	public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
+		final ArrayList<String> definitions = new ArrayList<String>();
+		sUniqueGroupMap = new HashMap<String, List<String>>();
+		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
+
+		for (Field field : tableInfo.getFields()) {
+			createUniqueColumnDefinition(tableInfo, field);
+		}
+
+		if (sUniqueGroupMap.isEmpty()) {
+			return definitions;
+		}
+
+		Set<String> keySet = sUniqueGroupMap.keySet();
+		for (String key : keySet) {
+			List<String> group = sUniqueGroupMap.get(key);
+			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
+
+			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
+					TextUtils.join(", ", group), conflictAction.toString()));
+		}
+
+		return definitions;
+	}
+
+	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
+		final String name = tableInfo.getColumnName(field);
+		final Column column = field.getAnnotation(Column.class);
+
+        if (field.getName().equals("mId")) {
+            return;
+        }
+
+		String[] groups = column.uniqueGroups();
+		ConflictAction[] conflictActions = column.onUniqueConflicts();
+		if (groups.length != conflictActions.length)
+			return;
+
+		for (int i = 0; i < groups.length; i++) {
+			String group = groups[i];
+			ConflictAction conflictAction = conflictActions[i];
+
+			if (TextUtils.isEmpty(group))
+				continue;
+
+			List<String> list = sUniqueGroupMap.get(group);
+			if (list == null) {
+				list = new ArrayList<String>();
+			}
+			list.add(name);
+
+			sUniqueGroupMap.put(group, list);
+			sOnUniqueConflictsMap.put(group, conflictAction);
+		}
+	}
+
+	public static String[] createIndexDefinition(TableInfo tableInfo) {
+		final ArrayList<String> definitions = new ArrayList<String>();
+		sIndexGroupMap = new HashMap<String, List<String>>();
+
+		for (Field field : tableInfo.getFields()) {
+			createIndexColumnDefinition(tableInfo, field);
+		}
+
+		if (sIndexGroupMap.isEmpty()) {
+			return new String[0];
+		}
+
+		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
+			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
+					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
+					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
+		}
+
+		return definitions.toArray(new String[definitions.size()]);
+	}
+
+	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
+		final String name = tableInfo.getColumnName(field);
+		final Column column = field.getAnnotation(Column.class);
+
+        if (field.getName().equals("mId")) {
+            return;
+        }
+
+		if (column.index()) {
+			List<String> list = new ArrayList<String>();
+			list.add(name);
+			sIndexGroupMap.put(name, list);
+		}
+
+		String[] groups = column.indexGroups();
+		for (String group : groups) {
+			if (TextUtils.isEmpty(group))
+				continue;
+
+			List<String> list = sIndexGroupMap.get(group);
+			if (list == null) {
+				list = new ArrayList<String>();
+			}
+
+			list.add(name);
+			sIndexGroupMap.put(group, list);
+		}
+	}
+
+	public static String createTableDefinition(TableInfo tableInfo) {
+		final ArrayList<String> definitions = new ArrayList<String>();
+
+		for (Field field : tableInfo.getFields()) {
+			String definition = createColumnDefinition(tableInfo, field);
+			if (!TextUtils.isEmpty(definition)) {
+				definitions.add(definition);
+			}
+		}
+
+		definitions.addAll(createUniqueDefinition(tableInfo));
+
+		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
+				TextUtils.join(", ", definitions));
+	}
+
+	@SuppressWarnings("unchecked")
+	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
+		StringBuilder definition = new StringBuilder();
+
+		Class<?> type = field.getType();
+		final String name = tableInfo.getColumnName(field);
+		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
+		final Column column = field.getAnnotation(Column.class);
+
+		if (typeSerializer != null) {
+			type = typeSerializer.getSerializedType();
+		}
+		
+		SQLiteType sqLiteType = null;
+		if (TYPE_MAP.containsKey(type)) {
+			sqLiteType = TYPE_MAP.get(type);
+		}
+		else if (ReflectionUtils.isModel(type)) {
+			sqLiteType = SQLiteType.INTEGER;
+		}
+		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
+			sqLiteType = SQLiteType.TEXT;
+		}
+		
+		if (sqLiteType != null) {
+			definition.append(name);
+			definition.append(" ");
+			definition.append(sqLiteType.toString());
+		}
+
+		if (!TextUtils.isEmpty(definition)) {
+
+			if (name.equals(tableInfo.getIdName())) {
+				definition.append(" PRIMARY KEY AUTOINCREMENT");
+			}else if(column!=null){
+				if (column.length() > -1) {
+					definition.append("(");
+					definition.append(column.length());
+					definition.append(")");
+				}
+
+				if (column.notNull()) {
+					definition.append(" NOT NULL ON CONFLICT ");
+					definition.append(column.onNullConflict().toString());
+				}
+
+				if (column.unique()) {
+					definition.append(" UNIQUE ON CONFLICT ");
+					definition.append(column.onUniqueConflict().toString());
+				}
+				
+				if (!TextUtils.isEmpty(column.defaultValue())) {
+					String defaultValue = null;
+					switch (sqLiteType) {
+					case TEXT: case BLOB:
+						defaultValue = "\"" + column.defaultValue() + "\"";
+						break;
+
+					case INTEGER:
+						try {
+							if (type.equals(Boolean.class) || type.equals(boolean.class)) {
+								boolean value = Boolean.parseBoolean(column.defaultValue());
+								defaultValue = value ? "1" : "0";
+							} else {
+								Integer.parseInt(column.defaultValue());
+								defaultValue = column.defaultValue();
+							}
+						} catch (NumberFormatException e) {
+							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
+						}
+						break;
+						
+					case REAL:
+						try {
+							Double.parseDouble(column.defaultValue());
+							defaultValue = column.defaultValue();
+						} catch (NumberFormatException e) {
+							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
+						}
+						break;
+					}
+					
+					if (defaultValue != null) {
+						definition.append(" DEFAULT ");
+						definition.append(defaultValue);
+					}
+				}
+			}
+
+			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type) && Cache.getTableInfo((Class<? extends Model>) type) != null) {
+				definition.append(" REFERENCES ");
+				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
+				definition.append("("+tableInfo.getIdName()+")");
+				definition.append(" ON DELETE ");
+				definition.append(column.onDelete().toString().replace("_", " "));
+				definition.append(" ON UPDATE ");
+				definition.append(column.onUpdate().toString().replace("_", " "));
+			}
+		
+		}
+		else {
+			Log.e("No type mapping for: " + type.toString());
+		}
+
+		return definition.toString();
+	}
+
+	@SuppressWarnings("unchecked")
+	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
+		TableInfo tableInfo = Cache.getTableInfo(type);
+		String idName = tableInfo.getIdName();
+		final List<T> entities = new ArrayList<T>();
+
+		try {
+			Constructor<?> entityConstructor = type.getConstructor();
+
+			if (cursor.moveToFirst()) {
+                /**
+                 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+                 * when the cursor have multiple columns with same name obtained from join tables.
+                 */
+                List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+				do {
+					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
+					if (entity == null) {
+						entity = (T) entityConstructor.newInstance();
+					}
+
+					entity.loadFromCursor(cursor);
+					entities.add((T) entity);
+				}
+				while (cursor.moveToNext());
+			}
+
+		}
+		catch (NoSuchMethodException e) {
+			throw new RuntimeException(
+                "Your model " + type.getName() + " does not define a default " +
+                "constructor. The default constructor is required for " +
+                "now in ActiveAndroid models, as the process to " +
+                "populate the ORM model is : " +
+                "1. instantiate default model " +
+                "2. populate fields"
+            );
+		}
+		catch (Exception e) {
+			Log.e("Failed to process cursor.", e);
+		}
+
+		return entities;
+	}
+
+	private static int processIntCursor(final Cursor cursor) {
+        if (cursor.moveToFirst()) {
+            return cursor.getInt(0);
+	    }
+        return 0;
+    }
+
+	public static List<String> lexSqlScript(String sqlScript) {
+		ArrayList<String> sl = new ArrayList<String>();
+		boolean inString = false, quoteNext = false;
+		StringBuilder b = new StringBuilder(100);
+
+		for (int i = 0; i < sqlScript.length(); i++) {
+			char c = sqlScript.charAt(i);
+
+			if (c == ';' && !inString && !quoteNext) {
+				sl.add(b.toString());
+				b = new StringBuilder(100);
+				inString = false;
+				quoteNext = false;
+				continue;
+			}
+
+			if (c == '\'' && !quoteNext) {
+				inString = !inString;
+			}
+
+			quoteNext = c == '\\' && !quoteNext;
+
+			b.append(c);
+		}
+
+		if (b.length() > 0) {
+			sl.add(b.toString());
+		}
+
+		return sl;
+	}
+	
+	public static String createInsertStatement(String insertInto, TableInfo tableInfo) {
+		StringBuilder stringBuilder = new StringBuilder(insertInto);
+		stringBuilder
+			.append(tableInfo.getTableName())
+			.append(" (");
+			appendColumns(stringBuilder, tableInfo.getColumnNames(), false)
+			.append(") VALUES (");
+		appendPlaceholders(stringBuilder, tableInfo.getFields().size());
+		stringBuilder.append(")");
+		return stringBuilder.toString();
+	}
+	
+	public static String createUpdateStatement(TableInfo tableInfo) {
+		StringBuilder stringBuilder = new StringBuilder("UPDATE ");
+		stringBuilder
+			.append(tableInfo.getTableName())
+			.append(" SET ");
+		appendColumns(stringBuilder, tableInfo.getColumnNames(), true)
+			.append(" WHERE ");
+		appendColumn(stringBuilder, tableInfo.getIdName())
+			.append(" = ?");
+		return stringBuilder.toString();
+	}
+	
+	private static StringBuilder appendColumns(StringBuilder stringBuilder, Collection<String> columns, boolean addEqPlaceholder) {
+		String divider = addEqPlaceholder ? " =?, " : ", ";
+		Iterator<String> iterator = columns.iterator();
+		while (iterator.hasNext())
+			appendColumn(stringBuilder, iterator.next()).append(iterator.hasNext() ? divider : "");
+		return stringBuilder;
+	}
+	
+	private static StringBuilder appendColumn(StringBuilder stringBuilder, String column) {
+		return stringBuilder.append("'").append(column).append("\'");
+	}
+	
+	private static StringBuilder appendPlaceholders(StringBuilder stringBuilder, int count) {
+		for (int i = 0; i < count; ++i)
+			stringBuilder.append("?").append(i == count - 1 ? "" : ", ");
+		return stringBuilder;
+	}
+
+}
diff --git a/src/com/activeandroid/util/SqlParser.java b/src/com/activeandroid/sebbia/util/SqlParser.java
similarity index 98%
rename from src/com/activeandroid/util/SqlParser.java
rename to src/com/activeandroid/sebbia/util/SqlParser.java
index f9531b7c..f34fce8d 100644
--- a/src/com/activeandroid/util/SqlParser.java
+++ b/src/com/activeandroid/sebbia/util/SqlParser.java
@@ -1,5 +1,5 @@
 
-package com.activeandroid.util;
+package com.activeandroid.sebbia.util;
 
 /*
  * Copyright (C) 2014 Markus Pfeiffer
diff --git a/src/com/activeandroid/util/Tokenizer.java b/src/com/activeandroid/sebbia/util/Tokenizer.java
similarity index 97%
rename from src/com/activeandroid/util/Tokenizer.java
rename to src/com/activeandroid/sebbia/util/Tokenizer.java
index 8ae34da3..af52c68f 100644
--- a/src/com/activeandroid/util/Tokenizer.java
+++ b/src/com/activeandroid/sebbia/util/Tokenizer.java
@@ -1,5 +1,5 @@
 
-package com.activeandroid.util;
+package com.activeandroid.sebbia.util;
 
 /*
  * Copyright (C) 2014 Markus Pfeiffer
diff --git a/src/com/activeandroid/widget/ModelAdapter.java b/src/com/activeandroid/sebbia/widget/ModelAdapter.java
similarity index 94%
rename from src/com/activeandroid/widget/ModelAdapter.java
rename to src/com/activeandroid/sebbia/widget/ModelAdapter.java
index a3895763..bb8b2b57 100644
--- a/src/com/activeandroid/widget/ModelAdapter.java
+++ b/src/com/activeandroid/sebbia/widget/ModelAdapter.java
@@ -1,4 +1,4 @@
-package com.activeandroid.widget;
+package com.activeandroid.sebbia.widget;
 
 import java.util.Collection;
 import java.util.List;
@@ -6,7 +6,7 @@
 import android.content.Context;
 import android.widget.ArrayAdapter;
 
-import com.activeandroid.Model;
+import com.activeandroid.sebbia.Model;
 
 public class ModelAdapter<T extends Model> extends ArrayAdapter<T> {
 	public ModelAdapter(Context context, int textViewResourceId) {
diff --git a/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
index 9a72e581..67358b71 100644
--- a/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -1 +1 @@
-com.activeandroid.internal.AnnotationProcessor
\ No newline at end of file
+com.activeandroid.sebbia.internal.AnnotationProcessor
\ No newline at end of file
diff --git a/tests/.factorypath b/tests/.factorypath
new file mode 100644
index 00000000..62901ce8
--- /dev/null
+++ b/tests/.factorypath
@@ -0,0 +1,3 @@
+<factorypath>
+    <factorypathentry kind="WKSPJAR" id="/ActiveAndroid/build/libs/ActiveAndroid.jar" enabled="true" runInBatchMode="false"/>
+</factorypath>
diff --git a/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java b/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
index ba7efd61..992b3f75 100644
--- a/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
+++ b/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
@@ -18,8 +18,7 @@
 
 import android.test.ApplicationTestCase;
 
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.app.Application;
+import com.activeandroid.sebbia.app.Application;
 
 public abstract class ActiveAndroidTestCase extends ApplicationTestCase<Application> {
 	public ActiveAndroidTestCase() {
diff --git a/tests/src/com/activeandroid/test/CacheTest.java b/tests/src/com/activeandroid/test/CacheTest.java
index 1689585a..7a223633 100644
--- a/tests/src/com/activeandroid/test/CacheTest.java
+++ b/tests/src/com/activeandroid/test/CacheTest.java
@@ -1,15 +1,15 @@
 package com.activeandroid.test;
 
-import android.test.AndroidTestCase;
+import java.util.Collection;
 
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Cache;
-import com.activeandroid.Configuration;
-import com.activeandroid.Model;
-import com.activeandroid.TableInfo;
-import com.activeandroid.annotation.Table;
+import android.test.AndroidTestCase;
 
-import java.util.Collection;
+import com.activeandroid.sebbia.ActiveAndroid;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Configuration;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.sebbia.annotation.Table;
 
 public class CacheTest extends AndroidTestCase {
 
diff --git a/tests/src/com/activeandroid/test/ConfigurationTest.java b/tests/src/com/activeandroid/test/ConfigurationTest.java
index 18684fd4..3b7d2943 100644
--- a/tests/src/com/activeandroid/test/ConfigurationTest.java
+++ b/tests/src/com/activeandroid/test/ConfigurationTest.java
@@ -1,13 +1,13 @@
 package com.activeandroid.test;
 
-import com.activeandroid.Configuration;
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Table;
+import java.io.IOException;
+import java.util.List;
 
 import android.test.AndroidTestCase;
 
-import java.io.IOException;
-import java.util.List;
+import com.activeandroid.sebbia.Configuration;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Table;
 
 public class ConfigurationTest extends AndroidTestCase {
 
diff --git a/tests/src/com/activeandroid/test/DefaultValueTest.java b/tests/src/com/activeandroid/test/DefaultValueTest.java
index d626b276..4a6b5acd 100644
--- a/tests/src/com/activeandroid/test/DefaultValueTest.java
+++ b/tests/src/com/activeandroid/test/DefaultValueTest.java
@@ -5,12 +5,12 @@
 import android.app.Application;
 import android.test.ApplicationTestCase;
 
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Configuration;
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.query.Select;
+import com.activeandroid.sebbia.ActiveAndroid;
+import com.activeandroid.sebbia.Configuration;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.query.Select;
 
 public class DefaultValueTest extends ApplicationTestCase<Application> {
 	
diff --git a/tests/src/com/activeandroid/test/MockModel.java b/tests/src/com/activeandroid/test/MockModel.java
index ff61dde3..b3c6fb18 100644
--- a/tests/src/com/activeandroid/test/MockModel.java
+++ b/tests/src/com/activeandroid/test/MockModel.java
@@ -16,12 +16,12 @@
  * limitations under the License.
  */
 
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-
 import java.util.Date;
 
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+
 @Table(name = "MockModel")
 public class MockModel extends Model {
     @Column
diff --git a/tests/src/com/activeandroid/test/ModelTest.java b/tests/src/com/activeandroid/test/ModelTest.java
index a86ad0b0..8d3d8cf4 100644
--- a/tests/src/com/activeandroid/test/ModelTest.java
+++ b/tests/src/com/activeandroid/test/ModelTest.java
@@ -23,12 +23,12 @@
 import java.util.List;
 import java.util.Set;
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
-import com.activeandroid.TableInfo;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.query.Select;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.query.Select;
 
 /**
  * Simple test now covering equals and hashcode methods.
diff --git a/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java b/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java
index cd1df8fe..60d05219 100644
--- a/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java
+++ b/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java
@@ -4,11 +4,11 @@
 
 import android.database.Cursor;
 
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.query.Select;
+import com.activeandroid.sebbia.ActiveAndroid;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.query.Select;
 
 public class AddColumnsTest extends AutoMigrationTest {
 	
diff --git a/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java b/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java
index 7dd11ca2..2501bc3c 100644
--- a/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java
+++ b/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java
@@ -4,11 +4,11 @@
 
 import android.database.Cursor;
 
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.query.Select;
+import com.activeandroid.sebbia.ActiveAndroid;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.query.Select;
 
 public class AddUniqueNotNullTest extends AutoMigrationTest {
 	
diff --git a/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java b/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java
index d313266e..7d1b5bf2 100644
--- a/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java
+++ b/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java
@@ -1,14 +1,14 @@
 package com.activeandroid.test.automigration;
 
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Configuration;
-import com.activeandroid.Model;
-
 import android.app.Application;
 import android.content.ContentValues;
 import android.database.sqlite.SQLiteDatabase;
 import android.test.ApplicationTestCase;
 
+import com.activeandroid.sebbia.ActiveAndroid;
+import com.activeandroid.sebbia.Configuration;
+import com.activeandroid.sebbia.Model;
+
 public abstract class AutoMigrationTest extends ApplicationTestCase<Application> {
 
 	protected static final String DATABASE = "auto_migration.db";
diff --git a/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java b/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java
index fa8324fa..4c6cb22c 100644
--- a/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java
+++ b/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java
@@ -1,10 +1,9 @@
 package com.activeandroid.test.automigration;
 
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.automigration.AutoMigration;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.automigration.AutoMigration;
 
 public class ChangeTypeTest extends AutoMigrationTest {
 	
diff --git a/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java b/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java
index 2d388d9b..29b47482 100644
--- a/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java
+++ b/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java
@@ -4,11 +4,11 @@
 
 import android.database.Cursor;
 
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.query.Select;
+import com.activeandroid.sebbia.ActiveAndroid;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.query.Select;
 
 public class DefaultValueMigrationTest extends AutoMigrationTest {
 	private static final String TABLE = "default_value_migration";
diff --git a/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java b/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java
index 5537aba0..913cbdeb 100644
--- a/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java
+++ b/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java
@@ -1,6 +1,6 @@
 package com.activeandroid.test.automigration;
 
-import com.activeandroid.automigration.SQLColumnInfo;
+import com.activeandroid.sebbia.automigration.SQLColumnInfo;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
 public class SQLColumnInfoTest extends ActiveAndroidTestCase {
diff --git a/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java b/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java
index 0ac90f2d..2cd5e39f 100644
--- a/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java
+++ b/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java
@@ -1,9 +1,9 @@
 package com.activeandroid.test.automigration;
 
-import com.activeandroid.automigration.SQLColumnInfo;
-import com.activeandroid.automigration.SQLTableInfo;
+import com.activeandroid.sebbia.automigration.SQLColumnInfo;
+import com.activeandroid.sebbia.automigration.SQLTableInfo;
+import com.activeandroid.sebbia.util.SQLiteUtils.SQLiteType;
 import com.activeandroid.test.ActiveAndroidTestCase;
-import com.activeandroid.util.SQLiteUtils.SQLiteType;
 
 public class SQLTableInfoTest extends ActiveAndroidTestCase {
 	
diff --git a/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java b/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java
new file mode 100644
index 00000000..1606e86a
--- /dev/null
+++ b/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java
@@ -0,0 +1,39 @@
+package com.activeandroid.test.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
+import com.activeandroid.sebbia.query.Select;
+
+public class DoNotGenerateTest extends ModelTestCase {
+	
+	@DoNotGenerate
+	public static class DoNotGenerateModel extends Model {
+		
+		@Column(name = "value")
+		private String value;
+	}
+
+	public void testNoGenerate() {
+		List<DoNotGenerateModel> impls = new ArrayList<DoNotGenerateModel>();
+		for (int i = 0; i < 100; ++i) {
+			DoNotGenerateModel model = new DoNotGenerateModel();
+			model.value = Integer.toString(i);
+			impls.add(model);
+		}
+		
+		Model.saveMultiple(impls);
+		
+		impls = new Select().from(DoNotGenerateModel.class).execute();
+		assertEquals(100, impls.size());
+		for (int i = 0; i < impls.size(); ++i) {
+			DoNotGenerateModel impl = impls.get(i);
+			assertNotNull(impl);
+			assertNotNull(impl.value);
+			assertTrue(impl.value.equalsIgnoreCase(Integer.toString(i)));
+		}
+	}
+}
diff --git a/tests/src/com/activeandroid/test/model/EnumTest.java b/tests/src/com/activeandroid/test/model/EnumTest.java
new file mode 100644
index 00000000..d253c09d
--- /dev/null
+++ b/tests/src/com/activeandroid/test/model/EnumTest.java
@@ -0,0 +1,56 @@
+package com.activeandroid.test.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import android.database.Cursor;
+
+import com.activeandroid.sebbia.ActiveAndroid;
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.query.Delete;
+
+public class EnumTest extends ModelTestCase {
+
+	public enum Enumeration {
+		TYPE_A,
+		TYPE_B,
+		TYPE_C
+	}
+
+	@Table(name = "enum_model")
+	public static class EnumModel extends Model {
+
+		@Column(name = "enum")
+		Enumeration enumeration;
+
+		public EnumModel() {
+
+		}
+
+		public EnumModel(Enumeration enumeration) {
+			super();
+			this.enumeration = enumeration;
+		}
+
+	}
+
+	public void testEnumSaving() {
+		new Delete().from(EnumModel.class).execute();
+		List<EnumModel> models = new ArrayList<EnumModel>();
+		for (Enumeration enumeration : Enumeration.values()) 
+			models.add(new EnumModel(enumeration));
+		
+		Model.saveMultiple(models);
+		
+		TableInfo tableInfo = Cache.getTableInfo(EnumModel.class);
+		Cursor cursor = ActiveAndroid.getDatabase().query(tableInfo.getTableName(), new String[] {"enum"}, null, null, null, null, null);
+		while (cursor.moveToNext()) {
+			assertTrue(cursor.getString(0).equals(Enumeration.values()[cursor.getPosition()]));
+		}
+		cursor.close();
+	}
+}
diff --git a/tests/src/com/activeandroid/test/model/ManyToManyTest.java b/tests/src/com/activeandroid/test/model/ManyToManyTest.java
index 02f9f7f4..1604af47 100644
--- a/tests/src/com/activeandroid/test/model/ManyToManyTest.java
+++ b/tests/src/com/activeandroid/test/model/ManyToManyTest.java
@@ -3,8 +3,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import com.activeandroid.Model;
-import com.activeandroid.model.ManyToManyRelation;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.model.ManyToManyRelation;
 import com.activeandroid.test.MockModel;
 
 public class ManyToManyTest extends ModelTestCase {
diff --git a/tests/src/com/activeandroid/test/model/ModelTestCase.java b/tests/src/com/activeandroid/test/model/ModelTestCase.java
index a4d16f12..11a38cf0 100644
--- a/tests/src/com/activeandroid/test/model/ModelTestCase.java
+++ b/tests/src/com/activeandroid/test/model/ModelTestCase.java
@@ -1,7 +1,7 @@
 package com.activeandroid.test.model;
 
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Configuration;
+import com.activeandroid.sebbia.ActiveAndroid;
+import com.activeandroid.sebbia.Configuration;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
 public class ModelTestCase extends ActiveAndroidTestCase {
@@ -9,7 +9,7 @@
 	protected void setUp() throws Exception {
 		Configuration configuration = new Configuration.Builder(getContext())
         .setDatabaseName("model.db")
-        .setDatabaseVersion(2)
+        .setDatabaseVersion(3)
         .create();
 		ActiveAndroid.initialize(configuration, true);
 	}
diff --git a/tests/src/com/activeandroid/test/model/OneToManyTest.java b/tests/src/com/activeandroid/test/model/OneToManyTest.java
index 28744d15..9319b13e 100644
--- a/tests/src/com/activeandroid/test/model/OneToManyTest.java
+++ b/tests/src/com/activeandroid/test/model/OneToManyTest.java
@@ -3,13 +3,13 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import com.activeandroid.Model;
-import com.activeandroid.model.OneToManyRelation;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.model.OneToManyRelation;
 import com.activeandroid.test.MockModel;
 
 public class OneToManyTest extends ModelTestCase {
 	
-	public static class MockOneToManyRelation extends OneToManyRelation<MockModel> {
+	public static class MockOneToManyRelation extends OneToManyRelation<MockModel, Model> {
 		public MockOneToManyRelation() {
 			super();
 		}
diff --git a/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java b/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
index 971b8a89..5f43b2ce 100644
--- a/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
+++ b/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
@@ -4,8 +4,8 @@
 import android.database.SQLException;
 import android.database.sqlite.SQLiteDatabase;
 
-import com.activeandroid.Configuration;
-import com.activeandroid.DatabaseHelper;
+import com.activeandroid.sebbia.Configuration;
+import com.activeandroid.sebbia.DatabaseHelper;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
 
diff --git a/tests/src/com/activeandroid/test/parser/ParserTest.java b/tests/src/com/activeandroid/test/parser/ParserTest.java
index 164376b3..759e785d 100644
--- a/tests/src/com/activeandroid/test/parser/ParserTest.java
+++ b/tests/src/com/activeandroid/test/parser/ParserTest.java
@@ -1,14 +1,14 @@
 
 package com.activeandroid.test.parser;
 
-import com.activeandroid.test.ActiveAndroidTestCase;
-import com.activeandroid.test.R;
-import com.activeandroid.util.SqlParser;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.List;
 
+import com.activeandroid.sebbia.util.SqlParser;
+import com.activeandroid.test.ActiveAndroidTestCase;
+import com.activeandroid.test.R;
+
 
 public class ParserTest extends ActiveAndroidTestCase {
 
@@ -232,7 +232,7 @@ public void testComplex() throws IOException {
         final String sql2 = "INSERT INTO Entity2 ( Id, Column, Column2 ) SELECT Id, Column, 0 FROM Entity";
         final String sql3 = "DROP TABLE Entity";
         final String sql4 = "ALTER TABLE Entity2 RENAME TO Entity";
-        final String sql5 = "INSERT INTO Entity2 ( Id, Column, Column2) VALUES ( 9001 , 42, 'string /* string */ -- string' )";
+        final String sql5 = "INSERT INTO Entity2 ( Id, Column, Column2 ) VALUES ( 9001 , 42, 'string /* string */ -- string' )";
 
         final InputStream stream = this.getStream(R.raw.complex);
         List<String> commands = SqlParser.parse(stream);
diff --git a/tests/src/com/activeandroid/test/query/CountTest.java b/tests/src/com/activeandroid/test/query/CountTest.java
index f0617ce1..ba9eea84 100644
--- a/tests/src/com/activeandroid/test/query/CountTest.java
+++ b/tests/src/com/activeandroid/test/query/CountTest.java
@@ -1,13 +1,13 @@
 
 package com.activeandroid.test.query;
 
-import com.activeandroid.query.Delete;
-import com.activeandroid.query.From;
-import com.activeandroid.query.Select;
-import com.activeandroid.test.MockModel;
-
 import java.util.List;
 
+import com.activeandroid.sebbia.query.Delete;
+import com.activeandroid.sebbia.query.From;
+import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.test.MockModel;
+
 
 public class CountTest extends SqlableTestCase {
 
diff --git a/tests/src/com/activeandroid/test/query/DeleteTest.java b/tests/src/com/activeandroid/test/query/DeleteTest.java
index 3d9a1d71..f0624ffc 100644
--- a/tests/src/com/activeandroid/test/query/DeleteTest.java
+++ b/tests/src/com/activeandroid/test/query/DeleteTest.java
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.query.Delete;
+import com.activeandroid.sebbia.query.Delete;
 import com.activeandroid.test.MockModel;
 
 public class DeleteTest extends SqlableTestCase {
diff --git a/tests/src/com/activeandroid/test/query/ExistsTest.java b/tests/src/com/activeandroid/test/query/ExistsTest.java
index e67d609a..eea3ca02 100644
--- a/tests/src/com/activeandroid/test/query/ExistsTest.java
+++ b/tests/src/com/activeandroid/test/query/ExistsTest.java
@@ -1,13 +1,13 @@
 
 package com.activeandroid.test.query;
 
-import com.activeandroid.query.Delete;
-import com.activeandroid.query.From;
-import com.activeandroid.query.Select;
-import com.activeandroid.test.MockModel;
-
 import java.util.List;
 
+import com.activeandroid.sebbia.query.Delete;
+import com.activeandroid.sebbia.query.From;
+import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.test.MockModel;
+
 
 public class ExistsTest extends SqlableTestCase {
 
diff --git a/tests/src/com/activeandroid/test/query/FromTest.java b/tests/src/com/activeandroid/test/query/FromTest.java
index 1305dd2b..a712e337 100644
--- a/tests/src/com/activeandroid/test/query/FromTest.java
+++ b/tests/src/com/activeandroid/test/query/FromTest.java
@@ -16,10 +16,10 @@
  * limitations under the License.
  */
 
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.query.From;
-import com.activeandroid.query.Select;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.query.From;
+import com.activeandroid.sebbia.query.Select;
 import com.activeandroid.test.MockModel;
 
 public class FromTest extends SqlableTestCase {
diff --git a/tests/src/com/activeandroid/test/query/SelectTest.java b/tests/src/com/activeandroid/test/query/SelectTest.java
index 73bfe73d..c4aca601 100644
--- a/tests/src/com/activeandroid/test/query/SelectTest.java
+++ b/tests/src/com/activeandroid/test/query/SelectTest.java
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.query.Select;
+import com.activeandroid.sebbia.query.Select;
 import com.activeandroid.test.MockModel;
 
 public class SelectTest extends SqlableTestCase {
diff --git a/tests/src/com/activeandroid/test/query/SqlableTestCase.java b/tests/src/com/activeandroid/test/query/SqlableTestCase.java
index 36137600..f339e1b0 100644
--- a/tests/src/com/activeandroid/test/query/SqlableTestCase.java
+++ b/tests/src/com/activeandroid/test/query/SqlableTestCase.java
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.query.Sqlable;
+import com.activeandroid.sebbia.query.Sqlable;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
 public abstract class SqlableTestCase extends ActiveAndroidTestCase {
diff --git a/tests/src/com/activeandroid/test/query/UpdateTest.java b/tests/src/com/activeandroid/test/query/UpdateTest.java
index 814d34f7..1d9d7c6d 100644
--- a/tests/src/com/activeandroid/test/query/UpdateTest.java
+++ b/tests/src/com/activeandroid/test/query/UpdateTest.java
@@ -16,8 +16,8 @@
  * limitations under the License.
  */
 
-import com.activeandroid.query.Set;
-import com.activeandroid.query.Update;
+import com.activeandroid.sebbia.query.Set;
+import com.activeandroid.sebbia.query.Update;
 import com.activeandroid.test.MockModel;
 
 public class UpdateTest extends SqlableTestCase {
