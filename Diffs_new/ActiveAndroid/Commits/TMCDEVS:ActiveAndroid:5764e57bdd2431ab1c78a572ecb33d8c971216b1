diff --git a/README.md b/README.md
index 7ba14fba..bfccb450 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,8 @@
 [![Build Status](https://travis-ci.org/pardom/ActiveAndroid.png?branch=master)](https://travis-ci.org/pardom/ActiveAndroid) [![Stories in Ready](https://badge.waffle.io/pardom/ActiveAndroid.png)](http://waffle.io/pardom/ActiveAndroid)  
+
+# TMC version - Disabling cache hits
+We are using ActiveAndroid library in projects for migrated DDBB and we are experiencing some cache problems. Disabling cache for now.
+
 # ActiveAndroid
 
 ActiveAndroid is an active record style ORM ([object relational mapper](http://en.wikipedia.org/wiki/Object-relational_mapping)). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like _save()_ and _delete()_.
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 421426ea..4d1235d7 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -242,7 +242,9 @@ else if (ReflectionUtils.isModel(fieldType)) {
 					final long entityId = cursor.getLong(columnIndex);
 					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
 
-					Model entity = Cache.getEntity(entityType, entityId);
+// @JE: Avoiding cache hits due to DDBB inconsistencies with 'Id' fields and PK
+//					Model entity = Cache.getEntity(entityType, entityId);
+                    Model entity = null;
 					if (entity == null) {
 						entity = new Select().from(entityType).where(idName+"=?", entityId).executeSingle();
 					}
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index cbf41eae..ff1618af 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -336,7 +336,9 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
                  */
                 List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
 				do {
-					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
+//                  @JE: Avoiding cache hits due to DDBB inconsistencies with 'Id' fields and PK
+//					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
+                    Model entity = null;
 					if (entity == null) {
 						entity = (T) entityConstructor.newInstance();
 					}
