diff --git a/.gitignore b/.gitignore
index 6029faf2..40e5796f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -35,5 +35,5 @@ tmp
 
 # Gradle
 .gradle
-/build
+build
 /out
diff --git a/README.md b/README.md
index 2e7c9e4d..b4acc924 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,8 @@
 [![Build Status](https://travis-ci.org/pardom/ActiveAndroid.png?branch=master)](https://travis-ci.org/pardom/ActiveAndroid) [![Stories in Ready](https://badge.waffle.io/pardom/ActiveAndroid.png)](http://waffle.io/pardom/ActiveAndroid)  
 # ActiveAndroid
 
+Version 3.5.0 split up runtime dependencies and annotation processor
+
 ActiveAndroid is an active record style ORM ([object relational mapper](http://en.wikipedia.org/wiki/Object-relational_mapping)). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like _save()_ and _delete()_.
 
 ActiveAndroid does so much more than this though. Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration.
@@ -10,8 +12,8 @@ ActiveAndroid does so much more than this though. Accessing the database is a ha
 Grab via Maven:
 ```xml
 <dependency>
-  <groupId>com.michaelpardo</groupId>
-  <artifactId>activeandroid</artifactId>
+  <groupId>com.michaelpardo.activeandroid</groupId>
+  <artifactId>library</artifactId>
   <version>3.1.0-SNAPSHOT</version>
 </dependency>
 ```
@@ -22,7 +24,8 @@ repositories {
     maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
 }
 
-compile 'com.michaelpardo:activeandroid:3.1.0-SNAPSHOT'
+compile 'com.michaelpardo.activeandroid:library:3.5.0-SNAPSHOT'
+annotationProcessor 'com.michaelpardo.activeandroid:processor:3.5.0-SNAPSHOT'
 ```
 
 ## Documentation
diff --git a/build.gradle b/build.gradle
index 5594e43b..8634e0da 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,17 +1,13 @@
-apply plugin: 'java'
-apply from: 'gradle-mvn-push.gradle'
+subprojects {
+	apply plugin: 'java'
+	apply from: "$rootProject.projectDir/gradle-mvn-push.gradle"
 
-targetCompatibility = '1.6'
-sourceCompatibility = '1.6'
+	targetCompatibility = '1.6'
+	sourceCompatibility = '1.6'
 
-sourceSets {
-	main {
-		java {
-			srcDir 'src'
-		}
+	dependencies {
+		compile fileTree(dir: "$rootProject.projectDir/libs", include: '*.jar')
 	}
-}
 
-dependencies {
-	compile fileTree(dir: 'libs', include: '*.jar')
+
 }
diff --git a/gradle-mvn-push.gradle b/gradle-mvn-push.gradle
index 8b88acd9..18fff822 100644
--- a/gradle-mvn-push.gradle
+++ b/gradle-mvn-push.gradle
@@ -47,7 +47,7 @@ afterEvaluate { project ->
 				beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
 
 				pom.groupId = GROUP
-				pom.artifactId = POM_ARTIFACT_ID
+				pom.artifactId = project.name
 				pom.version = VERSION_NAME
 
 				repository(url: getReleaseRepositoryUrl()) {
diff --git a/gradle.properties b/gradle.properties
index 1dec7c9c..5bb3d238 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,6 +1,6 @@
-VERSION_NAME=3.1.1-bandlab
-VERSION_CODE=2
-GROUP=com.michaelpardo
+VERSION_NAME=3.5.0-bandlab
+VERSION_CODE=3
+GROUP=com.michaelpardo.activeandroid
 
 POM_DESCRIPTION=Active record style SQLite persistence for Android.
 POM_URL=https://github.com/pardom/ActiveAndroid
@@ -14,5 +14,4 @@ POM_DEVELOPER_ID=michaelpardo
 POM_DEVELOPER_NAME=Michael Pardo
 
 POM_NAME=ActiveAndroid
-POM_ARTIFACT_ID=activeandroid
 POM_PACKAGING=jar
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 667288ad..0d4a9516 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 9770061d..115e6ac0 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Thu Feb 26 10:43:00 SGT 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.10-bin.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269..cccdd3d5 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +113,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
index aec99730..e95643d6 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,10 +46,9 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/src/com/activeandroid/sebbia/ActiveAndroid.java b/library/src/main/java/com/activeandroid/sebbia/ActiveAndroid.java
similarity index 100%
rename from src/com/activeandroid/sebbia/ActiveAndroid.java
rename to library/src/main/java/com/activeandroid/sebbia/ActiveAndroid.java
diff --git a/src/com/activeandroid/sebbia/Cache.java b/library/src/main/java/com/activeandroid/sebbia/Cache.java
similarity index 100%
rename from src/com/activeandroid/sebbia/Cache.java
rename to library/src/main/java/com/activeandroid/sebbia/Cache.java
diff --git a/src/com/activeandroid/sebbia/Configuration.java b/library/src/main/java/com/activeandroid/sebbia/Configuration.java
similarity index 100%
rename from src/com/activeandroid/sebbia/Configuration.java
rename to library/src/main/java/com/activeandroid/sebbia/Configuration.java
diff --git a/src/com/activeandroid/sebbia/DatabaseHelper.java b/library/src/main/java/com/activeandroid/sebbia/DatabaseHelper.java
similarity index 100%
rename from src/com/activeandroid/sebbia/DatabaseHelper.java
rename to library/src/main/java/com/activeandroid/sebbia/DatabaseHelper.java
diff --git a/src/com/activeandroid/sebbia/Model.java b/library/src/main/java/com/activeandroid/sebbia/Model.java
similarity index 100%
rename from src/com/activeandroid/sebbia/Model.java
rename to library/src/main/java/com/activeandroid/sebbia/Model.java
diff --git a/src/com/activeandroid/sebbia/ModelInfo.java b/library/src/main/java/com/activeandroid/sebbia/ModelInfo.java
similarity index 100%
rename from src/com/activeandroid/sebbia/ModelInfo.java
rename to library/src/main/java/com/activeandroid/sebbia/ModelInfo.java
diff --git a/src/com/activeandroid/sebbia/TableInfo.java b/library/src/main/java/com/activeandroid/sebbia/TableInfo.java
similarity index 96%
rename from src/com/activeandroid/sebbia/TableInfo.java
rename to library/src/main/java/com/activeandroid/sebbia/TableInfo.java
index 0274b35c..195b60a2 100644
--- a/src/com/activeandroid/sebbia/TableInfo.java
+++ b/library/src/main/java/com/activeandroid/sebbia/TableInfo.java
@@ -1,170 +1,170 @@
-package com.activeandroid.sebbia;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.reflect.Field;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-import android.text.TextUtils;
-
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.ReflectionUtils;
-import com.activeandroid.sebbia.util.SQLiteUtils;
-
-public final class TableInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Class<? extends Model> mType;
-	private String mTableName;
-	private String mIdName = Table.DEFAULT_ID_NAME;
-
-	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
-	
-	private SQLiteStatement mInsertStatement;
-	private SQLiteStatement mInsertOrReplaceStatement;
-	private SQLiteStatement mUpdateStatement;
-	
-	private Map<String, Integer> mColumnIndexes;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public TableInfo(Class<? extends Model> type) {
-		mType = type;
-
-		final Table tableAnnotation = type.getAnnotation(Table.class);
-
-        if (tableAnnotation != null) {
-			mTableName = tableAnnotation.name();
-			mIdName = tableAnnotation.id();
-		}
-		else {
-			mTableName = type.getSimpleName();
-        }
-
-        // Manually add the id column since it is not declared like the other columns.
-        Field idField = getIdField(type);
-        mColumnNames.put(idField, mIdName);
-
-        List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
-        Collections.reverse(fields);
-
-        for (Field field : fields) {
-            if (field.isAnnotationPresent(Column.class)) {
-                final Column columnAnnotation = field.getAnnotation(Column.class);
-                String columnName = columnAnnotation.name();
-                if (TextUtils.isEmpty(columnName)) {
-                    columnName = field.getName();
-                }
-
-                mColumnNames.put(field, columnName);
-            }
-        }
-        
-        mColumnIndexes = new HashMap<String, Integer>(mColumnNames.size());
-        int index = 1;
-        for (String column : mColumnNames.values()) {
-        	mColumnIndexes.put(column, index++);
-        }
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Class<? extends Model> getType() {
-		return mType;
-	}
-
-	public String getTableName() {
-		return mTableName;
-	}
-
-	public String getIdName() {
-		return mIdName;
-	}
-
-	public Collection<Field> getFields() {
-		return mColumnNames.keySet();
-	}
-	
-	public Collection<String> getColumnNames() {
-		return mColumnNames.values();
-	}
-
-	public String getColumnName(Field field) {
-		return mColumnNames.get(field);
-	}
-	
-	public SQLiteStatement getInsertStatement() {
-		if (mInsertStatement == null) {
-			SQLiteDatabase db = Cache.openDatabase(); 
-			mInsertStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT INTO ", this));
-		}
-		return mInsertStatement;
-	}
-	
-	public SQLiteStatement getUpdateStatement() {
-		if (mUpdateStatement == null) {
-			SQLiteDatabase db = Cache.openDatabase(); 
-			mUpdateStatement = db.compileStatement(SQLiteUtils.createUpdateStatement(this));
-		}
-		return mUpdateStatement;
-	}
-	
-	public SQLiteStatement getInsertOrReplaceStatement() {
-		if (mInsertOrReplaceStatement == null) {
-			SQLiteDatabase db = Cache.openDatabase(); 
-			mInsertOrReplaceStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT OR REPLACE INTO ", this));
-		}
-		return mInsertOrReplaceStatement;
-	}
-	
-    private Field getIdField(Class<?> type) {
-        if (type.equals(Model.class)) {
-            try {
-                return type.getDeclaredField("mId");
-            }
-            catch (NoSuchFieldException e) {
-                Log.e("Impossible!", e.toString());
-            }
-        }
-        else if (type.getSuperclass() != null) {
-            return getIdField(type.getSuperclass());
-        }
-
-        return null;
-    }
-    
-    public Map<String, Integer> getColumnIndexes() {
-		return mColumnIndexes;
-	}
-
-}
+package com.activeandroid.sebbia;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+import android.text.TextUtils;
+
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.ReflectionUtils;
+import com.activeandroid.sebbia.util.SQLiteUtils;
+
+public final class TableInfo {
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE MEMBERS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private Class<? extends Model> mType;
+	private String mTableName;
+	private String mIdName = Table.DEFAULT_ID_NAME;
+
+	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
+	
+	private SQLiteStatement mInsertStatement;
+	private SQLiteStatement mInsertOrReplaceStatement;
+	private SQLiteStatement mUpdateStatement;
+	
+	private Map<String, Integer> mColumnIndexes;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// CONSTRUCTORS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public TableInfo(Class<? extends Model> type) {
+		mType = type;
+
+		final Table tableAnnotation = type.getAnnotation(Table.class);
+
+        if (tableAnnotation != null) {
+			mTableName = tableAnnotation.name();
+			mIdName = tableAnnotation.id();
+		}
+		else {
+			mTableName = type.getSimpleName();
+        }
+
+        // Manually add the id column since it is not declared like the other columns.
+        Field idField = getIdField(type);
+        mColumnNames.put(idField, mIdName);
+
+        List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
+        Collections.reverse(fields);
+
+        for (Field field : fields) {
+            if (field.isAnnotationPresent(Column.class)) {
+                final Column columnAnnotation = field.getAnnotation(Column.class);
+                String columnName = columnAnnotation.name();
+                if (TextUtils.isEmpty(columnName)) {
+                    columnName = field.getName();
+                }
+
+                mColumnNames.put(field, columnName);
+            }
+        }
+        
+        mColumnIndexes = new HashMap<String, Integer>(mColumnNames.size());
+        int index = 1;
+        for (String column : mColumnNames.values()) {
+        	mColumnIndexes.put(column, index++);
+        }
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public Class<? extends Model> getType() {
+		return mType;
+	}
+
+	public String getTableName() {
+		return mTableName;
+	}
+
+	public String getIdName() {
+		return mIdName;
+	}
+
+	public Collection<Field> getFields() {
+		return mColumnNames.keySet();
+	}
+	
+	public Collection<String> getColumnNames() {
+		return mColumnNames.values();
+	}
+
+	public String getColumnName(Field field) {
+		return mColumnNames.get(field);
+	}
+	
+	public SQLiteStatement getInsertStatement() {
+		if (mInsertStatement == null) {
+			SQLiteDatabase db = Cache.openDatabase(); 
+			mInsertStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT INTO ", this));
+		}
+		return mInsertStatement;
+	}
+	
+	public SQLiteStatement getUpdateStatement() {
+		if (mUpdateStatement == null) {
+			SQLiteDatabase db = Cache.openDatabase(); 
+			mUpdateStatement = db.compileStatement(SQLiteUtils.createUpdateStatement(this));
+		}
+		return mUpdateStatement;
+	}
+	
+	public SQLiteStatement getInsertOrReplaceStatement() {
+		if (mInsertOrReplaceStatement == null) {
+			SQLiteDatabase db = Cache.openDatabase(); 
+			mInsertOrReplaceStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT OR REPLACE INTO ", this));
+		}
+		return mInsertOrReplaceStatement;
+	}
+	
+    private Field getIdField(Class<?> type) {
+        if (type.equals(Model.class)) {
+            try {
+                return type.getDeclaredField("mId");
+            }
+            catch (NoSuchFieldException e) {
+                Log.e("Impossible!", e.toString());
+            }
+        }
+        else if (type.getSuperclass() != null) {
+            return getIdField(type.getSuperclass());
+        }
+
+        return null;
+    }
+    
+    public Map<String, Integer> getColumnIndexes() {
+		return mColumnIndexes;
+	}
+
+}
diff --git a/src/com/activeandroid/sebbia/annotation/Column.java b/library/src/main/java/com/activeandroid/sebbia/annotation/Column.java
similarity index 100%
rename from src/com/activeandroid/sebbia/annotation/Column.java
rename to library/src/main/java/com/activeandroid/sebbia/annotation/Column.java
diff --git a/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java b/library/src/main/java/com/activeandroid/sebbia/annotation/DoNotGenerate.java
similarity index 100%
rename from src/com/activeandroid/sebbia/annotation/DoNotGenerate.java
rename to library/src/main/java/com/activeandroid/sebbia/annotation/DoNotGenerate.java
diff --git a/src/com/activeandroid/sebbia/annotation/Table.java b/library/src/main/java/com/activeandroid/sebbia/annotation/Table.java
similarity index 100%
rename from src/com/activeandroid/sebbia/annotation/Table.java
rename to library/src/main/java/com/activeandroid/sebbia/annotation/Table.java
diff --git a/src/com/activeandroid/sebbia/app/Application.java b/library/src/main/java/com/activeandroid/sebbia/app/Application.java
similarity index 100%
rename from src/com/activeandroid/sebbia/app/Application.java
rename to library/src/main/java/com/activeandroid/sebbia/app/Application.java
diff --git a/src/com/activeandroid/sebbia/automigration/AutoMigration.java b/library/src/main/java/com/activeandroid/sebbia/automigration/AutoMigration.java
similarity index 100%
rename from src/com/activeandroid/sebbia/automigration/AutoMigration.java
rename to library/src/main/java/com/activeandroid/sebbia/automigration/AutoMigration.java
diff --git a/src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java b/library/src/main/java/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
similarity index 100%
rename from src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
rename to library/src/main/java/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
diff --git a/src/com/activeandroid/sebbia/automigration/SQLTableInfo.java b/library/src/main/java/com/activeandroid/sebbia/automigration/SQLTableInfo.java
similarity index 100%
rename from src/com/activeandroid/sebbia/automigration/SQLTableInfo.java
rename to library/src/main/java/com/activeandroid/sebbia/automigration/SQLTableInfo.java
diff --git a/src/com/activeandroid/sebbia/automigration/TableDifference.java b/library/src/main/java/com/activeandroid/sebbia/automigration/TableDifference.java
similarity index 100%
rename from src/com/activeandroid/sebbia/automigration/TableDifference.java
rename to library/src/main/java/com/activeandroid/sebbia/automigration/TableDifference.java
diff --git a/src/com/activeandroid/sebbia/content/ContentProvider.java b/library/src/main/java/com/activeandroid/sebbia/content/ContentProvider.java
similarity index 100%
rename from src/com/activeandroid/sebbia/content/ContentProvider.java
rename to library/src/main/java/com/activeandroid/sebbia/content/ContentProvider.java
diff --git a/src/com/activeandroid/sebbia/internal/EmptyModelFiller.java b/library/src/main/java/com/activeandroid/sebbia/internal/EmptyModelFiller.java
similarity index 100%
rename from src/com/activeandroid/sebbia/internal/EmptyModelFiller.java
rename to library/src/main/java/com/activeandroid/sebbia/internal/EmptyModelFiller.java
diff --git a/src/com/activeandroid/sebbia/internal/ModelFiller.java b/library/src/main/java/com/activeandroid/sebbia/internal/ModelFiller.java
similarity index 100%
rename from src/com/activeandroid/sebbia/internal/ModelFiller.java
rename to library/src/main/java/com/activeandroid/sebbia/internal/ModelFiller.java
diff --git a/src/com/activeandroid/sebbia/internal/ModelHelper.java b/library/src/main/java/com/activeandroid/sebbia/internal/ModelHelper.java
similarity index 100%
rename from src/com/activeandroid/sebbia/internal/ModelHelper.java
rename to library/src/main/java/com/activeandroid/sebbia/internal/ModelHelper.java
diff --git a/src/com/activeandroid/sebbia/model/ManyToManyRelation.java b/library/src/main/java/com/activeandroid/sebbia/model/ManyToManyRelation.java
similarity index 100%
rename from src/com/activeandroid/sebbia/model/ManyToManyRelation.java
rename to library/src/main/java/com/activeandroid/sebbia/model/ManyToManyRelation.java
diff --git a/src/com/activeandroid/sebbia/model/OneToManyRelation.java b/library/src/main/java/com/activeandroid/sebbia/model/OneToManyRelation.java
similarity index 100%
rename from src/com/activeandroid/sebbia/model/OneToManyRelation.java
rename to library/src/main/java/com/activeandroid/sebbia/model/OneToManyRelation.java
diff --git a/src/com/activeandroid/sebbia/query/Delete.java b/library/src/main/java/com/activeandroid/sebbia/query/Delete.java
similarity index 100%
rename from src/com/activeandroid/sebbia/query/Delete.java
rename to library/src/main/java/com/activeandroid/sebbia/query/Delete.java
diff --git a/src/com/activeandroid/sebbia/query/From.java b/library/src/main/java/com/activeandroid/sebbia/query/From.java
similarity index 100%
rename from src/com/activeandroid/sebbia/query/From.java
rename to library/src/main/java/com/activeandroid/sebbia/query/From.java
diff --git a/src/com/activeandroid/sebbia/query/Join.java b/library/src/main/java/com/activeandroid/sebbia/query/Join.java
similarity index 100%
rename from src/com/activeandroid/sebbia/query/Join.java
rename to library/src/main/java/com/activeandroid/sebbia/query/Join.java
diff --git a/src/com/activeandroid/sebbia/query/Select.java b/library/src/main/java/com/activeandroid/sebbia/query/Select.java
similarity index 100%
rename from src/com/activeandroid/sebbia/query/Select.java
rename to library/src/main/java/com/activeandroid/sebbia/query/Select.java
diff --git a/src/com/activeandroid/sebbia/query/Set.java b/library/src/main/java/com/activeandroid/sebbia/query/Set.java
similarity index 100%
rename from src/com/activeandroid/sebbia/query/Set.java
rename to library/src/main/java/com/activeandroid/sebbia/query/Set.java
diff --git a/src/com/activeandroid/sebbia/query/Sqlable.java b/library/src/main/java/com/activeandroid/sebbia/query/Sqlable.java
similarity index 100%
rename from src/com/activeandroid/sebbia/query/Sqlable.java
rename to library/src/main/java/com/activeandroid/sebbia/query/Sqlable.java
diff --git a/src/com/activeandroid/sebbia/query/Update.java b/library/src/main/java/com/activeandroid/sebbia/query/Update.java
similarity index 100%
rename from src/com/activeandroid/sebbia/query/Update.java
rename to library/src/main/java/com/activeandroid/sebbia/query/Update.java
diff --git a/src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java b/library/src/main/java/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
similarity index 100%
rename from src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
rename to library/src/main/java/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
diff --git a/src/com/activeandroid/sebbia/serializer/CalendarSerializer.java b/library/src/main/java/com/activeandroid/sebbia/serializer/CalendarSerializer.java
similarity index 100%
rename from src/com/activeandroid/sebbia/serializer/CalendarSerializer.java
rename to library/src/main/java/com/activeandroid/sebbia/serializer/CalendarSerializer.java
diff --git a/src/com/activeandroid/sebbia/serializer/FileSerializer.java b/library/src/main/java/com/activeandroid/sebbia/serializer/FileSerializer.java
similarity index 100%
rename from src/com/activeandroid/sebbia/serializer/FileSerializer.java
rename to library/src/main/java/com/activeandroid/sebbia/serializer/FileSerializer.java
diff --git a/src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java b/library/src/main/java/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
similarity index 100%
rename from src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
rename to library/src/main/java/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
diff --git a/src/com/activeandroid/sebbia/serializer/TypeSerializer.java b/library/src/main/java/com/activeandroid/sebbia/serializer/TypeSerializer.java
similarity index 100%
rename from src/com/activeandroid/sebbia/serializer/TypeSerializer.java
rename to library/src/main/java/com/activeandroid/sebbia/serializer/TypeSerializer.java
diff --git a/src/com/activeandroid/sebbia/serializer/UUIDSerializer.java b/library/src/main/java/com/activeandroid/sebbia/serializer/UUIDSerializer.java
similarity index 100%
rename from src/com/activeandroid/sebbia/serializer/UUIDSerializer.java
rename to library/src/main/java/com/activeandroid/sebbia/serializer/UUIDSerializer.java
diff --git a/src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java b/library/src/main/java/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
similarity index 100%
rename from src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
rename to library/src/main/java/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
diff --git a/src/com/activeandroid/sebbia/util/IOUtils.java b/library/src/main/java/com/activeandroid/sebbia/util/IOUtils.java
similarity index 100%
rename from src/com/activeandroid/sebbia/util/IOUtils.java
rename to library/src/main/java/com/activeandroid/sebbia/util/IOUtils.java
diff --git a/src/com/activeandroid/sebbia/util/Log.java b/library/src/main/java/com/activeandroid/sebbia/util/Log.java
similarity index 95%
rename from src/com/activeandroid/sebbia/util/Log.java
rename to library/src/main/java/com/activeandroid/sebbia/util/Log.java
index c8f28af6..591f558a 100644
--- a/src/com/activeandroid/sebbia/util/Log.java
+++ b/library/src/main/java/com/activeandroid/sebbia/util/Log.java
@@ -1,196 +1,196 @@
-package com.activeandroid.sebbia.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public final class Log {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static String sTag = "ActiveAndroid";
-	private static boolean sEnabled = false;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Log() {
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-    public static boolean isEnabled() {
-        return sEnabled;
-    }
-
-	public static void setEnabled(boolean enabled) {
-		sEnabled = enabled;
-	}
-
-	public static boolean isLoggingEnabled() {
-		return sEnabled;
-	}
-
-	public static int v(String msg) {
-		if (sEnabled) {
-			return android.util.Log.v(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int v(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.v(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int v(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.v(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int v(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.v(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int d(String msg) {
-		if (sEnabled) {
-			return android.util.Log.d(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int d(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.d(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int d(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.d(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int d(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.d(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int i(String msg) {
-		if (sEnabled) {
-			return android.util.Log.i(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int i(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.i(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int i(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.i(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int i(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.i(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int w(String msg) {
-		if (sEnabled) {
-			return android.util.Log.w(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int w(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.w(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int w(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.w(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int w(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.w(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int e(String msg) {
-		if (sEnabled) {
-			return android.util.Log.e(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int e(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.e(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int e(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.e(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int e(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.e(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int t(String msg, Object... args) {
-		if (sEnabled) {
-			return android.util.Log.v("test", String.format(msg, args));
-		}
-		return 0;
-	}
+package com.activeandroid.sebbia.util;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public final class Log {
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC MEMBERS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private static String sTag = "ActiveAndroid";
+	private static boolean sEnabled = false;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// CONSTRUCTORS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private Log() {
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+    public static boolean isEnabled() {
+        return sEnabled;
+    }
+
+	public static void setEnabled(boolean enabled) {
+		sEnabled = enabled;
+	}
+
+	public static boolean isLoggingEnabled() {
+		return sEnabled;
+	}
+
+	public static int v(String msg) {
+		if (sEnabled) {
+			return android.util.Log.v(sTag, msg);
+		}
+		return 0;
+	}
+
+	public static int v(String tag, String msg) {
+		if (sEnabled) {
+			return android.util.Log.v(tag, msg);
+		}
+		return 0;
+	}
+
+	public static int v(String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.v(sTag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int v(String tag, String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.v(tag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int d(String msg) {
+		if (sEnabled) {
+			return android.util.Log.d(sTag, msg);
+		}
+		return 0;
+	}
+
+	public static int d(String tag, String msg) {
+		if (sEnabled) {
+			return android.util.Log.d(tag, msg);
+		}
+		return 0;
+	}
+
+	public static int d(String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.d(sTag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int d(String tag, String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.d(tag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int i(String msg) {
+		if (sEnabled) {
+			return android.util.Log.i(sTag, msg);
+		}
+		return 0;
+	}
+
+	public static int i(String tag, String msg) {
+		if (sEnabled) {
+			return android.util.Log.i(tag, msg);
+		}
+		return 0;
+	}
+
+	public static int i(String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.i(sTag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int i(String tag, String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.i(tag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int w(String msg) {
+		if (sEnabled) {
+			return android.util.Log.w(sTag, msg);
+		}
+		return 0;
+	}
+
+	public static int w(String tag, String msg) {
+		if (sEnabled) {
+			return android.util.Log.w(tag, msg);
+		}
+		return 0;
+	}
+
+	public static int w(String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.w(sTag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int w(String tag, String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.w(tag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int e(String msg) {
+		if (sEnabled) {
+			return android.util.Log.e(sTag, msg);
+		}
+		return 0;
+	}
+
+	public static int e(String tag, String msg) {
+		if (sEnabled) {
+			return android.util.Log.e(tag, msg);
+		}
+		return 0;
+	}
+
+	public static int e(String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.e(sTag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int e(String tag, String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.e(tag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int t(String msg, Object... args) {
+		if (sEnabled) {
+			return android.util.Log.v("test", String.format(msg, args));
+		}
+		return 0;
+	}
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/util/NaturalOrderComparator.java b/library/src/main/java/com/activeandroid/sebbia/util/NaturalOrderComparator.java
similarity index 96%
rename from src/com/activeandroid/sebbia/util/NaturalOrderComparator.java
rename to library/src/main/java/com/activeandroid/sebbia/util/NaturalOrderComparator.java
index 2fa9acf6..7ac09416 100644
--- a/src/com/activeandroid/sebbia/util/NaturalOrderComparator.java
+++ b/library/src/main/java/com/activeandroid/sebbia/util/NaturalOrderComparator.java
@@ -1,141 +1,141 @@
-package com.activeandroid.sebbia.util;
-
-/*
- NaturalOrderComparator.java -- Perform 'natural order' comparisons of strings in Java.
- Copyright (C) 2003 by Pierre-Luc Paour <natorder@paour.com>
-
- Based on the C version by Martin Pool, of which this is more or less a straight conversion.
- Copyright (C) 2000 by Martin Pool <mbp@humbug.org.au>
-
- This software is provided 'as-is', without any express or implied
- warranty.  In no event will the authors be held liable for any damages
- arising from the use of this software.
-
- Permission is granted to anyone to use this software for any purpose,
- including commercial applications, and to alter it and redistribute it
- freely, subject to the following restrictions:
-
- 1. The origin of this software must not be misrepresented; you must not
- claim that you wrote the original software. If you use this software
- in a product, an acknowledgment in the product documentation would be
- appreciated but is not required.
- 2. Altered source versions must be plainly marked as such, and must not be
- misrepresented as being the original software.
- 3. This notice may not be removed or altered from any source distribution.
- */
-
-import java.util.Comparator;
-
-public class NaturalOrderComparator implements Comparator<Object> {
-	int compareRight(String a, String b) {
-		int bias = 0;
-		int ia = 0;
-		int ib = 0;
-
-		// The longest run of digits wins. That aside, the greatest
-		// value wins, but we can't know that it will until we've scanned
-		// both numbers to know that they have the same magnitude, so we
-		// remember it in BIAS.
-		for (;; ia++, ib++) {
-			char ca = charAt(a, ia);
-			char cb = charAt(b, ib);
-
-			if (!Character.isDigit(ca) && !Character.isDigit(cb)) {
-				return bias;
-			}
-			else if (!Character.isDigit(ca)) {
-				return -1;
-			}
-			else if (!Character.isDigit(cb)) {
-				return +1;
-			}
-			else if (ca < cb) {
-				if (bias == 0) {
-					bias = -1;
-				}
-			}
-			else if (ca > cb) {
-				if (bias == 0)
-					bias = +1;
-			}
-			else if (ca == 0 && cb == 0) {
-				return bias;
-			}
-		}
-	}
-
-	public int compare(Object o1, Object o2) {
-		String a = o1.toString();
-		String b = o2.toString();
-
-		int ia = 0, ib = 0;
-		int nza = 0, nzb = 0;
-		char ca, cb;
-		int result;
-
-		while (true) {
-			// only count the number of zeroes leading the last number compared
-			nza = nzb = 0;
-
-			ca = charAt(a, ia);
-			cb = charAt(b, ib);
-
-			// skip over leading spaces or zeros
-			while (Character.isSpaceChar(ca) || ca == '0') {
-				if (ca == '0') {
-					nza++;
-				}
-				else {
-					// only count consecutive zeroes
-					nza = 0;
-				}
-
-				ca = charAt(a, ++ia);
-			}
-
-			while (Character.isSpaceChar(cb) || cb == '0') {
-				if (cb == '0') {
-					nzb++;
-				}
-				else {
-					// only count consecutive zeroes
-					nzb = 0;
-				}
-
-				cb = charAt(b, ++ib);
-			}
-
-			// process run of digits
-			if (Character.isDigit(ca) && Character.isDigit(cb)) {
-				if ((result = compareRight(a.substring(ia), b.substring(ib))) != 0) {
-					return result;
-				}
-			}
-
-			if (ca == 0 && cb == 0) {
-				// The strings compare the same. Perhaps the caller
-				// will want to call strcmp to break the tie.
-				return nza - nzb;
-			}
-
-			if (ca < cb) {
-				return -1;
-			}
-			else if (ca > cb) {
-				return +1;
-			}
-
-			++ia;
-			++ib;
-		}
-	}
-
-	static char charAt(String s, int i) {
-		if (i >= s.length()) {
-			return 0;
-		}
-		else {
-			return s.charAt(i);
-		}
-	}
+package com.activeandroid.sebbia.util;
+
+/*
+ NaturalOrderComparator.java -- Perform 'natural order' comparisons of strings in Java.
+ Copyright (C) 2003 by Pierre-Luc Paour <natorder@paour.com>
+
+ Based on the C version by Martin Pool, of which this is more or less a straight conversion.
+ Copyright (C) 2000 by Martin Pool <mbp@humbug.org.au>
+
+ This software is provided 'as-is', without any express or implied
+ warranty.  In no event will the authors be held liable for any damages
+ arising from the use of this software.
+
+ Permission is granted to anyone to use this software for any purpose,
+ including commercial applications, and to alter it and redistribute it
+ freely, subject to the following restrictions:
+
+ 1. The origin of this software must not be misrepresented; you must not
+ claim that you wrote the original software. If you use this software
+ in a product, an acknowledgment in the product documentation would be
+ appreciated but is not required.
+ 2. Altered source versions must be plainly marked as such, and must not be
+ misrepresented as being the original software.
+ 3. This notice may not be removed or altered from any source distribution.
+ */
+
+import java.util.Comparator;
+
+public class NaturalOrderComparator implements Comparator<Object> {
+	int compareRight(String a, String b) {
+		int bias = 0;
+		int ia = 0;
+		int ib = 0;
+
+		// The longest run of digits wins. That aside, the greatest
+		// value wins, but we can't know that it will until we've scanned
+		// both numbers to know that they have the same magnitude, so we
+		// remember it in BIAS.
+		for (;; ia++, ib++) {
+			char ca = charAt(a, ia);
+			char cb = charAt(b, ib);
+
+			if (!Character.isDigit(ca) && !Character.isDigit(cb)) {
+				return bias;
+			}
+			else if (!Character.isDigit(ca)) {
+				return -1;
+			}
+			else if (!Character.isDigit(cb)) {
+				return +1;
+			}
+			else if (ca < cb) {
+				if (bias == 0) {
+					bias = -1;
+				}
+			}
+			else if (ca > cb) {
+				if (bias == 0)
+					bias = +1;
+			}
+			else if (ca == 0 && cb == 0) {
+				return bias;
+			}
+		}
+	}
+
+	public int compare(Object o1, Object o2) {
+		String a = o1.toString();
+		String b = o2.toString();
+
+		int ia = 0, ib = 0;
+		int nza = 0, nzb = 0;
+		char ca, cb;
+		int result;
+
+		while (true) {
+			// only count the number of zeroes leading the last number compared
+			nza = nzb = 0;
+
+			ca = charAt(a, ia);
+			cb = charAt(b, ib);
+
+			// skip over leading spaces or zeros
+			while (Character.isSpaceChar(ca) || ca == '0') {
+				if (ca == '0') {
+					nza++;
+				}
+				else {
+					// only count consecutive zeroes
+					nza = 0;
+				}
+
+				ca = charAt(a, ++ia);
+			}
+
+			while (Character.isSpaceChar(cb) || cb == '0') {
+				if (cb == '0') {
+					nzb++;
+				}
+				else {
+					// only count consecutive zeroes
+					nzb = 0;
+				}
+
+				cb = charAt(b, ++ib);
+			}
+
+			// process run of digits
+			if (Character.isDigit(ca) && Character.isDigit(cb)) {
+				if ((result = compareRight(a.substring(ia), b.substring(ib))) != 0) {
+					return result;
+				}
+			}
+
+			if (ca == 0 && cb == 0) {
+				// The strings compare the same. Perhaps the caller
+				// will want to call strcmp to break the tie.
+				return nza - nzb;
+			}
+
+			if (ca < cb) {
+				return -1;
+			}
+			else if (ca > cb) {
+				return +1;
+			}
+
+			++ia;
+			++ib;
+		}
+	}
+
+	static char charAt(String s, int i) {
+		if (i >= s.length()) {
+			return 0;
+		}
+		else {
+			return s.charAt(i);
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/util/ReflectionUtils.java b/library/src/main/java/com/activeandroid/sebbia/util/ReflectionUtils.java
similarity index 100%
rename from src/com/activeandroid/sebbia/util/ReflectionUtils.java
rename to library/src/main/java/com/activeandroid/sebbia/util/ReflectionUtils.java
diff --git a/src/com/activeandroid/sebbia/util/SQLiteUtils.java b/library/src/main/java/com/activeandroid/sebbia/util/SQLiteUtils.java
similarity index 96%
rename from src/com/activeandroid/sebbia/util/SQLiteUtils.java
rename to library/src/main/java/com/activeandroid/sebbia/util/SQLiteUtils.java
index 85570058..03c1f054 100644
--- a/src/com/activeandroid/sebbia/util/SQLiteUtils.java
+++ b/library/src/main/java/com/activeandroid/sebbia/util/SQLiteUtils.java
@@ -1,488 +1,488 @@
-package com.activeandroid.sebbia.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import android.database.Cursor;
-import android.os.Build;
-import android.text.TextUtils;
-
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.TableInfo;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Column.ConflictAction;
-import com.activeandroid.sebbia.serializer.TypeSerializer;
-
-public final class SQLiteUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// ENUMERATIONS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public enum SQLiteType {
-		INTEGER, REAL, TEXT, BLOB
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONTSANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
-		{
-			put(byte.class, SQLiteType.INTEGER);
-			put(short.class, SQLiteType.INTEGER);
-			put(int.class, SQLiteType.INTEGER);
-			put(long.class, SQLiteType.INTEGER);
-			put(float.class, SQLiteType.REAL);
-			put(double.class, SQLiteType.REAL);
-			put(boolean.class, SQLiteType.INTEGER);
-			put(char.class, SQLiteType.TEXT);
-			put(byte[].class, SQLiteType.BLOB);
-			put(Byte.class, SQLiteType.INTEGER);
-			put(Short.class, SQLiteType.INTEGER);
-			put(Integer.class, SQLiteType.INTEGER);
-			put(Long.class, SQLiteType.INTEGER);
-			put(Float.class, SQLiteType.REAL);
-			put(Double.class, SQLiteType.REAL);
-			put(Boolean.class, SQLiteType.INTEGER);
-			put(Character.class, SQLiteType.TEXT);
-			put(String.class, SQLiteType.TEXT);
-			put(Byte[].class, SQLiteType.BLOB);
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static HashMap<String, List<String>> sIndexGroupMap;
-	private static HashMap<String, List<String>> sUniqueGroupMap;
-	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void execSql(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSql(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-
-	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-		List<T> entities = processCursor(type, cursor);
-		cursor.close();
-
-		return entities;
-	}
-	  
-	public static int intQuery(final String sql, final String[] selectionArgs) {
-        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-        final int number = processIntCursor(cursor);
-        cursor.close();
-
-        return number;
-	}
-
-	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		List<T> entities = rawQuery(type, sql, selectionArgs);
-
-		if (entities.size() > 0) {
-			return entities.get(0);
-		}
-
-		return null;
-	}
-
-	// Database creation
-
-	public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sUniqueGroupMap = new HashMap<String, List<String>>();
-		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
-
-		for (Field field : tableInfo.getFields()) {
-			createUniqueColumnDefinition(tableInfo, field);
-		}
-
-		if (sUniqueGroupMap.isEmpty()) {
-			return definitions;
-		}
-
-		Set<String> keySet = sUniqueGroupMap.keySet();
-		for (String key : keySet) {
-			List<String> group = sUniqueGroupMap.get(key);
-			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
-
-			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
-					TextUtils.join(", ", group), conflictAction.toString()));
-		}
-
-		return definitions;
-	}
-
-	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
-
-        if (field.getName().equals("mId")) {
-            return;
-        }
-
-		String[] groups = column.uniqueGroups();
-		ConflictAction[] conflictActions = column.onUniqueConflicts();
-		if (groups.length != conflictActions.length)
-			return;
-
-		for (int i = 0; i < groups.length; i++) {
-			String group = groups[i];
-			ConflictAction conflictAction = conflictActions[i];
-
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sUniqueGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-			list.add(name);
-
-			sUniqueGroupMap.put(group, list);
-			sOnUniqueConflictsMap.put(group, conflictAction);
-		}
-	}
-
-	public static String[] createIndexDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sIndexGroupMap = new HashMap<String, List<String>>();
-
-		for (Field field : tableInfo.getFields()) {
-			createIndexColumnDefinition(tableInfo, field);
-		}
-
-		if (sIndexGroupMap.isEmpty()) {
-			return new String[0];
-		}
-
-		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
-			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
-					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
-					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
-		}
-
-		return definitions.toArray(new String[definitions.size()]);
-	}
-
-	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
-
-        if (field.getName().equals("mId")) {
-            return;
-        }
-
-		if (column.index()) {
-			List<String> list = new ArrayList<String>();
-			list.add(name);
-			sIndexGroupMap.put(name, list);
-		}
-
-		String[] groups = column.indexGroups();
-		for (String group : groups) {
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sIndexGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-
-			list.add(name);
-			sIndexGroupMap.put(group, list);
-		}
-	}
-
-	public static String createTableDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-
-		for (Field field : tableInfo.getFields()) {
-			String definition = createColumnDefinition(tableInfo, field);
-			if (!TextUtils.isEmpty(definition)) {
-				definitions.add(definition);
-			}
-		}
-
-		definitions.addAll(createUniqueDefinition(tableInfo));
-
-		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
-				TextUtils.join(", ", definitions));
-	}
-
-	@SuppressWarnings("unchecked")
-	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
-		StringBuilder definition = new StringBuilder();
-
-		Class<?> type = field.getType();
-		final String name = tableInfo.getColumnName(field);
-		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-		final Column column = field.getAnnotation(Column.class);
-
-		if (typeSerializer != null) {
-			type = typeSerializer.getSerializedType();
-		}
-		
-		SQLiteType sqLiteType = null;
-		if (TYPE_MAP.containsKey(type)) {
-			sqLiteType = TYPE_MAP.get(type);
-		}
-		else if (ReflectionUtils.isModel(type)) {
-			sqLiteType = SQLiteType.INTEGER;
-		}
-		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
-			sqLiteType = SQLiteType.TEXT;
-		}
-		
-		if (sqLiteType != null) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(sqLiteType.toString());
-		}
-
-		if (!TextUtils.isEmpty(definition)) {
-
-			if (name.equals(tableInfo.getIdName())) {
-				definition.append(" PRIMARY KEY AUTOINCREMENT");
-			}else if(column!=null){
-				if (column.length() > -1) {
-					definition.append("(");
-					definition.append(column.length());
-					definition.append(")");
-				}
-
-				if (column.notNull()) {
-					definition.append(" NOT NULL ON CONFLICT ");
-					definition.append(column.onNullConflict().toString());
-				}
-
-				if (column.unique()) {
-					definition.append(" UNIQUE ON CONFLICT ");
-					definition.append(column.onUniqueConflict().toString());
-				}
-				
-				if (!TextUtils.isEmpty(column.defaultValue())) {
-					String defaultValue = null;
-					switch (sqLiteType) {
-					case TEXT: case BLOB:
-						defaultValue = "\"" + column.defaultValue() + "\"";
-						break;
-
-					case INTEGER:
-						try {
-							if (type.equals(Boolean.class) || type.equals(boolean.class)) {
-								boolean value = Boolean.parseBoolean(column.defaultValue());
-								defaultValue = value ? "1" : "0";
-							} else {
-								Integer.parseInt(column.defaultValue());
-								defaultValue = column.defaultValue();
-							}
-						} catch (NumberFormatException e) {
-							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
-						}
-						break;
-						
-					case REAL:
-						try {
-							Double.parseDouble(column.defaultValue());
-							defaultValue = column.defaultValue();
-						} catch (NumberFormatException e) {
-							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
-						}
-						break;
-					}
-					
-					if (defaultValue != null) {
-						definition.append(" DEFAULT ");
-						definition.append(defaultValue);
-					}
-				}
-			}
-
-			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type) && Cache.getTableInfo((Class<? extends Model>) type) != null) {
-				definition.append(" REFERENCES ");
-				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
-				definition.append("("+tableInfo.getIdName()+")");
-				definition.append(" ON DELETE ");
-				definition.append(column.onDelete().toString().replace("_", " "));
-				definition.append(" ON UPDATE ");
-				definition.append(column.onUpdate().toString().replace("_", " "));
-			}
-		
-		}
-		else {
-			Log.e("No type mapping for: " + type.toString());
-		}
-
-		return definition.toString();
-	}
-
-	@SuppressWarnings("unchecked")
-	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		String idName = tableInfo.getIdName();
-		final List<T> entities = new ArrayList<T>();
-
-		try {
-			Constructor<?> entityConstructor = type.getConstructor();
-
-			if (cursor.moveToFirst()) {
-                /**
-                 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-                 * when the cursor have multiple columns with same name obtained from join tables.
-                 */
-                List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-				do {
-					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
-					if (entity == null) {
-						entity = (T) entityConstructor.newInstance();
-					}
-
-					entity.loadFromCursor(cursor);
-					entities.add((T) entity);
-				}
-				while (cursor.moveToNext());
-			}
-
-		}
-		catch (NoSuchMethodException e) {
-			throw new RuntimeException(
-                "Your model " + type.getName() + " does not define a default " +
-                "constructor. The default constructor is required for " +
-                "now in ActiveAndroid models, as the process to " +
-                "populate the ORM model is : " +
-                "1. instantiate default model " +
-                "2. populate fields"
-            );
-		}
-		catch (Exception e) {
-			Log.e("Failed to process cursor.", e);
-		}
-
-		return entities;
-	}
-
-	private static int processIntCursor(final Cursor cursor) {
-        if (cursor.moveToFirst()) {
-            return cursor.getInt(0);
-	    }
-        return 0;
-    }
-
-	public static List<String> lexSqlScript(String sqlScript) {
-		ArrayList<String> sl = new ArrayList<String>();
-		boolean inString = false, quoteNext = false;
-		StringBuilder b = new StringBuilder(100);
-
-		for (int i = 0; i < sqlScript.length(); i++) {
-			char c = sqlScript.charAt(i);
-
-			if (c == ';' && !inString && !quoteNext) {
-				sl.add(b.toString());
-				b = new StringBuilder(100);
-				inString = false;
-				quoteNext = false;
-				continue;
-			}
-
-			if (c == '\'' && !quoteNext) {
-				inString = !inString;
-			}
-
-			quoteNext = c == '\\' && !quoteNext;
-
-			b.append(c);
-		}
-
-		if (b.length() > 0) {
-			sl.add(b.toString());
-		}
-
-		return sl;
-	}
-	
-	public static String createInsertStatement(String insertInto, TableInfo tableInfo) {
-		StringBuilder stringBuilder = new StringBuilder(insertInto);
-		stringBuilder
-			.append(tableInfo.getTableName())
-			.append(" (");
-			appendColumns(stringBuilder, tableInfo.getColumnNames(), false)
-			.append(") VALUES (");
-		appendPlaceholders(stringBuilder, tableInfo.getFields().size());
-		stringBuilder.append(")");
-		return stringBuilder.toString();
-	}
-	
-	public static String createUpdateStatement(TableInfo tableInfo) {
-		StringBuilder stringBuilder = new StringBuilder("UPDATE ");
-		stringBuilder
-			.append(tableInfo.getTableName())
-			.append(" SET ");
-		appendColumns(stringBuilder, tableInfo.getColumnNames(), true)
-			.append(" WHERE ");
-		appendColumn(stringBuilder, tableInfo.getIdName())
-			.append(" = ?");
-		return stringBuilder.toString();
-	}
-	
-	private static StringBuilder appendColumns(StringBuilder stringBuilder, Collection<String> columns, boolean addEqPlaceholder) {
-		String divider = addEqPlaceholder ? " =?, " : ", ";
-		Iterator<String> iterator = columns.iterator();
-		while (iterator.hasNext())
-			appendColumn(stringBuilder, iterator.next()).append(iterator.hasNext() ? divider : "");
-		return stringBuilder;
-	}
-	
-	private static StringBuilder appendColumn(StringBuilder stringBuilder, String column) {
-		return stringBuilder.append("'").append(column).append("\'");
-	}
-	
-	private static StringBuilder appendPlaceholders(StringBuilder stringBuilder, int count) {
-		for (int i = 0; i < count; ++i)
-			stringBuilder.append("?").append(i == count - 1 ? "" : ", ");
-		return stringBuilder;
-	}
-
-}
+package com.activeandroid.sebbia.util;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import android.database.Cursor;
+import android.os.Build;
+import android.text.TextUtils;
+
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Column.ConflictAction;
+import com.activeandroid.sebbia.serializer.TypeSerializer;
+
+public final class SQLiteUtils {
+	//////////////////////////////////////////////////////////////////////////////////////
+	// ENUMERATIONS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public enum SQLiteType {
+		INTEGER, REAL, TEXT, BLOB
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC CONSTANTS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE CONTSANTS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	@SuppressWarnings("serial")
+	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
+		{
+			put(byte.class, SQLiteType.INTEGER);
+			put(short.class, SQLiteType.INTEGER);
+			put(int.class, SQLiteType.INTEGER);
+			put(long.class, SQLiteType.INTEGER);
+			put(float.class, SQLiteType.REAL);
+			put(double.class, SQLiteType.REAL);
+			put(boolean.class, SQLiteType.INTEGER);
+			put(char.class, SQLiteType.TEXT);
+			put(byte[].class, SQLiteType.BLOB);
+			put(Byte.class, SQLiteType.INTEGER);
+			put(Short.class, SQLiteType.INTEGER);
+			put(Integer.class, SQLiteType.INTEGER);
+			put(Long.class, SQLiteType.INTEGER);
+			put(Float.class, SQLiteType.REAL);
+			put(Double.class, SQLiteType.REAL);
+			put(Boolean.class, SQLiteType.INTEGER);
+			put(Character.class, SQLiteType.TEXT);
+			put(String.class, SQLiteType.TEXT);
+			put(Byte[].class, SQLiteType.BLOB);
+		}
+	};
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE MEMBERS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private static HashMap<String, List<String>> sIndexGroupMap;
+	private static HashMap<String, List<String>> sUniqueGroupMap;
+	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public static void execSql(String sql) {
+		Cache.openDatabase().execSQL(sql);
+	}
+
+	public static void execSql(String sql, Object[] bindArgs) {
+		Cache.openDatabase().execSQL(sql, bindArgs);
+	}
+
+	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
+		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+		List<T> entities = processCursor(type, cursor);
+		cursor.close();
+
+		return entities;
+	}
+	  
+	public static int intQuery(final String sql, final String[] selectionArgs) {
+        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+        final int number = processIntCursor(cursor);
+        cursor.close();
+
+        return number;
+	}
+
+	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
+		List<T> entities = rawQuery(type, sql, selectionArgs);
+
+		if (entities.size() > 0) {
+			return entities.get(0);
+		}
+
+		return null;
+	}
+
+	// Database creation
+
+	public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
+		final ArrayList<String> definitions = new ArrayList<String>();
+		sUniqueGroupMap = new HashMap<String, List<String>>();
+		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
+
+		for (Field field : tableInfo.getFields()) {
+			createUniqueColumnDefinition(tableInfo, field);
+		}
+
+		if (sUniqueGroupMap.isEmpty()) {
+			return definitions;
+		}
+
+		Set<String> keySet = sUniqueGroupMap.keySet();
+		for (String key : keySet) {
+			List<String> group = sUniqueGroupMap.get(key);
+			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
+
+			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
+					TextUtils.join(", ", group), conflictAction.toString()));
+		}
+
+		return definitions;
+	}
+
+	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
+		final String name = tableInfo.getColumnName(field);
+		final Column column = field.getAnnotation(Column.class);
+
+        if (field.getName().equals("mId")) {
+            return;
+        }
+
+		String[] groups = column.uniqueGroups();
+		ConflictAction[] conflictActions = column.onUniqueConflicts();
+		if (groups.length != conflictActions.length)
+			return;
+
+		for (int i = 0; i < groups.length; i++) {
+			String group = groups[i];
+			ConflictAction conflictAction = conflictActions[i];
+
+			if (TextUtils.isEmpty(group))
+				continue;
+
+			List<String> list = sUniqueGroupMap.get(group);
+			if (list == null) {
+				list = new ArrayList<String>();
+			}
+			list.add(name);
+
+			sUniqueGroupMap.put(group, list);
+			sOnUniqueConflictsMap.put(group, conflictAction);
+		}
+	}
+
+	public static String[] createIndexDefinition(TableInfo tableInfo) {
+		final ArrayList<String> definitions = new ArrayList<String>();
+		sIndexGroupMap = new HashMap<String, List<String>>();
+
+		for (Field field : tableInfo.getFields()) {
+			createIndexColumnDefinition(tableInfo, field);
+		}
+
+		if (sIndexGroupMap.isEmpty()) {
+			return new String[0];
+		}
+
+		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
+			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
+					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
+					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
+		}
+
+		return definitions.toArray(new String[definitions.size()]);
+	}
+
+	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
+		final String name = tableInfo.getColumnName(field);
+		final Column column = field.getAnnotation(Column.class);
+
+        if (field.getName().equals("mId")) {
+            return;
+        }
+
+		if (column.index()) {
+			List<String> list = new ArrayList<String>();
+			list.add(name);
+			sIndexGroupMap.put(name, list);
+		}
+
+		String[] groups = column.indexGroups();
+		for (String group : groups) {
+			if (TextUtils.isEmpty(group))
+				continue;
+
+			List<String> list = sIndexGroupMap.get(group);
+			if (list == null) {
+				list = new ArrayList<String>();
+			}
+
+			list.add(name);
+			sIndexGroupMap.put(group, list);
+		}
+	}
+
+	public static String createTableDefinition(TableInfo tableInfo) {
+		final ArrayList<String> definitions = new ArrayList<String>();
+
+		for (Field field : tableInfo.getFields()) {
+			String definition = createColumnDefinition(tableInfo, field);
+			if (!TextUtils.isEmpty(definition)) {
+				definitions.add(definition);
+			}
+		}
+
+		definitions.addAll(createUniqueDefinition(tableInfo));
+
+		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
+				TextUtils.join(", ", definitions));
+	}
+
+	@SuppressWarnings("unchecked")
+	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
+		StringBuilder definition = new StringBuilder();
+
+		Class<?> type = field.getType();
+		final String name = tableInfo.getColumnName(field);
+		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
+		final Column column = field.getAnnotation(Column.class);
+
+		if (typeSerializer != null) {
+			type = typeSerializer.getSerializedType();
+		}
+		
+		SQLiteType sqLiteType = null;
+		if (TYPE_MAP.containsKey(type)) {
+			sqLiteType = TYPE_MAP.get(type);
+		}
+		else if (ReflectionUtils.isModel(type)) {
+			sqLiteType = SQLiteType.INTEGER;
+		}
+		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
+			sqLiteType = SQLiteType.TEXT;
+		}
+		
+		if (sqLiteType != null) {
+			definition.append(name);
+			definition.append(" ");
+			definition.append(sqLiteType.toString());
+		}
+
+		if (!TextUtils.isEmpty(definition)) {
+
+			if (name.equals(tableInfo.getIdName())) {
+				definition.append(" PRIMARY KEY AUTOINCREMENT");
+			}else if(column!=null){
+				if (column.length() > -1) {
+					definition.append("(");
+					definition.append(column.length());
+					definition.append(")");
+				}
+
+				if (column.notNull()) {
+					definition.append(" NOT NULL ON CONFLICT ");
+					definition.append(column.onNullConflict().toString());
+				}
+
+				if (column.unique()) {
+					definition.append(" UNIQUE ON CONFLICT ");
+					definition.append(column.onUniqueConflict().toString());
+				}
+				
+				if (!TextUtils.isEmpty(column.defaultValue())) {
+					String defaultValue = null;
+					switch (sqLiteType) {
+					case TEXT: case BLOB:
+						defaultValue = "\"" + column.defaultValue() + "\"";
+						break;
+
+					case INTEGER:
+						try {
+							if (type.equals(Boolean.class) || type.equals(boolean.class)) {
+								boolean value = Boolean.parseBoolean(column.defaultValue());
+								defaultValue = value ? "1" : "0";
+							} else {
+								Integer.parseInt(column.defaultValue());
+								defaultValue = column.defaultValue();
+							}
+						} catch (NumberFormatException e) {
+							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
+						}
+						break;
+						
+					case REAL:
+						try {
+							Double.parseDouble(column.defaultValue());
+							defaultValue = column.defaultValue();
+						} catch (NumberFormatException e) {
+							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
+						}
+						break;
+					}
+					
+					if (defaultValue != null) {
+						definition.append(" DEFAULT ");
+						definition.append(defaultValue);
+					}
+				}
+			}
+
+			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type) && Cache.getTableInfo((Class<? extends Model>) type) != null) {
+				definition.append(" REFERENCES ");
+				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
+				definition.append("("+tableInfo.getIdName()+")");
+				definition.append(" ON DELETE ");
+				definition.append(column.onDelete().toString().replace("_", " "));
+				definition.append(" ON UPDATE ");
+				definition.append(column.onUpdate().toString().replace("_", " "));
+			}
+		
+		}
+		else {
+			Log.e("No type mapping for: " + type.toString());
+		}
+
+		return definition.toString();
+	}
+
+	@SuppressWarnings("unchecked")
+	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
+		TableInfo tableInfo = Cache.getTableInfo(type);
+		String idName = tableInfo.getIdName();
+		final List<T> entities = new ArrayList<T>();
+
+		try {
+			Constructor<?> entityConstructor = type.getConstructor();
+
+			if (cursor.moveToFirst()) {
+                /**
+                 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+                 * when the cursor have multiple columns with same name obtained from join tables.
+                 */
+                List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+				do {
+					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
+					if (entity == null) {
+						entity = (T) entityConstructor.newInstance();
+					}
+
+					entity.loadFromCursor(cursor);
+					entities.add((T) entity);
+				}
+				while (cursor.moveToNext());
+			}
+
+		}
+		catch (NoSuchMethodException e) {
+			throw new RuntimeException(
+                "Your model " + type.getName() + " does not define a default " +
+                "constructor. The default constructor is required for " +
+                "now in ActiveAndroid models, as the process to " +
+                "populate the ORM model is : " +
+                "1. instantiate default model " +
+                "2. populate fields"
+            );
+		}
+		catch (Exception e) {
+			Log.e("Failed to process cursor.", e);
+		}
+
+		return entities;
+	}
+
+	private static int processIntCursor(final Cursor cursor) {
+        if (cursor.moveToFirst()) {
+            return cursor.getInt(0);
+	    }
+        return 0;
+    }
+
+	public static List<String> lexSqlScript(String sqlScript) {
+		ArrayList<String> sl = new ArrayList<String>();
+		boolean inString = false, quoteNext = false;
+		StringBuilder b = new StringBuilder(100);
+
+		for (int i = 0; i < sqlScript.length(); i++) {
+			char c = sqlScript.charAt(i);
+
+			if (c == ';' && !inString && !quoteNext) {
+				sl.add(b.toString());
+				b = new StringBuilder(100);
+				inString = false;
+				quoteNext = false;
+				continue;
+			}
+
+			if (c == '\'' && !quoteNext) {
+				inString = !inString;
+			}
+
+			quoteNext = c == '\\' && !quoteNext;
+
+			b.append(c);
+		}
+
+		if (b.length() > 0) {
+			sl.add(b.toString());
+		}
+
+		return sl;
+	}
+	
+	public static String createInsertStatement(String insertInto, TableInfo tableInfo) {
+		StringBuilder stringBuilder = new StringBuilder(insertInto);
+		stringBuilder
+			.append(tableInfo.getTableName())
+			.append(" (");
+			appendColumns(stringBuilder, tableInfo.getColumnNames(), false)
+			.append(") VALUES (");
+		appendPlaceholders(stringBuilder, tableInfo.getFields().size());
+		stringBuilder.append(")");
+		return stringBuilder.toString();
+	}
+	
+	public static String createUpdateStatement(TableInfo tableInfo) {
+		StringBuilder stringBuilder = new StringBuilder("UPDATE ");
+		stringBuilder
+			.append(tableInfo.getTableName())
+			.append(" SET ");
+		appendColumns(stringBuilder, tableInfo.getColumnNames(), true)
+			.append(" WHERE ");
+		appendColumn(stringBuilder, tableInfo.getIdName())
+			.append(" = ?");
+		return stringBuilder.toString();
+	}
+	
+	private static StringBuilder appendColumns(StringBuilder stringBuilder, Collection<String> columns, boolean addEqPlaceholder) {
+		String divider = addEqPlaceholder ? " =?, " : ", ";
+		Iterator<String> iterator = columns.iterator();
+		while (iterator.hasNext())
+			appendColumn(stringBuilder, iterator.next()).append(iterator.hasNext() ? divider : "");
+		return stringBuilder;
+	}
+	
+	private static StringBuilder appendColumn(StringBuilder stringBuilder, String column) {
+		return stringBuilder.append("'").append(column).append("\'");
+	}
+	
+	private static StringBuilder appendPlaceholders(StringBuilder stringBuilder, int count) {
+		for (int i = 0; i < count; ++i)
+			stringBuilder.append("?").append(i == count - 1 ? "" : ", ");
+		return stringBuilder;
+	}
+
+}
diff --git a/src/com/activeandroid/sebbia/util/SqlParser.java b/library/src/main/java/com/activeandroid/sebbia/util/SqlParser.java
similarity index 100%
rename from src/com/activeandroid/sebbia/util/SqlParser.java
rename to library/src/main/java/com/activeandroid/sebbia/util/SqlParser.java
diff --git a/src/com/activeandroid/sebbia/util/Tokenizer.java b/library/src/main/java/com/activeandroid/sebbia/util/Tokenizer.java
similarity index 100%
rename from src/com/activeandroid/sebbia/util/Tokenizer.java
rename to library/src/main/java/com/activeandroid/sebbia/util/Tokenizer.java
diff --git a/src/com/activeandroid/sebbia/widget/ModelAdapter.java b/library/src/main/java/com/activeandroid/sebbia/widget/ModelAdapter.java
similarity index 100%
rename from src/com/activeandroid/sebbia/widget/ModelAdapter.java
rename to library/src/main/java/com/activeandroid/sebbia/widget/ModelAdapter.java
diff --git a/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java b/processor/src/main/java/com/activeandroid/sebbia/ActiveAndroidProcessor.java
similarity index 97%
rename from src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
rename to processor/src/main/java/com/activeandroid/sebbia/ActiveAndroidProcessor.java
index 81969839..b864e6fd 100644
--- a/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
+++ b/processor/src/main/java/com/activeandroid/sebbia/ActiveAndroidProcessor.java
@@ -1,423 +1,425 @@
-package com.activeandroid.sebbia.internal;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.tools.Diagnostic.Kind;
-import javax.tools.JavaFileObject;
-
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.DoNotGenerate;
-
-public final class AnnotationProcessor extends AbstractProcessor {
-
-	private static final String MODEL = "model";
-	private static final String CURSOR = "cursor";
-	private static final String CONTENT_VALUES = "contentValues";
-	private static final String COLUMNS_ORDERED = "columnsOrdered";
-	private static final String STATEMENT = "statement";
-	private static final String COLUMNS = "columns";
-
-	private RoundEnvironment env;
-
-	@Override
-	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
-		this.env = env;
-		if (annotations.size() > 0) {
-			parseColumns();
-		}
-		return true;
-	}
-
-	@Override
-	public Set<String> getSupportedAnnotationTypes() {
-		Set<String> supportedTypes = new HashSet<String>();
-		supportedTypes.add(Column.class.getCanonicalName());
-		return supportedTypes;
-	}
-
-	@Override
-	public SourceVersion getSupportedSourceVersion() {
-		return SourceVersion.latestSupported();
-	}
-
-	private void parseColumns() {
-		Set<? extends Element> columns = env.getElementsAnnotatedWith(Column.class);
-		Map<TypeElement, Set<VariableElement>> tables = new HashMap<TypeElement, Set<VariableElement>>();
-		for (Element element : columns) {
-			if (element instanceof VariableElement == false || element.getKind() != ElementKind.FIELD) {
-				error("@Column annotation should be applied only to local variables", element);
-				continue;
-			}
-			VariableElement columnElement = (VariableElement) element;
-
-			TypeElement tableElement = null;
-			if (element.getEnclosingElement() instanceof TypeElement) {
-				tableElement = (TypeElement) element.getEnclosingElement();
-			} else {
-				error("@Column annotation located not inside of class", element);
-				continue;
-			}
-				
-			if (checkTableModifiers(tableElement) == false)
-				continue;
-			
-			if (checkColumnModifiers(columnElement) == false)
-				continue;
-
-			Set<VariableElement> columnsElements = tables.get(tableElement);
-			if (columnsElements == null) {
-				columnsElements = new HashSet<VariableElement>();
-				tables.put(tableElement, columnsElements);
-			}
-
-			columnsElements.add(columnElement);
-
-		}
-
-		for (TypeElement table : tables.keySet()) {
-			generate(table, tables.get(table));
-		}
-	}
-
-	private void generate(TypeElement tableElement, Set<VariableElement> columns) {
-		String packageName = processingEnv.getElementUtils().getPackageOf(tableElement).getQualifiedName().toString();
-		String className = tableElement.getQualifiedName().toString();
-		String fillerClassName = getClassName(tableElement, packageName) + ModelFiller.SUFFIX;
-
-		try {
-			JavaFileObject jfo = processingEnv.getFiler().createSourceFile(packageName + "." + fillerClassName, tableElement);
-			Writer writer = jfo.openWriter();
-			writer.write("//Generated by ActiveAndroid. Do not modify\n");
-			writer.write("package " + packageName + ";\n\n");
-			
-			writer.write("import android.database.sqlite.SQLiteStatement;\n");
-			writer.write("import java.util.ArrayList;\n");
-			writer.write("import java.util.Arrays;\n");
-			writer.write("import java.util.List;\n\n");
-			writer.write("import java.util.Map;\n\n");
-
-			writer.write("import com.activeandroid.sebbia.internal.ModelHelper;\n");
-			writer.write("import com.activeandroid.sebbia.internal.ModelFiller;\n");
-			writer.write("\n");
-			writer.write("public class " + fillerClassName + " extends ModelFiller {\n\n");
-			writer.write("  public void loadFromCursor(com.activeandroid.sebbia.Model genericModel, android.database.Cursor " + CURSOR + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.loadFromCursor(genericModel, " + CURSOR + ");\n");
-			writer.write("    List<String> " + COLUMNS_ORDERED + " = new ArrayList<String>(Arrays.asList(" + CURSOR + ".getColumnNames()));\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getLoadFromCursorCode(columns));
-			writer.write("  }\n\n");
-
-			
-			writer.write("  public void fillContentValues(com.activeandroid.sebbia.Model genericModel, android.content.ContentValues " + CONTENT_VALUES + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.fillContentValues(genericModel, " + CONTENT_VALUES + ");\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getFillContentValuesCode(columns));
-			writer.write("  }\n");
-			
-			writer.write("  public void bindStatement(com.activeandroid.sebbia.Model genericModel, SQLiteStatement " + STATEMENT + ", Map<String, Integer> " + COLUMNS + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.bindStatement(genericModel, " + STATEMENT + ", " + COLUMNS + ");\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getBindStatementCode(columns));
-			writer.write("  }\n");
-
-			writer.write("}");
-			writer.flush();
-			writer.close();
-		} catch (IOException exception) {
-			processingEnv.getMessager().printMessage(Kind.ERROR, exception.getMessage());
-		}
-	}
-
-	private String getLoadFromCursorCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-
-			TypeMirror typeMirror = column.asType();
-			String type = getClassString(typeMirror, typeMirror instanceof DeclaredType);
-			String getColumnIndex = COLUMNS_ORDERED + ".indexOf(\"" + fieldName + "\")";
-
-			String setValue = "    " + MODEL + "." + column.getSimpleName() + " = " + CURSOR;
-
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append("    " + MODEL + "." + column.getSimpleName() + " = (short) " + CURSOR + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append(setValue + ".getLong(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append(setValue + ".getFloat(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append(setValue + ".getDouble(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ") != 0;\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append(setValue + ".getBlob(" + getColumnIndex + ");\n");
-			else {
-				processingEnv.getMessager().printMessage(Kind.NOTE, "Guessing what type is at " + typeMirror.toString(), null);
-				stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
-				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = (" + typeMirror.toString() + ") ModelHelper.getSerializable(cursor, " + type + ", " + getColumnIndex + ");\n");
-				stringBuilder.append("    } else {\n");
-				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = ");
-				if (isTypeOf(typeMirror, Model.class))
-					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getModel(cursor, " + type + ", " + getColumnIndex + ");\n");
-				else if (isTypeOf(typeMirror, Enum.class))
-					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getEnum(cursor, " + type + ", " + getColumnIndex + ");\n");
-				else
-					stringBuilder.append(" null;\n");
-				
-				stringBuilder.append("    }\n");
-			}
-		}
-		return stringBuilder.toString();
-	}
-
-	private String getFillContentValuesCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-			
-			TypeMirror typeMirror = column.asType();
-			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
-			String type = getClassString(typeMirror, notPrimitiveType);
-			String getValue = MODEL + "." + column.getSimpleName();
-			
-			boolean hasDefault = annotation.defaultValue() != null && annotation.defaultValue().isEmpty() == false;
-			String emptySpace = "    ";
-			if (notPrimitiveType) {
-				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
-				emptySpace += "  ";
- 			}
-			String putValue = emptySpace + CONTENT_VALUES + ".put(\"" + fieldName + "\", " + getValue;
-			
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append(putValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append(putValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append(putValue + ");\n");
-			else {
-				stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
-				stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + CONTENT_VALUES + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
-				stringBuilder.append(emptySpace + "} else {\n");
-				stringBuilder.append(emptySpace + "  " + CONTENT_VALUES + ".");
-				if (isTypeOf(typeMirror, Model.class))
-					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".getId());\n");
-				else if (isTypeOf(typeMirror, Enum.class))
-					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".name());\n");
-				else
-					stringBuilder.append("putNull(\"" + fieldName + "\");\n");
-				stringBuilder.append(emptySpace + "}\n");
-			}
-			if (notPrimitiveType) {
-				if (hasDefault == false) {
-					stringBuilder.append("    } else {\n");
-					stringBuilder.append("      " + CONTENT_VALUES + ".putNull(\"" + fieldName +  "\");\n");
-				}
-				stringBuilder.append("    }\n");
-			}
-		}
-		return stringBuilder.toString();
-	}
-	
-	private String getBindStatementCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-			
-			TypeMirror typeMirror = column.asType();
-			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
-			String type = getClassString(typeMirror, notPrimitiveType);
-			
-			String getValue = MODEL + "." + column.getSimpleName();
-			
-			String columnIndex = COLUMNS + ".get(\"" + fieldName + "\")"; 
-			String emptySpace = "    ";
-			
-			if (notPrimitiveType) {
-				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
-				emptySpace += "  ";
- 			}
-			String bind = emptySpace + STATEMENT + ".bind";
-			
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + " ? 1 : 0);\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append(bind + "Blob(" + columnIndex + ", " + getValue + ");\n");
-			else {
-				boolean isModel = isTypeOf(typeMirror, Model.class);
-				boolean isEnum = isTypeOf(typeMirror, Enum.class);
-				if (isModel || isEnum) {
-					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
-					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
-					stringBuilder.append(emptySpace + "} else {\n");
-					stringBuilder.append(emptySpace + "  " + STATEMENT + ".bind");
-					if (isModel)
-						stringBuilder.append("Long(" + columnIndex + ", " + getValue + ".getId());\n");
-					else if (isEnum)
-						stringBuilder.append("String(" + columnIndex + ", " + getValue + ".name());\n");
-					stringBuilder.append(emptySpace + "}\n");
-				} else {
-					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + "))\n");
-					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");
-				}
-			}
-			if (notPrimitiveType)
-				stringBuilder.append("    }\n");
-		}
-		return stringBuilder.toString();
-	}
-
-	private String getClassString(TypeMirror typeMirror, boolean notPrimitiveType) {
-		String type = typeMirror.toString() + ".class";
-		if (notPrimitiveType) {
-			DeclaredType declaredType = (DeclaredType) typeMirror;
-			List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-			if (typeArguments != null && typeArguments.size() > 0)
-				type = ((TypeElement) declaredType.asElement()).getQualifiedName() + ".class";
-		}
-		return type;
-	}
-
-	private boolean isTypeOf(TypeMirror typeMirror, Class<?> type) {
-		if (type.getCanonicalName().equals(typeMirror.toString()))
-			return true;
-
-		if (typeMirror instanceof DeclaredType == false)
-			return false;
-
-		DeclaredType declaredType = (DeclaredType) typeMirror;
-		Element element = declaredType.asElement();
-		if (element instanceof TypeElement == false)
-			return false;
-
-		TypeElement typeElement = (TypeElement) element;
-		if (type == Enum.class)
-			return typeElement.getKind() == ElementKind.ENUM;
-		
-		TypeMirror superType = typeElement.getSuperclass();
-		if (isTypeOf(superType, type))
-			return true;
-		return false;
-	}
-
-	private boolean checkTableModifiers(TypeElement table) {
-		if (table.getModifiers().contains(Modifier.PRIVATE)) {
-			error("Classes marked with @Table cannot be private", table);
-			return false;
-		}
-
-		if (table.getKind() != ElementKind.CLASS) {
-			error("Only classes can be marked with @Table annotation", table);
-			return false;
-		}
-		
-		if (table.getAnnotation(DoNotGenerate.class) != null)
-			return false;
-
-		return true;
-	}
-
-	private boolean checkColumnModifiers(VariableElement column) {
-
-		if (column.getModifiers().contains(Modifier.PRIVATE)) {
-			error("Field marked with @Column cannot be private", column);
-			return false;
-		}
-
-		if (column.getModifiers().contains(Modifier.FINAL)) {
-			error("Field marked with @Column cannot be final", column);
-			return false;
-		}
-
-		if (column.getModifiers().contains(Modifier.STATIC)) {
-			error("Field marked with @Column cannot be static", column);
-			return false;
-		}
-
-		return true;
-	}
-
-	private void error(String message, Element element) {
-		processingEnv.getMessager().printMessage(Kind.ERROR, message, element);
-	}
-
-	private static String getClassName(TypeElement type, String packageName) {
-		int packageLen = packageName.length() + 1;
-		return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
-	}
-}
+package com.activeandroid.sebbia;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic.Kind;
+import javax.tools.JavaFileObject;
+
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.DoNotGenerate;
+
+public final class ActiveAndroidProcessor extends AbstractProcessor {
+
+    public static final String SUFFIX = "$$ActiveAndroidModelFiller";
+
+	private static final String MODEL = "model";
+	private static final String CURSOR = "cursor";
+	private static final String CONTENT_VALUES = "contentValues";
+	private static final String COLUMNS_ORDERED = "columnsOrdered";
+	private static final String STATEMENT = "statement";
+	private static final String COLUMNS = "columns";
+
+	private RoundEnvironment env;
+
+	@Override
+	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
+		this.env = env;
+		if (annotations.size() > 0) {
+			parseColumns();
+		}
+		return true;
+	}
+
+	@Override
+	public Set<String> getSupportedAnnotationTypes() {
+		Set<String> supportedTypes = new HashSet<String>();
+		supportedTypes.add(Column.class.getCanonicalName());
+		return supportedTypes;
+	}
+
+	@Override
+	public SourceVersion getSupportedSourceVersion() {
+		return SourceVersion.latestSupported();
+	}
+
+	private void parseColumns() {
+		Set<? extends Element> columns = env.getElementsAnnotatedWith(Column.class);
+		Map<TypeElement, Set<VariableElement>> tables = new HashMap<TypeElement, Set<VariableElement>>();
+		for (Element element : columns) {
+			if (element instanceof VariableElement == false || element.getKind() != ElementKind.FIELD) {
+				error("@Column annotation should be applied only to local variables", element);
+				continue;
+			}
+			VariableElement columnElement = (VariableElement) element;
+
+			TypeElement tableElement = null;
+			if (element.getEnclosingElement() instanceof TypeElement) {
+				tableElement = (TypeElement) element.getEnclosingElement();
+			} else {
+				error("@Column annotation located not inside of class", element);
+				continue;
+			}
+				
+			if (checkTableModifiers(tableElement) == false)
+				continue;
+			
+			if (checkColumnModifiers(columnElement) == false)
+				continue;
+
+			Set<VariableElement> columnsElements = tables.get(tableElement);
+			if (columnsElements == null) {
+				columnsElements = new HashSet<VariableElement>();
+				tables.put(tableElement, columnsElements);
+			}
+
+			columnsElements.add(columnElement);
+
+		}
+
+		for (TypeElement table : tables.keySet()) {
+			generate(table, tables.get(table));
+		}
+	}
+
+	private void generate(TypeElement tableElement, Set<VariableElement> columns) {
+		String packageName = processingEnv.getElementUtils().getPackageOf(tableElement).getQualifiedName().toString();
+		String className = tableElement.getQualifiedName().toString();
+		String fillerClassName = getClassName(tableElement, packageName) + SUFFIX;
+
+		try {
+			JavaFileObject jfo = processingEnv.getFiler().createSourceFile(packageName + "." + fillerClassName, tableElement);
+			Writer writer = jfo.openWriter();
+			writer.write("//Generated by ActiveAndroid. Do not modify\n");
+			writer.write("package " + packageName + ";\n\n");
+			
+			writer.write("import android.database.sqlite.SQLiteStatement;\n");
+			writer.write("import java.util.ArrayList;\n");
+			writer.write("import java.util.Arrays;\n");
+			writer.write("import java.util.List;\n\n");
+			writer.write("import java.util.Map;\n\n");
+
+			writer.write("import com.activeandroid.sebbia.internal.ModelHelper;\n");
+			writer.write("import com.activeandroid.sebbia.internal.ModelFiller;\n");
+			writer.write("\n");
+			writer.write("public class " + fillerClassName + " extends ModelFiller {\n\n");
+			writer.write("  public void loadFromCursor(com.activeandroid.sebbia.Model genericModel, android.database.Cursor " + CURSOR + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.loadFromCursor(genericModel, " + CURSOR + ");\n");
+			writer.write("    List<String> " + COLUMNS_ORDERED + " = new ArrayList<String>(Arrays.asList(" + CURSOR + ".getColumnNames()));\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getLoadFromCursorCode(columns));
+			writer.write("  }\n\n");
+
+			
+			writer.write("  public void fillContentValues(com.activeandroid.sebbia.Model genericModel, android.content.ContentValues " + CONTENT_VALUES + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.fillContentValues(genericModel, " + CONTENT_VALUES + ");\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getFillContentValuesCode(columns));
+			writer.write("  }\n");
+			
+			writer.write("  public void bindStatement(com.activeandroid.sebbia.Model genericModel, SQLiteStatement " + STATEMENT + ", Map<String, Integer> " + COLUMNS + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.bindStatement(genericModel, " + STATEMENT + ", " + COLUMNS + ");\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getBindStatementCode(columns));
+			writer.write("  }\n");
+
+			writer.write("}");
+			writer.flush();
+			writer.close();
+		} catch (IOException exception) {
+			processingEnv.getMessager().printMessage(Kind.ERROR, exception.getMessage());
+		}
+	}
+
+	private String getLoadFromCursorCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+
+			TypeMirror typeMirror = column.asType();
+			String type = getClassString(typeMirror, typeMirror instanceof DeclaredType);
+			String getColumnIndex = COLUMNS_ORDERED + ".indexOf(\"" + fieldName + "\")";
+
+			String setValue = "    " + MODEL + "." + column.getSimpleName() + " = " + CURSOR;
+
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append("    " + MODEL + "." + column.getSimpleName() + " = (short) " + CURSOR + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append(setValue + ".getLong(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append(setValue + ".getFloat(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append(setValue + ".getDouble(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ") != 0;\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append(setValue + ".getBlob(" + getColumnIndex + ");\n");
+			else {
+				processingEnv.getMessager().printMessage(Kind.NOTE, "Guessing what type is at " + typeMirror.toString(), null);
+				stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
+				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = (" + typeMirror.toString() + ") ModelHelper.getSerializable(cursor, " + type + ", " + getColumnIndex + ");\n");
+				stringBuilder.append("    } else {\n");
+				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = ");
+				if (isTypeOf(typeMirror, Model.class))
+					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getModel(cursor, " + type + ", " + getColumnIndex + ");\n");
+				else if (isTypeOf(typeMirror, Enum.class))
+					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getEnum(cursor, " + type + ", " + getColumnIndex + ");\n");
+				else
+					stringBuilder.append(" null;\n");
+				
+				stringBuilder.append("    }\n");
+			}
+		}
+		return stringBuilder.toString();
+	}
+
+	private String getFillContentValuesCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+			
+			TypeMirror typeMirror = column.asType();
+			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
+			String type = getClassString(typeMirror, notPrimitiveType);
+			String getValue = MODEL + "." + column.getSimpleName();
+			
+			boolean hasDefault = annotation.defaultValue() != null && annotation.defaultValue().isEmpty() == false;
+			String emptySpace = "    ";
+			if (notPrimitiveType) {
+				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
+				emptySpace += "  ";
+ 			}
+			String putValue = emptySpace + CONTENT_VALUES + ".put(\"" + fieldName + "\", " + getValue;
+			
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append(putValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append(putValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append(putValue + ");\n");
+			else {
+				stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
+				stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + CONTENT_VALUES + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
+				stringBuilder.append(emptySpace + "} else {\n");
+				stringBuilder.append(emptySpace + "  " + CONTENT_VALUES + ".");
+				if (isTypeOf(typeMirror, Model.class))
+					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".getId());\n");
+				else if (isTypeOf(typeMirror, Enum.class))
+					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".name());\n");
+				else
+					stringBuilder.append("putNull(\"" + fieldName + "\");\n");
+				stringBuilder.append(emptySpace + "}\n");
+			}
+			if (notPrimitiveType) {
+				if (hasDefault == false) {
+					stringBuilder.append("    } else {\n");
+					stringBuilder.append("      " + CONTENT_VALUES + ".putNull(\"" + fieldName +  "\");\n");
+				}
+				stringBuilder.append("    }\n");
+			}
+		}
+		return stringBuilder.toString();
+	}
+	
+	private String getBindStatementCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+			
+			TypeMirror typeMirror = column.asType();
+			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
+			String type = getClassString(typeMirror, notPrimitiveType);
+			
+			String getValue = MODEL + "." + column.getSimpleName();
+			
+			String columnIndex = COLUMNS + ".get(\"" + fieldName + "\")"; 
+			String emptySpace = "    ";
+			
+			if (notPrimitiveType) {
+				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
+				emptySpace += "  ";
+ 			}
+			String bind = emptySpace + STATEMENT + ".bind";
+			
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + " ? 1 : 0);\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append(bind + "Blob(" + columnIndex + ", " + getValue + ");\n");
+			else {
+				boolean isModel = isTypeOf(typeMirror, Model.class);
+				boolean isEnum = isTypeOf(typeMirror, Enum.class);
+				if (isModel || isEnum) {
+					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
+					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
+					stringBuilder.append(emptySpace + "} else {\n");
+					stringBuilder.append(emptySpace + "  " + STATEMENT + ".bind");
+					if (isModel)
+						stringBuilder.append("Long(" + columnIndex + ", " + getValue + ".getId());\n");
+					else if (isEnum)
+						stringBuilder.append("String(" + columnIndex + ", " + getValue + ".name());\n");
+					stringBuilder.append(emptySpace + "}\n");
+				} else {
+					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + "))\n");
+					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");
+				}
+			}
+			if (notPrimitiveType)
+				stringBuilder.append("    }\n");
+		}
+		return stringBuilder.toString();
+	}
+
+	private String getClassString(TypeMirror typeMirror, boolean notPrimitiveType) {
+		String type = typeMirror.toString() + ".class";
+		if (notPrimitiveType) {
+			DeclaredType declaredType = (DeclaredType) typeMirror;
+			List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+			if (typeArguments != null && typeArguments.size() > 0)
+				type = ((TypeElement) declaredType.asElement()).getQualifiedName() + ".class";
+		}
+		return type;
+	}
+
+	private boolean isTypeOf(TypeMirror typeMirror, Class<?> type) {
+		if (type.getCanonicalName().equals(typeMirror.toString()))
+			return true;
+
+		if (typeMirror instanceof DeclaredType == false)
+			return false;
+
+		DeclaredType declaredType = (DeclaredType) typeMirror;
+		Element element = declaredType.asElement();
+		if (element instanceof TypeElement == false)
+			return false;
+
+		TypeElement typeElement = (TypeElement) element;
+		if (type == Enum.class)
+			return typeElement.getKind() == ElementKind.ENUM;
+		
+		TypeMirror superType = typeElement.getSuperclass();
+		if (isTypeOf(superType, type))
+			return true;
+		return false;
+	}
+
+	private boolean checkTableModifiers(TypeElement table) {
+		if (table.getModifiers().contains(Modifier.PRIVATE)) {
+			error("Classes marked with @Table cannot be private", table);
+			return false;
+		}
+
+		if (table.getKind() != ElementKind.CLASS) {
+			error("Only classes can be marked with @Table annotation", table);
+			return false;
+		}
+		
+		if (table.getAnnotation(DoNotGenerate.class) != null)
+			return false;
+
+		return true;
+	}
+
+	private boolean checkColumnModifiers(VariableElement column) {
+
+		if (column.getModifiers().contains(Modifier.PRIVATE)) {
+			error("Field marked with @Column cannot be private", column);
+			return false;
+		}
+
+		if (column.getModifiers().contains(Modifier.FINAL)) {
+			error("Field marked with @Column cannot be final", column);
+			return false;
+		}
+
+		if (column.getModifiers().contains(Modifier.STATIC)) {
+			error("Field marked with @Column cannot be static", column);
+			return false;
+		}
+
+		return true;
+	}
+
+	private void error(String message, Element element) {
+		processingEnv.getMessager().printMessage(Kind.ERROR, message, element);
+	}
+
+	private static String getClassName(TypeElement type, String packageName) {
+		int packageLen = packageName.length() + 1;
+		return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
+	}
+}
diff --git a/processor/src/main/java/com/activeandroid/sebbia/Model.java b/processor/src/main/java/com/activeandroid/sebbia/Model.java
new file mode 100644
index 00000000..3ef6681b
--- /dev/null
+++ b/processor/src/main/java/com/activeandroid/sebbia/Model.java
@@ -0,0 +1,23 @@
+package com.activeandroid.sebbia;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Empty class just for reference during AP
+@SuppressWarnings("unchecked")
+public abstract class Model {
+
+}
diff --git a/processor/src/main/java/com/activeandroid/sebbia/annotation/Column.java b/processor/src/main/java/com/activeandroid/sebbia/annotation/Column.java
new file mode 100644
index 00000000..79fa6af6
--- /dev/null
+++ b/processor/src/main/java/com/activeandroid/sebbia/annotation/Column.java
@@ -0,0 +1,32 @@
+package com.activeandroid.sebbia.annotation;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+// Empty copy of Column from library, just for reference during AP
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Column {
+	String name() default "";
+
+	String defaultValue() default "";
+
+}
diff --git a/processor/src/main/java/com/activeandroid/sebbia/annotation/DoNotGenerate.java b/processor/src/main/java/com/activeandroid/sebbia/annotation/DoNotGenerate.java
new file mode 100644
index 00000000..c97b3fa4
--- /dev/null
+++ b/processor/src/main/java/com/activeandroid/sebbia/annotation/DoNotGenerate.java
@@ -0,0 +1,10 @@
+package com.activeandroid.sebbia.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface DoNotGenerate { }
diff --git a/processor/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/processor/src/main/resources/META-INF/services/javax.annotation.processing.Processor
new file mode 100644
index 00000000..e4996e47
--- /dev/null
+++ b/processor/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -0,0 +1 @@
+com.activeandroid.sebbia.ActiveAndroidProcessor
\ No newline at end of file
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..10dad912
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,2 @@
+include ':library'
+include ':processor'
\ No newline at end of file
diff --git a/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
deleted file mode 100644
index 67358b71..00000000
--- a/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ /dev/null
@@ -1 +0,0 @@
-com.activeandroid.sebbia.internal.AnnotationProcessor
\ No newline at end of file
