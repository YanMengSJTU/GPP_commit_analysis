diff --git a/src/main/java/com/activeandroid/DatabaseHelper.java b/src/main/java/com/activeandroid/DatabaseHelper.java
index c7a28625..7ad68615 100644
--- a/src/main/java/com/activeandroid/DatabaseHelper.java
+++ b/src/main/java/com/activeandroid/DatabaseHelper.java
@@ -41,11 +41,11 @@
 import java.util.List;
 
 public class DatabaseHelper extends SQLiteOpenHelper {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public final static String MIGRATION_PATH = "migrations";
+    public final static String MIGRATION_PATH = "migrations";
 
     public final static String TEMP_DB_NAME = "temp-";
 
@@ -55,14 +55,14 @@
 
     DatabaseHelperListener mListener;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public DatabaseHelper(Configuration configuration) {
-		super(configuration.getContext(), configuration.getDatabaseName(), null, configuration.getDatabaseVersion());
+    public DatabaseHelper(Configuration configuration) {
+        super(configuration.getContext(), configuration.getDatabaseName(), null, configuration.getDatabaseVersion());
         mDatabaseName = configuration.getDatabaseName();
-		copyAttachedDatabase(configuration.getContext(), configuration.getDatabaseName(), configuration.getDatabaseName());
+        copyAttachedDatabase(configuration.getContext(), configuration.getDatabaseName(), configuration.getDatabaseName());
 
         // temporary database uses the same methods
         mTempDatabase = new SQLiteOpenHelper(configuration.getContext(), TEMP_DB_NAME + configuration.getDatabaseName(),
@@ -90,60 +90,60 @@ public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
         // see if we need to make this mirror the prepackaged
         restoreDatabase(configuration.getContext(), TEMP_DB_NAME + configuration.getDatabaseName(), configuration.getDatabaseName());
         mTempDatabase.getWritableDatabase();
-	}
+    }
 
-    public void setListener(DatabaseHelperListener listener){
+    public void setListener(DatabaseHelperListener listener) {
         mListener = listener;
     }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	@Override
-	public void onOpen(SQLiteDatabase db) {
-        if(mListener!=null){
+    @Override
+    public void onOpen(SQLiteDatabase db) {
+        if (mListener != null) {
             mListener.onOpen(db);
         }
-		executePragmas(db);
-	}
+        executePragmas(db);
+    }
 
-	@Override
-	public void onCreate(SQLiteDatabase db) {
-        if(mListener!=null){
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        if (mListener != null) {
             mListener.onCreate(db);
         }
-		executePragmas(db);
-		executeCreate(db);
-		executeMigrations(db, -1, db.getVersion());
-	}
-
-	@Override
-	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        if(mListener!=null){
+        executePragmas(db);
+        executeCreate(db);
+        executeMigrations(db, -1, db.getVersion());
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        if (mListener != null) {
             mListener.onUpgrade(db, oldVersion, newVersion);
         }
-		executePragmas(db);
-		executeCreate(db);
-		executeMigrations(db, oldVersion, newVersion);
-	}
+        executePragmas(db);
+        executeCreate(db);
+        executeMigrations(db, oldVersion, newVersion);
+    }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public void copyAttachedDatabase(Context context, String databaseName, String prepackagedName) {
-		final File dbPath = context.getDatabasePath(databaseName);
+    public void copyAttachedDatabase(Context context, String databaseName, String prepackagedName) {
+        final File dbPath = context.getDatabasePath(databaseName);
 
-		// If the database already exists, return
-		if (dbPath.exists()) {
-			return;
-		}
+        // If the database already exists, return
+        if (dbPath.exists()) {
+            return;
+        }
 
-		// Make sure we have a path to the file
-		dbPath.getParentFile().mkdirs();
+        // Make sure we have a path to the file
+        dbPath.getParentFile().mkdirs();
 
-		// Try to copy database file
+        // Try to copy database file
         try {
             writeDB(dbPath, context.getAssets().open(prepackagedName));
         } catch (IOException e) {
@@ -168,7 +168,7 @@ public void restoreDatabase(Context context, String databaseName, String prepack
             File existingDb = context.getDatabasePath(getDatabaseName());
             InputStream inputStream;
             // if it exists and the integrity is ok
-            if(existingDb.exists() && Cache.checkDbIntegrity(this)) {
+            if (existingDb.exists() && Cache.checkDbIntegrity(this)) {
                 inputStream = new FileInputStream(existingDb);
             } else {
                 inputStream = context.getAssets().open(prepackagedName);
@@ -179,40 +179,37 @@ public void restoreDatabase(Context context, String databaseName, String prepack
         }
     }
 
-    private void writeDB(File dbPath, InputStream existingDB) {
-        try {
-            final OutputStream output = new FileOutputStream(dbPath);
-
-            byte[] buffer = new byte[1024];
-            int length;
+    private void writeDB(File dbPath, InputStream existingDB) throws IOException {
+        final OutputStream output = new FileOutputStream(dbPath);
 
-            while ((length = existingDB.read(buffer)) > 0) {
-                output.write(buffer, 0, length);
-            }
+        byte[] buffer = new byte[1024];
+        int length;
 
-            output.flush();
-            output.close();
-            existingDB.close();
-        }
-        catch (IOException e) {
-            AALog.e("Failed to open file", e);
+        while ((length = existingDB.read(buffer)) > 0) {
+            output.write(buffer, 0, length);
         }
+
+        output.flush();
+        output.close();
+        existingDB.close();
     }
 
+
     public String getDatabaseName() {
         return mDatabaseName;
     }
 
     /**
      * If integrity check fails, this method will use the backup db.
+     *
      * @param context
      */
     public void restoreBackUp(Context context) {
         File db = context.getDatabasePath(TEMP_DB_NAME + mDatabaseName);
         File corrupt = context.getDatabasePath(mDatabaseName);
-        if(corrupt.delete()) {
+        if (corrupt.delete()) {
             try {
-                 writeDB(corrupt,  new FileInputStream(db));
+                writeDB(corrupt, new FileInputStream(db));
             } catch (IOException e) {
                 AALog.e(e.getMessage());
             }
@@ -222,91 +219,94 @@ public void restoreBackUp(Context context) {
 
     }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	protected void executePragmas(SQLiteDatabase db) {
-		if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
-			db.execSQL("PRAGMA foreign_keys=ON;");
-			AALog.i("Foreign Keys supported. Enabling foreign key features.");
-		}
-	}
-
-	protected void executeCreate(SQLiteDatabase db) {
-		db.beginTransaction();
-		try {
-			for (TableInfo tableInfo : Cache.getTableInfos()) {
-				db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
-			}
-			db.setTransactionSuccessful();
-		}
-		finally {
-			db.endTransaction();
-		}
-	}
-
-	protected boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
-		boolean migrationExecuted = false;
-		try {
-			final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
-			Collections.sort(files, new NaturalOrderComparator());
-
-			db.beginTransaction();
-			try {
-				for (String file : files) {
-					try {
-						final int version = Integer.valueOf(file.replace(".sql", ""));
-
-						if (version > oldVersion && version <= newVersion) {
-							executeSqlScript(db, file);
-							migrationExecuted = true;
-
-							AALog.i(file + " executed succesfully.");
-						}
-					}
-					catch (NumberFormatException e) {
-						AALog.w("Skipping invalidly named file: " + file, e);
-					}
-				}
-				db.setTransactionSuccessful();
-			}
-			finally {
-				db.endTransaction();
-			}
-		}
-		catch (IOException e) {
-			AALog.e("Failed to execute migrations.", e);
-		}
-
-		return migrationExecuted;
-	}
-
-	protected void executeSqlScript(SQLiteDatabase db, String file) {
-		try {
-			final InputStream input = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
-			final BufferedReader reader = new BufferedReader(new InputStreamReader(input));
-			String line = null;
-
-			while ((line = reader.readLine()) != null) {
-				db.execSQL(line.replace(";", ""));
-			}
-		}
-		catch (IOException e) {
-			AALog.e("Failed to execute " + file, e);
-		}
-	}
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    protected void executePragmas(SQLiteDatabase db) {
+        if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
+            db.execSQL("PRAGMA foreign_keys=ON;");
+            AALog.i("Foreign Keys supported. Enabling foreign key features.");
+        }
+    }
+
+    protected void executeCreate(SQLiteDatabase db) {
+        db.beginTransaction();
+        try {
+            for (TableInfo tableInfo : Cache.getTableInfos()) {
+                db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
+            }
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    protected boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
+        boolean migrationExecuted = false;
+        try {
+            final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
+            Collections.sort(files, new NaturalOrderComparator());
+
+            db.beginTransaction();
+            try {
+                for (String file : files) {
+                    try {
+                        final int version = Integer.valueOf(file.replace(".sql", ""));
+
+                        if (version > oldVersion && version <= newVersion) {
+                            executeSqlScript(db, file);
+                            migrationExecuted = true;
+
+                            AALog.i(file + " executed succesfully.");
+                        }
+                    } catch (NumberFormatException e) {
+                        AALog.w("Skipping invalidly named file: " + file, e);
+                    }
+                }
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+        } catch (IOException e) {
+            AALog.e("Failed to execute migrations.", e);
+        }
+
+        return migrationExecuted;
+    }
+
+    protected void executeSqlScript(SQLiteDatabase db, String file) {
+        try {
+            final InputStream input = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
+            final BufferedReader reader = new BufferedReader(new InputStreamReader(input));
+            String line = null;
+
+            while ((line = reader.readLine()) != null) {
+                db.execSQL(line.replace(";", ""));
+            }
+        } catch (IOException e) {
+            AALog.e("Failed to execute " + file, e);
+        }
+    }
 
     /**
      * Saves the database as a backup
      */
     public void backupDB(final Context context) {
         // highest priority ever!
-        SingleDBManager.getSharedInstance().getQueue().add(new DBRequest(DBRequestInfo.create(DBRequest.PRIORITY_UI+1)) {
+        SingleDBManager.getSharedInstance().getQueue().add(new DBRequest(DBRequestInfo.create(DBRequest.PRIORITY_UI + 1)) {
             @Override
             public void run() {
                 File backup = context.getDatabasePath(TEMP_DB_NAME + mDatabaseName);
-                if(backup.exists()) {
+                File temp = context.getDatabasePath(TEMP_DB_NAME + "-2-" + mDatabaseName);
+
+                // if exists we want to delete it before rename
+                if(temp.exists()) {
+                    temp.delete();
+                }
+
+                backup.renameTo(temp);
+                if (backup.exists()) {
                     backup.delete();
                 }
                 File existing = context.getDatabasePath(mDatabaseName);
@@ -314,8 +314,11 @@ public void run() {
                 try {
                     backup.getParentFile().mkdirs();
                     writeDB(backup, new FileInputStream(existing));
-                } catch (FileNotFoundException e) {
-                    AALog.e(e.getMessage());
+
+                    temp.delete();
+                } catch (Exception e) {
+                    AALog.e("Error", e);
+
                 }
             }
         });
