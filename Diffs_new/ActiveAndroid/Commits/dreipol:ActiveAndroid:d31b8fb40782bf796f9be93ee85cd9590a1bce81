diff --git a/src/com/activeandroid/query/ColumnSplitter.java b/src/com/activeandroid/query/ColumnSplitter.java
new file mode 100644
index 00000000..130dfe65
--- /dev/null
+++ b/src/com/activeandroid/query/ColumnSplitter.java
@@ -0,0 +1,64 @@
+package com.activeandroid.query;
+
+import android.text.TextUtils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.regex.Pattern;
+
+/**
+ * Created by samuelbichsel on 15/02/16.
+ */
+public class ColumnSplitter {
+    private final String mTable;
+    private final String[] mColumns;
+    private final ArrayList<String> mProcessedColumns;
+
+    private ColumnSplitter(final String table, String... columns) {
+
+        mTable = table;
+        mColumns = columns;
+        mProcessedColumns = new ArrayList<String>();
+    }
+
+    public static ColumnSplitter split(String table, String... columns) {
+        ColumnSplitter columnSplitter = new ColumnSplitter(table, columns);
+        columnSplitter.split();
+        return columnSplitter;
+    }
+
+    public static ColumnSplitter split(String... columns) {
+        return split(null, columns);
+    }
+
+    public ArrayList<String> getColumns() {
+        return mProcessedColumns;
+    }
+
+    public String getString() {
+        String join = TextUtils.join(", ", mProcessedColumns);
+        if (join.isEmpty()) {
+            if (mTable != null) {
+                join = mTable + ".";
+            }
+            join += "*";
+        }
+        return join;
+    }
+
+    private void split() {
+        for (String col : mColumns) {
+            String[] strings = TextUtils.split(col, Pattern.compile(",\\s*"));
+            List<String> columnsList = Arrays.asList(strings);
+            if (mTable != null) {
+                for (String input : columnsList) {
+                    mProcessedColumns.add(mTable + "." + input);
+                }
+            } else {
+                mProcessedColumns.addAll(columnsList);
+            }
+        }
+
+    }
+}
diff --git a/src/com/activeandroid/query/Delete.java b/src/com/activeandroid/query/Delete.java
index 6d19dced..1136432c 100644
--- a/src/com/activeandroid/query/Delete.java
+++ b/src/com/activeandroid/query/Delete.java
@@ -23,7 +23,7 @@ public Delete() {
 	}
 
 	public From from(Class<? extends Model> table) {
-		return new From(table, this);
+		return new From(table, this, SqlMethod.DELETE);
 	}
 
 	@Override
diff --git a/src/com/activeandroid/query/From.java b/src/com/activeandroid/query/From.java
index 51e524ec..b17fcdf9 100644
--- a/src/com/activeandroid/query/From.java
+++ b/src/com/activeandroid/query/From.java
@@ -20,6 +20,8 @@
 
 import com.activeandroid.Cache;
 import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.annotation.Computed;
 import com.activeandroid.content.ContentProvider;
 import com.activeandroid.query.Join.JoinType;
 import com.activeandroid.util.Log;
@@ -29,63 +31,69 @@
 import java.util.List;
 
 public final class From implements Sqlable {
-	private Sqlable mQueryBase;
-
-	private Class<? extends Model> mType;
-	private String mAlias;
-	private List<Join> mJoins;
-	private final StringBuilder mWhere = new StringBuilder();
-	private String mGroupBy;
-	private String mHaving;
-	private String mOrderBy;
-	private String mLimit;
-	private String mOffset;
-
-	private List<Object> mArguments;
-
-	public From(Class<? extends Model> table, Sqlable queryBase) {
-		mType = table;
-		mJoins = new ArrayList<Join>();
-		mQueryBase = queryBase;
-
-		mJoins = new ArrayList<Join>();
-		mArguments = new ArrayList<Object>();
-	}
+    private Sqlable mQueryBase;
+
+    private Class<? extends Model> mType;
+    private String mAlias;
+    private List<Join> mJoins;
+    private final StringBuilder mWhere = new StringBuilder();
+    private String mGroupBy;
+    private String mHaving;
+    private String mOrderBy;
+    private String mLimit;
+    private String mOffset;
+    private SqlMethod mMethod;
+
+    private List<Object> mArguments;
+
+    public From(Class<? extends Model> table, Sqlable queryBase) {
+        this(table, queryBase, SqlMethod.UNKNOWN);
+    }
 
-	public From as(String alias) {
-		mAlias = alias;
-		return this;
-	}
+    public From(Class<? extends Model> table, Sqlable queryBase, SqlMethod method) {
+        mType = table;
+        mMethod = method;
+        mJoins = new ArrayList<Join>();
+        mQueryBase = queryBase;
 
-	public Join join(Class<? extends Model> table) {
-		Join join = new Join(this, table, null);
-		mJoins.add(join);
-		return join;
-	}
+        mJoins = new ArrayList<Join>();
+        mArguments = new ArrayList<Object>();
+    }
 
-	public Join leftJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.LEFT);
-		mJoins.add(join);
-		return join;
-	}
+    public From as(String alias) {
+        mAlias = alias;
+        return this;
+    }
 
-	public Join outerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.OUTER);
-		mJoins.add(join);
-		return join;
-	}
+    public Join join(Class<? extends Model> table) {
+        Join join = new Join(this, table, null);
+        mJoins.add(join);
+        return join;
+    }
 
-	public Join innerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.INNER);
-		mJoins.add(join);
-		return join;
-	}
+    public Join leftJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.LEFT);
+        mJoins.add(join);
+        return join;
+    }
 
-	public Join crossJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.CROSS);
-		mJoins.add(join);
-		return join;
-	}
+    public Join outerJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.OUTER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join innerJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.INNER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join crossJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.CROSS);
+        mJoins.add(join);
+        return join;
+    }
 
     public From where(String clause) {
         // Chain conditions if a previous condition exists.
@@ -121,48 +129,48 @@ public From or(String clause, Object... args) {
         or(clause).addArguments(args);
         return this;
     }
-    
-	public From groupBy(String groupBy) {
-		mGroupBy = groupBy;
-		return this;
-	}
 
-	public From having(String having) {
-		mHaving = having;
-		return this;
-	}
+    public From groupBy(String groupBy) {
+        mGroupBy = groupBy;
+        return this;
+    }
 
-	public From orderBy(String orderBy) {
-		mOrderBy = orderBy;
-		return this;
-	}
+    public From having(String having) {
+        mHaving = having;
+        return this;
+    }
 
-	public From limit(int limit) {
-		return limit(String.valueOf(limit));
-	}
+    public From orderBy(String orderBy) {
+        mOrderBy = orderBy;
+        return this;
+    }
 
-	public From limit(String limit) {
-		mLimit = limit;
-		return this;
-	}
+    public From limit(int limit) {
+        return limit(String.valueOf(limit));
+    }
 
-	public From offset(int offset) {
-		return offset(String.valueOf(offset));
-	}
+    public From limit(String limit) {
+        mLimit = limit;
+        return this;
+    }
 
-	public From offset(String offset) {
-		mOffset = offset;
-		return this;
-	}
+    public From offset(int offset) {
+        return offset(String.valueOf(offset));
+    }
 
-	void addArguments(Object[] args) {
-        for(Object arg : args) {
+    public From offset(String offset) {
+        mOffset = offset;
+        return this;
+    }
+
+    void addArguments(Object[] args) {
+        for (Object arg : args) {
             if (arg.getClass() == boolean.class || arg.getClass() == Boolean.class) {
                 arg = (arg.equals(true) ? 1 : 0);
             }
             mArguments.add(arg);
         }
-	}
+    }
 
     private void addFrom(final StringBuilder sql) {
         sql.append("FROM ");
@@ -246,9 +254,30 @@ private String sqlString(final StringBuilder sql) {
     public String toSql() {
         final StringBuilder sql = new StringBuilder();
         sql.append(mQueryBase.toSql());
-
+        String computedJoins = "";
+        String computedSelect = "";
+        if (mMethod == SqlMethod.SELECT) {
+            Select selectBase = (Select) mQueryBase;
+            TableInfo tableInfo = Cache.getTableInfo(mType);
+            boolean hasComputedFields = tableInfo.hasComputedFields();
+            if (!selectBase.hasColumns() && hasComputedFields) {
+                ArrayList<Computed> computedColumns = tableInfo.getComputedColumns();
+                for (Computed computed : computedColumns) {
+                    computedJoins += TextUtils.join(" ", computed.joins()) + " ";
+                    computedSelect += computed.select() + ",";
+                }
+                if(computedSelect.length() > 0) {
+                    computedSelect = computedSelect.replaceFirst(",$", " ");
+                }
+                String s = sql.toString();
+                sql.setLength(0);
+                sql.append(s.replaceFirst("\\*\\s*$", ""));
+                sql.append(tableInfo.getTableName()).append(".*, ").append(computedSelect);
+            }
+        }
         addFrom(sql);
         addJoins(sql);
+        sql.append(computedJoins);
         addWhere(sql);
         addGroupBy(sql);
         addHaving(sql);
@@ -298,33 +327,34 @@ public String toCountSql() {
         return toCountSql("*");
     }
 
-	public <T extends Model> List<T> execute() {
-		if (mQueryBase instanceof Select) {
-			return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
-			
-		} else {
-			SQLiteUtils.execSql(toSql(), getArguments());
-			Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mType, null), null);
-			return null;
-			
-		}
-	}
+    public <T extends Model> List<T> execute() {
+        if (mQueryBase instanceof Select) {
+            return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
+
+        } else {
+            SQLiteUtils.execSql(toSql(), getArguments());
+            Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mType, null), null);
+            return null;
+
+        }
+    }
+
+    public <T extends Model> T executeSingle() {
+        if (mQueryBase instanceof Select) {
+            limit(1);
+            return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
+
+        } else {
+            limit(1);
+            SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments()).delete();
+            return null;
+
+        }
+    }
 
-	public <T extends Model> T executeSingle() {
-		if (mQueryBase instanceof Select) {
-			limit(1);
-			return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
-			
-		} else {
-			limit(1);
-			SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments()).delete();
-			return null;
-			
-		}
-	}
-	
     /**
      * Gets a value indicating whether the query returns any rows.
+     *
      * @return <code>true</code> if the query returns at least one row; otherwise, <code>false</code>.
      */
     public boolean exists() {
diff --git a/src/com/activeandroid/query/Select.java b/src/com/activeandroid/query/Select.java
index 1d4c6488..0585e896 100644
--- a/src/com/activeandroid/query/Select.java
+++ b/src/com/activeandroid/query/Select.java
@@ -20,74 +20,89 @@
 
 import com.activeandroid.Model;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+
 public final class Select implements Sqlable {
-	private String[] mColumns;
-	private boolean mDistinct = false;
-	private boolean mAll = false;
-
-	public Select() {
-	}
-
-	public Select(String... columns) {
-		mColumns = columns;
-	}
-
-	public Select(Column... columns) {
-		final int size = columns.length;
-		mColumns = new String[size];
-		for (int i = 0; i < size; i++) {
-			mColumns[i] = columns[i].name + " AS " + columns[i].alias;
-		}
-	}
-
-	public Select distinct() {
-		mDistinct = true;
-		mAll = false;
-
-		return this;
-	}
-
-	public Select all() {
-		mDistinct = false;
-		mAll = true;
-
-		return this;
-	}
-
-	public From from(Class<? extends Model> table) {
-		return new From(table, this);
-	}
-
-	public static class Column {
-		String name;
-		String alias;
-
-		public Column(String name, String alias) {
-			this.name = name;
-			this.alias = alias;
-		}
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-
-		sql.append("SELECT ");
-
-		if (mDistinct) {
-			sql.append("DISTINCT ");
-		}
-		else if (mAll) {
-			sql.append("ALL ");
-		}
-
-		if (mColumns != null && mColumns.length > 0) {
-			sql.append(TextUtils.join(", ", mColumns) + " ");
-		}
-		else {
-			sql.append("* ");
-		}
-
-		return sql.toString();
-	}
+    private ArrayList<String> mColumns;
+    private boolean mDistinct = false;
+    private boolean mAll = false;
+
+    public Select() {
+        mColumns = new ArrayList<String>();
+    }
+
+    public Select(String... columns) {
+        this();
+        addColumns(columns);
+    }
+
+    public Select(Column... columns) {
+        this();
+        addColumns(columns);
+    }
+
+    public void addColumns(Column... columns) {
+        for (Column column : columns) {
+            mColumns.add(column.name + " AS " + column.alias);
+        }
+    }
+
+    public void addColumns(String... columns) {
+        mColumns.addAll(ColumnSplitter.split(columns).getColumns());
+    }
+
+    public Select all() {
+        mDistinct = false;
+        mAll = true;
+
+        return this;
+    }
+
+    public Select distinct() {
+        mDistinct = true;
+        mAll = false;
+
+        return this;
+    }
+
+    public From from(Class<? extends Model> table) {
+        return new From(table, this, SqlMethod.SELECT);
+    }
+
+    public boolean hasColumns() {
+        return mColumns != null && mColumns.size() > 0;
+    }
+
+    @Override
+    public String toSql() {
+        StringBuilder sql = new StringBuilder();
+
+        sql.append("SELECT ");
+
+        if (mDistinct) {
+            sql.append("DISTINCT ");
+        } else if (mAll) {
+            sql.append("ALL ");
+        }
+
+        if (hasColumns()) {
+            sql.append(TextUtils.join(", ", mColumns) + " ");
+        } else {
+            sql.append("* ");
+        }
+
+        return sql.toString();
+    }
+
+    public static class Column {
+        String name;
+        String alias;
+
+        public Column(String name, String alias) {
+            this.name = name;
+            this.alias = alias;
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/query/SqlMethod.java b/src/com/activeandroid/query/SqlMethod.java
new file mode 100644
index 00000000..3dfa6899
--- /dev/null
+++ b/src/com/activeandroid/query/SqlMethod.java
@@ -0,0 +1,12 @@
+package com.activeandroid.query;
+
+/**
+ * Created by samuelbichsel on 23/02/16.
+ */
+public enum SqlMethod {
+    UNKNOWN,
+    SELECT,
+    UPDATE,
+    DELETE,
+    SET;
+}
