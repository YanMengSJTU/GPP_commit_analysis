diff --git a/src/com/activeandroid/DBManager.java b/src/com/activeandroid/DBManager.java
new file mode 100644
index 00000000..e20fa726
--- /dev/null
+++ b/src/com/activeandroid/DBManager.java
@@ -0,0 +1,271 @@
+package com.activeandroid;
+
+import android.database.DatabaseUtils;
+import android.os.Handler;
+import android.util.Log;
+
+import com.activeandroid.query.Select;
+import com.activeandroid.receiver.CollectionReceiver;
+import com.activeandroid.receiver.ObjectReceiver;
+import com.activeandroid.runtime.DBRequest;
+import com.activeandroid.runtime.DBRequestQueue;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by andrewgrosner
+ * Date: 11/12/13
+ * Contributors:
+ * Description: Provides a handy base implementation for adding and getting objects from the database.
+ */
+public abstract class DBManager<OBJECT_CLASS extends Model> {
+
+    protected Class<OBJECT_CLASS> mObjectClass;
+
+    protected Handler mRequestHandler = new Handler();
+
+    /**
+     * Constructs a new instance while keeping an instance of the class for its objects
+     * @param classClass
+     */
+    public DBManager(Class<OBJECT_CLASS> classClass){
+        mObjectClass = classClass;
+    }
+
+    public static DBManager getSharedInstance(){
+        throw new IllegalStateException("Cannot call the base implementation of this method");
+    }
+
+    protected void processOnBackground(DBRequest runnable){
+       DBRequestQueue.getSharedInstance().add(runnable);
+    }
+
+    protected void processOnForeground(Runnable runnable){
+        mRequestHandler.post(runnable);
+    }
+
+    /**
+     * Adds an object to the manager's database
+     * @param object - object of the class defined by the manager
+     */
+    public OBJECT_CLASS add(OBJECT_CLASS object){
+        try{
+            if(object.exists()){
+                object.delete();
+            }
+        }catch (NullPointerException n){
+
+        }
+        object.save();
+        return object;
+    }
+
+    /**
+     * Adds a json object to this class, however its advised you ensure that the jsonobject being passed is what you want, since there's no type checking
+     * @param object
+     */
+    public OBJECT_CLASS add(JSONObject object){
+        try {
+            return add(mObjectClass.getConstructor(JSONObject.class).newInstance(object));
+        } catch (Throwable e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public void addInBackground(final JSONObject jsonObject, final ObjectReceiver<OBJECT_CLASS> objectReceiver, final int priority){
+        processOnBackground(new DBRequest(priority, "add") {
+            @Override
+            public void run() {
+                final OBJECT_CLASS object = add(jsonObject);
+                processOnForeground(new Runnable() {
+                    @Override
+                    public void run() {
+                        objectReceiver.onObjectReceived(object);
+                    }
+                });
+            }
+        });
+    }
+
+    /**
+     * Adds all objects to the DB
+     * @param objects
+     */
+    public void addAll(ArrayList<OBJECT_CLASS> objects){
+        Log.d("WTThread", "Thread name is : " + Thread.currentThread().getName());
+        ActiveAndroid.beginTransaction();
+        try{
+            for(OBJECT_CLASS object: objects){
+                add(object);
+            }
+            ActiveAndroid.setTransactionSuccessful();
+        } finally {
+            ActiveAndroid.endTransaction();
+        }
+    }
+
+    /**
+     * Adds all objects from the passed jsonarray, may NOT be type-safe so be careful with this
+     * @param array
+     */
+    public void addAll(JSONArray array){
+        ActiveAndroid.beginTransaction();
+        try{
+            for(int i = 0; i < array.length();i++){
+                OBJECT_CLASS object = mObjectClass.getConstructor(JSONObject.class).newInstance(array.get(i));
+                add(object);
+            }
+            ActiveAndroid.setTransactionSuccessful();
+        } catch (Throwable e) {
+            throw new RuntimeException(e);
+        } finally {
+            ActiveAndroid.endTransaction();
+        }
+
+    }
+
+    public void addAllInBackground(final JSONArray array, final Runnable finishedRunnable, String tag, int priority){
+        processOnBackground(new DBRequest(priority, "add "+ tag) {
+            @Override
+            public void run() {
+                addAll(array);
+
+                if(finishedRunnable!=null)
+                    processOnForeground(finishedRunnable);
+            }
+        });
+    }
+
+    public void addAllInBackground(final JSONArray array, final Runnable finishedRunnable, String tag){
+        addAllInBackground(array, finishedRunnable, tag, DBRequest.PRIORITY_LOW);
+    }
+
+    /**
+     * Retrieves a list of objects from the database without any threading
+     * Its recommended not to call this method in the foreground thread
+     * @return
+     */
+    public List<OBJECT_CLASS> getAll(){
+        return new Select().from(mObjectClass).execute();
+    }
+
+    /**
+     * Retrieves a list of objects from the database without any threading with the sort passed
+     * Its recommended not to call this method in the foreground thread
+     * @param sort - valid SQLLite syntax for sort e.g. name ASC
+     * @return
+     */
+    public List<OBJECT_CLASS> getAllWithSort(String sort){
+        return new Select().from(mObjectClass).orderBy(sort).execute();
+    }
+
+    /**
+     * Fetches objects from this DB on the BG
+     * @param receiver - function to call when finished that passes the list of objects that was found
+     */
+    public void fetchAll(final CollectionReceiver<OBJECT_CLASS> receiver){
+        processOnBackground(new DBRequest(DBRequest.PRIORITY_UI, "fetch") {
+            @Override
+            public void run() {
+                final List<OBJECT_CLASS> list = getAll();
+                processOnForeground(new Runnable() {
+                    @Override
+                    public void run() {
+                        receiver.onCollectionReceived(list);
+                    }
+                });
+            }
+        });
+    }
+
+    /**
+     * Fetches objects from this DB on the BG calling orderBy with the sort passed.
+     * @param sort - valid SQLLite syntax for sort e.g. name ASC
+     * @param receiver - function to call when finished that passes the list of objects that was found
+     */
+    public void fetchAllWithSort(final String sort, final CollectionReceiver<OBJECT_CLASS> receiver){
+        processOnBackground(new DBRequest(DBRequest.PRIORITY_UI, "fetch") {
+            @Override
+            public void run() {
+                final List<OBJECT_CLASS> list = getAllWithSort(sort);
+                processOnForeground(new Runnable() {
+                    @Override
+                    public void run() {
+                        receiver.onCollectionReceived(list);
+                    }
+                });
+            }
+        });
+    };
+
+    public void fetchAllWithId(final Object id, final String column, final CollectionReceiver<OBJECT_CLASS> receiver){
+        processOnBackground(new DBRequest(DBRequest.PRIORITY_UI, "fetch") {
+            @Override
+            public void run() {
+                final List<OBJECT_CLASS> list = getAllWithId(column, id);
+                processOnForeground(new Runnable() {
+                    @Override
+                    public void run() {
+                        receiver.onCollectionReceived(list);
+                    }
+                });
+            }
+        });
+    }
+
+    /**
+     * Returns the object at the correct location by the id passed
+     * @param uid
+     * @return
+     */
+    public OBJECT_CLASS getObjectById(Object uid){
+        return new Select().from(mObjectClass).where("uid = ?", uid).executeSingle();
+    }
+
+    public List<OBJECT_CLASS> getAllWithId(String column, Object id){
+        return new Select().from(mObjectClass).where(column + "= ?", id).execute();
+    }
+
+    public long getCount(){
+        return DatabaseUtils.queryNumEntries(Cache.openDatabase(), Cache.getTableName(mObjectClass));
+    }
+
+    /**
+     * Will return the object if its within the DB, if not, it will call upon an object requester to get the data from the API
+     * @param uid
+     * @param objectReceiver
+     * @return true if the object exists in the DB, otherwise its on a BG thread
+     */
+    public boolean fetchObject(final Object uid, final ObjectReceiver<OBJECT_CLASS> objectReceiver){
+        OBJECT_CLASS object = getObjectById(uid);
+        if(object==null){
+            processOnBackground(new DBRequest(DBRequest.PRIORITY_HIGH, "fetch") {
+                @Override
+                public void run() {
+                    processOnForeground(new Runnable() {
+                        @Override
+                        public void run() {
+                            requestObject(uid, objectReceiver);
+                        }
+                    });
+                }
+            });
+            return false;
+        } else{
+            objectReceiver.onObjectReceived(object);
+            return true;
+        }
+    }
+
+    /**
+     * Implement this method to perform a request if the object does not exist in the DB
+     * @param uid
+     * @param objectReceiver
+     */
+    public abstract void requestObject(final Object uid, final ObjectReceiver<OBJECT_CLASS> objectReceiver);
+}
diff --git a/src/com/activeandroid/app/Application.java b/src/com/activeandroid/app/Application.java
index 311c7c93..fbac45b4 100644
--- a/src/com/activeandroid/app/Application.java
+++ b/src/com/activeandroid/app/Application.java
@@ -17,17 +17,23 @@
  */
 
 import com.activeandroid.ActiveAndroid;
+import com.activeandroid.runtime.DBRequestQueue;
 
 public class Application extends android.app.Application {
 	@Override
 	public void onCreate() {
 		super.onCreate();
 		ActiveAndroid.initialize(this);
+
+        //Start the DB request queue
+        DBRequestQueue.getSharedInstance();
 	}
 	
 	@Override
 	public void onTerminate() {
 		super.onTerminate();
+
+        DBRequestQueue.getSharedInstance().quit();
 		ActiveAndroid.dispose();
 	}
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/receiver/CollectionReceiver.java b/src/com/activeandroid/receiver/CollectionReceiver.java
new file mode 100644
index 00000000..32e3586e
--- /dev/null
+++ b/src/com/activeandroid/receiver/CollectionReceiver.java
@@ -0,0 +1,21 @@
+package com.activeandroid.receiver;
+
+import java.util.List;
+
+/**
+ * Created by andrewgrosner
+ * Date: 12/8/13
+ * Contributors:
+ * Description: Used as a callback for items that are a List of Objects returned from the DB
+ * This function should be called on the foreground handler thread to perform UI interaction with the data.
+ * @param <OBJECT_CLASS>
+ */
+public interface CollectionReceiver<OBJECT_CLASS>{
+
+    /**
+     * Collection was received from the DB
+     * @param object
+     */
+    public void onCollectionReceived(List<OBJECT_CLASS> object);
+}
+
diff --git a/src/com/activeandroid/receiver/ObjectReceiver.java b/src/com/activeandroid/receiver/ObjectReceiver.java
new file mode 100644
index 00000000..13415dcf
--- /dev/null
+++ b/src/com/activeandroid/receiver/ObjectReceiver.java
@@ -0,0 +1,17 @@
+package com.activeandroid.receiver;
+
+/**
+ * Created by andrewgrosner
+ * Date: 12/8/13
+ * Contributors:
+ * Description: Returns the object when pulled from the database or by request
+ * The callback should be run on the main thread to perform UI updates
+ */
+public interface ObjectReceiver<OBJECT_CLASS> {
+
+    /**
+     * Object was received from DB or by API request
+     * @param object
+     */
+    public void onObjectReceived(OBJECT_CLASS object);
+}
diff --git a/src/com/activeandroid/runtime/DBRequest.java b/src/com/activeandroid/runtime/DBRequest.java
new file mode 100644
index 00000000..d05620c7
--- /dev/null
+++ b/src/com/activeandroid/runtime/DBRequest.java
@@ -0,0 +1,90 @@
+package com.activeandroid.runtime;
+
+import java.util.UUID;
+
+/**
+ * Created by andrewgrosner
+ * Date: 12/11/13
+ * Contributors:
+ * Description: The basic request object that's placed on the DBRequestQueue for processing.
+ * The {@link com.activeandroid.runtime.DBRequestQueue} uses a priority queue that will process
+ * this class based on the priority assigned to it.
+ *
+ * There are four main kinds of requests:
+ *  For requests that require UI or immediate retrieval, use PRIORITY_UI
+ *  For requests that are displayed in the UI some point in the near future, use PRIORITY_HIGH
+ *  For the bulk of data requests, use PRIORITY_NORMAL
+ *  For any request that's non-essential use PRIORITY_LOW
+ */
+public abstract class DBRequest implements Comparable<DBRequest> {
+
+    /**
+     * Low priority requests, reserved for non-essential tasks
+     */
+    public static int PRIORITY_LOW = 0;
+
+    /**
+     * The main of the requests, good for when adding a bunch of
+     * data to the DB that the app does not access right away.
+     */
+    public static int PRIORITY_NORMAL = 1;
+
+    /**
+     * Reserved for tasks that will influence user interaction, such as displaying data in the UI
+     * some point in the future (not necessarily right away)
+     */
+    public static int PRIORITY_HIGH = 2;
+
+    /**
+     * Reserved for only immediate tasks and all forms of fetching that will display on the UI
+     */
+    public static int PRIORITY_UI = 5;
+
+    public abstract void run();
+
+    /**
+     * The higher the number, the faster the request will be processed,
+     * default is PRIORITY_LOW
+     */
+    private int priority = PRIORITY_LOW;
+
+    /**
+     * Give this request a name
+     */
+    private String name;
+
+    /**
+     * Constructs a new instance specifying a priority and name
+     * @param priority
+     * @param name
+     */
+    public DBRequest(int priority, String name){
+        this.priority = priority;
+        this.name = name;
+    }
+
+    /**
+     * Constructs a new instance with a priority and UUID for the name
+     * @param priority
+     */
+    public DBRequest(int priority){
+        this.priority = priority;
+        this.name = UUID.randomUUID().toString();
+    }
+
+    /**
+     * Creates a new, low priority request
+     */
+    public DBRequest(){
+        this.name = UUID.randomUUID().toString();
+    }
+
+    @Override
+    public int compareTo(DBRequest another) {
+        return another.priority - priority;
+    }
+
+    public String getName() {
+        return name;
+    }
+}
diff --git a/src/com/activeandroid/runtime/DBRequestQueue.java b/src/com/activeandroid/runtime/DBRequestQueue.java
new file mode 100644
index 00000000..c3160839
--- /dev/null
+++ b/src/com/activeandroid/runtime/DBRequestQueue.java
@@ -0,0 +1,96 @@
+package com.activeandroid.runtime;
+
+import android.os.Looper;
+import android.os.Process;
+
+import java.util.concurrent.PriorityBlockingQueue;
+
+/**
+ * Created by andrewgrosner
+ * Date: 12/11/13
+ * Contributors:
+ * Description: will handle concurrent requests to the DB based on priority
+ */
+public class DBRequestQueue extends Thread{
+
+    private static DBRequestQueue shared;
+
+    /**
+     * Queue of requests
+     */
+    private final PriorityBlockingQueue<DBRequest> mQueue;
+
+    private boolean mQuit = false;
+
+    /**
+     * Gets and starts the request queue if it hasn't started yet.
+     * @return
+     */
+    public static DBRequestQueue getSharedInstance(){
+        if(shared==null){
+            shared = new DBRequestQueue("DBRequestQueue");
+            shared.start();
+        }
+        return shared;
+    }
+
+    /**
+     * Creates a queue with the specified name to ID it.
+     * @param name
+     */
+    public DBRequestQueue(String name) {
+        super(name);
+
+        mQueue = new PriorityBlockingQueue<DBRequest>();
+    }
+
+    @Override
+    public void run() {
+        Looper.prepare();
+        android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
+        DBRequest runnable;
+        while (true){
+            try{
+                runnable = mQueue.take();
+            } catch (InterruptedException e){
+                if(mQuit){
+                    return;
+                }
+                continue;
+            }
+
+            try{
+                runnable.run();
+            } catch (Throwable t){
+                throw new RuntimeException(t);
+            }
+        }
+
+    }
+
+    public void add(DBRequest runnable){
+        synchronized (mQueue){
+            mQueue.add(runnable);
+        }
+    }
+
+    /**
+     * Cancels the specified request.
+     * @param runnable
+     */
+    public void cancel(DBRequest runnable){
+        synchronized (mQueue){
+            if(mQueue.contains(runnable)){
+                mQueue.remove(runnable);
+            }
+        }
+    }
+
+    /**
+     * Quits this process
+     */
+    public void quit(){
+        mQuit = true;
+        interrupt();
+    }
+}
