diff --git a/src/com/activeandroid/ActiveAndroid.java b/src/com/activeandroid/ActiveAndroid.java
index c58c8efd..5906879d 100644
--- a/src/com/activeandroid/ActiveAndroid.java
+++ b/src/com/activeandroid/ActiveAndroid.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.test.christophergastebois.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -19,7 +19,7 @@
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 
-import com.activeandroid.util.Log;
+import com.test.christophergastebois.activeandroid.util.Log;
 
 public final class ActiveAndroid {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
index 6495e379..42bc7554 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.test.christophergastebois.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,14 +16,14 @@
  * limitations under the License.
  */
 
-import java.util.Collection;
-
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.support.v4.util.LruCache;
 
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.Log;
+import com.test.christophergastebois.activeandroid.serializer.TypeSerializer;
+import com.test.christophergastebois.activeandroid.util.Log;
+
+import java.util.Collection;
 
 public final class Cache {
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -39,6 +39,7 @@
 	private static Context sContext;
 
 	private static ModelInfo sModelInfo;
+    private static ViewTableInfo sViewTableInfo;
 	private static DatabaseHelper sDatabaseHelper;
 
 	private static LruCache<String, Model> sEntities;
@@ -64,6 +65,7 @@ public static synchronized void initialize(Configuration configuration) {
 
 		sContext = configuration.getContext();
 		sModelInfo = new ModelInfo(configuration);
+        sViewTableInfo = new ViewTableInfo( configuration );
 		sDatabaseHelper = new DatabaseHelper(configuration);
 
 		// TODO: It would be nice to override sizeOf here and calculate the memory
@@ -139,7 +141,6 @@ public static synchronized void removeEntity(Model entity) {
 	}
 
 	// Model cache
-
 	public static synchronized Collection<TableInfo> getTableInfos() {
 		return sModelInfo.getTableInfos();
 	}
@@ -155,4 +156,17 @@ public static synchronized TypeSerializer getParserForType(Class<?> type) {
 	public static synchronized String getTableName(Class<? extends Model> type) {
 		return sModelInfo.getTableInfo(type).getTableName();
 	}
+
+    // ViewTable cache
+    public static synchronized Collection<ViewTableTableInfo> getViewTableTableInfos() {
+        return sViewTableInfo.getViewTableTableInfos();
+    }
+
+    public static synchronized ViewTableTableInfo getViewTableTableInfo(Class<? extends ViewTable> type) {
+        return sViewTableInfo.getViewTableTableInfo(type);
+    }
+
+    public static synchronized String getViewTableTableName(Class<? extends ViewTable> type) {
+        return sViewTableInfo.getViewTableTableInfo(type).getViewTableName();
+    }
 }
diff --git a/src/com/activeandroid/Configuration.java b/src/com/activeandroid/Configuration.java
index b197d223..2b848c2d 100644
--- a/src/com/activeandroid/Configuration.java
+++ b/src/com/activeandroid/Configuration.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.test.christophergastebois.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,16 +16,16 @@
  * limitations under the License.
  */
 
+import android.content.Context;
+
+import com.test.christophergastebois.activeandroid.serializer.TypeSerializer;
+import com.test.christophergastebois.activeandroid.util.Log;
+import com.test.christophergastebois.activeandroid.util.ReflectionUtils;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import android.content.Context;
-
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
-
 public class Configuration {
 
     public final static String SQL_PARSER_LEGACY = "legacy";
@@ -39,6 +39,7 @@
 	private String mDatabaseName;
 	private int mDatabaseVersion;
 	private String mSqlParser;
+    private List<Class<? extends ViewTable>> mViewTableClasses;
 	private List<Class<? extends Model>> mModelClasses;
 	private List<Class<? extends TypeSerializer>> mTypeSerializers;
 	private int mCacheSize;
@@ -71,9 +72,11 @@ public String getSqlParser() {
 	    return mSqlParser;
 	}
 
-	public List<Class<? extends Model>> getModelClasses() {
-		return mModelClasses;
-	}
+	public List<Class<? extends Model>> getModelClasses() { return mModelClasses; }
+
+    public List<Class<? extends ViewTable>> getViewTableClasses() {
+        return mViewTableClasses;
+    }
 
 	public List<Class<? extends TypeSerializer>> getTypeSerializers() {
 		return mTypeSerializers;
@@ -83,10 +86,14 @@ public int getCacheSize() {
 		return mCacheSize;
 	}
 
-	public boolean isValid() {
+	public boolean modelConfigurationIsValid() {
 		return mModelClasses != null && mModelClasses.size() > 0;
 	}
 
+    public boolean viewTableConfigurationIsValid(){
+        return mViewTableClasses != null && mViewTableClasses.size() > 0;
+    }
+
 	//////////////////////////////////////////////////////////////////////////////////////
 	// INNER CLASSES
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -116,6 +123,7 @@ public boolean isValid() {
 		private String mDatabaseName;
 		private Integer mDatabaseVersion;
 		private String mSqlParser;
+        private List<Class<? extends ViewTable>> mViewTableClasses;
 		private List<Class<? extends Model>> mModelClasses;
 		private List<Class<? extends TypeSerializer>> mTypeSerializers;
 
@@ -152,28 +160,51 @@ public Builder setSqlParser(String sqlParser) {
 		    return this;
 		}
 
-		public Builder addModelClass(Class<? extends Model> modelClass) {
-			if (mModelClasses == null) {
-				mModelClasses = new ArrayList<Class<? extends Model>>();
+        public Builder addModelClass(Class<? extends Model> modelClass) {
+            if (mModelClasses == null) {
+                mModelClasses = new ArrayList<Class<? extends Model>>();
+            }
+
+            mModelClasses.add(modelClass);
+            return this;
+        }
+
+        public Builder addModelClasses(Class<? extends Model>... modelClasses) {
+            if (mModelClasses == null) {
+                mModelClasses = new ArrayList<Class<? extends Model>>();
+            }
+
+            mModelClasses.addAll(Arrays.asList(modelClasses));
+            return this;
+        }
+
+        public Builder setModelClasses(Class<? extends Model>... modelClasses) {
+            mModelClasses = Arrays.asList(modelClasses);
+            return this;
+        }
+
+		public Builder addViewTableClass(Class<? extends ViewTable> viewTableClass) {
+			if (mViewTableClasses == null) {
+                mViewTableClasses = new ArrayList<Class<? extends ViewTable>>();
 			}
 
-			mModelClasses.add(modelClass);
+            mViewTableClasses.add(viewTableClass);
 			return this;
 		}
 
-		public Builder addModelClasses(Class<? extends Model>... modelClasses) {
-			if (mModelClasses == null) {
-				mModelClasses = new ArrayList<Class<? extends Model>>();
+		public Builder addViewTableClasses(Class<? extends ViewTable>... viewTableClasses) {
+			if (mViewTableClasses == null) {
+                mViewTableClasses = new ArrayList<Class<? extends ViewTable>>();
 			}
 
-			mModelClasses.addAll(Arrays.asList(modelClasses));
+            mViewTableClasses.addAll(Arrays.asList(viewTableClasses));
 			return this;
 		}
 
-		public Builder setModelClasses(Class<? extends Model>... modelClasses) {
-			mModelClasses = Arrays.asList(modelClasses);
-			return this;
-		}
+        public Builder setViewTableClasses(Class<? extends ViewTable>... viewTableClasses) {
+            mViewTableClasses = Arrays.asList(viewTableClasses);
+            return this;
+        }
 
 		public Builder addTypeSerializer(Class<? extends TypeSerializer> typeSerializer) {
 			if (mTypeSerializers == null) {
@@ -233,6 +264,16 @@ public Configuration create() {
 				}
 			}
 
+            // Get model classes from meta-data
+            if (mViewTableClasses != null) {
+                configuration.mViewTableClasses = mViewTableClasses;
+            } else {
+                final String viewTableList = ReflectionUtils.getMetaData(mContext, AA_MODELS); // TODO
+                if (viewTableList != null) {
+                    configuration.mViewTableClasses = loadViewTableList(viewTableList.split(","));
+                }
+            }
+
 			// Get type serializer classes from meta-data
 			if (mTypeSerializers != null) {
 				configuration.mTypeSerializers = mTypeSerializers;
@@ -296,6 +337,24 @@ private String getMetaDataSqlParserOrDefault() {
 			return modelClasses;
 		}
 
+        private List<Class<? extends ViewTable>> loadViewTableList(String[] viewTables) {
+            final List<Class<? extends ViewTable>> viewTableClasses = new ArrayList<Class<? extends ViewTable>>();
+            final ClassLoader classLoader = mContext.getClass().getClassLoader();
+            for (String model : viewTables) {
+                try {
+                    Class viewTableClass = Class.forName(model.trim(), false, classLoader);
+                    if (ReflectionUtils.isModel(viewTableClass)) {
+                        viewTableClasses.add(viewTableClass);
+                    }
+                }
+                catch (ClassNotFoundException e) {
+                    Log.e("Couldn't create class.", e);
+                }
+            }
+
+            return viewTableClasses;
+        }
+
 		private List<Class<? extends TypeSerializer>> loadSerializerList(String[] serializers) {
 			final List<Class<? extends TypeSerializer>> typeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
 			final ClassLoader classLoader = mContext.getClass().getClassLoader();
diff --git a/src/com/activeandroid/DatabaseHelper.java b/src/com/activeandroid/DatabaseHelper.java
index 7158c5bb..3c3792ed 100644
--- a/src/com/activeandroid/DatabaseHelper.java
+++ b/src/com/activeandroid/DatabaseHelper.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.test.christophergastebois.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -32,11 +32,11 @@
 import android.database.sqlite.SQLiteOpenHelper;
 import android.text.TextUtils;
 
-import com.activeandroid.util.IOUtils;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.NaturalOrderComparator;
-import com.activeandroid.util.SQLiteUtils;
-import com.activeandroid.util.SqlParser;
+import com.test.christophergastebois.activeandroid.util.IOUtils;
+import com.test.christophergastebois.activeandroid.util.Log;
+import com.test.christophergastebois.activeandroid.util.NaturalOrderComparator;
+import com.test.christophergastebois.activeandroid.util.SQLiteUtils;
+import com.test.christophergastebois.activeandroid.util.SqlParser;
 
 public final class DatabaseHelper extends SQLiteOpenHelper {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 421426ea..4c248f92 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.test.christophergastebois.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -20,12 +20,12 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 
-import com.activeandroid.content.ContentProvider;
-import com.activeandroid.query.Delete;
-import com.activeandroid.query.Select;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
+import com.test.christophergastebois.activeandroid.content.ContentProvider;
+import com.test.christophergastebois.activeandroid.query.Delete;
+import com.test.christophergastebois.activeandroid.query.Select;
+import com.test.christophergastebois.activeandroid.serializer.TypeSerializer;
+import com.test.christophergastebois.activeandroid.util.Log;
+import com.test.christophergastebois.activeandroid.util.ReflectionUtils;
 
 import java.lang.reflect.Field;
 import java.util.ArrayList;
diff --git a/src/com/activeandroid/ModelInfo.java b/src/com/activeandroid/ModelInfo.java
index 09e79117..b5a7bf77 100644
--- a/src/com/activeandroid/ModelInfo.java
+++ b/src/com/activeandroid/ModelInfo.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.test.christophergastebois.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,6 +16,16 @@
  * limitations under the License.
  */
 
+import android.content.Context;
+
+import com.test.christophergastebois.activeandroid.serializer.CalendarSerializer;
+import com.test.christophergastebois.activeandroid.serializer.FileSerializer;
+import com.test.christophergastebois.activeandroid.serializer.SqlDateSerializer;
+import com.test.christophergastebois.activeandroid.serializer.TypeSerializer;
+import com.test.christophergastebois.activeandroid.serializer.UtilDateSerializer;
+import com.test.christophergastebois.activeandroid.util.Log;
+import com.test.christophergastebois.activeandroid.util.ReflectionUtils;
+
 import java.io.File;
 import java.io.IOException;
 import java.net.URL;
@@ -27,15 +37,6 @@
 import java.util.List;
 import java.util.Map;
 
-import android.content.Context;
-
-import com.activeandroid.serializer.CalendarSerializer;
-import com.activeandroid.serializer.SqlDateSerializer;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.serializer.UtilDateSerializer;
-import com.activeandroid.serializer.FileSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
 import dalvik.system.DexFile;
 
 final class ModelInfo {
@@ -91,7 +92,7 @@ public TypeSerializer getTypeSerializer(Class<?> type) {
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	private boolean loadModelFromMetaData(Configuration configuration) {
-		if (!configuration.isValid()) {
+		if (!configuration.modelConfigurationIsValid()) {
 			return false;
 		}
 
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/TableInfo.java
index 32d1ecb3..68a6e13a 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/src/com/activeandroid/TableInfo.java
@@ -1,4 +1,4 @@
-package com.activeandroid;
+package com.test.christophergastebois.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,6 +16,13 @@
  * limitations under the License.
  */
 
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.test.christophergastebois.activeandroid.annotation.Column;
+import com.test.christophergastebois.activeandroid.annotation.Table;
+import com.test.christophergastebois.activeandroid.util.ReflectionUtils;
+
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.Collections;
@@ -24,13 +31,6 @@
 import java.util.List;
 import java.util.Map;
 
-import android.text.TextUtils;
-import android.util.Log;
-
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.util.ReflectionUtils;
-
 public final class TableInfo {
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
diff --git a/src/com/activeandroid/ViewTable.java b/src/com/activeandroid/ViewTable.java
new file mode 100644
index 00000000..287ad49f
--- /dev/null
+++ b/src/com/activeandroid/ViewTable.java
@@ -0,0 +1,122 @@
+package com.test.christophergastebois.activeandroid;
+
+import android.database.Cursor;
+
+import com.test.christophergastebois.activeandroid.serializer.TypeSerializer;
+import com.test.christophergastebois.activeandroid.util.Log;
+import com.test.christophergastebois.activeandroid.util.ReflectionUtils;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Created by Christopher GATEBOIS on 04/07/2014.
+ */
+public abstract class ViewTable {
+
+    private final ViewTableTableInfo mViewTableTableInfo;
+
+    public ViewTable() {
+        mViewTableTableInfo = Cache.getViewTableTableInfo( getClass() );
+    }
+
+    // TODO
+    public final void loadFromCursor( Cursor cursor ) {
+        /**
+         * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+         * when the cursor have multiple columns with same name obtained from join tables.
+         */
+        List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+        for (Field field : mViewTableTableInfo.getFields()) {
+            final String fieldName = mViewTableTableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+            final int columnIndex = columnsOrdered.indexOf(fieldName);
+
+            if (columnIndex < 0) {
+                continue;
+            }
+
+            field.setAccessible(true);
+
+            try {
+                boolean columnIsNull = cursor.isNull(columnIndex);
+                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                Object value = null;
+
+                if (typeSerializer != null) {
+                    fieldType = typeSerializer.getSerializedType();
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (columnIsNull) {
+                    field = null;
+                }
+                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    value = cursor.getLong(columnIndex);
+                }
+                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    value = cursor.getFloat(columnIndex);
+                }
+                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    value = cursor.getDouble(columnIndex);
+                }
+                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    value = cursor.getInt(columnIndex) != 0;
+                }
+                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    value = cursor.getString(columnIndex).charAt(0);
+                }
+                else if (fieldType.equals(String.class)) {
+                    value = cursor.getString(columnIndex);
+                }
+                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    value = cursor.getBlob(columnIndex);
+                }
+                else if (ReflectionUtils.isModel(fieldType)) {
+                    // no Object in ViewTable, just primitive
+                    Log.e(getClass().getName(), "no Object in ViewTable, just primitive");
+                }
+                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    // no Object in ViewTable, just primitive
+                    Log.e(getClass().getName(), "no Object in ViewTable, just primitive");
+                }
+
+                // Use a deserializer if one is available
+                if (typeSerializer != null && !columnIsNull) {
+                    value = typeSerializer.deserialize(value);
+                }
+
+                // Set the field value
+                if (value != null) {
+                    field.set(this, value);
+                }
+            }
+            catch (IllegalArgumentException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+            catch (IllegalAccessException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+            catch (SecurityException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+
+        //if (mId != null) {
+        //    Cache.addEntity(this);
+        //}
+    }
+
+}
diff --git a/src/com/activeandroid/ViewTableInfo.java b/src/com/activeandroid/ViewTableInfo.java
new file mode 100644
index 00000000..96447193
--- /dev/null
+++ b/src/com/activeandroid/ViewTableInfo.java
@@ -0,0 +1,166 @@
+package com.test.christophergastebois.activeandroid;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.content.Context;
+
+import com.test.christophergastebois.activeandroid.util.Log;
+import com.test.christophergastebois.activeandroid.util.ReflectionUtils;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import dalvik.system.DexFile;
+
+final class ViewTableInfo {
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private Map<Class<? extends ViewTable>, ViewTableTableInfo> mTableInfos  = new HashMap<Class<? extends ViewTable>, ViewTableTableInfo>();
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// CONSTRUCTORS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public ViewTableInfo(Configuration configuration) {
+		if (!loadViewTableFromMetaData(configuration)) {
+			try {
+				scanForViewTable(configuration.getContext());
+			}
+			catch (IOException e) {
+				Log.e("Couldn't open source path.", e);
+			}
+		}
+
+		Log.i("ModelInfo loaded.");
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public Collection<ViewTableTableInfo> getViewTableTableInfos() {
+		return mTableInfos.values();
+	}
+
+	public ViewTableTableInfo getViewTableTableInfo(Class<? extends ViewTable> type) {
+		return mTableInfos.get(type);
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private boolean loadViewTableFromMetaData(Configuration configuration) {
+		if (!configuration.viewTableConfigurationIsValid()) {
+			return false;
+		}
+
+		final List<Class<? extends ViewTable>> viewTables = configuration.getViewTableClasses();
+		if (viewTables != null) {
+			for (Class<? extends ViewTable> viewTable : viewTables) {
+				mTableInfos.put(viewTable, new ViewTableTableInfo(viewTable));
+			}
+		}
+
+		return true;
+	}
+
+	private void scanForViewTable(Context context) throws IOException {
+		String packageName = context.getPackageName();
+		String sourcePath = context.getApplicationInfo().sourceDir;
+		List<String> paths = new ArrayList<String>();
+
+		if (sourcePath != null && !(new File(sourcePath).isDirectory())) {
+			DexFile dexfile = new DexFile(sourcePath);
+			Enumeration<String> entries = dexfile.entries();
+
+			while (entries.hasMoreElements()) {
+				paths.add(entries.nextElement());
+			}
+		}
+		// Robolectric fallback
+		else {
+			ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+			Enumeration<URL> resources = classLoader.getResources("");
+
+			while (resources.hasMoreElements()) {
+				String path = resources.nextElement().getFile();
+				if (path.contains("bin") || path.contains("classes")) {
+					paths.add(path);
+				}
+			}
+		}
+
+		for (String path : paths) {
+			File file = new File(path);
+			scanForViewTableClasses(file, packageName, context.getClassLoader());
+		}
+	}
+
+	private void scanForViewTableClasses(File path, String packageName, ClassLoader classLoader) {
+		if (path.isDirectory()) {
+			for (File file : path.listFiles()) {
+				scanForViewTableClasses(file, packageName, classLoader);
+			}
+		}
+		else {
+			String className = path.getName();
+
+			// Robolectric fallback
+			if (!path.getPath().equals(className)) {
+				className = path.getPath();
+
+				if (className.endsWith(".class")) {
+					className = className.substring(0, className.length() - 6);
+				}
+				else {
+					return;
+				}
+
+				className = className.replace(System.getProperty("file.separator"), ".");
+
+				int packageNameIndex = className.lastIndexOf(packageName);
+				if (packageNameIndex < 0) {
+					return;
+				}
+
+				className = className.substring(packageNameIndex);
+			}
+
+			try {
+				Class<?> discoveredClass = Class.forName(className, false, classLoader);
+				if (ReflectionUtils.isViewTable(discoveredClass)) {
+
+					Class<? extends ViewTable> viewTableClass = (Class<? extends ViewTable>) discoveredClass;
+					mTableInfos.put(viewTableClass, new ViewTableTableInfo(viewTableClass));
+				}
+			}
+			catch (ClassNotFoundException e) {
+				Log.e("Couldn't create class.", e);
+			}
+		}
+	}
+}
diff --git a/src/com/activeandroid/ViewTableTableInfo.java b/src/com/activeandroid/ViewTableTableInfo.java
new file mode 100644
index 00000000..7c630f8f
--- /dev/null
+++ b/src/com/activeandroid/ViewTableTableInfo.java
@@ -0,0 +1,96 @@
+package com.test.christophergastebois.activeandroid;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.text.TextUtils;
+
+import com.test.christophergastebois.activeandroid.annotation.Column;
+import com.test.christophergastebois.activeandroid.annotation.View;
+import com.test.christophergastebois.activeandroid.util.ReflectionUtils;
+
+import java.lang.reflect.Field;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+public final class ViewTableTableInfo {
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE MEMBERS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private Class<? extends ViewTable> mType;
+	private String mViewTableName;
+
+	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// CONSTRUCTORS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public ViewTableTableInfo(Class<? extends ViewTable> type) {
+		mType = type;
+
+		final View tableAnnotation = type.getAnnotation(View.class);
+
+        if (tableAnnotation != null) {
+			mViewTableName = tableAnnotation.name();
+		}
+		else {
+			mViewTableName = type.getSimpleName();
+        }
+
+        List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
+        Collections.reverse(fields);
+
+        for (Field field : fields) {
+            if (field.isAnnotationPresent(Column.class)) {
+                final Column columnAnnotation = field.getAnnotation(Column.class);
+                String columnName = columnAnnotation.name();
+                if (TextUtils.isEmpty(columnName)) {
+                    columnName = field.getName();
+                }
+
+                mColumnNames.put(field, columnName);
+            }
+        }
+
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public Class<? extends ViewTable> getType() {
+		return mType;
+	}
+
+	public String getViewTableName() {
+		return mViewTableName;
+	}
+
+	public Collection<Field> getFields() {
+		return mColumnNames.keySet();
+	}
+
+	public String getColumnName(Field field) {
+		return mColumnNames.get(field);
+	}
+
+}
diff --git a/src/com/activeandroid/annotation/View.java b/src/com/activeandroid/annotation/View.java
new file mode 100644
index 00000000..6410f72c
--- /dev/null
+++ b/src/com/activeandroid/annotation/View.java
@@ -0,0 +1,29 @@
+package com.activeandroid.annotation;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface View {
+
+	public String name();
+}
diff --git a/src/com/activeandroid/query/CreateView.java b/src/com/activeandroid/query/CreateView.java
new file mode 100644
index 00000000..c937cc7d
--- /dev/null
+++ b/src/com/activeandroid/query/CreateView.java
@@ -0,0 +1,24 @@
+package com.activeandroid.query;
+
+import com.test.christophergastebois.activeandroid.ViewTable;
+
+/**
+ * Created by Christopher GATEBOIS on 07/07/2014.
+ */
+public class CreateView implements Sqlable {
+
+    private Class<? extends ViewTable> mViewTable;
+
+    public CreateView( Class<? extends ViewTable> viewTable ){
+        mViewTable = viewTable;
+    }
+
+    public Select select( String... columns ){
+        return new Select(mViewTable, columns);
+    }
+
+    @Override
+    public String toSql() {
+        return "";
+    }
+}
diff --git a/src/com/activeandroid/query/Delete.java b/src/com/activeandroid/query/Delete.java
index 6d19dced..3498ce9a 100644
--- a/src/com/activeandroid/query/Delete.java
+++ b/src/com/activeandroid/query/Delete.java
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.Model;
+import com.test.christophergastebois.activeandroid.Model;
 
 public final class Delete implements Sqlable {
 	public Delete() {
diff --git a/src/com/activeandroid/query/From.java b/src/com/activeandroid/query/From.java
index ab3837a9..cd94a4da 100644
--- a/src/com/activeandroid/query/From.java
+++ b/src/com/activeandroid/query/From.java
@@ -18,12 +18,13 @@
 
 import android.text.TextUtils;
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
-import com.activeandroid.content.ContentProvider;
-import com.activeandroid.query.Join.JoinType;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.SQLiteUtils;
+import com.test.christophergastebois.activeandroid.Cache;
+import com.test.christophergastebois.activeandroid.Model;
+import com.test.christophergastebois.activeandroid.ViewTable;
+import com.test.christophergastebois.activeandroid.content.ContentProvider;
+import com.test.christophergastebois.activeandroid.query.Join.JoinType;
+import com.test.christophergastebois.activeandroid.util.Log;
+import com.test.christophergastebois.activeandroid.util.SQLiteUtils;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -31,7 +32,8 @@
 public final class From implements Sqlable {
 	private Sqlable mQueryBase;
 
-	private Class<? extends Model> mType;
+	private Class<? extends Model> mModelType;
+    private Class<? extends ViewTable> mViewTableType;
 	private String mAlias;
 	private List<Join> mJoins;
 	private final StringBuilder mWhere = new StringBuilder();
@@ -44,7 +46,7 @@
 	private List<Object> mArguments;
 
 	public From(Class<? extends Model> table, Sqlable queryBase) {
-		mType = table;
+		mModelType = table;
 		mJoins = new ArrayList<Join>();
 		mQueryBase = queryBase;
 
@@ -52,6 +54,16 @@ public From(Class<? extends Model> table, Sqlable queryBase) {
 		mArguments = new ArrayList<Object>();
 	}
 
+    public From(Class<? extends ViewTable> viewTable, Class<? extends Model> table, Sqlable queryBase) {
+        mModelType = table;
+        mViewTableType = viewTable;
+        mJoins = new ArrayList<Join>();
+        mQueryBase = queryBase;
+
+        mJoins = new ArrayList<Join>();
+        mArguments = new ArrayList<Object>();
+    }
+
 	public From as(String alias) {
 		mAlias = alias;
 		return this;
@@ -166,7 +178,7 @@ void addArguments(Object[] args) {
 
     private void addFrom(final StringBuilder sql) {
         sql.append("FROM ");
-        sql.append(Cache.getTableName(mType)).append(" ");
+        sql.append(Cache.getTableName(mModelType)).append(" ");
 
         if (mAlias != null) {
             sql.append("AS ");
@@ -295,28 +307,63 @@ public String toCountSql() {
 
 	public <T extends Model> List<T> execute() {
 		if (mQueryBase instanceof Select) {
-			return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
+			return SQLiteUtils.rawQuery(mModelType, toSql(), getArguments());
 			
 		} else {
 			SQLiteUtils.execSql(toSql(), getArguments());
-			Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mType, null), null);
+			Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mModelType, null), null);
 			return null;
-			
 		}
 	}
 
 	public <T extends Model> T executeSingle() {
 		if (mQueryBase instanceof Select) {
 			limit(1);
-			return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
-			
-		} else {
+			return (T) SQLiteUtils.rawQuerySingle(mModelType, toSql(), getArguments());
+		}
+        else {
 			limit(1);
-			SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments()).delete();
+			SQLiteUtils.rawQuerySingle(mModelType, toSql(), getArguments()).delete();
 			return null;
-			
 		}
 	}
+
+    // NEW
+    public <T extends ViewTable> List<T> executeToView() {
+        if( mViewTableType != null ) {
+            if (mQueryBase instanceof Select) {
+                return SQLiteUtils.rawQueryToViewTable(mViewTableType, toSql(), getArguments());
+            }
+            else {
+                SQLiteUtils.execSql(toSql(), getArguments());
+                Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mModelType, null), null);
+                return null;
+            }
+        }
+        else {
+            Log.e("You must instanciate CreateView for executeToView ");
+            return null;
+        }
+    }
+
+    // NEW
+    public <T extends ViewTable> T executeSingleToView() {
+        if( mViewTableType != null ) {
+            if (mQueryBase instanceof Select) {
+                limit(1);
+                return (T) SQLiteUtils.rawQuerySingleToViewTable(mViewTableType, toSql(), getArguments());
+
+            } else {
+                limit(1);
+                SQLiteUtils.rawQuerySingle(mModelType, toSql(), getArguments()).delete();
+                return null;
+            }
+        }
+        else {
+            Log.e("You must instanciate CreateView for executeToView ");
+            return null;
+        }
+    }
 	
     /**
      * Gets a value indicating whether the query returns any rows.
diff --git a/src/com/activeandroid/query/Join.java b/src/com/activeandroid/query/Join.java
index 13cdba3b..6ed30872 100644
--- a/src/com/activeandroid/query/Join.java
+++ b/src/com/activeandroid/query/Join.java
@@ -18,8 +18,8 @@
 
 import android.text.TextUtils;
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
+import com.test.christophergastebois.activeandroid.Cache;
+import com.test.christophergastebois.activeandroid.Model;
 
 public final class Join implements Sqlable {
 	static enum JoinType {
diff --git a/src/com/activeandroid/query/Select.java b/src/com/activeandroid/query/Select.java
index 1d4c6488..718b66c0 100644
--- a/src/com/activeandroid/query/Select.java
+++ b/src/com/activeandroid/query/Select.java
@@ -18,20 +18,27 @@
 
 import android.text.TextUtils;
 
-import com.activeandroid.Model;
+import com.test.christophergastebois.activeandroid.Model;
+import com.test.christophergastebois.activeandroid.ViewTable;
 
 public final class Select implements Sqlable {
 	private String[] mColumns;
 	private boolean mDistinct = false;
 	private boolean mAll = false;
 
-	public Select() {
-	}
+    private Class<? extends ViewTable> mViewTableType;
+
+	public Select() {}
 
 	public Select(String... columns) {
 		mColumns = columns;
 	}
 
+    public Select(Class<? extends ViewTable> viewTable, String... columns) {
+        mViewTableType = viewTable;
+        mColumns = columns;
+    }
+
 	public Select(Column... columns) {
 		final int size = columns.length;
 		mColumns = new String[size];
@@ -40,7 +47,7 @@ public Select(Column... columns) {
 		}
 	}
 
-	public Select distinct() {
+    public Select distinct() {
 		mDistinct = true;
 		mAll = false;
 
@@ -54,8 +61,13 @@ public Select all() {
 		return this;
 	}
 
-	public From from(Class<? extends Model> table) {
-		return new From(table, this);
+	public From from(Class<? extends Model> table) { package com.activeandroid.query
+        if( mViewTableType != null  ) {
+            return new From( mViewTableType, table, this );
+        }
+        else {
+            return new From(table, this);
+        }
 	}
 
 	public static class Column {
diff --git a/src/com/activeandroid/query/Set.java b/src/com/activeandroid/query/Set.java
index 183d99f0..3d5728da 100644
--- a/src/com/activeandroid/query/Set.java
+++ b/src/com/activeandroid/query/Set.java
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.util.SQLiteUtils;
+import com.test.christophergastebois.activeandroid.util.SQLiteUtils;
 
 import java.util.ArrayList;
 import java.util.Arrays;
diff --git a/src/com/activeandroid/query/Update.java b/src/com/activeandroid/query/Update.java
index a69d2d8e..8d272172 100644
--- a/src/com/activeandroid/query/Update.java
+++ b/src/com/activeandroid/query/Update.java
@@ -16,8 +16,8 @@
  * limitations under the License.
  */
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
+import com.test.christophergastebois.activeandroid.Cache;
+import com.test.christophergastebois.activeandroid.Model;
 
 public final class Update implements Sqlable {
 	private Class<? extends Model> mType;
diff --git a/src/com/activeandroid/util/IOUtils.java b/src/com/activeandroid/util/IOUtils.java
index 284d7bca..7bf86bb2 100644
--- a/src/com/activeandroid/util/IOUtils.java
+++ b/src/com/activeandroid/util/IOUtils.java
@@ -1,5 +1,5 @@
 
-package com.activeandroid.util;
+package com.test.christophergastebois.activeandroid.util;
 
 /*
  * Copyright (C) 2014 Markus Pfeiffer
@@ -22,8 +22,6 @@
 import java.io.Closeable;
 import java.io.IOException;
 
-import com.activeandroid.util.Log;
-
 
 public class IOUtils {
 
diff --git a/src/com/activeandroid/util/Log.java b/src/com/activeandroid/util/Log.java
index 3c40a23f..3ba0d0a7 100644
--- a/src/com/activeandroid/util/Log.java
+++ b/src/com/activeandroid/util/Log.java
@@ -1,4 +1,4 @@
-package com.activeandroid.util;
+package com.test.christophergastebois.activeandroid.util;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/util/NaturalOrderComparator.java b/src/com/activeandroid/util/NaturalOrderComparator.java
index 3e44af96..700e4383 100644
--- a/src/com/activeandroid/util/NaturalOrderComparator.java
+++ b/src/com/activeandroid/util/NaturalOrderComparator.java
@@ -1,4 +1,4 @@
-package com.activeandroid.util;
+package com.test.christophergastebois.activeandroid.util;
 
 /*
  NaturalOrderComparator.java -- Perform 'natural order' comparisons of strings in Java.
diff --git a/src/com/activeandroid/util/ReflectionUtils.java b/src/com/activeandroid/util/ReflectionUtils.java
index 32e995cc..d359a575 100644
--- a/src/com/activeandroid/util/ReflectionUtils.java
+++ b/src/com/activeandroid/util/ReflectionUtils.java
@@ -1,4 +1,4 @@
-package com.activeandroid.util;
+package com.test.christophergastebois.activeandroid.util;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,6 +16,15 @@
  * limitations under the License.
  */
 
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+
+import com.test.christophergastebois.activeandroid.Model;
+import com.test.christophergastebois.activeandroid.ViewTable;
+import com.test.christophergastebois.activeandroid.annotation.Column;
+import com.test.christophergastebois.activeandroid.serializer.TypeSerializer;
+
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.util.Arrays;
@@ -24,19 +33,15 @@
 import java.util.LinkedHashSet;
 import java.util.Set;
 
-import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.serializer.TypeSerializer;
-
 public final class ReflectionUtils {
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
+    public static boolean isViewTable(Class<?> type) {
+        return isSubclassOf(type, ViewTable.class) && (!Modifier.isAbstract(type.getModifiers()));
+    }
+
 	public static boolean isModel(Class<?> type) {
 		return isSubclassOf(type, Model.class) && (!Modifier.isAbstract(type.getModifiers()));
 	}
@@ -67,7 +72,7 @@ public static boolean isTypeSerializer(Class<?> type) {
 	public static Set<Field> getDeclaredColumnFields(Class<?> type) {
 		Set<Field> declaredColumnFields = Collections.emptySet();
 		
-		if (ReflectionUtils.isSubclassOf(type, Model.class) || Model.class.equals(type)) {
+		if (ReflectionUtils.isSubclassOf(type, Model.class) || Model.class.equals(type) || ReflectionUtils.isSubclassOf(type, ViewTable.class) || ViewTable.class.equals(type)) {
 			declaredColumnFields = new LinkedHashSet<Field>();
 			
 			Field[] fields = type.getDeclaredFields();
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index cbf41eae..aa548283 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -1,4 +1,4 @@
-package com.activeandroid.util;
+package com.test.christophergastebois.activeandroid.util;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -20,19 +20,18 @@
 import android.os.Build;
 import android.text.TextUtils;
 
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
-import com.activeandroid.TableInfo;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Column.ConflictAction;
-import com.activeandroid.serializer.TypeSerializer;
+import com.test.christophergastebois.activeandroid.Cache;
+import com.test.christophergastebois.activeandroid.Model;
+import com.test.christophergastebois.activeandroid.TableInfo;
+import com.test.christophergastebois.activeandroid.ViewTable;
+import com.test.christophergastebois.activeandroid.annotation.Column;
+import com.test.christophergastebois.activeandroid.annotation.Column.ConflictAction;
+import com.test.christophergastebois.activeandroid.serializer.TypeSerializer;
 
-import java.lang.Long;
-import java.lang.String;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.util.Arrays;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -109,6 +108,15 @@ public static void execSql(String sql, Object[] bindArgs) {
 
 		return entities;
 	}
+
+    // NEW
+    public static <T extends ViewTable> List<T> rawQueryToViewTable(Class<? extends ViewTable> viewTableType, String sql, String[] selectionArgs) {
+        Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+        List<T> entities = processCursorToViewTable(viewTableType, cursor);
+        cursor.close();
+
+        return entities;
+    }
 	  
 	public static int intQuery(final String sql, final String[] selectionArgs) {
         final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
@@ -127,6 +135,16 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
 
 		return null;
 	}
+    // NEW
+    public static <T extends ViewTable> T rawQuerySingleToViewTable(Class<? extends ViewTable> type, String sql, String[] selectionArgs) {
+        List<T> entities = rawQueryToViewTable(type, sql, selectionArgs);
+
+        if (entities.size() > 0) {
+            return entities.get(0);
+        }
+
+        return null;
+    }
 
 	// Database creation
 
@@ -365,6 +383,48 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 		return entities;
 	}
 
+    // test TODO
+    public static <T extends ViewTable> List<T> processCursorToViewTable(Class<? extends ViewTable> type, Cursor cursor) {
+
+        /*TableInfo tableInfo = Cache.getTableInfo(type);
+        String idName = tableInfo.getIdName();*/
+        final List<T> entities = new ArrayList<T>();
+
+        try {
+            Constructor<?> entityConstructor = type.getConstructor();
+
+            if (cursor.moveToFirst()) {
+                /**
+                 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+                 * when the cursor have multiple columns with same name obtained from join tables.
+                 */
+                List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+                do {
+                    ViewTable entity = (T) entityConstructor.newInstance();
+                    entity.loadFromCursor(cursor);
+                    entities.add((T) entity);
+                }
+                while (cursor.moveToNext());
+            }
+
+        }
+        catch (NoSuchMethodException e) {
+            throw new RuntimeException(
+                    "Your model " + type.getName() + " does not define a default " +
+                            "constructor. The default constructor is required for " +
+                            "now in ActiveAndroid models, as the process to " +
+                            "populate the ORM model is : " +
+                            "1. instantiate default model " +
+                            "2. populate fields"
+            );
+        }
+        catch (Exception e) {
+            Log.e("Failed to process cursor.", e);
+        }
+
+        return entities;
+    }
+
 	private static int processIntCursor(final Cursor cursor) {
         if (cursor.moveToFirst()) {
             return cursor.getInt(0);
diff --git a/src/com/activeandroid/util/SqlParser.java b/src/com/activeandroid/util/SqlParser.java
index f9531b7c..5839ea91 100644
--- a/src/com/activeandroid/util/SqlParser.java
+++ b/src/com/activeandroid/util/SqlParser.java
@@ -1,5 +1,5 @@
 
-package com.activeandroid.util;
+package com.test.christophergastebois.activeandroid.util;
 
 /*
  * Copyright (C) 2014 Markus Pfeiffer
diff --git a/src/com/activeandroid/util/Tokenizer.java b/src/com/activeandroid/util/Tokenizer.java
index 8ae34da3..6a83848d 100644
--- a/src/com/activeandroid/util/Tokenizer.java
+++ b/src/com/activeandroid/util/Tokenizer.java
@@ -1,5 +1,5 @@
 
-package com.activeandroid.util;
+package com.test.christophergastebois.activeandroid.util;
 
 /*
  * Copyright (C) 2014 Markus Pfeiffer
