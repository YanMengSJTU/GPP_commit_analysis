diff --git a/src/com/activeandroid/Configuration.java b/src/com/activeandroid/Configuration.java
index d63404cf..806f1361 100644
--- a/src/com/activeandroid/Configuration.java
+++ b/src/com/activeandroid/Configuration.java
@@ -283,9 +283,9 @@ private String getMetaDataSqlParserOrDefault() {
 			final ClassLoader classLoader = mContext.getClass().getClassLoader();
 			for (String model : models) {
 				try {
-				    @SuppressWarnings("unchecked")
-					Class<? extends Model> modelClass = (Class<? extends Model>) Class.forName(model.trim(), false, classLoader);
-					if (ReflectionUtils.isModel(modelClass)) {
+                    @SuppressWarnings("unchecked")
+                    Class<? extends Model> modelClass = (Class<? extends Model>) Class.forName(model.trim(), false, classLoader);
+                    if (ReflectionUtils.isModel(modelClass)) {
 						modelClasses.add(modelClass);
 					}
 				}
@@ -302,7 +302,7 @@ private String getMetaDataSqlParserOrDefault() {
 			final ClassLoader classLoader = mContext.getClass().getClassLoader();
 			for (String serializer : serializers) {
 				try {
-					@SuppressWarnings("unchecked")
+                    @SuppressWarnings("unchecked")
                     Class<? extends TypeSerializer> serializerClass = (Class<? extends TypeSerializer>) Class.forName(serializer.trim(), false, classLoader);
 					if (ReflectionUtils.isTypeSerializer(serializerClass)) {
 						typeSerializers.add(serializerClass);
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index a93c701d..428962ee 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -69,15 +69,15 @@ public final void delete() {
 				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
 	}
 
-	private ContentValues createContentValues() {
-	    // The exceptions should never happen, so we put the try-catch outside
-	    // for better performance.
+    private ContentValues createContentValues() {
+        // The exceptions should never happen, so we put the try-catch outside
+        // for better performance.
         final ContentValues values = new ContentValues();
 
-	    try {
-	        for (Field field : mTableInfo.getFields()) {
-	            final String fieldName = mTableInfo.getColumnName(field);
-	            Class<?> fieldType = field.getType();
+        try {
+            for (Field field : mTableInfo.getFields()) {
+                final String fieldName = mTableInfo.getColumnName(field);
+                Class<?> fieldType = field.getType();
                 Object value = field.get(this);
 
                 if (value != null) {
@@ -98,50 +98,50 @@ private ContentValues createContentValues() {
                 }
 
                 SQLiteUtils.put(values, fieldType, fieldName, value);       
-	        }
-	    }
+            }
+        }
         catch (IllegalArgumentException e) {
             Log.e(e.getClass().getName(), e);
         }
         catch (IllegalAccessException e) {
             Log.e(e.getClass().getName(), e);
         }
-	    
+        
         return values;
-	}
-	
-	/**
-	 * Updates this model if it has an ID; else inserts it.
-	 * @return If inserting, returns the new ID or -1 on failure; else returns the existing ID.
-	 */
-	public final Long save() {
-	    ContentValues values = createContentValues();
-		SQLiteDatabase db = null;
-		
-	    try {
-	        db = Cache.openDatabase();
-    		if (mId == null) {
-    			long newID = db.insert(mTableInfo.getTableName(), null, values);
-    			if (newID == -1L)
-    			    // returns -1 instead of null for backwards compatibility.
-    			    return -1L;
-    			mId = newID;
-    		}
-    		else {
-    			db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
-    		}
-	    }
+    }
+    
+    /**
+     * Updates this model if it has an ID; else inserts it.
+     * @return If inserting, returns the new ID or -1 on failure; else returns the existing ID.
+     */
+    public final Long save() {
+        ContentValues values = createContentValues();
+        SQLiteDatabase db = null;
+        
+        try {
+            db = Cache.openDatabase();
+            if (mId == null) {
+                long newID = db.insert(mTableInfo.getTableName(), null, values);
+                if (newID == -1L)
+                    // returns -1 instead of null for backwards compatibility.
+                    return -1L;
+                mId = newID;
+            }
+            else {
+                db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
+            }
+        }
         finally {
             if (db != null) 
                 db.close();
         }
 
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-		return mId;
-	}
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+        return mId;
+    }
 
-	/**
+    /**
      * Inserts or updates this object with a specified ID. If insertion fails,
      * due to for example, duplication of ID, this method will attempt to update
      * the existing row instead. Note that the entire operation is not atomic.
@@ -242,7 +242,7 @@ public static void delete(Class<? extends Model> type, long id) {
 
 	// Model population
 
-	public final void loadFromCursor(Cursor cursor) {
+    public final void loadFromCursor(Cursor cursor) {
         /**
          * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
          * when the cursor have multiple columns with same name obtained from join tables.
@@ -251,20 +251,20 @@ public final void loadFromCursor(Cursor cursor) {
         // The exceptions should never happen, so we put the try-catch outside
         // for better performance.
         try {
-    		for (Field field : mTableInfo.getFields()) {
-    			final String fieldName = mTableInfo.getColumnName(field);
-    			Class<?> fieldType = field.getType();
-    			final int columnIndex = SQLiteUtils.indexOfIgnoreCase(columnsOrdered, fieldName);
-    			 
-    			if (columnIndex < 0) {
-    				continue;
-    			}
+            for (Field field : mTableInfo.getFields()) {
+                final String fieldName = mTableInfo.getColumnName(field);
+                Class<?> fieldType = field.getType();
+                final int columnIndex = SQLiteUtils.indexOfIgnoreCase(columnsOrdered, fieldName);
+                 
+                if (columnIndex < 0) {
+                    continue;
+                }
     
-    			boolean columnIsNull = cursor.isNull(columnIndex);
-    			TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-    			Object value = null;
+                boolean columnIsNull = cursor.isNull(columnIndex);
+                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                Object value = null;
     
-    			if (!columnIsNull) {
+                if (!columnIsNull) {
                     if (typeSerializer != null) {
                         Class<?> getType = typeSerializer.getSerializedType();
                         value = SQLiteUtils.get(cursor, getType, columnIndex);
@@ -272,15 +272,15 @@ public final void loadFromCursor(Cursor cursor) {
                     }
                     else
                         value = SQLiteUtils.get(cursor, fieldType, columnIndex);
-    			}
+                }
     
-    			// If the field accepts null and the value is indeed null, then
-    			// set it to null.
-    			if (value != null || !fieldType.isPrimitive()) {
-    				field.set(this, value);
-    			}
-    		}
-    		
+                // If the field accepts null and the value is indeed null, then
+                // set it to null.
+                if (value != null || !fieldType.isPrimitive()) {
+                    field.set(this, value);
+                }
+            }
+            
             if (mId != null) {
                 Cache.addEntity(this);
             }
@@ -291,7 +291,7 @@ public final void loadFromCursor(Cursor cursor) {
         catch (IllegalAccessException e) {
             Log.e(e.getClass().getName(), e);
         }
-	}
+    }
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PROTECTED METHODS
diff --git a/src/com/activeandroid/ModelInfo.java b/src/com/activeandroid/ModelInfo.java
index abc9dd0b..ba61bd99 100644
--- a/src/com/activeandroid/ModelInfo.java
+++ b/src/com/activeandroid/ModelInfo.java
@@ -45,15 +45,15 @@
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	private Map<Class<? extends Model>, TableInfo> mTableInfos = new HashMap<Class<? extends Model>, TableInfo>();
-	@SuppressWarnings("serial")
+    @SuppressWarnings("serial")
     private Map<Class<?>, TypeSerializer> mTypeSerializers = new HashMap<Class<?>, TypeSerializer>() {
-		{
-			put(Calendar.class, new CalendarSerializer());
-			put(java.sql.Date.class, new SqlDateSerializer());
-			put(java.util.Date.class, new UtilDateSerializer());
-			put(java.io.File.class, new FileSerializer());
-		}
-	};
+        {
+            put(Calendar.class, new CalendarSerializer());
+            put(java.sql.Date.class, new SqlDateSerializer());
+            put(java.util.Date.class, new UtilDateSerializer());
+            put(java.io.File.class, new FileSerializer());
+        }
+    };
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index 8249aa12..df746b45 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -73,30 +73,30 @@ public TypeInfo(SQLiteType type, int typeFlag) {
 	// PRIVATE CONTSANTS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, TypeInfo> TYPE_MAP = new HashMap<Class<?>, TypeInfo>() {
-		{
-			put(byte.class, new TypeInfo(SQLiteType.INTEGER, TYPE_BYTE));
-			put(short.class, new TypeInfo(SQLiteType.INTEGER, TYPE_SHORT));
-			put(int.class, new TypeInfo(SQLiteType.INTEGER, TYPE_INT));
-			put(long.class, new TypeInfo(SQLiteType.INTEGER, TYPE_LONG));
-			put(float.class, new TypeInfo(SQLiteType.REAL, TYPE_FLOAT));
-			put(double.class, new TypeInfo(SQLiteType.REAL, TYPE_DOUBLE));
-			put(boolean.class, new TypeInfo(SQLiteType.INTEGER, TYPE_BOOL));
-			put(char.class, new TypeInfo(SQLiteType.TEXT, TYPE_CHAR));
-			put(byte[].class, new TypeInfo(SQLiteType.BLOB, TYPE_BLOB));
-			put(Byte.class, get(byte.class));
-			put(Short.class, get(short.class));
-			put(Integer.class, get(int.class));
-			put(Long.class, get(long.class));
-			put(Float.class, get(float.class));
-			put(Double.class, get(double.class));
-			put(Boolean.class, get(boolean.class));
-			put(Character.class, get(char.class));
-			put(String.class, new TypeInfo(SQLiteType.TEXT, TYPE_STRING));
-			put(Byte[].class, get(byte[].class));
-		}
-	};
+    @SuppressWarnings("serial")
+    private static final HashMap<Class<?>, TypeInfo> TYPE_MAP = new HashMap<Class<?>, TypeInfo>() {
+        {
+            put(byte.class, new TypeInfo(SQLiteType.INTEGER, TYPE_BYTE));
+            put(short.class, new TypeInfo(SQLiteType.INTEGER, TYPE_SHORT));
+            put(int.class, new TypeInfo(SQLiteType.INTEGER, TYPE_INT));
+            put(long.class, new TypeInfo(SQLiteType.INTEGER, TYPE_LONG));
+            put(float.class, new TypeInfo(SQLiteType.REAL, TYPE_FLOAT));
+            put(double.class, new TypeInfo(SQLiteType.REAL, TYPE_DOUBLE));
+            put(boolean.class, new TypeInfo(SQLiteType.INTEGER, TYPE_BOOL));
+            put(char.class, new TypeInfo(SQLiteType.TEXT, TYPE_CHAR));
+            put(byte[].class, new TypeInfo(SQLiteType.BLOB, TYPE_BLOB));
+            put(Byte.class, get(byte.class));
+            put(Short.class, get(short.class));
+            put(Integer.class, get(int.class));
+            put(Long.class, get(long.class));
+            put(Float.class, get(float.class));
+            put(Double.class, get(double.class));
+            put(Boolean.class, get(boolean.class));
+            put(Character.class, get(char.class));
+            put(String.class, new TypeInfo(SQLiteType.TEXT, TYPE_STRING));
+            put(Byte[].class, get(byte[].class));
+        }
+    };
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
@@ -110,12 +110,12 @@ public TypeInfo(SQLiteType type, int typeFlag) {
 	// PUBLIC METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	public static void put(ContentValues values, Class<?> fieldType, String fieldName, Object value) {
-	    if (value == null) {
+    public static void put(ContentValues values, Class<?> fieldType, String fieldName, Object value) {
+        if (value == null) {
             values.putNull(fieldName);
             return;
         }
-	    
+        
         TypeInfo typeInfo = TYPE_MAP.get(fieldType);
         if (typeInfo == null) {
             if (ReflectionUtils.isModel(fieldType)) {
@@ -157,33 +157,33 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
             values.put(fieldName, (byte[]) value);
             break;
         }
-	}
-	
-	public static Object get(Cursor cursor, Class<?> fieldType, int columnIndex) {
-	    TypeInfo typeInfo = TYPE_MAP.get(fieldType);
-	    if (typeInfo == null) {
-	        if (ReflectionUtils.isModel(fieldType)) {
-	            final long entityId = cursor.getLong(columnIndex);
-	            @SuppressWarnings("unchecked")
-	            final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
-
-	            Model entity = Cache.getEntity(entityType, entityId);
-	            if (entity == null) {
-	                entity = new Select().from(entityType).where(Cache.getTableInfo(entityType).getIdName()+"=?", entityId).executeSingle();
-	            }
-	            return entity;
-	        }
-	        
-	        if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-	            @SuppressWarnings({"rawtypes", "unchecked"})
-	            final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-	            @SuppressWarnings("unchecked")
-	            Object o = Enum.valueOf(enumType, cursor.getString(columnIndex));
-	            return o;
-	        }
-	    }
-	    
-	    switch (typeInfo.typeFlag) {
+    }
+    
+    public static Object get(Cursor cursor, Class<?> fieldType, int columnIndex) {
+        TypeInfo typeInfo = TYPE_MAP.get(fieldType);
+        if (typeInfo == null) {
+            if (ReflectionUtils.isModel(fieldType)) {
+                final long entityId = cursor.getLong(columnIndex);
+                @SuppressWarnings("unchecked")
+                final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
+
+                Model entity = Cache.getEntity(entityType, entityId);
+                if (entity == null) {
+                    entity = new Select().from(entityType).where(Cache.getTableInfo(entityType).getIdName()+"=?", entityId).executeSingle();
+                }
+                return entity;
+            }
+            
+            if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                @SuppressWarnings({"rawtypes", "unchecked"})
+                final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+                @SuppressWarnings("unchecked")
+                Object o = Enum.valueOf(enumType, cursor.getString(columnIndex));
+                return o;
+            }
+        }
+        
+        switch (typeInfo.typeFlag) {
         case TYPE_BYTE:
             return (byte) cursor.getInt(columnIndex);
         case TYPE_SHORT:
@@ -205,8 +205,8 @@ public static Object get(Cursor cursor, Class<?> fieldType, int columnIndex) {
         case TYPE_BLOB:
             return cursor.getBlob(columnIndex);
         }
-	    return null;
-	}
+        return null;
+    }
 	
 	public static void execSql(String sql) {
 		Cache.openDatabase().execSQL(sql);
@@ -522,20 +522,20 @@ private static int processIntCursor(final Cursor cursor) {
 		return sl;
 	}
 	
-	public static int indexOfIgnoreCase(String[] strs, String find) {
-	    final int len = strs.length;
-	    if (find != null) {
-	        for (int i = 0; i < len; i++) {
-	            if (find.equalsIgnoreCase(strs[i]))
-	                return i;
-	        }
-	    }
-	    else {
-	        for (int i = 0; i < len; i++) {
+    public static int indexOfIgnoreCase(String[] strs, String find) {
+        final int len = strs.length;
+        if (find != null) {
+            for (int i = 0; i < len; i++) {
+                if (find.equalsIgnoreCase(strs[i]))
+                    return i;
+            }
+        }
+        else {
+            for (int i = 0; i < len; i++) {
                 if (null == strs[i])
                     return i;
             }
-	    }
+        }
         return -1;
-	}
+    }
 }
