diff --git a/README.md b/README.md
index d3a984b1..b02cbff1 100755
--- a/README.md
+++ b/README.md
@@ -1,46 +1,86 @@
-# ActiveAndroid
-
-ActiveAndroid is an active record style ORM ([object relational mapper](http://en.wikipedia.org/wiki/Object-relational_mapping)). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like _save()_ and _delete()_.
-
-ActiveAndroid does so much more than this though. Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration.
-
-## Documentation
-
-* [Getting started](http://github.com/pardom/ActiveAndroid/wiki/Getting-started)
-* [Creating your database model](http://github.com/pardom/ActiveAndroid/wiki/Creating-your-database-model)
-* [Saving to the database](http://github.com/pardom/ActiveAndroid/wiki/Saving-to-the-database)
-* [Querying the database](http://github.com/pardom/ActiveAndroid/wiki/Querying-the-database)
-* [Type serializers](http://github.com/pardom/ActiveAndroid/wiki/Type-serializers)
-* [Using the content provider](http://github.com/pardom/ActiveAndroid/wiki/Using-the-content-provider)
-* [Schema migrations](http://github.com/pardom/ActiveAndroid/wiki/Schema-migrations)
-* [Pre-populated-databases](http://github.com/pardom/ActiveAndroid/wiki/Pre-populated-databases)
-
-## License
-
-[Apache Version 2.0](http://www.apache.org/licenses/LICENSE-2.0.html)
-
-    Copyright (C) 2010 Michael Pardo
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-
-## Contributing
-
-Please fork this repository and contribute back using [pull requests](http://github.com/pardom/ActiveAndroid/pulls).
-
-Any contributions, large or small, major features, bug fixes, unit tests are welcomed and appreciated but will be thoroughly reviewed and discussed.
-
-[![Donate](https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=TEQWCPJWGH6LY)
-
-## Author
-
-Michael Pardo | www.michaelpardo.com | www.activeandroid.com
\ No newline at end of file
+## Originally folk from [ActiveAndroid](https://github.com/hank-cp/ActiveAndroid)
+## This fold add multiple database support and some performance optimization
+
+## Usage (different from original code stream)
+
+#### Define a new DbMetaData class for db configuration
+
+	public class UserDbMetaData extends DbMetaData {
+	
+		private String mUin = null;
+	
+		public UserDbMetaData(String uin){
+			mUin = uin;
+		}
+	
+		@Override
+		public int getDatabaseVersion() {
+			return 12;
+		}
+	
+		@Override
+		public String getDatabaseName() {
+			return "user_"+mUin+".db";
+		}
+	
+		@Override
+		public String getMigrationPath() {
+			return "migration/user";
+		}
+	
+	    /**
+	     * When this flag return true, opening database under this dbMetaData will be 
+	     * closed if new one is register. As example:
+	     *
+	     * registerDb(1) -- database user_1.db is opened
+	     * registerDb(2) -- database user_1.db is closed and user_2.db is opened
+	     */
+		@Override
+		public boolean isResettable() {
+			return true; 
+		}
+	
+		@Override
+		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+			if (oldVersion < 5) {
+				// do somthing
+			}
+			if (newVersion >= 7) {
+				// do somthing
+			}
+		}
+	
+	    /**
+	     * You need to override equals method to tell ActiveAndroid how to 
+	     * identify DbMetaData to avoid open-close database too often
+	     */
+		@Override
+		public boolean equals(Object anotherObj) {
+			UserDbMetaData anotherUserDbMetaData = (UserDbMetaData) anotherObj;
+			return (mUin.equals(anotherUserDbMetaData.mUin));
+		}
+	
+	    /**
+	     * Call me when you are ready to open a database
+	     */
+		public static void registerDb(String uin) {
+			UserDbMetaData dbMetaData = new UserDbMetaData(uin);
+			ActiveAndroid.registerDbMetaData(Configuration.getInstance().getAppContext(), dbMetaData);
+		}
+	
+	}
+
+#### Annotate @DatabaseMetaData to your modal class
+
+	@DatabaseMetaData(metadataClass = UserDbMetaData.class)
+	public class Album extends Model implements Serializable { ... }
+
+#### Ehancement
+
+* If you add new modal class, just increate the value return by `getDatabaseVersion()`, ActiveAndroid
+will be able to setup missing table on next registration.
+* Alternative to using @DatabaseMetaData, you could also tell ActiveAndroid where is all your modal class via 
+`res/xml/db_model_config.xml`. Rather than looking up all annotated class in dex.jar, 
+this approach will significantly improve your App's startup time.
+
+#### Reset are almost the same. Enjoy it~ 
\ No newline at end of file
diff --git a/res/xml/db_model_config.xml b/res/xml/db_model_config.xml
new file mode 100644
index 00000000..164a018a
--- /dev/null
+++ b/res/xml/db_model_config.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<db_model_config>
+    <class>com.activeandroid.serializer.CalendarSerializer</class>
+    <class>com.activeandroid.serializer.SqlDateSerializer</class>
+    <class>com.activeandroid.serializer.UtilDateSerializer</class>
+</db_model_config>
\ No newline at end of file
diff --git a/src/com/activeandroid/ActiveAndroid.java b/src/com/activeandroid/ActiveAndroid.java
old mode 100755
new mode 100644
index a1625222..2db41739
--- a/src/com/activeandroid/ActiveAndroid.java
+++ b/src/com/activeandroid/ActiveAndroid.java
@@ -43,6 +43,10 @@ public static void clearCache() {
         Cache.clearCache();
     }
 
+    public static void clearCache(Class<? extends Model> entityClazz) {
+        Cache.clearCache(entityClazz);
+    }
+
     public static void dispose() {
         Cache.dispose();
     }
diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
index c2e066f4..853b79f8 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -95,6 +95,16 @@ public static synchronized void clearCache() {
         Log.v("Cache cleared.");
     }
 
+    public static synchronized void clearCache(Class<? extends Model> entityClazz) {
+        SoftReference<Model> removedRef = null;
+        for (SoftReference<Model> ref: sEntities) {
+            Model model = ref.get();
+            if (model != null && (entityClazz.isAssignableFrom(model.getClass()))) {
+                sEntities.remove(removedRef);
+            }
+        }
+    }
+
     public static synchronized void dispose() {
         closeAllDatabase();
 
@@ -108,19 +118,27 @@ public static synchronized void dispose() {
     // Database access
 
     public static synchronized SQLiteDatabase openDatabase(Class<?> type) {
+        if (sDatabaseHelper == null) return null;
         Class<? extends DbMetaData> metaDataType = ReflectionUtils.getDbMetaDataClass(type);
         DatabaseHelper databaseHelper = sDatabaseHelper.get(metaDataType);
         if (databaseHelper != null) return databaseHelper.getWritableDatabase();
-        throw new IllegalArgumentException("db meta" + metaDataType.getClass().getSimpleName() +" not found!");
+        throw new IllegalArgumentException("db meta " + metaDataType.getClass().getSimpleName() +" not found!");
     }
 
     public static synchronized void closeDatabase(Class<?> type) {
+        if (sDatabaseHelper == null) return;
         Class<? extends DbMetaData> metaDataType = ReflectionUtils.getDbMetaDataClass(type);
         DatabaseHelper databaseHelper = sDatabaseHelper.get(metaDataType);
-        if (databaseHelper != null) databaseHelper.close();
+        if (databaseHelper != null) {
+            try {
+                databaseHelper.getWritableDatabase().endTransaction();
+            } catch (Exception e) {}
+            databaseHelper.close();
+        }
     }
 
     public static synchronized void closeAllDatabase() {
+        if (sDatabaseHelper == null) return;
         for (DatabaseHelper databaseHelper : sDatabaseHelper.values()) {
             databaseHelper.close();
         }
@@ -167,18 +185,22 @@ public static synchronized void removeEntity(Model entity) {
     // Model cache
 
     public static synchronized Collection<TableInfo> getTableInfos() {
+        if (sModelInfo == null) return null;
         return sModelInfo.getTableInfos();
     }
 
     public static synchronized TableInfo getTableInfo(Class<? extends Model> type) {
+        if (sModelInfo == null) return null;
         return sModelInfo.getTableInfo(type);
     }
 
     public static synchronized TypeSerializer getParserForType(Class<?> type) {
+        if (sModelInfo == null) return null;
         return sModelInfo.getTypeSerializer(type);
     }
 
     public static synchronized String getTableName(Class<? extends Model> type) {
+        if (sModelInfo == null) return null;
         return sModelInfo.getTableInfo(type).getTableName();
     }
-}
\ No newline at end of file
+}
diff --git a/src/com/activeandroid/DatabaseHelper.java b/src/com/activeandroid/DatabaseHelper.java
index e6b1ec11..36b638db 100644
--- a/src/com/activeandroid/DatabaseHelper.java
+++ b/src/com/activeandroid/DatabaseHelper.java
@@ -25,9 +25,11 @@
 import java.io.OutputStream;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 
 import android.content.Context;
+import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
 
@@ -70,8 +72,6 @@ public void onCreate(SQLiteDatabase db) {
             Log.d("generate index:" + SQLiteUtils.createIndexDefinition(tableInfo));
         }
 
-
-
         db.setTransactionSuccessful();
         db.endTransaction();
 
@@ -85,10 +85,9 @@ public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
             Log.i("Foreign Keys supported. Enabling foreign key features.");
         }
 
-        if (!executeMigrations(db, oldVersion, newVersion)) {
-            Log.i("No migrations found. Calling onCreate.");
-            onCreate(db);
-        }
+        executeMigrations(db, oldVersion, newVersion);
+        Log.i("No migrations found. Calling onCreate.");
+        onCreate(db);
     }
 
     //////////////////////////////////////////////////////////////////////////////////////
@@ -143,7 +142,6 @@ private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVers
             for (String file : files) {
                 try {
                     final int version = Integer.valueOf(file.replace(".sql", ""));
-
                     if (version > oldVersion && version <= newVersion) {
                         executeSqlScript(db, file);
                         migrationExecuted = true;
@@ -156,6 +154,22 @@ private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVers
                 }
             }
 
+            HashSet<String> createdTableNames = new HashSet<String>();
+            Cursor cursor = db.rawQuery("select name from sqlite_master where type='table'", null);
+            if (cursor.moveToFirst()) {
+                while (cursor.moveToNext()) {
+                    createdTableNames.add(cursor.getString(0));
+                }
+            }
+            for (TableInfo tableInfo : Cache.getTableInfos()) {
+                if (createdTableNames.contains(tableInfo.getTableName())) continue;
+                db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
+                migrationExecuted = true;
+                Log.d("generate index:" + SQLiteUtils.createIndexDefinition(tableInfo));
+            }
+
+            mDbMetaData.onUpgrade(db, oldVersion, newVersion);
+
             db.setTransactionSuccessful();
             db.endTransaction();
         }
@@ -173,7 +187,12 @@ private void executeSqlScript(SQLiteDatabase db, String file) {
             String line = null;
 
             while ((line = reader.readLine()) != null) {
-                db.execSQL(line.replace(";", ""));
+                if (line.startsWith("#")) continue;
+                try{
+                    db.execSQL(line.replace(";", ""));
+                }catch (Exception e){
+                    e.printStackTrace();
+                }
             }
         }
         catch (IOException e) {
@@ -181,4 +200,27 @@ private void executeSqlScript(SQLiteDatabase db, String file) {
         }
     }
 
+    private void dropAllTableAndCreate(SQLiteDatabase db){
+        try{
+            db.beginTransaction();
+
+            for (TableInfo tableInfo : Cache.getTableInfos()) {
+                db.execSQL(SQLiteUtils.dropTableDefinition(tableInfo));
+            }
+
+            db.setTransactionSuccessful();
+            db.endTransaction();
+            onCreate(db);
+        }  catch (Exception e) {
+            e.printStackTrace();
+            Log.e("Failed to execute drop all table");
+        }
+    }
+
+
+    @Override
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        dropAllTableAndCreate(db);
+    }
+
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/DbMetaData.java b/src/com/activeandroid/DbMetaData.java
old mode 100755
new mode 100644
index f734c64d..147ee5dd
--- a/src/com/activeandroid/DbMetaData.java
+++ b/src/com/activeandroid/DbMetaData.java
@@ -1,5 +1,7 @@
 package com.activeandroid;
 
+import android.database.sqlite.SQLiteDatabase;
+
 public abstract class DbMetaData {
 
     public abstract int getDatabaseVersion();
@@ -8,5 +10,7 @@
 
     public abstract String getMigrationPath();
 
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {}
+
     public boolean isResettable() { return false; }
 }
diff --git a/src/com/activeandroid/DefaultMetaData.java b/src/com/activeandroid/DefaultMetaData.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 7c82b1f1..cbc8dbfb 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -49,7 +49,7 @@
 
     public Model() {
         mTableInfo = Cache.getTableInfo(getClass());
-        Cache.addEntity(this);
+        if (mTableInfo != null) Cache.addEntity(this);
     }
 
     //////////////////////////////////////////////////////////////////////////////////////
@@ -71,6 +71,8 @@ public final void delete() {
     }
 
     public final void save() {
+        preSave();
+
         final SQLiteDatabase db = Cache.openDatabase(ReflectionUtils.getDbMetaDataClass(getClass()));
         final ContentValues values = new ContentValues();
 
@@ -153,6 +155,8 @@ else if (ReflectionUtils.isModel(fieldType)) {
         else {
             db.update(mTableInfo.getTableName(), values, "Id=" + mId, null);
         }
+
+        postSave();
     }
 
     // Convenience methods
@@ -161,8 +165,11 @@ public static void delete(Class<? extends Model> type, long id) {
         new Delete().from(type).where("Id=?", id).execute();
     }
 
+    @SuppressWarnings("unchecked")
     public static <T extends Model> T load(Class<? extends Model> type, long id) {
-        return new Select().from(type).where("Id=?", id).executeSingle();
+        T entity = (T) new Select().from(type).where("Id=?", id).executeSingle();
+        if (entity != null) entity.postLoad();
+        return entity;
     }
 
     // Model population
@@ -255,6 +262,7 @@ else if (ReflectionUtils.isModel(fieldType)) {
                 Log.e(e.getMessage());
             }
         }
+        postLoad();
     }
 
     //////////////////////////////////////////////////////////////////////////////////////
@@ -276,4 +284,13 @@ public boolean equals(Object obj) {
         return this.mId != null && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()))
                 && (this.mId.equals(other.mId));
     }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // EVENT INTERFACE
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    protected void preSave() {};
+    protected void postSave() {};
+    protected void postLoad() {};
+
 }
diff --git a/src/com/activeandroid/ModelInfo.java b/src/com/activeandroid/ModelInfo.java
old mode 100755
new mode 100644
index 07900736..23e5a61d
--- a/src/com/activeandroid/ModelInfo.java
+++ b/src/com/activeandroid/ModelInfo.java
@@ -26,148 +26,200 @@
 import java.util.List;
 import java.util.Map;
 
+import org.xmlpull.v1.XmlPullParserException;
+
 import android.app.Application;
+import android.content.res.XmlResourceParser;
+import android.text.TextUtils;
 
 import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.test.R;
 import com.activeandroid.util.Log;
 import com.activeandroid.util.ReflectionUtils;
 
 import dalvik.system.DexFile;
 
 final class ModelInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Map<Class<? extends Model>, TableInfo> mTableInfos;
-	private Map<Class<?>, TypeSerializer> mTypeSerializers;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public ModelInfo(Application application) {
-		mTableInfos = new HashMap<Class<? extends Model>, TableInfo>();
-		mTypeSerializers = new HashMap<Class<?>, TypeSerializer>();
-
-		try {
-			scanForModel(application);
-		}
-		catch (IOException e) {
-			Log.e("Couln't open source path.", e);
-		}
-
-		Log.i("ModelInfo loaded.");
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Collection<TableInfo> getTableInfos() {
-		return mTableInfos.values();
-	}
-
-	public TableInfo getTableInfo(Class<? extends Model> type) {
-		return mTableInfos.get(type);
-	}
-
-	@SuppressWarnings("unchecked")
-	public List<Class<? extends Model>> getModelClasses() {
-		return (List<Class<? extends Model>>) mTableInfos.keySet();
-	}
-
-	public TypeSerializer getTypeSerializer(Class<?> type) {
-		return mTypeSerializers.get(type);
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private void scanForModel(Application application) throws IOException {
-		String packageName = application.getPackageName();
-		String sourcePath = application.getApplicationInfo().sourceDir;
-		List<String> paths = new ArrayList<String>();
-
-		if (sourcePath != null) {
-			DexFile dexfile = new DexFile(sourcePath);
-			Enumeration<String> entries = dexfile.entries();
-
-			while (entries.hasMoreElements()) {
-				paths.add(entries.nextElement());
-			}
-		}
-		// Robolectric fallback
-		else {
-			ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-			Enumeration<URL> resources = classLoader.getResources("");
-
-			while (resources.hasMoreElements()) {
-				String path = resources.nextElement().getFile();
-				if (path.contains("bin")) {
-					paths.add(path);
-				}
-			}
-		}
-
-		for (String path : paths) {
-			File file = new File(path);
-			scanForModelClasses(file, packageName, application.getClass().getClassLoader());
-		}
-	}
-
-	private void scanForModelClasses(File path, String packageName, ClassLoader classLoader) {
-		if (path.isDirectory()) {
-			for (File file : path.listFiles()) {
-				scanForModelClasses(file, packageName, classLoader);
-			}
-		}
-		else {
-			String className = path.getName();
-
-			// Robolectric fallback
-			if (!path.getPath().equals(className)) {
-				className = path.getPath();
-
-				if (className.endsWith(".class")) {
-					className = className.substring(0, className.length() - 6);
-				}
-				else {
-					return;
-				}
-
-				className = className.replace("/", ".");
-
-				int packageNameIndex = className.lastIndexOf(packageName);
-				if (packageNameIndex < 0) {
-					return;
-				}
-
-				className = className.substring(packageNameIndex);
-			}
-
-			try {
-				Class<?> discoveredClass = Class.forName(className, false, classLoader);
-				if (ReflectionUtils.isModel(discoveredClass)) {
-					@SuppressWarnings("unchecked")
-					Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
-					mTableInfos.put(modelClass, new TableInfo(modelClass));
-				}
-				else if (ReflectionUtils.isTypeSerializer(discoveredClass)) {
-					TypeSerializer typeSerializer = (TypeSerializer) discoveredClass.newInstance();
-					mTypeSerializers.put(typeSerializer.getDeserializedType(), typeSerializer);
-				}
-			}
-			catch (ClassNotFoundException e) {
-				Log.e("Couldn't create class.", e);
-			}
-			catch (InstantiationException e) {
-				Log.e("Couldn't instantiate TypeSerializer.", e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e("IllegalAccessException", e);
-			}
-		}
-	}
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Map<Class<? extends Model>, TableInfo> mTableInfos;
+    private Map<Class<?>, TypeSerializer> mTypeSerializers;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public ModelInfo(Application application) {
+        mTableInfos = new HashMap<Class<? extends Model>, TableInfo>();
+        mTypeSerializers = new HashMap<Class<?>, TypeSerializer>();
+
+        if (!scanForModelFromConfigXML(application)) {
+            try {
+                scanForModel(application);
+            }
+            catch (IOException e) {
+                Log.e("Couln't open source path.", e);
+            }
+        }
+
+        Log.i("ModelInfo loaded.");
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Collection<TableInfo> getTableInfos() {
+        return mTableInfos.values();
+    }
+
+    public TableInfo getTableInfo(Class<? extends Model> type) {
+        return mTableInfos.get(type);
+    }
+
+    @SuppressWarnings("unchecked")
+    public List<Class<? extends Model>> getModelClasses() {
+        return (List<Class<? extends Model>>) mTableInfos.keySet();
+    }
+
+    public TypeSerializer getTypeSerializer(Class<?> type) {
+        return mTypeSerializers.get(type);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private boolean scanForModelFromConfigXML(Application application) {
+        XmlResourceParser xmlParser = application.getResources().getXml(R.xml.db_model_config);
+        if (xmlParser == null) {
+            Log.w("db_model_config.xml is not provided.");
+            return false;
+        }
+
+        try {
+            while (XmlResourceParser.END_DOCUMENT != xmlParser.getEventType()) {
+                if (XmlResourceParser.START_TAG == xmlParser.getEventType()) {
+                    String tagName = xmlParser.getName();
+                    if (tagName.equals("class")) {
+                        String className = xmlParser.nextText();
+                        if (TextUtils.isEmpty(className)) continue;
+                        Class<?> discoveredClass = Class.forName(className, false,
+                                application.getClass().getClassLoader());
+                        if (discoveredClass == null) continue;
+                        if (ReflectionUtils.isModel(discoveredClass)) {
+                            @SuppressWarnings("unchecked")
+                            Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
+                            mTableInfos.put(modelClass, new TableInfo(modelClass));
+                        }
+                        else if (ReflectionUtils.isTypeSerializer(discoveredClass)) {
+                            TypeSerializer typeSerializer = (TypeSerializer) discoveredClass.newInstance();
+                            mTypeSerializers.put(typeSerializer.getDeserializedType(), typeSerializer);
+                        }
+                    }
+                }
+                xmlParser.next();
+            }
+        } catch (XmlPullParserException e) {
+            Log.e(e.getMessage());
+        } catch (IOException e) {
+            Log.e(e.getMessage());
+        } catch (ClassNotFoundException e) {
+            Log.e("Couldn't create class.", e);
+        } catch (InstantiationException e) {
+            Log.e("Couldn't instantiate TypeSerializer.", e);
+        } catch (IllegalAccessException e) {
+            Log.e("IllegalAccessException", e);
+        }
+
+        return !mTableInfos.isEmpty();
+    }
+
+    private void scanForModel(Application application) throws IOException {
+        String packageName = application.getPackageName();
+        String sourcePath = application.getApplicationInfo().sourceDir;
+        List<String> paths = new ArrayList<String>();
+
+        if (sourcePath != null) {
+            DexFile dexfile = new DexFile(sourcePath);
+            Enumeration<String> entries = dexfile.entries();
+
+            while (entries.hasMoreElements()) {
+                paths.add(entries.nextElement());
+            }
+        }
+        // Robolectric fallback
+        else {
+            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+            Enumeration<URL> resources = classLoader.getResources("");
+
+            while (resources.hasMoreElements()) {
+                String path = resources.nextElement().getFile();
+                if (path.contains("bin")) {
+                    paths.add(path);
+                }
+            }
+        }
+
+        for (String path : paths) {
+            File file = new File(path);
+            scanForModelClasses(file, packageName, application.getClass().getClassLoader());
+        }
+    }
+
+    private void scanForModelClasses(File path, String packageName, ClassLoader classLoader) {
+        if (path.isDirectory()) {
+            for (File file : path.listFiles()) {
+                scanForModelClasses(file, packageName, classLoader);
+            }
+        }
+        else {
+            String className = path.getName();
+
+            // Robolectric fallback
+            if (!path.getPath().equals(className)) {
+                className = path.getPath();
+
+                if (className.endsWith(".class")) {
+                    className = className.substring(0, className.length() - 6);
+                }
+                else {
+                    return;
+                }
+
+                className = className.replace("/", ".");
+
+                int packageNameIndex = className.lastIndexOf(packageName);
+                if (packageNameIndex < 0) {
+                    return;
+                }
+
+                className = className.substring(packageNameIndex);
+            }
+
+            try {
+                Class<?> discoveredClass = Class.forName(className, false, classLoader);
+                if (ReflectionUtils.isModel(discoveredClass)) {
+                    @SuppressWarnings("unchecked")
+                    Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
+                    mTableInfos.put(modelClass, new TableInfo(modelClass));
+                }
+                else if (ReflectionUtils.isTypeSerializer(discoveredClass)) {
+                    TypeSerializer typeSerializer = (TypeSerializer) discoveredClass.newInstance();
+                    mTypeSerializers.put(typeSerializer.getDeserializedType(), typeSerializer);
+                }
+            }
+            catch (ClassNotFoundException e) {
+                Log.e("Couldn't create class.", e);
+            }
+            catch (InstantiationException e) {
+                Log.e("Couldn't instantiate TypeSerializer.", e);
+            }
+            catch (IllegalAccessException e) {
+                Log.e("IllegalAccessException", e);
+            }
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/TableInfo.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/annotation/Column.java b/src/com/activeandroid/annotation/Column.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/annotation/CreateIndex.java b/src/com/activeandroid/annotation/CreateIndex.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/annotation/DatabaseMetaData.java b/src/com/activeandroid/annotation/DatabaseMetaData.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/annotation/Table.java b/src/com/activeandroid/annotation/Table.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/app/Application.java b/src/com/activeandroid/app/Application.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/content/ContentProvider.java b/src/com/activeandroid/content/ContentProvider.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/query/Delete.java b/src/com/activeandroid/query/Delete.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/query/From.java b/src/com/activeandroid/query/From.java
index 9845af4c..589c9627 100644
--- a/src/com/activeandroid/query/From.java
+++ b/src/com/activeandroid/query/From.java
@@ -195,10 +195,11 @@ public String toSql() {
         }
     }
 
+    @SuppressWarnings("unchecked")
     public <T extends Model> T executeSingle() {
         if (mQueryBase instanceof Select) {
             limit(1);
-            return SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
+            return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
         }
         else {
             SQLiteUtils.execSql(mType, toSql(), getArguments());
diff --git a/src/com/activeandroid/query/Join.java b/src/com/activeandroid/query/Join.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/query/Select.java b/src/com/activeandroid/query/Select.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/query/Set.java b/src/com/activeandroid/query/Set.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/query/Sqlable.java b/src/com/activeandroid/query/Sqlable.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/query/Update.java b/src/com/activeandroid/query/Update.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/serializer/CalendarSerializer.java b/src/com/activeandroid/serializer/CalendarSerializer.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/serializer/SqlDateSerializer.java b/src/com/activeandroid/serializer/SqlDateSerializer.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/serializer/TypeSerializer.java b/src/com/activeandroid/serializer/TypeSerializer.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/serializer/UtilDateSerializer.java b/src/com/activeandroid/serializer/UtilDateSerializer.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/util/Log.java b/src/com/activeandroid/util/Log.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/util/NaturalOrderComparator.java b/src/com/activeandroid/util/NaturalOrderComparator.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/util/ReflectionUtils.java b/src/com/activeandroid/util/ReflectionUtils.java
old mode 100755
new mode 100644
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
old mode 100755
new mode 100644
index eda22c86..26756c5a
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -124,6 +124,13 @@ public static String createTableDefinition(TableInfo tableInfo) {
                 TextUtils.join(", ", definitions));
     }
 
+
+    public static String dropTableDefinition(TableInfo tableInfo){
+
+        return String.format("DROP TABLE IF EXISTS %s;", tableInfo.getTableName());
+
+    }
+
     public static String createIndexDefinition(TableInfo tableInfo){
         List<String> createIndexSql=new LinkedList<String>();
 
