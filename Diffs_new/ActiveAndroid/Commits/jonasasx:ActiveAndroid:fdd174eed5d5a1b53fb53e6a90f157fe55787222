diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 421426ea..02b8abd8 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -36,42 +36,50 @@
 public abstract class Model {
 
 	/** Prime number used for hashcode() implementation. */
-	private static final int HASH_PRIME = 739;
+	private static final int	HASH_PRIME	= 739;
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	private Long mId = null;
+	private Long				mId			= null;
 
-	private final TableInfo mTableInfo;
-	private final String idName;
-	//////////////////////////////////////////////////////////////////////////////////////
+	private final TableInfo		mTableInfo;
+	private final String		idName;
+
+	private static boolean		sDisableReferences;
+
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	public Model() {
 		mTableInfo = Cache.getTableInfo(getClass());
 		idName = mTableInfo.getIdName();
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	public final Long getId() {
 		return mId;
 	}
 
+	public final void setId(long id) {
+		mId = id;
+	}
+
 	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), idName+"=?", new String[] { getId().toString() });
+		Cache.openDatabase().delete(mTableInfo.getTableName(), idName + "=?", new String[] { getId().toString() });
 		Cache.removeEntity(this);
 
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+		Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
 	}
 
 	public final Long save() {
+		if (!onBeforeSave())
+			return null;
 		final SQLiteDatabase db = Cache.openDatabase();
 		final ContentValues values = new ContentValues();
 
@@ -94,8 +102,7 @@ public final Long save() {
 							fieldType = value.getClass();
 							// check that the serializer returned what it promised
 							if (!fieldType.equals(typeSerializer.getSerializedType())) {
-								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-										typeSerializer.getSerializedType(), fieldType));
+								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s", typeSerializer.getSerializedType(), fieldType));
 							}
 						}
 					}
@@ -105,61 +112,45 @@ public final Long save() {
 				// can't know the type until runtime.
 				if (value == null) {
 					values.putNull(fieldName);
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+				} else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
 					values.put(fieldName, (Byte) value);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+				} else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
 					values.put(fieldName, (Short) value);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+				} else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
 					values.put(fieldName, (Integer) value);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+				} else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
 					values.put(fieldName, (Long) value);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+				} else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
 					values.put(fieldName, (Float) value);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+				} else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
 					values.put(fieldName, (Double) value);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+				} else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
 					values.put(fieldName, (Boolean) value);
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+				} else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
 					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(String.class)) {
+				} else if (fieldType.equals(String.class)) {
 					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+				} else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
 					values.put(fieldName, (byte[]) value);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
+				} else if (ReflectionUtils.isModel(fieldType)) {
 					values.put(fieldName, ((Model) value).getId());
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+				} else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 					values.put(fieldName, ((Enum<?>) value).name());
 				}
-			}
-			catch (IllegalArgumentException e) {
+			} catch (IllegalArgumentException e) {
 				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
+			} catch (IllegalAccessException e) {
 				Log.e(e.getClass().getName(), e);
 			}
 		}
 
 		if (mId == null) {
 			mId = db.insert(mTableInfo.getTableName(), null, values);
-		}
-		else {
-			db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
+		} else {
+			db.update(mTableInfo.getTableName(), values, idName + "=" + mId, null);
 		}
 
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+		Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
 		return mId;
 	}
 
@@ -167,22 +158,21 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 
 	public static void delete(Class<? extends Model> type, long id) {
 		TableInfo tableInfo = Cache.getTableInfo(type);
-		new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
+		new Delete().from(type).where(tableInfo.getIdName() + "=?", id).execute();
 	}
 
 	public static <T extends Model> T load(Class<T> type, long id) {
 		TableInfo tableInfo = Cache.getTableInfo(type);
-		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
+		return (T) new Select().from(type).where(tableInfo.getIdName() + "=?", id).executeSingle();
 	}
 
 	// Model population
 
 	public final void loadFromCursor(Cursor cursor) {
-        /**
-         * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-         * when the cursor have multiple columns with same name obtained from join tables.
-         */
-        List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+		/**
+		 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106) when the cursor have multiple columns with same name obtained from join tables.
+		 */
+		List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
 		for (Field field : mTableInfo.getFields()) {
 			final String fieldName = mTableInfo.getColumnName(field);
 			Class<?> fieldType = field.getType();
@@ -206,50 +196,38 @@ public final void loadFromCursor(Cursor cursor) {
 				// TODO: Find a smarter way to do this? This if block is necessary because we
 				// can't know the type until runtime.
 				if (columnIsNull) {
-					field = null;
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+					value = null;
+				} else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
 					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+				} else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
 					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+				} else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
 					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+				} else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
 					value = cursor.getLong(columnIndex);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+				} else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
 					value = cursor.getFloat(columnIndex);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+				} else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
 					value = cursor.getDouble(columnIndex);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+				} else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
 					value = cursor.getInt(columnIndex) != 0;
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+				} else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
 					value = cursor.getString(columnIndex).charAt(0);
-				}
-				else if (fieldType.equals(String.class)) {
+				} else if (fieldType.equals(String.class)) {
 					value = cursor.getString(columnIndex);
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+				} else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
 					value = cursor.getBlob(columnIndex);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
+				} else if (ReflectionUtils.isModel(fieldType)) {
 					final long entityId = cursor.getLong(columnIndex);
 					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
 
 					Model entity = Cache.getEntity(entityType, entityId);
-					if (entity == null) {
-						entity = new Select().from(entityType).where(idName+"=?", entityId).executeSingle();
+					if (entity == null && !sDisableReferences) {
+						entity = new Select().from(entityType).where(idName + "=?", entityId).executeSingle();
 					}
 
 					value = entity;
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+				} else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 					@SuppressWarnings("rawtypes")
 					final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
 					value = Enum.valueOf(enumType, cursor.getString(columnIndex));
@@ -264,34 +242,31 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 				if (value != null) {
 					field.set(this, value);
 				}
-			}
-			catch (IllegalArgumentException e) {
+			} catch (IllegalArgumentException e) {
 				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
+			} catch (IllegalAccessException e) {
 				Log.e(e.getClass().getName(), e);
-			}
-			catch (SecurityException e) {
+			} catch (SecurityException e) {
 				Log.e(e.getClass().getName(), e);
 			}
+			if (field.getName().equals("mId") && field.getDeclaringClass() == Model.class && mId != null) {
+				Cache.addEntity(this);
+			}
 		}
 
-		if (mId != null) {
-			Cache.addEntity(this);
-		}
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
 		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	@Override
 	public String toString() {
@@ -303,8 +278,7 @@ public boolean equals(Object obj) {
 		if (obj instanceof Model && this.mId != null) {
 			final Model other = (Model) obj;
 
-			return this.mId.equals(other.mId)							
-							&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
+			return this.mId.equals(other.mId) && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
 		} else {
 			return this == obj;
 		}
@@ -313,8 +287,20 @@ public boolean equals(Object obj) {
 	@Override
 	public int hashCode() {
 		int hash = HASH_PRIME;
-		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); //if id is null, use Object.hashCode()
+		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); // if id is null, use Object.hashCode()
 		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
-		return hash; //To change body of generated methods, choose Tools | Templates.
+		return hash; // To change body of generated methods, choose Tools | Templates.
+	}
+
+	public static boolean isDisableReferences() {
+		return sDisableReferences;
+	}
+
+	public static void setDisableReferences(boolean disableReferences) {
+		Model.sDisableReferences = disableReferences;
+	}
+
+	protected boolean onBeforeSave() {
+		return true;
 	}
 }
diff --git a/src/com/activeandroid/util/ReflectionUtils.java b/src/com/activeandroid/util/ReflectionUtils.java
index 32e995cc..4c5ab1ea 100644
--- a/src/com/activeandroid/util/ReflectionUtils.java
+++ b/src/com/activeandroid/util/ReflectionUtils.java
@@ -33,9 +33,9 @@
 import com.activeandroid.serializer.TypeSerializer;
 
 public final class ReflectionUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	public static boolean isModel(Class<?> type) {
 		return isSubclassOf(type, Model.class) && (!Modifier.isAbstract(type.getModifiers()));
@@ -50,26 +50,24 @@ public static boolean isTypeSerializer(Class<?> type) {
 	@SuppressWarnings("unchecked")
 	public static <T> T getMetaData(Context context, String name) {
 		try {
-			final ApplicationInfo ai = context.getPackageManager().getApplicationInfo(context.getPackageName(),
-					PackageManager.GET_META_DATA);
+			final ApplicationInfo ai = context.getPackageManager().getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
 
 			if (ai.metaData != null) {
 				return (T) ai.metaData.get(name);
 			}
-		}
-		catch (Exception e) {
+		} catch (Exception e) {
 			Log.w("Couldn't find meta-data: " + name);
 		}
 
 		return null;
 	}
-	
+
 	public static Set<Field> getDeclaredColumnFields(Class<?> type) {
 		Set<Field> declaredColumnFields = Collections.emptySet();
-		
+		Set<String> declaredColumnFieldsNames = new LinkedHashSet<String>();
 		if (ReflectionUtils.isSubclassOf(type, Model.class) || Model.class.equals(type)) {
 			declaredColumnFields = new LinkedHashSet<Field>();
-			
+
 			Field[] fields = type.getDeclaredFields();
 			Arrays.sort(fields, new Comparator<Field>() {
 				@Override
@@ -80,21 +78,26 @@ public int compare(Field field1, Field field2) {
 			for (Field field : fields) {
 				if (field.isAnnotationPresent(Column.class)) {
 					declaredColumnFields.add(field);
+					declaredColumnFieldsNames.add(field.getName());
 				}
 			}
-	
+
 			Class<?> parentType = type.getSuperclass();
 			if (parentType != null) {
-				declaredColumnFields.addAll(getDeclaredColumnFields(parentType));
+				Set<Field> superFields = getDeclaredColumnFields(parentType);
+				for (Field field : superFields) {
+					if (!declaredColumnFieldsNames.contains(field.getName()))
+						declaredColumnFields.add(field);
+				}
 			}
 		}
-		
-		return declaredColumnFields;		
+
+		return declaredColumnFields;
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	public static boolean isSubclassOf(Class<?> type, Class<?> superClass) {
 		if (type.getSuperclass() != null) {
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index cbf41eae..9a767409 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -39,60 +39,60 @@
 import java.util.Set;
 
 public final class SQLiteUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// ENUMERATIONS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	public enum SQLiteType {
 		INTEGER, REAL, TEXT, BLOB
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+	public static final boolean							FOREIGN_KEYS_SUPPORTED	= Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE CONTSANTS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
-		{
-			put(byte.class, SQLiteType.INTEGER);
-			put(short.class, SQLiteType.INTEGER);
-			put(int.class, SQLiteType.INTEGER);
-			put(long.class, SQLiteType.INTEGER);
-			put(float.class, SQLiteType.REAL);
-			put(double.class, SQLiteType.REAL);
-			put(boolean.class, SQLiteType.INTEGER);
-			put(char.class, SQLiteType.TEXT);
-			put(byte[].class, SQLiteType.BLOB);
-			put(Byte.class, SQLiteType.INTEGER);
-			put(Short.class, SQLiteType.INTEGER);
-			put(Integer.class, SQLiteType.INTEGER);
-			put(Long.class, SQLiteType.INTEGER);
-			put(Float.class, SQLiteType.REAL);
-			put(Double.class, SQLiteType.REAL);
-			put(Boolean.class, SQLiteType.INTEGER);
-			put(Character.class, SQLiteType.TEXT);
-			put(String.class, SQLiteType.TEXT);
-			put(Byte[].class, SQLiteType.BLOB);
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
+	private static final HashMap<Class<?>, SQLiteType>	TYPE_MAP				= new HashMap<Class<?>, SQLiteType>() {
+																					{
+																						put(byte.class, SQLiteType.INTEGER);
+																						put(short.class, SQLiteType.INTEGER);
+																						put(int.class, SQLiteType.INTEGER);
+																						put(long.class, SQLiteType.INTEGER);
+																						put(float.class, SQLiteType.REAL);
+																						put(double.class, SQLiteType.REAL);
+																						put(boolean.class, SQLiteType.INTEGER);
+																						put(char.class, SQLiteType.TEXT);
+																						put(byte[].class, SQLiteType.BLOB);
+																						put(Byte.class, SQLiteType.INTEGER);
+																						put(Short.class, SQLiteType.INTEGER);
+																						put(Integer.class, SQLiteType.INTEGER);
+																						put(Long.class, SQLiteType.INTEGER);
+																						put(Float.class, SQLiteType.REAL);
+																						put(Double.class, SQLiteType.REAL);
+																						put(Boolean.class, SQLiteType.INTEGER);
+																						put(Character.class, SQLiteType.TEXT);
+																						put(String.class, SQLiteType.TEXT);
+																						put(Byte[].class, SQLiteType.BLOB);
+																					}
+																				};
+
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	private static HashMap<String, List<String>> sIndexGroupMap;
-	private static HashMap<String, List<String>> sUniqueGroupMap;
-	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
+	private static HashMap<String, List<String>>		sIndexGroupMap;
+	private static HashMap<String, List<String>>		sUniqueGroupMap;
+	private static HashMap<String, ConflictAction>		sOnUniqueConflictsMap;
 
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	public static void execSql(String sql) {
 		Cache.openDatabase().execSQL(sql);
@@ -109,13 +109,13 @@ public static void execSql(String sql, Object[] bindArgs) {
 
 		return entities;
 	}
-	  
+
 	public static int intQuery(final String sql, final String[] selectionArgs) {
-        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-        final int number = processIntCursor(cursor);
-        cursor.close();
+		final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+		final int number = processIntCursor(cursor);
+		cursor.close();
 
-        return number;
+		return number;
 	}
 
 	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
@@ -148,8 +148,7 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
 			List<String> group = sUniqueGroupMap.get(key);
 			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
 
-			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
-					TextUtils.join(", ", group), conflictAction.toString()));
+			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s", TextUtils.join(", ", group), conflictAction.toString()));
 		}
 
 		return definitions;
@@ -159,9 +158,9 @@ public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field
 		final String name = tableInfo.getColumnName(field);
 		final Column column = field.getAnnotation(Column.class);
 
-        if (field.getName().equals("mId")) {
-            return;
-        }
+		if (field.getName().equals("mId") && field.getDeclaringClass() == Model.class) {
+			return;
+		}
 
 		String[] groups = column.uniqueGroups();
 		ConflictAction[] conflictActions = column.onUniqueConflicts();
@@ -199,9 +198,8 @@ public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field
 		}
 
 		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
-			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
-					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
-					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
+			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);", "index_" + tableInfo.getTableName() + "_" + entry.getKey(), tableInfo.getTableName(),
+					TextUtils.join(", ", entry.getValue())));
 		}
 
 		return definitions.toArray(new String[definitions.size()]);
@@ -211,9 +209,9 @@ public static void createIndexColumnDefinition(TableInfo tableInfo, Field field)
 		final String name = tableInfo.getColumnName(field);
 		final Column column = field.getAnnotation(Column.class);
 
-        if (field.getName().equals("mId")) {
-            return;
-        }
+		if (field.getName().equals("mId")) {
+			return;
+		}
 
 		if (column.index()) {
 			List<String> list = new ArrayList<String>();
@@ -248,8 +246,7 @@ public static String createTableDefinition(TableInfo tableInfo) {
 
 		definitions.addAll(createUniqueDefinition(tableInfo));
 
-		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
-				TextUtils.join(", ", definitions));
+		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(), TextUtils.join(", ", definitions));
 	}
 
 	@SuppressWarnings("unchecked")
@@ -269,13 +266,11 @@ public static String createColumnDefinition(TableInfo tableInfo, Field field) {
 			definition.append(name);
 			definition.append(" ");
 			definition.append(TYPE_MAP.get(type).toString());
-		}
-		else if (ReflectionUtils.isModel(type)) {
+		} else if (ReflectionUtils.isModel(type)) {
 			definition.append(name);
 			definition.append(" ");
 			definition.append(SQLiteType.INTEGER.toString());
-		}
-		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
+		} else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 			definition.append(name);
 			definition.append(" ");
 			definition.append(SQLiteType.TEXT.toString());
@@ -285,7 +280,7 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 
 			if (name.equals(tableInfo.getIdName())) {
 				definition.append(" PRIMARY KEY AUTOINCREMENT");
-			}else if(column!=null){
+			} else if (column != null) {
 				if (column.length() > -1) {
 					definition.append("(");
 					definition.append(column.length());
@@ -306,14 +301,13 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
 				definition.append(" REFERENCES ");
 				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
-				definition.append("("+tableInfo.getIdName()+")");
+				definition.append("(" + tableInfo.getIdName() + ")");
 				definition.append(" ON DELETE ");
 				definition.append(column.onDelete().toString().replace("_", " "));
 				definition.append(" ON UPDATE ");
 				definition.append(column.onUpdate().toString().replace("_", " "));
 			}
-		}
-		else {
+		} else {
 			Log.e("No type mapping for: " + type.toString());
 		}
 
@@ -330,11 +324,10 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 			Constructor<?> entityConstructor = type.getConstructor();
 
 			if (cursor.moveToFirst()) {
-                /**
-                 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-                 * when the cursor have multiple columns with same name obtained from join tables.
-                 */
-                List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+				/**
+				 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106) when the cursor have multiple columns with same name obtained from join tables.
+				 */
+				List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
 				do {
 					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
 					if (entity == null) {
@@ -343,22 +336,19 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 
 					entity.loadFromCursor(cursor);
 					entities.add((T) entity);
-				}
-				while (cursor.moveToNext());
+				} while (cursor.moveToNext());
 			}
 
-		}
-		catch (NoSuchMethodException e) {
-			throw new RuntimeException(
-                "Your model " + type.getName() + " does not define a default " +
-                "constructor. The default constructor is required for " +
-                "now in ActiveAndroid models, as the process to " +
-                "populate the ORM model is : " +
-                "1. instantiate default model " +
-                "2. populate fields"
-            );
-		}
-		catch (Exception e) {
+		} catch (NoSuchMethodException e) {
+			throw new RuntimeException("Your model "
+					+ type.getName()
+					+ " does not define a default "
+					+ "constructor. The default constructor is required for "
+					+ "now in ActiveAndroid models, as the process to "
+					+ "populate the ORM model is : "
+					+ "1. instantiate default model "
+					+ "2. populate fields");
+		} catch (Exception e) {
 			Log.e("Failed to process cursor.", e);
 		}
 
@@ -366,11 +356,11 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 	}
 
 	private static int processIntCursor(final Cursor cursor) {
-        if (cursor.moveToFirst()) {
-            return cursor.getInt(0);
-	    }
-        return 0;
-    }
+		if (cursor.moveToFirst()) {
+			return cursor.getInt(0);
+		}
+		return 0;
+	}
 
 	public static List<String> lexSqlScript(String sqlScript) {
 		ArrayList<String> sl = new ArrayList<String>();
