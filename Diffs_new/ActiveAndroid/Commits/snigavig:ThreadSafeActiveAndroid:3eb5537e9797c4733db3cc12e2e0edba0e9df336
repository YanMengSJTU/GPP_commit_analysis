diff --git a/AndroidManifest.xml b/AndroidManifest.xml
new file mode 100644
index 00000000..842ed881
--- /dev/null
+++ b/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.activeandroid">
+
+    <uses-sdk android:minSdkVersion="16" />
+    <application android:allowBackup="true" />
+</manifest>
\ No newline at end of file
diff --git a/build.gradle b/build.gradle
index 5594e43b..0d60bbb7 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,17 +1,35 @@
-apply plugin: 'java'
-apply from: 'gradle-mvn-push.gradle'
+apply plugin: 'com.android.library'
+apply plugin: 'maven'
+apply plugin: 'signing'
+// configure android plugin
+android {
+    compileSdkVersion Integer.parseInt(COMPILE_SDK_VERSION)
+    buildToolsVersion BUILD_TOOLS_VERSION
 
-targetCompatibility = '1.6'
-sourceCompatibility = '1.6'
+    defaultConfig {
+        minSdkVersion Integer.parseInt(MIN_SDK_VERSION)
+        targetSdkVersion Integer.parseInt(TARGET_SDK_VERSION)
+    }
 
-sourceSets {
-	main {
-		java {
-			srcDir 'src'
-		}
-	}
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_6
+        targetCompatibility JavaVersion.VERSION_1_6
+    }
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src']
+            resources.srcDirs = ['src']
+            aidl.srcDirs = ['src']
+            renderscript.srcDirs = ['src']
+            res.srcDirs = ['res']
+            assets.srcDirs = ['assets']
+        }
+        androidTest.setRoot('tests')
+    }
 }
 
 dependencies {
-	compile fileTree(dir: 'libs', include: '*.jar')
-}
+    compile 'com.android.support:support-v4:22.2.0'
+}
\ No newline at end of file
diff --git a/gradle.properties b/gradle.properties
index 424d885a..c44c6c94 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,18 +1,4 @@
-VERSION_NAME=3.1.0-SNAPSHOT
-VERSION_CODE=1
-GROUP=com.michaelpardo
-
-POM_DESCRIPTION=Active record style SQLite persistence for Android.
-POM_URL=https://github.com/pardom/ActiveAndroid
-POM_SCM_URL=https://github.com/pardom/ActiveAndroid
-POM_SCM_CONNECTION=scm:git@github.com:pardom/ActiveAndroid.git
-POM_SCM_DEV_CONNECTION=scm:git@github.com:pardom/ActiveAndroid.git
-POM_LICENCE_NAME=The Apache Software License, Version 2.0
-POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
-POM_LICENCE_DIST=repo
-POM_DEVELOPER_ID=michaelpardo
-POM_DEVELOPER_NAME=Michael Pardo
-
-POM_NAME=ActiveAndroid
-POM_ARTIFACT_ID=activeandroid
-POM_PACKAGING=jar
+COMPILE_SDK_VERSION = 22
+BUILD_TOOLS_VERSION = 22.0.1
+MIN_SDK_VERSION = 16
+TARGET_SDK_VERSION = 22
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 330a2c9f..a1381595 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Fri Nov 29 09:06:20 EST 2013
+#Sun Jun 14 16:37:42 EEST 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-bin.zip
+distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip
diff --git a/libs/android.jar b/libs/android.jar
deleted file mode 100644
index 4274d2b0..00000000
Binary files a/libs/android.jar and /dev/null differ
diff --git a/src/com/activeandroid/ActiveAndroid.java b/src/com/activeandroid/ActiveAndroid.java
index c58c8efd..25b18a51 100644
--- a/src/com/activeandroid/ActiveAndroid.java
+++ b/src/com/activeandroid/ActiveAndroid.java
@@ -61,7 +61,7 @@ public static SQLiteDatabase getDatabase() {
 	}
 
 	public static void beginTransaction() {
-		Cache.openDatabase().beginTransaction();
+		Cache.openDatabase().beginTransactionNonExclusive();
 	}
 
 	public static void endTransaction() {
diff --git a/src/com/activeandroid/Configuration.java b/src/com/activeandroid/Configuration.java
index b197d223..e44e926d 100644
--- a/src/com/activeandroid/Configuration.java
+++ b/src/com/activeandroid/Configuration.java
@@ -16,20 +16,21 @@
  * limitations under the License.
  */
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
 import android.content.Context;
 
 import com.activeandroid.serializer.TypeSerializer;
 import com.activeandroid.util.Log;
 import com.activeandroid.util.ReflectionUtils;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
 public class Configuration {
 
     public final static String SQL_PARSER_LEGACY = "legacy";
     public final static String SQL_PARSER_DELIMITED = "delimited";
+	public final static int MAX_SQL_CACHE_SIZE = 100;
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
diff --git a/src/com/activeandroid/DatabaseHelper.java b/src/com/activeandroid/DatabaseHelper.java
index 7158c5bb..564a663a 100644
--- a/src/com/activeandroid/DatabaseHelper.java
+++ b/src/com/activeandroid/DatabaseHelper.java
@@ -16,17 +16,6 @@
  * limitations under the License.
  */
 
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
@@ -38,202 +27,217 @@
 import com.activeandroid.util.SQLiteUtils;
 import com.activeandroid.util.SqlParser;
 
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
 public final class DatabaseHelper extends SQLiteOpenHelper {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public final static String MIGRATION_PATH = "migrations";
+    public final static String MIGRATION_PATH = "migrations";
 
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
     // PRIVATE FIELDS
     //////////////////////////////////////////////////////////////////////////////////////
 
     private final String mSqlParser;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public DatabaseHelper(Configuration configuration) {
-		super(configuration.getContext(), configuration.getDatabaseName(), null, configuration.getDatabaseVersion());
-		copyAttachedDatabase(configuration.getContext(), configuration.getDatabaseName());
-		mSqlParser = configuration.getSqlParser();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public void onOpen(SQLiteDatabase db) {
-		executePragmas(db);
-	};
-
-	@Override
-	public void onCreate(SQLiteDatabase db) {
-		executePragmas(db);
-		executeCreate(db);
-		executeMigrations(db, -1, db.getVersion());
-		executeCreateIndex(db);
-	}
-
-	@Override
-	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-		executePragmas(db);
-		executeCreate(db);
-		executeMigrations(db, oldVersion, newVersion);
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public void copyAttachedDatabase(Context context, String databaseName) {
-		final File dbPath = context.getDatabasePath(databaseName);
-
-		// If the database already exists, return
-		if (dbPath.exists()) {
-			return;
-		}
-
-		// Make sure we have a path to the file
-		dbPath.getParentFile().mkdirs();
-
-		// Try to copy database file
-		try {
-			final InputStream inputStream = context.getAssets().open(databaseName);
-			final OutputStream output = new FileOutputStream(dbPath);
-
-			byte[] buffer = new byte[8192];
-			int length;
-
-			while ((length = inputStream.read(buffer, 0, 8192)) > 0) {
-				output.write(buffer, 0, length);
-			}
-
-			output.flush();
-			output.close();
-			inputStream.close();
-		}
-		catch (IOException e) {
-			Log.e("Failed to open file", e);
-		}
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private void executePragmas(SQLiteDatabase db) {
-		if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
-			db.execSQL("PRAGMA foreign_keys=ON;");
-			Log.i("Foreign Keys supported. Enabling foreign key features.");
-		}
-	}
-
-	private void executeCreateIndex(SQLiteDatabase db) {
-		db.beginTransaction();
-		try {
-			for (TableInfo tableInfo : Cache.getTableInfos()) {
-				String[] definitions = SQLiteUtils.createIndexDefinition(tableInfo);
-
-				for (String definition : definitions) {
-					db.execSQL(definition);
-				}
-			}
-			db.setTransactionSuccessful();
-		}
-		finally {
-			db.endTransaction();
-		}
-	}
-
-	private void executeCreate(SQLiteDatabase db) {
-		db.beginTransaction();
-		try {
-			for (TableInfo tableInfo : Cache.getTableInfos()) {
-				db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
-			}
-			db.setTransactionSuccessful();
-		}
-		finally {
-			db.endTransaction();
-		}
-	}
-
-	private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
-		boolean migrationExecuted = false;
-		try {
-			final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
-			Collections.sort(files, new NaturalOrderComparator());
-
-			db.beginTransaction();
-			try {
-				for (String file : files) {
-					try {
-						final int version = Integer.valueOf(file.replace(".sql", ""));
-
-						if (version > oldVersion && version <= newVersion) {
-							executeSqlScript(db, file);
-							migrationExecuted = true;
-
-							Log.i(file + " executed succesfully.");
-						}
-					}
-					catch (NumberFormatException e) {
-						Log.w("Skipping invalidly named file: " + file, e);
-					}
-				}
-				db.setTransactionSuccessful();
-			}
-			finally {
-				db.endTransaction();
-			}
-		}
-		catch (IOException e) {
-			Log.e("Failed to execute migrations.", e);
-		}
-
-		return migrationExecuted;
-	}
-
-	private void executeSqlScript(SQLiteDatabase db, String file) {
-
-	    InputStream stream = null;
-
-		try {
-		    stream = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
-
-		    if (Configuration.SQL_PARSER_DELIMITED.equalsIgnoreCase(mSqlParser)) {
-		        executeDelimitedSqlScript(db, stream);
-
-		    } else {
-		        executeLegacySqlScript(db, stream);
-
-		    }
-
-		} catch (IOException e) {
-			Log.e("Failed to execute " + file, e);
-
-		} finally {
-		    IOUtils.closeQuietly(stream);
-
-		}
-	}
-
-	private void executeDelimitedSqlScript(SQLiteDatabase db, InputStream stream) throws IOException {
-
-	    List<String> commands = SqlParser.parse(stream);
-
-	    for(String command : commands) {
-	        db.execSQL(command);
-	    }
-	}
-
-	private void executeLegacySqlScript(SQLiteDatabase db, InputStream stream) throws IOException {
-
-	    InputStreamReader reader = null;
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public DatabaseHelper(Configuration configuration) {
+        super(configuration.getContext(), configuration.getDatabaseName(), null, configuration.getDatabaseVersion());
+        copyAttachedDatabase(configuration.getContext(), configuration.getDatabaseName());
+        mSqlParser = configuration.getSqlParser();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public void onOpen(SQLiteDatabase db) {
+        executePragmas(db);
+    }
+
+    ;
+
+    @Override
+    public void onConfigure(SQLiteDatabase db) {
+        db.enableWriteAheadLogging();
+        db.setForeignKeyConstraintsEnabled(true);
+        db.setMaxSqlCacheSize(Configuration.MAX_SQL_CACHE_SIZE);
+        executePragmas(db);
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        executePragmas(db);
+        executeCreate(db);
+        executeMigrations(db, -1, db.getVersion());
+        executeCreateIndex(db);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        executePragmas(db);
+        executeCreate(db);
+        executeMigrations(db, oldVersion, newVersion);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public void copyAttachedDatabase(Context context, String databaseName) {
+        final File dbPath = context.getDatabasePath(databaseName);
+
+        // If the database already exists, return
+        if (dbPath.exists()) {
+            return;
+        }
+
+        // Make sure we have a path to the file
+        dbPath.getParentFile().mkdirs();
+
+        // Try to copy database file
+        try {
+            final InputStream inputStream = context.getAssets().open(databaseName);
+            final OutputStream output = new FileOutputStream(dbPath);
+
+            byte[] buffer = new byte[8192];
+            int length;
+
+            while ((length = inputStream.read(buffer, 0, 8192)) > 0) {
+                output.write(buffer, 0, length);
+            }
+
+            output.flush();
+            output.close();
+            inputStream.close();
+        } catch (IOException e) {
+            Log.e("Failed to open file", e);
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private void executePragmas(SQLiteDatabase db) {
+        if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
+            db.execSQL("PRAGMA foreign_keys=ON;");
+            Log.i("Foreign Keys supported. Enabling foreign key features.");
+        }
+    }
+
+    private void executeCreateIndex(SQLiteDatabase db) {
+        db.beginTransaction();
+        try {
+            for (TableInfo tableInfo : Cache.getTableInfos()) {
+                String[] definitions = SQLiteUtils.createIndexDefinition(tableInfo);
+
+                for (String definition : definitions) {
+                    db.execSQL(definition);
+                }
+            }
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    private void executeCreate(SQLiteDatabase db) {
+        db.beginTransaction();
+        try {
+            for (TableInfo tableInfo : Cache.getTableInfos()) {
+                db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
+            }
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
+        boolean migrationExecuted = false;
+        try {
+            final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
+            Collections.sort(files, new NaturalOrderComparator());
+
+            db.beginTransaction();
+            try {
+                for (String file : files) {
+                    try {
+                        final int version = Integer.valueOf(file.replace(".sql", ""));
+
+                        if (version > oldVersion && version <= newVersion) {
+                            executeSqlScript(db, file);
+                            migrationExecuted = true;
+
+                            Log.i(file + " executed succesfully.");
+                        }
+                    } catch (NumberFormatException e) {
+                        Log.w("Skipping invalidly named file: " + file, e);
+                    }
+                }
+                db.setTransactionSuccessful();
+            } finally {
+                db.endTransaction();
+            }
+        } catch (IOException e) {
+            Log.e("Failed to execute migrations.", e);
+        }
+
+        return migrationExecuted;
+    }
+
+    private void executeSqlScript(SQLiteDatabase db, String file) {
+
+        InputStream stream = null;
+
+        try {
+            stream = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
+
+            if (Configuration.SQL_PARSER_DELIMITED.equalsIgnoreCase(mSqlParser)) {
+                executeDelimitedSqlScript(db, stream);
+
+            } else {
+                executeLegacySqlScript(db, stream);
+
+            }
+
+        } catch (IOException e) {
+            Log.e("Failed to execute " + file, e);
+
+        } finally {
+            IOUtils.closeQuietly(stream);
+
+        }
+    }
+
+    private void executeDelimitedSqlScript(SQLiteDatabase db, InputStream stream) throws IOException {
+
+        List<String> commands = SqlParser.parse(stream);
+
+        for (String command : commands) {
+            db.execSQL(command);
+        }
+    }
+
+    private void executeLegacySqlScript(SQLiteDatabase db, InputStream stream) throws IOException {
+
+        InputStreamReader reader = null;
         BufferedReader buffer = null;
 
         try {
@@ -253,5 +257,5 @@ private void executeLegacySqlScript(SQLiteDatabase db, InputStream stream) throw
             IOUtils.closeQuietly(reader);
 
         }
-	}
+    }
 }
