diff --git a/src/com/activeandroid/sebbia/ActiveAndroid.java b/src/com/activeandroid/ActiveAndroid.java
similarity index 96%
rename from src/com/activeandroid/sebbia/ActiveAndroid.java
rename to src/com/activeandroid/ActiveAndroid.java
index 902c33ba..c58c8efd 100644
--- a/src/com/activeandroid/sebbia/ActiveAndroid.java
+++ b/src/com/activeandroid/ActiveAndroid.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia;
+package com.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -19,7 +19,7 @@
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 
-import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.util.Log;
 
 public final class ActiveAndroid {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/sebbia/Cache.java b/src/com/activeandroid/Cache.java
similarity index 95%
rename from src/com/activeandroid/sebbia/Cache.java
rename to src/com/activeandroid/Cache.java
index c4d93bb5..b4242db9 100644
--- a/src/com/activeandroid/sebbia/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia;
+package com.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -24,12 +24,12 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.support.v4.util.LruCache;
 
-import com.activeandroid.sebbia.annotation.DoNotGenerate;
-import com.activeandroid.sebbia.internal.EmptyModelFiller;
-import com.activeandroid.sebbia.internal.ModelFiller;
-import com.activeandroid.sebbia.serializer.TypeSerializer;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.ReflectionUtils;
+import com.activeandroid.annotation.DoNotGenerate;
+import com.activeandroid.internal.EmptyModelFiller;
+import com.activeandroid.internal.ModelFiller;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
 
 public final class Cache {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/sebbia/Configuration.java b/src/com/activeandroid/Configuration.java
similarity index 98%
rename from src/com/activeandroid/sebbia/Configuration.java
rename to src/com/activeandroid/Configuration.java
index d6b000d1..b197d223 100644
--- a/src/com/activeandroid/sebbia/Configuration.java
+++ b/src/com/activeandroid/Configuration.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia;
+package com.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -22,9 +22,9 @@
 
 import android.content.Context;
 
-import com.activeandroid.sebbia.serializer.TypeSerializer;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.ReflectionUtils;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
 
 public class Configuration {
 
diff --git a/src/com/activeandroid/sebbia/DatabaseHelper.java b/src/com/activeandroid/DatabaseHelper.java
similarity index 95%
rename from src/com/activeandroid/sebbia/DatabaseHelper.java
rename to src/com/activeandroid/DatabaseHelper.java
index 22c65ec0..70a19ddf 100644
--- a/src/com/activeandroid/sebbia/DatabaseHelper.java
+++ b/src/com/activeandroid/DatabaseHelper.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia;
+package com.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -32,12 +32,12 @@
 import android.database.sqlite.SQLiteOpenHelper;
 import android.text.TextUtils;
 
-import com.activeandroid.sebbia.automigration.AutoMigration;
-import com.activeandroid.sebbia.util.IOUtils;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.NaturalOrderComparator;
-import com.activeandroid.sebbia.util.SQLiteUtils;
-import com.activeandroid.sebbia.util.SqlParser;
+import com.activeandroid.automigration.AutoMigration;
+import com.activeandroid.util.IOUtils;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.NaturalOrderComparator;
+import com.activeandroid.util.SQLiteUtils;
+import com.activeandroid.util.SqlParser;
 
 public final class DatabaseHelper extends SQLiteOpenHelper {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/sebbia/Model.java b/src/com/activeandroid/Model.java
similarity index 95%
rename from src/com/activeandroid/sebbia/Model.java
rename to src/com/activeandroid/Model.java
index dfc622a1..5e7f633a 100644
--- a/src/com/activeandroid/sebbia/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia;
+package com.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -26,16 +26,16 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
 
-import com.activeandroid.sebbia.content.ContentProvider;
-import com.activeandroid.sebbia.internal.ModelFiller;
-import com.activeandroid.sebbia.internal.ModelHelper;
-import com.activeandroid.sebbia.model.ManyToManyRelation;
-import com.activeandroid.sebbia.model.OneToManyRelation;
-import com.activeandroid.sebbia.query.Delete;
-import com.activeandroid.sebbia.query.Select;
-import com.activeandroid.sebbia.serializer.TypeSerializer;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.ReflectionUtils;
+import com.activeandroid.content.ContentProvider;
+import com.activeandroid.internal.ModelFiller;
+import com.activeandroid.internal.ModelHelper;
+import com.activeandroid.model.ManyToManyRelation;
+import com.activeandroid.model.OneToManyRelation;
+import com.activeandroid.query.Delete;
+import com.activeandroid.query.Select;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
 
 @SuppressWarnings("unchecked")
 public abstract class Model {
diff --git a/src/com/activeandroid/sebbia/ModelInfo.java b/src/com/activeandroid/ModelInfo.java
similarity index 89%
rename from src/com/activeandroid/sebbia/ModelInfo.java
rename to src/com/activeandroid/ModelInfo.java
index 85e2d921..3fc7e361 100644
--- a/src/com/activeandroid/sebbia/ModelInfo.java
+++ b/src/com/activeandroid/ModelInfo.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia;
+package com.activeandroid;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,30 +16,24 @@
  * limitations under the License.
  */
 
-import com.activeandroid.sebbia.util.MultiDexHelper;
+import com.activeandroid.util.MultiDexHelper;
 import java.io.File;
-import java.io.IOException;
 import java.lang.reflect.Modifier;
-import java.net.URL;
-import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
-import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import android.content.Context;
 
-import com.activeandroid.sebbia.serializer.CalendarSerializer;
-import com.activeandroid.sebbia.serializer.FileSerializer;
-import com.activeandroid.sebbia.serializer.SqlDateSerializer;
-import com.activeandroid.sebbia.serializer.TypeSerializer;
-import com.activeandroid.sebbia.serializer.UtilDateSerializer;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.ReflectionUtils;
-
-import dalvik.system.DexFile;
+import com.activeandroid.serializer.CalendarSerializer;
+import com.activeandroid.serializer.FileSerializer;
+import com.activeandroid.serializer.SqlDateSerializer;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.serializer.UtilDateSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
 
 final class ModelInfo {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/sebbia/TableInfo.java b/src/com/activeandroid/TableInfo.java
similarity index 91%
rename from src/com/activeandroid/sebbia/TableInfo.java
rename to src/com/activeandroid/TableInfo.java
index 0274b35c..e1241c1f 100644
--- a/src/com/activeandroid/sebbia/TableInfo.java
+++ b/src/com/activeandroid/TableInfo.java
@@ -1,170 +1,170 @@
-package com.activeandroid.sebbia;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.reflect.Field;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-import android.text.TextUtils;
-
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.ReflectionUtils;
-import com.activeandroid.sebbia.util.SQLiteUtils;
-
-public final class TableInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Class<? extends Model> mType;
-	private String mTableName;
-	private String mIdName = Table.DEFAULT_ID_NAME;
-
-	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
-	
-	private SQLiteStatement mInsertStatement;
-	private SQLiteStatement mInsertOrReplaceStatement;
-	private SQLiteStatement mUpdateStatement;
-	
-	private Map<String, Integer> mColumnIndexes;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public TableInfo(Class<? extends Model> type) {
-		mType = type;
-
-		final Table tableAnnotation = type.getAnnotation(Table.class);
-
-        if (tableAnnotation != null) {
-			mTableName = tableAnnotation.name();
-			mIdName = tableAnnotation.id();
-		}
-		else {
-			mTableName = type.getSimpleName();
-        }
-
-        // Manually add the id column since it is not declared like the other columns.
-        Field idField = getIdField(type);
-        mColumnNames.put(idField, mIdName);
-
-        List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
-        Collections.reverse(fields);
-
-        for (Field field : fields) {
-            if (field.isAnnotationPresent(Column.class)) {
-                final Column columnAnnotation = field.getAnnotation(Column.class);
-                String columnName = columnAnnotation.name();
-                if (TextUtils.isEmpty(columnName)) {
-                    columnName = field.getName();
-                }
-
-                mColumnNames.put(field, columnName);
-            }
-        }
-        
-        mColumnIndexes = new HashMap<String, Integer>(mColumnNames.size());
-        int index = 1;
-        for (String column : mColumnNames.values()) {
-        	mColumnIndexes.put(column, index++);
-        }
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Class<? extends Model> getType() {
-		return mType;
-	}
-
-	public String getTableName() {
-		return mTableName;
-	}
-
-	public String getIdName() {
-		return mIdName;
-	}
-
-	public Collection<Field> getFields() {
-		return mColumnNames.keySet();
-	}
-	
-	public Collection<String> getColumnNames() {
-		return mColumnNames.values();
-	}
-
-	public String getColumnName(Field field) {
-		return mColumnNames.get(field);
-	}
-	
-	public SQLiteStatement getInsertStatement() {
-		if (mInsertStatement == null) {
-			SQLiteDatabase db = Cache.openDatabase(); 
-			mInsertStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT INTO ", this));
-		}
-		return mInsertStatement;
-	}
-	
-	public SQLiteStatement getUpdateStatement() {
-		if (mUpdateStatement == null) {
-			SQLiteDatabase db = Cache.openDatabase(); 
-			mUpdateStatement = db.compileStatement(SQLiteUtils.createUpdateStatement(this));
-		}
-		return mUpdateStatement;
-	}
-	
-	public SQLiteStatement getInsertOrReplaceStatement() {
-		if (mInsertOrReplaceStatement == null) {
-			SQLiteDatabase db = Cache.openDatabase(); 
-			mInsertOrReplaceStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT OR REPLACE INTO ", this));
-		}
-		return mInsertOrReplaceStatement;
-	}
-	
-    private Field getIdField(Class<?> type) {
-        if (type.equals(Model.class)) {
-            try {
-                return type.getDeclaredField("mId");
-            }
-            catch (NoSuchFieldException e) {
-                Log.e("Impossible!", e.toString());
-            }
-        }
-        else if (type.getSuperclass() != null) {
-            return getIdField(type.getSuperclass());
-        }
-
-        return null;
-    }
-    
-    public Map<String, Integer> getColumnIndexes() {
-		return mColumnIndexes;
-	}
-
-}
+package com.activeandroid;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Field;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+import android.text.TextUtils;
+
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
+import com.activeandroid.util.SQLiteUtils;
+
+public final class TableInfo {
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE MEMBERS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private Class<? extends Model> mType;
+	private String mTableName;
+	private String mIdName = Table.DEFAULT_ID_NAME;
+
+	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
+	
+	private SQLiteStatement mInsertStatement;
+	private SQLiteStatement mInsertOrReplaceStatement;
+	private SQLiteStatement mUpdateStatement;
+	
+	private Map<String, Integer> mColumnIndexes;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// CONSTRUCTORS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public TableInfo(Class<? extends Model> type) {
+		mType = type;
+
+		final Table tableAnnotation = type.getAnnotation(Table.class);
+
+        if (tableAnnotation != null) {
+			mTableName = tableAnnotation.name();
+			mIdName = tableAnnotation.id();
+		}
+		else {
+			mTableName = type.getSimpleName();
+        }
+
+        // Manually add the id column since it is not declared like the other columns.
+        Field idField = getIdField(type);
+        mColumnNames.put(idField, mIdName);
+
+        List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
+        Collections.reverse(fields);
+
+        for (Field field : fields) {
+            if (field.isAnnotationPresent(Column.class)) {
+                final Column columnAnnotation = field.getAnnotation(Column.class);
+                String columnName = columnAnnotation.name();
+                if (TextUtils.isEmpty(columnName)) {
+                    columnName = field.getName();
+                }
+
+                mColumnNames.put(field, columnName);
+            }
+        }
+        
+        mColumnIndexes = new HashMap<String, Integer>(mColumnNames.size());
+        int index = 1;
+        for (String column : mColumnNames.values()) {
+        	mColumnIndexes.put(column, index++);
+        }
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public Class<? extends Model> getType() {
+		return mType;
+	}
+
+	public String getTableName() {
+		return mTableName;
+	}
+
+	public String getIdName() {
+		return mIdName;
+	}
+
+	public Collection<Field> getFields() {
+		return mColumnNames.keySet();
+	}
+	
+	public Collection<String> getColumnNames() {
+		return mColumnNames.values();
+	}
+
+	public String getColumnName(Field field) {
+		return mColumnNames.get(field);
+	}
+	
+	public SQLiteStatement getInsertStatement() {
+		if (mInsertStatement == null) {
+			SQLiteDatabase db = Cache.openDatabase(); 
+			mInsertStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT INTO ", this));
+		}
+		return mInsertStatement;
+	}
+	
+	public SQLiteStatement getUpdateStatement() {
+		if (mUpdateStatement == null) {
+			SQLiteDatabase db = Cache.openDatabase(); 
+			mUpdateStatement = db.compileStatement(SQLiteUtils.createUpdateStatement(this));
+		}
+		return mUpdateStatement;
+	}
+	
+	public SQLiteStatement getInsertOrReplaceStatement() {
+		if (mInsertOrReplaceStatement == null) {
+			SQLiteDatabase db = Cache.openDatabase(); 
+			mInsertOrReplaceStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT OR REPLACE INTO ", this));
+		}
+		return mInsertOrReplaceStatement;
+	}
+	
+    private Field getIdField(Class<?> type) {
+        if (type.equals(Model.class)) {
+            try {
+                return type.getDeclaredField("mId");
+            }
+            catch (NoSuchFieldException e) {
+                Log.e("Impossible!", e.toString());
+            }
+        }
+        else if (type.getSuperclass() != null) {
+            return getIdField(type.getSuperclass());
+        }
+
+        return null;
+    }
+    
+    public Map<String, Integer> getColumnIndexes() {
+		return mColumnIndexes;
+	}
+
+}
diff --git a/src/com/activeandroid/sebbia/annotation/Column.java b/src/com/activeandroid/annotation/Column.java
similarity index 98%
rename from src/com/activeandroid/sebbia/annotation/Column.java
rename to src/com/activeandroid/annotation/Column.java
index 52e46d49..5ecc8d69 100644
--- a/src/com/activeandroid/sebbia/annotation/Column.java
+++ b/src/com/activeandroid/annotation/Column.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.annotation;
+package com.activeandroid.annotation;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java b/src/com/activeandroid/annotation/DoNotGenerate.java
similarity index 85%
rename from src/com/activeandroid/sebbia/annotation/DoNotGenerate.java
rename to src/com/activeandroid/annotation/DoNotGenerate.java
index c97b3fa4..2147105b 100644
--- a/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java
+++ b/src/com/activeandroid/annotation/DoNotGenerate.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.annotation;
+package com.activeandroid.annotation;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
diff --git a/src/com/activeandroid/sebbia/annotation/Table.java b/src/com/activeandroid/annotation/Table.java
similarity index 95%
rename from src/com/activeandroid/sebbia/annotation/Table.java
rename to src/com/activeandroid/annotation/Table.java
index 38b22f8c..541dfbe9 100644
--- a/src/com/activeandroid/sebbia/annotation/Table.java
+++ b/src/com/activeandroid/annotation/Table.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.annotation;
+package com.activeandroid.annotation;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/sebbia/app/Application.java b/src/com/activeandroid/app/Application.java
similarity index 90%
rename from src/com/activeandroid/sebbia/app/Application.java
rename to src/com/activeandroid/app/Application.java
index 6b914f95..311c7c93 100644
--- a/src/com/activeandroid/sebbia/app/Application.java
+++ b/src/com/activeandroid/app/Application.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.app;
+package com.activeandroid.app;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.sebbia.ActiveAndroid;
+import com.activeandroid.ActiveAndroid;
 
 public class Application extends android.app.Application {
 	@Override
diff --git a/src/com/activeandroid/sebbia/automigration/AutoMigration.java b/src/com/activeandroid/automigration/AutoMigration.java
similarity index 95%
rename from src/com/activeandroid/sebbia/automigration/AutoMigration.java
rename to src/com/activeandroid/automigration/AutoMigration.java
index 603aa1f6..b605dc82 100644
--- a/src/com/activeandroid/sebbia/automigration/AutoMigration.java
+++ b/src/com/activeandroid/automigration/AutoMigration.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.automigration;
+package com.activeandroid.automigration;
 
 import java.util.Random;
 
@@ -6,11 +6,11 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.TableInfo;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.SQLiteUtils;
-import com.activeandroid.sebbia.util.SQLiteUtils.SQLiteType;
+import com.activeandroid.Cache;
+import com.activeandroid.TableInfo;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.SQLiteUtils;
+import com.activeandroid.util.SQLiteUtils.SQLiteType;
 
 public class AutoMigration {
 	
diff --git a/src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java b/src/com/activeandroid/automigration/SQLColumnInfo.java
similarity index 91%
rename from src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
rename to src/com/activeandroid/automigration/SQLColumnInfo.java
index 1145ad9c..9f6441b4 100644
--- a/src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
+++ b/src/com/activeandroid/automigration/SQLColumnInfo.java
@@ -1,9 +1,9 @@
-package com.activeandroid.sebbia.automigration;
+package com.activeandroid.automigration;
 
 import java.util.ArrayList;
 import java.util.Locale;
 
-import com.activeandroid.sebbia.util.SQLiteUtils.SQLiteType;
+import com.activeandroid.util.SQLiteUtils.SQLiteType;
 
 import android.text.TextUtils;
 
diff --git a/src/com/activeandroid/sebbia/automigration/SQLTableInfo.java b/src/com/activeandroid/automigration/SQLTableInfo.java
similarity index 97%
rename from src/com/activeandroid/sebbia/automigration/SQLTableInfo.java
rename to src/com/activeandroid/automigration/SQLTableInfo.java
index 63832b60..39fccbac 100644
--- a/src/com/activeandroid/sebbia/automigration/SQLTableInfo.java
+++ b/src/com/activeandroid/automigration/SQLTableInfo.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.automigration;
+package com.activeandroid.automigration;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/src/com/activeandroid/sebbia/automigration/TableDifference.java b/src/com/activeandroid/automigration/TableDifference.java
similarity index 90%
rename from src/com/activeandroid/sebbia/automigration/TableDifference.java
rename to src/com/activeandroid/automigration/TableDifference.java
index aaba59fd..d7356985 100644
--- a/src/com/activeandroid/sebbia/automigration/TableDifference.java
+++ b/src/com/activeandroid/automigration/TableDifference.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.automigration;
+package com.activeandroid.automigration;
 
 import java.lang.reflect.Field;
 import java.util.ArrayList;
@@ -6,9 +6,9 @@
 import java.util.List;
 import java.util.Map;
 
-import com.activeandroid.sebbia.TableInfo;
-import com.activeandroid.sebbia.automigration.AutoMigration.IncompatibleColumnTypesException;
-import com.activeandroid.sebbia.util.SQLiteUtils;
+import com.activeandroid.TableInfo;
+import com.activeandroid.automigration.AutoMigration.IncompatibleColumnTypesException;
+import com.activeandroid.util.SQLiteUtils;
 
 class TableDifference {
 	
diff --git a/src/com/activeandroid/sebbia/content/ContentProvider.java b/src/com/activeandroid/content/ContentProvider.java
similarity index 95%
rename from src/com/activeandroid/sebbia/content/ContentProvider.java
rename to src/com/activeandroid/content/ContentProvider.java
index c49c30d7..b4a841d6 100644
--- a/src/com/activeandroid/sebbia/content/ContentProvider.java
+++ b/src/com/activeandroid/content/ContentProvider.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.content;
+package com.activeandroid.content;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -9,11 +9,11 @@
 import android.net.Uri;
 import android.util.SparseArray;
 
-import com.activeandroid.sebbia.ActiveAndroid;
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Configuration;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Cache;
+import com.activeandroid.Configuration;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
 
 public class ContentProvider extends android.content.ContentProvider {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java b/src/com/activeandroid/internal/AnnotationProcessor.java
similarity index 93%
rename from src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
rename to src/com/activeandroid/internal/AnnotationProcessor.java
index 81969839..f1edba62 100644
--- a/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
+++ b/src/com/activeandroid/internal/AnnotationProcessor.java
@@ -1,423 +1,423 @@
-package com.activeandroid.sebbia.internal;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.tools.Diagnostic.Kind;
-import javax.tools.JavaFileObject;
-
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.DoNotGenerate;
-
-public final class AnnotationProcessor extends AbstractProcessor {
-
-	private static final String MODEL = "model";
-	private static final String CURSOR = "cursor";
-	private static final String CONTENT_VALUES = "contentValues";
-	private static final String COLUMNS_ORDERED = "columnsOrdered";
-	private static final String STATEMENT = "statement";
-	private static final String COLUMNS = "columns";
-
-	private RoundEnvironment env;
-
-	@Override
-	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
-		this.env = env;
-		if (annotations.size() > 0) {
-			parseColumns();
-		}
-		return true;
-	}
-
-	@Override
-	public Set<String> getSupportedAnnotationTypes() {
-		Set<String> supportedTypes = new HashSet<String>();
-		supportedTypes.add(Column.class.getCanonicalName());
-		return supportedTypes;
-	}
-
-	@Override
-	public SourceVersion getSupportedSourceVersion() {
-		return SourceVersion.latestSupported();
-	}
-
-	private void parseColumns() {
-		Set<? extends Element> columns = env.getElementsAnnotatedWith(Column.class);
-		Map<TypeElement, Set<VariableElement>> tables = new HashMap<TypeElement, Set<VariableElement>>();
-		for (Element element : columns) {
-			if (element instanceof VariableElement == false || element.getKind() != ElementKind.FIELD) {
-				error("@Column annotation should be applied only to local variables", element);
-				continue;
-			}
-			VariableElement columnElement = (VariableElement) element;
-
-			TypeElement tableElement = null;
-			if (element.getEnclosingElement() instanceof TypeElement) {
-				tableElement = (TypeElement) element.getEnclosingElement();
-			} else {
-				error("@Column annotation located not inside of class", element);
-				continue;
-			}
-				
-			if (checkTableModifiers(tableElement) == false)
-				continue;
-			
-			if (checkColumnModifiers(columnElement) == false)
-				continue;
-
-			Set<VariableElement> columnsElements = tables.get(tableElement);
-			if (columnsElements == null) {
-				columnsElements = new HashSet<VariableElement>();
-				tables.put(tableElement, columnsElements);
-			}
-
-			columnsElements.add(columnElement);
-
-		}
-
-		for (TypeElement table : tables.keySet()) {
-			generate(table, tables.get(table));
-		}
-	}
-
-	private void generate(TypeElement tableElement, Set<VariableElement> columns) {
-		String packageName = processingEnv.getElementUtils().getPackageOf(tableElement).getQualifiedName().toString();
-		String className = tableElement.getQualifiedName().toString();
-		String fillerClassName = getClassName(tableElement, packageName) + ModelFiller.SUFFIX;
-
-		try {
-			JavaFileObject jfo = processingEnv.getFiler().createSourceFile(packageName + "." + fillerClassName, tableElement);
-			Writer writer = jfo.openWriter();
-			writer.write("//Generated by ActiveAndroid. Do not modify\n");
-			writer.write("package " + packageName + ";\n\n");
-			
-			writer.write("import android.database.sqlite.SQLiteStatement;\n");
-			writer.write("import java.util.ArrayList;\n");
-			writer.write("import java.util.Arrays;\n");
-			writer.write("import java.util.List;\n\n");
-			writer.write("import java.util.Map;\n\n");
-
-			writer.write("import com.activeandroid.sebbia.internal.ModelHelper;\n");
-			writer.write("import com.activeandroid.sebbia.internal.ModelFiller;\n");
-			writer.write("\n");
-			writer.write("public class " + fillerClassName + " extends ModelFiller {\n\n");
-			writer.write("  public void loadFromCursor(com.activeandroid.sebbia.Model genericModel, android.database.Cursor " + CURSOR + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.loadFromCursor(genericModel, " + CURSOR + ");\n");
-			writer.write("    List<String> " + COLUMNS_ORDERED + " = new ArrayList<String>(Arrays.asList(" + CURSOR + ".getColumnNames()));\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getLoadFromCursorCode(columns));
-			writer.write("  }\n\n");
-
-			
-			writer.write("  public void fillContentValues(com.activeandroid.sebbia.Model genericModel, android.content.ContentValues " + CONTENT_VALUES + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.fillContentValues(genericModel, " + CONTENT_VALUES + ");\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getFillContentValuesCode(columns));
-			writer.write("  }\n");
-			
-			writer.write("  public void bindStatement(com.activeandroid.sebbia.Model genericModel, SQLiteStatement " + STATEMENT + ", Map<String, Integer> " + COLUMNS + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.bindStatement(genericModel, " + STATEMENT + ", " + COLUMNS + ");\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getBindStatementCode(columns));
-			writer.write("  }\n");
-
-			writer.write("}");
-			writer.flush();
-			writer.close();
-		} catch (IOException exception) {
-			processingEnv.getMessager().printMessage(Kind.ERROR, exception.getMessage());
-		}
-	}
-
-	private String getLoadFromCursorCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-
-			TypeMirror typeMirror = column.asType();
-			String type = getClassString(typeMirror, typeMirror instanceof DeclaredType);
-			String getColumnIndex = COLUMNS_ORDERED + ".indexOf(\"" + fieldName + "\")";
-
-			String setValue = "    " + MODEL + "." + column.getSimpleName() + " = " + CURSOR;
-
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append("    " + MODEL + "." + column.getSimpleName() + " = (short) " + CURSOR + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append(setValue + ".getLong(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append(setValue + ".getFloat(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append(setValue + ".getDouble(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ") != 0;\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append(setValue + ".getBlob(" + getColumnIndex + ");\n");
-			else {
-				processingEnv.getMessager().printMessage(Kind.NOTE, "Guessing what type is at " + typeMirror.toString(), null);
-				stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
-				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = (" + typeMirror.toString() + ") ModelHelper.getSerializable(cursor, " + type + ", " + getColumnIndex + ");\n");
-				stringBuilder.append("    } else {\n");
-				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = ");
-				if (isTypeOf(typeMirror, Model.class))
-					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getModel(cursor, " + type + ", " + getColumnIndex + ");\n");
-				else if (isTypeOf(typeMirror, Enum.class))
-					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getEnum(cursor, " + type + ", " + getColumnIndex + ");\n");
-				else
-					stringBuilder.append(" null;\n");
-				
-				stringBuilder.append("    }\n");
-			}
-		}
-		return stringBuilder.toString();
-	}
-
-	private String getFillContentValuesCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-			
-			TypeMirror typeMirror = column.asType();
-			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
-			String type = getClassString(typeMirror, notPrimitiveType);
-			String getValue = MODEL + "." + column.getSimpleName();
-			
-			boolean hasDefault = annotation.defaultValue() != null && annotation.defaultValue().isEmpty() == false;
-			String emptySpace = "    ";
-			if (notPrimitiveType) {
-				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
-				emptySpace += "  ";
- 			}
-			String putValue = emptySpace + CONTENT_VALUES + ".put(\"" + fieldName + "\", " + getValue;
-			
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append(putValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append(putValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append(putValue + ");\n");
-			else {
-				stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
-				stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + CONTENT_VALUES + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
-				stringBuilder.append(emptySpace + "} else {\n");
-				stringBuilder.append(emptySpace + "  " + CONTENT_VALUES + ".");
-				if (isTypeOf(typeMirror, Model.class))
-					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".getId());\n");
-				else if (isTypeOf(typeMirror, Enum.class))
-					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".name());\n");
-				else
-					stringBuilder.append("putNull(\"" + fieldName + "\");\n");
-				stringBuilder.append(emptySpace + "}\n");
-			}
-			if (notPrimitiveType) {
-				if (hasDefault == false) {
-					stringBuilder.append("    } else {\n");
-					stringBuilder.append("      " + CONTENT_VALUES + ".putNull(\"" + fieldName +  "\");\n");
-				}
-				stringBuilder.append("    }\n");
-			}
-		}
-		return stringBuilder.toString();
-	}
-	
-	private String getBindStatementCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-			
-			TypeMirror typeMirror = column.asType();
-			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
-			String type = getClassString(typeMirror, notPrimitiveType);
-			
-			String getValue = MODEL + "." + column.getSimpleName();
-			
-			String columnIndex = COLUMNS + ".get(\"" + fieldName + "\")"; 
-			String emptySpace = "    ";
-			
-			if (notPrimitiveType) {
-				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
-				emptySpace += "  ";
- 			}
-			String bind = emptySpace + STATEMENT + ".bind";
-			
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + " ? 1 : 0);\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append(bind + "Blob(" + columnIndex + ", " + getValue + ");\n");
-			else {
-				boolean isModel = isTypeOf(typeMirror, Model.class);
-				boolean isEnum = isTypeOf(typeMirror, Enum.class);
-				if (isModel || isEnum) {
-					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
-					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
-					stringBuilder.append(emptySpace + "} else {\n");
-					stringBuilder.append(emptySpace + "  " + STATEMENT + ".bind");
-					if (isModel)
-						stringBuilder.append("Long(" + columnIndex + ", " + getValue + ".getId());\n");
-					else if (isEnum)
-						stringBuilder.append("String(" + columnIndex + ", " + getValue + ".name());\n");
-					stringBuilder.append(emptySpace + "}\n");
-				} else {
-					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + "))\n");
-					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");
-				}
-			}
-			if (notPrimitiveType)
-				stringBuilder.append("    }\n");
-		}
-		return stringBuilder.toString();
-	}
-
-	private String getClassString(TypeMirror typeMirror, boolean notPrimitiveType) {
-		String type = typeMirror.toString() + ".class";
-		if (notPrimitiveType) {
-			DeclaredType declaredType = (DeclaredType) typeMirror;
-			List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-			if (typeArguments != null && typeArguments.size() > 0)
-				type = ((TypeElement) declaredType.asElement()).getQualifiedName() + ".class";
-		}
-		return type;
-	}
-
-	private boolean isTypeOf(TypeMirror typeMirror, Class<?> type) {
-		if (type.getCanonicalName().equals(typeMirror.toString()))
-			return true;
-
-		if (typeMirror instanceof DeclaredType == false)
-			return false;
-
-		DeclaredType declaredType = (DeclaredType) typeMirror;
-		Element element = declaredType.asElement();
-		if (element instanceof TypeElement == false)
-			return false;
-
-		TypeElement typeElement = (TypeElement) element;
-		if (type == Enum.class)
-			return typeElement.getKind() == ElementKind.ENUM;
-		
-		TypeMirror superType = typeElement.getSuperclass();
-		if (isTypeOf(superType, type))
-			return true;
-		return false;
-	}
-
-	private boolean checkTableModifiers(TypeElement table) {
-		if (table.getModifiers().contains(Modifier.PRIVATE)) {
-			error("Classes marked with @Table cannot be private", table);
-			return false;
-		}
-
-		if (table.getKind() != ElementKind.CLASS) {
-			error("Only classes can be marked with @Table annotation", table);
-			return false;
-		}
-		
-		if (table.getAnnotation(DoNotGenerate.class) != null)
-			return false;
-
-		return true;
-	}
-
-	private boolean checkColumnModifiers(VariableElement column) {
-
-		if (column.getModifiers().contains(Modifier.PRIVATE)) {
-			error("Field marked with @Column cannot be private", column);
-			return false;
-		}
-
-		if (column.getModifiers().contains(Modifier.FINAL)) {
-			error("Field marked with @Column cannot be final", column);
-			return false;
-		}
-
-		if (column.getModifiers().contains(Modifier.STATIC)) {
-			error("Field marked with @Column cannot be static", column);
-			return false;
-		}
-
-		return true;
-	}
-
-	private void error(String message, Element element) {
-		processingEnv.getMessager().printMessage(Kind.ERROR, message, element);
-	}
-
-	private static String getClassName(TypeElement type, String packageName) {
-		int packageLen = packageName.length() + 1;
-		return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
-	}
-}
+package com.activeandroid.internal;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic.Kind;
+import javax.tools.JavaFileObject;
+
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.DoNotGenerate;
+
+public final class AnnotationProcessor extends AbstractProcessor {
+
+	private static final String MODEL = "model";
+	private static final String CURSOR = "cursor";
+	private static final String CONTENT_VALUES = "contentValues";
+	private static final String COLUMNS_ORDERED = "columnsOrdered";
+	private static final String STATEMENT = "statement";
+	private static final String COLUMNS = "columns";
+
+	private RoundEnvironment env;
+
+	@Override
+	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
+		this.env = env;
+		if (annotations.size() > 0) {
+			parseColumns();
+		}
+		return true;
+	}
+
+	@Override
+	public Set<String> getSupportedAnnotationTypes() {
+		Set<String> supportedTypes = new HashSet<String>();
+		supportedTypes.add(Column.class.getCanonicalName());
+		return supportedTypes;
+	}
+
+	@Override
+	public SourceVersion getSupportedSourceVersion() {
+		return SourceVersion.latestSupported();
+	}
+
+	private void parseColumns() {
+		Set<? extends Element> columns = env.getElementsAnnotatedWith(Column.class);
+		Map<TypeElement, Set<VariableElement>> tables = new HashMap<TypeElement, Set<VariableElement>>();
+		for (Element element : columns) {
+			if (element instanceof VariableElement == false || element.getKind() != ElementKind.FIELD) {
+				error("@Column annotation should be applied only to local variables", element);
+				continue;
+			}
+			VariableElement columnElement = (VariableElement) element;
+
+			TypeElement tableElement = null;
+			if (element.getEnclosingElement() instanceof TypeElement) {
+				tableElement = (TypeElement) element.getEnclosingElement();
+			} else {
+				error("@Column annotation located not inside of class", element);
+				continue;
+			}
+				
+			if (checkTableModifiers(tableElement) == false)
+				continue;
+			
+			if (checkColumnModifiers(columnElement) == false)
+				continue;
+
+			Set<VariableElement> columnsElements = tables.get(tableElement);
+			if (columnsElements == null) {
+				columnsElements = new HashSet<VariableElement>();
+				tables.put(tableElement, columnsElements);
+			}
+
+			columnsElements.add(columnElement);
+
+		}
+
+		for (TypeElement table : tables.keySet()) {
+			generate(table, tables.get(table));
+		}
+	}
+
+	private void generate(TypeElement tableElement, Set<VariableElement> columns) {
+		String packageName = processingEnv.getElementUtils().getPackageOf(tableElement).getQualifiedName().toString();
+		String className = tableElement.getQualifiedName().toString();
+		String fillerClassName = getClassName(tableElement, packageName) + ModelFiller.SUFFIX;
+
+		try {
+			JavaFileObject jfo = processingEnv.getFiler().createSourceFile(packageName + "." + fillerClassName, tableElement);
+			Writer writer = jfo.openWriter();
+			writer.write("//Generated by ActiveAndroid. Do not modify\n");
+			writer.write("package " + packageName + ";\n\n");
+			
+			writer.write("import android.database.sqlite.SQLiteStatement;\n");
+			writer.write("import java.util.ArrayList;\n");
+			writer.write("import java.util.Arrays;\n");
+			writer.write("import java.util.List;\n\n");
+			writer.write("import java.util.Map;\n\n");
+
+			writer.write("import ModelHelper;\n");
+			writer.write("import ModelFiller;\n");
+			writer.write("\n");
+			writer.write("public class " + fillerClassName + " extends ModelFiller {\n\n");
+			writer.write("  public void loadFromCursor(Model genericModel, android.database.Cursor " + CURSOR + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.loadFromCursor(genericModel, " + CURSOR + ");\n");
+			writer.write("    List<String> " + COLUMNS_ORDERED + " = new ArrayList<String>(Arrays.asList(" + CURSOR + ".getColumnNames()));\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getLoadFromCursorCode(columns));
+			writer.write("  }\n\n");
+
+			
+			writer.write("  public void fillContentValues(Model genericModel, android.content.ContentValues " + CONTENT_VALUES + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.fillContentValues(genericModel, " + CONTENT_VALUES + ");\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getFillContentValuesCode(columns));
+			writer.write("  }\n");
+			
+			writer.write("  public void bindStatement(Model genericModel, SQLiteStatement " + STATEMENT + ", Map<String, Integer> " + COLUMNS + ") {\n");
+			writer.write("    if (superModelFiller != null)\n");
+			writer.write("       superModelFiller.bindStatement(genericModel, " + STATEMENT + ", " + COLUMNS + ");\n");
+			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+			writer.write(getBindStatementCode(columns));
+			writer.write("  }\n");
+
+			writer.write("}");
+			writer.flush();
+			writer.close();
+		} catch (IOException exception) {
+			processingEnv.getMessager().printMessage(Kind.ERROR, exception.getMessage());
+		}
+	}
+
+	private String getLoadFromCursorCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+
+			TypeMirror typeMirror = column.asType();
+			String type = getClassString(typeMirror, typeMirror instanceof DeclaredType);
+			String getColumnIndex = COLUMNS_ORDERED + ".indexOf(\"" + fieldName + "\")";
+
+			String setValue = "    " + MODEL + "." + column.getSimpleName() + " = " + CURSOR;
+
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append("    " + MODEL + "." + column.getSimpleName() + " = (short) " + CURSOR + ".getInt(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append(setValue + ".getLong(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append(setValue + ".getFloat(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append(setValue + ".getDouble(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ") != 0;\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append(setValue + ".getBlob(" + getColumnIndex + ");\n");
+			else {
+				processingEnv.getMessager().printMessage(Kind.NOTE, "Guessing what type is at " + typeMirror.toString(), null);
+				stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
+				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = (" + typeMirror.toString() + ") ModelHelper.getSerializable(cursor, " + type + ", " + getColumnIndex + ");\n");
+				stringBuilder.append("    } else {\n");
+				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = ");
+				if (isTypeOf(typeMirror, Model.class))
+					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getModel(cursor, " + type + ", " + getColumnIndex + ");\n");
+				else if (isTypeOf(typeMirror, Enum.class))
+					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getEnum(cursor, " + type + ", " + getColumnIndex + ");\n");
+				else
+					stringBuilder.append(" null;\n");
+				
+				stringBuilder.append("    }\n");
+			}
+		}
+		return stringBuilder.toString();
+	}
+
+	private String getFillContentValuesCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+			
+			TypeMirror typeMirror = column.asType();
+			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
+			String type = getClassString(typeMirror, notPrimitiveType);
+			String getValue = MODEL + "." + column.getSimpleName();
+			
+			boolean hasDefault = annotation.defaultValue() != null && annotation.defaultValue().isEmpty() == false;
+			String emptySpace = "    ";
+			if (notPrimitiveType) {
+				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
+				emptySpace += "  ";
+ 			}
+			String putValue = emptySpace + CONTENT_VALUES + ".put(\"" + fieldName + "\", " + getValue;
+			
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append(putValue + ");\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append(putValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append(putValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append(putValue + ");\n");
+			else {
+				stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
+				stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + CONTENT_VALUES + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
+				stringBuilder.append(emptySpace + "} else {\n");
+				stringBuilder.append(emptySpace + "  " + CONTENT_VALUES + ".");
+				if (isTypeOf(typeMirror, Model.class))
+					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".getId());\n");
+				else if (isTypeOf(typeMirror, Enum.class))
+					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".name());\n");
+				else
+					stringBuilder.append("putNull(\"" + fieldName + "\");\n");
+				stringBuilder.append(emptySpace + "}\n");
+			}
+			if (notPrimitiveType) {
+				if (hasDefault == false) {
+					stringBuilder.append("    } else {\n");
+					stringBuilder.append("      " + CONTENT_VALUES + ".putNull(\"" + fieldName +  "\");\n");
+				}
+				stringBuilder.append("    }\n");
+			}
+		}
+		return stringBuilder.toString();
+	}
+	
+	private String getBindStatementCode(Set<VariableElement> columns) {
+		StringBuilder stringBuilder = new StringBuilder();
+
+		for (VariableElement column : columns) {
+			Column annotation = column.getAnnotation(Column.class);
+
+			String fieldName = annotation.name();
+
+			if (fieldName == null || fieldName.isEmpty())
+				fieldName = column.getSimpleName().toString();
+			
+			TypeMirror typeMirror = column.asType();
+			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
+			String type = getClassString(typeMirror, notPrimitiveType);
+			
+			String getValue = MODEL + "." + column.getSimpleName();
+			
+			String columnIndex = COLUMNS + ".get(\"" + fieldName + "\")"; 
+			String emptySpace = "    ";
+			
+			if (notPrimitiveType) {
+				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
+				emptySpace += "  ";
+ 			}
+			String bind = emptySpace + STATEMENT + ".bind";
+			
+			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
+			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + " ? 1 : 0);\n");
+			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, String.class))
+				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
+			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+				stringBuilder.append(bind + "Blob(" + columnIndex + ", " + getValue + ");\n");
+			else {
+				boolean isModel = isTypeOf(typeMirror, Model.class);
+				boolean isEnum = isTypeOf(typeMirror, Enum.class);
+				if (isModel || isEnum) {
+					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
+					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
+					stringBuilder.append(emptySpace + "} else {\n");
+					stringBuilder.append(emptySpace + "  " + STATEMENT + ".bind");
+					if (isModel)
+						stringBuilder.append("Long(" + columnIndex + ", " + getValue + ".getId());\n");
+					else if (isEnum)
+						stringBuilder.append("String(" + columnIndex + ", " + getValue + ".name());\n");
+					stringBuilder.append(emptySpace + "}\n");
+				} else {
+					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + "))\n");
+					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");
+				}
+			}
+			if (notPrimitiveType)
+				stringBuilder.append("    }\n");
+		}
+		return stringBuilder.toString();
+	}
+
+	private String getClassString(TypeMirror typeMirror, boolean notPrimitiveType) {
+		String type = typeMirror.toString() + ".class";
+		if (notPrimitiveType) {
+			DeclaredType declaredType = (DeclaredType) typeMirror;
+			List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+			if (typeArguments != null && typeArguments.size() > 0)
+				type = ((TypeElement) declaredType.asElement()).getQualifiedName() + ".class";
+		}
+		return type;
+	}
+
+	private boolean isTypeOf(TypeMirror typeMirror, Class<?> type) {
+		if (type.getCanonicalName().equals(typeMirror.toString()))
+			return true;
+
+		if (typeMirror instanceof DeclaredType == false)
+			return false;
+
+		DeclaredType declaredType = (DeclaredType) typeMirror;
+		Element element = declaredType.asElement();
+		if (element instanceof TypeElement == false)
+			return false;
+
+		TypeElement typeElement = (TypeElement) element;
+		if (type == Enum.class)
+			return typeElement.getKind() == ElementKind.ENUM;
+		
+		TypeMirror superType = typeElement.getSuperclass();
+		if (isTypeOf(superType, type))
+			return true;
+		return false;
+	}
+
+	private boolean checkTableModifiers(TypeElement table) {
+		if (table.getModifiers().contains(Modifier.PRIVATE)) {
+			error("Classes marked with @Table cannot be private", table);
+			return false;
+		}
+
+		if (table.getKind() != ElementKind.CLASS) {
+			error("Only classes can be marked with @Table annotation", table);
+			return false;
+		}
+		
+		if (table.getAnnotation(DoNotGenerate.class) != null)
+			return false;
+
+		return true;
+	}
+
+	private boolean checkColumnModifiers(VariableElement column) {
+
+		if (column.getModifiers().contains(Modifier.PRIVATE)) {
+			error("Field marked with @Column cannot be private", column);
+			return false;
+		}
+
+		if (column.getModifiers().contains(Modifier.FINAL)) {
+			error("Field marked with @Column cannot be final", column);
+			return false;
+		}
+
+		if (column.getModifiers().contains(Modifier.STATIC)) {
+			error("Field marked with @Column cannot be static", column);
+			return false;
+		}
+
+		return true;
+	}
+
+	private void error(String message, Element element) {
+		processingEnv.getMessager().printMessage(Kind.ERROR, message, element);
+	}
+
+	private static String getClassName(TypeElement type, String packageName) {
+		int packageLen = packageName.length() + 1;
+		return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
+	}
+}
diff --git a/src/com/activeandroid/sebbia/internal/EmptyModelFiller.java b/src/com/activeandroid/internal/EmptyModelFiller.java
similarity index 90%
rename from src/com/activeandroid/sebbia/internal/EmptyModelFiller.java
rename to src/com/activeandroid/internal/EmptyModelFiller.java
index 695ac5a1..ae40b0e2 100644
--- a/src/com/activeandroid/sebbia/internal/EmptyModelFiller.java
+++ b/src/com/activeandroid/internal/EmptyModelFiller.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.internal;
+package com.activeandroid.internal;
 
 import java.util.Map;
 
@@ -6,7 +6,7 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteStatement;
 
-import com.activeandroid.sebbia.Model;
+import com.activeandroid.Model;
 
 public class EmptyModelFiller extends ModelFiller {
 
diff --git a/src/com/activeandroid/sebbia/internal/ModelFiller.java b/src/com/activeandroid/internal/ModelFiller.java
similarity index 86%
rename from src/com/activeandroid/sebbia/internal/ModelFiller.java
rename to src/com/activeandroid/internal/ModelFiller.java
index dd8af96b..f68cb8e3 100644
--- a/src/com/activeandroid/sebbia/internal/ModelFiller.java
+++ b/src/com/activeandroid/internal/ModelFiller.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.internal;
+package com.activeandroid.internal;
 
 import java.util.Map;
 
@@ -6,7 +6,7 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteStatement;
 
-import com.activeandroid.sebbia.Model;
+import com.activeandroid.Model;
 
 public abstract class ModelFiller {
 	public static final String SUFFIX = "$$ActiveAndroidModelFiller";
diff --git a/src/com/activeandroid/sebbia/internal/ModelHelper.java b/src/com/activeandroid/internal/ModelHelper.java
similarity index 96%
rename from src/com/activeandroid/sebbia/internal/ModelHelper.java
rename to src/com/activeandroid/internal/ModelHelper.java
index d6a719e6..7944c4ec 100644
--- a/src/com/activeandroid/sebbia/internal/ModelHelper.java
+++ b/src/com/activeandroid/internal/ModelHelper.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.internal;
+package com.activeandroid.internal;
 
 import java.util.Map;
 
@@ -7,12 +7,12 @@
 import android.database.sqlite.SQLiteStatement;
 import android.text.TextUtils;
 
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.query.Select;
-import com.activeandroid.sebbia.serializer.TypeSerializer;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.ReflectionUtils;
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.query.Select;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
 
 public class ModelHelper {
 	
diff --git a/src/com/activeandroid/sebbia/model/ManyToManyRelation.java b/src/com/activeandroid/model/ManyToManyRelation.java
similarity index 93%
rename from src/com/activeandroid/sebbia/model/ManyToManyRelation.java
rename to src/com/activeandroid/model/ManyToManyRelation.java
index 469192bb..8bada177 100644
--- a/src/com/activeandroid/sebbia/model/ManyToManyRelation.java
+++ b/src/com/activeandroid/model/ManyToManyRelation.java
@@ -1,16 +1,16 @@
-package com.activeandroid.sebbia.model;
+package com.activeandroid.model;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.TableInfo;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.DoNotGenerate;
-import com.activeandroid.sebbia.query.Delete;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.SQLiteUtils;
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.DoNotGenerate;
+import com.activeandroid.query.Delete;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.SQLiteUtils;
 
 @DoNotGenerate
 public abstract class ManyToManyRelation<T1 extends Model, T2 extends Model> extends Model {
diff --git a/src/com/activeandroid/sebbia/model/OneToManyRelation.java b/src/com/activeandroid/model/OneToManyRelation.java
similarity index 87%
rename from src/com/activeandroid/sebbia/model/OneToManyRelation.java
rename to src/com/activeandroid/model/OneToManyRelation.java
index 79bd2367..0899706b 100644
--- a/src/com/activeandroid/sebbia/model/OneToManyRelation.java
+++ b/src/com/activeandroid/model/OneToManyRelation.java
@@ -1,17 +1,17 @@
-package com.activeandroid.sebbia.model;
+package com.activeandroid.model;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import android.database.Cursor;
 
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.TableInfo;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.DoNotGenerate;
-import com.activeandroid.sebbia.query.Delete;
-import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.DoNotGenerate;
+import com.activeandroid.query.Delete;
+import com.activeandroid.util.Log;
 
 @DoNotGenerate
 public abstract class OneToManyRelation<T1 extends Model, T2 extends Model> extends Model {
diff --git a/src/com/activeandroid/sebbia/query/Delete.java b/src/com/activeandroid/query/Delete.java
similarity index 91%
rename from src/com/activeandroid/sebbia/query/Delete.java
rename to src/com/activeandroid/query/Delete.java
index 61fe2336..6d19dced 100644
--- a/src/com/activeandroid/sebbia/query/Delete.java
+++ b/src/com/activeandroid/query/Delete.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.query;
+package com.activeandroid.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.sebbia.Model;
+import com.activeandroid.Model;
 
 public final class Delete implements Sqlable {
 	public Delete() {
diff --git a/src/com/activeandroid/sebbia/query/From.java b/src/com/activeandroid/query/From.java
similarity index 96%
rename from src/com/activeandroid/sebbia/query/From.java
rename to src/com/activeandroid/query/From.java
index 80289f65..ab3837a9 100644
--- a/src/com/activeandroid/sebbia/query/From.java
+++ b/src/com/activeandroid/query/From.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.query;
+package com.activeandroid.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -18,12 +18,12 @@
 
 import android.text.TextUtils;
 
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.content.ContentProvider;
-import com.activeandroid.sebbia.query.Join.JoinType;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.SQLiteUtils;
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.content.ContentProvider;
+import com.activeandroid.query.Join.JoinType;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.SQLiteUtils;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/src/com/activeandroid/sebbia/query/Join.java b/src/com/activeandroid/query/Join.java
similarity index 94%
rename from src/com/activeandroid/sebbia/query/Join.java
rename to src/com/activeandroid/query/Join.java
index c818616a..13cdba3b 100644
--- a/src/com/activeandroid/sebbia/query/Join.java
+++ b/src/com/activeandroid/query/Join.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.query;
+package com.activeandroid.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -18,8 +18,8 @@
 
 import android.text.TextUtils;
 
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
 
 public final class Join implements Sqlable {
 	static enum JoinType {
diff --git a/src/com/activeandroid/sebbia/query/Select.java b/src/com/activeandroid/query/Select.java
similarity index 95%
rename from src/com/activeandroid/sebbia/query/Select.java
rename to src/com/activeandroid/query/Select.java
index 43e216e1..1d4c6488 100644
--- a/src/com/activeandroid/sebbia/query/Select.java
+++ b/src/com/activeandroid/query/Select.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.query;
+package com.activeandroid.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -18,7 +18,7 @@
 
 import android.text.TextUtils;
 
-import com.activeandroid.sebbia.Model;
+import com.activeandroid.Model;
 
 public final class Select implements Sqlable {
 	private String[] mColumns;
diff --git a/src/com/activeandroid/sebbia/query/Set.java b/src/com/activeandroid/query/Set.java
similarity index 96%
rename from src/com/activeandroid/sebbia/query/Set.java
rename to src/com/activeandroid/query/Set.java
index 6c865f56..183d99f0 100644
--- a/src/com/activeandroid/sebbia/query/Set.java
+++ b/src/com/activeandroid/query/Set.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.query;
+package com.activeandroid.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.sebbia.util.SQLiteUtils;
+import com.activeandroid.util.SQLiteUtils;
 
 import java.util.ArrayList;
 import java.util.Arrays;
diff --git a/src/com/activeandroid/sebbia/query/Sqlable.java b/src/com/activeandroid/query/Sqlable.java
similarity index 94%
rename from src/com/activeandroid/sebbia/query/Sqlable.java
rename to src/com/activeandroid/query/Sqlable.java
index 64c4cff5..2c3f5d43 100644
--- a/src/com/activeandroid/sebbia/query/Sqlable.java
+++ b/src/com/activeandroid/query/Sqlable.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.query;
+package com.activeandroid.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/sebbia/query/Update.java b/src/com/activeandroid/query/Update.java
similarity index 90%
rename from src/com/activeandroid/sebbia/query/Update.java
rename to src/com/activeandroid/query/Update.java
index 8eb2932a..a69d2d8e 100644
--- a/src/com/activeandroid/sebbia/query/Update.java
+++ b/src/com/activeandroid/query/Update.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.query;
+package com.activeandroid.query;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -16,8 +16,8 @@
  * limitations under the License.
  */
 
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
 
 public final class Update implements Sqlable {
 	private Class<? extends Model> mType;
diff --git a/src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java b/src/com/activeandroid/serializer/BigDecimalSerializer.java
similarity index 91%
rename from src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
rename to src/com/activeandroid/serializer/BigDecimalSerializer.java
index 1b398742..333f900f 100644
--- a/src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
+++ b/src/com/activeandroid/serializer/BigDecimalSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.serializer;
+package com.activeandroid.serializer;
 
 import java.math.BigDecimal;
 
diff --git a/src/com/activeandroid/sebbia/serializer/CalendarSerializer.java b/src/com/activeandroid/serializer/CalendarSerializer.java
similarity index 95%
rename from src/com/activeandroid/sebbia/serializer/CalendarSerializer.java
rename to src/com/activeandroid/serializer/CalendarSerializer.java
index 6cd2068e..55509bd0 100644
--- a/src/com/activeandroid/sebbia/serializer/CalendarSerializer.java
+++ b/src/com/activeandroid/serializer/CalendarSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.serializer;
+package com.activeandroid.serializer;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/sebbia/serializer/FileSerializer.java b/src/com/activeandroid/serializer/FileSerializer.java
similarity index 95%
rename from src/com/activeandroid/sebbia/serializer/FileSerializer.java
rename to src/com/activeandroid/serializer/FileSerializer.java
index 0d15a76d..0aed072c 100644
--- a/src/com/activeandroid/sebbia/serializer/FileSerializer.java
+++ b/src/com/activeandroid/serializer/FileSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.serializer;
+package com.activeandroid.serializer;
 
 import java.io.File;
 
diff --git a/src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java b/src/com/activeandroid/serializer/SqlDateSerializer.java
similarity index 95%
rename from src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
rename to src/com/activeandroid/serializer/SqlDateSerializer.java
index ad6a995b..530d1249 100644
--- a/src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
+++ b/src/com/activeandroid/serializer/SqlDateSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.serializer;
+package com.activeandroid.serializer;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/sebbia/serializer/TypeSerializer.java b/src/com/activeandroid/serializer/TypeSerializer.java
similarity index 94%
rename from src/com/activeandroid/sebbia/serializer/TypeSerializer.java
rename to src/com/activeandroid/serializer/TypeSerializer.java
index eb326146..af0a21de 100644
--- a/src/com/activeandroid/sebbia/serializer/TypeSerializer.java
+++ b/src/com/activeandroid/serializer/TypeSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.serializer;
+package com.activeandroid.serializer;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/sebbia/serializer/UUIDSerializer.java b/src/com/activeandroid/serializer/UUIDSerializer.java
similarity index 90%
rename from src/com/activeandroid/sebbia/serializer/UUIDSerializer.java
rename to src/com/activeandroid/serializer/UUIDSerializer.java
index 2942c130..94ba37ff 100644
--- a/src/com/activeandroid/sebbia/serializer/UUIDSerializer.java
+++ b/src/com/activeandroid/serializer/UUIDSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.serializer;
+package com.activeandroid.serializer;
 
 import java.util.UUID;
 
diff --git a/src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java b/src/com/activeandroid/serializer/UtilDateSerializer.java
similarity index 95%
rename from src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
rename to src/com/activeandroid/serializer/UtilDateSerializer.java
index cf3a1423..a82c7ef1 100644
--- a/src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
+++ b/src/com/activeandroid/serializer/UtilDateSerializer.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.serializer;
+package com.activeandroid.serializer;
 
 /*
  * Copyright (C) 2010 Michael Pardo
diff --git a/src/com/activeandroid/sebbia/util/IOUtils.java b/src/com/activeandroid/util/IOUtils.java
similarity index 95%
rename from src/com/activeandroid/sebbia/util/IOUtils.java
rename to src/com/activeandroid/util/IOUtils.java
index d4b059b8..aaed558b 100644
--- a/src/com/activeandroid/sebbia/util/IOUtils.java
+++ b/src/com/activeandroid/util/IOUtils.java
@@ -1,5 +1,5 @@
 
-package com.activeandroid.sebbia.util;
+package com.activeandroid.util;
 
 /*
  * Copyright (C) 2014 Markus Pfeiffer
@@ -22,9 +22,6 @@
 import java.io.Closeable;
 import java.io.IOException;
 
-import com.activeandroid.sebbia.util.Log;
-
-
 public class IOUtils {
 
     /**
diff --git a/src/com/activeandroid/sebbia/util/Log.java b/src/com/activeandroid/util/Log.java
similarity index 94%
rename from src/com/activeandroid/sebbia/util/Log.java
rename to src/com/activeandroid/util/Log.java
index c8f28af6..1c2a384d 100644
--- a/src/com/activeandroid/sebbia/util/Log.java
+++ b/src/com/activeandroid/util/Log.java
@@ -1,196 +1,196 @@
-package com.activeandroid.sebbia.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public final class Log {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static String sTag = "ActiveAndroid";
-	private static boolean sEnabled = false;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Log() {
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-    public static boolean isEnabled() {
-        return sEnabled;
-    }
-
-	public static void setEnabled(boolean enabled) {
-		sEnabled = enabled;
-	}
-
-	public static boolean isLoggingEnabled() {
-		return sEnabled;
-	}
-
-	public static int v(String msg) {
-		if (sEnabled) {
-			return android.util.Log.v(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int v(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.v(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int v(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.v(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int v(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.v(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int d(String msg) {
-		if (sEnabled) {
-			return android.util.Log.d(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int d(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.d(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int d(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.d(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int d(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.d(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int i(String msg) {
-		if (sEnabled) {
-			return android.util.Log.i(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int i(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.i(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int i(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.i(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int i(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.i(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int w(String msg) {
-		if (sEnabled) {
-			return android.util.Log.w(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int w(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.w(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int w(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.w(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int w(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.w(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int e(String msg) {
-		if (sEnabled) {
-			return android.util.Log.e(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int e(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.e(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int e(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.e(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int e(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.e(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int t(String msg, Object... args) {
-		if (sEnabled) {
-			return android.util.Log.v("test", String.format(msg, args));
-		}
-		return 0;
-	}
+package com.activeandroid.util;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public final class Log {
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC MEMBERS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private static String sTag = "ActiveAndroid";
+	private static boolean sEnabled = false;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// CONSTRUCTORS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private Log() {
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+    public static boolean isEnabled() {
+        return sEnabled;
+    }
+
+	public static void setEnabled(boolean enabled) {
+		sEnabled = enabled;
+	}
+
+	public static boolean isLoggingEnabled() {
+		return sEnabled;
+	}
+
+	public static int v(String msg) {
+		if (sEnabled) {
+			return android.util.Log.v(sTag, msg);
+		}
+		return 0;
+	}
+
+	public static int v(String tag, String msg) {
+		if (sEnabled) {
+			return android.util.Log.v(tag, msg);
+		}
+		return 0;
+	}
+
+	public static int v(String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.v(sTag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int v(String tag, String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.v(tag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int d(String msg) {
+		if (sEnabled) {
+			return android.util.Log.d(sTag, msg);
+		}
+		return 0;
+	}
+
+	public static int d(String tag, String msg) {
+		if (sEnabled) {
+			return android.util.Log.d(tag, msg);
+		}
+		return 0;
+	}
+
+	public static int d(String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.d(sTag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int d(String tag, String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.d(tag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int i(String msg) {
+		if (sEnabled) {
+			return android.util.Log.i(sTag, msg);
+		}
+		return 0;
+	}
+
+	public static int i(String tag, String msg) {
+		if (sEnabled) {
+			return android.util.Log.i(tag, msg);
+		}
+		return 0;
+	}
+
+	public static int i(String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.i(sTag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int i(String tag, String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.i(tag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int w(String msg) {
+		if (sEnabled) {
+			return android.util.Log.w(sTag, msg);
+		}
+		return 0;
+	}
+
+	public static int w(String tag, String msg) {
+		if (sEnabled) {
+			return android.util.Log.w(tag, msg);
+		}
+		return 0;
+	}
+
+	public static int w(String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.w(sTag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int w(String tag, String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.w(tag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int e(String msg) {
+		if (sEnabled) {
+			return android.util.Log.e(sTag, msg);
+		}
+		return 0;
+	}
+
+	public static int e(String tag, String msg) {
+		if (sEnabled) {
+			return android.util.Log.e(tag, msg);
+		}
+		return 0;
+	}
+
+	public static int e(String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.e(sTag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int e(String tag, String msg, Throwable tr) {
+		if (sEnabled) {
+			return android.util.Log.e(tag, msg, tr);
+		}
+		return 0;
+	}
+
+	public static int t(String msg, Object... args) {
+		if (sEnabled) {
+			return android.util.Log.v("test", String.format(msg, args));
+		}
+		return 0;
+	}
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/util/MultiDexHelper.java b/src/com/activeandroid/util/MultiDexHelper.java
similarity index 98%
rename from src/com/activeandroid/sebbia/util/MultiDexHelper.java
rename to src/com/activeandroid/util/MultiDexHelper.java
index 19958a2f..374970be 100644
--- a/src/com/activeandroid/sebbia/util/MultiDexHelper.java
+++ b/src/com/activeandroid/util/MultiDexHelper.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.util;
+package com.activeandroid.util;
 
 
 import android.content.Context;
diff --git a/src/com/activeandroid/sebbia/util/NaturalOrderComparator.java b/src/com/activeandroid/util/NaturalOrderComparator.java
similarity index 94%
rename from src/com/activeandroid/sebbia/util/NaturalOrderComparator.java
rename to src/com/activeandroid/util/NaturalOrderComparator.java
index 2fa9acf6..b09de26f 100644
--- a/src/com/activeandroid/sebbia/util/NaturalOrderComparator.java
+++ b/src/com/activeandroid/util/NaturalOrderComparator.java
@@ -1,141 +1,141 @@
-package com.activeandroid.sebbia.util;
-
-/*
- NaturalOrderComparator.java -- Perform 'natural order' comparisons of strings in Java.
- Copyright (C) 2003 by Pierre-Luc Paour <natorder@paour.com>
-
- Based on the C version by Martin Pool, of which this is more or less a straight conversion.
- Copyright (C) 2000 by Martin Pool <mbp@humbug.org.au>
-
- This software is provided 'as-is', without any express or implied
- warranty.  In no event will the authors be held liable for any damages
- arising from the use of this software.
-
- Permission is granted to anyone to use this software for any purpose,
- including commercial applications, and to alter it and redistribute it
- freely, subject to the following restrictions:
-
- 1. The origin of this software must not be misrepresented; you must not
- claim that you wrote the original software. If you use this software
- in a product, an acknowledgment in the product documentation would be
- appreciated but is not required.
- 2. Altered source versions must be plainly marked as such, and must not be
- misrepresented as being the original software.
- 3. This notice may not be removed or altered from any source distribution.
- */
-
-import java.util.Comparator;
-
-public class NaturalOrderComparator implements Comparator<Object> {
-	int compareRight(String a, String b) {
-		int bias = 0;
-		int ia = 0;
-		int ib = 0;
-
-		// The longest run of digits wins. That aside, the greatest
-		// value wins, but we can't know that it will until we've scanned
-		// both numbers to know that they have the same magnitude, so we
-		// remember it in BIAS.
-		for (;; ia++, ib++) {
-			char ca = charAt(a, ia);
-			char cb = charAt(b, ib);
-
-			if (!Character.isDigit(ca) && !Character.isDigit(cb)) {
-				return bias;
-			}
-			else if (!Character.isDigit(ca)) {
-				return -1;
-			}
-			else if (!Character.isDigit(cb)) {
-				return +1;
-			}
-			else if (ca < cb) {
-				if (bias == 0) {
-					bias = -1;
-				}
-			}
-			else if (ca > cb) {
-				if (bias == 0)
-					bias = +1;
-			}
-			else if (ca == 0 && cb == 0) {
-				return bias;
-			}
-		}
-	}
-
-	public int compare(Object o1, Object o2) {
-		String a = o1.toString();
-		String b = o2.toString();
-
-		int ia = 0, ib = 0;
-		int nza = 0, nzb = 0;
-		char ca, cb;
-		int result;
-
-		while (true) {
-			// only count the number of zeroes leading the last number compared
-			nza = nzb = 0;
-
-			ca = charAt(a, ia);
-			cb = charAt(b, ib);
-
-			// skip over leading spaces or zeros
-			while (Character.isSpaceChar(ca) || ca == '0') {
-				if (ca == '0') {
-					nza++;
-				}
-				else {
-					// only count consecutive zeroes
-					nza = 0;
-				}
-
-				ca = charAt(a, ++ia);
-			}
-
-			while (Character.isSpaceChar(cb) || cb == '0') {
-				if (cb == '0') {
-					nzb++;
-				}
-				else {
-					// only count consecutive zeroes
-					nzb = 0;
-				}
-
-				cb = charAt(b, ++ib);
-			}
-
-			// process run of digits
-			if (Character.isDigit(ca) && Character.isDigit(cb)) {
-				if ((result = compareRight(a.substring(ia), b.substring(ib))) != 0) {
-					return result;
-				}
-			}
-
-			if (ca == 0 && cb == 0) {
-				// The strings compare the same. Perhaps the caller
-				// will want to call strcmp to break the tie.
-				return nza - nzb;
-			}
-
-			if (ca < cb) {
-				return -1;
-			}
-			else if (ca > cb) {
-				return +1;
-			}
-
-			++ia;
-			++ib;
-		}
-	}
-
-	static char charAt(String s, int i) {
-		if (i >= s.length()) {
-			return 0;
-		}
-		else {
-			return s.charAt(i);
-		}
-	}
+package com.activeandroid.util;
+
+/*
+ NaturalOrderComparator.java -- Perform 'natural order' comparisons of strings in Java.
+ Copyright (C) 2003 by Pierre-Luc Paour <natorder@paour.com>
+
+ Based on the C version by Martin Pool, of which this is more or less a straight conversion.
+ Copyright (C) 2000 by Martin Pool <mbp@humbug.org.au>
+
+ This software is provided 'as-is', without any express or implied
+ warranty.  In no event will the authors be held liable for any damages
+ arising from the use of this software.
+
+ Permission is granted to anyone to use this software for any purpose,
+ including commercial applications, and to alter it and redistribute it
+ freely, subject to the following restrictions:
+
+ 1. The origin of this software must not be misrepresented; you must not
+ claim that you wrote the original software. If you use this software
+ in a product, an acknowledgment in the product documentation would be
+ appreciated but is not required.
+ 2. Altered source versions must be plainly marked as such, and must not be
+ misrepresented as being the original software.
+ 3. This notice may not be removed or altered from any source distribution.
+ */
+
+import java.util.Comparator;
+
+public class NaturalOrderComparator implements Comparator<Object> {
+	int compareRight(String a, String b) {
+		int bias = 0;
+		int ia = 0;
+		int ib = 0;
+
+		// The longest run of digits wins. That aside, the greatest
+		// value wins, but we can't know that it will until we've scanned
+		// both numbers to know that they have the same magnitude, so we
+		// remember it in BIAS.
+		for (;; ia++, ib++) {
+			char ca = charAt(a, ia);
+			char cb = charAt(b, ib);
+
+			if (!Character.isDigit(ca) && !Character.isDigit(cb)) {
+				return bias;
+			}
+			else if (!Character.isDigit(ca)) {
+				return -1;
+			}
+			else if (!Character.isDigit(cb)) {
+				return +1;
+			}
+			else if (ca < cb) {
+				if (bias == 0) {
+					bias = -1;
+				}
+			}
+			else if (ca > cb) {
+				if (bias == 0)
+					bias = +1;
+			}
+			else if (ca == 0 && cb == 0) {
+				return bias;
+			}
+		}
+	}
+
+	public int compare(Object o1, Object o2) {
+		String a = o1.toString();
+		String b = o2.toString();
+
+		int ia = 0, ib = 0;
+		int nza = 0, nzb = 0;
+		char ca, cb;
+		int result;
+
+		while (true) {
+			// only count the number of zeroes leading the last number compared
+			nza = nzb = 0;
+
+			ca = charAt(a, ia);
+			cb = charAt(b, ib);
+
+			// skip over leading spaces or zeros
+			while (Character.isSpaceChar(ca) || ca == '0') {
+				if (ca == '0') {
+					nza++;
+				}
+				else {
+					// only count consecutive zeroes
+					nza = 0;
+				}
+
+				ca = charAt(a, ++ia);
+			}
+
+			while (Character.isSpaceChar(cb) || cb == '0') {
+				if (cb == '0') {
+					nzb++;
+				}
+				else {
+					// only count consecutive zeroes
+					nzb = 0;
+				}
+
+				cb = charAt(b, ++ib);
+			}
+
+			// process run of digits
+			if (Character.isDigit(ca) && Character.isDigit(cb)) {
+				if ((result = compareRight(a.substring(ia), b.substring(ib))) != 0) {
+					return result;
+				}
+			}
+
+			if (ca == 0 && cb == 0) {
+				// The strings compare the same. Perhaps the caller
+				// will want to call strcmp to break the tie.
+				return nza - nzb;
+			}
+
+			if (ca < cb) {
+				return -1;
+			}
+			else if (ca > cb) {
+				return +1;
+			}
+
+			++ia;
+			++ib;
+		}
+	}
+
+	static char charAt(String s, int i) {
+		if (i >= s.length()) {
+			return 0;
+		}
+		else {
+			return s.charAt(i);
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/util/ReflectionUtils.java b/src/com/activeandroid/util/ReflectionUtils.java
similarity index 94%
rename from src/com/activeandroid/sebbia/util/ReflectionUtils.java
rename to src/com/activeandroid/util/ReflectionUtils.java
index 18d64207..a5306856 100644
--- a/src/com/activeandroid/sebbia/util/ReflectionUtils.java
+++ b/src/com/activeandroid/util/ReflectionUtils.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.util;
+package com.activeandroid.util;
 
 /*
  * Copyright (C) 2010 Michael Pardo
@@ -27,9 +27,9 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.serializer.TypeSerializer;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.serializer.TypeSerializer;
 
 public final class ReflectionUtils {
 	//////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/com/activeandroid/sebbia/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
similarity index 94%
rename from src/com/activeandroid/sebbia/util/SQLiteUtils.java
rename to src/com/activeandroid/util/SQLiteUtils.java
index 85570058..0b2e89be 100644
--- a/src/com/activeandroid/sebbia/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -1,488 +1,488 @@
-package com.activeandroid.sebbia.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import android.database.Cursor;
-import android.os.Build;
-import android.text.TextUtils;
-
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.TableInfo;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Column.ConflictAction;
-import com.activeandroid.sebbia.serializer.TypeSerializer;
-
-public final class SQLiteUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// ENUMERATIONS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public enum SQLiteType {
-		INTEGER, REAL, TEXT, BLOB
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONTSANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
-		{
-			put(byte.class, SQLiteType.INTEGER);
-			put(short.class, SQLiteType.INTEGER);
-			put(int.class, SQLiteType.INTEGER);
-			put(long.class, SQLiteType.INTEGER);
-			put(float.class, SQLiteType.REAL);
-			put(double.class, SQLiteType.REAL);
-			put(boolean.class, SQLiteType.INTEGER);
-			put(char.class, SQLiteType.TEXT);
-			put(byte[].class, SQLiteType.BLOB);
-			put(Byte.class, SQLiteType.INTEGER);
-			put(Short.class, SQLiteType.INTEGER);
-			put(Integer.class, SQLiteType.INTEGER);
-			put(Long.class, SQLiteType.INTEGER);
-			put(Float.class, SQLiteType.REAL);
-			put(Double.class, SQLiteType.REAL);
-			put(Boolean.class, SQLiteType.INTEGER);
-			put(Character.class, SQLiteType.TEXT);
-			put(String.class, SQLiteType.TEXT);
-			put(Byte[].class, SQLiteType.BLOB);
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static HashMap<String, List<String>> sIndexGroupMap;
-	private static HashMap<String, List<String>> sUniqueGroupMap;
-	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void execSql(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSql(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-
-	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-		List<T> entities = processCursor(type, cursor);
-		cursor.close();
-
-		return entities;
-	}
-	  
-	public static int intQuery(final String sql, final String[] selectionArgs) {
-        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-        final int number = processIntCursor(cursor);
-        cursor.close();
-
-        return number;
-	}
-
-	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		List<T> entities = rawQuery(type, sql, selectionArgs);
-
-		if (entities.size() > 0) {
-			return entities.get(0);
-		}
-
-		return null;
-	}
-
-	// Database creation
-
-	public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sUniqueGroupMap = new HashMap<String, List<String>>();
-		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
-
-		for (Field field : tableInfo.getFields()) {
-			createUniqueColumnDefinition(tableInfo, field);
-		}
-
-		if (sUniqueGroupMap.isEmpty()) {
-			return definitions;
-		}
-
-		Set<String> keySet = sUniqueGroupMap.keySet();
-		for (String key : keySet) {
-			List<String> group = sUniqueGroupMap.get(key);
-			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
-
-			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
-					TextUtils.join(", ", group), conflictAction.toString()));
-		}
-
-		return definitions;
-	}
-
-	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
-
-        if (field.getName().equals("mId")) {
-            return;
-        }
-
-		String[] groups = column.uniqueGroups();
-		ConflictAction[] conflictActions = column.onUniqueConflicts();
-		if (groups.length != conflictActions.length)
-			return;
-
-		for (int i = 0; i < groups.length; i++) {
-			String group = groups[i];
-			ConflictAction conflictAction = conflictActions[i];
-
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sUniqueGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-			list.add(name);
-
-			sUniqueGroupMap.put(group, list);
-			sOnUniqueConflictsMap.put(group, conflictAction);
-		}
-	}
-
-	public static String[] createIndexDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sIndexGroupMap = new HashMap<String, List<String>>();
-
-		for (Field field : tableInfo.getFields()) {
-			createIndexColumnDefinition(tableInfo, field);
-		}
-
-		if (sIndexGroupMap.isEmpty()) {
-			return new String[0];
-		}
-
-		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
-			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
-					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
-					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
-		}
-
-		return definitions.toArray(new String[definitions.size()]);
-	}
-
-	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
-
-        if (field.getName().equals("mId")) {
-            return;
-        }
-
-		if (column.index()) {
-			List<String> list = new ArrayList<String>();
-			list.add(name);
-			sIndexGroupMap.put(name, list);
-		}
-
-		String[] groups = column.indexGroups();
-		for (String group : groups) {
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sIndexGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-
-			list.add(name);
-			sIndexGroupMap.put(group, list);
-		}
-	}
-
-	public static String createTableDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-
-		for (Field field : tableInfo.getFields()) {
-			String definition = createColumnDefinition(tableInfo, field);
-			if (!TextUtils.isEmpty(definition)) {
-				definitions.add(definition);
-			}
-		}
-
-		definitions.addAll(createUniqueDefinition(tableInfo));
-
-		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
-				TextUtils.join(", ", definitions));
-	}
-
-	@SuppressWarnings("unchecked")
-	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
-		StringBuilder definition = new StringBuilder();
-
-		Class<?> type = field.getType();
-		final String name = tableInfo.getColumnName(field);
-		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-		final Column column = field.getAnnotation(Column.class);
-
-		if (typeSerializer != null) {
-			type = typeSerializer.getSerializedType();
-		}
-		
-		SQLiteType sqLiteType = null;
-		if (TYPE_MAP.containsKey(type)) {
-			sqLiteType = TYPE_MAP.get(type);
-		}
-		else if (ReflectionUtils.isModel(type)) {
-			sqLiteType = SQLiteType.INTEGER;
-		}
-		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
-			sqLiteType = SQLiteType.TEXT;
-		}
-		
-		if (sqLiteType != null) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(sqLiteType.toString());
-		}
-
-		if (!TextUtils.isEmpty(definition)) {
-
-			if (name.equals(tableInfo.getIdName())) {
-				definition.append(" PRIMARY KEY AUTOINCREMENT");
-			}else if(column!=null){
-				if (column.length() > -1) {
-					definition.append("(");
-					definition.append(column.length());
-					definition.append(")");
-				}
-
-				if (column.notNull()) {
-					definition.append(" NOT NULL ON CONFLICT ");
-					definition.append(column.onNullConflict().toString());
-				}
-
-				if (column.unique()) {
-					definition.append(" UNIQUE ON CONFLICT ");
-					definition.append(column.onUniqueConflict().toString());
-				}
-				
-				if (!TextUtils.isEmpty(column.defaultValue())) {
-					String defaultValue = null;
-					switch (sqLiteType) {
-					case TEXT: case BLOB:
-						defaultValue = "\"" + column.defaultValue() + "\"";
-						break;
-
-					case INTEGER:
-						try {
-							if (type.equals(Boolean.class) || type.equals(boolean.class)) {
-								boolean value = Boolean.parseBoolean(column.defaultValue());
-								defaultValue = value ? "1" : "0";
-							} else {
-								Integer.parseInt(column.defaultValue());
-								defaultValue = column.defaultValue();
-							}
-						} catch (NumberFormatException e) {
-							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
-						}
-						break;
-						
-					case REAL:
-						try {
-							Double.parseDouble(column.defaultValue());
-							defaultValue = column.defaultValue();
-						} catch (NumberFormatException e) {
-							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
-						}
-						break;
-					}
-					
-					if (defaultValue != null) {
-						definition.append(" DEFAULT ");
-						definition.append(defaultValue);
-					}
-				}
-			}
-
-			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type) && Cache.getTableInfo((Class<? extends Model>) type) != null) {
-				definition.append(" REFERENCES ");
-				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
-				definition.append("("+tableInfo.getIdName()+")");
-				definition.append(" ON DELETE ");
-				definition.append(column.onDelete().toString().replace("_", " "));
-				definition.append(" ON UPDATE ");
-				definition.append(column.onUpdate().toString().replace("_", " "));
-			}
-		
-		}
-		else {
-			Log.e("No type mapping for: " + type.toString());
-		}
-
-		return definition.toString();
-	}
-
-	@SuppressWarnings("unchecked")
-	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		String idName = tableInfo.getIdName();
-		final List<T> entities = new ArrayList<T>();
-
-		try {
-			Constructor<?> entityConstructor = type.getConstructor();
-
-			if (cursor.moveToFirst()) {
-                /**
-                 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-                 * when the cursor have multiple columns with same name obtained from join tables.
-                 */
-                List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-				do {
-					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
-					if (entity == null) {
-						entity = (T) entityConstructor.newInstance();
-					}
-
-					entity.loadFromCursor(cursor);
-					entities.add((T) entity);
-				}
-				while (cursor.moveToNext());
-			}
-
-		}
-		catch (NoSuchMethodException e) {
-			throw new RuntimeException(
-                "Your model " + type.getName() + " does not define a default " +
-                "constructor. The default constructor is required for " +
-                "now in ActiveAndroid models, as the process to " +
-                "populate the ORM model is : " +
-                "1. instantiate default model " +
-                "2. populate fields"
-            );
-		}
-		catch (Exception e) {
-			Log.e("Failed to process cursor.", e);
-		}
-
-		return entities;
-	}
-
-	private static int processIntCursor(final Cursor cursor) {
-        if (cursor.moveToFirst()) {
-            return cursor.getInt(0);
-	    }
-        return 0;
-    }
-
-	public static List<String> lexSqlScript(String sqlScript) {
-		ArrayList<String> sl = new ArrayList<String>();
-		boolean inString = false, quoteNext = false;
-		StringBuilder b = new StringBuilder(100);
-
-		for (int i = 0; i < sqlScript.length(); i++) {
-			char c = sqlScript.charAt(i);
-
-			if (c == ';' && !inString && !quoteNext) {
-				sl.add(b.toString());
-				b = new StringBuilder(100);
-				inString = false;
-				quoteNext = false;
-				continue;
-			}
-
-			if (c == '\'' && !quoteNext) {
-				inString = !inString;
-			}
-
-			quoteNext = c == '\\' && !quoteNext;
-
-			b.append(c);
-		}
-
-		if (b.length() > 0) {
-			sl.add(b.toString());
-		}
-
-		return sl;
-	}
-	
-	public static String createInsertStatement(String insertInto, TableInfo tableInfo) {
-		StringBuilder stringBuilder = new StringBuilder(insertInto);
-		stringBuilder
-			.append(tableInfo.getTableName())
-			.append(" (");
-			appendColumns(stringBuilder, tableInfo.getColumnNames(), false)
-			.append(") VALUES (");
-		appendPlaceholders(stringBuilder, tableInfo.getFields().size());
-		stringBuilder.append(")");
-		return stringBuilder.toString();
-	}
-	
-	public static String createUpdateStatement(TableInfo tableInfo) {
-		StringBuilder stringBuilder = new StringBuilder("UPDATE ");
-		stringBuilder
-			.append(tableInfo.getTableName())
-			.append(" SET ");
-		appendColumns(stringBuilder, tableInfo.getColumnNames(), true)
-			.append(" WHERE ");
-		appendColumn(stringBuilder, tableInfo.getIdName())
-			.append(" = ?");
-		return stringBuilder.toString();
-	}
-	
-	private static StringBuilder appendColumns(StringBuilder stringBuilder, Collection<String> columns, boolean addEqPlaceholder) {
-		String divider = addEqPlaceholder ? " =?, " : ", ";
-		Iterator<String> iterator = columns.iterator();
-		while (iterator.hasNext())
-			appendColumn(stringBuilder, iterator.next()).append(iterator.hasNext() ? divider : "");
-		return stringBuilder;
-	}
-	
-	private static StringBuilder appendColumn(StringBuilder stringBuilder, String column) {
-		return stringBuilder.append("'").append(column).append("\'");
-	}
-	
-	private static StringBuilder appendPlaceholders(StringBuilder stringBuilder, int count) {
-		for (int i = 0; i < count; ++i)
-			stringBuilder.append("?").append(i == count - 1 ? "" : ", ");
-		return stringBuilder;
-	}
-
-}
+package com.activeandroid.util;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import android.database.Cursor;
+import android.os.Build;
+import android.text.TextUtils;
+
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Column.ConflictAction;
+import com.activeandroid.serializer.TypeSerializer;
+
+public final class SQLiteUtils {
+	//////////////////////////////////////////////////////////////////////////////////////
+	// ENUMERATIONS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public enum SQLiteType {
+		INTEGER, REAL, TEXT, BLOB
+	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC CONSTANTS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE CONTSANTS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	@SuppressWarnings("serial")
+	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
+		{
+			put(byte.class, SQLiteType.INTEGER);
+			put(short.class, SQLiteType.INTEGER);
+			put(int.class, SQLiteType.INTEGER);
+			put(long.class, SQLiteType.INTEGER);
+			put(float.class, SQLiteType.REAL);
+			put(double.class, SQLiteType.REAL);
+			put(boolean.class, SQLiteType.INTEGER);
+			put(char.class, SQLiteType.TEXT);
+			put(byte[].class, SQLiteType.BLOB);
+			put(Byte.class, SQLiteType.INTEGER);
+			put(Short.class, SQLiteType.INTEGER);
+			put(Integer.class, SQLiteType.INTEGER);
+			put(Long.class, SQLiteType.INTEGER);
+			put(Float.class, SQLiteType.REAL);
+			put(Double.class, SQLiteType.REAL);
+			put(Boolean.class, SQLiteType.INTEGER);
+			put(Character.class, SQLiteType.TEXT);
+			put(String.class, SQLiteType.TEXT);
+			put(Byte[].class, SQLiteType.BLOB);
+		}
+	};
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE MEMBERS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private static HashMap<String, List<String>> sIndexGroupMap;
+	private static HashMap<String, List<String>> sUniqueGroupMap;
+	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PUBLIC METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public static void execSql(String sql) {
+		Cache.openDatabase().execSQL(sql);
+	}
+
+	public static void execSql(String sql, Object[] bindArgs) {
+		Cache.openDatabase().execSQL(sql, bindArgs);
+	}
+
+	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
+		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+		List<T> entities = processCursor(type, cursor);
+		cursor.close();
+
+		return entities;
+	}
+	  
+	public static int intQuery(final String sql, final String[] selectionArgs) {
+        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+        final int number = processIntCursor(cursor);
+        cursor.close();
+
+        return number;
+	}
+
+	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
+		List<T> entities = rawQuery(type, sql, selectionArgs);
+
+		if (entities.size() > 0) {
+			return entities.get(0);
+		}
+
+		return null;
+	}
+
+	// Database creation
+
+	public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
+		final ArrayList<String> definitions = new ArrayList<String>();
+		sUniqueGroupMap = new HashMap<String, List<String>>();
+		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
+
+		for (Field field : tableInfo.getFields()) {
+			createUniqueColumnDefinition(tableInfo, field);
+		}
+
+		if (sUniqueGroupMap.isEmpty()) {
+			return definitions;
+		}
+
+		Set<String> keySet = sUniqueGroupMap.keySet();
+		for (String key : keySet) {
+			List<String> group = sUniqueGroupMap.get(key);
+			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
+
+			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
+					TextUtils.join(", ", group), conflictAction.toString()));
+		}
+
+		return definitions;
+	}
+
+	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
+		final String name = tableInfo.getColumnName(field);
+		final Column column = field.getAnnotation(Column.class);
+
+        if (field.getName().equals("mId")) {
+            return;
+        }
+
+		String[] groups = column.uniqueGroups();
+		ConflictAction[] conflictActions = column.onUniqueConflicts();
+		if (groups.length != conflictActions.length)
+			return;
+
+		for (int i = 0; i < groups.length; i++) {
+			String group = groups[i];
+			ConflictAction conflictAction = conflictActions[i];
+
+			if (TextUtils.isEmpty(group))
+				continue;
+
+			List<String> list = sUniqueGroupMap.get(group);
+			if (list == null) {
+				list = new ArrayList<String>();
+			}
+			list.add(name);
+
+			sUniqueGroupMap.put(group, list);
+			sOnUniqueConflictsMap.put(group, conflictAction);
+		}
+	}
+
+	public static String[] createIndexDefinition(TableInfo tableInfo) {
+		final ArrayList<String> definitions = new ArrayList<String>();
+		sIndexGroupMap = new HashMap<String, List<String>>();
+
+		for (Field field : tableInfo.getFields()) {
+			createIndexColumnDefinition(tableInfo, field);
+		}
+
+		if (sIndexGroupMap.isEmpty()) {
+			return new String[0];
+		}
+
+		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
+			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
+					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
+					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
+		}
+
+		return definitions.toArray(new String[definitions.size()]);
+	}
+
+	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
+		final String name = tableInfo.getColumnName(field);
+		final Column column = field.getAnnotation(Column.class);
+
+        if (field.getName().equals("mId")) {
+            return;
+        }
+
+		if (column.index()) {
+			List<String> list = new ArrayList<String>();
+			list.add(name);
+			sIndexGroupMap.put(name, list);
+		}
+
+		String[] groups = column.indexGroups();
+		for (String group : groups) {
+			if (TextUtils.isEmpty(group))
+				continue;
+
+			List<String> list = sIndexGroupMap.get(group);
+			if (list == null) {
+				list = new ArrayList<String>();
+			}
+
+			list.add(name);
+			sIndexGroupMap.put(group, list);
+		}
+	}
+
+	public static String createTableDefinition(TableInfo tableInfo) {
+		final ArrayList<String> definitions = new ArrayList<String>();
+
+		for (Field field : tableInfo.getFields()) {
+			String definition = createColumnDefinition(tableInfo, field);
+			if (!TextUtils.isEmpty(definition)) {
+				definitions.add(definition);
+			}
+		}
+
+		definitions.addAll(createUniqueDefinition(tableInfo));
+
+		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
+				TextUtils.join(", ", definitions));
+	}
+
+	@SuppressWarnings("unchecked")
+	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
+		StringBuilder definition = new StringBuilder();
+
+		Class<?> type = field.getType();
+		final String name = tableInfo.getColumnName(field);
+		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
+		final Column column = field.getAnnotation(Column.class);
+
+		if (typeSerializer != null) {
+			type = typeSerializer.getSerializedType();
+		}
+		
+		SQLiteType sqLiteType = null;
+		if (TYPE_MAP.containsKey(type)) {
+			sqLiteType = TYPE_MAP.get(type);
+		}
+		else if (ReflectionUtils.isModel(type)) {
+			sqLiteType = SQLiteType.INTEGER;
+		}
+		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
+			sqLiteType = SQLiteType.TEXT;
+		}
+		
+		if (sqLiteType != null) {
+			definition.append(name);
+			definition.append(" ");
+			definition.append(sqLiteType.toString());
+		}
+
+		if (!TextUtils.isEmpty(definition)) {
+
+			if (name.equals(tableInfo.getIdName())) {
+				definition.append(" PRIMARY KEY AUTOINCREMENT");
+			}else if(column!=null){
+				if (column.length() > -1) {
+					definition.append("(");
+					definition.append(column.length());
+					definition.append(")");
+				}
+
+				if (column.notNull()) {
+					definition.append(" NOT NULL ON CONFLICT ");
+					definition.append(column.onNullConflict().toString());
+				}
+
+				if (column.unique()) {
+					definition.append(" UNIQUE ON CONFLICT ");
+					definition.append(column.onUniqueConflict().toString());
+				}
+				
+				if (!TextUtils.isEmpty(column.defaultValue())) {
+					String defaultValue = null;
+					switch (sqLiteType) {
+					case TEXT: case BLOB:
+						defaultValue = "\"" + column.defaultValue() + "\"";
+						break;
+
+					case INTEGER:
+						try {
+							if (type.equals(Boolean.class) || type.equals(boolean.class)) {
+								boolean value = Boolean.parseBoolean(column.defaultValue());
+								defaultValue = value ? "1" : "0";
+							} else {
+								Integer.parseInt(column.defaultValue());
+								defaultValue = column.defaultValue();
+							}
+						} catch (NumberFormatException e) {
+							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
+						}
+						break;
+						
+					case REAL:
+						try {
+							Double.parseDouble(column.defaultValue());
+							defaultValue = column.defaultValue();
+						} catch (NumberFormatException e) {
+							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
+						}
+						break;
+					}
+					
+					if (defaultValue != null) {
+						definition.append(" DEFAULT ");
+						definition.append(defaultValue);
+					}
+				}
+			}
+
+			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type) && Cache.getTableInfo((Class<? extends Model>) type) != null) {
+				definition.append(" REFERENCES ");
+				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
+				definition.append("("+tableInfo.getIdName()+")");
+				definition.append(" ON DELETE ");
+				definition.append(column.onDelete().toString().replace("_", " "));
+				definition.append(" ON UPDATE ");
+				definition.append(column.onUpdate().toString().replace("_", " "));
+			}
+		
+		}
+		else {
+			Log.e("No type mapping for: " + type.toString());
+		}
+
+		return definition.toString();
+	}
+
+	@SuppressWarnings("unchecked")
+	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
+		TableInfo tableInfo = Cache.getTableInfo(type);
+		String idName = tableInfo.getIdName();
+		final List<T> entities = new ArrayList<T>();
+
+		try {
+			Constructor<?> entityConstructor = type.getConstructor();
+
+			if (cursor.moveToFirst()) {
+                /**
+                 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+                 * when the cursor have multiple columns with same name obtained from join tables.
+                 */
+                List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+				do {
+					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
+					if (entity == null) {
+						entity = (T) entityConstructor.newInstance();
+					}
+
+					entity.loadFromCursor(cursor);
+					entities.add((T) entity);
+				}
+				while (cursor.moveToNext());
+			}
+
+		}
+		catch (NoSuchMethodException e) {
+			throw new RuntimeException(
+                "Your model " + type.getName() + " does not define a default " +
+                "constructor. The default constructor is required for " +
+                "now in ActiveAndroid models, as the process to " +
+                "populate the ORM model is : " +
+                "1. instantiate default model " +
+                "2. populate fields"
+            );
+		}
+		catch (Exception e) {
+			Log.e("Failed to process cursor.", e);
+		}
+
+		return entities;
+	}
+
+	private static int processIntCursor(final Cursor cursor) {
+        if (cursor.moveToFirst()) {
+            return cursor.getInt(0);
+	    }
+        return 0;
+    }
+
+	public static List<String> lexSqlScript(String sqlScript) {
+		ArrayList<String> sl = new ArrayList<String>();
+		boolean inString = false, quoteNext = false;
+		StringBuilder b = new StringBuilder(100);
+
+		for (int i = 0; i < sqlScript.length(); i++) {
+			char c = sqlScript.charAt(i);
+
+			if (c == ';' && !inString && !quoteNext) {
+				sl.add(b.toString());
+				b = new StringBuilder(100);
+				inString = false;
+				quoteNext = false;
+				continue;
+			}
+
+			if (c == '\'' && !quoteNext) {
+				inString = !inString;
+			}
+
+			quoteNext = c == '\\' && !quoteNext;
+
+			b.append(c);
+		}
+
+		if (b.length() > 0) {
+			sl.add(b.toString());
+		}
+
+		return sl;
+	}
+	
+	public static String createInsertStatement(String insertInto, TableInfo tableInfo) {
+		StringBuilder stringBuilder = new StringBuilder(insertInto);
+		stringBuilder
+			.append(tableInfo.getTableName())
+			.append(" (");
+			appendColumns(stringBuilder, tableInfo.getColumnNames(), false)
+			.append(") VALUES (");
+		appendPlaceholders(stringBuilder, tableInfo.getFields().size());
+		stringBuilder.append(")");
+		return stringBuilder.toString();
+	}
+	
+	public static String createUpdateStatement(TableInfo tableInfo) {
+		StringBuilder stringBuilder = new StringBuilder("UPDATE ");
+		stringBuilder
+			.append(tableInfo.getTableName())
+			.append(" SET ");
+		appendColumns(stringBuilder, tableInfo.getColumnNames(), true)
+			.append(" WHERE ");
+		appendColumn(stringBuilder, tableInfo.getIdName())
+			.append(" = ?");
+		return stringBuilder.toString();
+	}
+	
+	private static StringBuilder appendColumns(StringBuilder stringBuilder, Collection<String> columns, boolean addEqPlaceholder) {
+		String divider = addEqPlaceholder ? " =?, " : ", ";
+		Iterator<String> iterator = columns.iterator();
+		while (iterator.hasNext())
+			appendColumn(stringBuilder, iterator.next()).append(iterator.hasNext() ? divider : "");
+		return stringBuilder;
+	}
+	
+	private static StringBuilder appendColumn(StringBuilder stringBuilder, String column) {
+		return stringBuilder.append("'").append(column).append("\'");
+	}
+	
+	private static StringBuilder appendPlaceholders(StringBuilder stringBuilder, int count) {
+		for (int i = 0; i < count; ++i)
+			stringBuilder.append("?").append(i == count - 1 ? "" : ", ");
+		return stringBuilder;
+	}
+
+}
diff --git a/src/com/activeandroid/sebbia/util/SqlParser.java b/src/com/activeandroid/util/SqlParser.java
similarity index 98%
rename from src/com/activeandroid/sebbia/util/SqlParser.java
rename to src/com/activeandroid/util/SqlParser.java
index f34fce8d..f9531b7c 100644
--- a/src/com/activeandroid/sebbia/util/SqlParser.java
+++ b/src/com/activeandroid/util/SqlParser.java
@@ -1,5 +1,5 @@
 
-package com.activeandroid.sebbia.util;
+package com.activeandroid.util;
 
 /*
  * Copyright (C) 2014 Markus Pfeiffer
diff --git a/src/com/activeandroid/sebbia/util/Tokenizer.java b/src/com/activeandroid/util/Tokenizer.java
similarity index 97%
rename from src/com/activeandroid/sebbia/util/Tokenizer.java
rename to src/com/activeandroid/util/Tokenizer.java
index af52c68f..8ae34da3 100644
--- a/src/com/activeandroid/sebbia/util/Tokenizer.java
+++ b/src/com/activeandroid/util/Tokenizer.java
@@ -1,5 +1,5 @@
 
-package com.activeandroid.sebbia.util;
+package com.activeandroid.util;
 
 /*
  * Copyright (C) 2014 Markus Pfeiffer
diff --git a/src/com/activeandroid/sebbia/widget/ModelAdapter.java b/src/com/activeandroid/widget/ModelAdapter.java
similarity index 94%
rename from src/com/activeandroid/sebbia/widget/ModelAdapter.java
rename to src/com/activeandroid/widget/ModelAdapter.java
index bb8b2b57..a3895763 100644
--- a/src/com/activeandroid/sebbia/widget/ModelAdapter.java
+++ b/src/com/activeandroid/widget/ModelAdapter.java
@@ -1,4 +1,4 @@
-package com.activeandroid.sebbia.widget;
+package com.activeandroid.widget;
 
 import java.util.Collection;
 import java.util.List;
@@ -6,7 +6,7 @@
 import android.content.Context;
 import android.widget.ArrayAdapter;
 
-import com.activeandroid.sebbia.Model;
+import com.activeandroid.Model;
 
 public class ModelAdapter<T extends Model> extends ArrayAdapter<T> {
 	public ModelAdapter(Context context, int textViewResourceId) {
diff --git a/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
index 67358b71..9a72e581 100644
--- a/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -1 +1 @@
-com.activeandroid.sebbia.internal.AnnotationProcessor
\ No newline at end of file
+com.activeandroid.internal.AnnotationProcessor
\ No newline at end of file
diff --git a/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java b/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
index 992b3f75..5b31a2cb 100644
--- a/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
+++ b/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
@@ -18,7 +18,7 @@
 
 import android.test.ApplicationTestCase;
 
-import com.activeandroid.sebbia.app.Application;
+import com.activeandroid.app.Application;
 
 public abstract class ActiveAndroidTestCase extends ApplicationTestCase<Application> {
 	public ActiveAndroidTestCase() {
diff --git a/tests/src/com/activeandroid/test/CacheTest.java b/tests/src/com/activeandroid/test/CacheTest.java
index 7a223633..d2a55a13 100644
--- a/tests/src/com/activeandroid/test/CacheTest.java
+++ b/tests/src/com/activeandroid/test/CacheTest.java
@@ -4,12 +4,12 @@
 
 import android.test.AndroidTestCase;
 
-import com.activeandroid.sebbia.ActiveAndroid;
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Configuration;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.TableInfo;
-import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Cache;
+import com.activeandroid.Configuration;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.annotation.Table;
 
 public class CacheTest extends AndroidTestCase {
 
diff --git a/tests/src/com/activeandroid/test/ConfigurationTest.java b/tests/src/com/activeandroid/test/ConfigurationTest.java
index 3b7d2943..ba34e498 100644
--- a/tests/src/com/activeandroid/test/ConfigurationTest.java
+++ b/tests/src/com/activeandroid/test/ConfigurationTest.java
@@ -5,9 +5,9 @@
 
 import android.test.AndroidTestCase;
 
-import com.activeandroid.sebbia.Configuration;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.Configuration;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Table;
 
 public class ConfigurationTest extends AndroidTestCase {
 
diff --git a/tests/src/com/activeandroid/test/DefaultValueTest.java b/tests/src/com/activeandroid/test/DefaultValueTest.java
index 4a6b5acd..d626b276 100644
--- a/tests/src/com/activeandroid/test/DefaultValueTest.java
+++ b/tests/src/com/activeandroid/test/DefaultValueTest.java
@@ -5,12 +5,12 @@
 import android.app.Application;
 import android.test.ApplicationTestCase;
 
-import com.activeandroid.sebbia.ActiveAndroid;
-import com.activeandroid.sebbia.Configuration;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Configuration;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.query.Select;
 
 public class DefaultValueTest extends ApplicationTestCase<Application> {
 	
diff --git a/tests/src/com/activeandroid/test/MockModel.java b/tests/src/com/activeandroid/test/MockModel.java
index b3c6fb18..8603e64b 100644
--- a/tests/src/com/activeandroid/test/MockModel.java
+++ b/tests/src/com/activeandroid/test/MockModel.java
@@ -18,9 +18,9 @@
 
 import java.util.Date;
 
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
 
 @Table(name = "MockModel")
 public class MockModel extends Model {
diff --git a/tests/src/com/activeandroid/test/ModelTest.java b/tests/src/com/activeandroid/test/ModelTest.java
index 8d3d8cf4..a86ad0b0 100644
--- a/tests/src/com/activeandroid/test/ModelTest.java
+++ b/tests/src/com/activeandroid/test/ModelTest.java
@@ -23,12 +23,12 @@
 import java.util.List;
 import java.util.Set;
 
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.TableInfo;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.query.Select;
 
 /**
  * Simple test now covering equals and hashcode methods.
diff --git a/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java b/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java
index 60d05219..cd1df8fe 100644
--- a/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java
+++ b/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java
@@ -4,11 +4,11 @@
 
 import android.database.Cursor;
 
-import com.activeandroid.sebbia.ActiveAndroid;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.query.Select;
 
 public class AddColumnsTest extends AutoMigrationTest {
 	
diff --git a/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java b/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java
index 2501bc3c..7dd11ca2 100644
--- a/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java
+++ b/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java
@@ -4,11 +4,11 @@
 
 import android.database.Cursor;
 
-import com.activeandroid.sebbia.ActiveAndroid;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.query.Select;
 
 public class AddUniqueNotNullTest extends AutoMigrationTest {
 	
diff --git a/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java b/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java
index 7d1b5bf2..13567656 100644
--- a/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java
+++ b/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java
@@ -5,9 +5,9 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.test.ApplicationTestCase;
 
-import com.activeandroid.sebbia.ActiveAndroid;
-import com.activeandroid.sebbia.Configuration;
-import com.activeandroid.sebbia.Model;
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Configuration;
+import com.activeandroid.Model;
 
 public abstract class AutoMigrationTest extends ApplicationTestCase<Application> {
 
diff --git a/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java b/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java
index 4c6cb22c..14e64775 100644
--- a/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java
+++ b/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java
@@ -1,9 +1,9 @@
 package com.activeandroid.test.automigration;
 
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.automigration.AutoMigration;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.automigration.AutoMigration;
 
 public class ChangeTypeTest extends AutoMigrationTest {
 	
diff --git a/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java b/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java
index 29b47482..2d388d9b 100644
--- a/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java
+++ b/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java
@@ -4,11 +4,11 @@
 
 import android.database.Cursor;
 
-import com.activeandroid.sebbia.ActiveAndroid;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.query.Select;
 
 public class DefaultValueMigrationTest extends AutoMigrationTest {
 	private static final String TABLE = "default_value_migration";
diff --git a/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java b/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java
index 913cbdeb..5537aba0 100644
--- a/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java
+++ b/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java
@@ -1,6 +1,6 @@
 package com.activeandroid.test.automigration;
 
-import com.activeandroid.sebbia.automigration.SQLColumnInfo;
+import com.activeandroid.automigration.SQLColumnInfo;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
 public class SQLColumnInfoTest extends ActiveAndroidTestCase {
diff --git a/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java b/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java
index 2cd5e39f..f863c206 100644
--- a/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java
+++ b/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java
@@ -1,8 +1,8 @@
 package com.activeandroid.test.automigration;
 
-import com.activeandroid.sebbia.automigration.SQLColumnInfo;
-import com.activeandroid.sebbia.automigration.SQLTableInfo;
-import com.activeandroid.sebbia.util.SQLiteUtils.SQLiteType;
+import com.activeandroid.automigration.SQLColumnInfo;
+import com.activeandroid.automigration.SQLTableInfo;
+import com.activeandroid.util.SQLiteUtils.SQLiteType;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
 public class SQLTableInfoTest extends ActiveAndroidTestCase {
diff --git a/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java b/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java
index 1606e86a..3da8eecd 100644
--- a/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java
+++ b/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java
@@ -3,10 +3,10 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.DoNotGenerate;
-import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.DoNotGenerate;
+import com.activeandroid.query.Select;
 
 public class DoNotGenerateTest extends ModelTestCase {
 	
diff --git a/tests/src/com/activeandroid/test/model/EnumTest.java b/tests/src/com/activeandroid/test/model/EnumTest.java
index d253c09d..1c2d89f2 100644
--- a/tests/src/com/activeandroid/test/model/EnumTest.java
+++ b/tests/src/com/activeandroid/test/model/EnumTest.java
@@ -5,13 +5,13 @@
 
 import android.database.Cursor;
 
-import com.activeandroid.sebbia.ActiveAndroid;
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.TableInfo;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.query.Delete;
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.query.Delete;
 
 public class EnumTest extends ModelTestCase {
 
diff --git a/tests/src/com/activeandroid/test/model/ManyToManyTest.java b/tests/src/com/activeandroid/test/model/ManyToManyTest.java
index 1604af47..02f9f7f4 100644
--- a/tests/src/com/activeandroid/test/model/ManyToManyTest.java
+++ b/tests/src/com/activeandroid/test/model/ManyToManyTest.java
@@ -3,8 +3,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.model.ManyToManyRelation;
+import com.activeandroid.Model;
+import com.activeandroid.model.ManyToManyRelation;
 import com.activeandroid.test.MockModel;
 
 public class ManyToManyTest extends ModelTestCase {
diff --git a/tests/src/com/activeandroid/test/model/ModelTestCase.java b/tests/src/com/activeandroid/test/model/ModelTestCase.java
index 11a38cf0..edc478f4 100644
--- a/tests/src/com/activeandroid/test/model/ModelTestCase.java
+++ b/tests/src/com/activeandroid/test/model/ModelTestCase.java
@@ -1,7 +1,7 @@
 package com.activeandroid.test.model;
 
-import com.activeandroid.sebbia.ActiveAndroid;
-import com.activeandroid.sebbia.Configuration;
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Configuration;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
 public class ModelTestCase extends ActiveAndroidTestCase {
diff --git a/tests/src/com/activeandroid/test/model/OneToManyTest.java b/tests/src/com/activeandroid/test/model/OneToManyTest.java
index 9319b13e..4abb9768 100644
--- a/tests/src/com/activeandroid/test/model/OneToManyTest.java
+++ b/tests/src/com/activeandroid/test/model/OneToManyTest.java
@@ -3,8 +3,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.model.OneToManyRelation;
+import com.activeandroid.Model;
+import com.activeandroid.model.OneToManyRelation;
 import com.activeandroid.test.MockModel;
 
 public class OneToManyTest extends ModelTestCase {
diff --git a/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java b/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
index 5f43b2ce..971b8a89 100644
--- a/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
+++ b/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
@@ -4,8 +4,8 @@
 import android.database.SQLException;
 import android.database.sqlite.SQLiteDatabase;
 
-import com.activeandroid.sebbia.Configuration;
-import com.activeandroid.sebbia.DatabaseHelper;
+import com.activeandroid.Configuration;
+import com.activeandroid.DatabaseHelper;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
 
diff --git a/tests/src/com/activeandroid/test/parser/ParserTest.java b/tests/src/com/activeandroid/test/parser/ParserTest.java
index 759e785d..bbfc15bf 100644
--- a/tests/src/com/activeandroid/test/parser/ParserTest.java
+++ b/tests/src/com/activeandroid/test/parser/ParserTest.java
@@ -5,7 +5,7 @@
 import java.io.InputStream;
 import java.util.List;
 
-import com.activeandroid.sebbia.util.SqlParser;
+import com.activeandroid.util.SqlParser;
 import com.activeandroid.test.ActiveAndroidTestCase;
 import com.activeandroid.test.R;
 
diff --git a/tests/src/com/activeandroid/test/query/CountTest.java b/tests/src/com/activeandroid/test/query/CountTest.java
index ba9eea84..5af551aa 100644
--- a/tests/src/com/activeandroid/test/query/CountTest.java
+++ b/tests/src/com/activeandroid/test/query/CountTest.java
@@ -3,9 +3,9 @@
 
 import java.util.List;
 
-import com.activeandroid.sebbia.query.Delete;
-import com.activeandroid.sebbia.query.From;
-import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.query.Delete;
+import com.activeandroid.query.From;
+import com.activeandroid.query.Select;
 import com.activeandroid.test.MockModel;
 
 
diff --git a/tests/src/com/activeandroid/test/query/DeleteTest.java b/tests/src/com/activeandroid/test/query/DeleteTest.java
index f0624ffc..3d9a1d71 100644
--- a/tests/src/com/activeandroid/test/query/DeleteTest.java
+++ b/tests/src/com/activeandroid/test/query/DeleteTest.java
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.sebbia.query.Delete;
+import com.activeandroid.query.Delete;
 import com.activeandroid.test.MockModel;
 
 public class DeleteTest extends SqlableTestCase {
diff --git a/tests/src/com/activeandroid/test/query/ExistsTest.java b/tests/src/com/activeandroid/test/query/ExistsTest.java
index eea3ca02..c387fb94 100644
--- a/tests/src/com/activeandroid/test/query/ExistsTest.java
+++ b/tests/src/com/activeandroid/test/query/ExistsTest.java
@@ -3,9 +3,9 @@
 
 import java.util.List;
 
-import com.activeandroid.sebbia.query.Delete;
-import com.activeandroid.sebbia.query.From;
-import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.query.Delete;
+import com.activeandroid.query.From;
+import com.activeandroid.query.Select;
 import com.activeandroid.test.MockModel;
 
 
diff --git a/tests/src/com/activeandroid/test/query/FromTest.java b/tests/src/com/activeandroid/test/query/FromTest.java
index a712e337..1305dd2b 100644
--- a/tests/src/com/activeandroid/test/query/FromTest.java
+++ b/tests/src/com/activeandroid/test/query/FromTest.java
@@ -16,10 +16,10 @@
  * limitations under the License.
  */
 
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.query.From;
-import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.query.From;
+import com.activeandroid.query.Select;
 import com.activeandroid.test.MockModel;
 
 public class FromTest extends SqlableTestCase {
diff --git a/tests/src/com/activeandroid/test/query/SelectTest.java b/tests/src/com/activeandroid/test/query/SelectTest.java
index c4aca601..73bfe73d 100644
--- a/tests/src/com/activeandroid/test/query/SelectTest.java
+++ b/tests/src/com/activeandroid/test/query/SelectTest.java
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.sebbia.query.Select;
+import com.activeandroid.query.Select;
 import com.activeandroid.test.MockModel;
 
 public class SelectTest extends SqlableTestCase {
diff --git a/tests/src/com/activeandroid/test/query/SqlableTestCase.java b/tests/src/com/activeandroid/test/query/SqlableTestCase.java
index f339e1b0..36137600 100644
--- a/tests/src/com/activeandroid/test/query/SqlableTestCase.java
+++ b/tests/src/com/activeandroid/test/query/SqlableTestCase.java
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import com.activeandroid.sebbia.query.Sqlable;
+import com.activeandroid.query.Sqlable;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
 public abstract class SqlableTestCase extends ActiveAndroidTestCase {
diff --git a/tests/src/com/activeandroid/test/query/UpdateTest.java b/tests/src/com/activeandroid/test/query/UpdateTest.java
index 1d9d7c6d..814d34f7 100644
--- a/tests/src/com/activeandroid/test/query/UpdateTest.java
+++ b/tests/src/com/activeandroid/test/query/UpdateTest.java
@@ -16,8 +16,8 @@
  * limitations under the License.
  */
 
-import com.activeandroid.sebbia.query.Set;
-import com.activeandroid.sebbia.query.Update;
+import com.activeandroid.query.Set;
+import com.activeandroid.query.Update;
 import com.activeandroid.test.MockModel;
 
 public class UpdateTest extends SqlableTestCase {
