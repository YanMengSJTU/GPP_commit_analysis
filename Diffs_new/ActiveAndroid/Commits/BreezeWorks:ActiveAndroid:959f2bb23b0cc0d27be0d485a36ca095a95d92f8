diff --git a/build.gradle b/build.gradle
index 8e6986f2..49c24f15 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,6 +1,6 @@
 apply plugin: 'java'
 
-sourceCompatibility = 1.6
+sourceCompatibility = 1.7
 
 jar.baseName = 'activeandroid'
 archivesBaseName = 'activeandroid'
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 421426ea..df37712d 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -30,7 +30,9 @@
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 @SuppressWarnings("unchecked")
 public abstract class Model {
@@ -176,13 +178,13 @@ public static void delete(Class<? extends Model> type, long id) {
 	}
 
 	// Model population
-
 	public final void loadFromCursor(Cursor cursor) {
         /**
          * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
          * when the cursor have multiple columns with same name obtained from join tables.
          */
         List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+
 		for (Field field : mTableInfo.getFields()) {
 			final String fieldName = mTableInfo.getColumnName(field);
 			Class<?> fieldType = field.getType();
@@ -195,6 +197,7 @@ public final void loadFromCursor(Cursor cursor) {
 			field.setAccessible(true);
 
 			try {
+
 				boolean columnIsNull = cursor.isNull(columnIndex);
 				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
 				Object value = null;
@@ -239,15 +242,15 @@ else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
 					value = cursor.getBlob(columnIndex);
 				}
 				else if (ReflectionUtils.isModel(fieldType)) {
-					final long entityId = cursor.getLong(columnIndex);
+					final Long entityId = cursor.getLong(columnIndex);
 					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
 
-					Model entity = Cache.getEntity(entityType, entityId);
-					if (entity == null) {
-						entity = new Select().from(entityType).where(idName+"=?", entityId).executeSingle();
+					Model entity = Cache.getEntity(entityType, entityId.longValue());
+					if (entity != null) {
+						value = entity;
+					} else {
+						faultedRelationships.add(new FaultedRelationship(entityType, entityId, field));
 					}
-
-					value = entity;
 				}
 				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 					@SuppressWarnings("rawtypes")
@@ -279,6 +282,8 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 		if (mId != null) {
 			Cache.addEntity(this);
 		}
+
+
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -317,4 +322,66 @@ public int hashCode() {
 		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
 		return hash; //To change body of generated methods, choose Tools | Templates.
 	}
+
+	//////////////////////////////////////////////////////////////////////////////////////
+	// Faulting relationships Management
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private class FaultedRelationship {
+		public Class<? extends Model> targetType;
+		public Long targetId;
+		public Field field;
+		FaultedRelationship(Class<? extends Model> targetType, Long targetId, Field field){
+			this.targetType = targetType;
+			this.targetId = targetId;
+			this.field = field;
+		}
+	}
+	private ArrayList<FaultedRelationship> faultedRelationships = new ArrayList<FaultedRelationship>();
+
+	public Set<Class<? extends Model>> getFaultedClasses(){
+		HashSet<Class<? extends Model>> deps = new HashSet<>();
+
+		for(FaultedRelationship f : faultedRelationships) {
+			deps.add(f.targetType);
+		}
+
+		return deps;
+	}
+
+	public Set<String> getFaultedIdsForClass(Class<? extends Model> clazz){
+		HashSet<String> ids = new HashSet<String>();
+
+		for(FaultedRelationship f : faultedRelationships) {
+			if(f.targetType.equals(clazz)){
+				ids.add(f.targetId.toString());
+			}
+		}
+
+		return ids;
+	}
+
+	public void associateFaultedObject(Model targetObject){
+		for (FaultedRelationship f : matchingFaultsForTarget(targetObject)) {
+			try {
+				f.field.setAccessible(true);
+				f.field.set(this, targetObject);
+			}
+			catch (IllegalAccessException e) {
+				Log.e(e.getClass().getName(), e);
+			}
+			faultedRelationships.remove(f);
+		}
+	}
+
+	private List<FaultedRelationship> matchingFaultsForTarget(Model target) {
+		ArrayList<FaultedRelationship> matching = new ArrayList<>();
+		for (FaultedRelationship f : faultedRelationships) {
+			if (target.getClass().equals(f.targetType) && target.getId().equals(f.targetId)){
+				matching.add(f);
+			}
+		}
+		return matching;
+	}
+
 }
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index cbf41eae..6a26dced 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -34,6 +34,7 @@
 import java.util.Arrays;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -345,6 +346,9 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 					entities.add((T) entity);
 				}
 				while (cursor.moveToNext());
+
+				// now, load all dependencies of the entities
+				processDependencies(entities);
 			}
 
 		}
@@ -365,6 +369,62 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 		return entities;
 	}
 
+	private static void processDependencies(List<? extends Model> entities){
+
+		//get a set of all the dependent classes
+		HashSet<Class<? extends Model>> dependentClasses = new HashSet<Class<? extends Model>>();
+		for (Model entity : entities) {
+			dependentClasses.addAll(entity.getFaultedClasses());
+		}
+
+		//load each class one at time
+		for (Class<? extends Model> dependencyClass : dependentClasses) {
+			loadDependencies(dependencyClass, entities);
+		}
+
+	}
+
+	private static void loadDependencies(Class<? extends Model> dependencyClass, List<? extends Model> entities) {
+
+		// get all the ids
+		HashSet<String> faultedIds = new HashSet<>();
+		for (Model entity : entities) {
+			faultedIds.addAll(entity.getFaultedIdsForClass(dependencyClass));
+		}
+
+		//execute the IN query
+		List<? extends Model> relatedEntities = inQuery(dependencyClass, faultedIds.toArray(new String[faultedIds.size()]));
+
+		//build a hash
+		HashMap<Long, Model> relatedEntityHash = new HashMap<>();
+		for (Model relatedEntity : relatedEntities ) {
+			relatedEntityHash.put(relatedEntity.getId(), relatedEntity);
+		}
+
+		//Now, map dependencies to the entities
+		for (Model entity : entities) {
+			for(String faultedId : entity.getFaultedIdsForClass(dependencyClass)) {
+				Model matchingRelatedObject = relatedEntityHash.get(new Long(faultedId));
+				if (matchingRelatedObject != null) {
+					entity.associateFaultedObject(matchingRelatedObject);
+				}
+			}
+		}
+
+	}
+
+	private static <T extends Model> List<T> inQuery(Class<? extends Model> clazz, String[] ids) {
+		Character[] placeholdersArray = new Character[ids.length];
+		for (int i = 0; i < ids.length; i++) {
+			placeholdersArray[i] = '?';
+		}
+		String placeholders = TextUtils.join(",", placeholdersArray);
+		String whereClause = " where " + Cache.getTableInfo(clazz).getIdName()+" IN ("+placeholders+")";
+		String fromClause = "Select * from " + Cache.getTableName(clazz);
+
+		return rawQuery(clazz, fromClause + whereClause, ids);
+	}
+
 	private static int processIntCursor(final Cursor cursor) {
         if (cursor.moveToFirst()) {
             return cursor.getInt(0);
