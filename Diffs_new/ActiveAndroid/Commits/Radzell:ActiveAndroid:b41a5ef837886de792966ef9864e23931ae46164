diff --git a/src/com/activeandroid/ActiveAndroid.java b/src/com/activeandroid/ActiveAndroid.java
index c58c8efd..d61a5aca 100644
--- a/src/com/activeandroid/ActiveAndroid.java
+++ b/src/com/activeandroid/ActiveAndroid.java
@@ -83,4 +83,6 @@ public static void execSQL(String sql) {
 	public static void execSQL(String sql, Object[] bindArgs) {
 		Cache.openDatabase().execSQL(sql, bindArgs);
 	}
+
+
 }
diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
index a48e18f7..abb5e8ac 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -16,8 +16,6 @@
  * limitations under the License.
  */
 
-import java.util.Collection;
-
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.support.v4.util.LruCache;
@@ -25,6 +23,8 @@
 import com.activeandroid.serializer.TypeSerializer;
 import com.activeandroid.util.Log;
 
+import java.util.Collection;
+
 public final class Cache {
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC CONSTANTS
@@ -151,6 +151,9 @@ public static synchronized TableInfo getTableInfo(Class<? extends Model> type) {
 	public static synchronized TypeSerializer getParserForType(Class<?> type) {
 		return sModelInfo.getTypeSerializer(type);
 	}
+    public static synchronized com.activeandroid.sqlserializer.SqlTypeSerializer getSqlParserForType(Class<?> type) {
+        return sModelInfo.getSQLTypeSerializer(type);
+    }
 
 	public static synchronized String getTableName(Class<? extends Model> type) {
 		return sModelInfo.getTableInfo(type).getTableName();
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 6dcbc5f9..41dadb09 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -20,7 +20,6 @@
 import android.database.Cursor;
 import android.database.SQLException;
 import android.database.sqlite.SQLiteDatabase;
-import android.text.TextUtils;
 
 import com.activeandroid.content.ContentProvider;
 import com.activeandroid.query.Delete;
@@ -37,332 +36,318 @@
 @SuppressWarnings("unchecked")
 public abstract class Model {
 
-	/** Prime number used for hashcode() implementation. */
-	private static final int HASH_PRIME = 739;
-    private boolean dbEnabled=false;
+    /**
+     * Prime number used for hashcode() implementation.
+     */
+    private static final int HASH_PRIME = 739;
+    private boolean dbEnabled = false;
 
     //////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private Long mId = null;
+    private long mId = -1;
 
-	private TableInfo mTableInfo;
-	private String idName;
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
+    private TableInfo mTableInfo;
+    private String idName;
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public Model() {
+    public Model() {
         this(true);
-	}
+    }
 
-    public Model(boolean useDB){
-        if(useDB){
+    public Model(boolean useDB) {
+        if (useDB) {
             enableDB(true);
         }
     }
 
 
     //////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
 
     private void enableDB(boolean enable) {
         mTableInfo = Cache.getTableInfo(getClass());
         idName = mTableInfo.getIdName();
-        dbEnabled =enable;
+        dbEnabled = enable;
+    }
+
+    public boolean isDbEnabled() {
+        return dbEnabled;
+    }
+
+    public final long getId() {
+        return mId;
     }
 
-    public boolean isDbEnabled(){return dbEnabled;}
-    public final Long getId() {
-		return mId;
-	}
     public final void setId(Long pId) {
-         mId=pId;
+        mId = pId;
+    }
+
+    public final void delete() {
+        Cache.openDatabase().delete(mTableInfo.getTableName(), idName + "=?", new String[]{String.valueOf(getId())});
+        Cache.removeEntity(this);
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
     }
 
-	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), idName+"=?", new String[] { getId().toString() });
-		Cache.removeEntity(this);
+    public void onBeforeSave() {
 
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-	}
-    public void onBeforeSave(){
-        
     }
-	public final Long save() throws SQLException{
+
+    public final Long saveOrUpdate() throws SQLException {
+        return saveOrUpdate(true,true);
+    }
+    private final Long saveOrUpdate(boolean update, boolean save) throws SQLException {
         onBeforeSave();
-		final SQLiteDatabase db = Cache.openDatabase();
-		final ContentValues values = new ContentValues();
-
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-
-			field.setAccessible(true);
-
-			try {
-				Object value = field.get(this);
-
-				if (value != null) {
-					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-					if (typeSerializer != null) {
-						// serialize data
-						value = typeSerializer.serialize(value);
-						// set new object type
-						if (value != null) {
-							fieldType = value.getClass();
-							// check that the serializer returned what it promised
-							if (!fieldType.equals(typeSerializer.getSerializedType())) {
-								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-										typeSerializer.getSerializedType(), fieldType));
-							}
-						}
-					}
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (value == null) {
-					values.putNull(fieldName);
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					values.put(fieldName, (Byte) value);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					values.put(fieldName, (Short) value);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					values.put(fieldName, (Integer) value);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					values.put(fieldName, (Long) value);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					values.put(fieldName, (Float) value);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					values.put(fieldName, (Double) value);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					values.put(fieldName, (Boolean) value);
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(String.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					values.put(fieldName, (byte[]) value);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					values.put(fieldName, ((Model) value).getId());
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					values.put(fieldName, ((Enum<?>) value).name());
-				}
-			}
-			catch (IllegalArgumentException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-		}
-
-		if (mId == null) {
-			mId = db.insertOrThrow(mTableInfo.getTableName(), null, values);
-		}
-		else {
-            String matchStatement;
-
-            if(!mTableInfo.hasMatchValue()) {
-
-                matchStatement = idName + "=" + mId;
-            }else{
-                List<String> matchTokens= new ArrayList<String>();
-
-                for(Field field : mTableInfo.getMatchValue()){
-                    try {
-                        final String fieldName = mTableInfo.getColumnName(field);
-                        Object value = field.get(this);
-                        String statement = fieldName + "=" + value;
-                        matchTokens.add(statement);
-                    } catch (IllegalAccessException e) {
-                        Log.e(e.getClass().getName(), e);
+        final SQLiteDatabase db = Cache.openDatabase();
+        final ContentValues values = new ContentValues();
+        TableInfo.ColumnField matchColumnField = mTableInfo.getMatchValue();
+        Class<?> matchFieldType = null;
+
+        for (TableInfo.ColumnField columnField : mTableInfo.getColumns()) {
+            Class<?> fieldType = columnField.getField().getType();
+
+            columnField.getField().setAccessible(true);
+
+            try {
+                Object value = columnField.getField().get(this);
+
+                if (value != null) {
+                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                    if (typeSerializer != null) {
+                        // serialize data
+                        value = typeSerializer.serialize(value);
+                        // set new object type
+                        if (value != null) {
+                            fieldType = value.getClass();
+                            // check that the serializer returned what it promised
+                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
+                                Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                        typeSerializer.getSerializedType(), fieldType));
+                            }
+                        }
                     }
                 }
-                matchStatement = TextUtils.join(" AND ",matchTokens);
+                if (matchColumnField.getName().equals(columnField.getName())) {
+                    matchFieldType = fieldType;
+                }
+                if (columnField.isAutoIncrement) {
+                    continue;
+                }
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (value == null) {
+                    values.putNull(columnField.getName());
+                } else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    values.put(columnField.getName(), (Byte) value);
+                } else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    values.put(columnField.getName(), (Short) value);
+                } else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    values.put(columnField.getName(), (Integer) value);
+                } else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    values.put(columnField.getName(), (Long) value);
+                } else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    values.put(columnField.getName(), (Float) value);
+                } else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    values.put(columnField.getName(), (Double) value);
+                } else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    values.put(columnField.getName(), (Boolean) value);
+                } else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    values.put(columnField.getName(), value.toString());
+                } else if (fieldType.equals(String.class)) {
+                    values.put(columnField.getName(), value.toString());
+                } else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    values.put(columnField.getName(), (byte[]) value);
+                } else if (ReflectionUtils.isModel(fieldType)) {
+                    values.put(columnField.getName(), ((Model) value).getId());
+                } else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    values.put(columnField.getName(), ((Enum<?>) value).name());
+                }
+
+            } catch (IllegalArgumentException e) {
+                Log.e(e.getClass().getName(), e);
+            } catch (IllegalAccessException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+
+        try {
+            Object matchValue = matchColumnField.getField().get(this);
+
+            int affected;
+            if (matchValue != null&&update) {
+                affected = db.update(mTableInfo.getTableName(), values, matchColumnField.getName() + " = " + Cache.getSqlParserForType(matchFieldType).toSql(matchValue), null);
+
+                if (affected <= 0&&save) {
+                    mId = db.insertOrThrow(mTableInfo.getTableName(), null, values);
+                }else{
+                    mId = new Select(idName).from(mTableInfo.getType()).where(matchColumnField.getName() + " = ?", matchValue).executeSingle().getId();
+                }
+            } else if(save) {
+                mId = db.insertOrThrow(mTableInfo.getTableName(), null, values);
             }
 
-            db.update(mTableInfo.getTableName(), values, matchStatement, null);
 
+            Cache.getContext().getContentResolver()
+                    .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
         }
+        return mId;
+    }
 
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-		return mId;
-	}
+    public final long save() throws SQLException {
+        return saveOrUpdate(false,true);
+    }
 
-	// Convenience methods
+    public final long update() throws SQLException {
+        return saveOrUpdate(true,false);
+    }
+    // Convenience methods
 
-	public static void delete(Class<? extends Model> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
-	}
+    public static void delete(Class<? extends Model> type, long id) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        new Delete().from(type).where(tableInfo.getIdName() + "=?", id).execute();
+    }
 
-	public static <T extends Model> T load(Class<T> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
-	}
+    public static <T extends Model> T load(Class<T> type, long id) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        return (T) new Select().from(type).where(tableInfo.getIdName() + "=?", id).executeSingle();
+    }
 
-	// Model population
+    // Model population
 
-	public final void loadFromCursor(Cursor cursor) {
+    public final void loadFromCursor(Cursor cursor) {
         /**
          * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
          * when the cursor have multiple columns with same name obtained from join tables.
          */
         List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-			final int columnIndex = columnsOrdered.indexOf(fieldName);
-
-			if (columnIndex < 0) {
-				continue;
-			}
-
-			field.setAccessible(true);
-
-			try {
-				boolean columnIsNull = cursor.isNull(columnIndex);
-				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-				Object value = null;
-
-				if (typeSerializer != null) {
-					fieldType = typeSerializer.getSerializedType();
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (columnIsNull) {
-					field = null;
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					value = cursor.getLong(columnIndex);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					value = cursor.getFloat(columnIndex);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					value = cursor.getDouble(columnIndex);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					value = cursor.getInt(columnIndex) != 0;
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					value = cursor.getString(columnIndex).charAt(0);
-				}
-				else if (fieldType.equals(String.class)) {
-					value = cursor.getString(columnIndex);
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					value = cursor.getBlob(columnIndex);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					final long entityId = cursor.getLong(columnIndex);
-					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
-
-					Model entity = Cache.getEntity(entityType, entityId);
-					if (entity == null) {
-						entity = new Select().from(entityType).where(idName+"=?", entityId).executeSingle();
-					}
-
-					value = entity;
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					@SuppressWarnings("rawtypes")
-					final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-					value = Enum.valueOf(enumType, cursor.getString(columnIndex));
-				}
-
-				// Use a deserializer if one is available
-				if (typeSerializer != null && !columnIsNull) {
-					value = typeSerializer.deserialize(value);
-				}
-
-				// Set the field value
-				if (value != null) {
-					field.set(this, value);
-				}
-			}
-			catch (IllegalArgumentException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (SecurityException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-		}
-
-		if (mId != null) {
-			Cache.addEntity(this);
-		}
+        for (TableInfo.ColumnField columnField : mTableInfo.getColumns()) {
+            Class<?> fieldType = columnField.getField().getType();
+            final int columnIndex = columnsOrdered.indexOf(columnField.getName());
+
+            if (columnIndex < 0) {
+                continue;
+            }
+
+            columnField.getField().setAccessible(true);
+
+            try {
+                boolean columnIsNull = cursor.isNull(columnIndex);
+                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                Object value = null;
+
+                if (typeSerializer != null) {
+                    fieldType = typeSerializer.getSerializedType();
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (columnIsNull) {
+                    Field field = columnField.getField();
+                } else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    value = cursor.getInt(columnIndex);
+                } else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    value = cursor.getInt(columnIndex);
+                } else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    value = cursor.getInt(columnIndex);
+                } else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    value = cursor.getLong(columnIndex);
+                } else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    value = cursor.getFloat(columnIndex);
+                } else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    value = cursor.getDouble(columnIndex);
+                } else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    value = cursor.getInt(columnIndex) != 0;
+                } else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    value = cursor.getString(columnIndex).charAt(0);
+                } else if (fieldType.equals(String.class)) {
+                    value = cursor.getString(columnIndex);
+                } else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    value = cursor.getBlob(columnIndex);
+                } else if (ReflectionUtils.isModel(fieldType)) {
+                    final long entityId = cursor.getLong(columnIndex);
+                    final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
+
+                    Model entity = Cache.getEntity(entityType, entityId);
+                    if (entity == null) {
+                        entity = new Select().from(entityType).where(idName + "=?", entityId).executeSingle();
+                    }
+
+                    value = entity;
+                } else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    @SuppressWarnings("rawtypes")
+                    final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+                    value = Enum.valueOf(enumType, cursor.getString(columnIndex));
+                }
+
+                // Use a deserializer if one is available
+                if (typeSerializer != null && !columnIsNull) {
+                    value = typeSerializer.deserialize(value);
+                }
+
+                // Set the field value
+                if (value != null) {
+                    columnField.getField().set(this, value);
+                }
+            } catch (IllegalArgumentException e) {
+                Log.e(e.getClass().getName(), e);
+            } catch (IllegalAccessException e) {
+                Log.e(e.getClass().getName(), e);
+            } catch (SecurityException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+
+        if (mId != -1) {
+            Cache.addEntity(this);
+        }
         onAfterLoad();
-	}
+    }
+
+    public void onAfterLoad() {
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PROTECTED METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-    private void onAfterLoad() {
+    protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
+        return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
     }
 
     //////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
-		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public String toString() {
-		return mTableInfo.getTableName() + "@" + getId();
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (obj instanceof Model && this.mId != null) {
-			final Model other = (Model) obj;
-
-			return this.mId.equals(other.mId)							
-							&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
-		} else {
-			return this == obj;
-		}
-	}
-
-	@Override
-	public int hashCode() {
-		int hash = HASH_PRIME;
-		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); //if id is null, use Object.hashCode()
-		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
-		return hash; //To change body of generated methods, choose Tools | Templates.
-	}
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public String toString() {
+        return mTableInfo.getTableName() + "@" + getId();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof Model && this.mId != -1) {
+            final Model other = (Model) obj;
+
+            return this.mId==other.mId
+                    && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
+        } else {
+            return this == obj;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = HASH_PRIME;
+        hash += HASH_PRIME * (mId == -1 ? super.hashCode() : mId); //if id is null, use Object.hashCode()
+        hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
+        return hash; //To change body of generated methods, choose Tools | Templates.
+    }
 }
diff --git a/src/com/activeandroid/ModelInfo.java b/src/com/activeandroid/ModelInfo.java
index 09e79117..fb71b8f8 100644
--- a/src/com/activeandroid/ModelInfo.java
+++ b/src/com/activeandroid/ModelInfo.java
@@ -16,26 +16,39 @@
  * limitations under the License.
  */
 
+import android.content.Context;
+import android.graphics.Bitmap;
+
+import com.activeandroid.serializer.CalendarSerializer;
+import com.activeandroid.serializer.FileSerializer;
+import com.activeandroid.serializer.SqlDateSerializer;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.serializer.UtilDateSerializer;
+import com.activeandroid.sqlserializer.BitmapSerializerSql;
+import com.activeandroid.sqlserializer.BooleanSerializerSql;
+import com.activeandroid.sqlserializer.DateSerializerSql;
+import com.activeandroid.sqlserializer.DoubleSerializerSql;
+import com.activeandroid.sqlserializer.FloatSerializerSql;
+import com.activeandroid.sqlserializer.IntSerializerSql;
+import com.activeandroid.sqlserializer.LongSerializerSql;
+import com.activeandroid.sqlserializer.SqlTypeSerializer;
+import com.activeandroid.sqlserializer.StringSerializerSql;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
+
 import java.io.File;
 import java.io.IOException;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
+import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
-import android.content.Context;
-
-import com.activeandroid.serializer.CalendarSerializer;
-import com.activeandroid.serializer.SqlDateSerializer;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.serializer.UtilDateSerializer;
-import com.activeandroid.serializer.FileSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
 import dalvik.system.DexFile;
 
 final class ModelInfo {
@@ -53,7 +66,31 @@
 		}
 	};
 
-	//////////////////////////////////////////////////////////////////////////////////////
+    private Map<Class, SqlTypeSerializer> mSqlTypeSerializers = new ConcurrentHashMap<Class, SqlTypeSerializer>(){
+        {
+            put(int.class, new IntSerializerSql());
+            put(Integer.class, new IntSerializerSql());
+
+            put(long.class, new LongSerializerSql());
+            put(Long.class, new LongSerializerSql());
+
+            put(float.class, new FloatSerializerSql());
+            put(Float.class, new FloatSerializerSql());
+
+            put(double.class, new DoubleSerializerSql());
+            put(Double.class, new DoubleSerializerSql());
+
+            put(boolean.class, new BooleanSerializerSql());
+            put(Boolean.class, new BooleanSerializerSql());
+
+            put(String.class, new StringSerializerSql());
+            put(Date.class, new DateSerializerSql());
+            put(Bitmap.class, new BitmapSerializerSql());
+        }
+    };
+
+
+    //////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
 	//////////////////////////////////////////////////////////////////////////////////////
 
@@ -86,6 +123,9 @@ public TypeSerializer getTypeSerializer(Class<?> type) {
 		return mTypeSerializers.get(type);
 	}
 
+    public SqlTypeSerializer getSQLTypeSerializer(Class<?> type) {
+        return mSqlTypeSerializers.get(type);
+    }
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -206,4 +246,6 @@ else if (ReflectionUtils.isTypeSerializer(discoveredClass)) {
 			}
 		}
 	}
+
+
 }
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/TableInfo.java
index 0d43cd10..af1fe593 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/src/com/activeandroid/TableInfo.java
@@ -24,24 +24,24 @@
 import com.activeandroid.util.ReflectionUtils;
 
 import java.lang.reflect.Field;
-import java.util.Collection;
 import java.util.Collections;
-import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.Map;
+import java.util.Set;
 
 public final class TableInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	private Class<? extends Model> mType;
 	private String mTableName;
 	private String mIdName = Table.DEFAULT_ID_NAME;
+	private Set<ColumnField> mColumns = new LinkedHashSet<ColumnField>();
+    private ColumnField mMatchValue;
+    private ColumnField idColumnField;
 
-	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
-    private Map<Field,String> mMatchValues = new LinkedHashMap<Field, String>();
     //////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -61,7 +61,8 @@ public TableInfo(Class<? extends Model> type) {
 
         // Manually add the id column since it is not declared like the other columns.
         Field idField = getIdField(type);
-        mColumnNames.put(idField, mIdName);
+        idColumnField = new ColumnField(mIdName, idField,false,true);
+        mColumns.add(idColumnField);
 
         List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
         Collections.reverse(fields);
@@ -73,14 +74,15 @@ public TableInfo(Class<? extends Model> type) {
                 if (TextUtils.isEmpty(columnName)) {
                     columnName = field.getName();
                 }
-                if(columnAnnotation.matchvalue()){
-                    mMatchValues.put(field,columnName);
+                if(columnAnnotation.matchvalue()&&mMatchValue==null){
+                    mMatchValue= new ColumnField(columnName,field,true);
                 }
-
-                mColumnNames.put(field, columnName);
+                mColumns.add(new ColumnField(columnName, field));
             }
         }
-
+        if(mMatchValue==null){
+            mMatchValue=idColumnField;
+        }
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -99,13 +101,6 @@ public String getIdName() {
 		return mIdName;
 	}
 
-	public Collection<Field> getFields() {
-		return mColumnNames.keySet();
-	}
-
-	public String getColumnName(Field field) {
-		return mColumnNames.get(field);
-	}
 
 
     private Field getIdField(Class<?> type) {
@@ -125,10 +120,58 @@ else if (type.getSuperclass() != null) {
     }
 
     public boolean hasMatchValue() {
-        return !mMatchValues.isEmpty();
+        return (mMatchValue!=null);
+    }
+
+    public ColumnField getMatchValue() {
+        return mMatchValue;
     }
 
-    public java.util.Set<Field> getMatchValue() {
-        return mMatchValues.keySet();
+    public Set<ColumnField> getColumns() {
+        return mColumns;
     }
+
+    public static class ColumnField {
+        final String name;
+        String sqlType;
+        final Field field;
+        final boolean isMatchValue;
+        final boolean isAutoIncrement;
+
+
+        public ColumnField(String name, Field field){
+            this(name, field, false, false);
+        }
+        public ColumnField(String name, Field field,boolean isMatchValue){
+            this(name, field, isMatchValue, false);
+        }
+        public ColumnField(String name, Field field, boolean isMatchValue, boolean isAutoIncrement) {
+            this.name = name;
+            this.field = field;
+            this.isMatchValue = isMatchValue;
+            this.isAutoIncrement = isAutoIncrement;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (o instanceof ColumnField) {
+                return ((ColumnField) o).name.equals(name);
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            return this.name.hashCode();
+        }
+
+        public Field getField() {
+            return field;
+        }
+
+        public String getName() {
+            return name;
+        }
+    }
+
 }
diff --git a/src/com/activeandroid/sqlserializer/BitmapSerializerSql.java b/src/com/activeandroid/sqlserializer/BitmapSerializerSql.java
new file mode 100644
index 00000000..7c860961
--- /dev/null
+++ b/src/com/activeandroid/sqlserializer/BitmapSerializerSql.java
@@ -0,0 +1,47 @@
+package com.activeandroid.sqlserializer;
+
+import android.annotation.TargetApi;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+
+import java.io.ByteArrayOutputStream;
+
+public class BitmapSerializerSql implements SqlTypeSerializer<Bitmap> {
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @Override
+    public Bitmap unpack(Cursor c, String name) {
+        byte[] bytes = c.getBlob(c.getColumnIndex(name));
+        BitmapFactory.Options opts = new BitmapFactory.Options();
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            opts.inMutable = true;
+        }
+        Bitmap bmp = BitmapFactory.decodeByteArray(bytes, 0, bytes.length, opts);
+        return bmp;
+    }
+
+    @Override
+    public void pack(Bitmap object, ContentValues cv, String name) {
+        ByteArrayOutputStream stream = new ByteArrayOutputStream();
+        object.compress(Bitmap.CompressFormat.PNG, 100, stream);
+        byte[] bytes = stream.toByteArray();
+        cv.put(name, bytes);
+    }
+
+    @Override
+    public String toSql(Bitmap object) {
+        ByteArrayOutputStream stream = new ByteArrayOutputStream();
+        object.compress(Bitmap.CompressFormat.PNG, 100, stream);
+        byte[] bytes = stream.toByteArray();
+        return new String(bytes);
+    }
+
+    @Override
+    public SqlType getSqlType() {
+        return SqlType.BLOB;
+    }
+
+}
diff --git a/src/com/activeandroid/sqlserializer/BooleanSerializerSql.java b/src/com/activeandroid/sqlserializer/BooleanSerializerSql.java
new file mode 100644
index 00000000..acb080c1
--- /dev/null
+++ b/src/com/activeandroid/sqlserializer/BooleanSerializerSql.java
@@ -0,0 +1,28 @@
+package com.activeandroid.sqlserializer;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+
+public class BooleanSerializerSql implements SqlTypeSerializer<Boolean> {
+
+    @Override
+    public Boolean unpack(Cursor c, String name) {
+        return c.getInt(c.getColumnIndexOrThrow(name)) > 0;
+    }
+
+    @Override
+    public void pack(Boolean object, ContentValues cv, String name) {
+        cv.put(name, object ? 1 : 0);
+    }
+
+    @Override
+    public String toSql(Boolean object) {
+        return object ? "1" : "0";
+    }
+
+    @Override
+    public SqlType getSqlType() {
+        return SqlType.INTEGER;
+    }
+
+}
diff --git a/src/com/activeandroid/sqlserializer/DateSerializerSql.java b/src/com/activeandroid/sqlserializer/DateSerializerSql.java
new file mode 100644
index 00000000..7fd02b7b
--- /dev/null
+++ b/src/com/activeandroid/sqlserializer/DateSerializerSql.java
@@ -0,0 +1,30 @@
+package com.activeandroid.sqlserializer;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+
+import java.util.Date;
+
+public class DateSerializerSql implements SqlTypeSerializer<Date> {
+
+    @Override
+    public Date unpack(Cursor c, String name) {
+        return new Date(c.getLong(c.getColumnIndexOrThrow(name)));
+    }
+
+    @Override
+    public void pack(Date object, ContentValues cv, String name) {
+        cv.put(name, object.getTime());
+    }
+
+    @Override
+    public String toSql(Date object) {
+        return String.valueOf(object.getTime());
+    }
+
+    @Override
+    public SqlType getSqlType() {
+        return SqlType.INTEGER;
+    }
+
+}
diff --git a/src/com/activeandroid/sqlserializer/DoubleSerializerSql.java b/src/com/activeandroid/sqlserializer/DoubleSerializerSql.java
new file mode 100644
index 00000000..bc207159
--- /dev/null
+++ b/src/com/activeandroid/sqlserializer/DoubleSerializerSql.java
@@ -0,0 +1,28 @@
+package com.activeandroid.sqlserializer;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+
+public class DoubleSerializerSql implements SqlTypeSerializer<Double> {
+
+    @Override
+    public Double unpack(Cursor c, String name) {
+        return c.getDouble(c.getColumnIndexOrThrow(name));
+    }
+
+    @Override
+    public void pack(Double object, ContentValues cv, String name) {
+        cv.put(name, object);
+    }
+
+    @Override
+    public String toSql(Double object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public SqlType getSqlType() {
+        return SqlType.REAL;
+    }
+
+}
diff --git a/src/com/activeandroid/sqlserializer/FloatSerializerSql.java b/src/com/activeandroid/sqlserializer/FloatSerializerSql.java
new file mode 100644
index 00000000..6c8a18e8
--- /dev/null
+++ b/src/com/activeandroid/sqlserializer/FloatSerializerSql.java
@@ -0,0 +1,28 @@
+package com.activeandroid.sqlserializer;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+
+public class FloatSerializerSql implements SqlTypeSerializer<Float> {
+
+    @Override
+    public Float unpack(Cursor c, String name) {
+        return c.getFloat(c.getColumnIndexOrThrow(name));
+    }
+
+    @Override
+    public void pack(Float object, ContentValues cv, String name) {
+        cv.put(name, object);
+    }
+
+    @Override
+    public String toSql(Float object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public SqlType getSqlType() {
+        return SqlType.REAL;
+    }
+
+}
diff --git a/src/com/activeandroid/sqlserializer/IntSerializerSql.java b/src/com/activeandroid/sqlserializer/IntSerializerSql.java
new file mode 100644
index 00000000..61be2051
--- /dev/null
+++ b/src/com/activeandroid/sqlserializer/IntSerializerSql.java
@@ -0,0 +1,28 @@
+package com.activeandroid.sqlserializer;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+
+public class IntSerializerSql implements SqlTypeSerializer<Integer> {
+
+    @Override
+    public Integer unpack(Cursor c, String name) {
+        return c.getInt(c.getColumnIndexOrThrow(name));
+    }
+
+    @Override
+    public void pack(Integer object, ContentValues cv, String name) {
+        cv.put(name, object);
+    }
+
+    @Override
+    public String toSql(Integer object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public SqlType getSqlType() {
+        return SqlType.INTEGER;
+    }
+
+}
diff --git a/src/com/activeandroid/sqlserializer/LongSerializerSql.java b/src/com/activeandroid/sqlserializer/LongSerializerSql.java
new file mode 100644
index 00000000..a2cdd80c
--- /dev/null
+++ b/src/com/activeandroid/sqlserializer/LongSerializerSql.java
@@ -0,0 +1,28 @@
+package com.activeandroid.sqlserializer;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+
+public class LongSerializerSql implements SqlTypeSerializer<Long> {
+
+    @Override
+    public Long unpack(Cursor c, String name) {
+        return c.getLong(c.getColumnIndexOrThrow(name));
+    }
+
+    @Override
+    public void pack(Long object, ContentValues cv, String name) {
+        cv.put(name, object);
+    }
+
+    @Override
+    public String toSql(Long object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public SqlType getSqlType() {
+        return SqlType.INTEGER;
+    }
+
+}
diff --git a/src/com/activeandroid/sqlserializer/SqlType.java b/src/com/activeandroid/sqlserializer/SqlType.java
new file mode 100644
index 00000000..4421b0ca
--- /dev/null
+++ b/src/com/activeandroid/sqlserializer/SqlType.java
@@ -0,0 +1,8 @@
+package com.activeandroid.sqlserializer;
+
+public enum SqlType {
+    INTEGER,
+    REAL,
+    TEXT,
+    BLOB
+}
diff --git a/src/com/activeandroid/sqlserializer/SqlTypeSerializer.java b/src/com/activeandroid/sqlserializer/SqlTypeSerializer.java
new file mode 100644
index 00000000..9eab0585
--- /dev/null
+++ b/src/com/activeandroid/sqlserializer/SqlTypeSerializer.java
@@ -0,0 +1,16 @@
+package com.activeandroid.sqlserializer;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+
+public interface SqlTypeSerializer<T> {
+
+    T unpack(Cursor c, String name);
+
+    void pack(T object, ContentValues cv, String name);
+
+    String toSql(T object);
+
+    SqlType getSqlType();
+
+}
diff --git a/src/com/activeandroid/sqlserializer/StringSerializerSql.java b/src/com/activeandroid/sqlserializer/StringSerializerSql.java
new file mode 100644
index 00000000..ffbc6a0e
--- /dev/null
+++ b/src/com/activeandroid/sqlserializer/StringSerializerSql.java
@@ -0,0 +1,29 @@
+package com.activeandroid.sqlserializer;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+
+public class StringSerializerSql implements SqlTypeSerializer<String> {
+
+    @Override
+    public String unpack(Cursor c, String name) {
+        return c.getString(c.getColumnIndexOrThrow(name));
+    }
+
+    @Override
+    public void pack(String object, ContentValues cv, String name) {
+        cv.put(name, object);
+    }
+
+    @Override
+    public String toSql(String object) {
+        return  DatabaseUtils.sqlEscapeString(object);
+    }
+
+    @Override
+    public SqlType getSqlType() {
+        return SqlType.TEXT;
+    }
+
+}
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index cbf41eae..24588586 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -27,12 +27,9 @@
 import com.activeandroid.annotation.Column.ConflictAction;
 import com.activeandroid.serializer.TypeSerializer;
 
-import java.lang.Long;
-import java.lang.String;
 import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.util.Arrays;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -135,8 +132,8 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
 		sUniqueGroupMap = new HashMap<String, List<String>>();
 		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
 
-		for (Field field : tableInfo.getFields()) {
-			createUniqueColumnDefinition(tableInfo, field);
+		for (TableInfo.ColumnField columnField : tableInfo.getColumns()) {
+			createUniqueColumnDefinition(tableInfo, columnField);
 		}
 
 		if (sUniqueGroupMap.isEmpty()) {
@@ -155,11 +152,11 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
 		return definitions;
 	}
 
-	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
+	public static void createUniqueColumnDefinition(TableInfo tableInfo, TableInfo.ColumnField columnField) {
+		final String name = columnField.getName();
+		final Column column = columnField.getField().getAnnotation(Column.class);
 
-        if (field.getName().equals("mId")) {
+        if (columnField.getField().getName().equals("mId")) {
             return;
         }
 
@@ -190,8 +187,8 @@ public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field
 		final ArrayList<String> definitions = new ArrayList<String>();
 		sIndexGroupMap = new HashMap<String, List<String>>();
 
-		for (Field field : tableInfo.getFields()) {
-			createIndexColumnDefinition(tableInfo, field);
+		for (TableInfo.ColumnField columnField : tableInfo.getColumns()) {
+			createIndexColumnDefinition(tableInfo, columnField);
 		}
 
 		if (sIndexGroupMap.isEmpty()) {
@@ -207,18 +204,17 @@ public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field
 		return definitions.toArray(new String[definitions.size()]);
 	}
 
-	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
+	public static void createIndexColumnDefinition(TableInfo tableInfo, TableInfo.ColumnField columnField) {
+		final Column column = columnField.getField().getAnnotation(Column.class);
 
-        if (field.getName().equals("mId")) {
+        if (columnField.getField().getName().equals("mId")) {
             return;
         }
 
 		if (column.index()) {
 			List<String> list = new ArrayList<String>();
-			list.add(name);
-			sIndexGroupMap.put(name, list);
+			list.add(columnField.getName());
+			sIndexGroupMap.put(columnField.getName(), list);
 		}
 
 		String[] groups = column.indexGroups();
@@ -231,7 +227,7 @@ public static void createIndexColumnDefinition(TableInfo tableInfo, Field field)
 				list = new ArrayList<String>();
 			}
 
-			list.add(name);
+			list.add(columnField.getName());
 			sIndexGroupMap.put(group, list);
 		}
 	}
@@ -239,8 +235,8 @@ public static void createIndexColumnDefinition(TableInfo tableInfo, Field field)
 	public static String createTableDefinition(TableInfo tableInfo) {
 		final ArrayList<String> definitions = new ArrayList<String>();
 
-		for (Field field : tableInfo.getFields()) {
-			String definition = createColumnDefinition(tableInfo, field);
+		for (TableInfo.ColumnField columnField : tableInfo.getColumns()) {
+			String definition = createColumnDefinition(tableInfo, columnField);
 			if (!TextUtils.isEmpty(definition)) {
 				definitions.add(definition);
 			}
@@ -253,13 +249,13 @@ public static String createTableDefinition(TableInfo tableInfo) {
 	}
 
 	@SuppressWarnings("unchecked")
-	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
+	public static String createColumnDefinition(TableInfo tableInfo, TableInfo.ColumnField columnField) {
 		StringBuilder definition = new StringBuilder();
 
-		Class<?> type = field.getType();
-		final String name = tableInfo.getColumnName(field);
-		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-		final Column column = field.getAnnotation(Column.class);
+		Class<?> type = columnField.getField().getType();
+		final String name = columnField.getName();
+		final TypeSerializer typeSerializer = Cache.getParserForType(columnField.getField().getType());
+		final Column column = columnField.getField().getAnnotation(Column.class);
 
 		if (typeSerializer != null) {
 			type = typeSerializer.getSerializedType();
diff --git a/tests/src/com/activeandroid/test/MockModel.java b/tests/src/com/activeandroid/test/MockModel.java
index 93a40f16..f354de87 100644
--- a/tests/src/com/activeandroid/test/MockModel.java
+++ b/tests/src/com/activeandroid/test/MockModel.java
@@ -39,6 +39,4 @@
     @Column
     public String stringField;
 
-    @Column(matchvalue =true)
-    public String matchField;
 }
diff --git a/tests/src/com/activeandroid/test/ModelTest.java b/tests/src/com/activeandroid/test/ModelTest.java
index f33b10ce..168739a4 100644
--- a/tests/src/com/activeandroid/test/ModelTest.java
+++ b/tests/src/com/activeandroid/test/ModelTest.java
@@ -22,8 +22,8 @@
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.Table;
 import com.activeandroid.query.Select;
+import com.activeandroid.util.Log;
 
-import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashSet;
@@ -76,8 +76,8 @@ public void testEqualsDifferentRows() {
 		MockModel model2 = new MockModel();
 		MockModel model3;
 
-		model1.save();
-		model2.save();
+		model1.saveOrUpdate();
+		model2.saveOrUpdate();
 		model3 = Model.load(MockModel.class, model1.getId());
 
         // Not equal to each other.
@@ -121,8 +121,8 @@ public void testHashCodeDifferentRows() {
 		Model m2 = new MockModel();
 		Model m3;
 
-		m1.save();
-		m2.save();
+		m1.saveOrUpdate();
+		m2.saveOrUpdate();
 		m3 = Model.load(MockModel.class, m1.getId());
 
 		assertEquals(m1.hashCode(), m3.hashCode());
@@ -139,11 +139,11 @@ public void testHashCodeDifferentRows() {
     public void testColumnNamesDefaulToFieldNames() {
         TableInfo tableInfo = Cache.getTableInfo(MockModel.class);
 
-        for ( Field field : tableInfo.getFields() ) {
+        for ( TableInfo.ColumnField columnField : tableInfo.getColumns() ) {
             // Id column is a special case, we'll ignore that one.
-            if ( field.getName().equals("mId") ) continue;
+            if ( columnField.getField().getName().equals("mId") ) continue;
 
-            assertEquals(field.getName(), tableInfo.getColumnName(field));
+            assertEquals(columnField.getField().getName(), columnField.getName());
         }
     }
 
@@ -153,7 +153,7 @@ public void testColumnNamesDefaulToFieldNames() {
     public void testBooleanColumnType() {
         MockModel mockModel = new MockModel();
         mockModel.booleanField = false;
-        Long id = mockModel.save();
+        Long id = mockModel.saveOrUpdate();
 
         boolean databaseBooleanValue = MockModel.load( MockModel.class, id ).booleanField;
 
@@ -172,31 +172,53 @@ public void testBooleanColumnType() {
 
         assertNull( new Select().from(MockModel.class).where("booleanField = ?", true).executeSingle() );
     }
+    /**
+     * Mock model as we need 2 different model classes.
+     */
+    @Table(name = "MatcherMockModel")
+    public static class MatcherMockModel extends Model {
+        @Column
+        public Date dateField;
+
+        @Column
+        public double doubleField;
+
+        @Column
+        public int intField;
 
-    /**public void testMatchValueColumn(){
-        MockModel m1 = new MockModel();
-        m1.matchField="testkey"
+        @Column
+        public boolean booleanField;
+
+        @Column
+        public String stringField;
+
+        @Column(matchvalue = true)
+        public String matchField;
+    }
+    public void testMatchValueColumn(){
+        MatcherMockModel m1 = new MatcherMockModel();
+        m1.matchField="testkey";
         m1.intField=45;
         m1.stringField="testField";
-        Long id = m1.save();
-
+        long id1 = m1.save();
+        Log.i("testing","id");
 
-        MockModel databaseMockModel = MockModel.load( MockModel.class, id );
+        MatcherMockModel  databaseMockModel = MatcherMockModel .load( MatcherMockModel .class, id1 );
         assertTrue(databaseMockModel.equals(m1));
+        assertTrue(id1!=-1);
 
-        MockModel m2 = new MockModel();
-        m2.matchField="testkey"
+        MatcherMockModel  m2 = new MatcherMockModel ();
+        m2.matchField="testkey";
         m2.intField=44;
         m2.stringField="testField2";
-        Long id2 = m2.save();
+        long id2 = m2.update();
+        databaseMockModel = MatcherMockModel .load( MatcherMockModel .class, id2 );
 
-        MockModel databaseMockModel = MockModel.load( MockModel.class, id );
+        assertFalse(databaseMockModel.stringField.equals(m1.stringField));
+        assertTrue(databaseMockModel.stringField.equals(m2.stringField));
+        assertTrue(m1.matchField==m2.matchField);
 
-        assertFalse(databaseMockModel.equals(m1));
-        assertTrue(databaseMockModel.equals(m2));
-        assertTrue(id1==id2);
-
-    }*/
+    }
 
 	/**
      * Test to check the join of two (or more) tables with some fields in common when not use a projection on select.
@@ -209,7 +231,7 @@ public void testJoinWithSameNames(){
         parent.dateField = new Date();
         parent.doubleField = 2.0;
         parent.intField = 1;
-        parent.save();
+        parent.saveOrUpdate();
 
         //the values to assign to child
         Date dateValue = new Date();
@@ -223,7 +245,7 @@ public void testJoinWithSameNames(){
         child1.doubleField = doubleValue;
         child1.intField = intValue;
         child1.parent = parent;
-        child1.save();
+        child1.saveOrUpdate();
 
         ChildMockModel child2 = new ChildMockModel();
         child2.booleanField = false;
@@ -231,7 +253,7 @@ public void testJoinWithSameNames(){
         child2.doubleField = doubleValue;
         child2.intField = intValue;
         child2.parent = parent;
-        child2.save();
+        child2.saveOrUpdate();
 
         //Store the ids assigned to child entities when persists
         List<Long> ids = new ArrayList<Long>();
diff --git a/tests/src/com/activeandroid/test/query/CountTest.java b/tests/src/com/activeandroid/test/query/CountTest.java
index f0617ce1..1bfe5d71 100644
--- a/tests/src/com/activeandroid/test/query/CountTest.java
+++ b/tests/src/com/activeandroid/test/query/CountTest.java
@@ -24,9 +24,9 @@ private void populateTable() {
         m2.intField = 1;
         m3.intField = 2;
 
-        m1.save();
-        m2.save();
-        m3.save();
+        m1.saveOrUpdate();
+        m2.saveOrUpdate();
+        m3.saveOrUpdate();
     }
 
     /**
diff --git a/tests/src/com/activeandroid/test/query/ExistsTest.java b/tests/src/com/activeandroid/test/query/ExistsTest.java
index e67d609a..e1b7b406 100644
--- a/tests/src/com/activeandroid/test/query/ExistsTest.java
+++ b/tests/src/com/activeandroid/test/query/ExistsTest.java
@@ -24,9 +24,9 @@ private void populateTable() {
         m2.intField = 1;
         m3.intField = 2;
 
-        m1.save();
-        m2.save();
-        m3.save();
+        m1.saveOrUpdate();
+        m2.saveOrUpdate();
+        m3.saveOrUpdate();
     }
 
     /**
