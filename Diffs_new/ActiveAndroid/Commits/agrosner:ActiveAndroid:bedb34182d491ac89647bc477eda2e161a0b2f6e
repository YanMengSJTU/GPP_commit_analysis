diff --git a/src/main/java/com/activeandroid/Cache.java b/src/main/java/com/activeandroid/Cache.java
index a2a5cf0d..08596331 100644
--- a/src/main/java/com/activeandroid/Cache.java
+++ b/src/main/java/com/activeandroid/Cache.java
@@ -46,17 +46,9 @@
 
 	private static boolean sIsInitialized = false;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	private Cache() {
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	public static synchronized void initialize(Configuration configuration) {
 		if (sIsInitialized) {
 			AALog.v("ActiveAndroid already initialized.");
@@ -131,7 +123,7 @@ public static synchronized IModelInfo getEntity(Class<? extends IModelInfo> type
 		return sEntities.get(getIdentifier(type, entityId));
 	}
 
-	public static synchronized void removeEntity(Model entity) {
+	public static synchronized void removeEntity(IModelInfo entity) {
 		sEntities.remove(getIdentifier(entity));
 	}
 
@@ -153,7 +145,11 @@ public static synchronized String getTableName(Class<? extends IModelInfo> type)
 		return sModelInfo.getTableInfo(type).getTableName();
 	}
 
-    public static synchronized ClassSerializer getClassSerializerForType(Class<?> type){
+    public static synchronized ClassSerializer getClassSerializerForType(Class<? extends IModelInfo> type){
+        //if we have model we load the default
+        if(Model.class.isAssignableFrom(type)){
+            return sModelInfo.getClassSerializer(Model.class);
+        }
         return sModelInfo.getClassSerializer(type);
     }
 }
diff --git a/src/main/java/com/activeandroid/IModelInfo.java b/src/main/java/com/activeandroid/IModelInfo.java
index 5cf816f5..62f24f3a 100644
--- a/src/main/java/com/activeandroid/IModelInfo.java
+++ b/src/main/java/com/activeandroid/IModelInfo.java
@@ -22,4 +22,6 @@
 
     public String getTableName();
 
+    public Class<? extends IModelInfo> getModelClass();
+
 }
diff --git a/src/main/java/com/activeandroid/Model.java b/src/main/java/com/activeandroid/Model.java
index 0e73496d..3961fe67 100644
--- a/src/main/java/com/activeandroid/Model.java
+++ b/src/main/java/com/activeandroid/Model.java
@@ -16,7 +16,6 @@
  * limitations under the License.
  */
 
-import com.activeandroid.content.ContentProvider;
 import com.activeandroid.query.Select;
 import com.activeandroid.util.SQLiteUtils;
 
@@ -24,26 +23,14 @@
 
 @SuppressWarnings("unchecked")
 public abstract class Model implements IModelInfo{
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	private TableInfo mTableInfo;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	public Model() {
 		mTableInfo = Cache.getTableInfo(getClass());
 	}
 
     private long mId;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
     /**
      * Use This method to return the values of your primary key, must be separated by comma delimiter in order of declaration
      * Also each object thats instance of {@link java.lang.Number} must be DataBaseUtils.sqlEscapeString(object.toString)
@@ -59,22 +46,18 @@ public final void delete() {
 
     @Override
 	public final void save() {
-        SQLiteUtils.save(this);
+        SQLiteUtils.save(Cache.getClassSerializerForType(Model.class), this);
 	}
 
     @Override
     public boolean exists(){
-        return SQLiteUtils.exists(this);
+        return SQLiteUtils.exists((Class<Model>) getClass(), this);
     }
 
    /* public void update(){
 
     }*/
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
     protected final <T extends Model> List<T> getManyFromField(Class<T> type,Object field, String foreignKey){
         return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", field).execute();
     }
@@ -83,10 +66,6 @@ public boolean exists(){
         return new Select().from(type).orderBy(sort).where(Cache.getTableName(type) + "." + foreignKey + "=?", field).execute();
     }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	@Override
 	public String toString() {
 		return mTableInfo!=null? mTableInfo.getTableName() + "@" + getId() : "No Table for: " + getClass() + "@" + getId();
@@ -110,4 +89,9 @@ public void setRowId(long id) {
     public String getTableName() {
         return mTableInfo.getTableName();
     }
+
+    @Override
+    public Class<?> getModelClass() {
+        return getClass();
+    }
 }
diff --git a/src/main/java/com/activeandroid/ModelInfo.java b/src/main/java/com/activeandroid/ModelInfo.java
index a275fae7..2cd5a130 100644
--- a/src/main/java/com/activeandroid/ModelInfo.java
+++ b/src/main/java/com/activeandroid/ModelInfo.java
@@ -54,7 +54,7 @@
 		}
 	};
 
-    private Map<Class<?>, ClassSerializer> mClassSerializers = new HashMap<Class<?>, ClassSerializer>() {
+    private Map<Class<? extends IModelInfo>, ClassSerializer> mClassSerializers = new HashMap<Class<? extends IModelInfo>, ClassSerializer>() {
         {
             put(Model.class, new ModelClassSerializer());
         }
@@ -93,7 +93,7 @@ public TypeSerializer getTypeSerializer(Class<?> type) {
 		return mTypeSerializers.get(type);
 	}
 
-    public ClassSerializer getClassSerializer(Class<?> type){
+    public ClassSerializer getClassSerializer(Class<? extends IModelInfo> type){
         return mClassSerializers.get(type);
     }
 
@@ -189,10 +189,16 @@ private void scanForModelClasses(File path, String packageName, ClassLoader clas
 		else {
 			String className = path.getName();
 
+            //ignore android system classes
+            if(className.startsWith("android.")){
+                return;
+            }
+
 			// Robolectric fallback
 			if (!path.getPath().equals(className)) {
 				className = path.getPath();
 
+                //we want to ignore android system classes for checking
 				if (className.endsWith(".class")) {
 					className = className.substring(0, className.length() - 6);
 				}
@@ -212,7 +218,8 @@ private void scanForModelClasses(File path, String packageName, ClassLoader clas
 
 			try {
 				Class<?> discoveredClass = Class.forName(className, false, classLoader);
-				if (ReflectionUtils.isModel(discoveredClass) && !discoveredClass.isAnnotationPresent(Ignore.class)) {
+				if (ReflectionUtils.isModel(discoveredClass) && !discoveredClass.isAnnotationPresent(Ignore.class)
+                        && !discoveredClass.equals(IModelInfo.class) && !discoveredClass.equals(Model.class)) {
 					@SuppressWarnings("unchecked")
 					Class<? extends IModelInfo> modelClass = (Class<? extends IModelInfo>) discoveredClass;
 					mTableInfos.put(modelClass, new TableInfo(modelClass));
diff --git a/src/main/java/com/activeandroid/TableInfo.java b/src/main/java/com/activeandroid/TableInfo.java
index 5d0fcc53..86dcae4c 100644
--- a/src/main/java/com/activeandroid/TableInfo.java
+++ b/src/main/java/com/activeandroid/TableInfo.java
@@ -62,7 +62,6 @@ public TableInfo(Class<? extends IModelInfo> type) {
 		List<Field> fields = new ArrayList<Field>();
         try {
             fields = ReflectionUtils.getAllFields(fields, Class.forName(type.getName()));
-            fields.add(getIdField(type));
         } catch (ClassNotFoundException e) {
             e.printStackTrace();
         }
@@ -95,10 +94,6 @@ public TableInfo(Class<? extends IModelInfo> type) {
         }
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	public Class<? extends IModelInfo> getType() {
 		return mType;
 	}
@@ -111,14 +106,21 @@ public String getTableName() {
         return mColumnNames.keySet().toArray(new Field[mColumnNames.size()]);
     }
 
+    public Field getFieldForName(String name){
+        Field field = null;
+        for(Field f: mColumnNames.keySet()){
+            if(f.getName().equals(name)){
+                field = f;
+                break;
+            }
+        }
+        return field;
+    }
+
 	public String getColumnName(Field field) {
 		return mColumnNames.get(field);
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	private Field getIdField(Class<?> type) {
 		if (type.equals(IModelInfo.class)) {
 			try {
diff --git a/src/main/java/com/activeandroid/content/ContentProvider.java b/src/main/java/com/activeandroid/content/ContentProvider.java
index 1299d65a..bfbd7d71 100644
--- a/src/main/java/com/activeandroid/content/ContentProvider.java
+++ b/src/main/java/com/activeandroid/content/ContentProvider.java
@@ -12,28 +12,18 @@
 import com.activeandroid.ActiveAndroid;
 import com.activeandroid.Cache;
 import com.activeandroid.Configuration;
+import com.activeandroid.IModelInfo;
 import com.activeandroid.Model;
 import com.activeandroid.TableInfo;
 
 public class ContentProvider extends android.content.ContentProvider {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
 
 	private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
-	private static final SparseArray<Class<? extends Model>> TYPE_CODES = new SparseArray<Class<? extends Model>>();
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+	private static final SparseArray<Class<? extends IModelInfo>> TYPE_CODES = new SparseArray<Class<? extends IModelInfo>>();
 
 	private static String sAuthority;
 	private static SparseArray<String> sMimeTypeCache = new SparseArray<String>();
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
 	@Override
 	public boolean onCreate() {
 		ActiveAndroid.initialize(getConfiguration());
@@ -67,7 +57,7 @@ public String getType(Uri uri) {
 			return cachedMimeType;
 		}
 
-		final Class<? extends Model> type = getModelType(uri);
+		final Class<? extends IModelInfo> type = getModelType(uri);
 		final boolean single = ((match % 2) == 0);
 
 		StringBuilder mimeType = new StringBuilder();
@@ -92,7 +82,7 @@ public String getType(Uri uri) {
 
 	@Override
 	public Uri insert(Uri uri, ContentValues values) {
-		final Class<? extends Model> type = getModelType(uri);
+		final Class<? extends IModelInfo> type = getModelType(uri);
 		final Long id = Cache.openDatabase().insert(Cache.getTableName(type), null, values);
 
 		if (id != null && id > 0) {
@@ -107,7 +97,7 @@ public Uri insert(Uri uri, ContentValues values) {
 
 	@Override
 	public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-		final Class<? extends Model> type = getModelType(uri);
+		final Class<? extends IModelInfo> type = getModelType(uri);
 		final int count = Cache.openDatabase().update(Cache.getTableName(type), values, selection, selectionArgs);
 
 		notifyChange(uri);
@@ -117,7 +107,7 @@ public int update(Uri uri, ContentValues values, String selection, String[] sele
 
 	@Override
 	public int delete(Uri uri, String selection, String[] selectionArgs) {
-		final Class<? extends Model> type = getModelType(uri);
+		final Class<? extends IModelInfo> type = getModelType(uri);
 		final int count = Cache.openDatabase().delete(Cache.getTableName(type), selection, selectionArgs);
 
 		notifyChange(uri);
@@ -127,7 +117,7 @@ public int delete(Uri uri, String selection, String[] selectionArgs) {
 
 	@Override
 	public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
-		final Class<? extends Model> type = getModelType(uri);
+		final Class<? extends IModelInfo> type = getModelType(uri);
 		final Cursor cursor = Cache.openDatabase().query(
 				Cache.getTableName(type),
 				projection,
@@ -146,7 +136,7 @@ public Cursor query(Uri uri, String[] projection, String selection, String[] sel
 	// PUBLIC METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	public static Uri createUri(Class<? extends Model> type, String id) {
+	public static Uri createUri(Class<? extends IModelInfo> type, String id) {
 		final StringBuilder uri = new StringBuilder();
 		uri.append("content://");
 		uri.append(sAuthority);
@@ -177,7 +167,7 @@ protected Configuration getConfiguration() {
 	// PRIVATE METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-	private Class<? extends Model> getModelType(Uri uri) {
+	private Class<? extends IModelInfo> getModelType(Uri uri) {
 		final int code = URI_MATCHER.match(uri);
 		if (code != UriMatcher.NO_MATCH) {
 			return TYPE_CODES.get(code);
diff --git a/src/main/java/com/activeandroid/exception/ClassSerializerNotFoundException.java b/src/main/java/com/activeandroid/exception/ClassSerializerNotFoundException.java
new file mode 100644
index 00000000..0abb1c08
--- /dev/null
+++ b/src/main/java/com/activeandroid/exception/ClassSerializerNotFoundException.java
@@ -0,0 +1,14 @@
+package com.activeandroid.exception;
+
+
+/**
+ * Created by andrewgrosner
+ * Date: 4/3/14
+ * Contributors:
+ * Description:
+ */
+public class ClassSerializerNotFoundException extends RuntimeException {
+    public ClassSerializerNotFoundException(String s) {
+        super(s);
+    }
+}
diff --git a/src/main/java/com/activeandroid/interfaces/ObjectRequester.java b/src/main/java/com/activeandroid/interfaces/ObjectRequester.java
index 111913e6..1c3b03ac 100644
--- a/src/main/java/com/activeandroid/interfaces/ObjectRequester.java
+++ b/src/main/java/com/activeandroid/interfaces/ObjectRequester.java
@@ -1,5 +1,6 @@
 package com.activeandroid.interfaces;
 
+import com.activeandroid.IModelInfo;
 import com.activeandroid.Model;
 
 /**
@@ -8,7 +9,7 @@
 * Contributors:
 * Description:
 */
-public interface ObjectRequester<OBJECT_CLASS extends Model>{
+public interface ObjectRequester<OBJECT_CLASS extends IModelInfo>{
     /**
      * Implement this method to perform a request if the object does not exist in the DB
      * @param objectReceiver
diff --git a/src/main/java/com/activeandroid/manager/SingleDBManager.java b/src/main/java/com/activeandroid/manager/SingleDBManager.java
index b296bba9..a47a81b6 100644
--- a/src/main/java/com/activeandroid/manager/SingleDBManager.java
+++ b/src/main/java/com/activeandroid/manager/SingleDBManager.java
@@ -5,7 +5,7 @@
 
 import com.activeandroid.ActiveAndroid;
 import com.activeandroid.Cache;
-import com.activeandroid.Model;
+import com.activeandroid.IModelInfo;
 import com.activeandroid.exception.DBManagerNotOnMainException;
 import com.activeandroid.interfaces.ObjectRequester;
 import com.activeandroid.query.Delete;
@@ -16,6 +16,7 @@
 import com.activeandroid.runtime.DBRequest;
 import com.activeandroid.runtime.DBRequestInfo;
 import com.activeandroid.runtime.DBRequestQueue;
+import com.activeandroid.serializer.ClassSerializer;
 import com.activeandroid.util.ReflectionUtils;
 import com.activeandroid.util.SQLiteUtils;
 
@@ -109,7 +110,7 @@ protected synchronized void processOnForeground(Runnable runnable){
         mRequestHandler.post(runnable);
     }
 
-    public <OBJECT_CLASS extends Model> OBJECT_CLASS getObject(Class<OBJECT_CLASS> obClazz, Object object){
+    public <OBJECT_CLASS extends IModelInfo> OBJECT_CLASS getObject(Class<OBJECT_CLASS> obClazz, Object object){
         try {
             return obClazz.getConstructor(object.getClass()).newInstance(object);
         } catch (Throwable e) {
@@ -122,7 +123,7 @@ protected synchronized void processOnForeground(Runnable runnable){
      * Adds an object to the manager's database
      * @param inObject - object of the class defined by the manager
      */
-    public <OBJECT_CLASS extends Model> OBJECT_CLASS add(OBJECT_CLASS inObject){
+    public <OBJECT_CLASS extends IModelInfo> OBJECT_CLASS add(OBJECT_CLASS inObject){
         inObject.save();
         return inObject;
     }
@@ -131,7 +132,7 @@ protected synchronized void processOnForeground(Runnable runnable){
      * Adds a json object to this class, however its advised you ensure that the jsonobject being passed is what you want, since there's no type checking
      * @param object
      */
-    public <OBJECT_CLASS extends Model> OBJECT_CLASS add(Class<OBJECT_CLASS> obClazz, Object object){
+    public <OBJECT_CLASS extends IModelInfo> OBJECT_CLASS add(Class<OBJECT_CLASS> obClazz, Object object){
         try {
             return add(getObject(obClazz,object));
         } catch (Throwable e) {
@@ -144,7 +145,7 @@ protected synchronized void processOnForeground(Runnable runnable){
      * Adds an object to the DB in the BG
      * @param jsonObject
      */
-    public <OBJECT_CLASS extends Model> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject, final ObjectReceiver<OBJECT_CLASS> objectReceiver){
+    public <OBJECT_CLASS extends IModelInfo> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject, final ObjectReceiver<OBJECT_CLASS> objectReceiver){
         OBJECT_CLASS object = getObject(obClazz, jsonObject);
         if(objectReceiver!=null){
             objectReceiver.onObjectReceived(object);
@@ -153,12 +154,12 @@ protected synchronized void processOnForeground(Runnable runnable){
 
     }
 
-    public <OBJECT_CLASS extends Model> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject){
+    public <OBJECT_CLASS extends IModelInfo> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject){
         addInBackground(obClazz, jsonObject,null);
     }
 
 
-    public <OBJECT_CLASS extends Model> void addInBackground(final OBJECT_CLASS object){
+    public <OBJECT_CLASS extends IModelInfo> void addInBackground(final OBJECT_CLASS object){
         getSaveQueue().add(object);
     }
 
@@ -166,7 +167,7 @@ protected synchronized void processOnForeground(Runnable runnable){
      * Adds all objects to the DB
      * @param objects
      */
-    public <OBJECT_CLASS extends Model, COLLECTION_CLASS extends Collection<OBJECT_CLASS>> void addAll(COLLECTION_CLASS objects){
+    public <OBJECT_CLASS extends IModelInfo, COLLECTION_CLASS extends Collection<OBJECT_CLASS>> void addAll(COLLECTION_CLASS objects){
         ActiveAndroid.beginTransaction();
         try{
             for(OBJECT_CLASS object: objects){
@@ -182,14 +183,20 @@ protected synchronized void processOnForeground(Runnable runnable){
      * Adds all objects from the passed object (if it has collection-like methods), may NOT be type-safe so be careful with this
      * @param array
      */
-    public <OBJECT_CLASS extends Model> void addAll(Class<OBJECT_CLASS> obClazz, Object array){
+    public <OBJECT_CLASS extends IModelInfo> void addAll(Class<OBJECT_CLASS> obClazz, Object array){
         ActiveAndroid.beginTransaction();
         try{
-            int count = ReflectionUtils.invokeGetSizeOfObject(array);
-            for(int i = 0; i < count;i++){
-                Object getObject = ReflectionUtils.invokeGetMethod(array, i);
-                OBJECT_CLASS object = obClazz.getConstructor(getObject.getClass()).newInstance(getObject);
-                add(object);
+
+            ClassSerializer classSerializer = Cache.getClassSerializerForType(obClazz);
+            if(classSerializer!=null && IModelInfo.class.isAssignableFrom(array.getClass())){
+                SQLiteUtils.save(classSerializer, (com.activeandroid.IModelInfo) array);
+            } else {
+                int count = ReflectionUtils.invokeGetSizeOfObject(array);
+                for (int i = 0; i < count; i++) {
+                    Object getObject = ReflectionUtils.invokeGetMethod(array, i);
+                    OBJECT_CLASS object = obClazz.getConstructor(getObject.getClass()).newInstance(getObject);
+                    add(object);
+                }
             }
             ActiveAndroid.setTransactionSuccessful();
         } catch (Throwable e) {
@@ -200,12 +207,12 @@ protected synchronized void processOnForeground(Runnable runnable){
 
     }
 
-    public <OBJECT_CLASS extends Model> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array) {
+    public <OBJECT_CLASS extends IModelInfo> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array) {
         addAllInBackground(obClazz, array, null);
     }
 
 
-    public <OBJECT_CLASS extends Model> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array, final CollectionReceiver<OBJECT_CLASS> collectionReceiver){
+    public <OBJECT_CLASS extends IModelInfo> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array, final CollectionReceiver<OBJECT_CLASS> collectionReceiver){
         processOnBackground(new DBRequest() {
             @Override
             public void run() {
@@ -231,7 +238,7 @@ public void run() {
 
     }
 
-    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends Model> void addAllInBackground(final COLLECTION_CLASS collection){
+    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModelInfo> void addAllInBackground(final COLLECTION_CLASS collection){
        getSaveQueue().addAll(collection);
     }
 
@@ -240,7 +247,7 @@ public void run() {
      * Its recommended not to call this method in the foreground thread
      * @return
      */
-    public <OBJECT_CLASS extends Model> List<OBJECT_CLASS> getAll(final Class<OBJECT_CLASS> obClazz){
+    public <OBJECT_CLASS extends IModelInfo> List<OBJECT_CLASS> getAll(final Class<OBJECT_CLASS> obClazz){
         return new Select().from(obClazz).execute();
     }
 
@@ -250,7 +257,7 @@ public void run() {
      * @param sort - valid SQLLite syntax for sort e.g. name ASC
      * @return
      */
-    public <OBJECT_CLASS extends Model> List<OBJECT_CLASS> getAllWithSort(Class<OBJECT_CLASS> obClazz, String sort){
+    public <OBJECT_CLASS extends IModelInfo> List<OBJECT_CLASS> getAllWithSort(Class<OBJECT_CLASS> obClazz, String sort){
         return new Select().from(obClazz).orderBy(sort).execute();
     }
 
@@ -258,7 +265,7 @@ public void run() {
      * Fetches objects from this DB on the BG
      * @param receiver - function to call when finished that passes the list of objects that was found
      */
-    public <OBJECT_CLASS extends Model> void fetchAll(final Class<OBJECT_CLASS> obClazz, final CollectionReceiver<OBJECT_CLASS> receiver){
+    public <OBJECT_CLASS extends IModelInfo> void fetchAll(final Class<OBJECT_CLASS> obClazz, final CollectionReceiver<OBJECT_CLASS> receiver){
         processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
             @Override
             public void run() {
@@ -278,7 +285,7 @@ public void run() {
      * @param sort - valid SQLLite syntax for sort e.g. name ASC
      * @param receiver - function to call when finished that passes the list of objects that was found
      */
-    public <OBJECT_CLASS extends Model> void fetchAllWithSort(final Class<OBJECT_CLASS> obClazz, final String sort, final CollectionReceiver<OBJECT_CLASS> receiver){
+    public <OBJECT_CLASS extends IModelInfo> void fetchAllWithSort(final Class<OBJECT_CLASS> obClazz, final String sort, final CollectionReceiver<OBJECT_CLASS> receiver){
         processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
             @Override
             public void run() {
@@ -293,7 +300,7 @@ public void run() {
         });
     };
 
-    public <OBJECT_CLASS extends Model> void fetchAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, final Object value, final String column, final CollectionReceiver<OBJECT_CLASS> receiver){
+    public <OBJECT_CLASS extends IModelInfo> void fetchAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, final Object value, final String column, final CollectionReceiver<OBJECT_CLASS> receiver){
         processOnBackground(new DBRequest(DBRequestInfo.create("fetch" , DBRequest.PRIORITY_UI)) {
             @Override
             public void run() {
@@ -312,8 +319,8 @@ public void run() {
      * This will get the where statement for this object, the amount of ids passed must match the primary key column size
      * @return
      */
-    public <OBJECT_CLASS extends Model> OBJECT_CLASS getObjectById(final Class<OBJECT_CLASS> obClazz, Object...ids){
-        return new Select().from(obClazz).where(SQLiteUtils.getWhereStatement(obClazz, Cache.getTableInfo(obClazz)), ids).executeSingle();
+    public <OBJECT_CLASS extends IModelInfo> OBJECT_CLASS getObjectById(final Class<OBJECT_CLASS> obClazz, Object...ids){
+        return new Select().from(obClazz).where(SQLiteUtils.getWhereStatementWithoutValues(Cache.getClassSerializerForType(obClazz), obClazz), ids).executeSingle();
     }
 
     /**
@@ -323,7 +330,7 @@ public void run() {
      * @param uid
      * @return
      */
-    public <OBJECT_CLASS extends Model> OBJECT_CLASS getObjectByColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object uid){
+    public <OBJECT_CLASS extends IModelInfo> OBJECT_CLASS getObjectByColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object uid){
         return new Select().from(obClazz).where(column+" =?", uid).executeSingle();
     }
 
@@ -333,7 +340,7 @@ public void run() {
      * @param value
      * @return
      */
-    public <OBJECT_CLASS extends Model> List<OBJECT_CLASS> getAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object value){
+    public <OBJECT_CLASS extends IModelInfo> List<OBJECT_CLASS> getAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object value){
         return new Select().from(obClazz).where(column + "= ?", value).execute();
     }
 
@@ -344,7 +351,7 @@ public void run() {
      * @param <OBJECT_CLASS>
      * @return
      */
-    public <OBJECT_CLASS extends Model> List<OBJECT_CLASS> getAllWithGroupby(final Class<OBJECT_CLASS> obClazz, String groupBy){
+    public <OBJECT_CLASS extends IModelInfo> List<OBJECT_CLASS> getAllWithGroupby(final Class<OBJECT_CLASS> obClazz, String groupBy){
         return new Select().from(obClazz).groupBy(groupBy).execute();
     }
 
@@ -352,7 +359,7 @@ public void run() {
      * Returns the count of rows from this DB manager's DB
      * @return
      */
-    public long getCount(final Class<? extends Model> obClazz){
+    public long getCount(final Class<? extends IModelInfo> obClazz){
         return DatabaseUtils.queryNumEntries(Cache.openDatabase(), Cache.getTableName(obClazz));
     }
 
@@ -360,7 +367,7 @@ public long getCount(final Class<? extends Model> obClazz){
      * Fetches the count on the DB thread and returns it on the handler
      * @param objectReceiver
      */
-    public <OBJECT_CLASS extends Model> void fetchCount(final Class<OBJECT_CLASS> obclazz, final ObjectReceiver<Long> objectReceiver){
+    public <OBJECT_CLASS extends IModelInfo> void fetchCount(final Class<OBJECT_CLASS> obclazz, final ObjectReceiver<Long> objectReceiver){
         processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
             @Override
             public void run() {
@@ -381,7 +388,7 @@ public void run() {
      * @param uid
      * @return true if the object exists in the DB, otherwise its on a BG thread
      */
-    public <OBJECT_CLASS extends Model> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectRequester<OBJECT_CLASS> requester,  final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
+    public <OBJECT_CLASS extends IModelInfo> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectRequester<OBJECT_CLASS> requester,  final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
         OBJECT_CLASS object = getObjectById(obClazz, uid);
         if(object==null&&requester!=null){
             processOnForeground(new Runnable() {
@@ -403,7 +410,7 @@ public void run() {
      * @param uid
      * @return true if the object exists in the DB, otherwise its on a BG thread
      */
-    public <OBJECT_CLASS extends Model> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
+    public <OBJECT_CLASS extends IModelInfo> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
        return fetchObject(obClazz, null, objectReceiver, uid);
     }
 
@@ -413,7 +420,7 @@ public void run() {
      * @param obClazz
      * @param <OBJECT_CLASS>
      */
-    public <OBJECT_CLASS extends Model> void deleteAll(Class<OBJECT_CLASS> obClazz){
+    public <OBJECT_CLASS extends IModelInfo> void deleteAll(Class<OBJECT_CLASS> obClazz){
         new Delete().from(obClazz).execute();
     }
 
@@ -421,7 +428,7 @@ public void run() {
      * Deletes objects from the db
      * @param <OBJECT_CLASS>
      */
-    public<OBJECT_CLASS extends Model> void deleteAll(OBJECT_CLASS...objects) {
+    public<OBJECT_CLASS extends IModelInfo> void deleteAll(OBJECT_CLASS...objects) {
         ActiveAndroid.beginTransaction();
         try{
             for(OBJECT_CLASS object: objects){
@@ -437,7 +444,7 @@ public void run() {
      * Deletes all objects from the collection specified
      * @param objects - the list of model objects you wish to delete
      */
-    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends Model> void deleteAll(COLLECTION_CLASS objects) {
+    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModelInfo> void deleteAll(COLLECTION_CLASS objects) {
         ActiveAndroid.beginTransaction();
         try{
             for(OBJECT_CLASS object: objects){
@@ -456,7 +463,7 @@ public void run() {
      * @param objects
      * @param <OBJECT_CLASS>
      */
-    public<LIST_CLASS extends List<OBJECT_CLASS>, OBJECT_CLASS extends Model> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final LIST_CLASS objects) {
+    public<LIST_CLASS extends List<OBJECT_CLASS>, OBJECT_CLASS extends IModelInfo> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final LIST_CLASS objects) {
         processOnBackground(new DBRequest(dbRequestInfo) {
             @Override
             public void run() {
@@ -475,7 +482,7 @@ public void run() {
      * @param objects
      * @param <OBJECT_CLASS>
      */
-    public<OBJECT_CLASS extends Model> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final OBJECT_CLASS...objects) {
+    public<OBJECT_CLASS extends IModelInfo> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final OBJECT_CLASS...objects) {
         processOnBackground(new DBRequest(dbRequestInfo) {
             @Override
             public void run() {
diff --git a/src/main/java/com/activeandroid/query/Delete.java b/src/main/java/com/activeandroid/query/Delete.java
index 6d19dced..274d9d68 100644
--- a/src/main/java/com/activeandroid/query/Delete.java
+++ b/src/main/java/com/activeandroid/query/Delete.java
@@ -16,13 +16,14 @@
  * limitations under the License.
  */
 
+import com.activeandroid.IModelInfo;
 import com.activeandroid.Model;
 
 public final class Delete implements Sqlable {
 	public Delete() {
 	}
 
-	public From from(Class<? extends Model> table) {
+	public From from(Class<? extends IModelInfo> table) {
 		return new From(table, this);
 	}
 
diff --git a/src/main/java/com/activeandroid/query/From.java b/src/main/java/com/activeandroid/query/From.java
index af93f912..49189688 100644
--- a/src/main/java/com/activeandroid/query/From.java
+++ b/src/main/java/com/activeandroid/query/From.java
@@ -19,6 +19,7 @@
 import android.database.DatabaseUtils;
 import android.text.TextUtils;
 import com.activeandroid.Cache;
+import com.activeandroid.IModelInfo;
 import com.activeandroid.Model;
 import com.activeandroid.query.Join.JoinType;
 import com.activeandroid.util.AALog;
@@ -31,7 +32,7 @@
 public final class From implements Sqlable {
 	private Sqlable mQueryBase;
 
-	private Class<? extends Model> mType;
+	private Class<? extends IModelInfo> mType;
 	private String mAlias;
 	private List<Join> mJoins;
 	private String mWhere;
@@ -43,7 +44,7 @@
 
 	private List<Object> mArguments;
 
-	public From(Class<? extends Model> table, Sqlable queryBase) {
+	public From(Class<? extends IModelInfo> table, Sqlable queryBase) {
 		mType = table;
 		mJoins = new ArrayList<Join>();
 		mQueryBase = queryBase;
@@ -214,7 +215,7 @@ public long executeCount(){
         }
     }
 
-	public <T extends Model> List<T> execute() {
+	public <T extends IModelInfo> List<T> execute() {
 		if (mQueryBase instanceof Select) {
 			return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
 		}
@@ -224,7 +225,7 @@ public long executeCount(){
 		}
 	}
 
-	public <T extends Model> T executeSingle() {
+	public <T extends IModelInfo> T executeSingle() {
 		if (mQueryBase instanceof Select) {
 			limit(1);
 			return SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
diff --git a/src/main/java/com/activeandroid/query/Select.java b/src/main/java/com/activeandroid/query/Select.java
index e3de2708..186885dd 100644
--- a/src/main/java/com/activeandroid/query/Select.java
+++ b/src/main/java/com/activeandroid/query/Select.java
@@ -18,6 +18,7 @@
 
 import android.text.TextUtils;
 
+import com.activeandroid.IModelInfo;
 import com.activeandroid.Model;
 
 public final class Select implements Sqlable {
@@ -64,7 +65,7 @@ public Select count(){
         return this;
     }
 
-	public From from(Class<? extends Model> table) {
+	public From from(Class<? extends IModelInfo> table) {
 		return new From(table, this);
 	}
 
diff --git a/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java b/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java
index 2cb5b4c4..142cbf6d 100644
--- a/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java
+++ b/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java
@@ -3,7 +3,7 @@
 import android.os.Looper;
 
 import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Model;
+import com.activeandroid.IModelInfo;
 import com.activeandroid.manager.SingleDBManager;
 import com.activeandroid.util.AALog;
 
@@ -27,12 +27,12 @@ public static DBBatchSaveQueue getSharedSaveQueue(){
         return mBatchSaveQueue;
     }
 
-    private final ArrayList<Model> mModels;
+    private final ArrayList<IModelInfo> mModels;
 
     public DBBatchSaveQueue(){
         super("DBBatchSaveQueue");
 
-        mModels = new ArrayList<Model>();
+        mModels = new ArrayList<IModelInfo>();
     }
 
     @Override
@@ -41,9 +41,9 @@ public void run() {
         Looper.prepare();
         android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
         while (true){
-            final ArrayList<Model> tmpModels;
+            final ArrayList<IModelInfo> tmpModels;
             synchronized (mModels){
-                tmpModels = new ArrayList<Model>(mModels);
+                tmpModels = new ArrayList<IModelInfo>(mModels);
                 mModels.clear();
             }
             if(tmpModels.size()>0) {
@@ -55,7 +55,7 @@ public void run() {
                         ActiveAndroid.beginTransaction();
                         try {
                             AALog.d("DBBatchSaveQueue", "Executing batch save of: " + tmpModels.size() + " on :" + Thread.currentThread().getName());
-                            for (Model model: tmpModels) {
+                            for (IModelInfo model: tmpModels) {
                                 model.save();
                             }
                             ActiveAndroid.setTransactionSuccessful();
@@ -77,19 +77,19 @@ public void run() {
         }
     }
 
-    public void add(final Model model){
+    public void add(final IModelInfo model){
         synchronized (mModels){
             mModels.add(model);
         }
     }
 
-    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends Model> void addAll(final COLLECTION_CLASS list){
+    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModelInfo> void addAll(final COLLECTION_CLASS list){
         synchronized (mModels){
             mModels.addAll(list);
         }
     }
 
-    public void remove(final Model model){
+    public void remove(final IModelInfo model){
         synchronized (mModels){
             mModels.remove(model);
         }
diff --git a/src/main/java/com/activeandroid/serializer/ClassSerializer.java b/src/main/java/com/activeandroid/serializer/ClassSerializer.java
index d2fb5700..3f04f4ee 100644
--- a/src/main/java/com/activeandroid/serializer/ClassSerializer.java
+++ b/src/main/java/com/activeandroid/serializer/ClassSerializer.java
@@ -1,15 +1,19 @@
 package com.activeandroid.serializer;
 
+import android.content.ContentValues;
+import android.database.Cursor;
+
 import com.activeandroid.Cache;
 import com.activeandroid.IModelInfo;
 import com.activeandroid.Model;
 import com.activeandroid.TableInfo;
 import com.activeandroid.annotation.ForeignKey;
 import com.activeandroid.annotation.PrimaryKey;
+import com.activeandroid.query.Select;
 import com.activeandroid.util.ReflectionUtils;
+import com.activeandroid.util.SQLiteUtils;
 
 import java.lang.reflect.Field;
-import java.lang.reflect.Type;
 
 /**
  * Created by andrewgrosner
@@ -24,37 +28,96 @@
      * @param position
      * @return
      */
-    public abstract Object serializeField(OBJECT_CLASS object, int position);
+    public void serializeField(ContentValues contentValues, OBJECT_CLASS object, int position){
+        TableInfo tableInfo = Cache.getTableInfo(object.getClass());
+        Field field = tableInfo.getFields()[position];
+        field.setAccessible(true);
+        String fieldName = tableInfo.getColumnName(field);
 
-    public abstract Object deserializeField(OBJECT_CLASS object, int position, String entityId, boolean columnIsNull);
+        Class<?> fieldType = field.getType();
 
-    public int getFieldCount(OBJECT_CLASS iModelInfo){
-        return Cache.getTableInfo(iModelInfo.getClass()).getFields().length;
+        if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(getFieldType(object, position))) {
+            ForeignKey key = field.getAnnotation(ForeignKey.class);
+            if (!key.name().equals("")) {
+                fieldName = key.name();
+            }
+        }
+
+        SQLiteUtils.applyToContentValues(contentValues, getFieldValue(object, position), fieldName, fieldType);
+    }
+
+    public Object getFieldValue(OBJECT_CLASS object, int position){
+        TableInfo tableInfo = Cache.getTableInfo(object.getClass());
+        Field field = tableInfo.getFields()[position];
+        field.setAccessible(true);
+
+        Object value = null;
+        try {
+            value = field.get(object);
+            if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(getFieldType(object, position))) {
+                value = ((Model) value).getId();
+            }
+        } catch (IllegalAccessException e) {
+
+        }
+        value = SQLiteUtils.getTypeSerializedValue(value);
+        return value;
     }
 
-    public String getFieldName(OBJECT_CLASS iModelInfo, int position){
-        TableInfo tableInfo = Cache.getTableInfo(iModelInfo.getClass());
+    public Object deserializeField(Cursor cursor, OBJECT_CLASS object, int position){
+
+        TableInfo tableInfo = Cache.getTableInfo(object.getClass());
         Field field = tableInfo.getFields()[position];
+        field.setAccessible(true);
+
+        Class fieldType = field.getType();
         String fieldName = tableInfo.getColumnName(field);
-        if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(getFieldType(position))) {
-            ForeignKey key = field.getAnnotation(ForeignKey.class);
-            if (!key.name().equals("")) {
-                fieldName = field.getAnnotation(ForeignKey.class).name();
+
+        int columnIndex = cursor.getColumnIndex(fieldName);
+
+        if(columnIndex<0){
+            return null;
+        }
+
+        boolean columnIsNull = cursor.isNull(columnIndex);
+        String entityId = cursor.getString(columnIndex);
+
+        TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+        if (typeSerializer != null) {
+            fieldType = typeSerializer.getSerializedType();
+        }
+        Object value = null;
+        if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
+            Model entity = (Model) Cache.getEntity(object.getClass(), entityId);
+            if (entity == null) {
+                entity = new Select().from(object.getClass()).where(SQLiteUtils.getWhereFromEntityId(object, entityId)).executeSingle();
             }
+
+            value = entity;
+        }
+
+        // Use a deserializer if one is available
+        if (typeSerializer != null && !columnIsNull) {
+            value = typeSerializer.deserialize(value);
         }
 
-        return fieldName;
+        return SQLiteUtils.loadValues(cursor, value, fieldType, columnIndex);
     }
 
-    public String getPrimaryFieldName(IModelInfo iModelInfo, int position){
-        return Cache.getTableInfo(iModelInfo.getClass()).getPrimaryKeys().get(position).getName();
+    public int getFieldCount(OBJECT_CLASS iModelInfo){
+        return Cache.getTableInfo(iModelInfo.getClass()).getFields().length;
     }
 
-    public int getPrimaryFieldCount(IModelInfo iModelInfo){
-        return Cache.getTableInfo(iModelInfo.getClass()).getPrimaryKeys().size();
+    public String getPrimaryFieldName(Class<? extends IModelInfo> iModelInfo, int position){
+        TableInfo tableInfo = Cache.getTableInfo(iModelInfo);
+        return tableInfo.getColumnName(tableInfo.getPrimaryKeys().get(position));
     }
 
-    public Class<?> getFieldType(IModelInfo iModelInfo, int position){
+    public int getPrimaryFieldCount(Class<? extends IModelInfo> iModelInfo){
+        return Cache.getTableInfo(iModelInfo).getPrimaryKeys().size();
+    }
+
+    public Class<?> getFieldType(OBJECT_CLASS iModelInfo, int position){
         return Cache.getTableInfo(iModelInfo.getClass()).getFields()[position].getType();
     }
 
@@ -73,8 +136,8 @@ public void applyPrimaryKeys(OBJECT_CLASS model){
         }
     }
 
-    public Class<OBJECT_CLASS> getTableType(OBJECT_CLASS object){
-        return (Class<OBJECT_CLASS>) Cache.getTableInfo(object.getClass()).getType();
+    public Class<?> getTableType(OBJECT_CLASS object){
+        return Cache.getTableInfo(object.getClass()).getType();
     }
 
     public void setField(int position, OBJECT_CLASS iModelInfo, Object value){
@@ -86,4 +149,6 @@ public void setField(int position, OBJECT_CLASS iModelInfo, Object value){
 
         }
     }
+
+    public abstract Class<?> getTableType();
 }
diff --git a/src/main/java/com/activeandroid/serializer/ModelClassSerializer.java b/src/main/java/com/activeandroid/serializer/ModelClassSerializer.java
index 57e8c387..632e979b 100644
--- a/src/main/java/com/activeandroid/serializer/ModelClassSerializer.java
+++ b/src/main/java/com/activeandroid/serializer/ModelClassSerializer.java
@@ -1,13 +1,8 @@
 package com.activeandroid.serializer;
 
-import com.activeandroid.Cache;
 import com.activeandroid.Model;
-import com.activeandroid.annotation.ForeignKey;
-import com.activeandroid.query.Select;
-import com.activeandroid.util.ReflectionUtils;
-import com.activeandroid.util.SQLiteUtils;
 
-import java.lang.reflect.Field;
+import java.lang.reflect.Type;
 
 /**
  * Created by andrewgrosner
@@ -17,56 +12,12 @@
  */
 public class ModelClassSerializer extends ClassSerializer<Model> {
 
-    private static ModelClassSerializer
-
     public ModelClassSerializer(){
 
     }
-    @Override
-    public Object serializeField(Model model, int position) {
-        Field field = model.getTableInfo().getFields()[position];
-        field.setAccessible(true);
-
-        Object value = null;
-        try {
-            value = field.get(model);
-            if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(getFieldType(model, position))) {
-                value = ((Model) value).getId();
-            }
-        } catch (IllegalAccessException e) {
-
-        }
-        return SQLiteUtils.getTypeSerializedValue(value);
-    }
 
     @Override
-    public Object deserializeField(Model model, int position, String entityId, boolean columnIsNull) {
-        Field field = mFields.get(position);
-        Class fieldType = getFieldType(position);
-        TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-        if (typeSerializer != null) {
-            fieldType = typeSerializer.getSerializedType();
-        }
-        Object value = null;
-        if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
-            Model entity = (Model) Cache.getEntity(model.getClass(), entityId);
-            if (entity == null) {
-                entity = new Select().from(model.getClass()).where(SQLiteUtils.getWhereFromEntityId(model.getId(), entityId)).executeSingle();
-            }
-
-            value = entity;
-        }
-
-        if (columnIsNull) {
-            field = null;
-        }
-
-        // Use a deserializer if one is available
-        if (typeSerializer != null && !columnIsNull) {
-            value = typeSerializer.deserialize(value);
-        }
-
-        return value;
+    public Class<?> getTableType() {
+        return Model.class;
     }
-
 }
diff --git a/src/main/java/com/activeandroid/util/ReflectionUtils.java b/src/main/java/com/activeandroid/util/ReflectionUtils.java
index 48b01048..7e85e2fb 100644
--- a/src/main/java/com/activeandroid/util/ReflectionUtils.java
+++ b/src/main/java/com/activeandroid/util/ReflectionUtils.java
@@ -35,7 +35,7 @@
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	public static boolean isModel(Class<?> type) {
-		return isSubclassOf(type, IModelInfo.class);
+		return doesImplement(type, IModelInfo.class);
 	}
 
 	public static boolean isTypeSerializer(Class<?> type) {
@@ -65,9 +65,14 @@ public static boolean isTypeClassSerializer(Class<?> type){
 		return null;
 	}
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    public static boolean doesImplement(Class<?> type, Class<?> superClass){
+        if(type==null){
+            return false;
+        } else if(superClass.isAssignableFrom(type)){
+            return true;
+        }
+        return doesImplement(type.getSuperclass(), superClass);
+    }
 
 	public static boolean isSubclassOf(Class<?> type, Class<?> superClass) {
 		if (type.getSuperclass() != null) {
diff --git a/src/main/java/com/activeandroid/util/SQLiteUtils.java b/src/main/java/com/activeandroid/util/SQLiteUtils.java
index dcdf4a18..3421627f 100644
--- a/src/main/java/com/activeandroid/util/SQLiteUtils.java
+++ b/src/main/java/com/activeandroid/util/SQLiteUtils.java
@@ -31,16 +31,15 @@
 import com.activeandroid.annotation.ForeignKey;
 import com.activeandroid.annotation.PrimaryKey;
 import com.activeandroid.content.ContentProvider;
+import com.activeandroid.exception.ClassSerializerNotFoundException;
 import com.activeandroid.exception.PrimaryKeyCannotBeNullException;
 import com.activeandroid.query.Select;
 import com.activeandroid.serializer.ClassSerializer;
-import com.activeandroid.serializer.ModelClassSerializer;
 import com.activeandroid.serializer.TypeSerializer;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 
@@ -100,7 +99,7 @@ public static void execSql(String sql, Object[] bindArgs) {
 		Cache.openDatabase().execSQL(sql, bindArgs);
 	}
 
-	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
+	public static <T extends IModelInfo> List<T> rawQuery(Class<? extends IModelInfo> type, String sql, String[] selectionArgs) {
 		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
 		List<T> entities = processCursor(type, cursor);
 		cursor.close();
@@ -108,7 +107,7 @@ public static void execSql(String sql, Object[] bindArgs) {
 		return entities;
 	}
 
-	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
+	public static <T extends IModelInfo> T rawQuerySingle(Class<? extends IModelInfo> type, String sql, String[] selectionArgs) {
 		List<T> entities = rawQuery(type, sql, selectionArgs);
 
 		if (entities.size() > 0) {
@@ -226,7 +225,7 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 	}
 
 	@SuppressWarnings("unchecked")
-	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
+	public static <T extends IModelInfo> List<T> processCursor(Class<? extends IModelInfo> type, Cursor cursor) {
 		final List<T> entities = new ArrayList<T>();
 
 		try {
@@ -237,8 +236,8 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 
 			if (cursor.moveToFirst()) {
 				do {
-					Model entity = (T) entityConstructor.newInstance();
-                    loadFromCursor(cursor, entity);
+					IModelInfo entity = (T) entityConstructor.newInstance();
+                    loadFromCursor(cursor, entity, Cache.getClassSerializerForType(entity.getClass()));
 					entities.add((T) entity);
 				}
 				while (cursor.moveToNext());
@@ -259,12 +258,15 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
      * @param tableInfo
      * @return
      */
-    public static String getWhereStatement(ClassSerializer classSerializer){
+    public static String getWhereStatementWithoutValues(ClassSerializer classSerializer, Class<? extends IModelInfo> iModelInfo){
+        if(classSerializer==null){
+            throw new ClassSerializerNotFoundException("You Must Define a Class Serializer for a class that does not directly inherit from Model for: " + Cache.getTableName(iModelInfo));
+        }
 
-        int count = classSerializer.getPrimaryFieldCount();
+        int count = classSerializer.getPrimaryFieldCount(iModelInfo);
         final StringBuilder where = new StringBuilder();
         for(int i = 0 ; i < count; i++){
-            where.append(classSerializer.getPrimaryFieldName(i));
+            where.append(classSerializer.getPrimaryFieldName(iModelInfo,i));
             where.append("=?");
 
             if(i < count-1){
@@ -284,11 +286,15 @@ public static String getWhereStatement(ClassSerializer classSerializer){
      * @return
      */
     public static String getWhereStatement(ClassSerializer classSerializer, IModelInfo model){
-        int count = classSerializer.getPrimaryFieldCount();
+        if(classSerializer==null){
+            throw new ClassSerializerNotFoundException("You Must Define a Class Serializer for a class that does not directly inherit from Model for: " + Cache.getTableName(model.getClass()));
+        }
+
+        int count = classSerializer.getPrimaryFieldCount(model.getModelClass());
 
         final StringBuilder where = new StringBuilder();
         for(int i = 0 ; i < count; i++){
-            where.append(classSerializer.getPrimaryFieldName(i));
+            where.append(classSerializer.getPrimaryFieldName(model.getModelClass(), i));
             where.append("=?");
 
             if(i < count-1){
@@ -300,9 +306,9 @@ public static String getWhereStatement(ClassSerializer classSerializer, IModelIn
 
         for(int i = 0; i < count; i++){
             try {
-                Object object = classSerializer.serializeField(model, i);
+                Object object = classSerializer.getFieldValue(model, i);
                 if(object==null){
-                    throw new PrimaryKeyCannotBeNullException("The primary key: " + classSerializer.getPrimaryFieldName(i) + "from " + model.getTableName() + " cannot be null.");
+                    throw new PrimaryKeyCannotBeNullException("The primary key: " + classSerializer.getPrimaryFieldName(model.getModelClass(), i) + "from " + model.getTableName()+ " cannot be null.");
                 } else if(object instanceof Number){
                     sql = sql.replaceFirst("\\?", object.toString());
                 } else {
@@ -317,12 +323,12 @@ public static String getWhereStatement(ClassSerializer classSerializer, IModelIn
         return sql;
     }
 
-    public static String getWhereFromEntityId(Class<? extends IModelInfo> model, String entityId){
+    public static String getWhereFromEntityId(IModelInfo model, String entityId){
         String[] primaries = entityId.split(",");
-        String whereString = getWhereStatement(model, Cache.getTableInfo(model));
+        String whereString = getWhereStatementWithoutValues(Cache.getClassSerializerForType(model.getClass()), model.getClass());
 
         List<Field> fields = new ArrayList<Field>();
-        fields = ReflectionUtils.getAllFields(fields, model);
+        fields = ReflectionUtils.getAllFields(fields, model.getClass());
 
         ArrayList<Field> primaryColumn = new ArrayList<Field>();
         for(Field field : fields){
@@ -356,125 +362,30 @@ public static String getWhereFromEntityId(Class<? extends IModelInfo> model, Str
     public static void save(ClassSerializer serializer, IModelInfo model){
         final SQLiteDatabase db = Cache.openDatabase();
         final ContentValues values = new ContentValues();
-        int count = serializer.getFieldCount();
+        int count = serializer.getFieldCount(model);
 
         for (int i =  0; i  < count; i++) {
-            String fieldName = serializer.getFieldName(i);
-            Class<?> fieldType = serializer.getFieldType(i);
-
-            try {
-                Object value = serializer.serializeField(model, i);
-
-                // TODO: Find a smarter way to do this? This if block is necessary because we
-                // can't know the type until runtime.
-                if (value == null) {
-                    values.putNull(fieldName);
-                }
-                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-                    values.put(fieldName, (Byte) value);
-                }
-                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-                    values.put(fieldName, (Short) value);
-                }
-                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-                    values.put(fieldName, (Integer) value);
-                }
-                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-                    values.put(fieldName, (Long) value);
-                }
-                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-                    values.put(fieldName, (Float) value);
-                }
-                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-                    values.put(fieldName, (Double) value);
-                }
-                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-                    values.put(fieldName, (Boolean) value);
-                }
-                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-                    values.put(fieldName, value.toString());
-                }
-                else if (fieldType.equals(String.class)) {
-                    values.put(fieldName, value.toString());
-                }
-                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-                    values.put(fieldName, (byte[]) value);
-                }
-                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-                    values.put(fieldName, ((Enum<?>) value).name());
-                }
-            }
-            catch (IllegalArgumentException e) {
-                AALog.e(e.getClass().getName(), e);
-            }
+            serializer.serializeField(values, model, i);
         }
 
         if(!model.exists()){
             model.setRowId(db.insert(model.getTableName(), null, values));
             serializer.applyPrimaryKeys(model);
         } else {
-            model.setRowId(db.update(model.getTableName(), values, SQLiteUtils.getWhereStatement(serializer), null));
+            model.setRowId(db.update(model.getTableName(), values, SQLiteUtils.getWhereStatement(serializer, model), null));
         }
 
         Cache.getContext().getContentResolver()
-                .notifyChange(ContentProvider.createUri(serializer.getTableType(), model.getId()), null);
+                .notifyChange(ContentProvider.createUri(serializer.getTableType(model), model.getId()), null);
     }
 
     public static final void loadFromCursor(Cursor cursor, IModelInfo model, ClassSerializer classSerializer){
 
-        int count = classSerializer.getFieldCount();
+        int count = classSerializer.getFieldCount(model);
 
         for (int i = 0; i < count; i++) {
-            final String fieldName = classSerializer.getFieldName(i);
-            Class<?> fieldType = classSerializer.getFieldType(i);
-            final int columnIndex = cursor.getColumnIndex(fieldName);
-
-            if (columnIndex < 0) {
-                continue;
-            }
             try {
-                boolean columnIsNull = cursor.isNull(columnIndex);
-                Object value = classSerializer.deserializeField(model, i, cursor.getString(columnIndex), columnIsNull);
-
-                // TODO: Find a smarter way to do this? This if block is necessary because we
-                // can't know the type until runtime.
-
-                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-                    value = cursor.getInt(columnIndex);
-                }
-                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-                    value = cursor.getInt(columnIndex);
-                }
-                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-                    value = cursor.getInt(columnIndex);
-                }
-                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-                    value = cursor.getLong(columnIndex);
-                }
-                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-                    value = cursor.getFloat(columnIndex);
-                }
-                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-                    value = cursor.getDouble(columnIndex);
-                }
-                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-                    value = cursor.getInt(columnIndex) != 0;
-                }
-                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-                    value = cursor.getString(columnIndex).charAt(0);
-                }
-                else if (fieldType.equals(String.class)) {
-                    value = cursor.getString(columnIndex);
-                }
-                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-                    value = cursor.getBlob(columnIndex);
-                }
-                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-                    @SuppressWarnings("rawtypes")
-                    final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-                    value = Enum.valueOf(enumType, cursor.getString(columnIndex));
-                }
-
+                Object value = classSerializer.deserializeField(cursor, model, i);
                 // Set the field name
                 if (value != null) {
                     classSerializer.setField(i, model, value);
@@ -483,9 +394,6 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
             catch (IllegalArgumentException e) {
                 AALog.e(e.getClass().getName(), e);
             }
-            catch (IllegalAccessException e) {
-                AALog.e(e.getClass().getName(), e);
-            }
             catch (SecurityException e) {
                 AALog.e(e.getClass().getName(), e);
             }
@@ -501,20 +409,20 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
      * @param model
      * @return
      */
-    public static boolean exists(Model model){
-        return (new Select().from(model.getClass()).where(SQLiteUtils.getWhereStatement(model, model.getTableInfo())).executeSingle())!=null;
+    public static <OBJECT_CLASS extends IModelInfo> boolean exists(Class<OBJECT_CLASS> modelClass, OBJECT_CLASS model){
+        return (new Select().from(modelClass).where(SQLiteUtils.getWhereStatement(Cache.getClassSerializerForType(modelClass), model)).executeSingle())!=null;
     }
 
     /**
      * Deletes a model
      * @param model
      */
-    public static void delete(Model model){
-        Cache.openDatabase().delete(model.getTableInfo().getTableName(), SQLiteUtils.getWhereStatement(model, model.getTableInfo()), null);
+    public static void delete(IModelInfo model){
+        Cache.openDatabase().delete(Cache.getTableName(model.getClass()), SQLiteUtils.getWhereStatement(Cache.getClassSerializerForType(model.getClass()), model), null);
         Cache.removeEntity(model);
 
         Cache.getContext().getContentResolver()
-                .notifyChange(ContentProvider.createUri(model.getTableInfo().getType(), model.getId()), null);
+                .notifyChange(ContentProvider.createUri(Cache.getTableInfo(model.getClass()).getType(), model.getId()), null);
     }
 
     /**
@@ -539,8 +447,96 @@ public static Object getTypeSerializedValue(Object outValue){
                                 typeSerializer.getSerializedType(), fieldType));
                     }
                 }
+            } else if(IModelInfo.class.isAssignableFrom(fieldType)){
+                IModelInfo iModelInfo = (IModelInfo) outValue;
+                iModelInfo.save();
             }
         }
         return outValue;
     }
+
+    public static void applyToContentValues(ContentValues values, Object value, String fieldName, Class<?> fieldType){
+        try {
+            // TODO: Find a smarter way to do this? This if block is necessary because we
+            // can't know the type until runtime.
+            if (value == null) {
+                values.putNull(fieldName);
+            }
+            else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                values.put(fieldName, (Byte) value);
+            }
+            else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                values.put(fieldName, (Short) value);
+            }
+            else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                values.put(fieldName, (Integer) value);
+            }
+            else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                values.put(fieldName, (Long) value);
+            }
+            else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                values.put(fieldName, (Float) value);
+            }
+            else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                values.put(fieldName, (Double) value);
+            }
+            else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                values.put(fieldName, (Boolean) value);
+            }
+            else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                values.put(fieldName, value.toString());
+            }
+            else if (fieldType.equals(String.class)) {
+                values.put(fieldName, value.toString());
+            }
+            else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                values.put(fieldName, (byte[]) value);
+            }
+            else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                values.put(fieldName, ((Enum<?>) value).name());
+            }
+        }
+        catch (IllegalArgumentException e) {
+            AALog.e(e.getClass().getName(), e);
+        }
+    }
+
+    public static Object loadValues(Cursor cursor, Object value, Class<?> fieldType, int columnIndex){
+        if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+            value = cursor.getInt(columnIndex);
+        }
+        else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+            value = cursor.getInt(columnIndex);
+        }
+        else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+            value = cursor.getInt(columnIndex);
+        }
+        else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+            value = cursor.getLong(columnIndex);
+        }
+        else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+            value = cursor.getFloat(columnIndex);
+        }
+        else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+            value = cursor.getDouble(columnIndex);
+        }
+        else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+            value = cursor.getInt(columnIndex) != 0;
+        }
+        else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+            value = cursor.getString(columnIndex).charAt(0);
+        }
+        else if (fieldType.equals(String.class)) {
+            value = cursor.getString(columnIndex);
+        }
+        else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+            value = cursor.getBlob(columnIndex);
+        }
+        else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+            @SuppressWarnings("rawtypes")
+            final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+            value = Enum.valueOf(enumType, cursor.getString(columnIndex));
+        }
+        return value;
+    }
 }
