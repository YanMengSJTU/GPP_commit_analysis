diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index e27fddfd..715fe7b9 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -149,24 +149,41 @@ public final Long save() {
 	}
 
 	/**
-	 * Inserts or replaces this row. If a unique constraint violation
-	 * occurs, then the original row is deleted and this one is inserted. 
-	 * Becareful that if the ID column is auto-incrementing, the new row will 
-	 * not have the same ID as the original one.  
-	 * @return The new ID or -1 on failure.
-	 * @see <a href="https://www.sqlite.org/lang_conflict.html">SQLite Conflict Resolution</a>
-	 */
-    public final Long replace() {
+     * Inserts or updates this object with a specified ID. If insertion fails,
+     * due to for example, duplication of ID, this method will attempt to update
+     * the existing row instead. Note that the entire operation is not atomic.
+     * If either the insertion or updating succeeds, this object will be
+     * assigned the specified ID. This object will not be modified in any way on
+     * failure. This "upsert" operation is desirable over "REPLACE" in that it
+     * doesn't result in deletion of an existing row, and thus does not trigger
+     * deletion of foreign children that has "ON DELETE CASCADE".
+     * 
+     * @param id
+     * @throws IllegalStateException
+     *             if this object already has an ID.
+     * @returns true on success; false on failure.
+     */
+    public final boolean upsert(long id) {
+        if (mId != null)
+            throw new IllegalStateException();
+        
         ContentValues values = createContentValues();
+        values.put(idName, id);
         SQLiteDatabase db = null;
         
         try {
             db = Cache.openDatabase();
-            long newID = db.replace(mTableInfo.getTableName(), null, values);
-            if (newID == -1L)
-                // returns -1 instead of null for backwards compatibility.
-                return -1L;
-            mId = newID;
+            long newID = db.insert(mTableInfo.getTableName(), null, values);
+            if (newID == -1L) {
+                // Don't update the ID so as to avoid triggering foreign
+                // keys ON UPDATE.
+                values.remove(idName);
+                int rows = db.update(mTableInfo.getTableName(), values, idName+"=" + id, null);
+                if (rows == 0)
+                    return  false;
+            }
+            // newID should be the same as id.
+            mId = id;
         }
         finally {
             if (db != null) 
@@ -175,7 +192,7 @@ public final Long replace() {
     
         Cache.getContext().getContentResolver()
                 .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-        return mId;
+        return true;
     }
 	
 	// Convenience methods
