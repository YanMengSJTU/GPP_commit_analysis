diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index 0de95a85..00000000
--- a/.gitignore
+++ /dev/null
@@ -1,39 +0,0 @@
-#Android generated
-bin
-gen
-lint.xml
-
-#Eclipse
-.project
-.classpath
-.settings
-.checkstyle
-
-#IntelliJ IDEA
-.idea
-*.iml
-*.ipr
-*.iws
-classes
-gen-external-apklibs
-
-#Maven
-target
-release.properties
-pom.xml.*
-
-#Ant
-ant.properties
-local.properties
-proguard.cfg
-proguard-project.txt
-
-#Other
-.DS_Store
-dist/
-tmp
-
-# Gradle
-.gradle
-/build
-/out
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
deleted file mode 100644
index 98f75ecf..00000000
--- a/.travis.yml
+++ /dev/null
@@ -1,11 +0,0 @@
-language: java
-jdk: oraclejdk7
-
-before_install:
-  # Gradle
-  - wget http://services.gradle.org/distributions/gradle-1.6-bin.zip
-  - unzip gradle-1.6-bin.zip
-  - export GRADLE_HOME=$PWD/gradle-1.6
-  - export PATH=$GRADLE_HOME/bin:$PATH
-
-script: gradle assemble
\ No newline at end of file
diff --git a/README.md b/README.md
index 21cb7693..1d79e4f3 100644
--- a/README.md
+++ b/README.md
@@ -2,57 +2,5 @@
 
 This repository is slated for deletion.  Please find other solutions.  
 
-[![Build Status](https://travis-ci.org/pardom/ActiveAndroid.png?branch=master)](https://travis-ci.org/pardom/ActiveAndroid) [![Stories in Ready](https://badge.waffle.io/pardom/ActiveAndroid.png)](http://waffle.io/pardom/ActiveAndroid)  
-# ActiveAndroid On Steroids
+Questions?  Email rzopensource@raizlabs.com
 
-ActiveAndroid On Steroids (a fork of ActiveAndroid) is an active record style ORM ([object relational mapper](http://en.wikipedia.org/wiki/Object-relational_mapping)). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like _save()_ and _delete()_.
-
-ActiveAndroid does so much more than this though (and now even more). Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration. 
-
-_ActiveAndroid On Steroids provides you with a completely thread-safe, priority-based DBRequestQueue, code-crushing DBManagers, and some other surprises "Sprinkled" in._
-
-## Documentation
-
-* [Getting started](http://github.com/agrosner/ActiveAndroid/wiki/Getting-started)
-* [Creating your database IModel](http://github.com/agrosner/ActiveAndroid/wiki/Creating-your-database-Model)
-* [Saving to the database](http://github.com/agrosner/ActiveAndroid/wiki/Saving-to-the-database)
-* [Querying the database](http://github.com/agrosner/ActiveAndroid/wiki/Querying-the-database)
-* [DB Managers] (http://github.com/agrosner/ActiveAndroid/wiki/DB-Managers)
-* [Type serializers](http://github.com/agrosner/ActiveAndroid/wiki/Type-serializers)
-* [Using the content provider](http://github.com/agrosner/ActiveAndroid/wiki/Using-the-content-provider)
-* [Schema migrations](http://github.com/agrosner/ActiveAndroid/wiki/Schema-migrations)
-* [Pre-populated-databases](http://github.com/agrosner/ActiveAndroid/wiki/Pre-populated-databases)
-
-## License
-
-[Apache Version 2.0](http://www.apache.org/licenses/LICENSE-2.0.html)
-
-    Copyright (C) 2010 Michael Pardo
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-
-## Contributing
-
-Please fork this repository and contribute back using [pull requests](http://github.com/agrosner/ActiveAndroid/pulls).
-
-Any requests will be happily looked at and contributors will be recognized here:
-
-_Be the first!_
-
-## Original Author
-
-Michael Pardo | www.michaelpardo.com | www.activeandroid.com
-
-## ActiveAndroid On Steroids Author
-
-Andrew Grosner | andrew@fuzzproductions.com
diff --git a/build.gradle b/build.gradle
deleted file mode 100644
index 8e6986f2..00000000
--- a/build.gradle
+++ /dev/null
@@ -1,27 +0,0 @@
-apply plugin: 'java'
-
-sourceCompatibility = 1.6
-
-jar.baseName = 'activeandroid'
-archivesBaseName = 'activeandroid'
-
-sourceSets {
-	main {
-		java {
-			srcDir 'src'
-		}
-	}
-}
-
-dependencies {
-	compile fileTree(dir: 'libs', include: '*.jar')
-}
-
-task sourcesJar(type: Jar) {
-    classifier = 'sources'
-    from sourceSets.main.allSource
-}
-
-artifacts {
-    archives sourcesJar
-}
\ No newline at end of file
diff --git a/build.xml b/build.xml
deleted file mode 100644
index b2b7bfa6..00000000
--- a/build.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0"?>
-<project name="ActiveAndroid" default="dist" basedir=".">
-
-	<property name="dist.dir"  value="dist" />
-    <property name="src.dir"   value="src" />
-	<property name="build.dir" value="bin" />
-	<property name="lib.dir"   value="libs"/>
-	
-	<target name="dist" depends="clean, package" />
-
-	<target name="clean">
-		<delete dir="${build.dir}" />
-		<delete dir="${dist.dir}" />
-	</target>
-
-	<target name="init">
-		<mkdir dir="${build.dir}"/>
-		<mkdir dir="${dist.dir}" />
-	</target>
-
-	<path id="classpath">
-        <fileset dir="${lib.dir}" includes="**/*.jar"/>
-    </path>
-    
-	<target name="compile">
-    	<javac srcdir="${src.dir}" destdir="${build.dir}" source="1.5" target="1.5" classpathref="classpath" debug="off" />
-	</target>
-		
-	<target name="package" depends="init, compile">
-		<jar destfile="${dist.dir}/ActiveAndroid.jar" basedir="${build.dir}"/>
-	</target>
-</project>
diff --git a/libs/android-support-v4.jar b/libs/android-support-v4.jar
deleted file mode 100644
index 428bdbc0..00000000
Binary files a/libs/android-support-v4.jar and /dev/null differ
diff --git a/libs/android.jar b/libs/android.jar
deleted file mode 100644
index 4274d2b0..00000000
Binary files a/libs/android.jar and /dev/null differ
diff --git a/pom-child.xml b/pom-child.xml
deleted file mode 100644
index 96ded224..00000000
--- a/pom-child.xml
+++ /dev/null
@@ -1,93 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-
-    <IModelVersion>4.0.0</IModelVersion>
-    <groupId>com.activeandroid</groupId>
-    <artifactId>activeandroid</artifactId>
-    <version>3.1-SNAPSHOT</version>
-    <packaging>jar</packaging>
-    <name>ActiveAndroid</name>
-
-    <licenses>
-        <license>
-            <name>The Apache Software License, Version 2.0</name>
-            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-            <distribution>repo</distribution>
-        </license>
-    </licenses>
-
-  <parent>
-    <groupId>com.activeandroid</groupId>
-    <artifactId>activeandroid-parent</artifactId>
-    <version>3.1-SNAPSHOT</version>
-    <relativePath>./pom.xml</relativePath>
-  </parent>
-
-    <scm>
-        <connection>scm:git:git@github.com:pardom/ActiveAndroid.git</connection>
-        <developerConnection>scm:git:git@github.com:pardom/ActiveAndroid.git</developerConnection>
-        <url>git@github.com:pardom/ActiveAndroid.git</url>
-    </scm>
-
-    <properties>
-        <java.version>1.6</java.version>
-        <platform.sdk>16</platform.sdk>
-        <platform.version>4.1.1.4</platform.version>
-        <platform.support-version>r7</platform.support-version>
-    </properties>
-
-    <dependencies>
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>android</artifactId>
-            <version>${platform.version}</version>
-            <scope>provided</scope>
-        </dependency>
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>android-test</artifactId>
-            <version>${platform.version}</version>
-            <scope>provided</scope>
-        </dependency>
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>support-v4</artifactId>
-            <version>${platform.support-version}</version>
-        </dependency>
-    </dependencies>
-
-    <build>
-        <sourceDirectory>src</sourceDirectory>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.14.1</version>
-            </plugin>
-            <plugin>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
-                <configuration>
-                    <source>${java.version}</source>
-                    <target>${java.version}</target>
-                </configuration>
-            </plugin>
-            <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-                <artifactId>android-maven-plugin</artifactId>
-                <version>3.6.0</version>
-                <configuration>
-                    <sdk>
-                        <path>${env.ANDROID_HOME}</path>
-                        <platform>${platform.sdk}</platform>
-                    </sdk>
-                </configuration>
-                <extensions>true</extensions>
-            </plugin>
-        </plugins>
-    </build>
-
-</project>
diff --git a/pom.xml b/pom.xml
deleted file mode 100644
index 151b1cff..00000000
--- a/pom.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <IModelVersion>4.0.0</IModelVersion>
-  <groupId>com.activeandroid</groupId>
-  <artifactId>activeandroid-parent</artifactId>
-  <version>3.1-SNAPSHOT</version>
-  <packaging>pom</packaging>
-  <name>ActiveAndroid - Parent</name>
-
-  <modules>
-    <module>pom-child.xml</module>
-    <module>tests</module>
-  </modules>
-
-    <properties>
-        <java.version>1.6</java.version>
-        <platform.sdk>16</platform.sdk>
-        <platform.version>4.1.1.4</platform.version>
-        <platform.support-version>r7</platform.support-version>
-    </properties>
-
-  <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-          <artifactId>android-maven-plugin</artifactId>
-          <version>3.6.0</version>
-        </plugin>
-        <plugin>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.1</version>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-  </build>
-</project>
diff --git a/src/main/java/com/activeandroid/ActiveAndroid.java b/src/main/java/com/activeandroid/ActiveAndroid.java
deleted file mode 100644
index d8e90523..00000000
--- a/src/main/java/com/activeandroid/ActiveAndroid.java
+++ /dev/null
@@ -1,117 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-
-import com.activeandroid.util.AALog;
-
-public final class ActiveAndroid {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void initialize(Context context, DatabaseHelperListener databaseHelperListener) {
-        //add app package name for searching by default
-        ModelPathManager.addPath(context.getPackageName());
-
-		initialize(new Configuration.Builder(context).create(), databaseHelperListener);
-    }
-
-    public static void initialize(Context context) {
-        initialize(context, null);
-    }
-
-	public static void initialize(Configuration configuration, DatabaseHelperListener databaseHelperListener) {
-		initialize(configuration, false, databaseHelperListener);
-	}
-
-    public static void initialize(Configuration configuration) {
-        initialize(configuration, null);
-    }
-
-	public static void initialize(Context context, boolean loggingEnabled, DatabaseHelperListener databaseHelperListener) {
-		initialize(new Configuration.Builder(context).create(), loggingEnabled,databaseHelperListener);
-	}
-
-    public static void initialize(Context context, boolean loggingEnabled) {
-        initialize(context, loggingEnabled,null);
-    }
-
-	public static void initialize(Configuration configuration, boolean loggingEnabled, DatabaseHelperListener databaseHelperListener) {
-		// Set logging enabled first
-		setLoggingEnabled(loggingEnabled);
-		Cache.initialize(configuration, databaseHelperListener);
-	}
-
-    public static void initialize(Configuration configuration, boolean loggingEnabled) {
-        initialize(configuration, loggingEnabled,null);
-    }
-
-	public static void clearCache() {
-		Cache.clear();
-	}
-
-	public static void dispose() {
-		Cache.dispose();
-	}
-
-    public static void reset(Context context){
-        Cache.reset(context);
-    }
-
-	public static void setLoggingEnabled(boolean enabled) {
-		AALog.setEnabled(enabled);
-	}
-
-	public static SQLiteDatabase getDatabase() {
-		return Cache.openDatabase();
-	}
-
-	public static void beginTransaction() {
-		Cache.openDatabase().beginTransaction();
-	}
-
-	public static void endTransaction() {
-		Cache.openDatabase().endTransaction();
-	}
-
-	public static void setTransactionSuccessful() {
-		Cache.openDatabase().setTransactionSuccessful();
-	}
-
-	public static boolean inTransaction() {
-		return Cache.openDatabase().inTransaction();
-	}
-
-	public static void execSQL(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSQL(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-
-    public static boolean checkDbIntegrity() {
-        return Cache.checkDbIntegrity();
-    }
-
-    public static void backupDB(Context context) {
-        Cache.backUpDB(context);
-    }
-}
diff --git a/src/main/java/com/activeandroid/Cache.java b/src/main/java/com/activeandroid/Cache.java
deleted file mode 100644
index 663df145..00000000
--- a/src/main/java/com/activeandroid/Cache.java
+++ /dev/null
@@ -1,218 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.database.sqlite.SQLiteStatement;
-import android.support.v4.util.LruCache;
-
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.AALog;
-
-import java.util.Collection;
-
-public final class Cache {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static final int DEFAULT_CACHE_SIZE = 1024;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static Context sContext;
-
-	private static ModelInfo sIModelInfo;
-	private static DatabaseHelper sDatabaseHelper;
-
-    private static Configuration sDatabaseConfiguration;
-
-	private static LruCache<String, IModel> sEntities;
-
-	private static boolean sIsInitialized = false;
-
-    private static boolean isUpgrading = false;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Cache() {
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static synchronized void initialize(Configuration configuration, DatabaseHelperListener databaseHelperListener) {
-		if (sIsInitialized) {
-			AALog.v("ActiveAndroid already initialized.");
-			return;
-		}
-
-        sDatabaseConfiguration = configuration;
-		sContext = configuration.getContext();
-		sIModelInfo = new ModelInfo(configuration);
-		sDatabaseHelper = new DatabaseHelper(configuration);
-        sDatabaseHelper.setListener(databaseHelperListener);
-
-		// TODO: It would be nice to override sizeOf here and calculate the memory
-		// actually used, however at this point it seems like the reflection
-		// required would be too costly to be of any benefit. We'll just set a max
-		// object size instead.
-		sEntities = new LruCache<String, IModel>(configuration.getCacheSize());
-
-		openDatabase();
-
-		sIsInitialized = true;
-
-		AALog.v("ActiveAndroid initialized successfully.");
-	}
-
-	public static synchronized void clear() {
-		sEntities.evictAll();
-		AALog.v("Cache cleared.");
-	}
-
-	public static synchronized void dispose() {
-		closeDatabase();
-
-		sEntities = null;
-		sIModelInfo = null;
-		sDatabaseHelper = null;
-
-		sIsInitialized = false;
-
-		AALog.v("ActiveAndroid disposed. Call initialize to use library.");
-	}
-
-    public static boolean checkDbIntegrity() {
-        return checkDbIntegrity(sDatabaseHelper);
-    }
-
-    public static boolean checkDbIntegrity(DatabaseHelper helper) {
-        boolean ok = true;
-        String sql = "Pragma quick_check(1)";
-        SQLiteStatement statement = helper.getWritableDatabase().compileStatement(sql);
-
-        try {
-            String result = statement.simpleQueryForString();
-            if (!result.equalsIgnoreCase("ok")) {
-                ok = helper.restoreBackUp(sContext);
-            }
-        } finally {
-            if (statement != null) {
-                statement.close();
-            }
-        }
-
-        return ok;
-    }
-
-    public static boolean checkDbIntegrity(SQLiteOpenHelper helper) {
-        boolean ok = true;
-        String sql = "Pragma quick_check(1)";
-        SQLiteStatement statement = helper.getWritableDatabase().compileStatement(sql);
-
-        try {
-            String result = statement.simpleQueryForString();
-            if (!result.equalsIgnoreCase("ok")) {
-                ok = false;
-            }
-        } finally {
-            if (statement != null) {
-                statement.close();
-            }
-        }
-
-        return ok;
-    }
-
-	// Database access
-
-	public static synchronized SQLiteDatabase openDatabase() {
-		return sDatabaseHelper.getWritableDatabase();
-	}
-
-	public static synchronized void closeDatabase() {
-		sDatabaseHelper.close();
-	}
-
-	// Context access
-
-	public static Context getContext() {
-		return sContext;
-	}
-
-	// Entity cache
-
-	public static String getIdentifier(Class<? extends IModel> type, String entityId) {
-		return getTableName(type) + "@" + entityId;
-	}
-
-	public static String getIdentifier(IModel entity) {
-		return getIdentifier(entity.getClass(), entity.getId());
-	}
-
-	public static synchronized void addEntity(IModel entity) {
-		sEntities.put(getIdentifier(entity), entity);
-	}
-
-	public static synchronized IModel getEntity(Class<? extends IModel> type, String entityId) {
-		return sEntities.get(getIdentifier(type, entityId));
-	}
-
-	public static synchronized void removeEntity(IModel entity) {
-		sEntities.remove(getIdentifier(entity));
-	}
-
-	// IModel cache
-
-	public static synchronized Collection<TableInfo> getTableInfos() {
-		return sIModelInfo.getTableInfos();
-	}
-
-	public static synchronized TableInfo getTableInfo(Class<? extends IModel> type) {
-		return sIModelInfo.getTableInfo(type);
-	}
-
-	public static synchronized TypeSerializer getParserForType(Class<?> type) {
-		return sIModelInfo.getTypeSerializer(type);
-	}
-
-	public static synchronized String getTableName(Class<? extends IModel> type) {
-		return sIModelInfo.getTableInfo(type).getTableName();
-	}
-
-    public static void reset(Context context) {
-        if(!isUpgrading) {
-            sIsInitialized = false;
-            isUpgrading = true;
-            context.deleteDatabase(sDatabaseConfiguration.getDatabaseName());
-            initialize(sDatabaseConfiguration, sDatabaseHelper.mListener);
-            isUpgrading = false;
-        }
-    }
-
-    public static void backUpDB(Context context) {
-        sDatabaseHelper.backupDB(context);
-    }
-}
diff --git a/src/main/java/com/activeandroid/Configuration.java b/src/main/java/com/activeandroid/Configuration.java
deleted file mode 100644
index 3b371557..00000000
--- a/src/main/java/com/activeandroid/Configuration.java
+++ /dev/null
@@ -1,302 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import android.content.Context;
-
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.AALog;
-import com.activeandroid.util.ReflectionUtils;
-
-public class Configuration {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Context mContext;
-	private String mDatabaseName;
-	private int mDatabaseVersion;
-	private List<Class<? extends IModel>> mModelClasses;
-	private List<Class<? extends TypeSerializer>> mTypeSerializers;
-	private int mCacheSize;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Configuration(Context context) {
-		mContext = context;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Context getContext() {
-		return mContext;
-	}
-
-	public String getDatabaseName() {
-		return mDatabaseName;
-	}
-
-	public int getDatabaseVersion() {
-		return mDatabaseVersion;
-	}
-
-	public List<Class<? extends IModel>> getModelClasses() {
-		return mModelClasses;
-	}
-
-	public List<Class<? extends TypeSerializer>> getTypeSerializers() {
-		return mTypeSerializers;
-	}
-
-	public int getCacheSize() {
-		return mCacheSize;
-	}
-
-	public boolean isValid() {
-		return mModelClasses != null && mModelClasses.size() > 0;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// INNER CLASSES
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static class Builder {
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PRIVATE CONSTANTS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		private static final String AA_DB_NAME = "AA_DB_NAME";
-		private static final String AA_DB_VERSION = "AA_DB_VERSION";
-		private final static String AA_MODELS = "AA_MODELS";
-		private final static String AA_SERIALIZERS = "AA_SERIALIZERS";
-
-		private static final int DEFAULT_CACHE_SIZE = 1024;
-		private static final String DEFAULT_DB_NAME = "Application.db";
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PRIVATE MEMBERS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		private Context mContext;
-
-		private Integer mCacheSize;
-		private String mDatabaseName;
-		private Integer mDatabaseVersion;
-		private List<Class<? extends IModel>> mModelClasses;
-		private List<Class<? extends TypeSerializer>> mTypeSerializers;
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// CONSTRUCTORS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		public Builder(Context context) {
-			mContext = context.getApplicationContext();
-			mCacheSize = DEFAULT_CACHE_SIZE;
-		}
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PUBLIC METHODS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		public Builder setCacheSize(int cacheSize) {
-			mCacheSize = cacheSize;
-			return this;
-		}
-
-		public Builder setDatabaseName(String databaseName) {
-			mDatabaseName = databaseName;
-			return this;
-		}
-
-		public Builder setDatabaseVersion(int databaseVersion) {
-			mDatabaseVersion = databaseVersion;
-			return this;
-		}
-
-		public Builder addModelClass(Class<? extends IModel> modelClass) {
-			if (mModelClasses == null) {
-				mModelClasses = new ArrayList<Class<? extends IModel>>();
-			}
-
-			mModelClasses.add(modelClass);
-			return this;
-		}
-
-		public Builder addModelClasses(Class<? extends IModel>... modelClasses) {
-			if (mModelClasses == null) {
-				mModelClasses = new ArrayList<Class<? extends IModel>>();
-			}
-
-			mModelClasses.addAll(Arrays.asList(modelClasses));
-			return this;
-		}
-
-		public Builder setModelClasses(Class<? extends IModel>... modelClasses) {
-			mModelClasses = Arrays.asList(modelClasses);
-			return this;
-		}
-
-		public Builder addTypeSerializer(Class<? extends TypeSerializer> typeSerializer) {
-			if (mTypeSerializers == null) {
-				mTypeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
-			}
-
-			mTypeSerializers.add(typeSerializer);
-			return this;
-		}
-
-		public Builder addTypeSerializers(Class<? extends TypeSerializer>... typeSerializers) {
-			if (mTypeSerializers == null) {
-				mTypeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
-			}
-
-			mTypeSerializers.addAll(Arrays.asList(typeSerializers));
-			return this;
-		}
-
-		public Builder setTypeSerializers(Class<? extends TypeSerializer>... typeSerializers) {
-			mTypeSerializers = Arrays.asList(typeSerializers);
-			return this;
-		}
-
-		public Configuration create() {
-			Configuration configuration = new Configuration(mContext);
-			configuration.mCacheSize = mCacheSize;
-
-			// Get database name from meta-data
-			if (mDatabaseName != null) {
-				configuration.mDatabaseName = mDatabaseName;
-			}
-			else {
-				configuration.mDatabaseName = getMetaDataDatabaseNameOrDefault();
-			}
-
-			// Get database version from meta-data
-			if (mDatabaseVersion != null) {
-				configuration.mDatabaseVersion = mDatabaseVersion;
-			}
-			else {
-				configuration.mDatabaseVersion = getMetaDataDatabaseVersionOrDefault();
-			}
-
-			// Get model classes from meta-data
-			if (mModelClasses != null) {
-				configuration.mModelClasses = mModelClasses;
-			}
-			else {
-				final String modelList = ReflectionUtils.getMetaData(mContext, AA_MODELS);
-				if (modelList != null) {
-					configuration.mModelClasses = loadModelList(modelList.split(","));
-				}
-			}
-
-			// Get type serializer classes from meta-data
-			if (mTypeSerializers != null) {
-				configuration.mTypeSerializers = mTypeSerializers;
-			}
-			else {
-				final String serializerList = ReflectionUtils.getMetaData(mContext, AA_SERIALIZERS);
-				if (serializerList != null) {
-					configuration.mTypeSerializers = loadSerializerList(serializerList.split(","));
-				}
-			}
-
-			return configuration;
-		}
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PRIVATE METHODS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		// Meta-data methods
-
-		private String getMetaDataDatabaseNameOrDefault() {
-			String aaName = ReflectionUtils.getMetaData(mContext, AA_DB_NAME);
-			if (aaName == null) {
-				aaName = DEFAULT_DB_NAME;
-			}
-
-			return aaName;
-		}
-
-		private int getMetaDataDatabaseVersionOrDefault() {
-			Integer aaVersion = ReflectionUtils.getMetaData(mContext, AA_DB_VERSION);
-			if (aaVersion == null || aaVersion == 0) {
-				aaVersion = 1;
-			}
-
-			return aaVersion;
-		}
-
-		private List<Class<? extends IModel>> loadModelList(String[] models) {
-			final List<Class<? extends IModel>> modelClasses = new ArrayList<Class<? extends IModel>>();
-			final ClassLoader classLoader = mContext.getClass().getClassLoader();
-			for (String model : models) {
-				model = ensurePackageInName(model);
-
-				try {
-					Class modelClass = Class.forName(model, false, classLoader);
-					if (ReflectionUtils.isModel(modelClass)) {
-						modelClasses.add(modelClass);
-					}
-				}
-				catch (ClassNotFoundException e) {
-					AALog.e("Couldn't create class.", e);
-				}
-			}
-
-			return modelClasses;
-		}
-
-		private List<Class<? extends TypeSerializer>> loadSerializerList(String[] serializers) {
-			final List<Class<? extends TypeSerializer>> typeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
-			final ClassLoader classLoader = mContext.getClass().getClassLoader();
-			for (String serializer : serializers) {
-				serializer = ensurePackageInName(serializer);
-
-				try {
-					Class serializerClass = Class.forName(serializer, false, classLoader);
-					if (ReflectionUtils.isTypeSerializer(serializerClass)) {
-						typeSerializers.add(serializerClass);
-					}
-				}
-				catch (ClassNotFoundException e) {
-					AALog.e("Couldn't create class.", e);
-				}
-			}
-
-			return typeSerializers;
-		}
-
-		private String ensurePackageInName(String name) {
-			String packageName = mContext.getPackageName();
-			if (name.startsWith(packageName)) {
-				return name.trim();
-			}
-
-			return packageName + name.trim();
-		}
-	}
-}
diff --git a/src/main/java/com/activeandroid/DatabaseHelper.java b/src/main/java/com/activeandroid/DatabaseHelper.java
deleted file mode 100644
index 6efb10ab..00000000
--- a/src/main/java/com/activeandroid/DatabaseHelper.java
+++ /dev/null
@@ -1,339 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-
-import com.activeandroid.manager.SingleDBManager;
-import com.activeandroid.runtime.DBRequest;
-import com.activeandroid.runtime.DBRequestInfo;
-import com.activeandroid.util.AALog;
-import com.activeandroid.util.NaturalOrderComparator;
-import com.activeandroid.util.SQLiteUtils;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-public class DatabaseHelper extends SQLiteOpenHelper {
-    //////////////////////////////////////////////////////////////////////////////////////
-    // PUBLIC CONSTANTS
-    //////////////////////////////////////////////////////////////////////////////////////
-
-    public final static String MIGRATION_PATH = "migrations";
-
-    public final static String TEMP_DB_NAME = "temp-";
-
-    private SQLiteOpenHelper mTempDatabase;
-
-    private String mDatabaseName;
-
-    DatabaseHelperListener mListener;
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // CONSTRUCTORS
-    //////////////////////////////////////////////////////////////////////////////////////
-
-    public DatabaseHelper(Configuration configuration) {
-        super(configuration.getContext(), configuration.getDatabaseName(), null, configuration.getDatabaseVersion());
-        mDatabaseName = configuration.getDatabaseName();
-        copyAttachedDatabase(configuration.getContext(), configuration.getDatabaseName(), configuration.getDatabaseName());
-
-        // temporary database uses the same methods
-        mTempDatabase = new SQLiteOpenHelper(configuration.getContext(), TEMP_DB_NAME + configuration.getDatabaseName(),
-                null, configuration.getDatabaseVersion()) {
-
-            @Override
-            public void onOpen(SQLiteDatabase db) {
-                executePragmas(db);
-            }
-
-            @Override
-            public void onCreate(SQLiteDatabase db) {
-                executePragmas(db);
-                executeCreate(db);
-                executeMigrations(db, -1, db.getVersion());
-            }
-
-            @Override
-            public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-                executePragmas(db);
-                executeCreate(db);
-                executeMigrations(db, oldVersion, newVersion);
-            }
-        };
-        // see if we need to make this mirror the prepackaged
-        restoreDatabase(configuration.getContext(), TEMP_DB_NAME + configuration.getDatabaseName(), configuration.getDatabaseName());
-        mTempDatabase.getWritableDatabase();
-    }
-
-    public void setListener(DatabaseHelperListener listener) {
-        mListener = listener;
-    }
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // OVERRIDEN METHODS
-    //////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    public void onOpen(SQLiteDatabase db) {
-        if (mListener != null) {
-            mListener.onOpen(db);
-        }
-        executePragmas(db);
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        if (mListener != null) {
-            mListener.onCreate(db);
-        }
-        executePragmas(db);
-        executeCreate(db);
-        executeMigrations(db, -1, db.getVersion());
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        if (mListener != null) {
-            mListener.onUpgrade(db, oldVersion, newVersion);
-        }
-        executePragmas(db);
-        executeCreate(db);
-        executeMigrations(db, oldVersion, newVersion);
-    }
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // PUBLIC METHODS
-    //////////////////////////////////////////////////////////////////////////////////////
-
-    public void copyAttachedDatabase(Context context, String databaseName, String prepackagedName) {
-        final File dbPath = context.getDatabasePath(databaseName);
-
-        // If the database already exists, return
-        if (dbPath.exists() && Cache.checkDbIntegrity(this)) {
-            return;
-        }
-
-        // Make sure we have a path to the file
-        dbPath.getParentFile().mkdirs();
-
-        // Try to copy database file
-        try {
-            // check existing and use that as backup
-            File existingDb = context.getDatabasePath(TEMP_DB_NAME + getDatabaseName());
-            InputStream inputStream;
-            // if it exists and the integrity is ok
-            if (existingDb.exists() && Cache.checkDbIntegrity(mTempDatabase)) {
-                inputStream = new FileInputStream(existingDb);
-            } else {
-                inputStream = context.getAssets().open(prepackagedName);
-            }
-            writeDB(dbPath, inputStream);
-        } catch (IOException e) {
-            AALog.e(e.getMessage());
-        }
-    }
-
-    public void restoreDatabase(Context context, String databaseName, String prepackagedName) {
-        final File dbPath = context.getDatabasePath(databaseName);
-
-        // If the database already exists, return
-        if (dbPath.exists()) {
-            return;
-        }
-
-        // Make sure we have a path to the file
-        dbPath.getParentFile().mkdirs();
-
-        // Try to copy database file
-        try {
-            // check existing and use that as backup
-            File existingDb = context.getDatabasePath(getDatabaseName());
-            InputStream inputStream;
-            // if it exists and the integrity is ok
-            if (existingDb.exists() && Cache.checkDbIntegrity(this)) {
-                inputStream = new FileInputStream(existingDb);
-            } else {
-                inputStream = context.getAssets().open(prepackagedName);
-            }
-            writeDB(dbPath, inputStream);
-        } catch (IOException e) {
-            AALog.e(e.getMessage());
-        }
-    }
-
-    private void writeDB(File dbPath, InputStream existingDB) throws IOException {
-        final OutputStream output = new FileOutputStream(dbPath);
-
-        byte[] buffer = new byte[1024];
-        int length;
-
-        while ((length = existingDB.read(buffer)) > 0) {
-            output.write(buffer, 0, length);
-        }
-
-        output.flush();
-        output.close();
-        existingDB.close();
-    }
-
-
-    public String getDatabaseName() {
-        return mDatabaseName;
-    }
-
-    /**
-     * If integrity check fails, this method will use the backup db.
-     *
-     * @param context
-     */
-    public boolean restoreBackUp(Context context) {
-        boolean success = true;
-
-        File db = context.getDatabasePath(TEMP_DB_NAME + mDatabaseName);
-        File corrupt = context.getDatabasePath(mDatabaseName);
-        if (corrupt.delete()) {
-            try {
-                writeDB(corrupt, new FileInputStream(db));
-            } catch (IOException e) {
-                AALog.e(e.getMessage());
-                success = false;
-            }
-        } else {
-            AALog.e("Failed to delete DB");
-        }
-        return success;
-    }
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // PRIVATE METHODS
-    //////////////////////////////////////////////////////////////////////////////////////
-
-    protected void executePragmas(SQLiteDatabase db) {
-        if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
-            db.execSQL("PRAGMA foreign_keys=ON;");
-            AALog.i("Foreign Keys supported. Enabling foreign key features.");
-        }
-    }
-
-    protected void executeCreate(SQLiteDatabase db) {
-        db.beginTransaction();
-        try {
-            for (TableInfo tableInfo : Cache.getTableInfos()) {
-                db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
-            }
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-        }
-    }
-
-    protected boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
-        boolean migrationExecuted = false;
-        try {
-            final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
-            Collections.sort(files, new NaturalOrderComparator());
-
-            db.beginTransaction();
-            try {
-                for (String file : files) {
-                    try {
-                        final int version = Integer.valueOf(file.replace(".sql", ""));
-
-                        if (version > oldVersion && version <= newVersion) {
-                            executeSqlScript(db, file);
-                            migrationExecuted = true;
-
-                            AALog.i(file + " executed succesfully.");
-                        }
-                    } catch (NumberFormatException e) {
-                        AALog.w("Skipping invalidly named file: " + file, e);
-                    }
-                }
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-        } catch (IOException e) {
-            AALog.e("Failed to execute migrations.", e);
-        }
-
-        return migrationExecuted;
-    }
-
-    protected void executeSqlScript(SQLiteDatabase db, String file) {
-        try {
-            final InputStream input = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
-            final BufferedReader reader = new BufferedReader(new InputStreamReader(input));
-            String line = null;
-
-            while ((line = reader.readLine()) != null) {
-                db.execSQL(line.replace(";", ""));
-            }
-        } catch (IOException e) {
-            AALog.e("Failed to execute " + file, e);
-        }
-    }
-
-    /**
-     * Saves the database as a backup
-     */
-    public void backupDB(final Context context) {
-        // highest priority ever!
-        SingleDBManager.getSharedInstance().getQueue().add(new DBRequest(DBRequestInfo.create(DBRequest.PRIORITY_UI + 1)) {
-            @Override
-            public void run() {
-                File backup = context.getDatabasePath(TEMP_DB_NAME + mDatabaseName);
-                File temp = context.getDatabasePath(TEMP_DB_NAME + "-2-" + mDatabaseName);
-
-                // if exists we want to delete it before rename
-                if(temp.exists()) {
-                    temp.delete();
-                }
-
-                backup.renameTo(temp);
-                if (backup.exists()) {
-                    backup.delete();
-                }
-                File existing = context.getDatabasePath(mDatabaseName);
-
-                try {
-                    backup.getParentFile().mkdirs();
-                    writeDB(backup, new FileInputStream(existing));
-
-                    temp.delete();
-                } catch (Exception e) {
-                    AALog.e("Error", e);
-
-                }
-            }
-        });
-
-    }
-}
diff --git a/src/main/java/com/activeandroid/DatabaseHelperListener.java b/src/main/java/com/activeandroid/DatabaseHelperListener.java
deleted file mode 100644
index 41042633..00000000
--- a/src/main/java/com/activeandroid/DatabaseHelperListener.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package com.activeandroid;
-
-import android.database.sqlite.SQLiteDatabase;
-
-public interface DatabaseHelperListener {
-
-    public void onOpen(SQLiteDatabase database);
-
-    public void onCreate(SQLiteDatabase db);
-
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion);
-}
diff --git a/src/main/java/com/activeandroid/IModel.java b/src/main/java/com/activeandroid/IModel.java
deleted file mode 100644
index 7814a159..00000000
--- a/src/main/java/com/activeandroid/IModel.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.activeandroid;
-
-import android.database.Cursor;
-
-/**
- * Author: andrewgrosner
- * Date: 6/16/14
- * Contributors: { }
- * Description: Describes the base interface for all DB classes
- */
-public interface IModel {
-
-    public void save();
-
-    public void delete();
-
-    /**
-     * if the object exists in the DB
-     * @return
-     */
-    public boolean exists();
-
-    /**
-     * Load the model from the cursor
-     * @param cursor
-     */
-    public void loadFromCursor(Cursor cursor);
-
-    /**
-     * Set the id returned by the DB
-     * @param id
-     */
-    public void setRowId(long id);
-
-    public long getRowId();
-
-    /**
-     * Return the ID of this class specified by "(" and comma separated primary key fields
-     * @return
-     */
-    public String getId();
-}
diff --git a/src/main/java/com/activeandroid/Model.java b/src/main/java/com/activeandroid/Model.java
deleted file mode 100644
index ec260f1f..00000000
--- a/src/main/java/com/activeandroid/Model.java
+++ /dev/null
@@ -1,98 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-
-import com.activeandroid.annotation.ForeignKey;
-import com.activeandroid.annotation.Ignore;
-import com.activeandroid.annotation.PrimaryKey;
-import com.activeandroid.content.ContentProvider;
-import com.activeandroid.query.Delete;
-import com.activeandroid.query.Select;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.AALog;
-import com.activeandroid.util.ReflectionUtils;
-import com.activeandroid.util.SQLiteUtils;
-
-import java.lang.reflect.Field;
-import java.util.List;
-
-@SuppressWarnings("unchecked")
-@Ignore
-public abstract class Model implements IModel{
-
-	private TableInfo mTableInfo;
-
-	public Model() {
-		mTableInfo = Cache.getTableInfo(getClass());
-	}
-
-    private long mId;
-
-    /**
-     * Use This method to return the values of your primary key, must be separated by comma delimiter in order of declaration
-     * Also each object thats instance of {@link java.lang.Number} must be DataBaseUtils.sqlEscapeString(object.toString)
-     * @return
-     */
-	public abstract String getId();
-
-    @Override
-	public final void delete() {
-		SQLiteUtils.delete(this);
-	}
-
-    @Override
-	public final void save() {
-        SQLiteUtils.save(this);
-	}
-
-    public final void save(int mode) {
-        SQLiteUtils.save(this, mode);
-    }
-
-    @Override
-    public boolean exists(){
-        return SQLiteUtils.exists(this);
-    }
-
-    public void update(){
-
-    }
-
-    @Override
-	public final void loadFromCursor(Cursor cursor) {
-        SQLiteUtils.loadFromCursor(cursor, this);
-	}
-
-	@Override
-	public String toString() {
-		return mTableInfo!=null? mTableInfo.getTableName() + "@" + getId() : "No Table for: " + getClass() + "@" + getId();
-	}
-
-    @Override
-    public long getRowId(){
-        return mId;
-    }
-
-    @Override
-    public void setRowId(long id) {
-        this.mId = id;
-    }
-}
diff --git a/src/main/java/com/activeandroid/ModelInfo.java b/src/main/java/com/activeandroid/ModelInfo.java
deleted file mode 100644
index aad5bd17..00000000
--- a/src/main/java/com/activeandroid/ModelInfo.java
+++ /dev/null
@@ -1,214 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.File;
-import java.io.IOException;
-import java.lang.reflect.Modifier;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Collection;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import android.content.Context;
-
-import com.activeandroid.annotation.Ignore;
-import com.activeandroid.serializer.CalendarSerializer;
-import com.activeandroid.serializer.SqlDateSerializer;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.serializer.UtilDateSerializer;
-import com.activeandroid.util.AALog;
-import com.activeandroid.util.ReflectionUtils;
-
-import dalvik.system.DexFile;
-
-final class ModelInfo {
-    //////////////////////////////////////////////////////////////////////////////////////
-    // PRIVATE METHODS
-    //////////////////////////////////////////////////////////////////////////////////////
-
-    private Map<Class<? extends IModel>, TableInfo> mTableInfos = new HashMap<Class<? extends IModel>, TableInfo>();
-    private Map<Class<?>, TypeSerializer> mTypeSerializers = new HashMap<Class<?>, TypeSerializer>() {
-        {
-            put(Calendar.class, new CalendarSerializer());
-            put(java.sql.Date.class, new SqlDateSerializer());
-            put(java.util.Date.class, new UtilDateSerializer());
-        }
-    };
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // CONSTRUCTORS
-    //////////////////////////////////////////////////////////////////////////////////////
-
-    public ModelInfo(Configuration configuration) {
-        if (!loadModelFromMetaData(configuration)) {
-            try {
-                scanForModel(configuration.getContext());
-            } catch (IOException e) {
-                AALog.e("Couldn't open source path.", e);
-            }
-        }
-
-        AALog.i("ModelInfo loaded.");
-    }
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // PUBLIC METHODS
-    //////////////////////////////////////////////////////////////////////////////////////
-
-    public Collection<TableInfo> getTableInfos() {
-        return mTableInfos.values();
-    }
-
-    public TableInfo getTableInfo(Class<? extends IModel> type) {
-        return mTableInfos.get(type);
-    }
-
-    public TypeSerializer getTypeSerializer(Class<?> type) {
-        return mTypeSerializers.get(type);
-    }
-
-    //////////////////////////////////////////////////////////////////////////////////////
-    // PRIVATE METHODS
-    //////////////////////////////////////////////////////////////////////////////////////
-
-    private boolean loadModelFromMetaData(Configuration configuration) {
-        if (!configuration.isValid()) {
-            return false;
-        }
-
-        final List<Class<? extends IModel>> models = configuration.getModelClasses();
-        if (models != null) {
-            for (Class<? extends IModel> IModel : models) {
-                mTableInfos.put(IModel, new TableInfo(IModel));
-            }
-        }
-
-        final List<Class<? extends TypeSerializer>> typeSerializers = configuration.getTypeSerializers();
-        if (typeSerializers != null) {
-            for (Class<? extends TypeSerializer> typeSerializer : typeSerializers) {
-                try {
-                    TypeSerializer instance = typeSerializer.newInstance();
-                    mTypeSerializers.put(instance.getDeserializedType(), instance);
-                } catch (InstantiationException e) {
-                    AALog.e("Couldn't instantiate TypeSerializer.", e);
-                } catch (IllegalAccessException e) {
-                    AALog.e("IllegalAccessException", e);
-                }
-            }
-        }
-
-        return true;
-    }
-
-    private void scanForModel(Context context) throws IOException {
-        String packageName = context.getPackageName();
-        String sourcePath = context.getApplicationInfo().sourceDir;
-        List<String> paths = new ArrayList<String>();
-
-        if (sourcePath != null && !(new File(sourcePath).isDirectory())) {
-            DexFile dexfile = new DexFile(sourcePath);
-            Enumeration<String> entries = dexfile.entries();
-
-            while (entries.hasMoreElements()) {
-                String path = entries.nextElement();
-                boolean success = false;
-                for (String modelPath : ModelPathManager.getPaths()) {
-                    if (path.startsWith(modelPath)) {
-                        success = true;
-                        break;
-                    }
-                }
-                if (success) {
-                    paths.add(path);
-                }
-            }
-        }
-        // Robolectric fallback
-        else {
-            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-            Enumeration<URL> resources = classLoader.getResources("");
-
-            while (resources.hasMoreElements()) {
-                String path = resources.nextElement().getFile();
-                if (path.contains("bin") || path.contains("classes")) {
-                    paths.add(path);
-                }
-            }
-        }
-
-        for (String path : paths) {
-            File file = new File(path);
-            scanForModelClasses(file, packageName, context.getClass().getClassLoader());
-        }
-    }
-
-    private void scanForModelClasses(File path, String packageName, ClassLoader classLoader) {
-        if (path.isDirectory()) {
-            for (File file : path.listFiles()) {
-                scanForModelClasses(file, packageName, classLoader);
-            }
-        } else {
-            String className = path.getName();
-
-            // Robolectric fallback
-            if (!path.getPath().equals(className)) {
-                className = path.getPath();
-
-                if (className.endsWith(".class")) {
-                    className = className.substring(0, className.length() - 6);
-                } else {
-                    return;
-                }
-
-                className = className.replace("/", ".");
-
-                int packageNameIndex = className.lastIndexOf(packageName);
-                if (packageNameIndex < 0) {
-                    return;
-                }
-
-                className = className.substring(packageNameIndex);
-            }
-
-            try {
-                Class<?> discoveredClass = Class.forName(className, false, classLoader);
-                if (!Modifier.isAbstract(discoveredClass.getModifiers())
-                        && !discoveredClass.equals(IModel.class)
-                        && ReflectionUtils.isModel(discoveredClass)
-                        && !discoveredClass.isAnnotationPresent(Ignore.class)) {
-                    @SuppressWarnings("unchecked")
-                    Class<? extends IModel> modelClass = (Class<? extends IModel>) discoveredClass;
-                    mTableInfos.put(modelClass, new TableInfo(modelClass));
-                } else if (ReflectionUtils.isTypeSerializer(discoveredClass) && !discoveredClass.isAnnotationPresent(Ignore.class)) {
-                    TypeSerializer instance = (TypeSerializer) discoveredClass.newInstance();
-                    mTypeSerializers.put(instance.getDeserializedType(), instance);
-                }
-            } catch (ClassNotFoundException e) {
-                AALog.e("Couldn't create class.", e);
-            } catch (InstantiationException e) {
-                AALog.e("Couldn't instantiate TypeSerializer.", e);
-            } catch (IllegalAccessException e) {
-                AALog.e("IllegalAccessException", e);
-            }
-        }
-    }
-}
diff --git a/src/main/java/com/activeandroid/ModelPathManager.java b/src/main/java/com/activeandroid/ModelPathManager.java
deleted file mode 100644
index a77dcf95..00000000
--- a/src/main/java/com/activeandroid/ModelPathManager.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.activeandroid;
-
-import java.util.ArrayList;
-
-/**
- * Description: This class allows you to Specify what paths you want AA to use scan for classes,
- * significantly cutting down load time.
- */
-public class ModelPathManager {
-
-    private static ArrayList<String> PATHS;
-
-    static ArrayList<String> getPaths(){
-        if(PATHS==null){
-            PATHS = new ArrayList<String>();
-        }
-        return PATHS;
-    }
-
-    /**
-     * Adds a path to the list of Paths we check to ignore on launch.
-     * This method will check to see if the class name starts with the path, so be careful of your exclusions.
-     * @param path - the starting part of the class. E.g: com.example.somepackage
-     */
-    public static void addPath(String path){
-        getPaths().add(path);
-    }
-}
diff --git a/src/main/java/com/activeandroid/TableInfo.java b/src/main/java/com/activeandroid/TableInfo.java
deleted file mode 100644
index 16a69073..00000000
--- a/src/main/java/com/activeandroid/TableInfo.java
+++ /dev/null
@@ -1,148 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.ForeignKey;
-import com.activeandroid.annotation.PrimaryKey;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.exception.PrimaryKeyNotFoundException;
-import com.activeandroid.util.AALog;
-import com.activeandroid.util.ReflectionUtils;
-
-public final class TableInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Class<? extends IModel> mType;
-	private String mTableName;
-
-	private Map<Field, String> mColumnNames = new HashMap<Field, String>();
-    private LinkedList<Field> mPrimaryKeys = new LinkedList<Field>();
-    private LinkedList<Field> mForeignKeys = new LinkedList<Field>();
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public TableInfo(Class<? extends IModel> type) {
-		mType = type;
-
-		final Table tableAnnotation = type.getAnnotation(Table.class);
-		if (tableAnnotation != null) {
-			mTableName = tableAnnotation.name();
-		}
-		else {
-			mTableName = type.getSimpleName();
-		}
-
-		List<Field> fields = new ArrayList<Field>();
-        try {
-            fields = ReflectionUtils.getAllFields(fields, Class.forName(type.getName()));
-
-            Field id = getIdField(type);
-            if(id!=null) {
-                fields.add(id);
-            }
-        } catch (ClassNotFoundException e) {
-            e.printStackTrace();
-        }
-
-
-		for (Field field : fields) {
-			if (field.isAnnotationPresent(Column.class)) {
-				final Column columnAnnotation = field.getAnnotation(Column.class);
-                String fieldName;
-                if(!columnAnnotation.name().equals("")){
-                    fieldName = columnAnnotation.name();
-                } else{
-                    fieldName = field.getName();
-                }
-				mColumnNames.put(field, fieldName);
-			}
-
-            if(field.isAnnotationPresent(PrimaryKey.class)){
-                mPrimaryKeys.add(field);
-            }
-
-            if(field.isAnnotationPresent(ForeignKey.class)){
-                mForeignKeys.add(field);
-            }
-		}
-
-        if(mPrimaryKeys.isEmpty()){
-            throw new PrimaryKeyNotFoundException("Table: " + mTableName + " must define a primary key");
-        }
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Class<? extends IModel> getType() {
-		return mType;
-	}
-
-	public String getTableName() {
-		return mTableName;
-	}
-
-	public Collection<Field> getFields() {
-		return mColumnNames.keySet();
-	}
-
-	public String getColumnName(Field field) {
-		return mColumnNames.get(field);
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Field getIdField(Class<?> type) {
-		if (type.equals(IModel.class)) {
-			try {
-				return type.getDeclaredField("mId");
-			}
-			catch (NoSuchFieldException e) {
-				AALog.e("Impossible!", e);
-			}
-		}
-		else if (type.getSuperclass() != null) {
-			return getIdField(type.getSuperclass());
-		}
-
-		return null;
-	}
-
-    public LinkedList<Field> getForeignKeys() {
-        return mForeignKeys;
-    }
-
-    public LinkedList<Field> getPrimaryKeys() {
-        return mPrimaryKeys;
-    }
-}
diff --git a/src/main/java/com/activeandroid/annotation/Column.java b/src/main/java/com/activeandroid/annotation/Column.java
deleted file mode 100644
index 3e1ead06..00000000
--- a/src/main/java/com/activeandroid/annotation/Column.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package com.activeandroid.annotation;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-@Target(ElementType.FIELD)
-@Retention(RetentionPolicy.RUNTIME)
-public @interface Column {
-	public enum ConflictAction {
-		ROLLBACK, ABORT, FAIL, IGNORE, REPLACE
-	}
-
-	public enum ForeignKeyAction {
-		SET_NULL, SET_DEFAULT, CASCADE, RESTRICT, NO_ACTION
-	}
-
-	public String name() default "";
-
-	public int length() default -1;
-
-	public boolean notNull() default false;
-
-	public ConflictAction onNullConflict() default ConflictAction.FAIL;
-
-	public ForeignKeyAction onDelete() default ForeignKeyAction.NO_ACTION;
-
-	public ForeignKeyAction onUpdate() default ForeignKeyAction.NO_ACTION;
-
-	public boolean unique() default false;
-
-	public ConflictAction onUniqueConflict() default ConflictAction.FAIL;
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/annotation/ForeignKey.java b/src/main/java/com/activeandroid/annotation/ForeignKey.java
deleted file mode 100644
index 99ee6b99..00000000
--- a/src/main/java/com/activeandroid/annotation/ForeignKey.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.activeandroid.annotation;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * Created by andrewgrosner
- * Date: 12/12/13
- * Contributors:
- * Description:
- */
-@Target(ElementType.FIELD)
-@Retention(RetentionPolicy.RUNTIME)
-public @interface ForeignKey {
-    String name() default "";
-    String foreignColumn();
-}
diff --git a/src/main/java/com/activeandroid/annotation/Ignore.java b/src/main/java/com/activeandroid/annotation/Ignore.java
deleted file mode 100644
index 8e8932df..00000000
--- a/src/main/java/com/activeandroid/annotation/Ignore.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.activeandroid.annotation;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * Created by andrewgrosner
- * Date: 12/9/13
- * Contributors:
- * Description: tells ActiveAndroid that we want to ignore this class as a table
- */
-@Target(ElementType.TYPE)
-@Retention(RetentionPolicy.RUNTIME)
-public @interface Ignore {
-}
diff --git a/src/main/java/com/activeandroid/annotation/PrimaryKey.java b/src/main/java/com/activeandroid/annotation/PrimaryKey.java
deleted file mode 100644
index 52a0e6d2..00000000
--- a/src/main/java/com/activeandroid/annotation/PrimaryKey.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package com.activeandroid.annotation;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * Created by andrewgrosner
- * Date: 12/12/13
- * Contributors:
- * Description: Marks a field as a primary key
- */
-@Target(ElementType.FIELD)
-@Retention(RetentionPolicy.RUNTIME)
-public @interface PrimaryKey {
-    public enum Type{
-        AUTO_INCREMENT,
-        DEFAULT;
-    }
-
-    public Type type() default Type.DEFAULT;
-}
diff --git a/src/main/java/com/activeandroid/annotation/Table.java b/src/main/java/com/activeandroid/annotation/Table.java
deleted file mode 100644
index 4bb6deaf..00000000
--- a/src/main/java/com/activeandroid/annotation/Table.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.activeandroid.annotation;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-@Target(ElementType.TYPE)
-@Retention(RetentionPolicy.RUNTIME)
-public @interface Table {
-	public String name();
-}
diff --git a/src/main/java/com/activeandroid/app/AAApplication.java b/src/main/java/com/activeandroid/app/AAApplication.java
deleted file mode 100644
index d4a0b759..00000000
--- a/src/main/java/com/activeandroid/app/AAApplication.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package com.activeandroid.app;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.manager.DBManagerRuntime;
-import com.activeandroid.runtime.DBRequestQueue;
-
-public class AAApplication extends android.app.Application {
-
-    private static boolean mDebug = false;
-
-	@Override
-	public void onCreate() {
-		super.onCreate();
-		ActiveAndroid.initialize(this);
-
-        DBManagerRuntime.restartManagers();
-	}
-
-    public static void setDebugLogEnabled(boolean enabled){
-        mDebug = enabled;
-    }
-
-    public static boolean isDebugEnabled(){
-        return mDebug;
-    }
-	
-	@Override
-	public void onTerminate() {
-		super.onTerminate();
-
-		ActiveAndroid.dispose();
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/content/ContentProvider.java b/src/main/java/com/activeandroid/content/ContentProvider.java
deleted file mode 100644
index f8f2cfb6..00000000
--- a/src/main/java/com/activeandroid/content/ContentProvider.java
+++ /dev/null
@@ -1,192 +0,0 @@
-package com.activeandroid.content;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import android.content.ContentValues;
-import android.content.UriMatcher;
-import android.database.Cursor;
-import android.net.Uri;
-import android.util.SparseArray;
-
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Cache;
-import com.activeandroid.Configuration;
-import com.activeandroid.IModel;
-import com.activeandroid.TableInfo;
-
-public class ContentProvider extends android.content.ContentProvider {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
-	private static final SparseArray<Class<? extends IModel>> TYPE_CODES = new SparseArray<Class<? extends IModel>>();
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static String sAuthority;
-	private static SparseArray<String> sMimeTypeCache = new SparseArray<String>();
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public boolean onCreate() {
-		ActiveAndroid.initialize(getConfiguration());
-		sAuthority = getAuthority();
-
-		final List<TableInfo> tableInfos = new ArrayList<TableInfo>(Cache.getTableInfos());
-		final int size = tableInfos.size();
-		for (int i = 0; i < size; i++) {
-			final TableInfo tableInfo = tableInfos.get(i);
-			final int tableKey = (i * 2) + 1;
-			final int itemKey = (i * 2) + 2;
-
-			// content://<authority>/<table>
-			URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase(), tableKey);
-			TYPE_CODES.put(tableKey, tableInfo.getType());
-
-			// content://<authority>/<table>/<id>
-			URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase() + "/#", itemKey);
-			TYPE_CODES.put(itemKey, tableInfo.getType());
-		}
-
-		return true;
-	}
-
-	@Override
-	public String getType(Uri uri) {
-		final int match = URI_MATCHER.match(uri);
-
-		String cachedMimeType = sMimeTypeCache.get(match);
-		if (cachedMimeType != null) {
-			return cachedMimeType;
-		}
-
-		final Class<? extends IModel> type = getModelType(uri);
-		final boolean single = ((match % 2) == 0);
-
-		StringBuilder mimeType = new StringBuilder();
-		mimeType.append("vnd");
-		mimeType.append(".");
-		mimeType.append(sAuthority);
-		mimeType.append(".");
-		mimeType.append(single ? "item" : "dir");
-		mimeType.append("/");
-		mimeType.append("vnd");
-		mimeType.append(".");
-		mimeType.append(sAuthority);
-		mimeType.append(".");
-		mimeType.append(Cache.getTableName(type));
-
-		sMimeTypeCache.append(match, mimeType.toString());
-
-		return mimeType.toString();
-	}
-
-	// SQLite methods
-
-	@Override
-	public Uri insert(Uri uri, ContentValues values) {
-		final Class<? extends IModel> type = getModelType(uri);
-		final Long id = Cache.openDatabase().insert(Cache.getTableName(type), null, values);
-
-		if (id != null && id > 0) {
-			Uri retUri = createUri(type, String.valueOf(id));
-			notifyChange(retUri);
-
-			return retUri;
-		}
-
-		return null;
-	}
-
-	@Override
-	public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-		final Class<? extends IModel> type = getModelType(uri);
-		final int count = Cache.openDatabase().update(Cache.getTableName(type), values, selection, selectionArgs);
-
-		notifyChange(uri);
-
-		return count;
-	}
-
-	@Override
-	public int delete(Uri uri, String selection, String[] selectionArgs) {
-		final Class<? extends IModel> type = getModelType(uri);
-		final int count = Cache.openDatabase().delete(Cache.getTableName(type), selection, selectionArgs);
-
-		notifyChange(uri);
-
-		return count;
-	}
-
-	@Override
-	public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
-		final Class<? extends IModel> type = getModelType(uri);
-		final Cursor cursor = Cache.openDatabase().query(
-				Cache.getTableName(type),
-				projection,
-				selection,
-				selectionArgs,
-				null,
-				null,
-				sortOrder);
-
-		cursor.setNotificationUri(getContext().getContentResolver(), uri);
-
-		return cursor;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static Uri createUri(Class<? extends IModel> type, String id) {
-		final StringBuilder uri = new StringBuilder();
-		uri.append("content://");
-		uri.append(sAuthority);
-		uri.append("/");
-		uri.append(Cache.getTableName(type).toLowerCase());
-
-		if (id != null) {
-			uri.append("/");
-			uri.append(id);
-		}
-
-		return Uri.parse(uri.toString());
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	protected String getAuthority() {
-		return getContext().getPackageName();
-	}
-
-	protected Configuration getConfiguration() {
-		return new Configuration.Builder(getContext()).create();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Class<? extends IModel> getModelType(Uri uri) {
-		final int code = URI_MATCHER.match(uri);
-		if (code != UriMatcher.NO_MATCH) {
-			return TYPE_CODES.get(code);
-		}
-
-		return null;
-	}
-
-	private void notifyChange(Uri uri) {
-		getContext().getContentResolver().notifyChange(uri, null);
-	}
-}
diff --git a/src/main/java/com/activeandroid/exception/DBManagerNotOnMainException.java b/src/main/java/com/activeandroid/exception/DBManagerNotOnMainException.java
deleted file mode 100644
index 388e0c18..00000000
--- a/src/main/java/com/activeandroid/exception/DBManagerNotOnMainException.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package com.activeandroid.exception;
-
-/**
- * Created by andrewgrosner
- * Date: 1/10/14
- * Contributors:
- * Description:
- */
-public class DBManagerNotOnMainException extends RuntimeException {
-    public DBManagerNotOnMainException(String s) {
-        super(s);
-    }
-}
diff --git a/src/main/java/com/activeandroid/exception/PrimaryKeyCannotBeNullException.java b/src/main/java/com/activeandroid/exception/PrimaryKeyCannotBeNullException.java
deleted file mode 100644
index 68c21e83..00000000
--- a/src/main/java/com/activeandroid/exception/PrimaryKeyCannotBeNullException.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package com.activeandroid.exception;
-
-/**
- * Created by andrewgrosner
- * Date: 12/26/13
- * Contributors:
- * Description:
- */
-public class PrimaryKeyCannotBeNullException extends Throwable {
-    public PrimaryKeyCannotBeNullException(String s) {
-        super(s);
-    }
-}
diff --git a/src/main/java/com/activeandroid/exception/PrimaryKeyNotFoundException.java b/src/main/java/com/activeandroid/exception/PrimaryKeyNotFoundException.java
deleted file mode 100644
index e8d6d058..00000000
--- a/src/main/java/com/activeandroid/exception/PrimaryKeyNotFoundException.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package com.activeandroid.exception;
-
-/**
- * Created by andrewgrosner
- * Date: 12/12/13
- * Contributors:
- * Description:
- */
-public class PrimaryKeyNotFoundException extends RuntimeException {
-    public PrimaryKeyNotFoundException(String s) {
-        super(s);
-    }
-}
diff --git a/src/main/java/com/activeandroid/interfaces/CollectionReceiver.java b/src/main/java/com/activeandroid/interfaces/CollectionReceiver.java
deleted file mode 100644
index 7373ec28..00000000
--- a/src/main/java/com/activeandroid/interfaces/CollectionReceiver.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package com.activeandroid.interfaces;
-
-import java.util.List;
-
-/**
- * Created by andrewgrosner
- * Date: 12/8/13
- * Contributors:
- * Description: Used as a callback for items that are a List of Objects returned from the DB
- * This function should be called on the foreground handler thread to perform UI interaction with the data.
- * @param <OBJECT_CLASS>
- */
-public interface CollectionReceiver<OBJECT_CLASS>{
-
-    /**
-     * Collection was received from the DB
-     * @param object
-     */
-    public void onCollectionReceived(List<OBJECT_CLASS> object);
-}
-
diff --git a/src/main/java/com/activeandroid/interfaces/ObjectReceiver.java b/src/main/java/com/activeandroid/interfaces/ObjectReceiver.java
deleted file mode 100644
index 7db6d642..00000000
--- a/src/main/java/com/activeandroid/interfaces/ObjectReceiver.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.activeandroid.interfaces;
-
-/**
- * Created by andrewgrosner
- * Date: 12/8/13
- * Contributors:
- * Description: Returns the object when pulled from the database or by request
- * The callback should be run on the main thread to perform UI updates
- */
-public interface ObjectReceiver<OBJECT_CLASS> {
-
-    /**
-     * Object was received from DB or by API request
-     * @param object
-     */
-    public void onObjectReceived(OBJECT_CLASS object);
-}
diff --git a/src/main/java/com/activeandroid/interfaces/ObjectRequester.java b/src/main/java/com/activeandroid/interfaces/ObjectRequester.java
deleted file mode 100644
index 36916c89..00000000
--- a/src/main/java/com/activeandroid/interfaces/ObjectRequester.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package com.activeandroid.interfaces;
-
-import com.activeandroid.IModel;
-
-/**
-* Created by andrewgrosner
-* Date: 12/26/13
-* Contributors:
-* Description:
-*/
-public interface ObjectRequester<OBJECT_CLASS extends IModel>{
-    /**
-     * Implement this method to perform a request if the object does not exist in the DB
-     * @param objectReceiver
-     * @param uid
-     */
-    public abstract void requestObject(final Class<OBJECT_CLASS> obclazz, final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid);
-}
diff --git a/src/main/java/com/activeandroid/manager/DBManager.java b/src/main/java/com/activeandroid/manager/DBManager.java
deleted file mode 100644
index 54b47c55..00000000
--- a/src/main/java/com/activeandroid/manager/DBManager.java
+++ /dev/null
@@ -1,230 +0,0 @@
-package com.activeandroid.manager;
-
-import com.activeandroid.IModel;
-import com.activeandroid.interfaces.CollectionReceiver;
-import com.activeandroid.interfaces.ObjectReceiver;
-import com.activeandroid.runtime.DBRequest;
-import com.activeandroid.runtime.DBRequestInfo;
-
-import java.util.List;
-
-/**
- * Created by andrewgrosner
- * Date: 11/12/13
- * Contributors:
- * Description: Provides a handy base implementation for adding and getting objects from the database.
- * Each extension of this manager corresponds to one table only.
- *
- * @param <OBJECT_CLASS> - the class of objects that represent a Model from the DB
- */
-public abstract class DBManager<OBJECT_CLASS extends IModel> extends SingleDBManager{
-
-    protected Class<OBJECT_CLASS> mObjectClass;
-
-
-    /**
-     * Constructs a new instance while keeping an instance of the class for its objects.
-     * <br>
-     * Shares the same queue with the {@link com.activeandroid.manager.SingleDBManager}
-     * @param mObjectClass
-     */
-    public DBManager(Class<OBJECT_CLASS> mObjectClass) {
-        super(mObjectClass.getSimpleName(), false);
-        this.mObjectClass = mObjectClass;
-    }
-
-    /**
-     * Constructs a new instance while keeping an instance of the class for its objects
-     * @param classClass
-     * @param hasOwnQueue - set this flag to true to create its own request queue
-     *                    (useful for many DB operations, however each may use up a chunk  of memory)
-     */
-    public DBManager(Class<OBJECT_CLASS> classClass, boolean hasOwnQueue){
-        super(classClass.getSimpleName(), hasOwnQueue);
-        mObjectClass = classClass;
-    }
-
-    /**
-     * Override this method to have one instance of the manager accross the app
-     * @return
-     */
-    public static DBManager getSharedInstance(){
-        throw new IllegalStateException("Cannot call the base implementation of this method");
-    }
-
-    /**
-     * Adds a object to this class, however its advised you ensure that the object being passed is what you want, since there's no type checking
-     * @param object
-     */
-    public OBJECT_CLASS add(Object object){
-        return add(mObjectClass, object);
-    }
-
-    /**
-     * Adds an object to the DB in the BG
-     * @param jsonObject
-     */
-    public void addInBackground(final Object jsonObject){
-        addInBackground(mObjectClass, jsonObject);
-    }
-
-    public void addInBackground(final Object object, final ObjectReceiver<OBJECT_CLASS> objectReceiver){
-        addInBackground(mObjectClass, object, objectReceiver);
-    }
-
-    /**
-     * Adds all objects from the passed array, may NOT be type-safe so be careful with this
-     * @param array
-     */
-    public void addAll(Object array){
-        addAll(mObjectClass, array);
-    }
-
-    public void addAllInBackground(final Object array){
-        addAllInBackground(mObjectClass, array);
-    }
-
-    public void addAllInBackground(final Object array, final CollectionReceiver<OBJECT_CLASS> collectionReceiver) {
-        addAllInBackground(mObjectClass, array, collectionReceiver);
-    }
-
-    /**
-     * Retrieves a list of objects from the database without any threading
-     * Its recommended not to call this method in the foreground thread
-     * @return
-     */
-    public List<OBJECT_CLASS> getAll(){
-        return getAll(mObjectClass);
-    }
-
-    public OBJECT_CLASS getObject(Object object){
-        return DBManagerCache.constructNewInstance(object, mObjectClass);
-    }
-
-    /**
-     * Retrieves a list of objects from the database without any threading with the sort passed
-     * Its recommended not to call this method in the foreground thread
-     * @param sort - valid SQLLite syntax for sort e.g. name ASC
-     * @return
-     */
-    public List<OBJECT_CLASS> getAllWithSort(String sort){
-        return getAllWithSort(mObjectClass, sort);
-    }
-
-    /**
-     * Fetches objects from this DB on the BG
-     * @param receiver - function to call when finished that passes the list of objects that was found
-     */
-    public void fetchAll(final CollectionReceiver<OBJECT_CLASS> receiver){
-        fetchAll(mObjectClass, receiver);
-    }
-
-    /**
-     * Fetches objects from this DB on the BG calling orderBy with the sort passed.
-     * @param sort - valid SQLLite syntax for sort e.g. name ASC
-     * @param receiver - function to call when finished that passes the list of objects that was found
-     */
-    public void fetchAllWithSort(final String sort, final CollectionReceiver<OBJECT_CLASS> receiver){
-        fetchAllWithSort(mObjectClass, sort, receiver);
-    };
-
-    public void fetchAllWithColumnValue(final Object value, final String column, final CollectionReceiver<OBJECT_CLASS> receiver){
-        fetchAllWithColumnValue(mObjectClass, value, column, receiver);
-    }
-
-    /**
-     * This will get the where statement for this object, the amount of ids passed must match the primary key column size
-     * @return
-     */
-    public OBJECT_CLASS getObjectById(Object...ids){
-        return getObjectById(mObjectClass, ids);
-    }
-
-    /**
-     * Returns a single object with the specified column name.
-     * Useful for getting objects with a specific primary key
-     * @param column
-     * @param uid
-     * @return
-     */
-    public OBJECT_CLASS getObjectByColumnValue(String column, Object uid){
-        return getObjectByColumnValue(mObjectClass, column, uid);
-    }
-
-    /**
-     * Gets all in a table by a group by
-     * @param groupBy
-     * @return
-     */
-    public List<OBJECT_CLASS> getAllWithGroupby(String groupBy){
-        return getAllWithGroupby(mObjectClass, groupBy);
-    }
-
-    /**
-     * Returns all objects with the specified column name
-     * @param column
-     * @param value
-     * @return
-     */
-    public List<OBJECT_CLASS> getAllWithColumnValue(String column, Object value){
-        return getAllWithColumnValue(mObjectClass, column, value);
-    }
-
-    /**
-     * Returns the count of rows from this DB manager's DB
-     * @return
-     */
-    public long getCount(){
-        return getCount(mObjectClass);
-    }
-
-    /**
-     * Fetches the count on the DB thread and returns it on the handler
-     * @param objectReceiver
-     */
-    public void fetchCount(final ObjectReceiver<Long> objectReceiver){
-        fetchCount(mObjectClass, objectReceiver);
-    }
-
-    /**
-     * Will return the object if its within the DB, if not, it will call upon an object requester to get the data from the API
-     *
-     * @param objectReceiver
-     * @param uid
-     * @return true if the object exists in the DB, otherwise its on a BG thread
-     */
-    public boolean fetchObject(final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
-        OBJECT_CLASS object = getObjectById(uid);
-        if(object==null){
-            processOnForeground(new Runnable() {
-                @Override
-                public void run() {
-                    requestObject(objectReceiver, uid);
-                }
-            });
-            return false;
-        } else{
-            objectReceiver.onObjectReceived(object);
-            return true;
-        }
-    }
-
-    /**
-     * Implement this method to perform a request if the object does not exist in the DB
-     * @param objectReceiver
-     * @param uid
-     */
-    public abstract void requestObject(final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid);
-
-    public Class<OBJECT_CLASS> getObjectClass() {
-        return mObjectClass;
-    }
-
-    /**
-     * Deletes all from the current object's class
-     */
-    public void deleteAll() {
-        deleteAll(mObjectClass);
-    }
-
-}
diff --git a/src/main/java/com/activeandroid/manager/DBManagerCache.java b/src/main/java/com/activeandroid/manager/DBManagerCache.java
deleted file mode 100644
index 219ed2ac..00000000
--- a/src/main/java/com/activeandroid/manager/DBManagerCache.java
+++ /dev/null
@@ -1,107 +0,0 @@
-package com.activeandroid.manager;
-
-import com.activeandroid.IModel;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.util.HashMap;
-
-/**
- * Created by andrewgrosner
- * Date: 4/7/14
- * Contributors:
- * Description:
- */
-public class DBManagerCache {
-
-    private static HashMap<Class, Method> mGetSizeMethodMap = new HashMap<Class, Method>();
-    private static HashMap<Class, Method> mGetMethodMap = new HashMap<Class, Method>();
-    private static HashMap<Class, Constructor> mConstructorMap = new HashMap<Class, Constructor>();
-
-    public static int invokeGetSizeMethod(Object inObject){
-        Class objectClazz = inObject.getClass();
-        Method method = mGetSizeMethodMap.get(objectClazz);
-        if(method==null){
-            try {
-                method = objectClazz.getDeclaredMethod("length", null);
-            } catch (NoSuchMethodException e) {
-                try {
-                    method = objectClazz.getDeclaredMethod("size", null);
-                } catch (NoSuchMethodException e1) {
-                    try {
-                        method = objectClazz.getDeclaredMethod("count", null);
-                    } catch (NoSuchMethodException e2) {
-                        //custom method will go here
-                    }
-                }
-            } finally {
-                mGetSizeMethodMap.put(objectClazz, method);
-            }
-        }
-
-        if(method!=null){
-            method.setAccessible(true);
-            Integer count = 0;
-            try {
-                count = (Integer) method.invoke(inObject, null);
-            } catch (Throwable throwable) {
-                throw new RuntimeException(throwable);
-            } finally {
-                return count;
-            }
-        } else{
-            return 0;
-        }
-    }
-
-    public static Object invokeGetMethod(Object inObject, int index){
-
-        Class objectClazz = inObject.getClass();
-        Method method = mGetMethodMap.get(objectClazz);
-        if(method==null) {
-
-            try {
-                method = objectClazz.getDeclaredMethod("get", int.class);
-            } catch (NoSuchMethodException e) {
-                try {
-                    method = objectClazz.getDeclaredMethod("getItem", int.class);
-                } catch (NoSuchMethodException e1) {
-
-                }
-            } finally {
-                mGetMethodMap.put(objectClazz, method);
-            }
-        }
-        if(method!=null){
-            method.setAccessible(true);
-            Object outObject = 0;
-            try {
-                outObject = method.invoke(inObject, index);
-            } catch (Throwable e) {
-                throw new RuntimeException(e);
-            } finally {
-                return outObject;
-            }
-        } else{
-            return null;
-        }
-    }
-
-    public static <OBJECT_CLASS extends IModel> OBJECT_CLASS constructNewInstance(Object inObject, Class<OBJECT_CLASS> objectClass){
-        Constructor<OBJECT_CLASS> constructor = mConstructorMap.get(objectClass);
-        if(constructor==null){
-            try {
-                constructor = objectClass.getConstructor(inObject.getClass());
-                mConstructorMap.put(objectClass, constructor);
-            } catch (Throwable e) {
-                throw new RuntimeException(e);
-            }
-        }
-        try {
-            return constructor.newInstance(inObject);
-        } catch (Throwable e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-}
diff --git a/src/main/java/com/activeandroid/manager/DBManagerRuntime.java b/src/main/java/com/activeandroid/manager/DBManagerRuntime.java
deleted file mode 100644
index c71406da..00000000
--- a/src/main/java/com/activeandroid/manager/DBManagerRuntime.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.activeandroid.manager;
-
-import com.activeandroid.runtime.DBBatchSaveQueue;
-
-import java.util.ArrayList;
-
-/**
- * Created by andrewgrosner
- * Date: 4/17/14
- * Contributors:
- * Description:
- */
-public class DBManagerRuntime {
-
-
-    private static ArrayList<SingleDBManager> managers;
-
-    static ArrayList<SingleDBManager> getManagers(){
-        if(managers==null){
-            managers = new ArrayList<SingleDBManager>();
-        }
-        return managers;
-    }
-
-    /**
-     * Quits all active DBManager queues
-     */
-    public static void quit(){
-        for(SingleDBManager manager: getManagers()){
-            if(manager.hasOwnQueue()) {
-                manager.getQueue().quit();
-                manager.disposeQueue();
-            }
-        }
-        DBBatchSaveQueue.getSharedSaveQueue().quit();
-        DBBatchSaveQueue.disposeSharedQueue();
-    }
-
-    public static void restartManagers(){
-        for(SingleDBManager manager: getManagers()){
-            manager.checkQueue();
-        }
-    }
-}
diff --git a/src/main/java/com/activeandroid/manager/SingleDBManager.java b/src/main/java/com/activeandroid/manager/SingleDBManager.java
deleted file mode 100644
index 6d99e2d4..00000000
--- a/src/main/java/com/activeandroid/manager/SingleDBManager.java
+++ /dev/null
@@ -1,507 +0,0 @@
-package com.activeandroid.manager;
-
-import android.database.DatabaseUtils;
-import android.os.Handler;
-
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Cache;
-import com.activeandroid.IModel;
-import com.activeandroid.exception.DBManagerNotOnMainException;
-import com.activeandroid.interfaces.ObjectRequester;
-import com.activeandroid.query.Delete;
-import com.activeandroid.query.Select;
-import com.activeandroid.interfaces.CollectionReceiver;
-import com.activeandroid.interfaces.ObjectReceiver;
-import com.activeandroid.runtime.DBBatchSaveQueue;
-import com.activeandroid.runtime.DBRequest;
-import com.activeandroid.runtime.DBRequestInfo;
-import com.activeandroid.runtime.DBRequestQueue;
-import com.activeandroid.util.AALog;
-import com.activeandroid.util.ReflectionUtils;
-import com.activeandroid.util.SQLiteUtils;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-/**
- * Created by andrewgrosner
- * Date: 12/26/13
- * Contributors:
- * Description: This class will provide one instance for all tables,
- * however the downside requires the class of an object when retrieving from the DB. Any {@link com.activeandroid.manager.DBManager} will extend off this class
- * and provide its own {@link com.activeandroid.runtime.DBRequestQueue}
- */
-public class SingleDBManager {
-
-    private static SingleDBManager manager;
-
-    private DBRequestQueue mQueue;
-
-    private String mName;
-
-    private  final boolean hasOwnQueue;
-
-    /**
-     * Creates the SingleDBManager while starting its own request queue
-     * @param name
-     */
-    public SingleDBManager(String name, boolean createNewQueue){
-        mName = name;
-        hasOwnQueue = createNewQueue;
-        checkThread();
-        DBManagerRuntime.getManagers().add(this);
-        checkQueue();
-    }
-
-    /**
-     * Returns the application's only needed DBManager.
-     * Note: this manager must be created on the main thread, otherwise a {@link com.activeandroid.exception.DBManagerNotOnMainException} will be thrown
-     * @return
-     */
-    public static SingleDBManager getSharedInstance(){
-        if(manager==null){
-           manager = new SingleDBManager("SingleDBManager", true);
-        }
-        return manager;
-    }
-
-    void checkQueue() {
-        if (!getQueue().isAlive()) {
-            getQueue().start();
-        }
-        if (!getSaveQueue().isAlive()) {
-            getSaveQueue().start();
-        }
-    }
-
-    public boolean hasOwnQueue() {
-        return hasOwnQueue;
-    }
-
-    /**
-     * Destroys the running queue
-     */
-    void disposeQueue() {
-        mQueue = null;
-    }
-
-    public DBRequestQueue getQueue(){
-        if(mQueue==null){
-            if(hasOwnQueue) {
-                mQueue = new DBRequestQueue(mName);
-            } else{
-                mQueue = SingleDBManager.getSharedInstance().mQueue;
-            }
-        }
-        return mQueue;
-    }
-
-    public DBBatchSaveQueue getSaveQueue(){
-        return DBBatchSaveQueue.getSharedSaveQueue();
-    }
-
-    /**
-     * Ensure manager was created in the main thread, otherwise handler will not work
-     */
-    protected void checkThread(){
-        if(!Thread.currentThread().getName().equals("main")){
-            throw new DBManagerNotOnMainException("DBManager needs to be instantiated on the main thread so Handler is on UI thread. Was on : " + Thread.currentThread().getName());
-        }
-    }
-
-    /**
-     * Runs all of the UI threaded requests
-     */
-    protected Handler mRequestHandler = new Handler();
-
-    /**
-     * Runs a request from the DB in the request queue
-     * @param runnable
-     */
-    protected void processOnBackground(DBRequest runnable){
-        getQueue().add(runnable);
-    }
-
-    /**
-     * Runs UI operations in the handler
-     * @param runnable
-     */
-    protected synchronized void processOnForeground(Runnable runnable){
-        mRequestHandler.post(runnable);
-    }
-
-    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObject(Class<OBJECT_CLASS> obClazz, Object object){
-       return DBManagerCache.constructNewInstance(object, obClazz);
-    }
-
-    /**
-     * Adds an object to the manager's database
-     * @param inObject - object of the class defined by the manager
-     */
-    public <OBJECT_CLASS extends IModel> OBJECT_CLASS add(OBJECT_CLASS inObject){
-        inObject.save();
-        return inObject;
-    }
-
-    /**
-     * Adds a json object to this class, however its advised you ensure that the jsonobject being passed is what you want, since there's no type checking
-     * @param object
-     */
-    public <OBJECT_CLASS extends IModel> OBJECT_CLASS add(Class<OBJECT_CLASS> obClazz, Object object){
-        try {
-            return add(getObject(obClazz,object));
-        } catch (Throwable e) {
-            e.printStackTrace();
-        }
-        return null;
-    }
-
-    /**
-     * Adds an object to the DB in the BG
-     * @param jsonObject
-     */
-    public <OBJECT_CLASS extends IModel> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject, final ObjectReceiver<OBJECT_CLASS> objectReceiver){
-        OBJECT_CLASS object = getObject(obClazz, jsonObject);
-        if(objectReceiver!=null){
-            objectReceiver.onObjectReceived(object);
-        }
-        getSaveQueue().add(object);
-
-    }
-
-    public <OBJECT_CLASS extends IModel> void addInBackground(final Class<OBJECT_CLASS> obClazz, final Object jsonObject){
-        addInBackground(obClazz, jsonObject,null);
-    }
-
-
-    public <OBJECT_CLASS extends IModel> void addInBackground(final OBJECT_CLASS object){
-        getSaveQueue().add(object);
-    }
-
-    /**
-     * Adds all objects to the DB
-     * @param objects
-     */
-    public <OBJECT_CLASS extends IModel, COLLECTION_CLASS extends Collection<OBJECT_CLASS>> void addAll(COLLECTION_CLASS objects){
-        ActiveAndroid.beginTransaction();
-        try{
-            for(OBJECT_CLASS object: objects){
-                add(object);
-            }
-            ActiveAndroid.setTransactionSuccessful();
-        } finally {
-            ActiveAndroid.endTransaction();
-        }
-    }
-
-    /**
-     * Adds all objects from the passed object (if it has collection-like methods), may NOT be type-safe so be careful with this
-     * @param array
-     */
-    public <OBJECT_CLASS extends IModel> void addAll(Class<OBJECT_CLASS> obClazz, Object array){
-        ActiveAndroid.beginTransaction();
-        try{
-            int count = DBManagerCache.invokeGetSizeMethod(array);
-            for(int i = 0; i < count;i++){
-                Object getObject = DBManagerCache.invokeGetMethod(array, i);
-                OBJECT_CLASS object = DBManagerCache.constructNewInstance(getObject, obClazz);
-                add(object);
-            }
-            ActiveAndroid.setTransactionSuccessful();
-        } catch (Throwable e) {
-            throw new RuntimeException(e);
-        } finally {
-            ActiveAndroid.endTransaction();
-        }
-
-    }
-
-    public <OBJECT_CLASS extends IModel> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array) {
-        addAllInBackground(obClazz, array, null);
-    }
-
-
-    public <OBJECT_CLASS extends IModel> void addAllInBackground(final Class<OBJECT_CLASS> obClazz, final Object array, final CollectionReceiver<OBJECT_CLASS> collectionReceiver){
-        processOnBackground(new DBRequest() {
-            @Override
-            public void run() {
-                final List<OBJECT_CLASS> objects = new ArrayList<OBJECT_CLASS>();
-                int count = DBManagerCache.invokeGetSizeMethod(array);
-                for(int i = 0; i < count;i++){
-                    Object getObject =  DBManagerCache.invokeGetMethod(array, i);
-                    objects.add(getObject(obClazz, getObject));
-                }
-
-                if(collectionReceiver!=null){
-                    processOnForeground(new Runnable() {
-                        @Override
-                        public void run() {
-                            collectionReceiver.onCollectionReceived(objects);
-                        }
-                    });
-                }
-
-                getSaveQueue().addAll(objects);
-            }
-        });
-
-    }
-
-    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void addAllInBackground(final COLLECTION_CLASS collection){
-       getSaveQueue().addAll(collection);
-    }
-
-    /**
-     * Retrieves a list of objects from the database without any threading
-     * Its recommended not to call this method in the foreground thread
-     * @return
-     */
-    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAll(final Class<OBJECT_CLASS> obClazz){
-        return new Select().from(obClazz).execute();
-    }
-
-    /**
-     * Retrieves a list of objects from the database without any threading with the sort passed
-     * Its recommended not to call this method in the foreground thread
-     * @param sort - valid SQLLite syntax for sort e.g. name ASC
-     * @return
-     */
-    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithSort(Class<OBJECT_CLASS> obClazz, String sort){
-        return new Select().from(obClazz).orderBy(sort).execute();
-    }
-
-    /**
-     * Fetches objects from this DB on the BG
-     * @param receiver - function to call when finished that passes the list of objects that was found
-     */
-    public <OBJECT_CLASS extends IModel> void fetchAll(final Class<OBJECT_CLASS> obClazz, final CollectionReceiver<OBJECT_CLASS> receiver){
-        processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
-            @Override
-            public void run() {
-                final List<OBJECT_CLASS> list = getAll(obClazz);
-                processOnForeground(new Runnable() {
-                    @Override
-                    public void run() {
-                        receiver.onCollectionReceived(list);
-                    }
-                });
-            }
-        });
-    }
-
-    /**
-     * Fetches objects from this DB on the BG calling orderBy with the sort passed.
-     * @param sort - valid SQLLite syntax for sort e.g. name ASC
-     * @param receiver - function to call when finished that passes the list of objects that was found
-     */
-    public <OBJECT_CLASS extends IModel> void fetchAllWithSort(final Class<OBJECT_CLASS> obClazz, final String sort, final CollectionReceiver<OBJECT_CLASS> receiver){
-        processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
-            @Override
-            public void run() {
-                final List<OBJECT_CLASS> list = getAllWithSort(obClazz, sort);
-                processOnForeground(new Runnable() {
-                    @Override
-                    public void run() {
-                        receiver.onCollectionReceived(list);
-                    }
-                });
-            }
-        });
-    };
-
-    public <OBJECT_CLASS extends IModel> void fetchAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, final Object value, final String column, final CollectionReceiver<OBJECT_CLASS> receiver){
-        processOnBackground(new DBRequest(DBRequestInfo.create("fetch" , DBRequest.PRIORITY_UI)) {
-            @Override
-            public void run() {
-                final List<OBJECT_CLASS> list = getAllWithColumnValue(obClazz, column, value);
-                processOnForeground(new Runnable() {
-                    @Override
-                    public void run() {
-                        receiver.onCollectionReceived(list);
-                    }
-                });
-            }
-        });
-    }
-
-    /**
-     * This will get the where statement for this object, the amount of ids passed must match the primary key column size
-     * @return
-     */
-    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObjectById(final Class<OBJECT_CLASS> obClazz, Object...ids){
-        return new Select().from(obClazz).where(SQLiteUtils.getWhereStatement(obClazz, Cache.getTableInfo(obClazz)), ids).executeSingle();
-    }
-
-    /**
-     * Returns a single object with the specified column name.
-     * Useful for getting objects with a specific primary key
-     * @param column
-     * @param uid
-     * @return
-     */
-    public <OBJECT_CLASS extends IModel> OBJECT_CLASS getObjectByColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object uid){
-        return new Select().from(obClazz).where(column+" =?", uid).executeSingle();
-    }
-
-    /**
-     * Returns all objects with the specified column name
-     * @param column
-     * @param value
-     * @return
-     */
-    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithColumnValue(final Class<OBJECT_CLASS> obClazz, String column, Object value){
-        return new Select().from(obClazz).where(column + "= ?", value).execute();
-    }
-
-    /**
-     * Gets all in a table by a group by
-     * @param obClazz
-     * @param groupBy
-     * @param <OBJECT_CLASS>
-     * @return
-     */
-    public <OBJECT_CLASS extends IModel> List<OBJECT_CLASS> getAllWithGroupby(final Class<OBJECT_CLASS> obClazz, String groupBy){
-        return new Select().from(obClazz).groupBy(groupBy).execute();
-    }
-
-    /**
-     * Returns the count of rows from this DB manager's DB
-     * @return
-     */
-    public long getCount(final Class<? extends IModel> obClazz){
-        return DatabaseUtils.queryNumEntries(Cache.openDatabase(), Cache.getTableName(obClazz));
-    }
-
-    /**
-     * Fetches the count on the DB thread and returns it on the handler
-     * @param objectReceiver
-     */
-    public <OBJECT_CLASS extends IModel> void fetchCount(final Class<OBJECT_CLASS> obclazz, final ObjectReceiver<Long> objectReceiver){
-        processOnBackground(new DBRequest(DBRequestInfo.createFetch()) {
-            @Override
-            public void run() {
-                processOnForeground(new Runnable() {
-                    @Override
-                    public void run() {
-                        objectReceiver.onObjectReceived(getCount(obclazz));
-                    }
-                });
-            }
-        });
-    }
-
-    /**
-     * Will return the object if its within the DB, if not, it will call upon an {@link com.activeandroid.interfaces.ObjectRequester} to get the data from the API
-     *
-     * @param objectReceiver
-     * @param uid
-     * @return true if the object exists in the DB, otherwise its on a BG thread
-     */
-    public <OBJECT_CLASS extends IModel> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectRequester<OBJECT_CLASS> requester,  final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
-        OBJECT_CLASS object = getObjectById(obClazz, uid);
-        if(object==null&&requester!=null){
-            processOnForeground(new Runnable() {
-                @Override
-                public void run() {
-                    requester.requestObject(obClazz, objectReceiver, uid);
-                }
-            });
-            return false;
-        } else{
-            objectReceiver.onObjectReceived(object);
-            return true;
-        }
-    }
-    /**
-     * Will return the object if its within the DB, if not, it will not call an{@link com.activeandroid.interfaces.ObjectRequester}
-     *
-     * @param objectReceiver
-     * @param uid
-     * @return true if the object exists in the DB, otherwise its on a BG thread
-     */
-    public <OBJECT_CLASS extends IModel> boolean fetchObject(final Class<OBJECT_CLASS> obClazz, final ObjectReceiver<OBJECT_CLASS> objectReceiver, final Object... uid){
-       return fetchObject(obClazz, null, objectReceiver, uid);
-    }
-
-
-    /**
-     * Deletes all objects from the specified table
-     * @param obClazz
-     * @param <OBJECT_CLASS>
-     */
-    public <OBJECT_CLASS extends IModel> void deleteAll(Class<OBJECT_CLASS> obClazz){
-        new Delete().from(obClazz).execute();
-    }
-
-    /**
-     * Deletes objects from the db
-     * @param <OBJECT_CLASS>
-     */
-    public<OBJECT_CLASS extends IModel> void deleteAll(OBJECT_CLASS...objects) {
-        ActiveAndroid.beginTransaction();
-        try{
-            for(OBJECT_CLASS object: objects){
-                object.delete();
-            }
-            ActiveAndroid.setTransactionSuccessful();
-        } finally {
-            ActiveAndroid.endTransaction();
-        }
-    }
-
-    /**
-     * Deletes all objects from the collection specified
-     * @param objects - the list of IModel objects you wish to delete
-     */
-    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void deleteAll(COLLECTION_CLASS objects) {
-        ActiveAndroid.beginTransaction();
-        try{
-            for(OBJECT_CLASS object: objects){
-                object.delete();
-            }
-            ActiveAndroid.setTransactionSuccessful();
-        } finally {
-            ActiveAndroid.endTransaction();
-        }
-    }
-
-    /**
-     * Deletes objects from the db
-     * @param finishedRunnable
-     * @param dbRequestInfo
-     * @param objects
-     * @param <OBJECT_CLASS>
-     */
-    public<LIST_CLASS extends List<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final LIST_CLASS objects) {
-        processOnBackground(new DBRequest(dbRequestInfo) {
-            @Override
-            public void run() {
-                deleteAll(objects);
-                if(finishedRunnable!=null){
-                    finishedRunnable.run();
-                }
-            }
-        });
-    }
-
-    /**
-     * Deletes objects from the db
-     * @param finishedRunnable
-     * @param dbRequestInfo
-     * @param objects
-     * @param <OBJECT_CLASS>
-     */
-    public<OBJECT_CLASS extends IModel> void deleteAllInBackground(final Runnable finishedRunnable, DBRequestInfo dbRequestInfo, final OBJECT_CLASS...objects) {
-        processOnBackground(new DBRequest(dbRequestInfo) {
-            @Override
-            public void run() {
-                deleteAll(objects);
-                if(finishedRunnable!=null){
-                    finishedRunnable.run();
-                }
-            }
-        });
-    }
-
-}
diff --git a/src/main/java/com/activeandroid/query/Delete.java b/src/main/java/com/activeandroid/query/Delete.java
deleted file mode 100644
index 46313ef4..00000000
--- a/src/main/java/com/activeandroid/query/Delete.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package com.activeandroid.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.IModel;
-
-public final class Delete implements Sqlable {
-	public Delete() {
-	}
-
-	public From from(Class<? extends IModel> table) {
-		return new From(table, this);
-	}
-
-	@Override
-	public String toSql() {
-		return "DELETE ";
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/query/From.java b/src/main/java/com/activeandroid/query/From.java
deleted file mode 100644
index 88567611..00000000
--- a/src/main/java/com/activeandroid/query/From.java
+++ /dev/null
@@ -1,257 +0,0 @@
-package com.activeandroid.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.text.TextUtils;
-import com.activeandroid.Cache;
-import com.activeandroid.IModel;
-import com.activeandroid.query.Join.JoinType;
-import com.activeandroid.util.AALog;
-import com.activeandroid.util.SQLiteUtils;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-public final class From implements Sqlable {
-	private Sqlable mQueryBase;
-
-	private Class<? extends IModel> mType;
-	private String mAlias;
-	private List<Join> mJoins;
-	private String mWhere;
-	private String mGroupBy;
-	private String mHaving;
-	private String mOrderBy;
-	private String mLimit;
-	private String mOffset;
-
-	private List<Object> mArguments;
-
-	public From(Class<? extends IModel> table, Sqlable queryBase) {
-		mType = table;
-		mJoins = new ArrayList<Join>();
-		mQueryBase = queryBase;
-
-		mJoins = new ArrayList<Join>();
-		mArguments = new ArrayList<Object>();
-	}
-
-	public From as(String alias) {
-		mAlias = alias;
-		return this;
-	}
-
-	public Join join(Class<? extends IModel> table) {
-		Join join = new Join(this, table, null);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join leftJoin(Class<? extends IModel> table) {
-		Join join = new Join(this, table, JoinType.LEFT);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join outerJoin(Class<? extends IModel> table) {
-		Join join = new Join(this, table, JoinType.OUTER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join innerJoin(Class<? extends IModel> table) {
-		Join join = new Join(this, table, JoinType.INNER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join crossJoin(Class<? extends IModel> table) {
-		Join join = new Join(this, table, JoinType.CROSS);
-		mJoins.add(join);
-		return join;
-	}
-
-	public From where(String where) {
-		mWhere = where;
-		mArguments.clear();
-
-		return this;
-	}
-
-	public From where(String where, Object... args) {
-		mWhere = where;
-		mArguments.clear();
-		mArguments.addAll(Arrays.asList(args));
-
-		return this;
-	}
-
-	public From groupBy(String groupBy) {
-		mGroupBy = groupBy;
-		return this;
-	}
-
-	public From having(String having) {
-		mHaving = having;
-		return this;
-	}
-
-	public From orderBy(String orderBy) {
-		mOrderBy = orderBy;
-		return this;
-	}
-
-	public From limit(int limit) {
-		return limit(String.valueOf(limit));
-	}
-
-	public From limit(String limit) {
-		mLimit = limit;
-		return this;
-	}
-
-	public From offset(int offset) {
-		return offset(String.valueOf(offset));
-	}
-
-	public From offset(String offset) {
-		mOffset = offset;
-		return this;
-	}
-
-	void addArguments(Object[] args) {
-		mArguments.addAll(Arrays.asList(args));
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-		sql.append(mQueryBase.toSql());
-		sql.append("FROM ");
-		sql.append(Cache.getTableName(mType)).append(" ");
-
-		if (mAlias != null) {
-			sql.append("AS ");
-			sql.append(mAlias);
-			sql.append(" ");
-		}
-
-		for (Join join : mJoins) {
-			sql.append(join.toSql());
-		}
-
-		if (mWhere != null) {
-			sql.append("WHERE ");
-			sql.append(mWhere);
-			sql.append(" ");
-		}
-
-		if (mGroupBy != null) {
-			sql.append("GROUP BY ");
-			sql.append(mGroupBy);
-			sql.append(" ");
-		}
-
-		if (mHaving != null) {
-			sql.append("HAVING ");
-			sql.append(mHaving);
-			sql.append(" ");
-		}
-
-		if (mOrderBy != null) {
-			sql.append("ORDER BY ");
-			sql.append(mOrderBy);
-			sql.append(" ");
-		}
-
-		if (mLimit != null) {
-			sql.append("LIMIT ");
-			sql.append(mLimit);
-			sql.append(" ");
-		}
-
-		if (mOffset != null) {
-			sql.append("OFFSET ");
-			sql.append(mOffset);
-			sql.append(" ");
-		}
-
-		// Don't wast time building the string
-		// unless we're going to log it.
-		if (AALog.isEnabled()) {
-			AALog.v(sql.toString() + " " + TextUtils.join(",", getArguments()));
-		}
-
-		return sql.toString().trim();
-	}
-
-    /**
-     * Gets the count of of rows
-     * @return
-     */
-    public long executeCount(){
-        if(mQueryBase instanceof Select){
-            return DatabaseUtils.longForQuery(Cache.openDatabase(), toSql(), getArguments());
-        } else{
-            SQLiteUtils.execSql(toSql(), getArguments());
-            return 0L;
-        }
-    }
-
-	public <T extends IModel> List<T> execute() {
-		if (mQueryBase instanceof Select) {
-			return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
-		}
-		else {
-			SQLiteUtils.execSql(toSql(), getArguments());
-			return null;
-		}
-	}
-
-    /**
-     * Returns the DB Cursor from the SQL statement
-     * @return
-     */
-    public Cursor getCursor(){
-        return Cache.openDatabase().rawQuery(toSql(), getArguments());
-    }
-
-	public <T extends IModel> T executeSingle() {
-		if (mQueryBase instanceof Select) {
-			limit(1);
-			return SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
-		}
-		else {
-			SQLiteUtils.execSql(toSql(), getArguments());
-			return null;
-		}
-	}
-
-	public String[] getArguments() {
-		final int size = mArguments.size();
-		final String[] args = new String[size];
-
-		for (int i = 0; i < size; i++) {
-			args[i] = mArguments.get(i).toString();
-		}
-
-		return args;
-	}
-}
diff --git a/src/main/java/com/activeandroid/query/Join.java b/src/main/java/com/activeandroid/query/Join.java
deleted file mode 100644
index 2d5b8419..00000000
--- a/src/main/java/com/activeandroid/query/Join.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package com.activeandroid.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.text.TextUtils;
-
-import com.activeandroid.Cache;
-import com.activeandroid.IModel;
-
-public final class Join implements Sqlable {
-	static enum JoinType {
-		LEFT, OUTER, INNER, CROSS
-	}
-
-	private From mFrom;
-	private Class<? extends IModel> mType;
-	private String mAlias;
-	private JoinType mJoinType;
-	private String mOn;
-	private String[] mUsing;
-
-	Join(From from, Class<? extends IModel> table, JoinType joinType) {
-		mFrom = from;
-		mType = table;
-		mJoinType = joinType;
-	}
-
-	public Join as(String alias) {
-		mAlias = alias;
-		return this;
-	}
-
-	public From on(String on) {
-		mOn = on;
-		return mFrom;
-	}
-
-	public From on(String on, Object... args) {
-		mOn = on;
-		mFrom.addArguments(args);
-		return mFrom;
-	}
-
-	public From using(String... columns) {
-		mUsing = columns;
-		return mFrom;
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-
-		if (mJoinType != null) {
-			sql.append(mJoinType.toString()).append(" ");
-		}
-
-		sql.append("JOIN ");
-		sql.append(Cache.getTableName(mType));
-		sql.append(" ");
-
-		if (mAlias != null) {
-			sql.append("AS ");
-			sql.append(mAlias);
-			sql.append(" ");
-		}
-
-		if (mOn != null) {
-			sql.append("ON ");
-			sql.append(mOn);
-			sql.append(" ");
-		}
-		else if (mUsing != null) {
-			sql.append("USING (");
-			sql.append(TextUtils.join(", ", mUsing));
-			sql.append(") ");
-		}
-
-		return sql.toString();
-	}
-}
diff --git a/src/main/java/com/activeandroid/query/Select.java b/src/main/java/com/activeandroid/query/Select.java
deleted file mode 100644
index f12d79eb..00000000
--- a/src/main/java/com/activeandroid/query/Select.java
+++ /dev/null
@@ -1,105 +0,0 @@
-package com.activeandroid.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.text.TextUtils;
-
-import com.activeandroid.IModel;
-
-public final class Select implements Sqlable {
-	private String[] mColumns;
-	private boolean mDistinct = false;
-	private boolean mAll = false;
-    private boolean mCount = false;
-
-	public Select() {
-	}
-
-	public Select(String... columns) {
-		mColumns = columns;
-	}
-
-	public Select(Column... columns) {
-		final int size = columns.length;
-		mColumns = new String[size];
-		for (int i = 0; i < size; i++) {
-			mColumns[i] = columns[i].name + " AS " + columns[i].alias;
-		}
-	}
-
-	public Select distinct() {
-		mDistinct = true;
-		mAll = false;
-        mCount = false;
-
-		return this;
-	}
-
-	public Select all() {
-		mDistinct = false;
-        mCount = false;
-		mAll = true;
-
-		return this;
-	}
-
-    public Select count(){
-        mAll = false;
-        mDistinct = false;
-        mCount = true;
-        return this;
-    }
-
-	public From from(Class<? extends IModel> table) {
-		return new From(table, this);
-	}
-
-	public static class Column {
-		String name;
-		String alias;
-
-		public Column(String name, String alias) {
-			this.name = name;
-			this.alias = alias;
-		}
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-
-		sql.append("SELECT ");
-
-		if (mDistinct) {
-			sql.append("DISTINCT ");
-		}
-		else if (mAll) {
-			sql.append("ALL ");
-		} else if(mCount){
-            sql.append("COUNT(*) ");
-        }
-
-		if (mColumns != null && mColumns.length > 0) {
-			sql.append(TextUtils.join(", ", mColumns) + " ");
-		}
-		else if(!mCount){
-			sql.append("* ");
-		}
-
-		return sql.toString();
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/query/Set.java b/src/main/java/com/activeandroid/query/Set.java
deleted file mode 100644
index 183d99f0..00000000
--- a/src/main/java/com/activeandroid/query/Set.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package com.activeandroid.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.util.SQLiteUtils;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-public final class Set implements Sqlable {
-	private Update mUpdate;
-
-	private String mSet;
-	private String mWhere;
-
-	private List<Object> mSetArguments;
-	private List<Object> mWhereArguments;
-
-	public Set(Update queryBase, String set) {
-		mUpdate = queryBase;
-		mSet = set;
-
-		mSetArguments = new ArrayList<Object>();
-		mWhereArguments = new ArrayList<Object>();
-	}
-
-	public Set(Update queryBase, String set, Object... args) {
-		mUpdate = queryBase;
-		mSet = set;
-
-		mSetArguments = new ArrayList<Object>();
-		mWhereArguments = new ArrayList<Object>();
-
-		mSetArguments.addAll(Arrays.asList(args));
-	}
-
-	public Set where(String where) {
-		mWhere = where;
-		mWhereArguments.clear();
-
-		return this;
-	}
-
-	public Set where(String where, Object... args) {
-		mWhere = where;
-		mWhereArguments.clear();
-		mWhereArguments.addAll(Arrays.asList(args));
-
-		return this;
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-		sql.append(mUpdate.toSql());
-		sql.append("SET ");
-		sql.append(mSet);
-		sql.append(" ");
-
-		if (mWhere != null) {
-			sql.append("WHERE ");
-			sql.append(mWhere);
-			sql.append(" ");
-		}
-
-		return sql.toString();
-	}
-
-	public void execute() {
-		SQLiteUtils.execSql(toSql(), getArguments());
-	}
-
-	public String[] getArguments() {
-		final int setSize = mSetArguments.size();
-		final int whereSize = mWhereArguments.size();
-		final String[] args = new String[setSize + whereSize];
-
-		for (int i = 0; i < setSize; i++) {
-			args[i] = mSetArguments.get(i).toString();
-		}
-
-		for (int i = 0; i < whereSize; i++) {
-			args[i + setSize] = mWhereArguments.get(i).toString();
-		}
-
-		return args;
-	}
-}
diff --git a/src/main/java/com/activeandroid/query/Sqlable.java b/src/main/java/com/activeandroid/query/Sqlable.java
deleted file mode 100644
index 2c3f5d43..00000000
--- a/src/main/java/com/activeandroid/query/Sqlable.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package com.activeandroid.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public interface Sqlable {
-	public String toSql();
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/query/Update.java b/src/main/java/com/activeandroid/query/Update.java
deleted file mode 100644
index 509db5b4..00000000
--- a/src/main/java/com/activeandroid/query/Update.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package com.activeandroid.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.Cache;
-import com.activeandroid.IModel;
-
-public final class Update implements Sqlable {
-	private Class<? extends IModel> mType;
-
-	public Update(Class<? extends IModel> table) {
-		mType = table;
-	}
-
-	public Set set(String set) {
-		return new Set(this, set);
-	}
-
-	public Set set(String set, Object... args) {
-		return new Set(this, set, args);
-	}
-
-	Class<? extends IModel> getType() {
-		return mType;
-	}
-
-	@Override
-	public String toSql() {
-		return "UPDATE " + Cache.getTableName(mType) + " ";
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java b/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java
deleted file mode 100644
index d88326d7..00000000
--- a/src/main/java/com/activeandroid/runtime/DBBatchSaveQueue.java
+++ /dev/null
@@ -1,146 +0,0 @@
-package com.activeandroid.runtime;
-
-import android.os.Looper;
-
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.IModel;
-import com.activeandroid.manager.SingleDBManager;
-import com.activeandroid.util.AALog;
-
-import java.util.ArrayList;
-import java.util.Collection;
-
-/**
- * Created by andrewgrosner
- * Date: 3/19/14
- * Contributors:
- * Description: This queue will bulk save items added to it when it gets access to the DB. It should only exist as one entity.
- */
-public class DBBatchSaveQueue extends Thread{
-
-    private static DBBatchSaveQueue mBatchSaveQueue;
-
-    /**
-     *  Once the queue size reaches 50 or larger, the thread will be interrupted and we will batch save the models.
-     */
-    private static final int sMODEL_SAVE_SIZE = 50;
-
-    /**
-     * Tells how many items to save at a time. This can be set using {@link #setModelSaveSize(int)}
-     */
-    private int mModelSaveSize = sMODEL_SAVE_SIZE;
-
-    private boolean mQuit = false;
-
-    public static DBBatchSaveQueue getSharedSaveQueue(){
-        if(mBatchSaveQueue==null){
-            mBatchSaveQueue = new DBBatchSaveQueue();
-        }
-        return mBatchSaveQueue;
-    }
-
-    public static void disposeSharedQueue(){
-        mBatchSaveQueue = null;
-    }
-
-    private final ArrayList<IModel> mModels;
-
-    public DBBatchSaveQueue(){
-        super("DBBatchSaveQueue");
-
-        mModels = new ArrayList<IModel>();
-    }
-
-    /**
-     * Sets how many models to save at a time in this queue.
-     * Increase it for larger batches, but slower recovery time.
-     * Smaller the batch, the more time it takes to save overall.
-     * @param mModelSaveSize
-     */
-    public void setModelSaveSize(int mModelSaveSize) {
-        this.mModelSaveSize = mModelSaveSize;
-    }
-
-    @Override
-    public void run() {
-        super.run();
-        Looper.prepare();
-        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
-        while (true){
-            final ArrayList<IModel> tmpModels;
-            synchronized (mModels){
-                tmpModels = new ArrayList<IModel>(mModels);
-                mModels.clear();
-            }
-            if(tmpModels.size()>0) {
-                //run this on the DBManager thread
-                SingleDBManager.getSharedInstance().getQueue().add(new DBRequest(DBRequestInfo.create("Batch Saving")) {
-                    @Override
-                    public void run() {
-                        long time = System.currentTimeMillis();
-                        ActiveAndroid.beginTransaction();
-                        try {
-                            AALog.d("DBBatchSaveQueue", "Executing batch save of: " + tmpModels.size() + " on :" + Thread.currentThread().getName());
-                            for (IModel IModel: tmpModels) {
-                                IModel.save();
-                            }
-                            ActiveAndroid.setTransactionSuccessful();
-                        } catch (Throwable e) {
-                            throw new RuntimeException(e.getCause());
-                        } finally {
-                            ActiveAndroid.endTransaction();
-                        }
-                        AALog.d("DBBatchSaveQueue", "Time took: " + (System.currentTimeMillis() -time));
-                    }
-                });
-            }
-
-            try {
-                //sleep for 5 mins, and then check for leftovers
-                Thread.sleep(300000);
-            } catch (InterruptedException e) {
-                AALog.d("DBBatchSaveQueue", "Batch interrupted to start saving");
-            }
-
-            if(mQuit){
-                return;
-            }
-        }
-    }
-
-    public void add(final IModel IModel){
-        synchronized (mModels){
-            mModels.add(IModel);
-
-            if(mModels.size()>mModelSaveSize){
-                interrupt();
-            }
-        }
-    }
-
-    public <COLLECTION_CLASS extends Collection<OBJECT_CLASS>, OBJECT_CLASS extends IModel> void addAll(final COLLECTION_CLASS list){
-        synchronized (mModels){
-            mModels.addAll(list);
-
-            if(mModels.size()>mModelSaveSize){
-                interrupt();
-            }
-        }
-    }
-
-    public void remove(final IModel IModel){
-        synchronized (mModels){
-            mModels.remove(IModel);
-        }
-    }
-
-    public void removeAll(final Collection collection){
-        synchronized (mModels){
-            mModels.removeAll(collection);
-        }
-    }
-
-    public void quit() {
-        mQuit = true;
-    }
-}
diff --git a/src/main/java/com/activeandroid/runtime/DBRequest.java b/src/main/java/com/activeandroid/runtime/DBRequest.java
deleted file mode 100644
index c542c302..00000000
--- a/src/main/java/com/activeandroid/runtime/DBRequest.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package com.activeandroid.runtime;
-
-import java.util.UUID;
-
-/**
- * Created by andrewgrosner
- * Date: 12/11/13
- * Contributors:
- * Description: The basic request object that's placed on the DBRequestQueue for processing.
- * The {@link com.activeandroid.runtime.DBRequestQueue} uses a priority queue that will process
- * this class based on the priority assigned to it.
- *
- * There are four main kinds of requests:
- *  For requests that require UI or immediate retrieval, use PRIORITY_UI
- *  For requests that are displayed in the UI some point in the near future, use PRIORITY_HIGH
- *  For the bulk of data requests, use PRIORITY_NORMAL
- *  For any request that's non-essential use PRIORITY_LOW
- */
-public abstract class DBRequest implements Comparable<DBRequest> {
-
-    /**
-     * Low priority requests, reserved for non-essential tasks
-     */
-    public static int PRIORITY_LOW = 0;
-
-    /**
-     * The main of the requests, good for when adding a bunch of
-     * data to the DB that the app does not access right away.
-     */
-    public static int PRIORITY_NORMAL = 1;
-
-    /**
-     * Reserved for tasks that will influence user interaction, such as displaying data in the UI
-     * some point in the future (not necessarily right away)
-     */
-    public static int PRIORITY_HIGH = 2;
-
-    /**
-     * Reserved for only immediate tasks and all forms of fetching that will display on the UI
-     */
-    public static int PRIORITY_UI = 5;
-
-    public abstract void run();
-
-    private DBRequestInfo mInfo;
-
-    /**
-     * Constructs this class using the specified DBRequest info
-     * @param dbRequestInfo
-     */
-    public DBRequest(DBRequestInfo dbRequestInfo) {
-        mInfo = dbRequestInfo;
-    }
-
-    /**
-     * Creates a new, low priority request
-     */
-    public DBRequest(){
-        mInfo = DBRequestInfo.create();
-    }
-
-    @Override
-    public int compareTo(DBRequest another) {
-        return another.mInfo.getPriority() - mInfo.getPriority();
-    }
-
-    public String getName() {
-        return mInfo.getName();
-    }
-}
diff --git a/src/main/java/com/activeandroid/runtime/DBRequestInfo.java b/src/main/java/com/activeandroid/runtime/DBRequestInfo.java
deleted file mode 100644
index b76f54fd..00000000
--- a/src/main/java/com/activeandroid/runtime/DBRequestInfo.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package com.activeandroid.runtime;
-
-import java.util.UUID;
-
-/**
- * Created by andrewgrosner
- * Date: 2/2/14
- * Contributors:
- * Description: Holds information related to a {@link com.activeandroid.runtime.DBRequest}
- */
-public class DBRequestInfo {
-
-    private String name;
-
-    private int priority;
-
-    private DBRequestInfo(){
-    }
-
-    /**
-     * Creates with a name and priority
-     * @param name
-     * @param priority
-     * @return
-     */
-    public static DBRequestInfo create(String name, int priority){
-        DBRequestInfo requestInfo = new DBRequestInfo();
-        requestInfo.name = name;
-        requestInfo.priority = priority;
-        return requestInfo;
-    }
-
-    /**
-     * Creates with a name and default {@link com.activeandroid.runtime.DBRequest#PRIORITY_NORMAL}
-     * @param name
-     * @return
-     */
-    public static DBRequestInfo create(String name){
-        DBRequestInfo requestInfo = new DBRequestInfo();
-        requestInfo.name = name;
-        requestInfo.priority = DBRequest.PRIORITY_NORMAL;
-        return requestInfo;
-    }
-
-    /**
-     * Creates with a priority and name generated from {@link java.util.UUID#randomUUID()}
-     * @param priority
-     * @return
-     */
-    public static DBRequestInfo create(int priority){
-        DBRequestInfo requestInfo = new DBRequestInfo();
-        requestInfo.name = UUID.randomUUID().toString();
-        requestInfo.priority = priority;
-        return requestInfo;
-    }
-
-    /**
-     * Creates with a priority and name generated from {@link java.util.UUID#randomUUID()} and {@link com.activeandroid.runtime.DBRequest#PRIORITY_NORMAL}
-     * @param priority
-     * @return
-     */
-    public static DBRequestInfo create(){
-        DBRequestInfo requestInfo = new DBRequestInfo();
-        requestInfo.name = UUID.randomUUID().toString();
-        requestInfo.priority = DBRequest.PRIORITY_LOW;
-        return requestInfo;
-    }
-
-    /**
-     * Returns a prefilled, fetch request
-     * @return
-     */
-    public static DBRequestInfo createFetch(){
-        DBRequestInfo requestInfo = new DBRequestInfo();
-        requestInfo.priority = DBRequest.PRIORITY_UI;
-        requestInfo.name = "fetch " + UUID.randomUUID().toString();
-        return requestInfo;
-    }
-
-
-
-    public String getName() {
-        return name;
-    }
-
-    public int getPriority() {
-        return priority;
-    }
-}
diff --git a/src/main/java/com/activeandroid/runtime/DBRequestQueue.java b/src/main/java/com/activeandroid/runtime/DBRequestQueue.java
deleted file mode 100644
index 5aeb76c7..00000000
--- a/src/main/java/com/activeandroid/runtime/DBRequestQueue.java
+++ /dev/null
@@ -1,105 +0,0 @@
-package com.activeandroid.runtime;
-
-import android.os.Looper;
-import android.os.Process;
-
-import com.activeandroid.util.AALog;
-
-import java.util.Iterator;
-import java.util.concurrent.PriorityBlockingQueue;
-
-/**
- * Created by andrewgrosner
- * Date: 12/11/13
- * Contributors:
- * Description: will handle concurrent requests to the DB based on priority
- */
-public class DBRequestQueue extends Thread{
-
-    /**
-     * Queue of requests
-     */
-    private final PriorityBlockingQueue<DBRequest> mQueue;
-
-    private boolean mQuit = false;
-
-    /**
-     * Creates a queue with the specified name to ID it.
-     * @param name
-     */
-    public DBRequestQueue(String name) {
-        super(name);
-
-        mQueue = new PriorityBlockingQueue<DBRequest>();
-    }
-
-    @Override
-    public void run() {
-        Looper.prepare();
-        android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-        DBRequest runnable;
-        while (true){
-            try{
-                runnable = mQueue.take();
-            } catch (InterruptedException e){
-                if(mQuit){
-                    synchronized (mQueue) {
-                        mQueue.clear();
-                    }
-                    return;
-                }
-                continue;
-            }
-
-            try{
-                if(AALog.isEnabled()) {
-                    AALog.d("DBRequestQueue + " + getName(), "Size is: " + mQueue.size() + " executing:" + runnable.getName());
-                }
-                runnable.run();
-            } catch (Throwable t){
-                throw new RuntimeException(t);
-            }
-        }
-
-    }
-
-    public void add(DBRequest runnable){
-        if (!mQueue.contains(runnable)) {
-            mQueue.add(runnable);
-        }
-    }
-
-    /**
-     * Cancels the specified request.
-     * @param runnable
-     */
-    public void cancel(DBRequest runnable){
-        if (mQueue.contains(runnable)) {
-            mQueue.remove(runnable);
-        }
-    }
-
-    /**
-     * Cancels all requests by a specific tag
-     * @param tag
-     */
-    public void cancel(String tag){
-        synchronized (mQueue){
-            Iterator<DBRequest> it = mQueue.iterator();
-            while(it.hasNext()){
-                DBRequest next = it.next();
-                if(next.getName().equals(tag)){
-                    it.remove();
-                }
-            }
-        }
-    }
-
-    /**
-     * Quits this process
-     */
-    public void quit(){
-        mQuit = true;
-        interrupt();
-    }
-}
diff --git a/src/main/java/com/activeandroid/serializer/CalendarSerializer.java b/src/main/java/com/activeandroid/serializer/CalendarSerializer.java
deleted file mode 100644
index c96207ed..00000000
--- a/src/main/java/com/activeandroid/serializer/CalendarSerializer.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.activeandroid.serializer;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Calendar;
-
-public final class CalendarSerializer extends TypeSerializer<Calendar> {
-	public Class<?> getDeserializedType() {
-		return Calendar.class;
-	}
-
-	public Class<?> getSerializedType() {
-		return long.class;
-	}
-
-    @Override
-	public Long serialize(Calendar data) {
-		return data.getTimeInMillis();
-	}
-
-    @Override
-	public Calendar deserialize(Object data) {
-		Calendar calendar = Calendar.getInstance();
-		calendar.setTimeInMillis((Long) data);
-
-		return calendar;
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/serializer/SqlDateSerializer.java b/src/main/java/com/activeandroid/serializer/SqlDateSerializer.java
deleted file mode 100644
index 77bad6f7..00000000
--- a/src/main/java/com/activeandroid/serializer/SqlDateSerializer.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package com.activeandroid.serializer;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.sql.Date;
-
-public final class SqlDateSerializer extends TypeSerializer<Date> {
-	public Class<?> getDeserializedType() {
-		return Date.class;
-	}
-
-	public Class<?> getSerializedType() {
-		return long.class;
-	}
-
-    @Override
-	public Long serialize(Date data) {
-		if (data == null) {
-			return null;
-		}
-
-		return data.getTime();
-	}
-
-    @Override
-	public Date deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return new Date((Long) data);
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/serializer/TypeSerializer.java b/src/main/java/com/activeandroid/serializer/TypeSerializer.java
deleted file mode 100644
index ea0bc5a6..00000000
--- a/src/main/java/com/activeandroid/serializer/TypeSerializer.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.activeandroid.serializer;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public abstract class TypeSerializer<OBJECT_CLASS> {
-	public abstract Class<?> getDeserializedType();
-
-	public abstract Class<?> getSerializedType();
-
-	public abstract Object serialize(OBJECT_CLASS data);
-
-	public abstract OBJECT_CLASS deserialize(Object data);
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/serializer/UtilDateSerializer.java b/src/main/java/com/activeandroid/serializer/UtilDateSerializer.java
deleted file mode 100644
index 6608bf67..00000000
--- a/src/main/java/com/activeandroid/serializer/UtilDateSerializer.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package com.activeandroid.serializer;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Date;
-
-public final class UtilDateSerializer extends TypeSerializer<Date> {
-	public Class<?> getDeserializedType() {
-		return Date.class;
-	}
-
-	public Class<?> getSerializedType() {
-		return Long.class;
-	}
-
-    @Override
-	public Long serialize(Date data) {
-		if (data == null) {
-			return null;
-		}
-
-		return data.getTime();
-	}
-
-    @Override
-	public Date deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return new Date((Long) data);
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/util/AALog.java b/src/main/java/com/activeandroid/util/AALog.java
deleted file mode 100644
index 0b75d6e9..00000000
--- a/src/main/java/com/activeandroid/util/AALog.java
+++ /dev/null
@@ -1,196 +0,0 @@
-package com.activeandroid.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public final class AALog {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static String sTag = "ActiveAndroid";
-	private static boolean sEnabled = false;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private AALog() {
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-    public static boolean isEnabled() {
-        return sEnabled;
-    }
-
-	public static void setEnabled(boolean enabled) {
-		sEnabled = enabled;
-	}
-
-	public static boolean isLoggingEnabled() {
-		return sEnabled;
-	}
-
-	public static int v(String msg) {
-		if (sEnabled) {
-			return android.util.Log.v(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int v(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.v(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int v(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.v(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int v(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.v(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int d(String msg) {
-		if (sEnabled) {
-			return android.util.Log.d(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int d(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.d(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int d(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.d(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int d(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.d(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int i(String msg) {
-		if (sEnabled) {
-			return android.util.Log.i(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int i(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.i(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int i(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.i(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int i(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.i(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int w(String msg) {
-		if (sEnabled) {
-			return android.util.Log.w(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int w(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.w(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int w(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.w(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int w(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.w(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int e(String msg) {
-		if (sEnabled) {
-			return android.util.Log.e(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int e(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.e(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int e(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.e(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int e(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.e(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int t(String msg, Object... args) {
-		if (sEnabled) {
-			return android.util.Log.v("test", String.format(msg, args));
-		}
-		return 0;
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/util/NaturalOrderComparator.java b/src/main/java/com/activeandroid/util/NaturalOrderComparator.java
deleted file mode 100644
index a6b76d05..00000000
--- a/src/main/java/com/activeandroid/util/NaturalOrderComparator.java
+++ /dev/null
@@ -1,141 +0,0 @@
-package com.activeandroid.util;
-
-/*
- NaturalOrderComparator.java -- Perform 'natural order' comparisons of strings in Java.
- Copyright (C) 2003 by Pierre-Luc Paour <natorder@paour.com>
-
- Based on the C version by Martin Pool, of which this is more or less a straight conversion.
- Copyright (C) 2000 by Martin Pool <mbp@humbug.org.au>
-
- This software is provided 'as-is', without any express or implied
- warranty.  In no event will the authors be held liable for any damages
- arising from the use of this software.
-
- Permission is granted to anyone to use this software for any purpose,
- including commercial applications, and to alter it and redistribute it
- freely, subject to the following restrictions:
-
- 1. The origin of this software must not be misrepresented; you must not
- claim that you wrote the original software. If you use this software
- in a product, an acknowledgment in the product documentation would be
- appreciated but is not required.
- 2. Altered source versions must be plainly marked as such, and must not be
- misrepresented as being the original software.
- 3. This notice may not be removed or altered from any source distribution.
- */
-
-import java.util.Comparator;
-
-public class NaturalOrderComparator implements Comparator<Object> {
-	int compareRight(String a, String b) {
-		int bias = 0;
-		int ia = 0;
-		int ib = 0;
-
-		// The longest run of digits wins. That aside, the greatest
-		// name wins, but we can't know that it will until we've scanned
-		// both numbers to know that they have the same magnitude, so we
-		// remember it in BIAS.
-		for (;; ia++, ib++) {
-			char ca = charAt(a, ia);
-			char cb = charAt(b, ib);
-
-			if (!Character.isDigit(ca) && !Character.isDigit(cb)) {
-				return bias;
-			}
-			else if (!Character.isDigit(ca)) {
-				return -1;
-			}
-			else if (!Character.isDigit(cb)) {
-				return +1;
-			}
-			else if (ca < cb) {
-				if (bias == 0) {
-					bias = -1;
-				}
-			}
-			else if (ca > cb) {
-				if (bias == 0)
-					bias = +1;
-			}
-			else if (ca == 0 && cb == 0) {
-				return bias;
-			}
-		}
-	}
-
-	public int compare(Object o1, Object o2) {
-		String a = o1.toString();
-		String b = o2.toString();
-
-		int ia = 0, ib = 0;
-		int nza = 0, nzb = 0;
-		char ca, cb;
-		int result;
-
-		while (true) {
-			// only count the number of zeroes leading the last number compared
-			nza = nzb = 0;
-
-			ca = charAt(a, ia);
-			cb = charAt(b, ib);
-
-			// skip over leading spaces or zeros
-			while (Character.isSpaceChar(ca) || ca == '0') {
-				if (ca == '0') {
-					nza++;
-				}
-				else {
-					// only count consecutive zeroes
-					nza = 0;
-				}
-
-				ca = charAt(a, ++ia);
-			}
-
-			while (Character.isSpaceChar(cb) || cb == '0') {
-				if (cb == '0') {
-					nzb++;
-				}
-				else {
-					// only count consecutive zeroes
-					nzb = 0;
-				}
-
-				cb = charAt(b, ++ib);
-			}
-
-			// process run of digits
-			if (Character.isDigit(ca) && Character.isDigit(cb)) {
-				if ((result = compareRight(a.substring(ia), b.substring(ib))) != 0) {
-					return result;
-				}
-			}
-
-			if (ca == 0 && cb == 0) {
-				// The strings compare the same. Perhaps the caller
-				// will want to call strcmp to break the tie.
-				return nza - nzb;
-			}
-
-			if (ca < cb) {
-				return -1;
-			}
-			else if (ca > cb) {
-				return +1;
-			}
-
-			++ia;
-			++ib;
-		}
-	}
-
-	static char charAt(String s, int i) {
-		if (i >= s.length()) {
-			return 0;
-		}
-		else {
-			return s.charAt(i);
-		}
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/util/ReflectionUtils.java b/src/main/java/com/activeandroid/util/ReflectionUtils.java
deleted file mode 100644
index 739f3873..00000000
--- a/src/main/java/com/activeandroid/util/ReflectionUtils.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package com.activeandroid.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-
-import com.activeandroid.IModel;
-import com.activeandroid.serializer.TypeSerializer;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.List;
-
-public final class ReflectionUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static boolean isModel(Class<?> type) {
-		return IModel.class.isAssignableFrom(type);
-	}
-
-	public static boolean isTypeSerializer(Class<?> type) {
-		return isSubclassOf(type, TypeSerializer.class);
-	}
-
-	// Meta-data
-
-	@SuppressWarnings("unchecked")
-	public static <T> T getMetaData(Context context, String name) {
-		try {
-			final ApplicationInfo ai = context.getPackageManager().getApplicationInfo(context.getPackageName(),
-					PackageManager.GET_META_DATA);
-
-			if (ai.metaData != null) {
-				return (T) ai.metaData.get(name);
-			}
-		}
-		catch (Exception e) {
-			AALog.w("Couldn't find meta-data: " + name);
-		}
-
-		return null;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static boolean isSubclassOf(Class<?> type, Class<?> superClass) {
-		if (type.getSuperclass() != null) {
-			if (type.getSuperclass().equals(superClass)) {
-				return true;
-			}
-
-			return isSubclassOf(type.getSuperclass(), superClass);
-		}
-
-		return false;
-	}
-
-    public static List<Field> getAllFields(List<Field> outFields, Class<?> inClass) {
-        for (Field field : inClass.getDeclaredFields()) {
-            outFields.add(field);
-        }
-        if (inClass.getSuperclass() != null && !inClass.getSuperclass().equals(IModel.class)) {
-            outFields = getAllFields(outFields, inClass.getSuperclass());
-        }
-        return outFields;
-    }
-
-
-}
\ No newline at end of file
diff --git a/src/main/java/com/activeandroid/util/SQLiteUtils.java b/src/main/java/com/activeandroid/util/SQLiteUtils.java
deleted file mode 100644
index b276f8c5..00000000
--- a/src/main/java/com/activeandroid/util/SQLiteUtils.java
+++ /dev/null
@@ -1,680 +0,0 @@
-package com.activeandroid.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
-import android.os.Build;
-import android.text.TextUtils;
-
-import com.activeandroid.Cache;
-import com.activeandroid.IModel;
-import com.activeandroid.TableInfo;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.ForeignKey;
-import com.activeandroid.annotation.PrimaryKey;
-import com.activeandroid.content.ContentProvider;
-import com.activeandroid.exception.PrimaryKeyCannotBeNullException;
-import com.activeandroid.query.Select;
-import com.activeandroid.serializer.TypeSerializer;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-
-public final class SQLiteUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// ENUMERATIONS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public enum SQLiteType {
-		INTEGER, REAL, TEXT, BLOB
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONTSANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
-		{
-			put(byte.class, SQLiteType.INTEGER);
-			put(short.class, SQLiteType.INTEGER);
-			put(int.class, SQLiteType.INTEGER);
-			put(long.class, SQLiteType.INTEGER);
-			put(float.class, SQLiteType.REAL);
-			put(double.class, SQLiteType.REAL);
-			put(boolean.class, SQLiteType.INTEGER);
-			put(char.class, SQLiteType.TEXT);
-			put(byte[].class, SQLiteType.BLOB);
-			put(Byte.class, SQLiteType.INTEGER);
-			put(Short.class, SQLiteType.INTEGER);
-			put(Integer.class, SQLiteType.INTEGER);
-			put(Long.class, SQLiteType.INTEGER);
-			put(Float.class, SQLiteType.REAL);
-			put(Double.class, SQLiteType.REAL);
-			put(Boolean.class, SQLiteType.INTEGER);
-			put(Character.class, SQLiteType.TEXT);
-			put(String.class, SQLiteType.TEXT);
-			put(Byte[].class, SQLiteType.BLOB);
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void execSql(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSql(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-
-	public static <T extends IModel> List<T> rawQuery(SQLiteDatabase database, Class<? extends IModel> type, String sql, String[] selectionArgs) {
-		Cursor cursor = database.rawQuery(sql, selectionArgs);
-		List<T> entities = processCursor(type, cursor);
-		cursor.close();
-
-		return entities;
-	}
-
-    public static <T extends IModel> List<T> rawQuery(Class<? extends IModel> type, String sql, String[] selectionArgs) {
-        return rawQuery(Cache.openDatabase(), type, sql, selectionArgs);
-    }
-
-	public static <T extends IModel> T rawQuerySingle(Class<? extends IModel> type, String sql, String[] selectionArgs) {
-		List<T> entities = rawQuery(type, sql, selectionArgs);
-
-		if (entities.size() > 0) {
-			return entities.get(0);
-		}
-
-		return null;
-	}
-
-	// Database creation
-
-	public static String createTableDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-
-		for (Field field : tableInfo.getFields()) {
-			String definition = createColumnDefinition(tableInfo, field);
-			if (!TextUtils.isEmpty(definition)) {
-				definitions.add(definition);
-			}
-		}
-
-        List<Field> primaryColumns = tableInfo.getPrimaryKeys();
-        List<Field> foreignColumns = tableInfo.getForeignKeys();
-        if(!primaryColumns.isEmpty()){
-            StringBuilder builder = new StringBuilder("PRIMARY KEY(");
-
-
-            int count = 0;
-            for(int i  =0 ; i< primaryColumns.size(); i++){
-                PrimaryKey primaryKey = primaryColumns.get(i).getAnnotation(PrimaryKey.class);
-                if(!primaryKey.type().equals(PrimaryKey.Type.AUTO_INCREMENT)) {
-                    count++;
-                    builder.append(tableInfo.getColumnName(primaryColumns.get(i)));
-                    if (i < primaryColumns.size() - 1) {
-                        builder.append(", ");
-                    }
-                }
-            }
-
-            if(count>0) {
-                builder.append(")");
-
-                definitions.add(builder.toString());
-            }
-        }
-
-        for(int i = 0; i < foreignColumns.size(); i++){
-            final Field column = foreignColumns.get(i);
-            ForeignKey foreignKey = column.getAnnotation(ForeignKey.class);
-
-            StringBuilder forDef = new StringBuilder("FOREIGN KEY(");
-            forDef.append(tableInfo.getColumnName(column)).append(") REFERENCES ")
-                    .append(Cache.getTableName((Class<? extends IModel>) column.getType()))
-                    .append("(").append(foreignKey.foreignColumn()).append(")");
-
-            definitions.add(forDef.toString());
-        }
-
-
-		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
-				TextUtils.join(", ", definitions));
-	}
-
-	@SuppressWarnings("unchecked")
-	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
-		StringBuilder definition = new StringBuilder();
-
-		Class<?> type = field.getType();
-		final String name = tableInfo.getColumnName(field);
-		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-		final Column column = field.getAnnotation(Column.class);
-
-		if (typeSerializer != null) {
-			type = typeSerializer.getSerializedType();
-		}
-
-		if (TYPE_MAP.containsKey(type)) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(TYPE_MAP.get(type).toString());
-		}
-		else if (ReflectionUtils.isModel(type)) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(SQLiteType.INTEGER.toString());
-		}
-		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(SQLiteType.TEXT.toString());
-		}
-
-		if (!TextUtils.isEmpty(definition)) {
-			if (column.length() > -1) {
-				definition.append("(");
-				definition.append(column.length());
-				definition.append(")");
-			}
-
-			if (field.isAnnotationPresent(PrimaryKey.class)) {
-                PrimaryKey primaryKey = field.getAnnotation(PrimaryKey.class);
-                if(primaryKey.type().equals(PrimaryKey.Type.AUTO_INCREMENT)){
-				    definition.append(" PRIMARY KEY AUTOINCREMENT");
-                }
-			}
-
-			if (column.notNull()) {
-				definition.append(" NOT NULL ON CONFLICT ");
-				definition.append(column.onNullConflict().toString());
-			}
-
-			if (column.unique()) {
-				definition.append(" UNIQUE ON CONFLICT ");
-				definition.append(column.onUniqueConflict().toString());
-			}
-		}
-		else {
-			AALog.e("No type mapping for: " + type.toString());
-		}
-
-		return definition.toString();
-	}
-
-	@SuppressWarnings("unchecked")
-	public static <T extends IModel> List<T> processCursor(Class<? extends IModel> type, Cursor cursor) {
-		final List<T> entities = new ArrayList<T>();
-
-		try {
-			Constructor<?> entityConstructor = type.getConstructor();
-
-            //enable private constructors
-            entityConstructor.setAccessible(true);
-
-			if (cursor.moveToFirst()) {
-				do {
-					IModel entity = (T) entityConstructor.newInstance();
-					entity.loadFromCursor(cursor);
-					entities.add((T) entity);
-				}
-				while (cursor.moveToNext());
-			}
-
-		}
-        catch (IllegalArgumentException i){
-            throw new RuntimeException("Default constructor for: " + type.getName() + " was not found.");
-        } catch (Exception e) {
-			AALog.e("Failed to process cursor.", e);
-		}
-
-		return entities;
-	}
-
-    /**
-     * Returns the where statement with primary keys with no values
-     * @param tableInfo
-     * @return
-     */
-    public static String getWhereStatement(Class<? extends IModel> modelClass, TableInfo tableInfo){
-        List<Field> fields = new ArrayList<Field>();
-        ArrayList<Field> primaryColumn = new ArrayList<Field>();
-        fields = ReflectionUtils.getAllFields(fields, modelClass);
-
-        for(Field field : fields){
-            if(field.isAnnotationPresent(PrimaryKey.class)){
-                primaryColumn.add(field);
-            }
-        }
-
-        final StringBuilder where = new StringBuilder();
-        for(int i = 0 ; i < primaryColumn.size(); i++){
-            final Field field = primaryColumn.get(i);
-            where.append(tableInfo.getColumnName(field));
-            where.append("=?");
-
-            if(i < primaryColumn.size()-1){
-                where.append(" AND ");
-            }
-        }
-
-        String sql = where.toString();
-
-        return sql;
-    }
-
-    /**
-     * Returns the where statement with primary keys and values filled in
-     * @param IModel
-     * @param tableInfo
-     * @return
-     */
-    public static String getWhereStatement(IModel IModel, TableInfo tableInfo){
-        List<Field> fields = new ArrayList<Field>();
-        ArrayList<Field> primaryColumn = new ArrayList<Field>();
-        fields = ReflectionUtils.getAllFields(fields, IModel.getClass());
-
-        for(Field field : fields){
-            if(field.isAnnotationPresent(PrimaryKey.class)){
-                primaryColumn.add(field);
-            }
-        }
-
-        final StringBuilder where = new StringBuilder();
-        for(int i = 0 ; i < primaryColumn.size(); i++){
-            final Field field = primaryColumn.get(i);
-            where.append(tableInfo.getColumnName(field));
-            where.append("=?");
-
-            if(i < primaryColumn.size()-1){
-                where.append(" AND ");
-            }
-        }
-
-        String sql = where.toString();
-
-        for(int i = 0; i < primaryColumn.size(); i++){
-            final Field field = primaryColumn.get(i);
-            field.setAccessible(true);
-            try {
-                Object object = field.get(IModel);
-                if(object==null){
-                    throw new PrimaryKeyCannotBeNullException("The primary key: " + field.getName() + "from " + tableInfo.getTableName() + " cannot be null.");
-                } else {
-                    final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-                    if (typeSerializer != null) {
-                        // serialize data
-                        object = typeSerializer.serialize(object);
-                        // set new object type
-                        if (object != null) {
-                            Class fieldType = object.getClass();
-                            // check that the serializer returned what it promised
-                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
-                                AALog.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-                                        typeSerializer.getSerializedType(), fieldType));
-                            }
-                        }
-                    }
-
-                    if (object instanceof Number) {
-                        sql = sql.replaceFirst("\\?", object.toString());
-                    } else {
-                        String escaped = DatabaseUtils.sqlEscapeString(object.toString());
-
-                        sql = sql.replaceFirst("\\?", escaped);
-                    }
-                }
-            } catch (Throwable e) {
-                throw new RuntimeException(e);
-            }
-        }
-        return sql;
-    }
-
-    public static String getWhereFromEntityId(Class<? extends IModel> IModel, String entityId){
-        String[] primaries = entityId.split(",");
-        String whereString = getWhereStatement(IModel, Cache.getTableInfo(IModel));
-
-        List<Field> fields = new ArrayList<Field>();
-        fields = ReflectionUtils.getAllFields(fields, IModel);
-
-        ArrayList<Field> primaryColumn = new ArrayList<Field>();
-        for(Field field : fields){
-            if(field.isAnnotationPresent(PrimaryKey.class)){
-                primaryColumn.add(field);
-            }
-        }
-
-        for(int i = 0; i < primaries.length; i++){
-            final Field field = primaryColumn.get(i);
-            field.setAccessible(true);
-            try {
-                if(field.getType().isAssignableFrom(String.class)){
-                    String escaped = DatabaseUtils.sqlEscapeString(primaries[i]);
-                    whereString = whereString.replaceFirst("\\?", escaped);
-                } else {
-                    whereString = whereString.replaceFirst("\\?", primaries[i]);
-                }
-            } catch (Throwable e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        return whereString;
-    }
-
-    public static void delete(IModel IModel) {
-        delete(IModel, Cache.openDatabase());
-    }
-
-    public static void delete(IModel IModel, SQLiteDatabase database){
-        TableInfo tableInfo = Cache.getTableInfo(IModel.getClass());
-        database.delete(tableInfo.getTableName(), SQLiteUtils.getWhereStatement(IModel, tableInfo), null);
-        Cache.removeEntity(IModel);
-
-        Cache.getContext().getContentResolver()
-                .notifyChange(ContentProvider.createUri(tableInfo.getType(), IModel.getId()), null);
-    }
-
-
-    /**
-     *  {@link #save(com.activeandroid.IModel, int)} will check for the model to exist before inserting or updating
-     */
-    public static final int MODE_DEFAULT = 0;
-
-    /**
-     *  Used in {@link #save(com.activeandroid.IModel, int)}, we know the data is not new so we will update it all.
-     *  If it does not do anything, we will insert it
-     */
-    public static final int MODE_UPDATE = 1;
-
-    /**
-     * We will only attempt to insert the data into the DB
-     */
-    public static final int MODE_INSERT = 3;
-
-
-    /**
-     * Saves the given {@link com.activeandroid.IModel} to the DB with {@link #MODE_DEFAULT}
-     * @param iModel
-     */
-    public static void save(IModel iModel) {
-        save(iModel, MODE_DEFAULT);
-    }
-
-    /**
-     * Saves the given {@link com.activeandroid.IModel} to the DB.
-     * @param IModel
-     * @param mode
-     */
-    public static void save(IModel IModel, int mode) {
-        save(IModel, mode, Cache.openDatabase());
-    }
-
-    /**
-     * Saves the given {@link com.activeandroid.IModel} to the DB.
-     * @param IModel
-     * @param mode
-     * @param db The database to save to
-     */
-    public static void save(IModel IModel, int mode, SQLiteDatabase db){
-        TableInfo tableInfo = Cache.getTableInfo(IModel.getClass());
-        final ContentValues values = new ContentValues();
-
-        for (Field field : tableInfo.getFields()) {
-            PrimaryKey primaryKey = field.getAnnotation(PrimaryKey.class);
-
-            // skip autoincrement
-            if(primaryKey != null && primaryKey.type().equals(PrimaryKey.Type.AUTO_INCREMENT)) {
-                continue;
-            }
-            String fieldName = tableInfo.getColumnName(field);
-            Class<?> fieldType = field.getType();
-
-            field.setAccessible(true);
-
-            try {
-                Object value = field.get(IModel);
-
-                if (value != null) {
-                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-                    if (typeSerializer != null) {
-                        // serialize data
-                        value = typeSerializer.serialize(value);
-                        // set new object type
-                        if (value != null) {
-                            fieldType = value.getClass();
-                            // check that the serializer returned what it promised
-                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
-                                AALog.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-                                        typeSerializer.getSerializedType(), fieldType));
-                            }
-                        }
-                    }
-                }
-
-                // TODO: Find a smarter way to do this? This if block is necessary because we
-                // can't know the type until runtime.
-                if (value == null) {
-                    values.putNull(fieldName);
-                }
-                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-                    values.put(fieldName, (Byte) value);
-                }
-                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-                    values.put(fieldName, (Short) value);
-                }
-                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-                    values.put(fieldName, (Integer) value);
-                }
-                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-                    values.put(fieldName, (Long) value);
-                }
-                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-                    values.put(fieldName, (Float) value);
-                }
-                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-                    values.put(fieldName, (Double) value);
-                }
-                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-                    values.put(fieldName, (Boolean) value);
-                }
-                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-                    values.put(fieldName, value.toString());
-                }
-                else if (fieldType.equals(String.class)) {
-                    values.put(fieldName, value.toString());
-                }
-                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-                    values.put(fieldName, (byte[]) value);
-                }
-                else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
-                    ForeignKey key = field.getAnnotation(ForeignKey.class);
-                    if(!key.name().equals("")){
-                        fieldName = field.getAnnotation(ForeignKey.class).name();
-                    }
-                    values.put(fieldName, ((IModel) value).getId());
-                }
-                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-                    values.put(fieldName, ((Enum<?>) value).name());
-                }
-            }
-            catch (IllegalArgumentException e) {
-                AALog.e(e.getClass().getName(), e);
-            }
-            catch (IllegalAccessException e) {
-                AALog.e(e.getClass().getName(), e);
-            }
-        }
-
-        boolean exists = false;
-        if(mode == MODE_DEFAULT ) {
-            exists = exists(IModel);
-        } else if(mode == MODE_UPDATE) {
-            exists = true;
-        }
-
-        if(exists) {
-            exists = (db.update(tableInfo.getTableName(), values, SQLiteUtils.getWhereStatement(IModel, tableInfo), null) != 0);
-        }
-
-        if(!exists) {
-            long id = db.insert(tableInfo.getTableName(), null, values);
-            IModel.setRowId(id);
-            for(Field field : tableInfo.getPrimaryKeys()){
-                if(field.isAnnotationPresent(PrimaryKey.class) &&
-                        field.getAnnotation(PrimaryKey.class).type().equals(PrimaryKey.Type.AUTO_INCREMENT)){
-                    field.setAccessible(true);
-                    if(field.getType().isAssignableFrom(Long.class) || field.getType().isAssignableFrom(long.class)) {
-                        try {
-                            field.set(IModel, id);
-                        } catch (Throwable e) {
-                            throw new RuntimeException(e);
-                        }
-                    } else {
-                        throw new IllegalArgumentException("Autoincrementing field " + field.getName() + " must be a long");
-                    }
-                }
-            }
-        }
-
-        Cache.getContext().getContentResolver()
-                .notifyChange(ContentProvider.createUri(tableInfo.getType(), IModel.getId()), null);
-    }
-
-    public static void loadFromCursor(Cursor cursor, IModel IModel){
-        TableInfo tableInfo = Cache.getTableInfo(IModel.getClass());
-        for (Field field : tableInfo.getFields()) {
-            final String fieldName = tableInfo.getColumnName(field);
-            Class<?> fieldType = field.getType();
-            final int columnIndex = cursor.getColumnIndex(fieldName);
-
-            if (columnIndex < 0) {
-                continue;
-            }
-
-            field.setAccessible(true);
-
-            try {
-                boolean columnIsNull = cursor.isNull(columnIndex);
-                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-                Object value = null;
-
-                if (typeSerializer != null) {
-                    fieldType = typeSerializer.getSerializedType();
-                }
-
-                // TODO: Find a smarter way to do this? This if block is necessary because we
-                // can't know the type until runtime.
-                if (columnIsNull) {
-                    field = null;
-                }
-                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-                    value = cursor.getInt(columnIndex);
-                }
-                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-                    value = cursor.getInt(columnIndex);
-                }
-                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-                    value = cursor.getInt(columnIndex);
-                }
-                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-                    value = cursor.getLong(columnIndex);
-                }
-                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-                    value = cursor.getFloat(columnIndex);
-                }
-                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-                    value = cursor.getDouble(columnIndex);
-                }
-                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-                    value = cursor.getInt(columnIndex) != 0;
-                }
-                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-                    value = cursor.getString(columnIndex).charAt(0);
-                }
-                else if (fieldType.equals(String.class)) {
-                    value = cursor.getString(columnIndex);
-                }
-                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-                    value = cursor.getBlob(columnIndex);
-                }
-                else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
-                    final String entityId = cursor.getString(columnIndex);
-                    final Class<? extends IModel> entityType = (Class<? extends IModel>) fieldType;
-
-                    IModel entity = Cache.getEntity(entityType, entityId);
-                    if (entity == null) {
-                        entity = new Select().from(entityType).where(SQLiteUtils.getWhereFromEntityId(entityType, entityId)).executeSingle();
-                    }
-
-                    value = entity;
-                }
-                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-                    @SuppressWarnings("rawtypes")
-                    final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-                    value = Enum.valueOf(enumType, cursor.getString(columnIndex));
-                }
-
-                // Use a deserializer if one is available
-                if (typeSerializer != null && !columnIsNull) {
-                    value = typeSerializer.deserialize(value);
-                }
-
-                // Set the field name
-                if (value != null) {
-                    field.set(IModel, value);
-                }
-            }
-            catch (IllegalArgumentException e) {
-                AALog.e(e.getClass().getName(), e);
-            }
-            catch (IllegalAccessException e) {
-                AALog.e(e.getClass().getName(), e);
-            }
-            catch (SecurityException e) {
-                AALog.e(e.getClass().getName(), e);
-            }
-        }
-
-        if (IModel.getId() != null) {
-            Cache.addEntity(IModel);
-        }
-    }
-
-    public static boolean exists(IModel iModel){
-        IModel model = new Select().from(iModel.getClass()).where(SQLiteUtils.getWhereStatement(iModel, Cache.getTableInfo(iModel.getClass()))).executeSingle();
-        return model!=null;
-    }
-
-}
diff --git a/src/main/java/com/activeandroid/widget/AbstractManagerAdapter.java b/src/main/java/com/activeandroid/widget/AbstractManagerAdapter.java
deleted file mode 100644
index 9636417b..00000000
--- a/src/main/java/com/activeandroid/widget/AbstractManagerAdapter.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.activeandroid.widget;
-
-import android.widget.BaseAdapter;
-
-import com.activeandroid.manager.DBManager;
-import com.activeandroid.IModel;
-import com.activeandroid.interfaces.CollectionReceiver;
-
-import java.util.List;
-
-/**
- * Created by andrewgrosner
- * Date: 12/14/13
- * Contributors:
- * Description: Provides simple, type-safe implementation in an adapter, fetching objects from the DBManager
- */
-public abstract class AbstractManagerAdapter<OBJECT_CLASS extends IModel> extends BaseAdapter {
-
-    protected List<OBJECT_CLASS> mObjects;
-
-    private CollectionReceiver<OBJECT_CLASS> mReceiver = new CollectionReceiver<OBJECT_CLASS>() {
-        @Override
-        public void onCollectionReceived(List<OBJECT_CLASS> object) {
-            setData(object);
-        }
-    };
-
-    public AbstractManagerAdapter(DBManager<OBJECT_CLASS> manager){
-        super();
-        manager.fetchAll(mReceiver);
-    }
-
-    public AbstractManagerAdapter(DBManager<OBJECT_CLASS> manager, String sort){
-        super();
-        manager.fetchAllWithSort(sort, mReceiver);
-    }
-
-    public AbstractManagerAdapter(DBManager<OBJECT_CLASS> manager, Object value, String column){
-        super();
-        manager.fetchAllWithColumnValue(value, column, mReceiver);
-    }
-
-    public void setData(List<OBJECT_CLASS> objects){
-        mObjects = objects;
-        notifyDataSetChanged();
-    }
-
-    @Override
-    public int getCount() {
-        return mObjects==null? 0: mObjects.size();
-    }
-
-    @Override
-    public OBJECT_CLASS getItem(int i) {
-        return mObjects==null? null : mObjects.get(i);
-    }
-}
diff --git a/src/main/java/com/activeandroid/widget/ModelAdapter.java b/src/main/java/com/activeandroid/widget/ModelAdapter.java
deleted file mode 100644
index 86732533..00000000
--- a/src/main/java/com/activeandroid/widget/ModelAdapter.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.activeandroid.widget;
-
-import java.util.Collection;
-import java.util.List;
-
-import android.content.Context;
-import android.widget.ArrayAdapter;
-
-import com.activeandroid.IModel;
-
-public class ModelAdapter<T extends IModel> extends ArrayAdapter<T> {
-	public ModelAdapter(Context context, int textViewResourceId) {
-		super(context, textViewResourceId);
-	}
-
-	public ModelAdapter(Context context, int resource, int textViewResourceId) {
-		super(context, resource, textViewResourceId);
-	}
-
-	public ModelAdapter(Context context, int textViewResourceId, List<T> objects) {
-		super(context, textViewResourceId, objects);
-	}
-
-	public ModelAdapter(Context context, int resource, int textViewResourceId, List<T> objects) {
-		super(context, resource, textViewResourceId, objects);
-	}
-
-	/**
-	 * Clears the adapter and, if data != null, fills if with new Items.
-	 * 
-	 * @param collection A Collection<? extends T> which members get added to the adapter.
-	 */
-	public void setData(Collection<? extends T> collection) {
-		clear();
-
-		if (collection != null) {
-			for (T item : collection) {
-				add(item);
-			}
-		}
-	}
-
-	/**
-	 * @return The Id of the record at position.
-	 */
-	@Override
-	public long getItemId(int position) {
-		T item = getItem(position);
-
-		if (item != null) {
-			return item.getRowId();
-		}
-		else {
-			return -1;
-		}
-	}
-}
\ No newline at end of file
diff --git a/tests/.gitignore b/tests/.gitignore
deleted file mode 100644
index 6d0dc1c1..00000000
--- a/tests/.gitignore
+++ /dev/null
@@ -1,34 +0,0 @@
-#Android generated
-bin
-gen
-lint.xml
-
-#Eclipse
-.project
-.classpath
-.settings
-.checkstyle
-
-#IntelliJ IDEA
-.idea
-*.iml
-*.ipr
-*.iws
-classes
-gen-external-apklibs
-
-#Maven
-target
-release.properties
-pom.xml.*
-
-#Ant
-build.xml
-ant.properties
-local.properties
-proguard.cfg
-proguard-project.txt
-
-#Other
-.DS_Store
-tmp
diff --git a/tests/AndroidManifest.xml b/tests/AndroidManifest.xml
deleted file mode 100644
index 925693a9..00000000
--- a/tests/AndroidManifest.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.activeandroid.test"
-    android:versionCode="1"
-    android:versionName="1.0" >
-
-    <uses-sdk android:minSdkVersion="4" />
-
-    <instrumentation
-        android:name="android.test.InstrumentationTestRunner"
-        android:targetPackage="com.activeandroid.test" />
-
-    <application
-        android:icon="@drawable/ic_launcher"
-        android:label="@string/app_name" >
-        <uses-library android:name="android.test.runner" />
-    </application>
-
-</manifest>
\ No newline at end of file
diff --git a/tests/pom.xml b/tests/pom.xml
deleted file mode 100644
index 7958f720..00000000
--- a/tests/pom.xml
+++ /dev/null
@@ -1,79 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project
-  xmlns="http://maven.apache.org/POM/4.0.0"
-  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.activeandroid</groupId>
-    <artifactId>activeandroid-parent</artifactId>
-    <version>3.1-SNAPSHOT</version>
-  </parent>
-
-  <groupId>com.activeandroid</groupId>
-  <artifactId>activeandroid-tests</artifactId>
-  <version>3.1-SNAPSHOT</version>
-  <packaging>apk</packaging>
-  <name>ActiveAndroid - Tests</name>
-
-    <properties>
-        <java.version>1.6</java.version>
-        <platform.sdk>16</platform.sdk>
-        <platform.version>4.1.1.4</platform.version>
-        <platform.support-version>r7</platform.support-version>
-    </properties>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android-test</artifactId>
-      <version>${platform.version}</version>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.activeandroid</groupId>
-      <artifactId>activeandroid</artifactId>
-      <type>jar</type>
-      <version>3.1-SNAPSHOT</version>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <version>4.10</version>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-  <build>
-    <sourceDirectory>src</sourceDirectory>
-    <plugins>
-      <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-        <artifactId>android-maven-plugin</artifactId>
-        <version>3.6.0</version>
-        <configuration>
-          <androidManifestFile>${project.basedir}/AndroidManifest.xml</androidManifestFile>
-          <assetsDirectory>${project.basedir}/assets</assetsDirectory>
-          <resourceDirectory>${project.basedir}/res</resourceDirectory>
-          <sdk>
-            <platform>${platform.sdk}</platform>
-          </sdk>
-          <undeployBeforeDeploy>true</undeployBeforeDeploy>
-          <test>
-            <createReport>true</createReport>
-          </test>
-        </configuration>
-        <extensions>true</extensions>
-      </plugin>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>${java.version}</source>
-          <target>${java.version}</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/tests/project.properties b/tests/project.properties
deleted file mode 100644
index a3ee5ab6..00000000
--- a/tests/project.properties
+++ /dev/null
@@ -1,14 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-17
diff --git a/tests/res/drawable-hdpi/ic_launcher.png b/tests/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 96a442e5..00000000
Binary files a/tests/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/tests/res/drawable-ldpi/ic_launcher.png b/tests/res/drawable-ldpi/ic_launcher.png
deleted file mode 100644
index 99238729..00000000
Binary files a/tests/res/drawable-ldpi/ic_launcher.png and /dev/null differ
diff --git a/tests/res/drawable-mdpi/ic_launcher.png b/tests/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index 359047df..00000000
Binary files a/tests/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/tests/res/drawable-xhdpi/ic_launcher.png b/tests/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index 71c6d760..00000000
Binary files a/tests/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/tests/res/values/strings.xml b/tests/res/values/strings.xml
deleted file mode 100644
index 2d1ce35a..00000000
--- a/tests/res/values/strings.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-
-    <string name="app_name">TestsTest</string>
-
-</resources>
\ No newline at end of file
diff --git a/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java b/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
deleted file mode 100644
index ba5a9bdd..00000000
--- a/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.activeandroid.test;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.test.ApplicationTestCase;
-
-import com.activeandroid.app.AAApplication;
-
-public abstract class ActiveAndroidTestCase extends ApplicationTestCase<AAApplication> {
-	public ActiveAndroidTestCase() {
-		super(AAApplication.class);
-	}
-
-	protected void setUp() throws Exception {
-		super.setUp();
-		createApplication();
-	}
-
-	protected void tearDown() throws Exception {
-		super.tearDown();
-	}
-
-	public static <T> void assertArrayEquals(T[] actual, T... expected) {
-		assertEquals(expected.length, actual.length);
-		
-		for (int i = 0; i < expected.length; i++) {
-			assertEquals(expected[i], actual[i]);
-		}
-	}
-}
diff --git a/tests/src/com/activeandroid/test/MockModel.java b/tests/src/com/activeandroid/test/MockModel.java
deleted file mode 100644
index a6638043..00000000
--- a/tests/src/com/activeandroid/test/MockModel.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.activeandroid.test;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.IModel;
-import com.activeandroid.annotation.Table;
-
-@Table(name = "MockModel")
-public class MockModel extends IModel {
-}
diff --git a/tests/src/com/activeandroid/test/query/DeleteTest.java b/tests/src/com/activeandroid/test/query/DeleteTest.java
deleted file mode 100644
index 3d9a1d71..00000000
--- a/tests/src/com/activeandroid/test/query/DeleteTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.activeandroid.test.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.query.Delete;
-import com.activeandroid.test.MockModel;
-
-public class DeleteTest extends SqlableTestCase {
-	public void testDelete() {
-		assertSqlEquals("DELETE ", new Delete());
-	}
-
-	public void testFrom() {
-		assertSqlEquals("DELETE FROM MockModel",
-				new Delete().from(MockModel.class));
-	}
-}
diff --git a/tests/src/com/activeandroid/test/query/FromTest.java b/tests/src/com/activeandroid/test/query/FromTest.java
deleted file mode 100644
index 30523294..00000000
--- a/tests/src/com/activeandroid/test/query/FromTest.java
+++ /dev/null
@@ -1,166 +0,0 @@
-package com.activeandroid.test.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.IModel;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.query.From;
-import com.activeandroid.query.Select;
-import com.activeandroid.test.MockModel;
-
-public class FromTest extends SqlableTestCase {
-	private static final String SELECT_PREFIX = "SELECT ALL * FROM MockModel ";
-	
-	public void testLimit() {
-		assertSqlEquals(SELECT_PREFIX + "LIMIT 10",
-				from().limit(10));
-		assertSqlEquals(SELECT_PREFIX + "LIMIT 10",
-				from().limit("10"));
-	}
-	
-	public void testOffset() {
-		assertSqlEquals(SELECT_PREFIX + "OFFSET 10",
-				from().offset(10));
-		assertSqlEquals(SELECT_PREFIX + "OFFSET 10",
-				from().offset("10"));
-	}
-	
-	public void testLimitOffset() {
-		assertSqlEquals(SELECT_PREFIX + "LIMIT 10 OFFSET 20",
-				from().offset(20).limit(10));
-		assertSqlEquals(SELECT_PREFIX + "LIMIT 10 OFFSET 20",
-				from().limit(10).offset(20));
-	}
-	
-	public void testAs() {
-		assertSqlEquals(SELECT_PREFIX + "AS a",
-				from().as("a"));
-	}
-	
-	public void testOrderBy() {
-		assertSqlEquals(SELECT_PREFIX + "ORDER BY Id DESC",
-				from().orderBy("Id DESC"));
-	}
-	
-	public void testWhereNoArguments() {
-		assertSqlEquals(SELECT_PREFIX + "WHERE Id = 5",
-				from().where("Id = 5"));
-		
-		assertSqlEquals(SELECT_PREFIX + "WHERE Id = 5",
-				from().where("Id = 1").where("Id = 2").where("Id = 5"));
-	}
-	
-	public void testWhereWithArguments() {
-		From query = from().where("Id = ?", 5);
-		assertArrayEquals(query.getArguments(), "5");
-		assertSqlEquals(SELECT_PREFIX + "WHERE Id = ?",
-				query);
-		
-		query = from().where("Id > ? AND Id < ?", 5, 10);
-		assertArrayEquals(query.getArguments(), "5", "10");
-		assertSqlEquals(SELECT_PREFIX + "WHERE Id > ? AND Id < ?",
-				query);
-		
-		query = from()
-				.where("Id != ?", 10)
-				.where("Id IN (?, ?, ?)", 5, 10, 15)
-				.where("Id > ? AND Id < ?", 5, 10);
-		assertArrayEquals(query.getArguments(), "5", "10");
-		assertSqlEquals(SELECT_PREFIX + "WHERE Id > ? AND Id < ?",
-				query);
-	}
-	
-	public void testSingleJoin() {
-		assertSqlEquals(SELECT_PREFIX + "JOIN JoinModel ON MockModel.Id = JoinModel.Id",
-				from().join(JoinModel.class).on("MockModel.Id = JoinModel.Id"));
-		
-		assertSqlEquals(SELECT_PREFIX + "AS a JOIN JoinModel AS b ON a.Id = b.Id",
-				from().as("a").join(JoinModel.class).as("b").on("a.Id = b.Id"));
-		
-		assertSqlEquals(SELECT_PREFIX + "JOIN JoinModel USING (Id, other)",
-				from().join(JoinModel.class).using("Id", "other"));
-	}
-	
-	public void testJoins() {
-		assertSqlEquals(SELECT_PREFIX + "JOIN JoinModel ON Id JOIN JoinModel2 ON Id",
-				from().join(JoinModel.class).on("Id")
-				.join(JoinModel2.class).on("Id"));
-	}
-	
-	public void testJoinTypes() {
-		assertSqlEquals(SELECT_PREFIX + "INNER JOIN JoinModel ON",
-				from().innerJoin(JoinModel.class).on(""));
-		assertSqlEquals(SELECT_PREFIX + "OUTER JOIN JoinModel ON",
-				from().outerJoin(JoinModel.class).on(""));
-		assertSqlEquals(SELECT_PREFIX + "CROSS JOIN JoinModel ON",
-				from().crossJoin(JoinModel.class).on(""));
-	}
-	
-	public void testGroupByHaving() {
-		assertSqlEquals(SELECT_PREFIX + "GROUP BY Id",
-				from().groupBy("Id"));
-		assertSqlEquals(SELECT_PREFIX + "GROUP BY Id HAVING Id = 1",
-				from().groupBy("Id").having("Id = 1"));
-		assertSqlEquals(SELECT_PREFIX + "GROUP BY Id HAVING Id = 1",
-				from().having("Id = 1").groupBy("Id"));
-	}
-	
-	public void testAll() {
-		final String expectedSql = SELECT_PREFIX + "AS a JOIN JoinModel USING (Id) WHERE Id > 5 GROUP BY Id HAVING Id < 10 LIMIT 5 OFFSET 10";
-		
-		// Try a few different orderings, shouldn't change the output
-		assertSqlEquals(expectedSql,
-				from()
-					.as("a")
-					.where("Id > 5")
-					.join(JoinModel.class).using("Id")
-					.groupBy("Id")
-					.having("Id < 10")
-					.limit(5)
-					.offset(10));
-		assertSqlEquals(expectedSql,
-				from()
-					.offset(10)
-					.having("Id < 10")
-					.join(JoinModel.class).using("Id")
-					.limit(5)
-					.as("a")
-					.where("Id > 5")
-					.groupBy("Id"));
-		assertSqlEquals(expectedSql,
-				from()
-					.join(JoinModel.class).using("Id")
-					.offset(10)
-					.having("Id < 10")
-					.where("Id > 5")
-					.groupBy("Id")
-					.limit(5)
-					.as("a"));
-	}
-	
-	private From from() {
-		return new Select().all().from(MockModel.class);
-	}
-	
-	@Table(name = "JoinModel")
-	private static class JoinModel extends IModel {
-	}
-	
-	@Table(name = "JoinModel2")
-	private static class JoinModel2 extends IModel {
-	}
-}
diff --git a/tests/src/com/activeandroid/test/query/SelectTest.java b/tests/src/com/activeandroid/test/query/SelectTest.java
deleted file mode 100644
index 73bfe73d..00000000
--- a/tests/src/com/activeandroid/test/query/SelectTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package com.activeandroid.test.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.query.Select;
-import com.activeandroid.test.MockModel;
-
-public class SelectTest extends SqlableTestCase {
-	public void testSelectEmpty() {
-		assertSqlEquals("SELECT * ", new Select());
-	}
-
-	public void testSelectAll() {
-		assertSqlEquals("SELECT ALL * ", new Select().all());
-		assertSqlEquals("SELECT ALL * ", new Select().distinct().all());
-	}
-
-	public void testSelectDistinct() {
-		assertSqlEquals("SELECT DISTINCT * ", new Select().distinct());
-		assertSqlEquals("SELECT DISTINCT * ", new Select().all().distinct());
-	}
-
-	public void testSelectStringColumns() {
-		assertSqlEquals("SELECT a, b, c ", new Select("a", "b", "c"));
-	}
-
-	public void testSelectDistinctColumns() {
-		assertSqlEquals("SELECT DISTINCT a, b, c ",
-				new Select("a", "b", "c").distinct());
-	}
-
-	public void testFrom() {
-		assertSqlEquals("SELECT ALL * FROM MockModel",
-				new Select().all().from(MockModel.class));
-	}
-}
diff --git a/tests/src/com/activeandroid/test/query/SqlableTestCase.java b/tests/src/com/activeandroid/test/query/SqlableTestCase.java
deleted file mode 100644
index e206adcc..00000000
--- a/tests/src/com/activeandroid/test/query/SqlableTestCase.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.activeandroid.test.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.query.Sqlable;
-import com.activeandroid.test.ActiveAndroidTestCase;
-
-public abstract class SqlableTestCase extends ActiveAndroidTestCase {
-	public static void assertSqlEquals(String expected, Sqlable actual) {
-		assertEquals(expected, actual.toSql());
-	}
-}
diff --git a/tests/src/com/activeandroid/test/query/UpdateTest.java b/tests/src/com/activeandroid/test/query/UpdateTest.java
deleted file mode 100644
index 814d34f7..00000000
--- a/tests/src/com/activeandroid/test/query/UpdateTest.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package com.activeandroid.test.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.query.Set;
-import com.activeandroid.query.Update;
-import com.activeandroid.test.MockModel;
-
-public class UpdateTest extends SqlableTestCase {
-	private static final String UPDATE_PREFIX = "UPDATE MockModel ";
-	
-	public void testUpdate() {
-		assertSqlEquals(UPDATE_PREFIX, update());
-	}
-	
-	public void testUpdateSet() {
-		assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 ",
-				update().set("Id = 5"));
-	}
-	
-	public void testUpdateWhereNoArguments() {
-		assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 WHERE Id = 1 ",
-				update()
-					.set("Id = 5")
-					.where("Id = 1"));
-	}
-	
-	public void testUpdateWhereWithArguments() {
-		Set set = update()
-				.set("Id = 5")
-				.where("Id = ?", 1);
-		assertArrayEquals(set.getArguments(), "1");
-		assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 WHERE Id = ? ",
-				set);
-		
-		set = update()
-				.set("Id = 5")
-				.where("Id = ?", 1)
-				.where("Id IN (?, ?, ?)", 5, 4, 3);
-		assertArrayEquals(set.getArguments(), "5", "4", "3");
-		assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 WHERE Id IN (?, ?, ?) ",
-				set);
-	}
-	
-	private Update update() {
-		return new Update(MockModel.class);
-	}
-}
