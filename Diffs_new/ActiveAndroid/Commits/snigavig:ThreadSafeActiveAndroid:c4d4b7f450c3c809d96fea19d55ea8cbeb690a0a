diff --git a/.gitignore b/.gitignore
index 6029faf2..316cc9b2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,39 +1,35 @@
-#Android generated
-bin
-gen
-lint.xml
+# built application files
+*.apk
+*.ap_
 
-#Eclipse
-.project
-.classpath
-.settings
-.checkstyle
+# files for the dex VM
+*.dex
 
-#IntelliJ IDEA
-.idea
-*.iml
-*.ipr
-*.iws
-classes
-gen-external-apklibs
+# Java class files
+*.class
 
-#Maven
-target
-release.properties
-pom.xml.*
+# generated files
+bin/
+gen/
+out/
+build/
+proguard_logs/
 
-#Ant
-ant.properties
+# Local configuration file (sdk path, etc)
 local.properties
-proguard.cfg
-proguard-project.txt
 
-#Other
+# ==== Eclipse project files ====
+.classpath
+.project
+.settings
+.metadata
+
+# === Android Studio ===
+.idea
+**/*.iml
+*.iml
+libs/**/*.iml
 .DS_Store
-dist/
-tmp
 
-# Gradle
-.gradle
-/build
-/out
+# == Gradle staff ==
+.gradle/
diff --git a/.travis.yml b/.travis.yml
deleted file mode 100644
index bed811fd..00000000
--- a/.travis.yml
+++ /dev/null
@@ -1,40 +0,0 @@
-language: java
-jdk: oraclejdk7
-env: ANDROID_SDK=android-16 ANDROID_ABI=armeabi-v7a
-
-before_install:
-  # Install ia32-libs (necessary for Android SDK to run on 64-bit linux)
-  # - sudo apt-get clean && sudo apt-get update
-  - sudo apt-get update -qq
-  - sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch
-
-  # Install Android SDK
-  - wget http://dl.google.com/android/android-sdk_r22.6.2-linux.tgz
-  - tar -zxf android-sdk_r22.6.2-linux.tgz
-  - ls
-  - export ANDROID_HOME=`pwd`/android-sdk-linux
-  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
-
-  # Install build-tools
-  - wget https://dl-ssl.google.com/android/repository/build-tools_r19.0.3-linux.zip
-  - unzip build-tools_r19.0.3-linux.zip -d $ANDROID_HOME
-  - mkdir -p $ANDROID_HOME/build-tools/
-  - mv $ANDROID_HOME/android-4.4.2 $ANDROID_HOME/build-tools/19.0.1
-
-  # Install required Android components
-  - android list sdk --extended
-  # Do you accept the license 'android-sdk-license-bcbbd656' [y/n]:
-  - echo -ne "y\n" | android update sdk --filter system-image,platform-tools,extra-android-support,$ANDROID_SDK --no-ui --force
-
-  # Create and start emulator
-  - echo no | android create avd --force -n test -t $ANDROID_SDK --abi $ANDROID_ABI
-  - android list avds
-  - emulator -avd test -no-skin -no-audio -no-window &
-
-before_script:
-  # Make sure the emulator has started before running tests
-  - chmod +x ./wait_for_emulator
-  - ./wait_for_emulator
-
-script:
-  - mvn clean install -e
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
deleted file mode 100644
index 842ed881..00000000
--- a/AndroidManifest.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.activeandroid">
-
-    <uses-sdk android:minSdkVersion="16" />
-    <application android:allowBackup="true" />
-</manifest>
\ No newline at end of file
diff --git a/README.md b/README.md
index 2e7c9e4d..ecf95a1e 100644
--- a/README.md
+++ b/README.md
@@ -1,69 +1,98 @@
-[![Build Status](https://travis-ci.org/pardom/ActiveAndroid.png?branch=master)](https://travis-ci.org/pardom/ActiveAndroid) [![Stories in Ready](https://badge.waffle.io/pardom/ActiveAndroid.png)](http://waffle.io/pardom/ActiveAndroid)  
-# ActiveAndroid
+#Static map
 
-ActiveAndroid is an active record style ORM ([object relational mapper](http://en.wikipedia.org/wiki/Object-relational_mapping)). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like _save()_ and _delete()_.
+[![Maven](https://img.shields.io/badge/maven-0.1.3-brightgreen.svg)](http://search.maven.org/#artifactdetails%7Ccom.github.d-max%7Cstatic-map%7C0.1.3%7Caar)
+[![Blog Post](https://img.shields.io/badge/blog-post-yellow.svg)](http://dybarsky.blogspot.com/2014/08/static-map-library.html)
 
-ActiveAndroid does so much more than this though. Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration.
+NOT SUPPORTED ANYMORE!
 
-## Download
+Google made its own lite mode of google maps in play services v6.5
+https://developers.google.com/maps/documentation/android/lite
 
-Grab via Maven:
-```xml
-<dependency>
-  <groupId>com.michaelpardo</groupId>
-  <artifactId>activeandroid</artifactId>
-  <version>3.1.0-SNAPSHOT</version>
-</dependency>
-```
-or Gradle:
-```groovy
-repositories {
-    mavenCentral()
-    maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
-}
-
-compile 'com.michaelpardo:activeandroid:3.1.0-SNAPSHOT'
-```
-
-## Documentation
+==========
+ 
+This is standalone android library developed to generate static map images easily. It is based on [Google Static Maps API][4] and provides **sync** and **async** ways of bitmaps generation.
 
-* [Getting started](http://github.com/pardom/ActiveAndroid/wiki/Getting-started)
-* [Creating your database model](http://github.com/pardom/ActiveAndroid/wiki/Creating-your-database-model)
-* [Saving to the database](http://github.com/pardom/ActiveAndroid/wiki/Saving-to-the-database)
-* [Querying the database](http://github.com/pardom/ActiveAndroid/wiki/Querying-the-database)
-* [Type serializers](http://github.com/pardom/ActiveAndroid/wiki/Type-serializers)
-* [Using the content provider](http://github.com/pardom/ActiveAndroid/wiki/Using-the-content-provider)
-* [Schema migrations](http://github.com/pardom/ActiveAndroid/wiki/Schema-migrations)
-* [Pre-populated-databases](http://github.com/pardom/ActiveAndroid/wiki/Pre-populated-databases)
-* [Running the Test Suite](https://github.com/pardom/ActiveAndroid/wiki/Running-the-Test-Suite)
+Next features are supported:
+* Secure access (https)
+* Location (geo position, address)
+* Map types (roads, satellite, etc)
+* Zoom, scale, image size params
+* Markers (without custom icon)
 
-## License
+![Example Image1][1] ⠀
+![Example Image2][2] ⠀
+![Example Image3][3]
 
-[Apache Version 2.0](http://www.apache.org/licenses/LICENSE-2.0.html)
+###Usage
 
-    Copyright (C) 2010 Michael Pardo
+Google Static Map API documentation is available [here][4]. Please, read it first if you are not familiar with service requirements and differences.
+Static-map library available in maven central repository. You can get it using:
+```groovy
+dependencies {
+    compile 'com.github.d-max:static-map:0.1+@aar'
+}
+```
+Javadoc and sources package [classigiers][8] available too.
+
+Use [Config][5] class to set map generation basic params. Example:
+```java
+Config config = new Config();
+config.setImageSize(200, 300)
+      .setZoom(10)
+      .setAddress("Kyiv");
+```
+[StaticMap][6] class contais two static methods for map generation. To get map image *synchronously* use like this:
+```java
+try {
+    Bitmap mapImage = StaticMap.requestMapImage(context, config);
+} catch (StaticMapException ex) { /* log */ }
+```
+To get map image *asynchronously*, use another method with [Callback][7] param:
+```java
+Bitmap mapImage;
+Callback callback = new Callback() {
+    public void onFailed(int errorCode, String errorMessage) { /* log */ }
+    public void onMapGenerated(Bitmap bitmap) { mapImage = bitmap; }
+};
+StaticMap.requestMapImage(context, config, callback);
+```
+This method encapsulates AsyncTask class to load image in background.
+**Note:** Callback class methods will be invoked in main thread.
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
 
-       http://www.apache.org/licenses/LICENSE-2.0
+###Developed By
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+Maksym Dybarskyi - http://d-max.info
 
-## Contributing
+###License
 
-Please fork this repository and contribute back using [pull requests](http://github.com/pardom/ActiveAndroid/pulls).
+	The MIT License (MIT)
+	Copyright © 2014 Maxim Dybarsky
 
-Any contributions, large or small, major features, bug fixes, unit tests are welcomed and appreciated but will be thoroughly reviewed and discussed.
+	Permission is hereby granted, free of charge, to any person obtaining a copy
+	of this software and associated documentation files (the “Software”), to deal
+	in the Software without restriction, including without limitation the rights
+	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+	copies of the Software, and to permit persons to whom the Software is
+	furnished to do so, subject to the following conditions:
 
-You can run the test suite by following the instructions on the [Running the Test Suite](https://github.com/pardom/ActiveAndroid/wiki/Running-the-Test-Suite) Wiki page.
+	The above copyright notice and this permission notice shall be included in
+	all copies or substantial portions of the Software.
 
+	THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+	THE SOFTWARE.
 
-## Author
 
-Michael Pardo | www.michaelpardo.com | www.activeandroid.com
+[1]: http://maps.google.com/maps/api/staticmap?size=200x200&center=49,31&zoom=4&maptype=sattelite
+[2]: http://maps.google.com/maps/api/staticmap?size=200x200&center=50,0&zoom=3&maptype=satellite
+[3]: http://maps.google.com/maps/api/staticmap?size=200x200&center=50.4513,30.522&zoom=15&markers=color:blue%7C50.450866,30.522873
+[4]: https://developers.google.com/maps/documentation/staticmaps/
+[5]: library/src/main/java/dmax/staticmap/Config.java
+[6]: library/src/main/java/dmax/staticmap/StaticMap.java
+[7]: library/src/main/java/dmax/staticmap/Callback.java
+[8]: http://www.gradle.org/docs/current/userguide/dependency_management.html#sub:classifiers
diff --git a/build.gradle b/build.gradle
index 0d60bbb7..ee123693 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,35 +1,12 @@
-apply plugin: 'com.android.library'
-apply plugin: 'maven'
-apply plugin: 'signing'
-// configure android plugin
-android {
-    compileSdkVersion Integer.parseInt(COMPILE_SDK_VERSION)
-    buildToolsVersion BUILD_TOOLS_VERSION
-
-    defaultConfig {
-        minSdkVersion Integer.parseInt(MIN_SDK_VERSION)
-        targetSdkVersion Integer.parseInt(TARGET_SDK_VERSION)
-    }
-
-    compileOptions {
-        sourceCompatibility JavaVersion.VERSION_1_6
-        targetCompatibility JavaVersion.VERSION_1_6
-    }
+subprojects {
+    buildscript {
+        repositories {
+            mavenCentral()
+        }
 
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            resources.srcDirs = ['src']
-            aidl.srcDirs = ['src']
-            renderscript.srcDirs = ['src']
-            res.srcDirs = ['res']
-            assets.srcDirs = ['assets']
+        dependencies {
+            classpath 'com.android.tools.build:gradle:1.2.3'
+            classpath 'com.github.dcendents:android-maven-plugin:1.2'
         }
-        androidTest.setRoot('tests')
     }
 }
-
-dependencies {
-    compile 'com.android.support:support-v4:22.2.0'
-}
\ No newline at end of file
diff --git a/build.xml b/build.xml
deleted file mode 100644
index b2b7bfa6..00000000
--- a/build.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0"?>
-<project name="ActiveAndroid" default="dist" basedir=".">
-
-	<property name="dist.dir"  value="dist" />
-    <property name="src.dir"   value="src" />
-	<property name="build.dir" value="bin" />
-	<property name="lib.dir"   value="libs"/>
-	
-	<target name="dist" depends="clean, package" />
-
-	<target name="clean">
-		<delete dir="${build.dir}" />
-		<delete dir="${dist.dir}" />
-	</target>
-
-	<target name="init">
-		<mkdir dir="${build.dir}"/>
-		<mkdir dir="${dist.dir}" />
-	</target>
-
-	<path id="classpath">
-        <fileset dir="${lib.dir}" includes="**/*.jar"/>
-    </path>
-    
-	<target name="compile">
-    	<javac srcdir="${src.dir}" destdir="${build.dir}" source="1.5" target="1.5" classpathref="classpath" debug="off" />
-	</target>
-		
-	<target name="package" depends="init, compile">
-		<jar destfile="${dist.dir}/ActiveAndroid.jar" basedir="${build.dir}"/>
-	</target>
-</project>
diff --git a/gradle-mvn-push.gradle b/gradle-mvn-push.gradle
deleted file mode 100644
index 8b88acd9..00000000
--- a/gradle-mvn-push.gradle
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright 2013 Chris Banes
- * Copyright 2014 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-apply plugin: 'maven'
-apply plugin: 'signing'
-
-def isReleaseBuild() {
-	return VERSION_NAME.contains("SNAPSHOT") == false
-}
-
-def getReleaseRepositoryUrl() {
-	return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
-			: "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
-}
-
-def getSnapshotRepositoryUrl() {
-	return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
-			: "https://oss.sonatype.org/content/repositories/snapshots/"
-}
-
-def getRepositoryUsername() {
-	return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
-}
-
-def getRepositoryPassword() {
-	return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
-}
-
-afterEvaluate { project ->
-	uploadArchives {
-		repositories {
-			mavenDeployer {
-				beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
-
-				pom.groupId = GROUP
-				pom.artifactId = POM_ARTIFACT_ID
-				pom.version = VERSION_NAME
-
-				repository(url: getReleaseRepositoryUrl()) {
-					authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
-				}
-				snapshotRepository(url: getSnapshotRepositoryUrl()) {
-					authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
-				}
-
-				pom.project {
-					name POM_NAME
-					packaging POM_PACKAGING
-					description POM_DESCRIPTION
-					url POM_URL
-
-					scm {
-						url POM_SCM_URL
-						connection POM_SCM_CONNECTION
-						developerConnection POM_SCM_DEV_CONNECTION
-					}
-
-					licenses {
-						license {
-							name POM_LICENCE_NAME
-							url POM_LICENCE_URL
-							distribution POM_LICENCE_DIST
-						}
-					}
-
-					developers {
-						developer {
-							id POM_DEVELOPER_ID
-							name POM_DEVELOPER_NAME
-						}
-					}
-				}
-			}
-		}
-	}
-
-	signing {
-		required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
-		sign configurations.archives
-	}
-
-	task javadocs(type: Javadoc) {
-		source = sourceSets.main.allJava
-		classpath = configurations.compile
-	}
-
-	task javadocsJar(type: Jar, dependsOn: javadocs) {
-		classifier = 'javadoc'
-		from javadocs.destinationDir
-	}
-
-	task sourcesJar(type: Jar) {
-		classifier = 'sources'
-		from sourceSets.main.allJava
-	}
-
-	artifacts {
-		archives sourcesJar
-		archives javadocsJar
-	}
-}
diff --git a/gradle.properties b/gradle.properties
index c44c6c94..b14bfdc7 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,4 +1,4 @@
 COMPILE_SDK_VERSION = 22
-BUILD_TOOLS_VERSION = 22.0.1
-MIN_SDK_VERSION = 16
-TARGET_SDK_VERSION = 22
+BUILD_TOOLS_VERSION = 21.1.2
+MIN_SDK_VERSION = 14
+TARGET_SDK_VERSION = 22
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 667288ad..8c0fb64a 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index a1381595..0c71e760 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sun Jun 14 16:37:42 EEST 2015
+#Wed Apr 10 15:27:10 PDT 2013
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/library/build.gradle b/library/build.gradle
new file mode 100644
index 00000000..63e84177
--- /dev/null
+++ b/library/build.gradle
@@ -0,0 +1,47 @@
+apply plugin: 'com.android.library'
+apply plugin: 'android-maven'
+android {
+    compileSdkVersion 22
+    buildToolsVersion '21.1.2'
+    // resourcePrefix 'mpcht'
+    defaultConfig {
+        minSdkVersion 8
+        targetSdkVersion 22
+        versionCode 1
+        versionName '1.0'
+
+        sourceSets {
+            main {
+                java.srcDirs = ['src/main/java']
+                res.srcDirs = ['src/main/res']
+                manifest.srcFile 'src/main/AndroidManifest.xml'
+            }
+        }
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+    lintOptions {
+        abortOnError false
+    }
+}
+android.libraryVariants.all { variant ->
+    def name = variant.buildType.name
+    def task = project.tasks.create "jar${name.capitalize()}", Jar
+    task.dependsOn variant.javaCompile
+    task.from variant.javaCompile.destinationDir
+    artifacts.add('archives', task);
+}
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+artifacts {
+    archives sourcesJar
+}
+dependencies {
+    compile files('src/libs/android-support-v4.jar')
+}
\ No newline at end of file
diff --git a/library/gradle.properties b/library/gradle.properties
new file mode 100755
index 00000000..c44c6c94
--- /dev/null
+++ b/library/gradle.properties
@@ -0,0 +1,4 @@
+COMPILE_SDK_VERSION = 22
+BUILD_TOOLS_VERSION = 22.0.1
+MIN_SDK_VERSION = 16
+TARGET_SDK_VERSION = 22
diff --git a/libs/android-support-v4.jar b/library/src/libs/android-support-v4.jar
similarity index 100%
rename from libs/android-support-v4.jar
rename to library/src/libs/android-support-v4.jar
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..9ca21b10
--- /dev/null
+++ b/library/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.activeandroid">
+
+    <application />
+</manifest>
diff --git a/library/src/main/java/com/activeandroid/ActiveAndroid.java b/library/src/main/java/com/activeandroid/ActiveAndroid.java
new file mode 100644
index 00000000..78cce41b
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/ActiveAndroid.java
@@ -0,0 +1,86 @@
+package com.activeandroid;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+
+import com.activeandroid.util.Log;
+
+public final class ActiveAndroid {
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static void initialize(Context context) {
+        initialize(new Configuration.Builder(context).create());
+    }
+
+    public static void initialize(Configuration configuration) {
+        initialize(configuration, false);
+    }
+
+    public static void initialize(Context context, boolean loggingEnabled) {
+        initialize(new Configuration.Builder(context).create(), loggingEnabled);
+    }
+
+    public static void initialize(Configuration configuration, boolean loggingEnabled) {
+        // Set logging enabled first
+        setLoggingEnabled(loggingEnabled);
+        Cache.initialize(configuration);
+    }
+
+    public static void clearCache() {
+        Cache.clear();
+    }
+
+    public static void dispose() {
+        Cache.dispose();
+    }
+
+    public static void setLoggingEnabled(boolean enabled) {
+        Log.setEnabled(enabled);
+    }
+
+    public static SQLiteDatabase getDatabase() {
+        return Cache.openDatabase();
+    }
+
+    public static void beginTransaction() {
+        Cache.openDatabase().beginTransactionNonExclusive();
+    }
+
+    public static void endTransaction() {
+        Cache.openDatabase().endTransaction();
+    }
+
+    public static void setTransactionSuccessful() {
+        Cache.openDatabase().setTransactionSuccessful();
+    }
+
+    public static boolean inTransaction() {
+        return Cache.openDatabase().inTransaction();
+    }
+
+    public static void execSQL(String sql) {
+        Cache.openDatabase().execSQL(sql);
+    }
+
+    public static void execSQL(String sql, Object[] bindArgs) {
+        Cache.openDatabase().execSQL(sql, bindArgs);
+    }
+}
diff --git a/library/src/main/java/com/activeandroid/Cache.java b/library/src/main/java/com/activeandroid/Cache.java
new file mode 100644
index 00000000..6b9aaead
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/Cache.java
@@ -0,0 +1,158 @@
+package com.activeandroid;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.support.v4.util.LruCache;
+
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.util.Log;
+
+import java.util.Collection;
+
+public final class Cache {
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static final int DEFAULT_CACHE_SIZE = 1024;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private static Context sContext;
+
+    private static ModelInfo sModelInfo;
+    private static DatabaseHelper sDatabaseHelper;
+
+    private static LruCache<String, Model> sEntities;
+
+    private static boolean sIsInitialized = false;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Cache() {
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static synchronized void initialize(Configuration configuration) {
+        if (sIsInitialized) {
+            Log.v("ActiveAndroid already initialized.");
+            return;
+        }
+
+        sContext = configuration.getContext();
+        sModelInfo = new ModelInfo(configuration);
+        sDatabaseHelper = new DatabaseHelper(configuration);
+
+        // TODO: It would be nice to override sizeOf here and calculate the memory
+        // actually used, however at this point it seems like the reflection
+        // required would be too costly to be of any benefit. We'll just set a max
+        // object size instead.
+        sEntities = new LruCache<String, Model>(configuration.getCacheSize());
+
+        openDatabase();
+
+        sIsInitialized = true;
+
+        Log.v("ActiveAndroid initialized successfully.");
+    }
+
+    public static synchronized void clear() {
+        sEntities.evictAll();
+        Log.v("Cache cleared.");
+    }
+
+    public static synchronized void dispose() {
+        closeDatabase();
+
+        sEntities = null;
+        sModelInfo = null;
+        sDatabaseHelper = null;
+
+        sIsInitialized = false;
+
+        Log.v("ActiveAndroid disposed. Call initialize to use library.");
+    }
+
+    // Database access
+
+    public static boolean isInitialized() {
+        return sIsInitialized;
+    }
+
+    public static synchronized SQLiteDatabase openDatabase() {
+        return sDatabaseHelper.getWritableDatabase();
+    }
+
+    public static synchronized void closeDatabase() {
+        sDatabaseHelper.close();
+    }
+
+    // Context access
+
+    public static Context getContext() {
+        return sContext;
+    }
+
+    // Entity cache
+
+    public static String getIdentifier(Class<? extends Model> type, Long id) {
+        return getTableName(type) + "@" + id;
+    }
+
+    public static String getIdentifier(Model entity) {
+        return getIdentifier(entity.getClass(), entity.getId());
+    }
+
+    public static synchronized void addEntity(Model entity) {
+        sEntities.put(getIdentifier(entity), entity);
+    }
+
+    public static synchronized Model getEntity(Class<? extends Model> type, long id) {
+        return sEntities.get(getIdentifier(type, id));
+    }
+
+    public static synchronized void removeEntity(Model entity) {
+        sEntities.remove(getIdentifier(entity));
+    }
+
+    // Model cache
+
+    public static synchronized Collection<TableInfo> getTableInfos() {
+        return sModelInfo.getTableInfos();
+    }
+
+    public static synchronized TableInfo getTableInfo(Class<? extends Model> type) {
+        return sModelInfo.getTableInfo(type);
+    }
+
+    public static synchronized TypeSerializer getParserForType(Class<?> type) {
+        return sModelInfo.getTypeSerializer(type);
+    }
+
+    public static synchronized String getTableName(Class<? extends Model> type) {
+        return sModelInfo.getTableInfo(type).getTableName();
+    }
+}
diff --git a/library/src/main/java/com/activeandroid/Configuration.java b/library/src/main/java/com/activeandroid/Configuration.java
new file mode 100644
index 00000000..1b47b079
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/Configuration.java
@@ -0,0 +1,317 @@
+package com.activeandroid;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.content.Context;
+
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class Configuration {
+
+    public final static String SQL_PARSER_LEGACY = "legacy";
+    public final static String SQL_PARSER_DELIMITED = "delimited";
+    public final static int MAX_SQL_CACHE_SIZE = 100;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Context mContext;
+    private String mDatabaseName;
+    private int mDatabaseVersion;
+    private String mSqlParser;
+    private List<Class<? extends Model>> mModelClasses;
+    private List<Class<? extends TypeSerializer>> mTypeSerializers;
+    private int mCacheSize;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Configuration(Context context) {
+        mContext = context;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Context getContext() {
+        return mContext;
+    }
+
+    public String getDatabaseName() {
+        return mDatabaseName;
+    }
+
+    public int getDatabaseVersion() {
+        return mDatabaseVersion;
+    }
+
+    public String getSqlParser() {
+        return mSqlParser;
+    }
+
+    public List<Class<? extends Model>> getModelClasses() {
+        return mModelClasses;
+    }
+
+    public List<Class<? extends TypeSerializer>> getTypeSerializers() {
+        return mTypeSerializers;
+    }
+
+    public int getCacheSize() {
+        return mCacheSize;
+    }
+
+    public boolean isValid() {
+        return mModelClasses != null && mModelClasses.size() > 0;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // INNER CLASSES
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static class Builder {
+        //////////////////////////////////////////////////////////////////////////////////////
+        // PRIVATE CONSTANTS
+        //////////////////////////////////////////////////////////////////////////////////////
+
+        private static final String AA_DB_NAME = "AA_DB_NAME";
+        private static final String AA_DB_VERSION = "AA_DB_VERSION";
+        private final static String AA_MODELS = "AA_MODELS";
+        private final static String AA_SERIALIZERS = "AA_SERIALIZERS";
+        private final static String AA_SQL_PARSER = "AA_SQL_PARSER";
+
+        private static final int DEFAULT_CACHE_SIZE = 1024;
+        private static final String DEFAULT_DB_NAME = "Application.db";
+        private static final String DEFAULT_SQL_PARSER = SQL_PARSER_LEGACY;
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        // PRIVATE MEMBERS
+        //////////////////////////////////////////////////////////////////////////////////////
+
+        private Context mContext;
+
+        private Integer mCacheSize;
+        private String mDatabaseName;
+        private Integer mDatabaseVersion;
+        private String mSqlParser;
+        private List<Class<? extends Model>> mModelClasses;
+        private List<Class<? extends TypeSerializer>> mTypeSerializers;
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        // CONSTRUCTORS
+        //////////////////////////////////////////////////////////////////////////////////////
+
+        public Builder(Context context) {
+            mContext = context.getApplicationContext();
+            mCacheSize = DEFAULT_CACHE_SIZE;
+        }
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        // PUBLIC METHODS
+        //////////////////////////////////////////////////////////////////////////////////////
+
+        public Builder setCacheSize(int cacheSize) {
+            mCacheSize = cacheSize;
+            return this;
+        }
+
+        public Builder setDatabaseName(String databaseName) {
+            mDatabaseName = databaseName;
+            return this;
+        }
+
+        public Builder setDatabaseVersion(int databaseVersion) {
+            mDatabaseVersion = databaseVersion;
+            return this;
+        }
+
+        public Builder setSqlParser(String sqlParser) {
+            mSqlParser = sqlParser;
+            return this;
+        }
+
+        public Builder addModelClass(Class<? extends Model> modelClass) {
+            if (mModelClasses == null) {
+                mModelClasses = new ArrayList<Class<? extends Model>>();
+            }
+
+            mModelClasses.add(modelClass);
+            return this;
+        }
+
+        public Builder addModelClasses(Class<? extends Model>... modelClasses) {
+            if (mModelClasses == null) {
+                mModelClasses = new ArrayList<Class<? extends Model>>();
+            }
+
+            mModelClasses.addAll(Arrays.asList(modelClasses));
+            return this;
+        }
+
+        public Builder setModelClasses(Class<? extends Model>... modelClasses) {
+            mModelClasses = Arrays.asList(modelClasses);
+            return this;
+        }
+
+        public Builder addTypeSerializer(Class<? extends TypeSerializer> typeSerializer) {
+            if (mTypeSerializers == null) {
+                mTypeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
+            }
+
+            mTypeSerializers.add(typeSerializer);
+            return this;
+        }
+
+        public Builder addTypeSerializers(Class<? extends TypeSerializer>... typeSerializers) {
+            if (mTypeSerializers == null) {
+                mTypeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
+            }
+
+            mTypeSerializers.addAll(Arrays.asList(typeSerializers));
+            return this;
+        }
+
+        public Builder setTypeSerializers(Class<? extends TypeSerializer>... typeSerializers) {
+            mTypeSerializers = Arrays.asList(typeSerializers);
+            return this;
+        }
+
+        public Configuration create() {
+            Configuration configuration = new Configuration(mContext);
+            configuration.mCacheSize = mCacheSize;
+
+            // Get database name from meta-data
+            if (mDatabaseName != null) {
+                configuration.mDatabaseName = mDatabaseName;
+            } else {
+                configuration.mDatabaseName = getMetaDataDatabaseNameOrDefault();
+            }
+
+            // Get database version from meta-data
+            if (mDatabaseVersion != null) {
+                configuration.mDatabaseVersion = mDatabaseVersion;
+            } else {
+                configuration.mDatabaseVersion = getMetaDataDatabaseVersionOrDefault();
+            }
+
+            // Get SQL parser from meta-data
+            if (mSqlParser != null) {
+                configuration.mSqlParser = mSqlParser;
+            } else {
+                configuration.mSqlParser = getMetaDataSqlParserOrDefault();
+            }
+
+            // Get model classes from meta-data
+            if (mModelClasses != null) {
+                configuration.mModelClasses = mModelClasses;
+            } else {
+                final String modelList = ReflectionUtils.getMetaData(mContext, AA_MODELS);
+                if (modelList != null) {
+                    configuration.mModelClasses = loadModelList(modelList.split(","));
+                }
+            }
+
+            // Get type serializer classes from meta-data
+            if (mTypeSerializers != null) {
+                configuration.mTypeSerializers = mTypeSerializers;
+            } else {
+                final String serializerList = ReflectionUtils.getMetaData(mContext, AA_SERIALIZERS);
+                if (serializerList != null) {
+                    configuration.mTypeSerializers = loadSerializerList(serializerList.split(","));
+                }
+            }
+
+            return configuration;
+        }
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        // PRIVATE METHODS
+        //////////////////////////////////////////////////////////////////////////////////////
+
+        // Meta-data methods
+
+        private String getMetaDataDatabaseNameOrDefault() {
+            String aaName = ReflectionUtils.getMetaData(mContext, AA_DB_NAME);
+            if (aaName == null) {
+                aaName = DEFAULT_DB_NAME;
+            }
+
+            return aaName;
+        }
+
+        private int getMetaDataDatabaseVersionOrDefault() {
+            Integer aaVersion = ReflectionUtils.getMetaData(mContext, AA_DB_VERSION);
+            if (aaVersion == null || aaVersion == 0) {
+                aaVersion = 1;
+            }
+
+            return aaVersion;
+        }
+
+        private String getMetaDataSqlParserOrDefault() {
+            final String mode = ReflectionUtils.getMetaData(mContext, AA_SQL_PARSER);
+            if (mode == null) {
+                return DEFAULT_SQL_PARSER;
+            }
+            return mode;
+        }
+
+        private List<Class<? extends Model>> loadModelList(String[] models) {
+            final List<Class<? extends Model>> modelClasses = new ArrayList<Class<? extends Model>>();
+            final ClassLoader classLoader = mContext.getClass().getClassLoader();
+            for (String model : models) {
+                try {
+                    Class modelClass = Class.forName(model.trim(), false, classLoader);
+                    if (ReflectionUtils.isModel(modelClass)) {
+                        modelClasses.add(modelClass);
+                    }
+                } catch (ClassNotFoundException e) {
+                    Log.e("Couldn't create class.", e);
+                }
+            }
+
+            return modelClasses;
+        }
+
+        private List<Class<? extends TypeSerializer>> loadSerializerList(String[] serializers) {
+            final List<Class<? extends TypeSerializer>> typeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
+            final ClassLoader classLoader = mContext.getClass().getClassLoader();
+            for (String serializer : serializers) {
+                try {
+                    Class serializerClass = Class.forName(serializer.trim(), false, classLoader);
+                    if (ReflectionUtils.isTypeSerializer(serializerClass)) {
+                        typeSerializers.add(serializerClass);
+                    }
+                } catch (ClassNotFoundException e) {
+                    Log.e("Couldn't create class.", e);
+                }
+            }
+
+            return typeSerializers;
+        }
+
+    }
+}
diff --git a/src/com/activeandroid/DatabaseHelper.java b/library/src/main/java/com/activeandroid/DatabaseHelper.java
similarity index 100%
rename from src/com/activeandroid/DatabaseHelper.java
rename to library/src/main/java/com/activeandroid/DatabaseHelper.java
diff --git a/library/src/main/java/com/activeandroid/Model.java b/library/src/main/java/com/activeandroid/Model.java
new file mode 100644
index 00000000..4f6c0479
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/Model.java
@@ -0,0 +1,290 @@
+package com.activeandroid;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+
+import com.activeandroid.content.ContentProvider;
+import com.activeandroid.query.Delete;
+import com.activeandroid.query.Select;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+@SuppressWarnings("unchecked")
+public abstract class Model {
+
+    /**
+     * Prime number used for hashcode() implementation.
+     */
+    private static final int HASH_PRIME = 739;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+    private final TableInfo mTableInfo;
+    private final String idName;
+    private Long mId = null;
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Model() {
+        mTableInfo = Cache.getTableInfo(getClass());
+        idName = mTableInfo.getIdName();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static void delete(Class<? extends Model> type, long id) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        new Delete().from(type).where(tableInfo.getIdName() + "=?", id).execute();
+    }
+
+    public static <T extends Model> T load(Class<T> type, long id) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        return (T) new Select().from(type).where(tableInfo.getIdName() + "=?", id).executeSingle();
+    }
+
+    public final Long getId() {
+        return mId;
+    }
+
+    // Convenience methods
+
+    public final void delete() {
+        Cache.openDatabase().delete(mTableInfo.getTableName(), idName + "=?", new String[]{getId().toString()});
+        Cache.removeEntity(this);
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+    }
+
+    public final Long save() {
+        final SQLiteDatabase db = Cache.openDatabase();
+        final ContentValues values = new ContentValues();
+
+        for (Field field : mTableInfo.getFields()) {
+            final String fieldName = mTableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+
+            field.setAccessible(true);
+
+            try {
+                Object value = field.get(this);
+
+                if (value != null) {
+                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                    if (typeSerializer != null) {
+                        // serialize data
+                        value = typeSerializer.serialize(value);
+                        // set new object type
+                        if (value != null) {
+                            fieldType = value.getClass();
+                            // check that the serializer returned what it promised
+                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
+                                Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                        typeSerializer.getSerializedType(), fieldType));
+                            }
+                        }
+                    }
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (value == null) {
+                    values.putNull(fieldName);
+                } else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    values.put(fieldName, (Byte) value);
+                } else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    values.put(fieldName, (Short) value);
+                } else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    values.put(fieldName, (Integer) value);
+                } else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    values.put(fieldName, (Long) value);
+                } else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    values.put(fieldName, (Float) value);
+                } else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    values.put(fieldName, (Double) value);
+                } else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    values.put(fieldName, (Boolean) value);
+                } else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    values.put(fieldName, value.toString());
+                } else if (fieldType.equals(String.class)) {
+                    values.put(fieldName, value.toString());
+                } else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    values.put(fieldName, (byte[]) value);
+                } else if (ReflectionUtils.isModel(fieldType)) {
+                    values.put(fieldName, ((Model) value).getId());
+                } else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    values.put(fieldName, ((Enum<?>) value).name());
+                }
+            } catch (IllegalArgumentException e) {
+                Log.e(e.getClass().getName(), e);
+            } catch (IllegalAccessException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+
+        if (mId == null) {
+            mId = db.insert(mTableInfo.getTableName(), null, values);
+        } else {
+            db.update(mTableInfo.getTableName(), values, idName + "=" + mId, null);
+        }
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+        return mId;
+    }
+
+    // Model population
+
+    public final void loadFromCursor(Cursor cursor) {
+        /**
+         * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+         * when the cursor have multiple columns with same name obtained from join tables.
+         */
+        List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+        for (Field field : mTableInfo.getFields()) {
+            final String fieldName = mTableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+            final int columnIndex = columnsOrdered.indexOf(fieldName);
+
+            if (columnIndex < 0) {
+                continue;
+            }
+
+            field.setAccessible(true);
+
+            try {
+                boolean columnIsNull = cursor.isNull(columnIndex);
+                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                Object value = null;
+
+                if (typeSerializer != null) {
+                    fieldType = typeSerializer.getSerializedType();
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (columnIsNull) {
+                    field = null;
+                } else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    value = cursor.getInt(columnIndex);
+                } else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    value = cursor.getInt(columnIndex);
+                } else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    value = cursor.getInt(columnIndex);
+                } else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    value = cursor.getLong(columnIndex);
+                } else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    value = cursor.getFloat(columnIndex);
+                } else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    value = cursor.getDouble(columnIndex);
+                } else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    value = cursor.getInt(columnIndex) != 0;
+                } else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    value = cursor.getString(columnIndex).charAt(0);
+                } else if (fieldType.equals(String.class)) {
+                    value = cursor.getString(columnIndex);
+                } else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    value = cursor.getBlob(columnIndex);
+                } else if (ReflectionUtils.isModel(fieldType)) {
+                    final long entityId = cursor.getLong(columnIndex);
+                    final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
+
+                    Model entity = Cache.getEntity(entityType, entityId);
+                    if (entity == null) {
+                        entity = new Select().from(entityType).where(idName + "=?", entityId).executeSingle();
+                    }
+
+                    value = entity;
+                } else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    @SuppressWarnings("rawtypes")
+                    final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+                    value = Enum.valueOf(enumType, cursor.getString(columnIndex));
+                }
+
+                // Use a deserializer if one is available
+                if (typeSerializer != null && !columnIsNull) {
+                    value = typeSerializer.deserialize(value);
+                }
+
+                // Set the field value
+                if (value != null) {
+                    field.set(this, value);
+                }
+            } catch (IllegalArgumentException e) {
+                Log.e(e.getClass().getName(), e);
+            } catch (IllegalAccessException e) {
+                Log.e(e.getClass().getName(), e);
+            } catch (SecurityException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+
+        if (mId != null) {
+            Cache.addEntity(this);
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PROTECTED METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
+        return new Select().from(type).where(Cache.getTableName(type) + "" + foreignKey + "=?", getId()).execute();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public String toString() {
+        return mTableInfo.getTableName() + "@" + getId();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof Model && this.mId != null) {
+            final Model other = (Model) obj;
+
+            return this.mId.equals(other.mId)
+                    && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
+        } else {
+            return this == obj;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = HASH_PRIME;
+        hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); //if id is null, use Object.hashCode()
+        hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
+        return hash; //To change body of generated methods, choose Tools | Templates.
+    }
+}
diff --git a/library/src/main/java/com/activeandroid/ModelInfo.java b/library/src/main/java/com/activeandroid/ModelInfo.java
new file mode 100644
index 00000000..b3037e42
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/ModelInfo.java
@@ -0,0 +1,201 @@
+package com.activeandroid;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.content.Context;
+
+import com.activeandroid.serializer.CalendarSerializer;
+import com.activeandroid.serializer.FileSerializer;
+import com.activeandroid.serializer.SqlDateSerializer;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.serializer.UtilDateSerializer;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.ReflectionUtils;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collection;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import dalvik.system.DexFile;
+
+final class ModelInfo {
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Map<Class<? extends Model>, TableInfo> mTableInfos = new HashMap<Class<? extends Model>, TableInfo>();
+    private Map<Class<?>, TypeSerializer> mTypeSerializers = new HashMap<Class<?>, TypeSerializer>() {
+        {
+            put(Calendar.class, new CalendarSerializer());
+            put(java.sql.Date.class, new SqlDateSerializer());
+            put(java.util.Date.class, new UtilDateSerializer());
+            put(java.io.File.class, new FileSerializer());
+        }
+    };
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public ModelInfo(Configuration configuration) {
+        if (!loadModelFromMetaData(configuration)) {
+            try {
+                scanForModel(configuration.getContext());
+            } catch (IOException e) {
+                Log.e("Couldn't open source path.", e);
+            }
+        }
+
+        Log.i("ModelInfo loaded.");
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Collection<TableInfo> getTableInfos() {
+        return mTableInfos.values();
+    }
+
+    public TableInfo getTableInfo(Class<? extends Model> type) {
+        return mTableInfos.get(type);
+    }
+
+    public TypeSerializer getTypeSerializer(Class<?> type) {
+        return mTypeSerializers.get(type);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private boolean loadModelFromMetaData(Configuration configuration) {
+        if (!configuration.isValid()) {
+            return false;
+        }
+
+        final List<Class<? extends Model>> models = configuration.getModelClasses();
+        if (models != null) {
+            for (Class<? extends Model> model : models) {
+                mTableInfos.put(model, new TableInfo(model));
+            }
+        }
+
+        final List<Class<? extends TypeSerializer>> typeSerializers = configuration.getTypeSerializers();
+        if (typeSerializers != null) {
+            for (Class<? extends TypeSerializer> typeSerializer : typeSerializers) {
+                try {
+                    TypeSerializer instance = typeSerializer.newInstance();
+                    mTypeSerializers.put(instance.getDeserializedType(), instance);
+                } catch (InstantiationException e) {
+                    Log.e("Couldn't instantiate TypeSerializer.", e);
+                } catch (IllegalAccessException e) {
+                    Log.e("IllegalAccessException", e);
+                }
+            }
+        }
+
+        return true;
+    }
+
+    private void scanForModel(Context context) throws IOException {
+        String packageName = context.getPackageName();
+        String sourcePath = context.getApplicationInfo().sourceDir;
+        List<String> paths = new ArrayList<String>();
+
+        if (sourcePath != null && !(new File(sourcePath).isDirectory())) {
+            DexFile dexfile = new DexFile(sourcePath);
+            Enumeration<String> entries = dexfile.entries();
+
+            while (entries.hasMoreElements()) {
+                paths.add(entries.nextElement());
+            }
+        }
+        // Robolectric fallback
+        else {
+            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+            Enumeration<URL> resources = classLoader.getResources("");
+
+            while (resources.hasMoreElements()) {
+                String path = resources.nextElement().getFile();
+                if (path.contains("bin") || path.contains("classes")) {
+                    paths.add(path);
+                }
+            }
+        }
+
+        for (String path : paths) {
+            File file = new File(path);
+            scanForModelClasses(file, packageName, context.getClassLoader());
+        }
+    }
+
+    private void scanForModelClasses(File path, String packageName, ClassLoader classLoader) {
+        if (path.isDirectory()) {
+            for (File file : path.listFiles()) {
+                scanForModelClasses(file, packageName, classLoader);
+            }
+        } else {
+            String className = path.getName();
+
+            // Robolectric fallback
+            if (!path.getPath().equals(className)) {
+                className = path.getPath();
+
+                if (className.endsWith(".class")) {
+                    className = className.substring(0, className.length() - 6);
+                } else {
+                    return;
+                }
+
+                className = className.replace(System.getProperty("file.separator"), "");
+
+                int packageNameIndex = className.lastIndexOf(packageName);
+                if (packageNameIndex < 0) {
+                    return;
+                }
+
+                className = className.substring(packageNameIndex);
+            }
+
+            try {
+                Class<?> discoveredClass = Class.forName(className, false, classLoader);
+                if (ReflectionUtils.isModel(discoveredClass)) {
+                    @SuppressWarnings("unchecked")
+                    Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
+                    mTableInfos.put(modelClass, new TableInfo(modelClass));
+                } else if (ReflectionUtils.isTypeSerializer(discoveredClass)) {
+                    TypeSerializer instance = (TypeSerializer) discoveredClass.newInstance();
+                    mTypeSerializers.put(instance.getDeserializedType(), instance);
+                }
+            } catch (ClassNotFoundException e) {
+                Log.e("Couldn't create class.", e);
+            } catch (InstantiationException e) {
+                Log.e("Couldn't instantiate TypeSerializer.", e);
+            } catch (IllegalAccessException e) {
+                Log.e("IllegalAccessException", e);
+            }
+        }
+    }
+}
diff --git a/src/com/activeandroid/TableInfo.java b/library/src/main/java/com/activeandroid/TableInfo.java
similarity index 57%
rename from src/com/activeandroid/TableInfo.java
rename to library/src/main/java/com/activeandroid/TableInfo.java
index 32d1ecb3..66785045 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/library/src/main/java/com/activeandroid/TableInfo.java
@@ -16,6 +16,13 @@
  * limitations under the License.
  */
 
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.util.ReflectionUtils;
+
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.Collections;
@@ -24,39 +31,31 @@
 import java.util.List;
 import java.util.Map;
 
-import android.text.TextUtils;
-import android.util.Log;
-
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.util.ReflectionUtils;
-
 public final class TableInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private Class<? extends Model> mType;
-	private String mTableName;
-	private String mIdName = Table.DEFAULT_ID_NAME;
+    private Class<? extends Model> mType;
+    private String mTableName;
+    private String mIdName = Table.DEFAULT_ID_NAME;
 
-	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
+    private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public TableInfo(Class<? extends Model> type) {
-		mType = type;
+    public TableInfo(Class<? extends Model> type) {
+        mType = type;
 
-		final Table tableAnnotation = type.getAnnotation(Table.class);
+        final Table tableAnnotation = type.getAnnotation(Table.class);
 
         if (tableAnnotation != null) {
-			mTableName = tableAnnotation.name();
-			mIdName = tableAnnotation.id();
-		}
-		else {
-			mTableName = type.getSimpleName();
+            mTableName = tableAnnotation.name();
+            mIdName = tableAnnotation.id();
+        } else {
+            mTableName = type.getSimpleName();
         }
 
         // Manually add the id column since it is not declared like the other columns.
@@ -78,43 +77,41 @@ public TableInfo(Class<? extends Model> type) {
             }
         }
 
-	}
+    }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public Class<? extends Model> getType() {
-		return mType;
-	}
+    public Class<? extends Model> getType() {
+        return mType;
+    }
 
-	public String getTableName() {
-		return mTableName;
-	}
+    public String getTableName() {
+        return mTableName;
+    }
 
-	public String getIdName() {
-		return mIdName;
-	}
+    public String getIdName() {
+        return mIdName;
+    }
 
-	public Collection<Field> getFields() {
-		return mColumnNames.keySet();
-	}
+    public Collection<Field> getFields() {
+        return mColumnNames.keySet();
+    }
 
-	public String getColumnName(Field field) {
-		return mColumnNames.get(field);
-	}
+    public String getColumnName(Field field) {
+        return mColumnNames.get(field);
+    }
 
 
     private Field getIdField(Class<?> type) {
         if (type.equals(Model.class)) {
             try {
                 return type.getDeclaredField("mId");
-            }
-            catch (NoSuchFieldException e) {
+            } catch (NoSuchFieldException e) {
                 Log.e("Impossible!", e.toString());
             }
-        }
-        else if (type.getSuperclass() != null) {
+        } else if (type.getSuperclass() != null) {
             return getIdField(type.getSuperclass());
         }
 
diff --git a/library/src/main/java/com/activeandroid/annotation/Column.java b/library/src/main/java/com/activeandroid/annotation/Column.java
new file mode 100644
index 00000000..87a69256
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/annotation/Column.java
@@ -0,0 +1,110 @@
+package com.activeandroid.annotation;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Column {
+    public String name() default "";
+
+    public int length() default -1;
+
+    public boolean notNull() default false;
+
+    public ConflictAction onNullConflict() default ConflictAction.FAIL;
+
+    public ForeignKeyAction onDelete() default ForeignKeyAction.NO_ACTION;
+
+    public ForeignKeyAction onUpdate() default ForeignKeyAction.NO_ACTION;
+
+    public boolean unique() default false;
+
+    public ConflictAction onUniqueConflict() default ConflictAction.FAIL;
+
+    /*
+     * If set uniqueGroups = {"group_name"}, we will create a table constraint with group.
+     *
+     * Example:
+     *
+     * @Table(name = "table_name")
+     * public class Table extends Model {
+     *     @Column(name = "member1", uniqueGroups = {"group1"}, onUniqueConflicts = {ConflictAction.FAIL})
+     *     public String member1;
+     *
+     *     @Column(name = "member2", uniqueGroups = {"group1", "group2"}, onUniqueConflicts = {ConflictAction.FAIL, ConflictAction.IGNORE})
+     *     public String member2;
+     *
+     *     @Column(name = "member3", uniqueGroups = {"group2"}, onUniqueConflicts = {ConflictAction.IGNORE})
+     *     public String member3;
+     * }
+     *
+     * CREATE TABLE table_name (..., UNIQUE (member1, member2) ON CONFLICT FAIL, UNIQUE (member2, member3) ON CONFLICT IGNORE)
+     */
+    public String[] uniqueGroups() default {};
+
+    public ConflictAction[] onUniqueConflicts() default {};
+
+    /*
+     * If set index = true, we will create a index with single column.
+     *
+     * Example:
+     *
+     * @Table(name = "table_name")
+     * public class Table extends Model {
+     *     @Column(name = "member", index = true)
+     *     public String member;
+     * }
+     *
+     * Execute CREATE INDEX index_table_name_member on table_name(member)
+     */
+    public boolean index() default false;
+
+    /*
+     * If set indexGroups = {"group_name"}, we will create a index with group.
+     *
+     * Example:
+     *
+     * @Table(name = "table_name")
+     * public class Table extends Model {
+     *     @Column(name = "member1", indexGroups = {"group1"})
+     *     public String member1;
+     *
+     *     @Column(name = "member2", indexGroups = {"group1", "group2"})
+     *     public String member2;
+     *
+     *     @Column(name = "member3", indexGroups = {"group2"})
+     *     public String member3;
+     * }
+     *
+     * Execute CREATE INDEX index_table_name_group1 on table_name(member1, member2)
+     * Execute CREATE INDEX index_table_name_group2 on table_name(member2, member3)
+     */
+    public String[] indexGroups() default {};
+
+    public enum ConflictAction {
+        ROLLBACK, ABORT, FAIL, IGNORE, REPLACE
+    }
+
+    public enum ForeignKeyAction {
+        SET_NULL, SET_DEFAULT, CASCADE, RESTRICT, NO_ACTION
+    }
+}
diff --git a/src/com/activeandroid/annotation/Table.java b/library/src/main/java/com/activeandroid/annotation/Table.java
similarity index 87%
rename from src/com/activeandroid/annotation/Table.java
rename to library/src/main/java/com/activeandroid/annotation/Table.java
index 541dfbe9..58401188 100644
--- a/src/com/activeandroid/annotation/Table.java
+++ b/library/src/main/java/com/activeandroid/annotation/Table.java
@@ -25,7 +25,9 @@
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Table {
 
-	public static final String DEFAULT_ID_NAME = "Id";
-	public String name();
-	public String id() default DEFAULT_ID_NAME;
+    public static final String DEFAULT_ID_NAME = "Id";
+
+    public String name();
+
+    public String id() default DEFAULT_ID_NAME;
 }
diff --git a/src/com/activeandroid/app/Application.java b/library/src/main/java/com/activeandroid/app/Application.java
similarity index 76%
rename from src/com/activeandroid/app/Application.java
rename to library/src/main/java/com/activeandroid/app/Application.java
index 311c7c93..d2b7dbe3 100644
--- a/src/com/activeandroid/app/Application.java
+++ b/library/src/main/java/com/activeandroid/app/Application.java
@@ -19,15 +19,15 @@
 import com.activeandroid.ActiveAndroid;
 
 public class Application extends android.app.Application {
-	@Override
-	public void onCreate() {
-		super.onCreate();
-		ActiveAndroid.initialize(this);
-	}
-	
-	@Override
-	public void onTerminate() {
-		super.onTerminate();
-		ActiveAndroid.dispose();
-	}
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        ActiveAndroid.initialize(this);
+    }
+
+    @Override
+    public void onTerminate() {
+        super.onTerminate();
+        ActiveAndroid.dispose();
+    }
 }
\ No newline at end of file
diff --git a/library/src/main/java/com/activeandroid/content/ContentProvider.java b/library/src/main/java/com/activeandroid/content/ContentProvider.java
new file mode 100644
index 00000000..0069f4ce
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/content/ContentProvider.java
@@ -0,0 +1,192 @@
+package com.activeandroid.content;
+
+import android.content.ContentValues;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.net.Uri;
+import android.util.SparseArray;
+
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Cache;
+import com.activeandroid.Configuration;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class ContentProvider extends android.content.ContentProvider {
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
+    private static final SparseArray<Class<? extends Model>> TYPE_CODES = new SparseArray<Class<? extends Model>>();
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private static String sAuthority;
+    private static SparseArray<String> sMimeTypeCache = new SparseArray<String>();
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static Uri createUri(Class<? extends Model> type, Long id) {
+        final StringBuilder uri = new StringBuilder();
+        uri.append("content://");
+        uri.append(sAuthority);
+        uri.append("/");
+        uri.append(Cache.getTableName(type).toLowerCase());
+
+        if (id != null) {
+            uri.append("/");
+            uri.append(id.toString());
+        }
+
+        return Uri.parse(uri.toString());
+    }
+
+    @Override
+    public boolean onCreate() {
+        ActiveAndroid.initialize(getConfiguration());
+        sAuthority = getAuthority();
+
+        final List<TableInfo> tableInfos = new ArrayList<TableInfo>(Cache.getTableInfos());
+        final int size = tableInfos.size();
+        for (int i = 0; i < size; i++) {
+            final TableInfo tableInfo = tableInfos.get(i);
+            final int tableKey = (i * 2) + 1;
+            final int itemKey = (i * 2) + 2;
+
+            // content://<authority>/<table>
+            URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase(), tableKey);
+            TYPE_CODES.put(tableKey, tableInfo.getType());
+
+            // content://<authority>/<table>/<id>
+            URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase() + "/#", itemKey);
+            TYPE_CODES.put(itemKey, tableInfo.getType());
+        }
+
+        return true;
+    }
+
+    // SQLite methods
+
+    @Override
+    public String getType(Uri uri) {
+        final int match = URI_MATCHER.match(uri);
+
+        String cachedMimeType = sMimeTypeCache.get(match);
+        if (cachedMimeType != null) {
+            return cachedMimeType;
+        }
+
+        final Class<? extends Model> type = getModelType(uri);
+        final boolean single = ((match % 2) == 0);
+
+        StringBuilder mimeType = new StringBuilder();
+        mimeType.append("vnd");
+        mimeType.append("");
+        mimeType.append(sAuthority);
+        mimeType.append("");
+        mimeType.append(single ? "item" : "dir");
+        mimeType.append("/");
+        mimeType.append("vnd");
+        mimeType.append("");
+        mimeType.append(sAuthority);
+        mimeType.append("");
+        mimeType.append(Cache.getTableName(type));
+
+        sMimeTypeCache.append(match, mimeType.toString());
+
+        return mimeType.toString();
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        final Class<? extends Model> type = getModelType(uri);
+        final Long id = Cache.openDatabase().insert(Cache.getTableName(type), null, values);
+
+        if (id != null && id > 0) {
+            Uri retUri = createUri(type, id);
+            notifyChange(retUri);
+
+            return retUri;
+        }
+
+        return null;
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        final Class<? extends Model> type = getModelType(uri);
+        final int count = Cache.openDatabase().update(Cache.getTableName(type), values, selection, selectionArgs);
+
+        notifyChange(uri);
+
+        return count;
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        final Class<? extends Model> type = getModelType(uri);
+        final int count = Cache.openDatabase().delete(Cache.getTableName(type), selection, selectionArgs);
+
+        notifyChange(uri);
+
+        return count;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+        final Class<? extends Model> type = getModelType(uri);
+        final Cursor cursor = Cache.openDatabase().query(
+                Cache.getTableName(type),
+                projection,
+                selection,
+                selectionArgs,
+                null,
+                null,
+                sortOrder);
+
+        cursor.setNotificationUri(getContext().getContentResolver(), uri);
+
+        return cursor;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PROTECTED METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    protected String getAuthority() {
+        return getContext().getPackageName();
+    }
+
+    protected Configuration getConfiguration() {
+        return new Configuration.Builder(getContext()).create();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Class<? extends Model> getModelType(Uri uri) {
+        final int code = URI_MATCHER.match(uri);
+        if (code != UriMatcher.NO_MATCH) {
+            return TYPE_CODES.get(code);
+        }
+
+        return null;
+    }
+
+    private void notifyChange(Uri uri) {
+        getContext().getContentResolver().notifyChange(uri, null);
+    }
+}
diff --git a/src/com/activeandroid/query/Delete.java b/library/src/main/java/com/activeandroid/query/Delete.java
similarity index 78%
rename from src/com/activeandroid/query/Delete.java
rename to library/src/main/java/com/activeandroid/query/Delete.java
index 6d19dced..43f8c550 100644
--- a/src/com/activeandroid/query/Delete.java
+++ b/library/src/main/java/com/activeandroid/query/Delete.java
@@ -19,15 +19,15 @@
 import com.activeandroid.Model;
 
 public final class Delete implements Sqlable {
-	public Delete() {
-	}
+    public Delete() {
+    }
 
-	public From from(Class<? extends Model> table) {
-		return new From(table, this);
-	}
+    public From from(Class<? extends Model> table) {
+        return new From(table, this);
+    }
 
-	@Override
-	public String toSql() {
-		return "DELETE ";
-	}
+    @Override
+    public String toSql() {
+        return "DELETE ";
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/query/From.java b/library/src/main/java/com/activeandroid/query/From.java
similarity index 62%
rename from src/com/activeandroid/query/From.java
rename to library/src/main/java/com/activeandroid/query/From.java
index ab3837a9..37aa5137 100644
--- a/src/com/activeandroid/query/From.java
+++ b/library/src/main/java/com/activeandroid/query/From.java
@@ -29,63 +29,62 @@
 import java.util.List;
 
 public final class From implements Sqlable {
-	private Sqlable mQueryBase;
-
-	private Class<? extends Model> mType;
-	private String mAlias;
-	private List<Join> mJoins;
-	private final StringBuilder mWhere = new StringBuilder();
-	private String mGroupBy;
-	private String mHaving;
-	private String mOrderBy;
-	private String mLimit;
-	private String mOffset;
-
-	private List<Object> mArguments;
-
-	public From(Class<? extends Model> table, Sqlable queryBase) {
-		mType = table;
-		mJoins = new ArrayList<Join>();
-		mQueryBase = queryBase;
-
-		mJoins = new ArrayList<Join>();
-		mArguments = new ArrayList<Object>();
-	}
-
-	public From as(String alias) {
-		mAlias = alias;
-		return this;
-	}
-
-	public Join join(Class<? extends Model> table) {
-		Join join = new Join(this, table, null);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join leftJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.LEFT);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join outerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.OUTER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join innerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.INNER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join crossJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.CROSS);
-		mJoins.add(join);
-		return join;
-	}
+    private final StringBuilder mWhere = new StringBuilder();
+    private Sqlable mQueryBase;
+    private Class<? extends Model> mType;
+    private String mAlias;
+    private List<Join> mJoins;
+    private String mGroupBy;
+    private String mHaving;
+    private String mOrderBy;
+    private String mLimit;
+    private String mOffset;
+
+    private List<Object> mArguments;
+
+    public From(Class<? extends Model> table, Sqlable queryBase) {
+        mType = table;
+        mJoins = new ArrayList<Join>();
+        mQueryBase = queryBase;
+
+        mJoins = new ArrayList<Join>();
+        mArguments = new ArrayList<Object>();
+    }
+
+    public From as(String alias) {
+        mAlias = alias;
+        return this;
+    }
+
+    public Join join(Class<? extends Model> table) {
+        Join join = new Join(this, table, null);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join leftJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.LEFT);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join outerJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.OUTER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join innerJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.INNER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join crossJoin(Class<? extends Model> table) {
+        Join join = new Join(this, table, JoinType.CROSS);
+        mJoins.add(join);
+        return join;
+    }
 
     public From where(String clause) {
         // Chain conditions if a previous condition exists.
@@ -121,48 +120,48 @@ public From or(String clause, Object... args) {
         or(clause).addArguments(args);
         return this;
     }
-    
-	public From groupBy(String groupBy) {
-		mGroupBy = groupBy;
-		return this;
-	}
-
-	public From having(String having) {
-		mHaving = having;
-		return this;
-	}
-
-	public From orderBy(String orderBy) {
-		mOrderBy = orderBy;
-		return this;
-	}
-
-	public From limit(int limit) {
-		return limit(String.valueOf(limit));
-	}
-
-	public From limit(String limit) {
-		mLimit = limit;
-		return this;
-	}
-
-	public From offset(int offset) {
-		return offset(String.valueOf(offset));
-	}
-
-	public From offset(String offset) {
-		mOffset = offset;
-		return this;
-	}
-
-	void addArguments(Object[] args) {
-        for(Object arg : args) {
+
+    public From groupBy(String groupBy) {
+        mGroupBy = groupBy;
+        return this;
+    }
+
+    public From having(String having) {
+        mHaving = having;
+        return this;
+    }
+
+    public From orderBy(String orderBy) {
+        mOrderBy = orderBy;
+        return this;
+    }
+
+    public From limit(int limit) {
+        return limit(String.valueOf(limit));
+    }
+
+    public From limit(String limit) {
+        mLimit = limit;
+        return this;
+    }
+
+    public From offset(int offset) {
+        return offset(String.valueOf(offset));
+    }
+
+    public From offset(String offset) {
+        mOffset = offset;
+        return this;
+    }
+
+    void addArguments(Object[] args) {
+        for (Object arg : args) {
             if (arg.getClass() == boolean.class || arg.getClass() == Boolean.class) {
                 arg = (arg.equals(true) ? 1 : 0);
             }
             mArguments.add(arg);
         }
-	}
+    }
 
     private void addFrom(final StringBuilder sql) {
         sql.append("FROM ");
@@ -293,33 +292,34 @@ public String toCountSql() {
         return sqlString(sql);
     }
 
-	public <T extends Model> List<T> execute() {
-		if (mQueryBase instanceof Select) {
-			return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
-			
-		} else {
-			SQLiteUtils.execSql(toSql(), getArguments());
-			Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mType, null), null);
-			return null;
-			
-		}
-	}
-
-	public <T extends Model> T executeSingle() {
-		if (mQueryBase instanceof Select) {
-			limit(1);
-			return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
-			
-		} else {
-			limit(1);
-			SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments()).delete();
-			return null;
-			
-		}
-	}
-	
+    public <T extends Model> List<T> execute() {
+        if (mQueryBase instanceof Select) {
+            return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
+
+        } else {
+            SQLiteUtils.execSql(toSql(), getArguments());
+            Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mType, null), null);
+            return null;
+
+        }
+    }
+
+    public <T extends Model> T executeSingle() {
+        if (mQueryBase instanceof Select) {
+            limit(1);
+            return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
+
+        } else {
+            limit(1);
+            SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments()).delete();
+            return null;
+
+        }
+    }
+
     /**
      * Gets a value indicating whether the query returns any rows.
+     *
      * @return <code>true</code> if the query returns at least one row; otherwise, <code>false</code>.
      */
     public boolean exists() {
@@ -333,14 +333,14 @@ public int count() {
         return SQLiteUtils.intQuery(toCountSql(), getArguments());
     }
 
-	public String[] getArguments() {
-		final int size = mArguments.size();
-		final String[] args = new String[size];
+    public String[] getArguments() {
+        final int size = mArguments.size();
+        final String[] args = new String[size];
 
-		for (int i = 0; i < size; i++) {
-			args[i] = mArguments.get(i).toString();
-		}
+        for (int i = 0; i < size; i++) {
+            args[i] = mArguments.get(i).toString();
+        }
 
-		return args;
-	}
+        return args;
+    }
 }
diff --git a/library/src/main/java/com/activeandroid/query/Join.java b/library/src/main/java/com/activeandroid/query/Join.java
new file mode 100644
index 00000000..8e53af22
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/query/Join.java
@@ -0,0 +1,93 @@
+package com.activeandroid.query;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.text.TextUtils;
+
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+
+public final class Join implements Sqlable {
+    private From mFrom;
+    private Class<? extends Model> mType;
+    private String mAlias;
+    private JoinType mJoinType;
+    private String mOn;
+    private String[] mUsing;
+
+    Join(From from, Class<? extends Model> table, JoinType joinType) {
+        mFrom = from;
+        mType = table;
+        mJoinType = joinType;
+    }
+
+    public Join as(String alias) {
+        mAlias = alias;
+        return this;
+    }
+
+    public From on(String on) {
+        mOn = on;
+        return mFrom;
+    }
+
+    public From on(String on, Object... args) {
+        mOn = on;
+        mFrom.addArguments(args);
+        return mFrom;
+    }
+
+    public From using(String... columns) {
+        mUsing = columns;
+        return mFrom;
+    }
+
+    @Override
+    public String toSql() {
+        StringBuilder sql = new StringBuilder();
+
+        if (mJoinType != null) {
+            sql.append(mJoinType.toString()).append(" ");
+        }
+
+        sql.append("JOIN ");
+        sql.append(Cache.getTableName(mType));
+        sql.append(" ");
+
+        if (mAlias != null) {
+            sql.append("AS ");
+            sql.append(mAlias);
+            sql.append(" ");
+        }
+
+        if (mOn != null) {
+            sql.append("ON ");
+            sql.append(mOn);
+            sql.append(" ");
+        } else if (mUsing != null) {
+            sql.append("USING (");
+            sql.append(TextUtils.join(", ", mUsing));
+            sql.append(") ");
+        }
+
+        return sql.toString();
+    }
+
+    static enum JoinType {
+        LEFT, OUTER, INNER, CROSS
+    }
+}
diff --git a/library/src/main/java/com/activeandroid/query/Select.java b/library/src/main/java/com/activeandroid/query/Select.java
new file mode 100644
index 00000000..6ab4e01e
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/query/Select.java
@@ -0,0 +1,91 @@
+package com.activeandroid.query;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.text.TextUtils;
+
+import com.activeandroid.Model;
+
+public final class Select implements Sqlable {
+    private String[] mColumns;
+    private boolean mDistinct = false;
+    private boolean mAll = false;
+
+    public Select() {
+    }
+
+    public Select(String... columns) {
+        mColumns = columns;
+    }
+
+    public Select(Column... columns) {
+        final int size = columns.length;
+        mColumns = new String[size];
+        for (int i = 0; i < size; i++) {
+            mColumns[i] = columns[i].name + " AS " + columns[i].alias;
+        }
+    }
+
+    public Select distinct() {
+        mDistinct = true;
+        mAll = false;
+
+        return this;
+    }
+
+    public Select all() {
+        mDistinct = false;
+        mAll = true;
+
+        return this;
+    }
+
+    public From from(Class<? extends Model> table) {
+        return new From(table, this);
+    }
+
+    @Override
+    public String toSql() {
+        StringBuilder sql = new StringBuilder();
+
+        sql.append("SELECT ");
+
+        if (mDistinct) {
+            sql.append("DISTINCT ");
+        } else if (mAll) {
+            sql.append("ALL ");
+        }
+
+        if (mColumns != null && mColumns.length > 0) {
+            sql.append(TextUtils.join(", ", mColumns) + " ");
+        } else {
+            sql.append("* ");
+        }
+
+        return sql.toString();
+    }
+
+    public static class Column {
+        String name;
+        String alias;
+
+        public Column(String name, String alias) {
+            this.name = name;
+            this.alias = alias;
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/activeandroid/query/Set.java b/library/src/main/java/com/activeandroid/query/Set.java
new file mode 100644
index 00000000..9fd4916d
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/query/Set.java
@@ -0,0 +1,103 @@
+package com.activeandroid.query;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import com.activeandroid.util.SQLiteUtils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public final class Set implements Sqlable {
+    private Update mUpdate;
+
+    private String mSet;
+    private String mWhere;
+
+    private List<Object> mSetArguments;
+    private List<Object> mWhereArguments;
+
+    public Set(Update queryBase, String set) {
+        mUpdate = queryBase;
+        mSet = set;
+
+        mSetArguments = new ArrayList<Object>();
+        mWhereArguments = new ArrayList<Object>();
+    }
+
+    public Set(Update queryBase, String set, Object... args) {
+        mUpdate = queryBase;
+        mSet = set;
+
+        mSetArguments = new ArrayList<Object>();
+        mWhereArguments = new ArrayList<Object>();
+
+        mSetArguments.addAll(Arrays.asList(args));
+    }
+
+    public Set where(String where) {
+        mWhere = where;
+        mWhereArguments.clear();
+
+        return this;
+    }
+
+    public Set where(String where, Object... args) {
+        mWhere = where;
+        mWhereArguments.clear();
+        mWhereArguments.addAll(Arrays.asList(args));
+
+        return this;
+    }
+
+    @Override
+    public String toSql() {
+        StringBuilder sql = new StringBuilder();
+        sql.append(mUpdate.toSql());
+        sql.append("SET ");
+        sql.append(mSet);
+        sql.append(" ");
+
+        if (mWhere != null) {
+            sql.append("WHERE ");
+            sql.append(mWhere);
+            sql.append(" ");
+        }
+
+        return sql.toString();
+    }
+
+    public void execute() {
+        SQLiteUtils.execSql(toSql(), getArguments());
+    }
+
+    public String[] getArguments() {
+        final int setSize = mSetArguments.size();
+        final int whereSize = mWhereArguments.size();
+        final String[] args = new String[setSize + whereSize];
+
+        for (int i = 0; i < setSize; i++) {
+            args[i] = mSetArguments.get(i).toString();
+        }
+
+        for (int i = 0; i < whereSize; i++) {
+            args[i + setSize] = mWhereArguments.get(i).toString();
+        }
+
+        return args;
+    }
+}
diff --git a/src/com/activeandroid/query/Sqlable.java b/library/src/main/java/com/activeandroid/query/Sqlable.java
similarity index 95%
rename from src/com/activeandroid/query/Sqlable.java
rename to library/src/main/java/com/activeandroid/query/Sqlable.java
index 2c3f5d43..3d513ee7 100644
--- a/src/com/activeandroid/query/Sqlable.java
+++ b/library/src/main/java/com/activeandroid/query/Sqlable.java
@@ -17,5 +17,5 @@
  */
 
 public interface Sqlable {
-	public String toSql();
+    public String toSql();
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/query/Update.java b/library/src/main/java/com/activeandroid/query/Update.java
similarity index 56%
rename from src/com/activeandroid/query/Update.java
rename to library/src/main/java/com/activeandroid/query/Update.java
index a69d2d8e..a81ac559 100644
--- a/src/com/activeandroid/query/Update.java
+++ b/library/src/main/java/com/activeandroid/query/Update.java
@@ -20,31 +20,31 @@
 import com.activeandroid.Model;
 
 public final class Update implements Sqlable {
-	private Class<? extends Model> mType;
+    private Class<? extends Model> mType;
 
-	public Update(Class<? extends Model> table) {
-		mType = table;
-	}
+    public Update(Class<? extends Model> table) {
+        mType = table;
+    }
 
-	public Set set(String set) {
-		return new Set(this, set);
-	}
+    public Set set(String set) {
+        return new Set(this, set);
+    }
 
-	public Set set(String set, Object... args) {
-		return new Set(this, set, args);
-	}
+    public Set set(String set, Object... args) {
+        return new Set(this, set, args);
+    }
 
-	Class<? extends Model> getType() {
-		return mType;
-	}
+    Class<? extends Model> getType() {
+        return mType;
+    }
 
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-		sql.append("UPDATE ");
-		sql.append(Cache.getTableName(mType));
-		sql.append(" ");
+    @Override
+    public String toSql() {
+        StringBuilder sql = new StringBuilder();
+        sql.append("UPDATE ");
+        sql.append(Cache.getTableName(mType));
+        sql.append(" ");
 
-		return sql.toString();
-	}
+        return sql.toString();
+    }
 }
diff --git a/library/src/main/java/com/activeandroid/serializer/BigDecimalSerializer.java b/library/src/main/java/com/activeandroid/serializer/BigDecimalSerializer.java
new file mode 100644
index 00000000..ba0c5100
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/serializer/BigDecimalSerializer.java
@@ -0,0 +1,29 @@
+package com.activeandroid.serializer;
+
+import java.math.BigDecimal;
+
+public final class BigDecimalSerializer extends TypeSerializer {
+    public Class<?> getDeserializedType() {
+        return BigDecimal.class;
+    }
+
+    public Class<?> getSerializedType() {
+        return String.class;
+    }
+
+    public String serialize(Object data) {
+        if (data == null) {
+            return null;
+        }
+
+        return ((BigDecimal) data).toString();
+    }
+
+    public BigDecimal deserialize(Object data) {
+        if (data == null) {
+            return null;
+        }
+
+        return new BigDecimal((String) data);
+    }
+}
\ No newline at end of file
diff --git a/src/com/activeandroid/serializer/CalendarSerializer.java b/library/src/main/java/com/activeandroid/serializer/CalendarSerializer.java
similarity index 62%
rename from src/com/activeandroid/serializer/CalendarSerializer.java
rename to library/src/main/java/com/activeandroid/serializer/CalendarSerializer.java
index 55509bd0..db06fa96 100644
--- a/src/com/activeandroid/serializer/CalendarSerializer.java
+++ b/library/src/main/java/com/activeandroid/serializer/CalendarSerializer.java
@@ -19,22 +19,22 @@
 import java.util.Calendar;
 
 public final class CalendarSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return Calendar.class;
-	}
+    public Class<?> getDeserializedType() {
+        return Calendar.class;
+    }
 
-	public Class<?> getSerializedType() {
-		return long.class;
-	}
+    public Class<?> getSerializedType() {
+        return long.class;
+    }
 
-	public Long serialize(Object data) {
-		return ((Calendar) data).getTimeInMillis();
-	}
+    public Long serialize(Object data) {
+        return ((Calendar) data).getTimeInMillis();
+    }
 
-	public Calendar deserialize(Object data) {
-		Calendar calendar = Calendar.getInstance();
-		calendar.setTimeInMillis((Long) data);
+    public Calendar deserialize(Object data) {
+        Calendar calendar = Calendar.getInstance();
+        calendar.setTimeInMillis((Long) data);
 
-		return calendar;
-	}
+        return calendar;
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/serializer/FileSerializer.java b/library/src/main/java/com/activeandroid/serializer/FileSerializer.java
similarity index 61%
rename from src/com/activeandroid/serializer/FileSerializer.java
rename to library/src/main/java/com/activeandroid/serializer/FileSerializer.java
index 0aed072c..0efa81f9 100644
--- a/src/com/activeandroid/serializer/FileSerializer.java
+++ b/library/src/main/java/com/activeandroid/serializer/FileSerializer.java
@@ -20,27 +20,27 @@
 
 
 public final class FileSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return File.class;
-	}
+    public Class<?> getDeserializedType() {
+        return File.class;
+    }
 
-	public Class<?> getSerializedType() {
-		return String.class;
-	}
+    public Class<?> getSerializedType() {
+        return String.class;
+    }
 
-	public String serialize(Object data) {
-		if (data == null) {
-			return null;
-		}
+    public String serialize(Object data) {
+        if (data == null) {
+            return null;
+        }
 
-		return ((File) data).toString();
-	}
+        return ((File) data).toString();
+    }
 
-	public File deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
+    public File deserialize(Object data) {
+        if (data == null) {
+            return null;
+        }
 
-		return new File((String) data);
-	}
+        return new File((String) data);
+    }
 }
diff --git a/src/com/activeandroid/serializer/SqlDateSerializer.java b/library/src/main/java/com/activeandroid/serializer/SqlDateSerializer.java
similarity index 61%
rename from src/com/activeandroid/serializer/SqlDateSerializer.java
rename to library/src/main/java/com/activeandroid/serializer/SqlDateSerializer.java
index 530d1249..ca836f1f 100644
--- a/src/com/activeandroid/serializer/SqlDateSerializer.java
+++ b/library/src/main/java/com/activeandroid/serializer/SqlDateSerializer.java
@@ -19,27 +19,27 @@
 import java.sql.Date;
 
 public final class SqlDateSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return Date.class;
-	}
+    public Class<?> getDeserializedType() {
+        return Date.class;
+    }
 
-	public Class<?> getSerializedType() {
-		return long.class;
-	}
+    public Class<?> getSerializedType() {
+        return long.class;
+    }
 
-	public Long serialize(Object data) {
-		if (data == null) {
-			return null;
-		}
+    public Long serialize(Object data) {
+        if (data == null) {
+            return null;
+        }
 
-		return ((Date) data).getTime();
-	}
+        return ((Date) data).getTime();
+    }
 
-	public Date deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
+    public Date deserialize(Object data) {
+        if (data == null) {
+            return null;
+        }
 
-		return new Date((Long) data);
-	}
+        return new Date((Long) data);
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/serializer/TypeSerializer.java b/library/src/main/java/com/activeandroid/serializer/TypeSerializer.java
similarity index 76%
rename from src/com/activeandroid/serializer/TypeSerializer.java
rename to library/src/main/java/com/activeandroid/serializer/TypeSerializer.java
index af0a21de..0bd95975 100644
--- a/src/com/activeandroid/serializer/TypeSerializer.java
+++ b/library/src/main/java/com/activeandroid/serializer/TypeSerializer.java
@@ -17,11 +17,11 @@
  */
 
 public abstract class TypeSerializer {
-	public abstract Class<?> getDeserializedType();
+    public abstract Class<?> getDeserializedType();
 
-	public abstract Class<?> getSerializedType();
+    public abstract Class<?> getSerializedType();
 
-	public abstract Object serialize(Object data);
+    public abstract Object serialize(Object data);
 
-	public abstract Object deserialize(Object data);
+    public abstract Object deserialize(Object data);
 }
\ No newline at end of file
diff --git a/library/src/main/java/com/activeandroid/serializer/UUIDSerializer.java b/library/src/main/java/com/activeandroid/serializer/UUIDSerializer.java
new file mode 100644
index 00000000..b2733cb5
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/serializer/UUIDSerializer.java
@@ -0,0 +1,29 @@
+package com.activeandroid.serializer;
+
+import java.util.UUID;
+
+public final class UUIDSerializer extends TypeSerializer {
+    public Class<?> getDeserializedType() {
+        return UUID.class;
+    }
+
+    public Class<?> getSerializedType() {
+        return String.class;
+    }
+
+    public String serialize(Object data) {
+        if (data == null) {
+            return null;
+        }
+
+        return ((UUID) data).toString();
+    }
+
+    public UUID deserialize(Object data) {
+        if (data == null) {
+            return null;
+        }
+
+        return UUID.fromString((String) data);
+    }
+}
\ No newline at end of file
diff --git a/src/com/activeandroid/serializer/UtilDateSerializer.java b/library/src/main/java/com/activeandroid/serializer/UtilDateSerializer.java
similarity index 61%
rename from src/com/activeandroid/serializer/UtilDateSerializer.java
rename to library/src/main/java/com/activeandroid/serializer/UtilDateSerializer.java
index a82c7ef1..886bdb90 100644
--- a/src/com/activeandroid/serializer/UtilDateSerializer.java
+++ b/library/src/main/java/com/activeandroid/serializer/UtilDateSerializer.java
@@ -19,27 +19,27 @@
 import java.util.Date;
 
 public final class UtilDateSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return Date.class;
-	}
+    public Class<?> getDeserializedType() {
+        return Date.class;
+    }
 
-	public Class<?> getSerializedType() {
-		return long.class;
-	}
+    public Class<?> getSerializedType() {
+        return long.class;
+    }
 
-	public Long serialize(Object data) {
-		if (data == null) {
-			return null;
-		}
+    public Long serialize(Object data) {
+        if (data == null) {
+            return null;
+        }
 
-		return ((Date) data).getTime();
-	}
+        return ((Date) data).getTime();
+    }
 
-	public Date deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
+    public Date deserialize(Object data) {
+        if (data == null) {
+            return null;
+        }
 
-		return new Date((Long) data);
-	}
+        return new Date((Long) data);
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/util/IOUtils.java b/library/src/main/java/com/activeandroid/util/IOUtils.java
similarity index 98%
rename from src/com/activeandroid/util/IOUtils.java
rename to library/src/main/java/com/activeandroid/util/IOUtils.java
index b3005f85..24b0bb40 100644
--- a/src/com/activeandroid/util/IOUtils.java
+++ b/library/src/main/java/com/activeandroid/util/IOUtils.java
@@ -22,8 +22,6 @@
 import java.io.Closeable;
 import java.io.IOException;
 
-import com.activeandroid.util.Log;
-
 
 public class IOUtils {
 
@@ -33,6 +31,7 @@
      * </p>
      * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored. This is
      * typically used in finally blocks.
+     *
      * @param closeable A {@link Closeable} to close.
      */
     public static void closeQuietly(final Closeable closeable) {
@@ -54,6 +53,7 @@ public static void closeQuietly(final Closeable closeable) {
      * </p>
      * Equivalent to {@link Cursor#close()}, except any exceptions will be ignored. This is
      * typically used in finally blocks.
+     *
      * @param cursor A {@link Cursor} to close.
      */
     public static void closeQuietly(final Cursor cursor) {
diff --git a/library/src/main/java/com/activeandroid/util/Log.java b/library/src/main/java/com/activeandroid/util/Log.java
new file mode 100644
index 00000000..a455f17e
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/util/Log.java
@@ -0,0 +1,196 @@
+package com.activeandroid.util;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public final class Log {
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private static String sTag = "ActiveAndroid";
+    private static boolean sEnabled = false;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Log() {
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static boolean isEnabled() {
+        return sEnabled;
+    }
+
+    public static void setEnabled(boolean enabled) {
+        sEnabled = enabled;
+    }
+
+    public static boolean isLoggingEnabled() {
+        return sEnabled;
+    }
+
+    public static int v(String msg) {
+        if (sEnabled) {
+            return android.util.Log.v(sTag, msg);
+        }
+        return 0;
+    }
+
+    public static int v(String tag, String msg) {
+        if (sEnabled) {
+            return android.util.Log.v(tag, msg);
+        }
+        return 0;
+    }
+
+    public static int v(String msg, Throwable tr) {
+        if (sEnabled) {
+            return android.util.Log.v(sTag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int v(String tag, String msg, Throwable tr) {
+        if (sEnabled) {
+            return android.util.Log.v(tag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int d(String msg) {
+        if (sEnabled) {
+            return android.util.Log.d(sTag, msg);
+        }
+        return 0;
+    }
+
+    public static int d(String tag, String msg) {
+        if (sEnabled) {
+            return android.util.Log.d(tag, msg);
+        }
+        return 0;
+    }
+
+    public static int d(String msg, Throwable tr) {
+        if (sEnabled) {
+            return android.util.Log.d(sTag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int d(String tag, String msg, Throwable tr) {
+        if (sEnabled) {
+            return android.util.Log.d(tag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int i(String msg) {
+        if (sEnabled) {
+            return android.util.Log.i(sTag, msg);
+        }
+        return 0;
+    }
+
+    public static int i(String tag, String msg) {
+        if (sEnabled) {
+            return android.util.Log.i(tag, msg);
+        }
+        return 0;
+    }
+
+    public static int i(String msg, Throwable tr) {
+        if (sEnabled) {
+            return android.util.Log.i(sTag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int i(String tag, String msg, Throwable tr) {
+        if (sEnabled) {
+            return android.util.Log.i(tag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int w(String msg) {
+        if (sEnabled) {
+            return android.util.Log.w(sTag, msg);
+        }
+        return 0;
+    }
+
+    public static int w(String tag, String msg) {
+        if (sEnabled) {
+            return android.util.Log.w(tag, msg);
+        }
+        return 0;
+    }
+
+    public static int w(String msg, Throwable tr) {
+        if (sEnabled) {
+            return android.util.Log.w(sTag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int w(String tag, String msg, Throwable tr) {
+        if (sEnabled) {
+            return android.util.Log.w(tag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int e(String msg) {
+        if (sEnabled) {
+            return android.util.Log.e(sTag, msg);
+        }
+        return 0;
+    }
+
+    public static int e(String tag, String msg) {
+        if (sEnabled) {
+            return android.util.Log.e(tag, msg);
+        }
+        return 0;
+    }
+
+    public static int e(String msg, Throwable tr) {
+        if (sEnabled) {
+            return android.util.Log.e(sTag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int e(String tag, String msg, Throwable tr) {
+        if (sEnabled) {
+            return android.util.Log.e(tag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int t(String msg, Object... args) {
+        if (sEnabled) {
+            return android.util.Log.v("test", String.format(msg, args));
+        }
+        return 0;
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/activeandroid/util/NaturalOrderComparator.java b/library/src/main/java/com/activeandroid/util/NaturalOrderComparator.java
new file mode 100644
index 00000000..8fbf04c1
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/util/NaturalOrderComparator.java
@@ -0,0 +1,132 @@
+package com.activeandroid.util;
+
+/*
+ NaturalOrderComparator.java -- Perform 'natural order' comparisons of strings in Java.
+ Copyright (C) 2003 by Pierre-Luc Paour <natorder@paour.com>
+
+ Based on the C version by Martin Pool, of which this is more or less a straight conversion.
+ Copyright (C) 2000 by Martin Pool <mbp@humbug.org.au>
+
+ This software is provided 'as-is', without any express or implied
+ warranty.  In no event will the authors be held liable for any damages
+ arising from the use of this software.
+
+ Permission is granted to anyone to use this software for any purpose,
+ including commercial applications, and to alter it and redistribute it
+ freely, subject to the following restrictions:
+
+ 1. The origin of this software must not be misrepresented; you must not
+ claim that you wrote the original software. If you use this software
+ in a product, an acknowledgment in the product documentation would be
+ appreciated but is not required.
+ 2. Altered source versions must be plainly marked as such, and must not be
+ misrepresented as being the original software.
+ 3. This notice may not be removed or altered from any source distribution.
+ */
+
+import java.util.Comparator;
+
+public class NaturalOrderComparator implements Comparator<Object> {
+    static char charAt(String s, int i) {
+        if (i >= s.length()) {
+            return 0;
+        } else {
+            return s.charAt(i);
+        }
+    }
+
+    int compareRight(String a, String b) {
+        int bias = 0;
+        int ia = 0;
+        int ib = 0;
+
+        // The longest run of digits wins. That aside, the greatest
+        // value wins, but we can't know that it will until we've scanned
+        // both numbers to know that they have the same magnitude, so we
+        // remember it in BIAS.
+        for (; ; ia++, ib++) {
+            char ca = charAt(a, ia);
+            char cb = charAt(b, ib);
+
+            if (!Character.isDigit(ca) && !Character.isDigit(cb)) {
+                return bias;
+            } else if (!Character.isDigit(ca)) {
+                return -1;
+            } else if (!Character.isDigit(cb)) {
+                return +1;
+            } else if (ca < cb) {
+                if (bias == 0) {
+                    bias = -1;
+                }
+            } else if (ca > cb) {
+                if (bias == 0)
+                    bias = +1;
+            } else if (ca == 0 && cb == 0) {
+                return bias;
+            }
+        }
+    }
+
+    public int compare(Object o1, Object o2) {
+        String a = o1.toString();
+        String b = o2.toString();
+
+        int ia = 0, ib = 0;
+        int nza = 0, nzb = 0;
+        char ca, cb;
+        int result;
+
+        while (true) {
+            // only count the number of zeroes leading the last number compared
+            nza = nzb = 0;
+
+            ca = charAt(a, ia);
+            cb = charAt(b, ib);
+
+            // skip over leading spaces or zeros
+            while (Character.isSpaceChar(ca) || ca == '0') {
+                if (ca == '0') {
+                    nza++;
+                } else {
+                    // only count consecutive zeroes
+                    nza = 0;
+                }
+
+                ca = charAt(a, ++ia);
+            }
+
+            while (Character.isSpaceChar(cb) || cb == '0') {
+                if (cb == '0') {
+                    nzb++;
+                } else {
+                    // only count consecutive zeroes
+                    nzb = 0;
+                }
+
+                cb = charAt(b, ++ib);
+            }
+
+            // process run of digits
+            if (Character.isDigit(ca) && Character.isDigit(cb)) {
+                if ((result = compareRight(a.substring(ia), b.substring(ib))) != 0) {
+                    return result;
+                }
+            }
+
+            if (ca == 0 && cb == 0) {
+                // The strings compare the same. Perhaps the caller
+                // will want to call strcmp to break the tie.
+                return nza - nzb;
+            }
+
+            if (ca < cb) {
+                return -1;
+            } else if (ca > cb) {
+                return +1;
+            }
+
+            ++ia;
+            ++ib;
+        }
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/activeandroid/util/ReflectionUtils.java b/library/src/main/java/com/activeandroid/util/ReflectionUtils.java
new file mode 100644
index 00000000..7f0a142b
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/util/ReflectionUtils.java
@@ -0,0 +1,109 @@
+package com.activeandroid.util;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.serializer.TypeSerializer;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+public final class ReflectionUtils {
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static boolean isModel(Class<?> type) {
+        return isSubclassOf(type, Model.class) && (!Modifier.isAbstract(type.getModifiers()));
+    }
+
+    public static boolean isTypeSerializer(Class<?> type) {
+        return isSubclassOf(type, TypeSerializer.class);
+    }
+
+    // Meta-data
+
+    @SuppressWarnings("unchecked")
+    public static <T> T getMetaData(Context context, String name) {
+        try {
+            final ApplicationInfo ai = context.getPackageManager().getApplicationInfo(context.getPackageName(),
+                    PackageManager.GET_META_DATA);
+
+            if (ai.metaData != null) {
+                return (T) ai.metaData.get(name);
+            }
+        } catch (Exception e) {
+            Log.w("Couldn't find meta-data: " + name);
+        }
+
+        return null;
+    }
+
+    public static Set<Field> getDeclaredColumnFields(Class<?> type) {
+        Set<Field> declaredColumnFields = Collections.emptySet();
+
+        if (ReflectionUtils.isSubclassOf(type, Model.class) || Model.class.equals(type)) {
+            declaredColumnFields = new LinkedHashSet<Field>();
+
+            Field[] fields = type.getDeclaredFields();
+            Arrays.sort(fields, new Comparator<Field>() {
+                @Override
+                public int compare(Field field1, Field field2) {
+                    return field2.getName().compareTo(field1.getName());
+                }
+            });
+            for (Field field : fields) {
+                if (field.isAnnotationPresent(Column.class)) {
+                    declaredColumnFields.add(field);
+                }
+            }
+
+            Class<?> parentType = type.getSuperclass();
+            if (parentType != null) {
+                declaredColumnFields.addAll(getDeclaredColumnFields(parentType));
+            }
+        }
+
+        return declaredColumnFields;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static boolean isSubclassOf(Class<?> type, Class<?> superClass) {
+        if (type.getSuperclass() != null) {
+            if (type.getSuperclass().equals(superClass)) {
+                return true;
+            }
+
+            return isSubclassOf(type.getSuperclass(), superClass);
+        }
+
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/activeandroid/util/SQLiteUtils.java b/library/src/main/java/com/activeandroid/util/SQLiteUtils.java
new file mode 100644
index 00000000..50101750
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/util/SQLiteUtils.java
@@ -0,0 +1,397 @@
+package com.activeandroid.util;
+
+/*
+ * Copyright (C) 2010 Michael Pardo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.database.Cursor;
+import android.os.Build;
+import android.text.TextUtils;
+
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Column.ConflictAction;
+import com.activeandroid.serializer.TypeSerializer;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public final class SQLiteUtils {
+    //////////////////////////////////////////////////////////////////////////////////////
+    // ENUMERATIONS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+    @SuppressWarnings("serial")
+    private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
+        {
+            put(byte.class, SQLiteType.INTEGER);
+            put(short.class, SQLiteType.INTEGER);
+            put(int.class, SQLiteType.INTEGER);
+            put(long.class, SQLiteType.INTEGER);
+            put(float.class, SQLiteType.REAL);
+            put(double.class, SQLiteType.REAL);
+            put(boolean.class, SQLiteType.INTEGER);
+            put(char.class, SQLiteType.TEXT);
+            put(byte[].class, SQLiteType.BLOB);
+            put(Byte.class, SQLiteType.INTEGER);
+            put(Short.class, SQLiteType.INTEGER);
+            put(Integer.class, SQLiteType.INTEGER);
+            put(Long.class, SQLiteType.INTEGER);
+            put(Float.class, SQLiteType.REAL);
+            put(Double.class, SQLiteType.REAL);
+            put(Boolean.class, SQLiteType.INTEGER);
+            put(Character.class, SQLiteType.TEXT);
+            put(String.class, SQLiteType.TEXT);
+            put(Byte[].class, SQLiteType.BLOB);
+        }
+    };
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE CONTSANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+    private static HashMap<String, List<String>> sIndexGroupMap;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+    private static HashMap<String, List<String>> sUniqueGroupMap;
+    private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
+
+    public static void execSql(String sql) {
+        Cache.openDatabase().execSQL(sql);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static void execSql(String sql, Object[] bindArgs) {
+        Cache.openDatabase().execSQL(sql, bindArgs);
+    }
+
+    public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
+        Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+        List<T> entities = processCursor(type, cursor);
+        cursor.close();
+
+        return entities;
+    }
+
+    public static int intQuery(final String sql, final String[] selectionArgs) {
+        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+        final int number = processIntCursor(cursor);
+        cursor.close();
+
+        return number;
+    }
+
+    public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
+        List<T> entities = rawQuery(type, sql, selectionArgs);
+
+        if (entities.size() > 0) {
+            return entities.get(0);
+        }
+
+        return null;
+    }
+
+    public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
+        final ArrayList<String> definitions = new ArrayList<String>();
+        sUniqueGroupMap = new HashMap<String, List<String>>();
+        sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
+
+        for (Field field : tableInfo.getFields()) {
+            createUniqueColumnDefinition(tableInfo, field);
+        }
+
+        if (sUniqueGroupMap.isEmpty()) {
+            return definitions;
+        }
+
+        Set<String> keySet = sUniqueGroupMap.keySet();
+        for (String key : keySet) {
+            List<String> group = sUniqueGroupMap.get(key);
+            ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
+
+            definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
+                    TextUtils.join(", ", group), conflictAction.toString()));
+        }
+
+        return definitions;
+    }
+
+    // Database creation
+
+    public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
+        final String name = tableInfo.getColumnName(field);
+        final Column column = field.getAnnotation(Column.class);
+
+        if (field.getName().equals("mId")) {
+            return;
+        }
+
+        String[] groups = column.uniqueGroups();
+        ConflictAction[] conflictActions = column.onUniqueConflicts();
+        if (groups.length != conflictActions.length)
+            return;
+
+        for (int i = 0; i < groups.length; i++) {
+            String group = groups[i];
+            ConflictAction conflictAction = conflictActions[i];
+
+            if (TextUtils.isEmpty(group))
+                continue;
+
+            List<String> list = sUniqueGroupMap.get(group);
+            if (list == null) {
+                list = new ArrayList<String>();
+            }
+            list.add(name);
+
+            sUniqueGroupMap.put(group, list);
+            sOnUniqueConflictsMap.put(group, conflictAction);
+        }
+    }
+
+    public static String[] createIndexDefinition(TableInfo tableInfo) {
+        final ArrayList<String> definitions = new ArrayList<String>();
+        sIndexGroupMap = new HashMap<String, List<String>>();
+
+        for (Field field : tableInfo.getFields()) {
+            createIndexColumnDefinition(tableInfo, field);
+        }
+
+        if (sIndexGroupMap.isEmpty()) {
+            return new String[0];
+        }
+
+        for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
+            definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
+                    "index_" + tableInfo.getTableName() + "_" + entry.getKey(),
+                    tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
+        }
+
+        return definitions.toArray(new String[definitions.size()]);
+    }
+
+    public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
+        final String name = tableInfo.getColumnName(field);
+        final Column column = field.getAnnotation(Column.class);
+
+        if (field.getName().equals("mId")) {
+            return;
+        }
+
+        if (column.index()) {
+            List<String> list = new ArrayList<String>();
+            list.add(name);
+            sIndexGroupMap.put(name, list);
+        }
+
+        String[] groups = column.indexGroups();
+        for (String group : groups) {
+            if (TextUtils.isEmpty(group))
+                continue;
+
+            List<String> list = sIndexGroupMap.get(group);
+            if (list == null) {
+                list = new ArrayList<String>();
+            }
+
+            list.add(name);
+            sIndexGroupMap.put(group, list);
+        }
+    }
+
+    public static String createTableDefinition(TableInfo tableInfo) {
+        final ArrayList<String> definitions = new ArrayList<String>();
+
+        for (Field field : tableInfo.getFields()) {
+            String definition = createColumnDefinition(tableInfo, field);
+            if (!TextUtils.isEmpty(definition)) {
+                definitions.add(definition);
+            }
+        }
+
+        definitions.addAll(createUniqueDefinition(tableInfo));
+
+        return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
+                TextUtils.join(", ", definitions));
+    }
+
+    @SuppressWarnings("unchecked")
+    public static String createColumnDefinition(TableInfo tableInfo, Field field) {
+        StringBuilder definition = new StringBuilder();
+
+        Class<?> type = field.getType();
+        final String name = tableInfo.getColumnName(field);
+        final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
+        final Column column = field.getAnnotation(Column.class);
+
+        if (typeSerializer != null) {
+            type = typeSerializer.getSerializedType();
+        }
+
+        if (TYPE_MAP.containsKey(type)) {
+            definition.append(name);
+            definition.append(" ");
+            definition.append(TYPE_MAP.get(type).toString());
+        } else if (ReflectionUtils.isModel(type)) {
+            definition.append(name);
+            definition.append(" ");
+            definition.append(SQLiteType.INTEGER.toString());
+        } else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
+            definition.append(name);
+            definition.append(" ");
+            definition.append(SQLiteType.TEXT.toString());
+        }
+
+        if (!TextUtils.isEmpty(definition)) {
+
+            if (name.equals(tableInfo.getIdName())) {
+                definition.append(" PRIMARY KEY AUTOINCREMENT");
+            } else if (column != null) {
+                if (column.length() > -1) {
+                    definition.append("(");
+                    definition.append(column.length());
+                    definition.append(")");
+                }
+
+                if (column.notNull()) {
+                    definition.append(" NOT NULL ON CONFLICT ");
+                    definition.append(column.onNullConflict().toString());
+                }
+
+                if (column.unique()) {
+                    definition.append(" UNIQUE ON CONFLICT ");
+                    definition.append(column.onUniqueConflict().toString());
+                }
+            }
+
+            if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
+                definition.append(" REFERENCES ");
+                definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
+                definition.append("(" + tableInfo.getIdName() + ")");
+                definition.append(" ON DELETE ");
+                definition.append(column.onDelete().toString().replace("_", " "));
+                definition.append(" ON UPDATE ");
+                definition.append(column.onUpdate().toString().replace("_", " "));
+            }
+        } else {
+            Log.e("No type mapping for: " + type.toString());
+        }
+
+        return definition.toString();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        String idName = tableInfo.getIdName();
+        final List<T> entities = new ArrayList<T>();
+
+        try {
+            Constructor<?> entityConstructor = type.getConstructor();
+
+            if (cursor.moveToFirst()) {
+                /**
+                 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+                 * when the cursor have multiple columns with same name obtained from join tables.
+                 */
+                List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+                do {
+                    Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
+                    if (entity == null) {
+                        entity = (T) entityConstructor.newInstance();
+                    }
+
+                    entity.loadFromCursor(cursor);
+                    entities.add((T) entity);
+                }
+                while (cursor.moveToNext());
+            }
+
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException(
+                    "Your model " + type.getName() + " does not define a default " +
+                            "constructor. The default constructor is required for " +
+                            "now in ActiveAndroid models, as the process to " +
+                            "populate the ORM model is : " +
+                            "1. instantiate default model " +
+                            "2. populate fields"
+            );
+        } catch (Exception e) {
+            Log.e("Failed to process cursor.", e);
+        }
+
+        return entities;
+    }
+
+    private static int processIntCursor(final Cursor cursor) {
+        if (cursor.moveToFirst()) {
+            return cursor.getInt(0);
+        }
+        return 0;
+    }
+
+    public static List<String> lexSqlScript(String sqlScript) {
+        ArrayList<String> sl = new ArrayList<String>();
+        boolean inString = false, quoteNext = false;
+        StringBuilder b = new StringBuilder(100);
+
+        for (int i = 0; i < sqlScript.length(); i++) {
+            char c = sqlScript.charAt(i);
+
+            if (c == ';' && !inString && !quoteNext) {
+                sl.add(b.toString());
+                b = new StringBuilder(100);
+                inString = false;
+                quoteNext = false;
+                continue;
+            }
+
+            if (c == '\'' && !quoteNext) {
+                inString = !inString;
+            }
+
+            quoteNext = c == '\\' && !quoteNext;
+
+            b.append(c);
+        }
+
+        if (b.length() > 0) {
+            sl.add(b.toString());
+        }
+
+        return sl;
+    }
+
+    public enum SQLiteType {
+        INTEGER, REAL, TEXT, BLOB
+    }
+}
diff --git a/src/com/activeandroid/util/SqlParser.java b/library/src/main/java/com/activeandroid/util/SqlParser.java
similarity index 95%
rename from src/com/activeandroid/util/SqlParser.java
rename to library/src/main/java/com/activeandroid/util/SqlParser.java
index f9531b7c..e9fec50a 100644
--- a/src/com/activeandroid/util/SqlParser.java
+++ b/library/src/main/java/com/activeandroid/util/SqlParser.java
@@ -26,9 +26,9 @@
 
 public class SqlParser {
 
-    public final static int STATE_NONE          = 0;
-    public final static int STATE_STRING        = 1;
-    public final static int STATE_COMMENT       = 2;
+    public final static int STATE_NONE = 0;
+    public final static int STATE_STRING = 1;
+    public final static int STATE_COMMENT = 2;
     public final static int STATE_COMMENT_BLOCK = 3;
 
     public static List<String> parse(final InputStream stream) throws IOException {
diff --git a/src/com/activeandroid/util/Tokenizer.java b/library/src/main/java/com/activeandroid/util/Tokenizer.java
similarity index 95%
rename from src/com/activeandroid/util/Tokenizer.java
rename to library/src/main/java/com/activeandroid/util/Tokenizer.java
index 8ae34da3..0db8084f 100644
--- a/src/com/activeandroid/util/Tokenizer.java
+++ b/library/src/main/java/com/activeandroid/util/Tokenizer.java
@@ -25,8 +25,8 @@
 
     private final InputStream mStream;
 
-    private boolean           mIsNext;
-    private int               mCurrent;
+    private boolean mIsNext;
+    private int mCurrent;
 
     public Tokenizer(final InputStream in) {
         this.mStream = in;
diff --git a/library/src/main/java/com/activeandroid/widget/ModelAdapter.java b/library/src/main/java/com/activeandroid/widget/ModelAdapter.java
new file mode 100644
index 00000000..dc66893f
--- /dev/null
+++ b/library/src/main/java/com/activeandroid/widget/ModelAdapter.java
@@ -0,0 +1,56 @@
+package com.activeandroid.widget;
+
+import android.content.Context;
+import android.widget.ArrayAdapter;
+
+import com.activeandroid.Model;
+
+import java.util.Collection;
+import java.util.List;
+
+public class ModelAdapter<T extends Model> extends ArrayAdapter<T> {
+    public ModelAdapter(Context context, int textViewResourceId) {
+        super(context, textViewResourceId);
+    }
+
+    public ModelAdapter(Context context, int resource, int textViewResourceId) {
+        super(context, resource, textViewResourceId);
+    }
+
+    public ModelAdapter(Context context, int textViewResourceId, List<T> objects) {
+        super(context, textViewResourceId, objects);
+    }
+
+    public ModelAdapter(Context context, int resource, int textViewResourceId, List<T> objects) {
+        super(context, resource, textViewResourceId, objects);
+    }
+
+    /**
+     * Clears the adapter and, if data != null, fills if with new Items.
+     *
+     * @param collection A Collection&lt;? extends T&gt; which members get added to the adapter.
+     */
+    public void setData(Collection<? extends T> collection) {
+        clear();
+
+        if (collection != null) {
+            for (T item : collection) {
+                add(item);
+            }
+        }
+    }
+
+    /**
+     * @return The Id of the record at position.
+     */
+    @Override
+    public long getItemId(int position) {
+        T item = getItem(position);
+
+        if (item != null) {
+            return item.getId();
+        } else {
+            return -1;
+        }
+    }
+}
diff --git a/pom-child.xml b/pom-child.xml
deleted file mode 100644
index 4f0c72df..00000000
--- a/pom-child.xml
+++ /dev/null
@@ -1,93 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-
-    <modelVersion>4.0.0</modelVersion>
-    <groupId>com.activeandroid</groupId>
-    <artifactId>activeandroid</artifactId>
-    <version>3.1-SNAPSHOT</version>
-    <packaging>jar</packaging>
-    <name>ActiveAndroid</name>
-
-    <licenses>
-        <license>
-            <name>The Apache Software License, Version 2.0</name>
-            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-            <distribution>repo</distribution>
-        </license>
-    </licenses>
-
-  <parent>
-    <groupId>com.activeandroid</groupId>
-    <artifactId>activeandroid-parent</artifactId>
-    <version>3.1-SNAPSHOT</version>
-    <relativePath>./pom.xml</relativePath>
-  </parent>
-
-    <scm>
-        <connection>scm:git:git@github.com:pardom/ActiveAndroid.git</connection>
-        <developerConnection>scm:git:git@github.com:pardom/ActiveAndroid.git</developerConnection>
-        <url>git@github.com:pardom/ActiveAndroid.git</url>
-    </scm>
-
-    <properties>
-        <java.version>1.6</java.version>
-        <platform.sdk>16</platform.sdk>
-        <platform.version>4.1.1.4</platform.version>
-        <platform.support-version>r7</platform.support-version>
-    </properties>
-
-    <dependencies>
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>android</artifactId>
-            <version>${platform.version}</version>
-            <scope>provided</scope>
-        </dependency>
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>android-test</artifactId>
-            <version>${platform.version}</version>
-            <scope>provided</scope>
-        </dependency>
-        <dependency>
-            <groupId>com.google.android</groupId>
-            <artifactId>support-v4</artifactId>
-            <version>${platform.support-version}</version>
-        </dependency>
-    </dependencies>
-
-    <build>
-        <sourceDirectory>src</sourceDirectory>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.14.1</version>
-            </plugin>
-            <plugin>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
-                <configuration>
-                    <source>${java.version}</source>
-                    <target>${java.version}</target>
-                </configuration>
-            </plugin>
-            <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-                <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
-                <configuration>
-                    <sdk>
-                        <path>${env.ANDROID_HOME}</path>
-                        <platform>${platform.sdk}</platform>
-                    </sdk>
-                </configuration>
-                <extensions>true</extensions>
-            </plugin>
-        </plugins>
-    </build>
-
-</project>
diff --git a/pom.xml b/pom.xml
deleted file mode 100644
index eafb111c..00000000
--- a/pom.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.activeandroid</groupId>
-  <artifactId>activeandroid-parent</artifactId>
-  <version>3.1-SNAPSHOT</version>
-  <packaging>pom</packaging>
-  <name>ActiveAndroid - Parent</name>
-
-  <modules>
-    <module>pom-child.xml</module>
-    <module>tests</module>
-  </modules>
-
-    <properties>
-        <java.version>1.6</java.version>
-        <platform.sdk>16</platform.sdk>
-        <platform.version>4.1.1.4</platform.version>
-        <platform.support-version>r7</platform.support-version>
-    </properties>
-
-  <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-          <artifactId>android-maven-plugin</artifactId>
-          <version>3.8.2</version>
-        </plugin>
-        <plugin>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.1</version>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-  </build>
-</project>
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..d8f14a13
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1 @@
+include ':library'
diff --git a/src/com/activeandroid/ActiveAndroid.java b/src/com/activeandroid/ActiveAndroid.java
deleted file mode 100644
index 25b18a51..00000000
--- a/src/com/activeandroid/ActiveAndroid.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-
-import com.activeandroid.util.Log;
-
-public final class ActiveAndroid {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void initialize(Context context) {
-		initialize(new Configuration.Builder(context).create());
-	}
-
-	public static void initialize(Configuration configuration) {
-		initialize(configuration, false);
-	}
-
-	public static void initialize(Context context, boolean loggingEnabled) {
-		initialize(new Configuration.Builder(context).create(), loggingEnabled);
-	}
-
-	public static void initialize(Configuration configuration, boolean loggingEnabled) {
-		// Set logging enabled first
-		setLoggingEnabled(loggingEnabled);
-		Cache.initialize(configuration);
-	}
-
-	public static void clearCache() {
-		Cache.clear();
-	}
-
-	public static void dispose() {
-		Cache.dispose();
-	}
-
-	public static void setLoggingEnabled(boolean enabled) {
-		Log.setEnabled(enabled);
-	}
-
-	public static SQLiteDatabase getDatabase() {
-		return Cache.openDatabase();
-	}
-
-	public static void beginTransaction() {
-		Cache.openDatabase().beginTransactionNonExclusive();
-	}
-
-	public static void endTransaction() {
-		Cache.openDatabase().endTransaction();
-	}
-
-	public static void setTransactionSuccessful() {
-		Cache.openDatabase().setTransactionSuccessful();
-	}
-
-	public static boolean inTransaction() {
-		return Cache.openDatabase().inTransaction();
-	}
-
-	public static void execSQL(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSQL(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-}
diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
deleted file mode 100644
index 6495e379..00000000
--- a/src/com/activeandroid/Cache.java
+++ /dev/null
@@ -1,158 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Collection;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.support.v4.util.LruCache;
-
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.Log;
-
-public final class Cache {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static final int DEFAULT_CACHE_SIZE = 1024;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static Context sContext;
-
-	private static ModelInfo sModelInfo;
-	private static DatabaseHelper sDatabaseHelper;
-
-	private static LruCache<String, Model> sEntities;
-
-	private static boolean sIsInitialized = false;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Cache() {
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static synchronized void initialize(Configuration configuration) {
-		if (sIsInitialized) {
-			Log.v("ActiveAndroid already initialized.");
-			return;
-		}
-
-		sContext = configuration.getContext();
-		sModelInfo = new ModelInfo(configuration);
-		sDatabaseHelper = new DatabaseHelper(configuration);
-
-		// TODO: It would be nice to override sizeOf here and calculate the memory
-		// actually used, however at this point it seems like the reflection
-		// required would be too costly to be of any benefit. We'll just set a max
-		// object size instead.
-		sEntities = new LruCache<String, Model>(configuration.getCacheSize());
-
-		openDatabase();
-
-		sIsInitialized = true;
-
-		Log.v("ActiveAndroid initialized successfully.");
-	}
-
-	public static synchronized void clear() {
-		sEntities.evictAll();
-		Log.v("Cache cleared.");
-	}
-
-	public static synchronized void dispose() {
-		closeDatabase();
-
-		sEntities = null;
-		sModelInfo = null;
-		sDatabaseHelper = null;
-
-		sIsInitialized = false;
-
-		Log.v("ActiveAndroid disposed. Call initialize to use library.");
-	}
-
-	// Database access
-	
-	public static boolean isInitialized() {
-		return sIsInitialized;
-	}
-
-	public static synchronized SQLiteDatabase openDatabase() {
-		return sDatabaseHelper.getWritableDatabase();
-	}
-
-	public static synchronized void closeDatabase() {
-		sDatabaseHelper.close();
-	}
-
-	// Context access
-
-	public static Context getContext() {
-		return sContext;
-	}
-
-	// Entity cache
-
-	public static String getIdentifier(Class<? extends Model> type, Long id) {
-		return getTableName(type) + "@" + id;
-	}
-
-	public static String getIdentifier(Model entity) {
-		return getIdentifier(entity.getClass(), entity.getId());
-	}
-
-	public static synchronized void addEntity(Model entity) {
-		sEntities.put(getIdentifier(entity), entity);
-	}
-
-	public static synchronized Model getEntity(Class<? extends Model> type, long id) {
-		return sEntities.get(getIdentifier(type, id));
-	}
-
-	public static synchronized void removeEntity(Model entity) {
-		sEntities.remove(getIdentifier(entity));
-	}
-
-	// Model cache
-
-	public static synchronized Collection<TableInfo> getTableInfos() {
-		return sModelInfo.getTableInfos();
-	}
-
-	public static synchronized TableInfo getTableInfo(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type);
-	}
-
-	public static synchronized TypeSerializer getParserForType(Class<?> type) {
-		return sModelInfo.getTypeSerializer(type);
-	}
-
-	public static synchronized String getTableName(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type).getTableName();
-	}
-}
diff --git a/src/com/activeandroid/Configuration.java b/src/com/activeandroid/Configuration.java
deleted file mode 100644
index e44e926d..00000000
--- a/src/com/activeandroid/Configuration.java
+++ /dev/null
@@ -1,319 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.content.Context;
-
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-public class Configuration {
-
-    public final static String SQL_PARSER_LEGACY = "legacy";
-    public final static String SQL_PARSER_DELIMITED = "delimited";
-	public final static int MAX_SQL_CACHE_SIZE = 100;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Context mContext;
-	private String mDatabaseName;
-	private int mDatabaseVersion;
-	private String mSqlParser;
-	private List<Class<? extends Model>> mModelClasses;
-	private List<Class<? extends TypeSerializer>> mTypeSerializers;
-	private int mCacheSize;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Configuration(Context context) {
-		mContext = context;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Context getContext() {
-		return mContext;
-	}
-
-	public String getDatabaseName() {
-		return mDatabaseName;
-	}
-
-	public int getDatabaseVersion() {
-		return mDatabaseVersion;
-	}
-	
-	public String getSqlParser() {
-	    return mSqlParser;
-	}
-
-	public List<Class<? extends Model>> getModelClasses() {
-		return mModelClasses;
-	}
-
-	public List<Class<? extends TypeSerializer>> getTypeSerializers() {
-		return mTypeSerializers;
-	}
-
-	public int getCacheSize() {
-		return mCacheSize;
-	}
-
-	public boolean isValid() {
-		return mModelClasses != null && mModelClasses.size() > 0;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// INNER CLASSES
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static class Builder {
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PRIVATE CONSTANTS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		private static final String AA_DB_NAME = "AA_DB_NAME";
-		private static final String AA_DB_VERSION = "AA_DB_VERSION";
-		private final static String AA_MODELS = "AA_MODELS";
-		private final static String AA_SERIALIZERS = "AA_SERIALIZERS";
-		private final static String AA_SQL_PARSER = "AA_SQL_PARSER";
-
-		private static final int DEFAULT_CACHE_SIZE = 1024;
-		private static final String DEFAULT_DB_NAME = "Application.db";
-		private static final String DEFAULT_SQL_PARSER = SQL_PARSER_LEGACY;
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PRIVATE MEMBERS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		private Context mContext;
-
-		private Integer mCacheSize;
-		private String mDatabaseName;
-		private Integer mDatabaseVersion;
-		private String mSqlParser;
-		private List<Class<? extends Model>> mModelClasses;
-		private List<Class<? extends TypeSerializer>> mTypeSerializers;
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// CONSTRUCTORS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		public Builder(Context context) {
-			mContext = context.getApplicationContext();
-			mCacheSize = DEFAULT_CACHE_SIZE;
-		}
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PUBLIC METHODS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		public Builder setCacheSize(int cacheSize) {
-			mCacheSize = cacheSize;
-			return this;
-		}
-
-		public Builder setDatabaseName(String databaseName) {
-			mDatabaseName = databaseName;
-			return this;
-		}
-
-		public Builder setDatabaseVersion(int databaseVersion) {
-			mDatabaseVersion = databaseVersion;
-			return this;
-		}
-		
-		public Builder setSqlParser(String sqlParser) {
-		    mSqlParser = sqlParser;
-		    return this;
-		}
-
-		public Builder addModelClass(Class<? extends Model> modelClass) {
-			if (mModelClasses == null) {
-				mModelClasses = new ArrayList<Class<? extends Model>>();
-			}
-
-			mModelClasses.add(modelClass);
-			return this;
-		}
-
-		public Builder addModelClasses(Class<? extends Model>... modelClasses) {
-			if (mModelClasses == null) {
-				mModelClasses = new ArrayList<Class<? extends Model>>();
-			}
-
-			mModelClasses.addAll(Arrays.asList(modelClasses));
-			return this;
-		}
-
-		public Builder setModelClasses(Class<? extends Model>... modelClasses) {
-			mModelClasses = Arrays.asList(modelClasses);
-			return this;
-		}
-
-		public Builder addTypeSerializer(Class<? extends TypeSerializer> typeSerializer) {
-			if (mTypeSerializers == null) {
-				mTypeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
-			}
-
-			mTypeSerializers.add(typeSerializer);
-			return this;
-		}
-
-		public Builder addTypeSerializers(Class<? extends TypeSerializer>... typeSerializers) {
-			if (mTypeSerializers == null) {
-				mTypeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
-			}
-
-			mTypeSerializers.addAll(Arrays.asList(typeSerializers));
-			return this;
-		}
-
-		public Builder setTypeSerializers(Class<? extends TypeSerializer>... typeSerializers) {
-			mTypeSerializers = Arrays.asList(typeSerializers);
-			return this;
-		}
-
-		public Configuration create() {
-			Configuration configuration = new Configuration(mContext);
-			configuration.mCacheSize = mCacheSize;
-
-			// Get database name from meta-data
-			if (mDatabaseName != null) {
-				configuration.mDatabaseName = mDatabaseName;
-			} else {
-				configuration.mDatabaseName = getMetaDataDatabaseNameOrDefault();
-			}
-
-			// Get database version from meta-data
-			if (mDatabaseVersion != null) {
-				configuration.mDatabaseVersion = mDatabaseVersion;
-			} else {
-				configuration.mDatabaseVersion = getMetaDataDatabaseVersionOrDefault();
-			}
-
-			// Get SQL parser from meta-data
-			if (mSqlParser != null) {
-			    configuration.mSqlParser = mSqlParser;
-			} else {
-			    configuration.mSqlParser = getMetaDataSqlParserOrDefault();
-			}
-			
-			// Get model classes from meta-data
-			if (mModelClasses != null) {
-				configuration.mModelClasses = mModelClasses;
-			} else {
-				final String modelList = ReflectionUtils.getMetaData(mContext, AA_MODELS);
-				if (modelList != null) {
-					configuration.mModelClasses = loadModelList(modelList.split(","));
-				}
-			}
-
-			// Get type serializer classes from meta-data
-			if (mTypeSerializers != null) {
-				configuration.mTypeSerializers = mTypeSerializers;
-			} else {
-				final String serializerList = ReflectionUtils.getMetaData(mContext, AA_SERIALIZERS);
-				if (serializerList != null) {
-					configuration.mTypeSerializers = loadSerializerList(serializerList.split(","));
-				}
-			}
-
-			return configuration;
-		}
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PRIVATE METHODS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		// Meta-data methods
-
-		private String getMetaDataDatabaseNameOrDefault() {
-			String aaName = ReflectionUtils.getMetaData(mContext, AA_DB_NAME);
-			if (aaName == null) {
-				aaName = DEFAULT_DB_NAME;
-			}
-
-			return aaName;
-		}
-
-		private int getMetaDataDatabaseVersionOrDefault() {
-			Integer aaVersion = ReflectionUtils.getMetaData(mContext, AA_DB_VERSION);
-			if (aaVersion == null || aaVersion == 0) {
-				aaVersion = 1;
-			}
-
-			return aaVersion;
-		}
-
-		private String getMetaDataSqlParserOrDefault() {
-		    final String mode = ReflectionUtils.getMetaData(mContext, AA_SQL_PARSER);
-		    if (mode == null) {
-		        return DEFAULT_SQL_PARSER;
-		    }
-		    return mode;
-		}
-
-		private List<Class<? extends Model>> loadModelList(String[] models) {
-			final List<Class<? extends Model>> modelClasses = new ArrayList<Class<? extends Model>>();
-			final ClassLoader classLoader = mContext.getClass().getClassLoader();
-			for (String model : models) {
-				try {
-					Class modelClass = Class.forName(model.trim(), false, classLoader);
-					if (ReflectionUtils.isModel(modelClass)) {
-						modelClasses.add(modelClass);
-					}
-				}
-				catch (ClassNotFoundException e) {
-					Log.e("Couldn't create class.", e);
-				}
-			}
-
-			return modelClasses;
-		}
-
-		private List<Class<? extends TypeSerializer>> loadSerializerList(String[] serializers) {
-			final List<Class<? extends TypeSerializer>> typeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
-			final ClassLoader classLoader = mContext.getClass().getClassLoader();
-			for (String serializer : serializers) {
-				try {
-					Class serializerClass = Class.forName(serializer.trim(), false, classLoader);
-					if (ReflectionUtils.isTypeSerializer(serializerClass)) {
-						typeSerializers.add(serializerClass);
-					}
-				}
-				catch (ClassNotFoundException e) {
-					Log.e("Couldn't create class.", e);
-				}
-			}
-
-			return typeSerializers;
-		}
-
-	}
-}
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
deleted file mode 100644
index 421426ea..00000000
--- a/src/com/activeandroid/Model.java
+++ /dev/null
@@ -1,320 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-
-import com.activeandroid.content.ContentProvider;
-import com.activeandroid.query.Delete;
-import com.activeandroid.query.Select;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
-
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-@SuppressWarnings("unchecked")
-public abstract class Model {
-
-	/** Prime number used for hashcode() implementation. */
-	private static final int HASH_PRIME = 739;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Long mId = null;
-
-	private final TableInfo mTableInfo;
-	private final String idName;
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Model() {
-		mTableInfo = Cache.getTableInfo(getClass());
-		idName = mTableInfo.getIdName();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public final Long getId() {
-		return mId;
-	}
-
-	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), idName+"=?", new String[] { getId().toString() });
-		Cache.removeEntity(this);
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-	}
-
-	public final Long save() {
-		final SQLiteDatabase db = Cache.openDatabase();
-		final ContentValues values = new ContentValues();
-
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-
-			field.setAccessible(true);
-
-			try {
-				Object value = field.get(this);
-
-				if (value != null) {
-					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-					if (typeSerializer != null) {
-						// serialize data
-						value = typeSerializer.serialize(value);
-						// set new object type
-						if (value != null) {
-							fieldType = value.getClass();
-							// check that the serializer returned what it promised
-							if (!fieldType.equals(typeSerializer.getSerializedType())) {
-								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-										typeSerializer.getSerializedType(), fieldType));
-							}
-						}
-					}
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (value == null) {
-					values.putNull(fieldName);
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					values.put(fieldName, (Byte) value);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					values.put(fieldName, (Short) value);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					values.put(fieldName, (Integer) value);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					values.put(fieldName, (Long) value);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					values.put(fieldName, (Float) value);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					values.put(fieldName, (Double) value);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					values.put(fieldName, (Boolean) value);
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(String.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					values.put(fieldName, (byte[]) value);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					values.put(fieldName, ((Model) value).getId());
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					values.put(fieldName, ((Enum<?>) value).name());
-				}
-			}
-			catch (IllegalArgumentException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-		}
-
-		if (mId == null) {
-			mId = db.insert(mTableInfo.getTableName(), null, values);
-		}
-		else {
-			db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
-		}
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-		return mId;
-	}
-
-	// Convenience methods
-
-	public static void delete(Class<? extends Model> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
-	}
-
-	public static <T extends Model> T load(Class<T> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
-	}
-
-	// Model population
-
-	public final void loadFromCursor(Cursor cursor) {
-        /**
-         * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-         * when the cursor have multiple columns with same name obtained from join tables.
-         */
-        List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-			final int columnIndex = columnsOrdered.indexOf(fieldName);
-
-			if (columnIndex < 0) {
-				continue;
-			}
-
-			field.setAccessible(true);
-
-			try {
-				boolean columnIsNull = cursor.isNull(columnIndex);
-				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-				Object value = null;
-
-				if (typeSerializer != null) {
-					fieldType = typeSerializer.getSerializedType();
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (columnIsNull) {
-					field = null;
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					value = cursor.getLong(columnIndex);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					value = cursor.getFloat(columnIndex);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					value = cursor.getDouble(columnIndex);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					value = cursor.getInt(columnIndex) != 0;
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					value = cursor.getString(columnIndex).charAt(0);
-				}
-				else if (fieldType.equals(String.class)) {
-					value = cursor.getString(columnIndex);
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					value = cursor.getBlob(columnIndex);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					final long entityId = cursor.getLong(columnIndex);
-					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
-
-					Model entity = Cache.getEntity(entityType, entityId);
-					if (entity == null) {
-						entity = new Select().from(entityType).where(idName+"=?", entityId).executeSingle();
-					}
-
-					value = entity;
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					@SuppressWarnings("rawtypes")
-					final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-					value = Enum.valueOf(enumType, cursor.getString(columnIndex));
-				}
-
-				// Use a deserializer if one is available
-				if (typeSerializer != null && !columnIsNull) {
-					value = typeSerializer.deserialize(value);
-				}
-
-				// Set the field value
-				if (value != null) {
-					field.set(this, value);
-				}
-			}
-			catch (IllegalArgumentException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (SecurityException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-		}
-
-		if (mId != null) {
-			Cache.addEntity(this);
-		}
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
-		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public String toString() {
-		return mTableInfo.getTableName() + "@" + getId();
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (obj instanceof Model && this.mId != null) {
-			final Model other = (Model) obj;
-
-			return this.mId.equals(other.mId)							
-							&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
-		} else {
-			return this == obj;
-		}
-	}
-
-	@Override
-	public int hashCode() {
-		int hash = HASH_PRIME;
-		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); //if id is null, use Object.hashCode()
-		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
-		return hash; //To change body of generated methods, choose Tools | Templates.
-	}
-}
diff --git a/src/com/activeandroid/ModelInfo.java b/src/com/activeandroid/ModelInfo.java
deleted file mode 100644
index 09e79117..00000000
--- a/src/com/activeandroid/ModelInfo.java
+++ /dev/null
@@ -1,209 +0,0 @@
-package com.activeandroid;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.File;
-import java.io.IOException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Collection;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import android.content.Context;
-
-import com.activeandroid.serializer.CalendarSerializer;
-import com.activeandroid.serializer.SqlDateSerializer;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.serializer.UtilDateSerializer;
-import com.activeandroid.serializer.FileSerializer;
-import com.activeandroid.util.Log;
-import com.activeandroid.util.ReflectionUtils;
-import dalvik.system.DexFile;
-
-final class ModelInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Map<Class<? extends Model>, TableInfo> mTableInfos = new HashMap<Class<? extends Model>, TableInfo>();
-	private Map<Class<?>, TypeSerializer> mTypeSerializers = new HashMap<Class<?>, TypeSerializer>() {
-		{
-			put(Calendar.class, new CalendarSerializer());
-			put(java.sql.Date.class, new SqlDateSerializer());
-			put(java.util.Date.class, new UtilDateSerializer());
-			put(java.io.File.class, new FileSerializer());
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public ModelInfo(Configuration configuration) {
-		if (!loadModelFromMetaData(configuration)) {
-			try {
-				scanForModel(configuration.getContext());
-			}
-			catch (IOException e) {
-				Log.e("Couldn't open source path.", e);
-			}
-		}
-
-		Log.i("ModelInfo loaded.");
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Collection<TableInfo> getTableInfos() {
-		return mTableInfos.values();
-	}
-
-	public TableInfo getTableInfo(Class<? extends Model> type) {
-		return mTableInfos.get(type);
-	}
-
-	public TypeSerializer getTypeSerializer(Class<?> type) {
-		return mTypeSerializers.get(type);
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private boolean loadModelFromMetaData(Configuration configuration) {
-		if (!configuration.isValid()) {
-			return false;
-		}
-
-		final List<Class<? extends Model>> models = configuration.getModelClasses();
-		if (models != null) {
-			for (Class<? extends Model> model : models) {
-				mTableInfos.put(model, new TableInfo(model));
-			}
-		}
-
-		final List<Class<? extends TypeSerializer>> typeSerializers = configuration.getTypeSerializers();
-		if (typeSerializers != null) {
-			for (Class<? extends TypeSerializer> typeSerializer : typeSerializers) {
-				try {
-					TypeSerializer instance = typeSerializer.newInstance();
-					mTypeSerializers.put(instance.getDeserializedType(), instance);
-				}
-				catch (InstantiationException e) {
-					Log.e("Couldn't instantiate TypeSerializer.", e);
-				}
-				catch (IllegalAccessException e) {
-					Log.e("IllegalAccessException", e);
-				}
-			}
-		}
-
-		return true;
-	}
-
-	private void scanForModel(Context context) throws IOException {
-		String packageName = context.getPackageName();
-		String sourcePath = context.getApplicationInfo().sourceDir;
-		List<String> paths = new ArrayList<String>();
-
-		if (sourcePath != null && !(new File(sourcePath).isDirectory())) {
-			DexFile dexfile = new DexFile(sourcePath);
-			Enumeration<String> entries = dexfile.entries();
-
-			while (entries.hasMoreElements()) {
-				paths.add(entries.nextElement());
-			}
-		}
-		// Robolectric fallback
-		else {
-			ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-			Enumeration<URL> resources = classLoader.getResources("");
-
-			while (resources.hasMoreElements()) {
-				String path = resources.nextElement().getFile();
-				if (path.contains("bin") || path.contains("classes")) {
-					paths.add(path);
-				}
-			}
-		}
-
-		for (String path : paths) {
-			File file = new File(path);
-			scanForModelClasses(file, packageName, context.getClassLoader());
-		}
-	}
-
-	private void scanForModelClasses(File path, String packageName, ClassLoader classLoader) {
-		if (path.isDirectory()) {
-			for (File file : path.listFiles()) {
-				scanForModelClasses(file, packageName, classLoader);
-			}
-		}
-		else {
-			String className = path.getName();
-
-			// Robolectric fallback
-			if (!path.getPath().equals(className)) {
-				className = path.getPath();
-
-				if (className.endsWith(".class")) {
-					className = className.substring(0, className.length() - 6);
-				}
-				else {
-					return;
-				}
-
-				className = className.replace(System.getProperty("file.separator"), ".");
-
-				int packageNameIndex = className.lastIndexOf(packageName);
-				if (packageNameIndex < 0) {
-					return;
-				}
-
-				className = className.substring(packageNameIndex);
-			}
-
-			try {
-				Class<?> discoveredClass = Class.forName(className, false, classLoader);
-				if (ReflectionUtils.isModel(discoveredClass)) {
-					@SuppressWarnings("unchecked")
-					Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
-					mTableInfos.put(modelClass, new TableInfo(modelClass));
-				}
-				else if (ReflectionUtils.isTypeSerializer(discoveredClass)) {
-					TypeSerializer instance = (TypeSerializer) discoveredClass.newInstance();
-					mTypeSerializers.put(instance.getDeserializedType(), instance);
-				}
-			}
-			catch (ClassNotFoundException e) {
-				Log.e("Couldn't create class.", e);
-			}
-			catch (InstantiationException e) {
-				Log.e("Couldn't instantiate TypeSerializer.", e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e("IllegalAccessException", e);
-			}
-		}
-	}
-}
diff --git a/src/com/activeandroid/annotation/Column.java b/src/com/activeandroid/annotation/Column.java
deleted file mode 100644
index 56bbcde8..00000000
--- a/src/com/activeandroid/annotation/Column.java
+++ /dev/null
@@ -1,110 +0,0 @@
-package com.activeandroid.annotation;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-@Target(ElementType.FIELD)
-@Retention(RetentionPolicy.RUNTIME)
-public @interface Column {
-	public enum ConflictAction {
-		ROLLBACK, ABORT, FAIL, IGNORE, REPLACE
-	}
-
-	public enum ForeignKeyAction {
-		SET_NULL, SET_DEFAULT, CASCADE, RESTRICT, NO_ACTION
-	}
-
-	public String name() default "";
-
-	public int length() default -1;
-
-	public boolean notNull() default false;
-
-	public ConflictAction onNullConflict() default ConflictAction.FAIL;
-
-	public ForeignKeyAction onDelete() default ForeignKeyAction.NO_ACTION;
-
-	public ForeignKeyAction onUpdate() default ForeignKeyAction.NO_ACTION;
-
-	public boolean unique() default false;
-
-	public ConflictAction onUniqueConflict() default ConflictAction.FAIL;
-
-	/*
-	 * If set uniqueGroups = {"group_name"}, we will create a table constraint with group.
-	 *
-	 * Example:
-	 *
-	 * @Table(name = "table_name")
-	 * public class Table extends Model {
-	 *     @Column(name = "member1", uniqueGroups = {"group1"}, onUniqueConflicts = {ConflictAction.FAIL})
-	 *     public String member1;
-	 *
-	 *     @Column(name = "member2", uniqueGroups = {"group1", "group2"}, onUniqueConflicts = {ConflictAction.FAIL, ConflictAction.IGNORE})
-	 *     public String member2;
-	 *
-	 *     @Column(name = "member3", uniqueGroups = {"group2"}, onUniqueConflicts = {ConflictAction.IGNORE})
-	 *     public String member3;
-	 * }
-	 *
-	 * CREATE TABLE table_name (..., UNIQUE (member1, member2) ON CONFLICT FAIL, UNIQUE (member2, member3) ON CONFLICT IGNORE)
-	 */
-	public String[] uniqueGroups() default {};
-
-	public ConflictAction[] onUniqueConflicts() default {};
-
-	/*
-	 * If set index = true, we will create a index with single column.
-	 *
-	 * Example:
-	 *
-	 * @Table(name = "table_name")
-	 * public class Table extends Model {
-	 *     @Column(name = "member", index = true)
-	 *     public String member;
-	 * }
-	 *
-	 * Execute CREATE INDEX index_table_name_member on table_name(member)
-	 */
-	public boolean index() default false;
-
-	/*
-	 * If set indexGroups = {"group_name"}, we will create a index with group.
-	 *
-	 * Example:
-	 *
-	 * @Table(name = "table_name")
-	 * public class Table extends Model {
-	 *     @Column(name = "member1", indexGroups = {"group1"})
-	 *     public String member1;
-	 *
-	 *     @Column(name = "member2", indexGroups = {"group1", "group2"})
-	 *     public String member2;
-	 *
-	 *     @Column(name = "member3", indexGroups = {"group2"})
-	 *     public String member3;
-	 * }
-	 *
-	 * Execute CREATE INDEX index_table_name_group1 on table_name(member1, member2)
-	 * Execute CREATE INDEX index_table_name_group2 on table_name(member2, member3)
-	 */
-	public String[] indexGroups() default {};
-}
diff --git a/src/com/activeandroid/content/ContentProvider.java b/src/com/activeandroid/content/ContentProvider.java
deleted file mode 100644
index b4a841d6..00000000
--- a/src/com/activeandroid/content/ContentProvider.java
+++ /dev/null
@@ -1,192 +0,0 @@
-package com.activeandroid.content;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import android.content.ContentValues;
-import android.content.UriMatcher;
-import android.database.Cursor;
-import android.net.Uri;
-import android.util.SparseArray;
-
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Cache;
-import com.activeandroid.Configuration;
-import com.activeandroid.Model;
-import com.activeandroid.TableInfo;
-
-public class ContentProvider extends android.content.ContentProvider {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
-	private static final SparseArray<Class<? extends Model>> TYPE_CODES = new SparseArray<Class<? extends Model>>();
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static String sAuthority;
-	private static SparseArray<String> sMimeTypeCache = new SparseArray<String>();
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public boolean onCreate() {
-		ActiveAndroid.initialize(getConfiguration());
-		sAuthority = getAuthority();
-
-		final List<TableInfo> tableInfos = new ArrayList<TableInfo>(Cache.getTableInfos());
-		final int size = tableInfos.size();
-		for (int i = 0; i < size; i++) {
-			final TableInfo tableInfo = tableInfos.get(i);
-			final int tableKey = (i * 2) + 1;
-			final int itemKey = (i * 2) + 2;
-
-			// content://<authority>/<table>
-			URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase(), tableKey);
-			TYPE_CODES.put(tableKey, tableInfo.getType());
-
-			// content://<authority>/<table>/<id>
-			URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase() + "/#", itemKey);
-			TYPE_CODES.put(itemKey, tableInfo.getType());
-		}
-
-		return true;
-	}
-
-	@Override
-	public String getType(Uri uri) {
-		final int match = URI_MATCHER.match(uri);
-
-		String cachedMimeType = sMimeTypeCache.get(match);
-		if (cachedMimeType != null) {
-			return cachedMimeType;
-		}
-
-		final Class<? extends Model> type = getModelType(uri);
-		final boolean single = ((match % 2) == 0);
-
-		StringBuilder mimeType = new StringBuilder();
-		mimeType.append("vnd");
-		mimeType.append(".");
-		mimeType.append(sAuthority);
-		mimeType.append(".");
-		mimeType.append(single ? "item" : "dir");
-		mimeType.append("/");
-		mimeType.append("vnd");
-		mimeType.append(".");
-		mimeType.append(sAuthority);
-		mimeType.append(".");
-		mimeType.append(Cache.getTableName(type));
-
-		sMimeTypeCache.append(match, mimeType.toString());
-
-		return mimeType.toString();
-	}
-
-	// SQLite methods
-
-	@Override
-	public Uri insert(Uri uri, ContentValues values) {
-		final Class<? extends Model> type = getModelType(uri);
-		final Long id = Cache.openDatabase().insert(Cache.getTableName(type), null, values);
-
-		if (id != null && id > 0) {
-			Uri retUri = createUri(type, id);
-			notifyChange(retUri);
-
-			return retUri;
-		}
-
-		return null;
-	}
-
-	@Override
-	public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-		final Class<? extends Model> type = getModelType(uri);
-		final int count = Cache.openDatabase().update(Cache.getTableName(type), values, selection, selectionArgs);
-
-		notifyChange(uri);
-
-		return count;
-	}
-
-	@Override
-	public int delete(Uri uri, String selection, String[] selectionArgs) {
-		final Class<? extends Model> type = getModelType(uri);
-		final int count = Cache.openDatabase().delete(Cache.getTableName(type), selection, selectionArgs);
-
-		notifyChange(uri);
-
-		return count;
-	}
-
-	@Override
-	public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
-		final Class<? extends Model> type = getModelType(uri);
-		final Cursor cursor = Cache.openDatabase().query(
-				Cache.getTableName(type),
-				projection,
-				selection,
-				selectionArgs,
-				null,
-				null,
-				sortOrder);
-
-		cursor.setNotificationUri(getContext().getContentResolver(), uri);
-
-		return cursor;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static Uri createUri(Class<? extends Model> type, Long id) {
-		final StringBuilder uri = new StringBuilder();
-		uri.append("content://");
-		uri.append(sAuthority);
-		uri.append("/");
-		uri.append(Cache.getTableName(type).toLowerCase());
-
-		if (id != null) {
-			uri.append("/");
-			uri.append(id.toString());
-		}
-
-		return Uri.parse(uri.toString());
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	protected String getAuthority() {
-		return getContext().getPackageName();
-	}
-
-	protected Configuration getConfiguration() {
-		return new Configuration.Builder(getContext()).create();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Class<? extends Model> getModelType(Uri uri) {
-		final int code = URI_MATCHER.match(uri);
-		if (code != UriMatcher.NO_MATCH) {
-			return TYPE_CODES.get(code);
-		}
-
-		return null;
-	}
-
-	private void notifyChange(Uri uri) {
-		getContext().getContentResolver().notifyChange(uri, null);
-	}
-}
diff --git a/src/com/activeandroid/query/Join.java b/src/com/activeandroid/query/Join.java
deleted file mode 100644
index 13cdba3b..00000000
--- a/src/com/activeandroid/query/Join.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package com.activeandroid.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.text.TextUtils;
-
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
-
-public final class Join implements Sqlable {
-	static enum JoinType {
-		LEFT, OUTER, INNER, CROSS
-	}
-
-	private From mFrom;
-	private Class<? extends Model> mType;
-	private String mAlias;
-	private JoinType mJoinType;
-	private String mOn;
-	private String[] mUsing;
-
-	Join(From from, Class<? extends Model> table, JoinType joinType) {
-		mFrom = from;
-		mType = table;
-		mJoinType = joinType;
-	}
-
-	public Join as(String alias) {
-		mAlias = alias;
-		return this;
-	}
-
-	public From on(String on) {
-		mOn = on;
-		return mFrom;
-	}
-
-	public From on(String on, Object... args) {
-		mOn = on;
-		mFrom.addArguments(args);
-		return mFrom;
-	}
-
-	public From using(String... columns) {
-		mUsing = columns;
-		return mFrom;
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-
-		if (mJoinType != null) {
-			sql.append(mJoinType.toString()).append(" ");
-		}
-
-		sql.append("JOIN ");
-		sql.append(Cache.getTableName(mType));
-		sql.append(" ");
-
-		if (mAlias != null) {
-			sql.append("AS ");
-			sql.append(mAlias);
-			sql.append(" ");
-		}
-
-		if (mOn != null) {
-			sql.append("ON ");
-			sql.append(mOn);
-			sql.append(" ");
-		}
-		else if (mUsing != null) {
-			sql.append("USING (");
-			sql.append(TextUtils.join(", ", mUsing));
-			sql.append(") ");
-		}
-
-		return sql.toString();
-	}
-}
diff --git a/src/com/activeandroid/query/Select.java b/src/com/activeandroid/query/Select.java
deleted file mode 100644
index 1d4c6488..00000000
--- a/src/com/activeandroid/query/Select.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package com.activeandroid.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.text.TextUtils;
-
-import com.activeandroid.Model;
-
-public final class Select implements Sqlable {
-	private String[] mColumns;
-	private boolean mDistinct = false;
-	private boolean mAll = false;
-
-	public Select() {
-	}
-
-	public Select(String... columns) {
-		mColumns = columns;
-	}
-
-	public Select(Column... columns) {
-		final int size = columns.length;
-		mColumns = new String[size];
-		for (int i = 0; i < size; i++) {
-			mColumns[i] = columns[i].name + " AS " + columns[i].alias;
-		}
-	}
-
-	public Select distinct() {
-		mDistinct = true;
-		mAll = false;
-
-		return this;
-	}
-
-	public Select all() {
-		mDistinct = false;
-		mAll = true;
-
-		return this;
-	}
-
-	public From from(Class<? extends Model> table) {
-		return new From(table, this);
-	}
-
-	public static class Column {
-		String name;
-		String alias;
-
-		public Column(String name, String alias) {
-			this.name = name;
-			this.alias = alias;
-		}
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-
-		sql.append("SELECT ");
-
-		if (mDistinct) {
-			sql.append("DISTINCT ");
-		}
-		else if (mAll) {
-			sql.append("ALL ");
-		}
-
-		if (mColumns != null && mColumns.length > 0) {
-			sql.append(TextUtils.join(", ", mColumns) + " ");
-		}
-		else {
-			sql.append("* ");
-		}
-
-		return sql.toString();
-	}
-}
\ No newline at end of file
diff --git a/src/com/activeandroid/query/Set.java b/src/com/activeandroid/query/Set.java
deleted file mode 100644
index 183d99f0..00000000
--- a/src/com/activeandroid/query/Set.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package com.activeandroid.query;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.activeandroid.util.SQLiteUtils;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-public final class Set implements Sqlable {
-	private Update mUpdate;
-
-	private String mSet;
-	private String mWhere;
-
-	private List<Object> mSetArguments;
-	private List<Object> mWhereArguments;
-
-	public Set(Update queryBase, String set) {
-		mUpdate = queryBase;
-		mSet = set;
-
-		mSetArguments = new ArrayList<Object>();
-		mWhereArguments = new ArrayList<Object>();
-	}
-
-	public Set(Update queryBase, String set, Object... args) {
-		mUpdate = queryBase;
-		mSet = set;
-
-		mSetArguments = new ArrayList<Object>();
-		mWhereArguments = new ArrayList<Object>();
-
-		mSetArguments.addAll(Arrays.asList(args));
-	}
-
-	public Set where(String where) {
-		mWhere = where;
-		mWhereArguments.clear();
-
-		return this;
-	}
-
-	public Set where(String where, Object... args) {
-		mWhere = where;
-		mWhereArguments.clear();
-		mWhereArguments.addAll(Arrays.asList(args));
-
-		return this;
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-		sql.append(mUpdate.toSql());
-		sql.append("SET ");
-		sql.append(mSet);
-		sql.append(" ");
-
-		if (mWhere != null) {
-			sql.append("WHERE ");
-			sql.append(mWhere);
-			sql.append(" ");
-		}
-
-		return sql.toString();
-	}
-
-	public void execute() {
-		SQLiteUtils.execSql(toSql(), getArguments());
-	}
-
-	public String[] getArguments() {
-		final int setSize = mSetArguments.size();
-		final int whereSize = mWhereArguments.size();
-		final String[] args = new String[setSize + whereSize];
-
-		for (int i = 0; i < setSize; i++) {
-			args[i] = mSetArguments.get(i).toString();
-		}
-
-		for (int i = 0; i < whereSize; i++) {
-			args[i + setSize] = mWhereArguments.get(i).toString();
-		}
-
-		return args;
-	}
-}
diff --git a/src/com/activeandroid/serializer/BigDecimalSerializer.java b/src/com/activeandroid/serializer/BigDecimalSerializer.java
deleted file mode 100644
index 333f900f..00000000
--- a/src/com/activeandroid/serializer/BigDecimalSerializer.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package com.activeandroid.serializer;
-
-import java.math.BigDecimal;
-
-public final class BigDecimalSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return BigDecimal.class;
-	}
-
-	public Class<?> getSerializedType() {
-		return String.class;
-	}
-
-	public String serialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return ((BigDecimal) data).toString();
-	}
-
-	public BigDecimal deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return new BigDecimal((String) data);
-	}
-}
\ No newline at end of file
diff --git a/src/com/activeandroid/serializer/UUIDSerializer.java b/src/com/activeandroid/serializer/UUIDSerializer.java
deleted file mode 100644
index 94ba37ff..00000000
--- a/src/com/activeandroid/serializer/UUIDSerializer.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package com.activeandroid.serializer;
-
-import java.util.UUID;
-
-public final class UUIDSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return UUID.class;
-	}
-
-	public Class<?> getSerializedType() {
-		return String.class;
-	}
-
-	public String serialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return ((UUID) data).toString();
-	}
-
-	public UUID deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return UUID.fromString((String)data);
-	}
-}
\ No newline at end of file
diff --git a/src/com/activeandroid/util/Log.java b/src/com/activeandroid/util/Log.java
deleted file mode 100644
index 3c40a23f..00000000
--- a/src/com/activeandroid/util/Log.java
+++ /dev/null
@@ -1,196 +0,0 @@
-package com.activeandroid.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public final class Log {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static String sTag = "ActiveAndroid";
-	private static boolean sEnabled = false;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Log() {
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-    public static boolean isEnabled() {
-        return sEnabled;
-    }
-
-	public static void setEnabled(boolean enabled) {
-		sEnabled = enabled;
-	}
-
-	public static boolean isLoggingEnabled() {
-		return sEnabled;
-	}
-
-	public static int v(String msg) {
-		if (sEnabled) {
-			return android.util.Log.v(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int v(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.v(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int v(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.v(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int v(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.v(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int d(String msg) {
-		if (sEnabled) {
-			return android.util.Log.d(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int d(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.d(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int d(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.d(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int d(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.d(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int i(String msg) {
-		if (sEnabled) {
-			return android.util.Log.i(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int i(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.i(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int i(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.i(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int i(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.i(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int w(String msg) {
-		if (sEnabled) {
-			return android.util.Log.w(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int w(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.w(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int w(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.w(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int w(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.w(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int e(String msg) {
-		if (sEnabled) {
-			return android.util.Log.e(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int e(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.e(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int e(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.e(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int e(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.e(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int t(String msg, Object... args) {
-		if (sEnabled) {
-			return android.util.Log.v("test", String.format(msg, args));
-		}
-		return 0;
-	}
-}
\ No newline at end of file
diff --git a/src/com/activeandroid/util/NaturalOrderComparator.java b/src/com/activeandroid/util/NaturalOrderComparator.java
deleted file mode 100644
index 3e44af96..00000000
--- a/src/com/activeandroid/util/NaturalOrderComparator.java
+++ /dev/null
@@ -1,141 +0,0 @@
-package com.activeandroid.util;
-
-/*
- NaturalOrderComparator.java -- Perform 'natural order' comparisons of strings in Java.
- Copyright (C) 2003 by Pierre-Luc Paour <natorder@paour.com>
-
- Based on the C version by Martin Pool, of which this is more or less a straight conversion.
- Copyright (C) 2000 by Martin Pool <mbp@humbug.org.au>
-
- This software is provided 'as-is', without any express or implied
- warranty.  In no event will the authors be held liable for any damages
- arising from the use of this software.
-
- Permission is granted to anyone to use this software for any purpose,
- including commercial applications, and to alter it and redistribute it
- freely, subject to the following restrictions:
-
- 1. The origin of this software must not be misrepresented; you must not
- claim that you wrote the original software. If you use this software
- in a product, an acknowledgment in the product documentation would be
- appreciated but is not required.
- 2. Altered source versions must be plainly marked as such, and must not be
- misrepresented as being the original software.
- 3. This notice may not be removed or altered from any source distribution.
- */
-
-import java.util.Comparator;
-
-public class NaturalOrderComparator implements Comparator<Object> {
-	int compareRight(String a, String b) {
-		int bias = 0;
-		int ia = 0;
-		int ib = 0;
-
-		// The longest run of digits wins. That aside, the greatest
-		// value wins, but we can't know that it will until we've scanned
-		// both numbers to know that they have the same magnitude, so we
-		// remember it in BIAS.
-		for (;; ia++, ib++) {
-			char ca = charAt(a, ia);
-			char cb = charAt(b, ib);
-
-			if (!Character.isDigit(ca) && !Character.isDigit(cb)) {
-				return bias;
-			}
-			else if (!Character.isDigit(ca)) {
-				return -1;
-			}
-			else if (!Character.isDigit(cb)) {
-				return +1;
-			}
-			else if (ca < cb) {
-				if (bias == 0) {
-					bias = -1;
-				}
-			}
-			else if (ca > cb) {
-				if (bias == 0)
-					bias = +1;
-			}
-			else if (ca == 0 && cb == 0) {
-				return bias;
-			}
-		}
-	}
-
-	public int compare(Object o1, Object o2) {
-		String a = o1.toString();
-		String b = o2.toString();
-
-		int ia = 0, ib = 0;
-		int nza = 0, nzb = 0;
-		char ca, cb;
-		int result;
-
-		while (true) {
-			// only count the number of zeroes leading the last number compared
-			nza = nzb = 0;
-
-			ca = charAt(a, ia);
-			cb = charAt(b, ib);
-
-			// skip over leading spaces or zeros
-			while (Character.isSpaceChar(ca) || ca == '0') {
-				if (ca == '0') {
-					nza++;
-				}
-				else {
-					// only count consecutive zeroes
-					nza = 0;
-				}
-
-				ca = charAt(a, ++ia);
-			}
-
-			while (Character.isSpaceChar(cb) || cb == '0') {
-				if (cb == '0') {
-					nzb++;
-				}
-				else {
-					// only count consecutive zeroes
-					nzb = 0;
-				}
-
-				cb = charAt(b, ++ib);
-			}
-
-			// process run of digits
-			if (Character.isDigit(ca) && Character.isDigit(cb)) {
-				if ((result = compareRight(a.substring(ia), b.substring(ib))) != 0) {
-					return result;
-				}
-			}
-
-			if (ca == 0 && cb == 0) {
-				// The strings compare the same. Perhaps the caller
-				// will want to call strcmp to break the tie.
-				return nza - nzb;
-			}
-
-			if (ca < cb) {
-				return -1;
-			}
-			else if (ca > cb) {
-				return +1;
-			}
-
-			++ia;
-			++ib;
-		}
-	}
-
-	static char charAt(String s, int i) {
-		if (i >= s.length()) {
-			return 0;
-		}
-		else {
-			return s.charAt(i);
-		}
-	}
-}
\ No newline at end of file
diff --git a/src/com/activeandroid/util/ReflectionUtils.java b/src/com/activeandroid/util/ReflectionUtils.java
deleted file mode 100644
index 32e995cc..00000000
--- a/src/com/activeandroid/util/ReflectionUtils.java
+++ /dev/null
@@ -1,110 +0,0 @@
-package com.activeandroid.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.LinkedHashSet;
-import java.util.Set;
-
-import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-
-import com.activeandroid.Model;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.serializer.TypeSerializer;
-
-public final class ReflectionUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static boolean isModel(Class<?> type) {
-		return isSubclassOf(type, Model.class) && (!Modifier.isAbstract(type.getModifiers()));
-	}
-
-	public static boolean isTypeSerializer(Class<?> type) {
-		return isSubclassOf(type, TypeSerializer.class);
-	}
-
-	// Meta-data
-
-	@SuppressWarnings("unchecked")
-	public static <T> T getMetaData(Context context, String name) {
-		try {
-			final ApplicationInfo ai = context.getPackageManager().getApplicationInfo(context.getPackageName(),
-					PackageManager.GET_META_DATA);
-
-			if (ai.metaData != null) {
-				return (T) ai.metaData.get(name);
-			}
-		}
-		catch (Exception e) {
-			Log.w("Couldn't find meta-data: " + name);
-		}
-
-		return null;
-	}
-	
-	public static Set<Field> getDeclaredColumnFields(Class<?> type) {
-		Set<Field> declaredColumnFields = Collections.emptySet();
-		
-		if (ReflectionUtils.isSubclassOf(type, Model.class) || Model.class.equals(type)) {
-			declaredColumnFields = new LinkedHashSet<Field>();
-			
-			Field[] fields = type.getDeclaredFields();
-			Arrays.sort(fields, new Comparator<Field>() {
-				@Override
-				public int compare(Field field1, Field field2) {
-					return field2.getName().compareTo(field1.getName());
-				}
-			});
-			for (Field field : fields) {
-				if (field.isAnnotationPresent(Column.class)) {
-					declaredColumnFields.add(field);
-				}
-			}
-	
-			Class<?> parentType = type.getSuperclass();
-			if (parentType != null) {
-				declaredColumnFields.addAll(getDeclaredColumnFields(parentType));
-			}
-		}
-		
-		return declaredColumnFields;		
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static boolean isSubclassOf(Class<?> type, Class<?> superClass) {
-		if (type.getSuperclass() != null) {
-			if (type.getSuperclass().equals(superClass)) {
-				return true;
-			}
-
-			return isSubclassOf(type.getSuperclass(), superClass);
-		}
-
-		return false;
-	}
-}
\ No newline at end of file
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
deleted file mode 100644
index cbf41eae..00000000
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ /dev/null
@@ -1,406 +0,0 @@
-package com.activeandroid.util;
-
-/*
- * Copyright (C) 2010 Michael Pardo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.database.Cursor;
-import android.os.Build;
-import android.text.TextUtils;
-
-import com.activeandroid.Cache;
-import com.activeandroid.Model;
-import com.activeandroid.TableInfo;
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Column.ConflictAction;
-import com.activeandroid.serializer.TypeSerializer;
-
-import java.lang.Long;
-import java.lang.String;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.util.Arrays;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-public final class SQLiteUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// ENUMERATIONS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public enum SQLiteType {
-		INTEGER, REAL, TEXT, BLOB
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONTSANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
-		{
-			put(byte.class, SQLiteType.INTEGER);
-			put(short.class, SQLiteType.INTEGER);
-			put(int.class, SQLiteType.INTEGER);
-			put(long.class, SQLiteType.INTEGER);
-			put(float.class, SQLiteType.REAL);
-			put(double.class, SQLiteType.REAL);
-			put(boolean.class, SQLiteType.INTEGER);
-			put(char.class, SQLiteType.TEXT);
-			put(byte[].class, SQLiteType.BLOB);
-			put(Byte.class, SQLiteType.INTEGER);
-			put(Short.class, SQLiteType.INTEGER);
-			put(Integer.class, SQLiteType.INTEGER);
-			put(Long.class, SQLiteType.INTEGER);
-			put(Float.class, SQLiteType.REAL);
-			put(Double.class, SQLiteType.REAL);
-			put(Boolean.class, SQLiteType.INTEGER);
-			put(Character.class, SQLiteType.TEXT);
-			put(String.class, SQLiteType.TEXT);
-			put(Byte[].class, SQLiteType.BLOB);
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static HashMap<String, List<String>> sIndexGroupMap;
-	private static HashMap<String, List<String>> sUniqueGroupMap;
-	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void execSql(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSql(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-
-	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-		List<T> entities = processCursor(type, cursor);
-		cursor.close();
-
-		return entities;
-	}
-	  
-	public static int intQuery(final String sql, final String[] selectionArgs) {
-        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-        final int number = processIntCursor(cursor);
-        cursor.close();
-
-        return number;
-	}
-
-	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		List<T> entities = rawQuery(type, sql, selectionArgs);
-
-		if (entities.size() > 0) {
-			return entities.get(0);
-		}
-
-		return null;
-	}
-
-	// Database creation
-
-	public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sUniqueGroupMap = new HashMap<String, List<String>>();
-		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
-
-		for (Field field : tableInfo.getFields()) {
-			createUniqueColumnDefinition(tableInfo, field);
-		}
-
-		if (sUniqueGroupMap.isEmpty()) {
-			return definitions;
-		}
-
-		Set<String> keySet = sUniqueGroupMap.keySet();
-		for (String key : keySet) {
-			List<String> group = sUniqueGroupMap.get(key);
-			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
-
-			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
-					TextUtils.join(", ", group), conflictAction.toString()));
-		}
-
-		return definitions;
-	}
-
-	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
-
-        if (field.getName().equals("mId")) {
-            return;
-        }
-
-		String[] groups = column.uniqueGroups();
-		ConflictAction[] conflictActions = column.onUniqueConflicts();
-		if (groups.length != conflictActions.length)
-			return;
-
-		for (int i = 0; i < groups.length; i++) {
-			String group = groups[i];
-			ConflictAction conflictAction = conflictActions[i];
-
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sUniqueGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-			list.add(name);
-
-			sUniqueGroupMap.put(group, list);
-			sOnUniqueConflictsMap.put(group, conflictAction);
-		}
-	}
-
-	public static String[] createIndexDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sIndexGroupMap = new HashMap<String, List<String>>();
-
-		for (Field field : tableInfo.getFields()) {
-			createIndexColumnDefinition(tableInfo, field);
-		}
-
-		if (sIndexGroupMap.isEmpty()) {
-			return new String[0];
-		}
-
-		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
-			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
-					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
-					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
-		}
-
-		return definitions.toArray(new String[definitions.size()]);
-	}
-
-	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
-
-        if (field.getName().equals("mId")) {
-            return;
-        }
-
-		if (column.index()) {
-			List<String> list = new ArrayList<String>();
-			list.add(name);
-			sIndexGroupMap.put(name, list);
-		}
-
-		String[] groups = column.indexGroups();
-		for (String group : groups) {
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sIndexGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-
-			list.add(name);
-			sIndexGroupMap.put(group, list);
-		}
-	}
-
-	public static String createTableDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-
-		for (Field field : tableInfo.getFields()) {
-			String definition = createColumnDefinition(tableInfo, field);
-			if (!TextUtils.isEmpty(definition)) {
-				definitions.add(definition);
-			}
-		}
-
-		definitions.addAll(createUniqueDefinition(tableInfo));
-
-		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
-				TextUtils.join(", ", definitions));
-	}
-
-	@SuppressWarnings("unchecked")
-	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
-		StringBuilder definition = new StringBuilder();
-
-		Class<?> type = field.getType();
-		final String name = tableInfo.getColumnName(field);
-		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-		final Column column = field.getAnnotation(Column.class);
-
-		if (typeSerializer != null) {
-			type = typeSerializer.getSerializedType();
-		}
-
-		if (TYPE_MAP.containsKey(type)) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(TYPE_MAP.get(type).toString());
-		}
-		else if (ReflectionUtils.isModel(type)) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(SQLiteType.INTEGER.toString());
-		}
-		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(SQLiteType.TEXT.toString());
-		}
-
-		if (!TextUtils.isEmpty(definition)) {
-
-			if (name.equals(tableInfo.getIdName())) {
-				definition.append(" PRIMARY KEY AUTOINCREMENT");
-			}else if(column!=null){
-				if (column.length() > -1) {
-					definition.append("(");
-					definition.append(column.length());
-					definition.append(")");
-				}
-
-				if (column.notNull()) {
-					definition.append(" NOT NULL ON CONFLICT ");
-					definition.append(column.onNullConflict().toString());
-				}
-
-				if (column.unique()) {
-					definition.append(" UNIQUE ON CONFLICT ");
-					definition.append(column.onUniqueConflict().toString());
-				}
-			}
-
-			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
-				definition.append(" REFERENCES ");
-				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
-				definition.append("("+tableInfo.getIdName()+")");
-				definition.append(" ON DELETE ");
-				definition.append(column.onDelete().toString().replace("_", " "));
-				definition.append(" ON UPDATE ");
-				definition.append(column.onUpdate().toString().replace("_", " "));
-			}
-		}
-		else {
-			Log.e("No type mapping for: " + type.toString());
-		}
-
-		return definition.toString();
-	}
-
-	@SuppressWarnings("unchecked")
-	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		String idName = tableInfo.getIdName();
-		final List<T> entities = new ArrayList<T>();
-
-		try {
-			Constructor<?> entityConstructor = type.getConstructor();
-
-			if (cursor.moveToFirst()) {
-                /**
-                 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-                 * when the cursor have multiple columns with same name obtained from join tables.
-                 */
-                List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-				do {
-					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
-					if (entity == null) {
-						entity = (T) entityConstructor.newInstance();
-					}
-
-					entity.loadFromCursor(cursor);
-					entities.add((T) entity);
-				}
-				while (cursor.moveToNext());
-			}
-
-		}
-		catch (NoSuchMethodException e) {
-			throw new RuntimeException(
-                "Your model " + type.getName() + " does not define a default " +
-                "constructor. The default constructor is required for " +
-                "now in ActiveAndroid models, as the process to " +
-                "populate the ORM model is : " +
-                "1. instantiate default model " +
-                "2. populate fields"
-            );
-		}
-		catch (Exception e) {
-			Log.e("Failed to process cursor.", e);
-		}
-
-		return entities;
-	}
-
-	private static int processIntCursor(final Cursor cursor) {
-        if (cursor.moveToFirst()) {
-            return cursor.getInt(0);
-	    }
-        return 0;
-    }
-
-	public static List<String> lexSqlScript(String sqlScript) {
-		ArrayList<String> sl = new ArrayList<String>();
-		boolean inString = false, quoteNext = false;
-		StringBuilder b = new StringBuilder(100);
-
-		for (int i = 0; i < sqlScript.length(); i++) {
-			char c = sqlScript.charAt(i);
-
-			if (c == ';' && !inString && !quoteNext) {
-				sl.add(b.toString());
-				b = new StringBuilder(100);
-				inString = false;
-				quoteNext = false;
-				continue;
-			}
-
-			if (c == '\'' && !quoteNext) {
-				inString = !inString;
-			}
-
-			quoteNext = c == '\\' && !quoteNext;
-
-			b.append(c);
-		}
-
-		if (b.length() > 0) {
-			sl.add(b.toString());
-		}
-
-		return sl;
-	}
-}
diff --git a/src/com/activeandroid/widget/ModelAdapter.java b/src/com/activeandroid/widget/ModelAdapter.java
deleted file mode 100644
index a3895763..00000000
--- a/src/com/activeandroid/widget/ModelAdapter.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.activeandroid.widget;
-
-import java.util.Collection;
-import java.util.List;
-
-import android.content.Context;
-import android.widget.ArrayAdapter;
-
-import com.activeandroid.Model;
-
-public class ModelAdapter<T extends Model> extends ArrayAdapter<T> {
-	public ModelAdapter(Context context, int textViewResourceId) {
-		super(context, textViewResourceId);
-	}
-
-	public ModelAdapter(Context context, int resource, int textViewResourceId) {
-		super(context, resource, textViewResourceId);
-	}
-
-	public ModelAdapter(Context context, int textViewResourceId, List<T> objects) {
-		super(context, textViewResourceId, objects);
-	}
-
-	public ModelAdapter(Context context, int resource, int textViewResourceId, List<T> objects) {
-		super(context, resource, textViewResourceId, objects);
-	}
-
-	/**
-	 * Clears the adapter and, if data != null, fills if with new Items.
-	 *
-	 * @param collection A Collection&lt;? extends T&gt; which members get added to the adapter.
-	 */
-	public void setData(Collection<? extends T> collection) {
-		clear();
-
-		if (collection != null) {
-			for (T item : collection) {
-				add(item);
-			}
-		}
-	}
-
-	/**
-	 * @return The Id of the record at position.
-	 */
-	@Override
-	public long getItemId(int position) {
-		T item = getItem(position);
-
-		if (item != null) {
-			return item.getId();
-		}
-		else {
-			return -1;
-		}
-	}
-}
diff --git a/wait_for_emulator b/wait_for_emulator
deleted file mode 100644
index b30bc35c..00000000
--- a/wait_for_emulator
+++ /dev/null
@@ -1,18 +0,0 @@
-#!/bin/bash
-
-bootanim=""
-failcounter=0
-until [[ "$bootanim" =~ "stopped" ]]; do
-  bootanim=`adb -e shell getprop init.svc.bootanim 2>&1`
-  echo "$bootanim"
-  if [[ "$bootanim" =~ "not found" ]]; then
-    let "failcounter += 1"
-    if [[ $failcounter -gt 3 ]]; then
-      echo "Failed to start emulator"
-      exit 1
-    fi
-  fi
-  sleep 1
-done
-
-echo "Done"
