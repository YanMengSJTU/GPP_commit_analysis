diff --git a/AndroidManifest.xml b/AndroidManifest.xml
new file mode 100644
index 00000000..df574d81
--- /dev/null
+++ b/AndroidManifest.xml
@@ -0,0 +1,32 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="ru.maxdestroyer.utils"
+          android:versionCode="1"
+          android:versionName="1.0"
+          android:installLocation="preferExternal">
+
+    <uses-sdk
+            android:minSdkVersion="14"
+            android:targetSdkVersion="21"/>
+
+    <uses-permission android:name="android.permission.CALL_PHONE"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.WRITE_SETTINGS"/>
+
+    <application
+            android:allowBackup="true"
+            android:hardwareAccelerated="true"
+            android:icon="@android:drawable/ic_btn_speak_now"
+            android:label="utils"
+            android:theme="@android:style/Theme">
+    </application>
+
+    <!--android:launchMode="singleTop"-->
+    <!--android:configChanges="keyboard|keyboardHidden|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|locale"-->
+    <!--android:windowSoftInputMode="stateAlwaysHidden|adjustPan"-->
+
+</manifest>
diff --git a/build.gradle b/build.gradle
index 8e456963..5657e6b6 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,26 +1,47 @@
-apply plugin: 'java'
-apply from: 'gradle-mvn-push.gradle'
+buildscript {
+    repositories {
+        mavenCentral()
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:2.1.0'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
+        //classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
+    }
+}
 
-targetCompatibility = '1.6'
-sourceCompatibility = '1.6'
+apply plugin: 'com.android.library'
+//apply plugin: 'com.neenbedankt.android-apt'
 
-sourceSets {
-    main {
-        java {
-            srcDir 'src'
-        }
-    }
+repositories {
+    mavenCentral()
+    jcenter()
 }
+group = 'com.github.maxx'
 
 dependencies {
-    compile fileTree(dir: 'libs', include: '*.jar')
+    compile fileTree(include: '*.jar', dir: 'libs')
+//    compile 'com.android.support:support-v4:23.3.0'
+//    compile 'com.android.support:appcompat-v7:23.3.0'
+//    compile 'com.jakewharton:butterknife:7.0.1'
 }
 
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
 
-if (JavaVersion.current().isJava8Compatible()) {
-    allprojects {
-        tasks.withType(Javadoc) {
-            options.addStringOption('Xdoclint:none', '-quiet')
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src']
+            resources.srcDirs = ['src']
+            aidl.srcDirs = ['src']
+            renderscript.srcDirs = ['src']
+            res.srcDirs = ['res']
+            assets.srcDirs = ['assets']
         }
+
+        instrumentTest.setRoot('tests')
     }
+    useLibrary 'org.apache.http.legacy'
 }
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 6530fad5..a1d9e925 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip
+distributionUrl=http\://services.gradle.org/distributions/gradle-2.12-all.zip
diff --git a/src/com/activeandroid/ExtendedModel.java b/src/com/activeandroid/ExtendedModel.java
new file mode 100644
index 00000000..d7944561
--- /dev/null
+++ b/src/com/activeandroid/ExtendedModel.java
@@ -0,0 +1,130 @@
+package com.activeandroid;
+
+import android.content.ContentValues;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.activeandroid.content.ContentProvider;
+import com.activeandroid.filler.Filler;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+
+public abstract class ExtendedModel extends Model implements Parcelable {
+    //@JsonIgnore
+    public TableInfo mTableInfo;
+    //@JsonIgnore
+    public String idName;
+    public static HashMap<Class, ArrayList<Filler>> fastSaveCache = new HashMap<>();
+    public static Constructor<ContentValues> contentValuesConstructor;
+
+    public ExtendedModel() {
+        super();
+        mTableInfo = Cache.getTableInfo(getClass());
+        idName = mTableInfo.getIdName();
+    }
+
+
+    public ExtendedModel(Long id) {
+        this();
+        setAaId(id);
+    }
+
+    private static Field idField;
+
+    public void setAaId(Long id) {
+        try {
+            if (idField == null) {
+                idField = Model.class.getDeclaredField("mId");
+                idField.setAccessible(true);
+            }
+            idField.set(this, id);
+        } catch (Exception e) {
+            throw new RuntimeException("Reflection failed to get the Active Android ID", e);
+        }
+    }
+
+
+    protected Long fastSave() {
+        // return super.save();
+        HashMap<String, Object> mapValues = new HashMap<>();
+        Class<? extends ExtendedModel> clazz = this.getClass();
+
+        ArrayList<Filler> list = fastSaveCache.get(clazz);
+        if (list == null) {
+            //Log.d("FAST SAVE", "CREATE NEW FILLERS FOR CLASS " + clazz.getName());
+            Collection<Field> fields = mTableInfo.getFields();
+            list = new ArrayList<>(fields.size());
+            for (Field field : fields) {
+                list.add(Filler.getInstance(field, mTableInfo));
+            }
+            fastSaveCache.put(clazz, list);
+        }
+
+        for (int i = 0; i < list.size(); i++) {
+            list.get(i).fill(mapValues, this);
+        }
+
+        try {
+            if (contentValuesConstructor == null) {
+                contentValuesConstructor = ContentValues.class.getDeclaredConstructor(HashMap.class);
+                contentValuesConstructor.setAccessible(true);
+            }
+            ContentValues values = contentValuesConstructor.newInstance(mapValues);
+            SQLiteDatabase db = Cache.openDatabase();
+            if (getId() == null) {
+                setAaId(db.insert(mTableInfo.getTableName(), null, values));
+            } else {
+                db.update(mTableInfo.getTableName(), values, idName + "=" + getId(), null);
+            }
+            Cache.getContext().getContentResolver()
+                    .notifyChange(ContentProvider.createUri(mTableInfo.getType(), getId()), null);
+        } catch (NoSuchMethodException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        } catch (InstantiationException e) {
+            e.printStackTrace();
+        } catch (InvocationTargetException e) {
+            e.printStackTrace();
+        }
+        return getId();
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        Long id = getId();
+        dest.writeLong(id != null ? id : -1L);
+    }
+
+    protected ExtendedModel(Parcel in) {
+        this();
+        Long id = in.readLong();
+        if (!id.equals(-1L)) {
+            setAaId(id);
+        }
+    }
+
+    /**
+     * извне всегда должен использоваться save() . Для кастомном имплементации у наследников - меняем fastSave
+     *
+     * @return
+     */
+    @Override
+    public Long save() {
+        return fastSave();
+    }
+
+    public void afterLoad() {
+
+    }
+}
\ No newline at end of file
diff --git a/src/com/activeandroid/Many.java b/src/com/activeandroid/Many.java
new file mode 100644
index 00000000..90615082
--- /dev/null
+++ b/src/com/activeandroid/Many.java
@@ -0,0 +1,438 @@
+package com.activeandroid;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.query.Select;
+import com.activeandroid.util.Convert;
+
+import java.lang.reflect.*;
+import java.util.*;
+
+@Table(name = "many", id = "_id")
+public final class Many<T extends ExtendedModel> extends ExtendedModel implements List<T> {
+
+    private Class<T> clazz;
+    private List<T> data = new ArrayList<>();
+
+    // список НЕ корректно сохраняется\загружается в базе, логика связи подразумевает отношение один ко многим
+    //List<Long> ids = new ArrayList<>();
+    @Column(name = "items")
+    String ids = ""; // "1, 2, 3..."
+    @Column(name = "type")
+    String type = "";
+    @Column(name = "class_name")
+    String class_name = "";
+
+    public Many() {
+        super();
+
+        Type type = getClass().getGenericSuperclass();
+        if (type instanceof ParameterizedType) {
+            Type[] types = ((ParameterizedType) type).getActualTypeArguments();
+            if (types != null && types.length > 0) {
+                type = types[0];
+                if (type instanceof Class) {
+                    initWith((Class<T>) type);
+                }
+            }
+        }
+        initClass();
+        reload();
+    }
+
+    public Many(Class<T> clazz) {
+        super();
+        initWith(clazz);
+        reload();
+    }
+
+    protected Many(Parcel in) {
+        super(in);
+        this.ids = in.readString();
+        this.type = in.readString();
+        this.class_name = in.readString();
+        initClass();
+        this.data = new ArrayList<>();
+        // fill data
+        reload();
+    }
+
+    private void initClass() {
+        if (clazz == null && class_name != null) {
+            try {
+                clazz = (Class<T>) Class.forName(class_name);
+            } catch (ClassNotFoundException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public Many(Many many) {
+        super(many.getId());
+        this.ids = many.ids;
+        this.type = many.type;
+        this.clazz = many.clazz;
+        this.class_name = many.class_name;
+        // fill data
+        reload();
+    }
+
+    public void initWith(Class<T> clazz) {
+        this.clazz = clazz;
+        this.class_name = clazz.getName();
+        Table tableAnnotation = clazz.getAnnotation(Table.class);
+        if (tableAnnotation != null && tableAnnotation.name() != null) {
+            this.type = tableAnnotation.name();
+        } else {
+            this.type = clazz.getSimpleName();
+        }
+        data = new ArrayList<>();
+    }
+
+    /**
+     * also update ids here!
+     */
+    @Override
+    public Long save() {
+        ids = "";
+        ArrayList<String> temp = new ArrayList<>();
+        if (data != null) {
+            for (int i = 0; i < data.size(); i++) {
+                T item = data.get(i);
+                item.fastSave();
+                temp.add(Long.toString(item.getId()));
+            }
+        }
+        ids = Convert.listToString(temp);
+
+        // should be impossible
+        if (class_name == null && clazz != null) {
+            class_name = clazz.getName();
+        }
+        return super.save();
+    }
+
+    /**
+     * актуализация данных в data согласно ids
+     */
+    public synchronized void reload() {
+        if (data == null || data.isEmpty()) {
+            if (clazz != null) {
+                if (ids.isEmpty()) {
+                    ArrayList<String> idsList = Convert.strToList(ids, ", ");
+                    String where = "";
+                    for (String arg : idsList) {
+                        where += where.isEmpty() ? "_id = ?" : " OR _id = ?";
+                    }
+                    data = new Select().from(clazz).where(where, Convert.listToArr(idsList)).execute();
+                }
+            } else {
+                Log.e("Many", "reload() called with clazz == null");
+            }
+            if (data == null) {
+                data = new ArrayList<>();
+            }
+        }
+    }
+
+    public synchronized void setList(List<T> list) {
+        this.data = list;
+        fastSave();
+    }
+
+    @Override
+    public void add(int location, T object) {
+        if (object.getId() == null) {
+            Log.e("Many", "add() in Many called for nonsaved object! " + object.toString());
+            object.save();
+        }
+        data.add(location, object);
+        fastSave();
+    }
+
+    @Override
+    public boolean add(T object) {
+//        if (this.clazz == null) {
+//            this.clazz = (Class<T>) object.getClass();
+//            this.class_name = clazz.getName();
+//            Table tableAnnotation = clazz.getAnnotation(Table.class);
+//            if (tableAnnotation != null && tableAnnotation.name() != null) {
+//                this.type = tableAnnotation.name();
+//            } else {
+//                this.type = clazz.getSimpleName();
+//            }
+//        }
+        if (object.getId() == null) {
+            Log.e("Many", "add() in Many called for nonsaved object! " + object.toString());
+            object.save();
+        }
+        boolean res = data.add(object);
+        fastSave();
+        return res;
+    }
+
+    @Override
+    public boolean addAll(int location, Collection<? extends T> collection) {
+        boolean res = data.addAll(location, collection);
+        fastSave();
+        return res;
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends T> collection) {
+        boolean res = data.addAll(collection);
+        fastSave();
+        return res;
+    }
+
+    @Override
+    public void clear() {
+        data.clear();
+        fastSave();
+    }
+
+    @Override
+    public boolean contains(Object object) {
+        return data.contains(object);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> collection) {
+        return data.containsAll(collection);
+    }
+
+    @Override
+    public T get(int location) {
+        return data.get(location);
+    }
+
+    @Override
+    public int indexOf(Object object) {
+        return data.indexOf(object);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return data.isEmpty();
+    }
+
+    //@NonNull
+    @Override
+    public Iterator<T> iterator() {
+        return data.iterator();
+    }
+
+    @Override
+    public int lastIndexOf(Object object) {
+        return data.lastIndexOf(object);
+    }
+
+    @Override
+    public ListIterator<T> listIterator() {
+        return data.listIterator();
+    }
+
+    //@NonNull
+    @Override
+    public ListIterator<T> listIterator(int location) {
+        return data.listIterator(location);
+    }
+
+    /**
+     * @return the element previously at the specified position
+     */
+    @Override
+    public T remove(int location) {
+        data.remove(location);
+
+        ArrayList<String> idsList = Convert.strToList(ids, ", ");
+        idsList.remove(location);
+        ids = Convert.listToString(idsList);
+
+        reload();
+        if (data.size() > location) {
+            return data.get(location);
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public boolean remove(Object object) {
+        if (object instanceof ExtendedModel) {
+            if (((ExtendedModel) object).getId() != null) {
+                ArrayList<String> idsList = Convert.strToList(ids, ", ");
+                long id = ((ExtendedModel) object).getId();
+                idsList.remove(idsList.indexOf(id));
+                ids = Convert.listToString(idsList);
+            }
+        }
+
+        boolean res = data.remove(object);
+        fastSave();
+        return res;
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> collection) {
+        boolean res = data.removeAll(collection);
+        fastSave();
+        return res;
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> collection) {
+        return data.retainAll(collection);
+    }
+
+    @Override
+    public T set(int location, T object) {
+        T res = data.set(location, object);
+        fastSave();
+        return res;
+    }
+
+    @Override
+    public int size() {
+        return data.size();
+    }
+
+    //@NonNull
+    @Override
+    public List<T> subList(int start, int end) {
+        return data.subList(start, end);
+    }
+
+    //@NonNull
+    @Override
+    public Object[] toArray() {
+        return data.toArray();
+    }
+
+    //@NonNull
+    @Override
+    public <T1> T1[] toArray(T1[] array) {
+        return data.toArray(array);
+    }
+
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        super.writeToParcel(dest, flags);
+        dest.writeString(this.ids);
+        dest.writeString(this.type);
+        dest.writeString(this.class_name);
+    }
+
+    public static final Parcelable.Creator<Many> CREATOR = new Parcelable.Creator<Many>() {
+        @Override
+        public Many createFromParcel(Parcel source) {
+            return new Many(source);
+        }
+
+        @Override
+        public Many[] newArray(int size) {
+            return new Many[size];
+        }
+    };
+
+
+    public final Parcelable.Creator<T> SUB_CREATOR = new Parcelable.Creator<T>() {
+        public Constructor<T> constructor;
+
+        {
+        }
+
+        @Override
+        public T createFromParcel(Parcel source) {
+            try {
+                return constructor().newInstance(source);
+            } catch (InstantiationException e) {
+                e.printStackTrace();
+            } catch (IllegalAccessException e) {
+                e.printStackTrace();
+            } catch (InvocationTargetException e) {
+                e.printStackTrace();
+            } catch (NullPointerException e) {
+                e.printStackTrace();
+            }
+            return null;
+        }
+
+        private Constructor<T> constructor() {
+            if (constructor == null) {
+                try {
+                    initClass();
+                    constructor = clazz.getConstructor(Parcel.class);
+                } catch (NoSuchMethodException e) {
+                    e.printStackTrace();
+                }
+            }
+            return constructor;
+        }
+
+        @Override
+        public T[] newArray(int size) {
+            initClass();
+            return (T[]) Array.newInstance(clazz, size);
+        }
+    };
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof Many)) {
+            return false;
+        }
+        if (!super.equals(o)) {
+            return false;
+        }
+
+        Many<?> many = (Many<?>) o;
+
+        return data != null ? data.equals(many.data) : many.data == null;
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = 31 * result + (data != null ? data.hashCode() : 0);
+        return result;
+    }
+
+    public List<T> getData() {
+        return data;
+    }
+
+    public void setData(final List<T> data) {
+        this.data = data;
+        fastSave();
+    }
+
+    public Class<T> getClazz() {
+        return clazz;
+    }
+
+    public void setClazz(final Class<T> clazz) {
+        this.clazz = clazz;
+    }
+
+    public String getClass_name() {
+        return class_name;
+    }
+
+    public void setClass_name(final String class_name) {
+        this.class_name = class_name;
+    }
+}
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index c3470697..10387779 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -19,7 +19,6 @@
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
-
 import com.activeandroid.content.ContentProvider;
 import com.activeandroid.query.Delete;
 import com.activeandroid.query.Select;
@@ -28,11 +27,7 @@
 import com.activeandroid.util.ReflectionUtils;
 
 import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 
 @SuppressWarnings("unchecked")
 public abstract class Model {
@@ -76,7 +71,7 @@ public final void delete() {
 				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
 	}
 
-	public final Long save() {
+	public Long save() {
 		final SQLiteDatabase db = Cache.openDatabase();
 		final ContentValues values = new ContentValues();
 
diff --git a/src/com/activeandroid/filler/EnumFiller.java b/src/com/activeandroid/filler/EnumFiller.java
new file mode 100644
index 00000000..c7412318
--- /dev/null
+++ b/src/com/activeandroid/filler/EnumFiller.java
@@ -0,0 +1,21 @@
+package com.activeandroid.filler;
+
+import com.activeandroid.ExtendedModel;
+import com.activeandroid.serializer.TypeSerializer;
+
+import java.lang.reflect.Field;
+import java.util.HashMap;
+
+/**
+ * Created by paul on 12/16/15.
+ */
+public class EnumFiller extends Filler<Enum> {
+    public EnumFiller(String fieldName, Field field, TypeSerializer typeSerializer) {
+        super(fieldName, field, typeSerializer);
+    }
+
+    @Override
+    public void fill(HashMap<String, Object> map, ExtendedModel extendedModel) {
+        map.put(fieldName, ((Enum) getValue(extendedModel)).name());
+    }
+}
diff --git a/src/com/activeandroid/filler/Filler.java b/src/com/activeandroid/filler/Filler.java
new file mode 100644
index 00000000..ce6eb225
--- /dev/null
+++ b/src/com/activeandroid/filler/Filler.java
@@ -0,0 +1,86 @@
+package com.activeandroid.filler;
+
+import com.activeandroid.Cache;
+import com.activeandroid.ExtendedModel;
+import com.activeandroid.TableInfo;
+import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.util.ReflectionUtils;
+
+import java.lang.reflect.Field;
+import java.util.HashMap;
+
+public class Filler<T> {
+    final String fieldName;
+    final Field field;
+    final TypeSerializer typeSerializer;
+
+    public Filler(String fieldName, Field field, TypeSerializer typeSerializer) {
+        this.field = field;
+        this.fieldName = fieldName;
+        this.typeSerializer = typeSerializer;
+    }
+
+    public void fill(HashMap<String, Object> map, ExtendedModel extendedModel) {
+        map.put(fieldName, getValue(extendedModel));
+    }
+
+    public Object getValue(ExtendedModel extendedModel) {
+        Object value = null;
+        try {
+            value = field.get(extendedModel);
+        } catch (IllegalAccessException e) {
+            field.setAccessible(true);
+            try {
+                value = field.get(extendedModel);
+            } catch (IllegalAccessException e1) {
+                e1.printStackTrace();
+            }
+        }
+
+        if (value != null) {
+            if (typeSerializer != null) {
+                value = typeSerializer.serialize(value);
+            }
+        }
+        return value;
+    }
+
+    public static Filler getInstance(Field field, TableInfo tableInfo) {
+        String fieldName = tableInfo.getColumnName(field);
+
+        Class<?> fieldType = field.getType();
+
+        TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+        if (typeSerializer != null) {
+            fieldType = typeSerializer.getSerializedType();
+        }
+
+        if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+            return new Filler<Byte>(fieldName, field, typeSerializer);
+        } else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+            return new Filler<Short>(fieldName, field, typeSerializer);
+        } else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+            return new Filler<Integer>(fieldName, field, typeSerializer);
+        } else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+            return new Filler<Long>(fieldName, field, typeSerializer);
+        } else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+            return new Filler<Float>(fieldName, field, typeSerializer);
+        } else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+            return new Filler<Double>(fieldName, field, typeSerializer);
+        } else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+            return new Filler<Boolean>(fieldName, field, typeSerializer);
+        } else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+            return new Filler<Character>(fieldName, field, typeSerializer);
+        } else if (fieldType.equals(String.class)) {
+            return new Filler<String>(fieldName, field, typeSerializer);
+        } else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+            return new Filler<Byte[]>(fieldName, field, typeSerializer);
+        } else if (ReflectionUtils.isModel(fieldType)) {
+            return new ModelFiller(fieldName, field, typeSerializer);
+        } else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+            return new EnumFiller(fieldName, field, typeSerializer);
+        } else {
+            return new IgnoreFiller(fieldName, field, typeSerializer);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/com/activeandroid/filler/IgnoreFiller.java b/src/com/activeandroid/filler/IgnoreFiller.java
new file mode 100644
index 00000000..d1dba99f
--- /dev/null
+++ b/src/com/activeandroid/filler/IgnoreFiller.java
@@ -0,0 +1,21 @@
+package com.activeandroid.filler;
+
+import com.activeandroid.ExtendedModel;
+import com.activeandroid.serializer.TypeSerializer;
+
+import java.lang.reflect.Field;
+import java.util.HashMap;
+
+/**
+ * Created by paul on 12/16/15.
+ */
+public class IgnoreFiller extends Filler {
+    public IgnoreFiller(String fieldName, Field field, TypeSerializer typeSerializer) {
+        super(fieldName, field, typeSerializer);
+    }
+
+    @Override
+    public void fill(HashMap map, ExtendedModel extendedModel) {
+
+    }
+}
diff --git a/src/com/activeandroid/filler/ModelFiller.java b/src/com/activeandroid/filler/ModelFiller.java
new file mode 100644
index 00000000..108ee7a9
--- /dev/null
+++ b/src/com/activeandroid/filler/ModelFiller.java
@@ -0,0 +1,25 @@
+package com.activeandroid.filler;
+
+import com.activeandroid.ExtendedModel;
+import com.activeandroid.serializer.TypeSerializer;
+
+import java.lang.reflect.Field;
+import java.util.HashMap;
+
+/**
+ * Created by paul on 12/16/15.
+ */
+public class ModelFiller extends Filler<ExtendedModel> {
+    public ModelFiller(String fieldName, Field field, TypeSerializer typeSerializer) {
+        super(fieldName, field, typeSerializer);
+    }
+
+    @Override
+    public void fill(HashMap<String, Object> map, ExtendedModel extendedModel) {
+        ExtendedModel model = (ExtendedModel) getValue(extendedModel);
+        if (model != null) {
+            model.fastSave();
+            map.put(fieldName, model.getId());
+        }
+    }
+}
diff --git a/src/com/activeandroid/util/Convert.java b/src/com/activeandroid/util/Convert.java
new file mode 100644
index 00000000..7ce2aeea
--- /dev/null
+++ b/src/com/activeandroid/util/Convert.java
@@ -0,0 +1,56 @@
+package com.activeandroid.util;
+
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Created by Maxim Smirnov on 24.05.16.
+ */
+public class Convert {
+
+    /**
+     * @param arr - list like "1, 2, 3"
+     * @return - string "1, 2, 3"
+     */
+    public static String listToString(List<?> arr) {
+        if (!arr.isEmpty()) {
+            StringBuilder nameBuilder = new StringBuilder();
+
+            for (Object n : arr) {
+                nameBuilder.append(n.toString()).append(", ");
+            }
+
+            nameBuilder.deleteCharAt(nameBuilder.length() - 1);
+            nameBuilder.deleteCharAt(nameBuilder.length() - 1);
+
+            return nameBuilder.toString();
+        } else {
+            return "";
+        }
+    }
+
+    /**
+     * @param str - like "1, 2, 3"
+     * @param sep - ", " by default
+     * @return - list of "1" "2" "3"
+     */
+    public static ArrayList<String> strToList(String str, String sep) {
+        String[] arr = str.split(sep);
+        return arrToList(arr);
+    }
+
+    public static <T> ArrayList<T> arrToList(T[] arr) {
+        return new ArrayList<T>(Arrays.asList(arr));
+    }
+
+    public static <T> T[] listToArr(List<T> arr) {
+        final T t = arr.get(0);
+        final T[] res = (T[]) Array.newInstance(t.getClass(), arr.size());
+        for (int i = 0; i < arr.size(); i++) {
+            res[i] = arr.get(i);
+        }
+        return res;
+    }
+}
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index 8b5e3802..df7284f9 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -19,8 +19,8 @@
 import android.database.Cursor;
 import android.os.Build;
 import android.text.TextUtils;
-
 import com.activeandroid.Cache;
+import com.activeandroid.ExtendedModel;
 import com.activeandroid.Model;
 import com.activeandroid.TableInfo;
 import com.activeandroid.annotation.Column;
@@ -29,13 +29,7 @@
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;
 
 public final class SQLiteUtils {
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -106,6 +100,11 @@ public static void execSql(String sql, Object[] bindArgs) {
 		List<T> entities = processCursor(type, cursor);
 		cursor.close();
 
+		for (T entity : entities) {
+			if (entity instanceof ExtendedModel) {
+				((ExtendedModel) entity).afterLoad();
+			}
+		}
 		return entities;
 	}
 	  
@@ -121,6 +120,9 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
 		List<T> entities = rawQuery(type, sql, selectionArgs);
 
 		if (entities.size() > 0) {
+			if (entities.get(0) instanceof ExtendedModel) {
+				((ExtendedModel) entities.get(0)).afterLoad();
+			}
 			return entities.get(0);
 		}
 
