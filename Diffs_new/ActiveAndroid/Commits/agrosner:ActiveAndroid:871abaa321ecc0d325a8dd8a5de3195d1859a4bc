diff --git a/src/main/java/com/activeandroid/IModelInfo.java b/src/main/java/com/activeandroid/IModelInfo.java
new file mode 100644
index 00000000..4f8c082f
--- /dev/null
+++ b/src/main/java/com/activeandroid/IModelInfo.java
@@ -0,0 +1,22 @@
+package com.activeandroid;
+
+/**
+ * Created by andrewgrosner
+ * Date: 4/3/14
+ * Contributors:
+ * Description:
+ */
+public interface IModelInfo {
+
+    public String getId();
+
+    public void setRowId(String rowId);
+
+    public String getRowId();
+
+    public boolean exists();
+
+    public void save();
+
+    public void delete();
+}
diff --git a/src/main/java/com/activeandroid/Model.java b/src/main/java/com/activeandroid/Model.java
index 2f6663e9..b4d2fde5 100644
--- a/src/main/java/com/activeandroid/Model.java
+++ b/src/main/java/com/activeandroid/Model.java
@@ -16,25 +16,14 @@
  * limitations under the License.
  */
 
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-
-import com.activeandroid.annotation.ForeignKey;
-import com.activeandroid.annotation.PrimaryKey;
 import com.activeandroid.content.ContentProvider;
-import com.activeandroid.query.Delete;
 import com.activeandroid.query.Select;
-import com.activeandroid.serializer.TypeSerializer;
-import com.activeandroid.util.AALog;
-import com.activeandroid.util.ReflectionUtils;
 import com.activeandroid.util.SQLiteUtils;
 
-import java.lang.reflect.Field;
 import java.util.List;
 
 @SuppressWarnings("unchecked")
-public abstract class Model {
+public abstract class Model implements IModelInfo{
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -60,251 +49,27 @@ public Model() {
      * Also each object thats instance of {@link java.lang.Number} must be DataBaseUtils.sqlEscapeString(object.toString)
      * @return
      */
+    @Override
 	public abstract String getId();
 
+    @Override
 	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), SQLiteUtils.getWhereStatement(this, mTableInfo), null);
-		Cache.removeEntity(this);
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), getId()), null);
+        SQLiteUtils.delete(this);
 	}
 
+    @Override
 	public final void save() {
-		final SQLiteDatabase db = Cache.openDatabase();
-		final ContentValues values = new ContentValues();
-
-		for (Field field : mTableInfo.getFields()) {
-			String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-
-			field.setAccessible(true);
-
-			try {
-				Object value = field.get(this);
-
-				if (value != null) {
-					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-					if (typeSerializer != null) {
-						// serialize data
-						value = typeSerializer.serialize(value);
-						// set new object type
-						if (value != null) {
-							fieldType = value.getClass();
-							// check that the serializer returned what it promised
-							if (!fieldType.equals(typeSerializer.getSerializedType())) {
-								AALog.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-                                        typeSerializer.getSerializedType(), fieldType));
-							}
-						}
-					}
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (value == null) {
-					values.putNull(fieldName);
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					values.put(fieldName, (Byte) value);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					values.put(fieldName, (Short) value);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					values.put(fieldName, (Integer) value);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					values.put(fieldName, (Long) value);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					values.put(fieldName, (Float) value);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					values.put(fieldName, (Double) value);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					values.put(fieldName, (Boolean) value);
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(String.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					values.put(fieldName, (byte[]) value);
-				}
-				else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
-                    ForeignKey key = field.getAnnotation(ForeignKey.class);
-                    if(!key.name().equals("")){
-                        fieldName = field.getAnnotation(ForeignKey.class).name();
-                    }
-					values.put(fieldName, ((Model) value).getId());
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					values.put(fieldName, ((Enum<?>) value).name());
-				}
-			}
-			catch (IllegalArgumentException e) {
-				AALog.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				AALog.e(e.getClass().getName(), e);
-			}
-		}
-
-        if(!exists()){
-		     mId = db.insert(mTableInfo.getTableName(), null, values);
-
-            for(Field field : mTableInfo.getPrimaryKeys()){
-                if(field.isAnnotationPresent(PrimaryKey.class) &&
-                        field.getAnnotation(PrimaryKey.class).type().equals(PrimaryKey.Type.AUTO_INCREMENT)){
-                    field.setAccessible(true);
-                    try {
-                        field.set(this, mId);
-                    } catch (Throwable e) {
-                        throw new RuntimeException(e);
-                    }
-                }
-            }
-        } else {
-			mId = db.update(mTableInfo.getTableName(), values, SQLiteUtils.getWhereStatement(this, mTableInfo), null);
-		}
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), getId()), null);
+        SQLiteUtils.save(this);
 	}
 
+    @Override
     public boolean exists(){
-        Model model = new Select().from(getClass()).where(SQLiteUtils.getWhereStatement(this, mTableInfo)).executeSingle();
-        return model!=null;
+        return SQLiteUtils.exists(this);
     }
 
-    public void update(){
+   /* public void update(){
 
-    }
-
-    /**
-     * Checks to see if object exists, if so, deletes it then updates itself
-     */
-    public <OBJECT_CLASS extends Model> void saveById(){
-        if(exists()){
-            delete();
-        }
-        save();
-    }
-
-	// Convenience methods
-
-	public static void delete(Class<? extends Model> type, long id) {
-		new Delete().from(type).where("Id=?", id).execute();
-	}
-
-	public static <T extends Model> T load(Class<T> type, long id) {
-		return new Select().from(type).where("Id=?", id).executeSingle();
-	}
-
-	// Model population
-
-	public final void loadFromCursor(Cursor cursor) {
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-			final int columnIndex = cursor.getColumnIndex(fieldName);
-
-			if (columnIndex < 0) {
-				continue;
-			}
-
-			field.setAccessible(true);
-
-			try {
-				boolean columnIsNull = cursor.isNull(columnIndex);
-				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-				Object value = null;
-
-				if (typeSerializer != null) {
-					fieldType = typeSerializer.getSerializedType();
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (columnIsNull) {
-					field = null;
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					value = cursor.getLong(columnIndex);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					value = cursor.getFloat(columnIndex);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					value = cursor.getDouble(columnIndex);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					value = cursor.getInt(columnIndex) != 0;
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					value = cursor.getString(columnIndex).charAt(0);
-				}
-				else if (fieldType.equals(String.class)) {
-					value = cursor.getString(columnIndex);
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					value = cursor.getBlob(columnIndex);
-				}
-				else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
-					final String entityId = cursor.getString(columnIndex);
-					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
-
-					Model entity = Cache.getEntity(entityType, entityId);
-					if (entity == null) {
-						entity = new Select().from(entityType).where(SQLiteUtils.getWhereFromEntityId(entityType, entityId)).executeSingle();
-					}
-
-					value = entity;
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					@SuppressWarnings("rawtypes")
-					final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-					value = Enum.valueOf(enumType, cursor.getString(columnIndex));
-				}
-
-				// Use a deserializer if one is available
-				if (typeSerializer != null && !columnIsNull) {
-					value = typeSerializer.deserialize(value);
-				}
-
-				// Set the field name
-				if (value != null) {
-					field.set(this, value);
-				}
-			}
-			catch (IllegalArgumentException e) {
-				AALog.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				AALog.e(e.getClass().getName(), e);
-			}
-			catch (SecurityException e) {
-				AALog.e(e.getClass().getName(), e);
-			}
-		}
-
-		if (getId() != null) {
-			Cache.addEntity(this);
-		}
-	}
+    }*/
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PROTECTED METHODS
@@ -330,4 +95,12 @@ public String toString() {
     public long getRowId(){
         return mId;
     }
+
+    public TableInfo getTableInfo() {
+        return mTableInfo;
+    }
+
+    public void setRowId(long id) {
+        mId = id;
+    }
 }
diff --git a/src/main/java/com/activeandroid/serializer/ClassSerializer.java b/src/main/java/com/activeandroid/serializer/ClassSerializer.java
new file mode 100644
index 00000000..2422b504
--- /dev/null
+++ b/src/main/java/com/activeandroid/serializer/ClassSerializer.java
@@ -0,0 +1,26 @@
+package com.activeandroid.serializer;
+
+import com.activeandroid.IModelInfo;
+import com.activeandroid.TableInfo;
+
+/**
+ * Created by andrewgrosner
+ * Date: 4/3/14
+ * Contributors:
+ * Description: Allows objects other than just {@link com.activeandroid.Model} objects to store data in the DB
+ */
+public interface ClassSerializer<OBJECT_CLASS extends IModelInfo> {
+
+    /**
+     * Instructs the class to retrieve the field at a specific position
+     * @param position
+     * @return
+     */
+    public Object serializeField(OBJECT_CLASS object, int position);
+
+    public Object deserializeField(OBJECT_CLASS object, int position);
+
+    public int getFieldCount();
+
+    public String getFieldName(int position);
+}
diff --git a/src/main/java/com/activeandroid/serializer/ModelClassSerializer.java b/src/main/java/com/activeandroid/serializer/ModelClassSerializer.java
new file mode 100644
index 00000000..2e492c8f
--- /dev/null
+++ b/src/main/java/com/activeandroid/serializer/ModelClassSerializer.java
@@ -0,0 +1,54 @@
+package com.activeandroid.serializer;
+
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.util.SQLiteUtils;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+
+/**
+ * Created by andrewgrosner
+ * Date: 4/3/14
+ * Contributors:
+ * Description:
+ */
+public class ModelClassSerializer implements ClassSerializer<Model> {
+
+    private TableInfo mTableInfo;
+    private ArrayList<Field> mFields;
+
+    public ModelClassSerializer(TableInfo tableInfo){
+        mTableInfo = tableInfo;
+        mFields = new ArrayList<Field>(mTableInfo.getFields());
+    }
+
+    @Override
+    public Object serializeField(Model model, int position) {
+        Field field = mFields.get(position);
+        field.setAccessible(true);
+
+        Object value = null;
+        try {
+            value = field.get(model);
+        } catch (IllegalAccessException e) {
+
+        }
+        return SQLiteUtils.getTypeSerializedValue(value);
+    }
+
+    @Override
+    public Object deserializeField(Model model, int position) {
+        return null;
+    }
+
+    @Override
+    public int getFieldCount() {
+        return mFields.size();
+    }
+
+    @Override
+    public String getFieldName(int position) {
+        return mTableInfo.getColumnName(mFields.get(position));
+    }
+}
diff --git a/src/main/java/com/activeandroid/util/SQLiteUtils.java b/src/main/java/com/activeandroid/util/SQLiteUtils.java
index 69af06d1..ab8c8488 100644
--- a/src/main/java/com/activeandroid/util/SQLiteUtils.java
+++ b/src/main/java/com/activeandroid/util/SQLiteUtils.java
@@ -16,8 +16,10 @@
  * limitations under the License.
  */
 
+import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
 import android.os.Build;
 import android.text.TextUtils;
 
@@ -27,12 +29,15 @@
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.ForeignKey;
 import com.activeandroid.annotation.PrimaryKey;
+import com.activeandroid.content.ContentProvider;
 import com.activeandroid.exception.PrimaryKeyCannotBeNullException;
+import com.activeandroid.query.Select;
 import com.activeandroid.serializer.TypeSerializer;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 
@@ -230,7 +235,7 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 			if (cursor.moveToFirst()) {
 				do {
 					Model entity = (T) entityConstructor.newInstance();
-					entity.loadFromCursor(cursor);
+                    loadFromCursor(cursor, entity);
 					entities.add((T) entity);
 				}
 				while (cursor.moveToNext());
@@ -361,4 +366,263 @@ public static String getWhereFromEntityId(Class<? extends Model> model, String e
         return whereString;
     }
 
+    /**
+     * Saves a model to the DB
+     * @param model
+     */
+    public static void save(Model model){
+        final SQLiteDatabase db = Cache.openDatabase();
+        final ContentValues values = new ContentValues();
+        Collection<Field> fields = model.getTableInfo().getFields();
+
+        for (Field field : fields) {
+            String fieldName = model.getTableInfo().getColumnName(field);
+            Class<?> fieldType = field.getType();
+
+            field.setAccessible(true);
+
+            try {
+                Object value = field.get(model);
+
+                if (value != null) {
+                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                    if (typeSerializer != null) {
+                        // serialize data
+                        value = typeSerializer.serialize(value);
+                        // set new object type
+                        if (value != null) {
+                            fieldType = value.getClass();
+                            // check that the serializer returned what it promised
+                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
+                                AALog.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                        typeSerializer.getSerializedType(), fieldType));
+                            }
+                        }
+                    }
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (value == null) {
+                    values.putNull(fieldName);
+                }
+                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    values.put(fieldName, (Byte) value);
+                }
+                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    values.put(fieldName, (Short) value);
+                }
+                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    values.put(fieldName, (Integer) value);
+                }
+                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    values.put(fieldName, (Long) value);
+                }
+                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    values.put(fieldName, (Float) value);
+                }
+                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    values.put(fieldName, (Double) value);
+                }
+                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    values.put(fieldName, (Boolean) value);
+                }
+                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    values.put(fieldName, value.toString());
+                }
+                else if (fieldType.equals(String.class)) {
+                    values.put(fieldName, value.toString());
+                }
+                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    values.put(fieldName, (byte[]) value);
+                }
+                else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
+                    ForeignKey key = field.getAnnotation(ForeignKey.class);
+                    if(!key.name().equals("")){
+                        fieldName = field.getAnnotation(ForeignKey.class).name();
+                    }
+                    values.put(fieldName, ((Model) value).getId());
+                }
+                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    values.put(fieldName, ((Enum<?>) value).name());
+                }
+            }
+            catch (IllegalArgumentException e) {
+                AALog.e(e.getClass().getName(), e);
+            }
+            catch (IllegalAccessException e) {
+                AALog.e(e.getClass().getName(), e);
+            }
+        }
+
+        if(!model.exists()){
+            model.setRowId(db.insert(model.getTableInfo().getTableName(), null, values));
+
+            for(Field field : model.getTableInfo().getPrimaryKeys()){
+                if(field.isAnnotationPresent(PrimaryKey.class) &&
+                        field.getAnnotation(PrimaryKey.class).type().equals(PrimaryKey.Type.AUTO_INCREMENT)){
+                    field.setAccessible(true);
+                    try {
+                        field.set(model, model.getRowId());
+                    } catch (Throwable e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+            }
+        } else {
+            model.setRowId(db.update(model.getTableInfo().getTableName(), values, SQLiteUtils.getWhereStatement(model, model.getTableInfo()), null));
+        }
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(model.getTableInfo().getType(), model.getId()), null);
+    }
+
+    public static final void loadFromCursor(Cursor cursor, Model model){
+        Collection<Field> fields = model.getTableInfo().getFields();
+
+        for (Field field : fields) {
+            final String fieldName = model.getTableInfo().getColumnName(field);
+            Class<?> fieldType = field.getType();
+            final int columnIndex = cursor.getColumnIndex(fieldName);
+
+            if (columnIndex < 0) {
+                continue;
+            }
+
+            field.setAccessible(true);
+
+            try {
+                boolean columnIsNull = cursor.isNull(columnIndex);
+                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                Object value = null;
+
+                if (typeSerializer != null) {
+                    fieldType = typeSerializer.getSerializedType();
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (columnIsNull) {
+                    field = null;
+                }
+                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    value = cursor.getInt(columnIndex);
+                }
+                else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    value = cursor.getLong(columnIndex);
+                }
+                else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    value = cursor.getFloat(columnIndex);
+                }
+                else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    value = cursor.getDouble(columnIndex);
+                }
+                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    value = cursor.getInt(columnIndex) != 0;
+                }
+                else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    value = cursor.getString(columnIndex).charAt(0);
+                }
+                else if (fieldType.equals(String.class)) {
+                    value = cursor.getString(columnIndex);
+                }
+                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    value = cursor.getBlob(columnIndex);
+                }
+                else if (field.isAnnotationPresent(ForeignKey.class) && ReflectionUtils.isModel(fieldType)) {
+                    final String entityId = cursor.getString(columnIndex);
+                    final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
+
+                    Model entity = Cache.getEntity(entityType, entityId);
+                    if (entity == null) {
+                        entity = new Select().from(entityType).where(SQLiteUtils.getWhereFromEntityId(entityType, entityId)).executeSingle();
+                    }
+
+                    value = entity;
+                }
+                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    @SuppressWarnings("rawtypes")
+                    final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+                    value = Enum.valueOf(enumType, cursor.getString(columnIndex));
+                }
+
+                // Use a deserializer if one is available
+                if (typeSerializer != null && !columnIsNull) {
+                    value = typeSerializer.deserialize(value);
+                }
+
+                // Set the field name
+                if (value != null) {
+                    field.set(model, value);
+                }
+            }
+            catch (IllegalArgumentException e) {
+                AALog.e(e.getClass().getName(), e);
+            }
+            catch (IllegalAccessException e) {
+                AALog.e(e.getClass().getName(), e);
+            }
+            catch (SecurityException e) {
+                AALog.e(e.getClass().getName(), e);
+            }
+        }
+
+        if (model.getId() != null) {
+            Cache.addEntity(model);
+        }
+    }
+
+    /**
+     * Check whether the given model exists
+     * @param model
+     * @return
+     */
+    public static boolean exists(Model model){
+        return (new Select().from(model.getClass()).where(SQLiteUtils.getWhereStatement(model, model.getTableInfo())).executeSingle())!=null;
+    }
+
+    /**
+     * Deletes a model
+     * @param model
+     */
+    public static void delete(Model model){
+        Cache.openDatabase().delete(model.getTableInfo().getTableName(), SQLiteUtils.getWhereStatement(model, model.getTableInfo()), null);
+        Cache.removeEntity(model);
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(model.getTableInfo().getType(), model.getId()), null);
+    }
+
+    /**
+     * Attempts to use a {@link com.activeandroid.serializer.TypeSerializer} to convert the value from the DB into the object's value
+     * @param outValue - the object that gets converted
+     * @return
+     */
+    public static Object getTypeSerializedValue(Object outValue){
+        if (outValue != null) {
+            Class fieldType = outValue.getClass();
+
+            final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+            if (typeSerializer != null) {
+                // serialize data
+                outValue = typeSerializer.serialize(outValue);
+                // set new object type
+                if (outValue != null) {
+                    fieldType = outValue.getClass();
+                    // check that the serializer returned what it promised
+                    if (!fieldType.equals(typeSerializer.getSerializedType())) {
+                        AALog.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                typeSerializer.getSerializedType(), fieldType));
+                    }
+                }
+            }
+        }
+        return outValue;
+    }
 }
