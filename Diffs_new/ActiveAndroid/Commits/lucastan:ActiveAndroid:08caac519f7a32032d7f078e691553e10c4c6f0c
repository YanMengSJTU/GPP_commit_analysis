diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 488c6974..7d0cf643 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -18,6 +18,7 @@
 
 import android.content.ContentValues;
 import android.database.Cursor;
+import android.database.SQLException;
 import android.database.sqlite.SQLiteDatabase;
 import android.text.TextUtils;
 
@@ -67,137 +68,151 @@ public final void delete() {
 		Cache.removeEntity(this);
 
 		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+		.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+	}
+
+	private ContentValues createContentValues() {
+		// The exceptions should never happen, so we put the try-catch outside
+		// for better performance.
+		final ContentValues values = new ContentValues();
+
+		try {
+			for (Field field : mTableInfo.getFields()) {
+				final String fieldName = mTableInfo.getColumnName(field);
+				Class<?> fieldType = field.getType();
+				Object value = field.get(this);
+
+				if (value != null) {
+					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+					if (typeSerializer != null) {
+						// serialize data
+						value = typeSerializer.serialize(value);
+						// set new object type
+						if (value != null) {
+							fieldType = value.getClass();
+							// check that the serializer returned what it promised
+							if (!fieldType.equals(typeSerializer.getSerializedType())) {
+								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+										typeSerializer.getSerializedType(), fieldType));
+							}
+						}
+					}
+				}
+
+				SQLiteUtils.put(values, fieldType, fieldName, value);
+			}
+		}
+		catch (IllegalArgumentException e) {
+			Log.e(e.getClass().getName(), e);
+		}
+		catch (IllegalAccessException e) {
+			Log.e(e.getClass().getName(), e);
+		}
+
+		return values;
+	}
+
+	/**
+	 * Updates this model if it has an ID; else inserts it.
+	 * @return If inserting, returns the new ID or -1 on failure; else returns the existing ID.
+	 */
+	public final Long save() {
+		ContentValues values = createContentValues();
+		SQLiteDatabase db = null;
+
+		try {
+			db = Cache.openDatabase();
+			if (mId == null) {
+				long newID = db.insert(mTableInfo.getTableName(), null, values);
+				if (newID == -1L)
+					// returns -1 instead of null for backwards compatibility.
+					return -1L;
+				mId = newID;
+			}
+			else {
+				db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
+			}
+		}
+		finally {
+			if (db != null)
+				db.close();
+		}
+
+		Cache.getContext().getContentResolver()
+		.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+		return mId;
+	}
+
+	public final boolean upsert(long id) {
+		return upsert(id, null, null);
+	}
+
+	/**
+	 * Inserts or updates this object with a specified ID. If insertion fails,
+	 * due to for example, duplication of ID, this method will attempt to update
+	 * the existing row instead. Note that the entire operation is not atomic.
+	 * If either the insertion or updating succeeds, this object will be
+	 * assigned the specified ID. This object will not be modified in any way on
+	 * failure. This "upsert" operation is desirable over "REPLACE" in that it
+	 * doesn't result in deletion of an existing row, and thus does not trigger
+	 * deletion of foreign children that has "ON DELETE CASCADE".
+	 * 
+	 * @param id
+	 * @param updateWhere "where" clause to be used only when updating. Can be null.
+	 * @throws IllegalStateException
+	 *             if this object already has an ID.
+	 * @returns true on success; false on failure.
+	 */
+	public final boolean upsert(long id, String updateWhere, String[] updateWhereArgs) {
+		if (mId != null)
+			throw new IllegalStateException();
+
+		ContentValues values = createContentValues();
+		SQLiteDatabase db = null;
+
+		db = Cache.openDatabase();
+		values.put(idName, id);
+
+		try {
+			// use insertOrThrow to avoid logging to logcat.
+			long newID = db.insertOrThrow(mTableInfo.getTableName(), null,
+					values);
+			if (newID != -1) {
+				// should be same as id.
+				mId = newID;
+				db.close();
+			}
+		}
+		catch (SQLException ignored) {
+		}
+
+		if (mId == null) {
+			try {
+				// Don't update the ID so as to avoid triggering foreign
+				// keys ON UPDATE.
+				values.remove(idName);
+				if (updateWhere != null)
+					updateWhere = updateWhere.trim();
+                if (!TextUtils.isEmpty(updateWhere))
+					updateWhere = " and (" + updateWhere + ")";
+				int rows = db.update(mTableInfo.getTableName(), values, idName
+                        + "=" + id + updateWhere,
+						updateWhereArgs);
+				if (rows == 0) {
+					return false;
+				}
+				mId = id;
+			}
+			finally {
+				db.close();
+			}
+		}
+
+		Cache.getContext().getContentResolver()
+		.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+		return true;
 	}
 
-    private ContentValues createContentValues() {
-        // The exceptions should never happen, so we put the try-catch outside
-        // for better performance.
-        final ContentValues values = new ContentValues();
-
-        try {
-            for (Field field : mTableInfo.getFields()) {
-                final String fieldName = mTableInfo.getColumnName(field);
-                Class<?> fieldType = field.getType();
-                Object value = field.get(this);
-
-                if (value != null) {
-                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-                    if (typeSerializer != null) {
-                        // serialize data
-                        value = typeSerializer.serialize(value);
-                        // set new object type
-                        if (value != null) {
-                            fieldType = value.getClass();
-                            // check that the serializer returned what it promised
-                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
-                                Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-                                        typeSerializer.getSerializedType(), fieldType));
-                            }
-                        }
-                    }
-                }
-
-                SQLiteUtils.put(values, fieldType, fieldName, value);       
-            }
-        }
-        catch (IllegalArgumentException e) {
-            Log.e(e.getClass().getName(), e);
-        }
-        catch (IllegalAccessException e) {
-            Log.e(e.getClass().getName(), e);
-        }
-        
-        return values;
-    }
-    
-    /**
-     * Updates this model if it has an ID; else inserts it.
-     * @return If inserting, returns the new ID or -1 on failure; else returns the existing ID.
-     */
-    public final Long save() {
-        ContentValues values = createContentValues();
-        SQLiteDatabase db = null;
-        
-        try {
-            db = Cache.openDatabase();
-            if (mId == null) {
-                long newID = db.insert(mTableInfo.getTableName(), null, values);
-                if (newID == -1L)
-                    // returns -1 instead of null for backwards compatibility.
-                    return -1L;
-                mId = newID;
-            }
-            else {
-                db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
-            }
-        }
-        finally {
-            if (db != null) 
-                db.close();
-        }
-
-        Cache.getContext().getContentResolver()
-                .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-        return mId;
-    }
-
-    public final boolean upsert(long id) {
-        return upsert(id, null, null);
-    }
-    
-    /**
-     * Inserts or updates this object with a specified ID. If insertion fails,
-     * due to for example, duplication of ID, this method will attempt to update
-     * the existing row instead. Note that the entire operation is not atomic.
-     * If either the insertion or updating succeeds, this object will be
-     * assigned the specified ID. This object will not be modified in any way on
-     * failure. This "upsert" operation is desirable over "REPLACE" in that it
-     * doesn't result in deletion of an existing row, and thus does not trigger
-     * deletion of foreign children that has "ON DELETE CASCADE".
-     * 
-     * @param id
-     * @param updateWhere "where" clause to be used only when updating. Can be null.
-     * @throws IllegalStateException
-     *             if this object already has an ID.
-     * @returns true on success; false on failure.
-     */
-    public final boolean upsert(long id, String updateWhere, String[] updateWhereArgs) {
-        if (mId != null)
-            throw new IllegalStateException();
-        
-        ContentValues values = createContentValues();
-        values.put(idName, id);
-        SQLiteDatabase db = null;
-        
-        try {
-            db = Cache.openDatabase();
-            long newID = db.insert(mTableInfo.getTableName(), null, values);
-            if (newID == -1L) {
-                // Don't update the ID so as to avoid triggering foreign
-                // keys ON UPDATE.
-                values.remove(idName);
-                if (updateWhere != null)
-                    updateWhere = updateWhere.trim();
-                if (TextUtils.isEmpty(updateWhere))
-                    updateWhere = "1";
-                int rows = db.update(mTableInfo.getTableName(), values, idName+"=" + id + " and ("+updateWhere+")", updateWhereArgs);
-                if (rows == 0)
-                    return  false;
-            }
-            // newID should be the same as id.
-            mId = id;
-        }
-        finally {
-            if (db != null) 
-                db.close();
-        }
-    
-        Cache.getContext().getContentResolver()
-                .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-        return true;
-    }
-	
 	// Convenience methods
 
 	public static void delete(Class<? extends Model> type, long id) {
@@ -210,98 +225,98 @@ public static void delete(Class<? extends Model> type, long id) {
 		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
 	}
 
-    /**
-     * Deep copies a model instance. Only the model ID and the fields annotated 
-     * as {@link Column} will be copied over to the new instance. 
-     * WARNING: If the specified model is self-referential, this will cause an 
-     * infinite recursion. 
-     * @param model Model instance to copy. Must not be null.
-     * @return The new model instance or null if an error occurs.
-     */
-    public static <T extends Model> T clone(T model) {
-        final Class<T> cls = (Class<T>) model.getClass();
-        T newInstance = null;
-
-        try {
-            newInstance = cls.newInstance();
-
-            // copy fields from model to newInstance.
-            for (Field field : model.mTableInfo.getFields()) {
-                Object val = field.get(model);
-                
-                if (val instanceof Model)
-                    val = clone((Model)val);
-                
-                field.set(newInstance, val);
-            }
-
-            newInstance.mId = model.mId;
-
-            return newInstance;
-        }
-        // These should not happen.
-        catch (IllegalAccessException e) {
-            // nothing
-        }
-        catch (InstantiationException e) {
-            // nothing
-        }
-
-        return null;
-    }
+	/**
+	 * Deep copies a model instance. Only the model ID and the fields annotated
+	 * as {@link Column} will be copied over to the new instance.
+	 * WARNING: If the specified model is self-referential, this will cause an
+	 * infinite recursion.
+	 * @param model Model instance to copy. Must not be null.
+	 * @return The new model instance or null if an error occurs.
+	 */
+	public static <T extends Model> T clone(T model) {
+		final Class<T> cls = (Class<T>) model.getClass();
+		T newInstance = null;
+
+		try {
+			newInstance = cls.newInstance();
+
+			// copy fields from model to newInstance.
+			for (Field field : model.mTableInfo.getFields()) {
+				Object val = field.get(model);
+
+				if (val instanceof Model)
+					val = clone((Model)val);
+
+				field.set(newInstance, val);
+			}
+
+			newInstance.mId = model.mId;
+
+			return newInstance;
+		}
+		// These should not happen.
+		catch (IllegalAccessException e) {
+			// nothing
+		}
+		catch (InstantiationException e) {
+			// nothing
+		}
+
+		return null;
+	}
 
 	// Model population
 
-    public final void loadFromCursor(Cursor cursor) {
-        /**
-         * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-         * when the cursor have multiple columns with same name obtained from join tables.
-         */
-        String[] columnsOrdered = cursor.getColumnNames();
-        // The exceptions should never happen, so we put the try-catch outside
-        // for better performance.
-        try {
-            for (Field field : mTableInfo.getFields()) {
-                final String fieldName = mTableInfo.getColumnName(field);
-                Class<?> fieldType = field.getType();
-                final int columnIndex = SQLiteUtils.indexOfIgnoreCase(columnsOrdered, fieldName);
-                 
-                if (columnIndex < 0) {
-                    continue;
-                }
-    
-                boolean columnIsNull = cursor.isNull(columnIndex);
-                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-                Object value = null;
-    
-                if (!columnIsNull) {
-                    if (typeSerializer != null) {
-                        Class<?> getType = typeSerializer.getSerializedType();
-                        value = SQLiteUtils.get(cursor, getType, columnIndex);
-                        value = typeSerializer.deserialize(value);
-                    }
-                    else
-                        value = SQLiteUtils.get(cursor, fieldType, columnIndex);
-                }
-    
-                // If the field accepts null and the value is indeed null, then
-                // set it to null.
-                if (value != null || !fieldType.isPrimitive()) {
-                    field.set(this, value);
-                }
-            }
-            
-            if (mId != null) {
-                Cache.addEntity(this);
-            }
-        }
-        catch (IllegalArgumentException e) {
-            Log.e(e.getClass().getName(), e);
-        }
-        catch (IllegalAccessException e) {
-            Log.e(e.getClass().getName(), e);
-        }
-    }
+	public final void loadFromCursor(Cursor cursor) {
+		/**
+		 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+		 * when the cursor have multiple columns with same name obtained from join tables.
+		 */
+		String[] columnsOrdered = cursor.getColumnNames();
+		// The exceptions should never happen, so we put the try-catch outside
+		// for better performance.
+		try {
+			for (Field field : mTableInfo.getFields()) {
+				final String fieldName = mTableInfo.getColumnName(field);
+				Class<?> fieldType = field.getType();
+				final int columnIndex = SQLiteUtils.indexOfIgnoreCase(columnsOrdered, fieldName);
+
+				if (columnIndex < 0) {
+					continue;
+				}
+
+				boolean columnIsNull = cursor.isNull(columnIndex);
+				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+				Object value = null;
+
+				if (!columnIsNull) {
+					if (typeSerializer != null) {
+						Class<?> getType = typeSerializer.getSerializedType();
+						value = SQLiteUtils.get(cursor, getType, columnIndex);
+						value = typeSerializer.deserialize(value);
+					}
+					else
+						value = SQLiteUtils.get(cursor, fieldType, columnIndex);
+				}
+
+				// If the field accepts null and the value is indeed null, then
+				// set it to null.
+				if (value != null || !fieldType.isPrimitive()) {
+					field.set(this, value);
+				}
+			}
+
+			if (mId != null) {
+				Cache.addEntity(this);
+			}
+		}
+		catch (IllegalArgumentException e) {
+			Log.e(e.getClass().getName(), e);
+		}
+		catch (IllegalAccessException e) {
+			Log.e(e.getClass().getName(), e);
+		}
+	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PROTECTED METHODS
@@ -325,8 +340,8 @@ public boolean equals(Object obj) {
 		if (obj instanceof Model && this.mId != null) {
 			final Model other = (Model) obj;
 
-			return this.mId.equals(other.mId)							
-							&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
+			return this.mId.equals(other.mId)
+					&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
 		} else {
 			return this == obj;
 		}
