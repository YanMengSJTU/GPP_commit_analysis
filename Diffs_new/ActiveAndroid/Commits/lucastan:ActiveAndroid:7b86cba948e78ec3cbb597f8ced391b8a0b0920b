diff --git a/src/com/activeandroid/Configuration.java b/src/com/activeandroid/Configuration.java
index 758ed194..b197d223 100644
--- a/src/com/activeandroid/Configuration.java
+++ b/src/com/activeandroid/Configuration.java
@@ -27,6 +27,10 @@
 import com.activeandroid.util.ReflectionUtils;
 
 public class Configuration {
+
+    public final static String SQL_PARSER_LEGACY = "legacy";
+    public final static String SQL_PARSER_DELIMITED = "delimited";
+
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -34,6 +38,7 @@
 	private Context mContext;
 	private String mDatabaseName;
 	private int mDatabaseVersion;
+	private String mSqlParser;
 	private List<Class<? extends Model>> mModelClasses;
 	private List<Class<? extends TypeSerializer>> mTypeSerializers;
 	private int mCacheSize;
@@ -61,6 +66,10 @@ public String getDatabaseName() {
 	public int getDatabaseVersion() {
 		return mDatabaseVersion;
 	}
+	
+	public String getSqlParser() {
+	    return mSqlParser;
+	}
 
 	public List<Class<? extends Model>> getModelClasses() {
 		return mModelClasses;
@@ -91,9 +100,11 @@ public boolean isValid() {
 		private static final String AA_DB_VERSION = "AA_DB_VERSION";
 		private final static String AA_MODELS = "AA_MODELS";
 		private final static String AA_SERIALIZERS = "AA_SERIALIZERS";
+		private final static String AA_SQL_PARSER = "AA_SQL_PARSER";
 
 		private static final int DEFAULT_CACHE_SIZE = 1024;
 		private static final String DEFAULT_DB_NAME = "Application.db";
+		private static final String DEFAULT_SQL_PARSER = SQL_PARSER_LEGACY;
 
 		//////////////////////////////////////////////////////////////////////////////////////
 		// PRIVATE MEMBERS
@@ -104,6 +115,7 @@ public boolean isValid() {
 		private Integer mCacheSize;
 		private String mDatabaseName;
 		private Integer mDatabaseVersion;
+		private String mSqlParser;
 		private List<Class<? extends Model>> mModelClasses;
 		private List<Class<? extends TypeSerializer>> mTypeSerializers;
 
@@ -134,6 +146,11 @@ public Builder setDatabaseVersion(int databaseVersion) {
 			mDatabaseVersion = databaseVersion;
 			return this;
 		}
+		
+		public Builder setSqlParser(String sqlParser) {
+		    mSqlParser = sqlParser;
+		    return this;
+		}
 
 		public Builder addModelClass(Class<? extends Model> modelClass) {
 			if (mModelClasses == null) {
@@ -188,24 +205,28 @@ public Configuration create() {
 			// Get database name from meta-data
 			if (mDatabaseName != null) {
 				configuration.mDatabaseName = mDatabaseName;
-			}
-			else {
+			} else {
 				configuration.mDatabaseName = getMetaDataDatabaseNameOrDefault();
 			}
 
 			// Get database version from meta-data
 			if (mDatabaseVersion != null) {
 				configuration.mDatabaseVersion = mDatabaseVersion;
-			}
-			else {
+			} else {
 				configuration.mDatabaseVersion = getMetaDataDatabaseVersionOrDefault();
 			}
 
+			// Get SQL parser from meta-data
+			if (mSqlParser != null) {
+			    configuration.mSqlParser = mSqlParser;
+			} else {
+			    configuration.mSqlParser = getMetaDataSqlParserOrDefault();
+			}
+			
 			// Get model classes from meta-data
 			if (mModelClasses != null) {
 				configuration.mModelClasses = mModelClasses;
-			}
-			else {
+			} else {
 				final String modelList = ReflectionUtils.getMetaData(mContext, AA_MODELS);
 				if (modelList != null) {
 					configuration.mModelClasses = loadModelList(modelList.split(","));
@@ -215,8 +236,7 @@ public Configuration create() {
 			// Get type serializer classes from meta-data
 			if (mTypeSerializers != null) {
 				configuration.mTypeSerializers = mTypeSerializers;
-			}
-			else {
+			} else {
 				final String serializerList = ReflectionUtils.getMetaData(mContext, AA_SERIALIZERS);
 				if (serializerList != null) {
 					configuration.mTypeSerializers = loadSerializerList(serializerList.split(","));
@@ -250,6 +270,14 @@ private int getMetaDataDatabaseVersionOrDefault() {
 			return aaVersion;
 		}
 
+		private String getMetaDataSqlParserOrDefault() {
+		    final String mode = ReflectionUtils.getMetaData(mContext, AA_SQL_PARSER);
+		    if (mode == null) {
+		        return DEFAULT_SQL_PARSER;
+		    }
+		    return mode;
+		}
+
 		private List<Class<? extends Model>> loadModelList(String[] models) {
 			final List<Class<? extends Model>> modelClasses = new ArrayList<Class<? extends Model>>();
 			final ClassLoader classLoader = mContext.getClass().getClassLoader();
diff --git a/src/com/activeandroid/DatabaseHelper.java b/src/com/activeandroid/DatabaseHelper.java
index 703d3e7d..d7551f27 100644
--- a/src/com/activeandroid/DatabaseHelper.java
+++ b/src/com/activeandroid/DatabaseHelper.java
@@ -31,9 +31,11 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
 
+import com.activeandroid.util.IOUtils;
 import com.activeandroid.util.Log;
 import com.activeandroid.util.NaturalOrderComparator;
 import com.activeandroid.util.SQLiteUtils;
+import com.activeandroid.util.SqlParser;
 
 public final class DatabaseHelper extends SQLiteOpenHelper {
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -42,6 +44,12 @@
 
 	public final static String MIGRATION_PATH = "migrations";
 
+	//////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE FIELDS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private final String mSqlParser;
+
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -49,6 +57,7 @@
 	public DatabaseHelper(Configuration configuration) {
 		super(configuration.getContext(), configuration.getDatabaseName(), null, configuration.getDatabaseVersion());
 		copyAttachedDatabase(configuration.getContext(), configuration.getDatabaseName());
+		mSqlParser = configuration.getSqlParser();
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -187,22 +196,61 @@ private boolean executeMigrations(SQLiteDatabase db, int oldVersion, int newVers
 
 		return migrationExecuted;
 	}
-
+	
 	private void executeSqlScript(SQLiteDatabase db, String file) {
+
+	    InputStream stream = null;
+
 		try {
-			final InputStream input = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
-			final BufferedReader reader = new BufferedReader(new InputStreamReader(input));
-			String line = null;
-
-			while ((line = reader.readLine()) != null) {
-				line = line.replace(";", "").trim();
-				if (!line.isEmpty()) {
-					db.execSQL(line);
-				}
-			}
-		}
-		catch (IOException e) {
+		    stream = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
+
+		    if (Configuration.SQL_PARSER_DELIMITED.equalsIgnoreCase(mSqlParser)) {
+		        executeDelimitedSqlScript(db, stream);
+
+		    } else {
+		        executeLegacySqlScript(db, stream);
+
+		    }
+
+		} catch (IOException e) {
 			Log.e("Failed to execute " + file, e);
+
+		} finally {
+		    IOUtils.closeQuietly(stream);
+
 		}
 	}
+
+	private void executeDelimitedSqlScript(SQLiteDatabase db, InputStream stream) throws IOException {
+
+	    List<String> commands = SqlParser.parse(stream);
+	    
+	    for(String command : commands) {
+	        db.execSQL(command);
+	    }
+	}
+
+	private void executeLegacySqlScript(SQLiteDatabase db, InputStream stream) throws IOException {
+
+	    InputStreamReader reader = null;
+        BufferedReader buffer = null;
+
+        try {
+            reader = new InputStreamReader(stream);
+            buffer = new BufferedReader(reader);
+            String line = null;
+    
+            while ((line = buffer.readLine()) != null) {
+                line = line.replace(";", "").trim();
+                if (!line.isEmpty()) {
+                    db.execSQL(line);
+                }
+            }
+
+        } finally {
+            IOUtils.closeQuietly(buffer);
+            IOUtils.closeQuietly(reader);
+
+        }
+	}
 }
diff --git a/src/com/activeandroid/util/IOUtils.java b/src/com/activeandroid/util/IOUtils.java
new file mode 100644
index 00000000..284d7bca
--- /dev/null
+++ b/src/com/activeandroid/util/IOUtils.java
@@ -0,0 +1,69 @@
+
+package com.activeandroid.util;
+
+/*
+ * Copyright (C) 2014 Markus Pfeiffer
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.database.Cursor;
+
+import java.io.Closeable;
+import java.io.IOException;
+
+import com.activeandroid.util.Log;
+
+
+public class IOUtils {
+
+    /**
+     * Unconditionally close a {@link Closeable}.
+     * <p/>
+     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored. This is
+     * typically used in finally blocks.
+     * @param closeable A {@link Closeable} to close.
+     */
+    public static void closeQuietly(final Closeable closeable) {
+
+        if (closeable == null) {
+            return;
+        }
+
+        try {
+            closeable.close();
+        } catch (final IOException e) {
+            Log.e("Couldn't close closeable.", e);
+        }
+    }
+
+    /**
+     * Unconditionally close a {@link Cursor}.
+     * <p/>
+     * Equivalent to {@link Cursor#close()}, except any exceptions will be ignored. This is
+     * typically used in finally blocks.
+     * @param cursor A {@link Cursor} to close.
+     */
+    public static void closeQuietly(final Cursor cursor) {
+
+        if (cursor == null) {
+            return;
+        }
+
+        try {
+            cursor.close();
+        } catch (final Exception e) {
+            Log.e("Couldn't close cursor.", e);
+        }
+    }
+}
diff --git a/src/com/activeandroid/util/SqlParser.java b/src/com/activeandroid/util/SqlParser.java
new file mode 100644
index 00000000..f9531b7c
--- /dev/null
+++ b/src/com/activeandroid/util/SqlParser.java
@@ -0,0 +1,110 @@
+
+package com.activeandroid.util;
+
+/*
+ * Copyright (C) 2014 Markus Pfeiffer
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+
+public class SqlParser {
+
+    public final static int STATE_NONE          = 0;
+    public final static int STATE_STRING        = 1;
+    public final static int STATE_COMMENT       = 2;
+    public final static int STATE_COMMENT_BLOCK = 3;
+
+    public static List<String> parse(final InputStream stream) throws IOException {
+
+        final BufferedInputStream buffer = new BufferedInputStream(stream);
+        final List<String> commands = new ArrayList<String>();
+        final StringBuffer sb = new StringBuffer();
+
+        try {
+            final Tokenizer tokenizer = new Tokenizer(buffer);
+            int state = STATE_NONE;
+
+            while (tokenizer.hasNext()) {
+                final char c = (char) tokenizer.next();
+
+                if (state == STATE_COMMENT_BLOCK) {
+                    if (tokenizer.skip("*/")) {
+                        state = STATE_NONE;
+                    }
+                    continue;
+
+                } else if (state == STATE_COMMENT) {
+                    if (isNewLine(c)) {
+                        state = STATE_NONE;
+                    }
+                    continue;
+
+                } else if (state == STATE_NONE && tokenizer.skip("/*")) {
+                    state = STATE_COMMENT_BLOCK;
+                    continue;
+
+                } else if (state == STATE_NONE && tokenizer.skip("--")) {
+                    state = STATE_COMMENT;
+                    continue;
+
+                } else if (state == STATE_NONE && c == ';') {
+                    final String command = sb.toString().trim();
+                    commands.add(command);
+                    sb.setLength(0);
+                    continue;
+
+                } else if (state == STATE_NONE && c == '\'') {
+                    state = STATE_STRING;
+
+                } else if (state == STATE_STRING && c == '\'') {
+                    state = STATE_NONE;
+
+                }
+
+                if (state == STATE_NONE || state == STATE_STRING) {
+                    if (state == STATE_NONE && isWhitespace(c)) {
+                        if (sb.length() > 0 && sb.charAt(sb.length() - 1) != ' ') {
+                            sb.append(' ');
+                        }
+                    } else {
+                        sb.append(c);
+                    }
+                }
+            }
+
+        } finally {
+            IOUtils.closeQuietly(buffer);
+        }
+
+        if (sb.length() > 0) {
+            commands.add(sb.toString().trim());
+        }
+
+        return commands;
+    }
+
+    private static boolean isNewLine(final char c) {
+        return c == '\r' || c == '\n';
+    }
+
+    private static boolean isWhitespace(final char c) {
+        return c == '\r' || c == '\n' || c == '\t' || c == ' ';
+    }
+}
diff --git a/src/com/activeandroid/util/Tokenizer.java b/src/com/activeandroid/util/Tokenizer.java
new file mode 100644
index 00000000..8ae34da3
--- /dev/null
+++ b/src/com/activeandroid/util/Tokenizer.java
@@ -0,0 +1,76 @@
+
+package com.activeandroid.util;
+
+/*
+ * Copyright (C) 2014 Markus Pfeiffer
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public class Tokenizer {
+
+    private final InputStream mStream;
+
+    private boolean           mIsNext;
+    private int               mCurrent;
+
+    public Tokenizer(final InputStream in) {
+        this.mStream = in;
+    }
+
+    public boolean hasNext() throws IOException {
+
+        if (!this.mIsNext) {
+            this.mIsNext = true;
+            this.mCurrent = this.mStream.read();
+        }
+        return this.mCurrent != -1;
+    }
+
+    public int next() throws IOException {
+
+        if (!this.mIsNext) {
+            this.mCurrent = this.mStream.read();
+        }
+        this.mIsNext = false;
+        return this.mCurrent;
+    }
+
+    public boolean skip(final String s) throws IOException {
+
+        if (s == null || s.length() == 0) {
+            return false;
+        }
+
+        if (s.charAt(0) != this.mCurrent) {
+            return false;
+        }
+
+        final int len = s.length();
+        this.mStream.mark(len - 1);
+
+        for (int n = 1; n < len; n++) {
+            final int value = this.mStream.read();
+
+            if (value != s.charAt(n)) {
+                this.mStream.reset();
+                return false;
+            }
+        }
+        return true;
+    }
+}
diff --git a/tests/assets/migrations/2.sql b/tests/assets/migrations/2.sql
new file mode 100644
index 00000000..9281dd77
--- /dev/null
+++ b/tests/assets/migrations/2.sql
@@ -0,0 +1,18 @@
+CREATE TABLE IF NOT EXISTS MockMigration
+(
+	Id INTEGER AUTO_INCREMENT PRIMARY KEY,
+	Column TEXT NOT NULL
+);
+
+INSERT INTO MockMigration
+(
+	Id,
+	Column
+)
+VALUES
+(
+	1,
+	'text'
+);
+
+DROP TABLE IF EXISTS MockMigration;
diff --git a/tests/res/raw/block_comment.sql b/tests/res/raw/block_comment.sql
new file mode 100644
index 00000000..081e5e72
--- /dev/null
+++ b/tests/res/raw/block_comment.sql
@@ -0,0 +1,5 @@
+CREATE TABLE Entity1
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL,
+	Column1 INTEGER /* This is a block comment and should be ignored */
+)
diff --git a/tests/res/raw/block_comment_with_semicolon.sql b/tests/res/raw/block_comment_with_semicolon.sql
new file mode 100644
index 00000000..ba88da24
--- /dev/null
+++ b/tests/res/raw/block_comment_with_semicolon.sql
@@ -0,0 +1,5 @@
+CREATE TABLE Entity1
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, /* block comment ; with semicolon */
+	Column1 INTEGER
+)
diff --git a/tests/res/raw/block_comment_with_string.sql b/tests/res/raw/block_comment_with_string.sql
new file mode 100644
index 00000000..982bacf3
--- /dev/null
+++ b/tests/res/raw/block_comment_with_string.sql
@@ -0,0 +1,5 @@
+CREATE TABLE Entity1
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL,
+	Column1 INTEGER /* This is a block comment 'with a string that doesn't matter' */
+)
diff --git a/tests/res/raw/block_with_line_comment.sql b/tests/res/raw/block_with_line_comment.sql
new file mode 100644
index 00000000..7279803a
--- /dev/null
+++ b/tests/res/raw/block_with_line_comment.sql
@@ -0,0 +1,4 @@
+CREATE TABLE Entity1
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, /* This is a block comment -- not a line comment */ Column1 INTEGER 
+)
diff --git a/tests/res/raw/complex.sql b/tests/res/raw/complex.sql
new file mode 100644
index 00000000..611ad37a
--- /dev/null
+++ b/tests/res/raw/complex.sql
@@ -0,0 +1,38 @@
+-- Create table for migration
+CREATE TABLE Entity2
+(
+    Id INTEGER AUTO_INCREMENT PRIMARY KEY,
+    Column TEXT NOT NULL,
+    Column2 INTEGER NULL /* this column is new */
+);
+
+-- Migrate data
+INSERT INTO Entity2
+(
+    Id,
+    Column, /* --> ; <-- */
+    Column2
+)
+SELECT  Id,
+        Column,
+        0 -- there's no such value in the old table
+        FROM Entity;
+
+-- Rename Entity2 to Entity
+DROP TABLE Entity;
+ALTER TABLE Entity2 RENAME TO Entity;
+
+/* Add some --sample-- data */
+INSERT INTO Entity2
+(
+    Id, --;'/*;*/--
+    Col/*not sure if anyone would ever be insane enough to do this*/umn,
+    Column2--,
+)
+VALUES
+(
+	9001 /* not -- really */, -- almost forgot that comma
+	42,--23, /* I don't know who messed this up
+	'string /* string */ -- string'--,
+	-- 'test' whoops we don't have that many columns
+)
\ No newline at end of file
diff --git a/tests/res/raw/invalid_block_comment.sql b/tests/res/raw/invalid_block_comment.sql
new file mode 100644
index 00000000..07dfd474
--- /dev/null
+++ b/tests/res/raw/invalid_block_comment.sql
@@ -0,0 +1,6 @@
+CREATE TABLE Entity1
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL,
+	 /* /* /* This is an invalid block comment */ */
+	Column1 INTEGER
+)
diff --git a/tests/res/raw/line_comment.sql b/tests/res/raw/line_comment.sql
new file mode 100644
index 00000000..d7e91e05
--- /dev/null
+++ b/tests/res/raw/line_comment.sql
@@ -0,0 +1,5 @@
+CREATE TABLE Entity1
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL,
+	Column1 INTEGER -- This is a line comment and should be ignored
+)
diff --git a/tests/res/raw/line_comment_and_block_end.sql b/tests/res/raw/line_comment_and_block_end.sql
new file mode 100644
index 00000000..f555f40a
--- /dev/null
+++ b/tests/res/raw/line_comment_and_block_end.sql
@@ -0,0 +1,6 @@
+CREATE TABLE Entity1
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL,
+	-- This is a line comment and should be ignored */ NonColumn STRING,
+	Column1 INTEGER
+)
diff --git a/tests/res/raw/line_comment_with_semicolon.sql b/tests/res/raw/line_comment_with_semicolon.sql
new file mode 100644
index 00000000..a2d0c421
--- /dev/null
+++ b/tests/res/raw/line_comment_with_semicolon.sql
@@ -0,0 +1,5 @@
+CREATE TABLE Entity1
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, -- line comment ; with semicolon
+	Column1 INTEGER
+)
diff --git a/tests/res/raw/line_comment_with_string.sql b/tests/res/raw/line_comment_with_string.sql
new file mode 100644
index 00000000..6c05cb99
--- /dev/null
+++ b/tests/res/raw/line_comment_with_string.sql
@@ -0,0 +1,5 @@
+CREATE TABLE Entity1
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL,
+	Column1 INTEGER -- This is a line comment 'with a string that doesn't matter'
+)
diff --git a/tests/res/raw/string_with_block_comment.sql b/tests/res/raw/string_with_block_comment.sql
new file mode 100644
index 00000000..04e89364
--- /dev/null
+++ b/tests/res/raw/string_with_block_comment.sql
@@ -0,0 +1,12 @@
+INSERT INTO Entity
+(
+	Id,
+	Column1,
+	Column2
+)
+VALUES
+(
+	1,
+	'/* some text',
+	'some text */'
+);
\ No newline at end of file
diff --git a/tests/res/raw/string_with_line_comment.sql b/tests/res/raw/string_with_line_comment.sql
new file mode 100644
index 00000000..4ba8fb7b
--- /dev/null
+++ b/tests/res/raw/string_with_line_comment.sql
@@ -0,0 +1,12 @@
+INSERT INTO Entity
+(
+	Id,
+	Column1,
+	Column2
+)
+VALUES
+(
+	1,
+	'-- some text',
+	'some text'
+);
\ No newline at end of file
diff --git a/tests/res/raw/string_with_semicolon.sql b/tests/res/raw/string_with_semicolon.sql
new file mode 100644
index 00000000..47bcb840
--- /dev/null
+++ b/tests/res/raw/string_with_semicolon.sql
@@ -0,0 +1,12 @@
+INSERT INTO Entity
+(
+	Id,
+	Column1,
+	Column2
+)
+VALUES
+(
+	1,
+	'some ; text',
+	'some ; text'
+);
\ No newline at end of file
diff --git a/tests/res/raw/string_with_whitespace.sql b/tests/res/raw/string_with_whitespace.sql
new file mode 100644
index 00000000..2ba29ac3
--- /dev/null
+++ b/tests/res/raw/string_with_whitespace.sql
@@ -0,0 +1,12 @@
+INSERT INTO Entity
+(
+	Id,
+	Column1,
+	Column2
+)
+VALUES
+(
+	1,
+	'some			text',
+	'some    text'
+);
\ No newline at end of file
diff --git a/tests/res/raw/two_statements.sql b/tests/res/raw/two_statements.sql
new file mode 100644
index 00000000..ad87c403
--- /dev/null
+++ b/tests/res/raw/two_statements.sql
@@ -0,0 +1,11 @@
+CREATE TABLE Entity1
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL,
+	Column1 INTEGER
+);
+
+CREATE TABLE Entity2
+(
+	Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL,
+	Column1 INTEGER
+)
diff --git a/tests/res/raw/whitespace.sql b/tests/res/raw/whitespace.sql
new file mode 100644
index 00000000..97eb6f2a
--- /dev/null
+++ b/tests/res/raw/whitespace.sql
@@ -0,0 +1,36 @@
+CREATE TABLE Entity1
+
+
+(
+
+
+
+
+
+
+
+
+
+
+
+
+	Id INTEGER AUTOINCREMENT                         PRIMARY KEY NOT NULL,
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	Column1					INTEGER
+);
\ No newline at end of file
diff --git a/tests/src/com/activeandroid/test/ConfigurationTest.java b/tests/src/com/activeandroid/test/ConfigurationTest.java
index 460f2c8d..12ca4a72 100644
--- a/tests/src/com/activeandroid/test/ConfigurationTest.java
+++ b/tests/src/com/activeandroid/test/ConfigurationTest.java
@@ -20,6 +20,7 @@ public void testDefaultValue() throws IOException, ClassNotFoundException {
         assertNull(conf.getModelClasses());
         assertFalse(conf.isValid());
         assertNull(conf.getTypeSerializers());
+        assertEquals(Configuration.SQL_PARSER_LEGACY, conf.getSqlParser());
     }
 
     public void testCreateConfigurationWithMockModel() {
diff --git a/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java b/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
new file mode 100644
index 00000000..971b8a89
--- /dev/null
+++ b/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
@@ -0,0 +1,54 @@
+
+package com.activeandroid.test.parser;
+
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+
+import com.activeandroid.Configuration;
+import com.activeandroid.DatabaseHelper;
+import com.activeandroid.test.ActiveAndroidTestCase;
+
+
+public class ParserConfigurationTest extends ActiveAndroidTestCase {
+
+    /**
+     * Should try to use the legacy parser by default, which is be unable to handle the SQL script.
+     */
+    public void testLegacyMigration() {
+
+        try {
+            Configuration configuration = new Configuration.Builder(getContext())
+                    .setDatabaseName("migration.db")
+                    .setDatabaseVersion(2)
+                    .create();
+
+            DatabaseHelper helper = new DatabaseHelper(configuration);
+            SQLiteDatabase db = helper.getWritableDatabase();
+            helper.onUpgrade(db, 1, 2);
+
+            fail("Should not be able to parse the SQL script.");
+
+        } catch (SQLException e) {
+            final String message = e.getMessage();
+
+            assertNotNull(message);
+            assertTrue(message.contains("syntax error"));
+            assertTrue(message.contains("near \"MockMigration\""));
+        }
+    }
+
+    /**
+     * Should use the new parser if configured to do so.
+     */
+    public void testDelimitedMigration() {
+        Configuration configuration = new Configuration.Builder(getContext())
+                .setSqlParser(Configuration.SQL_PARSER_DELIMITED)
+                .setDatabaseName("migration.db")
+                .setDatabaseVersion(2)
+                .create();
+
+        DatabaseHelper helper = new DatabaseHelper(configuration);
+        SQLiteDatabase db = helper.getWritableDatabase();
+        helper.onUpgrade(db, 1, 2);
+    }
+}
diff --git a/tests/src/com/activeandroid/test/parser/ParserTest.java b/tests/src/com/activeandroid/test/parser/ParserTest.java
new file mode 100644
index 00000000..164376b3
--- /dev/null
+++ b/tests/src/com/activeandroid/test/parser/ParserTest.java
@@ -0,0 +1,247 @@
+
+package com.activeandroid.test.parser;
+
+import com.activeandroid.test.ActiveAndroidTestCase;
+import com.activeandroid.test.R;
+import com.activeandroid.util.SqlParser;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+
+
+public class ParserTest extends ActiveAndroidTestCase {
+
+    private final String sql1    = "CREATE TABLE Entity1 ( Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, Column1 INTEGER )";
+    private final String sql2    = "CREATE TABLE Entity2 ( Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, Column1 INTEGER )";
+
+    private final String invalid = "CREATE TABLE Entity1 ( Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, */ Column1 INTEGER )";
+
+    private InputStream getStream(int id) {
+        return this.getContext().getResources().openRawResource(id);
+    }
+
+    /**
+     * Should be able to parse a script with two multi-line statments, even if the last statement
+     * is not terminated by a semicolon.
+     * @throws IOException
+     */
+    public void testTwoStatements() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.two_statements);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(2, commands.size());
+        assertEquals(sql1, commands.get(0));
+        assertEquals(sql2, commands.get(1));
+    }
+
+    /**
+     * Should reduce unnecessary whitespace.
+     * @throws IOException
+     */
+    public void testWhitespace() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.whitespace);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql1, commands.get(0));
+    }
+
+    /**
+     * Should be able to parse a multi-line statement that has an embedded line comment.
+     * @throws IOException
+     */
+    public void testLineComment() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.line_comment);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql1, commands.get(0));
+    }
+
+    /**
+     * Should be able to handle a line comment that contains string tokens.
+     * @throws IOException
+     */
+    public void testLineCommentWithString() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.line_comment_with_string);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql1, commands.get(0));
+    }
+
+    /**
+     * Should be able to handle a line comment that contains a semicolon.
+     * @throws IOException
+     */
+    public void testLineCommentWithSemicolon() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.line_comment_with_semicolon);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql1, commands.get(0));
+    }
+
+    /**
+     * Should ignore a block comment end token inside a line comment.
+     * @throws IOException
+     */
+    public void testLineAndBlockEndComment() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.line_comment_and_block_end);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql1, commands.get(0));
+    }
+
+    /**
+     * Should be able to handle a block comment.
+     * @throws IOException
+     */
+    public void testBlockComment() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.block_comment);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql1, commands.get(0));
+    }
+
+    /**
+     * Should be able to handle a block comment that contains string tokens.
+     * @throws IOException
+     */
+    public void testBlockCommentWithString() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.block_comment_with_string);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql1, commands.get(0));
+    }
+
+    /**
+     * Should be able to handle a block comment that contains a semicolon.
+     * @throws IOException
+     */
+    public void testBlockCommentWithSemicolon() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.block_comment_with_semicolon);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql1, commands.get(0));
+    }
+
+    /**
+     * Should ignore a line comment token inside a block comment.
+     * @throws IOException
+     */
+    public void testBlockAndLineComment() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.block_with_line_comment);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql1, commands.get(0));
+    }
+
+    /**
+     * Should be able to parse a script that incorrectly closes a block comment twice. The
+     * resulting script is not expected to run, but the parser shouldn't choke on it.
+     * @throws IOException
+     */
+    public void testInvalidBlockComment() throws IOException {
+
+        final InputStream stream = this.getStream(R.raw.invalid_block_comment);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(invalid, commands.get(0));
+    }
+
+    /**
+     * Should ignore a line comment token inside a string.
+     * @throws IOException
+     */
+    public void testStringWithLineComment() throws IOException {
+        final String sql = "INSERT INTO Entity ( Id, Column1, Column2 ) VALUES ( 1, '-- some text', 'some text' )";
+
+        final InputStream stream = this.getStream(R.raw.string_with_line_comment);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql, commands.get(0));
+    }
+
+    /**
+     * Should ignore block comment tokens inside strings.
+     * @throws IOException
+     */
+    public void testStringWithBlockComment() throws IOException {
+        final String sql = "INSERT INTO Entity ( Id, Column1, Column2 ) VALUES ( 1, '/* some text', 'some text */' )";
+
+        final InputStream stream = this.getStream(R.raw.string_with_block_comment);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql, commands.get(0));
+    }
+
+    /**
+     * Should ignore semicolons inside strings.
+     * @throws IOException
+     */
+    public void testStringWithSemicolon() throws IOException {
+        final String sql = "INSERT INTO Entity ( Id, Column1, Column2 ) VALUES ( 1, 'some ; text', 'some ; text' )";
+
+        final InputStream stream = this.getStream(R.raw.string_with_semicolon);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql, commands.get(0));
+    }
+
+    /**
+     * Should not clobber whitespace in strings.
+     * @throws IOException
+     */
+    public void testStringWithWhitespace() throws IOException {
+        final String sql = "INSERT INTO Entity ( Id, Column1, Column2 ) VALUES ( 1, 'some\t\t\ttext', 'some    text' )";
+
+        final InputStream stream = this.getStream(R.raw.string_with_whitespace);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(1, commands.size());
+        assertEquals(sql, commands.get(0));
+    }
+
+    /**
+     * Should be able to handle a script that contains anything nasty I can thing of right now.
+     * @throws IOException 
+     */
+    public void testComplex() throws IOException {
+        final String sql1 = "CREATE TABLE Entity2 ( Id INTEGER AUTO_INCREMENT PRIMARY KEY, Column TEXT NOT NULL, Column2 INTEGER NULL )";
+        final String sql2 = "INSERT INTO Entity2 ( Id, Column, Column2 ) SELECT Id, Column, 0 FROM Entity";
+        final String sql3 = "DROP TABLE Entity";
+        final String sql4 = "ALTER TABLE Entity2 RENAME TO Entity";
+        final String sql5 = "INSERT INTO Entity2 ( Id, Column, Column2) VALUES ( 9001 , 42, 'string /* string */ -- string' )";
+
+        final InputStream stream = this.getStream(R.raw.complex);
+        List<String> commands = SqlParser.parse(stream);
+
+        assertEquals(5, commands.size());
+        assertEquals(sql1, commands.get(0));
+        assertEquals(sql2, commands.get(1));
+        assertEquals(sql3, commands.get(2));
+        assertEquals(sql4, commands.get(3));
+        assertEquals(sql5, commands.get(4));
+    }
+}
