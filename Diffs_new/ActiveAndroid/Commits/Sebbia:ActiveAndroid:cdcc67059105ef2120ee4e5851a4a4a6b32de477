diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 421426ea..ad948fad 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -73,84 +73,10 @@ public final void delete() {
 
 	public final Long save() {
 		final SQLiteDatabase db = Cache.openDatabase();
-		final ContentValues values = new ContentValues();
-
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-
-			field.setAccessible(true);
-
-			try {
-				Object value = field.get(this);
-
-				if (value != null) {
-					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-					if (typeSerializer != null) {
-						// serialize data
-						value = typeSerializer.serialize(value);
-						// set new object type
-						if (value != null) {
-							fieldType = value.getClass();
-							// check that the serializer returned what it promised
-							if (!fieldType.equals(typeSerializer.getSerializedType())) {
-								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-										typeSerializer.getSerializedType(), fieldType));
-							}
-						}
-					}
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (value == null) {
-					values.putNull(fieldName);
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					values.put(fieldName, (Byte) value);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					values.put(fieldName, (Short) value);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					values.put(fieldName, (Integer) value);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					values.put(fieldName, (Long) value);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					values.put(fieldName, (Float) value);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					values.put(fieldName, (Double) value);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					values.put(fieldName, (Boolean) value);
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(String.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					values.put(fieldName, (byte[]) value);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					values.put(fieldName, ((Model) value).getId());
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					values.put(fieldName, ((Enum<?>) value).name());
-				}
-			}
-			catch (IllegalArgumentException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-		}
-
+		
+		ContentValues values = new ContentValues();
+		fillContentValues(values);
+		
 		if (mId == null) {
 			mId = db.insert(mTableInfo.getTableName(), null, values);
 		}
@@ -174,7 +100,21 @@ public static void delete(Class<? extends Model> type, long id) {
 		TableInfo tableInfo = Cache.getTableInfo(type);
 		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
 	}
-
+	
+	public static void saveMultiple(List<? extends Model> entities) {
+		final SQLiteDatabase db = Cache.openDatabase();
+		final ContentValues values = new ContentValues();
+		
+		for (Model entity : entities) {
+			entity.fillContentValues(values);
+
+			if (entity.mId == null) {
+				entity.mId = db.insertWithOnConflict(entity.mTableInfo.getTableName(), null, values, SQLiteDatabase.CONFLICT_REPLACE);
+			} else {
+				db.update(entity.mTableInfo.getTableName(), values, "Id=" + entity.mId, null);
+			}
+		}
+	}
 	// Model population
 
 	public final void loadFromCursor(Cursor cursor) {
@@ -288,7 +228,7 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
 		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
 	}
-
+	
 	//////////////////////////////////////////////////////////////////////////////////////
 	// OVERRIDEN METHODS
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -317,4 +257,87 @@ public int hashCode() {
 		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
 		return hash; //To change body of generated methods, choose Tools | Templates.
 	}
+	
+	//////////////////////////////////////////////////////////////////////////////////////
+	// PRIVATE METHODS
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private void fillContentValues(ContentValues values) {
+		values.clear();
+		for (Field field : mTableInfo.getFields()) {
+			final String fieldName = mTableInfo.getColumnName(field);
+			Class<?> fieldType = field.getType();
+
+			field.setAccessible(true);
+
+			try {
+				Object value = field.get(this);
+
+				if (value != null) {
+					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+					if (typeSerializer != null) {
+						// serialize data
+						value = typeSerializer.serialize(value);
+						// set new object type
+						if (value != null) {
+							fieldType = value.getClass();
+							// check that the serializer returned what it promised
+							if (!fieldType.equals(typeSerializer.getSerializedType())) {
+								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+										typeSerializer.getSerializedType(), fieldType));
+							}
+						}
+					}
+				}
+
+				// TODO: Find a smarter way to do this? This if block is necessary because we
+				// can't know the type until runtime.
+				if (value == null) {
+					values.putNull(fieldName);
+				}
+				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+					values.put(fieldName, (Byte) value);
+				}
+				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+					values.put(fieldName, (Short) value);
+				}
+				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+					values.put(fieldName, (Integer) value);
+				}
+				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+					values.put(fieldName, (Long) value);
+				}
+				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+					values.put(fieldName, (Float) value);
+				}
+				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+					values.put(fieldName, (Double) value);
+				}
+				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+					values.put(fieldName, (Boolean) value);
+				}
+				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+					values.put(fieldName, value.toString());
+				}
+				else if (fieldType.equals(String.class)) {
+					values.put(fieldName, value.toString());
+				}
+				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+					values.put(fieldName, (byte[]) value);
+				}
+				else if (ReflectionUtils.isModel(fieldType)) {
+					values.put(fieldName, ((Model) value).getId());
+				}
+				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+					values.put(fieldName, ((Enum<?>) value).name());
+				}
+			}
+			catch (IllegalArgumentException e) {
+				Log.e(e.getClass().getName(), e);
+			}
+			catch (IllegalAccessException e) {
+				Log.e(e.getClass().getName(), e);
+			}
+		}
+	}
 }
diff --git a/src/com/activeandroid/ModelInfo.java b/src/com/activeandroid/ModelInfo.java
index 09e79117..9a68a122 100644
--- a/src/com/activeandroid/ModelInfo.java
+++ b/src/com/activeandroid/ModelInfo.java
@@ -18,6 +18,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.lang.reflect.Modifier;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Calendar;
@@ -36,6 +37,7 @@
 import com.activeandroid.serializer.FileSerializer;
 import com.activeandroid.util.Log;
 import com.activeandroid.util.ReflectionUtils;
+
 import dalvik.system.DexFile;
 
 final class ModelInfo {
@@ -185,7 +187,7 @@ private void scanForModelClasses(File path, String packageName, ClassLoader clas
 
 			try {
 				Class<?> discoveredClass = Class.forName(className, false, classLoader);
-				if (ReflectionUtils.isModel(discoveredClass)) {
+				if (ReflectionUtils.isModel(discoveredClass) && !Modifier.isAbstract(discoveredClass.getModifiers())) {
 					@SuppressWarnings("unchecked")
 					Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
 					mTableInfos.put(modelClass, new TableInfo(modelClass));
diff --git a/src/com/activeandroid/model/ManyToManyRelation.java b/src/com/activeandroid/model/ManyToManyRelation.java
new file mode 100644
index 00000000..97bf6b81
--- /dev/null
+++ b/src/com/activeandroid/model/ManyToManyRelation.java
@@ -0,0 +1,165 @@
+package com.activeandroid.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.query.Delete;
+import com.activeandroid.util.Log;
+import com.activeandroid.util.SQLiteUtils;
+
+public abstract class ManyToManyRelation<T1 extends Model, T2 extends Model> extends Model {
+
+	@Column (name = "entity1")
+	private T1 entity1;
+	@Column (name = "entity2")
+	private T2 entity2;
+
+	public static <T1 extends Model, T2 extends Model> void setRelationsFront(Class<? extends ManyToManyRelation<T1, T2>> relation, T1 entity1, List<T2> entities2) {
+		if (entity1.getId() == null)
+			throw new IllegalArgumentException(entity1.getClass().getSimpleName() + " is not saved to database yet, aborting");
+		for (T2 entity2 : entities2) {
+			if (entity2.getId() == null)
+				throw new IllegalArgumentException(entity2.getClass().getSimpleName() + " is not saved to database yet, aborting");
+		}
+
+		new Delete().from(relation).where("entity1 = ?", entity1.getId()).execute();
+		try {
+			ArrayList<ManyToManyRelation<T1, T2>> connections = new ArrayList<ManyToManyRelation<T1,T2>>();
+			for (T2 entity2 : entities2) {
+				ManyToManyRelation<T1, T2> connection = relation.newInstance();
+				connection.entity1 = entity1;
+				connection.entity2 = entity2;
+				connections.add(connection);
+			}
+			saveMultiple(connections);
+		} catch (Exception e) {
+			Log.e("Cannot create instance of class " + relation.getSimpleName());
+			throw new RuntimeException(e);
+		}
+	}
+
+	public static <T1 extends Model, T2 extends Model> void setRelationsReverse(Class<? extends ManyToManyRelation<T1, T2>> relation, T2 entity2, List<T1> entities1) {
+		if (entity2.getId() == null)
+			throw new IllegalArgumentException(entity2.getClass().getSimpleName() + " is not saved to database yet, aborting");
+		for (T1 entity1 : entities1) {
+			if (entity1.getId() == null)
+				throw new IllegalArgumentException(entity1.getClass().getSimpleName() + " is not saved to database yet, aborting");
+		}
+
+		new Delete().from(relation).where("entity2 = ?", entity2.getId()).execute();
+		try {
+			ArrayList<ManyToManyRelation<T1, T2>> connections = new ArrayList<ManyToManyRelation<T1,T2>>();
+			for (T1 entity1 : entities1) {
+				ManyToManyRelation<T1, T2> connection = relation.newInstance();
+				connection.entity1 = entity1;
+				connection.entity2 = entity2;
+				connections.add(connection);
+			}
+			saveMultiple(connections);
+		} catch (Exception e) {
+			Log.e("Cannot create instance of class " + relation.getSimpleName());
+			throw new RuntimeException(e);
+		}
+	}
+
+	public static <T1 extends Model, T2 extends Model> List<T2> getRelationsFront(Class<? extends ManyToManyRelation<T1, T2>> relation, T1 entity) {
+		if (entity.getId() == null)
+			throw new IllegalArgumentException(entity.getClass().getSimpleName() + " is not saved to database yet, aborting");
+
+		Class<? extends Model> entity1Class;
+		Class<? extends Model> entity2Class;
+		TableInfo entity1TableInfo;
+		TableInfo entity2TableInfo;
+		TableInfo crossTableInfo;
+		try {
+			ManyToManyRelation<T1, T2> instance = relation.newInstance();
+			entity1Class = instance.getEntity1Class();
+			entity2Class = instance.getEntity2Class();
+			entity1TableInfo = Cache.getTableInfo(entity1Class);
+			entity2TableInfo = Cache.getTableInfo(entity2Class);
+			crossTableInfo = Cache.getTableInfo(relation);
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+
+		StringBuilder queryBuilder = new StringBuilder();
+		queryBuilder.append("SELECT ");
+		queryBuilder.append(entity2TableInfo.getTableName());
+		queryBuilder.append(".* FROM (");
+		queryBuilder.append(entity1TableInfo.getTableName());
+		queryBuilder.append(" JOIN ");
+		queryBuilder.append(crossTableInfo.getTableName());
+		queryBuilder.append(" ON ");
+		queryBuilder.append(entity1TableInfo.getTableName());
+		queryBuilder.append(".id == ");
+		queryBuilder.append(crossTableInfo.getTableName());
+		queryBuilder.append(".entity1) JOIN ");
+		queryBuilder.append(entity2TableInfo.getTableName());
+		queryBuilder.append(" ON ");
+		queryBuilder.append(entity2TableInfo.getTableName());
+		queryBuilder.append(".id == ");
+		queryBuilder.append(crossTableInfo.getTableName());
+		queryBuilder.append(".entity2 WHERE ");
+		queryBuilder.append(entity1TableInfo.getTableName());
+		queryBuilder.append(".id == ?");
+
+		return SQLiteUtils.rawQuery(entity2Class, queryBuilder.toString(), new String[] {entity.getId().toString()});
+	}
+
+	public static <T1 extends Model, T2 extends Model> List<T1> getRelationsReverse(Class<? extends ManyToManyRelation<T1, T2>> relation, T2 entity) {
+		if (entity.getId() == null)
+			throw new IllegalArgumentException(entity.getClass().getSimpleName() + " is not saved to database yet, aborting");
+
+		Class<? extends Model> entity1Class;
+		Class<? extends Model> entity2Class;
+		TableInfo entity1TableInfo;
+		TableInfo entity2TableInfo;
+		TableInfo crossTableInfo;
+		try {
+			ManyToManyRelation<T1, T2> instance = relation.newInstance();
+			entity1Class = instance.getEntity1Class();
+			entity2Class = instance.getEntity2Class();
+			entity1TableInfo = Cache.getTableInfo(entity1Class);
+			entity2TableInfo = Cache.getTableInfo(entity2Class);
+			crossTableInfo = Cache.getTableInfo(relation);
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+
+		StringBuilder queryBuilder = new StringBuilder();
+		queryBuilder.append("SELECT ");
+		queryBuilder.append(entity1TableInfo.getTableName());
+		queryBuilder.append(".* FROM (");
+		queryBuilder.append(entity2TableInfo.getTableName());
+		queryBuilder.append(" JOIN ");
+		queryBuilder.append(crossTableInfo.getTableName());
+		queryBuilder.append(" ON ");
+		queryBuilder.append(entity2TableInfo.getTableName());
+		queryBuilder.append(".id == ");
+		queryBuilder.append(crossTableInfo.getTableName());
+		queryBuilder.append(".entity2) JOIN ");
+		queryBuilder.append(entity1TableInfo.getTableName());
+		queryBuilder.append(" ON ");
+		queryBuilder.append(entity1TableInfo.getTableName());
+		queryBuilder.append(".id == ");
+		queryBuilder.append(crossTableInfo.getTableName());
+		queryBuilder.append(".entity1 WHERE ");
+		queryBuilder.append(entity2TableInfo.getTableName());
+		queryBuilder.append(".id == ?");
+
+		return SQLiteUtils.rawQuery(entity1Class, queryBuilder.toString(), new String[] {entity.getId().toString()});
+	}
+
+	public ManyToManyRelation() {
+		super();
+	}
+
+	public abstract Class<T1> getEntity1Class();
+	public abstract Class<T2> getEntity2Class();
+
+
+}
diff --git a/src/com/activeandroid/model/OneToManyRelation.java b/src/com/activeandroid/model/OneToManyRelation.java
new file mode 100644
index 00000000..4a831edc
--- /dev/null
+++ b/src/com/activeandroid/model/OneToManyRelation.java
@@ -0,0 +1,80 @@
+package com.activeandroid.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import android.database.Cursor;
+
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.annotation.Column;
+import com.activeandroid.query.Delete;
+import com.activeandroid.util.Log;
+
+public abstract class OneToManyRelation<T1 extends Model> extends Model {
+
+	@Column (name = "entity1")
+	private T1 entity1;
+	@Column (name = "entity2Type")
+	private String entity2Type;
+	@Column (name = "entity2")
+	private Model entity2;
+
+	public static <T1 extends Model> void setRelations(Class<? extends OneToManyRelation<T1>> relation, T1 entity1, List<Model> entities2) {
+		if (entity1.getId() == null)
+			throw new IllegalArgumentException(entity1.getClass().getSimpleName() + " is not saved to database yet, aborting");
+		for (Model entity2 : entities2) {
+			if (entity2.getId() == null)
+				throw new IllegalArgumentException(entity2.getClass().getSimpleName() + " is not saved to database yet, aborting");
+		}
+
+		new Delete().from(relation).where("entity1 = ?", entity1.getId()).execute();
+		try {
+			ArrayList<OneToManyRelation<T1>> connections = new ArrayList<OneToManyRelation<T1>>();
+			for (Model entity2 : entities2) {
+				OneToManyRelation<T1> connection = relation.newInstance();
+				connection.entity1 = entity1;
+				connection.entity2Type = entity2.getClass().getCanonicalName();
+				connection.entity2 = entity2;
+				connections.add(connection);
+			}
+			saveMultiple(connections);
+		} catch (Exception e) {
+			Log.e("Cannot create instance of class " + relation.getSimpleName());
+			throw new RuntimeException(e);
+		}
+	}
+
+	public static <T1 extends Model> List<Model> getRelations(Class<? extends OneToManyRelation<T1>> relation, T1 entity) {
+		if (entity.getId() == null)
+			throw new IllegalArgumentException(entity.getClass().getSimpleName() + " is not saved to database yet, aborting");
+
+		TableInfo crossTableInfo = Cache.getTableInfo(relation);
+		Cursor cursor = Cache.openDatabase().rawQuery("SELECT entity2Type, entity2 FROM " + crossTableInfo.getTableName() + " WHERE entity1 = ?", new String[] {entity.getId().toString()});
+		final List<Model> entities = new ArrayList<Model>();
+		try {
+			if (cursor.moveToFirst()) {
+				do {
+					String typeName = cursor.getString(0);
+					@SuppressWarnings("unchecked")
+					Class<? extends Model> entity2Class = (Class<? extends Model>) Class.forName(typeName);
+					entities.add(Model.load(entity2Class, cursor.getLong(1)));
+				}
+				while (cursor.moveToNext());
+			}
+		}
+		catch (Exception e) {
+			Log.e("Failed to process cursor.", e);
+			throw new RuntimeException(e);
+		} finally {
+			cursor.close();
+		}
+
+		return entities;
+	}
+
+	public OneToManyRelation() {
+		super();
+	}
+}
diff --git a/src/com/activeandroid/util/ReflectionUtils.java b/src/com/activeandroid/util/ReflectionUtils.java
index 32e995cc..a5306856 100644
--- a/src/com/activeandroid/util/ReflectionUtils.java
+++ b/src/com/activeandroid/util/ReflectionUtils.java
@@ -17,7 +17,6 @@
  */
 
 import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
@@ -38,7 +37,7 @@
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	public static boolean isModel(Class<?> type) {
-		return isSubclassOf(type, Model.class) && (!Modifier.isAbstract(type.getModifiers()));
+		return type == Model.class || isSubclassOf(type, Model.class);
 	}
 
 	public static boolean isTypeSerializer(Class<?> type) {
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index cbf41eae..1e91dbaf 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -303,7 +303,7 @@ else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
 				}
 			}
 
-			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
+			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type) && Cache.getTableInfo((Class<? extends Model>) type) != null) {
 				definition.append(" REFERENCES ");
 				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
 				definition.append("("+tableInfo.getIdName()+")");
diff --git a/tests/src/com/activeandroid/test/model/ManyToManyTest.java b/tests/src/com/activeandroid/test/model/ManyToManyTest.java
new file mode 100644
index 00000000..02f9f7f4
--- /dev/null
+++ b/tests/src/com/activeandroid/test/model/ManyToManyTest.java
@@ -0,0 +1,78 @@
+package com.activeandroid.test.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.activeandroid.Model;
+import com.activeandroid.model.ManyToManyRelation;
+import com.activeandroid.test.MockModel;
+
+public class ManyToManyTest extends ModelTestCase {
+	
+	public static class MockModelList extends MockModel {
+		
+	}
+	
+	public static class MockManyToManyRelation extends ManyToManyRelation<MockModelList, MockModel> {
+
+		@Override
+		public Class<MockModelList> getEntity1Class() {
+			return MockModelList.class;
+		}
+
+		@Override
+		public Class<MockModel> getEntity2Class() {
+			return MockModel.class;
+		}
+	}
+	
+	public void testManyToManyRelationForward() throws Exception {
+		List<MockModel> mockModels = createChildEntities(MockModel.class);
+		List<MockModelList> mockModelLists = new ArrayList<ManyToManyTest.MockModelList>();
+		for (int i = 0; i < 3; ++i) {
+			MockModelList mockModelList = new MockModelList();
+			mockModelList.save();
+			ManyToManyRelation.setRelationsFront(MockManyToManyRelation.class, mockModelList, mockModels);
+			mockModelLists.add(mockModelList);
+		}
+		
+		for (MockModelList list : mockModelLists) {
+			verifyMockModels(ManyToManyRelation.getRelationsFront(MockManyToManyRelation.class, list), MockModel.class);			
+		}
+	}
+	
+	public void testManyToManyRelationReverse() throws Exception {
+		List<MockModelList> mockModelLists = createChildEntities(MockModelList.class);
+		List<MockModel> mockModels = new ArrayList<MockModel>();
+		for (int i = 0; i < 3; ++i) {
+			MockModel mockModel = new MockModel();
+			mockModel.save();
+			ManyToManyRelation.setRelationsReverse(MockManyToManyRelation.class, mockModel, mockModelLists);
+			mockModels.add(mockModel);
+		}
+		for (MockModel mockModel : mockModels) {
+			verifyMockModels(ManyToManyRelation.getRelationsReverse(MockManyToManyRelation.class, mockModel), MockModelList.class);			
+		}
+	}
+		
+	private void verifyMockModels(List<? extends MockModel> mockModels, Class<? extends MockModel> clazz) {
+		assertTrue(mockModels.size() == 5);
+		for (int i = 0; i < 5; ++i) {
+			MockModel mockModel = mockModels.get(i);
+			assertTrue(mockModel.getClass() == clazz);
+			assertTrue(mockModel.intField == i);
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	private <T extends Model> List<T> createChildEntities(Class<? extends MockModel> clazz) throws IllegalAccessException, InstantiationException {
+		List<T> mockModels = new ArrayList<T>();
+		for (int i = 0; i < 5; ++i) {
+			MockModel mockModel = clazz.newInstance();
+			mockModel.intField = i;
+			mockModel.save();
+			mockModels.add((T) mockModel);
+		}
+		return mockModels;
+	}
+}
diff --git a/tests/src/com/activeandroid/test/model/ModelTestCase.java b/tests/src/com/activeandroid/test/model/ModelTestCase.java
new file mode 100644
index 00000000..a4d16f12
--- /dev/null
+++ b/tests/src/com/activeandroid/test/model/ModelTestCase.java
@@ -0,0 +1,16 @@
+package com.activeandroid.test.model;
+
+import com.activeandroid.ActiveAndroid;
+import com.activeandroid.Configuration;
+import com.activeandroid.test.ActiveAndroidTestCase;
+
+public class ModelTestCase extends ActiveAndroidTestCase {
+	@Override
+	protected void setUp() throws Exception {
+		Configuration configuration = new Configuration.Builder(getContext())
+        .setDatabaseName("model.db")
+        .setDatabaseVersion(2)
+        .create();
+		ActiveAndroid.initialize(configuration, true);
+	}
+}
diff --git a/tests/src/com/activeandroid/test/model/OneToManyTest.java b/tests/src/com/activeandroid/test/model/OneToManyTest.java
new file mode 100644
index 00000000..28744d15
--- /dev/null
+++ b/tests/src/com/activeandroid/test/model/OneToManyTest.java
@@ -0,0 +1,35 @@
+package com.activeandroid.test.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.activeandroid.Model;
+import com.activeandroid.model.OneToManyRelation;
+import com.activeandroid.test.MockModel;
+
+public class OneToManyTest extends ModelTestCase {
+	
+	public static class MockOneToManyRelation extends OneToManyRelation<MockModel> {
+		public MockOneToManyRelation() {
+			super();
+		}
+	}
+	
+	public void testOneToManyRelation() {
+		
+		MockModel mockModelsHolder = new MockModel();
+		mockModelsHolder.save();
+		
+		List<Model> mockModels = new ArrayList<Model>();
+		for (int i = 0; i < 5; ++i) {
+			MockModel mockModel = new MockModel();
+			mockModel.save();
+			mockModels.add(mockModel);
+		}
+		
+		OneToManyRelation.setRelations(MockOneToManyRelation.class, mockModelsHolder, mockModels);
+		
+		mockModels = OneToManyRelation.getRelations(MockOneToManyRelation.class, mockModelsHolder);
+		assertTrue(mockModels.size() == 5);
+	}
+}
