diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 421426ea..6563dbe2 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -20,11 +20,15 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 
+import com.activeandroid.annotation.Column;
 import com.activeandroid.content.ContentProvider;
+import com.activeandroid.exceptions.IllegalUniqueIdentifierException;
+import com.activeandroid.exceptions.ModelUpdateException;
 import com.activeandroid.query.Delete;
 import com.activeandroid.query.Select;
 import com.activeandroid.serializer.TypeSerializer;
 import com.activeandroid.util.Log;
+import com.activeandroid.util.ModelUtils;
 import com.activeandroid.util.ReflectionUtils;
 
 import java.lang.reflect.Field;
@@ -35,286 +39,348 @@
 @SuppressWarnings("unchecked")
 public abstract class Model {
 
-	/** Prime number used for hashcode() implementation. */
-	private static final int HASH_PRIME = 739;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Long mId = null;
-
-	private final TableInfo mTableInfo;
-	private final String idName;
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Model() {
-		mTableInfo = Cache.getTableInfo(getClass());
-		idName = mTableInfo.getIdName();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public final Long getId() {
-		return mId;
-	}
-
-	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), idName+"=?", new String[] { getId().toString() });
-		Cache.removeEntity(this);
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-	}
-
-	public final Long save() {
-		final SQLiteDatabase db = Cache.openDatabase();
-		final ContentValues values = new ContentValues();
-
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-
-			field.setAccessible(true);
-
-			try {
-				Object value = field.get(this);
-
-				if (value != null) {
-					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-					if (typeSerializer != null) {
-						// serialize data
-						value = typeSerializer.serialize(value);
-						// set new object type
-						if (value != null) {
-							fieldType = value.getClass();
-							// check that the serializer returned what it promised
-							if (!fieldType.equals(typeSerializer.getSerializedType())) {
-								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-										typeSerializer.getSerializedType(), fieldType));
-							}
-						}
-					}
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (value == null) {
-					values.putNull(fieldName);
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					values.put(fieldName, (Byte) value);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					values.put(fieldName, (Short) value);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					values.put(fieldName, (Integer) value);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					values.put(fieldName, (Long) value);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					values.put(fieldName, (Float) value);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					values.put(fieldName, (Double) value);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					values.put(fieldName, (Boolean) value);
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(String.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					values.put(fieldName, (byte[]) value);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					values.put(fieldName, ((Model) value).getId());
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					values.put(fieldName, ((Enum<?>) value).name());
-				}
-			}
-			catch (IllegalArgumentException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-		}
-
-		if (mId == null) {
-			mId = db.insert(mTableInfo.getTableName(), null, values);
-		}
-		else {
-			db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
-		}
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-		return mId;
-	}
-
-	// Convenience methods
-
-	public static void delete(Class<? extends Model> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		new Delete().from(type).where(tableInfo.getIdName()+"=?", id).execute();
-	}
-
-	public static <T extends Model> T load(Class<T> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		return (T) new Select().from(type).where(tableInfo.getIdName()+"=?", id).executeSingle();
-	}
-
-	// Model population
-
-	public final void loadFromCursor(Cursor cursor) {
+    /**
+     * Prime number used for hashcode() implementation.
+     */
+    private static final int HASH_PRIME = 739;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Long mId = null;
+
+    private final TableInfo mTableInfo;
+    private final String idName;
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Model() {
+        mTableInfo = Cache.getTableInfo(getClass());
+        idName = mTableInfo.getIdName();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public final Long getId() {
+        return mId;
+    }
+
+    public final void delete() {
+        Cache.openDatabase().delete(mTableInfo.getTableName(), idName + "=?", new String[]{getId().toString()});
+        Cache.removeEntity(this);
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+    }
+
+    public final Long save() {
+        final SQLiteDatabase db = Cache.openDatabase();
+        final ContentValues values = new ContentValues();
+
+        for (Field field : mTableInfo.getFields()) {
+            final String fieldName = mTableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+
+            field.setAccessible(true);
+
+            try {
+                Object value = field.get(this);
+
+                if (value != null) {
+                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                    if (typeSerializer != null) {
+                        // serialize data
+                        value = typeSerializer.serialize(value);
+                        // set new object type
+                        if (value != null) {
+                            fieldType = value.getClass();
+                            // check that the serializer returned what it promised
+                            if (!fieldType.equals(typeSerializer.getSerializedType())) {
+                                Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                        typeSerializer.getSerializedType(), fieldType));
+                            }
+                        }
+                    }
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (value == null) {
+                    values.putNull(fieldName);
+                } else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    values.put(fieldName, (Byte) value);
+                } else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    values.put(fieldName, (Short) value);
+                } else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    values.put(fieldName, (Integer) value);
+                } else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    values.put(fieldName, (Long) value);
+                } else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    values.put(fieldName, (Float) value);
+                } else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    values.put(fieldName, (Double) value);
+                } else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    values.put(fieldName, (Boolean) value);
+                } else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    values.put(fieldName, value.toString());
+                } else if (fieldType.equals(String.class)) {
+                    values.put(fieldName, value.toString());
+                } else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    values.put(fieldName, (byte[]) value);
+                } else if (ReflectionUtils.isModel(fieldType)) {
+                    Model model = (Model) value;
+                    Long foreignkeyID = model.getId();
+                    if (foreignkeyID == null && field.getAnnotation(Column.class).autoCreate()) {
+                        model.save();
+                        foreignkeyID = model.getId();
+                    }
+                    values.put(fieldName, foreignkeyID);
+                } else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    values.put(fieldName, ((Enum<?>) value).name());
+                }
+            } catch (IllegalArgumentException e) {
+                Log.e(e.getClass().getName(), e);
+            } catch (IllegalAccessException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+
+        if (mId == null) {
+            mId = db.insert(mTableInfo.getTableName(), null, values);
+        } else {
+            db.update(mTableInfo.getTableName(), values, idName + "=" + mId, null);
+        }
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+        return mId;
+    }
+
+    // Convenience methods
+
+    public static void delete(Class<? extends Model> type, long id) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        new Delete().from(type).where(tableInfo.getIdName() + "=?", id).execute();
+    }
+
+    public static <T extends Model> T load(Class<T> type, long id) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        return (T) new Select().from(type).where(tableInfo.getIdName() + "=?", id).executeSingle();
+    }
+
+    // Model population
+
+    public final void loadFromCursor(Cursor cursor) {
         /**
          * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
          * when the cursor have multiple columns with same name obtained from join tables.
          */
         List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-			final int columnIndex = columnsOrdered.indexOf(fieldName);
-
-			if (columnIndex < 0) {
-				continue;
-			}
-
-			field.setAccessible(true);
-
-			try {
-				boolean columnIsNull = cursor.isNull(columnIndex);
-				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-				Object value = null;
-
-				if (typeSerializer != null) {
-					fieldType = typeSerializer.getSerializedType();
-				}
-
-				// TODO: Find a smarter way to do this? This if block is necessary because we
-				// can't know the type until runtime.
-				if (columnIsNull) {
-					field = null;
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					value = cursor.getInt(columnIndex);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					value = cursor.getLong(columnIndex);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					value = cursor.getFloat(columnIndex);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					value = cursor.getDouble(columnIndex);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					value = cursor.getInt(columnIndex) != 0;
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					value = cursor.getString(columnIndex).charAt(0);
-				}
-				else if (fieldType.equals(String.class)) {
-					value = cursor.getString(columnIndex);
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					value = cursor.getBlob(columnIndex);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					final long entityId = cursor.getLong(columnIndex);
-					final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
-
-					Model entity = Cache.getEntity(entityType, entityId);
-					if (entity == null) {
-						entity = new Select().from(entityType).where(idName+"=?", entityId).executeSingle();
-					}
-
-					value = entity;
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					@SuppressWarnings("rawtypes")
-					final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-					value = Enum.valueOf(enumType, cursor.getString(columnIndex));
-				}
-
-				// Use a deserializer if one is available
-				if (typeSerializer != null && !columnIsNull) {
-					value = typeSerializer.deserialize(value);
-				}
-
-				// Set the field value
-				if (value != null) {
-					field.set(this, value);
-				}
-			}
-			catch (IllegalArgumentException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-			catch (SecurityException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-		}
-
-		if (mId != null) {
-			Cache.addEntity(this);
-		}
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
-		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public String toString() {
-		return mTableInfo.getTableName() + "@" + getId();
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (obj instanceof Model && this.mId != null) {
-			final Model other = (Model) obj;
-
-			return this.mId.equals(other.mId)							
-							&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
-		} else {
-			return this == obj;
-		}
-	}
-
-	@Override
-	public int hashCode() {
-		int hash = HASH_PRIME;
-		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); //if id is null, use Object.hashCode()
-		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
-		return hash; //To change body of generated methods, choose Tools | Templates.
-	}
+        for (Field field : mTableInfo.getFields()) {
+            final String fieldName = mTableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+            final int columnIndex = columnsOrdered.indexOf(fieldName);
+
+            if (columnIndex < 0) {
+                continue;
+            }
+
+            field.setAccessible(true);
+
+            try {
+                boolean columnIsNull = cursor.isNull(columnIndex);
+                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                Object value = null;
+
+                if (typeSerializer != null) {
+                    fieldType = typeSerializer.getSerializedType();
+                }
+
+                // TODO: Find a smarter way to do this? This if block is necessary because we
+                // can't know the type until runtime.
+                if (columnIsNull) {
+                    field = null;
+                } else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
+                    value = cursor.getInt(columnIndex);
+                } else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
+                    value = cursor.getInt(columnIndex);
+                } else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
+                    value = cursor.getInt(columnIndex);
+                } else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
+                    value = cursor.getLong(columnIndex);
+                } else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
+                    value = cursor.getFloat(columnIndex);
+                } else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
+                    value = cursor.getDouble(columnIndex);
+                } else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
+                    value = cursor.getInt(columnIndex) != 0;
+                } else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
+                    value = cursor.getString(columnIndex).charAt(0);
+                } else if (fieldType.equals(String.class)) {
+                    value = cursor.getString(columnIndex);
+                } else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
+                    value = cursor.getBlob(columnIndex);
+                } else if (ReflectionUtils.isModel(fieldType)) {
+                    final long entityId = cursor.getLong(columnIndex);
+                    final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
+
+                    Model entity = Cache.getEntity(entityType, entityId);
+                    if (entity == null) {
+                        entity = new Select().from(entityType).where(idName + "=?", entityId).executeSingle();
+                    }
+
+                    value = entity;
+                } else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
+                    @SuppressWarnings("rawtypes")
+                    final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+                    value = Enum.valueOf(enumType, cursor.getString(columnIndex));
+                }
+
+                // Use a deserializer if one is available
+                if (typeSerializer != null && !columnIsNull) {
+                    value = typeSerializer.deserialize(value);
+                }
+
+                // Set the field value
+                if (value != null) {
+                    field.set(this, value);
+                }
+            } catch (IllegalArgumentException e) {
+                Log.e(e.getClass().getName(), e);
+            } catch (IllegalAccessException e) {
+                Log.e(e.getClass().getName(), e);
+            } catch (SecurityException e) {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+
+        if (mId != null) {
+            Cache.addEntity(this);
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PROTECTED METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
+        return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public String toString() {
+        return mTableInfo.getTableName() + "@" + getId();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof Model && this.mId != null) {
+            final Model other = (Model) obj;
+
+            return this.mId.equals(other.mId)
+                    && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
+        } else {
+            return this == obj;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = HASH_PRIME;
+        hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); //if id is null, use Object.hashCode()
+        hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
+        return hash; //To change body of generated methods, choose Tools | Templates.
+    }
+
+    /**
+     * Create or update a model entity. The table has to have an unique identifier registrated.
+     * The default unique identifier is the id column.
+     * If there are foreign keys you should wrap this method in a transaction.
+     *
+     * @param object
+     * @return the created/updated enity
+     * @throws IllegalUniqueIdentifierException
+     * @throws ModelUpdateException
+     */
+    public static <T extends Model> T createOrUpdate(T object) throws IllegalUniqueIdentifierException, ModelUpdateException {
+        Class<? extends Model> objectClass = object.getClass();
+        TableInfo info = Cache.getTableInfo(objectClass);
+        String uniqueIdentifier = info.getUniqueIdentifier();
+        T entity;
+        try {
+            Field f = objectClass.getDeclaredField(uniqueIdentifier);
+            String columnName = info.getColumnName(f);
+            f.setAccessible(true);
+            Object value = f.get(object);
+            entity = new Select().from(objectClass).where(columnName + "=?", value).executeSingle();
+        } catch (NoSuchFieldException e) {
+            throw new IllegalUniqueIdentifierException("Couldn't get the specified unique identifier", e);
+        } catch (IllegalAccessException e) {
+            throw new IllegalUniqueIdentifierException("Couldn't get the specified unique identifier", e);
+        }
+        List<Model> modelsToBeDeleted = new ArrayList<Model>();
+        if (entity != null) {
+            modelsToBeDeleted = entity.updateWith(object);
+        } else {
+            entity = object;
+        }
+        entity.save();
+        for (Model m : modelsToBeDeleted) {
+            m.delete();
+        }
+        return entity;
+    }
+
+    /**
+     * This method updates a model with another one.
+     *
+     * @param other
+     * @return Entities to delete. (Because they get exchanged).
+     * @throws ModelUpdateException
+     * @throws IllegalUniqueIdentifierException
+     */
+    protected List<Model> updateWith(Model other) throws ModelUpdateException, IllegalUniqueIdentifierException {
+        Class<? extends Model> myClass = getClass();
+        Class<? extends Model> otherClass = other.getClass();
+        ArrayList<Model> entitiesToBeDeleted = new ArrayList<Model>();
+        if (myClass.isAssignableFrom(otherClass)) {
+            fieldloop:
+            for (Field field : Cache.getTableInfo(myClass).getFields()) {
+                field.setAccessible(true);
+                try {
+                    Object newValue = field.get(other);
+                    Column annotation = field.getAnnotation(Column.class);
+                    Column.ModelUpdateAction modelUpdateAction = (annotation != null) ? annotation.onModelUpdate() : Column.ModelUpdateAction.NO_ACTION;
+                    switch (modelUpdateAction) {
+                        case NO_ACTION:
+                            continue fieldloop;
+                        case REPLACE:
+                            if (ModelUtils.isForeignKey(field)) {
+                                Model thisFieldValue = (Model) field.get(this);
+                                entitiesToBeDeleted.add(thisFieldValue);
+                            }
+                            break;
+                        case UPDATE:
+                            if (ModelUtils.isForeignKey(field)) {
+                                newValue = Model.createOrUpdate((Model) newValue);
+                            }
+                            break;
+
+                    }
+                    field.set(this, newValue);
+                } catch (IllegalAccessException e) {
+                    throw new ModelUpdateException("The update of field: " + field.getName() + "was not possible.", e);
+                }
+            }
+        }
+        return entitiesToBeDeleted;
+    }
 }
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/TableInfo.java
index 940a2623..36fa30cd 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/src/com/activeandroid/TableInfo.java
@@ -42,6 +42,9 @@
     private String mTableName;
     private String mIdName = Table.DEFAULT_ID_NAME;
 
+
+
+    private String mUniqueIdentifier = Table.DEFAULT_ID_NAME;
     private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
 
     //////////////////////////////////////////////////////////////////////////////////////
@@ -57,6 +60,10 @@ public TableInfo(Class<? extends Model> type) {
         if (tableAnnotation != null) {
             mTableName = tableAnnotation.name();
             mIdName = tableAnnotation.id();
+            mUniqueIdentifier = tableAnnotation.uniqueIdentifier();
+            if (mUniqueIdentifier.equals("")) {
+                mUniqueIdentifier = getIdField(type).getName();
+            }
             try {
                 Class<? extends ColumnNamingStrategy> namingClass = tableAnnotation.columnNaming();
                 namingStrategy = namingClass.newInstance();
@@ -128,4 +135,7 @@ private Field getIdField(Class<?> type) {
         return null;
     }
 
+    public String getUniqueIdentifier() {
+        return mUniqueIdentifier;
+    }
 }
diff --git a/src/com/activeandroid/annotation/Column.java b/src/com/activeandroid/annotation/Column.java
index 56bbcde8..a9b1d5af 100644
--- a/src/com/activeandroid/annotation/Column.java
+++ b/src/com/activeandroid/annotation/Column.java
@@ -24,13 +24,17 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Column {
-	public enum ConflictAction {
+
+    public enum ConflictAction {
 		ROLLBACK, ABORT, FAIL, IGNORE, REPLACE
 	}
 
 	public enum ForeignKeyAction {
 		SET_NULL, SET_DEFAULT, CASCADE, RESTRICT, NO_ACTION
 	}
+    public enum ModelUpdateAction {
+        UPDATE, REPLACE, NO_ACTION
+    }
 
 	public String name() default "";
 
@@ -44,7 +48,11 @@
 
 	public ForeignKeyAction onUpdate() default ForeignKeyAction.NO_ACTION;
 
-	public boolean unique() default false;
+    public boolean autoCreate() default false;
+
+    public ModelUpdateAction onModelUpdate() default ModelUpdateAction.NO_ACTION;
+
+    public boolean unique() default false;
 
 	public ConflictAction onUniqueConflict() default ConflictAction.FAIL;
 
@@ -107,4 +115,6 @@
 	 * Execute CREATE INDEX index_table_name_group2 on table_name(member2, member3)
 	 */
 	public String[] indexGroups() default {};
+
+
 }
diff --git a/src/com/activeandroid/annotation/Table.java b/src/com/activeandroid/annotation/Table.java
index 34dbe7f7..d414cbb2 100644
--- a/src/com/activeandroid/annotation/Table.java
+++ b/src/com/activeandroid/annotation/Table.java
@@ -32,4 +32,5 @@
 	public String name();
 	public String id() default DEFAULT_ID_NAME;
     public Class <? extends ColumnNamingStrategy> columnNaming() default FieldNamingStrategy.class;
+    public String uniqueIdentifier() default "";
 }
diff --git a/src/com/activeandroid/exceptions/IllegalUniqueIdentifierException.java b/src/com/activeandroid/exceptions/IllegalUniqueIdentifierException.java
new file mode 100644
index 00000000..7d7f66e7
--- /dev/null
+++ b/src/com/activeandroid/exceptions/IllegalUniqueIdentifierException.java
@@ -0,0 +1,11 @@
+package com.activeandroid.exceptions;
+
+/**
+ * Created by melbic on 22/08/14.
+ */
+public class IllegalUniqueIdentifierException extends Exception {
+
+    public IllegalUniqueIdentifierException(String s, Throwable e) {
+        super(s,e);
+    }
+}
diff --git a/src/com/activeandroid/exceptions/ModelUpdateException.java b/src/com/activeandroid/exceptions/ModelUpdateException.java
new file mode 100644
index 00000000..9ccbf27b
--- /dev/null
+++ b/src/com/activeandroid/exceptions/ModelUpdateException.java
@@ -0,0 +1,10 @@
+package com.activeandroid.exceptions;
+
+/**
+ * Created by melbic on 25/08/14.
+ */
+public class ModelUpdateException extends Throwable {
+    public ModelUpdateException(String s, Throwable e) {
+        super(s,e);
+    }
+}
diff --git a/src/com/activeandroid/naming/AndroidNamingStrategy.java b/src/com/activeandroid/naming/AndroidNamingStrategy.java
index 98c0f092..70c04645 100644
--- a/src/com/activeandroid/naming/AndroidNamingStrategy.java
+++ b/src/com/activeandroid/naming/AndroidNamingStrategy.java
@@ -10,6 +10,9 @@
     @Override
     public String translateName(Field f) {
         String columnName = f.getName();
+        if(columnName.equals("_id")){
+            return columnName;
+        }
         if (columnName.charAt(0) == 'm' && columnName.length() > 1 && Character.isUpperCase(columnName.codePointAt(1))) {
             columnName = columnName.substring(1);
         }
diff --git a/src/com/activeandroid/util/ModelUtils.java b/src/com/activeandroid/util/ModelUtils.java
new file mode 100644
index 00000000..bd31613c
--- /dev/null
+++ b/src/com/activeandroid/util/ModelUtils.java
@@ -0,0 +1,21 @@
+package com.activeandroid.util;
+
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Table;
+
+import java.lang.reflect.Field;
+
+/**
+ * Created by melbic on 25/08/14.
+ */
+public abstract class ModelUtils {
+    /**
+     * Check if a field is a Foreignkey
+     * @param field
+     * @return
+     */
+    public static boolean isForeignKey(Field field) {
+        return Model.class.isAssignableFrom(field.getType());
+    }
+}
