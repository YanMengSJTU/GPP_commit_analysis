diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index 1672cacb..ef00bab1 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -58,22 +58,22 @@ public TypeInfo(SQLiteType type, int typeFlag) {
     }
     
     //////////////////////////////////////////////////////////////////////////////////////
-	// ENUMERATIONS
-	//////////////////////////////////////////////////////////////////////////////////////
+    // ENUMERATIONS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public enum SQLiteType {
-		INTEGER, REAL, TEXT, BLOB
-	}
+    public enum SQLiteType {
+        INTEGER, REAL, TEXT, BLOB
+    }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+    public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONTSANTS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE CONTSANTS
+    //////////////////////////////////////////////////////////////////////////////////////
 
     @SuppressWarnings("serial")
     private static final HashMap<Class<?>, TypeInfo> TYPE_MAP = new HashMap<Class<?>, TypeInfo>() {
@@ -100,9 +100,9 @@ public TypeInfo(SQLiteType type, int typeFlag) {
         }
     };
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
 
     public static void put(ContentValues values, Class<?> fieldType, String fieldName, Object value) {
         if (value == null) {
@@ -201,45 +201,45 @@ public static Object get(Cursor cursor, Class<?> fieldType, int columnIndex) {
         }
         return null;
     }
-	
-	public static void execSql(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSql(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-
-	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-		List<T> entities = processCursor(type, cursor);
-		cursor.close();
-
-		return entities;
-	}
-	  
-	public static int intQuery(final String sql, final String[] selectionArgs) {
+    
+    public static void execSql(String sql) {
+        Cache.openDatabase().execSQL(sql);
+    }
+
+    public static void execSql(String sql, Object[] bindArgs) {
+        Cache.openDatabase().execSQL(sql, bindArgs);
+    }
+
+    public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
+        Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+        List<T> entities = processCursor(type, cursor);
+        cursor.close();
+
+        return entities;
+    }
+      
+    public static int intQuery(final String sql, final String[] selectionArgs) {
         final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
         final int number = processIntCursor(cursor);
         cursor.close();
 
         return number;
-	}
+    }
 
-	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		List<T> entities = rawQuery(type, sql, selectionArgs);
+    public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
+        List<T> entities = rawQuery(type, sql, selectionArgs);
 
-		if (entities.size() > 0) {
-			return entities.get(0);
-		}
+        if (entities.size() > 0) {
+            return entities.get(0);
+        }
 
-		return null;
-	}
+        return null;
+    }
 
-	// Database creation
+    // Database creation
 
-	public static List<String> createUniqueDefinitions(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
+    public static List<String> createUniqueDefinitions(TableInfo tableInfo) {
+        final ArrayList<String> definitions = new ArrayList<String>();
         final String tableName = tableInfo.getTableName();
 
         for (Field field : tableInfo.getFields()){
@@ -268,10 +268,10 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
             indexIndex++;
         }
 
-		return definitions;
-	}
+        return definitions;
+    }
 
-	public static List<String> createIndexDefinitions(TableInfo tableInfo) {
+    public static List<String> createIndexDefinitions(TableInfo tableInfo) {
         final ArrayList<String> definitions = new ArrayList<String>();
         final String tableName = tableInfo.getTableName();
 
@@ -281,7 +281,7 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
                 continue;
             String columnName = tableInfo.getColumnName(field);
             definitions.add(String.format("CREATE INDEX IF NOT EXISTS index_%s_%s on %s(%s);",
-                                          tableInfo.getTableName(), columnName,
+                                          tableName, columnName,
                                           tableName,
                                           columnName));
         }
@@ -294,133 +294,133 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
                 continue;
             String indexName = TextUtils.isEmpty(index.name()) ? String.valueOf(indexIndex) : index.name();
             definitions.add(String.format("CREATE INDEX IF NOT EXISTS index_%s_%s on %s(%s);",
-                                          tableInfo.getTableName(), indexName,
+                                          tableName, indexName,
                                           tableName,
                                           TextUtils.join(", ", index.columns())));
             indexIndex++;
         }
 
         return definitions;
-	}
+    }
 
-	public static String createTableDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
+    public static String createTableDefinition(TableInfo tableInfo) {
+        final ArrayList<String> definitions = new ArrayList<String>();
 
-		for (Field field : tableInfo.getFields()) {
-			String definition = createColumnDefinition(tableInfo, field);
-			if (!TextUtils.isEmpty(definition)) {
-				definitions.add(definition);
-			}
-		}
+        for (Field field : tableInfo.getFields()) {
+            String definition = createColumnDefinition(tableInfo, field);
+            if (!TextUtils.isEmpty(definition)) {
+                definitions.add(definition);
+            }
+        }
 
-		definitions.addAll(createUniqueDefinitions(tableInfo));
+        definitions.addAll(createUniqueDefinitions(tableInfo));
 
-		return String.format(
-            "CREATE TABLE IF NOT EXISTS %s (\n%s);",
+        return String.format(
+            "CREATE TABLE IF NOT EXISTS %s (\n\t%s\n);",
             tableInfo.getTableName(),
-            TextUtils.join(",\n", definitions)
+            TextUtils.join(",\n\t", definitions)
         );
-	}
-
-	@SuppressWarnings("unchecked")
-	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
-		StringBuilder definition = new StringBuilder();
-
-		Class<?> type = field.getType();
-		final String name = tableInfo.getColumnName(field);
-		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-		final Column column = field.getAnnotation(Column.class);
-
-		if (typeSerializer != null) {
-			type = typeSerializer.getSerializedType();
-		}
-
-		TypeInfo typeInfo = TYPE_MAP.get(type);
-		if (typeInfo != null) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(typeInfo.type.toString());
-		}
-		else if (ReflectionUtils.isModel(type)) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(SQLiteType.INTEGER.toString());
-		}
-		else if (Enum.class.isAssignableFrom(type)){
-			definition.append(name);
-			definition.append(" ");
-			definition.append(SQLiteType.TEXT.toString());
-		}
-
-		if (!TextUtils.isEmpty(definition)) {
-
-			if (name.equals(tableInfo.getIdName())) {
-				definition.append(" PRIMARY KEY AUTOINCREMENT");
-			}else if(column!=null){
-				if (column.length() > -1) {
-					definition.append("(");
-					definition.append(column.length());
-					definition.append(")");
-				}
-
-				if (column.notNull()) {
-					definition.append(" NOT NULL ON CONFLICT ");
-					definition.append(column.onNullConflict().toString());
-				}
-
-				if (column.unique()) {
-					definition.append(" UNIQUE ON CONFLICT ");
-					definition.append(column.onUniqueConflict().toString());
-				}
-			}
-
-			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
-				definition.append(" REFERENCES ");
-				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
-				definition.append("(").append(tableInfo.getIdName()).append(")");
-				definition.append(" ON DELETE ");
-				definition.append(column.onDelete().toString().replace("_", " "));
-				definition.append(" ON UPDATE ");
-				definition.append(column.onUpdate().toString().replace("_", " "));
-			}
-		}
-		else {
-			Log.e("No type mapping for: " + type.toString());
-		}
-
-		return definition.toString();
-	}
-
-	@SuppressWarnings("unchecked")
-	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		String idName = tableInfo.getIdName();
-		final List<T> entities = new ArrayList<T>();
-
-		try {
-			Constructor<?> entityConstructor = type.getConstructor();
-
-			if (cursor.moveToFirst()) {
+    }
+
+    @SuppressWarnings("unchecked")
+    public static String createColumnDefinition(TableInfo tableInfo, Field field) {
+        StringBuilder definition = new StringBuilder();
+
+        Class<?> type = field.getType();
+        final String name = tableInfo.getColumnName(field);
+        final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
+        final Column column = field.getAnnotation(Column.class);
+
+        if (typeSerializer != null) {
+            type = typeSerializer.getSerializedType();
+        }
+
+        TypeInfo typeInfo = TYPE_MAP.get(type);
+        if (typeInfo != null) {
+            definition.append(name);
+            definition.append(" ");
+            definition.append(typeInfo.type.toString());
+        }
+        else if (ReflectionUtils.isModel(type)) {
+            definition.append(name);
+            definition.append(" ");
+            definition.append(SQLiteType.INTEGER.toString());
+        }
+        else if (Enum.class.isAssignableFrom(type)){
+            definition.append(name);
+            definition.append(" ");
+            definition.append(SQLiteType.TEXT.toString());
+        }
+
+        if (!TextUtils.isEmpty(definition)) {
+
+            if (name.equals(tableInfo.getIdName())) {
+                definition.append(" PRIMARY KEY AUTOINCREMENT");
+            }else if(column!=null){
+                if (column.length() > -1) {
+                    definition.append("(");
+                    definition.append(column.length());
+                    definition.append(")");
+                }
+
+                if (column.notNull()) {
+                    definition.append(" NOT NULL ON CONFLICT ");
+                    definition.append(column.onNullConflict().toString());
+                }
+
+                if (column.unique()) {
+                    definition.append(" UNIQUE ON CONFLICT ");
+                    definition.append(column.onUniqueConflict().toString());
+                }
+            }
+
+            if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
+                definition.append(" REFERENCES ");
+                definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
+                definition.append("(").append(tableInfo.getIdName()).append(")");
+                definition.append(" ON DELETE ");
+                definition.append(column.onDelete().toString().replace("_", " "));
+                definition.append(" ON UPDATE ");
+                definition.append(column.onUpdate().toString().replace("_", " "));
+            }
+        }
+        else {
+            Log.e("No type mapping for: " + type.toString());
+        }
+
+        return definition.toString();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        String idName = tableInfo.getIdName();
+        final List<T> entities = new ArrayList<T>();
+
+        try {
+            Constructor<?> entityConstructor = type.getConstructor();
+
+            if (cursor.moveToFirst()) {
                 /**
                  * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
                  * when the cursor have multiple columns with same name obtained from join tables.
                  */
                 String[] columnsOrdered = cursor.getColumnNames();
-				do {
-					Model entity = Cache.getEntity(type, cursor.getLong(indexOfIgnoreCase(columnsOrdered, idName)));
-					if (entity == null) {
-						entity = (T) entityConstructor.newInstance();
-					}
-
-					entity.loadFromCursor(cursor);
-					entities.add((T) entity);
-				}
-				while (cursor.moveToNext());
-			}
-
-		}
-		catch (NoSuchMethodException e) {
-			throw new RuntimeException(
+                do {
+                    Model entity = Cache.getEntity(type, cursor.getLong(indexOfIgnoreCase(columnsOrdered, idName)));
+                    if (entity == null) {
+                        entity = (T) entityConstructor.newInstance();
+                    }
+
+                    entity.loadFromCursor(cursor);
+                    entities.add((T) entity);
+                }
+                while (cursor.moveToNext());
+            }
+
+        }
+        catch (NoSuchMethodException e) {
+            throw new RuntimeException(
                 "Your model " + type.getName() + " does not define a default " +
                 "constructor. The default constructor is required for " +
                 "now in ActiveAndroid models, as the process to " +
@@ -428,56 +428,56 @@ else if (Enum.class.isAssignableFrom(type)){
                 "1. instantiate default model " +
                 "2. populate fields"
             );
-		}
-		catch (Exception e) {
-			Log.e("Failed to process cursor.", e);
-		}
+        }
+        catch (Exception e) {
+            Log.e("Failed to process cursor.", e);
+        }
 
-		return entities;
-	}
+        return entities;
+    }
 
-	private static int processIntCursor(final Cursor cursor) {
+    private static int processIntCursor(final Cursor cursor) {
         if (cursor.moveToFirst()) {
             return cursor.getInt(0);
-	    }
+        }
         return 0;
     }
 
-	public static List<String> lexSqlScript(String sqlScript) {
-		ArrayList<String> sl = new ArrayList<String>();
-		boolean inString = false, escapeNext = false;
-		final int len = sqlScript.length();
-		int start = 0;
-		
-		for (int i = 0; i < len; i++) {
-			final char c = sqlScript.charAt(i);
-
-			switch(c) {
-			case ';':
-			    if (!inString && !escapeNext) {
-			        sl.add(sqlScript.substring(start, i));
-			        start = i + 1;
-			    }
-			    escapeNext = false;
-			    break;
-			case '\'':
-			    if (!escapeNext)
-			        inString = !inString;
-			    escapeNext = false;
-			    break;
-			case '\\':
-			    escapeNext = !escapeNext;
-			    break;
-			}
-		}
-
-		if (start < len) {
-			sl.add(sqlScript.substring(start));
-		}
-
-		return sl;
-	}
-	
+    public static List<String> lexSqlScript(String sqlScript) {
+        ArrayList<String> sl = new ArrayList<String>();
+        boolean inString = false, escapeNext = false;
+        final int len = sqlScript.length();
+        int start = 0;
+        
+        for (int i = 0; i < len; i++) {
+            final char c = sqlScript.charAt(i);
+
+            switch(c) {
+            case ';':
+                if (!inString && !escapeNext) {
+                    sl.add(sqlScript.substring(start, i));
+                    start = i + 1;
+                }
+                escapeNext = false;
+                break;
+            case '\'':
+                if (!escapeNext)
+                    inString = !inString;
+                escapeNext = false;
+                break;
+            case '\\':
+                escapeNext = !escapeNext;
+                break;
+            }
+        }
+
+        if (start < len) {
+            sl.add(sqlScript.substring(start));
+        }
+
+        return sl;
+    }
+    
     public static int indexOfIgnoreCase(String[] strs, String find) {
         final int len = strs.length;
         if (find != null) {
