diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 699bbad8..6563dbe2 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -21,7 +21,6 @@
 import android.database.sqlite.SQLiteDatabase;
 
 import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
 import com.activeandroid.content.ContentProvider;
 import com.activeandroid.exceptions.IllegalUniqueIdentifierException;
 import com.activeandroid.exceptions.ModelUpdateException;
@@ -29,9 +28,9 @@
 import com.activeandroid.query.Select;
 import com.activeandroid.serializer.TypeSerializer;
 import com.activeandroid.util.Log;
+import com.activeandroid.util.ModelUtils;
 import com.activeandroid.util.ReflectionUtils;
 
-import java.io.Serializable;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -301,9 +300,19 @@ public int hashCode() {
         return hash; //To change body of generated methods, choose Tools | Templates.
     }
 
+    /**
+     * Create or update a model entity. The table has to have an unique identifier registrated.
+     * The default unique identifier is the id column.
+     * If there are foreign keys you should wrap this method in a transaction.
+     *
+     * @param object
+     * @return the created/updated enity
+     * @throws IllegalUniqueIdentifierException
+     * @throws ModelUpdateException
+     */
     public static <T extends Model> T createOrUpdate(T object) throws IllegalUniqueIdentifierException, ModelUpdateException {
         Class<? extends Model> objectClass = object.getClass();
-        TableInfo info = new TableInfo(objectClass);
+        TableInfo info = Cache.getTableInfo(objectClass);
         String uniqueIdentifier = info.getUniqueIdentifier();
         T entity;
         try {
@@ -317,30 +326,61 @@ public int hashCode() {
         } catch (IllegalAccessException e) {
             throw new IllegalUniqueIdentifierException("Couldn't get the specified unique identifier", e);
         }
+        List<Model> modelsToBeDeleted = new ArrayList<Model>();
         if (entity != null) {
-            entity.updateWith(object);
+            modelsToBeDeleted = entity.updateWith(object);
         } else {
             entity = object;
         }
         entity.save();
+        for (Model m : modelsToBeDeleted) {
+            m.delete();
+        }
         return entity;
     }
 
-    protected void updateWith(Model other) throws ModelUpdateException {
+    /**
+     * This method updates a model with another one.
+     *
+     * @param other
+     * @return Entities to delete. (Because they get exchanged).
+     * @throws ModelUpdateException
+     * @throws IllegalUniqueIdentifierException
+     */
+    protected List<Model> updateWith(Model other) throws ModelUpdateException, IllegalUniqueIdentifierException {
         Class<? extends Model> myClass = getClass();
         Class<? extends Model> otherClass = other.getClass();
+        ArrayList<Model> entitiesToBeDeleted = new ArrayList<Model>();
         if (myClass.isAssignableFrom(otherClass)) {
+            fieldloop:
             for (Field field : Cache.getTableInfo(myClass).getFields()) {
                 field.setAccessible(true);
                 try {
-                    Object otherFieldValue = field.get(other);
-                    if (otherFieldValue != null) {
-                        field.set(this, otherFieldValue);
+                    Object newValue = field.get(other);
+                    Column annotation = field.getAnnotation(Column.class);
+                    Column.ModelUpdateAction modelUpdateAction = (annotation != null) ? annotation.onModelUpdate() : Column.ModelUpdateAction.NO_ACTION;
+                    switch (modelUpdateAction) {
+                        case NO_ACTION:
+                            continue fieldloop;
+                        case REPLACE:
+                            if (ModelUtils.isForeignKey(field)) {
+                                Model thisFieldValue = (Model) field.get(this);
+                                entitiesToBeDeleted.add(thisFieldValue);
+                            }
+                            break;
+                        case UPDATE:
+                            if (ModelUtils.isForeignKey(field)) {
+                                newValue = Model.createOrUpdate((Model) newValue);
+                            }
+                            break;
+
                     }
+                    field.set(this, newValue);
                 } catch (IllegalAccessException e) {
                     throw new ModelUpdateException("The update of field: " + field.getName() + "was not possible.", e);
                 }
             }
         }
+        return entitiesToBeDeleted;
     }
 }
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/TableInfo.java
index d69e9020..36fa30cd 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/src/com/activeandroid/TableInfo.java
@@ -61,8 +61,8 @@ public TableInfo(Class<? extends Model> type) {
             mTableName = tableAnnotation.name();
             mIdName = tableAnnotation.id();
             mUniqueIdentifier = tableAnnotation.uniqueIdentifier();
-            if (mUniqueIdentifier.equals(Table.DEFAULT_ID_NAME)) {
-                mUniqueIdentifier = mIdName;
+            if (mUniqueIdentifier.equals("")) {
+                mUniqueIdentifier = getIdField(type).getName();
             }
             try {
                 Class<? extends ColumnNamingStrategy> namingClass = tableAnnotation.columnNaming();
diff --git a/src/com/activeandroid/annotation/Column.java b/src/com/activeandroid/annotation/Column.java
index 68f6e633..a9b1d5af 100644
--- a/src/com/activeandroid/annotation/Column.java
+++ b/src/com/activeandroid/annotation/Column.java
@@ -24,13 +24,17 @@
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Column {
-	public enum ConflictAction {
+
+    public enum ConflictAction {
 		ROLLBACK, ABORT, FAIL, IGNORE, REPLACE
 	}
 
 	public enum ForeignKeyAction {
 		SET_NULL, SET_DEFAULT, CASCADE, RESTRICT, NO_ACTION
 	}
+    public enum ModelUpdateAction {
+        UPDATE, REPLACE, NO_ACTION
+    }
 
 	public String name() default "";
 
@@ -46,7 +50,9 @@
 
     public boolean autoCreate() default false;
 
-	public boolean unique() default false;
+    public ModelUpdateAction onModelUpdate() default ModelUpdateAction.NO_ACTION;
+
+    public boolean unique() default false;
 
 	public ConflictAction onUniqueConflict() default ConflictAction.FAIL;
 
@@ -109,4 +115,6 @@
 	 * Execute CREATE INDEX index_table_name_group2 on table_name(member2, member3)
 	 */
 	public String[] indexGroups() default {};
+
+
 }
diff --git a/src/com/activeandroid/util/ModelUtils.java b/src/com/activeandroid/util/ModelUtils.java
new file mode 100644
index 00000000..bd31613c
--- /dev/null
+++ b/src/com/activeandroid/util/ModelUtils.java
@@ -0,0 +1,21 @@
+package com.activeandroid.util;
+
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.annotation.Table;
+
+import java.lang.reflect.Field;
+
+/**
+ * Created by melbic on 25/08/14.
+ */
+public abstract class ModelUtils {
+    /**
+     * Check if a field is a Foreignkey
+     * @param field
+     * @return
+     */
+    public static boolean isForeignKey(Field field) {
+        return Model.class.isAssignableFrom(field.getType());
+    }
+}
