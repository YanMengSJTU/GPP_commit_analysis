diff --git a/src/META-INF/MANIFEST.MF b/src/META-INF/MANIFEST.MF
new file mode 100644
index 00000000..ef62bb7b
--- /dev/null
+++ b/src/META-INF/MANIFEST.MF
@@ -0,0 +1,3 @@
+Manifest-Version: 1.0
+Main-Class: 
+
diff --git a/src/com/activeandroid/DatabaseHelper.java b/src/com/activeandroid/DatabaseHelper.java
index b5844891..aa012665 100644
--- a/src/com/activeandroid/DatabaseHelper.java
+++ b/src/com/activeandroid/DatabaseHelper.java
@@ -33,7 +33,6 @@
 import android.database.sqlite.SQLiteOpenHelper;
 
 import com.activeandroid.migration.Migration;
-import com.activeandroid.migration.MigrationOperation;
 import com.activeandroid.util.*;
 
 public final class DatabaseHelper extends SQLiteOpenHelper {
@@ -46,15 +45,12 @@
 
 	private final static String MIGRATION_PATH = "migrations";
 
-    private Context mContext;
-
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	public DatabaseHelper(Context context) {
 		super(context, getDbName(context), null, getDbVersion(context));
-        mContext = context;
 		copyAttachedDatabase(context);
 	}
 
@@ -78,7 +74,7 @@ public void onCreate(SQLiteDatabase db) {
 		db.setTransactionSuccessful();
 		db.endTransaction();
 
-		executeMigrations(db, -1, db.getVersion());
+		executeNamedMigrations(db, -1, db.getVersion());
 	}
 
 	@Override
@@ -88,7 +84,7 @@ public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 			Log.i("Foreign Keys supported. Enabling foreign key features.");
 		}
 
-		if (!executeMigrations(db, oldVersion, newVersion)) {
+		if (!executeNamedMigrations(db, oldVersion, newVersion)) {
 			Log.i("No migrations found. Calling onCreate.");
 			onCreate(db);
 		}
@@ -138,7 +134,7 @@ public void copyAttachedDatabase(Context context) {
     private boolean executeNamedMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
         boolean migrationExecuted = false;
 
-        List<Migration> migrations = MigrationUtils.getMigrations(mContext, oldVersion, newVersion);
+        List<Migration> migrations = MigrationUtils.getMigrations(Cache.getContext(), oldVersion, newVersion);
         Collections.sort(migrations, new Comparator<Migration>() {
             @Override
             public int compare(Migration migration, Migration migration2) {
diff --git a/src/com/activeandroid/util/MigrationUtils.java b/src/com/activeandroid/util/MigrationUtils.java
index 05a159b7..995b7a71 100644
--- a/src/com/activeandroid/util/MigrationUtils.java
+++ b/src/com/activeandroid/util/MigrationUtils.java
@@ -20,10 +20,10 @@
         try {
 
             String migrationPackage = ReflectionUtils.getMetaData(context, AA_MIGRATION_PACKAGE);
-            Class[] migrationClasses = ReflectionUtils.findClasses(migrationPackage);
+            ArrayList<Class> migrationClasses = ReflectionUtils.findClasses(context, migrationPackage);
 
             for(Class c : migrationClasses) {
-                if (c.isAssignableFrom(Migration.class)) {
+                if (ReflectionUtils.isSubclassOf(c, Migration.class)) {
                     Migration m = (Migration)c.newInstance();
                     if (m.databaseVersion() > oldVersion && m.databaseVersion() <= newVersion) {
                         migrations.add(m);
@@ -31,8 +31,6 @@
                 }
             }
 
-        } catch (ClassNotFoundException e) {
-            e.printStackTrace();
         } catch (IOException e) {
             e.printStackTrace();
         } catch (InstantiationException e) {
@@ -47,11 +45,12 @@
     public static String[] migrationOperationsToSql(MigrationOperation[] ops) {
         if (ops == null) return null;
 
-        ArrayList<String> statements = new ArrayList<String>(ops.length);
-        for (MigrationOperation op : ops) {
-            statements.add(op.toSqlString());
+        String[] statements = new String[ops.length];
+        for (int i = 0; i < ops.length; i++) {
+            statements[i] = ops[i].toSqlString();
         }
-        return (String[]) statements.toArray();
+
+        return statements;
     }
 
 }
diff --git a/src/com/activeandroid/util/ReflectionUtils.java b/src/com/activeandroid/util/ReflectionUtils.java
index 073c12b8..e881f9cd 100644
--- a/src/com/activeandroid/util/ReflectionUtils.java
+++ b/src/com/activeandroid/util/ReflectionUtils.java
@@ -21,7 +21,11 @@
 import android.content.pm.PackageManager;
 
 import com.activeandroid.Model;
+import com.activeandroid.TableInfo;
+import com.activeandroid.app.Application;
+import com.activeandroid.migration.Migration;
 import com.activeandroid.serializer.TypeSerializer;
+import dalvik.system.DexFile;
 
 import java.io.File;
 import java.io.IOException;
@@ -62,21 +66,83 @@ public static boolean isTypeSerializer(Class<?> type) {
 		return null;
 	}
 
-    public static Class[] findClasses(String packageName) throws ClassNotFoundException, IOException {
-        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-        assert classLoader != null;
-        String path = packageName.replace('.', '/');
-        Enumeration<URL> resources = classLoader.getResources(path);
-        List<File> dirs = new ArrayList<File>();
-        while (resources.hasMoreElements()) {
-            URL resource = resources.nextElement();
-            dirs.add(new File(resource.getFile()));
+    public static ArrayList<Class> findClasses(Context application, String packageName) throws IOException {
+        String sourcePath = application.getApplicationInfo().sourceDir;
+        List<String> paths = new ArrayList<String>();
+
+        if (sourcePath != null) {
+            DexFile dexfile = new DexFile(sourcePath);
+            Enumeration<String> entries = dexfile.entries();
+
+            while (entries.hasMoreElements()) {
+                paths.add(entries.nextElement());
+            }
         }
+        // Robolectric fallback
+        else {
+            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+            Enumeration<URL> resources = classLoader.getResources("");
+
+            while (resources.hasMoreElements()) {
+                String path = resources.nextElement().getFile();
+                if (path.contains("bin")) {
+                    paths.add(path);
+                }
+            }
+        }
+
         ArrayList<Class> classes = new ArrayList<Class>();
-        for (File directory : dirs) {
-            classes.addAll(findClasses(directory, packageName));
+
+        for (String path : paths) {
+            File file = new File(path);
+            classes.addAll(findClassesInPath(file, packageName, application.getClass().getClassLoader()));
         }
-        return classes.toArray(new Class[classes.size()]);
+
+        return classes;
+    }
+
+    private static List<Class> findClassesInPath(File path, String packageName, ClassLoader classLoader) {
+        ArrayList<Class> classes = new ArrayList<Class>();
+
+        if (path.isDirectory()) {
+            for (File file : path.listFiles()) {
+                classes.addAll(findClassesInPath(file, packageName, classLoader));
+            }
+        }
+        else {
+            String className = path.getName();
+
+            // Robolectric fallback
+            if (!path.getPath().equals(className)) {
+                className = path.getPath();
+
+                if (className.endsWith(".class")) {
+                    className = className.substring(0, className.length() - 6);
+                }
+                else {
+                    return classes;
+                }
+
+                className = className.replace("/", ".");
+
+                int packageNameIndex = className.lastIndexOf(packageName);
+                if (packageNameIndex < 0) {
+                    return classes;
+                }
+
+                className = className.substring(packageNameIndex);
+            }
+
+            try {
+                Class<?> discoveredClass = Class.forName(className, false, classLoader);
+                classes.add(discoveredClass);
+            }
+            catch (ClassNotFoundException e) {
+                Log.e("Couldn't create class.", e);
+            }
+        }
+
+        return classes;
     }
 
 
