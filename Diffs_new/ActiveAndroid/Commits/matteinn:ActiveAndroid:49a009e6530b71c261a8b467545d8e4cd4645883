diff --git a/src/com/activeandroid/util/LRUCache.java b/src/com/activeandroid/util/LRUCache.java
index a7587980..e7a47721 100644
--- a/src/com/activeandroid/util/LRUCache.java
+++ b/src/com/activeandroid/util/LRUCache.java
@@ -2,7 +2,12 @@
 
 import java.util.LinkedHashMap;
 import java.util.Map;
+
 /**
+ * BEGIN LAYOUTLIB CHANGE
+ * This is a custom version that doesn't use the non standard LinkedHashMap#eldest.
+ * END LAYOUTLIB CHANGE
+ *
  * A cache that holds strong references to a limited number of values. Each time
  * a value is accessed, it is moved to the head of a queue. When a value is
  * added to a full cache, the value at the end of that queue is evicted and may
@@ -43,16 +48,18 @@
  * Support Package</a> for earlier releases.
  */
 public class LruCache<K, V> {
-
     private final LinkedHashMap<K, V> map;
+
     /** Size of this cache in units. Not necessarily the number of elements. */
     private int size;
     private int maxSize;
+
     private int putCount;
     private int createCount;
     private int evictionCount;
     private int hitCount;
     private int missCount;
+
     /**
      * @param maxSize for caches that do not override {@link #sizeOf}, this is
      *     the maximum number of entries in the cache. For all other caches,
@@ -65,20 +72,24 @@ public LruCache(int maxSize) {
         this.maxSize = maxSize;
         this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
     }
+
     /**
      * Sets the size of the cache.
-     *
      * @param maxSize The new maximum size.
+     *
+     * @hide
      */
     public void resize(int maxSize) {
         if (maxSize <= 0) {
             throw new IllegalArgumentException("maxSize <= 0");
         }
+
         synchronized (this) {
             this.maxSize = maxSize;
         }
         trimToSize(maxSize);
     }
+
     /**
      * Returns the value for {@code key} if it exists in the cache or can be
      * created by {@code #create}. If a value was returned, it is moved to the
@@ -89,6 +100,7 @@ public final V get(K key) {
         if (key == null) {
             throw new NullPointerException("key == null");
         }
+
         V mapValue;
         synchronized (this) {
             mapValue = map.get(key);
@@ -98,19 +110,23 @@ public final V get(K key) {
             }
             missCount++;
         }
+
         /*
          * Attempt to create a value. This may take a long time, and the map
          * may be different when create() returns. If a conflicting value was
          * added to the map while create() was working, we leave that value in
          * the map and release the created value.
          */
+
         V createdValue = create(key);
         if (createdValue == null) {
             return null;
         }
+
         synchronized (this) {
             createCount++;
             mapValue = map.put(key, createdValue);
+
             if (mapValue != null) {
                 // There was a conflict so undo that last put
                 map.put(key, mapValue);
@@ -118,6 +134,7 @@ public final V get(K key) {
                 size += safeSizeOf(key, createdValue);
             }
         }
+
         if (mapValue != null) {
             entryRemoved(false, key, createdValue, mapValue);
             return mapValue;
@@ -126,6 +143,7 @@ public final V get(K key) {
             return createdValue;
         }
     }
+
     /**
      * Caches {@code value} for {@code key}. The value is moved to the head of
      * the queue.
@@ -136,6 +154,7 @@ public final V put(K key, V value) {
         if (key == null || value == null) {
             throw new NullPointerException("key == null || value == null");
         }
+
         V previous;
         synchronized (this) {
             putCount++;
@@ -145,20 +164,20 @@ public final V put(K key, V value) {
                 size -= safeSizeOf(key, previous);
             }
         }
+
         if (previous != null) {
             entryRemoved(false, key, previous, value);
         }
+
         trimToSize(maxSize);
         return previous;
     }
+
     /**
-     * Remove the eldest entries until the total of remaining entries is at or
-     * below the requested size.
-     *
      * @param maxSize the maximum size of the cache before returning. May be -1
-     *            to evict even 0-sized elements.
+     *     to evict even 0-sized elements.
      */
-    public void trimToSize(int maxSize) {
+    private void trimToSize(int maxSize) {
         while (true) {
             K key;
             V value;
@@ -167,22 +186,36 @@ public void trimToSize(int maxSize) {
                     throw new IllegalStateException(getClass().getName()
                             + ".sizeOf() is reporting inconsistent results!");
                 }
+
                 if (size <= maxSize) {
                     break;
                 }
-                Map.Entry<K, V> toEvict = map.eldest();
+
+                // BEGIN LAYOUTLIB CHANGE
+                // get the last item in the linked list.
+                // This is not efficient, the goal here is to minimize the changes
+                // compared to the platform version.
+                Map.Entry<K, V> toEvict = null;
+                for (Map.Entry<K, V> entry : map.entrySet()) {
+                    toEvict = entry;
+                }
+                // END LAYOUTLIB CHANGE
+
                 if (toEvict == null) {
                     break;
                 }
+
                 key = toEvict.getKey();
                 value = toEvict.getValue();
                 map.remove(key);
                 size -= safeSizeOf(key, value);
                 evictionCount++;
             }
+
             entryRemoved(true, key, value, null);
         }
     }
+
     /**
      * Removes the entry for {@code key} if it exists.
      *
@@ -192,6 +225,7 @@ public final V remove(K key) {
         if (key == null) {
             throw new NullPointerException("key == null");
         }
+
         V previous;
         synchronized (this) {
             previous = map.remove(key);
@@ -199,11 +233,14 @@ public final V remove(K key) {
                 size -= safeSizeOf(key, previous);
             }
         }
+
         if (previous != null) {
             entryRemoved(false, key, previous, null);
         }
+
         return previous;
     }
+
     /**
      * Called for entries that have been evicted or removed. This method is
      * invoked when a value is evicted to make space, removed by a call to
@@ -220,6 +257,7 @@ public final V remove(K key) {
      *     an eviction or a {@link #remove}.
      */
     protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
+
     /**
      * Called after a cache miss to compute a value for the corresponding key.
      * Returns the computed value or null if no value can be computed. The
@@ -238,6 +276,7 @@ protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
     protected V create(K key) {
         return null;
     }
+
     private int safeSizeOf(K key, V value) {
         int result = sizeOf(key, value);
         if (result < 0) {
@@ -245,6 +284,7 @@ private int safeSizeOf(K key, V value) {
         }
         return result;
     }
+
     /**
      * Returns the size of the entry for {@code key} and {@code value} in
      * user-defined units.  The default implementation returns 1 so that size
@@ -255,12 +295,14 @@ private int safeSizeOf(K key, V value) {
     protected int sizeOf(K key, V value) {
         return 1;
     }
+
     /**
      * Clear the cache, calling {@link #entryRemoved} on each removed entry.
      */
     public final void evictAll() {
         trimToSize(-1); // -1 will evict 0-sized elements
     }
+
     /**
      * For caches that do not override {@link #sizeOf}, this returns the number
      * of entries in the cache. For all other caches, this returns the sum of
@@ -269,6 +311,7 @@ public final void evictAll() {
     public synchronized final int size() {
         return size;
     }
+
     /**
      * For caches that do not override {@link #sizeOf}, this returns the maximum
      * number of entries in the cache. For all other caches, this returns the
@@ -277,6 +320,7 @@ public synchronized final int size() {
     public synchronized final int maxSize() {
         return maxSize;
     }
+
     /**
      * Returns the number of times {@link #get} returned a value that was
      * already present in the cache.
@@ -284,6 +328,7 @@ public synchronized final int maxSize() {
     public synchronized final int hitCount() {
         return hitCount;
     }
+
     /**
      * Returns the number of times {@link #get} returned null or required a new
      * value to be created.
@@ -291,24 +336,28 @@ public synchronized final int hitCount() {
     public synchronized final int missCount() {
         return missCount;
     }
+
     /**
      * Returns the number of times {@link #create(Object)} returned a value.
      */
     public synchronized final int createCount() {
         return createCount;
     }
+
     /**
      * Returns the number of times {@link #put} was called.
      */
     public synchronized final int putCount() {
         return putCount;
     }
+
     /**
      * Returns the number of values that have been evicted.
      */
     public synchronized final int evictionCount() {
         return evictionCount;
     }
+
     /**
      * Returns a copy of the current contents of the cache, ordered from least
      * recently accessed to most recently accessed.
@@ -316,10 +365,11 @@ public synchronized final int evictionCount() {
     public synchronized final Map<K, V> snapshot() {
         return new LinkedHashMap<K, V>(map);
     }
+
     @Override public synchronized final String toString() {
         int accesses = hitCount + missCount;
         int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
         return String.format("LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
                 maxSize, hitCount, missCount, hitPercent);
     }
-}
\ No newline at end of file
+}
