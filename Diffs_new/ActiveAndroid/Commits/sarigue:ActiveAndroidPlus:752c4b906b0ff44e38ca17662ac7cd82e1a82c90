diff --git a/README.md b/README.md
index 2402f784..47e745ed 100644
--- a/README.md
+++ b/README.md
@@ -1,14 +1,20 @@
 [![Build Status](https://travis-ci.org/pardom/ActiveAndroid.png?branch=master)](https://travis-ci.org/pardom/ActiveAndroid) [![Stories in Ready](https://badge.waffle.io/pardom/ActiveAndroid.png)](http://waffle.io/pardom/ActiveAndroid)
-# ActiveAndroidRx
+# ActiveAndroidPlus
 
-Fork from vicpinm repository.
+Fork from ActiveAndroidRx (vicpinm repository) version 3.1.5
 
-Wrapper around ActiveAndroid which introduces reactive queries with SQLBrite from Square (https://github.com/square/sqlbrite).
-You can use it as alternative for Android loaders! 
+- ActiveAndroidRx : Reactive queries with SQLBrite from Square
+- UPDATE onConflictAction
 
 ## Usage
 
+ActiveAndroidRx:
+
     RxSelect.from(MyEntity.class).where(...).execute().subscribe(myEntitiesList -> ...);
+
+UPDATE OnConflictAction:
+
+    @Column(... onConlictAction=ConflictAction.UPDATE)
     
 ## Download
 
@@ -18,7 +24,7 @@ repositories {
     maven { url "https://jitpack.io" }
 }
 
-compile 'com.github.sarigue:activeandroidrx:master'
+compile 'com.github.sarigue:activeandroidplus:master'
 ```
 
 ## Documentation
diff --git a/build.gradle b/build.gradle
index 195a27a6..61deb2fe 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,7 +2,7 @@ apply plugin: 'java'
 apply from: 'gradle-mvn-push.gradle'
 
 group = 'com.github.sarigue'
-version = '3.1.5'
+version = '1.0.0'
 
 sourceCompatibility = 1.7
 targetCompatibility = 1.7
@@ -22,6 +22,6 @@ repositories {
 dependencies {
     compile fileTree(dir: 'libs', include: '*.jar')
     compile 'com.google.code.gson:gson:2.3.1'
+    compile 'com.squareup.moshi:moshi:1.4.0'
     compile 'io.reactivex:rxjava:1.0.14'
-
 }
diff --git a/gradle.properties b/gradle.properties
index a7e7e4c4..d68e06a5 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,6 +1,6 @@
 VERSION_NAME=3.1.5
 VERSION_CODE=2
-GROUP=com.github.vicpinm
+GROUP=com.github.fraoult
 
 POM_DESCRIPTION=ActiveAndroid fork with reactive extensions.
 POM_URL=https://github.com/vicpinm/ActiveAndroidRx
@@ -10,9 +10,9 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:vicpinm/ActiveAndroidRx.git
 POM_LICENCE_NAME=The Apache Software License, Version 2.0
 POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
 POM_LICENCE_DIST=repo
-POM_DEVELOPER_ID=vicipnm
-POM_DEVELOPER_NAME=Victor Manuel Pineda Murcia
+POM_DEVELOPER_ID=fraoult
+POM_DEVELOPER_NAME=Francois Raoult
 
-POM_NAME=ActiveAndroidRx
-POM_ARTIFACT_ID=activeandroidrx
+POM_NAME=ActiveAndroidPlus
+POM_ARTIFACT_ID=activeandroidplus
 POM_PACKAGING=jar
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index 390e3cf6..1d03e6b1 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -21,12 +21,14 @@
 
 import com.activeandroid.content.ContentProvider;
 import com.activeandroid.query.Delete;
+import com.activeandroid.query.From;
 import com.activeandroid.query.Select;
 import com.activeandroid.serializer.TypeSerializer;
 import com.activeandroid.sqlbrite.BriteDatabase;
 import com.activeandroid.util.Log;
 import com.activeandroid.util.ReflectionUtils;
 import com.google.gson.annotations.SerializedName;
+import com.squareup.moshi.Json;
 
 import java.lang.reflect.Field;
 import java.util.ArrayList;
@@ -43,7 +45,8 @@
 	// PRIVATE MEMBERS
 	//////////////////////////////////////////////////////////////////////////////////////
 
-    @SerializedName("id")
+	@SerializedName("id")
+	@Json(name="id")
 	private Long mId = null;
 
 	private final TableInfo mTableInfo;
@@ -65,11 +68,11 @@ public final Long getId() {
 		return mId;
 	}
 
-    public void setId(Long id) {
-        this.mId = id;
-    }
+	public void setId(Long id) {
+		this.mId = id;
+	}
 
-    public void delete() {
+	public void delete() {
 		Cache.openDatabase().delete(mTableInfo.getTableName(), idName+"=?", new String[] { getId().toString() });
 		Cache.removeEntity(this);
 
@@ -157,14 +160,16 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 			}
 		}
 
+		setIdFromUniqueOnUpdate(values);
+
 		if (mId == null) {
 			mId = db.insert(mTableInfo.getTableName(), values);
 		}
 		else {
 			int updated = db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
-            if(updated == 0) {
-                mId = db.insert(mTableInfo.getTableName(), values);
-            }
+			if(updated == 0) {
+				mId = db.insert(mTableInfo.getTableName(), values);
+			}
 		}
 
 		Cache.getContext().getContentResolver()
@@ -172,6 +177,67 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 		return mId;
 	}
 
+
+	/**
+	 * Retrieve primary key from "unique" fields with "update" action
+	 */
+	private void setIdFromUniqueOnUpdate(ContentValues values)
+	{
+		if (mId != null && mId != -1) // Primary key is set yet
+		{
+			return;
+		}
+
+		if (! mTableInfo.hasOnUpdateFields()) // No Unique columns with UPDATE action
+		{
+			return;
+		}
+
+		From query = new Select(mTableInfo.getIdName()).from(this.getClass());
+
+		for(Field field : mTableInfo.getUniqueFields())
+		{
+			Object value = null;
+			try {
+				value = field.get(this);
+			}
+			catch (IllegalAccessException e) {
+				Log.e(e.getClass().getName(), e);
+			}
+
+			if (value == null) {
+				continue; // Value is null
+			}
+
+			String fieldname = mTableInfo.getColumnName(field);
+			query.or(fieldname+"=?", values.get(fieldname));
+		}
+
+		for(List<Field> fields : mTableInfo.getUniqueGroups())
+		{
+			query.startGroupOr();
+			for(Field field : fields)
+			{
+				String fieldname = mTableInfo.getColumnName(field);
+				query.and(fieldname+"=?", values.get(fieldname));
+			}
+			query.endGroup();
+		}
+
+		String sqlQuery = query.toSql();
+		Cursor cursor = Cache.openDatabase().query(sqlQuery, query.getArguments());
+
+		if (cursor != null) {
+			cursor.moveToFirst();
+			if (cursor.getCount() > 0 && cursor.getColumnCount() > 0)
+			{
+				cursor.moveToFirst();
+				mId = cursor.getLong(0);
+			}
+			cursor.close();
+		}
+	}
+
 	// Convenience methods
 
 	public static void delete(Class<? extends Model> type, long id) {
@@ -187,11 +253,11 @@ public static void delete(Class<? extends Model> type, long id) {
 	// Model population
 
 	public final void loadFromCursor(Cursor cursor) {
-        /**
-         * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
-         * when the cursor have multiple columns with same name obtained from join tables.
-         */
-        List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+		/**
+		 * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
+		 * when the cursor have multiple columns with same name obtained from join tables.
+		 */
+		List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
 		for (Field field : mTableInfo.getFields()) {
 			final String fieldName = mTableInfo.getColumnName(field);
 			Class<?> fieldType = field.getType();
diff --git a/src/com/activeandroid/TableInfo.java b/src/com/activeandroid/TableInfo.java
index 32d1ecb3..c822ddb6 100644
--- a/src/com/activeandroid/TableInfo.java
+++ b/src/com/activeandroid/TableInfo.java
@@ -16,7 +16,15 @@
  * limitations under the License.
  */
 
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.activeandroid.annotation.Column;
+import com.activeandroid.annotation.Table;
+import com.activeandroid.util.ReflectionUtils;
+
 import java.lang.reflect.Field;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedHashMap;
@@ -24,13 +32,6 @@
 import java.util.List;
 import java.util.Map;
 
-import android.text.TextUtils;
-import android.util.Log;
-
-import com.activeandroid.annotation.Column;
-import com.activeandroid.annotation.Table;
-import com.activeandroid.util.ReflectionUtils;
-
 public final class TableInfo {
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE MEMBERS
@@ -41,6 +42,8 @@
 	private String mIdName = Table.DEFAULT_ID_NAME;
 
 	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
+    private Map<String, List<Field>> mUniqueGroups = new LinkedHashMap<String, List<Field>>();
+    private List<Field> mUniqueKeys = new ArrayList<Field>();
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// CONSTRUCTORS
@@ -67,6 +70,9 @@ public TableInfo(Class<? extends Model> type) {
         Collections.reverse(fields);
 
         for (Field field : fields) {
+
+            // Fields
+
             if (field.isAnnotationPresent(Column.class)) {
                 final Column columnAnnotation = field.getAnnotation(Column.class);
                 String columnName = columnAnnotation.name();
@@ -76,9 +82,42 @@ public TableInfo(Class<? extends Model> type) {
 
                 mColumnNames.put(field, columnName);
             }
-        }
 
-	}
+            // "Unique on update" fields
+
+            Column column = field.getAnnotation(Column.class);
+            Object value = null;
+            if (column == null) {
+                continue; // Not a column
+            }
+            if (! column.unique() && column.uniqueGroups().length == 0) {
+                continue; // Not unique key
+            }
+            Column.ConflictAction   conflictAction = column.onUniqueConflict();
+            Column.ConflictAction[] conflictActions = column.onUniqueConflicts();
+            if (! Column.ConflictAction.UPDATE.equals(conflictAction) && conflictActions.length == 0) {
+                continue; // No "UPDATE" action
+            }
+            if (Column.ConflictAction.UPDATE.equals(conflictAction)) {
+                mUniqueKeys.add(field);
+            }
+            String[] uniqueGroups = column.uniqueGroups();
+            Column.ConflictAction[] uniqueConflicts = column.onUniqueConflicts();
+            for(int i=0; i<uniqueGroups.length; i++) {
+                if (uniqueConflicts.length <= i) {
+                    continue;
+                }
+                if (Column.ConflictAction.UPDATE.equals(uniqueConflicts[i])) {
+                    String group = uniqueGroups[i];
+                    if (mUniqueGroups.get(group) == null) {
+                        mUniqueGroups.put(group, new LinkedList<Field>());
+                    }
+                    mUniqueGroups.get(group).add(field);
+                }
+            }
+        } // for each field
+
+    }
 
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC METHODS
@@ -104,6 +143,17 @@ public String getColumnName(Field field) {
 		return mColumnNames.get(field);
 	}
 
+    public boolean hasOnUpdateFields() {
+        return ! mUniqueGroups.isEmpty() || ! mUniqueKeys.isEmpty();
+    }
+
+    public Collection<List<Field>> getUniqueGroups() {
+        return mUniqueGroups.values();
+    }
+
+    public Collection<Field> getUniqueFields() {
+        return mUniqueKeys;
+    }
 
     private Field getIdField(Class<?> type) {
         if (type.equals(Model.class)) {
diff --git a/src/com/activeandroid/annotation/Column.java b/src/com/activeandroid/annotation/Column.java
index 56bbcde8..dc48cf4c 100644
--- a/src/com/activeandroid/annotation/Column.java
+++ b/src/com/activeandroid/annotation/Column.java
@@ -25,7 +25,7 @@
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Column {
 	public enum ConflictAction {
-		ROLLBACK, ABORT, FAIL, IGNORE, REPLACE
+		ROLLBACK, ABORT, FAIL, IGNORE, REPLACE, UPDATE
 	}
 
 	public enum ForeignKeyAction {
diff --git a/src/com/activeandroid/query/From.java b/src/com/activeandroid/query/From.java
index b1a40a6d..c6ef6a06 100644
--- a/src/com/activeandroid/query/From.java
+++ b/src/com/activeandroid/query/From.java
@@ -16,6 +16,7 @@
  * limitations under the License.
  */
 
+import android.database.SQLException;
 import android.text.TextUtils;
 
 import com.activeandroid.Cache;
@@ -34,14 +35,16 @@
 	private Sqlable mQueryBase;
 
 	private Class<? extends Model> mType;
-	private String mAlias;
+	private String     mAlias;
 	private List<Join> mJoins;
 	private final StringBuilder mWhere = new StringBuilder();
-	private String mGroupBy;
-	private String mHaving;
-	private String mOrderBy;
-	private String mLimit;
-	private String mOffset;
+	private String  mGroupBy;
+	private String  mHaving;
+	private String  mOrderBy;
+	private String  mLimit;
+	private String  mOffset;
+	private int     mGroups = 0;
+	private boolean mGroupStart = false;
 
 	private List<Object> mArguments;
 
@@ -89,41 +92,77 @@ public Join crossJoin(Class<? extends Model> table) {
 		return join;
 	}
 
-    public From where(String clause) {
-        // Chain conditions if a previous condition exists.
-        if (mWhere.length() > 0) {
-            mWhere.append(" AND ");
-        }
-        mWhere.append(clause);
-        return this;
-    }
-
-    public From where(String clause, Object... args) {
-        where(clause).addArguments(args);
-        return this;
-    }
-
-    public From and(String clause) {
-        return where(clause);
-    }
-
-    public From and(String clause, Object... args) {
-        return where(clause, args);
-    }
-
-    public From or(String clause) {
-        if (mWhere.length() > 0) {
-            mWhere.append(" OR ");
-        }
-        mWhere.append(clause);
-        return this;
-    }
-
-    public From or(String clause, Object... args) {
-        or(clause).addArguments(args);
-        return this;
-    }
-    
+	public From startGroupAnd() {
+		if (mWhere.length() > 0) {
+			mWhere.append(" AND");
+		}
+		mWhere.append(" (");
+		mGroups++;
+		mGroupStart = true;
+		return this;
+	}
+
+	public From startGroupOr() {
+		if (mWhere.length() > 0) {
+			mWhere.append(" OR");
+		}
+		mWhere.append(" (");
+		mGroups++;
+		mGroupStart = true;
+		return this;
+	}
+
+	public From endGroup() {
+		if (mGroupStart)
+		{
+			throw new SQLException("Group is empty !");
+		}
+		if (mGroups > 0)
+		{
+			mWhere.append(")");
+		}
+		mGroups--;
+		mGroupStart = false;
+		return this;
+	}
+
+	public From where(String clause) {
+		// Chain conditions if a previous condition exists.
+		if (mWhere.length() > 0 && ! mGroupStart) {
+			mWhere.append(" AND ");
+		}
+		mWhere.append(clause);
+		mGroupStart = false;
+		return this;
+	}
+
+	public From where(String clause, Object... args) {
+		where(clause).addArguments(args);
+		return this;
+	}
+
+	public From and(String clause) {
+		return where(clause);
+	}
+
+	public From and(String clause, Object... args) {
+		return where(clause, args);
+	}
+
+	public From or(String clause) {
+		if (mWhere.length() > 0 && ! mGroupStart) {
+			mWhere.append(" OR ");
+		}
+		mWhere.append(clause);
+		mGroupStart = false;
+		return this;
+	}
+
+	public From or(String clause, Object... args) {
+		or(clause).addArguments(args);
+		return this;
+	}
+
 	public From groupBy(String groupBy) {
 		mGroupBy = groupBy;
 		return this;
@@ -158,142 +197,147 @@ public From offset(String offset) {
 	}
 
 	void addArguments(Object[] args) {
-        for(Object arg : args) {
-            if (arg.getClass() == boolean.class || arg.getClass() == Boolean.class) {
-                arg = (arg.equals(true) ? 1 : 0);
-            }
-            mArguments.add(arg);
-        }
-	}
-
-    private void addFrom(final StringBuilder sql) {
-        sql.append("FROM ");
-        sql.append(Cache.getTableName(mType)).append(" ");
-
-        if (mAlias != null) {
-            sql.append("AS ");
-            sql.append(mAlias);
-            sql.append(" ");
-        }
-    }
-
-    private void addJoins(final StringBuilder sql) {
-        for (final Join join : mJoins) {
-            sql.append(join.toSql());
-        }
-    }
-
-    private void addWhere(final StringBuilder sql) {
-        if (mWhere.length() > 0) {
-            sql.append("WHERE ");
-            sql.append(mWhere);
-            sql.append(" ");
-        }
-    }
-
-    private void addGroupBy(final StringBuilder sql) {
-        if (mGroupBy != null) {
-            sql.append("GROUP BY ");
-            sql.append(mGroupBy);
-            sql.append(" ");
-        }
-    }
-
-    private void addHaving(final StringBuilder sql) {
-        if (mHaving != null) {
-            sql.append("HAVING ");
-            sql.append(mHaving);
-            sql.append(" ");
-        }
-    }
-
-    private void addOrderBy(final StringBuilder sql) {
-        if (mOrderBy != null) {
-            sql.append("ORDER BY ");
-            sql.append(mOrderBy);
-            sql.append(" ");
-        }
-    }
-
-    private void addLimit(final StringBuilder sql) {
-        if (mLimit != null) {
-            sql.append("LIMIT ");
-            sql.append(mLimit);
-            sql.append(" ");
-        }
-    }
-
-    private void addOffset(final StringBuilder sql) {
-        if (mOffset != null) {
-            sql.append("OFFSET ");
-            sql.append(mOffset);
-            sql.append(" ");
-        }
-    }
-
-    private String sqlString(final StringBuilder sql) {
-
-        final String sqlString = sql.toString().trim();
-
-        // Don't waste time building the string
-        // unless we're going to log it.
-        if (Log.isEnabled()) {
-            Log.v(sqlString + " " + TextUtils.join(",", getArguments()));
-        }
-
-        return sqlString;
-    }
-
-    @Override
-    public String toSql() {
-        final StringBuilder sql = new StringBuilder();
-        sql.append(mQueryBase.toSql());
-
-        addFrom(sql);
-        addJoins(sql);
-        addWhere(sql);
-        addGroupBy(sql);
-        addHaving(sql);
-        addOrderBy(sql);
-        addLimit(sql);
-        addOffset(sql);
-
-        return sqlString(sql);
-    }
-
-    public String toExistsSql() {
-
-        final StringBuilder sql = new StringBuilder();
-        sql.append("SELECT EXISTS(SELECT 1 ");
-
-        addFrom(sql);
-        addJoins(sql);
-        addWhere(sql);
-        addGroupBy(sql);
-        addHaving(sql);
-        addLimit(sql);
-        addOffset(sql);
-
-        sql.append(")");
-
-        return sqlString(sql);
-    }
-
-    public String toCountSql() {
-
-        final StringBuilder sql = new StringBuilder();
-        sql.append("SELECT COUNT(*) ");
-
-        addFrom(sql);
-        addJoins(sql);
-        addWhere(sql);
-        addGroupBy(sql);
-        addHaving(sql);
-        addLimit(sql);
-        addOffset(sql);
-
-        return sqlString(sql);
-    }
+		for(Object arg : args) {
+			if (arg.getClass() == boolean.class || arg.getClass() == Boolean.class) {
+				arg = (arg.equals(true) ? 1 : 0);
+			}
+			mArguments.add(arg);
+		}
+	}
+
+	private void addFrom(final StringBuilder sql) {
+		sql.append("FROM ");
+		sql.append(Cache.getTableName(mType)).append(" ");
+
+		if (mAlias != null) {
+			sql.append("AS ");
+			sql.append(mAlias);
+			sql.append(" ");
+		}
+	}
+
+	private void addJoins(final StringBuilder sql) {
+		for (final Join join : mJoins) {
+			sql.append(join.toSql());
+		}
+	}
+
+	private void addWhere(final StringBuilder sql) {
+		if (mWhere.length() > 0) {
+			sql.append("WHERE ");
+			sql.append(mWhere);
+			sql.append(" ");
+		}
+	}
+
+	private void addGroupBy(final StringBuilder sql) {
+		if (mGroupBy != null) {
+			sql.append("GROUP BY ");
+			sql.append(mGroupBy);
+			sql.append(" ");
+		}
+	}
+
+	private void addHaving(final StringBuilder sql) {
+		if (mHaving != null) {
+			sql.append("HAVING ");
+			sql.append(mHaving);
+			sql.append(" ");
+		}
+	}
+
+	private void addOrderBy(final StringBuilder sql) {
+		if (mOrderBy != null) {
+			sql.append("ORDER BY ");
+			sql.append(mOrderBy);
+			sql.append(" ");
+		}
+	}
+
+	private void addLimit(final StringBuilder sql) {
+		if (mLimit != null) {
+			sql.append("LIMIT ");
+			sql.append(mLimit);
+			sql.append(" ");
+		}
+	}
+
+	private void addOffset(final StringBuilder sql) {
+		if (mOffset != null) {
+			sql.append("OFFSET ");
+			sql.append(mOffset);
+			sql.append(" ");
+		}
+	}
+
+	private String sqlString(final StringBuilder sql) {
+
+		final String sqlString = sql.toString().trim();
+
+		// Don't waste time building the string
+		// unless we're going to log it.
+		if (Log.isEnabled()) {
+			Log.v(sqlString + " " + TextUtils.join(",", getArguments()));
+		}
+
+		return sqlString;
+	}
+
+	@Override
+	public String toSql() {
+		final StringBuilder sql = new StringBuilder();
+		sql.append(mQueryBase.toSql());
+
+		addFrom(sql);
+		addJoins(sql);
+		addWhere(sql);
+		addGroupBy(sql);
+		addHaving(sql);
+		addOrderBy(sql);
+		addLimit(sql);
+		addOffset(sql);
+
+		if (mGroups > 0)
+		{
+			throw new SQLException("At least one group is not closed in SQL Query : "+sqlString(sql));
+		}
+
+		return sqlString(sql);
+	}
+
+	public String toExistsSql() {
+
+		final StringBuilder sql = new StringBuilder();
+		sql.append("SELECT EXISTS(SELECT 1 ");
+
+		addFrom(sql);
+		addJoins(sql);
+		addWhere(sql);
+		addGroupBy(sql);
+		addHaving(sql);
+		addLimit(sql);
+		addOffset(sql);
+
+		sql.append(")");
+
+		return sqlString(sql);
+	}
+
+	public String toCountSql() {
+
+		final StringBuilder sql = new StringBuilder();
+		sql.append("SELECT COUNT(*) ");
+
+		addFrom(sql);
+		addJoins(sql);
+		addWhere(sql);
+		addGroupBy(sql);
+		addHaving(sql);
+		addLimit(sql);
+		addOffset(sql);
+
+		return sqlString(sql);
+	}
 
 	public <T extends Model> List<T> execute() {
 		if (mQueryBase instanceof Select) {
@@ -307,15 +351,15 @@ public String toCountSql() {
 		}
 	}
 
-    public <T extends Model> Observable<T> executeRx() {
-        if (mQueryBase instanceof Select) {
-            return SQLiteUtils.rawRxQuery(mType, toSql(), getArguments());
+	public <T extends Model> Observable<T> executeRx() {
+		if (mQueryBase instanceof Select) {
+			return SQLiteUtils.rawRxQuery(mType, toSql(), getArguments());
 
-        } else {
-            throw new IllegalArgumentException("Query must be instance of Select");
+		} else {
+			throw new IllegalArgumentException("Query must be instance of Select");
 
-        }
-    }
+		}
+	}
 
 	public <T extends Model> T executeSingle() {
 		if (mQueryBase instanceof Select) {
@@ -330,20 +374,20 @@ public String toCountSql() {
 		}
 	}
 	
-    /**
-     * Gets a value indicating whether the query returns any rows.
-     * @return <code>true</code> if the query returns at least one row; otherwise, <code>false</code>.
-     */
-    public boolean exists() {
-        return SQLiteUtils.intQuery(toExistsSql(), getArguments()) != 0;
-    }
-
-    /**
-     * Gets the number of rows returned by the query.
-     */
-    public int count() {
-        return SQLiteUtils.intQuery(toCountSql(), getArguments());
-    }
+	/**
+	 * Gets a value indicating whether the query returns any rows.
+	 * @return <code>true</code> if the query returns at least one row; otherwise, <code>false</code>.
+	 */
+	public boolean exists() {
+		return SQLiteUtils.intQuery(toExistsSql(), getArguments()) != 0;
+	}
+
+	/**
+	 * Gets the number of rows returned by the query.
+	 */
+	public int count() {
+		return SQLiteUtils.intQuery(toCountSql(), getArguments());
+	}
 
 	public String[] getArguments() {
 		final int size = mArguments.size();
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index 968db841..e24921f9 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -178,7 +178,9 @@ public static int intQuery(final String sql, final String[] selectionArgs) {
         for (String key : keySet) {
             List<String> group = sUniqueGroupMap.get(key);
             ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
-
+            if (ConflictAction.UPDATE.equals(conflictAction)) {
+                conflictAction = ConflictAction.IGNORE;
+            }
             definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
                     TextUtils.join(", ", group), conflictAction.toString()));
         }
@@ -327,8 +329,12 @@ public static String createColumnDefinition(TableInfo tableInfo, Field field) {
                 }
 
                 if (column.unique()) {
+                    ConflictAction conflictAction = column.onUniqueConflict();
                     definition.append(" UNIQUE ON CONFLICT ");
-                    definition.append(column.onUniqueConflict().toString());
+                    if (ConflictAction.UPDATE.equals(conflictAction)) {
+                        conflictAction = ConflictAction.IGNORE;
+                    }
+                    definition.append(conflictAction.toString());
                 }
             }
 
