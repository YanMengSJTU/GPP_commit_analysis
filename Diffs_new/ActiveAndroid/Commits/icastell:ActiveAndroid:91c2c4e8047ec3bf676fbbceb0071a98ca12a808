diff --git a/README.md b/README.md
index 2e7c9e4d..b897fc18 100644
--- a/README.md
+++ b/README.md
@@ -1,28 +1,22 @@
 [![Build Status](https://travis-ci.org/pardom/ActiveAndroid.png?branch=master)](https://travis-ci.org/pardom/ActiveAndroid) [![Stories in Ready](https://badge.waffle.io/pardom/ActiveAndroid.png)](http://waffle.io/pardom/ActiveAndroid)  
-# ActiveAndroid
+# ActiveAndroidRx
 
-ActiveAndroid is an active record style ORM ([object relational mapper](http://en.wikipedia.org/wiki/Object-relational_mapping)). What does that mean exactly? Well, ActiveAndroid allows you to save and retrieve SQLite database records without ever writing a single SQL statement. Each database record is wrapped neatly into a class with methods like _save()_ and _delete()_.
+Wrapper around ActiveAndroid which introduces reactive queries with SQLBrite from Square (https://github.com/square/sqlbrite).
+You can use it as alternative for Android loaders! 
 
-ActiveAndroid does so much more than this though. Accessing the database is a hassle, to say the least, in Android. ActiveAndroid takes care of all the setup and messy stuff, and all with just a few simple steps of configuration.
+## Usage
 
+    RxSelect.from(MyEntity.class).where(...).execute().subscribe(myEntitiesList -> ...);
+    
 ## Download
 
-Grab via Maven:
-```xml
-<dependency>
-  <groupId>com.michaelpardo</groupId>
-  <artifactId>activeandroid</artifactId>
-  <version>3.1.0-SNAPSHOT</version>
-</dependency>
-```
-or Gradle:
+Grab via Gradle:
 ```groovy
 repositories {
     mavenCentral()
-    maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
 }
 
-compile 'com.michaelpardo:activeandroid:3.1.0-SNAPSHOT'
+compile 'com.github.vicpinm:activeandroidrx:3.1.1'
 ```
 
 ## Documentation
@@ -66,4 +60,7 @@ You can run the test suite by following the instructions on the [Running the Tes
 
 ## Author
 
+VÃ­ctor Manuel Pineda Murcia | http://vicpinm.github.io/ActiveAndroidRx/
+
+Original Project: 
 Michael Pardo | www.michaelpardo.com | www.activeandroid.com
diff --git a/build.gradle b/build.gradle
index ec63778c..f104d261 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,26 +1,11 @@
 apply plugin: 'java'
-apply plugin: 'maven'
+apply from: 'gradle-mvn-push.gradle'
 
-group = 'com.michaelpardo'
-version = '3.1.0'
+group = 'com.github.vicpinm'
+version = '3.1.1'
 
-uploadArchives {
-    configuration = configurations.archives
-    repositories {
-        mavenDeployer {
-            // I chose to put my repo in the project's root
-            repository(url: uri("../../localrepo"))
-            pom.project {
-                artifactId 'active-android'
-                name 'ActiveAndroid'
-                packaging 'aar'
-            }
-        }
-    }
-}
-
-targetCompatibility = '1.6'
-sourceCompatibility = '1.6'
+sourceCompatibility = 1.7
+targetCompatibility = 1.7
 
 sourceSets {
     main {
@@ -37,4 +22,6 @@ repositories {
 dependencies {
     compile fileTree(dir: 'libs', include: '*.jar')
     compile 'com.google.code.gson:gson:2.3.1'
+    compile 'io.reactivex:rxjava:1.0.14'
+
 }
diff --git a/gradle.properties b/gradle.properties
index 424d885a..e87e89bf 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,18 +1,18 @@
-VERSION_NAME=3.1.0-SNAPSHOT
+VERSION_NAME=3.1.1
 VERSION_CODE=1
-GROUP=com.michaelpardo
+GROUP=com.github.vicpinm
 
-POM_DESCRIPTION=Active record style SQLite persistence for Android.
-POM_URL=https://github.com/pardom/ActiveAndroid
-POM_SCM_URL=https://github.com/pardom/ActiveAndroid
-POM_SCM_CONNECTION=scm:git@github.com:pardom/ActiveAndroid.git
-POM_SCM_DEV_CONNECTION=scm:git@github.com:pardom/ActiveAndroid.git
+POM_DESCRIPTION=ActiveAndroid fork with reactive extensions.
+POM_URL=https://github.com/vicpinm/ActiveAndroidRx
+POM_SCM_URL=https://github.com/vicpinm/ActiveAndroidRx
+POM_SCM_CONNECTION=scm:git@github.com:vicpinm/ActiveAndroidRx.git
+POM_SCM_DEV_CONNECTION=scm:git@github.com:vicpinm/ActiveAndroidRx.git
 POM_LICENCE_NAME=The Apache Software License, Version 2.0
 POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
 POM_LICENCE_DIST=repo
-POM_DEVELOPER_ID=michaelpardo
-POM_DEVELOPER_NAME=Michael Pardo
+POM_DEVELOPER_ID=vicipnm
+POM_DEVELOPER_NAME=Victor Manuel Pineda Murcia
 
-POM_NAME=ActiveAndroid
-POM_ARTIFACT_ID=activeandroid
+POM_NAME=ActiveAndroidRx
+POM_ARTIFACT_ID=activeandroidrx
 POM_PACKAGING=jar
diff --git a/libs/android-support-annotations.jar b/libs/android-support-annotations.jar
new file mode 100644
index 00000000..21b33216
Binary files /dev/null and b/libs/android-support-annotations.jar differ
diff --git a/pom-child.xml b/pom-child.xml
index 4f0c72df..1ea436d4 100644
--- a/pom-child.xml
+++ b/pom-child.xml
@@ -5,11 +5,11 @@
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
 
     <modelVersion>4.0.0</modelVersion>
-    <groupId>com.activeandroid</groupId>
-    <artifactId>activeandroid</artifactId>
-    <version>3.1-SNAPSHOT</version>
+    <groupId>com.activeandroidrx</groupId>
+    <artifactId>activeandroidrx</artifactId>
+    <version>3.1.1</version>
     <packaging>jar</packaging>
-    <name>ActiveAndroid</name>
+    <name>ActiveAndroidRx</name>
 
     <licenses>
         <license>
@@ -20,16 +20,16 @@
     </licenses>
 
   <parent>
-    <groupId>com.activeandroid</groupId>
-    <artifactId>activeandroid-parent</artifactId>
-    <version>3.1-SNAPSHOT</version>
+    <groupId>com.activeandroidrx</groupId>
+    <artifactId>activeandroidrx-parent</artifactId>
+    <version>3.1.1</version>
     <relativePath>./pom.xml</relativePath>
   </parent>
 
     <scm>
-        <connection>scm:git:git@github.com:pardom/ActiveAndroid.git</connection>
-        <developerConnection>scm:git:git@github.com:pardom/ActiveAndroid.git</developerConnection>
-        <url>git@github.com:pardom/ActiveAndroid.git</url>
+        <connection>scm:git:git@github.com:vicpinm/ActiveAndroidRx.git</connection>
+        <developerConnection>scm:git:git@github.com:vicpinm/ActiveAndroidRx.git</developerConnection>
+        <url>git@github.com:vicpinm/ActiveAndroidRx.git</url>
     </scm>
 
     <properties>
diff --git a/pom.xml b/pom.xml
index eafb111c..b2f79d17 100644
--- a/pom.xml
+++ b/pom.xml
@@ -2,11 +2,11 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.activeandroid</groupId>
-  <artifactId>activeandroid-parent</artifactId>
-  <version>3.1-SNAPSHOT</version>
+  <groupId>com.github.vicpinm</groupId>
+  <artifactId>activeandroidrx-parent</artifactId>
+  <version>3.1.1</version>
   <packaging>pom</packaging>
-  <name>ActiveAndroid - Parent</name>
+  <name>ActiveAndroidRx - Parent</name>
 
   <modules>
     <module>pom-child.xml</module>
diff --git a/src/com/activeandroid/ActiveAndroid.java b/src/com/activeandroid/ActiveAndroid.java
index c58c8efd..4ff2d0fb 100644
--- a/src/com/activeandroid/ActiveAndroid.java
+++ b/src/com/activeandroid/ActiveAndroid.java
@@ -17,70 +17,130 @@
  */
 
 import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
+import android.database.Cursor;
 
+import com.activeandroid.rxschedulers.AndroidSchedulers;
+import com.activeandroid.sqlbrite.BriteDatabase;
+import com.activeandroid.sqlbrite.SqlBrite;
 import com.activeandroid.util.Log;
 
+import java.util.ArrayList;
+import java.util.List;
+
+import rx.Observable;
+import rx.functions.Func1;
+import rx.schedulers.Schedulers;
+
 public final class ActiveAndroid {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void initialize(Context context) {
-		initialize(new Configuration.Builder(context).create());
-	}
-
-	public static void initialize(Configuration configuration) {
-		initialize(configuration, false);
-	}
-
-	public static void initialize(Context context, boolean loggingEnabled) {
-		initialize(new Configuration.Builder(context).create(), loggingEnabled);
-	}
-
-	public static void initialize(Configuration configuration, boolean loggingEnabled) {
-		// Set logging enabled first
-		setLoggingEnabled(loggingEnabled);
-		Cache.initialize(configuration);
-	}
-
-	public static void clearCache() {
-		Cache.clear();
-	}
-
-	public static void dispose() {
-		Cache.dispose();
-	}
-
-	public static void setLoggingEnabled(boolean enabled) {
-		Log.setEnabled(enabled);
-	}
-
-	public static SQLiteDatabase getDatabase() {
-		return Cache.openDatabase();
-	}
-
-	public static void beginTransaction() {
-		Cache.openDatabase().beginTransaction();
-	}
-
-	public static void endTransaction() {
-		Cache.openDatabase().endTransaction();
-	}
-
-	public static void setTransactionSuccessful() {
-		Cache.openDatabase().setTransactionSuccessful();
-	}
-
-	public static boolean inTransaction() {
-		return Cache.openDatabase().inTransaction();
-	}
-
-	public static void execSQL(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSQL(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static void initialize(Context context) {
+        initialize(new Configuration.Builder(context).create());
+    }
+
+    public static void initialize(Configuration configuration) {
+        initialize(configuration, false);
+    }
+
+    public static void initialize(Context context, boolean loggingEnabled) {
+        initialize(new Configuration.Builder(context).create(), loggingEnabled);
+    }
+
+    public static void initialize(Configuration configuration, boolean loggingEnabled) {
+        // Set logging enabled first
+        setLoggingEnabled(loggingEnabled);
+        Cache.initialize(configuration);
+    }
+
+    public static void clearCache() {
+        Cache.clear();
+    }
+
+    public static void dispose() {
+        Cache.dispose();
+    }
+
+    public static void setLoggingEnabled(boolean enabled) {
+        Log.setEnabled(enabled);
+    }
+
+    public static BriteDatabase getDatabase() {
+        return Cache.openDatabase();
+    }
+
+    public static BriteDatabase.Transaction beginTransaction() {
+        return Cache.openDatabase().newTransaction();
+    }
+
+    public static void endTransaction(BriteDatabase.Transaction transaction) {
+        transaction.end();
+    }
+
+    public static void setTransactionSuccessful(BriteDatabase.Transaction transaction) {
+        transaction.markSuccessful();
+    }
+
+
+    public static void execSQL(String sql) {
+        Cache.openDatabase().execute(sql);
+    }
+
+    public static void execSQL(String sql, Object[] bindArgs) {
+        Cache.openDatabase().execute(sql, bindArgs);
+    }
+
+    public static Observable<SqlBrite.Query> query(String table, String sql) {
+        return Cache.openDatabase().createQuery(table, sql);
+    }
+
+    public static Observable<Cursor> queryCursor(Class<? extends Model> clase, String sql) {
+
+        TableInfo tableInfo = new TableInfo(clase);
+        return Cache.openDatabase().createQuery(tableInfo.getTableName(), sql)
+                .subscribeOn(Schedulers.io())
+                .map(new Func1<SqlBrite.Query, Cursor>() {
+                    @Override
+                    public Cursor call(SqlBrite.Query query) {
+                        return query.run();
+                    }
+                })
+                .observeOn(AndroidSchedulers.mainThread());
+    }
+
+    public static Observable<List<? extends Model>> queryObject(final Class<? extends Model> clase,String sql) {
+
+        TableInfo tableInfo = new TableInfo(clase);
+
+        return Cache.openDatabase().createQuery(tableInfo.getTableName(), sql)
+                .subscribeOn(Schedulers.io())
+                .map(new Func1<SqlBrite.Query, List<? extends Model>>() {
+                    @Override
+                    public List<? extends Model> call(SqlBrite.Query query) {
+                        try {
+                            Cursor cursor = query.run();
+                            List<Model> data = new ArrayList<Model>();
+                            if (cursor != null && cursor.getCount() > 0) {
+                                while (cursor.moveToNext()) {
+                                    Model model = clase.newInstance();
+                                    model.loadFromCursor(cursor);
+                                    data.add(model);
+                                }
+                            }
+
+                            return data;
+                        } catch(Exception ex){
+                            ex.printStackTrace();
+                        }
+
+                        return null;
+
+                    }
+                })
+                .observeOn(AndroidSchedulers.mainThread());
+    }
+
+
+
 }
diff --git a/src/com/activeandroid/Cache.java b/src/com/activeandroid/Cache.java
index 6495e379..384ad94c 100644
--- a/src/com/activeandroid/Cache.java
+++ b/src/com/activeandroid/Cache.java
@@ -16,15 +16,16 @@
  * limitations under the License.
  */
 
-import java.util.Collection;
-
 import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
 import android.support.v4.util.LruCache;
 
 import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.sqlbrite.BriteDatabase;
+import com.activeandroid.sqlbrite.SqlBrite;
 import com.activeandroid.util.Log;
 
+import java.util.Collection;
+
 public final class Cache {
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PUBLIC CONSTANTS
@@ -43,6 +44,10 @@
 
 	private static LruCache<String, Model> sEntities;
 
+	private static SqlBrite sSqlBrite;
+
+	private static BriteDatabase sDatabase;
+
 	private static boolean sIsInitialized = false;
 
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -65,6 +70,9 @@ public static synchronized void initialize(Configuration configuration) {
 		sContext = configuration.getContext();
 		sModelInfo = new ModelInfo(configuration);
 		sDatabaseHelper = new DatabaseHelper(configuration);
+		sSqlBrite = SqlBrite.create();
+		sDatabase = sSqlBrite.wrapDatabaseHelper(sDatabaseHelper);
+
 
 		// TODO: It would be nice to override sizeOf here and calculate the memory
 		// actually used, however at this point it seems like the reflection
@@ -102,8 +110,8 @@ public static boolean isInitialized() {
 		return sIsInitialized;
 	}
 
-	public static synchronized SQLiteDatabase openDatabase() {
-		return sDatabaseHelper.getWritableDatabase();
+	public static synchronized BriteDatabase openDatabase() {
+		return sDatabase;
 	}
 
 	public static synchronized void closeDatabase() {
@@ -155,4 +163,9 @@ public static synchronized TypeSerializer getParserForType(Class<?> type) {
 	public static synchronized String getTableName(Class<? extends Model> type) {
 		return sModelInfo.getTableInfo(type).getTableName();
 	}
+
+	public static DatabaseHelper getHelper(){
+		return sDatabaseHelper;
+	}
+
 }
diff --git a/src/com/activeandroid/Interface.java b/src/com/activeandroid/Interface.java
new file mode 100644
index 00000000..4f8e99be
--- /dev/null
+++ b/src/com/activeandroid/Interface.java
@@ -0,0 +1,9 @@
+package com.activeandroid;
+
+/**
+ * Created by Victor on 30/10/2015.
+ */
+public interface Interface<T> {
+
+    T getObject(T s);
+}
diff --git a/src/com/activeandroid/Model.java b/src/com/activeandroid/Model.java
index b6fe88d4..c8c50393 100644
--- a/src/com/activeandroid/Model.java
+++ b/src/com/activeandroid/Model.java
@@ -18,12 +18,12 @@
 
 import android.content.ContentValues;
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
 
 import com.activeandroid.content.ContentProvider;
 import com.activeandroid.query.Delete;
 import com.activeandroid.query.Select;
 import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.sqlbrite.BriteDatabase;
 import com.activeandroid.util.Log;
 import com.activeandroid.util.ReflectionUtils;
 import com.google.gson.annotations.SerializedName;
@@ -78,7 +78,7 @@ public final void delete() {
 	}
 
 	public final Long save() {
-		final SQLiteDatabase db = Cache.openDatabase();
+		final BriteDatabase db = Cache.openDatabase();
 		final ContentValues values = new ContentValues();
 
 		for (Field field : mTableInfo.getFields()) {
@@ -158,12 +158,12 @@ else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
 		}
 
 		if (mId == null) {
-			mId = db.insert(mTableInfo.getTableName(), null, values);
+			mId = db.insert(mTableInfo.getTableName(), values);
 		}
 		else {
 			int updated = db.update(mTableInfo.getTableName(), values, idName+"=" + mId, null);
             if(updated == 0) {
-                mId = db.insert(mTableInfo.getTableName(), null, values);
+                mId = db.insert(mTableInfo.getTableName(), values);
             }
 		}
 
diff --git a/src/com/activeandroid/content/ContentProvider.java b/src/com/activeandroid/content/ContentProvider.java
index b4a841d6..89e509d9 100644
--- a/src/com/activeandroid/content/ContentProvider.java
+++ b/src/com/activeandroid/content/ContentProvider.java
@@ -1,8 +1,5 @@
 package com.activeandroid.content;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import android.content.ContentValues;
 import android.content.UriMatcher;
 import android.database.Cursor;
@@ -15,6 +12,9 @@
 import com.activeandroid.Model;
 import com.activeandroid.TableInfo;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class ContentProvider extends android.content.ContentProvider {
 	//////////////////////////////////////////////////////////////////////////////////////
 	// PRIVATE CONSTANTS
@@ -93,7 +93,7 @@ public String getType(Uri uri) {
 	@Override
 	public Uri insert(Uri uri, ContentValues values) {
 		final Class<? extends Model> type = getModelType(uri);
-		final Long id = Cache.openDatabase().insert(Cache.getTableName(type), null, values);
+		final Long id = Cache.openDatabase().insert(Cache.getTableName(type), values);
 
 		if (id != null && id > 0) {
 			Uri retUri = createUri(type, id);
diff --git a/src/com/activeandroid/query/From.java b/src/com/activeandroid/query/From.java
index ab3837a9..b1a40a6d 100644
--- a/src/com/activeandroid/query/From.java
+++ b/src/com/activeandroid/query/From.java
@@ -28,6 +28,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import rx.Observable;
+
 public final class From implements Sqlable {
 	private Sqlable mQueryBase;
 
@@ -305,6 +307,16 @@ public String toCountSql() {
 		}
 	}
 
+    public <T extends Model> Observable<T> executeRx() {
+        if (mQueryBase instanceof Select) {
+            return SQLiteUtils.rawRxQuery(mType, toSql(), getArguments());
+
+        } else {
+            throw new IllegalArgumentException("Query must be instance of Select");
+
+        }
+    }
+
 	public <T extends Model> T executeSingle() {
 		if (mQueryBase instanceof Select) {
 			limit(1);
diff --git a/src/com/activeandroid/rx/RxSelect.java b/src/com/activeandroid/rx/RxSelect.java
new file mode 100644
index 00000000..a35eebfe
--- /dev/null
+++ b/src/com/activeandroid/rx/RxSelect.java
@@ -0,0 +1,208 @@
+package com.activeandroid.rx;
+
+
+import android.database.Cursor;
+import android.text.TextUtils;
+
+import com.activeandroid.Cache;
+import com.activeandroid.Model;
+import com.activeandroid.rxschedulers.AndroidSchedulers;
+import com.activeandroid.sqlbrite.SqlBrite;
+import com.activeandroid.util.SQLiteUtils;
+
+import java.util.List;
+
+import rx.functions.Func1;
+import rx.schedulers.Schedulers;
+
+/**
+ * Created by Victor on 30/10/2015.
+ */
+public class RxSelect<T extends Model> {
+
+    private Class<T> mType;
+    private String mAlias;
+    private String mWhere;
+    private String mLimit;
+    private String mGroupBy;
+    private String mHaving;
+    private String mOrderBy;
+    private String mOffset;
+
+    private RxSelect(Class<T> type) {
+        this.mType = type;
+    }
+
+    public static <T extends Model> RxSelect<T> from(Class<T> type) {
+        return new RxSelect<>(type);
+    }
+
+    public RxSelect<T> as(String alias) {
+        mAlias = alias;
+        return this;
+    }
+
+    public RxSelect<T> groupBy(String groupBy) {
+        mGroupBy = groupBy;
+        return this;
+    }
+
+    public RxSelect<T> where(String where) {
+        this.mWhere = where;
+        return this;
+    }
+
+    public RxSelect<T> orderBy(String orderBy) {
+        mOrderBy = orderBy;
+        return this;
+    }
+
+    public RxSelect<T> limit(int limit) {
+        return limit(String.valueOf(limit));
+    }
+
+    public RxSelect<T> limit(String limit) {
+        mLimit = limit;
+        return this;
+    }
+
+    public RxSelect<T> offset(int offset) {
+        return offset(String.valueOf(offset));
+    }
+
+    public RxSelect<T> offset(String offset) {
+        mOffset = offset;
+        return this;
+    }
+
+    public RxSelect<T> having(String having) {
+        mHaving = having;
+        return this;
+    }
+
+    public <T extends Model> rx.Observable<List<T>> execute() {
+
+        String sql = buildSql();
+
+        return Cache.openDatabase().createQuery(Cache.getTableName(mType), sql)
+                .subscribeOn(Schedulers.io())
+                .map(new Func1<SqlBrite.Query, List<T>>() {
+                    @Override
+                    public List<T> call(SqlBrite.Query query) {
+                        try {
+                            Cursor cursor = query.run();
+                            return SQLiteUtils.processCursor(mType, cursor);
+
+                        } catch (Exception ex) {
+                            ex.printStackTrace();
+                        }
+
+                        return null;
+
+                    }
+                })
+                .observeOn(AndroidSchedulers.mainThread());
+    }
+
+    public rx.Observable<T> executeSingle() {
+
+        String sql = buildSql();
+
+        return Cache.openDatabase().createQuery(Cache.getTableName(mType), sql)
+                .subscribeOn(Schedulers.io())
+                .map(new Func1<SqlBrite.Query, T>() {
+                    @Override
+                    public T call(SqlBrite.Query query) {
+                        try {
+                            Cursor cursor = query.run();
+                            if (cursor != null && cursor.getCount() > 0) {
+                                cursor.moveToFirst();
+                                Model model = (Model) mType.newInstance();
+                                model.loadFromCursor(cursor);
+                                return (T) model;
+                            }
+                        } catch (Exception ex) {
+                            ex.printStackTrace();
+                        }
+
+                        return null;
+
+                    }
+                })
+                .observeOn(AndroidSchedulers.mainThread());
+    }
+
+    private String buildSql() {
+        StringBuilder sql = new StringBuilder();
+
+        buildSelect(sql);
+        addFrom(sql);
+        addWhere(sql);
+        addLimit(sql);
+
+        return sql.toString();
+    }
+
+    private void buildSelect(final StringBuilder sql) {
+        sql.append("SELECT * ");
+    }
+
+    private void addFrom(final StringBuilder sql) {
+        sql.append("FROM ");
+        sql.append(Cache.getTableName(mType)).append(" ");
+
+        if (mAlias != null) {
+            sql.append("AS ");
+            sql.append(mAlias);
+            sql.append(" ");
+        }
+    }
+
+    private void addWhere(final StringBuilder sql) {
+        if (!TextUtils.isEmpty(mWhere)) {
+            sql.append("WHERE ");
+            sql.append(mWhere);
+            sql.append(" ");
+        }
+    }
+
+    private void addGroupBy(final StringBuilder sql) {
+        if (mGroupBy != null) {
+            sql.append("GROUP BY ");
+            sql.append(mGroupBy);
+            sql.append(" ");
+        }
+    }
+
+    private void addHaving(final StringBuilder sql) {
+        if (mHaving != null) {
+            sql.append("HAVING ");
+            sql.append(mHaving);
+            sql.append(" ");
+        }
+    }
+
+    private void addOrderBy(final StringBuilder sql) {
+        if (mOrderBy != null) {
+            sql.append("ORDER BY ");
+            sql.append(mOrderBy);
+            sql.append(" ");
+        }
+    }
+
+    private void addLimit(final StringBuilder sql) {
+        if (!TextUtils.isEmpty(mLimit)) {
+            sql.append("LIMIT ");
+            sql.append(mLimit);
+            sql.append(" ");
+        }
+    }
+
+    private void addOffset(final StringBuilder sql) {
+        if (mOffset != null) {
+            sql.append("OFFSET ");
+            sql.append(mOffset);
+            sql.append(" ");
+        }
+    }
+}
diff --git a/src/com/activeandroid/rxschedulers/AndroidSchedulers.java b/src/com/activeandroid/rxschedulers/AndroidSchedulers.java
new file mode 100644
index 00000000..54978670
--- /dev/null
+++ b/src/com/activeandroid/rxschedulers/AndroidSchedulers.java
@@ -0,0 +1,23 @@
+package com.activeandroid.rxschedulers;
+
+import android.os.Handler;
+import android.os.Looper;
+
+import rx.Scheduler;
+
+/** Android-specific Schedulers. */
+public final class AndroidSchedulers {
+    private AndroidSchedulers() {
+        throw new AssertionError("No instances");
+    }
+
+    private static final Scheduler MAIN_THREAD_SCHEDULER =
+            new HandlerScheduler(new Handler(Looper.getMainLooper()));
+
+    /** A {@link Scheduler} which executes actions on the Android UI thread. */
+    public static Scheduler mainThread() {
+        Scheduler scheduler =
+                RxAndroidPlugins.getInstance().getSchedulersHook().getMainThreadScheduler();
+        return scheduler != null ? scheduler : MAIN_THREAD_SCHEDULER;
+    }
+}
\ No newline at end of file
diff --git a/src/com/activeandroid/rxschedulers/HandlerScheduler.java b/src/com/activeandroid/rxschedulers/HandlerScheduler.java
new file mode 100644
index 00000000..f39f8ac4
--- /dev/null
+++ b/src/com/activeandroid/rxschedulers/HandlerScheduler.java
@@ -0,0 +1,83 @@
+package com.activeandroid.rxschedulers;
+
+
+import android.os.Handler;
+
+import java.util.concurrent.TimeUnit;
+
+import rx.Scheduler;
+import rx.Subscription;
+import rx.functions.Action0;
+import rx.internal.schedulers.ScheduledAction;
+import rx.subscriptions.CompositeSubscription;
+import rx.subscriptions.Subscriptions;
+
+/** A {@link Scheduler} backed by a {@link Handler}. */
+public final class HandlerScheduler extends Scheduler {
+    /** Create a {@link Scheduler} which uses {@code handler} to execute actions. */
+    public static HandlerScheduler from(Handler handler) {
+        if (handler == null) throw new NullPointerException("handler == null");
+        return new HandlerScheduler(handler);
+    }
+
+    private final Handler handler;
+
+    HandlerScheduler(Handler handler) {
+        this.handler = handler;
+    }
+
+    @Override
+    public Worker createWorker() {
+        return new HandlerWorker(handler);
+    }
+
+    static class HandlerWorker extends Worker {
+
+        private final Handler handler;
+
+        private final CompositeSubscription compositeSubscription = new CompositeSubscription();
+
+        HandlerWorker(Handler handler) {
+            this.handler = handler;
+        }
+
+        @Override
+        public void unsubscribe() {
+            compositeSubscription.unsubscribe();
+        }
+
+        @Override
+        public boolean isUnsubscribed() {
+            return compositeSubscription.isUnsubscribed();
+        }
+
+        @Override
+        public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
+            if (compositeSubscription.isUnsubscribed()) {
+                return Subscriptions.unsubscribed();
+            }
+
+            action = RxAndroidPlugins.getInstance().getSchedulersHook().onSchedule(action);
+
+            final ScheduledAction scheduledAction = new ScheduledAction(action);
+            scheduledAction.addParent(compositeSubscription);
+            compositeSubscription.add(scheduledAction);
+
+            handler.postDelayed(scheduledAction, unit.toMillis(delayTime));
+
+            scheduledAction.add(Subscriptions.create(new Action0() {
+                @Override
+                public void call() {
+                    handler.removeCallbacks(scheduledAction);
+                }
+            }));
+
+            return scheduledAction;
+        }
+
+        @Override
+        public Subscription schedule(final Action0 action) {
+            return schedule(action, 0, TimeUnit.MILLISECONDS);
+        }
+    }
+}
diff --git a/src/com/activeandroid/rxschedulers/RxAndroidPlugins.java b/src/com/activeandroid/rxschedulers/RxAndroidPlugins.java
new file mode 100644
index 00000000..20fe7e85
--- /dev/null
+++ b/src/com/activeandroid/rxschedulers/RxAndroidPlugins.java
@@ -0,0 +1,69 @@
+package com.activeandroid.rxschedulers;
+
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import rx.annotations.Beta;
+
+/**
+ * Registry for plugin implementations that allows global override and handles the retrieval of
+ * correct implementation based on order of precedence:
+ * <ol>
+ * <li>plugin registered globally via {@code register} methods in this class</li>
+ * <li>default implementation</li>
+ * </ol>
+ */
+public final class RxAndroidPlugins {
+    private static final RxAndroidPlugins INSTANCE = new RxAndroidPlugins();
+
+    public static RxAndroidPlugins getInstance() {
+        return INSTANCE;
+    }
+
+    private final AtomicReference<RxAndroidSchedulersHook> schedulersHook =
+            new AtomicReference<RxAndroidSchedulersHook>();
+
+    RxAndroidPlugins() {
+    }
+
+    /**
+     * Reset any explicit or default-set hooks.
+     * <p>
+     * Note: This should only be used for testing purposes.
+     */
+    @Beta
+    public void reset() {
+        schedulersHook.set(null);
+    }
+
+    /**
+     * Retrieves the instance of {@link RxAndroidSchedulersHook} to use based on order of
+     * precedence as defined in the {@link RxAndroidPlugins} class header.
+     * <p>
+     * Override the default by calling {@link #registerSchedulersHook(RxAndroidSchedulersHook)} or by
+     * setting the property {@code rxandroid.plugin.RxAndroidSchedulersHook.implementation} with the
+     * full classname to load.
+     */
+    public RxAndroidSchedulersHook getSchedulersHook() {
+        if (schedulersHook.get() == null) {
+            schedulersHook.compareAndSet(null, RxAndroidSchedulersHook.getDefaultInstance());
+            // We don't return from here but call get() again in case of thread-race so the winner will
+            // always get returned.
+        }
+        return schedulersHook.get();
+    }
+
+    /**
+     * Registers an {@link RxAndroidSchedulersHook} implementation as a global override of any
+     * injected or default implementations.
+     *
+     * @throws IllegalStateException if called more than once or after the default was initialized
+     * (if usage occurs before trying to register)
+     */
+    public void registerSchedulersHook(RxAndroidSchedulersHook impl) {
+        if (!schedulersHook.compareAndSet(null, impl)) {
+            throw new IllegalStateException(
+                    "Another strategy was already registered: " + schedulersHook.get());
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/com/activeandroid/rxschedulers/RxAndroidSchedulersHook.java b/src/com/activeandroid/rxschedulers/RxAndroidSchedulersHook.java
new file mode 100644
index 00000000..745723e6
--- /dev/null
+++ b/src/com/activeandroid/rxschedulers/RxAndroidSchedulersHook.java
@@ -0,0 +1,33 @@
+package com.activeandroid.rxschedulers;
+
+import rx.Scheduler;
+import rx.functions.Action0;
+
+public class RxAndroidSchedulersHook {
+    private static final RxAndroidSchedulersHook DEFAULT_INSTANCE = new RxAndroidSchedulersHook();
+
+    public static RxAndroidSchedulersHook getDefaultInstance() {
+        return DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Scheduler to return from {@link AndroidSchedulers#mainThread()} or {@code null} if default
+     * should be used.
+     * <p>
+     * This instance should be or behave like a stateless singleton.
+     */
+    public Scheduler getMainThreadScheduler() {
+        return null;
+    }
+
+    /**
+     * Invoked before the Action is handed over to the scheduler.  Can be used for
+     * wrapping/decorating/logging. The default is just a passthrough.
+     *
+     * @param action action to schedule
+     * @return wrapped action to schedule
+     */
+    public Action0 onSchedule(Action0 action) {
+        return action;
+    }
+}
\ No newline at end of file
diff --git a/src/com/activeandroid/sqlbrite/BackpressureBufferLastOperator.java b/src/com/activeandroid/sqlbrite/BackpressureBufferLastOperator.java
new file mode 100644
index 00000000..03773f55
--- /dev/null
+++ b/src/com/activeandroid/sqlbrite/BackpressureBufferLastOperator.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.activeandroid.sqlbrite;
+
+import rx.Observable.Operator;
+import rx.Producer;
+import rx.Subscriber;
+
+/** An operator which keeps the last emitted instance when backpressure has been applied. */
+final class BackpressureBufferLastOperator<T> implements Operator<T, T> {
+  static final Operator<Object, Object> instance = new BackpressureBufferLastOperator<>();
+
+  static <T> Operator<T, T> instance() {
+    //noinspection unchecked
+    return (Operator<T, T>) instance;
+  }
+
+  private BackpressureBufferLastOperator() {
+  }
+
+  @Override public Subscriber<? super T> call(final Subscriber<? super T> child) {
+    BufferLastSubscriber<T> parent = new BufferLastSubscriber<>(child);
+    child.add(parent);
+    child.setProducer(parent.producer);
+    return parent;
+  }
+
+  static final class BufferLastSubscriber<T> extends Subscriber<T> {
+    private static final Object NONE = new Object();
+
+    private final Subscriber<? super T> child;
+
+    private Object last = NONE; // Guarded by 'this'.
+    private long requested; // Guarded by 'this'. Starts at zero.
+
+    final Producer producer = new Producer() {
+      @Override public void request(long n) {
+        if (n < 0) {
+          throw new IllegalArgumentException("requested " + n + " < 0");
+        }
+        if (n == 0) {
+          return;
+        }
+
+        Object candidate;
+        synchronized (BufferLastSubscriber.this) {
+          candidate = last;
+
+          long currentRequested = requested;
+          if (Long.MAX_VALUE - n <= currentRequested) {
+            requested = Long.MAX_VALUE;
+          } else {
+            if (candidate != NONE) {
+              n--; // Decrement since we will be emitting a value.
+            }
+            requested = currentRequested + n;
+          }
+        }
+
+        // Only emit if the value is not the explicit NONE marker.
+        if (candidate != NONE) {
+          //noinspection unchecked
+          child.onNext((T) candidate);
+        }
+      }
+    };
+
+    public BufferLastSubscriber(Subscriber<? super T> child) {
+      this.child = child;
+    }
+
+    @Override public void onNext(T t) {
+      boolean emit = false;
+      synchronized (this) {
+        long currentRequested = requested;
+        if (currentRequested == Long.MAX_VALUE) {
+          // No need to decrement when the firehose is open.
+          emit = true;
+        } else if (currentRequested > 0) {
+          requested = currentRequested - 1;
+          emit = true;
+        } else {
+          last = t; // Not emitting, store for later.
+        }
+      }
+
+      if (emit) {
+        child.onNext(t);
+      }
+    }
+
+    @Override public void onStart() {
+      request(Long.MAX_VALUE);
+    }
+
+    @Override public void onCompleted() {
+      child.onCompleted();
+    }
+
+    @Override public void onError(Throwable e) {
+      child.onError(e);
+    }
+  }
+}
diff --git a/src/com/activeandroid/sqlbrite/BriteContentResolver.java b/src/com/activeandroid/sqlbrite/BriteContentResolver.java
new file mode 100644
index 00000000..35268c15
--- /dev/null
+++ b/src/com/activeandroid/sqlbrite/BriteContentResolver.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.activeandroid.sqlbrite;
+
+import android.content.ContentResolver;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+
+import java.util.Arrays;
+
+import rx.Observable;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
+import rx.functions.Action0;
+import rx.subscriptions.Subscriptions;
+
+import static com.activeandroid.sqlbrite.SqlBrite.Logger;
+import static com.activeandroid.sqlbrite.SqlBrite.Query;
+
+/**
+ * A lightweight wrapper around {@link ContentResolver} which allows for continuously observing
+ * the result of a query. Create using a {@link SqlBrite} instance.
+ */
+public final class BriteContentResolver {
+  private final Handler contentObserverHandler = new Handler(Looper.getMainLooper());
+
+  private final ContentResolver contentResolver;
+  private final Logger logger;
+
+  private volatile boolean logging;
+
+  BriteContentResolver(@NonNull ContentResolver contentResolver, @NonNull Logger logger) {
+    this.contentResolver = contentResolver;
+    this.logger = logger;
+  }
+
+  /** Control whether debug logging is enabled. */
+  public void setLoggingEnabled(boolean enabled) {
+    logging = enabled;
+  }
+
+  /**
+   * Create an observable which will notify subscribers with a {@linkplain Query query} for
+   * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
+   * returned from the {@link Query}.
+   * <p>
+   * Subscribers will receive an immediate notification for initial data as well as subsequent
+   * notifications for when the supplied {@code uri}'s data changes. Unsubscribe when you no longer
+   * want updates to a query.
+   * <p>
+   * Note: To skip the immediate notification and only receive subsequent notifications when data
+   * has changed call {@code skip(1)} on the returned observable.
+   * <p>
+   * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
+   * {@link Observable} will the operation occur.
+   *
+   * @see ContentResolver#query(Uri, String[], String, String[], String)
+   * @see ContentResolver#registerContentObserver(Uri, boolean, ContentObserver)
+   */
+  @CheckResult @NonNull
+  public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final String[] projection,
+      @Nullable final String selection, @Nullable final String[] selectionArgs, @Nullable
+      final String sortOrder, final boolean notifyForDescendents) {
+    final Query query = new Query() {
+      @Override public Cursor run() {
+        return contentResolver.query(uri, projection, selection, selectionArgs, sortOrder);
+      }
+    };
+    OnSubscribe<Query> subscribe = new OnSubscribe<Query>() {
+      @Override public void call(final Subscriber<? super Query> subscriber) {
+        final ContentObserver observer = new ContentObserver(contentObserverHandler) {
+          @Override public void onChange(boolean selfChange) {
+            if (logging) {
+              log("QUERY\n  uri: %s\n  projection: %s\n  selection: %s\n  selectionArgs: %s\n  "
+                      + "sortOrder: %s\n  notifyForDescendents: %s", uri,
+                  Arrays.toString(projection), selection, Arrays.toString(selectionArgs), sortOrder,
+                  notifyForDescendents);
+            }
+            subscriber.onNext(query);
+          }
+        };
+        contentResolver.registerContentObserver(uri, notifyForDescendents, observer);
+        subscriber.add(Subscriptions.create(new Action0() {
+          @Override public void call() {
+            contentResolver.unregisterContentObserver(observer);
+          }
+        }));
+      }
+    };
+    Observable<Query> queryObservable = Observable.create(subscribe) //
+        .startWith(query) //
+        .lift(BackpressureBufferLastOperator.<Query>instance());
+    return new QueryObservable(queryObservable);
+  }
+
+  private void log(String message, Object... args) {
+    if (args.length > 0) message = String.format(message, args);
+    logger.log(message);
+  }
+}
diff --git a/src/com/activeandroid/sqlbrite/BriteDatabase.java b/src/com/activeandroid/sqlbrite/BriteDatabase.java
new file mode 100644
index 00000000..aa9b1e93
--- /dev/null
+++ b/src/com/activeandroid/sqlbrite/BriteDatabase.java
@@ -0,0 +1,616 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.activeandroid.sqlbrite;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteTransactionListener;
+import android.support.annotation.CheckResult;
+import android.support.annotation.IntDef;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.activeandroid.sqlbrite.SqlBrite.Query;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
+import rx.Observable;
+import rx.functions.Func1;
+import rx.subjects.PublishSubject;
+
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_ABORT;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_FAIL;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_NONE;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_ROLLBACK;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+/**
+ * A lightweight wrapper around {@link SQLiteOpenHelper} which allows for continuously observing
+ * the result of a query. Create using a {@link SqlBrite} instance.
+ */
+public final class BriteDatabase implements Closeable {
+  private static final Set<String> INITIAL_TRIGGER = Collections.singleton("<initial>");
+
+  private final SQLiteOpenHelper helper;
+  private final SqlBrite.Logger logger;
+
+  // Package-private to avoid synthetic accessor method for 'transaction' instance.
+  final ThreadLocal<SqliteTransaction> transactions = new ThreadLocal<>();
+  /** Publishes sets of tables which have changed. */
+  private final PublishSubject<Set<String>> triggers = PublishSubject.create();
+
+  private final Transaction transaction = new Transaction() {
+    @Override public void markSuccessful() {
+      if (logging) log("TXN SUCCESS %s", transactions.get());
+      getWriteableDatabase().setTransactionSuccessful();
+    }
+
+    @Override public boolean yieldIfContendedSafely() {
+      return getWriteableDatabase().yieldIfContendedSafely();
+    }
+
+    @Override public boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit) {
+      return getWriteableDatabase().yieldIfContendedSafely(sleepUnit.toMillis(sleepAmount));
+    }
+
+    @Override public void end() {
+      SqliteTransaction transaction = transactions.get();
+      if (transaction == null) {
+        throw new IllegalStateException("Not in transaction.");
+      }
+      SqliteTransaction newTransaction = transaction.parent;
+      transactions.set(newTransaction);
+      if (logging) log("TXN END %s", transaction);
+      getWriteableDatabase().endTransaction();
+      // Send the triggers after ending the transaction in the DB.
+      if (transaction.commit) {
+        sendTableTrigger(transaction);
+      }
+    }
+
+    @Override public void close() {
+      end();
+    }
+  };
+
+  // Read and write guarded by 'databaseLock'. Lazily initialized. Use methods to access.
+  private volatile SQLiteDatabase readableDatabase;
+  private volatile SQLiteDatabase writeableDatabase;
+  private final Object databaseLock = new Object();
+
+  // Package-private to avoid synthetic accessor method for 'transaction' instance.
+  volatile boolean logging;
+
+  BriteDatabase(@NonNull SQLiteOpenHelper helper, @NonNull SqlBrite.Logger logger) {
+    this.helper = helper;
+    this.logger = logger;
+  }
+
+  /**
+   * Control whether debug logging is enabled.
+   */
+  public void setLoggingEnabled(boolean enabled) {
+    logging = enabled;
+  }
+
+  private SQLiteDatabase getReadableDatabase() {
+    SQLiteDatabase db = readableDatabase;
+    if (db == null) {
+      synchronized (databaseLock) {
+        db = readableDatabase;
+        if (db == null) {
+          if (logging) log("Creating readable database");
+          db = readableDatabase = helper.getReadableDatabase();
+        }
+      }
+    }
+    return db;
+  }
+
+  // Package-private to avoid synthetic accessor method for 'transaction' instance.
+  SQLiteDatabase getWriteableDatabase() {
+    SQLiteDatabase db = writeableDatabase;
+    if (db == null) {
+      synchronized (databaseLock) {
+        db = writeableDatabase;
+        if (db == null) {
+          if (logging) log("Creating writeable database");
+          db = writeableDatabase = helper.getWritableDatabase();
+        }
+      }
+    }
+    return db;
+  }
+
+  private void sendTableTrigger(Set<String> tables) {
+    SqliteTransaction transaction = transactions.get();
+    if (transaction != null) {
+      transaction.addAll(tables);
+    } else {
+      if (logging) log("TRIGGER %s", tables);
+      triggers.onNext(tables);
+    }
+  }
+
+  /**
+   * Begin a transaction for this thread.
+   * <p>
+   * Transactions may nest. If the transaction is not in progress, then a database connection is
+   * obtained and a new transaction is started. Otherwise, a nested transaction is started.
+   * <p>
+   * Each call to {@code newTransaction} must be matched exactly by a call to
+   * {@link Transaction#end()}. To mark a transaction as successful, call
+   * {@link Transaction#markSuccessful()} before calling {@link Transaction#end()}. If the
+   * transaction is not successful, or if any of its nested transactions were not successful, then
+   * the entire transaction will be rolled back when the outermost transaction is ended.
+   * <p>
+   * Transactions queue up all query notifications until they have been applied.
+   * <p>
+   * Here is the standard idiom for transactions:
+   *
+   * <pre>{@code
+   * try (Transaction transaction = db.newTransaction()) {
+   *   ...
+   *   transaction.markSuccessful();
+   * }
+   * }</pre>
+   *
+   * Manually call {@link Transaction#end()} when try-with-resources is not available:
+   * <pre>{@code
+   * Transaction transaction = db.newTransaction();
+   * try {
+   *   ...
+   *   transaction.markSuccessful();
+   * } finally {
+   *   transaction.end();
+   * }
+   * }</pre>
+   *
+   *
+   * @see SQLiteDatabase#beginTransaction()
+   */
+  @CheckResult @NonNull
+  public Transaction newTransaction() {
+    SqliteTransaction transaction = new SqliteTransaction(transactions.get());
+    transactions.set(transaction);
+    if (logging) log("TXN BEGIN %s", transaction);
+    getWriteableDatabase().beginTransactionWithListener(transaction);
+
+    return this.transaction;
+  }
+
+  /**
+   * Close the underlying {@link SQLiteOpenHelper} and remove cached readable and writeable
+   * databases. This does not prevent existing observables from retaining existing references as
+   * well as attempting to create new ones for new subscriptions.
+   */
+  @Override public void close() throws IOException {
+    synchronized (databaseLock) {
+      readableDatabase = null;
+      writeableDatabase = null;
+      helper.close();
+    }
+  }
+
+  /**
+   * Create an observable which will notify subscribers with a {@linkplain Query query} for
+   * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
+   * returned from the {@link Query}.
+   * <p>
+   * Subscribers will receive an immediate notification for initial data as well as subsequent
+   * notifications for when the supplied {@code table}'s data changes through the {@code insert},
+   * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
+   * updates to a query.
+   * <p>
+   * Note: To skip the immediate notification and only receive subsequent notifications when data
+   * has changed call {@code skip(1)} on the returned observable.
+   * <p>
+   * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
+   * {@link Observable} will the operation occur.
+   *
+   * @see SQLiteDatabase#rawQuery(String, String[])
+   */
+  @CheckResult @NonNull
+  public QueryObservable createQuery(@NonNull final String table, @NonNull String sql,
+      @NonNull String... args) {
+    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
+      @Override public Boolean call(Set<String> triggers) {
+        return triggers.contains(table);
+      }
+
+      @Override public String toString() {
+        return table;
+      }
+    };
+    return createQuery(tableFilter, sql, args);
+  }
+
+  /**
+   * See {@link #createQuery(String, String, String...)} for usage. This overload allows for
+   * monitoring multiple tables for changes.
+   *
+   * @see SQLiteDatabase#rawQuery(String, String[])
+   */
+  @CheckResult @NonNull
+  public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonNull String sql,
+      @NonNull String... args) {
+    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
+      @Override public Boolean call(Set<String> triggers) {
+        for (String table : tables) {
+          if (triggers.contains(table)) {
+            return true;
+          }
+        }
+        return false;
+      }
+
+      @Override public String toString() {
+        return tables.toString();
+      }
+    };
+    return createQuery(tableFilter, sql, args);
+  }
+
+  @CheckResult @NonNull
+  private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilter,
+      final String sql, final String... args) {
+    if (transactions.get() != null) {
+      throw new IllegalStateException("Cannot create observable query in transaction. "
+          + "Use query() for a query inside a transaction.");
+    }
+
+    final Query query = new Query() {
+      @Override public Cursor run() {
+        if (transactions.get() != null) {
+          throw new IllegalStateException("Cannot execute observable query in a transaction.");
+        }
+        return getReadableDatabase().rawQuery(sql, args);
+      }
+
+      @Override public String toString() {
+        return sql;
+      }
+    };
+
+    Observable<Query> queryObservable = triggers //
+        .filter(tableFilter) // Only trigger on tables we care about.
+        .startWith(INITIAL_TRIGGER) // Immediately execute the query for initial value.
+        .map(new Func1<Set<String>, Query>() {
+          @Override public Query call(Set<String> trigger) {
+            if (transactions.get() != null) {
+              throw new IllegalStateException(
+                  "Cannot subscribe to observable query in a transaction.");
+            }
+            if (logging) {
+              log("QUERY\n  trigger: %s\n  tables: %s\n  sql: %s\n  args: %s", trigger, tableFilter,
+                  sql, Arrays.toString(args));
+            }
+            return query;
+          }
+        }) //
+        .lift(BackpressureBufferLastOperator.<Query>instance());
+    return new QueryObservable(queryObservable);
+  }
+
+  /**
+   * Runs the provided SQL and returns a {@link Cursor} over the result set.
+   *
+   * @see SQLiteDatabase#rawQuery(String, String[])
+   */
+  @CheckResult // TODO @WorkerThread
+  public Cursor query(@NonNull String sql, @NonNull String... args) {
+    if (logging) log("QUERY\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
+    return getReadableDatabase().rawQuery(sql, args);
+  }
+
+  public Cursor query(String table, String[] proyection, String selection, String[] selectionArgs, String groupBy, String having, String orderBy){
+    if (logging) log("QUERY\n  table: %s\n  args: %s", table, Arrays.toString(selectionArgs));
+    return getReadableDatabase().query(table, proyection, selection, selectionArgs, groupBy, having, orderBy);
+  }
+
+  /**
+   * Insert a row into the specified {@code table} and notify any subscribed queries.
+   *
+   * @see SQLiteDatabase#insert(String, String, ContentValues)
+   */
+  // TODO @WorkerThread
+  public long insert(@NonNull String table, @NonNull ContentValues values) {
+    return insert(table, values, CONFLICT_NONE);
+  }
+
+  /**
+   * Insert a row into the specified {@code table} and notify any subscribed queries.
+   *
+   * @see SQLiteDatabase#insertWithOnConflict(String, String, ContentValues, int)
+   */
+  // TODO @WorkerThread
+  public long insert(@NonNull String table, @NonNull ContentValues values,
+      @ConflictAlgorithm int conflictAlgorithm) {
+    SQLiteDatabase db = getWriteableDatabase();
+
+    if (logging) {
+      log("INSERT\n  table: %s\n  values: %s\n  conflictAlgorithm: %s", table, values,
+          conflictString(conflictAlgorithm));
+    }
+    long rowId = db.insertWithOnConflict(table, null, values, conflictAlgorithm);
+
+    if (logging) log("INSERT id: %s", rowId);
+
+    if (rowId != -1) {
+      // Only send a table trigger if the insert was successful.
+      sendTableTrigger(Collections.singleton(table));
+    }
+    return rowId;
+  }
+
+  /**
+   * Delete rows from the specified {@code table} and notify any subscribed queries. This method
+   * will not trigger a notification if no rows were deleted.
+   *
+   * @see SQLiteDatabase#delete(String, String, String[])
+   */
+  // TODO @WorkerThread
+  public int delete(@NonNull String table, @Nullable String whereClause,
+      @Nullable String... whereArgs) {
+    SQLiteDatabase db = getWriteableDatabase();
+
+    if (logging) {
+      log("DELETE\n  table: %s\n  whereClause: %s\n  whereArgs: %s", table, whereClause,
+          Arrays.toString(whereArgs));
+    }
+    int rows = db.delete(table, whereClause, whereArgs);
+
+    if (logging) log("DELETE affected %s %s", rows, rows != 1 ? "rows" : "row");
+
+    if (rows > 0) {
+      // Only send a table trigger if rows were affected.
+      sendTableTrigger(Collections.singleton(table));
+    }
+    return rows;
+  }
+
+  /**
+   * Update rows in the specified {@code table} and notify any subscribed queries. This method
+   * will not trigger a notification if no rows were updated.
+   *
+   * @see SQLiteDatabase#update(String, ContentValues, String, String[])
+   */
+  // TODO @WorkerThread
+  public int update(@NonNull String table, @NonNull ContentValues values,
+      @Nullable String whereClause, @Nullable String... whereArgs) {
+    return update(table, values, CONFLICT_NONE, whereClause, whereArgs);
+  }
+
+  /**
+   * Update rows in the specified {@code table} and notify any subscribed queries. This method
+   * will not trigger a notification if no rows were updated.
+   *
+   * @see SQLiteDatabase#updateWithOnConflict(String, ContentValues, String, String[], int)
+   */
+  // TODO @WorkerThread
+  public int update(@NonNull String table, @NonNull ContentValues values,
+      @ConflictAlgorithm int conflictAlgorithm, @Nullable String whereClause,
+      @Nullable String... whereArgs) {
+    SQLiteDatabase db = getWriteableDatabase();
+
+    if (logging) {
+      log("UPDATE\n  table: %s\n  values: %s\n  whereClause: %s\n  whereArgs: %s\n  conflictAlgorithm: %s",
+          table, values, whereClause, Arrays.toString(whereArgs),
+          conflictString(conflictAlgorithm));
+    }
+    int rows = db.updateWithOnConflict(table, values, whereClause, whereArgs, conflictAlgorithm);
+
+    if (logging) log("UPDATE affected %s %s", rows, rows != 1 ? "rows" : "row");
+
+    if (rows > 0) {
+      // Only send a table trigger if rows were affected.
+      sendTableTrigger(Collections.singleton(table));
+    }
+    return rows;
+  }
+
+  /**
+   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+   * returns data. No data can be returned (such as the number of affected rows). Instead, use
+   * {@link #insert}, {@link #update}, et al, when possible.
+   * <p>
+   * No notifications will be sent to queries if {@code sql} affects the data of a table.
+   *
+   * @see SQLiteDatabase#execSQL(String)
+   */
+  public void execute(String sql) {
+    SQLiteDatabase db = getWriteableDatabase();
+    db.execSQL(sql);
+  }
+
+  /**
+   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+   * returns data. No data can be returned (such as the number of affected rows). Instead, use
+   * {@link #insert}, {@link #update}, et al, when possible.
+   * <p>
+   * No notifications will be sent to queries if {@code sql} affects the data of a table.
+   *
+   * @see SQLiteDatabase#execSQL(String, Object[])
+   */
+  public void execute(String sql, Object... args) {
+    SQLiteDatabase db = getWriteableDatabase();
+    db.execSQL(sql, args);
+  }
+
+  /**
+   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+   * returns data. No data can be returned (such as the number of affected rows). Instead, use
+   * {@link #insert}, {@link #update}, et al, when possible.
+   * <p>
+   * A notification to queries for {@code table} will be sent after the statement is executed.
+   *
+   * @see SQLiteDatabase#execSQL(String)
+   */
+  public void executeAndTrigger(String table, String sql) {
+    SQLiteDatabase db = getWriteableDatabase();
+    db.execSQL(sql);
+
+    sendTableTrigger(Collections.singleton(table));
+  }
+
+  /**
+   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+   * returns data. No data can be returned (such as the number of affected rows). Instead, use
+   * {@link #insert}, {@link #update}, et al, when possible.
+   * <p>
+   * A notification to queries for {@code table} will be sent after the statement is executed.
+   *
+   * @see SQLiteDatabase#execSQL(String, Object[])
+   */
+  public void executeAndTrigger(String table, String sql, Object... args) {
+    SQLiteDatabase db = getWriteableDatabase();
+    db.execSQL(sql, args);
+
+    sendTableTrigger(Collections.singleton(table));
+  }
+
+  /** An in-progress database transaction. */
+  public interface Transaction extends Closeable {
+    /**
+     * End a transaction. See {@link #newTransaction()} for notes about how to use this and when
+     * transactions are committed and rolled back.
+     *
+     * @see SQLiteDatabase#endTransaction()
+     */
+    // TODO @WorkerThread
+    void end();
+
+    /**
+     * Marks the current transaction as successful. Do not do any more database work between
+     * calling this and calling {@link #end()}. Do as little non-database work as possible in that
+     * situation too. If any errors are encountered between this and {@link #end()} the transaction
+     * will still be committed.
+     *
+     * @see SQLiteDatabase#setTransactionSuccessful()
+     */
+    // TODO @WorkerThread
+    void markSuccessful();
+
+    /**
+     * Temporarily end the transaction to let other threads run. The transaction is assumed to be
+     * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
+     * returns a new transaction will have been created but not marked as successful. This assumes
+     * that there are no nested transactions (newTransaction has only been called once) and will
+     * throw an exception if that is not the case.
+     *
+     * @return true if the transaction was yielded
+     *
+     * @see SQLiteDatabase#yieldIfContendedSafely()
+     */
+    // TODO @WorkerThread
+    boolean yieldIfContendedSafely();
+
+    /**
+     * Temporarily end the transaction to let other threads run. The transaction is assumed to be
+     * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
+     * returns a new transaction will have been created but not marked as successful. This assumes
+     * that there are no nested transactions (newTransaction has only been called once) and will
+     * throw an exception if that is not the case.
+     *
+     * @param sleepAmount if greater than 0, sleep this long before starting a new transaction if
+     *   the lock was actually yielded. This will allow other background threads to make some
+     *   more progress than they would if we started the transaction immediately.
+     * @return true if the transaction was yielded
+     *
+     * @see SQLiteDatabase#yieldIfContendedSafely(long)
+     */
+    // TODO @WorkerThread
+    boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit);
+
+    /**
+     * Equivalent to calling {@link #end()}
+     */
+    // TODO @WorkerThread
+    @Override void close();
+  }
+
+  @IntDef({
+      CONFLICT_ABORT,
+      CONFLICT_FAIL,
+      CONFLICT_IGNORE,
+      CONFLICT_NONE,
+      CONFLICT_REPLACE,
+      CONFLICT_ROLLBACK
+  })
+  @Retention(SOURCE)
+  public @interface ConflictAlgorithm {
+  }
+
+  private void log(String message, Object... args) {
+    if (args.length > 0) message = String.format(message, args);
+    logger.log(message);
+  }
+
+  private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
+    switch (conflictAlgorithm) {
+      case CONFLICT_ABORT:
+        return "abort";
+      case CONFLICT_FAIL:
+        return "fail";
+      case CONFLICT_IGNORE:
+        return "ignore";
+      case CONFLICT_NONE:
+        return "none";
+      case CONFLICT_REPLACE:
+        return "replace";
+      case CONFLICT_ROLLBACK:
+        return "rollback";
+      default:
+        return "unknown (" + conflictAlgorithm + ')';
+    }
+  }
+
+  static final class SqliteTransaction extends LinkedHashSet<String>
+      implements SQLiteTransactionListener {
+    final SqliteTransaction parent;
+    boolean commit;
+
+    SqliteTransaction(SqliteTransaction parent) {
+      this.parent = parent;
+    }
+
+    @Override public void onBegin() {
+    }
+
+    @Override public void onCommit() {
+      commit = true;
+    }
+
+    @Override public void onRollback() {
+    }
+
+    @Override public String toString() {
+      String name = String.format("%08x", System.identityHashCode(this));
+      return parent == null ? name : name + " [" + parent.toString() + ']';
+    }
+  }
+}
diff --git a/src/com/activeandroid/sqlbrite/QueryObservable.java b/src/com/activeandroid/sqlbrite/QueryObservable.java
new file mode 100644
index 00000000..138eda54
--- /dev/null
+++ b/src/com/activeandroid/sqlbrite/QueryObservable.java
@@ -0,0 +1,84 @@
+package com.activeandroid.sqlbrite;
+
+import android.database.Cursor;
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import com.activeandroid.sqlbrite.SqlBrite.Query;
+import java.util.List;
+import rx.Observable;
+import rx.Subscriber;
+import rx.functions.Func1;
+
+/** An {@link Observable} of {@link Query} which offers query-specific convenience operators. */
+public final class QueryObservable extends Observable<Query> {
+  QueryObservable(final Observable<Query> o) {
+    super(new OnSubscribe<Query>() {
+      @Override public void call(Subscriber<? super Query> subscriber) {
+        o.unsafeSubscribe(subscriber);
+      }
+    });
+  }
+
+  /**
+   * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
+   * emitted {@link Query} which returns a single row to {@code T}.
+   * <p>
+   * It is an error for a query to pass through this operator with more than 1 row in its result
+   * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
+   * do not emit an item.
+   * <p>
+   * This method is equivalent to:
+   * <pre>{@code
+   * flatMap(q -> q.asRows(mapper).take(1))
+   * }</pre>
+   *
+   * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+   */
+  @CheckResult @NonNull
+  public final <T> Observable<T> mapToOne(@NonNull final Func1<Cursor, T> mapper) {
+    return lift(new QueryToOneOperator<>(mapper, false, null));
+  }
+
+  /**
+   * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
+   * emitted {@link Query} which returns a single row to {@code T}.
+   * <p>
+   * It is an error for a query to pass through this operator with more than 1 row in its result
+   * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
+   * emit {@code defaultValue}.
+   * <p>
+   * This method is equivalent to:
+   * <pre>{@code
+   * flatMap(q -> q.asRows(mapper).take(1).defaultIfEmpty(defaultValue))
+   * }</pre>
+   *
+   * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+   * @param defaultValue Value returned if result set is empty
+   */
+  @CheckResult @NonNull
+  public final <T> Observable<T> mapToOneOrDefault(@NonNull final Func1<Cursor, T> mapper,
+      T defaultValue) {
+    return lift(new QueryToOneOperator<>(mapper, true, defaultValue));
+  }
+
+  /**
+   * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
+   * emitted {@link Query} to a {@code List<T>}.
+   * <p>
+   * Be careful using this operator as it will always consume the entire cursor and create objects
+   * for each row, every time this observable emits a new query. On tables whose queries update
+   * frequently or very large result sets this can result in the creation of many objects.
+   * <p>
+   * This method is equivalent to:
+   * <pre>{@code
+   * flatMap(q -> q.asRows(mapper).toList())
+   * }</pre>
+   * Consider using {@link Query#asRows} if you need to limit or filter in memory.
+   *
+   * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+   */
+  @CheckResult @NonNull
+  public final <T> Observable<List<T>> mapToList(@NonNull final Func1<Cursor, T> mapper) {
+    return lift(new QueryToListOperator<>(mapper));
+  }
+}
diff --git a/src/com/activeandroid/sqlbrite/QueryToListOperator.java b/src/com/activeandroid/sqlbrite/QueryToListOperator.java
new file mode 100644
index 00000000..ce4430d2
--- /dev/null
+++ b/src/com/activeandroid/sqlbrite/QueryToListOperator.java
@@ -0,0 +1,57 @@
+package com.activeandroid.sqlbrite;
+
+import android.database.Cursor;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import rx.Observable;
+import rx.Subscriber;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnErrorThrowable;
+import rx.functions.Func1;
+
+final class QueryToListOperator<T> implements Observable.Operator<List<T>, SqlBrite.Query> {
+  private final Func1<Cursor, T> mapper;
+
+  QueryToListOperator(Func1<Cursor, T> mapper) {
+    this.mapper = mapper;
+  }
+
+  @Override
+  public Subscriber<? super SqlBrite.Query> call(final Subscriber<? super List<T>> subscriber) {
+    return new Subscriber<SqlBrite.Query>(subscriber) {
+      @Override public void onNext(SqlBrite.Query query) {
+        try {
+          Cursor cursor = query.run();
+          List<T> items = new ArrayList<>(cursor.getCount());
+          try {
+            for (int i = 1; cursor.moveToNext() && !subscriber.isUnsubscribed(); i++) {
+              T item = mapper.call(cursor);
+              if (item == null) {
+                throw new NullPointerException("Mapper returned null for row " + i);
+              }
+              items.add(item);
+            }
+          } finally {
+            cursor.close();
+          }
+          if (!subscriber.isUnsubscribed()) {
+            subscriber.onNext(items);
+          }
+        } catch (Throwable e) {
+          Exceptions.throwIfFatal(e);
+          onError(OnErrorThrowable.addValueAsLastCause(e, query.toString()));
+        }
+      }
+
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable e) {
+        subscriber.onError(e);
+      }
+    };
+  }
+}
diff --git a/src/com/activeandroid/sqlbrite/QueryToOneOperator.java b/src/com/activeandroid/sqlbrite/QueryToOneOperator.java
new file mode 100644
index 00000000..d280f7a2
--- /dev/null
+++ b/src/com/activeandroid/sqlbrite/QueryToOneOperator.java
@@ -0,0 +1,63 @@
+package com.activeandroid.sqlbrite;
+
+import android.database.Cursor;
+
+import rx.Observable;
+import rx.Subscriber;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnErrorThrowable;
+import rx.functions.Func1;
+
+final class QueryToOneOperator<T> implements Observable.Operator<T, SqlBrite.Query> {
+  private final Func1<Cursor, T> mapper;
+  private boolean emitDefault;
+  private T defaultValue;
+
+  QueryToOneOperator(Func1<Cursor, T> mapper, boolean emitDefault, T defaultValue) {
+    this.mapper = mapper;
+    this.emitDefault = emitDefault;
+    this.defaultValue = defaultValue;
+  }
+
+  @Override public Subscriber<? super SqlBrite.Query> call(final Subscriber<? super T> subscriber) {
+    return new Subscriber<SqlBrite.Query>(subscriber) {
+      @Override public void onNext(SqlBrite.Query query) {
+        try {
+          T item = null;
+          Cursor cursor = query.run();
+          try {
+            if (cursor.moveToNext()) {
+              item = mapper.call(cursor);
+              if (item == null) {
+                throw new NullPointerException("Mapper returned null for row 1");
+              }
+              if (cursor.moveToNext()) {
+                throw new IllegalStateException("Cursor returned more than 1 row");
+              }
+            }
+          } finally {
+            cursor.close();
+          }
+          if (!subscriber.isUnsubscribed()) {
+            if (item != null) {
+              subscriber.onNext(item);
+            } else if (emitDefault) {
+              subscriber.onNext(defaultValue);
+            }
+          }
+        } catch (Throwable e) {
+          Exceptions.throwIfFatal(e);
+          onError(OnErrorThrowable.addValueAsLastCause(e, query.toString()));
+        }
+      }
+
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable e) {
+        subscriber.onError(e);
+      }
+    };
+  }
+}
diff --git a/src/com/activeandroid/sqlbrite/SqlBrite.java b/src/com/activeandroid/sqlbrite/SqlBrite.java
new file mode 100644
index 00000000..b7033365
--- /dev/null
+++ b/src/com/activeandroid/sqlbrite/SqlBrite.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.activeandroid.sqlbrite;
+
+import android.content.ContentResolver;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import rx.Observable;
+import rx.Subscriber;
+import rx.functions.Func1;
+
+/**
+ * A lightweight wrapper around {@link SQLiteOpenHelper} which allows for continuously observing
+ * the result of a query.
+ */
+public final class SqlBrite {
+  @CheckResult @NonNull
+  public static SqlBrite create() {
+    return create(new Logger() {
+      @Override public void log(String message) {
+        Log.d("SqlBrite", message);
+      }
+    });
+  }
+
+  @CheckResult @NonNull
+  public static SqlBrite create(@NonNull Logger logger) {
+    return new SqlBrite(logger);
+  }
+
+  private final Logger logger;
+
+  private SqlBrite(@NonNull Logger logger) {
+    this.logger = logger;
+  }
+
+  /**
+   * Wrap a {@link SQLiteOpenHelper} for observable queries.
+   * <p>
+   * While not strictly required, instances of this class assume that they will be the only ones
+   * interacting with the underlying {@link SQLiteOpenHelper} and it is required for automatic
+   * notifications of table changes to work. See {@linkplain BriteDatabase#createQuery the
+   * <code>query</code> method} for more information on that behavior.
+   */
+  @CheckResult @NonNull
+  public BriteDatabase wrapDatabaseHelper(@NonNull SQLiteOpenHelper helper) {
+    return new BriteDatabase(helper, logger);
+  }
+
+  /** Wrap a {@link ContentResolver} for observable queries. */
+  @CheckResult @NonNull
+  public BriteContentResolver wrapContentProvider(@NonNull ContentResolver contentResolver) {
+    return new BriteContentResolver(contentResolver, logger);
+  }
+
+  /** An executable query. */
+  public static abstract class Query {
+    /** Execute the query on the underlying database and return the resulting cursor. */
+    @CheckResult // TODO @WorkerThread
+    // TODO Implementations might return null, which is gross. Throw?
+    public abstract Cursor run();
+
+    /**
+     * Execute the query on the underlying database and return an Observable of each row mapped to
+     * {@code T} by {@code mapper}.
+     * <p>
+     * Standard usage of this operation is in {@code flatMap}:
+     * <pre>{@code
+     * flatMap(q -> q.asRows(Item.MAPPER).toList())
+     * }</pre>
+     * However, the above is a more-verbose but identical operation as
+     * {@link QueryObservable#mapToList}. This {@code asRows} method should be used when you need
+     * to limit or filter the items separate from the actual query.
+     * <pre>{@code
+     * flatMap(q -> q.asRows(Item.MAPPER).take(5).toList())
+     * // or...
+     * flatMap(q -> q.asRows(Item.MAPPER).filter(i -> i.isActive).toList())
+     * }</pre>
+     * <p>
+     * Note: Limiting results or filtering will almost always be faster in the database as part of
+     * a query and should be preferred, where possible.
+     */
+    @CheckResult @NonNull
+    public final <T> Observable<T> asRows(final Func1<Cursor, T> mapper) {
+      return Observable.create(new Observable.OnSubscribe<T>() {
+        @Override public void call(Subscriber<? super T> subscriber) {
+          Cursor cursor = run();
+          try {
+            while (cursor.moveToNext() && !subscriber.isUnsubscribed()) {
+              subscriber.onNext(mapper.call(cursor));
+            }
+          } finally {
+            cursor.close();
+          }
+          if (!subscriber.isUnsubscribed()) {
+            subscriber.onCompleted();
+          }
+        }
+      });
+    }
+  }
+
+  /** A simple indirection for logging debug messages. */
+  public interface Logger {
+    void log(String message);
+  }
+}
diff --git a/src/com/activeandroid/util/SQLiteUtils.java b/src/com/activeandroid/util/SQLiteUtils.java
index cbf41eae..968db841 100644
--- a/src/com/activeandroid/util/SQLiteUtils.java
+++ b/src/com/activeandroid/util/SQLiteUtils.java
@@ -25,382 +25,408 @@
 import com.activeandroid.TableInfo;
 import com.activeandroid.annotation.Column;
 import com.activeandroid.annotation.Column.ConflictAction;
+import com.activeandroid.rxschedulers.AndroidSchedulers;
 import com.activeandroid.serializer.TypeSerializer;
+import com.activeandroid.sqlbrite.QueryObservable;
+import com.activeandroid.sqlbrite.SqlBrite;
 
-import java.lang.Long;
-import java.lang.String;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.util.Arrays;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import rx.Observable;
+import rx.functions.Func1;
+import rx.schedulers.Schedulers;
+
 public final class SQLiteUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// ENUMERATIONS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public enum SQLiteType {
-		INTEGER, REAL, TEXT, BLOB
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONTSANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
-		{
-			put(byte.class, SQLiteType.INTEGER);
-			put(short.class, SQLiteType.INTEGER);
-			put(int.class, SQLiteType.INTEGER);
-			put(long.class, SQLiteType.INTEGER);
-			put(float.class, SQLiteType.REAL);
-			put(double.class, SQLiteType.REAL);
-			put(boolean.class, SQLiteType.INTEGER);
-			put(char.class, SQLiteType.TEXT);
-			put(byte[].class, SQLiteType.BLOB);
-			put(Byte.class, SQLiteType.INTEGER);
-			put(Short.class, SQLiteType.INTEGER);
-			put(Integer.class, SQLiteType.INTEGER);
-			put(Long.class, SQLiteType.INTEGER);
-			put(Float.class, SQLiteType.REAL);
-			put(Double.class, SQLiteType.REAL);
-			put(Boolean.class, SQLiteType.INTEGER);
-			put(Character.class, SQLiteType.TEXT);
-			put(String.class, SQLiteType.TEXT);
-			put(Byte[].class, SQLiteType.BLOB);
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static HashMap<String, List<String>> sIndexGroupMap;
-	private static HashMap<String, List<String>> sUniqueGroupMap;
-	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void execSql(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSql(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-
-	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-		List<T> entities = processCursor(type, cursor);
-		cursor.close();
-
-		return entities;
-	}
-	  
-	public static int intQuery(final String sql, final String[] selectionArgs) {
-        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
+    //////////////////////////////////////////////////////////////////////////////////////
+    // ENUMERATIONS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public enum SQLiteType {
+        INTEGER, REAL, TEXT, BLOB
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE CONTSANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @SuppressWarnings("serial")
+    private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
+        {
+            put(byte.class, SQLiteType.INTEGER);
+            put(short.class, SQLiteType.INTEGER);
+            put(int.class, SQLiteType.INTEGER);
+            put(long.class, SQLiteType.INTEGER);
+            put(float.class, SQLiteType.REAL);
+            put(double.class, SQLiteType.REAL);
+            put(boolean.class, SQLiteType.INTEGER);
+            put(char.class, SQLiteType.TEXT);
+            put(byte[].class, SQLiteType.BLOB);
+            put(Byte.class, SQLiteType.INTEGER);
+            put(Short.class, SQLiteType.INTEGER);
+            put(Integer.class, SQLiteType.INTEGER);
+            put(Long.class, SQLiteType.INTEGER);
+            put(Float.class, SQLiteType.REAL);
+            put(Double.class, SQLiteType.REAL);
+            put(Boolean.class, SQLiteType.INTEGER);
+            put(Character.class, SQLiteType.TEXT);
+            put(String.class, SQLiteType.TEXT);
+            put(Byte[].class, SQLiteType.BLOB);
+        }
+    };
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private static HashMap<String, List<String>> sIndexGroupMap;
+    private static HashMap<String, List<String>> sUniqueGroupMap;
+    private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static void execSql(String sql) {
+        Cache.openDatabase().execute(sql);
+    }
+
+    public static void execSql(String sql, Object[] bindArgs) {
+        Cache.openDatabase().execute(sql, bindArgs);
+    }
+
+    public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
+        Cursor cursor = Cache.openDatabase().query(sql, selectionArgs);
+        List<T> entities = processCursor(type, cursor);
+        cursor.close();
+
+        return entities;
+    }
+
+    public static <T extends Model> Observable<T> rawRxQuery(final Class<? extends Model> type, String sql, String[] selectionArgs) {
+
+        TableInfo tableInfo = new TableInfo(type);
+        QueryObservable query = Cache.openDatabase().createQuery(tableInfo.getTableName(), sql, selectionArgs);
+
+        return query.subscribeOn(Schedulers.io())
+                .map(new Func1<SqlBrite.Query, T>() {
+                    @Override
+                    public T call(SqlBrite.Query query) {
+                        try {
+
+                            Cursor cursor = query.run();
+                            return (T) processCursor(type, cursor);
+
+                        } catch (Exception ex) {
+                            ex.printStackTrace();
+                        }
+
+                        return null;
+
+                    }
+                })
+                .observeOn(AndroidSchedulers.mainThread());
+
+    }
+
+    public static int intQuery(final String sql, final String[] selectionArgs) {
+        final Cursor cursor = Cache.openDatabase().query(sql, selectionArgs);
         final int number = processIntCursor(cursor);
         cursor.close();
 
         return number;
-	}
+    }
 
-	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		List<T> entities = rawQuery(type, sql, selectionArgs);
+    public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
+        List<T> entities = rawQuery(type, sql, selectionArgs);
 
-		if (entities.size() > 0) {
-			return entities.get(0);
-		}
+        if (entities.size() > 0) {
+            return entities.get(0);
+        }
 
-		return null;
-	}
+        return null;
+    }
 
-	// Database creation
+    // Database creation
 
-	public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sUniqueGroupMap = new HashMap<String, List<String>>();
-		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
+    public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
+        final ArrayList<String> definitions = new ArrayList<String>();
+        sUniqueGroupMap = new HashMap<String, List<String>>();
+        sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
 
-		for (Field field : tableInfo.getFields()) {
-			createUniqueColumnDefinition(tableInfo, field);
-		}
+        for (Field field : tableInfo.getFields()) {
+            createUniqueColumnDefinition(tableInfo, field);
+        }
 
-		if (sUniqueGroupMap.isEmpty()) {
-			return definitions;
-		}
+        if (sUniqueGroupMap.isEmpty()) {
+            return definitions;
+        }
 
-		Set<String> keySet = sUniqueGroupMap.keySet();
-		for (String key : keySet) {
-			List<String> group = sUniqueGroupMap.get(key);
-			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
+        Set<String> keySet = sUniqueGroupMap.keySet();
+        for (String key : keySet) {
+            List<String> group = sUniqueGroupMap.get(key);
+            ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
 
-			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
-					TextUtils.join(", ", group), conflictAction.toString()));
-		}
+            definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
+                    TextUtils.join(", ", group), conflictAction.toString()));
+        }
 
-		return definitions;
-	}
+        return definitions;
+    }
 
-	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
+    public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
+        final String name = tableInfo.getColumnName(field);
+        final Column column = field.getAnnotation(Column.class);
 
         if (field.getName().equals("mId")) {
             return;
         }
 
-		String[] groups = column.uniqueGroups();
-		ConflictAction[] conflictActions = column.onUniqueConflicts();
-		if (groups.length != conflictActions.length)
-			return;
+        String[] groups = column.uniqueGroups();
+        ConflictAction[] conflictActions = column.onUniqueConflicts();
+        if (groups.length != conflictActions.length)
+            return;
 
-		for (int i = 0; i < groups.length; i++) {
-			String group = groups[i];
-			ConflictAction conflictAction = conflictActions[i];
+        for (int i = 0; i < groups.length; i++) {
+            String group = groups[i];
+            ConflictAction conflictAction = conflictActions[i];
 
-			if (TextUtils.isEmpty(group))
-				continue;
+            if (TextUtils.isEmpty(group))
+                continue;
 
-			List<String> list = sUniqueGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-			list.add(name);
+            List<String> list = sUniqueGroupMap.get(group);
+            if (list == null) {
+                list = new ArrayList<String>();
+            }
+            list.add(name);
 
-			sUniqueGroupMap.put(group, list);
-			sOnUniqueConflictsMap.put(group, conflictAction);
-		}
-	}
+            sUniqueGroupMap.put(group, list);
+            sOnUniqueConflictsMap.put(group, conflictAction);
+        }
+    }
 
-	public static String[] createIndexDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sIndexGroupMap = new HashMap<String, List<String>>();
+    public static String[] createIndexDefinition(TableInfo tableInfo) {
+        final ArrayList<String> definitions = new ArrayList<String>();
+        sIndexGroupMap = new HashMap<String, List<String>>();
 
-		for (Field field : tableInfo.getFields()) {
-			createIndexColumnDefinition(tableInfo, field);
-		}
+        for (Field field : tableInfo.getFields()) {
+            createIndexColumnDefinition(tableInfo, field);
+        }
 
-		if (sIndexGroupMap.isEmpty()) {
-			return new String[0];
-		}
+        if (sIndexGroupMap.isEmpty()) {
+            return new String[0];
+        }
 
-		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
-			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
-					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
-					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
-		}
+        for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
+            definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
+                    "index_" + tableInfo.getTableName() + "_" + entry.getKey(),
+                    tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
+        }
 
-		return definitions.toArray(new String[definitions.size()]);
-	}
+        return definitions.toArray(new String[definitions.size()]);
+    }
 
-	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
+    public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
+        final String name = tableInfo.getColumnName(field);
+        final Column column = field.getAnnotation(Column.class);
 
         if (field.getName().equals("mId")) {
             return;
         }
 
-		if (column.index()) {
-			List<String> list = new ArrayList<String>();
-			list.add(name);
-			sIndexGroupMap.put(name, list);
-		}
-
-		String[] groups = column.indexGroups();
-		for (String group : groups) {
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sIndexGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-
-			list.add(name);
-			sIndexGroupMap.put(group, list);
-		}
-	}
-
-	public static String createTableDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-
-		for (Field field : tableInfo.getFields()) {
-			String definition = createColumnDefinition(tableInfo, field);
-			if (!TextUtils.isEmpty(definition)) {
-				definitions.add(definition);
-			}
-		}
-
-		definitions.addAll(createUniqueDefinition(tableInfo));
-
-		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
-				TextUtils.join(", ", definitions));
-	}
-
-	@SuppressWarnings("unchecked")
-	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
-		StringBuilder definition = new StringBuilder();
-
-		Class<?> type = field.getType();
-		final String name = tableInfo.getColumnName(field);
-		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-		final Column column = field.getAnnotation(Column.class);
-
-		if (typeSerializer != null) {
-			type = typeSerializer.getSerializedType();
-		}
-
-		if (TYPE_MAP.containsKey(type)) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(TYPE_MAP.get(type).toString());
-		}
-		else if (ReflectionUtils.isModel(type)) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(SQLiteType.INTEGER.toString());
-		}
-		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(SQLiteType.TEXT.toString());
-		}
-
-		if (!TextUtils.isEmpty(definition)) {
-
-			if (name.equals(tableInfo.getIdName())) {
-				definition.append(" PRIMARY KEY AUTOINCREMENT");
-			}else if(column!=null){
-				if (column.length() > -1) {
-					definition.append("(");
-					definition.append(column.length());
-					definition.append(")");
-				}
-
-				if (column.notNull()) {
-					definition.append(" NOT NULL ON CONFLICT ");
-					definition.append(column.onNullConflict().toString());
-				}
-
-				if (column.unique()) {
-					definition.append(" UNIQUE ON CONFLICT ");
-					definition.append(column.onUniqueConflict().toString());
-				}
-			}
-
-			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
-				definition.append(" REFERENCES ");
-				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
-				definition.append("("+tableInfo.getIdName()+")");
-				definition.append(" ON DELETE ");
-				definition.append(column.onDelete().toString().replace("_", " "));
-				definition.append(" ON UPDATE ");
-				definition.append(column.onUpdate().toString().replace("_", " "));
-			}
-		}
-		else {
-			Log.e("No type mapping for: " + type.toString());
-		}
-
-		return definition.toString();
-	}
-
-	@SuppressWarnings("unchecked")
-	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		String idName = tableInfo.getIdName();
-		final List<T> entities = new ArrayList<T>();
-
-		try {
-			Constructor<?> entityConstructor = type.getConstructor();
-
-			if (cursor.moveToFirst()) {
+        if (column.index()) {
+            List<String> list = new ArrayList<String>();
+            list.add(name);
+            sIndexGroupMap.put(name, list);
+        }
+
+        String[] groups = column.indexGroups();
+        for (String group : groups) {
+            if (TextUtils.isEmpty(group))
+                continue;
+
+            List<String> list = sIndexGroupMap.get(group);
+            if (list == null) {
+                list = new ArrayList<String>();
+            }
+
+            list.add(name);
+            sIndexGroupMap.put(group, list);
+        }
+    }
+
+    public static String createTableDefinition(TableInfo tableInfo) {
+        final ArrayList<String> definitions = new ArrayList<String>();
+
+        for (Field field : tableInfo.getFields()) {
+            String definition = createColumnDefinition(tableInfo, field);
+            if (!TextUtils.isEmpty(definition)) {
+                definitions.add(definition);
+            }
+        }
+
+        definitions.addAll(createUniqueDefinition(tableInfo));
+
+        return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
+                TextUtils.join(", ", definitions));
+    }
+
+    @SuppressWarnings("unchecked")
+    public static String createColumnDefinition(TableInfo tableInfo, Field field) {
+        StringBuilder definition = new StringBuilder();
+
+        Class<?> type = field.getType();
+        final String name = tableInfo.getColumnName(field);
+        final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
+        final Column column = field.getAnnotation(Column.class);
+
+        if (typeSerializer != null) {
+            type = typeSerializer.getSerializedType();
+        }
+
+        if (TYPE_MAP.containsKey(type)) {
+            definition.append(name);
+            definition.append(" ");
+            definition.append(TYPE_MAP.get(type).toString());
+        } else if (ReflectionUtils.isModel(type)) {
+            definition.append(name);
+            definition.append(" ");
+            definition.append(SQLiteType.INTEGER.toString());
+        } else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
+            definition.append(name);
+            definition.append(" ");
+            definition.append(SQLiteType.TEXT.toString());
+        }
+
+        if (!TextUtils.isEmpty(definition)) {
+
+            if (name.equals(tableInfo.getIdName())) {
+                definition.append(" PRIMARY KEY AUTOINCREMENT");
+            } else if (column != null) {
+                if (column.length() > -1) {
+                    definition.append("(");
+                    definition.append(column.length());
+                    definition.append(")");
+                }
+
+                if (column.notNull()) {
+                    definition.append(" NOT NULL ON CONFLICT ");
+                    definition.append(column.onNullConflict().toString());
+                }
+
+                if (column.unique()) {
+                    definition.append(" UNIQUE ON CONFLICT ");
+                    definition.append(column.onUniqueConflict().toString());
+                }
+            }
+
+            if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type)) {
+                definition.append(" REFERENCES ");
+                definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
+                definition.append("(" + tableInfo.getIdName() + ")");
+                definition.append(" ON DELETE ");
+                definition.append(column.onDelete().toString().replace("_", " "));
+                definition.append(" ON UPDATE ");
+                definition.append(column.onUpdate().toString().replace("_", " "));
+            }
+        } else {
+            Log.e("No type mapping for: " + type.toString());
+        }
+
+        return definition.toString();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        String idName = tableInfo.getIdName();
+        final List<T> entities = new ArrayList<T>();
+
+        try {
+            Constructor<?> entityConstructor = type.getConstructor();
+
+            if (cursor.moveToFirst()) {
                 /**
                  * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
                  * when the cursor have multiple columns with same name obtained from join tables.
                  */
                 List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-				do {
-					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
-					if (entity == null) {
-						entity = (T) entityConstructor.newInstance();
-					}
-
-					entity.loadFromCursor(cursor);
-					entities.add((T) entity);
-				}
-				while (cursor.moveToNext());
-			}
-
-		}
-		catch (NoSuchMethodException e) {
-			throw new RuntimeException(
-                "Your model " + type.getName() + " does not define a default " +
-                "constructor. The default constructor is required for " +
-                "now in ActiveAndroid models, as the process to " +
-                "populate the ORM model is : " +
-                "1. instantiate default model " +
-                "2. populate fields"
+                do {
+                    Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
+                    if (entity == null) {
+                        entity = (T) entityConstructor.newInstance();
+                    }
+
+                    entity.loadFromCursor(cursor);
+                    entities.add((T) entity);
+                }
+                while (cursor.moveToNext());
+            }
+
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException(
+                    "Your model " + type.getName() + " does not define a default " +
+                            "constructor. The default constructor is required for " +
+                            "now in ActiveAndroid models, as the process to " +
+                            "populate the ORM model is : " +
+                            "1. instantiate default model " +
+                            "2. populate fields"
             );
-		}
-		catch (Exception e) {
-			Log.e("Failed to process cursor.", e);
-		}
+        } catch (Exception e) {
+            Log.e("Failed to process cursor.", e);
+        }
 
-		return entities;
-	}
+        return entities;
+    }
 
-	private static int processIntCursor(final Cursor cursor) {
+    private static int processIntCursor(final Cursor cursor) {
         if (cursor.moveToFirst()) {
             return cursor.getInt(0);
-	    }
+        }
         return 0;
     }
 
-	public static List<String> lexSqlScript(String sqlScript) {
-		ArrayList<String> sl = new ArrayList<String>();
-		boolean inString = false, quoteNext = false;
-		StringBuilder b = new StringBuilder(100);
+    public static List<String> lexSqlScript(String sqlScript) {
+        ArrayList<String> sl = new ArrayList<String>();
+        boolean inString = false, quoteNext = false;
+        StringBuilder b = new StringBuilder(100);
 
-		for (int i = 0; i < sqlScript.length(); i++) {
-			char c = sqlScript.charAt(i);
+        for (int i = 0; i < sqlScript.length(); i++) {
+            char c = sqlScript.charAt(i);
 
-			if (c == ';' && !inString && !quoteNext) {
-				sl.add(b.toString());
-				b = new StringBuilder(100);
-				inString = false;
-				quoteNext = false;
-				continue;
-			}
+            if (c == ';' && !inString && !quoteNext) {
+                sl.add(b.toString());
+                b = new StringBuilder(100);
+                inString = false;
+                quoteNext = false;
+                continue;
+            }
 
-			if (c == '\'' && !quoteNext) {
-				inString = !inString;
-			}
+            if (c == '\'' && !quoteNext) {
+                inString = !inString;
+            }
 
-			quoteNext = c == '\\' && !quoteNext;
+            quoteNext = c == '\\' && !quoteNext;
 
-			b.append(c);
-		}
+            b.append(c);
+        }
 
-		if (b.length() > 0) {
-			sl.add(b.toString());
-		}
+        if (b.length() > 0) {
+            sl.add(b.toString());
+        }
 
-		return sl;
-	}
+        return sl;
+    }
 }
