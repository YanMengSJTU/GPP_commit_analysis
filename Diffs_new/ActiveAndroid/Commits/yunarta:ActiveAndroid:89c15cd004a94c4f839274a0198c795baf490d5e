diff --git a/build.gradle b/build.gradle
index 5594e43b..d9e3850f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -10,6 +10,12 @@ sourceSets {
 			srcDir 'src'
 		}
 	}
+
+	test {
+		java {
+			srcDir 'tests/src'
+		}
+	}
 }
 
 dependencies {
diff --git a/src/com/activeandroid/sebbia/ActiveAndroid.java b/src/com/activeandroid/sebbia/ActiveAndroid.java
index 902c33ba..240c0f6d 100644
--- a/src/com/activeandroid/sebbia/ActiveAndroid.java
+++ b/src/com/activeandroid/sebbia/ActiveAndroid.java
@@ -21,66 +21,81 @@
 
 import com.activeandroid.sebbia.util.Log;
 
-public final class ActiveAndroid {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void initialize(Context context) {
-		initialize(new Configuration.Builder(context).create());
-	}
-
-	public static void initialize(Configuration configuration) {
-		initialize(configuration, false);
-	}
-
-	public static void initialize(Context context, boolean loggingEnabled) {
-		initialize(new Configuration.Builder(context).create(), loggingEnabled);
-	}
-
-	public static void initialize(Configuration configuration, boolean loggingEnabled) {
-		// Set logging enabled first
-		setLoggingEnabled(loggingEnabled);
-		Cache.initialize(configuration);
-	}
-
-	public static void clearCache() {
-		Cache.clear();
-	}
-
-	public static void dispose() {
-		Cache.dispose();
-	}
-
-	public static void setLoggingEnabled(boolean enabled) {
-		Log.setEnabled(enabled);
-	}
-
-	public static SQLiteDatabase getDatabase() {
-		return Cache.openDatabase();
-	}
-
-	public static void beginTransaction() {
-		Cache.openDatabase().beginTransaction();
-	}
-
-	public static void endTransaction() {
-		Cache.openDatabase().endTransaction();
-	}
-
-	public static void setTransactionSuccessful() {
-		Cache.openDatabase().setTransactionSuccessful();
-	}
-
-	public static boolean inTransaction() {
-		return Cache.openDatabase().inTransaction();
-	}
-
-	public static void execSQL(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSQL(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
+public final class ActiveAndroid
+{
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static void initialize(Context context)
+    {
+        initialize(new Configuration.Builder(context).create());
+    }
+
+    public static void initialize(Configuration configuration)
+    {
+        initialize(configuration, false);
+    }
+
+    public static void initialize(Context context, boolean loggingEnabled)
+    {
+        initialize(new Configuration.Builder(context).create(), loggingEnabled);
+    }
+
+    public static void initialize(Configuration configuration, boolean loggingEnabled)
+    {
+        // Set logging enabled first
+        setLoggingEnabled(loggingEnabled);
+        Cache.initialize(configuration);
+    }
+
+    public static void clearCache()
+    {
+        Cache.clear();
+    }
+
+    public static void dispose()
+    {
+        Cache.dispose();
+    }
+
+    public static void setLoggingEnabled(boolean enabled)
+    {
+        Log.setEnabled(enabled);
+    }
+
+    public static SQLiteDatabase getDatabase(String database)
+    {
+        return Cache.openDatabase(database);
+    }
+
+    public static void beginTransaction(String database)
+    {
+        Cache.openDatabase(database).beginTransaction();
+    }
+
+    public static void endTransaction(String database)
+    {
+        Cache.openDatabase(database).endTransaction();
+    }
+
+    public static void setTransactionSuccessful(String database)
+    {
+        Cache.openDatabase(database).setTransactionSuccessful();
+    }
+
+    public static boolean inTransaction(String database)
+    {
+        return Cache.openDatabase(database).inTransaction();
+    }
+
+    public static void execSQL(String sql, String database)
+    {
+        Cache.openDatabase(database).execSQL(sql);
+    }
+
+    public static void execSQL(String sql, Object[] bindArgs, String database)
+    {
+        Cache.openDatabase(database).execSQL(sql, bindArgs);
+    }
 }
diff --git a/src/com/activeandroid/sebbia/Cache.java b/src/com/activeandroid/sebbia/Cache.java
index c4d93bb5..7828392b 100644
--- a/src/com/activeandroid/sebbia/Cache.java
+++ b/src/com/activeandroid/sebbia/Cache.java
@@ -16,13 +16,10 @@
  * limitations under the License.
  */
 
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.support.v4.util.LruCache;
+import android.util.SparseArray;
 
 import com.activeandroid.sebbia.annotation.DoNotGenerate;
 import com.activeandroid.sebbia.internal.EmptyModelFiller;
@@ -31,188 +28,258 @@
 import com.activeandroid.sebbia.util.Log;
 import com.activeandroid.sebbia.util.ReflectionUtils;
 
-public final class Cache {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+public final class Cache
+{
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static final int DEFAULT_CACHE_SIZE = 1024;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private static Context sContext;
+
+    private static ModelInfo sModelInfo;
+
+    private static SparseArray<DatabaseHelper> sDatabaseHelper;
+
+    private static LruCache<String, Model> sEntities;
+
+    private static boolean sIsInitialized = false;
+
+    private static Map<Class<? extends Model>, ModelFiller> sFillers;
+    private static int                                      sVersion;
+    private static String                                   sSqlParser;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Cache()
+    {
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static synchronized void initialize(Configuration configuration)
+    {
+        if (sIsInitialized)
+        {
+            Log.v("ActiveAndroid already initialized.");
+            return;
+        }
+
+        sContext = configuration.getContext();
+        sModelInfo = new ModelInfo(configuration);
+
+        sVersion = configuration.getDatabaseVersion();
+        sSqlParser = configuration.getSqlParser();
+
+        sDatabaseHelper = new SparseArray<DatabaseHelper>();
+        // sDatabaseHelper = new DatabaseHelper(configuration.getContext(), configuration.getDatabaseName(), sVersion, sSqlParser);
+
+        // TODO: It would be nice to override sizeOf here and calculate the memory
+        // actually used, however at this point it seems like the reflection
+        // required would be too costly to be of any benefit. We'll just set a max
+        // object size instead.
+        sEntities = new LruCache<String, Model>(configuration.getCacheSize());
 
-	public static final int DEFAULT_CACHE_SIZE = 1024;
+        initializeModelFillers();
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+        // openDatabase(database.hashCode());
 
-	private static Context sContext;
+        sIsInitialized = true;
 
-	private static ModelInfo sModelInfo;
-	private static DatabaseHelper sDatabaseHelper;
+        Log.v("ActiveAndroid initialized successfully.");
+    }
 
-	private static LruCache<String, Model> sEntities;
 
-	private static boolean sIsInitialized = false;
-	
-	private static Map<Class<? extends Model>, ModelFiller> sFillers;
+    public static synchronized void clear()
+    {
+        sEntities.evictAll();
+        Log.v("Cache cleared.");
+    }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
+    public static synchronized void dispose()
+    {
+        int size = sDatabaseHelper.size();
+        for (int i = 0; i < size; i++)
+        {
+            DatabaseHelper helper = sDatabaseHelper.valueAt(i);
+            helper.close();
+        }
 
-	private Cache() {
-	}
+        sEntities = null;
+        sModelInfo = null;
+        sDatabaseHelper = null;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+        sIsInitialized = false;
 
-	public static synchronized void initialize(Configuration configuration) {
-		if (sIsInitialized) {
-			Log.v("ActiveAndroid already initialized.");
-			return;
-		}
+        Log.v("ActiveAndroid disposed. Call initialize to use library.");
+    }
 
-		sContext = configuration.getContext();
-		sModelInfo = new ModelInfo(configuration);
-		sDatabaseHelper = new DatabaseHelper(configuration);
+    // Database access
 
-		// TODO: It would be nice to override sizeOf here and calculate the memory
-		// actually used, however at this point it seems like the reflection
-		// required would be too costly to be of any benefit. We'll just set a max
-		// object size instead.
-		sEntities = new LruCache<String, Model>(configuration.getCacheSize());
-		
-		initializeModelFillers();
-
-		openDatabase();
-
-		sIsInitialized = true;
-
-		Log.v("ActiveAndroid initialized successfully.");
-	}
-
-	
-	public static synchronized void clear() {
-		sEntities.evictAll();
-		Log.v("Cache cleared.");
-	}
-
-	public static synchronized void dispose() {
-		closeDatabase();
-
-		sEntities = null;
-		sModelInfo = null;
-		sDatabaseHelper = null;
-
-		sIsInitialized = false;
-
-		Log.v("ActiveAndroid disposed. Call initialize to use library.");
-	}
-
-	// Database access
-	
-	public static boolean isInitialized() {
-		return sIsInitialized;
-	}
-
-	public static synchronized SQLiteDatabase openDatabase() {
-		return sDatabaseHelper.getWritableDatabase();
-	}
-
-	public static synchronized void closeDatabase() {
-		if (sDatabaseHelper != null) {
-			sDatabaseHelper.close();
-		}
-	}
-
-	// Context access
-
-	public static Context getContext() {
-		return sContext;
-	}
-
-	// Entity cache
-
-	public static String getIdentifier(Class<? extends Model> type, Long id) {
-		return getTableName(type) + "@" + id;
-	}
-
-	public static String getIdentifier(Model entity) {
-		return getIdentifier(entity.getClass(), entity.getId());
-	}
-
-	public static synchronized void addEntity(Model entity) {
-		sEntities.put(getIdentifier(entity), entity);
-	}
-
-	public static synchronized Model getEntity(Class<? extends Model> type, long id) {
-		return sEntities.get(getIdentifier(type, id));
-	}
-
-	public static synchronized void removeEntity(Model entity) {
-		sEntities.remove(getIdentifier(entity));
-	}
-
-	// Model cache
-
-	public static synchronized Collection<TableInfo> getTableInfos() {
-		return sModelInfo.getTableInfos();
-	}
-
-	public static synchronized TableInfo getTableInfo(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type);
-	}
-
-	public static synchronized TypeSerializer getParserForType(Class<?> type) {
-		return sModelInfo.getTypeSerializer(type);
-	}
-
-	public static synchronized String getTableName(Class<? extends Model> type) {
-		return sModelInfo.getTableInfo(type).getTableName();
-	}
-	
-	static ModelFiller getFiller(Class<? extends Model> type) {
-		return sFillers.get(type);
-	}
-	
-	private static void initializeModelFillers() {
-		sFillers = new HashMap<Class<? extends Model>, ModelFiller>();
-		for (TableInfo tableInfo : sModelInfo.getTableInfos()) {
-			try {
-				Class<? extends Model> type = tableInfo.getType(); 
-				if (!isDoNotGenerate(type))
-					sFillers.put(type, instantiateFiller(type));
-			} catch (IllegalAccessException e) {
-				throw new RuntimeException(e);
-			} catch (InstantiationException e) {
-				throw new RuntimeException(e);
-			}
-		}
-		
-		
-	}
-	
-	private static boolean isDoNotGenerate(Class<?> clazz) {
-		if (clazz.isAnnotationPresent(DoNotGenerate.class))
-			return true;
-		if (clazz.getSuperclass() != null)
-			return isDoNotGenerate(clazz.getSuperclass());
-		return false;
-	}
-	
-	@SuppressWarnings("unchecked")
-	private static ModelFiller instantiateFiller(Class<? extends Model> type) throws IllegalAccessException, InstantiationException {
-		ModelFiller modelFiller = sFillers.get(type);
-		if (modelFiller == null) {
-			String fillerClassName = type.getName() + ModelFiller.SUFFIX;
-			try {
-				Class<? extends ModelFiller> fillerType = (Class<? extends ModelFiller>) Class.forName(fillerClassName);
-				modelFiller = fillerType.newInstance();
-			} catch (ClassNotFoundException e) {
-				modelFiller = new EmptyModelFiller();
-			}
-			if (type.getSuperclass() != null && ReflectionUtils.isModel(type.getSuperclass())) {
-				modelFiller.superModelFiller = instantiateFiller((Class<? extends Model>) type.getSuperclass());
-			}
-		}
-		return modelFiller;
-	}
+    public static boolean isInitialized()
+    {
+        return sIsInitialized;
+    }
+
+    public static synchronized SQLiteDatabase openDatabase(String database)
+    {
+        int key = database.hashCode();
+
+        DatabaseHelper helper = sDatabaseHelper.get(key);
+        if (helper == null)
+        {
+            helper = new DatabaseHelper(sContext, database, sVersion, sSqlParser);
+            sDatabaseHelper.put(key, helper);
+        }
+
+        return helper.getWritableDatabase();
+    }
+
+    public static synchronized void closeDatabase(String database)
+    {
+        int key = database.hashCode();
+
+        DatabaseHelper helper = sDatabaseHelper.get(key);
+        if (helper != null)
+        {
+            helper.close();
+        }
+    }
+
+    // Context access
+
+    public static Context getContext()
+    {
+        return sContext;
+    }
+
+    // Entity cache
+
+    public static String getIdentifier(Class<? extends Model> type, Long id)
+    {
+        return getTableName(type) + "@" + id;
+    }
+
+    public static String getIdentifier(Model entity)
+    {
+        return getIdentifier(entity.getClass(), entity.getId());
+    }
+
+    public static synchronized void addEntity(Model entity)
+    {
+        sEntities.put(getIdentifier(entity), entity);
+    }
+
+    public static synchronized Model getEntity(Class<? extends Model> type, long id)
+    {
+        return sEntities.get(getIdentifier(type, id));
+    }
+
+    public static synchronized void removeEntity(Model entity)
+    {
+        sEntities.remove(getIdentifier(entity));
+    }
+
+    // Model cache
+
+    public static synchronized Collection<TableInfo> getTableInfos()
+    {
+        return sModelInfo.getTableInfos();
+    }
+
+    public static synchronized TableInfo getTableInfo(Class<? extends Model> type)
+    {
+        return sModelInfo.getTableInfo(type);
+    }
+
+    public static synchronized TypeSerializer getParserForType(Class<?> type)
+    {
+        return sModelInfo.getTypeSerializer(type);
+    }
+
+    public static synchronized String getTableName(Class<? extends Model> type)
+    {
+        return sModelInfo.getTableInfo(type).getTableName();
+    }
+
+    static ModelFiller getFiller(Class<? extends Model> type)
+    {
+        return sFillers.get(type);
+    }
+
+    private static void initializeModelFillers()
+    {
+        sFillers = new HashMap<Class<? extends Model>, ModelFiller>();
+        for (TableInfo tableInfo : sModelInfo.getTableInfos())
+        {
+            try
+            {
+                Class<? extends Model> type = tableInfo.getType();
+                if (!isDoNotGenerate(type))
+                {
+                    sFillers.put(type, instantiateFiller(type));
+                }
+            }
+            catch (IllegalAccessException e)
+            {
+                throw new RuntimeException(e);
+            }
+            catch (InstantiationException e)
+            {
+                throw new RuntimeException(e);
+            }
+        }
+
+
+    }
+
+    private static boolean isDoNotGenerate(Class<?> clazz)
+    {
+        if (clazz.isAnnotationPresent(DoNotGenerate.class))
+        {
+            return true;
+        }
+        if (clazz.getSuperclass() != null)
+        {
+            return isDoNotGenerate(clazz.getSuperclass());
+        }
+        return false;
+    }
+
+    @SuppressWarnings("unchecked")
+    private static ModelFiller instantiateFiller(Class<? extends Model> type) throws IllegalAccessException, InstantiationException
+    {
+        ModelFiller modelFiller = sFillers.get(type);
+        if (modelFiller == null)
+        {
+            String fillerClassName = type.getName() + ModelFiller.SUFFIX;
+            try
+            {
+                Class<? extends ModelFiller> fillerType = (Class<? extends ModelFiller>) Class.forName(fillerClassName);
+                modelFiller = fillerType.newInstance();
+            }
+            catch (ClassNotFoundException e)
+            {
+                modelFiller = new EmptyModelFiller();
+            }
+            if (type.getSuperclass() != null && ReflectionUtils.isModel(type.getSuperclass()))
+            {
+                modelFiller.superModelFiller = instantiateFiller((Class<? extends Model>) type.getSuperclass());
+            }
+        }
+        return modelFiller;
+    }
 }
diff --git a/src/com/activeandroid/sebbia/Configuration.java b/src/com/activeandroid/sebbia/Configuration.java
index d6b000d1..7dad5d0e 100644
--- a/src/com/activeandroid/sebbia/Configuration.java
+++ b/src/com/activeandroid/sebbia/Configuration.java
@@ -26,293 +26,353 @@
 import com.activeandroid.sebbia.util.Log;
 import com.activeandroid.sebbia.util.ReflectionUtils;
 
-public class Configuration {
+public class Configuration
+{
 
-    public final static String SQL_PARSER_LEGACY = "legacy";
+    public final static String SQL_PARSER_LEGACY    = "legacy";
     public final static String SQL_PARSER_DELIMITED = "delimited";
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Context mContext;
-	private String mDatabaseName;
-	private int mDatabaseVersion;
-	private String mSqlParser;
-	private List<Class<? extends Model>> mModelClasses;
-	private List<Class<? extends TypeSerializer>> mTypeSerializers;
-	private int mCacheSize;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Configuration(Context context) {
-		mContext = context;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Context getContext() {
-		return mContext;
-	}
-
-	public String getDatabaseName() {
-		return mDatabaseName;
-	}
-
-	public int getDatabaseVersion() {
-		return mDatabaseVersion;
-	}
-	
-	public String getSqlParser() {
-	    return mSqlParser;
-	}
-
-	public List<Class<? extends Model>> getModelClasses() {
-		return mModelClasses;
-	}
-
-	public List<Class<? extends TypeSerializer>> getTypeSerializers() {
-		return mTypeSerializers;
-	}
-
-	public int getCacheSize() {
-		return mCacheSize;
-	}
-
-	public boolean isValid() {
-		return mModelClasses != null && mModelClasses.size() > 0;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// INNER CLASSES
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static class Builder {
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PRIVATE CONSTANTS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		private static final String AA_DB_NAME = "AA_DB_NAME";
-		private static final String AA_DB_VERSION = "AA_DB_VERSION";
-		private final static String AA_MODELS = "AA_MODELS";
-		private final static String AA_SERIALIZERS = "AA_SERIALIZERS";
-		private final static String AA_SQL_PARSER = "AA_SQL_PARSER";
-
-		private static final int DEFAULT_CACHE_SIZE = 1024;
-		private static final String DEFAULT_DB_NAME = "Application.db";
-		private static final String DEFAULT_SQL_PARSER = SQL_PARSER_LEGACY;
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PRIVATE MEMBERS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		private Context mContext;
-
-		private Integer mCacheSize;
-		private String mDatabaseName;
-		private Integer mDatabaseVersion;
-		private String mSqlParser;
-		private List<Class<? extends Model>> mModelClasses;
-		private List<Class<? extends TypeSerializer>> mTypeSerializers;
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// CONSTRUCTORS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		public Builder(Context context) {
-			mContext = context.getApplicationContext();
-			mCacheSize = DEFAULT_CACHE_SIZE;
-		}
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PUBLIC METHODS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		public Builder setCacheSize(int cacheSize) {
-			mCacheSize = cacheSize;
-			return this;
-		}
-
-		public Builder setDatabaseName(String databaseName) {
-			mDatabaseName = databaseName;
-			return this;
-		}
-
-		public Builder setDatabaseVersion(int databaseVersion) {
-			mDatabaseVersion = databaseVersion;
-			return this;
-		}
-		
-		public Builder setSqlParser(String sqlParser) {
-		    mSqlParser = sqlParser;
-		    return this;
-		}
-
-		public Builder addModelClass(Class<? extends Model> modelClass) {
-			if (mModelClasses == null) {
-				mModelClasses = new ArrayList<Class<? extends Model>>();
-			}
-
-			mModelClasses.add(modelClass);
-			return this;
-		}
-
-		public Builder addModelClasses(Class<? extends Model>... modelClasses) {
-			if (mModelClasses == null) {
-				mModelClasses = new ArrayList<Class<? extends Model>>();
-			}
-
-			mModelClasses.addAll(Arrays.asList(modelClasses));
-			return this;
-		}
-
-		public Builder setModelClasses(Class<? extends Model>... modelClasses) {
-			mModelClasses = Arrays.asList(modelClasses);
-			return this;
-		}
-
-		public Builder addTypeSerializer(Class<? extends TypeSerializer> typeSerializer) {
-			if (mTypeSerializers == null) {
-				mTypeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
-			}
-
-			mTypeSerializers.add(typeSerializer);
-			return this;
-		}
-
-		public Builder addTypeSerializers(Class<? extends TypeSerializer>... typeSerializers) {
-			if (mTypeSerializers == null) {
-				mTypeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
-			}
-
-			mTypeSerializers.addAll(Arrays.asList(typeSerializers));
-			return this;
-		}
-
-		public Builder setTypeSerializers(Class<? extends TypeSerializer>... typeSerializers) {
-			mTypeSerializers = Arrays.asList(typeSerializers);
-			return this;
-		}
-
-		public Configuration create() {
-			Configuration configuration = new Configuration(mContext);
-			configuration.mCacheSize = mCacheSize;
-
-			// Get database name from meta-data
-			if (mDatabaseName != null) {
-				configuration.mDatabaseName = mDatabaseName;
-			} else {
-				configuration.mDatabaseName = getMetaDataDatabaseNameOrDefault();
-			}
-
-			// Get database version from meta-data
-			if (mDatabaseVersion != null) {
-				configuration.mDatabaseVersion = mDatabaseVersion;
-			} else {
-				configuration.mDatabaseVersion = getMetaDataDatabaseVersionOrDefault();
-			}
-
-			// Get SQL parser from meta-data
-			if (mSqlParser != null) {
-			    configuration.mSqlParser = mSqlParser;
-			} else {
-			    configuration.mSqlParser = getMetaDataSqlParserOrDefault();
-			}
-			
-			// Get model classes from meta-data
-			if (mModelClasses != null) {
-				configuration.mModelClasses = mModelClasses;
-			} else {
-				final String modelList = ReflectionUtils.getMetaData(mContext, AA_MODELS);
-				if (modelList != null) {
-					configuration.mModelClasses = loadModelList(modelList.split(","));
-				}
-			}
-
-			// Get type serializer classes from meta-data
-			if (mTypeSerializers != null) {
-				configuration.mTypeSerializers = mTypeSerializers;
-			} else {
-				final String serializerList = ReflectionUtils.getMetaData(mContext, AA_SERIALIZERS);
-				if (serializerList != null) {
-					configuration.mTypeSerializers = loadSerializerList(serializerList.split(","));
-				}
-			}
-
-			return configuration;
-		}
-
-		//////////////////////////////////////////////////////////////////////////////////////
-		// PRIVATE METHODS
-		//////////////////////////////////////////////////////////////////////////////////////
-
-		// Meta-data methods
-
-		private String getMetaDataDatabaseNameOrDefault() {
-			String aaName = ReflectionUtils.getMetaData(mContext, AA_DB_NAME);
-			if (aaName == null) {
-				aaName = DEFAULT_DB_NAME;
-			}
-
-			return aaName;
-		}
-
-		private int getMetaDataDatabaseVersionOrDefault() {
-			Integer aaVersion = ReflectionUtils.getMetaData(mContext, AA_DB_VERSION);
-			if (aaVersion == null || aaVersion == 0) {
-				aaVersion = 1;
-			}
-
-			return aaVersion;
-		}
-
-		private String getMetaDataSqlParserOrDefault() {
-		    final String mode = ReflectionUtils.getMetaData(mContext, AA_SQL_PARSER);
-		    if (mode == null) {
-		        return DEFAULT_SQL_PARSER;
-		    }
-		    return mode;
-		}
-
-		private List<Class<? extends Model>> loadModelList(String[] models) {
-			final List<Class<? extends Model>> modelClasses = new ArrayList<Class<? extends Model>>();
-			final ClassLoader classLoader = mContext.getClass().getClassLoader();
-			for (String model : models) {
-				try {
-					Class modelClass = Class.forName(model.trim(), false, classLoader);
-					if (ReflectionUtils.isModel(modelClass)) {
-						modelClasses.add(modelClass);
-					}
-				}
-				catch (ClassNotFoundException e) {
-					Log.e("Couldn't create class.", e);
-				}
-			}
-
-			return modelClasses;
-		}
-
-		private List<Class<? extends TypeSerializer>> loadSerializerList(String[] serializers) {
-			final List<Class<? extends TypeSerializer>> typeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
-			final ClassLoader classLoader = mContext.getClass().getClassLoader();
-			for (String serializer : serializers) {
-				try {
-					Class serializerClass = Class.forName(serializer.trim(), false, classLoader);
-					if (ReflectionUtils.isTypeSerializer(serializerClass)) {
-						typeSerializers.add(serializerClass);
-					}
-				}
-				catch (ClassNotFoundException e) {
-					Log.e("Couldn't create class.", e);
-				}
-			}
-
-			return typeSerializers;
-		}
-
-	}
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Context                               mContext;
+    private String                                mDatabaseName;
+    private int                                   mDatabaseVersion;
+    private String                                mSqlParser;
+    private List<Class<? extends Model>>          mModelClasses;
+    private List<Class<? extends TypeSerializer>> mTypeSerializers;
+    private int                                   mCacheSize;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Configuration(Context context)
+    {
+        mContext = context;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Context getContext()
+    {
+        return mContext;
+    }
+
+    public String getDatabaseName()
+    {
+        return mDatabaseName;
+    }
+
+    public int getDatabaseVersion()
+    {
+        return mDatabaseVersion;
+    }
+
+    public String getSqlParser()
+    {
+        return mSqlParser;
+    }
+
+    public List<Class<? extends Model>> getModelClasses()
+    {
+        return mModelClasses;
+    }
+
+    public List<Class<? extends TypeSerializer>> getTypeSerializers()
+    {
+        return mTypeSerializers;
+    }
+
+    public int getCacheSize()
+    {
+        return mCacheSize;
+    }
+
+    public boolean isValid()
+    {
+        return mModelClasses != null && mModelClasses.size() > 0;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // INNER CLASSES
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static class Builder
+    {
+        //////////////////////////////////////////////////////////////////////////////////////
+        // PRIVATE CONSTANTS
+        //////////////////////////////////////////////////////////////////////////////////////
+
+        private static final String AA_DB_NAME     = "AA_DB_NAME";
+        private static final String AA_DB_VERSION  = "AA_DB_VERSION";
+        private final static String AA_MODELS      = "AA_MODELS";
+        private final static String AA_SERIALIZERS = "AA_SERIALIZERS";
+        private final static String AA_SQL_PARSER  = "AA_SQL_PARSER";
+
+        private static final int    DEFAULT_CACHE_SIZE = 1024;
+        private static final String DEFAULT_DB_NAME    = "Application.db";
+        private static final String DEFAULT_SQL_PARSER = SQL_PARSER_LEGACY;
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        // PRIVATE MEMBERS
+        //////////////////////////////////////////////////////////////////////////////////////
+
+        private Context mContext;
+
+        private Integer                               mCacheSize;
+        private String                                mDatabaseName;
+        private Integer                               mDatabaseVersion;
+        private String                                mSqlParser;
+        private List<Class<? extends Model>>          mModelClasses;
+        private List<Class<? extends TypeSerializer>> mTypeSerializers;
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        // CONSTRUCTORS
+        //////////////////////////////////////////////////////////////////////////////////////
+
+        public Builder(Context context)
+        {
+            mContext = context.getApplicationContext();
+            mCacheSize = DEFAULT_CACHE_SIZE;
+        }
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        // PUBLIC METHODS
+        //////////////////////////////////////////////////////////////////////////////////////
+
+        public Builder setCacheSize(int cacheSize)
+        {
+            mCacheSize = cacheSize;
+            return this;
+        }
+
+        public Builder setDatabaseName(String databaseName)
+        {
+            mDatabaseName = databaseName;
+            return this;
+        }
+
+        public Builder setDatabaseVersion(int databaseVersion)
+        {
+            mDatabaseVersion = databaseVersion;
+            return this;
+        }
+
+        public Builder setSqlParser(String sqlParser)
+        {
+            mSqlParser = sqlParser;
+            return this;
+        }
+
+        public Builder addModelClass(Class<? extends Model> modelClass)
+        {
+            if (mModelClasses == null)
+            {
+                mModelClasses = new ArrayList<Class<? extends Model>>();
+            }
+
+            mModelClasses.add(modelClass);
+            return this;
+        }
+
+        public Builder addModelClasses(Class<? extends Model>... modelClasses)
+        {
+            if (mModelClasses == null)
+            {
+                mModelClasses = new ArrayList<Class<? extends Model>>();
+            }
+
+            mModelClasses.addAll(Arrays.asList(modelClasses));
+            return this;
+        }
+
+        public Builder setModelClasses(Class<? extends Model>... modelClasses)
+        {
+            mModelClasses = Arrays.asList(modelClasses);
+            return this;
+        }
+
+        public Builder addTypeSerializer(Class<? extends TypeSerializer> typeSerializer)
+        {
+            if (mTypeSerializers == null)
+            {
+                mTypeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
+            }
+
+            mTypeSerializers.add(typeSerializer);
+            return this;
+        }
+
+        public Builder addTypeSerializers(Class<? extends TypeSerializer>... typeSerializers)
+        {
+            if (mTypeSerializers == null)
+            {
+                mTypeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
+            }
+
+            mTypeSerializers.addAll(Arrays.asList(typeSerializers));
+            return this;
+        }
+
+        public Builder setTypeSerializers(Class<? extends TypeSerializer>... typeSerializers)
+        {
+            mTypeSerializers = Arrays.asList(typeSerializers);
+            return this;
+        }
+
+        public Configuration create()
+        {
+            Configuration configuration = new Configuration(mContext);
+            configuration.mCacheSize = mCacheSize;
+
+            // Get database name from meta-data
+            if (mDatabaseName != null)
+            {
+                configuration.mDatabaseName = mDatabaseName;
+            }
+            else
+            {
+                configuration.mDatabaseName = getMetaDataDatabaseNameOrDefault();
+            }
+
+            // Get database version from meta-data
+            if (mDatabaseVersion != null)
+            {
+                configuration.mDatabaseVersion = mDatabaseVersion;
+            }
+            else
+            {
+                configuration.mDatabaseVersion = getMetaDataDatabaseVersionOrDefault();
+            }
+
+            // Get SQL parser from meta-data
+            if (mSqlParser != null)
+            {
+                configuration.mSqlParser = mSqlParser;
+            }
+            else
+            {
+                configuration.mSqlParser = getMetaDataSqlParserOrDefault();
+            }
+
+            // Get model classes from meta-data
+            if (mModelClasses != null)
+            {
+                configuration.mModelClasses = mModelClasses;
+            }
+            else
+            {
+                final String modelList = ReflectionUtils.getMetaData(mContext, AA_MODELS);
+                if (modelList != null)
+                {
+                    configuration.mModelClasses = loadModelList(modelList.split(","));
+                }
+            }
+
+            // Get type serializer classes from meta-data
+            if (mTypeSerializers != null)
+            {
+                configuration.mTypeSerializers = mTypeSerializers;
+            }
+            else
+            {
+                final String serializerList = ReflectionUtils.getMetaData(mContext, AA_SERIALIZERS);
+                if (serializerList != null)
+                {
+                    configuration.mTypeSerializers = loadSerializerList(serializerList.split(","));
+                }
+            }
+
+            return configuration;
+        }
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        // PRIVATE METHODS
+        //////////////////////////////////////////////////////////////////////////////////////
+
+        // Meta-data methods
+
+        private String getMetaDataDatabaseNameOrDefault()
+        {
+            String aaName = ReflectionUtils.getMetaData(mContext, AA_DB_NAME);
+            if (aaName == null)
+            {
+                aaName = DEFAULT_DB_NAME;
+            }
+
+            return aaName;
+        }
+
+        private int getMetaDataDatabaseVersionOrDefault()
+        {
+            Integer aaVersion = ReflectionUtils.getMetaData(mContext, AA_DB_VERSION);
+            if (aaVersion == null || aaVersion == 0)
+            {
+                aaVersion = 1;
+            }
+
+            return aaVersion;
+        }
+
+        private String getMetaDataSqlParserOrDefault()
+        {
+            final String mode = ReflectionUtils.getMetaData(mContext, AA_SQL_PARSER);
+            if (mode == null)
+            {
+                return DEFAULT_SQL_PARSER;
+            }
+            return mode;
+        }
+
+        private List<Class<? extends Model>> loadModelList(String[] models)
+        {
+            final List<Class<? extends Model>> modelClasses = new ArrayList<Class<? extends Model>>();
+            final ClassLoader                  classLoader  = mContext.getClass().getClassLoader();
+            for (String model : models)
+            {
+                try
+                {
+                    Class modelClass = Class.forName(model.trim(), false, classLoader);
+                    if (ReflectionUtils.isModel(modelClass))
+                    {
+                        modelClasses.add(modelClass);
+                    }
+                }
+                catch (ClassNotFoundException e)
+                {
+                    Log.e("Couldn't create class.", e);
+                }
+            }
+
+            return modelClasses;
+        }
+
+        private List<Class<? extends TypeSerializer>> loadSerializerList(String[] serializers)
+        {
+            final List<Class<? extends TypeSerializer>> typeSerializers = new ArrayList<Class<? extends TypeSerializer>>();
+            final ClassLoader                           classLoader     = mContext.getClass().getClassLoader();
+            for (String serializer : serializers)
+            {
+                try
+                {
+                    Class serializerClass = Class.forName(serializer.trim(), false, classLoader);
+                    if (ReflectionUtils.isTypeSerializer(serializerClass))
+                    {
+                        typeSerializers.add(serializerClass);
+                    }
+                }
+                catch (ClassNotFoundException e)
+                {
+                    Log.e("Couldn't create class.", e);
+                }
+            }
+
+            return typeSerializers;
+        }
+
+    }
 }
diff --git a/src/com/activeandroid/sebbia/DatabaseHelper.java b/src/com/activeandroid/sebbia/DatabaseHelper.java
index 22c65ec0..42d767be 100644
--- a/src/com/activeandroid/sebbia/DatabaseHelper.java
+++ b/src/com/activeandroid/sebbia/DatabaseHelper.java
@@ -16,17 +16,6 @@
  * limitations under the License.
  */
 
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
@@ -39,230 +28,292 @@
 import com.activeandroid.sebbia.util.SQLiteUtils;
 import com.activeandroid.sebbia.util.SqlParser;
 
-public final class DatabaseHelper extends SQLiteOpenHelper {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+public final class DatabaseHelper extends SQLiteOpenHelper
+{
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	public final static String MIGRATION_PATH = "migrations";
+    public final static String MIGRATION_PATH = "migrations";
 
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
     // PRIVATE FIELDS
     //////////////////////////////////////////////////////////////////////////////////////
 
     private final String mSqlParser;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public DatabaseHelper(Configuration configuration) {
-		super(configuration.getContext(), configuration.getDatabaseName(), null, configuration.getDatabaseVersion());
-		copyAttachedDatabase(configuration.getContext(), configuration.getDatabaseName());
-		mSqlParser = configuration.getSqlParser();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public void onOpen(SQLiteDatabase db) {
-		executePragmas(db);
-	};
-
-	@Override
-	public void onCreate(SQLiteDatabase db) {
-		executePragmas(db);
-		executeCreate(db);
-		executeMigrations(db, -1, db.getVersion());
-		executeCreateIndex(db);
-	}
-
-	@Override
-	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-		executePragmas(db);
-		executeCreate(db);
-		int latestVersion = executeMigrations(db, oldVersion, newVersion);
-		if (latestVersion < newVersion && db.needUpgrade(newVersion)) {
-			AutoMigration.migrate(db, newVersion);
-		}
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public void copyAttachedDatabase(Context context, String databaseName) {
-		final File dbPath = context.getDatabasePath(databaseName);
-
-		// If the database already exists, return
-		if (dbPath.exists()) {
-			return;
-		}
-
-		// Make sure we have a path to the file
-		dbPath.getParentFile().mkdirs();
-
-		// Try to copy database file
-		try {
-			final InputStream inputStream = context.getAssets().open(databaseName);
-			final OutputStream output = new FileOutputStream(dbPath);
-
-			byte[] buffer = new byte[8192];
-			int length;
-
-			while ((length = inputStream.read(buffer, 0, 8192)) > 0) {
-				output.write(buffer, 0, length);
-			}
-
-			output.flush();
-			output.close();
-			inputStream.close();
-		}
-		catch (IOException e) {
-			Log.e("Failed to open file", e);
-		}
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private void executePragmas(SQLiteDatabase db) {
-		if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED) {
-			db.execSQL("PRAGMA foreign_keys=ON;");
-			Log.i("Foreign Keys supported. Enabling foreign key features.");
-		}
-	}
-
-	private void executeCreateIndex(SQLiteDatabase db) {
-		db.beginTransaction();
-		try {
-			for (TableInfo tableInfo : Cache.getTableInfos()) {
-				String[] definitions = SQLiteUtils.createIndexDefinition(tableInfo);
-
-				for (String definition : definitions) {
-					db.execSQL(definition);
-				}
-			}
-			db.setTransactionSuccessful();
-		}
-		finally {
-			db.endTransaction();
-		}
-	}
-
-	private void executeCreate(SQLiteDatabase db) {
-		db.beginTransaction();
-		try {
-			for (TableInfo tableInfo : Cache.getTableInfos()) {
-				db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
-			}
-			db.setTransactionSuccessful();
-		}
-		finally {
-			db.endTransaction();
-		}
-	}
-
-	/**
-	 * Performs migrations from assets/migrations 
-	 * @param db
-	 * @param oldVersion
-	 * @param newVersion
-	 * @return latest version of migration file or -1 if none was executed.
-	 */
-	private int executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion) {
-		int latestVersion = -1;
-		try {
-			final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
-			Collections.sort(files, new NaturalOrderComparator());
-
-			db.beginTransaction();
-			try {
-				for (String file : files) {
-					try {
-						final int version = Integer.valueOf(file.replace(".sql", ""));
-
-						if (version > oldVersion && version <= newVersion) {
-							executeSqlScript(db, file);
-							latestVersion = version;
-
-							Log.i(file + " executed succesfully.");
-						}
-					}
-					catch (NumberFormatException e) {
-						Log.w("Skipping invalidly named file: " + file, e);
-					}
-				}
-				db.setTransactionSuccessful();
-			}
-			finally {
-				db.endTransaction();
-			}
-		}
-		catch (IOException e) {
-			Log.e("Failed to execute migrations.", e);
-		}
-
-		return latestVersion;
-	}
-
-	private void executeSqlScript(SQLiteDatabase db, String file) {
-
-	    InputStream stream = null;
-
-		try {
-		    stream = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
-
-		    if (Configuration.SQL_PARSER_DELIMITED.equalsIgnoreCase(mSqlParser)) {
-		        executeDelimitedSqlScript(db, stream);
-
-		    } else {
-		        executeLegacySqlScript(db, stream);
-
-		    }
-
-		} catch (IOException e) {
-			Log.e("Failed to execute " + file, e);
-
-		} finally {
-		    IOUtils.closeQuietly(stream);
-
-		}
-	}
-
-	private void executeDelimitedSqlScript(SQLiteDatabase db, InputStream stream) throws IOException {
-
-	    List<String> commands = SqlParser.parse(stream);
-
-	    for(String command : commands) {
-	        db.execSQL(command);
-	    }
-	}
-
-	private void executeLegacySqlScript(SQLiteDatabase db, InputStream stream) throws IOException {
-
-	    InputStreamReader reader = null;
-        BufferedReader buffer = null;
-
-        try {
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public DatabaseHelper(Context context, String name, int version, String sqlParser)
+    {
+        super(context, name, null, version);
+        copyAttachedDatabase(context, name);
+        mSqlParser = sqlParser;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public void onOpen(SQLiteDatabase db)
+    {
+        executePragmas(db);
+    }
+
+    ;
+
+    @Override
+    public void onCreate(SQLiteDatabase db)
+    {
+        executePragmas(db);
+        executeCreate(db);
+        executeMigrations(db, -1, db.getVersion());
+        executeCreateIndex(db);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)
+    {
+        executePragmas(db);
+        executeCreate(db);
+        int latestVersion = executeMigrations(db, oldVersion, newVersion);
+        if (latestVersion < newVersion && db.needUpgrade(newVersion))
+        {
+            AutoMigration.migrate(db, newVersion);
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public void copyAttachedDatabase(Context context, String databaseName)
+    {
+        final File dbPath = context.getDatabasePath(databaseName);
+
+        // If the database already exists, return
+        if (dbPath.exists())
+        {
+            return;
+        }
+
+        // Make sure we have a path to the file
+        dbPath.getParentFile().mkdirs();
+
+        // Try to copy database file
+        try
+        {
+            final InputStream inputStream = context.getAssets().open(databaseName);
+            final OutputStream output = new FileOutputStream(dbPath);
+
+            byte[] buffer = new byte[8192];
+            int length;
+
+            while ((length = inputStream.read(buffer, 0, 8192)) > 0)
+            {
+                output.write(buffer, 0, length);
+            }
+
+            output.flush();
+            output.close();
+            inputStream.close();
+        }
+        catch (IOException e)
+        {
+            Log.e("Failed to open file", e);
+        }
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private void executePragmas(SQLiteDatabase db)
+    {
+        if (SQLiteUtils.FOREIGN_KEYS_SUPPORTED)
+        {
+            db.execSQL("PRAGMA foreign_keys=ON;");
+            Log.i("Foreign Keys supported. Enabling foreign key features.");
+        }
+    }
+
+    private void executeCreateIndex(SQLiteDatabase db)
+    {
+        db.beginTransaction();
+        try
+        {
+            for (TableInfo tableInfo : Cache.getTableInfos())
+            {
+                String[] definitions = SQLiteUtils.createIndexDefinition(tableInfo);
+
+                for (String definition : definitions)
+                {
+                    db.execSQL(definition);
+                }
+            }
+            db.setTransactionSuccessful();
+        }
+        finally
+        {
+            db.endTransaction();
+        }
+    }
+
+    private void executeCreate(SQLiteDatabase db)
+    {
+        db.beginTransaction();
+        try
+        {
+            for (TableInfo tableInfo : Cache.getTableInfos())
+            {
+                db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
+            }
+            db.setTransactionSuccessful();
+        }
+        finally
+        {
+            db.endTransaction();
+        }
+    }
+
+    /**
+     * Performs migrations from assets/migrations
+     *
+     * @param db
+     * @param oldVersion
+     * @param newVersion
+     * @return latest version of migration file or -1 if none was executed.
+     */
+    private int executeMigrations(SQLiteDatabase db, int oldVersion, int newVersion)
+    {
+        int latestVersion = -1;
+        try
+        {
+            final List<String> files = Arrays.asList(Cache.getContext().getAssets().list(MIGRATION_PATH));
+            Collections.sort(files, new NaturalOrderComparator());
+
+            db.beginTransaction();
+            try
+            {
+                for (String file : files)
+                {
+                    try
+                    {
+                        final int version = Integer.valueOf(file.replace(".sql", ""));
+
+                        if (version > oldVersion && version <= newVersion)
+                        {
+                            executeSqlScript(db, file);
+                            latestVersion = version;
+
+                            Log.i(file + " executed succesfully.");
+                        }
+                    }
+                    catch (NumberFormatException e)
+                    {
+                        Log.w("Skipping invalidly named file: " + file, e);
+                    }
+                }
+                db.setTransactionSuccessful();
+            }
+            finally
+            {
+                db.endTransaction();
+            }
+        }
+        catch (IOException e)
+        {
+            Log.e("Failed to execute migrations.", e);
+        }
+
+        return latestVersion;
+    }
+
+    private void executeSqlScript(SQLiteDatabase db, String file)
+    {
+
+        InputStream stream = null;
+
+        try
+        {
+            stream = Cache.getContext().getAssets().open(MIGRATION_PATH + "/" + file);
+
+            if (Configuration.SQL_PARSER_DELIMITED.equalsIgnoreCase(mSqlParser))
+            {
+                executeDelimitedSqlScript(db, stream);
+
+            }
+            else
+            {
+                executeLegacySqlScript(db, stream);
+
+            }
+
+        }
+        catch (IOException e)
+        {
+            Log.e("Failed to execute " + file, e);
+
+        }
+        finally
+        {
+            IOUtils.closeQuietly(stream);
+
+        }
+    }
+
+    private void executeDelimitedSqlScript(SQLiteDatabase db, InputStream stream) throws IOException
+    {
+
+        List<String> commands = SqlParser.parse(stream);
+
+        for (String command : commands)
+        {
+            db.execSQL(command);
+        }
+    }
+
+    private void executeLegacySqlScript(SQLiteDatabase db, InputStream stream) throws IOException
+    {
+
+        InputStreamReader reader = null;
+        BufferedReader    buffer = null;
+
+        try
+        {
             reader = new InputStreamReader(stream);
             buffer = new BufferedReader(reader);
             String line = null;
 
-            while ((line = buffer.readLine()) != null) {
+            while ((line = buffer.readLine()) != null)
+            {
                 line = line.replace(";", "").trim();
-                if (!TextUtils.isEmpty(line)) {
+                if (!TextUtils.isEmpty(line))
+                {
                     db.execSQL(line);
                 }
             }
 
-        } finally {
+        }
+        finally
+        {
             IOUtils.closeQuietly(buffer);
             IOUtils.closeQuietly(reader);
 
         }
-	}
+    }
 }
diff --git a/src/com/activeandroid/sebbia/Model.java b/src/com/activeandroid/sebbia/Model.java
index dfc622a1..3c572795 100644
--- a/src/com/activeandroid/sebbia/Model.java
+++ b/src/com/activeandroid/sebbia/Model.java
@@ -16,11 +16,6 @@
  * limitations under the License.
  */
 
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
@@ -37,328 +32,422 @@
 import com.activeandroid.sebbia.util.Log;
 import com.activeandroid.sebbia.util.ReflectionUtils;
 
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
 @SuppressWarnings("unchecked")
-public abstract class Model {
-
-	/** Prime number used for hashcode() implementation. */
-	private static final int HASH_PRIME = 739;
-
-	// ////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	// ////////////////////////////////////////////////////////////////////////////////////
-
-	private Long mId = null;
-
-	private final TableInfo mTableInfo;
-	private final String idName;
-
-	// ////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	// ////////////////////////////////////////////////////////////////////////////////////
-
-	public Model() {
-		mTableInfo = Cache.getTableInfo(getClass());
-		idName = mTableInfo.getIdName();
-	}
-
-	// ////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	// ////////////////////////////////////////////////////////////////////////////////////
-
-	public final Long getId() {
-		return mId;
-	}
-
-	public final void delete() {
-		Cache.openDatabase().delete(mTableInfo.getTableName(), idName + "=?", new String[] { getId().toString() });
-		Cache.removeEntity(this);
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-	}
-
-	public final Long save() {
-		SQLiteDatabase db = Cache.openDatabase();
-		ContentValues values = new ContentValues();
-		fillContentValues(this, values);
-
-		if (mId == null) {
-			mId = db.insert(mTableInfo.getTableName(), null, values);
-		}
-		else {
-			db.update(mTableInfo.getTableName(), values, idName + "=" + mId, null);
-		}
-
-		Cache.getContext().getContentResolver()
-				.notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
-		return mId;
-	}
-
-	// Convenience methods
-
-	public static void delete(Class<? extends Model> type, long id) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		new Delete().from(type).where(tableInfo.getIdName() + "=?", id).execute();
-	}
-
-	public static <T extends Model> T load(Class<T> type, long id) {
-		T model = (T) Cache.getEntity(type, id);
-		if (model == null) { 
-			TableInfo tableInfo = Cache.getTableInfo(type);
-			model = new Select().from(type).where(tableInfo.getIdName() + "=?", id).executeSingle();
-		}
-		return model;
-	}
-
-	public static void saveMultiple(List<? extends Model> entities) {
-		final SQLiteDatabase db = Cache.openDatabase();
-		final ContentValues values = new ContentValues();
-		for (Model entity : entities) {
-			values.clear();
-			if (entity.mId == null) {
-				ModelFiller filler = Cache.getFiller(entity.getClass());
-				if (filler != null) {
-					synchronized (entity.getClass()) {
-						SQLiteStatement statement = entity.mTableInfo.getInsertOrReplaceStatement();
-						statement.clearBindings();
-						filler.bindStatement(entity, statement, entity.mTableInfo.getColumnIndexes());
-						entity.mId = statement.executeInsert();
-					}
-				} else {
-					entity.fillContentValuesReflective(values);
-					entity.mId = db.insert(entity.mTableInfo.getTableName(), null, values);
-				}
-			} else {
-				fillContentValues(entity, values);
-				db.update(entity.mTableInfo.getTableName(), values, "Id=" + entity.mId, null);
-			}
-		}
-	}
-
-	// Model population
-
-	public final void loadFromCursor(Cursor cursor) {
-		ModelFiller filler = Cache.getFiller(mTableInfo.getType());
-		if (filler != null) {
-			loadFromCursorWithFiller(cursor, filler);
-		} else {
-			loadFromCursorReflective(cursor);
-		}
-		if (mId != null) {
-			Cache.addEntity(this);
-		}
-	}
-
-	private static void fillContentValues(Model entity, ContentValues values) {
-		if (entity instanceof ManyToManyRelation<?, ?> || entity instanceof OneToManyRelation<?, ?>) {
-			entity.fillContentValuesReflective(values);
-			return;
-		}
-
-		ModelFiller filler = Cache.getFiller(entity.mTableInfo.getType());
-		if (filler != null)
-			filler.fillContentValues(entity, values);
-		else
-			entity.fillContentValuesReflective(values);
-	}
-
-	private void fillContentValuesReflective(final ContentValues values) {
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-
-			field.setAccessible(true);
-
-			try {
-				Object value = field.get(this);
-
-				if (value != null) {
-					final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-					if (typeSerializer != null) {
-						// serialize data
-						value = typeSerializer.serialize(value);
-						// set new object type
-						if (value != null) {
-							fieldType = value.getClass();
-							// check that the serializer returned what it
-							// promised
-							if (!fieldType.equals(typeSerializer.getSerializedType())) {
-								Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-										typeSerializer.getSerializedType(), fieldType));
-							}
-						}
-					}
-				}
-
-				// TODO: Find a smarter way to do this? This if block is
-				// necessary because we
-				// can't know the type until runtime.
-				if (value == null) {
-					values.putNull(fieldName);
-				}
-				else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-					values.put(fieldName, (Byte) value);
-				}
-				else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-					values.put(fieldName, (Short) value);
-				}
-				else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-					values.put(fieldName, (Integer) value);
-				}
-				else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-					values.put(fieldName, (Long) value);
-				}
-				else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-					values.put(fieldName, (Float) value);
-				}
-				else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-					values.put(fieldName, (Double) value);
-				}
-				else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-					values.put(fieldName, (Boolean) value);
-				}
-				else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(String.class)) {
-					values.put(fieldName, value.toString());
-				}
-				else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-					values.put(fieldName, (byte[]) value);
-				}
-				else if (ReflectionUtils.isModel(fieldType)) {
-					values.put(fieldName, ((Model) value).getId());
-				}
-				else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-					values.put(fieldName, ((Enum<?>) value).name());
-				}
-			} catch (IllegalArgumentException e) {
-				Log.e(e.getClass().getName(), e);
-			} catch (IllegalAccessException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-		}
-	}
-
-	private void loadFromCursorWithFiller(Cursor cursor, ModelFiller filler) {
-		int columnIndex = cursor.getColumnIndex(idName);
-		if (cursor.isNull(columnIndex) == false)
-			mId = cursor.getLong(columnIndex);
-		else
-			mId = null;
-		filler.loadFromCursor(this, cursor);
-	}
-
-	private void loadFromCursorReflective(Cursor cursor) {
-		/**
-		 * Obtain the columns ordered to fix issue #106
-		 * (https://github.com/pardom/ActiveAndroid/issues/106) when the cursor
-		 * have multiple columns with same name obtained from join tables.
-		 */
-		List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-		for (Field field : mTableInfo.getFields()) {
-			final String fieldName = mTableInfo.getColumnName(field);
-			Class<?> fieldType = field.getType();
-			final int columnIndex = columnsOrdered.indexOf(fieldName);
-
-			if (columnIndex < 0) {
-				continue;
-			}
-
-			field.setAccessible(true);
-
-			try {
-				boolean columnIsNull = cursor.isNull(columnIndex);
-				TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-				Object value = null;
-
-				if (typeSerializer != null) {
-					fieldType = typeSerializer.getSerializedType();
-				}
-
-				if (columnIsNull) {
-					field = null;
-				} else {
-					value = ModelHelper.getValueFromCursor(cursor, fieldType, columnIndex);
-				}
-
-				if (value == null) {
-					if (ReflectionUtils.isModel(fieldType)) {
-						value = ModelHelper.getModel(cursor, fieldType, columnIndex);
-					}
-					else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-						@SuppressWarnings("rawtypes")
-						final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-						value = Enum.valueOf(enumType, cursor.getString(columnIndex));
-					}
-				}
-				// Use a deserializer if one is available
-				if (typeSerializer != null && !columnIsNull) {
-					value = typeSerializer.deserialize(value);
-				}
-
-				// Set the field value
-				if (value != null) {
-					field.set(this, value);
-				}
-			} catch (IllegalArgumentException e) {
-				Log.e(e.getClass().getName(), e);
-			} catch (IllegalAccessException e) {
-				Log.e(e.getClass().getName(), e);
-			} catch (SecurityException e) {
-				Log.e(e.getClass().getName(), e);
-			}
-		}
-	}
-
-	// ////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	// ////////////////////////////////////////////////////////////////////////////////////
-
-	protected final <T extends Model> List<T> getMany(Class<T> type, String foreignKey) {
-		return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute();
-	}
-
-	protected String getIdName() {
-		return idName;
-	}
-	
-	protected void setModelId(long id) {
-		mId = id;
-	}
-
-	// ////////////////////////////////////////////////////////////////////////////////////
-	// OVERRIDEN METHODS
-	// ////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public String toString() {
-		return mTableInfo.getTableName() + "@" + getId();
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (obj instanceof Model && this.mId != null) {
-			final Model other = (Model) obj;
-
-			return this.mId.equals(other.mId)
-					&& (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
-		} else {
-			return this == obj;
-		}
-	}
-
-	@Override
-	public int hashCode() {
-		int hash = HASH_PRIME;
-		hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); // if
-																				// id
-																				// is
-																				// null,
-																				// use
-																				// Object.hashCode()
-		hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
-		return hash; // To change body of generated methods, choose Tools |
-						// Templates.
-	}
+public abstract class Model
+{
+
+    /**
+     * Prime number used for hashcode() implementation.
+     */
+    private static final int HASH_PRIME = 739;
+
+    // ////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    // ////////////////////////////////////////////////////////////////////////////////////
+
+    private Long mId = null;
+
+    private final TableInfo mTableInfo;
+    private final String    idName;
+
+    // ////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    // ////////////////////////////////////////////////////////////////////////////////////
+
+    public Model()
+    {
+        mTableInfo = Cache.getTableInfo(getClass());
+        idName = mTableInfo.getIdName();
+    }
+
+    // ////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    // ////////////////////////////////////////////////////////////////////////////////////
+
+    public final Long getId()
+    {
+        return mId;
+    }
+
+    public final void delete(String database)
+    {
+        Cache.openDatabase(database).delete(mTableInfo.getTableName(), idName + "=?", new String[]{getId().toString()});
+        Cache.removeEntity(this);
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+    }
+
+    public final Long save(String database)
+    {
+        SQLiteDatabase db     = Cache.openDatabase(database);
+        ContentValues  values = new ContentValues();
+        fillContentValues(this, values);
+
+        if (mId == null)
+        {
+            mId = db.insert(mTableInfo.getTableName(), null, values);
+        }
+        else
+        {
+            db.update(mTableInfo.getTableName(), values, idName + "=" + mId, null);
+        }
+
+        Cache.getContext().getContentResolver()
+                .notifyChange(ContentProvider.createUri(mTableInfo.getType(), mId), null);
+        return mId;
+    }
+
+    // Convenience methods
+
+    public static void delete(String database, Class<? extends Model> type, long id)
+    {
+        TableInfo tableInfo = Cache.getTableInfo(type);
+        new Delete().from(type).where(tableInfo.getIdName() + "=?", id).execute(database);
+    }
+
+    public static <T extends Model> T load(String database, Class<T> type, long id)
+    {
+        T model = (T) Cache.getEntity(type, id);
+        if (model == null)
+        {
+            TableInfo tableInfo = Cache.getTableInfo(type);
+            model = new Select().from(type).where(tableInfo.getIdName() + "=?", id).executeSingle(database);
+        }
+        return model;
+    }
+
+    public static void saveMultiple(String database, List<? extends Model> entities)
+    {
+        final SQLiteDatabase db     = Cache.openDatabase(database);
+        final ContentValues  values = new ContentValues();
+        for (Model entity : entities)
+        {
+            values.clear();
+            if (entity.mId == null)
+            {
+                ModelFiller filler = Cache.getFiller(entity.getClass());
+                if (filler != null)
+                {
+                    synchronized (entity.getClass())
+                    {
+                        SQLiteStatement statement = entity.mTableInfo.getInsertOrReplaceStatement(database);
+                        statement.clearBindings();
+                        filler.bindStatement(entity, statement, entity.mTableInfo.getColumnIndexes());
+                        entity.mId = statement.executeInsert();
+                    }
+                }
+                else
+                {
+                    entity.fillContentValuesReflective(values);
+                    entity.mId = db.insert(entity.mTableInfo.getTableName(), null, values);
+                }
+            }
+            else
+            {
+                fillContentValues(entity, values);
+                db.update(entity.mTableInfo.getTableName(), values, "Id=" + entity.mId, null);
+            }
+        }
+    }
+
+    // Model population
+
+    public final void loadFromCursor(String database, Cursor cursor)
+    {
+        ModelFiller filler = Cache.getFiller(mTableInfo.getType());
+        if (filler != null)
+        {
+            loadFromCursorWithFiller(cursor, filler);
+        }
+        else
+        {
+            loadFromCursorReflective(database, cursor);
+        }
+        if (mId != null)
+        {
+            Cache.addEntity(this);
+        }
+    }
+
+    private static void fillContentValues(Model entity, ContentValues values)
+    {
+        if (entity instanceof ManyToManyRelation<?, ?> || entity instanceof OneToManyRelation<?, ?>)
+        {
+            entity.fillContentValuesReflective(values);
+            return;
+        }
+
+        ModelFiller filler = Cache.getFiller(entity.mTableInfo.getType());
+        if (filler != null)
+        {
+            filler.fillContentValues(entity, values);
+        }
+        else
+        {
+            entity.fillContentValuesReflective(values);
+        }
+    }
+
+    private void fillContentValuesReflective(final ContentValues values)
+    {
+        for (Field field : mTableInfo.getFields())
+        {
+            final String fieldName = mTableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+
+            field.setAccessible(true);
+
+            try
+            {
+                Object value = field.get(this);
+
+                if (value != null)
+                {
+                    final TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                    if (typeSerializer != null)
+                    {
+                        // serialize data
+                        value = typeSerializer.serialize(value);
+                        // set new object type
+                        if (value != null)
+                        {
+                            fieldType = value.getClass();
+                            // check that the serializer returned what it
+                            // promised
+                            if (!fieldType.equals(typeSerializer.getSerializedType()))
+                            {
+                                Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                                        typeSerializer.getSerializedType(), fieldType));
+                            }
+                        }
+                    }
+                }
+
+                // TODO: Find a smarter way to do this? This if block is
+                // necessary because we
+                // can't know the type until runtime.
+                if (value == null)
+                {
+                    values.putNull(fieldName);
+                }
+                else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class))
+                {
+                    values.put(fieldName, (Byte) value);
+                }
+                else if (fieldType.equals(Short.class) || fieldType.equals(short.class))
+                {
+                    values.put(fieldName, (Short) value);
+                }
+                else if (fieldType.equals(Integer.class) || fieldType.equals(int.class))
+                {
+                    values.put(fieldName, (Integer) value);
+                }
+                else if (fieldType.equals(Long.class) || fieldType.equals(long.class))
+                {
+                    values.put(fieldName, (Long) value);
+                }
+                else if (fieldType.equals(Float.class) || fieldType.equals(float.class))
+                {
+                    values.put(fieldName, (Float) value);
+                }
+                else if (fieldType.equals(Double.class) || fieldType.equals(double.class))
+                {
+                    values.put(fieldName, (Double) value);
+                }
+                else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class))
+                {
+                    values.put(fieldName, (Boolean) value);
+                }
+                else if (fieldType.equals(Character.class) || fieldType.equals(char.class))
+                {
+                    values.put(fieldName, value.toString());
+                }
+                else if (fieldType.equals(String.class))
+                {
+                    values.put(fieldName, value.toString());
+                }
+                else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class))
+                {
+                    values.put(fieldName, (byte[]) value);
+                }
+                else if (ReflectionUtils.isModel(fieldType))
+                {
+                    values.put(fieldName, ((Model) value).getId());
+                }
+                else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class))
+                {
+                    values.put(fieldName, ((Enum<?>) value).name());
+                }
+            }
+            catch (IllegalArgumentException e)
+            {
+                Log.e(e.getClass().getName(), e);
+            }
+            catch (IllegalAccessException e)
+            {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+    }
+
+    private void loadFromCursorWithFiller(Cursor cursor, ModelFiller filler)
+    {
+        int columnIndex = cursor.getColumnIndex(idName);
+        if (cursor.isNull(columnIndex) == false)
+        {
+            mId = cursor.getLong(columnIndex);
+        }
+        else
+        {
+            mId = null;
+        }
+        filler.loadFromCursor(this, cursor);
+    }
+
+    private void loadFromCursorReflective(String database, Cursor cursor)
+    {
+        /**
+         * Obtain the columns ordered to fix issue #106
+         * (https://github.com/pardom/ActiveAndroid/issues/106) when the cursor
+         * have multiple columns with same name obtained from join tables.
+         */
+        List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
+        for (Field field : mTableInfo.getFields())
+        {
+            final String fieldName = mTableInfo.getColumnName(field);
+            Class<?> fieldType = field.getType();
+            final int columnIndex = columnsOrdered.indexOf(fieldName);
+
+            if (columnIndex < 0)
+            {
+                continue;
+            }
+
+            field.setAccessible(true);
+
+            try
+            {
+                boolean columnIsNull = cursor.isNull(columnIndex);
+                TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+                Object value = null;
+
+                if (typeSerializer != null)
+                {
+                    fieldType = typeSerializer.getSerializedType();
+                }
+
+                if (columnIsNull)
+                {
+                    field = null;
+                }
+                else
+                {
+                    value = ModelHelper.getValueFromCursor(cursor, fieldType, columnIndex);
+                }
+
+                if (value == null)
+                {
+                    if (ReflectionUtils.isModel(fieldType))
+                    {
+                        value = ModelHelper.getModel(database, cursor, fieldType, columnIndex);
+                    }
+                    else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class))
+                    {
+                        @SuppressWarnings("rawtypes")
+                        final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+                        value = Enum.valueOf(enumType, cursor.getString(columnIndex));
+                    }
+                }
+                // Use a deserializer if one is available
+                if (typeSerializer != null && !columnIsNull)
+                {
+                    value = typeSerializer.deserialize(value);
+                }
+
+                // Set the field value
+                if (value != null)
+                {
+                    field.set(this, value);
+                }
+            }
+            catch (IllegalArgumentException e)
+            {
+                Log.e(e.getClass().getName(), e);
+            }
+            catch (IllegalAccessException e)
+            {
+                Log.e(e.getClass().getName(), e);
+            }
+            catch (SecurityException e)
+            {
+                Log.e(e.getClass().getName(), e);
+            }
+        }
+    }
+
+    // ////////////////////////////////////////////////////////////////////////////////////
+    // PROTECTED METHODS
+    // ////////////////////////////////////////////////////////////////////////////////////
+
+    protected final <T extends Model> List<T> getMany(String database, Class<T> type, String foreignKey)
+    {
+        return new Select().from(type).where(Cache.getTableName(type) + "." + foreignKey + "=?", getId()).execute(database);
+    }
+
+    protected String getIdName()
+    {
+        return idName;
+    }
+
+    protected void setModelId(long id)
+    {
+        mId = id;
+    }
+
+    // ////////////////////////////////////////////////////////////////////////////////////
+    // OVERRIDEN METHODS
+    // ////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public String toString()
+    {
+        return mTableInfo.getTableName() + "@" + getId();
+    }
+
+    @Override
+    public boolean equals(Object obj)
+    {
+        if (obj instanceof Model && this.mId != null)
+        {
+            final Model other = (Model) obj;
+
+            return this.mId.equals(other.mId)
+                    && (this.mTableInfo.getTableName().equals(other.mTableInfo.getTableName()));
+        }
+        else
+        {
+            return this == obj;
+        }
+    }
+
+    @Override
+    public int hashCode()
+    {
+        int hash = HASH_PRIME;
+        hash += HASH_PRIME * (mId == null ? super.hashCode() : mId.hashCode()); // if
+        // id
+        // is
+        // null,
+        // use
+        // Object.hashCode()
+        hash += HASH_PRIME * mTableInfo.getTableName().hashCode();
+        return hash; // To change body of generated methods, choose Tools |
+        // Templates.
+    }
 }
diff --git a/src/com/activeandroid/sebbia/ModelInfo.java b/src/com/activeandroid/sebbia/ModelInfo.java
index a6743a6b..e601d8ef 100644
--- a/src/com/activeandroid/sebbia/ModelInfo.java
+++ b/src/com/activeandroid/sebbia/ModelInfo.java
@@ -40,172 +40,211 @@
 
 import dalvik.system.DexFile;
 
-final class ModelInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Map<Class<? extends Model>, TableInfo> mTableInfos = new HashMap<Class<? extends Model>, TableInfo>();
-	private Map<Class<?>, TypeSerializer> mTypeSerializers = new HashMap<Class<?>, TypeSerializer>() {
-		{
-			put(Calendar.class, new CalendarSerializer());
-			put(java.sql.Date.class, new SqlDateSerializer());
-			put(java.util.Date.class, new UtilDateSerializer());
-			put(java.io.File.class, new FileSerializer());
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public ModelInfo(Configuration configuration) {
-		if (!loadModelFromMetaData(configuration)) {
-			try {
-				scanForModel(configuration.getContext());
-			}
-			catch (IOException e) {
-				Log.e("Couldn't open source path.", e);
-			}
-		}
-
-		Log.i("ModelInfo loaded.");
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Collection<TableInfo> getTableInfos() {
-		return mTableInfos.values();
-	}
-
-	public TableInfo getTableInfo(Class<? extends Model> type) {
-		return mTableInfos.get(type);
-	}
-
-	public TypeSerializer getTypeSerializer(Class<?> type) {
-		return mTypeSerializers.get(type);
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private boolean loadModelFromMetaData(Configuration configuration) {
-		if (!configuration.isValid()) {
-			return false;
-		}
-
-		final List<Class<? extends Model>> models = configuration.getModelClasses();
-		if (models != null) {
-			for (Class<? extends Model> model : models) {
-				mTableInfos.put(model, new TableInfo(model));
-			}
-		}
-
-		final List<Class<? extends TypeSerializer>> typeSerializers = configuration.getTypeSerializers();
-		if (typeSerializers != null) {
-			for (Class<? extends TypeSerializer> typeSerializer : typeSerializers) {
-				try {
-					TypeSerializer instance = typeSerializer.newInstance();
-					mTypeSerializers.put(instance.getDeserializedType(), instance);
-				}
-				catch (InstantiationException e) {
-					Log.e("Couldn't instantiate TypeSerializer.", e);
-				}
-				catch (IllegalAccessException e) {
-					Log.e("IllegalAccessException", e);
-				}
-			}
-		}
-
-		return true;
-	}
-
-	private void scanForModel(Context context) throws IOException {
-		String packageName = context.getPackageName();
-		String sourcePath = context.getApplicationInfo().sourceDir;
-		List<String> paths = new ArrayList<String>();
-
-		if (sourcePath != null && !(new File(sourcePath).isDirectory())) {
-			DexFile dexfile = new DexFile(sourcePath);
-			Enumeration<String> entries = dexfile.entries();
-
-			while (entries.hasMoreElements()) {
-				paths.add(entries.nextElement());
-			}
-		}
-		// Robolectric fallback
-		else {
-			ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-			Enumeration<URL> resources = classLoader.getResources("");
-
-			while (resources.hasMoreElements()) {
-				String path = resources.nextElement().getFile();
-				if (path.contains("bin") || path.contains("classes")) {
-					paths.add(path);
-				}
-			}
-		}
-
-		for (String path : paths) {
-			File file = new File(path);
-			scanForModelClasses(file, packageName, context.getClassLoader());
-		}
-	}
-
-	private void scanForModelClasses(File path, String packageName, ClassLoader classLoader) {
-		if (path.isDirectory()) {
-			for (File file : path.listFiles()) {
-				scanForModelClasses(file, packageName, classLoader);
-			}
-		}
-		else {
-			String className = path.getName();
-
-			// Robolectric fallback
-			if (!path.getPath().equals(className)) {
-				className = path.getPath();
-
-				if (className.endsWith(".class")) {
-					className = className.substring(0, className.length() - 6);
-				}
-				else {
-					return;
-				}
-
-				className = className.replace(System.getProperty("file.separator"), ".");
-
-				int packageNameIndex = className.lastIndexOf(packageName);
-				if (packageNameIndex < 0) {
-					return;
-				}
-
-				className = className.substring(packageNameIndex);
-			}
-
-			try {
-				Class<?> discoveredClass = Class.forName(className, false, classLoader);
-				if (ReflectionUtils.isModel(discoveredClass) && !Modifier.isAbstract(discoveredClass.getModifiers())) {
-					@SuppressWarnings("unchecked")
-					Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
-					mTableInfos.put(modelClass, new TableInfo(modelClass));
-				}
-				else if (ReflectionUtils.isTypeSerializer(discoveredClass)) {
-					TypeSerializer instance = (TypeSerializer) discoveredClass.newInstance();
-					mTypeSerializers.put(instance.getDeserializedType(), instance);
-				}
-			}
-			catch (ClassNotFoundException e) {
-				Log.e("Couldn't create class.", e);
-			}
-			catch (InstantiationException e) {
-				Log.e("Couldn't instantiate TypeSerializer.", e);
-			}
-			catch (IllegalAccessException e) {
-				Log.e("IllegalAccessException", e);
-			}
-		}
-	}
+final class ModelInfo
+{
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Map<Class<? extends Model>, TableInfo> mTableInfos      = new HashMap<Class<? extends Model>, TableInfo>();
+    private Map<Class<?>, TypeSerializer>          mTypeSerializers = new HashMap<Class<?>, TypeSerializer>()
+    {
+        {
+            put(Calendar.class, new CalendarSerializer());
+            put(java.sql.Date.class, new SqlDateSerializer());
+            put(java.util.Date.class, new UtilDateSerializer());
+            put(java.io.File.class, new FileSerializer());
+        }
+    };
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public ModelInfo(Configuration configuration)
+    {
+        if (!loadModelFromMetaData(configuration))
+        {
+            try
+            {
+                scanForModel(configuration.getContext());
+            }
+            catch (IOException e)
+            {
+                Log.e("Couldn't open source path.", e);
+            }
+        }
+
+        Log.i("ModelInfo loaded.");
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Collection<TableInfo> getTableInfos()
+    {
+        return mTableInfos.values();
+    }
+
+    public TableInfo getTableInfo(Class<? extends Model> type)
+    {
+        return mTableInfos.get(type);
+    }
+
+    public TypeSerializer getTypeSerializer(Class<?> type)
+    {
+        return mTypeSerializers.get(type);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private boolean loadModelFromMetaData(Configuration configuration)
+    {
+        if (!configuration.isValid())
+        {
+            return false;
+        }
+
+        final List<Class<? extends Model>> models = configuration.getModelClasses();
+        if (models != null)
+        {
+            for (Class<? extends Model> model : models)
+            {
+                mTableInfos.put(model, new TableInfo(model));
+            }
+        }
+
+        final List<Class<? extends TypeSerializer>> typeSerializers = configuration.getTypeSerializers();
+        if (typeSerializers != null)
+        {
+            for (Class<? extends TypeSerializer> typeSerializer : typeSerializers)
+            {
+                try
+                {
+                    TypeSerializer instance = typeSerializer.newInstance();
+                    mTypeSerializers.put(instance.getDeserializedType(), instance);
+                }
+                catch (InstantiationException e)
+                {
+                    Log.e("Couldn't instantiate TypeSerializer.", e);
+                }
+                catch (IllegalAccessException e)
+                {
+                    Log.e("IllegalAccessException", e);
+                }
+            }
+        }
+
+        return true;
+    }
+
+    private void scanForModel(Context context) throws IOException
+    {
+        String       packageName = context.getPackageName();
+        String       sourcePath  = context.getApplicationInfo().sourceDir;
+        List<String> paths       = new ArrayList<String>();
+
+        if (sourcePath != null && !(new File(sourcePath).isDirectory()))
+        {
+            DexFile dexfile = new DexFile(sourcePath);
+            Enumeration<String> entries = dexfile.entries();
+
+            while (entries.hasMoreElements())
+            {
+                paths.add(entries.nextElement());
+            }
+        }
+        // Robolectric fallback
+        else
+        {
+            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+            Enumeration<URL> resources = classLoader.getResources("");
+
+            while (resources.hasMoreElements())
+            {
+                String path = resources.nextElement().getFile();
+                if (path.contains("bin") || path.contains("classes"))
+                {
+                    paths.add(path);
+                }
+            }
+        }
+
+        for (String path : paths)
+        {
+            File file = new File(path);
+            scanForModelClasses(file, packageName, context.getClassLoader());
+        }
+    }
+
+    private void scanForModelClasses(File path, String packageName, ClassLoader classLoader)
+    {
+        if (path.isDirectory())
+        {
+            for (File file : path.listFiles())
+            {
+                scanForModelClasses(file, packageName, classLoader);
+            }
+        }
+        else
+        {
+            String className = path.getName();
+
+            // Robolectric fallback
+            if (!path.getPath().equals(className))
+            {
+                className = path.getPath();
+
+                if (className.endsWith(".class"))
+                {
+                    className = className.substring(0, className.length() - 6);
+                }
+                else
+                {
+                    return;
+                }
+
+                className = className.replace(System.getProperty("file.separator"), ".");
+
+                int packageNameIndex = className.lastIndexOf(packageName);
+                if (packageNameIndex < 0)
+                {
+                    return;
+                }
+
+                className = className.substring(packageNameIndex);
+            }
+
+            try
+            {
+                Class<?> discoveredClass = Class.forName(className, false, classLoader);
+                if (ReflectionUtils.isModel(discoveredClass) && !Modifier.isAbstract(discoveredClass.getModifiers()))
+                {
+                    @SuppressWarnings("unchecked")
+                    Class<? extends Model> modelClass = (Class<? extends Model>) discoveredClass;
+                    mTableInfos.put(modelClass, new TableInfo(modelClass));
+                }
+                else if (ReflectionUtils.isTypeSerializer(discoveredClass))
+                {
+                    TypeSerializer instance = (TypeSerializer) discoveredClass.newInstance();
+                    mTypeSerializers.put(instance.getDeserializedType(), instance);
+                }
+            }
+            catch (ClassNotFoundException e)
+            {
+                Log.e("Couldn't create class.", e);
+            }
+            catch (InstantiationException e)
+            {
+                Log.e("Couldn't instantiate TypeSerializer.", e);
+            }
+            catch (IllegalAccessException e)
+            {
+                Log.e("IllegalAccessException", e);
+            }
+        }
+    }
 }
diff --git a/src/com/activeandroid/sebbia/TableInfo.java b/src/com/activeandroid/sebbia/TableInfo.java
index 0274b35c..a3d68147 100644
--- a/src/com/activeandroid/sebbia/TableInfo.java
+++ b/src/com/activeandroid/sebbia/TableInfo.java
@@ -16,6 +16,16 @@
  * limitations under the License.
  */
 
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+import android.text.TextUtils;
+
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Table;
+import com.activeandroid.sebbia.util.Log;
+import com.activeandroid.sebbia.util.ReflectionUtils;
+import com.activeandroid.sebbia.util.SQLiteUtils;
+
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.Collections;
@@ -25,48 +35,42 @@
 import java.util.List;
 import java.util.Map;
 
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-import android.text.TextUtils;
+public final class TableInfo
+{
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Table;
-import com.activeandroid.sebbia.util.Log;
-import com.activeandroid.sebbia.util.ReflectionUtils;
-import com.activeandroid.sebbia.util.SQLiteUtils;
+    private Class<? extends Model> mType;
+    private String                 mTableName;
+    private String mIdName = Table.DEFAULT_ID_NAME;
+
+    private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
+
+    private SQLiteStatement mInsertStatement;
+    private SQLiteStatement mInsertOrReplaceStatement;
+    private SQLiteStatement mUpdateStatement;
 
-public final class TableInfo {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Class<? extends Model> mType;
-	private String mTableName;
-	private String mIdName = Table.DEFAULT_ID_NAME;
-
-	private Map<Field, String> mColumnNames = new LinkedHashMap<Field, String>();
-	
-	private SQLiteStatement mInsertStatement;
-	private SQLiteStatement mInsertOrReplaceStatement;
-	private SQLiteStatement mUpdateStatement;
-	
-	private Map<String, Integer> mColumnIndexes;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public TableInfo(Class<? extends Model> type) {
-		mType = type;
-
-		final Table tableAnnotation = type.getAnnotation(Table.class);
-
-        if (tableAnnotation != null) {
-			mTableName = tableAnnotation.name();
-			mIdName = tableAnnotation.id();
-		}
-		else {
-			mTableName = type.getSimpleName();
+    private Map<String, Integer> mColumnIndexes;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public TableInfo(Class<? extends Model> type)
+    {
+        mType = type;
+
+        final Table tableAnnotation = type.getAnnotation(Table.class);
+
+        if (tableAnnotation != null)
+        {
+            mTableName = tableAnnotation.name();
+            mIdName = tableAnnotation.id();
+        }
+        else
+        {
+            mTableName = type.getSimpleName();
         }
 
         // Manually add the id column since it is not declared like the other columns.
@@ -76,95 +80,117 @@ public TableInfo(Class<? extends Model> type) {
         List<Field> fields = new LinkedList<Field>(ReflectionUtils.getDeclaredColumnFields(type));
         Collections.reverse(fields);
 
-        for (Field field : fields) {
-            if (field.isAnnotationPresent(Column.class)) {
+        for (Field field : fields)
+        {
+            if (field.isAnnotationPresent(Column.class))
+            {
                 final Column columnAnnotation = field.getAnnotation(Column.class);
                 String columnName = columnAnnotation.name();
-                if (TextUtils.isEmpty(columnName)) {
+                if (TextUtils.isEmpty(columnName))
+                {
                     columnName = field.getName();
                 }
 
                 mColumnNames.put(field, columnName);
             }
         }
-        
+
         mColumnIndexes = new HashMap<String, Integer>(mColumnNames.size());
         int index = 1;
-        for (String column : mColumnNames.values()) {
-        	mColumnIndexes.put(column, index++);
+        for (String column : mColumnNames.values())
+        {
+            mColumnIndexes.put(column, index++);
         }
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public Class<? extends Model> getType() {
-		return mType;
-	}
-
-	public String getTableName() {
-		return mTableName;
-	}
-
-	public String getIdName() {
-		return mIdName;
-	}
-
-	public Collection<Field> getFields() {
-		return mColumnNames.keySet();
-	}
-	
-	public Collection<String> getColumnNames() {
-		return mColumnNames.values();
-	}
-
-	public String getColumnName(Field field) {
-		return mColumnNames.get(field);
-	}
-	
-	public SQLiteStatement getInsertStatement() {
-		if (mInsertStatement == null) {
-			SQLiteDatabase db = Cache.openDatabase(); 
-			mInsertStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT INTO ", this));
-		}
-		return mInsertStatement;
-	}
-	
-	public SQLiteStatement getUpdateStatement() {
-		if (mUpdateStatement == null) {
-			SQLiteDatabase db = Cache.openDatabase(); 
-			mUpdateStatement = db.compileStatement(SQLiteUtils.createUpdateStatement(this));
-		}
-		return mUpdateStatement;
-	}
-	
-	public SQLiteStatement getInsertOrReplaceStatement() {
-		if (mInsertOrReplaceStatement == null) {
-			SQLiteDatabase db = Cache.openDatabase(); 
-			mInsertOrReplaceStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT OR REPLACE INTO ", this));
-		}
-		return mInsertOrReplaceStatement;
-	}
-	
-    private Field getIdField(Class<?> type) {
-        if (type.equals(Model.class)) {
-            try {
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public Class<? extends Model> getType()
+    {
+        return mType;
+    }
+
+    public String getTableName()
+    {
+        return mTableName;
+    }
+
+    public String getIdName()
+    {
+        return mIdName;
+    }
+
+    public Collection<Field> getFields()
+    {
+        return mColumnNames.keySet();
+    }
+
+    public Collection<String> getColumnNames()
+    {
+        return mColumnNames.values();
+    }
+
+    public String getColumnName(Field field)
+    {
+        return mColumnNames.get(field);
+    }
+
+    public SQLiteStatement getInsertStatement(String database)
+    {
+        if (mInsertStatement == null)
+        {
+            SQLiteDatabase db = Cache.openDatabase(database);
+            mInsertStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT INTO ", this));
+        }
+        return mInsertStatement;
+    }
+
+    public SQLiteStatement getUpdateStatement(String database)
+    {
+        if (mUpdateStatement == null)
+        {
+            SQLiteDatabase db = Cache.openDatabase(database);
+            mUpdateStatement = db.compileStatement(SQLiteUtils.createUpdateStatement(this));
+        }
+        return mUpdateStatement;
+    }
+
+    public SQLiteStatement getInsertOrReplaceStatement(String database)
+    {
+        if (mInsertOrReplaceStatement == null)
+        {
+            SQLiteDatabase db = Cache.openDatabase(database);
+            mInsertOrReplaceStatement = db.compileStatement(SQLiteUtils.createInsertStatement("INSERT OR REPLACE INTO ", this));
+        }
+        return mInsertOrReplaceStatement;
+    }
+
+    private Field getIdField(Class<?> type)
+    {
+        if (type.equals(Model.class))
+        {
+            try
+            {
                 return type.getDeclaredField("mId");
             }
-            catch (NoSuchFieldException e) {
+            catch (NoSuchFieldException e)
+            {
                 Log.e("Impossible!", e.toString());
             }
         }
-        else if (type.getSuperclass() != null) {
+        else if (type.getSuperclass() != null)
+        {
             return getIdField(type.getSuperclass());
         }
 
         return null;
     }
-    
-    public Map<String, Integer> getColumnIndexes() {
-		return mColumnIndexes;
-	}
+
+    public Map<String, Integer> getColumnIndexes()
+    {
+        return mColumnIndexes;
+    }
 
 }
diff --git a/src/com/activeandroid/sebbia/annotation/Column.java b/src/com/activeandroid/sebbia/annotation/Column.java
index 52e46d49..9b2cca1f 100644
--- a/src/com/activeandroid/sebbia/annotation/Column.java
+++ b/src/com/activeandroid/sebbia/annotation/Column.java
@@ -23,90 +23,93 @@
 
 @Target(ElementType.FIELD)
 @Retention(RetentionPolicy.RUNTIME)
-public @interface Column {
-	public enum ConflictAction {
-		ROLLBACK, ABORT, FAIL, IGNORE, REPLACE
-	}
-
-	public enum ForeignKeyAction {
-		SET_NULL, SET_DEFAULT, CASCADE, RESTRICT, NO_ACTION
-	}
-
-	public String name() default "";
-
-	public int length() default -1;
-
-	public boolean notNull() default false;
-
-	public ConflictAction onNullConflict() default ConflictAction.FAIL;
-
-	public ForeignKeyAction onDelete() default ForeignKeyAction.NO_ACTION;
-
-	public ForeignKeyAction onUpdate() default ForeignKeyAction.NO_ACTION;
-
-	public boolean unique() default false;
-
-	public ConflictAction onUniqueConflict() default ConflictAction.FAIL;
-	
-	public String defaultValue() default "";
-
-	/*
-	 * If set uniqueGroups = {"group_name"}, we will create a table constraint with group.
-	 *
-	 * Example:
-	 *
-	 * @Table(name = "table_name")
-	 * public class Table extends Model {
-	 *     @Column(name = "member1", uniqueGroups = {"group1"}, onUniqueConflicts = {ConflictAction.FAIL})
-	 *     public String member1;
-	 *
-	 *     @Column(name = "member2", uniqueGroups = {"group1", "group2"}, onUniqueConflicts = {ConflictAction.FAIL, ConflictAction.IGNORE})
-	 *     public String member2;
-	 *
-	 *     @Column(name = "member3", uniqueGroups = {"group2"}, onUniqueConflicts = {ConflictAction.IGNORE})
-	 *     public String member3;
-	 * }
-	 *
-	 * CREATE TABLE table_name (..., UNIQUE (member1, member2) ON CONFLICT FAIL, UNIQUE (member2, member3) ON CONFLICT IGNORE)
-	 */
-	public String[] uniqueGroups() default {};
-
-	public ConflictAction[] onUniqueConflicts() default {};
-
-	/*
-	 * If set index = true, we will create a index with single column.
-	 *
-	 * Example:
-	 *
-	 * @Table(name = "table_name")
-	 * public class Table extends Model {
-	 *     @Column(name = "member", index = true)
-	 *     public String member;
-	 * }
-	 *
-	 * Execute CREATE INDEX index_table_name_member on table_name(member)
-	 */
-	public boolean index() default false;
-
-	/*
-	 * If set indexGroups = {"group_name"}, we will create a index with group.
-	 *
-	 * Example:
-	 *
-	 * @Table(name = "table_name")
-	 * public class Table extends Model {
-	 *     @Column(name = "member1", indexGroups = {"group1"})
-	 *     public String member1;
-	 *
-	 *     @Column(name = "member2", indexGroups = {"group1", "group2"})
-	 *     public String member2;
-	 *
-	 *     @Column(name = "member3", indexGroups = {"group2"})
-	 *     public String member3;
-	 * }
-	 *
-	 * Execute CREATE INDEX index_table_name_group1 on table_name(member1, member2)
-	 * Execute CREATE INDEX index_table_name_group2 on table_name(member2, member3)
-	 */
-	public String[] indexGroups() default {};
+public @interface Column
+{
+    public enum ConflictAction
+    {
+        ROLLBACK, ABORT, FAIL, IGNORE, REPLACE
+    }
+
+    public enum ForeignKeyAction
+    {
+        SET_NULL, SET_DEFAULT, CASCADE, RESTRICT, NO_ACTION
+    }
+
+    public String name() default "";
+
+    public int length() default -1;
+
+    public boolean notNull() default false;
+
+    public ConflictAction onNullConflict() default ConflictAction.FAIL;
+
+    public ForeignKeyAction onDelete() default ForeignKeyAction.NO_ACTION;
+
+    public ForeignKeyAction onUpdate() default ForeignKeyAction.NO_ACTION;
+
+    public boolean unique() default false;
+
+    public ConflictAction onUniqueConflict() default ConflictAction.FAIL;
+
+    public String defaultValue() default "";
+
+    /*
+     * If set uniqueGroups = {"group_name"}, we will create a table constraint with group.
+     *
+     * Example:
+     *
+     * @Table(name = "table_name")
+     * public class Table extends Model {
+     *     @Column(name = "member1", uniqueGroups = {"group1"}, onUniqueConflicts = {ConflictAction.FAIL})
+     *     public String member1;
+     *
+     *     @Column(name = "member2", uniqueGroups = {"group1", "group2"}, onUniqueConflicts = {ConflictAction.FAIL, ConflictAction.IGNORE})
+     *     public String member2;
+     *
+     *     @Column(name = "member3", uniqueGroups = {"group2"}, onUniqueConflicts = {ConflictAction.IGNORE})
+     *     public String member3;
+     * }
+     *
+     * CREATE TABLE table_name (..., UNIQUE (member1, member2) ON CONFLICT FAIL, UNIQUE (member2, member3) ON CONFLICT IGNORE)
+     */
+    public String[] uniqueGroups() default {};
+
+    public ConflictAction[] onUniqueConflicts() default {};
+
+    /*
+     * If set index = true, we will create a index with single column.
+     *
+     * Example:
+     *
+     * @Table(name = "table_name")
+     * public class Table extends Model {
+     *     @Column(name = "member", index = true)
+     *     public String member;
+     * }
+     *
+     * Execute CREATE INDEX index_table_name_member on table_name(member)
+     */
+    public boolean index() default false;
+
+    /*
+     * If set indexGroups = {"group_name"}, we will create a index with group.
+     *
+     * Example:
+     *
+     * @Table(name = "table_name")
+     * public class Table extends Model {
+     *     @Column(name = "member1", indexGroups = {"group1"})
+     *     public String member1;
+     *
+     *     @Column(name = "member2", indexGroups = {"group1", "group2"})
+     *     public String member2;
+     *
+     *     @Column(name = "member3", indexGroups = {"group2"})
+     *     public String member3;
+     * }
+     *
+     * Execute CREATE INDEX index_table_name_group1 on table_name(member1, member2)
+     * Execute CREATE INDEX index_table_name_group2 on table_name(member2, member3)
+     */
+    public String[] indexGroups() default {};
 }
diff --git a/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java b/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java
index c97b3fa4..37582701 100644
--- a/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java
+++ b/src/com/activeandroid/sebbia/annotation/DoNotGenerate.java
@@ -7,4 +7,6 @@
 
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
-public @interface DoNotGenerate { }
+public @interface DoNotGenerate
+{
+}
diff --git a/src/com/activeandroid/sebbia/annotation/Table.java b/src/com/activeandroid/sebbia/annotation/Table.java
index 38b22f8c..ec60e2c1 100644
--- a/src/com/activeandroid/sebbia/annotation/Table.java
+++ b/src/com/activeandroid/sebbia/annotation/Table.java
@@ -23,9 +23,12 @@
 
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
-public @interface Table {
+public @interface Table
+{
 
-	public static final String DEFAULT_ID_NAME = "Id";
-	public String name();
-	public String id() default DEFAULT_ID_NAME;
+    public static final String DEFAULT_ID_NAME = "Id";
+
+    public String name();
+
+    public String id() default DEFAULT_ID_NAME;
 }
diff --git a/src/com/activeandroid/sebbia/app/Application.java b/src/com/activeandroid/sebbia/app/Application.java
index 6b914f95..f17cca90 100644
--- a/src/com/activeandroid/sebbia/app/Application.java
+++ b/src/com/activeandroid/sebbia/app/Application.java
@@ -18,16 +18,19 @@
 
 import com.activeandroid.sebbia.ActiveAndroid;
 
-public class Application extends android.app.Application {
-	@Override
-	public void onCreate() {
-		super.onCreate();
-		ActiveAndroid.initialize(this);
-	}
-	
-	@Override
-	public void onTerminate() {
-		super.onTerminate();
-		ActiveAndroid.dispose();
-	}
+public class Application extends android.app.Application
+{
+    @Override
+    public void onCreate()
+    {
+        super.onCreate();
+        ActiveAndroid.initialize(this);
+    }
+
+    @Override
+    public void onTerminate()
+    {
+        super.onTerminate();
+        ActiveAndroid.dispose();
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/automigration/AutoMigration.java b/src/com/activeandroid/sebbia/automigration/AutoMigration.java
index 603aa1f6..aa7ef7b3 100644
--- a/src/com/activeandroid/sebbia/automigration/AutoMigration.java
+++ b/src/com/activeandroid/sebbia/automigration/AutoMigration.java
@@ -12,130 +12,166 @@
 import com.activeandroid.sebbia.util.SQLiteUtils;
 import com.activeandroid.sebbia.util.SQLiteUtils.SQLiteType;
 
-public class AutoMigration {
-	
-	public static class IncompatibleColumnTypesException extends RuntimeException {
-		private static final long serialVersionUID = -6200636421142104030L;
-		
-		public IncompatibleColumnTypesException(String table, String column, SQLiteType typeA, SQLiteType typeB) {
-			super("Failed to match column " + column + " type " + typeA + " to " + typeB + " in " + table + " table");
-		}
-	}
-	
-	public static void migrate(SQLiteDatabase db, int newVersion) {
-		db.beginTransaction();
-		try {
-			for (TableInfo tableInfo : Cache.getTableInfos()) {
-				processTableInfo(db, tableInfo);
-			}
-			db.execSQL("PRAGMA user_version = " + newVersion);
-			Log.v("Automatic migration successfull, schemas updated to version " + newVersion);
-			db.setTransactionSuccessful();
-		} finally {
-			db.endTransaction();
-		}
-	}
-	
-	private static void processTableInfo(SQLiteDatabase db, TableInfo tableInfo) {
-		SQLTableInfo sqlTableInfo = getSqlTableInfo(db, tableInfo);
-		if (sqlTableInfo != null) {
-			TableDifference tableDifference = new TableDifference(tableInfo, sqlTableInfo);
-			if (tableDifference.isEmpty() == false) {
-				applyDifference(db, tableDifference);
-			} else {
-				Log.v("Table " + tableInfo.getTableName() + " does not have any difference, skipping it");
-			}
-		} else {
-			Log.v("Table " + tableInfo.getTableName() + " does not exist. Creating new");
-			db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
-		}
-	}
-	
-	private static void applyDifference(SQLiteDatabase db, TableDifference tableDifference) {
-		TableInfo tableInfo = tableDifference.getTableInfo();
-		if (Log.isEnabled()) {
-			Log.v("Migrating table " + tableInfo.getTableName() + 
-					" from schema '" + tableDifference.getSqlTableInfo().getSchema() + 
-					"' to schema '" + SQLiteUtils.createTableDefinition(tableInfo) + "'");
-		}
-		
-		if (tableDifference.isOnlyAdd()) {
-			Log.v("Table " + tableInfo.getTableName() + " has added columns without primary / unique keys, no existing columns affected");
-			for (SQLColumnInfo columnInfo : tableDifference.getDifferences().keySet()) {
-				addColumnToTable(db, tableDifference, columnInfo);
-				Log.v("Added " + columnInfo.getName() + " column to " + tableInfo.getTableName());
-			}
-		} else {
-			Log.v("Table " + tableInfo.getTableName() + " has modified existing columns, moving data to newly created table");
-			
-			String temporaryTableName = "TEMP_" + (tableInfo.getTableName() + "_" + new Random().nextInt(1000));
-			db.execSQL("ALTER TABLE " + tableInfo.getTableName() + " RENAME TO " + temporaryTableName);
-			Log.v("Renamed " + tableInfo.getTableName() + " to " + temporaryTableName);
-			
-			db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
-			Log.v("Created new table " + tableInfo.getTableName() + " with new schema");
-					
-			transferColumns(db, temporaryTableName, tableDifference);
-			Log.v("Rows from temporary table " + temporaryTableName + " transferred to newly created table with new schema " + tableInfo.getTableName()); 
-					
-			db.execSQL("DROP TABLE " + temporaryTableName);
-			Log.v("Dropped temporary table " + temporaryTableName);
-		}
-	}
-
-	private static void addColumnToTable(SQLiteDatabase db, TableDifference tableDifference, SQLColumnInfo columnInfo) {
-		db.execSQL("ALTER TABLE " + tableDifference.getTableInfo().getTableName() + " ADD COLUMN " + columnInfo.getColumnDefinition());
-	}
-	
-	private static void transferColumns(SQLiteDatabase db, String sourceTable, TableDifference tableDifference) {
-		Cursor sourceCursor = db.query(sourceTable, null, null, null, null, null, null);
-		ContentValues contentValues = new ContentValues();
-		try {
-			
-			while (sourceCursor.moveToNext()) {
-				contentValues.clear();
-				for (SQLColumnInfo columnInfo : tableDifference.getNewSchemaColumnInfos()) {
-					if (tableDifference.getDifferences().containsKey(columnInfo)) {
-						SQLColumnInfo mappedColumnInfo = tableDifference.getDifferences().get(columnInfo); 
-						if (mappedColumnInfo != null) {
-							putValueFromCursor(contentValues, sourceCursor, mappedColumnInfo, columnInfo);
-						}
-					} else {
-						putValueFromCursor(contentValues, sourceCursor, columnInfo, columnInfo);
-					}
-				}
-				db.insert(tableDifference.getTableInfo().getTableName(), null, contentValues);
-			}
-		} finally {
-			sourceCursor.close();
-		}
-	}
-	
-	private static void putValueFromCursor(ContentValues contentValues, Cursor cursor, SQLColumnInfo sourceColumnInfo, SQLColumnInfo targetColumnInfo) {
-		switch (sourceColumnInfo.getType()) {
-		case INTEGER:
-			contentValues.put(targetColumnInfo.getName(), cursor.getInt(cursor.getColumnIndex(sourceColumnInfo.getName())));
-			break;
-			
-		case TEXT:
-			contentValues.put(targetColumnInfo.getName(), cursor.getString(cursor.getColumnIndex(sourceColumnInfo.getName())));
-			break;
-			
-		case REAL:
-			contentValues.put(targetColumnInfo.getName(), cursor.getDouble(cursor.getColumnIndex(sourceColumnInfo.getName())));
-			break;
-			
-		case BLOB:
-			contentValues.put(targetColumnInfo.getName(), cursor.getBlob(cursor.getColumnIndex(sourceColumnInfo.getName())));
-			break;
-		}
-	}
-	
-	private static SQLTableInfo getSqlTableInfo(SQLiteDatabase db, TableInfo tableInfo) {
-		Cursor cursor = db.query("sqlite_master", new String[] { "sql" }, "tbl_name = ?", new String[] { tableInfo.getTableName() }, null, null, null);
-		if (cursor.moveToNext()) {
-			return new SQLTableInfo(cursor.getString(0));
-		}
-		return null;
-	}
+public class AutoMigration
+{
+
+    public static class IncompatibleColumnTypesException extends RuntimeException
+    {
+        private static final long serialVersionUID = -6200636421142104030L;
+
+        public IncompatibleColumnTypesException(String table, String column, SQLiteType typeA, SQLiteType typeB)
+        {
+            super("Failed to match column " + column + " type " + typeA + " to " + typeB + " in " + table + " table");
+        }
+    }
+
+    public static void migrate(SQLiteDatabase db, int newVersion)
+    {
+        db.beginTransaction();
+        try
+        {
+            for (TableInfo tableInfo : Cache.getTableInfos())
+            {
+                processTableInfo(db, tableInfo);
+            }
+            db.execSQL("PRAGMA user_version = " + newVersion);
+            Log.v("Automatic migration successfull, schemas updated to version " + newVersion);
+            db.setTransactionSuccessful();
+        }
+        finally
+        {
+            db.endTransaction();
+        }
+    }
+
+    private static void processTableInfo(SQLiteDatabase db, TableInfo tableInfo)
+    {
+        SQLTableInfo sqlTableInfo = getSqlTableInfo(db, tableInfo);
+        if (sqlTableInfo != null)
+        {
+            TableDifference tableDifference = new TableDifference(tableInfo, sqlTableInfo);
+            if (tableDifference.isEmpty() == false)
+            {
+                applyDifference(db, tableDifference);
+            }
+            else
+            {
+                Log.v("Table " + tableInfo.getTableName() + " does not have any difference, skipping it");
+            }
+        }
+        else
+        {
+            Log.v("Table " + tableInfo.getTableName() + " does not exist. Creating new");
+            db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
+        }
+    }
+
+    private static void applyDifference(SQLiteDatabase db, TableDifference tableDifference)
+    {
+        TableInfo tableInfo = tableDifference.getTableInfo();
+        if (Log.isEnabled())
+        {
+            Log.v("Migrating table " + tableInfo.getTableName() +
+                    " from schema '" + tableDifference.getSqlTableInfo().getSchema() +
+                    "' to schema '" + SQLiteUtils.createTableDefinition(tableInfo) + "'");
+        }
+
+        if (tableDifference.isOnlyAdd())
+        {
+            Log.v("Table " + tableInfo.getTableName() + " has added columns without primary / unique keys, no existing columns affected");
+            for (SQLColumnInfo columnInfo : tableDifference.getDifferences().keySet())
+            {
+                addColumnToTable(db, tableDifference, columnInfo);
+                Log.v("Added " + columnInfo.getName() + " column to " + tableInfo.getTableName());
+            }
+        }
+        else
+        {
+            Log.v("Table " + tableInfo.getTableName() + " has modified existing columns, moving data to newly created table");
+
+            String temporaryTableName = "TEMP_" + (tableInfo.getTableName() + "_" + new Random().nextInt(1000));
+            db.execSQL("ALTER TABLE " + tableInfo.getTableName() + " RENAME TO " + temporaryTableName);
+            Log.v("Renamed " + tableInfo.getTableName() + " to " + temporaryTableName);
+
+            db.execSQL(SQLiteUtils.createTableDefinition(tableInfo));
+            Log.v("Created new table " + tableInfo.getTableName() + " with new schema");
+
+            transferColumns(db, temporaryTableName, tableDifference);
+            Log.v("Rows from temporary table " + temporaryTableName + " transferred to newly created table with new schema " + tableInfo.getTableName());
+
+            db.execSQL("DROP TABLE " + temporaryTableName);
+            Log.v("Dropped temporary table " + temporaryTableName);
+        }
+    }
+
+    private static void addColumnToTable(SQLiteDatabase db, TableDifference tableDifference, SQLColumnInfo columnInfo)
+    {
+        db.execSQL("ALTER TABLE " + tableDifference.getTableInfo().getTableName() + " ADD COLUMN " + columnInfo.getColumnDefinition());
+    }
+
+    private static void transferColumns(SQLiteDatabase db, String sourceTable, TableDifference tableDifference)
+    {
+        Cursor        sourceCursor  = db.query(sourceTable, null, null, null, null, null, null);
+        ContentValues contentValues = new ContentValues();
+        try
+        {
+
+            while (sourceCursor.moveToNext())
+            {
+                contentValues.clear();
+                for (SQLColumnInfo columnInfo : tableDifference.getNewSchemaColumnInfos())
+                {
+                    if (tableDifference.getDifferences().containsKey(columnInfo))
+                    {
+                        SQLColumnInfo mappedColumnInfo = tableDifference.getDifferences().get(columnInfo);
+                        if (mappedColumnInfo != null)
+                        {
+                            putValueFromCursor(contentValues, sourceCursor, mappedColumnInfo, columnInfo);
+                        }
+                    }
+                    else
+                    {
+                        putValueFromCursor(contentValues, sourceCursor, columnInfo, columnInfo);
+                    }
+                }
+                db.insert(tableDifference.getTableInfo().getTableName(), null, contentValues);
+            }
+        }
+        finally
+        {
+            sourceCursor.close();
+        }
+    }
+
+    private static void putValueFromCursor(ContentValues contentValues, Cursor cursor, SQLColumnInfo sourceColumnInfo, SQLColumnInfo targetColumnInfo)
+    {
+        switch (sourceColumnInfo.getType())
+        {
+            case INTEGER:
+                contentValues.put(targetColumnInfo.getName(), cursor.getInt(cursor.getColumnIndex(sourceColumnInfo.getName())));
+                break;
+
+            case TEXT:
+                contentValues.put(targetColumnInfo.getName(), cursor.getString(cursor.getColumnIndex(sourceColumnInfo.getName())));
+                break;
+
+            case REAL:
+                contentValues.put(targetColumnInfo.getName(), cursor.getDouble(cursor.getColumnIndex(sourceColumnInfo.getName())));
+                break;
+
+            case BLOB:
+                contentValues.put(targetColumnInfo.getName(), cursor.getBlob(cursor.getColumnIndex(sourceColumnInfo.getName())));
+                break;
+        }
+    }
+
+    private static SQLTableInfo getSqlTableInfo(SQLiteDatabase db, TableInfo tableInfo)
+    {
+        Cursor cursor = db.query("sqlite_master", new String[]{"sql"}, "tbl_name = ?", new String[]{tableInfo.getTableName()}, null, null, null);
+        if (cursor.moveToNext())
+        {
+            return new SQLTableInfo(cursor.getString(0));
+        }
+        return null;
+    }
 }
diff --git a/src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java b/src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
index 1145ad9c..923395f7 100644
--- a/src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
+++ b/src/com/activeandroid/sebbia/automigration/SQLColumnInfo.java
@@ -7,47 +7,59 @@
 
 import android.text.TextUtils;
 
-public class SQLColumnInfo {
-
-	private String mColumnDefinition;
-	private String mName;
-	private SQLiteType mType;
-
-	public SQLColumnInfo(String columnDefinition) {
-		ArrayList<String> tokens = new ArrayList<String>();
-		for (String token : columnDefinition.split(" ")) {
-			if (TextUtils.isEmpty(token) == false)
-				tokens.add(token);
-		}
-
-		if (tokens.size() < 2)
-			throw new IllegalArgumentException("Failed to parse '" + columnDefinition + "' as sql column definition");
-		
-		this.mColumnDefinition = TextUtils.join(" ", tokens.subList(1, tokens.size()));
-
-		this.mName = tokens.get(0);
-		this.mType = SQLiteType.valueOf(tokens.get(1).toUpperCase(Locale.US));
-
-	}
-
-	public String getName() {
-		return mName;
-	}
-
-	public SQLiteType getType() {
-		return mType;
-	}
-	
-	public String getColumnDefinition() {
-		return mName + " " + mColumnDefinition;
-	}
-	
-	public boolean isPrimaryKey() {
-		return mColumnDefinition.toUpperCase(Locale.US).contains("PRIMARY KEY");
-	}
-	
-	public boolean isUnique() {
-		return mColumnDefinition.toUpperCase(Locale.US).contains("UNIQUE");
-	}
-	
+public class SQLColumnInfo
+{
+
+    private String     mColumnDefinition;
+    private String     mName;
+    private SQLiteType mType;
+
+    public SQLColumnInfo(String columnDefinition)
+    {
+        ArrayList<String> tokens = new ArrayList<String>();
+        for (String token : columnDefinition.split(" "))
+        {
+            if (TextUtils.isEmpty(token) == false)
+            {
+                tokens.add(token);
+            }
+        }
+
+        if (tokens.size() < 2)
+        {
+            throw new IllegalArgumentException("Failed to parse '" + columnDefinition + "' as sql column definition");
+        }
+
+        this.mColumnDefinition = TextUtils.join(" ", tokens.subList(1, tokens.size()));
+
+        this.mName = tokens.get(0);
+        this.mType = SQLiteType.valueOf(tokens.get(1).toUpperCase(Locale.US));
+
+    }
+
+    public String getName()
+    {
+        return mName;
+    }
+
+    public SQLiteType getType()
+    {
+        return mType;
+    }
+
+    public String getColumnDefinition()
+    {
+        return mName + " " + mColumnDefinition;
+    }
+
+    public boolean isPrimaryKey()
+    {
+        return mColumnDefinition.toUpperCase(Locale.US).contains("PRIMARY KEY");
+    }
+
+    public boolean isUnique()
+    {
+        return mColumnDefinition.toUpperCase(Locale.US).contains("UNIQUE");
+    }
+
 }
diff --git a/src/com/activeandroid/sebbia/automigration/SQLTableInfo.java b/src/com/activeandroid/sebbia/automigration/SQLTableInfo.java
index 63832b60..f9f04cdc 100644
--- a/src/com/activeandroid/sebbia/automigration/SQLTableInfo.java
+++ b/src/com/activeandroid/sebbia/automigration/SQLTableInfo.java
@@ -6,70 +6,89 @@
 
 import android.text.TextUtils;
 
-public final class SQLTableInfo {
-	
-	public static String constructSchema(String tableName, List<SQLColumnInfo> columns) {
-		String schema = "CREATE TABLE " + tableName + "(%s);";
-		List<String> tokens = new ArrayList<String>();
-		for (SQLColumnInfo column : columns) { 
-			tokens.add(column.getColumnDefinition());
-		}
-		return String.format(schema, TextUtils.join(", ", tokens));
-	}
-	
-	//Note that this class does not validate SQL syntax
-	
-	private String mTableName;
-	private SQLColumnInfo mIdColumnInfo;
-	private List<SQLColumnInfo> mColumns;
-	private String mSchema;
-
-	public SQLTableInfo(String sqlSchema) {
-		
-		if (TextUtils.isEmpty(sqlSchema))
-			throw new IllegalArgumentException("Cannot construct SqlTableInfo from empty sqlSchema");
-		
-		sqlSchema = sqlSchema.replaceAll("\\s+", " ");
-		this.mSchema = new String(sqlSchema);
-		
-		if (!sqlSchema.toUpperCase(Locale.US).startsWith("CREATE TABLE") || !sqlSchema.contains("(") || !sqlSchema.contains(")"))
-			throw new IllegalArgumentException("sqlSchema doesn't appears to be valid");
-		mColumns = new ArrayList<SQLColumnInfo>();
-		
-		sqlSchema = sqlSchema.replaceAll("(?i)CREATE TABLE ", "");
-		mTableName = sqlSchema.substring(0, sqlSchema.indexOf('(')).replace("\"", "");
-		
-		String columnDefinitions = sqlSchema.substring(sqlSchema.indexOf('(') + 1, sqlSchema.lastIndexOf(')'));
-		processColumnsDefinitions(columnDefinitions.split(","));
-	}
-	
-	private void processColumnsDefinitions(String[] columns) {
-		for (String columnDef : columns) {
-			SQLColumnInfo columnInfo = new SQLColumnInfo(columnDef);
-			if (columnInfo.isPrimaryKey()) {
-				if (mIdColumnInfo == null)
-					mIdColumnInfo = columnInfo;
-				else
-					throw new IllegalArgumentException("sqlSchema contains multiple primary keys");
-			}
-			
-			mColumns.add(columnInfo);
-		}
-	}
-	
-	public String getSchema() {
-		return mSchema;
-	}
-
-	public SQLColumnInfo getIdColumnInfo() {
-		return mIdColumnInfo;
-	}
-	
-	public List<SQLColumnInfo> getColumns() {
-		return mColumns;
-	}
-	
-	public String getTableName() {
-		return mTableName;
-	}
+public final class SQLTableInfo
+{
+
+    public static String constructSchema(String tableName, List<SQLColumnInfo> columns)
+    {
+        String       schema = "CREATE TABLE " + tableName + "(%s);";
+        List<String> tokens = new ArrayList<String>();
+        for (SQLColumnInfo column : columns)
+        {
+            tokens.add(column.getColumnDefinition());
+        }
+        return String.format(schema, TextUtils.join(", ", tokens));
+    }
+
+    //Note that this class does not validate SQL syntax
+
+    private String              mTableName;
+    private SQLColumnInfo       mIdColumnInfo;
+    private List<SQLColumnInfo> mColumns;
+    private String              mSchema;
+
+    public SQLTableInfo(String sqlSchema)
+    {
+
+        if (TextUtils.isEmpty(sqlSchema))
+        {
+            throw new IllegalArgumentException("Cannot construct SqlTableInfo from empty sqlSchema");
+        }
+
+        sqlSchema = sqlSchema.replaceAll("\\s+", " ");
+        this.mSchema = new String(sqlSchema);
+
+        if (!sqlSchema.toUpperCase(Locale.US).startsWith("CREATE TABLE") || !sqlSchema.contains("(") || !sqlSchema.contains(")"))
+        {
+            throw new IllegalArgumentException("sqlSchema doesn't appears to be valid");
+        }
+        mColumns = new ArrayList<SQLColumnInfo>();
+
+        sqlSchema = sqlSchema.replaceAll("(?i)CREATE TABLE ", "");
+        mTableName = sqlSchema.substring(0, sqlSchema.indexOf('(')).replace("\"", "");
+
+        String columnDefinitions = sqlSchema.substring(sqlSchema.indexOf('(') + 1, sqlSchema.lastIndexOf(')'));
+        processColumnsDefinitions(columnDefinitions.split(","));
+    }
+
+    private void processColumnsDefinitions(String[] columns)
+    {
+        for (String columnDef : columns)
+        {
+            SQLColumnInfo columnInfo = new SQLColumnInfo(columnDef);
+            if (columnInfo.isPrimaryKey())
+            {
+                if (mIdColumnInfo == null)
+                {
+                    mIdColumnInfo = columnInfo;
+                }
+                else
+                {
+                    throw new IllegalArgumentException("sqlSchema contains multiple primary keys");
+                }
+            }
+
+            mColumns.add(columnInfo);
+        }
+    }
+
+    public String getSchema()
+    {
+        return mSchema;
+    }
+
+    public SQLColumnInfo getIdColumnInfo()
+    {
+        return mIdColumnInfo;
+    }
+
+    public List<SQLColumnInfo> getColumns()
+    {
+        return mColumns;
+    }
+
+    public String getTableName()
+    {
+        return mTableName;
+    }
 }
diff --git a/src/com/activeandroid/sebbia/automigration/TableDifference.java b/src/com/activeandroid/sebbia/automigration/TableDifference.java
index aaba59fd..6b368ca2 100644
--- a/src/com/activeandroid/sebbia/automigration/TableDifference.java
+++ b/src/com/activeandroid/sebbia/automigration/TableDifference.java
@@ -10,70 +10,91 @@
 import com.activeandroid.sebbia.automigration.AutoMigration.IncompatibleColumnTypesException;
 import com.activeandroid.sebbia.util.SQLiteUtils;
 
-class TableDifference {
-	
-	
-	private TableInfo mTableInfo;
-	private SQLTableInfo mSqlTableInfo;
-	private Map<SQLColumnInfo, SQLColumnInfo> mDifferences;
-	private List<SQLColumnInfo> mCurrentVersionTableDefinitions;
-	
-	public TableDifference(TableInfo tableInfo, SQLTableInfo sqlTableInfo) {
-		this.mTableInfo = tableInfo;
-		this.mSqlTableInfo = sqlTableInfo;
-		this.mDifferences = new HashMap<SQLColumnInfo, SQLColumnInfo>();
-		this.mCurrentVersionTableDefinitions = new ArrayList<SQLColumnInfo>();
-		
-		for (Field field : tableInfo.getFields()) {
-			SQLColumnInfo sqlColumnInfo = new SQLColumnInfo(SQLiteUtils.createColumnDefinition(tableInfo, field));
-			mCurrentVersionTableDefinitions.add(sqlColumnInfo);
-			
-			boolean found = false;
-			for (SQLColumnInfo existingColumnInfo : sqlTableInfo.getColumns()) {
-				if (existingColumnInfo.getName().equalsIgnoreCase(sqlColumnInfo.getName()) == false)
-					continue;
-				
-				found = true;
-				
-				if (existingColumnInfo.getColumnDefinition().equalsIgnoreCase(sqlColumnInfo.getColumnDefinition()) == false) {
-					if (existingColumnInfo.getType() == sqlColumnInfo.getType()) {
-						mDifferences.put(sqlColumnInfo, existingColumnInfo);
-					} else {
-						throw new IncompatibleColumnTypesException(tableInfo.getTableName(), existingColumnInfo.getName(), existingColumnInfo.getType(), sqlColumnInfo.getType());
-					}
-				}
-				break;
-			}
-			if (!found)
-				mDifferences.put(sqlColumnInfo, null);
-		}
-	}
-	
-	public boolean isOnlyAdd() {
-		for (SQLColumnInfo sqlColumnInfo : mDifferences.keySet()) {
-			if (mDifferences.get(sqlColumnInfo) != null || sqlColumnInfo.isPrimaryKey() || sqlColumnInfo.isUnique())
-				return false;
-		}
-		return true;
-	}
-	
-	public boolean isEmpty() {
-		return mDifferences.size() == 0;
-	}
-	
-	public Map<SQLColumnInfo, SQLColumnInfo> getDifferences() {
-		return mDifferences;
-	}
-	
-	public List<SQLColumnInfo> getNewSchemaColumnInfos() {
-		return mCurrentVersionTableDefinitions;
-	}
-	
-	public TableInfo getTableInfo() {
-		return mTableInfo;
-	}
-	
-	public SQLTableInfo getSqlTableInfo() {
-		return mSqlTableInfo;
-	}
+class TableDifference
+{
+
+
+    private TableInfo                         mTableInfo;
+    private SQLTableInfo                      mSqlTableInfo;
+    private Map<SQLColumnInfo, SQLColumnInfo> mDifferences;
+    private List<SQLColumnInfo>               mCurrentVersionTableDefinitions;
+
+    public TableDifference(TableInfo tableInfo, SQLTableInfo sqlTableInfo)
+    {
+        this.mTableInfo = tableInfo;
+        this.mSqlTableInfo = sqlTableInfo;
+        this.mDifferences = new HashMap<SQLColumnInfo, SQLColumnInfo>();
+        this.mCurrentVersionTableDefinitions = new ArrayList<SQLColumnInfo>();
+
+        for (Field field : tableInfo.getFields())
+        {
+            SQLColumnInfo sqlColumnInfo = new SQLColumnInfo(SQLiteUtils.createColumnDefinition(tableInfo, field));
+            mCurrentVersionTableDefinitions.add(sqlColumnInfo);
+
+            boolean found = false;
+            for (SQLColumnInfo existingColumnInfo : sqlTableInfo.getColumns())
+            {
+                if (existingColumnInfo.getName().equalsIgnoreCase(sqlColumnInfo.getName()) == false)
+                {
+                    continue;
+                }
+
+                found = true;
+
+                if (existingColumnInfo.getColumnDefinition().equalsIgnoreCase(sqlColumnInfo.getColumnDefinition()) == false)
+                {
+                    if (existingColumnInfo.getType() == sqlColumnInfo.getType())
+                    {
+                        mDifferences.put(sqlColumnInfo, existingColumnInfo);
+                    }
+                    else
+                    {
+                        throw new IncompatibleColumnTypesException(tableInfo.getTableName(), existingColumnInfo.getName(), existingColumnInfo.getType(), sqlColumnInfo.getType());
+                    }
+                }
+                break;
+            }
+            if (!found)
+            {
+                mDifferences.put(sqlColumnInfo, null);
+            }
+        }
+    }
+
+    public boolean isOnlyAdd()
+    {
+        for (SQLColumnInfo sqlColumnInfo : mDifferences.keySet())
+        {
+            if (mDifferences.get(sqlColumnInfo) != null || sqlColumnInfo.isPrimaryKey() || sqlColumnInfo.isUnique())
+            {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public boolean isEmpty()
+    {
+        return mDifferences.size() == 0;
+    }
+
+    public Map<SQLColumnInfo, SQLColumnInfo> getDifferences()
+    {
+        return mDifferences;
+    }
+
+    public List<SQLColumnInfo> getNewSchemaColumnInfos()
+    {
+        return mCurrentVersionTableDefinitions;
+    }
+
+    public TableInfo getTableInfo()
+    {
+        return mTableInfo;
+    }
+
+    public SQLTableInfo getSqlTableInfo()
+    {
+        return mSqlTableInfo;
+    }
 }
diff --git a/src/com/activeandroid/sebbia/content/ContentProvider.java b/src/com/activeandroid/sebbia/content/ContentProvider.java
index c49c30d7..b9ed8113 100644
--- a/src/com/activeandroid/sebbia/content/ContentProvider.java
+++ b/src/com/activeandroid/sebbia/content/ContentProvider.java
@@ -1,8 +1,5 @@
 package com.activeandroid.sebbia.content;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import android.content.ContentValues;
 import android.content.UriMatcher;
 import android.database.Cursor;
@@ -15,178 +12,211 @@
 import com.activeandroid.sebbia.Model;
 import com.activeandroid.sebbia.TableInfo;
 
-public class ContentProvider extends android.content.ContentProvider {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
-	private static final SparseArray<Class<? extends Model>> TYPE_CODES = new SparseArray<Class<? extends Model>>();
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static String sAuthority;
-	private static SparseArray<String> sMimeTypeCache = new SparseArray<String>();
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@Override
-	public boolean onCreate() {
-		ActiveAndroid.initialize(getConfiguration());
-		sAuthority = getAuthority();
-
-		final List<TableInfo> tableInfos = new ArrayList<TableInfo>(Cache.getTableInfos());
-		final int size = tableInfos.size();
-		for (int i = 0; i < size; i++) {
-			final TableInfo tableInfo = tableInfos.get(i);
-			final int tableKey = (i * 2) + 1;
-			final int itemKey = (i * 2) + 2;
-
-			// content://<authority>/<table>
-			URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase(), tableKey);
-			TYPE_CODES.put(tableKey, tableInfo.getType());
-
-			// content://<authority>/<table>/<id>
-			URI_MATCHER.addURI(sAuthority, tableInfo.getTableName().toLowerCase() + "/#", itemKey);
-			TYPE_CODES.put(itemKey, tableInfo.getType());
-		}
-
-		return true;
-	}
-
-	@Override
-	public String getType(Uri uri) {
-		final int match = URI_MATCHER.match(uri);
-
-		String cachedMimeType = sMimeTypeCache.get(match);
-		if (cachedMimeType != null) {
-			return cachedMimeType;
-		}
-
-		final Class<? extends Model> type = getModelType(uri);
-		final boolean single = ((match % 2) == 0);
-
-		StringBuilder mimeType = new StringBuilder();
-		mimeType.append("vnd");
-		mimeType.append(".");
-		mimeType.append(sAuthority);
-		mimeType.append(".");
-		mimeType.append(single ? "item" : "dir");
-		mimeType.append("/");
-		mimeType.append("vnd");
-		mimeType.append(".");
-		mimeType.append(sAuthority);
-		mimeType.append(".");
-		mimeType.append(Cache.getTableName(type));
-
-		sMimeTypeCache.append(match, mimeType.toString());
-
-		return mimeType.toString();
-	}
-
-	// SQLite methods
-
-	@Override
-	public Uri insert(Uri uri, ContentValues values) {
-		final Class<? extends Model> type = getModelType(uri);
-		final Long id = Cache.openDatabase().insert(Cache.getTableName(type), null, values);
-
-		if (id != null && id > 0) {
-			Uri retUri = createUri(type, id);
-			notifyChange(retUri);
-
-			return retUri;
-		}
-
-		return null;
-	}
-
-	@Override
-	public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-		final Class<? extends Model> type = getModelType(uri);
-		final int count = Cache.openDatabase().update(Cache.getTableName(type), values, selection, selectionArgs);
-
-		notifyChange(uri);
-
-		return count;
-	}
-
-	@Override
-	public int delete(Uri uri, String selection, String[] selectionArgs) {
-		final Class<? extends Model> type = getModelType(uri);
-		final int count = Cache.openDatabase().delete(Cache.getTableName(type), selection, selectionArgs);
-
-		notifyChange(uri);
-
-		return count;
-	}
-
-	@Override
-	public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
-		final Class<? extends Model> type = getModelType(uri);
-		final Cursor cursor = Cache.openDatabase().query(
-				Cache.getTableName(type),
-				projection,
-				selection,
-				selectionArgs,
-				null,
-				null,
-				sortOrder);
-
-		cursor.setNotificationUri(getContext().getContentResolver(), uri);
-
-		return cursor;
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static Uri createUri(Class<? extends Model> type, Long id) {
-		final StringBuilder uri = new StringBuilder();
-		uri.append("content://");
-		uri.append(sAuthority);
-		uri.append("/");
-		uri.append(Cache.getTableName(type).toLowerCase());
-
-		if (id != null) {
-			uri.append("/");
-			uri.append(id.toString());
-		}
-
-		return Uri.parse(uri.toString());
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PROTECTED METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	protected String getAuthority() {
-		return getContext().getPackageName();
-	}
-
-	protected Configuration getConfiguration() {
-		return new Configuration.Builder(getContext()).create();
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private Class<? extends Model> getModelType(Uri uri) {
-		final int code = URI_MATCHER.match(uri);
-		if (code != UriMatcher.NO_MATCH) {
-			return TYPE_CODES.get(code);
-		}
+import java.util.ArrayList;
+import java.util.List;
 
-		return null;
-	}
-
-	private void notifyChange(Uri uri) {
-		getContext().getContentResolver().notifyChange(uri, null);
-	}
+public class ContentProvider extends android.content.ContentProvider
+{
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private static final UriMatcher                          URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
+    private static final SparseArray<Class<? extends Model>> TYPE_CODES  = new SparseArray<Class<? extends Model>>();
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private static String sAuthority;
+    private static SparseArray<String> sMimeTypeCache = new SparseArray<String>();
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @Override
+    public boolean onCreate()
+    {
+        ActiveAndroid.initialize(getConfiguration());
+        sAuthority = getAuthority();
+
+        final List<TableInfo> tableInfos = new ArrayList<TableInfo>(Cache.getTableInfos());
+        final int             size       = tableInfos.size();
+        for (int i = 0; i < size; i++)
+        {
+            final TableInfo tableInfo = tableInfos.get(i);
+            final int tableKey = (i * 2) + 1;
+            final int itemKey = (i * 2) + 2;
+
+            // content://<authority>/<table>
+            URI_MATCHER.addURI(sAuthority, "*/" + tableInfo.getTableName().toLowerCase(), tableKey);
+            TYPE_CODES.put(tableKey, tableInfo.getType());
+
+            // content://<authority>/<table>/<id>
+            URI_MATCHER.addURI(sAuthority, "*/" + tableInfo.getTableName().toLowerCase() + "/#", itemKey);
+            TYPE_CODES.put(itemKey, tableInfo.getType());
+        }
+
+        return true;
+    }
+
+    @Override
+    public String getType(Uri uri)
+    {
+        final int match = URI_MATCHER.match(uri);
+
+        String cachedMimeType = sMimeTypeCache.get(match);
+        if (cachedMimeType != null)
+        {
+            return cachedMimeType;
+        }
+
+        final Class<? extends Model> type   = getModelType(uri);
+        final boolean                single = ((match % 2) == 0);
+
+        StringBuilder mimeType = new StringBuilder();
+        mimeType.append("vnd");
+        mimeType.append(".");
+        mimeType.append(sAuthority);
+        mimeType.append(".");
+        mimeType.append(single ? "item" : "dir");
+        mimeType.append("/");
+        mimeType.append("vnd");
+        mimeType.append(".");
+        mimeType.append(sAuthority);
+        mimeType.append(".");
+        mimeType.append(Cache.getTableName(type));
+
+        sMimeTypeCache.append(match, mimeType.toString());
+
+        return mimeType.toString();
+    }
+
+    // SQLite methods
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values)
+    {
+        final Class<? extends Model> type    = getModelType(uri);
+        String                       database = getDatabase(uri);
+
+        final Long id = Cache.openDatabase(database).insert(Cache.getTableName(type), null, values);
+
+        if (id != null && id > 0)
+        {
+            Uri retUri = createUri(type, id);
+            notifyChange(retUri);
+
+            return retUri;
+        }
+
+        return null;
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
+    {
+        final Class<? extends Model> type    = getModelType(uri);
+        String                       database = getDatabase(uri);
+
+        final int count = Cache.openDatabase(database).update(Cache.getTableName(type), values, selection, selectionArgs);
+
+        notifyChange(uri);
+
+        return count;
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs)
+    {
+        final Class<? extends Model> type    = getModelType(uri);
+        String                       database = getDatabase(uri);
+        final int                    count   = Cache.openDatabase(database).delete(Cache.getTableName(type), selection, selectionArgs);
+
+        notifyChange(uri);
+
+        return count;
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
+    {
+        final Class<? extends Model> type    = getModelType(uri);
+        String                       database = getDatabase(uri);
+
+        final Cursor cursor = Cache.openDatabase(database).query(
+                Cache.getTableName(type),
+                projection,
+                selection,
+                selectionArgs,
+                null,
+                null,
+                sortOrder);
+
+        cursor.setNotificationUri(getContext().getContentResolver(), uri);
+
+        return cursor;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static Uri createUri(Class<? extends Model> type, Long id)
+    {
+        final StringBuilder uri = new StringBuilder();
+        uri.append("content://");
+        uri.append(sAuthority);
+        uri.append("/");
+        uri.append(Cache.getTableName(type).toLowerCase());
+
+        if (id != null)
+        {
+            uri.append("/");
+            uri.append(id.toString());
+        }
+
+        return Uri.parse(uri.toString());
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PROTECTED METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    protected String getAuthority()
+    {
+        return getContext().getPackageName();
+    }
+
+    protected Configuration getConfiguration()
+    {
+        return new Configuration.Builder(getContext()).create();
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private Class<? extends Model> getModelType(Uri uri)
+    {
+        final int code = URI_MATCHER.match(uri);
+        if (code != UriMatcher.NO_MATCH)
+        {
+            return TYPE_CODES.get(code);
+        }
+
+        return null;
+    }
+
+    private String getDatabase(Uri uri)
+    {
+        List<String> segments = uri.getPathSegments();
+        return segments.get(0);
+    }
+
+    private void notifyChange(Uri uri)
+    {
+        getContext().getContentResolver().notifyChange(uri, null);
+    }
 }
diff --git a/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java b/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
index 81969839..e3579a2b 100644
--- a/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
+++ b/src/com/activeandroid/sebbia/internal/AnnotationProcessor.java
@@ -25,399 +25,546 @@
 import com.activeandroid.sebbia.annotation.Column;
 import com.activeandroid.sebbia.annotation.DoNotGenerate;
 
-public final class AnnotationProcessor extends AbstractProcessor {
-
-	private static final String MODEL = "model";
-	private static final String CURSOR = "cursor";
-	private static final String CONTENT_VALUES = "contentValues";
-	private static final String COLUMNS_ORDERED = "columnsOrdered";
-	private static final String STATEMENT = "statement";
-	private static final String COLUMNS = "columns";
-
-	private RoundEnvironment env;
-
-	@Override
-	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
-		this.env = env;
-		if (annotations.size() > 0) {
-			parseColumns();
-		}
-		return true;
-	}
-
-	@Override
-	public Set<String> getSupportedAnnotationTypes() {
-		Set<String> supportedTypes = new HashSet<String>();
-		supportedTypes.add(Column.class.getCanonicalName());
-		return supportedTypes;
-	}
-
-	@Override
-	public SourceVersion getSupportedSourceVersion() {
-		return SourceVersion.latestSupported();
-	}
-
-	private void parseColumns() {
-		Set<? extends Element> columns = env.getElementsAnnotatedWith(Column.class);
-		Map<TypeElement, Set<VariableElement>> tables = new HashMap<TypeElement, Set<VariableElement>>();
-		for (Element element : columns) {
-			if (element instanceof VariableElement == false || element.getKind() != ElementKind.FIELD) {
-				error("@Column annotation should be applied only to local variables", element);
-				continue;
-			}
-			VariableElement columnElement = (VariableElement) element;
-
-			TypeElement tableElement = null;
-			if (element.getEnclosingElement() instanceof TypeElement) {
-				tableElement = (TypeElement) element.getEnclosingElement();
-			} else {
-				error("@Column annotation located not inside of class", element);
-				continue;
-			}
-				
-			if (checkTableModifiers(tableElement) == false)
-				continue;
-			
-			if (checkColumnModifiers(columnElement) == false)
-				continue;
-
-			Set<VariableElement> columnsElements = tables.get(tableElement);
-			if (columnsElements == null) {
-				columnsElements = new HashSet<VariableElement>();
-				tables.put(tableElement, columnsElements);
-			}
-
-			columnsElements.add(columnElement);
-
-		}
-
-		for (TypeElement table : tables.keySet()) {
-			generate(table, tables.get(table));
-		}
-	}
-
-	private void generate(TypeElement tableElement, Set<VariableElement> columns) {
-		String packageName = processingEnv.getElementUtils().getPackageOf(tableElement).getQualifiedName().toString();
-		String className = tableElement.getQualifiedName().toString();
-		String fillerClassName = getClassName(tableElement, packageName) + ModelFiller.SUFFIX;
-
-		try {
-			JavaFileObject jfo = processingEnv.getFiler().createSourceFile(packageName + "." + fillerClassName, tableElement);
-			Writer writer = jfo.openWriter();
-			writer.write("//Generated by ActiveAndroid. Do not modify\n");
-			writer.write("package " + packageName + ";\n\n");
-			
-			writer.write("import android.database.sqlite.SQLiteStatement;\n");
-			writer.write("import java.util.ArrayList;\n");
-			writer.write("import java.util.Arrays;\n");
-			writer.write("import java.util.List;\n\n");
-			writer.write("import java.util.Map;\n\n");
-
-			writer.write("import com.activeandroid.sebbia.internal.ModelHelper;\n");
-			writer.write("import com.activeandroid.sebbia.internal.ModelFiller;\n");
-			writer.write("\n");
-			writer.write("public class " + fillerClassName + " extends ModelFiller {\n\n");
-			writer.write("  public void loadFromCursor(com.activeandroid.sebbia.Model genericModel, android.database.Cursor " + CURSOR + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.loadFromCursor(genericModel, " + CURSOR + ");\n");
-			writer.write("    List<String> " + COLUMNS_ORDERED + " = new ArrayList<String>(Arrays.asList(" + CURSOR + ".getColumnNames()));\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getLoadFromCursorCode(columns));
-			writer.write("  }\n\n");
-
-			
-			writer.write("  public void fillContentValues(com.activeandroid.sebbia.Model genericModel, android.content.ContentValues " + CONTENT_VALUES + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.fillContentValues(genericModel, " + CONTENT_VALUES + ");\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getFillContentValuesCode(columns));
-			writer.write("  }\n");
-			
-			writer.write("  public void bindStatement(com.activeandroid.sebbia.Model genericModel, SQLiteStatement " + STATEMENT + ", Map<String, Integer> " + COLUMNS + ") {\n");
-			writer.write("    if (superModelFiller != null)\n");
-			writer.write("       superModelFiller.bindStatement(genericModel, " + STATEMENT + ", " + COLUMNS + ");\n");
-			writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
-			writer.write(getBindStatementCode(columns));
-			writer.write("  }\n");
-
-			writer.write("}");
-			writer.flush();
-			writer.close();
-		} catch (IOException exception) {
-			processingEnv.getMessager().printMessage(Kind.ERROR, exception.getMessage());
-		}
-	}
-
-	private String getLoadFromCursorCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-
-			TypeMirror typeMirror = column.asType();
-			String type = getClassString(typeMirror, typeMirror instanceof DeclaredType);
-			String getColumnIndex = COLUMNS_ORDERED + ".indexOf(\"" + fieldName + "\")";
-
-			String setValue = "    " + MODEL + "." + column.getSimpleName() + " = " + CURSOR;
-
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append("    " + MODEL + "." + column.getSimpleName() + " = (short) " + CURSOR + ".getInt(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append(setValue + ".getLong(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append(setValue + ".getFloat(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append(setValue + ".getDouble(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ") != 0;\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append(setValue + ".getBlob(" + getColumnIndex + ");\n");
-			else {
-				processingEnv.getMessager().printMessage(Kind.NOTE, "Guessing what type is at " + typeMirror.toString(), null);
-				stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
-				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = (" + typeMirror.toString() + ") ModelHelper.getSerializable(cursor, " + type + ", " + getColumnIndex + ");\n");
-				stringBuilder.append("    } else {\n");
-				stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = ");
-				if (isTypeOf(typeMirror, Model.class))
-					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getModel(cursor, " + type + ", " + getColumnIndex + ");\n");
-				else if (isTypeOf(typeMirror, Enum.class))
-					stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getEnum(cursor, " + type + ", " + getColumnIndex + ");\n");
-				else
-					stringBuilder.append(" null;\n");
-				
-				stringBuilder.append("    }\n");
-			}
-		}
-		return stringBuilder.toString();
-	}
-
-	private String getFillContentValuesCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-			
-			TypeMirror typeMirror = column.asType();
-			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
-			String type = getClassString(typeMirror, notPrimitiveType);
-			String getValue = MODEL + "." + column.getSimpleName();
-			
-			boolean hasDefault = annotation.defaultValue() != null && annotation.defaultValue().isEmpty() == false;
-			String emptySpace = "    ";
-			if (notPrimitiveType) {
-				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
-				emptySpace += "  ";
- 			}
-			String putValue = emptySpace + CONTENT_VALUES + ".put(\"" + fieldName + "\", " + getValue;
-			
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append(putValue + ");\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append(putValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append(putValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append(putValue + ");\n");
-			else {
-				stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
-				stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + CONTENT_VALUES + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
-				stringBuilder.append(emptySpace + "} else {\n");
-				stringBuilder.append(emptySpace + "  " + CONTENT_VALUES + ".");
-				if (isTypeOf(typeMirror, Model.class))
-					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".getId());\n");
-				else if (isTypeOf(typeMirror, Enum.class))
-					stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".name());\n");
-				else
-					stringBuilder.append("putNull(\"" + fieldName + "\");\n");
-				stringBuilder.append(emptySpace + "}\n");
-			}
-			if (notPrimitiveType) {
-				if (hasDefault == false) {
-					stringBuilder.append("    } else {\n");
-					stringBuilder.append("      " + CONTENT_VALUES + ".putNull(\"" + fieldName +  "\");\n");
-				}
-				stringBuilder.append("    }\n");
-			}
-		}
-		return stringBuilder.toString();
-	}
-	
-	private String getBindStatementCode(Set<VariableElement> columns) {
-		StringBuilder stringBuilder = new StringBuilder();
-
-		for (VariableElement column : columns) {
-			Column annotation = column.getAnnotation(Column.class);
-
-			String fieldName = annotation.name();
-
-			if (fieldName == null || fieldName.isEmpty())
-				fieldName = column.getSimpleName().toString();
-			
-			TypeMirror typeMirror = column.asType();
-			boolean notPrimitiveType = typeMirror instanceof DeclaredType;
-			String type = getClassString(typeMirror, notPrimitiveType);
-			
-			String getValue = MODEL + "." + column.getSimpleName();
-			
-			String columnIndex = COLUMNS + ".get(\"" + fieldName + "\")"; 
-			String emptySpace = "    ";
-			
-			if (notPrimitiveType) {
-				stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
-				emptySpace += "  ";
- 			}
-			String bind = emptySpace + STATEMENT + ".bind";
-			
-			if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
-				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
-				stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
-			else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
-				stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + " ? 1 : 0);\n");
-			else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
-				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, String.class))
-				stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
-			else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
-				stringBuilder.append(bind + "Blob(" + columnIndex + ", " + getValue + ");\n");
-			else {
-				boolean isModel = isTypeOf(typeMirror, Model.class);
-				boolean isEnum = isTypeOf(typeMirror, Enum.class);
-				if (isModel || isEnum) {
-					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
-					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");  
-					stringBuilder.append(emptySpace + "} else {\n");
-					stringBuilder.append(emptySpace + "  " + STATEMENT + ".bind");
-					if (isModel)
-						stringBuilder.append("Long(" + columnIndex + ", " + getValue + ".getId());\n");
-					else if (isEnum)
-						stringBuilder.append("String(" + columnIndex + ", " + getValue + ".name());\n");
-					stringBuilder.append(emptySpace + "}\n");
-				} else {
-					stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + "))\n");
-					stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");
-				}
-			}
-			if (notPrimitiveType)
-				stringBuilder.append("    }\n");
-		}
-		return stringBuilder.toString();
-	}
-
-	private String getClassString(TypeMirror typeMirror, boolean notPrimitiveType) {
-		String type = typeMirror.toString() + ".class";
-		if (notPrimitiveType) {
-			DeclaredType declaredType = (DeclaredType) typeMirror;
-			List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-			if (typeArguments != null && typeArguments.size() > 0)
-				type = ((TypeElement) declaredType.asElement()).getQualifiedName() + ".class";
-		}
-		return type;
-	}
-
-	private boolean isTypeOf(TypeMirror typeMirror, Class<?> type) {
-		if (type.getCanonicalName().equals(typeMirror.toString()))
-			return true;
-
-		if (typeMirror instanceof DeclaredType == false)
-			return false;
-
-		DeclaredType declaredType = (DeclaredType) typeMirror;
-		Element element = declaredType.asElement();
-		if (element instanceof TypeElement == false)
-			return false;
-
-		TypeElement typeElement = (TypeElement) element;
-		if (type == Enum.class)
-			return typeElement.getKind() == ElementKind.ENUM;
-		
-		TypeMirror superType = typeElement.getSuperclass();
-		if (isTypeOf(superType, type))
-			return true;
-		return false;
-	}
-
-	private boolean checkTableModifiers(TypeElement table) {
-		if (table.getModifiers().contains(Modifier.PRIVATE)) {
-			error("Classes marked with @Table cannot be private", table);
-			return false;
-		}
-
-		if (table.getKind() != ElementKind.CLASS) {
-			error("Only classes can be marked with @Table annotation", table);
-			return false;
-		}
-		
-		if (table.getAnnotation(DoNotGenerate.class) != null)
-			return false;
-
-		return true;
-	}
-
-	private boolean checkColumnModifiers(VariableElement column) {
-
-		if (column.getModifiers().contains(Modifier.PRIVATE)) {
-			error("Field marked with @Column cannot be private", column);
-			return false;
-		}
-
-		if (column.getModifiers().contains(Modifier.FINAL)) {
-			error("Field marked with @Column cannot be final", column);
-			return false;
-		}
-
-		if (column.getModifiers().contains(Modifier.STATIC)) {
-			error("Field marked with @Column cannot be static", column);
-			return false;
-		}
-
-		return true;
-	}
-
-	private void error(String message, Element element) {
-		processingEnv.getMessager().printMessage(Kind.ERROR, message, element);
-	}
-
-	private static String getClassName(TypeElement type, String packageName) {
-		int packageLen = packageName.length() + 1;
-		return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
-	}
+public final class AnnotationProcessor extends AbstractProcessor
+{
+
+    private static final String MODEL           = "model";
+    private static final String CURSOR          = "cursor";
+    private static final String CONTENT_VALUES  = "contentValues";
+    private static final String COLUMNS_ORDERED = "columnsOrdered";
+    private static final String STATEMENT       = "statement";
+    private static final String COLUMNS         = "columns";
+
+    private RoundEnvironment env;
+
+    @Override
+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env)
+    {
+        this.env = env;
+        if (annotations.size() > 0)
+        {
+            parseColumns();
+        }
+        return true;
+    }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes()
+    {
+        Set<String> supportedTypes = new HashSet<String>();
+        supportedTypes.add(Column.class.getCanonicalName());
+        return supportedTypes;
+    }
+
+    @Override
+    public SourceVersion getSupportedSourceVersion()
+    {
+        return SourceVersion.latestSupported();
+    }
+
+    private void parseColumns()
+    {
+        Set<? extends Element>                 columns = env.getElementsAnnotatedWith(Column.class);
+        Map<TypeElement, Set<VariableElement>> tables  = new HashMap<TypeElement, Set<VariableElement>>();
+        for (Element element : columns)
+        {
+            if (element instanceof VariableElement == false || element.getKind() != ElementKind.FIELD)
+            {
+                error("@Column annotation should be applied only to local variables", element);
+                continue;
+            }
+            VariableElement columnElement = (VariableElement) element;
+
+            TypeElement tableElement = null;
+            if (element.getEnclosingElement() instanceof TypeElement)
+            {
+                tableElement = (TypeElement) element.getEnclosingElement();
+            }
+            else
+            {
+                error("@Column annotation located not inside of class", element);
+                continue;
+            }
+
+            if (checkTableModifiers(tableElement) == false)
+            {
+                continue;
+            }
+
+            if (checkColumnModifiers(columnElement) == false)
+            {
+                continue;
+            }
+
+            Set<VariableElement> columnsElements = tables.get(tableElement);
+            if (columnsElements == null)
+            {
+                columnsElements = new HashSet<VariableElement>();
+                tables.put(tableElement, columnsElements);
+            }
+
+            columnsElements.add(columnElement);
+
+        }
+
+        for (TypeElement table : tables.keySet())
+        {
+            generate(table, tables.get(table));
+        }
+    }
+
+    private void generate(TypeElement tableElement, Set<VariableElement> columns)
+    {
+        String packageName     = processingEnv.getElementUtils().getPackageOf(tableElement).getQualifiedName().toString();
+        String className       = tableElement.getQualifiedName().toString();
+        String fillerClassName = getClassName(tableElement, packageName) + ModelFiller.SUFFIX;
+
+        try
+        {
+            JavaFileObject jfo = processingEnv.getFiler().createSourceFile(packageName + "." + fillerClassName, tableElement);
+            Writer writer = jfo.openWriter();
+            writer.write("//Generated by ActiveAndroid. Do not modify\n");
+            writer.write("package " + packageName + ";\n\n");
+
+            writer.write("import android.database.sqlite.SQLiteStatement;\n");
+            writer.write("import java.util.ArrayList;\n");
+            writer.write("import java.util.Arrays;\n");
+            writer.write("import java.util.List;\n\n");
+            writer.write("import java.util.Map;\n\n");
+
+            writer.write("import com.activeandroid.sebbia.internal.ModelHelper;\n");
+            writer.write("import com.activeandroid.sebbia.internal.ModelFiller;\n");
+            writer.write("\n");
+            writer.write("public class " + fillerClassName + " extends ModelFiller {\n\n");
+            writer.write("  public void loadFromCursor(com.activeandroid.sebbia.Model genericModel, android.database.Cursor " + CURSOR + ") {\n");
+            writer.write("    if (superModelFiller != null)\n");
+            writer.write("       superModelFiller.loadFromCursor(genericModel, " + CURSOR + ");\n");
+            writer.write("    List<String> " + COLUMNS_ORDERED + " = new ArrayList<String>(Arrays.asList(" + CURSOR + ".getColumnNames()));\n");
+            writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+            writer.write(getLoadFromCursorCode(columns));
+            writer.write("  }\n\n");
+
+
+            writer.write("  public void fillContentValues(com.activeandroid.sebbia.Model genericModel, android.content.ContentValues " + CONTENT_VALUES + ") {\n");
+            writer.write("    if (superModelFiller != null)\n");
+            writer.write("       superModelFiller.fillContentValues(genericModel, " + CONTENT_VALUES + ");\n");
+            writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+            writer.write(getFillContentValuesCode(columns));
+            writer.write("  }\n");
+
+            writer.write("  public void bindStatement(com.activeandroid.sebbia.Model genericModel, SQLiteStatement " + STATEMENT + ", Map<String, Integer> " + COLUMNS + ") {\n");
+            writer.write("    if (superModelFiller != null)\n");
+            writer.write("       superModelFiller.bindStatement(genericModel, " + STATEMENT + ", " + COLUMNS + ");\n");
+            writer.write("    " + className + " " + MODEL + " = (" + className + ") genericModel;\n");
+            writer.write(getBindStatementCode(columns));
+            writer.write("  }\n");
+
+            writer.write("}");
+            writer.flush();
+            writer.close();
+        }
+        catch (IOException exception)
+        {
+            processingEnv.getMessager().printMessage(Kind.ERROR, exception.getMessage());
+        }
+    }
+
+    private String getLoadFromCursorCode(Set<VariableElement> columns)
+    {
+        StringBuilder stringBuilder = new StringBuilder();
+
+        for (VariableElement column : columns)
+        {
+            Column annotation = column.getAnnotation(Column.class);
+
+            String fieldName = annotation.name();
+
+            if (fieldName == null || fieldName.isEmpty())
+            {
+                fieldName = column.getSimpleName().toString();
+            }
+
+            TypeMirror typeMirror = column.asType();
+            String type = getClassString(typeMirror, typeMirror instanceof DeclaredType);
+            String getColumnIndex = COLUMNS_ORDERED + ".indexOf(\"" + fieldName + "\")";
+
+            String setValue = "    " + MODEL + "." + column.getSimpleName() + " = " + CURSOR;
+
+            if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+            {
+                stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+            {
+                stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+            {
+                stringBuilder.append("    " + MODEL + "." + column.getSimpleName() + " = (short) " + CURSOR + ".getInt(" + getColumnIndex + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+            {
+                stringBuilder.append(setValue + ".getLong(" + getColumnIndex + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+            {
+                stringBuilder.append(setValue + ".getFloat(" + getColumnIndex + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+            {
+                stringBuilder.append(setValue + ".getDouble(" + getColumnIndex + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+            {
+                stringBuilder.append(setValue + ".getInt(" + getColumnIndex + ") != 0;\n");
+            }
+            else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+            {
+                stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
+            }
+            else if (isTypeOf(typeMirror, String.class))
+            {
+                stringBuilder.append(setValue + ".getString(" + getColumnIndex + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+            {
+                stringBuilder.append(setValue + ".getBlob(" + getColumnIndex + ");\n");
+            }
+            else
+            {
+                processingEnv.getMessager().printMessage(Kind.NOTE, "Guessing what type is at " + typeMirror.toString(), null);
+                stringBuilder.append("    if (ModelHelper.isSerializable(" + type + ")) {\n");
+                stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = (" + typeMirror.toString() + ") ModelHelper.getSerializable(cursor, " + type + ", " + getColumnIndex + ");\n");
+                stringBuilder.append("    } else {\n");
+                stringBuilder.append("      " + MODEL + "." + column.getSimpleName() + " = ");
+                if (isTypeOf(typeMirror, Model.class))
+                {
+                    stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getModel(cursor, " + type + ", " + getColumnIndex + ");\n");
+                }
+                else if (isTypeOf(typeMirror, Enum.class))
+                {
+                    stringBuilder.append("(" + typeMirror.toString() + ") ModelHelper.getEnum(cursor, " + type + ", " + getColumnIndex + ");\n");
+                }
+                else
+                {
+                    stringBuilder.append(" null;\n");
+                }
+
+                stringBuilder.append("    }\n");
+            }
+        }
+        return stringBuilder.toString();
+    }
+
+    private String getFillContentValuesCode(Set<VariableElement> columns)
+    {
+        StringBuilder stringBuilder = new StringBuilder();
+
+        for (VariableElement column : columns)
+        {
+            Column annotation = column.getAnnotation(Column.class);
+
+            String fieldName = annotation.name();
+
+            if (fieldName == null || fieldName.isEmpty())
+            {
+                fieldName = column.getSimpleName().toString();
+            }
+
+            TypeMirror typeMirror = column.asType();
+            boolean notPrimitiveType = typeMirror instanceof DeclaredType;
+            String type = getClassString(typeMirror, notPrimitiveType);
+            String getValue = MODEL + "." + column.getSimpleName();
+
+            boolean hasDefault = annotation.defaultValue() != null && annotation.defaultValue().isEmpty() == false;
+            String emptySpace = "    ";
+            if (notPrimitiveType)
+            {
+                stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
+                emptySpace += "  ";
+            }
+            String putValue = emptySpace + CONTENT_VALUES + ".put(\"" + fieldName + "\", " + getValue;
+
+            if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+            {
+                stringBuilder.append(putValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+            {
+                stringBuilder.append(putValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+            {
+                stringBuilder.append(putValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+            {
+                stringBuilder.append(putValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+            {
+                stringBuilder.append(putValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+            {
+                stringBuilder.append(putValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+            {
+                stringBuilder.append(putValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+            {
+                stringBuilder.append(putValue + ".toString());\n");
+            }
+            else if (isTypeOf(typeMirror, String.class))
+            {
+                stringBuilder.append(putValue + ".toString());\n");
+            }
+            else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+            {
+                stringBuilder.append(putValue + ");\n");
+            }
+            else
+            {
+                stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
+                stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + CONTENT_VALUES + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");
+                stringBuilder.append(emptySpace + "} else {\n");
+                stringBuilder.append(emptySpace + "  " + CONTENT_VALUES + ".");
+                if (isTypeOf(typeMirror, Model.class))
+                {
+                    stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".getId());\n");
+                }
+                else if (isTypeOf(typeMirror, Enum.class))
+                {
+                    stringBuilder.append("put(\"" + fieldName + "\", " + getValue + ".name());\n");
+                }
+                else
+                {
+                    stringBuilder.append("putNull(\"" + fieldName + "\");\n");
+                }
+                stringBuilder.append(emptySpace + "}\n");
+            }
+            if (notPrimitiveType)
+            {
+                if (hasDefault == false)
+                {
+                    stringBuilder.append("    } else {\n");
+                    stringBuilder.append("      " + CONTENT_VALUES + ".putNull(\"" + fieldName + "\");\n");
+                }
+                stringBuilder.append("    }\n");
+            }
+        }
+        return stringBuilder.toString();
+    }
+
+    private String getBindStatementCode(Set<VariableElement> columns)
+    {
+        StringBuilder stringBuilder = new StringBuilder();
+
+        for (VariableElement column : columns)
+        {
+            Column annotation = column.getAnnotation(Column.class);
+
+            String fieldName = annotation.name();
+
+            if (fieldName == null || fieldName.isEmpty())
+            {
+                fieldName = column.getSimpleName().toString();
+            }
+
+            TypeMirror typeMirror = column.asType();
+            boolean notPrimitiveType = typeMirror instanceof DeclaredType;
+            String type = getClassString(typeMirror, notPrimitiveType);
+
+            String getValue = MODEL + "." + column.getSimpleName();
+
+            String columnIndex = COLUMNS + ".get(\"" + fieldName + "\")";
+            String emptySpace = "    ";
+
+            if (notPrimitiveType)
+            {
+                stringBuilder.append(emptySpace + "if (" + getValue + " != null) {\n");
+                emptySpace += "  ";
+            }
+            String bind = emptySpace + STATEMENT + ".bind";
+
+            if (isTypeOf(typeMirror, Integer.class) || isTypeOf(typeMirror, int.class))
+            {
+                stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Byte.class) || isTypeOf(typeMirror, byte.class))
+            {
+                stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Short.class) || isTypeOf(typeMirror, short.class))
+            {
+                stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Long.class) || isTypeOf(typeMirror, long.class))
+            {
+                stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Float.class) || isTypeOf(typeMirror, float.class))
+            {
+                stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Double.class) || isTypeOf(typeMirror, double.class))
+            {
+                stringBuilder.append(bind + "Double(" + columnIndex + ", " + getValue + ");\n");
+            }
+            else if (isTypeOf(typeMirror, Boolean.class) || isTypeOf(typeMirror, boolean.class))
+            {
+                stringBuilder.append(bind + "Long(" + columnIndex + ", " + getValue + " ? 1 : 0);\n");
+            }
+            else if (isTypeOf(typeMirror, Character.class) || isTypeOf(typeMirror, char.class))
+            {
+                stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
+            }
+            else if (isTypeOf(typeMirror, String.class))
+            {
+                stringBuilder.append(bind + "String(" + columnIndex + ", " + getValue + ".toString());\n");
+            }
+            else if (isTypeOf(typeMirror, Byte[].class) || isTypeOf(typeMirror, byte[].class))
+            {
+                stringBuilder.append(bind + "Blob(" + columnIndex + ", " + getValue + ");\n");
+            }
+            else
+            {
+                boolean isModel = isTypeOf(typeMirror, Model.class);
+                boolean isEnum = isTypeOf(typeMirror, Enum.class);
+                if (isModel || isEnum)
+                {
+                    stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + ")) {\n");
+                    stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");
+                    stringBuilder.append(emptySpace + "} else {\n");
+                    stringBuilder.append(emptySpace + "  " + STATEMENT + ".bind");
+                    if (isModel)
+                    {
+                        stringBuilder.append("Long(" + columnIndex + ", " + getValue + ".getId());\n");
+                    }
+                    else if (isEnum)
+                    {
+                        stringBuilder.append("String(" + columnIndex + ", " + getValue + ".name());\n");
+                    }
+                    stringBuilder.append(emptySpace + "}\n");
+                }
+                else
+                {
+                    stringBuilder.append(emptySpace + "if (ModelHelper.isSerializable(" + type + "))\n");
+                    stringBuilder.append(emptySpace + "  ModelHelper.setSerializable(" + STATEMENT + ", " + COLUMNS + ", " + type + ", " + getValue + ", \"" + fieldName + "\");\n");
+                }
+            }
+            if (notPrimitiveType)
+            {
+                stringBuilder.append("    }\n");
+            }
+        }
+        return stringBuilder.toString();
+    }
+
+    private String getClassString(TypeMirror typeMirror, boolean notPrimitiveType)
+    {
+        String type = typeMirror.toString() + ".class";
+        if (notPrimitiveType)
+        {
+            DeclaredType declaredType = (DeclaredType) typeMirror;
+            List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+            if (typeArguments != null && typeArguments.size() > 0)
+            {
+                type = ((TypeElement) declaredType.asElement()).getQualifiedName() + ".class";
+            }
+        }
+        return type;
+    }
+
+    private boolean isTypeOf(TypeMirror typeMirror, Class<?> type)
+    {
+        if (type.getCanonicalName().equals(typeMirror.toString()))
+        {
+            return true;
+        }
+
+        if (typeMirror instanceof DeclaredType == false)
+        {
+            return false;
+        }
+
+        DeclaredType declaredType = (DeclaredType) typeMirror;
+        Element      element      = declaredType.asElement();
+        if (element instanceof TypeElement == false)
+        {
+            return false;
+        }
+
+        TypeElement typeElement = (TypeElement) element;
+        if (type == Enum.class)
+        {
+            return typeElement.getKind() == ElementKind.ENUM;
+        }
+
+        TypeMirror superType = typeElement.getSuperclass();
+        if (isTypeOf(superType, type))
+        {
+            return true;
+        }
+        return false;
+    }
+
+    private boolean checkTableModifiers(TypeElement table)
+    {
+        if (table.getModifiers().contains(Modifier.PRIVATE))
+        {
+            error("Classes marked with @Table cannot be private", table);
+            return false;
+        }
+
+        if (table.getKind() != ElementKind.CLASS)
+        {
+            error("Only classes can be marked with @Table annotation", table);
+            return false;
+        }
+
+        if (table.getAnnotation(DoNotGenerate.class) != null)
+        {
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean checkColumnModifiers(VariableElement column)
+    {
+
+        if (column.getModifiers().contains(Modifier.PRIVATE))
+        {
+            error("Field marked with @Column cannot be private", column);
+            return false;
+        }
+
+        if (column.getModifiers().contains(Modifier.FINAL))
+        {
+            error("Field marked with @Column cannot be final", column);
+            return false;
+        }
+
+        if (column.getModifiers().contains(Modifier.STATIC))
+        {
+            error("Field marked with @Column cannot be static", column);
+            return false;
+        }
+
+        return true;
+    }
+
+    private void error(String message, Element element)
+    {
+        processingEnv.getMessager().printMessage(Kind.ERROR, message, element);
+    }
+
+    private static String getClassName(TypeElement type, String packageName)
+    {
+        int packageLen = packageName.length() + 1;
+        return type.getQualifiedName().toString().substring(packageLen).replace('.', '$');
+    }
 }
diff --git a/src/com/activeandroid/sebbia/internal/EmptyModelFiller.java b/src/com/activeandroid/sebbia/internal/EmptyModelFiller.java
index 695ac5a1..f6f75b4f 100644
--- a/src/com/activeandroid/sebbia/internal/EmptyModelFiller.java
+++ b/src/com/activeandroid/sebbia/internal/EmptyModelFiller.java
@@ -8,23 +8,33 @@
 
 import com.activeandroid.sebbia.Model;
 
-public class EmptyModelFiller extends ModelFiller {
+public class EmptyModelFiller extends ModelFiller
+{
 
-	@Override
-	public void loadFromCursor(Model model, Cursor cursor) {
-		if (superModelFiller != null)
-			superModelFiller.loadFromCursor(model, cursor);
-	}
+    @Override
+    public void loadFromCursor(Model model, Cursor cursor)
+    {
+        if (superModelFiller != null)
+        {
+            superModelFiller.loadFromCursor(model, cursor);
+        }
+    }
 
-	@Override
-	public void fillContentValues(Model model, ContentValues contentValues) {
-		if (superModelFiller != null)
-			superModelFiller.fillContentValues(model, contentValues);
-	}
+    @Override
+    public void fillContentValues(Model model, ContentValues contentValues)
+    {
+        if (superModelFiller != null)
+        {
+            superModelFiller.fillContentValues(model, contentValues);
+        }
+    }
 
-	@Override
-	public void bindStatement(Model model, SQLiteStatement statement, Map<String, Integer> columns) {
-		if (superModelFiller != null)
-			superModelFiller.bindStatement(model, statement, columns);
-	}
+    @Override
+    public void bindStatement(Model model, SQLiteStatement statement, Map<String, Integer> columns)
+    {
+        if (superModelFiller != null)
+        {
+            superModelFiller.bindStatement(model, statement, columns);
+        }
+    }
 }
diff --git a/src/com/activeandroid/sebbia/internal/ModelFiller.java b/src/com/activeandroid/sebbia/internal/ModelFiller.java
index dd8af96b..fe39cf02 100644
--- a/src/com/activeandroid/sebbia/internal/ModelFiller.java
+++ b/src/com/activeandroid/sebbia/internal/ModelFiller.java
@@ -8,13 +8,14 @@
 
 import com.activeandroid.sebbia.Model;
 
-public abstract class ModelFiller {
-	public static final String SUFFIX = "$$ActiveAndroidModelFiller";
-	public ModelFiller superModelFiller;
+public abstract class ModelFiller
+{
+    public static final String SUFFIX = "$$ActiveAndroidModelFiller";
+    public ModelFiller superModelFiller;
 
-	public abstract void loadFromCursor(Model model, Cursor cursor);
+    public abstract void loadFromCursor(Model model, Cursor cursor);
 
-	public abstract void fillContentValues(Model model, ContentValues contentValues);
+    public abstract void fillContentValues(Model model, ContentValues contentValues);
 
-	public abstract void bindStatement(Model model, SQLiteStatement statement, Map<String, Integer> columns);
+    public abstract void bindStatement(Model model, SQLiteStatement statement, Map<String, Integer> columns);
 }
diff --git a/src/com/activeandroid/sebbia/internal/ModelHelper.java b/src/com/activeandroid/sebbia/internal/ModelHelper.java
index d6a719e6..11faf113 100644
--- a/src/com/activeandroid/sebbia/internal/ModelHelper.java
+++ b/src/com/activeandroid/sebbia/internal/ModelHelper.java
@@ -1,7 +1,5 @@
 package com.activeandroid.sebbia.internal;
 
-import java.util.Map;
-
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteStatement;
@@ -14,208 +12,273 @@
 import com.activeandroid.sebbia.util.Log;
 import com.activeandroid.sebbia.util.ReflectionUtils;
 
-public class ModelHelper {
-	
-	public static boolean isSerializable(Class<?> fieldType) {
-		return Cache.getParserForType(fieldType) != null;
-	}
-	
-	public static Object getSerializable(Cursor cursor, Class<?> fieldType, int columnIndex) {
-		TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-		if (typeSerializer == null)
-			return null;
-		
-		if (cursor.isNull(columnIndex))
-			return null;
-		
-		fieldType = typeSerializer.getSerializedType();
-		Object value = getValueFromCursor(cursor, fieldType, columnIndex);
-		if (value != null) {
-			value = typeSerializer.deserialize(value);
-		}
-		return value;
-	}
-	
-	public static void setSerializable(ContentValues values, Class<?> fieldType, Object value, String fieldName) {
-		if (value == null) {
-			values.putNull(fieldName);
-			return;
-		}
-		
-		TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-		if (typeSerializer == null)
-			return;
-		value = typeSerializer.serialize(value);
-		if (value != null) {
-			fieldType = value.getClass();
-			// check that the serializer returned what it promised
-			if (!fieldType.equals(typeSerializer.getSerializedType())) {
-				Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-						typeSerializer.getSerializedType(), fieldType));
-			}
-		}
-		// TODO: Find a smarter way to do this? This if block is necessary because we
-		// can't know the type until runtime.
-		if (value == null) {
-			values.putNull(fieldName);
-		} else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-			values.put(fieldName, (Byte) value);
-		}
-		else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-			values.put(fieldName, (Short) value);
-		}
-		else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-			values.put(fieldName, (Integer) value);
-		}
-		else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-			values.put(fieldName, (Long) value);
-		}
-		else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-			values.put(fieldName, (Float) value);
-		}
-		else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-			values.put(fieldName, (Double) value);
-		}
-		else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-			values.put(fieldName, (Boolean) value);
-		}
-		else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-			values.put(fieldName, value.toString());
-		}
-		else if (fieldType.equals(String.class)) {
-			values.put(fieldName, value.toString());
-		}
-		else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-			values.put(fieldName, (byte[]) value);
-		}
-		else if (ReflectionUtils.isModel(fieldType)) {
-			values.put(fieldName, ((Model) value).getId());
-		}
-		else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-			values.put(fieldName, ((Enum<?>) value).name());
-		}
-	}
-	
-	public static void setSerializable(SQLiteStatement statement, Map<String, Integer> columns, Class<?> fieldType, Object value, String fieldName) {
-		if (value == null) {
-			return;
-		}
-		
-		TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
-		if (typeSerializer == null)
-			return;
-		
-		int columnIndex = columns.get(fieldName);
-		value = typeSerializer.serialize(value);
-		if (value != null) {
-			fieldType = value.getClass();
-			// check that the serializer returned what it promised
-			if (!fieldType.equals(typeSerializer.getSerializedType())) {
-				Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
-						typeSerializer.getSerializedType(), fieldType));
-			}
-		}
-		// TODO: Find a smarter way to do this? This if block is necessary because we
-		// can't know the type until runtime.
-		if (value == null) {
-			return;
-		}
-		
-		if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-			statement.bindLong(columnIndex, (Long) value);
-		}
-		else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-			statement.bindLong(columnIndex, (Long) value);
-		}
-		else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-			statement.bindLong(columnIndex, (Long) value);
-		}
-		else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-			statement.bindLong(columnIndex, (Long) value);
-		}
-		else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-			statement.bindDouble(columnIndex, (Double) value);
-		}
-		else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-			statement.bindDouble(columnIndex,  (Double) value);
-		}
-		else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-			statement.bindLong(columnIndex, ((Boolean) value) ? 1L : 0L);
-		}
-		else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-			statement.bindString(columnIndex, value.toString());
-		}
-		else if (fieldType.equals(String.class)) {
-			statement.bindString(columnIndex, (String) value);
-		}
-		else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-			statement.bindBlob(columnIndex, (byte[]) value);
-		}
-		else if (ReflectionUtils.isModel(fieldType)) {
-			statement.bindLong(columnIndex, ((Model) value).getId());
-		}
-		else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class)) {
-			statement.bindString(columnIndex, ((Enum<?>) value).name());
-		}
-	}
-	
-	@SuppressWarnings("unchecked")
-	public static Object getModel(Cursor cursor, Class<?> fieldType, int columnIndex) {
-		final long entityId = cursor.getLong(columnIndex);
-		final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
-
-		Model entity = Cache.getEntity(entityType, entityId);
-		if (entity == null) {
-			entity = new Select().from(entityType).where(Cache.getTableInfo(entityType).getIdName() + "=?", entityId).executeSingle();
-		}
-		return entity;
-	}
-	
-	@SuppressWarnings("unchecked")
-	public static Object getEnum(Cursor cursor, Class<?> fieldType, int columnIndex) {
-		@SuppressWarnings("rawtypes")
-		final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
-		String enumName = cursor.getString(columnIndex);
-		if (!TextUtils.isEmpty(enumName))
-			return Enum.valueOf(enumType, cursor.getString(columnIndex));
-		return null;
-	}
-	
-	public static Object getValueFromCursor(Cursor cursor, Class<?> fieldType, int columnIndex) {
-		// TODO: Find a smarter way to do this? This if block is necessary because we
-		// can't know the type until runtime.
-		Object value = null;
-		if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
-			value = cursor.getInt(columnIndex);
-		}
-		else if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
-			value = cursor.getInt(columnIndex);
-		}
-		else if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
-			value = cursor.getInt(columnIndex);
-		}
-		else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
-			value = cursor.getLong(columnIndex);
-		}
-		else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
-			value = cursor.getFloat(columnIndex);
-		}
-		else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
-			value = cursor.getDouble(columnIndex);
-		}
-		else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
-			value = cursor.getInt(columnIndex) != 0;
-		}
-		else if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
-			value = cursor.getString(columnIndex).charAt(0);
-		}
-		else if (fieldType.equals(String.class)) {
-			value = cursor.getString(columnIndex);
-		}
-		else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
-			value = cursor.getBlob(columnIndex);
-		}
-		return value;
-	}
+import java.util.Map;
+
+public class ModelHelper
+{
+
+    public static boolean isSerializable(Class<?> fieldType)
+    {
+        return Cache.getParserForType(fieldType) != null;
+    }
+
+    public static Object getSerializable(Cursor cursor, Class<?> fieldType, int columnIndex)
+    {
+        TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+        if (typeSerializer == null)
+        {
+            return null;
+        }
+
+        if (cursor.isNull(columnIndex))
+        {
+            return null;
+        }
+
+        fieldType = typeSerializer.getSerializedType();
+        Object value = getValueFromCursor(cursor, fieldType, columnIndex);
+        if (value != null)
+        {
+            value = typeSerializer.deserialize(value);
+        }
+        return value;
+    }
+
+    public static void setSerializable(ContentValues values, Class<?> fieldType, Object value, String fieldName)
+    {
+        if (value == null)
+        {
+            values.putNull(fieldName);
+            return;
+        }
+
+        TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+        if (typeSerializer == null)
+        {
+            return;
+        }
+        value = typeSerializer.serialize(value);
+        if (value != null)
+        {
+            fieldType = value.getClass();
+            // check that the serializer returned what it promised
+            if (!fieldType.equals(typeSerializer.getSerializedType()))
+            {
+                Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                        typeSerializer.getSerializedType(), fieldType));
+            }
+        }
+        // TODO: Find a smarter way to do this? This if block is necessary because we
+        // can't know the type until runtime.
+        if (value == null)
+        {
+            values.putNull(fieldName);
+        }
+        else if (fieldType.equals(Byte.class) || fieldType.equals(byte.class))
+        {
+            values.put(fieldName, (Byte) value);
+        }
+        else if (fieldType.equals(Short.class) || fieldType.equals(short.class))
+        {
+            values.put(fieldName, (Short) value);
+        }
+        else if (fieldType.equals(Integer.class) || fieldType.equals(int.class))
+        {
+            values.put(fieldName, (Integer) value);
+        }
+        else if (fieldType.equals(Long.class) || fieldType.equals(long.class))
+        {
+            values.put(fieldName, (Long) value);
+        }
+        else if (fieldType.equals(Float.class) || fieldType.equals(float.class))
+        {
+            values.put(fieldName, (Float) value);
+        }
+        else if (fieldType.equals(Double.class) || fieldType.equals(double.class))
+        {
+            values.put(fieldName, (Double) value);
+        }
+        else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class))
+        {
+            values.put(fieldName, (Boolean) value);
+        }
+        else if (fieldType.equals(Character.class) || fieldType.equals(char.class))
+        {
+            values.put(fieldName, value.toString());
+        }
+        else if (fieldType.equals(String.class))
+        {
+            values.put(fieldName, value.toString());
+        }
+        else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class))
+        {
+            values.put(fieldName, (byte[]) value);
+        }
+        else if (ReflectionUtils.isModel(fieldType))
+        {
+            values.put(fieldName, ((Model) value).getId());
+        }
+        else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class))
+        {
+            values.put(fieldName, ((Enum<?>) value).name());
+        }
+    }
+
+    public static void setSerializable(SQLiteStatement statement, Map<String, Integer> columns, Class<?> fieldType, Object value, String fieldName)
+    {
+        if (value == null)
+        {
+            return;
+        }
+
+        TypeSerializer typeSerializer = Cache.getParserForType(fieldType);
+        if (typeSerializer == null)
+        {
+            return;
+        }
+
+        int columnIndex = columns.get(fieldName);
+        value = typeSerializer.serialize(value);
+        if (value != null)
+        {
+            fieldType = value.getClass();
+            // check that the serializer returned what it promised
+            if (!fieldType.equals(typeSerializer.getSerializedType()))
+            {
+                Log.w(String.format("TypeSerializer returned wrong type: expected a %s but got a %s",
+                        typeSerializer.getSerializedType(), fieldType));
+            }
+        }
+        // TODO: Find a smarter way to do this? This if block is necessary because we
+        // can't know the type until runtime.
+        if (value == null)
+        {
+            return;
+        }
+
+        if (fieldType.equals(Byte.class) || fieldType.equals(byte.class))
+        {
+            statement.bindLong(columnIndex, (Long) value);
+        }
+        else if (fieldType.equals(Short.class) || fieldType.equals(short.class))
+        {
+            statement.bindLong(columnIndex, (Long) value);
+        }
+        else if (fieldType.equals(Integer.class) || fieldType.equals(int.class))
+        {
+            statement.bindLong(columnIndex, (Long) value);
+        }
+        else if (fieldType.equals(Long.class) || fieldType.equals(long.class))
+        {
+            statement.bindLong(columnIndex, (Long) value);
+        }
+        else if (fieldType.equals(Float.class) || fieldType.equals(float.class))
+        {
+            statement.bindDouble(columnIndex, (Double) value);
+        }
+        else if (fieldType.equals(Double.class) || fieldType.equals(double.class))
+        {
+            statement.bindDouble(columnIndex, (Double) value);
+        }
+        else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class))
+        {
+            statement.bindLong(columnIndex, ((Boolean) value) ? 1L : 0L);
+        }
+        else if (fieldType.equals(Character.class) || fieldType.equals(char.class))
+        {
+            statement.bindString(columnIndex, value.toString());
+        }
+        else if (fieldType.equals(String.class))
+        {
+            statement.bindString(columnIndex, (String) value);
+        }
+        else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class))
+        {
+            statement.bindBlob(columnIndex, (byte[]) value);
+        }
+        else if (ReflectionUtils.isModel(fieldType))
+        {
+            statement.bindLong(columnIndex, ((Model) value).getId());
+        }
+        else if (ReflectionUtils.isSubclassOf(fieldType, Enum.class))
+        {
+            statement.bindString(columnIndex, ((Enum<?>) value).name());
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public static Object getModel(String database, Cursor cursor, Class<?> fieldType, int columnIndex)
+    {
+        final long                   entityId   = cursor.getLong(columnIndex);
+        final Class<? extends Model> entityType = (Class<? extends Model>) fieldType;
+
+        Model entity = Cache.getEntity(entityType, entityId);
+        if (entity == null)
+        {
+            entity = new Select().from(entityType).where(Cache.getTableInfo(entityType).getIdName() + "=?", entityId).executeSingle(database);
+        }
+        return entity;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static Object getEnum(Cursor cursor, Class<?> fieldType, int columnIndex)
+    {
+        @SuppressWarnings("rawtypes")
+        final Class<? extends Enum> enumType = (Class<? extends Enum>) fieldType;
+        String enumName = cursor.getString(columnIndex);
+        if (!TextUtils.isEmpty(enumName))
+        {
+            return Enum.valueOf(enumType, cursor.getString(columnIndex));
+        }
+        return null;
+    }
+
+    public static Object getValueFromCursor(Cursor cursor, Class<?> fieldType, int columnIndex)
+    {
+        // TODO: Find a smarter way to do this? This if block is necessary because we
+        // can't know the type until runtime.
+        Object value = null;
+        if (fieldType.equals(Byte.class) || fieldType.equals(byte.class))
+        {
+            value = cursor.getInt(columnIndex);
+        }
+        else if (fieldType.equals(Short.class) || fieldType.equals(short.class))
+        {
+            value = cursor.getInt(columnIndex);
+        }
+        else if (fieldType.equals(Integer.class) || fieldType.equals(int.class))
+        {
+            value = cursor.getInt(columnIndex);
+        }
+        else if (fieldType.equals(Long.class) || fieldType.equals(long.class))
+        {
+            value = cursor.getLong(columnIndex);
+        }
+        else if (fieldType.equals(Float.class) || fieldType.equals(float.class))
+        {
+            value = cursor.getFloat(columnIndex);
+        }
+        else if (fieldType.equals(Double.class) || fieldType.equals(double.class))
+        {
+            value = cursor.getDouble(columnIndex);
+        }
+        else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class))
+        {
+            value = cursor.getInt(columnIndex) != 0;
+        }
+        else if (fieldType.equals(Character.class) || fieldType.equals(char.class))
+        {
+            value = cursor.getString(columnIndex).charAt(0);
+        }
+        else if (fieldType.equals(String.class))
+        {
+            value = cursor.getString(columnIndex);
+        }
+        else if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class))
+        {
+            value = cursor.getBlob(columnIndex);
+        }
+        return value;
+    }
 
 }
diff --git a/src/com/activeandroid/sebbia/model/ManyToManyRelation.java b/src/com/activeandroid/sebbia/model/ManyToManyRelation.java
index 469192bb..7d6a5ec2 100644
--- a/src/com/activeandroid/sebbia/model/ManyToManyRelation.java
+++ b/src/com/activeandroid/sebbia/model/ManyToManyRelation.java
@@ -1,8 +1,5 @@
 package com.activeandroid.sebbia.model;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import com.activeandroid.sebbia.Cache;
 import com.activeandroid.sebbia.Model;
 import com.activeandroid.sebbia.TableInfo;
@@ -12,156 +9,194 @@
 import com.activeandroid.sebbia.util.Log;
 import com.activeandroid.sebbia.util.SQLiteUtils;
 
+import java.util.ArrayList;
+import java.util.List;
+
 @DoNotGenerate
-public abstract class ManyToManyRelation<T1 extends Model, T2 extends Model> extends Model {
-
-	@Column (name = "entity1")
-	private T1 entity1;
-	@Column (name = "entity2")
-	private T2 entity2;
-
-	public static <T1 extends Model, T2 extends Model> void setRelationsFront(Class<? extends ManyToManyRelation<T1, T2>> relation, T1 entity1, List<T2> entities2) {
-		if (entity1.getId() == null)
-			throw new IllegalArgumentException(entity1.getClass().getSimpleName() + " is not saved to database yet, aborting");
-		for (T2 entity2 : entities2) {
-			if (entity2.getId() == null)
-				throw new IllegalArgumentException(entity2.getClass().getSimpleName() + " is not saved to database yet, aborting");
-		}
-
-		new Delete().from(relation).where("entity1 = ?", entity1.getId()).execute();
-		try {
-			ArrayList<ManyToManyRelation<T1, T2>> connections = new ArrayList<ManyToManyRelation<T1,T2>>();
-			for (T2 entity2 : entities2) {
-				ManyToManyRelation<T1, T2> connection = relation.newInstance();
-				connection.entity1 = entity1;
-				connection.entity2 = entity2;
-				connections.add(connection);
-			}
-			saveMultiple(connections);
-		} catch (Exception e) {
-			Log.e("Cannot create instance of class " + relation.getSimpleName());
-			throw new RuntimeException(e);
-		}
-	}
-
-	public static <T1 extends Model, T2 extends Model> void setRelationsReverse(Class<? extends ManyToManyRelation<T1, T2>> relation, T2 entity2, List<T1> entities1) {
-		if (entity2.getId() == null)
-			throw new IllegalArgumentException(entity2.getClass().getSimpleName() + " is not saved to database yet, aborting");
-		for (T1 entity1 : entities1) {
-			if (entity1.getId() == null)
-				throw new IllegalArgumentException(entity1.getClass().getSimpleName() + " is not saved to database yet, aborting");
-		}
-
-		new Delete().from(relation).where("entity2 = ?", entity2.getId()).execute();
-		try {
-			ArrayList<ManyToManyRelation<T1, T2>> connections = new ArrayList<ManyToManyRelation<T1,T2>>();
-			for (T1 entity1 : entities1) {
-				ManyToManyRelation<T1, T2> connection = relation.newInstance();
-				connection.entity1 = entity1;
-				connection.entity2 = entity2;
-				connections.add(connection);
-			}
-			saveMultiple(connections);
-		} catch (Exception e) {
-			Log.e("Cannot create instance of class " + relation.getSimpleName());
-			throw new RuntimeException(e);
-		}
-	}
-
-	public static <T1 extends Model, T2 extends Model> List<T2> getRelationsFront(Class<? extends ManyToManyRelation<T1, T2>> relation, T1 entity) {
-		if (entity.getId() == null)
-			throw new IllegalArgumentException(entity.getClass().getSimpleName() + " is not saved to database yet, aborting");
-
-		Class<? extends Model> entity1Class;
-		Class<? extends Model> entity2Class;
-		TableInfo entity1TableInfo;
-		TableInfo entity2TableInfo;
-		TableInfo crossTableInfo;
-		try {
-			ManyToManyRelation<T1, T2> instance = relation.newInstance();
-			entity1Class = instance.getEntity1Class();
-			entity2Class = instance.getEntity2Class();
-			entity1TableInfo = Cache.getTableInfo(entity1Class);
-			entity2TableInfo = Cache.getTableInfo(entity2Class);
-			crossTableInfo = Cache.getTableInfo(relation);
-		} catch (Exception e) {
-			throw new RuntimeException(e);
-		}
-
-		StringBuilder queryBuilder = new StringBuilder();
-		queryBuilder.append("SELECT ");
-		queryBuilder.append(entity2TableInfo.getTableName());
-		queryBuilder.append(".* FROM (");
-		queryBuilder.append(entity1TableInfo.getTableName());
-		queryBuilder.append(" JOIN ");
-		queryBuilder.append(crossTableInfo.getTableName());
-		queryBuilder.append(" ON ");
-		queryBuilder.append(entity1TableInfo.getTableName());
-		queryBuilder.append(".id == ");
-		queryBuilder.append(crossTableInfo.getTableName());
-		queryBuilder.append(".entity1) JOIN ");
-		queryBuilder.append(entity2TableInfo.getTableName());
-		queryBuilder.append(" ON ");
-		queryBuilder.append(entity2TableInfo.getTableName());
-		queryBuilder.append(".id == ");
-		queryBuilder.append(crossTableInfo.getTableName());
-		queryBuilder.append(".entity2 WHERE ");
-		queryBuilder.append(entity1TableInfo.getTableName());
-		queryBuilder.append(".id == ?");
-
-		return SQLiteUtils.rawQuery(entity2Class, queryBuilder.toString(), new String[] {entity.getId().toString()});
-	}
-
-	public static <T1 extends Model, T2 extends Model> List<T1> getRelationsReverse(Class<? extends ManyToManyRelation<T1, T2>> relation, T2 entity) {
-		if (entity.getId() == null)
-			throw new IllegalArgumentException(entity.getClass().getSimpleName() + " is not saved to database yet, aborting");
-
-		Class<? extends Model> entity1Class;
-		Class<? extends Model> entity2Class;
-		TableInfo entity1TableInfo;
-		TableInfo entity2TableInfo;
-		TableInfo crossTableInfo;
-		try {
-			ManyToManyRelation<T1, T2> instance = relation.newInstance();
-			entity1Class = instance.getEntity1Class();
-			entity2Class = instance.getEntity2Class();
-			entity1TableInfo = Cache.getTableInfo(entity1Class);
-			entity2TableInfo = Cache.getTableInfo(entity2Class);
-			crossTableInfo = Cache.getTableInfo(relation);
-		} catch (Exception e) {
-			throw new RuntimeException(e);
-		}
-
-		StringBuilder queryBuilder = new StringBuilder();
-		queryBuilder.append("SELECT ");
-		queryBuilder.append(entity1TableInfo.getTableName());
-		queryBuilder.append(".* FROM (");
-		queryBuilder.append(entity2TableInfo.getTableName());
-		queryBuilder.append(" JOIN ");
-		queryBuilder.append(crossTableInfo.getTableName());
-		queryBuilder.append(" ON ");
-		queryBuilder.append(entity2TableInfo.getTableName());
-		queryBuilder.append(".id == ");
-		queryBuilder.append(crossTableInfo.getTableName());
-		queryBuilder.append(".entity2) JOIN ");
-		queryBuilder.append(entity1TableInfo.getTableName());
-		queryBuilder.append(" ON ");
-		queryBuilder.append(entity1TableInfo.getTableName());
-		queryBuilder.append(".id == ");
-		queryBuilder.append(crossTableInfo.getTableName());
-		queryBuilder.append(".entity1 WHERE ");
-		queryBuilder.append(entity2TableInfo.getTableName());
-		queryBuilder.append(".id == ?");
-
-		return SQLiteUtils.rawQuery(entity1Class, queryBuilder.toString(), new String[] {entity.getId().toString()});
-	}
-
-	public ManyToManyRelation() {
-		super();
-	}
-
-	public abstract Class<T1> getEntity1Class();
-	public abstract Class<T2> getEntity2Class();
+public abstract class ManyToManyRelation<T1 extends Model, T2 extends Model> extends Model
+{
+
+    @Column(name = "entity1")
+    private T1 entity1;
+    @Column(name = "entity2")
+    private T2 entity2;
+
+    public static <T1 extends Model, T2 extends Model> void setRelationsFront(String database, Class<? extends ManyToManyRelation<T1, T2>> relation, T1 entity1, List<T2> entities2)
+    {
+        if (entity1.getId() == null)
+        {
+            throw new IllegalArgumentException(entity1.getClass().getSimpleName() + " is not saved to database yet, aborting");
+        }
+        for (T2 entity2 : entities2)
+        {
+            if (entity2.getId() == null)
+            {
+                throw new IllegalArgumentException(entity2.getClass().getSimpleName() + " is not saved to database yet, aborting");
+            }
+        }
+
+        new Delete().from(relation).where("entity1 = ?", entity1.getId()).execute(database);
+        try
+        {
+            ArrayList<ManyToManyRelation<T1, T2>> connections = new ArrayList<ManyToManyRelation<T1, T2>>();
+            for (T2 entity2 : entities2)
+            {
+                ManyToManyRelation<T1, T2> connection = relation.newInstance();
+                connection.entity1 = entity1;
+                connection.entity2 = entity2;
+                connections.add(connection);
+            }
+            saveMultiple(database, connections);
+        }
+        catch (Exception e)
+        {
+            Log.e("Cannot create instance of class " + relation.getSimpleName());
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static <T1 extends Model, T2 extends Model> void setRelationsReverse(String database, Class<? extends ManyToManyRelation<T1, T2>> relation, T2 entity2, List<T1> entities1)
+    {
+        if (entity2.getId() == null)
+        {
+            throw new IllegalArgumentException(entity2.getClass().getSimpleName() + " is not saved to database yet, aborting");
+        }
+        for (T1 entity1 : entities1)
+        {
+            if (entity1.getId() == null)
+            {
+                throw new IllegalArgumentException(entity1.getClass().getSimpleName() + " is not saved to database yet, aborting");
+            }
+        }
+
+        new Delete().from(relation).where("entity2 = ?", entity2.getId()).execute(database);
+        try
+        {
+            ArrayList<ManyToManyRelation<T1, T2>> connections = new ArrayList<ManyToManyRelation<T1, T2>>();
+            for (T1 entity1 : entities1)
+            {
+                ManyToManyRelation<T1, T2> connection = relation.newInstance();
+                connection.entity1 = entity1;
+                connection.entity2 = entity2;
+                connections.add(connection);
+            }
+            saveMultiple(database, connections);
+        }
+        catch (Exception e)
+        {
+            Log.e("Cannot create instance of class " + relation.getSimpleName());
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static <T1 extends Model, T2 extends Model> List<T2> getRelationsFront(String database, Class<? extends ManyToManyRelation<T1, T2>> relation, T1 entity)
+    {
+        if (entity.getId() == null)
+        {
+            throw new IllegalArgumentException(entity.getClass().getSimpleName() + " is not saved to database yet, aborting");
+        }
+
+        Class<? extends Model> entity1Class;
+        Class<? extends Model> entity2Class;
+        TableInfo              entity1TableInfo;
+        TableInfo              entity2TableInfo;
+        TableInfo              crossTableInfo;
+        try
+        {
+            ManyToManyRelation<T1, T2> instance = relation.newInstance();
+            entity1Class = instance.getEntity1Class();
+            entity2Class = instance.getEntity2Class();
+            entity1TableInfo = Cache.getTableInfo(entity1Class);
+            entity2TableInfo = Cache.getTableInfo(entity2Class);
+            crossTableInfo = Cache.getTableInfo(relation);
+        }
+        catch (Exception e)
+        {
+            throw new RuntimeException(e);
+        }
+
+        StringBuilder queryBuilder = new StringBuilder();
+        queryBuilder.append("SELECT ");
+        queryBuilder.append(entity2TableInfo.getTableName());
+        queryBuilder.append(".* FROM (");
+        queryBuilder.append(entity1TableInfo.getTableName());
+        queryBuilder.append(" JOIN ");
+        queryBuilder.append(crossTableInfo.getTableName());
+        queryBuilder.append(" ON ");
+        queryBuilder.append(entity1TableInfo.getTableName());
+        queryBuilder.append(".id == ");
+        queryBuilder.append(crossTableInfo.getTableName());
+        queryBuilder.append(".entity1) JOIN ");
+        queryBuilder.append(entity2TableInfo.getTableName());
+        queryBuilder.append(" ON ");
+        queryBuilder.append(entity2TableInfo.getTableName());
+        queryBuilder.append(".id == ");
+        queryBuilder.append(crossTableInfo.getTableName());
+        queryBuilder.append(".entity2 WHERE ");
+        queryBuilder.append(entity1TableInfo.getTableName());
+        queryBuilder.append(".id == ?");
+
+        return SQLiteUtils.rawQuery(database, entity2Class, queryBuilder.toString(), new String[]{entity.getId().toString()});
+    }
+
+    public static <T1 extends Model, T2 extends Model> List<T1> getRelationsReverse(String database, Class<? extends ManyToManyRelation<T1, T2>> relation, T2 entity)
+    {
+        if (entity.getId() == null)
+        {
+            throw new IllegalArgumentException(entity.getClass().getSimpleName() + " is not saved to database yet, aborting");
+        }
+
+        Class<? extends Model> entity1Class;
+        Class<? extends Model> entity2Class;
+        TableInfo              entity1TableInfo;
+        TableInfo              entity2TableInfo;
+        TableInfo              crossTableInfo;
+        try
+        {
+            ManyToManyRelation<T1, T2> instance = relation.newInstance();
+            entity1Class = instance.getEntity1Class();
+            entity2Class = instance.getEntity2Class();
+            entity1TableInfo = Cache.getTableInfo(entity1Class);
+            entity2TableInfo = Cache.getTableInfo(entity2Class);
+            crossTableInfo = Cache.getTableInfo(relation);
+        }
+        catch (Exception e)
+        {
+            throw new RuntimeException(e);
+        }
+
+        StringBuilder queryBuilder = new StringBuilder();
+        queryBuilder.append("SELECT ");
+        queryBuilder.append(entity1TableInfo.getTableName());
+        queryBuilder.append(".* FROM (");
+        queryBuilder.append(entity2TableInfo.getTableName());
+        queryBuilder.append(" JOIN ");
+        queryBuilder.append(crossTableInfo.getTableName());
+        queryBuilder.append(" ON ");
+        queryBuilder.append(entity2TableInfo.getTableName());
+        queryBuilder.append(".id == ");
+        queryBuilder.append(crossTableInfo.getTableName());
+        queryBuilder.append(".entity2) JOIN ");
+        queryBuilder.append(entity1TableInfo.getTableName());
+        queryBuilder.append(" ON ");
+        queryBuilder.append(entity1TableInfo.getTableName());
+        queryBuilder.append(".id == ");
+        queryBuilder.append(crossTableInfo.getTableName());
+        queryBuilder.append(".entity1 WHERE ");
+        queryBuilder.append(entity2TableInfo.getTableName());
+        queryBuilder.append(".id == ?");
+
+        return SQLiteUtils.rawQuery(database, entity1Class, queryBuilder.toString(), new String[]{entity.getId().toString()});
+    }
+
+    public ManyToManyRelation()
+    {
+        super();
+    }
+
+    public abstract Class<T1> getEntity1Class();
+
+    public abstract Class<T2> getEntity2Class();
 
 
 }
diff --git a/src/com/activeandroid/sebbia/model/OneToManyRelation.java b/src/com/activeandroid/sebbia/model/OneToManyRelation.java
index 79bd2367..c5c23dda 100644
--- a/src/com/activeandroid/sebbia/model/OneToManyRelation.java
+++ b/src/com/activeandroid/sebbia/model/OneToManyRelation.java
@@ -1,8 +1,5 @@
 package com.activeandroid.sebbia.model;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import android.database.Cursor;
 
 import com.activeandroid.sebbia.Cache;
@@ -13,70 +10,94 @@
 import com.activeandroid.sebbia.query.Delete;
 import com.activeandroid.sebbia.util.Log;
 
+import java.util.ArrayList;
+import java.util.List;
+
 @DoNotGenerate
-public abstract class OneToManyRelation<T1 extends Model, T2 extends Model> extends Model {
+public abstract class OneToManyRelation<T1 extends Model, T2 extends Model> extends Model
+{
 
-	@Column (name = "entity1")
-	private T1 entity1;
-	@Column (name = "entity2Type")
-	private String entity2Type;
-	@Column (name = "entity2")
-	private Model entity2;
+    @Column(name = "entity1")
+    private T1     entity1;
+    @Column(name = "entity2Type")
+    private String entity2Type;
+    @Column(name = "entity2")
+    private Model  entity2;
 
-	public static <T1 extends Model, T2 extends Model> void setRelations(Class<? extends OneToManyRelation<T1, T2>> relation, T1 entity1, List<T2> entities2) {
-		if (entity1.getId() == null)
-			throw new IllegalArgumentException(entity1.getClass().getSimpleName() + " is not saved to database yet, aborting");
-		for (T2 entity2 : entities2) {
-			if (entity2.getId() == null)
-				throw new IllegalArgumentException(entity2.getClass().getSimpleName() + " is not saved to database yet, aborting");
-		}
+    public static <T1 extends Model, T2 extends Model> void setRelations(String database, Class<? extends OneToManyRelation<T1, T2>> relation, T1 entity1, List<T2> entities2)
+    {
+        if (entity1.getId() == null)
+        {
+            throw new IllegalArgumentException(entity1.getClass().getSimpleName() + " is not saved to database yet, aborting");
+        }
+        for (T2 entity2 : entities2)
+        {
+            if (entity2.getId() == null)
+            {
+                throw new IllegalArgumentException(entity2.getClass().getSimpleName() + " is not saved to database yet, aborting");
+            }
+        }
 
-		new Delete().from(relation).where("entity1 = ?", entity1.getId()).execute();
-		try {
-			List<OneToManyRelation<T1, T2>> connections = new ArrayList<OneToManyRelation<T1, T2>>();
-			for (T2 entity2 : entities2) {
-				OneToManyRelation<T1, T2> connection = relation.newInstance();
-				connection.entity1 = entity1;
-				connection.entity2Type = entity2.getClass().getCanonicalName();
-				connection.entity2 = entity2;
-				connections.add(connection);
-			}
-			saveMultiple(connections);
-		} catch (Exception e) {
-			Log.e("Cannot create instance of class " + relation.getSimpleName());
-			throw new RuntimeException(e);
-		}
-	}
+        new Delete().from(relation).where("entity1 = ?", entity1.getId()).execute(database);
+        try
+        {
+            List<OneToManyRelation<T1, T2>> connections = new ArrayList<OneToManyRelation<T1, T2>>();
+            for (T2 entity2 : entities2)
+            {
+                OneToManyRelation<T1, T2> connection = relation.newInstance();
+                connection.entity1 = entity1;
+                connection.entity2Type = entity2.getClass().getCanonicalName();
+                connection.entity2 = entity2;
+                connections.add(connection);
+            }
+            saveMultiple(database, connections);
+        }
+        catch (Exception e)
+        {
+            Log.e("Cannot create instance of class " + relation.getSimpleName());
+            throw new RuntimeException(e);
+        }
+    }
 
-	@SuppressWarnings("unchecked")
-	public static <T1 extends Model, T2 extends Model> List<T2> getRelations(Class<? extends OneToManyRelation<T1, T2>> relation, T1 entity) {
-		if (entity.getId() == null)
-			throw new IllegalArgumentException(entity.getClass().getSimpleName() + " is not saved to database yet, aborting");
+    @SuppressWarnings("unchecked")
+    public static <T1 extends Model, T2 extends Model> List<T2> getRelations(String database, Class<? extends OneToManyRelation<T1, T2>> relation, T1 entity)
+    {
+        if (entity.getId() == null)
+        {
+            throw new IllegalArgumentException(entity.getClass().getSimpleName() + " is not saved to database yet, aborting");
+        }
 
-		TableInfo crossTableInfo = Cache.getTableInfo(relation);
-		Cursor cursor = Cache.openDatabase().rawQuery("SELECT entity2Type, entity2 FROM " + crossTableInfo.getTableName() + " WHERE entity1 = ?", new String[] {entity.getId().toString()});
-		final List<T2> entities = new ArrayList<T2>();
-		try {
-			if (cursor.moveToFirst()) {
-				do {
-					String typeName = cursor.getString(0);
-					Class<? extends Model> entity2Class = (Class<? extends Model>) Class.forName(typeName);
-					entities.add((T2) Model.load(entity2Class, cursor.getLong(1)));
-				}
-				while (cursor.moveToNext());
-			}
-		}
-		catch (Exception e) {
-			Log.e("Failed to process cursor.", e);
-			throw new RuntimeException(e);
-		} finally {
-			cursor.close();
-		}
+        TableInfo      crossTableInfo = Cache.getTableInfo(relation);
+        Cursor         cursor         = Cache.openDatabase(database).rawQuery("SELECT entity2Type, entity2 FROM " + crossTableInfo.getTableName() + " WHERE entity1 = ?", new String[]{entity.getId().toString()});
+        final List<T2> entities       = new ArrayList<T2>();
+        try
+        {
+            if (cursor.moveToFirst())
+            {
+                do
+                {
+                    String typeName = cursor.getString(0);
+                    Class<? extends Model> entity2Class = (Class<? extends Model>) Class.forName(typeName);
+                    entities.add((T2) Model.load(database, entity2Class, cursor.getLong(1)));
+                }
+                while (cursor.moveToNext());
+            }
+        }
+        catch (Exception e)
+        {
+            Log.e("Failed to process cursor.", e);
+            throw new RuntimeException(e);
+        }
+        finally
+        {
+            cursor.close();
+        }
 
-		return entities;
-	}
+        return entities;
+    }
 
-	public OneToManyRelation() {
-		super();
-	}
+    public OneToManyRelation()
+    {
+        super();
+    }
 }
diff --git a/src/com/activeandroid/sebbia/query/Delete.java b/src/com/activeandroid/sebbia/query/Delete.java
index 61fe2336..d6e40a73 100644
--- a/src/com/activeandroid/sebbia/query/Delete.java
+++ b/src/com/activeandroid/sebbia/query/Delete.java
@@ -18,16 +18,20 @@
 
 import com.activeandroid.sebbia.Model;
 
-public final class Delete implements Sqlable {
-	public Delete() {
-	}
+public final class Delete implements Sqlable
+{
+    public Delete()
+    {
+    }
 
-	public From from(Class<? extends Model> table) {
-		return new From(table, this);
-	}
+    public From from(Class<? extends Model> table)
+    {
+        return new From(table, this);
+    }
 
-	@Override
-	public String toSql() {
-		return "DELETE ";
-	}
+    @Override
+    public String toSql()
+    {
+        return "DELETE ";
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/query/From.java b/src/com/activeandroid/sebbia/query/From.java
index 80289f65..0ea0c468 100644
--- a/src/com/activeandroid/sebbia/query/From.java
+++ b/src/com/activeandroid/sebbia/query/From.java
@@ -28,214 +28,258 @@
 import java.util.ArrayList;
 import java.util.List;
 
-public final class From implements Sqlable {
-	private Sqlable mQueryBase;
-
-	private Class<? extends Model> mType;
-	private String mAlias;
-	private List<Join> mJoins;
-	private final StringBuilder mWhere = new StringBuilder();
-	private String mGroupBy;
-	private String mHaving;
-	private String mOrderBy;
-	private String mLimit;
-	private String mOffset;
-
-	private List<Object> mArguments;
-
-	public From(Class<? extends Model> table, Sqlable queryBase) {
-		mType = table;
-		mJoins = new ArrayList<Join>();
-		mQueryBase = queryBase;
-
-		mJoins = new ArrayList<Join>();
-		mArguments = new ArrayList<Object>();
-	}
-
-	public From as(String alias) {
-		mAlias = alias;
-		return this;
-	}
-
-	public Join join(Class<? extends Model> table) {
-		Join join = new Join(this, table, null);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join leftJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.LEFT);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join outerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.OUTER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join innerJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.INNER);
-		mJoins.add(join);
-		return join;
-	}
-
-	public Join crossJoin(Class<? extends Model> table) {
-		Join join = new Join(this, table, JoinType.CROSS);
-		mJoins.add(join);
-		return join;
-	}
-
-    public From where(String clause) {
+public final class From implements Sqlable
+{
+    private Sqlable mQueryBase;
+
+    private Class<? extends Model> mType;
+    private String                 mAlias;
+    private List<Join>             mJoins;
+    private final StringBuilder mWhere = new StringBuilder();
+    private String mGroupBy;
+    private String mHaving;
+    private String mOrderBy;
+    private String mLimit;
+    private String mOffset;
+
+    private List<Object> mArguments;
+
+    public From(Class<? extends Model> table, Sqlable queryBase)
+    {
+        mType = table;
+        mJoins = new ArrayList<Join>();
+        mQueryBase = queryBase;
+
+        mJoins = new ArrayList<Join>();
+        mArguments = new ArrayList<Object>();
+    }
+
+    public From as(String alias)
+    {
+        mAlias = alias;
+        return this;
+    }
+
+    public Join join(Class<? extends Model> table)
+    {
+        Join join = new Join(this, table, null);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join leftJoin(Class<? extends Model> table)
+    {
+        Join join = new Join(this, table, JoinType.LEFT);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join outerJoin(Class<? extends Model> table)
+    {
+        Join join = new Join(this, table, JoinType.OUTER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join innerJoin(Class<? extends Model> table)
+    {
+        Join join = new Join(this, table, JoinType.INNER);
+        mJoins.add(join);
+        return join;
+    }
+
+    public Join crossJoin(Class<? extends Model> table)
+    {
+        Join join = new Join(this, table, JoinType.CROSS);
+        mJoins.add(join);
+        return join;
+    }
+
+    public From where(String clause)
+    {
         // Chain conditions if a previous condition exists.
-        if (mWhere.length() > 0) {
+        if (mWhere.length() > 0)
+        {
             mWhere.append(" AND ");
         }
         mWhere.append(clause);
         return this;
     }
 
-    public From where(String clause, Object... args) {
+    public From where(String clause, Object... args)
+    {
         where(clause).addArguments(args);
         return this;
     }
 
-    public From and(String clause) {
+    public From and(String clause)
+    {
         return where(clause);
     }
 
-    public From and(String clause, Object... args) {
+    public From and(String clause, Object... args)
+    {
         return where(clause, args);
     }
 
-    public From or(String clause) {
-        if (mWhere.length() > 0) {
+    public From or(String clause)
+    {
+        if (mWhere.length() > 0)
+        {
             mWhere.append(" OR ");
         }
         mWhere.append(clause);
         return this;
     }
 
-    public From or(String clause, Object... args) {
+    public From or(String clause, Object... args)
+    {
         or(clause).addArguments(args);
         return this;
     }
-    
-	public From groupBy(String groupBy) {
-		mGroupBy = groupBy;
-		return this;
-	}
-
-	public From having(String having) {
-		mHaving = having;
-		return this;
-	}
-
-	public From orderBy(String orderBy) {
-		mOrderBy = orderBy;
-		return this;
-	}
-
-	public From limit(int limit) {
-		return limit(String.valueOf(limit));
-	}
-
-	public From limit(String limit) {
-		mLimit = limit;
-		return this;
-	}
-
-	public From offset(int offset) {
-		return offset(String.valueOf(offset));
-	}
-
-	public From offset(String offset) {
-		mOffset = offset;
-		return this;
-	}
-
-	void addArguments(Object[] args) {
-        for(Object arg : args) {
-            if (arg.getClass() == boolean.class || arg.getClass() == Boolean.class) {
+
+    public From groupBy(String groupBy)
+    {
+        mGroupBy = groupBy;
+        return this;
+    }
+
+    public From having(String having)
+    {
+        mHaving = having;
+        return this;
+    }
+
+    public From orderBy(String orderBy)
+    {
+        mOrderBy = orderBy;
+        return this;
+    }
+
+    public From limit(int limit)
+    {
+        return limit(String.valueOf(limit));
+    }
+
+    public From limit(String limit)
+    {
+        mLimit = limit;
+        return this;
+    }
+
+    public From offset(int offset)
+    {
+        return offset(String.valueOf(offset));
+    }
+
+    public From offset(String offset)
+    {
+        mOffset = offset;
+        return this;
+    }
+
+    void addArguments(Object[] args)
+    {
+        for (Object arg : args)
+        {
+            if (arg.getClass() == boolean.class || arg.getClass() == Boolean.class)
+            {
                 arg = (arg.equals(true) ? 1 : 0);
             }
             mArguments.add(arg);
         }
-	}
+    }
 
-    private void addFrom(final StringBuilder sql) {
+    private void addFrom(final StringBuilder sql)
+    {
         sql.append("FROM ");
         sql.append(Cache.getTableName(mType)).append(" ");
 
-        if (mAlias != null) {
+        if (mAlias != null)
+        {
             sql.append("AS ");
             sql.append(mAlias);
             sql.append(" ");
         }
     }
 
-    private void addJoins(final StringBuilder sql) {
-        for (final Join join : mJoins) {
+    private void addJoins(final StringBuilder sql)
+    {
+        for (final Join join : mJoins)
+        {
             sql.append(join.toSql());
         }
     }
 
-    private void addWhere(final StringBuilder sql) {
-        if (mWhere.length() > 0) {
+    private void addWhere(final StringBuilder sql)
+    {
+        if (mWhere.length() > 0)
+        {
             sql.append("WHERE ");
             sql.append(mWhere);
             sql.append(" ");
         }
     }
 
-    private void addGroupBy(final StringBuilder sql) {
-        if (mGroupBy != null) {
+    private void addGroupBy(final StringBuilder sql)
+    {
+        if (mGroupBy != null)
+        {
             sql.append("GROUP BY ");
             sql.append(mGroupBy);
             sql.append(" ");
         }
     }
 
-    private void addHaving(final StringBuilder sql) {
-        if (mHaving != null) {
+    private void addHaving(final StringBuilder sql)
+    {
+        if (mHaving != null)
+        {
             sql.append("HAVING ");
             sql.append(mHaving);
             sql.append(" ");
         }
     }
 
-    private void addOrderBy(final StringBuilder sql) {
-        if (mOrderBy != null) {
+    private void addOrderBy(final StringBuilder sql)
+    {
+        if (mOrderBy != null)
+        {
             sql.append("ORDER BY ");
             sql.append(mOrderBy);
             sql.append(" ");
         }
     }
 
-    private void addLimit(final StringBuilder sql) {
-        if (mLimit != null) {
+    private void addLimit(final StringBuilder sql)
+    {
+        if (mLimit != null)
+        {
             sql.append("LIMIT ");
             sql.append(mLimit);
             sql.append(" ");
         }
     }
 
-    private void addOffset(final StringBuilder sql) {
-        if (mOffset != null) {
+    private void addOffset(final StringBuilder sql)
+    {
+        if (mOffset != null)
+        {
             sql.append("OFFSET ");
             sql.append(mOffset);
             sql.append(" ");
         }
     }
 
-    private String sqlString(final StringBuilder sql) {
+    private String sqlString(final StringBuilder sql)
+    {
 
         final String sqlString = sql.toString().trim();
 
         // Don't waste time building the string
         // unless we're going to log it.
-        if (Log.isEnabled()) {
+        if (Log.isEnabled())
+        {
             Log.v(sqlString + " " + TextUtils.join(",", getArguments()));
         }
 
@@ -243,7 +287,8 @@ private String sqlString(final StringBuilder sql) {
     }
 
     @Override
-    public String toSql() {
+    public String toSql()
+    {
         final StringBuilder sql = new StringBuilder();
         sql.append(mQueryBase.toSql());
 
@@ -259,7 +304,8 @@ public String toSql() {
         return sqlString(sql);
     }
 
-    public String toExistsSql() {
+    public String toExistsSql()
+    {
 
         final StringBuilder sql = new StringBuilder();
         sql.append("SELECT EXISTS(SELECT 1 ");
@@ -277,7 +323,8 @@ public String toExistsSql() {
         return sqlString(sql);
     }
 
-    public String toCountSql() {
+    public String toCountSql()
+    {
 
         final StringBuilder sql = new StringBuilder();
         sql.append("SELECT COUNT(*) ");
@@ -293,54 +340,70 @@ public String toCountSql() {
         return sqlString(sql);
     }
 
-	public <T extends Model> List<T> execute() {
-		if (mQueryBase instanceof Select) {
-			return SQLiteUtils.rawQuery(mType, toSql(), getArguments());
-			
-		} else {
-			SQLiteUtils.execSql(toSql(), getArguments());
-			Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mType, null), null);
-			return null;
-			
-		}
-	}
-
-	public <T extends Model> T executeSingle() {
-		if (mQueryBase instanceof Select) {
-			limit(1);
-			return (T) SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments());
-			
-		} else {
-			limit(1);
-			SQLiteUtils.rawQuerySingle(mType, toSql(), getArguments()).delete();
-			return null;
-			
-		}
-	}
-	
+    public <T extends Model> List<T> execute(String database)
+    {
+        if (mQueryBase instanceof Select)
+        {
+            return SQLiteUtils.rawQuery(database, mType, toSql(), getArguments());
+
+        }
+        else
+        {
+            SQLiteUtils.execSql(database, toSql(), getArguments());
+            Cache.getContext().getContentResolver().notifyChange(ContentProvider.createUri(mType, null), null);
+            return null;
+
+        }
+    }
+
+    public <T extends Model> T executeSingle(String database)
+    {
+        if (mQueryBase instanceof Select)
+        {
+            limit(1);
+            return (T) SQLiteUtils.rawQuerySingle(database, mType, toSql(), getArguments());
+
+        }
+        else
+        {
+            limit(1);
+            SQLiteUtils.rawQuerySingle(database, mType, toSql(), getArguments()).delete(database);
+            return null;
+
+        }
+    }
+
     /**
      * Gets a value indicating whether the query returns any rows.
+     *
+     * @param database
      * @return <code>true</code> if the query returns at least one row; otherwise, <code>false</code>.
      */
-    public boolean exists() {
-        return SQLiteUtils.intQuery(toExistsSql(), getArguments()) != 0;
+    public boolean exists(String database)
+    {
+        return SQLiteUtils.intQuery(database, toExistsSql(), getArguments()) != 0;
     }
 
     /**
      * Gets the number of rows returned by the query.
+     *
+     * @param database
      */
-    public int count() {
-        return SQLiteUtils.intQuery(toCountSql(), getArguments());
+    public int count(String database)
+    {
+        return SQLiteUtils.intQuery(database, toCountSql(), getArguments());
     }
 
-	public String[] getArguments() {
-		final int size = mArguments.size();
-		final String[] args = new String[size];
+    public String[] getArguments()
+    {
+        final int      size = mArguments.size();
+        final String[] args = new String[size];
 
-		for (int i = 0; i < size; i++) {
-			args[i] = mArguments.get(i).toString();
-		}
+        for (int i = 0; i < size; i++)
+        {
+            args[i] = mArguments.get(i).toString();
+        }
 
-		return args;
-	}
+        return args;
+    }
 }
diff --git a/src/com/activeandroid/sebbia/query/Join.java b/src/com/activeandroid/sebbia/query/Join.java
index c818616a..a8247c60 100644
--- a/src/com/activeandroid/sebbia/query/Join.java
+++ b/src/com/activeandroid/sebbia/query/Join.java
@@ -21,74 +21,86 @@
 import com.activeandroid.sebbia.Cache;
 import com.activeandroid.sebbia.Model;
 
-public final class Join implements Sqlable {
-	static enum JoinType {
-		LEFT, OUTER, INNER, CROSS
-	}
-
-	private From mFrom;
-	private Class<? extends Model> mType;
-	private String mAlias;
-	private JoinType mJoinType;
-	private String mOn;
-	private String[] mUsing;
-
-	Join(From from, Class<? extends Model> table, JoinType joinType) {
-		mFrom = from;
-		mType = table;
-		mJoinType = joinType;
-	}
-
-	public Join as(String alias) {
-		mAlias = alias;
-		return this;
-	}
-
-	public From on(String on) {
-		mOn = on;
-		return mFrom;
-	}
-
-	public From on(String on, Object... args) {
-		mOn = on;
-		mFrom.addArguments(args);
-		return mFrom;
-	}
-
-	public From using(String... columns) {
-		mUsing = columns;
-		return mFrom;
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-
-		if (mJoinType != null) {
-			sql.append(mJoinType.toString()).append(" ");
-		}
-
-		sql.append("JOIN ");
-		sql.append(Cache.getTableName(mType));
-		sql.append(" ");
-
-		if (mAlias != null) {
-			sql.append("AS ");
-			sql.append(mAlias);
-			sql.append(" ");
-		}
-
-		if (mOn != null) {
-			sql.append("ON ");
-			sql.append(mOn);
-			sql.append(" ");
-		}
-		else if (mUsing != null) {
-			sql.append("USING (");
-			sql.append(TextUtils.join(", ", mUsing));
-			sql.append(") ");
-		}
-
-		return sql.toString();
-	}
+public final class Join implements Sqlable
+{
+    static enum JoinType
+    {
+        LEFT, OUTER, INNER, CROSS
+    }
+
+    private From                   mFrom;
+    private Class<? extends Model> mType;
+    private String                 mAlias;
+    private JoinType               mJoinType;
+    private String                 mOn;
+    private String[]               mUsing;
+
+    Join(From from, Class<? extends Model> table, JoinType joinType)
+    {
+        mFrom = from;
+        mType = table;
+        mJoinType = joinType;
+    }
+
+    public Join as(String alias)
+    {
+        mAlias = alias;
+        return this;
+    }
+
+    public From on(String on)
+    {
+        mOn = on;
+        return mFrom;
+    }
+
+    public From on(String on, Object... args)
+    {
+        mOn = on;
+        mFrom.addArguments(args);
+        return mFrom;
+    }
+
+    public From using(String... columns)
+    {
+        mUsing = columns;
+        return mFrom;
+    }
+
+    @Override
+    public String toSql()
+    {
+        StringBuilder sql = new StringBuilder();
+
+        if (mJoinType != null)
+        {
+            sql.append(mJoinType.toString()).append(" ");
+        }
+
+        sql.append("JOIN ");
+        sql.append(Cache.getTableName(mType));
+        sql.append(" ");
+
+        if (mAlias != null)
+        {
+            sql.append("AS ");
+            sql.append(mAlias);
+            sql.append(" ");
+        }
+
+        if (mOn != null)
+        {
+            sql.append("ON ");
+            sql.append(mOn);
+            sql.append(" ");
+        }
+        else if (mUsing != null)
+        {
+            sql.append("USING (");
+            sql.append(TextUtils.join(", ", mUsing));
+            sql.append(") ");
+        }
+
+        return sql.toString();
+    }
 }
diff --git a/src/com/activeandroid/sebbia/query/Select.java b/src/com/activeandroid/sebbia/query/Select.java
index 43e216e1..e47d0b6b 100644
--- a/src/com/activeandroid/sebbia/query/Select.java
+++ b/src/com/activeandroid/sebbia/query/Select.java
@@ -20,74 +20,89 @@
 
 import com.activeandroid.sebbia.Model;
 
-public final class Select implements Sqlable {
-	private String[] mColumns;
-	private boolean mDistinct = false;
-	private boolean mAll = false;
-
-	public Select() {
-	}
-
-	public Select(String... columns) {
-		mColumns = columns;
-	}
-
-	public Select(Column... columns) {
-		final int size = columns.length;
-		mColumns = new String[size];
-		for (int i = 0; i < size; i++) {
-			mColumns[i] = columns[i].name + " AS " + columns[i].alias;
-		}
-	}
-
-	public Select distinct() {
-		mDistinct = true;
-		mAll = false;
-
-		return this;
-	}
-
-	public Select all() {
-		mDistinct = false;
-		mAll = true;
-
-		return this;
-	}
-
-	public From from(Class<? extends Model> table) {
-		return new From(table, this);
-	}
-
-	public static class Column {
-		String name;
-		String alias;
-
-		public Column(String name, String alias) {
-			this.name = name;
-			this.alias = alias;
-		}
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-
-		sql.append("SELECT ");
-
-		if (mDistinct) {
-			sql.append("DISTINCT ");
-		}
-		else if (mAll) {
-			sql.append("ALL ");
-		}
-
-		if (mColumns != null && mColumns.length > 0) {
-			sql.append(TextUtils.join(", ", mColumns) + " ");
-		}
-		else {
-			sql.append("* ");
-		}
-
-		return sql.toString();
-	}
+public final class Select implements Sqlable
+{
+    private String[] mColumns;
+    private boolean mDistinct = false;
+    private boolean mAll      = false;
+
+    public Select()
+    {
+    }
+
+    public Select(String... columns)
+    {
+        mColumns = columns;
+    }
+
+    public Select(Column... columns)
+    {
+        final int size = columns.length;
+        mColumns = new String[size];
+        for (int i = 0; i < size; i++)
+        {
+            mColumns[i] = columns[i].name + " AS " + columns[i].alias;
+        }
+    }
+
+    public Select distinct()
+    {
+        mDistinct = true;
+        mAll = false;
+
+        return this;
+    }
+
+    public Select all()
+    {
+        mDistinct = false;
+        mAll = true;
+
+        return this;
+    }
+
+    public From from(Class<? extends Model> table)
+    {
+        return new From(table, this);
+    }
+
+    public static class Column
+    {
+        String name;
+        String alias;
+
+        public Column(String name, String alias)
+        {
+            this.name = name;
+            this.alias = alias;
+        }
+    }
+
+    @Override
+    public String toSql()
+    {
+        StringBuilder sql = new StringBuilder();
+
+        sql.append("SELECT ");
+
+        if (mDistinct)
+        {
+            sql.append("DISTINCT ");
+        }
+        else if (mAll)
+        {
+            sql.append("ALL ");
+        }
+
+        if (mColumns != null && mColumns.length > 0)
+        {
+            sql.append(TextUtils.join(", ", mColumns) + " ");
+        }
+        else
+        {
+            sql.append("* ");
+        }
+
+        return sql.toString();
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/query/Set.java b/src/com/activeandroid/sebbia/query/Set.java
index 6c865f56..012bb492 100644
--- a/src/com/activeandroid/sebbia/query/Set.java
+++ b/src/com/activeandroid/sebbia/query/Set.java
@@ -22,82 +22,93 @@
 import java.util.Arrays;
 import java.util.List;
 
-public final class Set implements Sqlable {
-	private Update mUpdate;
-
-	private String mSet;
-	private String mWhere;
-
-	private List<Object> mSetArguments;
-	private List<Object> mWhereArguments;
-
-	public Set(Update queryBase, String set) {
-		mUpdate = queryBase;
-		mSet = set;
-
-		mSetArguments = new ArrayList<Object>();
-		mWhereArguments = new ArrayList<Object>();
-	}
-
-	public Set(Update queryBase, String set, Object... args) {
-		mUpdate = queryBase;
-		mSet = set;
-
-		mSetArguments = new ArrayList<Object>();
-		mWhereArguments = new ArrayList<Object>();
-
-		mSetArguments.addAll(Arrays.asList(args));
-	}
-
-	public Set where(String where) {
-		mWhere = where;
-		mWhereArguments.clear();
-
-		return this;
-	}
-
-	public Set where(String where, Object... args) {
-		mWhere = where;
-		mWhereArguments.clear();
-		mWhereArguments.addAll(Arrays.asList(args));
-
-		return this;
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-		sql.append(mUpdate.toSql());
-		sql.append("SET ");
-		sql.append(mSet);
-		sql.append(" ");
-
-		if (mWhere != null) {
-			sql.append("WHERE ");
-			sql.append(mWhere);
-			sql.append(" ");
-		}
-
-		return sql.toString();
-	}
-
-	public void execute() {
-		SQLiteUtils.execSql(toSql(), getArguments());
-	}
-
-	public String[] getArguments() {
-		final int setSize = mSetArguments.size();
-		final int whereSize = mWhereArguments.size();
-		final String[] args = new String[setSize + whereSize];
-
-		for (int i = 0; i < setSize; i++) {
-			args[i] = mSetArguments.get(i).toString();
-		}
-
-		for (int i = 0; i < whereSize; i++) {
-			args[i + setSize] = mWhereArguments.get(i).toString();
-		}
-
-		return args;
-	}
+public final class Set implements Sqlable
+{
+    private Update mUpdate;
+
+    private String mSet;
+    private String mWhere;
+
+    private List<Object> mSetArguments;
+    private List<Object> mWhereArguments;
+
+    public Set(Update queryBase, String set)
+    {
+        mUpdate = queryBase;
+        mSet = set;
+
+        mSetArguments = new ArrayList<Object>();
+        mWhereArguments = new ArrayList<Object>();
+    }
+
+    public Set(Update queryBase, String set, Object... args)
+    {
+        mUpdate = queryBase;
+        mSet = set;
+
+        mSetArguments = new ArrayList<Object>();
+        mWhereArguments = new ArrayList<Object>();
+
+        mSetArguments.addAll(Arrays.asList(args));
+    }
+
+    public Set where(String where)
+    {
+        mWhere = where;
+        mWhereArguments.clear();
+
+        return this;
+    }
+
+    public Set where(String where, Object... args)
+    {
+        mWhere = where;
+        mWhereArguments.clear();
+        mWhereArguments.addAll(Arrays.asList(args));
+
+        return this;
+    }
+
+    @Override
+    public String toSql()
+    {
+        StringBuilder sql = new StringBuilder();
+        sql.append(mUpdate.toSql());
+        sql.append("SET ");
+        sql.append(mSet);
+        sql.append(" ");
+
+        if (mWhere != null)
+        {
+            sql.append("WHERE ");
+            sql.append(mWhere);
+            sql.append(" ");
+        }
+
+        return sql.toString();
+    }
+
+    public void execute(String database)
+    {
+        SQLiteUtils.execSql(database, toSql(), getArguments());
+    }
+
+    public String[] getArguments()
+    {
+        final int      setSize   = mSetArguments.size();
+        final int      whereSize = mWhereArguments.size();
+        final String[] args      = new String[setSize + whereSize];
+
+        for (int i = 0; i < setSize; i++)
+        {
+            args[i] = mSetArguments.get(i).toString();
+        }
+
+        for (int i = 0; i < whereSize; i++)
+        {
+            args[i + setSize] = mWhereArguments.get(i).toString();
+        }
+
+        return args;
+    }
 }
diff --git a/src/com/activeandroid/sebbia/query/Sqlable.java b/src/com/activeandroid/sebbia/query/Sqlable.java
index 64c4cff5..684e6e85 100644
--- a/src/com/activeandroid/sebbia/query/Sqlable.java
+++ b/src/com/activeandroid/sebbia/query/Sqlable.java
@@ -16,6 +16,7 @@
  * limitations under the License.
  */
 
-public interface Sqlable {
-	public String toSql();
+public interface Sqlable
+{
+    public String toSql();
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/query/Update.java b/src/com/activeandroid/sebbia/query/Update.java
index 8eb2932a..d350db7d 100644
--- a/src/com/activeandroid/sebbia/query/Update.java
+++ b/src/com/activeandroid/sebbia/query/Update.java
@@ -19,32 +19,38 @@
 import com.activeandroid.sebbia.Cache;
 import com.activeandroid.sebbia.Model;
 
-public final class Update implements Sqlable {
-	private Class<? extends Model> mType;
-
-	public Update(Class<? extends Model> table) {
-		mType = table;
-	}
-
-	public Set set(String set) {
-		return new Set(this, set);
-	}
-
-	public Set set(String set, Object... args) {
-		return new Set(this, set, args);
-	}
-
-	Class<? extends Model> getType() {
-		return mType;
-	}
-
-	@Override
-	public String toSql() {
-		StringBuilder sql = new StringBuilder();
-		sql.append("UPDATE ");
-		sql.append(Cache.getTableName(mType));
-		sql.append(" ");
-
-		return sql.toString();
-	}
+public final class Update implements Sqlable
+{
+    private Class<? extends Model> mType;
+
+    public Update(Class<? extends Model> table)
+    {
+        mType = table;
+    }
+
+    public Set set(String set)
+    {
+        return new Set(this, set);
+    }
+
+    public Set set(String set, Object... args)
+    {
+        return new Set(this, set, args);
+    }
+
+    Class<? extends Model> getType()
+    {
+        return mType;
+    }
+
+    @Override
+    public String toSql()
+    {
+        StringBuilder sql = new StringBuilder();
+        sql.append("UPDATE ");
+        sql.append(Cache.getTableName(mType));
+        sql.append(" ");
+
+        return sql.toString();
+    }
 }
diff --git a/src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java b/src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
index 1b398742..f8511fbb 100644
--- a/src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/BigDecimalSerializer.java
@@ -2,28 +2,35 @@
 
 import java.math.BigDecimal;
 
-public final class BigDecimalSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return BigDecimal.class;
-	}
+public final class BigDecimalSerializer extends TypeSerializer
+{
+    public Class<?> getDeserializedType()
+    {
+        return BigDecimal.class;
+    }
 
-	public Class<?> getSerializedType() {
-		return String.class;
-	}
+    public Class<?> getSerializedType()
+    {
+        return String.class;
+    }
 
-	public String serialize(Object data) {
-		if (data == null) {
-			return null;
-		}
+    public String serialize(Object data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
 
-		return ((BigDecimal) data).toString();
-	}
+        return ((BigDecimal) data).toString();
+    }
 
-	public BigDecimal deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
+    public BigDecimal deserialize(Object data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
 
-		return new BigDecimal((String) data);
-	}
+        return new BigDecimal((String) data);
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/serializer/CalendarSerializer.java b/src/com/activeandroid/sebbia/serializer/CalendarSerializer.java
index 6cd2068e..c8a4c85a 100644
--- a/src/com/activeandroid/sebbia/serializer/CalendarSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/CalendarSerializer.java
@@ -18,23 +18,28 @@
 
 import java.util.Calendar;
 
-public final class CalendarSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return Calendar.class;
-	}
+public final class CalendarSerializer extends TypeSerializer
+{
+    public Class<?> getDeserializedType()
+    {
+        return Calendar.class;
+    }
 
-	public Class<?> getSerializedType() {
-		return long.class;
-	}
+    public Class<?> getSerializedType()
+    {
+        return long.class;
+    }
 
-	public Long serialize(Object data) {
-		return ((Calendar) data).getTimeInMillis();
-	}
+    public Long serialize(Object data)
+    {
+        return ((Calendar) data).getTimeInMillis();
+    }
 
-	public Calendar deserialize(Object data) {
-		Calendar calendar = Calendar.getInstance();
-		calendar.setTimeInMillis((Long) data);
+    public Calendar deserialize(Object data)
+    {
+        Calendar calendar = Calendar.getInstance();
+        calendar.setTimeInMillis((Long) data);
 
-		return calendar;
-	}
+        return calendar;
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/serializer/FileSerializer.java b/src/com/activeandroid/sebbia/serializer/FileSerializer.java
index 0d15a76d..c11d1605 100644
--- a/src/com/activeandroid/sebbia/serializer/FileSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/FileSerializer.java
@@ -19,28 +19,35 @@
  */
 
 
-public final class FileSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return File.class;
-	}
-
-	public Class<?> getSerializedType() {
-		return String.class;
-	}
-
-	public String serialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return ((File) data).toString();
-	}
-
-	public File deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return new File((String) data);
-	}
+public final class FileSerializer extends TypeSerializer
+{
+    public Class<?> getDeserializedType()
+    {
+        return File.class;
+    }
+
+    public Class<?> getSerializedType()
+    {
+        return String.class;
+    }
+
+    public String serialize(Object data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
+
+        return ((File) data).toString();
+    }
+
+    public File deserialize(Object data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
+
+        return new File((String) data);
+    }
 }
diff --git a/src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java b/src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
index ad6a995b..c1d95ff1 100644
--- a/src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/SqlDateSerializer.java
@@ -18,28 +18,35 @@
 
 import java.sql.Date;
 
-public final class SqlDateSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return Date.class;
-	}
-
-	public Class<?> getSerializedType() {
-		return long.class;
-	}
-
-	public Long serialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return ((Date) data).getTime();
-	}
-
-	public Date deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return new Date((Long) data);
-	}
+public final class SqlDateSerializer extends TypeSerializer
+{
+    public Class<?> getDeserializedType()
+    {
+        return Date.class;
+    }
+
+    public Class<?> getSerializedType()
+    {
+        return long.class;
+    }
+
+    public Long serialize(Object data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
+
+        return ((Date) data).getTime();
+    }
+
+    public Date deserialize(Object data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
+
+        return new Date((Long) data);
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/serializer/TypeSerializer.java b/src/com/activeandroid/sebbia/serializer/TypeSerializer.java
index eb326146..3e3d5c66 100644
--- a/src/com/activeandroid/sebbia/serializer/TypeSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/TypeSerializer.java
@@ -16,12 +16,13 @@
  * limitations under the License.
  */
 
-public abstract class TypeSerializer {
-	public abstract Class<?> getDeserializedType();
+public abstract class TypeSerializer
+{
+    public abstract Class<?> getDeserializedType();
 
-	public abstract Class<?> getSerializedType();
+    public abstract Class<?> getSerializedType();
 
-	public abstract Object serialize(Object data);
+    public abstract Object serialize(Object data);
 
-	public abstract Object deserialize(Object data);
+    public abstract Object deserialize(Object data);
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/serializer/UUIDSerializer.java b/src/com/activeandroid/sebbia/serializer/UUIDSerializer.java
index 2942c130..a4420dff 100644
--- a/src/com/activeandroid/sebbia/serializer/UUIDSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/UUIDSerializer.java
@@ -2,28 +2,35 @@
 
 import java.util.UUID;
 
-public final class UUIDSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return UUID.class;
-	}
+public final class UUIDSerializer extends TypeSerializer
+{
+    public Class<?> getDeserializedType()
+    {
+        return UUID.class;
+    }
 
-	public Class<?> getSerializedType() {
-		return String.class;
-	}
+    public Class<?> getSerializedType()
+    {
+        return String.class;
+    }
 
-	public String serialize(Object data) {
-		if (data == null) {
-			return null;
-		}
+    public String serialize(Object data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
 
-		return ((UUID) data).toString();
-	}
+        return ((UUID) data).toString();
+    }
 
-	public UUID deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
+    public UUID deserialize(Object data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
 
-		return UUID.fromString((String)data);
-	}
+        return UUID.fromString((String) data);
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java b/src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
index cf3a1423..c1699578 100644
--- a/src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
+++ b/src/com/activeandroid/sebbia/serializer/UtilDateSerializer.java
@@ -18,28 +18,35 @@
 
 import java.util.Date;
 
-public final class UtilDateSerializer extends TypeSerializer {
-	public Class<?> getDeserializedType() {
-		return Date.class;
-	}
-
-	public Class<?> getSerializedType() {
-		return long.class;
-	}
-
-	public Long serialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return ((Date) data).getTime();
-	}
-
-	public Date deserialize(Object data) {
-		if (data == null) {
-			return null;
-		}
-
-		return new Date((Long) data);
-	}
+public final class UtilDateSerializer extends TypeSerializer
+{
+    public Class<?> getDeserializedType()
+    {
+        return Date.class;
+    }
+
+    public Class<?> getSerializedType()
+    {
+        return long.class;
+    }
+
+    public Long serialize(Object data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
+
+        return ((Date) data).getTime();
+    }
+
+    public Date deserialize(Object data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
+
+        return new Date((Long) data);
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/util/IOUtils.java b/src/com/activeandroid/sebbia/util/IOUtils.java
index d4b059b8..25160a25 100644
--- a/src/com/activeandroid/sebbia/util/IOUtils.java
+++ b/src/com/activeandroid/sebbia/util/IOUtils.java
@@ -25,7 +25,8 @@
 import com.activeandroid.sebbia.util.Log;
 
 
-public class IOUtils {
+public class IOUtils
+{
 
     /**
      * <p>
@@ -33,17 +34,23 @@
      * </p>
      * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored. This is
      * typically used in finally blocks.
+     *
      * @param closeable A {@link Closeable} to close.
      */
-    public static void closeQuietly(final Closeable closeable) {
+    public static void closeQuietly(final Closeable closeable)
+    {
 
-        if (closeable == null) {
+        if (closeable == null)
+        {
             return;
         }
 
-        try {
+        try
+        {
             closeable.close();
-        } catch (final IOException e) {
+        }
+        catch (final IOException e)
+        {
             Log.e("Couldn't close closeable.", e);
         }
     }
@@ -54,17 +61,23 @@ public static void closeQuietly(final Closeable closeable) {
      * </p>
      * Equivalent to {@link Cursor#close()}, except any exceptions will be ignored. This is
      * typically used in finally blocks.
+     *
      * @param cursor A {@link Cursor} to close.
      */
-    public static void closeQuietly(final Cursor cursor) {
+    public static void closeQuietly(final Cursor cursor)
+    {
 
-        if (cursor == null) {
+        if (cursor == null)
+        {
             return;
         }
 
-        try {
+        try
+        {
             cursor.close();
-        } catch (final Exception e) {
+        }
+        catch (final Exception e)
+        {
             Log.e("Couldn't close cursor.", e);
         }
     }
diff --git a/src/com/activeandroid/sebbia/util/Log.java b/src/com/activeandroid/sebbia/util/Log.java
index c8f28af6..66527e4e 100644
--- a/src/com/activeandroid/sebbia/util/Log.java
+++ b/src/com/activeandroid/sebbia/util/Log.java
@@ -16,181 +16,228 @@
  * limitations under the License.
  */
 
-public final class Log {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
+public final class Log
+{
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private static String sTag = "ActiveAndroid";
-	private static boolean sEnabled = false;
+    private static String  sTag     = "ActiveAndroid";
+    private static boolean sEnabled = false;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// CONSTRUCTORS
-	//////////////////////////////////////////////////////////////////////////////////////
+    //////////////////////////////////////////////////////////////////////////////////////
+    // CONSTRUCTORS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-	private Log() {
-	}
+    private Log()
+    {
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static boolean isEnabled()
+    {
+        return sEnabled;
+    }
 
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
+    public static void setEnabled(boolean enabled)
+    {
+        sEnabled = enabled;
+    }
 
-    public static boolean isEnabled() {
+    public static boolean isLoggingEnabled()
+    {
         return sEnabled;
     }
 
-	public static void setEnabled(boolean enabled) {
-		sEnabled = enabled;
-	}
-
-	public static boolean isLoggingEnabled() {
-		return sEnabled;
-	}
-
-	public static int v(String msg) {
-		if (sEnabled) {
-			return android.util.Log.v(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int v(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.v(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int v(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.v(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int v(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.v(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int d(String msg) {
-		if (sEnabled) {
-			return android.util.Log.d(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int d(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.d(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int d(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.d(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int d(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.d(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int i(String msg) {
-		if (sEnabled) {
-			return android.util.Log.i(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int i(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.i(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int i(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.i(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int i(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.i(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int w(String msg) {
-		if (sEnabled) {
-			return android.util.Log.w(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int w(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.w(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int w(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.w(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int w(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.w(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int e(String msg) {
-		if (sEnabled) {
-			return android.util.Log.e(sTag, msg);
-		}
-		return 0;
-	}
-
-	public static int e(String tag, String msg) {
-		if (sEnabled) {
-			return android.util.Log.e(tag, msg);
-		}
-		return 0;
-	}
-
-	public static int e(String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.e(sTag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int e(String tag, String msg, Throwable tr) {
-		if (sEnabled) {
-			return android.util.Log.e(tag, msg, tr);
-		}
-		return 0;
-	}
-
-	public static int t(String msg, Object... args) {
-		if (sEnabled) {
-			return android.util.Log.v("test", String.format(msg, args));
-		}
-		return 0;
-	}
+    public static int v(String msg)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.v(sTag, msg);
+        }
+        return 0;
+    }
+
+    public static int v(String tag, String msg)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.v(tag, msg);
+        }
+        return 0;
+    }
+
+    public static int v(String msg, Throwable tr)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.v(sTag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int v(String tag, String msg, Throwable tr)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.v(tag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int d(String msg)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.d(sTag, msg);
+        }
+        return 0;
+    }
+
+    public static int d(String tag, String msg)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.d(tag, msg);
+        }
+        return 0;
+    }
+
+    public static int d(String msg, Throwable tr)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.d(sTag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int d(String tag, String msg, Throwable tr)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.d(tag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int i(String msg)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.i(sTag, msg);
+        }
+        return 0;
+    }
+
+    public static int i(String tag, String msg)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.i(tag, msg);
+        }
+        return 0;
+    }
+
+    public static int i(String msg, Throwable tr)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.i(sTag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int i(String tag, String msg, Throwable tr)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.i(tag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int w(String msg)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.w(sTag, msg);
+        }
+        return 0;
+    }
+
+    public static int w(String tag, String msg)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.w(tag, msg);
+        }
+        return 0;
+    }
+
+    public static int w(String msg, Throwable tr)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.w(sTag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int w(String tag, String msg, Throwable tr)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.w(tag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int e(String msg)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.e(sTag, msg);
+        }
+        return 0;
+    }
+
+    public static int e(String tag, String msg)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.e(tag, msg);
+        }
+        return 0;
+    }
+
+    public static int e(String msg, Throwable tr)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.e(sTag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int e(String tag, String msg, Throwable tr)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.e(tag, msg, tr);
+        }
+        return 0;
+    }
+
+    public static int t(String msg, Object... args)
+    {
+        if (sEnabled)
+        {
+            return android.util.Log.v("test", String.format(msg, args));
+        }
+        return 0;
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/util/NaturalOrderComparator.java b/src/com/activeandroid/sebbia/util/NaturalOrderComparator.java
index 2fa9acf6..9f528d20 100644
--- a/src/com/activeandroid/sebbia/util/NaturalOrderComparator.java
+++ b/src/com/activeandroid/sebbia/util/NaturalOrderComparator.java
@@ -26,116 +26,144 @@
 
 import java.util.Comparator;
 
-public class NaturalOrderComparator implements Comparator<Object> {
-	int compareRight(String a, String b) {
-		int bias = 0;
-		int ia = 0;
-		int ib = 0;
-
-		// The longest run of digits wins. That aside, the greatest
-		// value wins, but we can't know that it will until we've scanned
-		// both numbers to know that they have the same magnitude, so we
-		// remember it in BIAS.
-		for (;; ia++, ib++) {
-			char ca = charAt(a, ia);
-			char cb = charAt(b, ib);
-
-			if (!Character.isDigit(ca) && !Character.isDigit(cb)) {
-				return bias;
-			}
-			else if (!Character.isDigit(ca)) {
-				return -1;
-			}
-			else if (!Character.isDigit(cb)) {
-				return +1;
-			}
-			else if (ca < cb) {
-				if (bias == 0) {
-					bias = -1;
-				}
-			}
-			else if (ca > cb) {
-				if (bias == 0)
-					bias = +1;
-			}
-			else if (ca == 0 && cb == 0) {
-				return bias;
-			}
-		}
-	}
-
-	public int compare(Object o1, Object o2) {
-		String a = o1.toString();
-		String b = o2.toString();
-
-		int ia = 0, ib = 0;
-		int nza = 0, nzb = 0;
-		char ca, cb;
-		int result;
-
-		while (true) {
-			// only count the number of zeroes leading the last number compared
-			nza = nzb = 0;
-
-			ca = charAt(a, ia);
-			cb = charAt(b, ib);
-
-			// skip over leading spaces or zeros
-			while (Character.isSpaceChar(ca) || ca == '0') {
-				if (ca == '0') {
-					nza++;
-				}
-				else {
-					// only count consecutive zeroes
-					nza = 0;
-				}
-
-				ca = charAt(a, ++ia);
-			}
-
-			while (Character.isSpaceChar(cb) || cb == '0') {
-				if (cb == '0') {
-					nzb++;
-				}
-				else {
-					// only count consecutive zeroes
-					nzb = 0;
-				}
-
-				cb = charAt(b, ++ib);
-			}
-
-			// process run of digits
-			if (Character.isDigit(ca) && Character.isDigit(cb)) {
-				if ((result = compareRight(a.substring(ia), b.substring(ib))) != 0) {
-					return result;
-				}
-			}
-
-			if (ca == 0 && cb == 0) {
-				// The strings compare the same. Perhaps the caller
-				// will want to call strcmp to break the tie.
-				return nza - nzb;
-			}
-
-			if (ca < cb) {
-				return -1;
-			}
-			else if (ca > cb) {
-				return +1;
-			}
-
-			++ia;
-			++ib;
-		}
-	}
-
-	static char charAt(String s, int i) {
-		if (i >= s.length()) {
-			return 0;
-		}
-		else {
-			return s.charAt(i);
-		}
-	}
+public class NaturalOrderComparator implements Comparator<Object>
+{
+    int compareRight(String a, String b)
+    {
+        int bias = 0;
+        int ia   = 0;
+        int ib   = 0;
+
+        // The longest run of digits wins. That aside, the greatest
+        // value wins, but we can't know that it will until we've scanned
+        // both numbers to know that they have the same magnitude, so we
+        // remember it in BIAS.
+        for (; ; ia++, ib++)
+        {
+            char ca = charAt(a, ia);
+            char cb = charAt(b, ib);
+
+            if (!Character.isDigit(ca) && !Character.isDigit(cb))
+            {
+                return bias;
+            }
+            else if (!Character.isDigit(ca))
+            {
+                return -1;
+            }
+            else if (!Character.isDigit(cb))
+            {
+                return +1;
+            }
+            else if (ca < cb)
+            {
+                if (bias == 0)
+                {
+                    bias = -1;
+                }
+            }
+            else if (ca > cb)
+            {
+                if (bias == 0)
+                {
+                    bias = +1;
+                }
+            }
+            else if (ca == 0 && cb == 0)
+            {
+                return bias;
+            }
+        }
+    }
+
+    public int compare(Object o1, Object o2)
+    {
+        String a = o1.toString();
+        String b = o2.toString();
+
+        int  ia  = 0, ib = 0;
+        int  nza = 0, nzb = 0;
+        char ca, cb;
+        int  result;
+
+        while (true)
+        {
+            // only count the number of zeroes leading the last number compared
+            nza = nzb = 0;
+
+            ca = charAt(a, ia);
+            cb = charAt(b, ib);
+
+            // skip over leading spaces or zeros
+            while (Character.isSpaceChar(ca) || ca == '0')
+            {
+                if (ca == '0')
+                {
+                    nza++;
+                }
+                else
+                {
+                    // only count consecutive zeroes
+                    nza = 0;
+                }
+
+                ca = charAt(a, ++ia);
+            }
+
+            while (Character.isSpaceChar(cb) || cb == '0')
+            {
+                if (cb == '0')
+                {
+                    nzb++;
+                }
+                else
+                {
+                    // only count consecutive zeroes
+                    nzb = 0;
+                }
+
+                cb = charAt(b, ++ib);
+            }
+
+            // process run of digits
+            if (Character.isDigit(ca) && Character.isDigit(cb))
+            {
+                if ((result = compareRight(a.substring(ia), b.substring(ib))) != 0)
+                {
+                    return result;
+                }
+            }
+
+            if (ca == 0 && cb == 0)
+            {
+                // The strings compare the same. Perhaps the caller
+                // will want to call strcmp to break the tie.
+                return nza - nzb;
+            }
+
+            if (ca < cb)
+            {
+                return -1;
+            }
+            else if (ca > cb)
+            {
+                return +1;
+            }
+
+            ++ia;
+            ++ib;
+        }
+    }
+
+    static char charAt(String s, int i)
+    {
+        if (i >= s.length())
+        {
+            return 0;
+        }
+        else
+        {
+            return s.charAt(i);
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/util/ReflectionUtils.java b/src/com/activeandroid/sebbia/util/ReflectionUtils.java
index 18d64207..c1e3a137 100644
--- a/src/com/activeandroid/sebbia/util/ReflectionUtils.java
+++ b/src/com/activeandroid/sebbia/util/ReflectionUtils.java
@@ -31,79 +31,96 @@
 import com.activeandroid.sebbia.annotation.Column;
 import com.activeandroid.sebbia.serializer.TypeSerializer;
 
-public final class ReflectionUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static boolean isModel(Class<?> type) {
-		return type == Model.class || isSubclassOf(type, Model.class);
-	}
-
-	public static boolean isTypeSerializer(Class<?> type) {
-		return isSubclassOf(type, TypeSerializer.class);
-	}
-
-	// Meta-data
-
-	@SuppressWarnings("unchecked")
-	public static <T> T getMetaData(Context context, String name) {
-		try {
-			final ApplicationInfo ai = context.getPackageManager().getApplicationInfo(context.getPackageName(),
-					PackageManager.GET_META_DATA);
-
-			if (ai.metaData != null) {
-				return (T) ai.metaData.get(name);
-			}
-		}
-		catch (Exception e) {
-			Log.w("Couldn't find meta-data: " + name);
-		}
-
-		return null;
-	}
-	
-	public static Set<Field> getDeclaredColumnFields(Class<?> type) {
-		Set<Field> declaredColumnFields = Collections.emptySet();
-		
-		if (ReflectionUtils.isSubclassOf(type, Model.class) || Model.class.equals(type)) {
-			declaredColumnFields = new LinkedHashSet<Field>();
-			
-			Field[] fields = type.getDeclaredFields();
-			Arrays.sort(fields, new Comparator<Field>() {
-				@Override
-				public int compare(Field field1, Field field2) {
-					return field2.getName().compareTo(field1.getName());
-				}
-			});
-			for (Field field : fields) {
-				if (field.isAnnotationPresent(Column.class)) {
-					declaredColumnFields.add(field);
-				}
-			}
-	
-			Class<?> parentType = type.getSuperclass();
-			if (parentType != null) {
-				declaredColumnFields.addAll(getDeclaredColumnFields(parentType));
-			}
-		}
-		
-		return declaredColumnFields;		
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static boolean isSubclassOf(Class<?> type, Class<?> superClass) {
-		if (type.getSuperclass() != null) {
-			if (type.getSuperclass().equals(superClass)) {
-				return true;
-			}
-
-			return isSubclassOf(type.getSuperclass(), superClass);
-		}
-
-		return false;
-	}
+public final class ReflectionUtils
+{
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static boolean isModel(Class<?> type)
+    {
+        return type == Model.class || isSubclassOf(type, Model.class);
+    }
+
+    public static boolean isTypeSerializer(Class<?> type)
+    {
+        return isSubclassOf(type, TypeSerializer.class);
+    }
+
+    // Meta-data
+
+    @SuppressWarnings("unchecked")
+    public static <T> T getMetaData(Context context, String name)
+    {
+        try
+        {
+            final ApplicationInfo ai = context.getPackageManager().getApplicationInfo(context.getPackageName(),
+                    PackageManager.GET_META_DATA);
+
+            if (ai.metaData != null)
+            {
+                return (T) ai.metaData.get(name);
+            }
+        }
+        catch (Exception e)
+        {
+            Log.w("Couldn't find meta-data: " + name);
+        }
+
+        return null;
+    }
+
+    public static Set<Field> getDeclaredColumnFields(Class<?> type)
+    {
+        Set<Field> declaredColumnFields = Collections.emptySet();
+
+        if (ReflectionUtils.isSubclassOf(type, Model.class) || Model.class.equals(type))
+        {
+            declaredColumnFields = new LinkedHashSet<Field>();
+
+            Field[] fields = type.getDeclaredFields();
+            Arrays.sort(fields, new Comparator<Field>()
+            {
+                @Override
+                public int compare(Field field1, Field field2)
+                {
+                    return field2.getName().compareTo(field1.getName());
+                }
+            });
+            for (Field field : fields)
+            {
+                if (field.isAnnotationPresent(Column.class))
+                {
+                    declaredColumnFields.add(field);
+                }
+            }
+
+            Class<?> parentType = type.getSuperclass();
+            if (parentType != null)
+            {
+                declaredColumnFields.addAll(getDeclaredColumnFields(parentType));
+            }
+        }
+
+        return declaredColumnFields;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static boolean isSubclassOf(Class<?> type, Class<?> superClass)
+    {
+        if (type.getSuperclass() != null)
+        {
+            if (type.getSuperclass().equals(superClass))
+            {
+                return true;
+            }
+
+            return isSubclassOf(type.getSuperclass(), superClass);
+        }
+
+        return false;
+    }
 }
\ No newline at end of file
diff --git a/src/com/activeandroid/sebbia/util/SQLiteUtils.java b/src/com/activeandroid/sebbia/util/SQLiteUtils.java
index 85570058..3076115a 100644
--- a/src/com/activeandroid/sebbia/util/SQLiteUtils.java
+++ b/src/com/activeandroid/sebbia/util/SQLiteUtils.java
@@ -16,6 +16,17 @@
  * limitations under the License.
  */
 
+import android.database.Cursor;
+import android.os.Build;
+import android.text.TextUtils;
+
+import com.activeandroid.sebbia.Cache;
+import com.activeandroid.sebbia.Model;
+import com.activeandroid.sebbia.TableInfo;
+import com.activeandroid.sebbia.annotation.Column;
+import com.activeandroid.sebbia.annotation.Column.ConflictAction;
+import com.activeandroid.sebbia.serializer.TypeSerializer;
+
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
@@ -27,462 +38,537 @@
 import java.util.Map;
 import java.util.Set;
 
-import android.database.Cursor;
-import android.os.Build;
-import android.text.TextUtils;
+public final class SQLiteUtils
+{
+    //////////////////////////////////////////////////////////////////////////////////////
+    // ENUMERATIONS
+    //////////////////////////////////////////////////////////////////////////////////////
 
-import com.activeandroid.sebbia.Cache;
-import com.activeandroid.sebbia.Model;
-import com.activeandroid.sebbia.TableInfo;
-import com.activeandroid.sebbia.annotation.Column;
-import com.activeandroid.sebbia.annotation.Column.ConflictAction;
-import com.activeandroid.sebbia.serializer.TypeSerializer;
+    public enum SQLiteType
+    {
+        INTEGER, REAL, TEXT, BLOB
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC CONSTANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE CONTSANTS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    @SuppressWarnings("serial")
+    private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>()
+    {
+        {
+            put(byte.class, SQLiteType.INTEGER);
+            put(short.class, SQLiteType.INTEGER);
+            put(int.class, SQLiteType.INTEGER);
+            put(long.class, SQLiteType.INTEGER);
+            put(float.class, SQLiteType.REAL);
+            put(double.class, SQLiteType.REAL);
+            put(boolean.class, SQLiteType.INTEGER);
+            put(char.class, SQLiteType.TEXT);
+            put(byte[].class, SQLiteType.BLOB);
+            put(Byte.class, SQLiteType.INTEGER);
+            put(Short.class, SQLiteType.INTEGER);
+            put(Integer.class, SQLiteType.INTEGER);
+            put(Long.class, SQLiteType.INTEGER);
+            put(Float.class, SQLiteType.REAL);
+            put(Double.class, SQLiteType.REAL);
+            put(Boolean.class, SQLiteType.INTEGER);
+            put(Character.class, SQLiteType.TEXT);
+            put(String.class, SQLiteType.TEXT);
+            put(Byte[].class, SQLiteType.BLOB);
+        }
+    };
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PRIVATE MEMBERS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    private static HashMap<String, List<String>>   sIndexGroupMap;
+    private static HashMap<String, List<String>>   sUniqueGroupMap;
+    private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
 
-public final class SQLiteUtils {
-	//////////////////////////////////////////////////////////////////////////////////////
-	// ENUMERATIONS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public enum SQLiteType {
-		INTEGER, REAL, TEXT, BLOB
-	}
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC CONSTANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static final boolean FOREIGN_KEYS_SUPPORTED = Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE CONTSANTS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	@SuppressWarnings("serial")
-	private static final HashMap<Class<?>, SQLiteType> TYPE_MAP = new HashMap<Class<?>, SQLiteType>() {
-		{
-			put(byte.class, SQLiteType.INTEGER);
-			put(short.class, SQLiteType.INTEGER);
-			put(int.class, SQLiteType.INTEGER);
-			put(long.class, SQLiteType.INTEGER);
-			put(float.class, SQLiteType.REAL);
-			put(double.class, SQLiteType.REAL);
-			put(boolean.class, SQLiteType.INTEGER);
-			put(char.class, SQLiteType.TEXT);
-			put(byte[].class, SQLiteType.BLOB);
-			put(Byte.class, SQLiteType.INTEGER);
-			put(Short.class, SQLiteType.INTEGER);
-			put(Integer.class, SQLiteType.INTEGER);
-			put(Long.class, SQLiteType.INTEGER);
-			put(Float.class, SQLiteType.REAL);
-			put(Double.class, SQLiteType.REAL);
-			put(Boolean.class, SQLiteType.INTEGER);
-			put(Character.class, SQLiteType.TEXT);
-			put(String.class, SQLiteType.TEXT);
-			put(Byte[].class, SQLiteType.BLOB);
-		}
-	};
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PRIVATE MEMBERS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	private static HashMap<String, List<String>> sIndexGroupMap;
-	private static HashMap<String, List<String>> sUniqueGroupMap;
-	private static HashMap<String, ConflictAction> sOnUniqueConflictsMap;
-
-	//////////////////////////////////////////////////////////////////////////////////////
-	// PUBLIC METHODS
-	//////////////////////////////////////////////////////////////////////////////////////
-
-	public static void execSql(String sql) {
-		Cache.openDatabase().execSQL(sql);
-	}
-
-	public static void execSql(String sql, Object[] bindArgs) {
-		Cache.openDatabase().execSQL(sql, bindArgs);
-	}
-
-	public static <T extends Model> List<T> rawQuery(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-		List<T> entities = processCursor(type, cursor);
-		cursor.close();
-
-		return entities;
-	}
-	  
-	public static int intQuery(final String sql, final String[] selectionArgs) {
-        final Cursor cursor = Cache.openDatabase().rawQuery(sql, selectionArgs);
-        final int number = processIntCursor(cursor);
+    //////////////////////////////////////////////////////////////////////////////////////
+    // PUBLIC METHODS
+    //////////////////////////////////////////////////////////////////////////////////////
+
+    public static void execSql(String database, String sql)
+    {
+        Cache.openDatabase(database).execSQL(sql);
+    }
+
+    public static void execSql(String database, String sql, Object[] bindArgs)
+    {
+        Cache.openDatabase(database).execSQL(sql, bindArgs);
+    }
+
+    public static <T extends Model> List<T> rawQuery(String database, Class<? extends Model> type, String sql, String[] selectionArgs)
+    {
+        Cursor  cursor   = Cache.openDatabase(database).rawQuery(sql, selectionArgs);
+        List<T> entities = processCursor(database, type, cursor);
+        cursor.close();
+
+        return entities;
+    }
+
+    public static int intQuery(String database, final String sql, final String[] selectionArgs)
+    {
+        final Cursor cursor = Cache.openDatabase(database).rawQuery(sql, selectionArgs);
+        final int    number = processIntCursor(cursor);
         cursor.close();
 
         return number;
-	}
+    }
 
-	public static <T extends Model> T rawQuerySingle(Class<? extends Model> type, String sql, String[] selectionArgs) {
-		List<T> entities = rawQuery(type, sql, selectionArgs);
+    public static <T extends Model> T rawQuerySingle(String database, Class<? extends Model> type, String sql, String[] selectionArgs)
+    {
+        List<T> entities = rawQuery(database, type, sql, selectionArgs);
 
-		if (entities.size() > 0) {
-			return entities.get(0);
-		}
+        if (entities.size() > 0)
+        {
+            return entities.get(0);
+        }
 
-		return null;
-	}
+        return null;
+    }
 
-	// Database creation
+    // Database creation
 
-	public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sUniqueGroupMap = new HashMap<String, List<String>>();
-		sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
+    public static ArrayList<String> createUniqueDefinition(TableInfo tableInfo)
+    {
+        final ArrayList<String> definitions = new ArrayList<String>();
+        sUniqueGroupMap = new HashMap<String, List<String>>();
+        sOnUniqueConflictsMap = new HashMap<String, ConflictAction>();
 
-		for (Field field : tableInfo.getFields()) {
-			createUniqueColumnDefinition(tableInfo, field);
-		}
+        for (Field field : tableInfo.getFields())
+        {
+            createUniqueColumnDefinition(tableInfo, field);
+        }
 
-		if (sUniqueGroupMap.isEmpty()) {
-			return definitions;
-		}
+        if (sUniqueGroupMap.isEmpty())
+        {
+            return definitions;
+        }
 
-		Set<String> keySet = sUniqueGroupMap.keySet();
-		for (String key : keySet) {
-			List<String> group = sUniqueGroupMap.get(key);
-			ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
+        Set<String> keySet = sUniqueGroupMap.keySet();
+        for (String key : keySet)
+        {
+            List<String> group = sUniqueGroupMap.get(key);
+            ConflictAction conflictAction = sOnUniqueConflictsMap.get(key);
 
-			definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
-					TextUtils.join(", ", group), conflictAction.toString()));
-		}
+            definitions.add(String.format("UNIQUE (%s) ON CONFLICT %s",
+                    TextUtils.join(", ", group), conflictAction.toString()));
+        }
 
-		return definitions;
-	}
+        return definitions;
+    }
 
-	public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
+    public static void createUniqueColumnDefinition(TableInfo tableInfo, Field field)
+    {
+        final String name   = tableInfo.getColumnName(field);
+        final Column column = field.getAnnotation(Column.class);
 
-        if (field.getName().equals("mId")) {
+        if (field.getName().equals("mId"))
+        {
             return;
         }
 
-		String[] groups = column.uniqueGroups();
-		ConflictAction[] conflictActions = column.onUniqueConflicts();
-		if (groups.length != conflictActions.length)
-			return;
+        String[]         groups          = column.uniqueGroups();
+        ConflictAction[] conflictActions = column.onUniqueConflicts();
+        if (groups.length != conflictActions.length)
+        {
+            return;
+        }
 
-		for (int i = 0; i < groups.length; i++) {
-			String group = groups[i];
-			ConflictAction conflictAction = conflictActions[i];
+        for (int i = 0; i < groups.length; i++)
+        {
+            String group = groups[i];
+            ConflictAction conflictAction = conflictActions[i];
+
+            if (TextUtils.isEmpty(group))
+            {
+                continue;
+            }
+
+            List<String> list = sUniqueGroupMap.get(group);
+            if (list == null)
+            {
+                list = new ArrayList<String>();
+            }
+            list.add(name);
+
+            sUniqueGroupMap.put(group, list);
+            sOnUniqueConflictsMap.put(group, conflictAction);
+        }
+    }
 
-			if (TextUtils.isEmpty(group))
-				continue;
+    public static String[] createIndexDefinition(TableInfo tableInfo)
+    {
+        final ArrayList<String> definitions = new ArrayList<String>();
+        sIndexGroupMap = new HashMap<String, List<String>>();
 
-			List<String> list = sUniqueGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-			list.add(name);
+        for (Field field : tableInfo.getFields())
+        {
+            createIndexColumnDefinition(tableInfo, field);
+        }
 
-			sUniqueGroupMap.put(group, list);
-			sOnUniqueConflictsMap.put(group, conflictAction);
-		}
-	}
+        if (sIndexGroupMap.isEmpty())
+        {
+            return new String[0];
+        }
 
-	public static String[] createIndexDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-		sIndexGroupMap = new HashMap<String, List<String>>();
+        for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet())
+        {
+            definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
+                    "index_" + tableInfo.getTableName() + "_" + entry.getKey(),
+                    tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
+        }
 
-		for (Field field : tableInfo.getFields()) {
-			createIndexColumnDefinition(tableInfo, field);
-		}
+        return definitions.toArray(new String[definitions.size()]);
+    }
 
-		if (sIndexGroupMap.isEmpty()) {
-			return new String[0];
-		}
+    public static void createIndexColumnDefinition(TableInfo tableInfo, Field field)
+    {
+        final String name   = tableInfo.getColumnName(field);
+        final Column column = field.getAnnotation(Column.class);
 
-		for (Map.Entry<String, List<String>> entry : sIndexGroupMap.entrySet()) {
-			definitions.add(String.format("CREATE INDEX IF NOT EXISTS %s on %s(%s);",
-					"index_" + tableInfo.getTableName() + "_" + entry.getKey(),
-					tableInfo.getTableName(), TextUtils.join(", ", entry.getValue())));
-		}
+        if (field.getName().equals("mId"))
+        {
+            return;
+        }
 
-		return definitions.toArray(new String[definitions.size()]);
-	}
+        if (column.index())
+        {
+            List<String> list = new ArrayList<String>();
+            list.add(name);
+            sIndexGroupMap.put(name, list);
+        }
 
-	public static void createIndexColumnDefinition(TableInfo tableInfo, Field field) {
-		final String name = tableInfo.getColumnName(field);
-		final Column column = field.getAnnotation(Column.class);
+        String[] groups = column.indexGroups();
+        for (String group : groups)
+        {
+            if (TextUtils.isEmpty(group))
+            {
+                continue;
+            }
+
+            List<String> list = sIndexGroupMap.get(group);
+            if (list == null)
+            {
+                list = new ArrayList<String>();
+            }
+
+            list.add(name);
+            sIndexGroupMap.put(group, list);
+        }
+    }
 
-        if (field.getName().equals("mId")) {
-            return;
+    public static String createTableDefinition(TableInfo tableInfo)
+    {
+        final ArrayList<String> definitions = new ArrayList<String>();
+
+        for (Field field : tableInfo.getFields())
+        {
+            String definition = createColumnDefinition(tableInfo, field);
+            if (!TextUtils.isEmpty(definition))
+            {
+                definitions.add(definition);
+            }
         }
 
-		if (column.index()) {
-			List<String> list = new ArrayList<String>();
-			list.add(name);
-			sIndexGroupMap.put(name, list);
-		}
-
-		String[] groups = column.indexGroups();
-		for (String group : groups) {
-			if (TextUtils.isEmpty(group))
-				continue;
-
-			List<String> list = sIndexGroupMap.get(group);
-			if (list == null) {
-				list = new ArrayList<String>();
-			}
-
-			list.add(name);
-			sIndexGroupMap.put(group, list);
-		}
-	}
-
-	public static String createTableDefinition(TableInfo tableInfo) {
-		final ArrayList<String> definitions = new ArrayList<String>();
-
-		for (Field field : tableInfo.getFields()) {
-			String definition = createColumnDefinition(tableInfo, field);
-			if (!TextUtils.isEmpty(definition)) {
-				definitions.add(definition);
-			}
-		}
-
-		definitions.addAll(createUniqueDefinition(tableInfo));
-
-		return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
-				TextUtils.join(", ", definitions));
-	}
-
-	@SuppressWarnings("unchecked")
-	public static String createColumnDefinition(TableInfo tableInfo, Field field) {
-		StringBuilder definition = new StringBuilder();
-
-		Class<?> type = field.getType();
-		final String name = tableInfo.getColumnName(field);
-		final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
-		final Column column = field.getAnnotation(Column.class);
-
-		if (typeSerializer != null) {
-			type = typeSerializer.getSerializedType();
-		}
-		
-		SQLiteType sqLiteType = null;
-		if (TYPE_MAP.containsKey(type)) {
-			sqLiteType = TYPE_MAP.get(type);
-		}
-		else if (ReflectionUtils.isModel(type)) {
-			sqLiteType = SQLiteType.INTEGER;
-		}
-		else if (ReflectionUtils.isSubclassOf(type, Enum.class)) {
-			sqLiteType = SQLiteType.TEXT;
-		}
-		
-		if (sqLiteType != null) {
-			definition.append(name);
-			definition.append(" ");
-			definition.append(sqLiteType.toString());
-		}
-
-		if (!TextUtils.isEmpty(definition)) {
-
-			if (name.equals(tableInfo.getIdName())) {
-				definition.append(" PRIMARY KEY AUTOINCREMENT");
-			}else if(column!=null){
-				if (column.length() > -1) {
-					definition.append("(");
-					definition.append(column.length());
-					definition.append(")");
-				}
-
-				if (column.notNull()) {
-					definition.append(" NOT NULL ON CONFLICT ");
-					definition.append(column.onNullConflict().toString());
-				}
-
-				if (column.unique()) {
-					definition.append(" UNIQUE ON CONFLICT ");
-					definition.append(column.onUniqueConflict().toString());
-				}
-				
-				if (!TextUtils.isEmpty(column.defaultValue())) {
-					String defaultValue = null;
-					switch (sqLiteType) {
-					case TEXT: case BLOB:
-						defaultValue = "\"" + column.defaultValue() + "\"";
-						break;
-
-					case INTEGER:
-						try {
-							if (type.equals(Boolean.class) || type.equals(boolean.class)) {
-								boolean value = Boolean.parseBoolean(column.defaultValue());
-								defaultValue = value ? "1" : "0";
-							} else {
-								Integer.parseInt(column.defaultValue());
-								defaultValue = column.defaultValue();
-							}
-						} catch (NumberFormatException e) {
-							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
-						}
-						break;
-						
-					case REAL:
-						try {
-							Double.parseDouble(column.defaultValue());
-							defaultValue = column.defaultValue();
-						} catch (NumberFormatException e) {
-							Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
-						}
-						break;
-					}
-					
-					if (defaultValue != null) {
-						definition.append(" DEFAULT ");
-						definition.append(defaultValue);
-					}
-				}
-			}
-
-			if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type) && Cache.getTableInfo((Class<? extends Model>) type) != null) {
-				definition.append(" REFERENCES ");
-				definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
-				definition.append("("+tableInfo.getIdName()+")");
-				definition.append(" ON DELETE ");
-				definition.append(column.onDelete().toString().replace("_", " "));
-				definition.append(" ON UPDATE ");
-				definition.append(column.onUpdate().toString().replace("_", " "));
-			}
-		
-		}
-		else {
-			Log.e("No type mapping for: " + type.toString());
-		}
-
-		return definition.toString();
-	}
-
-	@SuppressWarnings("unchecked")
-	public static <T extends Model> List<T> processCursor(Class<? extends Model> type, Cursor cursor) {
-		TableInfo tableInfo = Cache.getTableInfo(type);
-		String idName = tableInfo.getIdName();
-		final List<T> entities = new ArrayList<T>();
-
-		try {
-			Constructor<?> entityConstructor = type.getConstructor();
-
-			if (cursor.moveToFirst()) {
+        definitions.addAll(createUniqueDefinition(tableInfo));
+
+        return String.format("CREATE TABLE IF NOT EXISTS %s (%s);", tableInfo.getTableName(),
+                TextUtils.join(", ", definitions));
+    }
+
+    @SuppressWarnings("unchecked")
+    public static String createColumnDefinition(TableInfo tableInfo, Field field)
+    {
+        StringBuilder definition = new StringBuilder();
+
+        Class<?>             type           = field.getType();
+        final String         name           = tableInfo.getColumnName(field);
+        final TypeSerializer typeSerializer = Cache.getParserForType(field.getType());
+        final Column         column         = field.getAnnotation(Column.class);
+
+        if (typeSerializer != null)
+        {
+            type = typeSerializer.getSerializedType();
+        }
+
+        SQLiteType sqLiteType = null;
+        if (TYPE_MAP.containsKey(type))
+        {
+            sqLiteType = TYPE_MAP.get(type);
+        }
+        else if (ReflectionUtils.isModel(type))
+        {
+            sqLiteType = SQLiteType.INTEGER;
+        }
+        else if (ReflectionUtils.isSubclassOf(type, Enum.class))
+        {
+            sqLiteType = SQLiteType.TEXT;
+        }
+
+        if (sqLiteType != null)
+        {
+            definition.append(name);
+            definition.append(" ");
+            definition.append(sqLiteType.toString());
+        }
+
+        if (!TextUtils.isEmpty(definition))
+        {
+
+            if (name.equals(tableInfo.getIdName()))
+            {
+                definition.append(" PRIMARY KEY AUTOINCREMENT");
+            }
+            else if (column != null)
+            {
+                if (column.length() > -1)
+                {
+                    definition.append("(");
+                    definition.append(column.length());
+                    definition.append(")");
+                }
+
+                if (column.notNull())
+                {
+                    definition.append(" NOT NULL ON CONFLICT ");
+                    definition.append(column.onNullConflict().toString());
+                }
+
+                if (column.unique())
+                {
+                    definition.append(" UNIQUE ON CONFLICT ");
+                    definition.append(column.onUniqueConflict().toString());
+                }
+
+                if (!TextUtils.isEmpty(column.defaultValue()))
+                {
+                    String defaultValue = null;
+                    switch (sqLiteType)
+                    {
+                        case TEXT:
+                        case BLOB:
+                            defaultValue = "\"" + column.defaultValue() + "\"";
+                            break;
+
+                        case INTEGER:
+                            try
+                            {
+                                if (type.equals(Boolean.class) || type.equals(boolean.class))
+                                {
+                                    boolean value = Boolean.parseBoolean(column.defaultValue());
+                                    defaultValue = value ? "1" : "0";
+                                }
+                                else
+                                {
+                                    Integer.parseInt(column.defaultValue());
+                                    defaultValue = column.defaultValue();
+                                }
+                            }
+                            catch (NumberFormatException e)
+                            {
+                                Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
+                            }
+                            break;
+
+                        case REAL:
+                            try
+                            {
+                                Double.parseDouble(column.defaultValue());
+                                defaultValue = column.defaultValue();
+                            }
+                            catch (NumberFormatException e)
+                            {
+                                Log.e("Failed to convert default value '" + column.defaultValue() + "' to " + sqLiteType.toString());
+                            }
+                            break;
+                    }
+
+                    if (defaultValue != null)
+                    {
+                        definition.append(" DEFAULT ");
+                        definition.append(defaultValue);
+                    }
+                }
+            }
+
+            if (FOREIGN_KEYS_SUPPORTED && ReflectionUtils.isModel(type) && Cache.getTableInfo((Class<? extends Model>) type) != null)
+            {
+                definition.append(" REFERENCES ");
+                definition.append(Cache.getTableInfo((Class<? extends Model>) type).getTableName());
+                definition.append("(" + tableInfo.getIdName() + ")");
+                definition.append(" ON DELETE ");
+                definition.append(column.onDelete().toString().replace("_", " "));
+                definition.append(" ON UPDATE ");
+                definition.append(column.onUpdate().toString().replace("_", " "));
+            }
+
+        }
+        else
+        {
+            Log.e("No type mapping for: " + type.toString());
+        }
+
+        return definition.toString();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T extends Model> List<T> processCursor(String database, Class<? extends Model> type, Cursor cursor)
+    {
+        TableInfo     tableInfo = Cache.getTableInfo(type);
+        String        idName    = tableInfo.getIdName();
+        final List<T> entities  = new ArrayList<T>();
+
+        try
+        {
+            Constructor<?> entityConstructor = type.getConstructor();
+
+            if (cursor.moveToFirst())
+            {
                 /**
                  * Obtain the columns ordered to fix issue #106 (https://github.com/pardom/ActiveAndroid/issues/106)
                  * when the cursor have multiple columns with same name obtained from join tables.
                  */
                 List<String> columnsOrdered = new ArrayList<String>(Arrays.asList(cursor.getColumnNames()));
-				do {
-					Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
-					if (entity == null) {
-						entity = (T) entityConstructor.newInstance();
-					}
-
-					entity.loadFromCursor(cursor);
-					entities.add((T) entity);
-				}
-				while (cursor.moveToNext());
-			}
-
-		}
-		catch (NoSuchMethodException e) {
-			throw new RuntimeException(
-                "Your model " + type.getName() + " does not define a default " +
-                "constructor. The default constructor is required for " +
-                "now in ActiveAndroid models, as the process to " +
-                "populate the ORM model is : " +
-                "1. instantiate default model " +
-                "2. populate fields"
+                do
+                {
+                    Model entity = Cache.getEntity(type, cursor.getLong(columnsOrdered.indexOf(idName)));
+                    if (entity == null)
+                    {
+                        entity = (T) entityConstructor.newInstance();
+                    }
+
+                    entity.loadFromCursor(database, cursor);
+                    entities.add((T) entity);
+                }
+                while (cursor.moveToNext());
+            }
+
+        }
+        catch (NoSuchMethodException e)
+        {
+            throw new RuntimeException(
+                    "Your model " + type.getName() + " does not define a default " +
+                            "constructor. The default constructor is required for " +
+                            "now in ActiveAndroid models, as the process to " +
+                            "populate the ORM model is : " +
+                            "1. instantiate default model " +
+                            "2. populate fields"
             );
-		}
-		catch (Exception e) {
-			Log.e("Failed to process cursor.", e);
-		}
+        }
+        catch (Exception e)
+        {
+            Log.e("Failed to process cursor.", e);
+        }
 
-		return entities;
-	}
+        return entities;
+    }
 
-	private static int processIntCursor(final Cursor cursor) {
-        if (cursor.moveToFirst()) {
+    private static int processIntCursor(final Cursor cursor)
+    {
+        if (cursor.moveToFirst())
+        {
             return cursor.getInt(0);
-	    }
+        }
         return 0;
     }
 
-	public static List<String> lexSqlScript(String sqlScript) {
-		ArrayList<String> sl = new ArrayList<String>();
-		boolean inString = false, quoteNext = false;
-		StringBuilder b = new StringBuilder(100);
-
-		for (int i = 0; i < sqlScript.length(); i++) {
-			char c = sqlScript.charAt(i);
-
-			if (c == ';' && !inString && !quoteNext) {
-				sl.add(b.toString());
-				b = new StringBuilder(100);
-				inString = false;
-				quoteNext = false;
-				continue;
-			}
-
-			if (c == '\'' && !quoteNext) {
-				inString = !inString;
-			}
-
-			quoteNext = c == '\\' && !quoteNext;
-
-			b.append(c);
-		}
-
-		if (b.length() > 0) {
-			sl.add(b.toString());
-		}
-
-		return sl;
-	}
-	
-	public static String createInsertStatement(String insertInto, TableInfo tableInfo) {
-		StringBuilder stringBuilder = new StringBuilder(insertInto);
-		stringBuilder
-			.append(tableInfo.getTableName())
-			.append(" (");
-			appendColumns(stringBuilder, tableInfo.getColumnNames(), false)
-			.append(") VALUES (");
-		appendPlaceholders(stringBuilder, tableInfo.getFields().size());
-		stringBuilder.append(")");
-		return stringBuilder.toString();
-	}
-	
-	public static String createUpdateStatement(TableInfo tableInfo) {
-		StringBuilder stringBuilder = new StringBuilder("UPDATE ");
-		stringBuilder
-			.append(tableInfo.getTableName())
-			.append(" SET ");
-		appendColumns(stringBuilder, tableInfo.getColumnNames(), true)
-			.append(" WHERE ");
-		appendColumn(stringBuilder, tableInfo.getIdName())
-			.append(" = ?");
-		return stringBuilder.toString();
-	}
-	
-	private static StringBuilder appendColumns(StringBuilder stringBuilder, Collection<String> columns, boolean addEqPlaceholder) {
-		String divider = addEqPlaceholder ? " =?, " : ", ";
-		Iterator<String> iterator = columns.iterator();
-		while (iterator.hasNext())
-			appendColumn(stringBuilder, iterator.next()).append(iterator.hasNext() ? divider : "");
-		return stringBuilder;
-	}
-	
-	private static StringBuilder appendColumn(StringBuilder stringBuilder, String column) {
-		return stringBuilder.append("'").append(column).append("\'");
-	}
-	
-	private static StringBuilder appendPlaceholders(StringBuilder stringBuilder, int count) {
-		for (int i = 0; i < count; ++i)
-			stringBuilder.append("?").append(i == count - 1 ? "" : ", ");
-		return stringBuilder;
-	}
+    public static List<String> lexSqlScript(String sqlScript)
+    {
+        ArrayList<String> sl       = new ArrayList<String>();
+        boolean           inString = false, quoteNext = false;
+        StringBuilder     b        = new StringBuilder(100);
+
+        for (int i = 0; i < sqlScript.length(); i++)
+        {
+            char c = sqlScript.charAt(i);
+
+            if (c == ';' && !inString && !quoteNext)
+            {
+                sl.add(b.toString());
+                b = new StringBuilder(100);
+                inString = false;
+                quoteNext = false;
+                continue;
+            }
+
+            if (c == '\'' && !quoteNext)
+            {
+                inString = !inString;
+            }
+
+            quoteNext = c == '\\' && !quoteNext;
+
+            b.append(c);
+        }
+
+        if (b.length() > 0)
+        {
+            sl.add(b.toString());
+        }
+
+        return sl;
+    }
+
+    public static String createInsertStatement(String insertInto, TableInfo tableInfo)
+    {
+        StringBuilder stringBuilder = new StringBuilder(insertInto);
+        stringBuilder
+                .append(tableInfo.getTableName())
+                .append(" (");
+        appendColumns(stringBuilder, tableInfo.getColumnNames(), false)
+                .append(") VALUES (");
+        appendPlaceholders(stringBuilder, tableInfo.getFields().size());
+        stringBuilder.append(")");
+        return stringBuilder.toString();
+    }
+
+    public static String createUpdateStatement(TableInfo tableInfo)
+    {
+        StringBuilder stringBuilder = new StringBuilder("UPDATE ");
+        stringBuilder
+                .append(tableInfo.getTableName())
+                .append(" SET ");
+        appendColumns(stringBuilder, tableInfo.getColumnNames(), true)
+                .append(" WHERE ");
+        appendColumn(stringBuilder, tableInfo.getIdName())
+                .append(" = ?");
+        return stringBuilder.toString();
+    }
+
+    private static StringBuilder appendColumns(StringBuilder stringBuilder, Collection<String> columns, boolean addEqPlaceholder)
+    {
+        String           divider  = addEqPlaceholder ? " =?, " : ", ";
+        Iterator<String> iterator = columns.iterator();
+        while (iterator.hasNext())
+        {
+            appendColumn(stringBuilder, iterator.next()).append(iterator.hasNext() ? divider : "");
+        }
+        return stringBuilder;
+    }
+
+    private static StringBuilder appendColumn(StringBuilder stringBuilder, String column)
+    {
+        return stringBuilder.append("'").append(column).append("\'");
+    }
+
+    private static StringBuilder appendPlaceholders(StringBuilder stringBuilder, int count)
+    {
+        for (int i = 0; i < count; ++i)
+        {
+            stringBuilder.append("?").append(i == count - 1 ? "" : ", ");
+        }
+        return stringBuilder;
+    }
 
 }
diff --git a/src/com/activeandroid/sebbia/util/SqlParser.java b/src/com/activeandroid/sebbia/util/SqlParser.java
index f34fce8d..ecbc447d 100644
--- a/src/com/activeandroid/sebbia/util/SqlParser.java
+++ b/src/com/activeandroid/sebbia/util/SqlParser.java
@@ -24,87 +24,116 @@
 import java.util.List;
 
 
-public class SqlParser {
+public class SqlParser
+{
 
     public final static int STATE_NONE          = 0;
     public final static int STATE_STRING        = 1;
     public final static int STATE_COMMENT       = 2;
     public final static int STATE_COMMENT_BLOCK = 3;
 
-    public static List<String> parse(final InputStream stream) throws IOException {
+    public static List<String> parse(final InputStream stream) throws IOException
+    {
 
-        final BufferedInputStream buffer = new BufferedInputStream(stream);
-        final List<String> commands = new ArrayList<String>();
-        final StringBuffer sb = new StringBuffer();
+        final BufferedInputStream buffer   = new BufferedInputStream(stream);
+        final List<String>        commands = new ArrayList<String>();
+        final StringBuffer        sb       = new StringBuffer();
 
-        try {
+        try
+        {
             final Tokenizer tokenizer = new Tokenizer(buffer);
             int state = STATE_NONE;
 
-            while (tokenizer.hasNext()) {
+            while (tokenizer.hasNext())
+            {
                 final char c = (char) tokenizer.next();
 
-                if (state == STATE_COMMENT_BLOCK) {
-                    if (tokenizer.skip("*/")) {
+                if (state == STATE_COMMENT_BLOCK)
+                {
+                    if (tokenizer.skip("*/"))
+                    {
                         state = STATE_NONE;
                     }
                     continue;
 
-                } else if (state == STATE_COMMENT) {
-                    if (isNewLine(c)) {
+                }
+                else if (state == STATE_COMMENT)
+                {
+                    if (isNewLine(c))
+                    {
                         state = STATE_NONE;
                     }
                     continue;
 
-                } else if (state == STATE_NONE && tokenizer.skip("/*")) {
+                }
+                else if (state == STATE_NONE && tokenizer.skip("/*"))
+                {
                     state = STATE_COMMENT_BLOCK;
                     continue;
 
-                } else if (state == STATE_NONE && tokenizer.skip("--")) {
+                }
+                else if (state == STATE_NONE && tokenizer.skip("--"))
+                {
                     state = STATE_COMMENT;
                     continue;
 
-                } else if (state == STATE_NONE && c == ';') {
+                }
+                else if (state == STATE_NONE && c == ';')
+                {
                     final String command = sb.toString().trim();
                     commands.add(command);
                     sb.setLength(0);
                     continue;
 
-                } else if (state == STATE_NONE && c == '\'') {
+                }
+                else if (state == STATE_NONE && c == '\'')
+                {
                     state = STATE_STRING;
 
-                } else if (state == STATE_STRING && c == '\'') {
+                }
+                else if (state == STATE_STRING && c == '\'')
+                {
                     state = STATE_NONE;
 
                 }
 
-                if (state == STATE_NONE || state == STATE_STRING) {
-                    if (state == STATE_NONE && isWhitespace(c)) {
-                        if (sb.length() > 0 && sb.charAt(sb.length() - 1) != ' ') {
+                if (state == STATE_NONE || state == STATE_STRING)
+                {
+                    if (state == STATE_NONE && isWhitespace(c))
+                    {
+                        if (sb.length() > 0 && sb.charAt(sb.length() - 1) != ' ')
+                        {
                             sb.append(' ');
                         }
-                    } else {
+                    }
+                    else
+                    {
                         sb.append(c);
                     }
                 }
             }
 
-        } finally {
+        }
+        finally
+        {
             IOUtils.closeQuietly(buffer);
         }
 
-        if (sb.length() > 0) {
+        if (sb.length() > 0)
+        {
             commands.add(sb.toString().trim());
         }
 
         return commands;
     }
 
-    private static boolean isNewLine(final char c) {
+    private static boolean isNewLine(final char c)
+    {
         return c == '\r' || c == '\n';
     }
 
-    private static boolean isWhitespace(final char c) {
+    private static boolean isWhitespace(final char c)
+    {
         return c == '\r' || c == '\n' || c == '\t' || c == ' ';
     }
 }
diff --git a/src/com/activeandroid/sebbia/util/Tokenizer.java b/src/com/activeandroid/sebbia/util/Tokenizer.java
index af52c68f..4c1c0352 100644
--- a/src/com/activeandroid/sebbia/util/Tokenizer.java
+++ b/src/com/activeandroid/sebbia/util/Tokenizer.java
@@ -21,52 +21,63 @@
 import java.io.InputStream;
 
 
-public class Tokenizer {
+public class Tokenizer
+{
 
     private final InputStream mStream;
 
-    private boolean           mIsNext;
-    private int               mCurrent;
+    private boolean mIsNext;
+    private int     mCurrent;
 
-    public Tokenizer(final InputStream in) {
+    public Tokenizer(final InputStream in)
+    {
         this.mStream = in;
     }
 
-    public boolean hasNext() throws IOException {
+    public boolean hasNext() throws IOException
+    {
 
-        if (!this.mIsNext) {
+        if (!this.mIsNext)
+        {
             this.mIsNext = true;
             this.mCurrent = this.mStream.read();
         }
         return this.mCurrent != -1;
     }
 
-    public int next() throws IOException {
+    public int next() throws IOException
+    {
 
-        if (!this.mIsNext) {
+        if (!this.mIsNext)
+        {
             this.mCurrent = this.mStream.read();
         }
         this.mIsNext = false;
         return this.mCurrent;
     }
 
-    public boolean skip(final String s) throws IOException {
+    public boolean skip(final String s) throws IOException
+    {
 
-        if (s == null || s.length() == 0) {
+        if (s == null || s.length() == 0)
+        {
             return false;
         }
 
-        if (s.charAt(0) != this.mCurrent) {
+        if (s.charAt(0) != this.mCurrent)
+        {
             return false;
         }
 
         final int len = s.length();
         this.mStream.mark(len - 1);
 
-        for (int n = 1; n < len; n++) {
+        for (int n = 1; n < len; n++)
+        {
             final int value = this.mStream.read();
 
-            if (value != s.charAt(n)) {
+            if (value != s.charAt(n))
+            {
                 this.mStream.reset();
                 return false;
             }
diff --git a/src/com/activeandroid/sebbia/widget/ModelAdapter.java b/src/com/activeandroid/sebbia/widget/ModelAdapter.java
index bb8b2b57..cc348ab6 100644
--- a/src/com/activeandroid/sebbia/widget/ModelAdapter.java
+++ b/src/com/activeandroid/sebbia/widget/ModelAdapter.java
@@ -8,50 +8,61 @@
 
 import com.activeandroid.sebbia.Model;
 
-public class ModelAdapter<T extends Model> extends ArrayAdapter<T> {
-	public ModelAdapter(Context context, int textViewResourceId) {
-		super(context, textViewResourceId);
-	}
-
-	public ModelAdapter(Context context, int resource, int textViewResourceId) {
-		super(context, resource, textViewResourceId);
-	}
-
-	public ModelAdapter(Context context, int textViewResourceId, List<T> objects) {
-		super(context, textViewResourceId, objects);
-	}
-
-	public ModelAdapter(Context context, int resource, int textViewResourceId, List<T> objects) {
-		super(context, resource, textViewResourceId, objects);
-	}
-
-	/**
-	 * Clears the adapter and, if data != null, fills if with new Items.
-	 *
-	 * @param collection A Collection&lt;? extends T&gt; which members get added to the adapter.
-	 */
-	public void setData(Collection<? extends T> collection) {
-		clear();
-
-		if (collection != null) {
-			for (T item : collection) {
-				add(item);
-			}
-		}
-	}
-
-	/**
-	 * @return The Id of the record at position.
-	 */
-	@Override
-	public long getItemId(int position) {
-		T item = getItem(position);
-
-		if (item != null) {
-			return item.getId();
-		}
-		else {
-			return -1;
-		}
-	}
+public class ModelAdapter<T extends Model> extends ArrayAdapter<T>
+{
+    public ModelAdapter(Context context, int textViewResourceId)
+    {
+        super(context, textViewResourceId);
+    }
+
+    public ModelAdapter(Context context, int resource, int textViewResourceId)
+    {
+        super(context, resource, textViewResourceId);
+    }
+
+    public ModelAdapter(Context context, int textViewResourceId, List<T> objects)
+    {
+        super(context, textViewResourceId, objects);
+    }
+
+    public ModelAdapter(Context context, int resource, int textViewResourceId, List<T> objects)
+    {
+        super(context, resource, textViewResourceId, objects);
+    }
+
+    /**
+     * Clears the adapter and, if data != null, fills if with new Items.
+     *
+     * @param collection A Collection&lt;? extends T&gt; which members get added to the adapter.
+     */
+    public void setData(Collection<? extends T> collection)
+    {
+        clear();
+
+        if (collection != null)
+        {
+            for (T item : collection)
+            {
+                add(item);
+            }
+        }
+    }
+
+    /**
+     * @return The Id of the record at position.
+     */
+    @Override
+    public long getItemId(int position)
+    {
+        T item = getItem(position);
+
+        if (item != null)
+        {
+            return item.getId();
+        }
+        else
+        {
+            return -1;
+        }
+    }
 }
diff --git a/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java b/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
index 992b3f75..26612c98 100644
--- a/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
+++ b/tests/src/com/activeandroid/test/ActiveAndroidTestCase.java
@@ -20,21 +20,26 @@
 
 import com.activeandroid.sebbia.app.Application;
 
-public abstract class ActiveAndroidTestCase extends ApplicationTestCase<Application> {
-	public ActiveAndroidTestCase() {
-		super(Application.class);
-	}
+public abstract class ActiveAndroidTestCase extends ApplicationTestCase<Application>
+{
+    public ActiveAndroidTestCase()
+    {
+        super(Application.class);
+    }
 
-	protected void setUp() throws Exception {
-		super.setUp();
-		createApplication();
-	}
+    protected void setUp() throws Exception
+    {
+        super.setUp();
+        createApplication();
+    }
 
-	public static <T> void assertArrayEquals(T[] actual, T... expected) {
-		assertEquals(expected.length, actual.length);
-		
-		for (int i = 0; i < expected.length; i++) {
-			assertEquals(expected[i], actual[i]);
-		}
-	}
+    public static <T> void assertArrayEquals(T[] actual, T... expected)
+    {
+        assertEquals(expected.length, actual.length);
+
+        for (int i = 0; i < expected.length; i++)
+        {
+            assertEquals(expected[i], actual[i]);
+        }
+    }
 }
diff --git a/tests/src/com/activeandroid/test/CacheTest.java b/tests/src/com/activeandroid/test/CacheTest.java
index 7a223633..ad2de5ec 100644
--- a/tests/src/com/activeandroid/test/CacheTest.java
+++ b/tests/src/com/activeandroid/test/CacheTest.java
@@ -11,10 +11,12 @@
 import com.activeandroid.sebbia.TableInfo;
 import com.activeandroid.sebbia.annotation.Table;
 
-public class CacheTest extends AndroidTestCase {
+public class CacheTest extends AndroidTestCase
+{
 
     @Override
-    protected void setUp() {
+    protected void setUp()
+    {
         Configuration conf = new Configuration.Builder(getContext())
                 .setDatabaseName("CacheTest")
                 .addModelClasses(CacheTestModel.class, CacheTestModel2.class)
@@ -22,7 +24,8 @@ protected void setUp() {
         ActiveAndroid.initialize(conf, true);
     }
 
-    public void testGetTableInfos() {
+    public void testGetTableInfos()
+    {
         assertNotNull(Cache.getContext());
         Collection<TableInfo> tableInfos = Cache.getTableInfos();
         assertEquals(2, tableInfos.size());
@@ -41,10 +44,12 @@ public void testGetTableInfos() {
     }
 
     @Table(name = "CacheTestModel")
-    static class CacheTestModel extends Model {
+    static class CacheTestModel extends Model
+    {
     }
 
     @Table(name = "CacheTestModel2")
-    static class CacheTestModel2 extends Model {
+    static class CacheTestModel2 extends Model
+    {
     }
 }
diff --git a/tests/src/com/activeandroid/test/ConfigurationTest.java b/tests/src/com/activeandroid/test/ConfigurationTest.java
index 3b7d2943..0300b6fa 100644
--- a/tests/src/com/activeandroid/test/ConfigurationTest.java
+++ b/tests/src/com/activeandroid/test/ConfigurationTest.java
@@ -9,9 +9,11 @@
 import com.activeandroid.sebbia.Model;
 import com.activeandroid.sebbia.annotation.Table;
 
-public class ConfigurationTest extends AndroidTestCase {
+public class ConfigurationTest extends AndroidTestCase
+{
 
-    public void testDefaultValue() throws IOException, ClassNotFoundException {
+    public void testDefaultValue() throws IOException, ClassNotFoundException
+    {
         Configuration conf = new Configuration.Builder(getContext()).create();
         assertNotNull(conf.getContext());
         assertEquals(1024, conf.getCacheSize());
@@ -23,7 +25,8 @@ public void testDefaultValue() throws IOException, ClassNotFoundException {
         assertEquals(Configuration.SQL_PARSER_LEGACY, conf.getSqlParser());
     }
 
-    public void testCreateConfigurationWithMockModel() {
+    public void testCreateConfigurationWithMockModel()
+    {
         Configuration conf = new Configuration.Builder(getContext())
                 .addModelClass(ConfigurationTestModel.class)
                 .create();
@@ -33,6 +36,7 @@ public void testCreateConfigurationWithMockModel() {
     }
 
     @Table(name = "ConfigurationTestModel")
-    static class ConfigurationTestModel extends Model {
+    static class ConfigurationTestModel extends Model
+    {
     }
 }
diff --git a/tests/src/com/activeandroid/test/DefaultValueTest.java b/tests/src/com/activeandroid/test/DefaultValueTest.java
index 4a6b5acd..d331b9e5 100644
--- a/tests/src/com/activeandroid/test/DefaultValueTest.java
+++ b/tests/src/com/activeandroid/test/DefaultValueTest.java
@@ -1,7 +1,5 @@
 package com.activeandroid.test;
 
-import java.util.List;
-
 import android.app.Application;
 import android.test.ApplicationTestCase;
 
@@ -12,102 +10,125 @@
 import com.activeandroid.sebbia.annotation.Table;
 import com.activeandroid.sebbia.query.Select;
 
-public class DefaultValueTest extends ApplicationTestCase<Application> {
-	
-	private static final int COUNT = 10;
-	
-	public DefaultValueTest() {
-		super(Application.class);
-	}
-	
-	@Override
-	protected void setUp() throws Exception {
-		super.setUp();
-		createApplication();
-	}
-
-	@Table(name = "IntegerDefaultValueModel")
-	public static class IntegerDefaultValueModel extends MockModel {
-		
-		@Column(defaultValue = "20")
-		Integer defaultField;
-		
-		public IntegerDefaultValueModel() {
-			super();
-		}
-	}
-	
-	@Table(name = "BooleanDefaultValueModel")
-	public static class BooleanDefaultValueModel extends MockModel {
-		
-		@Column(defaultValue = "true")
-		Boolean defaultField;
-		
-		public BooleanDefaultValueModel() {
-			super();
-		}
-	}
-
-	@Table(name = "StringDefaultValueModel")
-	public static class StringDefaultValueModel extends MockModel {
-		
-		@Column(defaultValue = "Some string")
-		String defaultField;
-		
-		public StringDefaultValueModel() {
-			super();
-		}
-	}
-	
-	public void testDefaultValueInteger() {
-		initializedActiveAndroid(IntegerDefaultValueModel.class);
-		List<IntegerDefaultValueModel> models = insertAndSelectModels(IntegerDefaultValueModel.class);
-		for (IntegerDefaultValueModel model : models) {
-			assertEquals(Integer.valueOf(20), model.defaultField);
-		}
-	}
-	
-	public void testDefaultValueBoolean() {
-		initializedActiveAndroid(BooleanDefaultValueModel.class);
-		List<BooleanDefaultValueModel> models = insertAndSelectModels(BooleanDefaultValueModel.class);
-		for (BooleanDefaultValueModel model : models) {
-			assertEquals(Boolean.valueOf(true), model.defaultField);
-		}
-	}
-	
-	public void testDefaultValueString() {
-		initializedActiveAndroid(StringDefaultValueModel.class);
-		List<StringDefaultValueModel> models = insertAndSelectModels(StringDefaultValueModel.class);
-		assertNotNull(models);
-		for (StringDefaultValueModel model : models) {
-			assertEquals("Some string", model.defaultField);
-		}
-	}
-	
-	private <T extends Model> List<T> insertAndSelectModels(Class<T> clazz) {
-		for (int i = 0; i < COUNT; ++i) {
-			T model = null;
-			try {
-				model = clazz.newInstance();
-			} catch (Exception e) {
-				throw new RuntimeException(e);
-			} 
-			model.save();
-		}
-		
-		List<T> models = new Select().from(clazz).execute();
-		assertEquals(COUNT, models.size());
-		return models;
-	}
-	
-	private void initializedActiveAndroid(Class<? extends Model> clazz) {
-		getContext().deleteDatabase("default_value.db");
-		ActiveAndroid.dispose();
-		Configuration configuration = new Configuration.Builder(getContext())
-		.addModelClass(clazz)
-		.setDatabaseName("default_value.db")
-		.create();
-		
-		ActiveAndroid.initialize(configuration, true);
-	}
+import java.util.List;
+
+public class DefaultValueTest extends ApplicationTestCase<Application>
+{
+
+    private static final int COUNT = 10;
+
+    public DefaultValueTest()
+    {
+        super(Application.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception
+    {
+        super.setUp();
+        createApplication();
+    }
+
+    @Table(name = "IntegerDefaultValueModel")
+    public static class IntegerDefaultValueModel extends MockModel
+    {
+
+        @Column(defaultValue = "20")
+        Integer defaultField;
+
+        public IntegerDefaultValueModel()
+        {
+            super();
+        }
+    }
+
+    @Table(name = "BooleanDefaultValueModel")
+    public static class BooleanDefaultValueModel extends MockModel
+    {
+
+        @Column(defaultValue = "true")
+        Boolean defaultField;
+
+        public BooleanDefaultValueModel()
+        {
+            super();
+        }
+    }
+
+    @Table(name = "StringDefaultValueModel")
+    public static class StringDefaultValueModel extends MockModel
+    {
+
+        @Column(defaultValue = "Some string")
+        String defaultField;
+
+        public StringDefaultValueModel()
+        {
+            super();
+        }
+    }
+
+    public void testDefaultValueInteger()
+    {
+        initializedActiveAndroid(IntegerDefaultValueModel.class);
+        List<IntegerDefaultValueModel> models = insertAndSelectModels("test", IntegerDefaultValueModel.class);
+        for (IntegerDefaultValueModel model : models)
+        {
+            assertEquals(Integer.valueOf(20), model.defaultField);
+        }
+    }
+
+    public void testDefaultValueBoolean()
+    {
+        initializedActiveAndroid(BooleanDefaultValueModel.class);
+        List<BooleanDefaultValueModel> models = insertAndSelectModels("test", BooleanDefaultValueModel.class);
+        for (BooleanDefaultValueModel model : models)
+        {
+            assertEquals(Boolean.valueOf(true), model.defaultField);
+        }
+    }
+
+    public void testDefaultValueString()
+    {
+        initializedActiveAndroid(StringDefaultValueModel.class);
+        List<StringDefaultValueModel> models = insertAndSelectModels("test", StringDefaultValueModel.class);
+        assertNotNull(models);
+        for (StringDefaultValueModel model : models)
+        {
+            assertEquals("Some string", model.defaultField);
+        }
+    }
+
+    private <T extends Model> List<T> insertAndSelectModels(String database, Class<T> clazz)
+    {
+        for (int i = 0; i < COUNT; ++i)
+        {
+            T model = null;
+            try
+            {
+                model = clazz.newInstance();
+            }
+            catch (Exception e)
+            {
+                throw new RuntimeException(e);
+            }
+            model.save(database);
+        }
+
+        List<T> models = new Select().from(clazz).execute(database);
+        assertEquals(COUNT, models.size());
+        return models;
+    }
+
+    private void initializedActiveAndroid(Class<? extends Model> clazz)
+    {
+        getContext().deleteDatabase("default_value.db");
+        ActiveAndroid.dispose();
+        Configuration configuration = new Configuration.Builder(getContext())
+                .addModelClass(clazz)
+                .setDatabaseName("default_value.db")
+                .create();
+
+        ActiveAndroid.initialize(configuration, true);
+    }
 }
diff --git a/tests/src/com/activeandroid/test/MockModel.java b/tests/src/com/activeandroid/test/MockModel.java
index b3c6fb18..c97250f3 100644
--- a/tests/src/com/activeandroid/test/MockModel.java
+++ b/tests/src/com/activeandroid/test/MockModel.java
@@ -23,7 +23,8 @@
 import com.activeandroid.sebbia.annotation.Table;
 
 @Table(name = "MockModel")
-public class MockModel extends Model {
+public class MockModel extends Model
+{
     @Column
     public Date dateField;
 
diff --git a/tests/src/com/activeandroid/test/ModelTest.java b/tests/src/com/activeandroid/test/ModelTest.java
index 8d3d8cf4..34f513ee 100644
--- a/tests/src/com/activeandroid/test/ModelTest.java
+++ b/tests/src/com/activeandroid/test/ModelTest.java
@@ -16,13 +16,6 @@
 
 package com.activeandroid.test;
 
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
 import com.activeandroid.sebbia.Cache;
 import com.activeandroid.sebbia.Model;
 import com.activeandroid.sebbia.TableInfo;
@@ -30,241 +23,266 @@
 import com.activeandroid.sebbia.annotation.Table;
 import com.activeandroid.sebbia.query.Select;
 
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
 /**
  * Simple test now covering equals and hashcode methods.
  */
-public class ModelTest extends ActiveAndroidTestCase {
-	
-	@Override
-	protected void tearDown() throws Exception {
-		super.tearDown();
-		getContext().deleteDatabase("Application.db");
-	}
-
-	/**
-	 * Equals should be type-safe.
-	 */
-	public void testEqualsNonModel() {
-		MockModel model = new MockModel();
-
-		assertFalse(model.equals("Dummy"));
-		assertFalse(model.equals(null));
-	}
-
-	/**
-	 * Equals should not be true for different model classes.
-	 */
-	public void testEqualsDifferentModel() {
-		Model model1 = new MockModel();
-		Model model2 = new AnotherMockModel();
-
-		assertFalse(model1.equals(model2));
-	}
-
-	/**
-	 * A new object does not have PK assigned yet, therefore by default it is
-	 * equal only to itself.
-	 */
-	public void testEqualsOnNew() {
-		MockModel model1 = new MockModel();
-		MockModel model2 = new MockModel();
-
-		assertFalse(model1.equals(model2));
-		assertFalse(model2.equals(model1));
-		assertTrue(model1.equals(model1)); // equal only to itself
-	}
-
-	/**
-	 * Two different rows in a table should not be equal (different ids).
-	 */
-	public void testEqualsDifferentRows() {
-		MockModel model1 = new MockModel();
-		MockModel model2 = new MockModel();
-		MockModel model3;
-
-		model1.save();
-		model2.save();
-		model3 = Model.load(MockModel.class, model1.getId());
-
-		// Not equal to each other.
-		assertFalse(model1.equals(model2));
-		assertFalse(model2.equals(model1));
-
-		// Equal to each other when loaded.
-		assertTrue(model1.equals(model3));
-		assertTrue(model1.equals(model3));
-
-		// Loaded model is not equal to a different model.
-		assertFalse(model3.equals(model2));
-		assertFalse(model2.equals(model3));
-	}
-
-	/**
-	 * Tests hashcode for new instances.
-	 */
-	public void testHashCode() {
-		Set<Model> set = new HashSet<Model>();
-		Model m1 = new MockModel();
-		Model m2 = new MockModel();
-		Model m3 = new AnotherMockModel();
-
-		assertFalse(m1.hashCode() == m2.hashCode()); // hashes for unsaved
-														// models must not match
-		set.add(m1);
-		set.add(m2);
-		assertEquals(2, set.size()); // try in a set
-
-		assertFalse(m1.hashCode() == m3.hashCode());
-		set.add(m3);
-		assertEquals(3, set.size());
-	}
-
-	/**
-	 * Two rows in a table should have different hashcodes.
-	 */
-	public void testHashCodeDifferentRows() {
-		Set<Model> set = new HashSet<Model>();
-		Model m1 = new MockModel();
-		Model m2 = new MockModel();
-		Model m3;
-
-		m1.save();
-		m2.save();
-		m3 = Model.load(MockModel.class, m1.getId());
-
-		assertEquals(m1.hashCode(), m3.hashCode());
-		assertFalse(m1.hashCode() == m2.hashCode());
-		set.add(m1);
-		set.add(m2);
-		set.add(m3);
-		assertEquals(2, set.size());
-	}
-
-	/**
-	 * Column names should default to the field name.
-	 */
-	public void testColumnNamesDefaulToFieldNames() {
-		TableInfo tableInfo = Cache.getTableInfo(MockModel.class);
-
-		for (Field field : tableInfo.getFields()) {
-			// Id column is a special case, we'll ignore that one.
-			if (field.getName().equals("mId"))
-				continue;
-
-			assertEquals(field.getName(), tableInfo.getColumnName(field));
-		}
-	}
-
-	/**
-	 * Boolean should handle integer (0/1) and boolean (false/true) values.
-	 */
-	public void testBooleanColumnType() {
-		MockModel mockModel = new MockModel();
-		mockModel.booleanField = false;
-		Long id = mockModel.save();
-
-        boolean databaseBooleanValue = MockModel.load( MockModel.class, id ).booleanField;
-        assertEquals( false, databaseBooleanValue );
-        
+public class ModelTest extends ActiveAndroidTestCase
+{
+
+    @Override
+    protected void tearDown() throws Exception
+    {
+        super.tearDown();
+        getContext().deleteDatabase("Application.db");
+    }
+
+    /**
+     * Equals should be type-safe.
+     */
+    public void testEqualsNonModel()
+    {
+        MockModel model = new MockModel();
+
+        assertFalse(model.equals("Dummy"));
+        assertFalse(model.equals(null));
+    }
+
+    /**
+     * Equals should not be true for different model classes.
+     */
+    public void testEqualsDifferentModel()
+    {
+        Model model1 = new MockModel();
+        Model model2 = new AnotherMockModel();
+
+        assertFalse(model1.equals(model2));
+    }
+
+    /**
+     * A new object does not have PK assigned yet, therefore by default it is
+     * equal only to itself.
+     */
+    public void testEqualsOnNew()
+    {
+        MockModel model1 = new MockModel();
+        MockModel model2 = new MockModel();
+
+        assertFalse(model1.equals(model2));
+        assertFalse(model2.equals(model1));
+        assertTrue(model1.equals(model1)); // equal only to itself
+    }
+
+    /**
+     * Two different rows in a table should not be equal (different ids).
+     */
+    public void testEqualsDifferentRows()
+    {
+        MockModel model1 = new MockModel();
+        MockModel model2 = new MockModel();
+        MockModel model3;
+
+        model1.save("test");
+        model2.save("test");
+        model3 = Model.load("test", MockModel.class, model1.getId());
+
+        // Not equal to each other.
+        assertFalse(model1.equals(model2));
+        assertFalse(model2.equals(model1));
+
+        // Equal to each other when loaded.
+        assertTrue(model1.equals(model3));
+        assertTrue(model1.equals(model3));
+
+        // Loaded model is not equal to a different model.
+        assertFalse(model3.equals(model2));
+        assertFalse(model2.equals(model3));
+    }
+
+    /**
+     * Tests hashcode for new instances.
+     */
+    public void testHashCode()
+    {
+        Set<Model> set = new HashSet<Model>();
+        Model      m1  = new MockModel();
+        Model      m2  = new MockModel();
+        Model      m3  = new AnotherMockModel();
+
+        assertFalse(m1.hashCode() == m2.hashCode()); // hashes for unsaved
+        // models must not match
+        set.add(m1);
+        set.add(m2);
+        assertEquals(2, set.size()); // try in a set
+
+        assertFalse(m1.hashCode() == m3.hashCode());
+        set.add(m3);
+        assertEquals(3, set.size());
+    }
+
+    /**
+     * Two rows in a table should have different hashcodes.
+     */
+    public void testHashCodeDifferentRows()
+    {
+        Set<Model> set = new HashSet<Model>();
+        Model      m1  = new MockModel();
+        Model      m2  = new MockModel();
+        Model      m3;
+
+        m1.save("test");
+        m2.save("test");
+        m3 = Model.load("test", MockModel.class, m1.getId());
+
+        assertEquals(m1.hashCode(), m3.hashCode());
+        assertFalse(m1.hashCode() == m2.hashCode());
+        set.add(m1);
+        set.add(m2);
+        set.add(m3);
+        assertEquals(2, set.size());
+    }
+
+    /**
+     * Column names should default to the field name.
+     */
+    public void testColumnNamesDefaulToFieldNames()
+    {
+        TableInfo tableInfo = Cache.getTableInfo(MockModel.class);
+
+        for (Field field : tableInfo.getFields())
+        {
+            // Id column is a special case, we'll ignore that one.
+            if (field.getName().equals("mId"))
+            {
+                continue;
+            }
+
+            assertEquals(field.getName(), tableInfo.getColumnName(field));
+        }
+    }
+
+    /**
+     * Boolean should handle integer (0/1) and boolean (false/true) values.
+     */
+    public void testBooleanColumnType()
+    {
+        MockModel mockModel = new MockModel();
+        mockModel.booleanField = false;
+        Long id = mockModel.save("test");
+
+        boolean databaseBooleanValue = MockModel.load("test", MockModel.class, id).booleanField;
+        assertEquals(false, databaseBooleanValue);
+
         // Test passing both a integer and a boolean into the where conditional.
-        assertEquals(mockModel, new Select().from(MockModel.class).where("booleanField = ?", 0).executeSingle() );
+        assertEquals(mockModel, new Select().from(MockModel.class).where("booleanField = ?", 0).executeSingle("test"));
 
-		assertEquals(mockModel, new Select().from(MockModel.class).where("booleanField = ?", false).executeSingle());
+        assertEquals(mockModel, new Select().from(MockModel.class).where("booleanField = ?", false).executeSingle("test"));
 
-		assertNull(new Select().from(MockModel.class).where("booleanField = ?", 1).executeSingle());
+        assertNull(new Select().from(MockModel.class).where("booleanField = ?", 1).executeSingle("test"));
 
-		assertNull(new Select().from(MockModel.class).where("booleanField = ?", true).executeSingle());
-	}
+        assertNull(new Select().from(MockModel.class).where("booleanField = ?", true).executeSingle("test"));
+    }
 
-	/*
+    /*
     * Test to check the join of two (or more) tables with some fields in common
-	 * when not use a projection on select. Test the issue #106
-	 * (https://github.com/pardom/ActiveAndroid/issues/106)
-	 */
-	public void testJoinWithSameNames() {
-		// create a parent entity and store
-		ParentJoinMockModel parent = new ParentJoinMockModel();
-		parent.booleanField = true;
-		parent.dateField = new Date();
-		parent.doubleField = 2.0;
-		parent.intField = 1;
-		parent.save();
-
-		// the values to assign to child
-		Date dateValue = new Date();
-		double doubleValue = 30.0;
-		int intValue = 3;
-
-		// create two child entities, relate with parent and save
-		ChildMockModel child1 = new ChildMockModel();
-		child1.booleanField = false;
-		child1.dateField = dateValue;
-		child1.doubleField = doubleValue;
-		child1.intField = intValue;
-		child1.parent = parent;
-		child1.save();
-
-		ChildMockModel child2 = new ChildMockModel();
-		child2.booleanField = false;
-		child2.dateField = dateValue;
-		child2.doubleField = doubleValue;
-		child2.intField = intValue;
-		child2.parent = parent;
-		child2.save();
-
-		// Store the ids assigned to child entities when persists
-		List<Long> ids = new ArrayList<Long>();
-		ids.add(child1.getId());
-		ids.add(child2.getId());
-
-		// make the query with a join
-		List<ChildMockModel> result = new Select().from(ChildMockModel.class).join(ParentJoinMockModel.class).on("ParentJoinMockModel.Id = ChildMockModel.parent").execute();
-
-		// check result
-		assertNotNull(result);
-		assertEquals(2, result.size());
-		for (ChildMockModel currentModel : result) {
-			assertFalse(currentModel.booleanField);
-			assertEquals(currentModel.intField, intValue);
-			assertEquals(currentModel.doubleField, doubleValue);
-			assertTrue(ids.contains(currentModel.getId()));
-		}
-
-	}
-
-	/**
-	 * Mock model as we need 2 different model classes.
-	 */
-	@Table(name = "AnotherMockTable")
-	public static class AnotherMockModel extends Model {
-	}
-
-	/**
-	 * Mock model to test joins with same names. It's a copy from MockModel.
-	 */
-	@Table(name = "ParentJoinMockModel")
-	public static class ParentJoinMockModel extends Model {
-		@Column
-		public Date dateField;
-
-		@Column
-		public double doubleField;
-
-		@Column
-		public int intField;
-
-		@Column
-		public boolean booleanField;
-	}
-
-	/**
-	 * Mock model to test joins with same names. Extends from
-	 * ParentJoinMockModel to have the same columns. Have a relationship with
-	 * ParentJoinMockModel to make te join query.
-	 */
-	@Table(name = "ChildMockModel")
-	public static class ChildMockModel extends ParentJoinMockModel {
-		@Column
-		ParentJoinMockModel parent;
-	}
+     * when not use a projection on select. Test the issue #106
+     * (https://github.com/pardom/ActiveAndroid/issues/106)
+     */
+    public void testJoinWithSameNames()
+    {
+        // create a parent entity and store
+        ParentJoinMockModel parent = new ParentJoinMockModel();
+        parent.booleanField = true;
+        parent.dateField = new Date();
+        parent.doubleField = 2.0;
+        parent.intField = 1;
+        parent.save("test");
+
+        // the values to assign to child
+        Date   dateValue   = new Date();
+        double doubleValue = 30.0;
+        int    intValue    = 3;
+
+        // create two child entities, relate with parent and save
+        ChildMockModel child1 = new ChildMockModel();
+        child1.booleanField = false;
+        child1.dateField = dateValue;
+        child1.doubleField = doubleValue;
+        child1.intField = intValue;
+        child1.parent = parent;
+        child1.save("test");
+
+        ChildMockModel child2 = new ChildMockModel();
+        child2.booleanField = false;
+        child2.dateField = dateValue;
+        child2.doubleField = doubleValue;
+        child2.intField = intValue;
+        child2.parent = parent;
+        child2.save("test");
+
+        // Store the ids assigned to child entities when persists
+        List<Long> ids = new ArrayList<Long>();
+        ids.add(child1.getId());
+        ids.add(child2.getId());
+
+        // make the query with a join
+        List<ChildMockModel> result = new Select().from(ChildMockModel.class).join(ParentJoinMockModel.class).on("ParentJoinMockModel.Id = ChildMockModel.parent").execute("test");
+
+        // check result
+        assertNotNull(result);
+        assertEquals(2, result.size());
+        for (ChildMockModel currentModel : result)
+        {
+            assertFalse(currentModel.booleanField);
+            assertEquals(currentModel.intField, intValue);
+            assertEquals(currentModel.doubleField, doubleValue);
+            assertTrue(ids.contains(currentModel.getId()));
+        }
+
+    }
+
+    /**
+     * Mock model as we need 2 different model classes.
+     */
+    @Table(name = "AnotherMockTable")
+    public static class AnotherMockModel extends Model
+    {
+    }
+
+    /**
+     * Mock model to test joins with same names. It's a copy from MockModel.
+     */
+    @Table(name = "ParentJoinMockModel")
+    public static class ParentJoinMockModel extends Model
+    {
+        @Column
+        public Date dateField;
+
+        @Column
+        public double doubleField;
+
+        @Column
+        public int intField;
+
+        @Column
+        public boolean booleanField;
+    }
+
+    /**
+     * Mock model to test joins with same names. Extends from
+     * ParentJoinMockModel to have the same columns. Have a relationship with
+     * ParentJoinMockModel to make te join query.
+     */
+    @Table(name = "ChildMockModel")
+    public static class ChildMockModel extends ParentJoinMockModel
+    {
+        @Column
+        ParentJoinMockModel parent;
+    }
 }
diff --git a/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java b/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java
index 60d05219..abe7cca5 100644
--- a/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java
+++ b/tests/src/com/activeandroid/test/automigration/AddColumnsTest.java
@@ -1,7 +1,5 @@
 package com.activeandroid.test.automigration;
 
-import java.util.List;
-
 import android.database.Cursor;
 
 import com.activeandroid.sebbia.ActiveAndroid;
@@ -10,48 +8,56 @@
 import com.activeandroid.sebbia.annotation.Table;
 import com.activeandroid.sebbia.query.Select;
 
-public class AddColumnsTest extends AutoMigrationTest {
-	
-	private static final String TABLE = "add_column_model";
-
-	@Table(name = TABLE)
-	public static class AddColumnMigrationModel extends Model {
-		@Column(name = "textValue")		
-		public String textValue;
-		@Column(name = "boolValue")
-		public boolean boolValue;
-		@Column(name = "floatValue")
-		public float floatValue;
-		@Column(name = "newString")
-		public String newString;
-		@Column(name = "newFloat")
-		public float newFloat;
-		
-		public AddColumnMigrationModel() {
-
-		}
-	}
-	
-	public AddColumnsTest() {
-		super(TABLE);
-	}
-	
-	public void testMigrationNewFieldsAdded() {
-		createOldDatabase();
-		initializeActiveAndroid(AddColumnMigrationModel.class);
-		List<AddColumnMigrationModel> migrationModels = new Select().from(AddColumnMigrationModel.class).execute();
-		assertEquals(10, migrationModels.size());
-		for (int i = 0; i < 10; ++i) {
-			AddColumnMigrationModel migrationModel = migrationModels.get(i);
-			assertEquals(Long.valueOf(i + 1), migrationModel.getId());
-			assertEquals("Text " + i, migrationModel.textValue);
-			assertEquals(i % 2 == 0, migrationModel.boolValue);
-			assertEquals((float) i, migrationModel.floatValue);
-			assertNull(migrationModel.newString);
-		}
-		
-		Cursor cursor = ActiveAndroid.getDatabase().query(TABLE, null, null, null, null, null, null);
-		assertTrue(cursor.getColumnIndex("unusedColumn") != -1);
-	}
-	
+import java.util.List;
+
+public class AddColumnsTest extends AutoMigrationTest
+{
+
+    private static final String TABLE = "add_column_model";
+
+    @Table(name = TABLE)
+    public static class AddColumnMigrationModel extends Model
+    {
+        @Column(name = "textValue")
+        public String  textValue;
+        @Column(name = "boolValue")
+        public boolean boolValue;
+        @Column(name = "floatValue")
+        public float   floatValue;
+        @Column(name = "newString")
+        public String  newString;
+        @Column(name = "newFloat")
+        public float   newFloat;
+
+        public AddColumnMigrationModel()
+        {
+
+        }
+    }
+
+    public AddColumnsTest()
+    {
+        super(TABLE);
+    }
+
+    public void testMigrationNewFieldsAdded()
+    {
+        createOldDatabase();
+        initializeActiveAndroid(AddColumnMigrationModel.class);
+        List<AddColumnMigrationModel> migrationModels = new Select().from(AddColumnMigrationModel.class).execute("test");
+        assertEquals(10, migrationModels.size());
+        for (int i = 0; i < 10; ++i)
+        {
+            AddColumnMigrationModel migrationModel = migrationModels.get(i);
+            assertEquals(Long.valueOf(i + 1), migrationModel.getId());
+            assertEquals("Text " + i, migrationModel.textValue);
+            assertEquals(i % 2 == 0, migrationModel.boolValue);
+            assertEquals((float) i, migrationModel.floatValue);
+            assertNull(migrationModel.newString);
+        }
+
+        Cursor cursor = ActiveAndroid.getDatabase("test").query(TABLE, null, null, null, null, null, null);
+        assertTrue(cursor.getColumnIndex("unusedColumn") != -1);
+    }
+
 }
diff --git a/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java b/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java
index 2501bc3c..f8d404ea 100644
--- a/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java
+++ b/tests/src/com/activeandroid/test/automigration/AddUniqueNotNullTest.java
@@ -1,7 +1,5 @@
 package com.activeandroid.test.automigration;
 
-import java.util.List;
-
 import android.database.Cursor;
 
 import com.activeandroid.sebbia.ActiveAndroid;
@@ -10,44 +8,52 @@
 import com.activeandroid.sebbia.annotation.Table;
 import com.activeandroid.sebbia.query.Select;
 
-public class AddUniqueNotNullTest extends AutoMigrationTest {
-	
-	private static final String TABLE = "add_unique_table";
-	
-	@Table(name = TABLE)
-	public static class AddUniqueMigrationModel extends Model {
-		@Column(name = "textValue", notNull = true, unique = true)		
-		public String textValue;
-		@Column(name = "boolValue")
-		public boolean boolValue;
-		@Column(name = "floatValue")
-		public float floatValue;
-		
-		public AddUniqueMigrationModel() {
-
-		}
-	}
-	
-	public AddUniqueNotNullTest() {
-		super(TABLE);
-	}
-		
-	public void testMigrationUniqueNotNullFieldAdded() {
-		createOldDatabase();
-		initializeActiveAndroid(AddUniqueMigrationModel.class);
-		List<AddUniqueMigrationModel> migrationModels = new Select().from(AddUniqueMigrationModel.class).execute();
-		assertEquals(10, migrationModels.size());
-		for (int i = 0; i < 10; ++i) {
-			AddUniqueMigrationModel migrationModel = migrationModels.get(i);
-			assertEquals(Long.valueOf(i + 1), migrationModel.getId());
-			assertEquals("Text " + i, migrationModel.textValue);
-			assertEquals(i % 2 == 0, migrationModel.boolValue);
-			assertEquals((float) i, migrationModel.floatValue);
-		}
-		
-		Cursor cursor = ActiveAndroid.getDatabase().query(TABLE, null, null, null, null, null, null);
-		assertTrue(cursor.getColumnIndex("unusedColumn") == -1);
-	}
-	
-	
+import java.util.List;
+
+public class AddUniqueNotNullTest extends AutoMigrationTest
+{
+
+    private static final String TABLE = "add_unique_table";
+
+    @Table(name = TABLE)
+    public static class AddUniqueMigrationModel extends Model
+    {
+        @Column(name = "textValue", notNull = true, unique = true)
+        public String  textValue;
+        @Column(name = "boolValue")
+        public boolean boolValue;
+        @Column(name = "floatValue")
+        public float   floatValue;
+
+        public AddUniqueMigrationModel()
+        {
+
+        }
+    }
+
+    public AddUniqueNotNullTest()
+    {
+        super(TABLE);
+    }
+
+    public void testMigrationUniqueNotNullFieldAdded()
+    {
+        createOldDatabase();
+        initializeActiveAndroid(AddUniqueMigrationModel.class);
+        List<AddUniqueMigrationModel> migrationModels = new Select().from(AddUniqueMigrationModel.class).execute("test");
+        assertEquals(10, migrationModels.size());
+        for (int i = 0; i < 10; ++i)
+        {
+            AddUniqueMigrationModel migrationModel = migrationModels.get(i);
+            assertEquals(Long.valueOf(i + 1), migrationModel.getId());
+            assertEquals("Text " + i, migrationModel.textValue);
+            assertEquals(i % 2 == 0, migrationModel.boolValue);
+            assertEquals((float) i, migrationModel.floatValue);
+        }
+
+        Cursor cursor = ActiveAndroid.getDatabase("test").query(TABLE, null, null, null, null, null, null);
+        assertTrue(cursor.getColumnIndex("unusedColumn") == -1);
+    }
+
+
 }
diff --git a/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java b/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java
index 7d1b5bf2..ce2a2ecc 100644
--- a/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java
+++ b/tests/src/com/activeandroid/test/automigration/AutoMigrationTest.java
@@ -9,64 +9,87 @@
 import com.activeandroid.sebbia.Configuration;
 import com.activeandroid.sebbia.Model;
 
-public abstract class AutoMigrationTest extends ApplicationTestCase<Application> {
+public abstract class AutoMigrationTest extends ApplicationTestCase<Application>
+{
 
-	protected static final String DATABASE = "auto_migration.db";
+    protected static final String DATABASE = "auto_migration.db";
 
-	private String mTable;
+    private String mTable;
 
-	public AutoMigrationTest(String table) {
-		super(Application.class);
-		this.mTable = table;
-	}
+    public AutoMigrationTest(String table)
+    {
+        super(Application.class);
+        this.mTable = table;
+    }
 
-	@Override
-	protected void setUp() throws Exception {
-		super.setUp();
-		createApplication();
-	}
+    @Override
+    protected void setUp() throws Exception
+    {
+        super.setUp();
+        createApplication();
+    }
 
-	protected void initializeActiveAndroid(Class<? extends Model> clazz) {
-		ActiveAndroid.initialize(new Configuration.Builder(getApplication()).addModelClass(clazz).setDatabaseName(DATABASE).setDatabaseVersion(3).create(), true);
-	}
+    protected void initializeActiveAndroid(Class<? extends Model> clazz)
+    {
+        ActiveAndroid.initialize(new Configuration.Builder(getApplication()).addModelClass(clazz).setDatabaseName(DATABASE).setDatabaseVersion(3).create(), true);
+    }
 
-	protected void createOldDatabase() {
-		ActiveAndroid.dispose();
-		getApplication().deleteDatabase(DATABASE);
-		SQLiteDatabase db = getApplication().openOrCreateDatabase(DATABASE, 0, null);
-		db.execSQL("PRAGMA user_version = 2");
-		db.execSQL("CREATE TABLE " + mTable + " (Id INTEGER PRIMARY KEY AUTOINCREMENT, textValue TEXT, boolValue INTEGER, floatValue REAL, unusedColumn INTEGER);");
-		db.beginTransaction();
-		try {
-			for (int i = 0; i < 10; ++i) {
-				db.insert(mTable, null, getContentValues("textValue", "Text " + i, "boolValue", i % 2 == 0, "floatValue", (float) i, "unusedColumn", i * 100));
-			}
-			db.setTransactionSuccessful();
-		} finally {
-			db.endTransaction();
-		}
-	}
+    protected void createOldDatabase()
+    {
+        ActiveAndroid.dispose();
+        getApplication().deleteDatabase(DATABASE);
+        SQLiteDatabase db = getApplication().openOrCreateDatabase(DATABASE, 0, null);
+        db.execSQL("PRAGMA user_version = 2");
+        db.execSQL("CREATE TABLE " + mTable + " (Id INTEGER PRIMARY KEY AUTOINCREMENT, textValue TEXT, boolValue INTEGER, floatValue REAL, unusedColumn INTEGER);");
+        db.beginTransaction();
+        try
+        {
+            for (int i = 0; i < 10; ++i)
+            {
+                db.insert(mTable, null, getContentValues("textValue", "Text " + i, "boolValue", i % 2 == 0, "floatValue", (float) i, "unusedColumn", i * 100));
+            }
+            db.setTransactionSuccessful();
+        }
+        finally
+        {
+            db.endTransaction();
+        }
+    }
 
-	private ContentValues getContentValues(Object... args) {
-		assertTrue(args.length % 2 == 0);
-		ContentValues contentValues = new ContentValues();
-		for (int i = 0; i < args.length / 2; ++i) {
-			String key = (String) args[i * 2];
-			Object value = args[(i * 2) + 1];
-			if (value instanceof Float)
-				contentValues.put(key, (Float) value);
-			else if (value instanceof String)
-				contentValues.put(key, (String) value);
-			else if (value instanceof Integer)
-				contentValues.put(key, (Integer) value);
-			else if (value instanceof Long)
-				contentValues.put(key, (Long) value);
-			else if (value instanceof Double)
-				contentValues.put(key, (Double) value);
-			else if (value instanceof Boolean)
-				contentValues.put(key, (Boolean) value);
-		}
-		return contentValues;
-	}
+    private ContentValues getContentValues(Object... args)
+    {
+        assertTrue(args.length % 2 == 0);
+        ContentValues contentValues = new ContentValues();
+        for (int i = 0; i < args.length / 2; ++i)
+        {
+            String key = (String) args[i * 2];
+            Object value = args[(i * 2) + 1];
+            if (value instanceof Float)
+            {
+                contentValues.put(key, (Float) value);
+            }
+            else if (value instanceof String)
+            {
+                contentValues.put(key, (String) value);
+            }
+            else if (value instanceof Integer)
+            {
+                contentValues.put(key, (Integer) value);
+            }
+            else if (value instanceof Long)
+            {
+                contentValues.put(key, (Long) value);
+            }
+            else if (value instanceof Double)
+            {
+                contentValues.put(key, (Double) value);
+            }
+            else if (value instanceof Boolean)
+            {
+                contentValues.put(key, (Boolean) value);
+            }
+        }
+        return contentValues;
+    }
 
 }
diff --git a/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java b/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java
index 4c6cb22c..ea398cfd 100644
--- a/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java
+++ b/tests/src/com/activeandroid/test/automigration/ChangeTypeTest.java
@@ -5,44 +5,52 @@
 import com.activeandroid.sebbia.annotation.Table;
 import com.activeandroid.sebbia.automigration.AutoMigration;
 
-public class ChangeTypeTest extends AutoMigrationTest {
-	
-	private static final String TABLE = "change_type_model";
-
-	@Table(name = TABLE)
-	public static class AddColumnMigrationModel extends Model {
-		@Column(name = "textValue")		
-		public boolean textValue;
-		@Column(name = "boolValue")
-		public boolean boolValue;
-		@Column(name = "floatValue")
-		public float floatValue;
-		@Column(name = "newString")
-		public String newString;
-		@Column(name = "newFloat")
-		public float newFloat;
-		
-		public AddColumnMigrationModel() {
-
-		}
-	}
-	
-	public ChangeTypeTest() {
-		super(TABLE);
-	}
-	
-	public void testMigrationNewFieldsAdded() {
-		createOldDatabase();
-		try {
-			initializeActiveAndroid(AddColumnMigrationModel.class);
-		} catch (Exception e) {
-			assertEquals(AutoMigration.IncompatibleColumnTypesException.class, e.getClass());
-			assertTrue(e.getMessage().contains("textValue"));
-			assertTrue(e.getMessage().contains("TEXT"));
-			assertTrue(e.getMessage().contains("INTEGER"));
-			assertTrue(e.getMessage().contains(TABLE));
-			return;
-		}
-		fail("Exception was not thrown during auto migration");
-	}
+public class ChangeTypeTest extends AutoMigrationTest
+{
+
+    private static final String TABLE = "change_type_model";
+
+    @Table(name = TABLE)
+    public static class AddColumnMigrationModel extends Model
+    {
+        @Column(name = "textValue")
+        public boolean textValue;
+        @Column(name = "boolValue")
+        public boolean boolValue;
+        @Column(name = "floatValue")
+        public float   floatValue;
+        @Column(name = "newString")
+        public String  newString;
+        @Column(name = "newFloat")
+        public float   newFloat;
+
+        public AddColumnMigrationModel()
+        {
+
+        }
+    }
+
+    public ChangeTypeTest()
+    {
+        super(TABLE);
+    }
+
+    public void testMigrationNewFieldsAdded()
+    {
+        createOldDatabase();
+        try
+        {
+            initializeActiveAndroid(AddColumnMigrationModel.class);
+        }
+        catch (Exception e)
+        {
+            assertEquals(AutoMigration.IncompatibleColumnTypesException.class, e.getClass());
+            assertTrue(e.getMessage().contains("textValue"));
+            assertTrue(e.getMessage().contains("TEXT"));
+            assertTrue(e.getMessage().contains("INTEGER"));
+            assertTrue(e.getMessage().contains(TABLE));
+            return;
+        }
+        fail("Exception was not thrown during auto migration");
+    }
 }
diff --git a/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java b/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java
index 29b47482..f85f6ca3 100644
--- a/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java
+++ b/tests/src/com/activeandroid/test/automigration/DefaultValueMigrationTest.java
@@ -1,7 +1,5 @@
 package com.activeandroid.test.automigration;
 
-import java.util.List;
-
 import android.database.Cursor;
 
 import com.activeandroid.sebbia.ActiveAndroid;
@@ -10,45 +8,53 @@
 import com.activeandroid.sebbia.annotation.Table;
 import com.activeandroid.sebbia.query.Select;
 
-public class DefaultValueMigrationTest extends AutoMigrationTest {
-	private static final String TABLE = "default_value_migration";
-	
-	@Table(name = TABLE)
-	public static class DefaultValueMigrationModel extends Model {
-		@Column(name = "textValue")		
-		public String textValue;
-		@Column(name = "boolValue")
-		public boolean boolValue;
-		@Column(name = "floatValue")
-		public float floatValue;
-		@Column(name = "defaultValue", defaultValue = "some_value")
-		public String defaultValue;
-			
-		public DefaultValueMigrationModel() {
-
-		}
-	}
-	
-	public DefaultValueMigrationTest() {
-		super(TABLE);
-	}
-	
-	public void testDefaultValueMigrationTest() {
-		createOldDatabase();
-		initializeActiveAndroid(DefaultValueMigrationModel.class);
-		List<DefaultValueMigrationModel> migrationModels = new Select().from(DefaultValueMigrationModel.class).execute();
-		assertEquals(10, migrationModels.size());
-		for (int i = 0; i < 10; ++i) {
-			DefaultValueMigrationModel migrationModel = migrationModels.get(i);
-			assertEquals(Long.valueOf(i + 1), migrationModel.getId());
-			assertEquals("Text " + i, migrationModel.textValue);
-			assertEquals(i % 2 == 0, migrationModel.boolValue);
-			assertEquals((float) i, migrationModel.floatValue);
-			assertEquals("some_value", migrationModel.defaultValue);
-		}
-		
-		Cursor cursor = ActiveAndroid.getDatabase().query(TABLE, null, null, null, null, null, null);
-		assertTrue(cursor.getColumnIndex("unusedColumn") != -1);
-	}
+import java.util.List;
+
+public class DefaultValueMigrationTest extends AutoMigrationTest
+{
+    private static final String TABLE = "default_value_migration";
+
+    @Table(name = TABLE)
+    public static class DefaultValueMigrationModel extends Model
+    {
+        @Column(name = "textValue")
+        public String  textValue;
+        @Column(name = "boolValue")
+        public boolean boolValue;
+        @Column(name = "floatValue")
+        public float   floatValue;
+        @Column(name = "defaultValue", defaultValue = "some_value")
+        public String  defaultValue;
+
+        public DefaultValueMigrationModel()
+        {
+
+        }
+    }
+
+    public DefaultValueMigrationTest()
+    {
+        super(TABLE);
+    }
+
+    public void testDefaultValueMigrationTest()
+    {
+        createOldDatabase();
+        initializeActiveAndroid(DefaultValueMigrationModel.class);
+        List<DefaultValueMigrationModel> migrationModels = new Select().from(DefaultValueMigrationModel.class).execute("test");
+        assertEquals(10, migrationModels.size());
+        for (int i = 0; i < 10; ++i)
+        {
+            DefaultValueMigrationModel migrationModel = migrationModels.get(i);
+            assertEquals(Long.valueOf(i + 1), migrationModel.getId());
+            assertEquals("Text " + i, migrationModel.textValue);
+            assertEquals(i % 2 == 0, migrationModel.boolValue);
+            assertEquals((float) i, migrationModel.floatValue);
+            assertEquals("some_value", migrationModel.defaultValue);
+        }
+
+        Cursor cursor = ActiveAndroid.getDatabase("test").query(TABLE, null, null, null, null, null, null);
+        assertTrue(cursor.getColumnIndex("unusedColumn") != -1);
+    }
 
 }
diff --git a/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java b/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java
index 913cbdeb..ce865cf9 100644
--- a/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java
+++ b/tests/src/com/activeandroid/test/automigration/SQLColumnInfoTest.java
@@ -3,30 +3,36 @@
 import com.activeandroid.sebbia.automigration.SQLColumnInfo;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
-public class SQLColumnInfoTest extends ActiveAndroidTestCase {
-	
-	public void testPrimaryKey() {
-		SQLColumnInfo sqlColumnInfo = new SQLColumnInfo("id integer primary key");
-		assertTrue(sqlColumnInfo.isPrimaryKey());
-	}
-	
-	public void testNoPrimaryKey() {
-		SQLColumnInfo sqlColumnInfo = new SQLColumnInfo("id integer key");
-		assertFalse(sqlColumnInfo.isPrimaryKey());
-	}
-	
-	public void testUniqueInName() {
-		SQLColumnInfo sqlColumnInfo = new SQLColumnInfo("unique_id integer");
-		assertFalse(sqlColumnInfo.isUnique());
-	}
-	
-	public void testUnique() {
-		SQLColumnInfo sqlColumnInfo = new SQLColumnInfo("id integer unique on conflict replace");
-		assertTrue(sqlColumnInfo.isUnique());
-	}
-	
-	public void testNotUnique() {
-		SQLColumnInfo sqlColumnInfo = new SQLColumnInfo("unique_id text not null default \"not null\"");
-		assertFalse(sqlColumnInfo.isUnique());
-	}
+public class SQLColumnInfoTest extends ActiveAndroidTestCase
+{
+
+    public void testPrimaryKey()
+    {
+        SQLColumnInfo sqlColumnInfo = new SQLColumnInfo("id integer primary key");
+        assertTrue(sqlColumnInfo.isPrimaryKey());
+    }
+
+    public void testNoPrimaryKey()
+    {
+        SQLColumnInfo sqlColumnInfo = new SQLColumnInfo("id integer key");
+        assertFalse(sqlColumnInfo.isPrimaryKey());
+    }
+
+    public void testUniqueInName()
+    {
+        SQLColumnInfo sqlColumnInfo = new SQLColumnInfo("unique_id integer");
+        assertFalse(sqlColumnInfo.isUnique());
+    }
+
+    public void testUnique()
+    {
+        SQLColumnInfo sqlColumnInfo = new SQLColumnInfo("id integer unique on conflict replace");
+        assertTrue(sqlColumnInfo.isUnique());
+    }
+
+    public void testNotUnique()
+    {
+        SQLColumnInfo sqlColumnInfo = new SQLColumnInfo("unique_id text not null default \"not null\"");
+        assertFalse(sqlColumnInfo.isUnique());
+    }
 }
diff --git a/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java b/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java
index 2cd5e39f..6e37d0f1 100644
--- a/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java
+++ b/tests/src/com/activeandroid/test/automigration/SQLTableInfoTest.java
@@ -5,78 +5,98 @@
 import com.activeandroid.sebbia.util.SQLiteUtils.SQLiteType;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
-public class SQLTableInfoTest extends ActiveAndroidTestCase {
-	
-	public void testEmptyParam() {
-		try {
-			new SQLTableInfo(""); 
-		} catch (IllegalArgumentException e) {
-			assertTrue(e.getMessage().contains("empty"));
-			return;
-		}
-		fail(IllegalArgumentException.class.getSimpleName() + " was not thrown");
-	}
-	
-	public void testInvalidSchema() {
-		try {
-			new SQLTableInfo("test(id integer primary key);"); 
-		} catch (IllegalArgumentException e) {
-			assertTrue(e.getMessage().contains("valid"));
-			return;
-		}
-		fail(IllegalArgumentException.class.getSimpleName() + " was not thrown");
-	}
-	
-	public void testInvalidSchemaNoBrackets() {
-		try {
-			new SQLTableInfo("create table test;"); 
-		} catch (IllegalArgumentException e) {
-			assertTrue(e.getMessage().contains("valid"));
-			return;
-		}
-		fail(IllegalArgumentException.class.getSimpleName() + " was not thrown");
-	}
-	
-	public void testTableName() {
-		SQLTableInfo sqlTableInfo = new SQLTableInfo("create table \"test\"(id integer);");
-		assertEquals("test", sqlTableInfo.getTableName());
-	}
-	
-	public void testTableWithoutPrimaryKey() {
-		SQLTableInfo sqlTableInfo = new SQLTableInfo("create table test(id integer);");
-		assertNull(sqlTableInfo.getIdColumnInfo());
-	}
-	
-	public void testTableWithMultipleSpaces() {
-		SQLTableInfo sqlTableInfo = new SQLTableInfo("create    table    test(id    integer     primary    key);");
-		assertNotNull(sqlTableInfo.getIdColumnInfo());
-		verifyColumn(sqlTableInfo.getIdColumnInfo(), "id", SQLiteType.INTEGER);
-	}
-	
-	public void testTableWithPrimaryKey() {
-		SQLTableInfo sqlTableInfo = new SQLTableInfo("create table test(id integer primary key);");
-		assertNotNull(sqlTableInfo.getIdColumnInfo());
-		verifyColumn(sqlTableInfo.getIdColumnInfo(), "id", SQLiteType.INTEGER);
-	}
-	
-	public void testMultipleColumnsWithoutPrimaryKey() {
-		SQLTableInfo sqlTableInfo = new SQLTableInfo("CREATE TABLE test(id integer key, my_value TEXT, boolean_value INTEGER);");
-		assertNull(sqlTableInfo.getIdColumnInfo());
-		assertTrue(sqlTableInfo.getColumns().size() == 3);
-		verifyColumn(sqlTableInfo.getColumns().get(0), "id", SQLiteType.INTEGER);
-		verifyColumn(sqlTableInfo.getColumns().get(1), "my_value", SQLiteType.TEXT);
-		verifyColumn(sqlTableInfo.getColumns().get(2), "boolean_value", SQLiteType.INTEGER);
-	}
-	
-	public void testCreateSchema() {
-		String sqlSchema = "CREATE TABLE test(id integer key, my_value TEXT, boolean_value INTEGER);";
-		SQLTableInfo sqlTableInfo = new SQLTableInfo(sqlSchema);
-		String createdSchema = SQLTableInfo.constructSchema(sqlTableInfo.getTableName(), sqlTableInfo.getColumns()); 
-		assertTrue(createdSchema.equalsIgnoreCase(sqlSchema));
-	}
-	
-	private void verifyColumn(SQLColumnInfo columnInfo, String name, SQLiteType type) {
-		assertEquals(name, columnInfo.getName());
-		assertEquals(type, columnInfo.getType());
-	}
+public class SQLTableInfoTest extends ActiveAndroidTestCase
+{
+
+    public void testEmptyParam()
+    {
+        try
+        {
+            new SQLTableInfo("");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertTrue(e.getMessage().contains("empty"));
+            return;
+        }
+        fail(IllegalArgumentException.class.getSimpleName() + " was not thrown");
+    }
+
+    public void testInvalidSchema()
+    {
+        try
+        {
+            new SQLTableInfo("test(id integer primary key);");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertTrue(e.getMessage().contains("valid"));
+            return;
+        }
+        fail(IllegalArgumentException.class.getSimpleName() + " was not thrown");
+    }
+
+    public void testInvalidSchemaNoBrackets()
+    {
+        try
+        {
+            new SQLTableInfo("create table test;");
+        }
+        catch (IllegalArgumentException e)
+        {
+            assertTrue(e.getMessage().contains("valid"));
+            return;
+        }
+        fail(IllegalArgumentException.class.getSimpleName() + " was not thrown");
+    }
+
+    public void testTableName()
+    {
+        SQLTableInfo sqlTableInfo = new SQLTableInfo("create table \"test\"(id integer);");
+        assertEquals("test", sqlTableInfo.getTableName());
+    }
+
+    public void testTableWithoutPrimaryKey()
+    {
+        SQLTableInfo sqlTableInfo = new SQLTableInfo("create table test(id integer);");
+        assertNull(sqlTableInfo.getIdColumnInfo());
+    }
+
+    public void testTableWithMultipleSpaces()
+    {
+        SQLTableInfo sqlTableInfo = new SQLTableInfo("create    table    test(id    integer     primary    key);");
+        assertNotNull(sqlTableInfo.getIdColumnInfo());
+        verifyColumn(sqlTableInfo.getIdColumnInfo(), "id", SQLiteType.INTEGER);
+    }
+
+    public void testTableWithPrimaryKey()
+    {
+        SQLTableInfo sqlTableInfo = new SQLTableInfo("create table test(id integer primary key);");
+        assertNotNull(sqlTableInfo.getIdColumnInfo());
+        verifyColumn(sqlTableInfo.getIdColumnInfo(), "id", SQLiteType.INTEGER);
+    }
+
+    public void testMultipleColumnsWithoutPrimaryKey()
+    {
+        SQLTableInfo sqlTableInfo = new SQLTableInfo("CREATE TABLE test(id integer key, my_value TEXT, boolean_value INTEGER);");
+        assertNull(sqlTableInfo.getIdColumnInfo());
+        assertTrue(sqlTableInfo.getColumns().size() == 3);
+        verifyColumn(sqlTableInfo.getColumns().get(0), "id", SQLiteType.INTEGER);
+        verifyColumn(sqlTableInfo.getColumns().get(1), "my_value", SQLiteType.TEXT);
+        verifyColumn(sqlTableInfo.getColumns().get(2), "boolean_value", SQLiteType.INTEGER);
+    }
+
+    public void testCreateSchema()
+    {
+        String       sqlSchema     = "CREATE TABLE test(id integer key, my_value TEXT, boolean_value INTEGER);";
+        SQLTableInfo sqlTableInfo  = new SQLTableInfo(sqlSchema);
+        String       createdSchema = SQLTableInfo.constructSchema(sqlTableInfo.getTableName(), sqlTableInfo.getColumns());
+        assertTrue(createdSchema.equalsIgnoreCase(sqlSchema));
+    }
+
+    private void verifyColumn(SQLColumnInfo columnInfo, String name, SQLiteType type)
+    {
+        assertEquals(name, columnInfo.getName());
+        assertEquals(type, columnInfo.getType());
+    }
 }
diff --git a/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java b/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java
index 1606e86a..87499291 100644
--- a/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java
+++ b/tests/src/com/activeandroid/test/model/DoNotGenerateTest.java
@@ -1,39 +1,44 @@
 package com.activeandroid.test.model;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import com.activeandroid.sebbia.Model;
 import com.activeandroid.sebbia.annotation.Column;
 import com.activeandroid.sebbia.annotation.DoNotGenerate;
 import com.activeandroid.sebbia.query.Select;
 
-public class DoNotGenerateTest extends ModelTestCase {
-	
-	@DoNotGenerate
-	public static class DoNotGenerateModel extends Model {
-		
-		@Column(name = "value")
-		private String value;
-	}
-
-	public void testNoGenerate() {
-		List<DoNotGenerateModel> impls = new ArrayList<DoNotGenerateModel>();
-		for (int i = 0; i < 100; ++i) {
-			DoNotGenerateModel model = new DoNotGenerateModel();
-			model.value = Integer.toString(i);
-			impls.add(model);
-		}
-		
-		Model.saveMultiple(impls);
-		
-		impls = new Select().from(DoNotGenerateModel.class).execute();
-		assertEquals(100, impls.size());
-		for (int i = 0; i < impls.size(); ++i) {
-			DoNotGenerateModel impl = impls.get(i);
-			assertNotNull(impl);
-			assertNotNull(impl.value);
-			assertTrue(impl.value.equalsIgnoreCase(Integer.toString(i)));
-		}
-	}
+import java.util.ArrayList;
+import java.util.List;
+
+public class DoNotGenerateTest extends ModelTestCase
+{
+
+    @DoNotGenerate
+    public static class DoNotGenerateModel extends Model
+    {
+
+        @Column(name = "value")
+        private String value;
+    }
+
+    public void testNoGenerate()
+    {
+        List<DoNotGenerateModel> impls = new ArrayList<DoNotGenerateModel>();
+        for (int i = 0; i < 100; ++i)
+        {
+            DoNotGenerateModel model = new DoNotGenerateModel();
+            model.value = Integer.toString(i);
+            impls.add(model);
+        }
+
+        Model.saveMultiple("test", impls);
+
+        impls = new Select().from(DoNotGenerateModel.class).execute("test");
+        assertEquals(100, impls.size());
+        for (int i = 0; i < impls.size(); ++i)
+        {
+            DoNotGenerateModel impl = impls.get(i);
+            assertNotNull(impl);
+            assertNotNull(impl.value);
+            assertTrue(impl.value.equalsIgnoreCase(Integer.toString(i)));
+        }
+    }
 }
diff --git a/tests/src/com/activeandroid/test/model/EnumTest.java b/tests/src/com/activeandroid/test/model/EnumTest.java
index d253c09d..89942f22 100644
--- a/tests/src/com/activeandroid/test/model/EnumTest.java
+++ b/tests/src/com/activeandroid/test/model/EnumTest.java
@@ -1,8 +1,5 @@
 package com.activeandroid.test.model;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import android.database.Cursor;
 
 import com.activeandroid.sebbia.ActiveAndroid;
@@ -13,44 +10,56 @@
 import com.activeandroid.sebbia.annotation.Table;
 import com.activeandroid.sebbia.query.Delete;
 
-public class EnumTest extends ModelTestCase {
-
-	public enum Enumeration {
-		TYPE_A,
-		TYPE_B,
-		TYPE_C
-	}
-
-	@Table(name = "enum_model")
-	public static class EnumModel extends Model {
-
-		@Column(name = "enum")
-		Enumeration enumeration;
-
-		public EnumModel() {
-
-		}
-
-		public EnumModel(Enumeration enumeration) {
-			super();
-			this.enumeration = enumeration;
-		}
-
-	}
-
-	public void testEnumSaving() {
-		new Delete().from(EnumModel.class).execute();
-		List<EnumModel> models = new ArrayList<EnumModel>();
-		for (Enumeration enumeration : Enumeration.values()) 
-			models.add(new EnumModel(enumeration));
-		
-		Model.saveMultiple(models);
-		
-		TableInfo tableInfo = Cache.getTableInfo(EnumModel.class);
-		Cursor cursor = ActiveAndroid.getDatabase().query(tableInfo.getTableName(), new String[] {"enum"}, null, null, null, null, null);
-		while (cursor.moveToNext()) {
-			assertTrue(cursor.getString(0).equals(Enumeration.values()[cursor.getPosition()]));
-		}
-		cursor.close();
-	}
+import java.util.ArrayList;
+import java.util.List;
+
+public class EnumTest extends ModelTestCase
+{
+
+    public enum Enumeration
+    {
+        TYPE_A,
+        TYPE_B,
+        TYPE_C
+    }
+
+    @Table(name = "enum_model")
+    public static class EnumModel extends Model
+    {
+
+        @Column(name = "enum")
+        Enumeration enumeration;
+
+        public EnumModel()
+        {
+
+        }
+
+        public EnumModel(Enumeration enumeration)
+        {
+            super();
+            this.enumeration = enumeration;
+        }
+
+    }
+
+    public void testEnumSaving()
+    {
+        new Delete().from(EnumModel.class).execute("test");
+        List<EnumModel> models = new ArrayList<EnumModel>();
+        for (Enumeration enumeration : Enumeration.values())
+        {
+            models.add(new EnumModel(enumeration));
+        }
+
+        Model.saveMultiple("test", models);
+
+        TableInfo tableInfo = Cache.getTableInfo(EnumModel.class);
+        Cursor    cursor    = ActiveAndroid.getDatabase("test").query(tableInfo.getTableName(), new String[]{"enum"}, null, null, null, null, null);
+        while (cursor.moveToNext())
+        {
+            assertTrue(cursor.getString(0).equals(Enumeration.values()[cursor.getPosition()]));
+        }
+        cursor.close();
+    }
 }
diff --git a/tests/src/com/activeandroid/test/model/ManyToManyTest.java b/tests/src/com/activeandroid/test/model/ManyToManyTest.java
index 1604af47..f8476439 100644
--- a/tests/src/com/activeandroid/test/model/ManyToManyTest.java
+++ b/tests/src/com/activeandroid/test/model/ManyToManyTest.java
@@ -1,78 +1,93 @@
 package com.activeandroid.test.model;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import com.activeandroid.sebbia.Model;
 import com.activeandroid.sebbia.model.ManyToManyRelation;
 import com.activeandroid.test.MockModel;
 
-public class ManyToManyTest extends ModelTestCase {
-	
-	public static class MockModelList extends MockModel {
-		
-	}
-	
-	public static class MockManyToManyRelation extends ManyToManyRelation<MockModelList, MockModel> {
+import java.util.ArrayList;
+import java.util.List;
+
+public class ManyToManyTest extends ModelTestCase
+{
+
+    public static class MockModelList extends MockModel
+    {
+
+    }
+
+    public static class MockManyToManyRelation extends ManyToManyRelation<MockModelList, MockModel>
+    {
+
+        @Override
+        public Class<MockModelList> getEntity1Class()
+        {
+            return MockModelList.class;
+        }
+
+        @Override
+        public Class<MockModel> getEntity2Class()
+        {
+            return MockModel.class;
+        }
+    }
+
+    public void testManyToManyRelationForward() throws Exception
+    {
+        List<MockModel>     mockModels     = createChildEntities(MockModel.class);
+        List<MockModelList> mockModelLists = new ArrayList<ManyToManyTest.MockModelList>();
+        for (int i = 0; i < 3; ++i)
+        {
+            MockModelList mockModelList = new MockModelList();
+            mockModelList.save("test");
+            ManyToManyRelation.setRelationsFront("test", MockManyToManyRelation.class, mockModelList, mockModels);
+            mockModelLists.add(mockModelList);
+        }
+
+        for (MockModelList list : mockModelLists)
+        {
+            verifyMockModels(ManyToManyRelation.getRelationsFront("test", MockManyToManyRelation.class, list), MockModel.class);
+        }
+    }
 
-		@Override
-		public Class<MockModelList> getEntity1Class() {
-			return MockModelList.class;
-		}
+    public void testManyToManyRelationReverse() throws Exception
+    {
+        List<MockModelList> mockModelLists = createChildEntities(MockModelList.class);
+        List<MockModel>     mockModels     = new ArrayList<MockModel>();
+        for (int i = 0; i < 3; ++i)
+        {
+            MockModel mockModel = new MockModel();
+            mockModel.save("test");
+            ManyToManyRelation.setRelationsReverse("test", MockManyToManyRelation.class, mockModel, mockModelLists);
+            mockModels.add(mockModel);
+        }
+        for (MockModel mockModel : mockModels)
+        {
+            verifyMockModels(ManyToManyRelation.getRelationsReverse("test", MockManyToManyRelation.class, mockModel), MockModelList.class);
+        }
+    }
 
-		@Override
-		public Class<MockModel> getEntity2Class() {
-			return MockModel.class;
-		}
-	}
-	
-	public void testManyToManyRelationForward() throws Exception {
-		List<MockModel> mockModels = createChildEntities(MockModel.class);
-		List<MockModelList> mockModelLists = new ArrayList<ManyToManyTest.MockModelList>();
-		for (int i = 0; i < 3; ++i) {
-			MockModelList mockModelList = new MockModelList();
-			mockModelList.save();
-			ManyToManyRelation.setRelationsFront(MockManyToManyRelation.class, mockModelList, mockModels);
-			mockModelLists.add(mockModelList);
-		}
-		
-		for (MockModelList list : mockModelLists) {
-			verifyMockModels(ManyToManyRelation.getRelationsFront(MockManyToManyRelation.class, list), MockModel.class);			
-		}
-	}
-	
-	public void testManyToManyRelationReverse() throws Exception {
-		List<MockModelList> mockModelLists = createChildEntities(MockModelList.class);
-		List<MockModel> mockModels = new ArrayList<MockModel>();
-		for (int i = 0; i < 3; ++i) {
-			MockModel mockModel = new MockModel();
-			mockModel.save();
-			ManyToManyRelation.setRelationsReverse(MockManyToManyRelation.class, mockModel, mockModelLists);
-			mockModels.add(mockModel);
-		}
-		for (MockModel mockModel : mockModels) {
-			verifyMockModels(ManyToManyRelation.getRelationsReverse(MockManyToManyRelation.class, mockModel), MockModelList.class);			
-		}
-	}
-		
-	private void verifyMockModels(List<? extends MockModel> mockModels, Class<? extends MockModel> clazz) {
-		assertTrue(mockModels.size() == 5);
-		for (int i = 0; i < 5; ++i) {
-			MockModel mockModel = mockModels.get(i);
-			assertTrue(mockModel.getClass() == clazz);
-			assertTrue(mockModel.intField == i);
-		}
-	}
+    private void verifyMockModels(List<? extends MockModel> mockModels, Class<? extends MockModel> clazz)
+    {
+        assertTrue(mockModels.size() == 5);
+        for (int i = 0; i < 5; ++i)
+        {
+            MockModel mockModel = mockModels.get(i);
+            assertTrue(mockModel.getClass() == clazz);
+            assertTrue(mockModel.intField == i);
+        }
+    }
 
-	@SuppressWarnings("unchecked")
-	private <T extends Model> List<T> createChildEntities(Class<? extends MockModel> clazz) throws IllegalAccessException, InstantiationException {
-		List<T> mockModels = new ArrayList<T>();
-		for (int i = 0; i < 5; ++i) {
-			MockModel mockModel = clazz.newInstance();
-			mockModel.intField = i;
-			mockModel.save();
-			mockModels.add((T) mockModel);
-		}
-		return mockModels;
-	}
+    @SuppressWarnings("unchecked")
+    private <T extends Model> List<T> createChildEntities(Class<? extends MockModel> clazz) throws IllegalAccessException, InstantiationException
+    {
+        List<T> mockModels = new ArrayList<T>();
+        for (int i = 0; i < 5; ++i)
+        {
+            MockModel mockModel = clazz.newInstance();
+            mockModel.intField = i;
+            mockModel.save("test");
+            mockModels.add((T) mockModel);
+        }
+        return mockModels;
+    }
 }
diff --git a/tests/src/com/activeandroid/test/model/ModelTestCase.java b/tests/src/com/activeandroid/test/model/ModelTestCase.java
index 11a38cf0..6e9b5a88 100644
--- a/tests/src/com/activeandroid/test/model/ModelTestCase.java
+++ b/tests/src/com/activeandroid/test/model/ModelTestCase.java
@@ -4,13 +4,15 @@
 import com.activeandroid.sebbia.Configuration;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
-public class ModelTestCase extends ActiveAndroidTestCase {
-	@Override
-	protected void setUp() throws Exception {
-		Configuration configuration = new Configuration.Builder(getContext())
-        .setDatabaseName("model.db")
-        .setDatabaseVersion(3)
-        .create();
-		ActiveAndroid.initialize(configuration, true);
-	}
+public class ModelTestCase extends ActiveAndroidTestCase
+{
+    @Override
+    protected void setUp() throws Exception
+    {
+        Configuration configuration = new Configuration.Builder(getContext())
+                .setDatabaseName("model.db")
+                .setDatabaseVersion(3)
+                .create();
+        ActiveAndroid.initialize(configuration, true);
+    }
 }
diff --git a/tests/src/com/activeandroid/test/model/OneToManyTest.java b/tests/src/com/activeandroid/test/model/OneToManyTest.java
index 9319b13e..336994b4 100644
--- a/tests/src/com/activeandroid/test/model/OneToManyTest.java
+++ b/tests/src/com/activeandroid/test/model/OneToManyTest.java
@@ -1,35 +1,40 @@
 package com.activeandroid.test.model;
 
-import java.util.ArrayList;
-import java.util.List;
-
 import com.activeandroid.sebbia.Model;
 import com.activeandroid.sebbia.model.OneToManyRelation;
 import com.activeandroid.test.MockModel;
 
-public class OneToManyTest extends ModelTestCase {
-	
-	public static class MockOneToManyRelation extends OneToManyRelation<MockModel, Model> {
-		public MockOneToManyRelation() {
-			super();
-		}
-	}
-	
-	public void testOneToManyRelation() {
-		
-		MockModel mockModelsHolder = new MockModel();
-		mockModelsHolder.save();
-		
-		List<Model> mockModels = new ArrayList<Model>();
-		for (int i = 0; i < 5; ++i) {
-			MockModel mockModel = new MockModel();
-			mockModel.save();
-			mockModels.add(mockModel);
-		}
-		
-		OneToManyRelation.setRelations(MockOneToManyRelation.class, mockModelsHolder, mockModels);
-		
-		mockModels = OneToManyRelation.getRelations(MockOneToManyRelation.class, mockModelsHolder);
-		assertTrue(mockModels.size() == 5);
-	}
+import java.util.ArrayList;
+import java.util.List;
+
+public class OneToManyTest extends ModelTestCase
+{
+
+    public static class MockOneToManyRelation extends OneToManyRelation<MockModel, Model>
+    {
+        public MockOneToManyRelation()
+        {
+            super();
+        }
+    }
+
+    public void testOneToManyRelation()
+    {
+
+        MockModel mockModelsHolder = new MockModel();
+        mockModelsHolder.save("test");
+
+        List<Model> mockModels = new ArrayList<Model>();
+        for (int i = 0; i < 5; ++i)
+        {
+            MockModel mockModel = new MockModel();
+            mockModel.save("test");
+            mockModels.add(mockModel);
+        }
+
+        OneToManyRelation.setRelations("test", MockOneToManyRelation.class, mockModelsHolder, mockModels);
+
+        mockModels = OneToManyRelation.getRelations("test", MockOneToManyRelation.class, mockModelsHolder);
+        assertTrue(mockModels.size() == 5);
+    }
 }
diff --git a/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java b/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
index 5f43b2ce..80ef2974 100644
--- a/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
+++ b/tests/src/com/activeandroid/test/parser/ParserConfigurationTest.java
@@ -9,26 +9,31 @@
 import com.activeandroid.test.ActiveAndroidTestCase;
 
 
-public class ParserConfigurationTest extends ActiveAndroidTestCase {
+public class ParserConfigurationTest extends ActiveAndroidTestCase
+{
 
     /**
      * Should try to use the legacy parser by default, which is be unable to handle the SQL script.
      */
-    public void testLegacyMigration() {
+    public void testLegacyMigration()
+    {
 
-        try {
+        try
+        {
             Configuration configuration = new Configuration.Builder(getContext())
                     .setDatabaseName("migration.db")
                     .setDatabaseVersion(2)
                     .create();
 
-            DatabaseHelper helper = new DatabaseHelper(configuration);
+            DatabaseHelper helper = new DatabaseHelper(configuration.getContext(), configuration.getDatabaseName(), configuration.getDatabaseVersion(), configuration.getSqlParser());
             SQLiteDatabase db = helper.getWritableDatabase();
             helper.onUpgrade(db, 1, 2);
 
             fail("Should not be able to parse the SQL script.");
 
-        } catch (SQLException e) {
+        }
+        catch (SQLException e)
+        {
             final String message = e.getMessage();
 
             assertNotNull(message);
@@ -40,15 +45,16 @@ public void testLegacyMigration() {
     /**
      * Should use the new parser if configured to do so.
      */
-    public void testDelimitedMigration() {
+    public void testDelimitedMigration()
+    {
         Configuration configuration = new Configuration.Builder(getContext())
                 .setSqlParser(Configuration.SQL_PARSER_DELIMITED)
                 .setDatabaseName("migration.db")
                 .setDatabaseVersion(2)
                 .create();
 
-        DatabaseHelper helper = new DatabaseHelper(configuration);
-        SQLiteDatabase db = helper.getWritableDatabase();
+        DatabaseHelper helper = new DatabaseHelper(configuration.getContext(), configuration.getDatabaseName(), configuration.getDatabaseVersion(), configuration.getSqlParser());
+        SQLiteDatabase db     = helper.getWritableDatabase();
         helper.onUpgrade(db, 1, 2);
     }
 }
diff --git a/tests/src/com/activeandroid/test/parser/ParserTest.java b/tests/src/com/activeandroid/test/parser/ParserTest.java
index 759e785d..c15ec980 100644
--- a/tests/src/com/activeandroid/test/parser/ParserTest.java
+++ b/tests/src/com/activeandroid/test/parser/ParserTest.java
@@ -10,26 +10,30 @@
 import com.activeandroid.test.R;
 
 
-public class ParserTest extends ActiveAndroidTestCase {
+public class ParserTest extends ActiveAndroidTestCase
+{
 
-    private final String sql1    = "CREATE TABLE Entity1 ( Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, Column1 INTEGER )";
-    private final String sql2    = "CREATE TABLE Entity2 ( Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, Column1 INTEGER )";
+    private final String sql1 = "CREATE TABLE Entity1 ( Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, Column1 INTEGER )";
+    private final String sql2 = "CREATE TABLE Entity2 ( Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, Column1 INTEGER )";
 
     private final String invalid = "CREATE TABLE Entity1 ( Id INTEGER AUTOINCREMENT PRIMARY KEY NOT NULL, */ Column1 INTEGER )";
 
-    private InputStream getStream(int id) {
+    private InputStream getStream(int id)
+    {
         return this.getContext().getResources().openRawResource(id);
     }
 
     /**
      * Should be able to parse a script with two multi-line statments, even if the last statement
      * is not terminated by a semicolon.
+     *
      * @throws IOException
      */
-    public void testTwoStatements() throws IOException {
+    public void testTwoStatements() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.two_statements);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.two_statements);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(2, commands.size());
         assertEquals(sql1, commands.get(0));
@@ -38,12 +42,14 @@ public void testTwoStatements() throws IOException {
 
     /**
      * Should reduce unnecessary whitespace.
+     *
      * @throws IOException
      */
-    public void testWhitespace() throws IOException {
+    public void testWhitespace() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.whitespace);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.whitespace);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql1, commands.get(0));
@@ -51,12 +57,14 @@ public void testWhitespace() throws IOException {
 
     /**
      * Should be able to parse a multi-line statement that has an embedded line comment.
+     *
      * @throws IOException
      */
-    public void testLineComment() throws IOException {
+    public void testLineComment() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.line_comment);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.line_comment);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql1, commands.get(0));
@@ -64,12 +72,14 @@ public void testLineComment() throws IOException {
 
     /**
      * Should be able to handle a line comment that contains string tokens.
+     *
      * @throws IOException
      */
-    public void testLineCommentWithString() throws IOException {
+    public void testLineCommentWithString() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.line_comment_with_string);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.line_comment_with_string);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql1, commands.get(0));
@@ -77,12 +87,14 @@ public void testLineCommentWithString() throws IOException {
 
     /**
      * Should be able to handle a line comment that contains a semicolon.
+     *
      * @throws IOException
      */
-    public void testLineCommentWithSemicolon() throws IOException {
+    public void testLineCommentWithSemicolon() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.line_comment_with_semicolon);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.line_comment_with_semicolon);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql1, commands.get(0));
@@ -90,12 +102,14 @@ public void testLineCommentWithSemicolon() throws IOException {
 
     /**
      * Should ignore a block comment end token inside a line comment.
+     *
      * @throws IOException
      */
-    public void testLineAndBlockEndComment() throws IOException {
+    public void testLineAndBlockEndComment() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.line_comment_and_block_end);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.line_comment_and_block_end);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql1, commands.get(0));
@@ -103,12 +117,14 @@ public void testLineAndBlockEndComment() throws IOException {
 
     /**
      * Should be able to handle a block comment.
+     *
      * @throws IOException
      */
-    public void testBlockComment() throws IOException {
+    public void testBlockComment() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.block_comment);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.block_comment);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql1, commands.get(0));
@@ -116,12 +132,14 @@ public void testBlockComment() throws IOException {
 
     /**
      * Should be able to handle a block comment that contains string tokens.
+     *
      * @throws IOException
      */
-    public void testBlockCommentWithString() throws IOException {
+    public void testBlockCommentWithString() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.block_comment_with_string);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.block_comment_with_string);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql1, commands.get(0));
@@ -129,12 +147,14 @@ public void testBlockCommentWithString() throws IOException {
 
     /**
      * Should be able to handle a block comment that contains a semicolon.
+     *
      * @throws IOException
      */
-    public void testBlockCommentWithSemicolon() throws IOException {
+    public void testBlockCommentWithSemicolon() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.block_comment_with_semicolon);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.block_comment_with_semicolon);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql1, commands.get(0));
@@ -142,12 +162,14 @@ public void testBlockCommentWithSemicolon() throws IOException {
 
     /**
      * Should ignore a line comment token inside a block comment.
+     *
      * @throws IOException
      */
-    public void testBlockAndLineComment() throws IOException {
+    public void testBlockAndLineComment() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.block_with_line_comment);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.block_with_line_comment);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql1, commands.get(0));
@@ -156,12 +178,14 @@ public void testBlockAndLineComment() throws IOException {
     /**
      * Should be able to parse a script that incorrectly closes a block comment twice. The
      * resulting script is not expected to run, but the parser shouldn't choke on it.
+     *
      * @throws IOException
      */
-    public void testInvalidBlockComment() throws IOException {
+    public void testInvalidBlockComment() throws IOException
+    {
 
-        final InputStream stream = this.getStream(R.raw.invalid_block_comment);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.invalid_block_comment);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(invalid, commands.get(0));
@@ -169,13 +193,15 @@ public void testInvalidBlockComment() throws IOException {
 
     /**
      * Should ignore a line comment token inside a string.
+     *
      * @throws IOException
      */
-    public void testStringWithLineComment() throws IOException {
+    public void testStringWithLineComment() throws IOException
+    {
         final String sql = "INSERT INTO Entity ( Id, Column1, Column2 ) VALUES ( 1, '-- some text', 'some text' )";
 
-        final InputStream stream = this.getStream(R.raw.string_with_line_comment);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.string_with_line_comment);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql, commands.get(0));
@@ -183,13 +209,15 @@ public void testStringWithLineComment() throws IOException {
 
     /**
      * Should ignore block comment tokens inside strings.
+     *
      * @throws IOException
      */
-    public void testStringWithBlockComment() throws IOException {
+    public void testStringWithBlockComment() throws IOException
+    {
         final String sql = "INSERT INTO Entity ( Id, Column1, Column2 ) VALUES ( 1, '/* some text', 'some text */' )";
 
-        final InputStream stream = this.getStream(R.raw.string_with_block_comment);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.string_with_block_comment);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql, commands.get(0));
@@ -197,13 +225,15 @@ public void testStringWithBlockComment() throws IOException {
 
     /**
      * Should ignore semicolons inside strings.
+     *
      * @throws IOException
      */
-    public void testStringWithSemicolon() throws IOException {
+    public void testStringWithSemicolon() throws IOException
+    {
         final String sql = "INSERT INTO Entity ( Id, Column1, Column2 ) VALUES ( 1, 'some ; text', 'some ; text' )";
 
-        final InputStream stream = this.getStream(R.raw.string_with_semicolon);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.string_with_semicolon);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql, commands.get(0));
@@ -211,13 +241,15 @@ public void testStringWithSemicolon() throws IOException {
 
     /**
      * Should not clobber whitespace in strings.
+     *
      * @throws IOException
      */
-    public void testStringWithWhitespace() throws IOException {
+    public void testStringWithWhitespace() throws IOException
+    {
         final String sql = "INSERT INTO Entity ( Id, Column1, Column2 ) VALUES ( 1, 'some\t\t\ttext', 'some    text' )";
 
-        final InputStream stream = this.getStream(R.raw.string_with_whitespace);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.string_with_whitespace);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(1, commands.size());
         assertEquals(sql, commands.get(0));
@@ -225,17 +257,19 @@ public void testStringWithWhitespace() throws IOException {
 
     /**
      * Should be able to handle a script that contains anything nasty I can thing of right now.
-     * @throws IOException 
+     *
+     * @throws IOException
      */
-    public void testComplex() throws IOException {
+    public void testComplex() throws IOException
+    {
         final String sql1 = "CREATE TABLE Entity2 ( Id INTEGER AUTO_INCREMENT PRIMARY KEY, Column TEXT NOT NULL, Column2 INTEGER NULL )";
         final String sql2 = "INSERT INTO Entity2 ( Id, Column, Column2 ) SELECT Id, Column, 0 FROM Entity";
         final String sql3 = "DROP TABLE Entity";
         final String sql4 = "ALTER TABLE Entity2 RENAME TO Entity";
         final String sql5 = "INSERT INTO Entity2 ( Id, Column, Column2 ) VALUES ( 9001 , 42, 'string /* string */ -- string' )";
 
-        final InputStream stream = this.getStream(R.raw.complex);
-        List<String> commands = SqlParser.parse(stream);
+        final InputStream stream   = this.getStream(R.raw.complex);
+        List<String>      commands = SqlParser.parse(stream);
 
         assertEquals(5, commands.size());
         assertEquals(sql1, commands.get(0));
diff --git a/tests/src/com/activeandroid/test/query/CountTest.java b/tests/src/com/activeandroid/test/query/CountTest.java
index ba9eea84..fb65dacf 100644
--- a/tests/src/com/activeandroid/test/query/CountTest.java
+++ b/tests/src/com/activeandroid/test/query/CountTest.java
@@ -1,21 +1,24 @@
 
 package com.activeandroid.test.query;
 
-import java.util.List;
-
 import com.activeandroid.sebbia.query.Delete;
 import com.activeandroid.sebbia.query.From;
 import com.activeandroid.sebbia.query.Select;
 import com.activeandroid.test.MockModel;
 
+import java.util.List;
+
 
-public class CountTest extends SqlableTestCase {
+public class CountTest extends SqlableTestCase
+{
 
-    private void cleanTable() {
-        new Delete().from(MockModel.class).execute();
+    private void cleanTable()
+    {
+        new Delete().from(MockModel.class).execute("test");
     }
 
-    private void populateTable() {
+    private void populateTable()
+    {
         MockModel m1 = new MockModel();
         MockModel m2 = new MockModel();
         MockModel m3 = new MockModel();
@@ -24,15 +27,16 @@ private void populateTable() {
         m2.intField = 1;
         m3.intField = 2;
 
-        m1.save();
-        m2.save();
-        m3.save();
+        m1.save("test");
+        m2.save("test");
+        m3.save("test");
     }
 
     /**
      * Should be a simple count for the entire table.
      */
-    public void testCountTableSql() {
+    public void testCountTableSql()
+    {
         final String expected = "SELECT COUNT(*) FROM MockModel";
 
         String actual = new Select()
@@ -45,7 +49,8 @@ public void testCountTableSql() {
     /**
      * Should be a count with the specified where-clause.
      */
-    public void testCountWhereClauseSql() {
+    public void testCountWhereClauseSql()
+    {
         final String expected = "SELECT COUNT(*) FROM MockModel WHERE intField = ?";
 
         String actual = new Select()
@@ -60,7 +65,8 @@ public void testCountWhereClauseSql() {
      * Shouldn't include <i>order by</i> as it has no influence on the result of <i>count</i> and
      * should improve performance.
      */
-    public void testCountOrderBySql() {
+    public void testCountOrderBySql()
+    {
         final String expected = "SELECT COUNT(*) FROM MockModel WHERE intField <> ? GROUP BY intField";
 
         String actual = new Select()
@@ -76,15 +82,16 @@ public void testCountOrderBySql() {
     /**
      * Should return the same count as there are entries in the result set/table.
      */
-    public void testCountTable() {
+    public void testCountTable()
+    {
         cleanTable();
         populateTable();
 
         From from = new Select()
                 .from(MockModel.class);
 
-        final List<MockModel> list = from.execute();
-        final int count = from.count();
+        final List<MockModel> list  = from.execute("test");
+        final int             count = from.count("test");
 
         assertEquals(3, count);
         assertEquals(list.size(), count);
@@ -94,7 +101,8 @@ public void testCountTable() {
      * Should return the same count as there are entries in the result set if the where-clause
      * matches several entries.
      */
-    public void testCountWhereClause() {
+    public void testCountWhereClause()
+    {
         cleanTable();
         populateTable();
 
@@ -102,8 +110,8 @@ public void testCountWhereClause() {
                 .from(MockModel.class)
                 .where("intField = ?", 1);
 
-        final List<MockModel> list = from.execute();
-        final int count = from.count();
+        final List<MockModel> list  = from.execute("test");
+        final int             count = from.count("test");
 
         assertEquals(2, count);
         assertEquals(list.size(), count);
@@ -113,7 +121,8 @@ public void testCountWhereClause() {
      * Should return the same count as there are entries in the result set if the where-clause
      * matches zero entries.
      */
-    public void testCountEmptyResult() {
+    public void testCountEmptyResult()
+    {
         cleanTable();
         populateTable();
 
@@ -121,8 +130,8 @@ public void testCountEmptyResult() {
                 .from(MockModel.class)
                 .where("intField = ?", 3);
 
-        final List<MockModel> list = from.execute();
-        final int count = from.count();
+        final List<MockModel> list  = from.execute("test");
+        final int             count = from.count("test");
 
         assertEquals(0, count);
         assertEquals(list.size(), count);
@@ -131,7 +140,8 @@ public void testCountEmptyResult() {
     /**
      * Should not change the result if order by is used.
      */
-    public void testCountOrderBy() {
+    public void testCountOrderBy()
+    {
         cleanTable();
         populateTable();
 
@@ -140,8 +150,8 @@ public void testCountOrderBy() {
                 .where("intField = ?", 1)
                 .orderBy("intField ASC");
 
-        final List<MockModel> list = from.execute();
-        final int count = from.count();
+        final List<MockModel> list  = from.execute("test");
+        final int             count = from.count("test");
 
         assertEquals(2, count);
         assertEquals(list.size(), count);
@@ -151,7 +161,8 @@ public void testCountOrderBy() {
      * Should return the total number of rows, even if the rows are grouped. May seem weird, just
      * test it in an SQL explorer.
      */
-    public void testCountGroupBy() {
+    public void testCountGroupBy()
+    {
         cleanTable();
         populateTable();
 
@@ -160,8 +171,8 @@ public void testCountGroupBy() {
                 .groupBy("intField")
                 .having("intField = 1");
 
-        final List<MockModel> list = from.execute();
-        final int count = from.count();
+        final List<MockModel> list  = from.execute("test");
+        final int             count = from.count("test");
 
         assertEquals(2, count);
         assertEquals(1, list.size());
diff --git a/tests/src/com/activeandroid/test/query/DeleteTest.java b/tests/src/com/activeandroid/test/query/DeleteTest.java
index f0624ffc..59e57183 100644
--- a/tests/src/com/activeandroid/test/query/DeleteTest.java
+++ b/tests/src/com/activeandroid/test/query/DeleteTest.java
@@ -19,13 +19,16 @@
 import com.activeandroid.sebbia.query.Delete;
 import com.activeandroid.test.MockModel;
 
-public class DeleteTest extends SqlableTestCase {
-	public void testDelete() {
-		assertSqlEquals("DELETE ", new Delete());
-	}
+public class DeleteTest extends SqlableTestCase
+{
+    public void testDelete()
+    {
+        assertSqlEquals("DELETE ", new Delete());
+    }
 
-	public void testFrom() {
-		assertSqlEquals("DELETE FROM MockModel",
-				new Delete().from(MockModel.class));
-	}
+    public void testFrom()
+    {
+        assertSqlEquals("DELETE FROM MockModel",
+                new Delete().from(MockModel.class));
+    }
 }
diff --git a/tests/src/com/activeandroid/test/query/ExistsTest.java b/tests/src/com/activeandroid/test/query/ExistsTest.java
index eea3ca02..fac578c3 100644
--- a/tests/src/com/activeandroid/test/query/ExistsTest.java
+++ b/tests/src/com/activeandroid/test/query/ExistsTest.java
@@ -1,21 +1,24 @@
 
 package com.activeandroid.test.query;
 
-import java.util.List;
-
 import com.activeandroid.sebbia.query.Delete;
 import com.activeandroid.sebbia.query.From;
 import com.activeandroid.sebbia.query.Select;
 import com.activeandroid.test.MockModel;
 
+import java.util.List;
+
 
-public class ExistsTest extends SqlableTestCase {
+public class ExistsTest extends SqlableTestCase
+{
 
-    private void cleanTable() {
-        new Delete().from(MockModel.class).execute();
+    private void cleanTable()
+    {
+        new Delete().from(MockModel.class).execute("test");
     }
 
-    private void populateTable() {
+    private void populateTable()
+    {
         MockModel m1 = new MockModel();
         MockModel m2 = new MockModel();
         MockModel m3 = new MockModel();
@@ -24,23 +27,24 @@ private void populateTable() {
         m2.intField = 1;
         m3.intField = 2;
 
-        m1.save();
-        m2.save();
-        m3.save();
+        m1.save("test");
+        m2.save("test");
+        m3.save("test");
     }
 
     /**
      * Should return {@code true} since the result set/table isn't empty.
      */
-    public void testExistsTable() {
+    public void testExistsTable()
+    {
         cleanTable();
         populateTable();
 
         From from = new Select()
                 .from(MockModel.class);
 
-        final List<MockModel> list = from.execute();
-        final boolean exists = from.exists();
+        final List<MockModel> list   = from.execute("test");
+        final boolean         exists = from.exists("test");
 
         assertTrue(exists);
         assertTrue(list.size() > 0);
@@ -49,7 +53,8 @@ public void testExistsTable() {
     /**
      * Should be a simple exists for the entire table.
      */
-    public void testCountTableSql() {
+    public void testCountTableSql()
+    {
         final String expected = "SELECT EXISTS(SELECT 1 FROM MockModel )";
 
         String actual = new Select()
@@ -62,7 +67,8 @@ public void testCountTableSql() {
     /**
      * Should be an exists with the specified where-clause.
      */
-    public void testCountWhereClauseSql() {
+    public void testCountWhereClauseSql()
+    {
         final String expected = "SELECT EXISTS(SELECT 1 FROM MockModel WHERE intField = ? )";
 
         String actual = new Select()
@@ -77,7 +83,8 @@ public void testCountWhereClauseSql() {
      * Shouldn't include <i>order by</i> as it has no influence on the result of <i>exists</i> and
      * should improve performance.
      */
-    public void testCountOrderBySql() {
+    public void testCountOrderBySql()
+    {
         final String expected = "SELECT EXISTS(SELECT 1 FROM MockModel WHERE intField <> ? GROUP BY intField )";
 
         String actual = new Select()
@@ -94,7 +101,8 @@ public void testCountOrderBySql() {
      * Should return {@code true} since the where-clause matches rows and thus the result set isn't
      * empty.
      */
-    public void testExistsWhereClause() {
+    public void testExistsWhereClause()
+    {
         cleanTable();
         populateTable();
 
@@ -102,8 +110,8 @@ public void testExistsWhereClause() {
                 .from(MockModel.class)
                 .where("intField = ?", 1);
 
-        final List<MockModel> list = from.execute();
-        final boolean exists = from.exists();
+        final List<MockModel> list   = from.execute("test");
+        final boolean         exists = from.exists("test");
 
         assertTrue(exists);
         assertTrue(list.size() > 0);
@@ -113,7 +121,8 @@ public void testExistsWhereClause() {
      * Should return {@code false} since the where-clause matches zero rows and thus the result set
      * is empty.
      */
-    public void testExistsEmptyResult() {
+    public void testExistsEmptyResult()
+    {
         cleanTable();
         populateTable();
 
@@ -121,8 +130,8 @@ public void testExistsEmptyResult() {
                 .from(MockModel.class)
                 .where("intField = ?", 3);
 
-        final List<MockModel> list = from.execute();
-        final boolean exists = from.exists();
+        final List<MockModel> list   = from.execute("test");
+        final boolean         exists = from.exists("test");
 
         assertFalse(exists);
         assertFalse(list.size() > 0);
@@ -131,7 +140,8 @@ public void testExistsEmptyResult() {
     /**
      * Should not change the result if order by is used.
      */
-    public void testCountOrderBy() {
+    public void testCountOrderBy()
+    {
         cleanTable();
         populateTable();
 
@@ -140,8 +150,8 @@ public void testCountOrderBy() {
                 .where("intField = ?", 1)
                 .orderBy("intField ASC");
 
-        final List<MockModel> list = from.execute();
-        final boolean exists = from.exists();
+        final List<MockModel> list   = from.execute("test");
+        final boolean         exists = from.exists("test");
 
         assertTrue(exists);
         assertTrue(list.size() > 0);
@@ -150,7 +160,8 @@ public void testCountOrderBy() {
     /**
      * Should not change the result if group by is used.
      */
-    public void testCountGroupBy() {
+    public void testCountGroupBy()
+    {
         cleanTable();
         populateTable();
 
@@ -159,8 +170,8 @@ public void testCountGroupBy() {
                 .groupBy("intField")
                 .having("intField = 1");
 
-        final List<MockModel> list = from.execute();
-        final boolean exists = from.exists();
+        final List<MockModel> list   = from.execute("test");
+        final boolean         exists = from.exists("test");
 
         assertTrue(exists);
         assertTrue(list.size() > 0);
@@ -169,7 +180,8 @@ public void testCountGroupBy() {
     /**
      * Should not exist if group by eliminates all rows.
      */
-    public void testCountGroupByEmpty() {
+    public void testCountGroupByEmpty()
+    {
         cleanTable();
         populateTable();
 
@@ -178,8 +190,8 @@ public void testCountGroupByEmpty() {
                 .groupBy("intField")
                 .having("intField = 3");
 
-        final List<MockModel> list = from.execute();
-        final boolean exists = from.exists();
+        final List<MockModel> list   = from.execute("test");
+        final boolean         exists = from.exists("test");
 
         assertFalse(exists);
         assertFalse(list.size() > 0);
diff --git a/tests/src/com/activeandroid/test/query/FromTest.java b/tests/src/com/activeandroid/test/query/FromTest.java
index a712e337..0da566ef 100644
--- a/tests/src/com/activeandroid/test/query/FromTest.java
+++ b/tests/src/com/activeandroid/test/query/FromTest.java
@@ -22,216 +22,238 @@
 import com.activeandroid.sebbia.query.Select;
 import com.activeandroid.test.MockModel;
 
-public class FromTest extends SqlableTestCase {
-	private static final String SELECT_PREFIX = "SELECT ALL * FROM MockModel ";
-	
-	public void testLimit() {
-		assertSqlEquals(SELECT_PREFIX + "LIMIT 10",
-				from().limit(10));
-		assertSqlEquals(SELECT_PREFIX + "LIMIT 10",
-				from().limit("10"));
-	}
-	
-	public void testOffset() {
-		assertSqlEquals(SELECT_PREFIX + "OFFSET 10",
-				from().offset(10));
-		assertSqlEquals(SELECT_PREFIX + "OFFSET 10",
-				from().offset("10"));
-	}
-	
-	public void testLimitOffset() {
-		assertSqlEquals(SELECT_PREFIX + "LIMIT 10 OFFSET 20",
-				from().offset(20).limit(10));
-		assertSqlEquals(SELECT_PREFIX + "LIMIT 10 OFFSET 20",
-				from().limit(10).offset(20));
-	}
-	
-	public void testAs() {
-		assertSqlEquals(SELECT_PREFIX + "AS a",
-				from().as("a"));
-	}
-	
-	public void testOrderBy() {
-		assertSqlEquals(SELECT_PREFIX + "ORDER BY Id DESC",
-				from().orderBy("Id DESC"));
-	}
-	
-	public void testWhereNoArguments() {
-		assertSqlEquals(SELECT_PREFIX + "WHERE Id = 5",
-				from().where("Id = 5"));
-		
-		assertSqlEquals(SELECT_PREFIX + "WHERE Id = 1 AND Id = 2 AND Id = 5",
-				from().where("Id = 1").where("Id = 2").where("Id = 5"));
-	}
-	
-	public void testWhereWithArguments() {
-		From query = from().where("Id = ?", 5);
-		assertArrayEquals(query.getArguments(), "5");
-		assertSqlEquals(SELECT_PREFIX + "WHERE Id = ?",
-				query);
-		
-		query = from().where("Id > ? AND Id < ?", 5, 10);
-		assertArrayEquals(query.getArguments(), "5", "10");
-		assertSqlEquals(SELECT_PREFIX + "WHERE Id > ? AND Id < ?",
-				query);
-		
+public class FromTest extends SqlableTestCase
+{
+    private static final String SELECT_PREFIX = "SELECT ALL * FROM MockModel ";
+
+    public void testLimit()
+    {
+        assertSqlEquals(SELECT_PREFIX + "LIMIT 10",
+                from().limit(10));
+        assertSqlEquals(SELECT_PREFIX + "LIMIT 10",
+                from().limit("10"));
+    }
+
+    public void testOffset()
+    {
+        assertSqlEquals(SELECT_PREFIX + "OFFSET 10",
+                from().offset(10));
+        assertSqlEquals(SELECT_PREFIX + "OFFSET 10",
+                from().offset("10"));
+    }
+
+    public void testLimitOffset()
+    {
+        assertSqlEquals(SELECT_PREFIX + "LIMIT 10 OFFSET 20",
+                from().offset(20).limit(10));
+        assertSqlEquals(SELECT_PREFIX + "LIMIT 10 OFFSET 20",
+                from().limit(10).offset(20));
+    }
+
+    public void testAs()
+    {
+        assertSqlEquals(SELECT_PREFIX + "AS a",
+                from().as("a"));
+    }
+
+    public void testOrderBy()
+    {
+        assertSqlEquals(SELECT_PREFIX + "ORDER BY Id DESC",
+                from().orderBy("Id DESC"));
+    }
+
+    public void testWhereNoArguments()
+    {
+        assertSqlEquals(SELECT_PREFIX + "WHERE Id = 5",
+                from().where("Id = 5"));
+
+        assertSqlEquals(SELECT_PREFIX + "WHERE Id = 1 AND Id = 2 AND Id = 5",
+                from().where("Id = 1").where("Id = 2").where("Id = 5"));
+    }
+
+    public void testWhereWithArguments()
+    {
+        From query = from().where("Id = ?", 5);
+        assertArrayEquals(query.getArguments(), "5");
+        assertSqlEquals(SELECT_PREFIX + "WHERE Id = ?",
+                query);
+
+        query = from().where("Id > ? AND Id < ?", 5, 10);
+        assertArrayEquals(query.getArguments(), "5", "10");
+        assertSqlEquals(SELECT_PREFIX + "WHERE Id > ? AND Id < ?",
+                query);
+
         // Chained
-		query = from()
-				.where("Id != ?", 10)
-				.where("Id IN (?, ?, ?)", 5, 10, 15)
-				.where("Id > ? AND Id < ?", 5, 10);
-		assertArrayEquals(query.getArguments(), "10", "5", "10", "15", "5", "10");
-		assertSqlEquals(SELECT_PREFIX + "WHERE Id != ? AND Id IN (?, ?, ?) AND Id > ? AND Id < ?",
-				query);
-	}
+        query = from()
+                .where("Id != ?", 10)
+                .where("Id IN (?, ?, ?)", 5, 10, 15)
+                .where("Id > ? AND Id < ?", 5, 10);
+        assertArrayEquals(query.getArguments(), "10", "5", "10", "15", "5", "10");
+        assertSqlEquals(SELECT_PREFIX + "WHERE Id != ? AND Id IN (?, ?, ?) AND Id > ? AND Id < ?",
+                query);
+    }
+
+    public void testWhereChaining()
+    {
+
+        From expected = from()
+                .where("a = ? AND b = ?", 1, 2);
+
+        From actual = from()
+                .where("a = ?", 1, 2)
+                .where("b = ?", 1, 2);
+
+        assertSqlEquals(expected, actual);
+    }
 
-	public void testWhereChaining() {
-	    
-	    From expected = from()
-	            .where("a = ? AND b = ?", 1, 2);
-	    
-	    From actual = from()
-	            .where("a = ?", 1, 2)
-	            .where("b = ?", 1, 2);
-	    
-	    assertSqlEquals(expected, actual);
-	}
-	
-   public void testWhereAndChaining() {
+    public void testWhereAndChaining()
+    {
 
-       From expected = from()
-               .where("a = ? AND b = ?", 1, 2);
+        From expected = from()
+                .where("a = ? AND b = ?", 1, 2);
 
-       From actual = from()
-               .where("a = ?", 1)
-               .and("b = ?", 2);
+        From actual = from()
+                .where("a = ?", 1)
+                .and("b = ?", 2);
 
-       assertSqlEquals(expected, actual);
-   }
+        assertSqlEquals(expected, actual);
+    }
 
-   public void testWhereOrChaining() {
+    public void testWhereOrChaining()
+    {
 
-       From expected = from()
-               .where("a = ? OR b = ?", 1, 2);
+        From expected = from()
+                .where("a = ? OR b = ?", 1, 2);
 
-       From actual = from()
-               .where("a = ?", 1)
-               .or("b = ?", 2);
+        From actual = from()
+                .where("a = ?", 1)
+                .or("b = ?", 2);
 
-       assertSqlEquals(expected, actual);
-   }
+        assertSqlEquals(expected, actual);
+    }
 
-   public void testWhereAndOrChaining() {
+    public void testWhereAndOrChaining()
+    {
 
-       From expected = from()
-               .where("a = ? OR (b = ? AND c = ?)", 1, 2, 3);
+        From expected = from()
+                .where("a = ? OR (b = ? AND c = ?)", 1, 2, 3);
 
-       From actual = from()
-               .where("a = ?", 1)
-               .or("(b = ? AND c = ?)", 2, 3);
+        From actual = from()
+                .where("a = ?", 1)
+                .or("(b = ? AND c = ?)", 2, 3);
 
-       assertSqlEquals(expected, actual);
-   }
+        assertSqlEquals(expected, actual);
+    }
 
-   public void testWhereAlternateAndOrChaining() {
+    public void testWhereAlternateAndOrChaining()
+    {
 
-       From expected = from()
-               .where("a = ? OR (b = ? AND c = ?)", 1, 2, 3);
+        From expected = from()
+                .where("a = ? OR (b = ? AND c = ?)", 1, 2, 3);
 
-       From actual = from()
-               .where("a = ?", 1)
-               .or("(b = ?", 2)
-               .and("c = ?)", 3);
+        From actual = from()
+                .where("a = ?", 1)
+                .or("(b = ?", 2)
+                .and("c = ?)", 3);
 
-       assertSqlEquals(expected, actual);
-   }
+        assertSqlEquals(expected, actual);
+    }
 
     // Test with 'no arguments' and 'with arguments' chained together.
-    public void testWhereWithNoArgumentsAndWithArguments() {
+    public void testWhereWithNoArgumentsAndWithArguments()
+    {
         From query = from().where("Id = 5");
         query.where("Id > ?", 4);
         assertArrayEquals(query.getArguments(), "4");
         assertSqlEquals(SELECT_PREFIX + "WHERE Id = 5 AND Id > ?",
                 query);
     }
-	
-	public void testSingleJoin() {
-		assertSqlEquals(SELECT_PREFIX + "JOIN JoinModel ON MockModel.Id = JoinModel.Id",
-				from().join(JoinModel.class).on("MockModel.Id = JoinModel.Id"));
-		
-		assertSqlEquals(SELECT_PREFIX + "AS a JOIN JoinModel AS b ON a.Id = b.Id",
-				from().as("a").join(JoinModel.class).as("b").on("a.Id = b.Id"));
-		
-		assertSqlEquals(SELECT_PREFIX + "JOIN JoinModel USING (Id, other)",
-				from().join(JoinModel.class).using("Id", "other"));
-	}
-	
-	public void testJoins() {
-		assertSqlEquals(SELECT_PREFIX + "JOIN JoinModel ON Id JOIN JoinModel2 ON Id",
-				from().join(JoinModel.class).on("Id")
-				.join(JoinModel2.class).on("Id"));
-	}
-	
-	public void testJoinTypes() {
-		assertSqlEquals(SELECT_PREFIX + "INNER JOIN JoinModel ON",
-				from().innerJoin(JoinModel.class).on(""));
-		assertSqlEquals(SELECT_PREFIX + "OUTER JOIN JoinModel ON",
-				from().outerJoin(JoinModel.class).on(""));
-		assertSqlEquals(SELECT_PREFIX + "CROSS JOIN JoinModel ON",
-				from().crossJoin(JoinModel.class).on(""));
-	}
-	
-	public void testGroupByHaving() {
-		assertSqlEquals(SELECT_PREFIX + "GROUP BY Id",
-				from().groupBy("Id"));
-		assertSqlEquals(SELECT_PREFIX + "GROUP BY Id HAVING Id = 1",
-				from().groupBy("Id").having("Id = 1"));
-		assertSqlEquals(SELECT_PREFIX + "GROUP BY Id HAVING Id = 1",
-				from().having("Id = 1").groupBy("Id"));
-	}
-	
-	public void testAll() {
-		final String expectedSql = SELECT_PREFIX + "AS a JOIN JoinModel USING (Id) WHERE Id > 5 GROUP BY Id HAVING Id < 10 LIMIT 5 OFFSET 10";
-		
-		// Try a few different orderings, shouldn't change the output
-		assertSqlEquals(expectedSql,
-				from()
-					.as("a")
-					.where("Id > 5")
-					.join(JoinModel.class).using("Id")
-					.groupBy("Id")
-					.having("Id < 10")
-					.limit(5)
-					.offset(10));
-		assertSqlEquals(expectedSql,
-				from()
-					.offset(10)
-					.having("Id < 10")
-					.join(JoinModel.class).using("Id")
-					.limit(5)
-					.as("a")
-					.where("Id > 5")
-					.groupBy("Id"));
-		assertSqlEquals(expectedSql,
-				from()
-					.join(JoinModel.class).using("Id")
-					.offset(10)
-					.having("Id < 10")
-					.where("Id > 5")
-					.groupBy("Id")
-					.limit(5)
-					.as("a"));
-	}
-	
-	private From from() {
-		return new Select().all().from(MockModel.class);
-	}
-	
-	@Table(name = "JoinModel")
-	static class JoinModel extends Model {
-	}
-	
-	@Table(name = "JoinModel2")
-	static class JoinModel2 extends Model {
-	}
+
+    public void testSingleJoin()
+    {
+        assertSqlEquals(SELECT_PREFIX + "JOIN JoinModel ON MockModel.Id = JoinModel.Id",
+                from().join(JoinModel.class).on("MockModel.Id = JoinModel.Id"));
+
+        assertSqlEquals(SELECT_PREFIX + "AS a JOIN JoinModel AS b ON a.Id = b.Id",
+                from().as("a").join(JoinModel.class).as("b").on("a.Id = b.Id"));
+
+        assertSqlEquals(SELECT_PREFIX + "JOIN JoinModel USING (Id, other)",
+                from().join(JoinModel.class).using("Id", "other"));
+    }
+
+    public void testJoins()
+    {
+        assertSqlEquals(SELECT_PREFIX + "JOIN JoinModel ON Id JOIN JoinModel2 ON Id",
+                from().join(JoinModel.class).on("Id")
+                        .join(JoinModel2.class).on("Id"));
+    }
+
+    public void testJoinTypes()
+    {
+        assertSqlEquals(SELECT_PREFIX + "INNER JOIN JoinModel ON",
+                from().innerJoin(JoinModel.class).on(""));
+        assertSqlEquals(SELECT_PREFIX + "OUTER JOIN JoinModel ON",
+                from().outerJoin(JoinModel.class).on(""));
+        assertSqlEquals(SELECT_PREFIX + "CROSS JOIN JoinModel ON",
+                from().crossJoin(JoinModel.class).on(""));
+    }
+
+    public void testGroupByHaving()
+    {
+        assertSqlEquals(SELECT_PREFIX + "GROUP BY Id",
+                from().groupBy("Id"));
+        assertSqlEquals(SELECT_PREFIX + "GROUP BY Id HAVING Id = 1",
+                from().groupBy("Id").having("Id = 1"));
+        assertSqlEquals(SELECT_PREFIX + "GROUP BY Id HAVING Id = 1",
+                from().having("Id = 1").groupBy("Id"));
+    }
+
+    public void testAll()
+    {
+        final String expectedSql = SELECT_PREFIX + "AS a JOIN JoinModel USING (Id) WHERE Id > 5 GROUP BY Id HAVING Id < 10 LIMIT 5 OFFSET 10";
+
+        // Try a few different orderings, shouldn't change the output
+        assertSqlEquals(expectedSql,
+                from()
+                        .as("a")
+                        .where("Id > 5")
+                        .join(JoinModel.class).using("Id")
+                        .groupBy("Id")
+                        .having("Id < 10")
+                        .limit(5)
+                        .offset(10));
+        assertSqlEquals(expectedSql,
+                from()
+                        .offset(10)
+                        .having("Id < 10")
+                        .join(JoinModel.class).using("Id")
+                        .limit(5)
+                        .as("a")
+                        .where("Id > 5")
+                        .groupBy("Id"));
+        assertSqlEquals(expectedSql,
+                from()
+                        .join(JoinModel.class).using("Id")
+                        .offset(10)
+                        .having("Id < 10")
+                        .where("Id > 5")
+                        .groupBy("Id")
+                        .limit(5)
+                        .as("a"));
+    }
+
+    private From from()
+    {
+        return new Select().all().from(MockModel.class);
+    }
+
+    @Table(name = "JoinModel")
+    static class JoinModel extends Model
+    {
+    }
+
+    @Table(name = "JoinModel2")
+    static class JoinModel2 extends Model
+    {
+    }
 }
diff --git a/tests/src/com/activeandroid/test/query/SelectTest.java b/tests/src/com/activeandroid/test/query/SelectTest.java
index c4aca601..e07c302b 100644
--- a/tests/src/com/activeandroid/test/query/SelectTest.java
+++ b/tests/src/com/activeandroid/test/query/SelectTest.java
@@ -19,32 +19,39 @@
 import com.activeandroid.sebbia.query.Select;
 import com.activeandroid.test.MockModel;
 
-public class SelectTest extends SqlableTestCase {
-	public void testSelectEmpty() {
-		assertSqlEquals("SELECT * ", new Select());
-	}
-
-	public void testSelectAll() {
-		assertSqlEquals("SELECT ALL * ", new Select().all());
-		assertSqlEquals("SELECT ALL * ", new Select().distinct().all());
-	}
-
-	public void testSelectDistinct() {
-		assertSqlEquals("SELECT DISTINCT * ", new Select().distinct());
-		assertSqlEquals("SELECT DISTINCT * ", new Select().all().distinct());
-	}
-
-	public void testSelectStringColumns() {
-		assertSqlEquals("SELECT a, b, c ", new Select("a", "b", "c"));
-	}
-
-	public void testSelectDistinctColumns() {
-		assertSqlEquals("SELECT DISTINCT a, b, c ",
-				new Select("a", "b", "c").distinct());
-	}
-
-	public void testFrom() {
-		assertSqlEquals("SELECT ALL * FROM MockModel",
-				new Select().all().from(MockModel.class));
-	}
+public class SelectTest extends SqlableTestCase
+{
+    public void testSelectEmpty()
+    {
+        assertSqlEquals("SELECT * ", new Select());
+    }
+
+    public void testSelectAll()
+    {
+        assertSqlEquals("SELECT ALL * ", new Select().all());
+        assertSqlEquals("SELECT ALL * ", new Select().distinct().all());
+    }
+
+    public void testSelectDistinct()
+    {
+        assertSqlEquals("SELECT DISTINCT * ", new Select().distinct());
+        assertSqlEquals("SELECT DISTINCT * ", new Select().all().distinct());
+    }
+
+    public void testSelectStringColumns()
+    {
+        assertSqlEquals("SELECT a, b, c ", new Select("a", "b", "c"));
+    }
+
+    public void testSelectDistinctColumns()
+    {
+        assertSqlEquals("SELECT DISTINCT a, b, c ",
+                new Select("a", "b", "c").distinct());
+    }
+
+    public void testFrom()
+    {
+        assertSqlEquals("SELECT ALL * FROM MockModel",
+                new Select().all().from(MockModel.class));
+    }
 }
diff --git a/tests/src/com/activeandroid/test/query/SqlableTestCase.java b/tests/src/com/activeandroid/test/query/SqlableTestCase.java
index f339e1b0..bde26760 100644
--- a/tests/src/com/activeandroid/test/query/SqlableTestCase.java
+++ b/tests/src/com/activeandroid/test/query/SqlableTestCase.java
@@ -19,12 +19,15 @@
 import com.activeandroid.sebbia.query.Sqlable;
 import com.activeandroid.test.ActiveAndroidTestCase;
 
-public abstract class SqlableTestCase extends ActiveAndroidTestCase {
-	public static void assertSqlEquals(String expected, Sqlable actual) {
-		assertEquals(expected, actual.toSql());
-	}
-	
-	public static void assertSqlEquals(Sqlable expected, Sqlable actual) {
-	    assertEquals(expected.toSql(), actual.toSql());
-	}
+public abstract class SqlableTestCase extends ActiveAndroidTestCase
+{
+    public static void assertSqlEquals(String expected, Sqlable actual)
+    {
+        assertEquals(expected, actual.toSql());
+    }
+
+    public static void assertSqlEquals(Sqlable expected, Sqlable actual)
+    {
+        assertEquals(expected.toSql(), actual.toSql());
+    }
 }
diff --git a/tests/src/com/activeandroid/test/query/UpdateTest.java b/tests/src/com/activeandroid/test/query/UpdateTest.java
index 1d9d7c6d..1b8a7685 100644
--- a/tests/src/com/activeandroid/test/query/UpdateTest.java
+++ b/tests/src/com/activeandroid/test/query/UpdateTest.java
@@ -20,43 +20,49 @@
 import com.activeandroid.sebbia.query.Update;
 import com.activeandroid.test.MockModel;
 
-public class UpdateTest extends SqlableTestCase {
-	private static final String UPDATE_PREFIX = "UPDATE MockModel ";
-	
-	public void testUpdate() {
-		assertSqlEquals(UPDATE_PREFIX, update());
-	}
-	
-	public void testUpdateSet() {
-		assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 ",
-				update().set("Id = 5"));
-	}
-	
-	public void testUpdateWhereNoArguments() {
-		assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 WHERE Id = 1 ",
-				update()
-					.set("Id = 5")
-					.where("Id = 1"));
-	}
-	
-	public void testUpdateWhereWithArguments() {
-		Set set = update()
-				.set("Id = 5")
-				.where("Id = ?", 1);
-		assertArrayEquals(set.getArguments(), "1");
-		assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 WHERE Id = ? ",
-				set);
-		
-		set = update()
-				.set("Id = 5")
-				.where("Id = ?", 1)
-				.where("Id IN (?, ?, ?)", 5, 4, 3);
-		assertArrayEquals(set.getArguments(), "5", "4", "3");
-		assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 WHERE Id IN (?, ?, ?) ",
-				set);
-	}
-	
-	private Update update() {
-		return new Update(MockModel.class);
-	}
+public class UpdateTest extends SqlableTestCase
+{
+    private static final String UPDATE_PREFIX = "UPDATE MockModel ";
+
+    public void testUpdate()
+    {
+        assertSqlEquals(UPDATE_PREFIX, update());
+    }
+
+    public void testUpdateSet()
+    {
+        assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 ",
+                update().set("Id = 5"));
+    }
+
+    public void testUpdateWhereNoArguments()
+    {
+        assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 WHERE Id = 1 ",
+                update()
+                        .set("Id = 5")
+                        .where("Id = 1"));
+    }
+
+    public void testUpdateWhereWithArguments()
+    {
+        Set set = update()
+                .set("Id = 5")
+                .where("Id = ?", 1);
+        assertArrayEquals(set.getArguments(), "1");
+        assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 WHERE Id = ? ",
+                set);
+
+        set = update()
+                .set("Id = 5")
+                .where("Id = ?", 1)
+                .where("Id IN (?, ?, ?)", 5, 4, 3);
+        assertArrayEquals(set.getArguments(), "5", "4", "3");
+        assertSqlEquals(UPDATE_PREFIX + "SET Id = 5 WHERE Id IN (?, ?, ?) ",
+                set);
+    }
+
+    private Update update()
+    {
+        return new Update(MockModel.class);
+    }
 }
