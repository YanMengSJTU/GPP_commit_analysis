diff --git a/.gitmodules b/.gitmodules
index f47cd622d..f5ffbce85 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,6 @@
 [submodule "TMessagesProj/jni/libtgvoip"]
 	path = TMessagesProj/jni/libtgvoip
 	url = https://github.com/grishka/libtgvoip
+[submodule "submodules/SFML/SFML"]
+	path = submodules/SFML/SFML
+	url = https://github.com/SFML/SFML.git
diff --git a/TMessagesProj/CMakeLists.txt b/TMessagesProj/CMakeLists.txt
new file mode 100644
index 000000000..88d4aaafe
--- /dev/null
+++ b/TMessagesProj/CMakeLists.txt
@@ -0,0 +1,152 @@
+# For more information about using CMake with Android Studio, read the
+# documentation: https://d.android.com/studio/projects/add-native-code.html
+
+# Sets the minimum version of CMake required to build the native library.
+
+cmake_minimum_required(VERSION 3.4.1)
+
+include(ndk-stl-config.cmake)
+
+# Export ANativeActivity_onCreate(),
+# Refer to: https://github.com/android-ndk/ndk/issues/381.
+set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -u ANativeActivity_onCreate")
+
+message(STATUS "ABI=\"${ANDROID_ABI}\"")
+
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/src/main/cpp)
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../submodules/SFML/SFML/include)
+#link_directories(${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI})
+
+# Creates and names a library, sets it as either STATIC
+# or SHARED, and provides the relative paths to its source code.
+# You can define multiple libraries, and CMake builds them for you.
+# Gradle automatically packages shared libraries with your APK.
+
+add_library( # Sets the name of the library.
+        native-lib
+
+        # Sets the library as a shared library.
+        SHARED
+
+        # Provides a relative path to your source file(s).
+        ${CMAKE_CURRENT_SOURCE_DIR}/src/main/cpp/main.cpp)
+
+# Searches for a specified prebuilt library and stores the path as a
+# variable. Because CMake includes system libraries in the search path by
+# default, you only need to specify the name of the public NDK library
+# you want to add. CMake verifies that the library exists before
+# completing its build.
+
+find_library( # Sets the name of the path variable.
+        log-lib
+
+        # Specifies the name of the NDK library that
+        # you want CMake to locate.
+        log)
+
+add_library(sfml-system SHARED IMPORTED)
+set_target_properties( # Specifies the target library.
+        sfml-system
+
+        # Specifies the parameter you want to define.
+        PROPERTIES IMPORTED_LOCATION
+
+        # Provides the path to the library you want to import.
+        ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libsfml-system-d.so )
+
+add_library(sfml-activity SHARED IMPORTED)
+set_target_properties( # Specifies the target library.
+        sfml-activity
+
+        # Specifies the parameter you want to define.
+        PROPERTIES IMPORTED_LOCATION
+
+        # Provides the path to the library you want to import.
+        ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libsfml-activity-d.so )
+
+add_library(sfml-audio SHARED IMPORTED)
+set_target_properties( # Specifies the target library.
+        sfml-audio
+
+        # Specifies the parameter you want to define.
+        PROPERTIES IMPORTED_LOCATION
+
+        # Provides the path to the library you want to import.
+        ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libsfml-audio-d.so )
+
+add_library(sfml-window SHARED IMPORTED)
+set_target_properties( # Specifies the target library.
+        sfml-window
+
+        # Specifies the parameter you want to define.
+        PROPERTIES IMPORTED_LOCATION
+
+        # Provides the path to the library you want to import.
+        ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libsfml-window-d.so )
+
+add_library(sfml-graphics SHARED IMPORTED)
+set_target_properties( # Specifies the target library.
+        sfml-graphics
+
+        # Specifies the parameter you want to define.
+        PROPERTIES IMPORTED_LOCATION
+
+        # Provides the path to the library you want to import.
+        ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libsfml-graphics-d.so )
+
+add_library(sfml-network SHARED IMPORTED)
+set_target_properties( # Specifies the target library.
+        sfml-network
+
+        # Specifies the parameter you want to define.
+        PROPERTIES IMPORTED_LOCATION
+
+        # Provides the path to the library you want to import.
+        ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libsfml-network-d.so )
+
+add_library(sfml-main STATIC IMPORTED)
+set_target_properties( # Specifies the target library.
+        sfml-main
+
+        # Specifies the parameter you want to define.
+        PROPERTIES IMPORTED_LOCATION
+
+        # Provides the path to the library you want to import.
+        ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libsfml-main-d.a )
+
+add_library(openal SHARED IMPORTED)
+set_target_properties( # Specifies the target library.
+        openal
+
+        # Specifies the parameter you want to define.
+        PROPERTIES IMPORTED_LOCATION
+
+        # Provides the path to the library you want to import.
+        ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libopenal.so )
+
+# Specifies libraries CMake should link to your target library. You
+# can link multiple libraries, such as libraries you define in this
+# build script, prebuilt third-party libraries, or system libraries.
+
+target_link_libraries( # Specifies the target library.
+        native-lib
+
+        # Links the target library to the log library
+        # included in the NDK.
+
+        log
+        android
+        EGL
+        GLESv1_CM
+
+        sfml-system
+
+        openal
+
+        sfml-window
+        sfml-audio
+        sfml-graphics
+        sfml-network
+        sfml-activity
+        -Wl,--whole-archive sfml-main -Wl,--no-whole-archive
+        )
diff --git a/TMessagesProj/build.gradle b/TMessagesProj/build.gradle
index c712a986e..f76b8bbfe 100644
--- a/TMessagesProj/build.gradle
+++ b/TMessagesProj/build.gradle
@@ -53,7 +53,7 @@ android {
 
     defaultConfig.applicationId = "org.telegramster.messenger"
 
-    sourceSets.main.jniLibs.srcDirs = ['./jni/']
+    sourceSets.main.jniLibs.srcDirs = ['./jni/', './jniLibs/']
 
     externalNativeBuild {
         ndkBuild {
@@ -313,12 +313,20 @@ android {
 
         externalNativeBuild {
             ndkBuild {
+                cFlags ""
+                cppFlags ""
                 arguments "NDK_APPLICATION_MK:=jni/Application.mk", "APP_PLATFORM:=android-21", "-j8"
-                abiFilters "armeabi-v7a", "arm64-v8a"//, "x86", "x86_64"
+                abiFilters "armeabi-v7a"//, "arm64-v8a", "x86", "x86_64"
+            }
+            cmake {
+                cFlags ""
+                cppFlags ""
+                arguments "-DANDROID_STL=c++_shared"
+                abiFilters "armeabi-v7a"//, "arm64-v8a", "x86", "x86_64"
             }
         }
 
-        manifestPlaceholders = [applicationClassName:"ApplicationLoader"]
+        manifestPlaceholders = [applicationClassName:"ApplicationLoader",androidAppLibName:"sfml-activity-d",sfmlAppLibName:"native-lib"]
     }
 }
 
diff --git a/TMessagesProj/jni/Android.mk b/TMessagesProj/jni/Android.mk
index 7aca1fc5d..e140656ee 100755
--- a/TMessagesProj/jni/Android.mk
+++ b/TMessagesProj/jni/Android.mk
@@ -106,6 +106,78 @@ LOCAL_PATH := $(MY_LOCAL_PATH) # restore local path after include
 
 include $(CLEAR_VARS)
 
+LOCAL_MODULE    := sfml-system
+LOCAL_SHORT_COMMANDS := true
+
+LOCAL_SRC_FILES := ./sfml/$(TARGET_ARCH_ABI)/libsfml-system-d.so
+
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := sfml-window
+LOCAL_SHORT_COMMANDS := true
+
+LOCAL_SRC_FILES := ./sfml/$(TARGET_ARCH_ABI)/libsfml-window-d.so
+
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := sfml-graphics
+LOCAL_SHORT_COMMANDS := true
+
+LOCAL_SRC_FILES := ./sfml/$(TARGET_ARCH_ABI)/libsfml-graphics-d.so
+
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := sfml-audio
+LOCAL_SHORT_COMMANDS := true
+
+LOCAL_SRC_FILES := ./sfml/$(TARGET_ARCH_ABI)/libsfml-audio-d.so
+
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := sfml-network
+LOCAL_SHORT_COMMANDS := true
+
+LOCAL_SRC_FILES := ./sfml/$(TARGET_ARCH_ABI)/libsfml-network-d.so
+
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := sfml-activity
+LOCAL_SHORT_COMMANDS := true
+
+LOCAL_SRC_FILES := ./sfml/$(TARGET_ARCH_ABI)/libsfml-activity-d.so
+
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := sfml-main
+LOCAL_SHORT_COMMANDS := true
+
+LOCAL_SRC_FILES := ./sfml/$(TARGET_ARCH_ABI)/libsfml-main-d.a
+
+include $(PREBUILT_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := openal
+LOCAL_SHORT_COMMANDS := true
+
+LOCAL_SRC_FILES := ./sfml/$(TARGET_ARCH_ABI)/libopenal.so
+
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+
 LOCAL_CPPFLAGS := -Wall -std=c++14 -DANDROID -frtti -DHAVE_PTHREAD -finline-functions -ffast-math -O0
 LOCAL_C_INCLUDES += ./jni/boringssl/include/
 LOCAL_ARM_MODE := arm
@@ -286,9 +358,10 @@ LOCAL_SHORT_COMMANDS := true
 LOCAL_CFLAGS 	:= -w -std=c11 -Os -DNULL=0 -DSOCKLEN_T=socklen_t -DLOCALE_NOT_USED -D_LARGEFILE_SOURCE=1
 LOCAL_CFLAGS 	+= -Drestrict='' -D__EMX__ -DOPUS_BUILD -DFIXED_POINT -DUSE_ALLOCA -DHAVE_LRINT -DHAVE_LRINTF -fno-math-errno
 LOCAL_CFLAGS 	+= -DANDROID_NDK -DDISABLE_IMPORTGL -fno-strict-aliasing -fprefetch-loop-arrays -DAVOID_TABLES -DANDROID_TILE_BASED_DECODE -DANDROID_ARMV6_IDCT -ffast-math -D__STDC_CONSTANT_MACROS
-LOCAL_CPPFLAGS 	:= -DBSD=1 -ffast-math -Os -funroll-loops -std=c++14
+LOCAL_CPPFLAGS 	:= -DBSD=1 -ffast-math -Os -funroll-loops -std=c++14 -I./../submodules/SFML/SFML/include
 LOCAL_LDLIBS 	:= -ljnigraphics -llog -lz -latomic -lEGL -lGLESv2 -landroid
-LOCAL_STATIC_LIBRARIES := webp sqlite tgnet swscale avformat avcodec avresample avutil voip flac
+LOCAL_STATIC_LIBRARIES := webp sqlite tgnet swscale avformat avcodec avresample avutil voip flac sfml-main
+LOCAL_SHARED_LIBRARIES := sfml-activity sfml-graphics sfml-window sfml-audio sfml-network sfml-system openal
 
 LOCAL_SRC_FILES     := \
 ./opus/src/opus.c \
@@ -548,7 +621,7 @@ ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)
 endif
 
 LOCAL_SRC_FILES     += \
-./jni.c \
+./jni.cpp \
 ./audio.c \
 ./image.c \
 ./video.c \
@@ -566,7 +639,10 @@ LOCAL_SRC_FILES     += \
 ./exoplayer/ffmpeg_jni.cc \
 ./fast-edge.cpp \
 ./genann.c \
-./secureid_ocr.cpp
+./secureid_ocr.cpp \
+./Log.cpp \
+./native-lib.cpp \
+./main.cpp
 
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/TMessagesProj/jni/Log.cpp b/TMessagesProj/jni/Log.cpp
new file mode 100644
index 000000000..90b8514fc
--- /dev/null
+++ b/TMessagesProj/jni/Log.cpp
@@ -0,0 +1,26 @@
+
+// Author: Pierce Brooks
+
+#include "Log.hpp"
+
+telegramster::Log* telegramster::Log::self = nullptr;
+
+telegramster::Log::Log() :
+    ss(new std::stringstream())
+{
+    self = this;
+}
+
+telegramster::Log::~Log()
+{
+    delete ss;
+}
+
+telegramster::Log* telegramster::Log::getSelf()
+{
+    if (self == nullptr)
+    {
+        new Log();
+    }
+    return self;
+}
diff --git a/TMessagesProj/jni/Log.hpp b/TMessagesProj/jni/Log.hpp
new file mode 100644
index 000000000..9f6609f14
--- /dev/null
+++ b/TMessagesProj/jni/Log.hpp
@@ -0,0 +1,51 @@
+
+// Author: Pierce Brooks
+
+#ifndef TELEGRAMSTER_LOG_HPP
+#define TELEGRAMSTER_LOG_HPP
+
+#include <sstream>
+#include <android/log.h>
+
+#define TAG "NATIVELOGGER"
+#define LOGI(tag, message) __android_log_print(ANDROID_LOG_INFO, tag, "%s", message)
+#define LOGD(tag, message) __android_log_print(ANDROID_LOG_DEBUG, tag, "%s", message)
+#define LOGE(tag, message) __android_log_print(ANDROID_LOG_ERROR, tag, "%s", message)
+#define LOGW(tag, message) __android_log_print(ANDROID_LOG_WARN, tag, "%s", message)
+#define LOGV(tag, message) __android_log_print(ANDROID_LOG_VERBOSE, tag, "%s", message)
+#define LOGGER (*telegramster::Log::getSelf())
+#define LOG(message) telegramster::Log::logThere(message)
+
+namespace telegramster
+{
+    class Log
+    {
+        public:
+            Log();
+            virtual ~Log();
+            template <typename T>
+            Log& operator <<(const T& message)
+            {
+                logHere(message);
+                return *this;
+            }
+            template <typename T>
+            void logHere(const T& message)
+            {
+                *ss << message;
+                LOGD(TAG, ss->str().c_str());
+                ss->str("");
+            }
+            template <typename T>
+            static void logThere(const T& message)
+            {
+                getSelf()->logHere(message);
+            }
+            static Log* getSelf();
+        protected:
+            std::stringstream* ss;
+            static Log* self;
+    };
+}
+
+#endif
diff --git a/TMessagesProj/jni/jni.c b/TMessagesProj/jni/jni.cpp
similarity index 98%
rename from TMessagesProj/jni/jni.c
rename to TMessagesProj/jni/jni.cpp
index 4007f606c..81cfbac52 100644
--- a/TMessagesProj/jni/jni.c
+++ b/TMessagesProj/jni/jni.cpp
@@ -11,6 +11,11 @@
 #include <sys/stat.h>
 #include "image.h"
 #include "libtgvoip/client/android/tg_voip_jni.h"
+#include "native-lib.hpp"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 int registerNativeTgNetFunctions(JavaVM *vm, JNIEnv *env);
 int videoOnJNILoad(JavaVM *vm, JNIEnv *env);
@@ -18,11 +23,11 @@ int videoOnJNILoad(JavaVM *vm, JNIEnv *env);
 jint JNI_OnLoad(JavaVM *vm, void *reserved) {
 	JNIEnv *env = 0;
     srand(time(NULL));
-    
+
 	if ((*vm)->GetEnv(vm, (void **) &env, JNI_VERSION_1_6) != JNI_OK) {
 		return -1;
 	}
-    
+
     if (imageOnJNILoad(vm, env) != JNI_TRUE) {
         return -1;
     }
@@ -36,8 +41,8 @@ jint JNI_OnLoad(JavaVM *vm, void *reserved) {
     }
 
     tgvoipRegisterNatives(env);
-    
-	return JNI_VERSION_1_6;
+
+	return JNIOnLoad(vm, reserved);
 }
 
 void JNI_OnUnload(JavaVM *vm, void *reserved) {
@@ -48,7 +53,7 @@ JNIEXPORT void Java_org_telegramster_messenger_Utilities_aesIgeEncryption(JNIEnv
     jbyte *what = (*env)->GetDirectBufferAddress(env, buffer) + offset;
     unsigned char *keyBuff = (unsigned char *)(*env)->GetByteArrayElements(env, key, NULL);
     unsigned char *ivBuff = (unsigned char *)(*env)->GetByteArrayElements(env, iv, NULL);
-    
+
     AES_KEY akey;
     if (!encrypt) {
         AES_set_decrypt_key(keyBuff, 32 * 8, &akey);
@@ -232,3 +237,7 @@ JNIEXPORT void Java_org_telegramster_messenger_Utilities_clearDir(JNIEnv *env, j
     listdir(fileName, 1, docType, time);
     (*env)->ReleaseStringUTFChars(env, path, fileName);
 }
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/TMessagesProj/jni/main.cpp b/TMessagesProj/jni/main.cpp
new file mode 100644
index 000000000..b598f987e
--- /dev/null
+++ b/TMessagesProj/jni/main.cpp
@@ -0,0 +1,87 @@
+#include "native-lib.hpp"
+
+int main(int argc, char *argv[])
+{
+    // Retrieve the JVM
+    JavaVM* vm = getJvm();
+
+    // Retrieve the JNI environment
+    JNIEnv* env = getEnv();
+
+    jint res = vm->AttachCurrentThread(&env, NULL);
+
+    if (res == JNI_ERR)
+        return EXIT_FAILURE;
+
+    sf::VideoMode screen(sf::VideoMode::getDesktopMode());
+
+    sf::RenderWindow window(screen, "");
+    window.setFramerateLimit(30);
+
+    sf::View view = window.getDefaultView();
+
+    sf::Color background = sf::Color::White;
+
+    // We shouldn't try drawing to the screen while in background
+    // so we'll have to track that. You can do minor background
+    // work, but keep battery life in mind.
+    bool active = true;
+
+    jobject backFlag = env->NewStringUTF("BACK");
+
+    while (window.isOpen())
+    {
+        sf::Event event;
+
+        while (active ? window.pollEvent(event) : window.waitEvent(event))
+        {
+            switch (event.type)
+            {
+                case sf::Event::Closed:
+                    window.close();
+                    break;
+                case sf::Event::KeyPressed:
+                    if (event.key.code == sf::Keyboard::Escape)
+                        window.close();
+                    break;
+                case sf::Event::Resized:
+                    view.setSize(event.size.width, event.size.height);
+                    view.setCenter(event.size.width/2, event.size.height/2);
+                    window.setView(view);
+                    break;
+                case sf::Event::LostFocus:
+                    background = sf::Color::Black;
+                    break;
+                case sf::Event::GainedFocus:
+                    background = sf::Color::White;
+                    break;
+                // On Android MouseLeft/MouseEntered are (for now) triggered,
+                // whenever the app loses or gains focus.
+                case sf::Event::MouseLeft:
+                    active = false;
+                    break;
+                case sf::Event::MouseEntered:
+                    active = true;
+                    break;
+                case sf::Event::TouchBegan:
+                    if (event.touch.finger == 0)
+                    {
+                        vibrate(sf::milliseconds(10));
+                    }
+                    break;
+            }
+        }
+
+        if (active) {
+            window.clear(background);
+            window.display();
+        } else {
+            sf::sleep(sf::milliseconds(100));
+        }
+    }
+
+    // Detach thread again
+    vm->DetachCurrentThread();
+
+    return EXIT_SUCCESS;
+}
diff --git a/TMessagesProj/jni/native-lib.cpp b/TMessagesProj/jni/native-lib.cpp
new file mode 100644
index 000000000..098289840
--- /dev/null
+++ b/TMessagesProj/jni/native-lib.cpp
@@ -0,0 +1,250 @@
+#include "native-lib.hpp"
+
+#include <android/native_activity.h>
+
+// Since we want to get the native activity from SFML, we'll have to use an
+// extra header here:
+#include <SFML/System/NativeActivity.hpp>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+std::map<std::string, jobject>* strings = nullptr;
+JavaVM *gJvm = nullptr;
+static jobject gClassLoader;
+static jmethodID gFindClassMethod;
+
+jint JNIOnLoad(JavaVM *pjvm, void *reserved) {
+    gJvm = pjvm;  // cache the JavaVM pointer
+    auto env = getEnv();
+    //replace with one of your classes in the line below
+    auto randomClass = env->FindClass("org/telegramster/ui/SFMLActivity");
+    jclass classClass = env->GetObjectClass(randomClass);
+    auto classLoaderClass = env->FindClass("java/lang/ClassLoader");
+    auto getClassLoaderMethod = env->GetMethodID(classClass, "getClassLoader", "()Ljava/lang/ClassLoader;");
+    gClassLoader = env->NewGlobalRef(env->CallObjectMethod(randomClass, getClassLoaderMethod));
+    gFindClassMethod = env->GetMethodID(classLoaderClass, "findClass", "(Ljava/lang/String;)Ljava/lang/Class;");
+
+    //gJvm->DetachCurrentThread();
+
+    return JNI_VERSION_1_6;
+}
+
+jobject newString(JNIEnv *env, const char *string) {
+    if (strings == nullptr) {
+        strings = new std::map<std::string, jobject>();
+    }
+    if (strings->find(std::string(string)) == strings->end()) {
+        (*strings)[std::string(string)] = env->NewStringUTF(string);
+    }
+    return (*strings)[std::string(string)];
+}
+
+jclass findClass(const char *name) {
+    return findClassWithEnv(getEnv(), name);
+}
+
+jclass findClassWithEnv(JNIEnv *env, const char *name) {
+    return static_cast<jclass>(env->CallObjectMethod(gClassLoader, gFindClassMethod, newString(env, name)));
+}
+
+JNIEnv *getEnv() {
+    JNIEnv *env;
+    int status = gJvm->GetEnv((void **) &env, JNI_VERSION_1_6);
+    if (status < 0) {
+        status = gJvm->AttachCurrentThread(&env, NULL);
+        if (status < 0) {
+            return nullptr;
+        }
+    }
+    return env;
+}
+
+JavaVM *getJvm() {
+    return gJvm;
+}
+
+int attach(JavaVM** jvm, JNIEnv** env)
+{
+    (*env)->GetJavaVM(jvm);
+
+    JNIEnv* myNewEnv; // as the code to run might be in a different thread (connections to signals for example) we will have a 'new one'
+    JavaVMAttachArgs jvmArgs;
+    jvmArgs.version = JNI_VERSION_1_6;
+
+    int attachedHere = 0; // know if detaching at the end is necessary
+    jint res = (*jvm)->GetEnv((void**)&myNewEnv, JNI_VERSION_1_6); // checks if current env needs attaching or it is already attached
+    if (JNI_EDETACHED == res) {
+        // Supported but not attached yet, needs to call AttachCurrentThread
+        res = (*jvm)->AttachCurrentThread(reinterpret_cast<JNIEnv **>(&myNewEnv), &jvmArgs);
+        if (JNI_OK == res) {
+            attachedHere = 1;
+        } else {
+            // Failed to attach, cancel
+            return attachedHere;
+        }
+    } else if (JNI_OK == res) {
+        // Current thread already attached, do not attach 'again' (just to save the attachedHere flag)
+        // We make sure to keep attachedHere = 0
+    } else {
+        // JNI_EVERSION, specified version is not supported cancel this..
+        return attachedHere;
+    }
+
+    *env = myNewEnv;
+
+    return attachedHere;
+}
+
+int detach(JavaVM* jvm, int attachedHere)
+{
+    if (attachedHere) { // Key check
+        jvm->DetachCurrentThread(); // Done only when attachment was done here
+    }
+    return EXIT_SUCCESS;
+}
+
+int vibrate(sf::Time duration)
+{
+    // First we'll need the native activity handle
+    ANativeActivity *activity = sf::getNativeActivity();
+
+    JavaVM* jvm;
+    JNIEnv* env = getEnv();
+    int attachedHere = attach(&jvm, &env);
+
+    // Retrieve class information
+    jclass natact = findClassWithEnv(env, "org/telegramster/ui/SFMLActivity");
+    jclass context = findClassWithEnv(env, "org/telegramster/ui/SFMLActivity");
+
+    // Get the value of a constant
+    jfieldID fid = env->GetStaticFieldID(context, "VIBRATOR_SERVICE", "Ljava/lang/String;");
+    jobject svcstr = env->GetStaticObjectField(context, fid);
+
+    // Get the method 'getSystemService' and call it
+    jmethodID getss = env->GetMethodID(natact, "getSystemService", "(Ljava/lang/String;)Ljava/lang/Object;");
+    jobject vib_obj = env->CallObjectMethod(activity->clazz, getss, svcstr);
+
+    // Get the object's class and retrieve the member name
+    jclass vib_cls = env->GetObjectClass(vib_obj);
+    jmethodID vibrate = env->GetMethodID(vib_cls, "vibrate", "(J)V");
+
+    // Determine the timeframe
+    jlong length = duration.asMilliseconds();
+
+    env->CallVoidMethod(vib_obj, vibrate, length);
+
+    // Free references
+    env->DeleteLocalRef(vib_obj);
+    env->DeleteLocalRef(vib_cls);
+    env->DeleteLocalRef(svcstr);
+    env->DeleteLocalRef(context);
+    env->DeleteLocalRef(natact);
+
+    detach(jvm, attachedHere);
+
+    return EXIT_SUCCESS;
+}
+
+int play(const std::string& song)
+{
+    // First we'll need the native activity handle
+    ANativeActivity *activity = sf::getNativeActivity();
+
+    JavaVM* jvm;
+    JNIEnv* env = getEnv();
+    int attachedHere = attach(&jvm, &env);
+
+    // Retrieve class information
+    jclass natact = findClassWithEnv(env, "org/telegramster/ui/SFMLActivity");
+
+    // Get the method 'getSelf' and call it
+    jmethodID getss = env->GetStaticMethodID(natact, "getSelf", "()Lorg/telegramster/ui/SFMLActivity;");
+    jobject play_obj = env->CallStaticObjectMethod(natact, getss);
+
+    // Get the object's class and retrieve the member name
+    jclass play_cls = env->GetObjectClass(play_obj);
+    jmethodID play = env->GetMethodID(play_cls, "play", "(Ljava/lang/String;)V");
+
+    env->CallVoidMethod(play_obj, play, env->NewStringUTF(song.c_str()));
+
+    // Free references
+    env->DeleteLocalRef(play_obj);
+    env->DeleteLocalRef(play_cls);
+    env->DeleteLocalRef(natact);
+
+    detach(jvm, attachedHere);
+
+    return EXIT_SUCCESS;
+}
+
+int pause()
+{
+    // First we'll need the native activity handle
+    ANativeActivity *activity = sf::getNativeActivity();
+
+    JavaVM* jvm;
+    JNIEnv* env = getEnv();
+    int attachedHere = attach(&jvm, &env);
+
+    // Retrieve class information
+    jclass natact = findClassWithEnv(env, "org/telegramster/ui/SFMLActivity");
+
+    // Get the method 'getSelf' and call it
+    jmethodID getss = env->GetStaticMethodID(natact, "getSelf", "()Lorg/telegramster/ui/SFMLActivity;");
+    jobject pause_obj = env->CallStaticObjectMethod(natact, getss);
+
+    // Get the object's class and retrieve the member name
+    jclass pause_cls = env->GetObjectClass(pause_obj);
+    jmethodID pause = env->GetMethodID(pause_cls, "pause", "()V");
+
+    env->CallVoidMethod(pause_obj, pause);
+
+    // Free references
+    env->DeleteLocalRef(pause_obj);
+    env->DeleteLocalRef(pause_cls);
+    env->DeleteLocalRef(natact);
+
+    detach(jvm, attachedHere);
+
+    return EXIT_SUCCESS;
+}
+
+bool checkFlag(jobject name)
+{
+    jboolean flag;
+
+    // First we'll need the native activity handle
+    ANativeActivity *activity = sf::getNativeActivity();
+
+    JavaVM* jvm;
+    JNIEnv* env = getEnv();
+    int attachedHere = attach(&jvm, &env);
+
+    // Retrieve class information
+    jclass natact = findClassWithEnv(env, "org/telegramster/ui/SFMLActivity");
+
+    // Get the method 'getSelf' and call it
+    jmethodID getss = env->GetStaticMethodID(natact, "getSelf", "()Lorg/telegramster/ui/SFMLActivity;");
+    jobject check_obj = env->CallStaticObjectMethod(natact, getss);
+
+    // Get the object's class and retrieve the member name
+    jclass check_cls = env->GetObjectClass(check_obj);
+    jmethodID check = env->GetMethodID(check_cls, "checkFlag", "(Ljava/lang/Object;)Z");
+
+    flag = env->CallBooleanMethod(check_obj, check, name);
+
+    // Free references
+    env->DeleteLocalRef(check_obj);
+    env->DeleteLocalRef(check_cls);
+    env->DeleteLocalRef(natact);
+
+    detach(jvm, attachedHere);
+
+    return (bool)flag;
+}
+
+#ifdef __cplusplus
+};
+#endif
diff --git a/TMessagesProj/jni/native-lib.hpp b/TMessagesProj/jni/native-lib.hpp
new file mode 100644
index 000000000..9bcfc7a2d
--- /dev/null
+++ b/TMessagesProj/jni/native-lib.hpp
@@ -0,0 +1,41 @@
+
+#ifndef TELEGRAMSTER_NATIVE_LIB_HPP
+#define TELEGRAMSTER_NATIVE_LIB_HPP
+
+#include <jni.h>
+#include <map>
+#include <string>
+#include <vector>
+#include <iostream>
+
+// SFML
+#include <SFML/System.hpp>
+#include <SFML/Window.hpp>
+#include <SFML/Graphics.hpp>
+#include <SFML/Audio.hpp>
+#include <SFML/Network.hpp>
+
+#include "Log.hpp"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+jint JNIOnLoad(JavaVM *pjvm, void *reserved);
+jobject newString(JNIEnv *env, const char *string);
+jclass findClass(const char *name);
+jclass findClassWithEnv(JNIEnv *env, const char *name);
+JNIEnv *getEnv();
+JavaVM *getJvm();
+int attach(JavaVM** jvm, JNIEnv** env);
+int detach(JavaVM* jvm, int attachedHere);
+int vibrate(sf::Time duration);
+int play(const std::string& song);
+int pause();
+bool checkFlag(jobject name);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
\ No newline at end of file
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libFLAC++.a b/TMessagesProj/jni/sfml/armeabi-v7a/libFLAC++.a
new file mode 100644
index 000000000..fdd44a2bf
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libFLAC++.a differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libFLAC.a b/TMessagesProj/jni/sfml/armeabi-v7a/libFLAC.a
new file mode 100644
index 000000000..d7fb8b1ab
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libFLAC.a differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libfreetype.a b/TMessagesProj/jni/sfml/armeabi-v7a/libfreetype.a
new file mode 100644
index 000000000..88408cb54
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libfreetype.a differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libogg.a b/TMessagesProj/jni/sfml/armeabi-v7a/libogg.a
new file mode 100644
index 000000000..3cf4bd873
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libogg.a differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libopenal.so b/TMessagesProj/jni/sfml/armeabi-v7a/libopenal.so
new file mode 100644
index 000000000..9b5821e7b
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libopenal.so differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-activity-d.so b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-activity-d.so
new file mode 100644
index 000000000..6e1a852ab
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-activity-d.so differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-audio-d.so b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-audio-d.so
new file mode 100644
index 000000000..c9f3e082c
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-audio-d.so differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-graphics-d.so b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-graphics-d.so
new file mode 100644
index 000000000..33ad35d05
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-graphics-d.so differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-main-d.a b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-main-d.a
new file mode 100644
index 000000000..5b070eebe
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-main-d.a differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-network-d.so b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-network-d.so
new file mode 100644
index 000000000..04663ccb6
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-network-d.so differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-system-d.so b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-system-d.so
new file mode 100644
index 000000000..eb7172831
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-system-d.so differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-window-d.so b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-window-d.so
new file mode 100644
index 000000000..f18143c69
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libsfml-window-d.so differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libvorbis.a b/TMessagesProj/jni/sfml/armeabi-v7a/libvorbis.a
new file mode 100644
index 000000000..c3a3cd687
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libvorbis.a differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libvorbisenc.a b/TMessagesProj/jni/sfml/armeabi-v7a/libvorbisenc.a
new file mode 100644
index 000000000..99eb04b00
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libvorbisenc.a differ
diff --git a/TMessagesProj/jni/sfml/armeabi-v7a/libvorbisfile.a b/TMessagesProj/jni/sfml/armeabi-v7a/libvorbisfile.a
new file mode 100644
index 000000000..e2aa66b2a
Binary files /dev/null and b/TMessagesProj/jni/sfml/armeabi-v7a/libvorbisfile.a differ
diff --git a/TMessagesProj/ndk-stl-config.cmake b/TMessagesProj/ndk-stl-config.cmake
new file mode 100644
index 000000000..e047d8c8d
--- /dev/null
+++ b/TMessagesProj/ndk-stl-config.cmake
@@ -0,0 +1,40 @@
+# Copy shared STL files to Android Studio output directory so they can be
+# packaged in the APK.
+# Usage:
+#
+#   find_package(ndk-stl REQUIRED)
+#
+# or
+#
+#   find_package(ndk-stl REQUIRED PATHS ".")
+
+if(NOT ${ANDROID_STL} MATCHES "_shared")
+  return()
+endif()
+
+function(configure_shared_stl lib_path so_base)
+  message("Configuring STL ${so_base} for ${ANDROID_ABI}")
+  configure_file(
+    "${ANDROID_NDK}/sources/cxx-stl/${lib_path}/libs/${ANDROID_ABI}/lib${so_base}.so" 
+    "${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/lib${so_base}.so" 
+    COPYONLY)
+endfunction()
+
+if("${ANDROID_STL}" STREQUAL "libstdc++")
+  # The default minimal system C++ runtime library.
+elseif("${ANDROID_STL}" STREQUAL "gabi++_shared")
+  # The GAbi++ runtime (shared).
+  message(FATAL_ERROR "gabi++_shared was not configured by ndk-stl package")
+elseif("${ANDROID_STL}" STREQUAL "stlport_shared")
+  # The STLport runtime (shared).
+  configure_shared_stl("stlport" "stlport_shared")
+elseif("${ANDROID_STL}" STREQUAL "gnustl_shared")
+  # The GNU STL (shared).
+  configure_shared_stl("gnu-libstdc++/4.9" "gnustl_shared")
+elseif("${ANDROID_STL}" STREQUAL "c++_shared")
+  # The LLVM libc++ runtime (static).
+  configure_shared_stl("llvm-libc++" "c++_shared")
+else()
+   message(FATAL_ERROR "STL configuration ANDROID_STL=${ANDROID_STL} is not supported")
+endif()
+
diff --git a/TMessagesProj/src/main/AndroidManifest.xml b/TMessagesProj/src/main/AndroidManifest.xml
index 59dadf53d..b096aeb39 100644
--- a/TMessagesProj/src/main/AndroidManifest.xml
+++ b/TMessagesProj/src/main/AndroidManifest.xml
@@ -168,6 +168,16 @@
                 <category android:name="android.intent.category.DEFAULT"/>
             </intent-filter>
         </activity>
+        <activity
+            android:name=".SFMLActivity"
+            android:screenOrientation="landscape">
+            <meta-data android:name="android.app.lib_name" android:value="${androidAppLibName}" />
+            <meta-data android:name="sfml.app.lib_name" android:value="${sfmlAppLibName}" />
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
         <activity
             android:name="org.telegramster.ui.IntroActivity"
             android:launchMode="singleTask"
diff --git a/TMessagesProj/src/main/java/org/telegramster/messenger/ApplicationLoader.java b/TMessagesProj/src/main/java/org/telegramster/messenger/ApplicationLoader.java
index 79d74e340..4c1e6bd41 100644
--- a/TMessagesProj/src/main/java/org/telegramster/messenger/ApplicationLoader.java
+++ b/TMessagesProj/src/main/java/org/telegramster/messenger/ApplicationLoader.java
@@ -175,7 +175,7 @@ public void onCreate() {
             applicationContext = getApplicationContext();
         }
 
-        (new AppSignatureHelper(applicationContext)).getAppSignatures();
+        //(new AppSignatureHelper(applicationContext)).getAppSignatures();
 
         NativeLoader.initNativeLibs(ApplicationLoader.applicationContext);
         ConnectionsManager.native_setJava(false);
diff --git a/TMessagesProj/src/main/java/org/telegramster/ui/SFMLActivity.java b/TMessagesProj/src/main/java/org/telegramster/ui/SFMLActivity.java
new file mode 100644
index 000000000..11fd7b23b
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegramster/ui/SFMLActivity.java
@@ -0,0 +1,192 @@
+
+// Author: Pierce Brooks
+
+package org.telegramster.ui;
+
+import android.app.NativeActivity;
+import android.content.Context;
+import android.os.Bundle;
+import android.os.PersistableBundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import org.telegramster.messenger.BuildConfig;
+
+import java.util.HashMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class SFMLActivity extends NativeActivity implements Lock {
+    static {
+        loadLibraries();
+    }
+
+    private static final String TAG = "SFML";
+    private static final String VIBRATOR_SERVICE = Context.VIBRATOR_SERVICE;
+    private static SFMLActivity self = null;
+
+    private HashMap<Object, Boolean> flags;
+    private ReentrantLock lock;
+
+    public SFMLActivity() {
+        super();
+        flags = new HashMap<Object, Boolean>();
+        lock = new ReentrantLock();
+        self = this;
+    }
+
+    public static SFMLActivity getSelf() {
+        return self;
+    }
+
+    @Override
+    public void onBackPressed()
+    {
+        lock();
+        try
+        {
+            flags.put("BACK", true);
+        }
+        catch (Exception exception)
+        {
+            exception.printStackTrace();
+        }
+        finally
+        {
+            unlock();
+        }
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        commonOnCreate(savedInstanceState, null);
+        super.onCreate(savedInstanceState);
+    }
+
+    @Override
+    public void onCreate(@Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState) {
+        commonOnCreate(savedInstanceState, persistentState);
+        super.onCreate(savedInstanceState, persistentState);
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        finish();
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        super.finalize();
+    }
+
+    private void commonOnCreate(@Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState) {
+        loadLibraries();
+    }
+
+    private static void loadLibrary(String library) {
+        loadLibrary(library, true);
+    }
+
+    private static void loadLibrary(String library, boolean variant) {
+        Log.d(TAG, "loadLibrary "+library);
+        if (variant) {
+            if (BuildConfig.DEBUG) {
+                System.loadLibrary(library+"-d");
+                return;
+            }
+        }
+        System.loadLibrary(library);
+    }
+
+    private static void loadLibraries() {
+        loadLibrary("c++_shared", false);
+        loadLibrary("openal", false);
+        loadLibrary("sfml-system");
+        loadLibrary("sfml-window");
+        loadLibrary("sfml-audio");
+        loadLibrary("sfml-graphics");
+        loadLibrary("sfml-network");
+        loadLibrary("sfml-activity");
+        loadLibrary("native-lib", false);
+    }
+
+    @Override
+    public String toString() {
+        return TAG;
+    }
+
+
+    @Override
+    public Object getSystemService(@NonNull String name) {
+        return super.getSystemService(name);
+    }
+
+    public boolean checkFlag(Object name)
+    {
+        boolean flag = false;
+        if (!flags.containsKey(name))
+        {
+            return flag;
+        }
+        lock();
+        try
+        {
+            flag = flags.get(name).booleanValue();
+        }
+        catch (Exception exception)
+        {
+            exception.printStackTrace();
+        }
+        finally
+        {
+            unlock();
+        }
+        flags.put(name, false);
+        return flag;
+    }
+
+    @Override
+    public void lock() {
+        lock.lock();
+    }
+
+    @Override
+    public void lockInterruptibly() throws InterruptedException {
+        lock.lockInterruptibly();
+    }
+
+    @Override
+    public boolean tryLock() {
+        return lock.tryLock();
+    }
+
+    @Override
+    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
+        return lock.tryLock(time, unit);
+    }
+
+    @Override
+    public void unlock() {
+        lock.unlock();
+    }
+
+    @Override
+    public Condition newCondition() {
+        return lock.newCondition();
+    }
+}
diff --git a/gradle.properties b/gradle.properties
index 1757d6d57..875ccbfa4 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -22,3 +22,5 @@ org.gradle.jvmargs=-Xmx4096M -XX:MaxPermSize=4096m
 org.gradle.daemon=true
 org.gradle.parallel=true
 org.gradle.configureondemand=true
+#org.gradle.console=verbose
+#org.gradle.logging.level=debug
diff --git a/submodules/SFML/SFML b/submodules/SFML/SFML
new file mode 160000
index 000000000..2f11710ab
--- /dev/null
+++ b/submodules/SFML/SFML
@@ -0,0 +1 @@
+Subproject commit 2f11710abc5aa478503a7ff3f9e654bd2078ebab
diff --git a/submodules/SFML/build.rb b/submodules/SFML/build.rb
new file mode 100644
index 000000000..6b0e2f26f
--- /dev/null
+++ b/submodules/SFML/build.rb
@@ -0,0 +1,28 @@
+
+# Author: Pierce Brooks
+
+require 'rubygems'
+require 'fileutils'
+
+if (Dir.exists?("build"))
+	FileUtils.remove_entry("build")
+end
+
+Dir.mkdir("build")
+
+cwd = Dir.getwd
+Dir.chdir("build")
+
+command = ["cmake", "-G", ARGV[0], "-DCMAKE_SYSTEM_NAME=Android", "-DCMAKE_ANDROID_NDK="+ARGV[1], "-DCMAKE_ANDROID_ARCH_ABI=armeabi-v7a", "-DCMAKE_ANDROID_STL_TYPE=c++_shared", "-DCMAKE_BUILD_TYPE=Debug", "-DCMAKE_ANDROID_NDK_TOOLCHAIN_VERSION=clang", "./../SFML"]
+print(command.join(" ").to_s+"\n")
+if not (system(*command))
+	exit
+end
+
+command = ["cmake", "--build", "."]
+print(command.join(" ").to_s+"\n")
+if not (system(*command))
+	exit
+end
+
+Dir.chdir(cwd)
diff --git a/submodules/SFML/build.txt b/submodules/SFML/build.txt
new file mode 100644
index 000000000..1f353a159
--- /dev/null
+++ b/submodules/SFML/build.txt
@@ -0,0 +1,2 @@
+
+ruby build.rb "MinGW Makefiles" "E:/UserData/Programs/AndroidSDK/ndk-bundle"
