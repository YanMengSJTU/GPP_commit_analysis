diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
index f8ca9bc5a..134ee9944 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
@@ -97,6 +97,10 @@
             R.drawable.group_blue,
             R.drawable.group_yellow};
 
+    public static enum HASH_TYPE { SHA1, SHA256 };
+    public static String[] HASH_TYPE_STR = { "SHA-1", "SHA-256" };
+    public static String EXTENDED_CRYPTO_MSG = "I support extended crypto!\1\3\3\7";
+
     public static int externalCacheNotAvailableState = 0;
 
     final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();
@@ -340,6 +344,16 @@ public static TPFactorizedValue getFactorizedValue(long what) {
         return null;
     }
 
+    public static byte[] computeSHA256(byte[] convertme) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA-256");
+            return md.digest(convertme);
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return null;
+    }
+
     public static byte[] encryptWithRSA(BigInteger[] key, byte[] data) {
         try {
             KeyFactory fact = KeyFactory.getInstance("RSA");
@@ -423,6 +437,73 @@ public static MessageKeyData generateMessageKeyData(byte[] authKey, byte[] messa
         return keyData;
     }
 
+    public static MessageKeyData generateSecureMessageKeyData(byte[] authKey, byte[] messageKey, boolean incoming, final HASH_TYPE hash_type) {
+        MessageKeyData keyData = new MessageKeyData();
+        if (authKey == null || authKey.length == 0) {
+            keyData.aesIv = null;
+            keyData.aesKey = null;
+            return keyData;
+        }
+
+        int x = incoming ? 8 : 0;
+
+        SerializedData data = new SerializedData();
+        data.writeRaw(messageKey);
+        data.writeRaw(authKey, x, 32);
+        byte[] sha1_a = null;
+        if(hash_type == HASH_TYPE.SHA256){
+            sha1_a = Utilities.computeSHA256(data.toByteArray());
+        } else {
+            sha1_a = Utilities.computeSHA1(data.toByteArray());
+        }
+
+        data = new SerializedData();
+        data.writeRaw(authKey, 32 + x, 16);
+        data.writeRaw(messageKey);
+        data.writeRaw(authKey, 48 + x, 16);
+        byte[] sha1_b = null;
+        if(hash_type == HASH_TYPE.SHA256){
+            sha1_b = Utilities.computeSHA256(data.toByteArray());
+        } else {
+            sha1_b = Utilities.computeSHA1(data.toByteArray());
+        }
+
+        data = new SerializedData();
+        data.writeRaw(authKey, 64 + x, 32);
+        data.writeRaw(messageKey);
+        byte[] sha1_c = null;
+        if(hash_type == HASH_TYPE.SHA256){
+            sha1_c = Utilities.computeSHA256(data.toByteArray());
+        } else {
+            sha1_c = Utilities.computeSHA1(data.toByteArray());
+        }
+
+        data = new SerializedData();
+        data.writeRaw(messageKey);
+        data.writeRaw(authKey, 96 + x, 32);
+        byte[] sha1_d = null;
+        if(hash_type == HASH_TYPE.SHA256){
+            sha1_d = Utilities.computeSHA256(data.toByteArray());
+        } else {
+            sha1_d = Utilities.computeSHA1(data.toByteArray());
+        }
+
+        SerializedData aesKey = new SerializedData();
+        aesKey.writeRaw(sha1_a, 0, 8);
+        aesKey.writeRaw(sha1_b, 8, 12);
+        aesKey.writeRaw(sha1_c, 4, 12);
+        keyData.aesKey = aesKey.toByteArray();
+
+        SerializedData aesIv = new SerializedData();
+        aesIv.writeRaw(sha1_a, 8, 12);
+        aesIv.writeRaw(sha1_b, 0, 8);
+        aesIv.writeRaw(sha1_c, 16, 4);
+        aesIv.writeRaw(sha1_d, 0, 8);
+        keyData.aesIv = aesIv.toByteArray();
+
+        return keyData;
+    }
+
     public static TLObject decompress(byte[] data, TLObject parentObject) {
         final int BUFFER_SIZE = 512;
         ByteArrayInputStream is = new ByteArrayInputStream(data);
