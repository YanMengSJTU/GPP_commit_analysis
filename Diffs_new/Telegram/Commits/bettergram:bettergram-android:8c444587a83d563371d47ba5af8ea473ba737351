diff --git a/TMessagesProj/src/main/java/io/bettergram/adapters/NewsAdapter.java b/TMessagesProj/src/main/java/io/bettergram/adapters/NewsAdapter.java
index eb7ab5694..eb2da5cc7 100644
--- a/TMessagesProj/src/main/java/io/bettergram/adapters/NewsAdapter.java
+++ b/TMessagesProj/src/main/java/io/bettergram/adapters/NewsAdapter.java
@@ -11,6 +11,7 @@
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.text.Html;
+import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -26,6 +27,7 @@
 import io.bettergram.telegram.messenger.support.widget.RecyclerView;
 import io.bettergram.telegram.ui.ActionBar.Theme;
 import io.bettergram.telegram.ui.Components.CardView.CardView;
+import io.bettergram.telegram.ui.Components.PullToRefresh.PullRefreshLayout;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -33,7 +35,7 @@
 
 import static io.bettergram.service.api.NewsApi.formatToYesterdayOrToday;
 
-public class NewsAdapter extends RecyclerView.Adapter<NewsAdapter.NewsViewHolder> {
+public class NewsAdapter extends RecyclerView.Adapter<NewsAdapter.NewsViewHolder> implements PullRefreshLayout.OnRefreshListener {
 
     /**
      * Receives data from {@link NewsDataService}
@@ -71,15 +73,27 @@ public void run() {
         }
     }
 
+    @Override
+    public void onRefresh(PullRefreshLayout ptrLayout) {
+        if (this.ptrLayout == null) {
+            this.ptrLayout = ptrLayout;
+        }
+        startService(activity);
+    }
+
+    private Activity activity;
+    private PullRefreshLayout ptrLayout;
     private List<News> newsList = new ArrayList<>();
 
+    public NewsAdapter(Activity activity) {
+        this.activity = activity;
+    }
+
     class NewsViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener, ImageReceiver.ImageReceiverDelegate {
 
         ImageReceiver newsPhoto;
-
         ImageView imageThumb;
         TextView textTitle, textAccount, textDatePosted;
-
         News news;
 
         NewsViewHolder(View itemView) {
@@ -129,6 +143,10 @@ public void onClick(View v) {
     }
 
     public void setNewsList(List<News> newsList) {
+        if (ptrLayout != null) {
+            ptrLayout.setRefreshing(false);
+        }
+
         this.newsList.clear();
         this.newsList.addAll(newsList);
         AndroidUtilities.runOnUIThread(this::notifyDataSetChanged);
@@ -155,7 +173,6 @@ public void onBindViewHolder(NewsViewHolder holder, int position) {
         final News news = newsList.get(position);
 
         holder.news = news;
-
         holder.newsPhoto.setImage(
                 news.urlToImage,
                 null,
diff --git a/TMessagesProj/src/main/java/io/bettergram/adapters/YouTubePlayerAdapter.java b/TMessagesProj/src/main/java/io/bettergram/adapters/YouTubePlayerAdapter.java
index 876274bfa..a3134b195 100644
--- a/TMessagesProj/src/main/java/io/bettergram/adapters/YouTubePlayerAdapter.java
+++ b/TMessagesProj/src/main/java/io/bettergram/adapters/YouTubePlayerAdapter.java
@@ -26,6 +26,7 @@
 import io.bettergram.telegram.messenger.support.widget.RecyclerView;
 import io.bettergram.telegram.ui.ActionBar.Theme;
 import io.bettergram.telegram.ui.Components.CardView.CardView;
+import io.bettergram.telegram.ui.Components.PullToRefresh.PullRefreshLayout;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -35,7 +36,7 @@
 import static io.bettergram.service.api.VideosApi.formatToYesterdayOrToday;
 
 public class YouTubePlayerAdapter extends
-        RecyclerView.Adapter<YouTubePlayerAdapter.YouTubePlayerViewHolder> {
+        RecyclerView.Adapter<YouTubePlayerAdapter.YouTubePlayerViewHolder> implements PullRefreshLayout.OnRefreshListener {
 
     /**
      * Receives data from {@link YoutubeDataService}
@@ -73,13 +74,30 @@ public void run() {
         }
     }
 
+    @Override
+    public void onRefresh(PullRefreshLayout ptrLayout) {
+        if (this.ptrLayout == null) {
+            this.ptrLayout = ptrLayout;
+        }
+        startService(activity);
+    }
+
+    private Activity activity;
+    private PullRefreshLayout ptrLayout;
     private List<Video> videos = new ArrayList<>();
-    private Context context;
     private FragmentManager fragmentManager;
     private int playerType;
     private String apiKey;
     private String webviewUrl;
 
+    public YouTubePlayerAdapter(Activity activity) {
+        this.activity = activity;
+        this.fragmentManager = activity.getFragmentManager();
+        this.playerType = STRICT_NATIVE;
+        this.apiKey = activity.getString(R.string.youtube_api_key);
+        this.webviewUrl = activity.getString(R.string.youtube_webview_url);
+    }
+
     class YouTubePlayerViewHolder extends RecyclerView.ViewHolder implements ImageReceiver.ImageReceiverDelegate {
         ImageReceiver videoPhoto;
         YouTubePlayerView playerView;
@@ -125,6 +143,9 @@ public void didSetImage(ImageReceiver imageReceiver, boolean set, boolean thumb)
     }
 
     public void setVideos(List<Video> videos) {
+        if (ptrLayout != null) {
+            ptrLayout.setRefreshing(false);
+        }
         if (videos == null || videos.isEmpty()) {
             return;
         }
@@ -133,14 +154,6 @@ public void setVideos(List<Video> videos) {
         notifyDataSetChanged();
     }
 
-    public YouTubePlayerAdapter(Activity activity) {
-        this.context = activity;
-        this.fragmentManager = activity.getFragmentManager();
-        this.playerType = STRICT_NATIVE;
-        this.apiKey = context.getString(R.string.youtube_api_key);
-        this.webviewUrl = context.getString(R.string.youtube_webview_url);
-    }
-
     @Override
     public int getItemCount() {
         return videos.size();
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java b/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java
index 933889c7d..5d3c0bbbc 100644
--- a/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java
+++ b/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java
@@ -88,10 +88,7 @@ private void startTimer(Intent intent) {
 
         for (int i = 0, size = list.size(); i < size; i++) {
             final int index = i;
-
-            CryptoCurrency foundCurrency = CollectionUtil.find(currencies,
-                    (CryptoCurrency item) -> list.get(index).code.equals(item.code));
-
+            CryptoCurrency foundCurrency = CollectionUtil.find(currencies, item -> list.get(index).code.equals(item.code));
             if (foundCurrency != null) {
                 list.get(index).icon = foundCurrency.icon;
                 list.get(index).name = foundCurrency.name;
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/NewsDataService.java b/TMessagesProj/src/main/java/io/bettergram/service/NewsDataService.java
index 5badbf0a1..f7c41e158 100644
--- a/TMessagesProj/src/main/java/io/bettergram/service/NewsDataService.java
+++ b/TMessagesProj/src/main/java/io/bettergram/service/NewsDataService.java
@@ -9,6 +9,7 @@
 import io.bettergram.service.api.NewsApi;
 import io.bettergram.telegram.messenger.ApplicationLoader;
 import io.bettergram.telegram.messenger.NotificationCenter;
+import io.bettergram.utils.CollectionUtil;
 import io.bettergram.utils.io.IOUtils;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -42,8 +43,7 @@
 
     public static boolean isIntentServiceRunning = false;
 
-    private SharedPreferences preferences = ApplicationLoader.applicationContext
-            .getSharedPreferences(NEWS_PREF, Context.MODE_PRIVATE);
+    private SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences(NEWS_PREF, Context.MODE_PRIVATE);
 
     public NewsDataService() {
         super("NewsDataService");
@@ -148,9 +148,20 @@ protected void onHandleIntent(Intent intent) {
 
                     NewsList newsList = new NewsList();
                     newsList.articles = articles;
+
                     if (isEmpty(jsonRaw)) {
-                        publishResults(NewsList__JsonHelper.serializeToJson(newsList), NOTIFICATION,
-                                RESULT);
+                        publishResults(NewsList__JsonHelper.serializeToJson(newsList), NOTIFICATION, RESULT);
+                    } else {
+                        NewsList savedNewsList = NewsList__JsonHelper.parseFromJson(jsonRaw);
+                        for (int i = 0, size = newsList.articles.size(); i < size; i++) {
+                            final News article = newsList.articles.get(i);
+                            News foundNews = CollectionUtil.find(savedNewsList.articles, item -> article.url.equals(item.url));
+                            if (foundNews != null) {
+                                newsList.articles.get(i).urlToImage = foundNews.urlToImage;
+                            }
+                        }
+                        newsList.sortArticlesByDate();
+                        publishResults(NewsList__JsonHelper.serializeToJson(newsList), NOTIFICATION, RESULT);
                     }
                 } else {
                     if (response.code() == 410) {
diff --git a/TMessagesProj/src/main/java/io/bettergram/telegram/ui/Components/PullToRefresh/PullRefreshLayout.java b/TMessagesProj/src/main/java/io/bettergram/telegram/ui/Components/PullToRefresh/PullRefreshLayout.java
new file mode 100644
index 000000000..5bc3c7d2e
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/telegram/ui/Components/PullToRefresh/PullRefreshLayout.java
@@ -0,0 +1,520 @@
+package io.bettergram.telegram.ui.Components.PullToRefresh;
+
+import android.content.Context;
+import android.support.v4.view.MotionEventCompat;
+import android.support.v4.view.ViewCompat;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.animation.Animation;
+import android.view.animation.DecelerateInterpolator;
+import android.view.animation.Interpolator;
+import android.view.animation.Transformation;
+import android.widget.AbsListView;
+import android.widget.ImageView;
+import io.bettergram.telegram.ui.ActionBar.Theme;
+
+import java.security.InvalidParameterException;
+
+/**
+ * Created by baoyz on 14/10/30.
+ */
+public class PullRefreshLayout extends ViewGroup {
+
+    private static final float DECELERATE_INTERPOLATION_FACTOR = 2f;
+    private static final int DRAG_MAX_DISTANCE = 64;
+    private static final int INVALID_POINTER = -1;
+    private static final float DRAG_RATE = .5f;
+
+    public static final int STYLE_MATERIAL = 0;
+    public static final int STYLE_CIRCLES = 1;
+    public static final int STYLE_WATER_DROP = 2;
+    public static final int STYLE_RING = 3;
+    public static final int STYLE_SMARTISAN = 4;
+
+    private View mTarget;
+    private ImageView mRefreshView;
+    private Interpolator mDecelerateInterpolator;
+    private int mTouchSlop;
+    private int mSpinnerFinalOffset;
+    private int mTotalDragDistance;
+    private RefreshDrawable mRefreshDrawable;
+    private int mCurrentOffsetTop;
+    private boolean mRefreshing;
+    private int mActivePointerId;
+    private boolean mIsBeingDragged;
+    private float mInitialMotionY;
+    private int mFrom;
+    private boolean mNotify;
+    private OnRefreshListener mListener;
+    private int[] mColorSchemeColors;
+
+    public int mDurationToStartPosition;
+    public int mDurationToCorrectPosition;
+    private int mInitialOffsetTop;
+    private boolean mDispatchTargetTouchDown;
+    private float mDragPercent;
+
+    public PullRefreshLayout(Context context) {
+        this(context, null);
+    }
+
+    public PullRefreshLayout(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        mDecelerateInterpolator = new DecelerateInterpolator(DECELERATE_INTERPOLATION_FACTOR);
+        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
+        int defaultDuration = getResources().getInteger(android.R.integer.config_mediumAnimTime);
+        mDurationToStartPosition = defaultDuration;
+        mDurationToCorrectPosition = defaultDuration;
+        mSpinnerFinalOffset = mTotalDragDistance = dp2px(DRAG_MAX_DISTANCE);
+
+        int color = Theme.getColor(Theme.key_bottombar_activeColor);
+        mColorSchemeColors = new int[]{color, color, color, color};
+
+        mRefreshView = new ImageView(context);
+        setRefreshStyle(STYLE_RING);
+        mRefreshView.setVisibility(View.GONE);
+        addView(mRefreshView, 0);
+        setWillNotDraw(false);
+        ViewCompat.setChildrenDrawingOrderEnabled(this, true);
+    }
+
+    public void setColorSchemeColors(int... colorSchemeColors) {
+        mColorSchemeColors = colorSchemeColors;
+        mRefreshDrawable.setColorSchemeColors(colorSchemeColors);
+    }
+
+    public void setColor(int color) {
+        setColorSchemeColors(color);
+    }
+
+    public void setRefreshStyle(int type) {
+        setRefreshing(false);
+        switch (type) {
+            case STYLE_MATERIAL:
+                //mRefreshDrawable = new MaterialDrawable(getContext(), this);
+                break;
+            case STYLE_CIRCLES:
+                //mRefreshDrawable = new CirclesDrawable(getContext(), this);
+                break;
+            case STYLE_WATER_DROP:
+                //mRefreshDrawable = new WaterDropDrawable(getContext(), this);
+                break;
+            case STYLE_RING:
+                mRefreshDrawable = new RingDrawable(getContext(), this);
+                break;
+            case STYLE_SMARTISAN:
+                //mRefreshDrawable = new SmartisanDrawable(getContext(), this);
+                break;
+            default:
+                throw new InvalidParameterException("Type does not exist");
+        }
+        mRefreshDrawable.setColorSchemeColors(mColorSchemeColors);
+        mRefreshView.setImageDrawable(mRefreshDrawable);
+    }
+
+    public void setRefreshDrawable(RefreshDrawable drawable) {
+        setRefreshing(false);
+        mRefreshDrawable = drawable;
+        mRefreshDrawable.setColorSchemeColors(mColorSchemeColors);
+        mRefreshView.setImageDrawable(mRefreshDrawable);
+    }
+
+    public int getDuration() {
+        return mDurationToCorrectPosition;
+    }
+
+    public int getFinalOffset() {
+        return mSpinnerFinalOffset;
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        ensureTarget();
+        if (mTarget == null)
+            return;
+
+        widthMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth() - getPaddingRight() - getPaddingLeft(), MeasureSpec.EXACTLY);
+        heightMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), MeasureSpec.EXACTLY);
+        mTarget.measure(widthMeasureSpec, heightMeasureSpec);
+        mRefreshView.measure(widthMeasureSpec, heightMeasureSpec);
+//        mRefreshView.measure(MeasureSpec.makeMeasureSpec(mRefreshViewWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(mRefreshViewHeight, MeasureSpec.EXACTLY));
+    }
+
+    private void ensureTarget() {
+        if (mTarget != null)
+            return;
+        if (getChildCount() > 0) {
+            for (int i = 0; i < getChildCount(); i++) {
+                View child = getChildAt(i);
+                if (child != mRefreshView)
+                    mTarget = child;
+            }
+        }
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent ev) {
+
+        if (!isEnabled() || (canChildScrollUp() && !mRefreshing)) {
+            return false;
+        }
+
+        final int action = MotionEventCompat.getActionMasked(ev);
+
+        switch (action) {
+            case MotionEvent.ACTION_DOWN:
+                if (!mRefreshing) {
+                    setTargetOffsetTop(0, true);
+                }
+                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
+                mIsBeingDragged = false;
+                final float initialMotionY = getMotionEventY(ev, mActivePointerId);
+                if (initialMotionY == -1) {
+                    return false;
+                }
+                mInitialMotionY = initialMotionY;
+                mInitialOffsetTop = mCurrentOffsetTop;
+                mDispatchTargetTouchDown = false;
+                mDragPercent = 0;
+                break;
+            case MotionEvent.ACTION_MOVE:
+                if (mActivePointerId == INVALID_POINTER) {
+                    return false;
+                }
+                final float y = getMotionEventY(ev, mActivePointerId);
+                if (y == -1) {
+                    return false;
+                }
+                final float yDiff = y - mInitialMotionY;
+                if (mRefreshing) {
+                    mIsBeingDragged = !(yDiff < 0 && mCurrentOffsetTop <= 0);
+                } else if (yDiff > mTouchSlop && !mIsBeingDragged) {
+                    mIsBeingDragged = true;
+                }
+                break;
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_CANCEL:
+                mIsBeingDragged = false;
+                mActivePointerId = INVALID_POINTER;
+                break;
+            case MotionEventCompat.ACTION_POINTER_UP:
+                onSecondaryPointerUp(ev);
+                break;
+        }
+
+        return mIsBeingDragged;
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent ev) {
+
+        if (!mIsBeingDragged) {
+            return super.onTouchEvent(ev);
+        }
+
+        final int action = MotionEventCompat.getActionMasked(ev);
+
+        switch (action) {
+            case MotionEvent.ACTION_MOVE: {
+                final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
+                if (pointerIndex < 0) {
+                    return false;
+                }
+
+                final float y = MotionEventCompat.getY(ev, pointerIndex);
+                final float yDiff = y - mInitialMotionY;
+                int targetY;
+                if (mRefreshing) {
+                    targetY = (int) (mInitialOffsetTop + yDiff);
+                    if (canChildScrollUp()) {
+                        targetY = -1;
+                        mInitialMotionY = y;
+                        mInitialOffsetTop = 0;
+                        if (mDispatchTargetTouchDown) {
+                            mTarget.dispatchTouchEvent(ev);
+                        } else {
+                            MotionEvent obtain = MotionEvent.obtain(ev);
+                            obtain.setAction(MotionEvent.ACTION_DOWN);
+                            mDispatchTargetTouchDown = true;
+                            mTarget.dispatchTouchEvent(obtain);
+                        }
+                    } else {
+                        if (targetY < 0) {
+                            if (mDispatchTargetTouchDown) {
+                                mTarget.dispatchTouchEvent(ev);
+                            } else {
+                                MotionEvent obtain = MotionEvent.obtain(ev);
+                                obtain.setAction(MotionEvent.ACTION_DOWN);
+                                mDispatchTargetTouchDown = true;
+                                mTarget.dispatchTouchEvent(obtain);
+                            }
+                            targetY = 0;
+                        } else if (targetY > mTotalDragDistance) {
+                            targetY = mTotalDragDistance;
+                        } else {
+                            if (mDispatchTargetTouchDown) {
+                                MotionEvent obtain = MotionEvent.obtain(ev);
+                                obtain.setAction(MotionEvent.ACTION_CANCEL);
+                                mDispatchTargetTouchDown = false;
+                                mTarget.dispatchTouchEvent(obtain);
+                            }
+                        }
+                    }
+                } else {
+                    final float scrollTop = yDiff * DRAG_RATE;
+                    float originalDragPercent = scrollTop / mTotalDragDistance;
+                    if (originalDragPercent < 0) {
+                        return false;
+                    }
+                    mDragPercent = Math.min(1f, Math.abs(originalDragPercent));
+                    float extraOS = Math.abs(scrollTop) - mTotalDragDistance;
+                    float slingshotDist = mSpinnerFinalOffset;
+                    float tensionSlingshotPercent = Math.max(0,
+                            Math.min(extraOS, slingshotDist * 2) / slingshotDist);
+                    float tensionPercent = (float) ((tensionSlingshotPercent / 4) - Math.pow(
+                            (tensionSlingshotPercent / 4), 2)) * 2f;
+                    float extraMove = (slingshotDist) * tensionPercent * 2;
+                    targetY = (int) ((slingshotDist * mDragPercent) + extraMove);
+                    if (mRefreshView.getVisibility() != View.VISIBLE) {
+                        mRefreshView.setVisibility(View.VISIBLE);
+                    }
+                    if (scrollTop < mTotalDragDistance) {
+                        mRefreshDrawable.setPercent(mDragPercent);
+                    }
+                }
+                setTargetOffsetTop(targetY - mCurrentOffsetTop, true);
+                break;
+            }
+            case MotionEventCompat.ACTION_POINTER_DOWN:
+                final int index = MotionEventCompat.getActionIndex(ev);
+                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
+                break;
+            case MotionEventCompat.ACTION_POINTER_UP:
+                onSecondaryPointerUp(ev);
+                break;
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_CANCEL: {
+                if (mActivePointerId == INVALID_POINTER) {
+                    return false;
+                }
+                if (mRefreshing) {
+                    if (mDispatchTargetTouchDown) {
+                        mTarget.dispatchTouchEvent(ev);
+                        mDispatchTargetTouchDown = false;
+                    }
+                    return false;
+                }
+                int pointerCount = MotionEventCompat.getPointerCount(ev);
+                final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
+                if (pointerIndex > -1 && pointerIndex < pointerCount) {
+                    final float y = MotionEventCompat.getY(ev, pointerIndex);
+                    final float overscrollTop = (y - mInitialMotionY) * DRAG_RATE;
+                    mIsBeingDragged = false;
+                    if (overscrollTop > mTotalDragDistance) {
+                        setRefreshing(true, true);
+                    } else {
+                        mRefreshing = false;
+                        animateOffsetToStartPosition();
+                    }
+                    mActivePointerId = INVALID_POINTER;
+                }
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public void setDurations(int durationToStartPosition, int durationToCorrectPosition) {
+        mDurationToStartPosition = durationToStartPosition;
+        mDurationToCorrectPosition = durationToCorrectPosition;
+    }
+
+    private void animateOffsetToStartPosition() {
+        mFrom = mCurrentOffsetTop;
+        mAnimateToStartPosition.reset();
+        mAnimateToStartPosition.setDuration(mDurationToStartPosition);
+        mAnimateToStartPosition.setInterpolator(mDecelerateInterpolator);
+        mAnimateToStartPosition.setAnimationListener(mToStartListener);
+        mRefreshView.clearAnimation();
+        mRefreshView.startAnimation(mAnimateToStartPosition);
+    }
+
+    private void animateOffsetToCorrectPosition() {
+        mFrom = mCurrentOffsetTop;
+        mAnimateToCorrectPosition.reset();
+        mAnimateToCorrectPosition.setDuration(mDurationToCorrectPosition);
+        mAnimateToCorrectPosition.setInterpolator(mDecelerateInterpolator);
+        mAnimateToCorrectPosition.setAnimationListener(mRefreshListener);
+        mRefreshView.clearAnimation();
+        mRefreshView.startAnimation(mAnimateToCorrectPosition);
+    }
+
+    private final Animation mAnimateToStartPosition = new Animation() {
+        @Override
+        public void applyTransformation(float interpolatedTime, Transformation t) {
+            moveToStart(interpolatedTime);
+        }
+    };
+
+    private final Animation mAnimateToCorrectPosition = new Animation() {
+        @Override
+        public void applyTransformation(float interpolatedTime, Transformation t) {
+            int endTarget = mSpinnerFinalOffset;
+            int targetTop = (mFrom + (int) ((endTarget - mFrom) * interpolatedTime));
+            int offset = targetTop - mTarget.getTop();
+            setTargetOffsetTop(offset, false /* requires update */);
+        }
+    };
+
+    private void moveToStart(float interpolatedTime) {
+        int targetTop = mFrom - (int) (mFrom * interpolatedTime);
+        int offset = targetTop - mTarget.getTop();
+        setTargetOffsetTop(offset, false);
+        mRefreshDrawable.setPercent(mDragPercent * (1 - interpolatedTime));
+    }
+
+    public void setRefreshing(boolean refreshing) {
+        if (mRefreshing != refreshing) {
+            setRefreshing(refreshing, false /* notify */);
+        }
+    }
+
+    private void setRefreshing(boolean refreshing, final boolean notify) {
+        if (mRefreshing != refreshing) {
+            mNotify = notify;
+            ensureTarget();
+            mRefreshing = refreshing;
+            if (mRefreshing) {
+                mRefreshDrawable.setPercent(1f);
+                animateOffsetToCorrectPosition();
+            } else {
+                animateOffsetToStartPosition();
+            }
+        }
+    }
+
+    private Animation.AnimationListener mRefreshListener = new Animation.AnimationListener() {
+        @Override
+        public void onAnimationStart(Animation animation) {
+            mRefreshView.setVisibility(View.VISIBLE);
+        }
+
+        @Override
+        public void onAnimationRepeat(Animation animation) {
+        }
+
+        @Override
+        public void onAnimationEnd(Animation animation) {
+            if (mRefreshing) {
+                mRefreshDrawable.start();
+                if (mNotify) {
+                    if (mListener != null) {
+                        mListener.onRefresh(PullRefreshLayout.this);
+                    }
+                }
+            } else {
+                mRefreshDrawable.stop();
+                mRefreshView.setVisibility(View.GONE);
+                animateOffsetToStartPosition();
+            }
+            mCurrentOffsetTop = mTarget.getTop();
+        }
+    };
+
+    private Animation.AnimationListener mToStartListener = new Animation.AnimationListener() {
+        @Override
+        public void onAnimationStart(Animation animation) {
+            mRefreshDrawable.stop();
+        }
+
+        @Override
+        public void onAnimationRepeat(Animation animation) {
+        }
+
+        @Override
+        public void onAnimationEnd(Animation animation) {
+//            mRefreshDrawable.stop();
+            mRefreshView.setVisibility(View.GONE);
+            mCurrentOffsetTop = mTarget.getTop();
+        }
+    };
+
+    private void onSecondaryPointerUp(MotionEvent ev) {
+        final int pointerIndex = MotionEventCompat.getActionIndex(ev);
+        final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
+        if (pointerId == mActivePointerId) {
+            final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
+            mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
+        }
+    }
+
+    private float getMotionEventY(MotionEvent ev, int activePointerId) {
+        final int index = MotionEventCompat.findPointerIndex(ev, activePointerId);
+        if (index < 0) {
+            return -1;
+        }
+        return MotionEventCompat.getY(ev, index);
+    }
+
+    private void setTargetOffsetTop(int offset, boolean requiresUpdate) {
+//        mRefreshView.bringToFront();
+        mTarget.offsetTopAndBottom(offset);
+        mCurrentOffsetTop = mTarget.getTop();
+        mRefreshDrawable.offsetTopAndBottom(offset);
+        if (requiresUpdate && android.os.Build.VERSION.SDK_INT < 11) {
+            invalidate();
+        }
+    }
+
+    private boolean canChildScrollUp() {
+        if (android.os.Build.VERSION.SDK_INT < 14) {
+            if (mTarget instanceof AbsListView) {
+                final AbsListView absListView = (AbsListView) mTarget;
+                return absListView.getChildCount() > 0
+                        && (absListView.getFirstVisiblePosition() > 0 || absListView.getChildAt(0)
+                        .getTop() < absListView.getPaddingTop());
+            } else {
+                return mTarget.getScrollY() > 0;
+            }
+        } else {
+            return ViewCompat.canScrollVertically(mTarget, -1);
+        }
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+
+        ensureTarget();
+        if (mTarget == null)
+            return;
+
+        int height = getMeasuredHeight();
+        int width = getMeasuredWidth();
+        int left = getPaddingLeft();
+        int top = getPaddingTop();
+        int right = getPaddingRight();
+        int bottom = getPaddingBottom();
+
+        mTarget.layout(left, top + mTarget.getTop(), left + width - right, top + height - bottom + mTarget.getTop());
+        mRefreshView.layout(left, top, left + width - right, top + height - bottom);
+    }
+
+    private int dp2px(int dp) {
+        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, getContext().getResources().getDisplayMetrics());
+    }
+
+    public void setOnRefreshListener(OnRefreshListener listener) {
+        mListener = listener;
+    }
+
+    public static interface OnRefreshListener {
+        public void onRefresh(PullRefreshLayout layout);
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/telegram/ui/Components/PullToRefresh/RefreshDrawable.java b/TMessagesProj/src/main/java/io/bettergram/telegram/ui/Components/PullToRefresh/RefreshDrawable.java
new file mode 100644
index 000000000..cf0e95c8f
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/telegram/ui/Components/PullToRefresh/RefreshDrawable.java
@@ -0,0 +1,71 @@
+package io.bettergram.telegram.ui.Components.PullToRefresh;
+
+import android.content.Context;
+import android.graphics.ColorFilter;
+import android.graphics.PixelFormat;
+import android.graphics.drawable.Animatable;
+import android.graphics.drawable.Drawable;
+
+/**
+ * Created by baoyz on 14/10/29.
+ */
+public abstract class RefreshDrawable extends Drawable implements Drawable.Callback, Animatable {
+
+    private PullRefreshLayout mRefreshLayout;
+
+    public RefreshDrawable(Context context, PullRefreshLayout layout) {
+        mRefreshLayout = layout;
+    }
+
+    public Context getContext(){
+        return mRefreshLayout != null ? mRefreshLayout.getContext() : null;
+    }
+
+    public PullRefreshLayout getRefreshLayout(){
+        return mRefreshLayout;
+    }
+
+    public abstract void setPercent(float percent);
+    public abstract void setColorSchemeColors(int[] colorSchemeColors);
+
+    public abstract void offsetTopAndBottom(int offset);
+
+    @Override
+    public void invalidateDrawable(Drawable who) {
+        final Callback callback = getCallback();
+        if (callback != null) {
+            callback.invalidateDrawable(this);
+        }
+    }
+
+    @Override
+    public void scheduleDrawable(Drawable who, Runnable what, long when) {
+        final Callback callback = getCallback();
+        if (callback != null) {
+            callback.scheduleDrawable(this, what, when);
+        }
+    }
+
+    @Override
+    public void unscheduleDrawable(Drawable who, Runnable what) {
+        final Callback callback = getCallback();
+        if (callback != null) {
+            callback.unscheduleDrawable(this, what);
+        }
+    }
+
+    @Override
+    public int getOpacity() {
+        return PixelFormat.TRANSLUCENT;
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+
+    }
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/telegram/ui/Components/PullToRefresh/RingDrawable.java b/TMessagesProj/src/main/java/io/bettergram/telegram/ui/Components/PullToRefresh/RingDrawable.java
new file mode 100644
index 000000000..d29a7f23a
--- /dev/null
+++ b/TMessagesProj/src/main/java/io/bettergram/telegram/ui/Components/PullToRefresh/RingDrawable.java
@@ -0,0 +1,136 @@
+package io.bettergram.telegram.ui.Components.PullToRefresh;
+
+import android.content.Context;
+import android.graphics.*;
+import android.os.Handler;
+import android.util.TypedValue;
+
+/**
+ * Created by baoyz on 14/11/2.
+ */
+class RingDrawable extends RefreshDrawable {
+
+    private static final int MAX_LEVEL = 200;
+
+    private boolean isRunning;
+    private RectF mBounds;
+    private int mWidth;
+    private int mHeight;
+    private Paint mPaint;
+    private Path mPath;
+    private float mAngle;
+    private int[] mColorSchemeColors;
+    private Handler mHandler = new Handler();
+    private int mLevel;
+    private float mDegress;
+
+    RingDrawable(Context context, PullRefreshLayout layout) {
+        super(context, layout);
+        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mPaint.setStyle(Paint.Style.STROKE);
+        mPaint.setStrokeWidth(dp2px(3));
+        mPaint.setStrokeCap(Paint.Cap.ROUND);
+        mPath = new Path();
+    }
+
+    @Override
+    public void setPercent(float percent) {
+        mPaint.setColor(evaluate(percent, mColorSchemeColors[0], mColorSchemeColors[1]));
+        mAngle = 340 * percent;
+    }
+
+    @Override
+    public void setColorSchemeColors(int[] colorSchemeColors) {
+        mColorSchemeColors = colorSchemeColors;
+    }
+
+    @Override
+    public void offsetTopAndBottom(int offset) {
+        invalidateSelf();
+    }
+
+    @Override
+    public void start() {
+        mLevel = 50;
+        isRunning = true;
+        invalidateSelf();
+    }
+
+    private void updateLevel(int level) {
+        int animationLevel = level == MAX_LEVEL ? 0 : level;
+
+        int stateForLevel = (animationLevel / 50);
+
+        float percent = level % 50 / 50f;
+        int startColor = mColorSchemeColors[stateForLevel];
+        int endColor = mColorSchemeColors[(stateForLevel + 1) % mColorSchemeColors.length];
+        mPaint.setColor(evaluate(percent, startColor, endColor));
+
+        mDegress = 360 * percent;
+    }
+
+    @Override
+    public void stop() {
+        isRunning = false;
+        mDegress = 0;
+    }
+
+    @Override
+    public boolean isRunning() {
+        return isRunning;
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        mWidth = getRefreshLayout().getFinalOffset();
+        mHeight = mWidth;
+        mBounds = new RectF(bounds.width() / 2 - mWidth / 2, bounds.top, bounds.width() / 2 + mWidth / 2, bounds.top + mHeight);
+        mBounds.inset(dp2px(15), dp2px(15));
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        canvas.save();
+//        canvas.translate(0, mTop);
+        canvas.rotate(mDegress, mBounds.centerX(), mBounds.centerY());
+        drawRing(canvas);
+        canvas.restore();
+        if (isRunning) {
+            mLevel = mLevel >= MAX_LEVEL ? 0 : mLevel + 1;
+            updateLevel(mLevel);
+            invalidateSelf();
+        }
+    }
+
+    private void drawRing(Canvas canvas) {
+        mPath.reset();
+        mPath.arcTo(mBounds, 270, mAngle, true);
+        canvas.drawPath(mPath, mPaint);
+//        canvas.drawArc(mBounds, 270, mAngle, true, mPaint);
+    }
+
+    private int dp2px(int dp) {
+        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, getContext().getResources().getDisplayMetrics());
+    }
+
+    private int evaluate(float fraction, int startValue, int endValue) {
+        int startInt = startValue;
+        int startA = (startInt >> 24) & 0xff;
+        int startR = (startInt >> 16) & 0xff;
+        int startG = (startInt >> 8) & 0xff;
+        int startB = startInt & 0xff;
+
+        int endInt = endValue;
+        int endA = (endInt >> 24) & 0xff;
+        int endR = (endInt >> 16) & 0xff;
+        int endG = (endInt >> 8) & 0xff;
+        int endB = endInt & 0xff;
+
+        return ((startA + (int) (fraction * (endA - startA))) << 24) |
+                ((startR + (int) (fraction * (endR - startR))) << 16) |
+                ((startG + (int) (fraction * (endG - startG))) << 8) |
+                ((startB + (int) (fraction * (endB - startB))));
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/io/bettergram/telegram/ui/DialogsActivity.java b/TMessagesProj/src/main/java/io/bettergram/telegram/ui/DialogsActivity.java
index 094c391a6..43159adb2 100644
--- a/TMessagesProj/src/main/java/io/bettergram/telegram/ui/DialogsActivity.java
+++ b/TMessagesProj/src/main/java/io/bettergram/telegram/ui/DialogsActivity.java
@@ -27,10 +27,7 @@
 import android.support.v4.view.ViewCompat;
 import android.text.TextUtils;
 import android.util.TypedValue;
-import android.view.Gravity;
-import android.view.View;
-import android.view.ViewOutlineProvider;
-import android.view.ViewTreeObserver;
+import android.view.*;
 import android.view.animation.AccelerateDecelerateInterpolator;
 import android.view.animation.DecelerateInterpolator;
 import android.widget.*;
@@ -49,6 +46,7 @@
 import io.bettergram.telegram.ui.Cells.*;
 import io.bettergram.telegram.ui.Components.*;
 import io.bettergram.telegram.ui.Components.BottomBar.BottomNavigationBar;
+import io.bettergram.telegram.ui.Components.PullToRefresh.PullRefreshLayout;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -58,7 +56,7 @@
     private RecyclerListView listView;
     private LinearLayoutManager layoutManager;
     private BetterDialogsAdapter dialogsAdapter;
-    private NewsAdapter newsAdapter = new NewsAdapter();
+    private NewsAdapter newsAdapter;
     private CryptoAdapter cryptoAdapter = new CryptoAdapter();
     private YouTubePlayerAdapter videoAdapter;
     private ResourcesAdapter resourcesAdapter = new ResourcesAdapter();
@@ -600,7 +598,11 @@ public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State
 
         tabsContainer.addView(newTabsView, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, AndroidUtilities.isTablet() ? 44 : 42, Gravity.TOP));
 
-        tabsContainer.addView(listView, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 0, 1f));
+        PullRefreshLayout ptrLayout = new PullRefreshLayout(context);
+        ptrLayout.setEnabled(false); /* setting as disabled by default*/
+        ptrLayout.addView(listView, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+
+        tabsContainer.addView(ptrLayout, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 0, 1f));
 
         contentView.addView(tabsContainer, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.CENTER, 0, AndroidUtilities.isTablet() ? 16 : 14, 0, AndroidUtilities.isTablet() ? 40 : 42));// added bottom margin for the bottom navigation view
         listView.setOnItemClickListener((view, position) -> {
@@ -1357,7 +1359,10 @@ public void onMessageSend(CharSequence message) {
         getAvailableActivity(activity -> {
             if (activity != null) {
                 cryptoAdapter.startService(activity);
-                newsAdapter.startService(getParentActivity());
+                if (newsAdapter == null) {
+                    newsAdapter = new NewsAdapter(activity);
+                }
+                newsAdapter.startService(activity);
                 if (videoAdapter == null) {
                     videoAdapter = new YouTubePlayerAdapter(activity);
                 }
@@ -1371,12 +1376,17 @@ public void onMessageSend(CharSequence message) {
                     listView.postAndNotifyAdapter(() -> {
                         currentBottomTabPosition = position;
                         actionBar.setTitle(title);
+
                         boolean isChat = position == 0;
+
                         floatingButton.post(() -> hideFloatingButton(!isChat, true));
                         newTabsView.post(() -> newTabsView.hide(!isChat));
+                        ptrLayout.setRefreshing(false);
+                        ptrLayout.setEnabled(position == 2 || position == 3);
 
                         ActionBarMenuItem itemSearch = menu.getItem(0);
                         itemSearch.setVisibility(!isChat ? View.GONE : View.VISIBLE);
+
                         switch (position) {
                             case 0:
                                 if (!(listView.getAdapter() instanceof BetterDialogsAdapter)) {
@@ -1391,11 +1401,13 @@ public void onMessageSend(CharSequence message) {
                             case 2:
                                 if (!(listView.getAdapter() instanceof NewsAdapter)) {
                                     listView.setAdapter(newsAdapter);
+                                    ptrLayout.setOnRefreshListener(newsAdapter);
                                 }
                                 break;
                             case 3:
                                 if (!(listView.getAdapter() instanceof YouTubePlayerAdapter)) {
                                     listView.setAdapter(videoAdapter);
+                                    ptrLayout.setOnRefreshListener(videoAdapter);
                                 }
                                 break;
                             case 4:
