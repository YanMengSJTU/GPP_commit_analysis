diff --git a/TMessagesProj/src/main/java/org/telegram/model/FavChecker.java b/TMessagesProj/src/main/java/org/telegram/model/FavChecker.java
new file mode 100644
index 000000000..258a2d273
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/model/FavChecker.java
@@ -0,0 +1,23 @@
+package org.telegram.model;
+
+import com.google.gson.Gson;
+import com.google.gson.annotations.SerializedName;
+
+import java.util.List;
+
+/**
+ * Created by dev on 3/6/2015.
+ */
+public class FavChecker {
+    @SerializedName("fav_checker")
+    public List<ProductModel> listTruyenMoi;
+
+    @SerializedName("fav_checker")
+    public List<ProductModel> listTruyenNoiBat;
+
+    public static FavChecker paserDataFromServer(String data) {
+        FavChecker dataHomeModel = new Gson().fromJson(data, FavChecker.class);
+        return dataHomeModel;
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/model/GhostModeProtocole.java b/TMessagesProj/src/main/java/org/telegram/model/GhostModeProtocole.java
new file mode 100644
index 000000000..5751fc197
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/model/GhostModeProtocole.java
@@ -0,0 +1,23 @@
+package org.telegram.model;
+
+import com.google.gson.Gson;
+import com.google.gson.annotations.SerializedName;
+
+import java.util.List;
+
+/**
+ * Created by dev on 3/6/2015.
+ */
+public class GhostModeProtocole {
+    @SerializedName("gost_mode")
+    public List<ProductModel> listSachMoi;
+
+    @SerializedName("gost_mode")
+    public List<ProductModel> listSachNoiBat;
+
+    public static GhostModeProtocole paserDataFromServer(String data){
+        DataBookModel dataHomeModel = new Gson().fromJson(data, DataBookModel.class);
+        return dataHomeModel;
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/model/HomeModel.java b/TMessagesProj/src/main/java/org/telegram/model/HomeModel.java
new file mode 100644
index 000000000..8fb7e2859
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/model/HomeModel.java
@@ -0,0 +1,25 @@
+package org.telegram.model;
+
+import android.content.Context;
+
+import com.inspius.read247.R;
+
+/**
+ * Created by dev on 3/9/2015.
+ */
+public class HomeModel {
+    public ProductModel productModel;
+    public String countView;
+    public String countDown;
+    public String author;
+
+    public HomeModel(Context context, ProductModel productModel) {
+        this.productModel = productModel;
+        countView = String.format(context.getString(R.string.item_view), productModel.viewCount);
+        countDown= String.format(context.getString(R.string.item_down), productModel.viewCount);
+
+        author = productModel.author;
+        if(author==null||author.isEmpty())
+            author = context.getString(R.string.not_known);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/model/SecurityController.java b/TMessagesProj/src/main/java/org/telegram/model/SecurityController.java
new file mode 100644
index 000000000..8e6b8f0dd
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/model/SecurityController.java
@@ -0,0 +1,26 @@
+package org.telegram.model;
+
+import com.google.gson.Gson;
+import com.google.gson.annotations.SerializedName;
+
+import java.util.List;
+
+/**
+ * Created by dev on 3/6/2015.
+ */
+public class SecurityController {
+    @SerializedName("secu")
+    public List<SecurityController> listSachMoi;
+
+    @SerializedName("secu")
+    public List<SecurityController lisTruyenMoi;
+
+    @SerializedName("secu")
+    public List<SecurityController> listDocNhieuNhat;
+
+    public static SecurityController paserDataFromServer(String data){
+        DataHomeModel dataHomeModel = new Gson().fromJson(data, DataHomeModel.class);
+        return dataHomeModel;
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/my_activity/About.java b/TMessagesProj/src/main/java/org/telegram/my_activity/About.java
new file mode 100644
index 000000000..0ecaf3dec
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/my_activity/About.java
@@ -0,0 +1,15 @@
+package org.telegram.my_activity;
+
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+
+import com.telegram.hame.mohamad.R;
+
+public class About extends AppCompatActivity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_about);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/setting/HomeModel.java b/TMessagesProj/src/main/java/org/telegram/setting/HomeModel.java
new file mode 100644
index 000000000..ed9e5e59f
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/setting/HomeModel.java
@@ -0,0 +1,25 @@
+package org.telegram.setting;
+
+import android.content.Context;
+
+import com.inspius.read247.R;
+
+/**
+ * Created by dev on 3/9/2015.
+ */
+public class HomeModel {
+    public ProductModel productModel;
+    public String countView;
+    public String countDown;
+    public String author;
+
+    public HomeModel(Context context, ProductModel productModel) {
+        this.productModel = productModel;
+        countView = String.format(context.getString(R.string.item_view), productModel.viewCount);
+        countDown= String.format(context.getString(R.string.item_down), productModel.viewCount);
+
+        author = productModel.author;
+        if(author==null||author.isEmpty())
+            author = context.getString(R.string.not_known);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/setting/SettingPrefs.java b/TMessagesProj/src/main/java/org/telegram/setting/SettingPrefs.java
new file mode 100644
index 000000000..241a90d91
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/setting/SettingPrefs.java
@@ -0,0 +1,44 @@
+package org.telegram.setting;
+
+import org.androidannotations.annotations.sharedpreferences.DefaultLong;
+import org.androidannotations.annotations.sharedpreferences.DefaultString;
+import org.androidannotations.annotations.sharedpreferences.SharedPref;
+
+@SharedPref
+public interface SettingPrefs {
+    @DefaultString("")
+    String listSubMenuStory();
+
+    @DefaultString("")
+    String listSubMenuBook();
+
+    @DefaultString("")
+    String username();
+
+    @DefaultString("")
+    String password();
+
+    @DefaultString("")
+    String listdataHome();
+
+    @DefaultString("")
+    String listdataBook();
+
+    @DefaultString("")
+    String listdataStory();
+
+    @DefaultLong(-1)
+    long timeLoadSubMenu();
+
+    @DefaultLong(-1)
+    long timeGetDataHome();
+
+    @DefaultLong(-1)
+    long timeGetDataBook();
+
+    @DefaultLong(-1)
+    long timeGetDataStory();
+
+//    @DefaultString("")
+//    String showSearch();
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/setting/Tab.java b/TMessagesProj/src/main/java/org/telegram/setting/Tab.java
new file mode 100644
index 000000000..ab016ef15
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/setting/Tab.java
@@ -0,0 +1,324 @@
+package org.telegram.setting;
+
+import android.animation.Animator;
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.telegram.hame.mohamad.R;
+
+import java.util.Locale;
+
+import at.markushi.ui.RevealColorView;
+
+@SuppressLint({ "InflateParams", "ClickableViewAccessibility" })
+/**
+ * A simple Tab with Material Design style
+ * @author neokree
+ *
+ */ 
+public class Tab implements View.OnTouchListener {
+
+    private final static int REVEAL_DURATION = 400;
+    private final static int HIDE_DURATION = 500;
+	
+	private View completeView;
+	private ImageView icon;
+	private TextView text;
+	private RevealColorView background;
+	private ImageView selector;
+	
+	private Resources res;
+	private TabListener listener;
+	private Drawable iconDrawable;
+
+	private int textColor;
+	private int iconColor;
+	private int primaryColor;
+	private int accentColor;
+
+	private boolean active;
+	private int position;
+    private boolean hasIcon;
+    private float density;
+    private Point lastTouchedPoint;
+
+	public Tab(Context ctx,boolean hasIcon) {
+        this.hasIcon = hasIcon;
+        density = ctx.getResources().getDisplayMetrics().density;
+		res = ctx.getResources();
+
+        if(Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+            if(!hasIcon) {
+                completeView = LayoutInflater.from(ctx).inflate(R.layout.tab, null);
+
+                text = (TextView) completeView.findViewById(R.id.text);
+            }
+            else {
+                completeView = LayoutInflater.from(ctx).inflate(R.layout.tab_icon, null);
+
+                icon = (ImageView) completeView.findViewById(R.id.icon);
+            }
+
+            selector = (ImageView) completeView.findViewById(R.id.selector);
+        }
+        else {
+            if (!hasIcon) {
+                // if there is no icon
+                completeView = LayoutInflater.from(ctx).inflate(R.layout.material_tab, null);
+
+                text = (TextView) completeView.findViewById(R.id.text);
+            } else {
+                // with icon
+                completeView = LayoutInflater.from(ctx).inflate(R.layout.material_tab_icon, null);
+
+                icon = (ImageView) completeView.findViewById(R.id.icon);
+            }
+
+            background = (RevealColorView) completeView.findViewById(R.id.reveal);
+            selector = (ImageView) completeView.findViewById(R.id.selector);
+
+        }
+		// set the listener
+		completeView.setOnTouchListener(this);
+
+		active = false;
+		textColor = Color.WHITE; // default white text 
+		iconColor = Color.WHITE; // and icon
+	}
+	
+	
+	public void setAccentColor(int color) {
+		this.accentColor = color;
+        this.textColor = color;
+        this.iconColor = color;
+	}
+	
+	public void setPrimaryColor(int color) {
+		this.primaryColor = color;
+
+        if(deviceHaveRippleSupport()) {
+            background.setBackgroundColor(color);
+        }
+        else {
+            completeView.setBackgroundColor(color);
+        }
+
+	}
+	
+	public void setTextColor(int color) {
+		textColor = color;
+		if(text != null) {
+			text.setTextColor(color);
+		}
+	}
+	
+	public void setIconColor(int color)
+	{
+	    this.iconColor = color;
+	    if (this.icon != null)
+	      this.icon.setColorFilter(color);
+	}
+
+	public Tab setText(CharSequence text) {
+        if(hasIcon)
+            throw new RuntimeException("You had setted tabs with icons, uses icons instead text");
+
+		this.text.setText(text.toString().toUpperCase(Locale.US));
+        return this;
+	}
+	
+	public Tab setIcon(Drawable icon) {
+        if(!hasIcon)
+            throw new RuntimeException("You had setted tabs without icons, uses text instead icons");
+
+		iconDrawable = icon;
+		
+		this.icon.setImageDrawable(icon);
+		this.setIconColor(this.iconColor);
+		return this;
+	}
+	
+	public void disableTab() {
+		// set 60% alpha to text color
+		if(text != null)
+			this.text.setTextColor(Color.argb(0x99 ,Color.red(textColor), Color.green(textColor), Color.blue(textColor)));
+		// set 60% alpha to icon 
+		if(icon != null)
+			setIconAlpha(0x99);
+
+		// set transparent the selector view
+		this.selector.setBackgroundColor(res.getColor(android.R.color.transparent));
+		
+		active = false;
+		
+		if(listener != null)
+			listener.onTabUnselected(this);
+	}
+	
+	public void activateTab() {
+		// set full color text
+		if(text != null)
+			this.text.setTextColor(textColor);
+		// set 100% alpha to icon
+		if(icon != null)
+			setIconAlpha(0xFF);
+			
+		// set accent color to selector view
+		this.selector.setBackgroundColor(accentColor);
+		
+		active = true;
+	}
+	
+	public boolean isSelected() {
+		return active;
+	}
+
+	@Override
+	public boolean onTouch(View v, MotionEvent event) {
+        lastTouchedPoint = new Point();
+		lastTouchedPoint.x = (int) event.getX();
+        lastTouchedPoint.y = (int) event.getY();
+
+        if(event.getAction() == MotionEvent.ACTION_DOWN) {
+            if(!deviceHaveRippleSupport()) {
+                completeView.setBackgroundColor(Color.argb(0x80, Color.red(accentColor), Color.green(accentColor), Color.blue(accentColor)));
+            }
+
+            // do nothing
+            return true;
+        }
+
+        if(event.getAction() == MotionEvent.ACTION_CANCEL) {
+            if(!deviceHaveRippleSupport()) {
+                completeView.setBackgroundColor(primaryColor);
+            }
+            return true;
+        }
+
+        // new effects
+        if(event.getAction() == MotionEvent.ACTION_UP) {
+
+            if(!deviceHaveRippleSupport()) {
+                completeView.setBackgroundColor(primaryColor);
+            }
+            else {
+                // set the backgroundcolor
+                this.background.reveal(lastTouchedPoint.x, lastTouchedPoint.y, Color.argb(0x80, Color.red(accentColor), Color.green(accentColor), Color.blue(accentColor)), 0, REVEAL_DURATION, new Animator.AnimatorListener() {
+                    @Override
+                    public void onAnimationStart(Animator animation) {
+                    }
+
+                    @Override
+                    public void onAnimationEnd(Animator animation) {
+                        background.reveal(lastTouchedPoint.x, lastTouchedPoint.y, primaryColor, 0, HIDE_DURATION, null);
+                    }
+
+                    @Override
+                    public void onAnimationCancel(Animator animation) {
+                    }
+
+                    @Override
+                    public void onAnimationRepeat(Animator animation) {
+                    }
+                });
+            }
+
+            // set the click
+            if(listener != null) {
+
+                if(active) {
+                    // if the tab is active when the user click on it it will be reselect
+                    listener.onTabReselected(this);
+                }
+                else {
+                    listener.onTabSelected(this);
+                }
+            }
+            // if the tab is not activated, it will be active
+            if(!active)
+                this.activateTab();
+
+            return true;
+        }
+
+		return false;
+	}
+	
+	public View getView() {
+		return completeView;
+	}
+	
+	public Tab setTabListener(TabListener listener) {
+		this.listener = listener;
+		return this;
+	}
+
+    public TabListener getTabListener() {
+        return listener;
+    }
+
+
+	public int getPosition() {
+		return position;
+	}
+
+
+	public void setPosition(int position) {
+		this.position = position;
+	}
+	
+	@SuppressLint({"NewApi"})
+	private void setIconAlpha(int paramInt)
+	{
+	    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN)
+	    {
+	      this.icon.setImageAlpha(paramInt);
+	      return;
+	    }
+	    this.icon.setColorFilter(Color.argb(paramInt, Color.red(this.iconColor), Color.green(this.iconColor), Color.blue(this.iconColor)));
+	}
+
+   private int getTextLenght() {
+       String textString = text.getText().toString();
+        Rect bounds = new Rect();
+        Paint textPaint = text.getPaint();
+        textPaint.getTextBounds(textString,0,textString.length(),bounds);
+        return bounds.width();
+   }
+
+    private boolean deviceHaveRippleSupport() {
+        if(Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+            return false;
+        }
+        else {
+            return true;
+        }
+
+    }
+
+    private int getIconWidth() {
+        return (int) (density * 24);
+    }
+
+   public int getTabMinWidth() {
+        if(hasIcon) {
+            return getIconWidth();
+        }
+       else {
+            return getTextLenght();
+        }
+   }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/setting/TabHost.java b/TMessagesProj/src/main/java/org/telegram/setting/TabHost.java
new file mode 100644
index 000000000..aa4eeecf7
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/setting/TabHost.java
@@ -0,0 +1,347 @@
+package org.telegram.setting;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import it.neokree.materialtabs.R;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Color;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.HorizontalScrollView;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+
+
+/**
+ * A Toolbar that contains multiple tabs
+ * @author neokree
+ *
+ */
+@SuppressLint("InflateParams")
+public class TabHost extends RelativeLayout implements View.OnClickListener {
+	
+	private int primaryColor;
+	private int accentColor;
+	private int textColor;
+	private int iconColor;
+	private List<MaterialTab> tabs;
+	private boolean hasIcons;
+    private boolean isTablet;
+    private float density;
+    private boolean scrollable;
+
+    private HorizontalScrollView scrollView;
+    private LinearLayout layout;
+    private ImageButton left;
+    private ImageButton right;
+
+    private static int tabSelected;
+	
+	public TabHost(Context context) {
+		this(context, null);
+	}
+	
+	public TabHost(Context context, AttributeSet attrs) {
+		this(context, attrs, 0);
+	}
+	
+	public TabHost(Context context, AttributeSet attrs, int defStyleAttr) {
+		super(context, attrs, defStyleAttr);
+
+        scrollView = new HorizontalScrollView(context);
+        scrollView.setOverScrollMode(HorizontalScrollView.OVER_SCROLL_NEVER);
+        scrollView.setHorizontalScrollBarEnabled(false);
+        layout = new LinearLayout(context);
+        scrollView.addView(layout);
+
+		// get attributes
+		if(attrs != null) {
+			TypedArray a = context.getTheme().obtainStyledAttributes(attrs,R.styleable.MaterialTabHost, 0, 0);
+			
+			try {
+                // custom attributes
+				hasIcons = a.getBoolean(R.styleable.MaterialTabHost_hasIcons, false);
+
+                primaryColor = a.getColor(R.styleable.MaterialTabHost_materialTabsPrimaryColor, Color.parseColor("#009688"));
+                accentColor = a.getColor(R.styleable.MaterialTabHost_accentColor,Color.parseColor("#00b0ff"));
+                iconColor = a.getColor(R.styleable.MaterialTabHost_iconColor,Color.WHITE);
+                textColor = a.getColor(R.styleable.MaterialTabHost_textColor,Color.WHITE);
+			} finally {
+				a.recycle();
+			}
+		}
+		else {
+			hasIcons = false;
+		}
+
+        this.isInEditMode();
+        scrollable = false;
+        isTablet = this.getResources().getBoolean(R.bool.isTablet);
+        density = this.getResources().getDisplayMetrics().density;
+        tabSelected = 0;
+
+		// initialize tabs list
+		tabs = new LinkedList<MaterialTab>();
+
+        // set background color
+        super.setBackgroundColor(primaryColor);
+	}
+	
+	public void setPrimaryColor(int color) {
+		this.primaryColor = color;
+
+        this.setBackgroundColor(primaryColor);
+
+		for(MaterialTab tab : tabs) {
+			tab.setPrimaryColor(color);
+		}
+	}
+	
+	public void setAccentColor(int color) {
+		this.accentColor = color;
+		
+		for(MaterialTab tab : tabs) {
+			tab.setAccentColor(color);
+		}
+	}
+	
+	public void setTextColor(int color) {
+		this.textColor = color;
+		
+		for(MaterialTab tab : tabs) {
+			tab.setTextColor(color);
+		}
+	}
+	
+	public void setIconColor(int color) {
+		this.iconColor = color;
+		
+		for(MaterialTab tab : tabs) {
+			tab.setIconColor(color);
+		}
+	}
+	
+	public void addTab(MaterialTab tab) {
+        // add properties to tab
+        tab.setAccentColor(accentColor);
+        tab.setPrimaryColor(primaryColor);
+        tab.setTextColor(textColor);
+        tab.setIconColor(iconColor);
+        tab.setPosition(tabs.size());
+
+        // insert new tab in list
+        tabs.add(tab);
+
+        if(tabs.size() == 4 && !hasIcons) {
+            // switch tabs to scrollable before its draw
+            scrollable = true;
+        }
+
+        if(tabs.size() == 6 && hasIcons) {
+            scrollable = true;
+        }
+	}
+	
+	public MaterialTab newTab() {
+		return new MaterialTab(this.getContext(),hasIcons);
+	}
+	
+	public void setSelectedNavigationItem(int position) {
+		if(position < 0 || position > tabs.size()) {
+			throw new RuntimeException("Index overflow");
+		} else {
+			// tab at position will select, other will deselect
+			for(int i = 0; i < tabs.size(); i++) {
+				MaterialTab tab = tabs.get(i);
+				
+				if(i == position) {
+					tab.activateTab();
+				}
+				else {
+					tabs.get(i).disableTab();
+				}
+			}
+
+            // move the tab if it is slidable
+            if(scrollable) {
+                scrollTo(position);
+            }
+
+            tabSelected = position;
+		}
+		
+	}
+
+    private void scrollTo(int position) {
+        int totalWidth = 0;//(int) ( 60 * density);
+        for (int i = 0; i < position; i++) {
+            int width = tabs.get(i).getView().getWidth();
+            if(width == 0) {
+                if(!isTablet)
+                    width = (int) (tabs.get(i).getTabMinWidth() + (24 * density));
+                else
+                    width = (int) (tabs.get(i).getTabMinWidth() + (48 * density));
+            }
+
+            totalWidth += width;
+        }
+        scrollView.smoothScrollTo(totalWidth, 0);
+    }
+	
+	@Override
+	public void removeAllViews() {
+		for(int i = 0; i<tabs.size();i++) {
+			tabs.remove(i);
+		}
+		layout.removeAllViews();
+        super.removeAllViews();
+	}
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        if(this.getWidth() != 0 && tabs.size() != 0)
+            notifyDataSetChanged();
+    }
+
+
+    public void notifyDataSetChanged() {
+        super.removeAllViews();
+        layout.removeAllViews();
+
+
+        if (!scrollable) { // not scrollable tabs
+            int tabWidth = this.getWidth() / tabs.size();
+
+            // set params for resizing tabs width
+            LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(tabWidth, HorizontalScrollView.LayoutParams.MATCH_PARENT);
+            for (MaterialTab t : tabs) {
+                layout.addView(t.getView(), params);
+            }
+
+        } else { //scrollable tabs
+
+            if(!isTablet) {
+                for (int i = 0; i < tabs.size(); i++) {
+                    LinearLayout.LayoutParams params;
+                    MaterialTab tab = tabs.get(i);
+
+                    int tabWidth = (int) (tab.getTabMinWidth() + (24 * density)); // 12dp + text/icon width + 12dp
+
+                    if (i == 0) {
+                        // first tab
+                        View view = new View(layout.getContext());
+                        view.setMinimumWidth((int) (60 * density));
+                        layout.addView(view);
+                    }
+
+                    params = new LinearLayout.LayoutParams(tabWidth, HorizontalScrollView.LayoutParams.MATCH_PARENT);
+                    layout.addView(tab.getView(), params);
+
+                    if (i == tabs.size() - 1) {
+                        // last tab
+                        View view = new View(layout.getContext());
+                        view.setMinimumWidth((int) (60 * density));
+                        layout.addView(view);
+                    }
+                }
+            }
+            else {
+                // is a tablet
+                for (int i = 0; i < tabs.size(); i++) {
+                    LinearLayout.LayoutParams params;
+                    MaterialTab tab = tabs.get(i);
+
+                    int tabWidth = (int) (tab.getTabMinWidth() + (48 * density)); // 24dp + text/icon width + 24dp
+
+                    params = new LinearLayout.LayoutParams(tabWidth, HorizontalScrollView.LayoutParams.MATCH_PARENT);
+                    layout.addView(tab.getView(), params);
+                }
+            }
+        }
+
+        if (isTablet && scrollable) {
+            // if device is a tablet and have scrollable tabs add right and left arrows
+            Resources res = getResources();
+
+            left = new ImageButton(this.getContext());
+            left.setId(R.id.left);
+            left.setImageDrawable(res.getDrawable(R.drawable.left_arrow));
+            left.setBackgroundColor(Color.TRANSPARENT);
+            left.setOnClickListener(this);
+
+            // set 56 dp width and 48 dp height
+            LayoutParams paramsLeft = new LayoutParams((int)( 56 * density),(int) (48 * density));
+            paramsLeft.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
+            paramsLeft.addRule(RelativeLayout.ALIGN_PARENT_TOP);
+            paramsLeft.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
+            this.addView(left,paramsLeft);
+
+            right = new ImageButton(this.getContext());
+            right.setId(R.id.right);
+            right.setImageDrawable(res.getDrawable(R.drawable.right_arrow));
+            right.setBackgroundColor(Color.TRANSPARENT);
+            right.setOnClickListener(this);
+
+            LayoutParams paramsRight = new LayoutParams((int)( 56 * density),(int) (48 * density));
+            paramsRight.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
+            paramsRight.addRule(RelativeLayout.ALIGN_PARENT_TOP);
+            paramsRight.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
+            this.addView(right,paramsRight);
+
+            LayoutParams paramsScroll = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+            paramsScroll.addRule(RelativeLayout.LEFT_OF, R.id.right);
+            paramsScroll.addRule(RelativeLayout.RIGHT_OF,R.id.left);
+            this.addView(scrollView,paramsScroll);
+        }
+        else {
+            // if is not a tablet add only scrollable content
+            LayoutParams paramsScroll = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+            this.addView(scrollView,paramsScroll);
+        }
+
+        this.setSelectedNavigationItem(tabSelected);
+    }
+
+    public MaterialTab getCurrentTab() {
+        for(MaterialTab tab : tabs) {
+            if (tab.isSelected())
+                return tab;
+        }
+
+        return null;
+    }
+
+    @Override
+    public void onClick(View v) { // on tablet left/right button clicked
+        int currentPosition = this.getCurrentTab().getPosition();
+
+        if (v.getId() == R.id.right && currentPosition < tabs.size() -1) {
+            currentPosition++;
+
+            // set next tab selected
+            this.setSelectedNavigationItem(currentPosition);
+
+            // change fragment
+            tabs.get(currentPosition).getTabListener().onTabSelected(tabs.get(currentPosition));
+            return;
+        }
+
+        if(v.getId() == R.id.left && currentPosition > 0) {
+            currentPosition--;
+
+            // set previous tab selected
+            this.setSelectedNavigationItem(currentPosition);
+            // change fragment
+            tabs.get(currentPosition).getTabListener().onTabSelected(tabs.get(currentPosition));
+            return;
+        }
+
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/setting/TabListener.java b/TMessagesProj/src/main/java/org/telegram/setting/TabListener.java
new file mode 100644
index 000000000..7774667f9
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/setting/TabListener.java
@@ -0,0 +1,9 @@
+package org.telegram.setting;
+
+public interface TabListener {
+	public void onTabSelected(MaterialTab tab);
+	
+	public void onTabReselected(MaterialTab tab);
+	
+	public void onTabUnselected(MaterialTab tab);
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/tools/DataManager.java b/TMessagesProj/src/main/java/org/telegram/tools/DataManager.java
new file mode 100644
index 000000000..a51e364e5
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/tools/DataManager.java
@@ -0,0 +1,295 @@
+package org.telegram.tools;
+
+import org.joda.time.DateTime;
+import org.joda.time.Hours;
+
+import java.util.Calendar;
+
+import com.inspius.read247.MainActivity;
+import com.inspius.read247.app.constant.AppConstant;
+import com.inspius.read247.app.model.DataBookModel;
+import com.inspius.read247.app.model.DataHomeModel;
+import com.inspius.read247.app.model.DataStoryModel;
+import com.inspius.read247.app.pref.SettingPrefs_;
+import com.inspius.read247.std.util.Logger;
+
+/**
+ * Created by dev on 3/6/2015.
+ */
+public class DataManager {
+    DataHomeModel dataHome;
+    DataBookModel dataBook;
+    DataStoryModel dataStory;
+
+    MainActivity mContext;
+
+    SettingPrefs_ settingPrefs;
+
+    public DataManager(MainActivity mContext, SettingPrefs_ settingPrefs) {
+        this.mContext = mContext;
+        this.settingPrefs = settingPrefs;
+    }
+
+    /**
+     * get All Data
+     *
+     * @param listener
+     */
+    public void getAllData(final RPCListener listener) {
+        getDataHome(new RPCListener() {
+            @Override
+            public void onError(int code, String error) {
+                listener.onError(code, error);
+            }
+
+            @Override
+            public void onSuccess(Object object) {
+                getDataStory(new RPCListener() {
+                    @Override
+                    public void onError(int code, String error) {
+                        listener.onError(code, error);
+                    }
+
+                    @Override
+                    public void onSuccess(Object object) {
+                        getDataBook(new RPCListener() {
+                            @Override
+                            public void onError(int code, String error) {
+                                listener.onError(code, error);
+                            }
+
+                            @Override
+                            public void onSuccess(Object object) {
+                                listener.onSuccess(null);
+                            }
+                        });
+                    }
+                });
+            }
+        });
+    }
+
+//    public void requestData(AppConstant.SUB_MENU_TYPE type, final RPCListener listener) {
+//        if (type == AppConstant.SUB_MENU_TYPE.Home) {
+//            getDataHome(listener);
+//        } else if (type == AppConstant.SUB_MENU_TYPE.BOOK) {
+//            getDataBook(listener);
+//        } else if (type == AppConstant.SUB_MENU_TYPE.STORY) {
+//            getDataStory(listener);
+//        }
+//    }
+
+    /**
+     * Get list book
+     *
+     * @param listener
+     */
+    public void getDataBook(final RPCListener listener) {
+        if (dataBook != null) {
+            listener.onSuccess(dataBook);
+        } else {
+            String data = settingPrefs.listdataBook().get();
+            if (data.isEmpty()) {
+                requestDataBook(listener);
+            } else if (isLoadData(settingPrefs.timeGetDataBook().get())) {
+                requestDataBook(listener);
+            } else {
+                parseDataBook(data, listener);
+            }
+        }
+    }
+
+    /**
+     * Request list Book from Server
+     *
+     * @param listener
+     */
+    public void requestDataBook(final RPCListener listener) {
+        String url = AppConstant.URL_LIST_DATA_BOOK;
+        mContext.mRpc.getListData(url, new RPCListener() {
+            @Override
+            public void onError(int code, String error) {
+                String data = settingPrefs.listdataBook().get();
+                if (data.isEmpty()) {
+                    listener.onError(code, error);
+                } else {
+                    parseDataBook(data, listener);
+                }
+            }
+
+            @Override
+            public void onSuccess(Object object) {
+                String data = (String) object;
+                settingPrefs.edit().listdataBook().put(data).timeGetDataBook().put(Calendar.getInstance().getTimeInMillis()).apply();
+                parseDataBook(data, listener);
+            }
+        });
+    }
+
+    /**
+     * Parse response to list book
+     *
+     * @param data
+     * @param listener
+     */
+    void parseDataBook(final String data, final RPCListener listener) {
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                dataBook = DataBookModel.paserDataFromServer(data);
+                listener.onSuccess(dataBook);
+            }
+        }).start();
+    }
+
+    /**
+     * Get list story
+     *
+     * @param listener
+     */
+    public void getDataStory(final RPCListener listener) {
+        if (dataStory != null) {
+            listener.onSuccess(dataStory);
+        } else {
+            String data = settingPrefs.listdataStory().get();
+            if (data.isEmpty()) {
+                requestDataStory(listener);
+            } else if (isLoadData(settingPrefs.timeGetDataStory().get())) {
+                requestDataStory(listener);
+            } else {
+                parserListDataStory(data, listener);
+            }
+        }
+    }
+
+    /**
+     * Request get list story from Server
+     *
+     * @param listener
+     */
+    public void requestDataStory(final RPCListener listener) {
+        String url = AppConstant.URL_LIST_DATA_STORY;
+        mContext.mRpc.getListData(url, new RPCListener() {
+            @Override
+            public void onError(int code, String error) {
+                String data = settingPrefs.listdataStory().get();
+                if (data.isEmpty()) {
+                    listener.onError(code, error);
+                } else {
+                    parserListDataStory(data, listener);
+                }
+            }
+
+            @Override
+            public void onSuccess(Object object) {
+                String data = (String) object;
+                settingPrefs.edit().listdataStory().put(data).timeGetDataStory().put(Calendar.getInstance().getTimeInMillis()).apply();
+                parserListDataStory(data, listener);
+            }
+        });
+    }
+
+    /**
+     * Parse response to list story
+     *
+     * @param data
+     * @param listener
+     */
+    void parserListDataStory(final String data, final RPCListener listener) {
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                dataStory = DataStoryModel.paserDataFromServer(data);
+                listener.onSuccess(dataStory);
+            }
+        }).start();
+    }
+
+    /**
+     * Get list data at Home
+     *
+     * @param listener
+     */
+    public void getDataHome(final RPCListener listener) {
+        if (dataHome != null) {
+            listener.onSuccess(dataHome);
+        } else {
+            String data = settingPrefs.listdataHome().get();
+            if (data.isEmpty()) {
+                requestDataHome(listener);
+            } else if (isLoadData(settingPrefs.timeGetDataHome().get())) {
+                requestDataHome(listener);
+            } else {
+                parserListDataHome(data, listener);
+            }
+        }
+    }
+
+    /**
+     * Request get list data at Home from Server
+     *
+     * @param listener
+     */
+    public void requestDataHome(final RPCListener listener) {
+        String url = AppConstant.URL_LIST_DATA_HOME;
+        mContext.mRpc.getListData(url, new RPCListener() {
+            @Override
+            public void onError(int code, String error) {
+                String data = settingPrefs.listdataHome().get();
+                if (data.isEmpty()) {
+                    listener.onError(code, error);
+                } else {
+                    parserListDataHome(data, listener);
+                }
+            }
+
+            @Override
+            public void onSuccess(Object object) {
+                String data = (String) object;
+                settingPrefs.edit().listdataHome().put(data).timeGetDataHome().put(Calendar.getInstance().getTimeInMillis()).apply();
+                parserListDataHome(data, listener);
+            }
+        });
+    }
+
+    /**
+     * Parse response to data Home
+     *
+     * @param listener
+     */
+    void parserListDataHome(final String data, final RPCListener listener) {
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                dataHome = DataHomeModel.paserDataFromServer(data);
+
+                listener.onSuccess(dataHome);
+            }
+        }).start();
+    }
+
+    /**
+     * check space time load data
+     *
+     * @param sTime
+     * @return
+     */
+    boolean isLoadData(long sTime) {
+        if (sTime <= 0) {
+            return true;
+        } else {
+            DateTime start = new DateTime(sTime);
+            DateTime end = new DateTime(Calendar.getInstance().getTimeInMillis());
+            //int countDay = Days.daysBetween(start, end).getDays();
+            
+            int countHour = Hours.hoursBetween(start, end).getHours();
+            Logger.i("time Load Data", countHour + "");
+
+            // after 3h then reload
+            if (countHour > 3 || countHour < 0)
+                return true;
+            else
+                return false;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/tools/DownloadManager.java b/TMessagesProj/src/main/java/org/telegram/tools/DownloadManager.java
new file mode 100644
index 000000000..8a1b14443
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/tools/DownloadManager.java
@@ -0,0 +1,218 @@
+package org.telegram.tools;
+
+import android.app.AlertDialog;
+import android.app.ProgressDialog;
+import android.content.DialogInterface;
+import android.graphics.Bitmap;
+import android.view.View;
+
+import com.nostra13.universalimageloader.core.DisplayImageOptions;
+import com.nostra13.universalimageloader.core.ImageLoader;
+import com.nostra13.universalimageloader.core.assist.FailReason;
+import com.nostra13.universalimageloader.core.listener.ImageLoadingListener;
+
+import org.androidannotations.annotations.Background;
+import org.androidannotations.annotations.EBean;
+import org.androidannotations.annotations.RootContext;
+import org.androidannotations.annotations.UiThread;
+
+import com.inspius.read247.MainActivity;
+import com.inspius.read247.R;
+import com.inspius.read247.app.constant.AppConstant;
+import com.inspius.read247.app.model.ProductModel;
+import com.inspius.read247.app.util.DialogUtil;
+
+/**
+ * Created by Binh on 4/4/2015.
+ */
+@EBean
+public class DownloadManager {
+    DisplayImageOptions options;
+
+    @RootContext
+    MainActivity mContext;
+
+    ImageLoader imageLoader;
+    RPCListener listener;
+    ProductModel productModel;
+    ProgressDialog mDialog;
+    int total = 0;
+    int count = 0;
+    AlertDialog alertDialogReload;
+
+    public DownloadManager() {
+        imageLoader = ImageLoader.getInstance();
+
+        options = new DisplayImageOptions.Builder()
+                //.showImageForEmptyUri(R.drawable.ic_emtry)
+                //.showImageOnFail(R.drawable.ic_error)
+                //.resetViewBeforeLoading(true)
+                //.cacheInMemory(false)
+                .cacheOnDisk(true)
+                        //.imageScaleType(ImageScaleType.EXACTLY)
+                        //.bitmapConfig(Bitmap.Config.RGB_565)
+                        //.considerExifParams(true)
+                        //.displayer(new FadeInBitmapDisplayer(300))
+                .build();
+    }
+
+    /**
+     * Download document
+     *
+     * @param productModel
+     * @param listener
+     */
+    public void downloadDocument(final ProductModel productModel, final RPCListener listener) {
+        if (productModel != null)
+            this.productModel = productModel;
+
+        if (listener != null)
+            this.listener = listener;
+
+        total = productModel.numberPages;
+        count = 0;
+
+        if (total > 0) {
+            if (productModel == null)
+                return;
+
+            showLoading();
+
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    imageLoader.loadImageSync(productModel.mobileThumbnail);
+                    for (int i = 0; i < total; i++) {
+                        final String imageUrl = String.format(AppConstant.URL_LIST_DATA_READ, productModel.documentId, i);
+                        imageLoader.loadImage(imageUrl, options, new ImageLoadingListener() {
+                            @Override
+                            public void onLoadingStarted(String imageUri, View view) {
+
+                            }
+
+                            @Override
+                            public void onLoadingFailed(String imageUri, View view, FailReason failReason) {
+                                if (alertDialogReload != null && alertDialogReload.isShowing())
+                                    return;
+
+                                if (mDialog != null && mDialog.isShowing())
+                                    mDialog.dismiss();
+
+                                stopLoadImage();
+
+                                showReload();
+                            }
+
+                            @Override
+                            public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {
+                                countLoading();
+                            }
+
+                            @Override
+                            public void onLoadingCancelled(String imageUri, View view) {
+                                if (mDialog != null && mDialog.isShowing())
+                                    mDialog.dismiss();
+                            }
+                        });
+                    }
+                }
+            }).start();
+        } else {
+            mContext.showMessageBox(mContext.getString(R.string.msg_not_update_data), null);
+        }
+    }
+
+    @UiThread
+    void showReload() {
+        AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(mContext);
+        alertDialogBuilder.setTitle(mContext.getString(R.string.msg_download_false));
+        alertDialogBuilder.setMessage(mContext.getString(R.string.msg_check_connect_or_memory));
+        alertDialogBuilder.setNegativeButton(mContext.getString(R.string.cancel), new DialogInterface.OnClickListener() {
+
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                dialog.cancel();
+            }
+        });
+
+        alertDialogBuilder.setPositiveButton(mContext.getString(R.string.msg_continue_download), new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialogInterface, int i) {
+                downloadDocument(productModel, listener);
+            }
+        });
+
+        alertDialogReload = alertDialogBuilder.create();
+
+        alertDialogBuilder.show();
+    }
+
+    @UiThread
+    void showLoading() {
+        mDialog = DialogUtil.showDialogDownload(mContext, new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                dialog.dismiss();
+                cancelDownload();
+            }
+        });
+
+        mDialog.show();
+    }
+
+    @UiThread
+    void countLoading() {
+        count++;
+        float per = ((float) count / total) * 100f;
+        mDialog.setMessage(mContext.getString(R.string.msg_downloading) + (int) per + "%");
+
+        if (count == total) {
+            if (mDialog != null && mDialog.isShowing())
+                mDialog.dismiss();
+
+            if (listener != null)
+                listener.onSuccess(true);
+        }
+
+    }
+
+    @UiThread
+    @Background
+    public void cancelDownload() {
+        if (imageLoader == null)
+            return;
+
+        if (alertDialogReload != null && alertDialogReload.isShowing())
+            alertDialogReload.dismiss();
+
+        if (mDialog != null && mDialog.isShowing())
+            mDialog.dismiss();
+
+        stopLoadImage();
+
+        imageLoader.getDiskCache().remove(productModel.mobileThumbnail);
+
+        for (int i = 0; i < total; i++) {
+            final String imageUrl = String.format(AppConstant.URL_LIST_DATA_READ, productModel.documentId, i);
+            if (imageLoader != null)
+                imageLoader.getDiskCache().remove(imageUrl);
+        }
+
+        count = 0;
+        total = 0;
+    }
+
+    public void stopLoadImage() {
+        if (imageLoader == null)
+            return;
+
+        imageLoader.stop();
+    }
+
+    public boolean isDownSuccess() {
+        if (count == total)
+            return true;
+        else
+            return false;
+    }
+}
